<!DOCTYPE html><html><head><title>Help for package binGroup2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {binGroup2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binGroup2'><p>binGroup2: Identification and Estimation using Group Testing</p></a></li>
<li><a href='#Accuracy'><p>Extract the accuracy measures from group testing results</p></a></li>
<li><a href='#coef.gtReg'><p>Extract coefficients from a fitted group testing model</p></a></li>
<li><a href='#CompareConfig'><p>Compare group testing results</p></a></li>
<li><a href='#Config'><p>Access the testing configurations returned from an object</p></a></li>
<li><a href='#Config.opChar'><p>Extract the testing configuration from group testing results</p></a></li>
<li><a href='#Config.OTC'><p>Extract the testing configuration from group testing results</p></a></li>
<li><a href='#designEst'><p>Optimal group size determination based on minimal MSE</p>
when estimating an overall prevalence</a></li>
<li><a href='#designPower'><p>Number of groups or group size needed to achieve a power level in</p>
one parameter group testing</a></li>
<li><a href='#expectOrderBeta'><p>Determine a vector of probabilities for informative group</p>
testing algorithms</a></li>
<li><a href='#ExpTests'><p>Access the expected number of tests from an object</p></a></li>
<li><a href='#ExpTests.halving'><p>Extract the expected number of tests from testing configuration results</p></a></li>
<li><a href='#ExpTests.opChar'><p>Extract the expected number of tests from testing configuration results</p></a></li>
<li><a href='#ExpTests.OTC'><p>Extract the expected number of tests from optimal testing</p>
configuration results</a></li>
<li><a href='#ExpTests.Sterrett'><p>Extract the expected number of tests from testing configuration results</p></a></li>
<li><a href='#ExpTests.TOD'><p>Extract the expected number of tests from testing configuration results</p></a></li>
<li><a href='#formula.gtReg'><p>Extract the model formula from a fitted group testing model</p></a></li>
<li><a href='#GroupMembershipMatrix'><p>Construct a group membership matrix for hierarchical algorithms</p></a></li>
<li><a href='#gtPower'><p>Power to reject a hypothesis for one proportion in group testing</p></a></li>
<li><a href='#gtReg'><p>Fitting group testing regression models</p></a></li>
<li><a href='#gtRegControl'><p>Auxiliary for controlling group testing regression</p></a></li>
<li><a href='#gtSim'><p>Simulation function for group testing data</p></a></li>
<li><a href='#gtTest'><p>Hypothesis test for one proportion in group testing</p></a></li>
<li><a href='#gtWidth'><p>Expected width of confidence intervals in group testing</p></a></li>
<li><a href='#halving'><p>Probability mass function for halving</p></a></li>
<li><a href='#hivsurv'><p>Data from an HIV surveillance project</p></a></li>
<li><a href='#IndProb'><p>Extract the individual probabilities used to calculate group testing</p>
results</a></li>
<li><a href='#informativeArrayProb'><p>Arrange a matrix of probabilities for informative array testing</p></a></li>
<li><a href='#operatingCharacteristics1'><p>Calculate operating characteristics for group testing algorithms</p>
that use a single-disease assay</a></li>
<li><a href='#operatingCharacteristics2'><p>Calculate operating characteristics for group testing algorithms</p>
that use a multiplex assay for two diseases</a></li>
<li><a href='#OTC1'><p>Find the optimal testing configuration for group testing algorithms</p>
that use a single-disease assay</a></li>
<li><a href='#OTC2'><p>Find the optimal testing configuration for group testing algorithms</p>
that use a multiplex assay for two diseases</a></li>
<li><a href='#plot.OTC'><p>Plot method for optimal testing configuration results</p></a></li>
<li><a href='#pmf'><p>Access the testing probability mass function returned from an object</p></a></li>
<li><a href='#pmf.halving'><p>Extract probability mass function (PMF) from group testing results</p></a></li>
<li><a href='#pmf.Sterrett'><p>Extract probability mass function (PMF) from group testing results</p></a></li>
<li><a href='#predict.gtReg'><p>Predict method for <kbd>gtReg</kbd></p></a></li>
<li><a href='#print.designEst'><p>Print method for objects of class &quot;designEst&quot;</p></a></li>
<li><a href='#print.designPower'><p>Print method for objects of class &quot;designPower&quot;</p></a></li>
<li><a href='#print.gtReg'><p>Print method for <kbd>gtReg</kbd></p></a></li>
<li><a href='#print.gtTest'><p>Print method for objects of class &quot;gtTest&quot;</p></a></li>
<li><a href='#print.halving'><p>Print method for objects of class &quot;halving&quot;</p></a></li>
<li><a href='#print.opChar'><p>Print method for operating characteristics results</p></a></li>
<li><a href='#print.OTC'><p>Print method for optimal testing configuration results</p></a></li>
<li><a href='#print.predict.gtReg'><p>Print method for <kbd>predict.gtReg</kbd></p></a></li>
<li><a href='#print.propCI'><p>Print method for objects of class &quot;propCI&quot;</p></a></li>
<li><a href='#print.propDiffCI'><p>Print method for objects of class &quot;propDiffCI&quot;</p></a></li>
<li><a href='#print.Sterrett'><p>Print method for objects of class &quot;Sterrett&quot;</p></a></li>
<li><a href='#print.summary.gtReg'><p>Print method for <kbd>summary.gtReg</kbd></p></a></li>
<li><a href='#print.TOD'><p>Print method for <kbd>TOD</kbd></p></a></li>
<li><a href='#propCI'><p>Confidence intervals for one proportion in group testing</p></a></li>
<li><a href='#propDiffCI'><p>Confidence intervals for the difference of proportions</p>
in group testing</a></li>
<li><a href='#residuals.gtReg'><p>Extract model residuals from a fitted group testing model</p></a></li>
<li><a href='#Sterrett'><p>Summary measures for Sterrett algorithms</p></a></li>
<li><a href='#summary.gtReg'><p>Summary method for <kbd>gtReg</kbd></p></a></li>
<li><a href='#summary.opChar'><p>Summary method for operating characteristics results</p></a></li>
<li><a href='#summary.OTC'><p>Summary method for optimal testing configuration results</p></a></li>
<li><a href='#TOD'><p>Summary measures for the Thresholded Optimal Dorfman (TOD) algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Identification and Estimation using Group Testing</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brianna Hitt &lt;brianna.hitt@afacademy.af.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for the group testing identification problem: 1) Operating 
    characteristics (e.g., expected number of tests) for commonly used 
    hierarchical and array-based algorithms, and 2) Optimal testing 
    configurations for these same algorithms. Methods for the group testing 
    estimation problem: 1) Estimation and inference procedures for an overall 
    prevalence, and 2) Regression modeling for commonly used hierarchical and 
    array-based algorithms. </td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, graphics, grDevices, partitions, rBeta2009, Rcpp (&ge;
1.0.0), Rdpack, scales, stats, utils</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Author:</td>
<td>Brianna Hitt <a href="https://orcid.org/0000-0002-0645-0067"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Christopher Bilder
    <a href="https://orcid.org/0000-0002-2848-8576"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Frank Schaarschmidt
    <a href="https://orcid.org/0000-0002-6599-3803"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Brad Biggerstaff <a href="https://orcid.org/0000-0002-3105-3530"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Christopher McMahan
    <a href="https://orcid.org/0000-0001-5056-9615"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Joshua Tebbs <a href="https://orcid.org/0000-0002-6762-7241"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Boan Zhang [ctb],
  Michael Black [ctb],
  Peijie Hou [ctb],
  Peng Chen [ctb],
  Minh Nguyen [ctb]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-13 23:51:30 UTC; Brianna.Hitt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-14 01:43:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='binGroup2'>binGroup2: Identification and Estimation using Group Testing</h2><span id='topic+binGroup2'></span><span id='topic+binGroup2-package'></span>

<h3>Description</h3>

<p>Methods for the group testing identification and
estimation problems.
</p>


<h3>Details</h3>

<p>Methods for identification of positive items in group testing designs:
Operating characteristics (e.g., expected number of tests) are calculated
for commonly used hierarchical and array-based algorithms. Optimal testing
configurations for an algorithm can be found as well. Please see Hitt et al.
(2019) for specific details.
</p>
<p>Methods for estimation and inference for proportions in group testing
designs: For estimating one proportion or the difference of proportions,
confidence interval methods are included that account for different pool
sizes. Functions for hypothesis testing of proportions, calculation of
power, and calculation of the expected width of confidence intervals are
also included. Furthermore, regression methods and simulation of group
testing data are implemented for simple pooling (Dorfman testing with
or without retests), halving, and array testing designs.
</p>
<p>The <code>binGroup2</code> package is based upon the <code>binGroup</code> package that
was originally designed for the group testing estimation problem. Over time,
additional functions for estimation and for the group testing identification
problem were included. Due to the diverse styles resulting from these
additions, we have created <code>binGroup2</code> as a way to unify functions in
a coherent structure and incorporate additional functions for
identification. The <code>binGroup2</code> package provides all the main
functionality from the <code>binGroup</code> package, and can be used in place of
the <code>binGroup</code> package. The name “binGroup” originates from the
assumption in basic estimation for group testing that the
number of positive groups has a binomial distribution. While more advanced
estimation methods no longer make this assumption, we continue with the
<code>binGroup</code> name for consistency.
</p>
<p>Bilder (2019a,b) provide introductions to group testing. These papers and
additional details about group testing are available at
<a href="http://chrisbilder.com/grouptesting/">http://chrisbilder.com/grouptesting/</a>.
</p>
<p>This research was supported by the National Institutes of Health under
grant R01 AI121351.
</p>


<h4>Identification</h4>

<p>The binGroup2 package focuses on the group testing identification problem
using hierarchical and array-based group testing algorithms.
</p>
<p>The <code><a href="#topic+OTC1">OTC1</a></code> function implements a number of group testing
algorithms, described in Hitt et al. (2019), which calculate the operating
characteristics and find the optimal testing configuration over a range of
possible initial group sizes and/or testing configurations (sets of
subsequent group sizes). The <code><a href="#topic+OTC2">OTC2</a></code> function does the same with
a multiplex assay that tests for two diseases.
</p>
<p>The <code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code> (<code><a href="#topic+opChar1">opChar1</a></code>) and
<code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code> (<code><a href="#topic+opChar2">opChar2</a></code>) functions
calculate operating characteristics for a specified testing configuration
with assays that test for one and two diseases, respectively.
</p>
<p>These functions allow the sensitivity and specificity to differ across
stages of testing. This means that the accuracy of the diagnostic test can
differ for stages in a hierarchical testing algorithm or between
row/column testing and individual testing in an array testing algorithm.</p>



<h4>Estimation</h4>

<p>The binGroup2 package also provides functions for estimation and
inference for proportions in group testing designs.
</p>
<p>The <code><a href="#topic+propCI">propCI</a></code> function calculates the point estimate and
confidence intervals for a single proportion from group testing data.
The <code><a href="#topic+propDiffCI">propDiffCI</a></code> function does the same for the difference of
proportions. A number of confidence interval methods are available for
groups of equal or different sizes.
</p>
<p>The <code><a href="#topic+gtWidth">gtWidth</a></code> function calculates the expected width of
confidence intervals in group testing. The <code><a href="#topic+gtTest">gtTest</a></code> function
calculates p-values for hypothesis tests of single proportions. The
<code><a href="#topic+gtPower">gtPower</a></code> function calculates power to reject a hypothesis.
</p>
<p>The <code><a href="#topic+designPower">designPower</a></code> function iterates either the number of groups
or group size in a one-parameter group testing design until a pre-specified
power level is achieved. The <code><a href="#topic+designEst">designEst</a></code> function finds the
optimal group size corresponding to the minimal mean-squared error of the
point estimator.
</p>
<p>The <code><a href="#topic+gtReg">gtReg</a></code> function implements regression methods and the
<code><a href="#topic+gtSim">gtSim</a></code> function simulates group testing data for simple
pooling, halving, and array testing designs.</p>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Brianna Hitt <a href="mailto:brianna.hitt@afacademy.af.edu">brianna.hitt@afacademy.af.edu</a> (<a href="https://orcid.org/0000-0002-0645-0067">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Christopher Bilder (<a href="https://orcid.org/0000-0002-2848-8576">ORCID</a>)
</p>
</li>
<li><p> Frank Schaarschmidt (<a href="https://orcid.org/0000-0002-6599-3803">ORCID</a>)
</p>
</li>
<li><p> Brad Biggerstaff (<a href="https://orcid.org/0000-0002-3105-3530">ORCID</a>)
</p>
</li>
<li><p> Christopher McMahan (<a href="https://orcid.org/0000-0001-5056-9615">ORCID</a>)
</p>
</li>
<li><p> Joshua Tebbs (<a href="https://orcid.org/0000-0002-6762-7241">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Boan Zhang [contributor]
</p>
</li>
<li><p> Michael Black [contributor]
</p>
</li>
<li><p> Peijie Hou [contributor]
</p>
</li>
<li><p> Peng Chen [contributor]
</p>
</li>
<li><p> Minh Nguyen [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: Sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: Predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Biggerstaff, B. (2008).
&ldquo;Confidence intervals for the difference of proportions estimated from pooled samples.&rdquo;
<em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>13</b>, 478&ndash;496.
</p>
<p>Bilder, C., Tebbs, J., Chen, P. (2010).
&ldquo;Informative retesting.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>105</b>, 942&ndash;955.
</p>
<p>Bilder, C., Tebbs, J., McMahan, C. (2019).
&ldquo;Informative group testing for multiplex assays.&rdquo;
<em>Biometrics</em>, <b>75</b>, 278&ndash;288.
</p>
<p>Bilder, C. (2019a).
&ldquo;Group Testing for Estimation.&rdquo;
<em>Wiley StatsRef: Statistics Reference Online</em>.
</p>
<p>Bilder, C. (2019b).
&ldquo;Group Testing for Identification.&rdquo;
<em>Wiley StatsRef: Statistics Reference Online</em>.
</p>
<p>Bilder, C., Iwen, P., Abdalhamid, B., Tebbs, J., McMahan, C. (2020).
&ldquo;Tests in short supply? Try group testing.&rdquo;
<em>Significance</em>, <b>17</b>, 15.
</p>
<p>Black, M., Bilder, C., Tebbs, J. (2012).
&ldquo;Group testing in heterogeneous populations by using halving algorithms.&rdquo;
<em>Journal of the Royal Statistical Society. Series C: Applied Statistics</em>, <b>61</b>, 277&ndash;290.
</p>
<p>Black, M., Bilder, C., Tebbs, J. (2015).
&ldquo;Optimal retesting configurations for hierarchical group testing.&rdquo;
<em>Journal of the Royal Statistical Society. Series C: Applied Statistics</em>, <b>64</b>, 693&ndash;710.
</p>
<p>Graff, L., Roeloffs, R. (1972).
&ldquo;Group testing in the presence of test error; an extension of the Dorfman procedure.&rdquo;
<em>Technometrics</em>, <b>14</b>, 113&ndash;122.
</p>
<p>Hepworth, G. (1996).
&ldquo;Exact confidence intervals for proportions estimated by group testing.&rdquo;
<em>Biometrics</em>, <b>52</b>, 1134&ndash;1146.
</p>
<p>Hepworth, G., Biggerstaff, B. (2017).
&ldquo;Bias correction in estimating proportions by pooled testing.&rdquo;
<em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>22</b>, 602&ndash;614.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019).
&ldquo;The objective function controversy for group testing: Much ado about nothing?&rdquo;
<em>Statistics in Medicine</em>, <b>38</b>, 4912&ndash;4923.
</p>
<p>Hou, P., Tebbs, J., Wang, D., McMahan, C., Bilder, C. (2021).
&ldquo;Array testing with multiplex assays.&rdquo;
<em>Biostatistics</em>, <b>21</b>, 417&ndash;431.
</p>
<p>Malinovsky, Y., Albert, P., Roy, A. (2016).
&ldquo;Reader reaction: A note on the evaluation of group testing algorithms in the presence of misclassification.&rdquo;
<em>Biometrics</em>, <b>72</b>, 299&ndash;302.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012a).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>, 287&ndash;296.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012b).
&ldquo;Two-Dimensional Informative Array Testing.&rdquo;
<em>Biometrics</em>, <b>68</b>, 793&ndash;804.
</p>
<p>Schaarschmidt, F. (2007).
&ldquo;Experimental design for one-sided confidence intervals or hypothesis tests in binomial group testing.&rdquo;
<em>Communications in Biometry and Crop Science</em>, <b>2</b>, 32&ndash;40.
ISSN 1896-0782.
</p>
<p>Swallow, W. (1985).
&ldquo;Group testing for estimating infection rates and probabilities of disease transmission.&rdquo;
<em>Phytopathology</em>, <b>75</b>, 882&ndash;889.
</p>
<p>Tebbs, J., Bilder, C. (2004).
&ldquo;Confidence interval procedures for the probability of disease transmission in multiple-vector-transfer designs.&rdquo;
<em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>9</b>, 75&ndash;90.
</p>
<p>Vansteelandt, S., Goetghebeur, E., Verstraeten, T. (2000).
&ldquo;Regression models for disease prevalence with diagnostic tests on pools of serum samples.&rdquo;
<em>Biometrics</em>, <b>56</b>, 1126&ndash;1133.
</p>
<p>Verstraeten, T., Farah, B., Duchateau, L., Matu, R. (1998).
&ldquo;Pooling sera to reduce the cost of HIV surveillance: a feasibility study in a rural Kenyan district.&rdquo;
<em>Tropical Medicine &amp; International Health</em>, <b>3</b>, 747&ndash;750.
</p>
<p>Xie, M. (2001).
&ldquo;Regression analysis of group testing samples.&rdquo;
<em>Statistics in Medicine</em>, <b>20</b>, 1957&ndash;1969.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1) Identification using hierarchical and array-based
#   group testing algorithms with an assay that tests
#   for one disease.

# 1.1) Find the optimal testing configuration over a
#   range of initial group sizes, using informative
#   three-stage hierarchical testing, where
#   p denotes the overall prevalence of disease (mean
#    parameter of a beta distribution);
#   Se denotes the sensitivity of the diagnostic test;
#   Sp denotes the specificity of the diagnostic test;
#   group.sz denotes the range of initial pool sizes
#   for consideration;
#   obj.fn specifies the objective functions for which
#   to find results; and
#   alpha is the heterogeneity level.
set.seed(1002)
results1 &lt;- OTC1(algorithm = "ID3", p = 0.025, Se = 0.95,
                 Sp = 0.95, group.sz = 3:20,
                 obj.fn = "ET", alpha = 2)
summary(results1)

# 1.2) Find the optimal testing configuration using
#   non-informative array testing without master pooling.
# The sensitivity and specificity differ for row/column
#   testing and individual testing.
results2 &lt;- OTC1(algorithm = "A2", p = 0.05,
                 Se = c(0.95, 0.99), Sp = c(0.95, 0.98),
                 group.sz = 3:15, obj.fn = "ET")
summary(results2)

# 1.3) Calculate the operating characteristics using
#   informative two-stage hierarchical (Dorfman) testing,
#   implemented via the pool-specific optimal Dorfman
#   (PSOD) method described in McMahan et al. (2012a).
# Hierarchical testing configurations are specified by
#   a matrix in the hier.config argument. The rows of
#   the matrix correspond to the stages of the
#   hierarchical testing algorithm, the columns
#   correspond to the individuals to be tested, and the
#   cell values correspond to the group number of each
#   individual at each stage.
config.mat &lt;- matrix(data = c(rep(1, 5), rep(2, 4), 3, 1:10),
                     nrow = 2, ncol = 10, byrow = TRUE)
set.seed(8791)
results3 &lt;- opChar1(algorithm = "ID2", p = 0.02,
                    Se = 0.95, Sp = 0.99,
                    hier.config = config.mat, alpha = 0.5)
summary(results3)

# 1.4) Calculate the operating characteristics using
#   non-informative four-stage hierarchical testing.
config.mat &lt;- matrix(data = c(rep(1, 15), rep(c(1, 2, 3), each = 5),
                              rep(1, 3), rep(2, 2),
                              rep(3, 3), rep(4, 2),
                              rep(5, 4), 6, 1:15),
                     nrow = 4, ncol = 15, byrow = TRUE)
results4 &lt;- opChar1(algorithm = "D4", p = 0.008,
                    Se = 0.96, Sp = 0.98,
                    hier.config = config.mat,
                    a = c(1, 4, 6, 9, 11, 15))
summary(results4)


# 2) Identification using hierarchical and array-based
#   group testing algorithms with a multiplex assay that
#   tests for two diseases.

# 2.1) Find the optimal testing configuration using
#   non-informative two-stage hierarchical testing, given
#   p.vec, a vector of overall joint probabilities of disease;
#   Se, a vector of sensitivity values for each disease; and
#   Sp, a vector of specificity values for each disease.
# Se and Sp can also be specified as a matrix, where one
#   value is specified for each disease at each stage of
#   testing.
results5 &lt;- OTC2(algorithm = "D2",
                 p.vec = c(0.90, 0.04, 0.04, 0.02),
                 Se = c(0.99, 0.99), Sp = c(0.99, 0.99),
                 group.sz = 3:20)
summary(results5)

# 2.2) Calculate the operating characteristics for
#   informative five-stage hierarchical testing, given
#   alpha.vec, a vector of shape parameters for the
#   Dirichlet distribution;
#   Se, a matrix of sensitivity values; and
#   Sp, a matrix of specificity values.
Se &lt;- matrix(data = rep(0.95, 10), nrow = 2, ncol = 5, byrow = TRUE)
Sp &lt;- matrix(data = rep(0.99, 10), nrow = 2, ncol = 5, byrow = TRUE)
config.mat &lt;- matrix(data = c(rep(1, 24), rep(1, 18),
                              rep(2, 6), rep(1, 9),
                              rep(2, 9), rep(3, 4), 4, 5,
                              rep(1, 6), rep(2, 3),
                              rep(3, 5), rep(4, 4),
                              rep(5, 3), 6, rep(NA, 2),
                              1:21, rep(NA, 3)),
                     nrow = 5, ncol = 24, byrow = TRUE)
results6 &lt;- opChar2(algorithm = "ID5",
                    alpha = c(18.25, 0.75, 0.75, 0.25),
                    Se = Se, Sp = Sp,
                    hier.config = config.mat)
summary(results6)

# 3) Estimation of the overall disease prevalence and
#   calculation of confidence intervals.

# 3.1) Suppose 3 groups out of 24 test positively.
#   Each group has a size of 7.
propCI(x = 3, m = 7, n = 24, ci.method = "CP")
propCI(x = 3, m = 7, n = 24, ci.method = "Blaker")
propCI(x = 3, m = 7, n = 24, ci.method = "score")
propCI(x = 3, m = 7, n = 24, ci.method = "soc")

# 3.2) Consider the following situation:
#   0 out of 5 groups test positively with groups
#   of size 1 (individual testing),
#   0 out of 5 groups test positively with groups of size 5,
#   1 out of 5 groups test positively with groups of size 10,
#   2 out of 5 groups test positively with groups of size 50
propCI(x = c(0, 0, 1, 2), m = c(1, 5, 10, 50),
       n = c(5, 5, 5, 5), pt.method = "Gart",
       ci.method = "skew-score")

# 4) Estimate a group testing regression model.

# 4.1) Fit a group testing regression model with
#   simple pooling using the "hivsurv" dataset.
data(hivsurv)
fit1 &lt;- gtReg(type = "sp",
              formula = groupres ~ AGE + EDUC.,
              data = hivsurv, groupn = gnum,
              sens = 0.9, spec = 0.9, method = "Xie")
summary(fit1)

# 4.2) Simulate data for the halving protocol, and
#   fit a group testing regression model.
set.seed(46)
gt.data &lt;- gtSim(type = "halving", par = c(-6, 0.1),
                 gshape = 17, gscale = 1.4,
                 size1 = 1000, size2 = 5,
                 sens = 0.95, spec = 0.95)
fit2 &lt;- gtReg(type = "halving", formula = gres ~ x,
              data = gt.data, groupn = groupn,
              subg = subgroup, retest = retest,
              sens = 0.95, spec = 0.95,
              start = c(-6, 0.1), trace = TRUE)
summary(fit2)


</code></pre>

<hr>
<h2 id='Accuracy'>Extract the accuracy measures from group testing results</h2><span id='topic+Accuracy'></span>

<h3>Description</h3>

<p>Extract the accuracy measures from objects of class
&quot;opchar&quot; returned by <code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code> (<kbd>opChar1</kbd>)
or <code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code> (<kbd>opChar2</kbd>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Accuracy(object, individual = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Accuracy_+3A_object">object</code></td>
<td>
<p>An object of class &quot;opChar&quot;, from which the accuracy measures
are to be extracted.</p>
</td></tr>
<tr><td><code id="Accuracy_+3A_individual">individual</code></td>
<td>
<p>A logical argument that determines whether the accuracy
measures for each individual (<kbd>individual=TRUE</kbd>) are to be included.</p>
</td></tr>
<tr><td><code id="Accuracy_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>Accuracy</code> (e.g.,
<code>digits</code> to be passed to <code>round</code> or <code>signif</code> for appropriate
rounding).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <kbd>Accuracy</kbd> function gives the individual accuracy measures
for each individual in <kbd>object</kbd> and the overall accuracy measures for
the algorithm. If <kbd>individual=TRUE</kbd>, individual accuracy measures
are provided for each individual specified in the <code>a</code> argument of the
call to <code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code> (<kbd>opChar1</kbd>)
or <code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code> (<kbd>opChar2</kbd>).
</p>
<p>Accuracy measures included are the pooling sensitivity, pooling
specificity, pooling positive predictive value, and pooling negative
predictive value. The overall accuracy measures displayed are weighted
averages of the corresponding individual accuracy measures for all
individuals in the algorithm. Expressions for these averages are provided
in the Supplementary Material for Hitt et al. (2019). For more information,
see the Details' section for the <code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code>
(<kbd>opChar1</kbd>) or <code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code> (<kbd>opChar2</kbd>)
function.
</p>
<p>The rows in the matrices of individual accuracy measures correspond to each
unique set of accuracy measures in the algorithm. Individuals with the same
set of accuracy measures are displayed together in a single row of the
matrix. The columns correspond to the pooling sensitivity, pooling
specificity, pooling positive predictive value, pooling negative predictive
value, and the indices for the individuals in each row of the matrix.
Individual accuracy measures are provided only if <kbd>individual=TRUE</kbd>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>Individual</code></td>
<td>
<p>matrix detailing the accuracy measures for each individual
from <kbd>object</kbd> (for objects returned by <code><a href="#topic+opChar1">opChar1</a></code>).</p>
</td></tr>
<tr><td><code>Disease 1 Individual</code></td>
<td>
<p>matrix detailing the accuracy measures
pertaining to disease 1 for each individual from <kbd>object</kbd>
(for objects returned by <code><a href="#topic+opChar2">opChar2</a></code>).</p>
</td></tr>
<tr><td><code>Disease 2 Individual</code></td>
<td>
<p>matrix detailing the accuracy measures
pertaining to disease 2 for each individual from <kbd>object</kbd>
(for objects returned by <code><a href="#topic+opChar2">opChar2</a></code>).</p>
</td></tr>
<tr><td><code>Overall</code></td>
<td>
<p>matrix detailing the overall accuracy measures for
the algorithm from <kbd>object</kbd>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>config.mat &lt;- matrix(data = c(rep(1, 10), 1:10),
                     nrow = 2, ncol = 10, byrow = TRUE)
res1 &lt;- opChar1(algorithm = "D2", p = 0.05, Se = 0.99, Sp = 0.99,
        hier.config = config.mat)
Accuracy(res1, individual = FALSE)
Accuracy(res1, individual = TRUE)

res2 &lt;- opChar2(algorithm = "A2M",
                p.vec = c(0.92, 0.05, 0.02, 0.01),
                Se = rep(0.95, 2), Sp = rep(0.99, 2),
                rowcol.sz = 8)
Accuracy(res2)
</code></pre>

<hr>
<h2 id='coef.gtReg'>Extract coefficients from a fitted group testing model</h2><span id='topic+coef.gtReg'></span><span id='topic+coefficients.gtReg'></span>

<h3>Description</h3>

<p>Extract coefficients from objects of class &quot;gtReg&quot; returned
by <code><a href="#topic+gtReg">gtReg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gtReg'
coef(object, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'gtReg'
coefficients(object, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.gtReg_+3A_object">object</code></td>
<td>
<p>An object of class &quot;gtReg&quot;, created by <code><a href="#topic+gtReg">gtReg</a></code>,
from which the coefficients are to be extracted.</p>
</td></tr>
<tr><td><code id="coef.gtReg_+3A_digits">digits</code></td>
<td>
<p>digits for rounding.</p>
</td></tr>
<tr><td><code id="coef.gtReg_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model coefficients extracted from the object <kbd>object</kbd>.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hivsurv)
fit1 &lt;- gtReg(formula = groupres ~ AGE * EDUC.,
              data = hivsurv, groupn = gnum,
              linkf = "probit")
coefficients(object = fit1)
</code></pre>

<hr>
<h2 id='CompareConfig'>Compare group testing results</h2><span id='topic+CompareConfig'></span>

<h3>Description</h3>

<p>Compare group testing results from objects of class
&quot;opchar&quot; returned by <code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code> (<kbd>opChar1</kbd>)
or <code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code> (<kbd>opChar2</kbd>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareConfig(object1, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompareConfig_+3A_object1">object1</code></td>
<td>
<p>An object of class &quot;opChar&quot; containing group testing results.</p>
</td></tr>
<tr><td><code id="CompareConfig_+3A_object2">object2</code></td>
<td>
<p>A second object of class &quot;opChar&quot; containing group
testing results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>CompareConfig</code> function compares group testing results from
two objects of class &quot;opChar&quot;. The function creates a
data frame with these comparisons.
</p>


<h3>Value</h3>

<p>A data frame with the expected percent reduction in tests (PercentReductionTests) and the expected
increase in testing capacity (PercentIncreaseTestCap) when using the second testing configuration rather than
the first testing configuration. Positive values for these quantities
indicate that the second testing configuration is more efficient than the first.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt and Christopher R. Bilder
</p>


<h3>Examples</h3>

<pre><code class='language-R'>config.mat1 &lt;- matrix(data = c(rep(1, 10), rep(1:2, each = 5), 1:10),
                      nrow = 3, ncol = 10, byrow = TRUE)
res1 &lt;- opChar1(algorithm = "D3", p = 0.05, Se = 0.99, Sp = 0.99,
                hier.config = config.mat1)
config.mat2 &lt;- matrix(data = c(rep(1, 10), 1:10),
                      nrow = 2, ncol = 10, byrow = TRUE)
res2 &lt;- opChar1(algorithm = "D2", p = 0.05, Se = 0.99, Sp = 0.99,
        hier.config = config.mat2)
CompareConfig(res2, res1)

config.mat3 &lt;- matrix(data = c(rep(1, 10), rep(1, 5),
                               rep(2, 4), 3, 1:9, NA),
                      nrow = 3, ncol = 10, byrow = TRUE)
Se &lt;- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
Sp &lt;- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
res3 &lt;- opChar2(algorithm = "D3", p.vec = c(0.95, 0.02, 0.02, 0.01),
                Se = Se, Sp = Sp, hier.config = config.mat3)
config.mat4 &lt;- matrix(data = c(rep(1, 12), rep(1, 6), rep(2, 6),
                               rep(1, 4), rep(2, 2), rep(3, 3),
                               rep(4, 3), 1:12),
                    nrow = 4, ncol = 12, byrow = TRUE)
Se &lt;- matrix(data = rep(0.95, 8), nrow = 2, ncol = 4,
             dimnames = list(Infection = 1:2, Stage = 1:4))
Sp &lt;- matrix(data = rep(0.99, 8), nrow = 2, ncol = 4,
             dimnames = list(Infection = 1:2, Stage = 1:4))
res4 &lt;- opChar2(algorithm = "D4", p.vec = c(0.92, 0.05, 0.02, 0.01),
                Se = Se, Sp = Sp, hier.config = config.mat4)
CompareConfig(res4, res3)
</code></pre>

<hr>
<h2 id='Config'>Access the testing configurations returned from an object</h2><span id='topic+Config'></span>

<h3>Description</h3>

<p><code>Config</code> is a generic function that extracts testing configurations from an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Config(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Config_+3A_object">object</code></td>
<td>
<p>An object from which the testing configurations are to be extracted.</p>
</td></tr>
<tr><td><code id="Config_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>Config</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher R. Bilder
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Config.opChar">Config.opChar</a></code> and <code><a href="#topic+Config.OTC">Config.OTC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the optimal testing configuration for
#   non-informative two-stage hierarchical testing.
res1 &lt;- OTC1(algorithm = "D2", p = 0.01, Se = 0.99, Sp = 0.99,
             group.sz = 2:100, obj.fn = c("ET", "MAR", "GR1"),
             weights = matrix(data = c(1,1), nrow = 1, ncol = 2))
Config(res1)
</code></pre>

<hr>
<h2 id='Config.opChar'>Extract the testing configuration from group testing results</h2><span id='topic+Config.opChar'></span>

<h3>Description</h3>

<p>Extract the testing configuration from objects of class
&quot;opchar&quot; returned by <code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code> (<kbd>opChar1</kbd>)
or <code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code> (<kbd>opChar2</kbd>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'opChar'
Config(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Config.opChar_+3A_object">object</code></td>
<td>
<p>An object of class &quot;opChar&quot;, from which the testing
configuration is to be extracted.</p>
</td></tr>
<tr><td><code id="Config.opChar_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame specifying elements of the testing configuration.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>config.mat &lt;- matrix(data = c(rep(1, 10), 1:10),
                     nrow = 2, ncol = 10, byrow = TRUE)
res1 &lt;- opChar1(algorithm = "D2", p = 0.05, Se = 0.99, Sp = 0.99,
        hier.config = config.mat)
Config(res1)

config.mat &lt;- matrix(data = c(rep(1, 20), rep(1, 10), rep(2, 10),
                             rep(c(1, 2, 3, 4), each = 5),
                             rep(1, 3), rep(2, 2), rep(3, 3),
                             rep(4, 2), rep(5, 3), rep(6, 2),
                             rep(7, 3), rep(8, 2), 1:20),
                    nrow = 5, ncol = 20, byrow = TRUE)
Se &lt;- matrix(data = rep(0.95, 10), nrow = 2, ncol = 5,
             dimnames = list(Infection = 1:2, Stage = 1:5))
Sp &lt;- matrix(data = rep(0.99, 10), nrow = 2, ncol = 5,
             dimnames = list(Infection = 1:2, Stage = 1:5))
res2 &lt;- opChar2(algorithm = "ID5",
                alpha = c(18.25, 0.75, 0.75, 0.25),
                Se = Se, Sp = Sp, hier.config = config.mat)
Config(res2)
</code></pre>

<hr>
<h2 id='Config.OTC'>Extract the testing configuration from group testing results</h2><span id='topic+Config.OTC'></span>

<h3>Description</h3>

<p>Extract the testing configuration from objects of class
&quot;OTC&quot; returned by <code><a href="#topic+OTC1">OTC1</a></code> (<kbd>OTC1</kbd>)
or <code><a href="#topic+OTC2">OTC2</a></code> (<kbd>OTC2</kbd>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'OTC'
Config(object, n = 5, top.overall = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Config.OTC_+3A_object">object</code></td>
<td>
<p>An object of class &quot;OTC&quot;, from which the testing
configuration is to be extracted.</p>
</td></tr>
<tr><td><code id="Config.OTC_+3A_n">n</code></td>
<td>
<p>Number of testing configurations.</p>
</td></tr>
<tr><td><code id="Config.OTC_+3A_top.overall">top.overall</code></td>
<td>
<p>logical; if TRUE, best overall testing configurations; if FALSE,
best testing configurations by initial group size</p>
</td></tr>
<tr><td><code id="Config.OTC_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame providing the best testing configurations.
</p>


<h3>Author(s)</h3>

<p>Christopher R. Bilder
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res1 &lt;- OTC1(algorithm = "D3", p = 0.05, Se = 0.99, Sp = 0.99,
             group.sz = 3:15, obj.fn = "ET")
Config(res1)
</code></pre>

<hr>
<h2 id='designEst'>Optimal group size determination based on minimal MSE
when estimating an overall prevalence</h2><span id='topic+designEst'></span>

<h3>Description</h3>

<p>Find the group size <kbd>s</kbd> for a fixed number of
groups <kbd>n</kbd> and an assumed true proportion <kbd>p.tr</kbd>, for
which the mean squared error (MSE) of the point estimator is
minimal and bias is within a restriction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designEst(n, smax, p.tr, biasrest = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designEst_+3A_n">n</code></td>
<td>
<p>integer specifying the fixed number of groups.</p>
</td></tr>
<tr><td><code id="designEst_+3A_smax">smax</code></td>
<td>
<p>integer specifying the maximum group size allowed in the
planning of the design.</p>
</td></tr>
<tr><td><code id="designEst_+3A_p.tr">p.tr</code></td>
<td>
<p>assumed true proportion of the &quot;positive&quot; trait
in the population, specified as a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="designEst_+3A_biasrest">biasrest</code></td>
<td>
<p>a value between 0 and 1 specifying the absolute
bias maximally allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Swallow (1985) recommends the use of the upper bound of
the expected range of the true proportion <kbd>p.tr</kbd> for optimization
of the design. For further details, see Swallow (1985). Note that the
specified number of groups must be less than <code class="reqn">n=1020</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the function call</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>a data frame containing:
</p>

<dl>
<dt>mse</dt><dd><p>the mean squared error of the estimator.</p>
</dd>
<dt>sout</dt><dd><p>the group size <kbd>s</kbd> for which the MSE of the estimator is
minimal for the given <kbd>n</kbd> and <kbd>p.tr</kbd> and for which the bias
restriction <kbd>biasrest</kbd> is not violated. In the case that the minimum
MSE is achieved for a group size <code class="reqn">s&gt;=smax</code>, the value of <kbd>smax</kbd>
is returned.</p>
</dd>
<dt>exp</dt><dd><p>the expected value of the estimator.</p>
</dd>
<dt>varp</dt><dd><p>the variance of the estimator.</p>
</dd>
<dt>bias</dt><dd><p>the bias of the estimator.</p>
</dd></dl>
</td></tr>
<tr><td><code>bias.reached</code></td>
<td>
<p>a logical value indicating whether the bias
restriction <kbd>biasrest</kbd> was violated.</p>
</td></tr>
<tr><td><code>smax.reached</code></td>
<td>
<p>a logical value indicating whether the maximum group
size allowed <kbd>smax</kbd> was reached.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function was originally written by Frank Schaarschmidt
as the <code>estDesign</code> function for the <code>binGroup</code> package. Minor
modifications were made for inclusion in the <code>binGroup2</code> package.
</p>


<h3>References</h3>

<p>Swallow, W. (1985).
&ldquo;Group testing for estimating infection rates and probabilities of disease transmission.&rdquo;
<em>Phytopathology</em>, <b>75</b>, 882&ndash;889.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+designPower">designPower</a></code> for choice of the group testing
design according to the power in a hypothesis test.
</p>
<p>Other estimation functions: 
<code><a href="#topic+designPower">designPower</a>()</code>,
<code><a href="#topic+gtPower">gtPower</a>()</code>,
<code><a href="#topic+gtTest">gtTest</a>()</code>,
<code><a href="#topic+gtWidth">gtWidth</a>()</code>,
<code><a href="#topic+propCI">propCI</a>()</code>,
<code><a href="#topic+propDiffCI">propDiffCI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare to Table 1 in Swallow (1985):
designEst(n = 10, smax = 100, p.tr = 0.001)
designEst(n = 10, smax = 100, p.tr = 0.01)
designEst(n = 25, smax = 100, p.tr = 0.05)
designEst(n = 40, smax = 100, p.tr = 0.25)
designEst(n = 200, smax = 100, p.tr = 0.30)
</code></pre>

<hr>
<h2 id='designPower'>Number of groups or group size needed to achieve a power level in
one parameter group testing</h2><span id='topic+designPower'></span>

<h3>Description</h3>

<p>For a fixed number of groups (group size), determine the
group size (number of groups) needed to obtain a specified power level to
reject a hypothesis for a proportion in one parameter group testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designPower(
  n,
  s,
  fixed = "s",
  delta,
  p.hyp,
  conf.level = 0.95,
  power = 0.8,
  alternative = "two.sided",
  method = "CP",
  biasrest = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designPower_+3A_n">n</code></td>
<td>
<p>integer specifying the maximum number of groups <kbd>n</kbd> allowed
when <kbd>fixed="s"</kbd> or the fixed number of groups when <kbd>fixed="n"</kbd>.
When <kbd>fixed="s"</kbd>, a vector of two integers giving the range of <kbd>n</kbd>
which power shall be iterated over is also allowed.</p>
</td></tr>
<tr><td><code id="designPower_+3A_s">s</code></td>
<td>
<p>integer specifying the fixed group size (number of units per group)
when <kbd>fixed="s"</kbd> or the maximum group size allowed in the planning of
the design when <kbd>fixed="n"</kbd>.</p>
</td></tr>
<tr><td><code id="designPower_+3A_fixed">fixed</code></td>
<td>
<p>character string specifying whether the number of groups
<kbd>"n"</kbd> or the group size <kbd>"s"</kbd> is to be held at a fixed value.</p>
</td></tr>
<tr><td><code id="designPower_+3A_delta">delta</code></td>
<td>
<p>the absolute difference between the true proportion and the
hypothesized proportion which shall be detectable with the specified power.</p>
</td></tr>
<tr><td><code id="designPower_+3A_p.hyp">p.hyp</code></td>
<td>
<p>the proportion in the hypotheses, specified as a value between
0 and 1.</p>
</td></tr>
<tr><td><code id="designPower_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the decision. The default
confidence level is 0.95.</p>
</td></tr>
<tr><td><code id="designPower_+3A_power">power</code></td>
<td>
<p>level of power to be achieved, specified as a
probability between 0 and 1.</p>
</td></tr>
<tr><td><code id="designPower_+3A_alternative">alternative</code></td>
<td>
<p>character string defining the alternative hypothesis,
either <kbd>"two.sided"</kbd>, <kbd>"less"</kbd>, or <kbd>"greater"</kbd>.</p>
</td></tr>
<tr><td><code id="designPower_+3A_method">method</code></td>
<td>
<p>character string specifying the confidence interval method
(see <code><a href="#topic+propCI">propCI</a></code>) to be used.</p>
</td></tr>
<tr><td><code id="designPower_+3A_biasrest">biasrest</code></td>
<td>
<p>a value between 0 and 1, specifying the absolute bias
maximally allowed for a point estimate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power of a hypothesis test performed by a confidence interval
is defined as the probability that a confidence interval excludes the
threshold parameter (<kbd>p.hyp</kbd>) of the hypothesis.
</p>
<p>When <kbd>fixed="s"</kbd>, this function increases the number of groups until a
pre-specified level of power is reached or the maximum number of groups
<kbd>n</kbd> is reached. Since the power does not increase monotonically with
increasing <kbd>n</kbd> for single proportions but oscillates between local
maxima and minima, the simple iteration given here will generally result in
selecting <kbd>n</kbd> for which the given confidence interval method shows a
local minimum of coverage if the null hypothesis is true. Bias decreases
monotonically with increasing the number of groups (if other parameters are
fixed). The resulting problems of choosing a number of groups which results
in satisfactory power are solved in the following manner:
</p>
<p>In the case that the pre-specified power is reached within the given
range of <kbd>n</kbd>, the smallest <kbd>n</kbd> is returned for which at least
this power is reached, as well as the actual power for this <kbd>n</kbd>.
</p>
<p>In the case that the pre-specified power is not reached within the given
value, that <kbd>n</kbd> is returned for which maximum power is achieved, and
the corresponding value of power.
</p>
<p>In the case that the bias restriction is violated even for the largest
<kbd>n</kbd> within the given range of <kbd>n</kbd>, simply that <kbd>n</kbd> will be
returned for which power was largest in the given range.
</p>
<p>Especially for large <kbd>n</kbd>, the calculation time may become large
(particularly for the Blaker interval). Alternatively, the function
<code><a href="#topic+gtPower">gtPower</a></code> might be used to calculate power and bias
only for some particular combinations of the input arguments.
</p>
<p>When <kbd>fixed="n"</kbd>, this function increases the size of groups until a
pre-specified level of power is reached. Since the power does not increase
monotonically with increasing <kbd>s</kbd> for single proportions but oscillates
between local maxima and minima, the simple iteration given here will
generally result in selecting <kbd>s</kbd> for which the given confidence
interval method shows a local minimum of coverage if the null hypothesis
is true. Since the positive bias of the estimator in group testing
increases with increasing group size, this function checks whether the bias
is smaller than a pre-specified level (<kbd>bias.rest</kbd>). If the bias violates
this restriction for a given combination <kbd>n</kbd>, <kbd>s</kbd>, and <kbd>delta</kbd>,
<kbd>s</kbd> will not be further increased and the actual power of the last
acceptable group size <kbd>s</kbd> is returned.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>nout</code></td>
<td>
<p>the number of groups necessary to reach the power with the
specified parameters, when <kbd>fixed="s"</kbd> only.</p>
</td></tr>
<tr><td><code>sout</code></td>
<td>
<p>the group size necessary to meet the conditions, when
<kbd>fixed="n"</kbd> only.</p>
</td></tr>
<tr><td><code>powerout</code></td>
<td>
<p>the power for the specified parameters and the selected
number of groups <kbd>n</kbd> when <kbd>fixed="s"</kbd> or the selected group
size <kbd>s</kbd> when <kbd>fixed="n"</kbd>.</p>
</td></tr>
<tr><td><code>biasout</code></td>
<td>
<p>the bias for the specified parameters and the selected
number of groups <kbd>n</kbd> when <kbd>fixed="s"</kbd> or the selected group
size <kbd>s</kbd> when <kbd>fixed="n"</kbd>.</p>
</td></tr>
<tr><td><code>power.reached</code></td>
<td>
<p>a logical value indicating whether the
specified level of power was reached.</p>
</td></tr>
<tr><td><code>bias.reached</code></td>
<td>
<p>a logical value indicating whether the maximum
allowed bias was reached.</p>
</td></tr>
<tr><td><code>nit</code></td>
<td>
<p>the number of groups for each iteration.</p>
</td></tr>
<tr><td><code>sit</code></td>
<td>
<p>the group size for each iteration.</p>
</td></tr>
<tr><td><code>powerit</code></td>
<td>
<p>the power achieved for each iteration.</p>
</td></tr>
<tr><td><code>biasit</code></td>
<td>
<p>the bias for each iteration.</p>
</td></tr>
<tr><td><code>maxit</code></td>
<td>
<p>the iteration at which the maximum power was reached,
or the total number of iterations.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>the alternative hypothesis specified by the user.</p>
</td></tr>
<tr><td><code>p.hyp</code></td>
<td>
<p>the hypothesized proportion specified by the user.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>the absolute difference between the true proportion and the
hypothesized proportion specified by the user.</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>the desired power specified by the user.</p>
</td></tr>
<tr><td><code>biasrest</code></td>
<td>
<p>the maximum absolute bias specified by the user.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The <code>nDesign</code> and <code>sDesign</code> functions were originally
written by Frank Schaarschmidt for the <code>binGroup</code> package. Minor
modifications were made for inclusion in the <code>binGroup2</code> package.
</p>


<h3>References</h3>

<p>Swallow, W. (1985).
&ldquo;Group testing for estimating infection rates and probabilities of disease transmission.&rdquo;
<em>Phytopathology</em>, <b>75</b>, 882&ndash;889.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtPower">gtPower</a></code> for calculation of power and bias depending
on <kbd>n</kbd>, <kbd>s</kbd>, <kbd>delta</kbd>, <kbd>p.hyp</kbd>, <kbd>conf.level</kbd>,
and <kbd>method</kbd>, and <code><a href="#topic+designEst">designEst</a></code> to choose the group size
<kbd>s</kbd> according to the minimal mse of the estimator, as given in
Swallow (1985).
</p>
<p>Other estimation functions: 
<code><a href="#topic+designEst">designEst</a>()</code>,
<code><a href="#topic+gtPower">gtPower</a>()</code>,
<code><a href="#topic+gtTest">gtTest</a>()</code>,
<code><a href="#topic+gtWidth">gtWidth</a>()</code>,
<code><a href="#topic+propCI">propCI</a>()</code>,
<code><a href="#topic+propDiffCI">propDiffCI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assume the objective is to show that a proportion is
#   smaller than 0.005 (i.e. 0.5 percent) with a power
#   of 0.80 (i.e. 80 percent) if the unknown proportion
#   in the population is 0.003 (i.e. 0.3 percent);
#   thus, a delta of 0.002 shall be detected.
# A 95% Clopper Pearson CI shall be used.
# The maximum group size because of limited sensitivity
#   of the diagnostic test might be s=20 and we can
#   only afford to perform maximally 100 tests:
designPower(n = 100, s = 20, delta = 0.002,
            p.hyp = 0.005, fixed = "s",
            alternative = "less", method = "CP",
            power = 0.8)

# One might accept to detect delta=0.004,
#   i.e. reject H0: p&gt;=0.005 with power 80 percent
#   when the true proportion is 0.001:
designPower(n = 100, s = 20, delta = 0.004, p.hyp = 0.005, fixed = "s",
             alternative = "less", method = "CP", power = 0.8)

# Power for a design with a fixed group size of s = 1
#   (individual testing).
designPower(n = 200, s = 1, delta = 0.05, p.hyp = 0.10,
            fixed = "s", method = "CP", power = 0.80)

# Assume that objective is to show that a proportion
#   is smaller than 0.005 (i.e. 0.5%) with a
#   power of 0.80 (i.e. 80%) if the unknown proportion
#   in the population is 0.003 (i.e. 0.3%); thus, a
#   delta = 0.002 shall be detected.
# A 95% Clopper-Pearson CI shall be used.
# The maximum number of groups might be 30, where the
#   overall sensitivity is not limited until group
#   size s=100.
designPower(s = 100, n = 30, delta = 0.002, p.hyp = 0.005, fixed = "n",
             alternative = "less", method = "CP", power = 0.8)

# One might accept to detect delta=0.004,
#   i.e. reject H0: p&gt;=0.005 with power 80 percent
#   when the true proportion is 0.001:
designPower(s = 100, n = 30, delta = 0.004, p.hyp = 0.005, fixed = "n",
             alternative = "less", method = "CP", power = 0.8)
designPower(s = 100, n = 30, delta = 0.004, p.hyp = 0.005, fixed = "n",
             alternative = "less", method = "score", power = 0.8)
</code></pre>

<hr>
<h2 id='expectOrderBeta'>Determine a vector of probabilities for informative group
testing algorithms</h2><span id='topic+expectOrderBeta'></span>

<h3>Description</h3>

<p>Find the expected value of order statistics from a beta
distribution. This function is used to provide a set of individual
risk probabilities for informative group testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectOrderBeta(
  p,
  alpha,
  size,
  grp.sz,
  num.sim = 10000,
  rel.tol = ifelse(alpha &gt;= 1, .Machine$double.eps^0.25, .Machine$double.eps^0.1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectOrderBeta_+3A_p">p</code></td>
<td>
<p>overall probability of disease that will be used to determine a
vector of individual risk probabilities. This is the expected value of a
random variable with a beta distribution,
<code class="reqn">\frac{\alpha}{\alpha + \beta}</code>.</p>
</td></tr>
<tr><td><code id="expectOrderBeta_+3A_alpha">alpha</code></td>
<td>
<p>a shape parameter for the beta distribution that
specifies the degree of heterogeneity for the determined
probability vector.</p>
</td></tr>
<tr><td><code id="expectOrderBeta_+3A_size">size</code></td>
<td>
<p>the size of the vector of individual risk probabilities to be
generated. This is also the number of total individuals for which to
determine risk probabilities.</p>
</td></tr>
<tr><td><code id="expectOrderBeta_+3A_grp.sz">grp.sz</code></td>
<td>
<p>the number of total individuals for which to determine risk
probabilities. This argument is deprecated; the <kbd>size</kbd> argument should
be used instead.</p>
</td></tr>
<tr><td><code id="expectOrderBeta_+3A_num.sim">num.sim</code></td>
<td>
<p>the number of simulations. This argument is used only when
simulation is necessary.</p>
</td></tr>
<tr><td><code id="expectOrderBeta_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative tolerance used for integration.</p>
</td></tr>
<tr><td><code id="expectOrderBeta_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the <code>beta.dist</code> function
written by Michael Black for Black et al. (2015).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code>beta.dist</code> function from
Black et al. (2015) to determine a vector of individual risk probabilities,
ordered from least to greatest. Depending on the specified probability,
<code class="reqn">\alpha</code> level, and overall group size, simulation may be necessary in
order to determine the probabilities. For this reason, the user should set
a seed in order to reproduce results. The number of simulations (default =
10,000) and relative tolerance for integration can be specified by the user.
The <kbd>expectOrderBeta</kbd> function augments the <code>beta.dist</code> function by
checking whether simulation is needed before attempting to determine the
probabilities, and by allowing the number of simulations to be specified by
the user. See Black et al. (2015) for additional details on the original
<kbd>beta.dist</kbd> function.
</p>


<h3>Value</h3>

<p>A vector of individual risk probabilities.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Black, M., Bilder, C., Tebbs, J. (2015).
&ldquo;Optimal retesting configurations for hierarchical group testing.&rdquo;
<em>Journal of the Royal Statistical Society. Series C: Applied Statistics</em>, <b>64</b>, 693&ndash;710.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+informativeArrayProb">informativeArrayProb</a></code> for
arranging a vector of individual risk probabilities in a matrix for
informative array testing without master pooling.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(8791)
expectOrderBeta(p = 0.03, alpha = 0.5, size = 100, rel.tol = 0.0001)

expectOrderBeta(p = 0.05, alpha = 2, size = 40)
</code></pre>

<hr>
<h2 id='ExpTests'>Access the expected number of tests from an object</h2><span id='topic+ExpTests'></span>

<h3>Description</h3>

<p><code>ExpTests</code> is a generic function that extracts the expected
number of tests from an object that contains information
aboout a testing configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpTests(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpTests_+3A_object">object</code></td>
<td>
<p>An object for which a summary of the expected number of tests is desired.</p>
</td></tr>
<tr><td><code id="ExpTests_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>ExpTests</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value return depends on the class of its object. See the documentation
for the corresponding method functions.
</p>


<h3>Author(s)</h3>

<p>Christopher R. Bilder
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ExpTests.opChar">ExpTests.opChar</a></code> and <code><a href="#topic+ExpTests.OTC">ExpTests.OTC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the optimal testing configuration for
#   non-informative two-stage hierarchical testing.
res1 &lt;- OTC1(algorithm = "D2", p = 0.01, Se = 0.99, Sp = 0.99,
             group.sz = 2:100, obj.fn = c("ET", "MAR", "GR1"),
             weights = matrix(data = c(1,1), nrow = 1, ncol = 2))
ExpTests(res1)
</code></pre>

<hr>
<h2 id='ExpTests.halving'>Extract the expected number of tests from testing configuration results</h2><span id='topic+ExpTests.halving'></span>

<h3>Description</h3>

<p>Extract the expected number of tests from objects of class &quot;halving&quot; returned by
<code><a href="#topic+halving">halving</a></code> (<kbd>halving</kbd>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'halving'
ExpTests(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpTests.halving_+3A_object">object</code></td>
<td>
<p>An object of class &quot;halving&quot;, from which the expected number
of tests is to be extracted.</p>
</td></tr>
<tr><td><code id="ExpTests.halving_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>ExpTests</code> (e.g.,
<code>digits</code> to be passed to <code>round</code> for appropriate rounding).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the columns:
</p>
<table>
<tr><td><code>ExpTests</code></td>
<td>
<p>the expected number of tests required to decode all individuals
in the algorithm.</p>
</td></tr>
<tr><td><code>ExpTestsPerIndividual</code></td>
<td>
<p>the expected number of tests per individual.</p>
</td></tr>
<tr><td><code>PercentReductionTests</code></td>
<td>
<p>The percent reduction in the number of tests; 100 * (1 - ExpTestsPerIndividual).</p>
</td></tr>
<tr><td><code>PercentIncreaseTestCap</code></td>
<td>
<p>The percent increase in testing capacity when the algorithm
is applied to a continuous stream of specimens; 100 * (1/ExpTestsPerIndividual - 1).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher R. Bilder
</p>


<h3>References</h3>

<p>Bilder, C., Iwen, P., Abdalhamid, B., Tebbs, J., McMahan, C. (2020).
&ldquo;Tests in short supply? Try group testing.&rdquo;
<em>Significance</em>, <b>17</b>, 15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>save.it1 &lt;- halving(p = rep(0.01, 10), Sp = 1, Se = 1, stages = 2,
        order.p = TRUE)
ExpTests(save.it1)
</code></pre>

<hr>
<h2 id='ExpTests.opChar'>Extract the expected number of tests from testing configuration results</h2><span id='topic+ExpTests.opChar'></span>

<h3>Description</h3>

<p>Extract the expected number of tests and expected number of
tests per individual from objects of class &quot;opchar&quot; returned by
<code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code> (<kbd>opChar1</kbd>)
or <code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code> (<kbd>opChar2</kbd>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'opChar'
ExpTests(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpTests.opChar_+3A_object">object</code></td>
<td>
<p>An object of class &quot;opChar&quot;, from which the expected number
of tests and expected number of tests per individual are to be extracted.</p>
</td></tr>
<tr><td><code id="ExpTests.opChar_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>ExpTests</code> (e.g.,
<code>digits</code> to be passed to <code>round</code> for appropriate rounding).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the columns:
</p>
<table>
<tr><td><code>ExpTests</code></td>
<td>
<p>the expected number of tests required to decode all individuals
in the algorithm.</p>
</td></tr>
<tr><td><code>ExpTestsPerIndividual</code></td>
<td>
<p>the expected number of tests per individual.</p>
</td></tr>
<tr><td><code>PercentReductionTests</code></td>
<td>
<p>The percent reduction in the number of tests; 100 * (1 - ExpTestsPerIndividual).</p>
</td></tr>
<tr><td><code>PercentIncreaseTestCap</code></td>
<td>
<p>The percent increase in testing capacity when the algorithm
is applied to a continuous stream of specimens; 100 * (1/ExpTestsPerIndividual - 1).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brianna D. Hitt and Christopher R. Bilder
</p>


<h3>References</h3>

<p>Bilder, C., Iwen, P., Abdalhamid, B., Tebbs, J., McMahan, C. (2020).
&ldquo;Tests in short supply? Try group testing.&rdquo;
<em>Significance</em>, <b>17</b>, 15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>config.mat &lt;- matrix(data = c(rep(1, 10), 1:10),
                     nrow = 2, ncol = 10, byrow = TRUE)
res1 &lt;- opChar1(algorithm = "D2", p = 0.05, Se = 0.99, Sp = 0.99,
                hier.config = config.mat)
ExpTests(res1)

res2 &lt;- opChar2(algorithm = "A2M", p.vec = c(0.92, 0.05, 0.02, 0.01),
                Se = rep(0.95, 2), Sp = rep(0.99, 2), rowcol.sz = 8)
ExpTests(res2)
</code></pre>

<hr>
<h2 id='ExpTests.OTC'>Extract the expected number of tests from optimal testing
configuration results</h2><span id='topic+ExpTests.OTC'></span>

<h3>Description</h3>

<p>Extract the expected number of tests and expected number of
tests per individual from objects of class &quot;OTC&quot; returned by
<code><a href="#topic+OTC1">OTC1</a></code> or <code><a href="#topic+OTC2">OTC2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'OTC'
ExpTests(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpTests.OTC_+3A_object">object</code></td>
<td>
<p>An object of class &quot;OTC&quot;, from which the expected number
of tests and expected number of tests per individual are to be extracted.</p>
</td></tr>
<tr><td><code id="ExpTests.OTC_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>ExpTests</code> (e.g.,
<code>digits</code> to be passed to <code>round</code> for appropriate rounding).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the columns:
</p>
<table>
<tr><td><code>ExpTests</code></td>
<td>
<p>the expected number of tests required by the optimal testing
configuration.</p>
</td></tr>
<tr><td><code>ExpTestsPerInd</code></td>
<td>
<p>the expected number of tests per individual for the optimal
testing configuration.</p>
</td></tr>
<tr><td><code>PercentReductionTests</code></td>
<td>
<p>The percent reduction in the number of tests; 100 * (1 - ExpTestsPerIndividual).</p>
</td></tr>
<tr><td><code>PercentIncreaseTestCap</code></td>
<td>
<p>The percent increase in testing capacity when the algorithm
is applied to a continuous stream of specimens; 100 * (1/ExpTestsPerIndividual - 1).</p>
</td></tr>
</table>
<p>Each row of the data frame represents an objective function specified in
the call to <code><a href="#topic+OTC1">OTC1</a></code> or <code><a href="#topic+OTC2">OTC2</a></code>.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt and Christopher R. Bilder
</p>


<h3>References</h3>

<p>Bilder, C., Iwen, P., Abdalhamid, B., Tebbs, J., McMahan, C. (2020).
&ldquo;Tests in short supply? Try group testing.&rdquo;
<em>Significance</em>, <b>17</b>, 15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res1 &lt;- OTC1(algorithm = "D2", p = 0.05, Se = 0.99, Sp = 0.99,
             group.sz = 2:100, obj.fn = c("ET", "MAR"),
             trace = TRUE)
ExpTests.OTC(res1)
</code></pre>

<hr>
<h2 id='ExpTests.Sterrett'>Extract the expected number of tests from testing configuration results</h2><span id='topic+ExpTests.Sterrett'></span>

<h3>Description</h3>

<p>Extract the expected number of tests from objects of class &quot;Sterrett&quot; returned by
<code><a href="#topic+Sterrett">Sterrett</a></code> (<kbd>Sterrett</kbd>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Sterrett'
ExpTests(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpTests.Sterrett_+3A_object">object</code></td>
<td>
<p>An object of class &quot;Sterrett&quot;, from which the expected number
of tests is to be extracted.</p>
</td></tr>
<tr><td><code id="ExpTests.Sterrett_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>ExpTests</code> (e.g.,
<code>digits</code> to be passed to <code>round</code> for appropriate rounding).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the columns:
</p>
<table>
<tr><td><code>ExpTests</code></td>
<td>
<p>the expected number of tests required to decode all individuals
in the algorithm.</p>
</td></tr>
<tr><td><code>ExpTestsPerIndividual</code></td>
<td>
<p>the expected number of tests per individual.</p>
</td></tr>
<tr><td><code>PercentReductionTests</code></td>
<td>
<p>The percent reduction in the number of tests; 100 * (1 - ExpTestsPerIndividual).</p>
</td></tr>
<tr><td><code>PercentIncreaseTestCap</code></td>
<td>
<p>The percent increase in testing capacity when the algorithm
is applied to a continuous stream of specimens; 100 * (1/ExpTestsPerIndividual - 1).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher R. Bilder
</p>


<h3>References</h3>

<p>Bilder, C., Iwen, P., Abdalhamid, B., Tebbs, J., McMahan, C. (2020).
&ldquo;Tests in short supply? Try group testing.&rdquo;
<em>Significance</em>, <b>17</b>, 15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1231)
p.vec1 &lt;- rbeta(n = 8, shape1 = 1, shape2 = 10)
save.it1 &lt;- Sterrett(p = p.vec1, Sp = 0.90, Se = 0.95)
ExpTests(save.it1)
</code></pre>

<hr>
<h2 id='ExpTests.TOD'>Extract the expected number of tests from testing configuration results</h2><span id='topic+ExpTests.TOD'></span>

<h3>Description</h3>

<p>Extract the expected number of tests from objects of class &quot;TOD&quot; returned by
<code><a href="#topic+TOD">TOD</a></code> (<kbd>TOD</kbd>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TOD'
ExpTests(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpTests.TOD_+3A_object">object</code></td>
<td>
<p>An object of class &quot;TOD&quot;, from which the expected number
of tests is to be extracted.</p>
</td></tr>
<tr><td><code id="ExpTests.TOD_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>ExpTests</code> (e.g.,
<code>digits</code> to be passed to <code>round</code> for appropriate rounding).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the columns:
</p>
<table>
<tr><td><code>ExpTests</code></td>
<td>
<p>the expected number of tests required to decode all individuals
in the algorithm.</p>
</td></tr>
<tr><td><code>ExpTestsPerIndividual</code></td>
<td>
<p>the expected number of tests per individual.</p>
</td></tr>
<tr><td><code>PercentReductionTests</code></td>
<td>
<p>The percent reduction in the number of tests; 100 * (1 - ExpTestsPerIndividual).</p>
</td></tr>
<tr><td><code>PercentIncreaseTestCap</code></td>
<td>
<p>The percent increase in testing capacity when the algorithm
is applied to a continuous stream of specimens; 100 * (1/ExpTestsPerIndividual - 1).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher R. Bilder
</p>


<h3>References</h3>

<p>Bilder, C., Iwen, P., Abdalhamid, B., Tebbs, J., McMahan, C. (2020).
&ldquo;Tests in short supply? Try group testing.&rdquo;
<em>Significance</em>, <b>17</b>, 15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1002)
p.vec &lt;- expectOrderBeta(p = 0.01, alpha = 2, size = 20)
save.it1 &lt;- TOD(p = p.vec, Se = 0.95, Sp = 0.95, max = 5, threshold = 0.015)
ExpTests(save.it1)
</code></pre>

<hr>
<h2 id='formula.gtReg'>Extract the model formula from a fitted group testing model</h2><span id='topic+formula.gtReg'></span>

<h3>Description</h3>

<p>Extract the model formula from objects of class &quot;gtReg&quot;
returned by <code><a href="#topic+gtReg">gtReg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gtReg'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.gtReg_+3A_x">x</code></td>
<td>
<p>An object of class &quot;gtReg&quot;, created by <code><a href="#topic+gtReg">gtReg</a></code>,
from which the model formula is to be extracted.</p>
</td></tr>
<tr><td><code id="formula.gtReg_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model formula extracted from the object <kbd>object</kbd>.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hivsurv)
fit1 &lt;- gtReg(formula = groupres ~ AGE * EDUC.,
              data = hivsurv, groupn = gnum,
              linkf = "probit")
formula(x = fit1)
</code></pre>

<hr>
<h2 id='GroupMembershipMatrix'>Construct a group membership matrix for hierarchical algorithms</h2><span id='topic+GroupMembershipMatrix'></span>

<h3>Description</h3>

<p>Construct a group membership matrix for two-, three-, or
four-stage hierarchical algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupMembershipMatrix(stage1, stage2 = NULL, stage3 = NULL, stage4 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GroupMembershipMatrix_+3A_stage1">stage1</code></td>
<td>
<p>the group size in stage one of testing. This also corresponds
to the number of individuals to be tested and will specify the number of
columns in the resulting group membership matrix.</p>
</td></tr>
<tr><td><code id="GroupMembershipMatrix_+3A_stage2">stage2</code></td>
<td>
<p>a vector of group sizes in stage two of testing. The group sizes
specified here should sum to the number of individuals/group size specified
in <kbd>stage1</kbd>. If <kbd>NULL</kbd>, a group membership matrix will be constructed
for a two-stage hierarchical algorithm.
Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="GroupMembershipMatrix_+3A_stage3">stage3</code></td>
<td>
<p>a vector of group sizes in stage three of testing. The group sizes
specified here should sum to the number of individuals/group size specified
in <kbd>stage1</kbd>. If group sizes are provided in <kbd>stage2</kbd> and <kbd>stage3</kbd>
is <kbd>NULL</kbd>, a group membership matrix will be constructed for a
three-stage hierarchical algorithm. Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="GroupMembershipMatrix_+3A_stage4">stage4</code></td>
<td>
<p>a vector of group sizes in stage four of testing. The group sizes
specified here should sum to the number of individuals/group size specified
in <kbd>stage1</kbd>. If group sizes are provided in <kbd>stage3</kbd> and <kbd>stage4</kbd>
is <kbd>NULL</kbd>, a group membership matrix will be constructed for a four-stage
hierarchical algorithm. Further details are given under 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function constructs a group membership matrix for two-, three-,
four-, or five-stage hierarchical algorithms. The resulting group membership
matrix has rows corresponding to the number of stages of testing and columns
corresponding to each individual to be tested. The value specified in
<kbd>stage1</kbd> corresponds to the number of individuals to be tested.
</p>
<p>For group membership matrices when only <kbd>stage1</kbd> is specified, a two-stage
hierarchical algorithm is used and the second stage will consist of individual
testing. For group membership matrices when <kbd>stage1</kbd> and <kbd>stage2</kbd> are
specified, a three-stage hierarchical algorithm is used and the third stage
will consist of individual testing. Group membership matrices for four- and
five-stage hierarchical algorithms follow a similar structure.
There should never be group sizes specified for later
stages of testing without also providing group sizes for all earlier stages
of testing (i.e., to provide group sizes for <kbd>stage3</kbd>, group sizes must
also be provided for <kbd>stage1</kbd> and <kbd>stage2</kbd>).
</p>


<h3>Value</h3>

<p>A matrix specifying the group membership for each individual. The
rows of the matrix correspond to the stages of testing and the columns of
the matrix correspond to the individuals to be tested.
</p>


<h3>Author(s)</h3>

<p>Minh Nguyen and Christopher Bilder
</p>


<h3>See Also</h3>

<p>Other operating characteristic functions: 
<code><a href="#topic+Sterrett">Sterrett</a>()</code>,
<code><a href="#topic+TOD">TOD</a>()</code>,
<code><a href="#topic+halving">halving</a>()</code>,
<code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a>()</code>,
<code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a group membership matrix for a two-stage
#   hierarchical algorithm, within the opChar1() function
#   and calculate operating characteristics
opChar1(algorithm = "D2", p = 0.0193, Se = 0.99, Sp = 0.99,
        hier.config = GroupMembershipMatrix(stage1 = 16),
        print.time = FALSE)

# Generate a group membership matrix for a five-stage
#   hierarchical algorithm and calculate the
#   operating characteristics for a two-disease assay
config.mat &lt;- GroupMembershipMatrix(stage1 = 16,
                                    stage2 = c(8,8),
                                    stage3 = c(4,4,4,4),
                                    stage4 = rep(2, times = 8))
Se &lt;- matrix(data = rep(0.95, 10), nrow = 2, ncol = 5,
             dimnames = list(Infection = 1:2, Stage = 1:5))
Sp &lt;- matrix(data = rep(0.99, 10), nrow = 2, ncol = 5,
             dimnames = list(Infection = 1:2, Stage = 1:5))
opChar2(algorithm = "D5", p.vec = c(0.92, 0.05, 0.02, 0.01),
        Se = Se, Sp = Sp, hier.config = config.mat)
</code></pre>

<hr>
<h2 id='gtPower'>Power to reject a hypothesis for one proportion in group testing</h2><span id='topic+gtPower'></span>

<h3>Description</h3>

<p>This function calculates the power to reject a hypothesis
in a group testing experiment, using confidence intervals for the
decision. This function also calculates the bias of the point estimator
for a given <code class="reqn">n</code>, <code class="reqn">s</code>, and true, unknown proportion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtPower(
  n,
  s,
  delta,
  p.hyp,
  conf.level = 0.95,
  method = "CP",
  alternative = "two.sided"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtPower_+3A_n">n</code></td>
<td>
<p>integer specifying the number of groups. A vector of integers is
also allowed.</p>
</td></tr>
<tr><td><code id="gtPower_+3A_s">s</code></td>
<td>
<p>integer specifying the common group size. A vector of integers is
also allowed.</p>
</td></tr>
<tr><td><code id="gtPower_+3A_delta">delta</code></td>
<td>
<p>the absolute difference between the true proportion and the
hypothesized proportion. A vector is also allowed.</p>
</td></tr>
<tr><td><code id="gtPower_+3A_p.hyp">p.hyp</code></td>
<td>
<p>the proportion in the hypotheses, specified as a value between
0 and 1.</p>
</td></tr>
<tr><td><code id="gtPower_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level required for the decision on the
hypotheses.</p>
</td></tr>
<tr><td><code id="gtPower_+3A_method">method</code></td>
<td>
<p>character string specifying the confidence interval method
(see <code><a href="#topic+propCI">propCI</a></code>) to be used.</p>
</td></tr>
<tr><td><code id="gtPower_+3A_alternative">alternative</code></td>
<td>
<p>character string defining the alternative hypothesis,
either <kbd>"two.sided"</kbd>, <kbd>"less"</kbd>, or <kbd>"greater"</kbd>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power of a hypothesis test performed by a confidence
interval is defined as the probability that a confidence interval
excludes the threshold parameter (<kbd>p.hyp</kbd>) of the null hypothesis,
as described in Schaarschmidt (2007). Due to discreteness, the power
does not increase monotonically for an increasing number of groups <code class="reqn">n</code>
or group size <code class="reqn">s</code>, but exhibits local maxima and minima, depending
on <code class="reqn">n</code>, <code class="reqn">s</code>, <kbd>p.hyp</kbd>, and <kbd>conf.level</kbd>.
</p>
<p>Additional to the power, the bias of the point estimator is calculated
according to Swallow (1985). If vectors are specified for <code class="reqn">n</code>,
<code class="reqn">s</code>, and (or) delta, a matrix will be constructed and power and
bias are calculated for each line in this matrix.
</p>


<h3>Value</h3>

<p>A matrix containing the following columns:
</p>
<table>
<tr><td><code>ns</code></td>
<td>
<p>a vector of the total sample size, <code class="reqn">n*s</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a vector of the number of groups.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>a vector of the group sizes.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>a vector of the delta values.</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>the power to reject the given null hypothesis.</p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p>the bias of the estimator for the specified
<code class="reqn">n</code>, <code class="reqn">s</code>, and the true proportion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function was originally written as <code>bgtPower</code> by Frank
Schaarschmidt for the <code>binGroup</code> package. Minor modifications have
been made for inclusion of the function in the <code>binGroup2</code> package.
</p>


<h3>References</h3>

<p>Schaarschmidt, F. (2007).
&ldquo;Experimental design for one-sided confidence intervals or hypothesis tests in binomial group testing.&rdquo;
<em>Communications in Biometry and Crop Science</em>, <b>2</b>, 32&ndash;40.
ISSN 1896-0782.
</p>
<p>Swallow, W. (1985).
&ldquo;Group testing for estimating infection rates and probabilities of disease transmission.&rdquo;
<em>Phytopathology</em>, <b>75</b>, 882&ndash;889.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+propCI">propCI</a></code> for confidence intervals and
<code><a href="#topic+gtTest">gtTest</a></code> for hypothesis tests for one proportion from a
group testing experiment.
</p>
<p>Other estimation functions: 
<code><a href="#topic+designEst">designEst</a>()</code>,
<code><a href="#topic+designPower">designPower</a>()</code>,
<code><a href="#topic+gtTest">gtTest</a>()</code>,
<code><a href="#topic+gtWidth">gtWidth</a>()</code>,
<code><a href="#topic+propCI">propCI</a>()</code>,
<code><a href="#topic+propDiffCI">propDiffCI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the power for the design
#   in the example given in Tebbs and Bilder(2004):
#   n=24 groups each containing 7 insects
#   if the true proportion of virus vectors
#   in the population is 0.04 (4 percent),
#   the power to reject H0: p&gt;=0.1 using an
#   upper Clopper-Pearson ("CP") confidence interval
#   is calculated with the following call:
gtPower(n = 24, s = 7, delta = 0.06, p.hyp = 0.1,
        conf.level = 0.95, alternative = "less",
        method = "CP")

# Explore development of power and bias for varying n,
#   s, and delta. How much can we decrease the number of
#   groups (costly tests to be performed) by pooling the
#   same number of 320 individuals to groups of
#   increasing size without largely decreasing power?
gtPower(n = c(320, 160, 80, 64, 40, 32, 20, 10, 5),
        s = c(1, 2, 4, 5, 8, 10, 16, 32, 64),
        delta = 0.01,  p.hyp = 0.02)

# What happens to the power for increasing differences
#   between the true proportion and the threshold
#   proportion?
gtPower(n = 50, s = 10,
        delta = seq(from = 0, to = 0.01, by = 0.001),
        p.hyp = 0.01, method = "CP")

# Calculate power with a group size of 1 (individual
#   testing).
gtPower(n = 100, s = 1,
        delta = seq(from = 0, to = 0.01, by = 0.001),
        p.hyp = 0.01, method = "CP")
</code></pre>

<hr>
<h2 id='gtReg'>Fitting group testing regression models</h2><span id='topic+gtReg'></span>

<h3>Description</h3>

<p>Fits the group testing regression model specified
through a symbolic description of the linear predictor and
descriptions of the group testing setting. This function allows
for fitting regression models with simple pooling, halving, or array
testing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtReg(
  type = "sp",
  formula,
  data,
  groupn = NULL,
  subg = NULL,
  coln = NULL,
  rown = NULL,
  arrayn = NULL,
  retest = NULL,
  sens = 1,
  spec = 1,
  linkf = c("logit", "probit", "cloglog"),
  method = c("Vansteelandt", "Xie"),
  sens.ind = NULL,
  spec.ind = NULL,
  start = NULL,
  control = gtRegControl(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtReg_+3A_type">type</code></td>
<td>
<p><kbd>"sp"</kbd> for simple pooling (Dorfman testing with
or without retests), <kbd>"halving"</kbd> for halving
protocol, or <kbd>"array"</kbd> for array testing. See 'Details' for
descriptions of the group testing algorithms.</p>
</td></tr>
<tr><td><code id="gtReg_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that
can be coerced to that class); a symbolic description of
the model to be fitted. The details of model specification
are under 'Details'.</p>
</td></tr>
<tr><td><code id="gtReg_+3A_data">data</code></td>
<td>
<p>an optional data frame, list, or environment
(or object coercible by <kbd>as.data.frame</kbd> to a data frame)
containing the variables in the model. If not found in data,
the variables are taken from <kbd>environment(formula)</kbd>,
typically the environment from which <code>gtReg</code> is called.</p>
</td></tr>
<tr><td><code id="gtReg_+3A_groupn">groupn</code></td>
<td>
<p>a vector, list, or data frame of the group
numbers that designates individuals to groups (for use with
simple pooling, <kbd>type = "sp"</kbd>, or the halving protocol,
<kbd>type = "halving"</kbd>).</p>
</td></tr>
<tr><td><code id="gtReg_+3A_subg">subg</code></td>
<td>
<p>a vector, list, or data frame of the group numbers
that designates individuals to subgroups (for use with the
halving protocol, <kbd>type = "halving"</kbd>).</p>
</td></tr>
<tr><td><code id="gtReg_+3A_coln">coln</code></td>
<td>
<p>a vector, list, or data frame that specifies the
column group number for each sample (for use with array
testing, <kbd>type = "array"</kbd>).</p>
</td></tr>
<tr><td><code id="gtReg_+3A_rown">rown</code></td>
<td>
<p>a vector, list, or data frame that specifies the
row group number for each sample (for use with array testing,
<kbd>type = "array"</kbd>).</p>
</td></tr>
<tr><td><code id="gtReg_+3A_arrayn">arrayn</code></td>
<td>
<p>a vector, list, or data frame that specifies the
array number for each sample (for use with array testing,
<kbd>type = "array"</kbd>).</p>
</td></tr>
<tr><td><code id="gtReg_+3A_retest">retest</code></td>
<td>
<p>a vector, list, or data frame of individual
retest results. Default value is <kbd>NULL</kbd> for no retests.
See 'Details' for details on how to specify <kbd>retest</kbd>.</p>
</td></tr>
<tr><td><code id="gtReg_+3A_sens">sens</code></td>
<td>
<p>sensitivity of the test. Default value is set
to 1.</p>
</td></tr>
<tr><td><code id="gtReg_+3A_spec">spec</code></td>
<td>
<p>specificity of the test. Default value is set
to 1.</p>
</td></tr>
<tr><td><code id="gtReg_+3A_linkf">linkf</code></td>
<td>
<p>a character string specifying one of the three
link functions for a binomial model: <kbd>"logit"</kbd> (default),
<kbd>"probit"</kbd>, or <kbd>"cloglog"</kbd>.</p>
</td></tr>
<tr><td><code id="gtReg_+3A_method">method</code></td>
<td>
<p>the method to fit the regression model.
Options include <kbd>"Vansteelandt"</kbd> (default) or <kbd>"Xie"</kbd>.
The <kbd>"Vansteelandt"</kbd> option finds estimates by directly
maximizing the likelihood function based on the group responses,
while the <kbd>"Xie"</kbd> option uses the EM algorithm to
maximize the likelihood function in terms of the unobserved
individual responses.</p>
</td></tr>
<tr><td><code id="gtReg_+3A_sens.ind">sens.ind</code></td>
<td>
<p>sensitivity of the individual retests. If NULL,
set to be equal to <kbd>sens</kbd>.</p>
</td></tr>
<tr><td><code id="gtReg_+3A_spec.ind">spec.ind</code></td>
<td>
<p>specificity of the individual retests. If NULL,
set to be equal to <kbd>spec</kbd>.</p>
</td></tr>
<tr><td><code id="gtReg_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the linear
predictor.</p>
</td></tr>
<tr><td><code id="gtReg_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting
process in method <kbd>"Xie"</kbd>. These parameters will be passed
to the <code><a href="#topic+gtRegControl">gtRegControl</a></code> function for use.</p>
</td></tr>
<tr><td><code id="gtReg_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+gtRegControl">gtRegControl</a></code> by
default. See argument <kbd>control</kbd>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With simple pooling and halving, a typical predictor
has the form <kbd>groupresp ~ covariates</kbd> where <kbd>groupresp</kbd>
is the (numeric) group response vector. With array testing,
individual samples are placed in a matrix-like grid where
samples are pooled within each row and within each column.
This leads to two kinds of group responses: row and column
group responses. Thus, a typical predictor has the form
<kbd>cbind(col.resp, row.resp) ~ covariates</kbd>, where
<kbd>col.resp</kbd> is the (numeric) column group response vector
and <kbd>row.resp</kbd> is the (numeric) row group response vector.
For all methods, <kbd>covariates</kbd> is a series of terms which
specifies a linear predictor for individual responses.
Note that it is actually the unobserved individual responses,
not the observed group responses, which are modeled by the
covariates. When denoting group responses (<kbd>groupresp</kbd>,
<kbd>col.resp</kbd>, and <kbd>row.resp</kbd>), a 0 denotes a negative
response and a 1 denotes a positive response, where the
probability of an individual positive response is being
modeled directly.
</p>
<p>A terms specification of the form
<kbd>first + second</kbd> indicates all the terms in <kbd>first</kbd>
together with all the terms in <kbd>second</kbd> with duplicates
removed. A specification of the form <kbd>first:second</kbd>
indicates the set of terms obtained by taking the interactions
of all terms in <kbd>first</kbd> with all terms in <kbd>second</kbd>.
The specification <kbd>first*second</kbd> indicates the cross of
<kbd>first</kbd> and <kbd>second</kbd>. This is the same as <kbd>first +
second + first:second</kbd>. The terms in the formula will be
re-ordered so that main effects come first, followed by the
interactions, all second-order, all third-order, and so on;
to avoid this, pass a terms object as the formula.
</p>
<p>For simple pooling (<kbd>type = "sp"</kbd>), the functions <kbd>gtreg.fit</kbd>,
<kbd>EM</kbd>, and <kbd>EM.ret</kbd>, where the first corresponds to Vansteelandt's
method described in Vansteelandt et al. (2000) and the last two correspond
to Xie's method described in Xie (2001), are called to carry out the
model fitting. The <kbd>gtreg.fit</kbd> function uses the <kbd>optim</kbd>
function with default method <kbd>"Nelder-Mead"</kbd> to maximize
the likelihood function of the observed group responses.
If this optimization method produces a Hessian matrix of all
zero elements, the <kbd>"SANN"</kbd> method in <kbd>optim</kbd> is
employed to find the coefficients and Hessian matrix. For
the <kbd>"SANN"</kbd> method, the number of iterations in <kbd>optim</kbd>
is set to be 10000. For the background on the use of <kbd>optim</kbd>,
see <kbd>help(optim)</kbd>.
</p>
<p>The <kbd>EM</kbd> and <kbd>EM.ret</kbd> functions apply Xie's EM
algorithm to the likelihood function written in terms of the
unobserved individual responses; the functions use <kbd>glm.fit</kbd>
to update the parameter estimates within each M step. The
<kbd>EM</kbd> function is used when there are no retests and
<kbd>EM.ret</kbd> is used when individual retests are available.
Thus, within the <kbd>retest</kbd> argument, individual observations
in observed positive groups are 0 (negative) or 1 (positive);
the remaining individual observations are <kbd>NA</kbd>s, meaning
that no retest is performed for them. Retests cannot be used
with Vansteelandt's method; a warning message will be given
in this case, and the individual retests will be ignored in
the model fitting. There could be slight differences in the
estimates between Vansteelandt's and Xie's methods (when
retests are not available) due to different convergence criteria.
</p>
<p>With simple pooling (i.e., Dorfman testing, two-stage hierarchical
testing), each individual appears in exactly one pool. When only the
group responses are observed, the null degrees of freedom are the number
of groups minus 1 and the residual degrees of freedom are the number of
groups minus the number of parameters. When individual retests are
observed too, it is an open research question for what the degrees of
freedom and the deviance for the null model should be; therefore, the
degrees of freedom and <kbd>null.deviance</kbd> will not be displayed.
</p>
<p>Under the halving protocol, the <kbd>EM.halving</kbd> function
applies Xie's EM algorithm to the
likelihood function written in terms of the unobserved
individual responses; the functions use <kbd>glm.fit</kbd> to update
the parameter estimates within each M step. In the halving
protocol, if the initial group tests positive, it is split
into two subgroups. The two subgroups are subsequently tested
and if either subgroup tests positive, the third and final
step is to test all individuals within the subgroup. Thus,
within <kbd>subg</kbd>, subgroup responses in observed positive
groups are 0 (negative) or 1 (positive); the remaining
subgroup responses are <kbd>NA</kbd>s, meaning that no tests are
performed for them. The individual retests are similarly coded.
</p>
<p>With array testing (also known as matrix pooling), the
<kbd>EM.mp</kbd> function applies Xie's
EM algorithm to the likelihood function written in terms of the
unobserved individual responses. In each E step, the Gibbs
sampling technique is used to estimate the conditional
probabilities. Because of the large number of Gibbs samples
needed to achieve convergence, the model fitting process could
be quite slow, especially when multiple positive rows and
columns are observed. In this case, we can either increase the
Gibbs sample size to help achieve convergence or loosen the
convergence criteria by increasing <kbd>tol</kbd> at the expense
of perhaps poorer estimates. If follow-up retests are performed,
the retest results going into the model will help achieve
convergence faster with the same Gibbs sample size and
convergence criteria. In each M step, we use <kbd>glm.fit</kbd> to
update the parameter estimates.
</p>
<p>For simple pooling, <kbd>retest</kbd> provides individual retest
results for Dorfman's retesting procedure. Under the halving
protocol, <kbd>retest</kbd> provides individual retest results
within a subgroup that tests positive. The <kbd>retest</kbd>
argument provides individual retest results, where a 0
denotes negative and 1 denotes positive status. An <kbd>NA</kbd>
denotes that no retest is performed for that individual.
The default value is <kbd>NULL</kbd> for no retests.
</p>
<p>For simple pooling, <kbd>control</kbd> provides parameters for
controlling the fitting process in the <kbd>"Xie"</kbd> method only.
</p>
<p><kbd>gtReg</kbd> returns an object of class <kbd>"gtReg"</kbd>.
The function <kbd>summary</kbd> (i.e., <code><a href="#topic+summary.gtReg">summary.gtReg</a></code>
is used to obtain or print a summary of the results.
The group testing function <kbd>predict</kbd> (i.e.,
<code><a href="#topic+predict.gtReg">predict.gtReg</a></code>) is used to make predictions
on <kbd>"gtReg"</kbd> objects.
</p>


<h3>Value</h3>

<p>An object of class <kbd>"gtReg"</kbd>, a list which may include:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>estimated Hessian matrix of the negative
log-likelihood function. This serves as an estimate of the
information matrix.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the response residuals. This is the difference
of the observed group responses and the fitted group
responses. Not included for array testing.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values of group responses.
Not included for array testing.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the deviance between the fitted model and the
saturated model. Not included for array testing.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>Akaike's Information Criterion. This is minus twice
the maximized log-likelihood plus twice the number of
coefficients. Not included for array testing.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the deviance for the null model,
comparable with <kbd>deviance</kbd>. The null model will
include only the intercept, if there is one in the model.
Provided for simple pooling, <kbd>type = "sp"</kbd>, only.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>the number of iterations in <kbd>optim</kbd>
(Vansteelandt's method) or the number of iterations in the
EM algorithm (Xie's method, halving, and array testing).</p>
</td></tr>
<tr><td><code>Gibbs.sample.size</code></td>
<td>
<p>the number of Gibbs samples
generated in each E step. Provided for array testing,
<kbd>type = "array"</kbd>, only.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom.
Provided for simple pooling, <kbd>type = "sp"</kbd>, only.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>the residual degrees of freedom for the null model.
Provided for simple pooling, <kbd>type = "sp"</kbd>, only.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>the vector of group responses. Not included for array testing.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the terms object used.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method (<kbd>"Vansteelandt"</kbd> or <kbd>"Xie"</kbd>)
used to fit the model. For the halving protocol, the
<kbd>"Xie"</kbd> method is used. Not included for array testing.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>the link function used in the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The majority of this function was originally written as
<kbd>gtreg.sp</kbd>, <kbd>gtreg.halving</kbd>, and <kbd>gtreg.mp</kbd> by Boan Zhang
for the <code>binGroup</code> package. Minor modifications have been made for
inclusion of the functions in the <code>binGroup2</code> package.
</p>


<h3>References</h3>

<p>Vansteelandt, S., Goetghebeur, E., Verstraeten, T. (2000).
&ldquo;Regression models for disease prevalence with diagnostic tests on pools of serum samples.&rdquo;
<em>Biometrics</em>, <b>56</b>, 1126&ndash;1133.
</p>
<p>Xie, M. (2001).
&ldquo;Regression analysis of group testing samples.&rdquo;
<em>Statistics in Medicine</em>, <b>20</b>, 1957&ndash;1969.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtSim">gtSim</a></code> for simulation of data in the
group testing form to be used by <kbd>gtReg</kbd>,
<code><a href="#topic+summary.gtReg">summary.gtReg</a></code> and <code><a href="#topic+predict.gtReg">predict.gtReg</a></code>
for <kbd>gtreg</kbd> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hivsurv)
fit1 &lt;- gtReg(type = "sp", formula  =  groupres ~ AGE + EDUC.,
              data  =  hivsurv, groupn  =  gnum, sens  =  0.9,
              spec  =  0.9, method  =  "Xie")
fit1

set.seed(46)
gt.data &lt;- gtSim(type = "sp", par = c(-12, 0.2),
                 size1 = 700, size2 = 5)
fit2 &lt;- gtReg(type = "sp", formula = gres ~ x, data = gt.data,
              groupn = groupn)
fit2

set.seed(21)
gt.data &lt;- gtSim(type = "sp", par = c(-12, 0.2),
                 size1 = 700, size2 = 6, sens = 0.95, spec = 0.95,
                 sens.ind = 0.98, spec.ind = 0.98)
fit3 &lt;- gtReg(type = "sp", formula = gres ~ x, data = gt.data,
              groupn = groupn, retest = retest, method = "Xie",
              sens = 0.95, spec = 0.95, sens.ind = 0.98,
              spec.ind = 0.98, trace = TRUE)
summary(fit3)

set.seed(46)
gt.data &lt;- gtSim(type = "halving", par = c(-6, 0.1), gshape = 17,
                 gscale = 1.4, size1 = 5000, size2 = 5,
                 sens = 0.95, spec = 0.95)
fit4 &lt;- gtReg(type = "halving", formula = gres ~ x,
              data = gt.data, groupn = groupn, subg = subgroup,
              retest = retest, sens = 0.95, spec = 0.95,
              start = c(-6, 0.1), trace = TRUE)
summary(fit4)

# 5x6 and 4x5 array
set.seed(9128)
sa1a &lt;- gtSim(type = "array", par = c(-7, 0.1), size1 = c(5, 4),
              size2 = c(6, 5), sens = 0.95, spec = 0.95)
sa1 &lt;- sa1a$dframe
fit5 &lt;- gtReg(type = "array",
              formula = cbind(col.resp, row.resp) ~ x,
              data = sa1, coln = coln, rown = rown,
              arrayn = arrayn, sens = 0.95, spec = 0.95,
              tol = 0.005, n.gibbs = 2000, trace = TRUE)
fit5
summary(fit5)

</code></pre>

<hr>
<h2 id='gtRegControl'>Auxiliary for controlling group testing regression</h2><span id='topic+gtRegControl'></span>

<h3>Description</h3>

<p>Auxiliary function to control fitting parameters
of the EM algorithm used internally in <code><a href="#topic+gtReg">gtReg</a></code>
for simple pooling (<kbd>type = "sp"</kbd>) with <kbd>method = "Xie"</kbd>
or for array testing (<kbd>type = "array"</kbd>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtRegControl(
  tol = 1e-04,
  n.gibbs = 1000,
  n.burnin = 20,
  maxit = 500,
  trace = FALSE,
  time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtRegControl_+3A_tol">tol</code></td>
<td>
<p>convergence criterion.</p>
</td></tr>
<tr><td><code id="gtRegControl_+3A_n.gibbs">n.gibbs</code></td>
<td>
<p>the Gibbs sample size to be used in each E step
of the EM algorithm, for array testing. The default is 1000.</p>
</td></tr>
<tr><td><code id="gtRegControl_+3A_n.burnin">n.burnin</code></td>
<td>
<p>the number of samples in the burn-in period,
for array testing. The default is 20.</p>
</td></tr>
<tr><td><code id="gtRegControl_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations in the EM algorithm.</p>
</td></tr>
<tr><td><code id="gtRegControl_+3A_trace">trace</code></td>
<td>
<p>a logical value indicating whether the output should
be printed for each iteration. The default is <kbd>FALSE</kbd>.</p>
</td></tr>
<tr><td><code id="gtRegControl_+3A_time">time</code></td>
<td>
<p>a logical value indicating whether the length of time
for the model fitting should be printed. The default is <kbd>TRUE</kbd>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components named as the input arguments.
</p>


<h3>Author(s)</h3>

<p>This function was originally written as the <code>gt.control</code>
function for the binGroup package. Minor modifications have been
made for inclusion in the binGroup2 package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The default settings:
gtRegControl()
</code></pre>

<hr>
<h2 id='gtSim'>Simulation function for group testing data</h2><span id='topic+gtSim'></span>

<h3>Description</h3>

<p>Simulates data in group testing form ready to be
fit by <code><a href="#topic+gtReg">gtReg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtSim(
  type = "sp",
  x = NULL,
  gshape = 20,
  gscale = 2,
  par,
  linkf = c("logit", "probit", "cloglog"),
  size1,
  size2,
  sens = 1,
  spec = 1,
  sens.ind = NULL,
  spec.ind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtSim_+3A_type">type</code></td>
<td>
<p><kbd>"sp"</kbd> for simple pooling (Dorfman testing with
or without retests), <kbd>"halving"</kbd> for
halving protocol, and <kbd>"array"</kbd> for array testing
(also known as matrix pooling).</p>
</td></tr>
<tr><td><code id="gtSim_+3A_x">x</code></td>
<td>
<p>a matrix of user-submitted covariates with which to
simulate the data. Default is <kbd>NULL</kbd>, in which case a gamma
distribution is used to generate the covariates automatically.</p>
</td></tr>
<tr><td><code id="gtSim_+3A_gshape">gshape</code></td>
<td>
<p>shape parameter for the gamma distribution. The
value must be non-negative. Default value is set to 20.</p>
</td></tr>
<tr><td><code id="gtSim_+3A_gscale">gscale</code></td>
<td>
<p>scale parameter for the gamma distribution. The
value must be strictly positive. Default value is set to 2.</p>
</td></tr>
<tr><td><code id="gtSim_+3A_par">par</code></td>
<td>
<p>the true coefficients in the linear predictor.</p>
</td></tr>
<tr><td><code id="gtSim_+3A_linkf">linkf</code></td>
<td>
<p>a character string specifying one of the three
link functions to be used: <kbd>"logit"</kbd> (default), <kbd>"probit"</kbd>, or
<kbd>"cloglog"</kbd>.</p>
</td></tr>
<tr><td><code id="gtSim_+3A_size1">size1</code></td>
<td>
<p>sample size of the simulated data (for use with
<kbd>"sp"</kbd> and <kbd>"halving"</kbd> methods) or a vector that specifies the
number of rows in each matrix (for use with <kbd>"array"</kbd> method). If
only one matrix is simulated, this value is a scalar.</p>
</td></tr>
<tr><td><code id="gtSim_+3A_size2">size2</code></td>
<td>
<p>group size in pooling individual samples (for use
with <kbd>"sp"</kbd> and <kbd>"halving"</kbd> methods) or a vector that specifies
the number of columns in each matrix (for use with <kbd>"array"</kbd> method).
If only one matrix is simulated, this value is a scalar.</p>
</td></tr>
<tr><td><code id="gtSim_+3A_sens">sens</code></td>
<td>
<p>sensitivity of the group tests. Default value is
set to 1.</p>
</td></tr>
<tr><td><code id="gtSim_+3A_spec">spec</code></td>
<td>
<p>specificity of the group tests. Default value is
set to 1.</p>
</td></tr>
<tr><td><code id="gtSim_+3A_sens.ind">sens.ind</code></td>
<td>
<p>sensitivity of the individual retests. If NULL,
set to be equal to sens.</p>
</td></tr>
<tr><td><code id="gtSim_+3A_spec.ind">spec.ind</code></td>
<td>
<p>specificity of the individual retests. If NULL,
set to be equal to spec.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates group testing data in simple pooling form
(<kbd>type = "sp"</kbd>), for the halving protocol (<kbd>type = "halving"</kbd>),
or in array testing form (<kbd>type = "array"</kbd>).
The covariates are either specified by the <kbd>x</kbd> argument or they
are generated from a gamma distribution with the given <kbd>gshape</kbd>
and <kbd>gscale</kbd> parameters. The individual probabilities are
calculated from the covariates, the coefficients given in <kbd>par</kbd>,
and the link function specified through <kbd>linkf</kbd>. The true binary
individual responses are then simulated from the individual
probabilities.
</p>
<p>Under the matrix pooling protocol (<kbd>type = "array"</kbd>),
the individuals are first organized into (by column) one or more matrices
specified by the number of rows (<kbd>size1</kbd>) and the number of columns
(<kbd>size2</kbd>).
</p>
<p>Then, for all pooling protocols, the true group responses are found
from the individual responses within groups or within rows/columns for
matrix pooling (i.e., if at least one response is positive, the group is
positive; otherwise, the group response is negative).
Finally, the observed group (<kbd>method = "sp"</kbd>) and subgroup
<kbd>method = "halving"</kbd> only), or row and column responses
<kbd>method = "array"</kbd> are simulated using the given <kbd>sens</kbd> and
<kbd>spec</kbd>.
</p>
<p>For the simple pooling and halving protocols, individual retests are
simulated from <kbd>sens.ind</kbd> and <kbd>spec.ind</kbd> for samples in observed
positive groups. Note that with a given group size (specified by <kbd>size2</kbd>
with <kbd>method = "sp"</kbd> or <kbd>method = "halving"</kbd>), the last group may
have fewer individuals.
For the matrix pooling protocol, individual retests are simulated from
<kbd>sens.ind</kbd> and <kbd>spec.ind</kbd> for individuals that lie on the
intersection of an observed positive row and and observed positive column.
In the case where no column (row) tests positive in a matrix, all the
individuals in any observed positive rows (columns) will be assigned a
simulated retest result. If no column or row is observed positive, NULL is
returned.
</p>


<h3>Value</h3>

<p>For simple pooling (<kbd>type = "sp"</kbd>) and the halving
protocol (<kbd>type = "halving"</kbd>), a data frame or for array
testing (<kbd>type = "array"</kbd>), a list, which may include the following:
</p>
<table>
<tr><td><code>gres</code></td>
<td>
<p>the group response, for simple pooling and the halving
protocol only.</p>
</td></tr>
<tr><td><code>col.resp</code></td>
<td>
<p>the column group response, for array testing only.</p>
</td></tr>
<tr><td><code>row.resp</code></td>
<td>
<p>the row group response, for array testing only.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the covariate.</p>
</td></tr>
<tr><td><code>groupn</code></td>
<td>
<p>the group number, for simple pooling and the halving
protocol only.</p>
</td></tr>
<tr><td><code>arrayn</code></td>
<td>
<p>the array number, for array testing only.</p>
</td></tr>
<tr><td><code>coln</code></td>
<td>
<p>the column group number, for array testing only.</p>
</td></tr>
<tr><td><code>rown</code></td>
<td>
<p>the row group number, for array testing only.</p>
</td></tr>
<tr><td><code>ind</code></td>
<td>
<p>the true individual responses. For simple pooling and the
halving protocol, these are included in the data frame of results.
For array testing, these are included in the list of results, with
individual responses presented in matrices.</p>
</td></tr>
<tr><td><code>retest</code></td>
<td>
<p>the results of individual retests.</p>
</td></tr>
<tr><td><code>subgroup</code></td>
<td>
<p>the subgroup number, for the halving protocol.</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>the individual probabilities, for array testing only.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function is a combination of <kbd>sim.gt</kbd>, <kbd>sim.halving</kbd>,
and <kbd>sim.mp</kbd> written by Boan Zhang for the <code>binGroup</code> package.
Minor modifications have been made for inclusion of the functions in the
<code>binGroup2</code> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtReg">gtReg</a></code> to fit simulated group testing data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(46)
gt.data &lt;- gtSim(type = "sp", par = c(-12, 0.2),
                 size1 = 700, size2 = 5)

x1 &lt;- sort(runif(100, 0, 30))
x2 &lt;- rgamma(100, shape = 17, scale = 1.5)
gt.data &lt;- gtSim(type = "sp", x = cbind(x1, x2),
                 par = c(-14, 0.2, 0.3), size2 = 4,
                 sens = 0.98, spec = 0.98)

set.seed(46)
gt.data &lt;- gtSim(type = "halving", par = c(-6, 0.1),
                 gshape = 17, gscale = 1.4, size1 = 5000,
                 size2 = 5, sens = 0.95, spec = 0.95)

# 5x6 and 4x5 matrix
set.seed(9128)
sa1a &lt;- gtSim(type = "array", par = c(-7, 0.1),
              size1 = c(5, 4), size2 = c(6, 5),
              sens = 0.95, spec = 0.95)
sa1a$dframe
</code></pre>

<hr>
<h2 id='gtTest'>Hypothesis test for one proportion in group testing</h2><span id='topic+gtTest'></span>

<h3>Description</h3>

<p>Calculates p-values for hypothesis tests of
single proportions estimated from group testing
experiments against a threshold proportion
in the hypotheses. Available methods include the exact test,
score test, and Wald test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtTest(n, y, s, p.hyp, alternative = "two.sided", method = "exact")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtTest_+3A_n">n</code></td>
<td>
<p>integer specifying the number of groups.</p>
</td></tr>
<tr><td><code id="gtTest_+3A_y">y</code></td>
<td>
<p>integer specifying the number of positive groups.</p>
</td></tr>
<tr><td><code id="gtTest_+3A_s">s</code></td>
<td>
<p>integer specifying the common size of groups.</p>
</td></tr>
<tr><td><code id="gtTest_+3A_p.hyp">p.hyp</code></td>
<td>
<p>the hypothetical threshold proportion against which to test,
specified as a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="gtTest_+3A_alternative">alternative</code></td>
<td>
<p>character string defining the alternative
hypothesis, either <kbd>"two.sided"</kbd>, <kbd>"less"</kbd>, or <kbd>"greater"</kbd>.</p>
</td></tr>
<tr><td><code id="gtTest_+3A_method">method</code></td>
<td>
<p>character string defining the test method to be
used. Options include &quot;exact&quot; for an exact test corresponding
to the Clopper-Pearson confidence interval, &quot;score&quot; for a score
test corresponding to the Wilson confidence interval, and &quot;Wald&quot;
for a Wald test corresponding to the Wald confidence interval.
The Wald method is not recommended. The &quot;exact&quot; method uses
<code>binom.test{stats}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes equal group sizes, no testing error
(i.e., 100 percent sensitivity and specificity) to test the groups, and
individual units randomly assigned to the groups with identical true
probability of success.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated proportion</p>
</td></tr>
<tr><td><code>p.hyp</code></td>
<td>
<p>the threshold proportion provided by the user.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>the alternative provided by the user.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the test method provided by the user.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function was originally written as <code>bgtTest</code> by Frank
Schaarschmidt for the <code>binGroup</code> package. Minor modifications have
been made for inclusion of the function in the <code>binGroup2</code> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+propCI">propCI</a></code> for confidence intervals in
group testing and <code>binom.test(stats)</code> for the
exact test and corresponding confidence interval.
</p>
<p>Other estimation functions: 
<code><a href="#topic+designEst">designEst</a>()</code>,
<code><a href="#topic+designPower">designPower</a>()</code>,
<code><a href="#topic+gtPower">gtPower</a>()</code>,
<code><a href="#topic+gtWidth">gtWidth</a>()</code>,
<code><a href="#topic+propCI">propCI</a>()</code>,
<code><a href="#topic+propDiffCI">propDiffCI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider the following the experiment: Tests are
#   performed on n=10 groups, each group has a size
#   of s=100 individuals. The aim is to show that less
#   than 0.5 percent (\eqn{p &lt; 0.005}) of the units in
#   the population show a detrimental trait (positive test).
#   y=1 positive test and 9 negative tests are observed.
gtTest(n = 10, y = 1, s = 100, p.hyp = 0.005,
       alternative = "less", method = "exact")

# The exact test corresponds to the
#   limits of the Clopper-Pearson confidence interval
#   in the example of Tebbs &amp; Bilder (2004):
gtTest(n = 24, y = 3, s = 7, alternative = "two.sided",
       method = "exact", p.hyp = 0.0543)

gtTest(n = 24, y = 3, s = 7, alternative = "two.sided",
       method = "exact", p.hyp = 0.0038)

# Hypothesis test with a group size of 1.
gtTest(n = 24, y = 3, s = 1, alternative = "two.sided",
       method = "exact", p.hyp = 0.1)

# Further methods:
gtTest(n = 24, y = 3, s = 7, alternative = "two.sided",
       method = "score", p.hyp = 0.0516)

gtTest(n = 24, y = 3, s = 7, alternative = "two.sided",
       method = "Wald", p.hyp = 0.0401)
</code></pre>

<hr>
<h2 id='gtWidth'>Expected width of confidence intervals in group testing</h2><span id='topic+gtWidth'></span>

<h3>Description</h3>

<p>Calculation of the expected value of the width of
confidence intervals for one proportion in group testing. Calculations
are available for the confidence interval methods in <code><a href="#topic+propCI">propCI</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtWidth(n, s, p, conf.level = 0.95, alternative = "two.sided", method = "CP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtWidth_+3A_n">n</code></td>
<td>
<p>integer specifying the number of groups. A vector of
integers is also allowed.</p>
</td></tr>
<tr><td><code id="gtWidth_+3A_s">s</code></td>
<td>
<p>integer specifying the common size of groups. A vector
of integers is also allowed.</p>
</td></tr>
<tr><td><code id="gtWidth_+3A_p">p</code></td>
<td>
<p>the assumed true proportion of individuals showing
the trait to be estimated. A vector is also allowed.</p>
</td></tr>
<tr><td><code id="gtWidth_+3A_conf.level">conf.level</code></td>
<td>
<p>the required confidence level of the interval.</p>
</td></tr>
<tr><td><code id="gtWidth_+3A_alternative">alternative</code></td>
<td>
<p>character string specifying the alternative
hypothesis, either <kbd>"two.sided"</kbd>, <kbd>"less"</kbd>, or <kbd>"greater"</kbd>.</p>
</td></tr>
<tr><td><code id="gtWidth_+3A_method">method</code></td>
<td>
<p>character string specifying the confidence
interval method. Available options include those in <code><a href="#topic+propCI">propCI</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two-sided (<kbd>alternative="two.sided"</kbd>) option calculates the
expected width between the lower and upper bound of a two-sided
<code class="reqn">conf.level*100</code> percent confidence interval. See Tebbs &amp; Bilder (2004)
for expression. The one-sided (<kbd>alternative="less"</kbd> or
<kbd>alternative="greater"</kbd>) options calculate the expected distance between the
one-sided limit and the assumed true proportion <kbd>p</kbd> for a one-sided
<code class="reqn">conf.level*100</code> percent confidence interval.
</p>


<h3>Value</h3>

<p>A matrix containing the columns:
</p>
<table>
<tr><td><code>ns</code></td>
<td>
<p>the resulting total number of units, <code class="reqn">n*s</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of groups.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>the group size.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the assumed true proportion.</p>
</td></tr>
<tr><td><code>expCIWidth</code></td>
<td>
<p>the expected value of the confidence
interval width as defined under the argument <kbd>alternative</kbd>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function was originally written as <code>bgtWidth</code> by Frank
Schaarschmidt for the <code>binGroup</code> package. Minor modifications have
been made for inclusion of the function in the <code>binGroup2</code> package.
</p>


<h3>References</h3>

<p>Tebbs, J., Bilder, C. (2004).
&ldquo;Confidence interval procedures for the probability of disease transmission in multiple-vector-transfer designs.&rdquo;
<em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>9</b>, 75&ndash;90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+propCI">propCI</a></code> for confidence intervals in
group testing.
</p>
<p>Other estimation functions: 
<code><a href="#topic+designEst">designEst</a>()</code>,
<code><a href="#topic+designPower">designPower</a>()</code>,
<code><a href="#topic+gtPower">gtPower</a>()</code>,
<code><a href="#topic+gtTest">gtTest</a>()</code>,
<code><a href="#topic+propCI">propCI</a>()</code>,
<code><a href="#topic+propDiffCI">propDiffCI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examine different group sizes to determine
#   the shortest expected width.
gtWidth(n = 20, s = seq(from = 1, to = 200, by = 10),
        p = 0.01, alternative = "less", method = "CP")

# Calculate the expected width of the confidence
#   interval with a group size of 1 (individual testing).
gtWidth(n = 20, s = 1, p = 0.005, alternative = "less", method = "CP")
</code></pre>

<hr>
<h2 id='halving'>Probability mass function for halving</h2><span id='topic+halving'></span>

<h3>Description</h3>

<p>Calculate the probability mass function for the number of tests
from using the halving algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>halving(p, Se = 1, Sp = 1, stages = 2, order.p = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="halving_+3A_p">p</code></td>
<td>
<p>a vector of individual risk probabilities.</p>
</td></tr>
<tr><td><code id="halving_+3A_se">Se</code></td>
<td>
<p>sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="halving_+3A_sp">Sp</code></td>
<td>
<p>specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="halving_+3A_stages">stages</code></td>
<td>
<p>the number of stages for the halving algorithm.</p>
</td></tr>
<tr><td><code id="halving_+3A_order.p">order.p</code></td>
<td>
<p>logical; if TRUE, the vector of individual risk probabilities
will be sorted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Halving algorithms involve successively splitting a positive
testing group into two equal-sized halves (or as close to equal as possible)
until all individuals have been identified as positive or negative.
<code class="reqn">S</code>-stage halving begins by testing the whole group of <code class="reqn">I</code>
individuals. Positive groups are split in half until the final stage of the
algorithm, which consists of individual testing. For example, consider an
initial group of size <code class="reqn">I=16</code> individuals. Three-stage halving (3H)
begins by testing the whole group of 16 individuals. If this group tests
positive, the second stage involves splitting into two groups of size 8.
If either of these groups test positive, a third stage involves testing each
individual rather than halving again. Four-stage halving (4H) would continue
with halving into groups of size 4 before individual testing. Five-stage
halving (5H) would continue with halving into groups of size 2 before
individual testing. 3H requires more than 2 individuals, 4H requires more
than 4 individuals, and 5H requires more than 8 individuals.
</p>
<p>This function calculates the probability mass function, expected testing
expenditure, and variance of the testing expenditure for halving algorithms
with 3 to 5 stages.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>pmf</code></td>
<td>
<p>the probability mass function for the halving algorithm.</p>
</td></tr>
<tr><td><code>et</code></td>
<td>
<p>the expected testing expenditure for the halving algorithm.</p>
</td></tr>
<tr><td><code>vt</code></td>
<td>
<p>the variance of the testing expenditure for the halving
algorithm.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a vector containing the probabilities of positivity for each individual.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function was originally written by Michael Black for Black
et al. (2012). The function was obtained from
<a href="http://chrisbilder.com/grouptesting/">http://chrisbilder.com/grouptesting/</a>. Minor modifications have been
made for inclusion of the function in the <code>binGroup2</code> package.
</p>


<h3>References</h3>

<p>Black, M., Bilder, C., Tebbs, J. (2012).
&ldquo;Group testing in heterogeneous populations by using halving algorithms.&rdquo;
<em>Journal of the Royal Statistical Society. Series C: Applied Statistics</em>, <b>61</b>, 277&ndash;290.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectOrderBeta">expectOrderBeta</a></code> for generating a vector of individual risk
probabilities for informative group testing.
</p>
<p>Other operating characteristic functions: 
<code><a href="#topic+GroupMembershipMatrix">GroupMembershipMatrix</a>()</code>,
<code><a href="#topic+Sterrett">Sterrett</a>()</code>,
<code><a href="#topic+TOD">TOD</a>()</code>,
<code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a>()</code>,
<code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Equivalent to Dorfman testing (two-stage hierarchical)
halving(p = rep(0.01, 10), Se = 1, Sp = 1, stages = 2,
        order.p = TRUE)

# Halving over three stages; each individual has a
#   different probability of being positive
set.seed(12895)
p.vec &lt;- expectOrderBeta(p = 0.05, alpha = 2, size = 20)
halving(p = p.vec, Se = 0.95, Sp = 0.95, stages = 3,
        order.p = TRUE)
</code></pre>

<hr>
<h2 id='hivsurv'>Data from an HIV surveillance project</h2><span id='topic+hivsurv'></span>

<h3>Description</h3>

<p>The <kbd>hivsurv</kbd> data set comes from an HIV surveillance project discussed in Verstraeten et al. (1998) and Vansteelandt et al. (2000). The purpose of the study was to estimate the HIV prevalence among pregnant Kenyan women in four rural locations of the country, using both individual and group testing responses. Blood tests were administered to each participating woman, and 4 covariates were obtained on each woman. Because the original group responses are unavailable, individuals are artificially put into groups of 5 here to form group responses. Only the 428 complete observations are given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hivsurv)</code></pre>


<h3>Format</h3>

<p>A data frame with 428 observations on the following 8 variables.
</p>

<dl>
<dt><code>DATE</code></dt><dd><p>the date when each sample was collected.</p>
</dd>
<dt><code>PAR.</code></dt><dd><p>parity (number of children).</p>
</dd>
<dt><code>AGE</code></dt><dd><p>age (in years).</p>
</dd>
<dt><code>MA.ST.</code></dt><dd><p>marital status (1: single; 2: married (polygamous); 3: married (monogamous); 4: divorced; 5: widow).</p>
</dd>
<dt><code>EDUC.</code></dt><dd><p>highest attained education level (1: no schooling; 2: primary school; 3: secondary school; 4: higher).</p>
</dd>
<dt><code>HIV</code></dt><dd><p>individual response of HIV diagnosis (0: negative; 1: positive).</p>
</dd>
<dt><code>gnum</code></dt><dd><p>the group number that designates individuals into groups.</p>
</dd>
<dt><code>groupres</code></dt><dd><p>the group response calculated from artificially formed groups.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Vansteelandt, S., Goetghebeur, E., Verstraeten, T. (2000).
&ldquo;Regression models for disease prevalence with diagnostic tests on pools of serum samples.&rdquo;
<em>Biometrics</em>, <b>56</b>, 1126&ndash;1133.
</p>
<p>Verstraeten, T., Farah, B., Duchateau, L., Matu, R. (1998).
&ldquo;Pooling sera to reduce the cost of HIV surveillance: a feasibility study in a rural Kenyan district.&rdquo;
<em>Tropical Medicine &amp; International Health</em>, <b>3</b>, 747&ndash;750.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hivsurv)

str(hivsurv)

</code></pre>

<hr>
<h2 id='IndProb'>Extract the individual probabilities used to calculate group testing
results</h2><span id='topic+IndProb'></span>

<h3>Description</h3>

<p>Extract the individual probabilities from objects of class
&quot;opchar&quot; returned by <code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code> (<kbd>opChar1</kbd>)
or <code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code> (<kbd>opChar2</kbd>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IndProb(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IndProb_+3A_object">object</code></td>
<td>
<p>An object of class &quot;opChar&quot;, from which the individual
probabilities are to be extracted.</p>
</td></tr>
<tr><td><code id="IndProb_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>IndProb</code> (e.g.,
<code>digits</code> to be passed to <code>signif</code> for appropriate
rounding).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either <kbd>p.vec</kbd>, the sorted vector of individual probabilities
(for hierarchical group testing algorithms) or <kbd>p.mat</kbd>, the sorted
matrix of individual probabilities in gradient arrangement (for array
testing algorithms). Further details are given under the 'Details' section
for the <code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code> (<kbd>opChar1</kbd>)
or <code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code> (<kbd>opChar2</kbd>) functions.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>config.mat &lt;- matrix(data = c(rep(1, 10), 1:10),
                     nrow = 2, ncol = 10, byrow = TRUE)
res1 &lt;- opChar1(algorithm = "D2", p = 0.05, Se = 0.99, Sp = 0.99,
        hier.config = config.mat)
IndProb(res1)

config.mat &lt;- matrix(data = c(rep(1, 20), rep(1, 10), rep(2, 10),
                             rep(c(1, 2, 3, 4), each = 5),
                             rep(1, 3), rep(2, 2), rep(3, 3),
                             rep(4, 2), rep(5, 3), rep(6, 2),
                             rep(7, 3), rep(8, 2), 1:20),
                    nrow = 5, ncol = 20, byrow = TRUE)
Se &lt;- matrix(data = rep(0.95, 10), nrow = 2, ncol = 5,
             dimnames = list(Infection = 1:2, Stage = 1:5))
Sp &lt;- matrix(data = rep(0.99, 10), nrow = 2, ncol = 5,
             dimnames = list(Infection = 1:2, Stage = 1:5))
res2 &lt;- opChar2(algorithm = "ID5",
                alpha = c(18.25, 0.75, 0.75, 0.25),
                Se = Se, Sp = Sp, hier.config = config.mat)
IndProb(res2)
</code></pre>

<hr>
<h2 id='informativeArrayProb'>Arrange a matrix of probabilities for informative array testing</h2><span id='topic+informativeArrayProb'></span>

<h3>Description</h3>

<p>Arrange a vector of individual risk probabilities in a matrix
for informative array testing without master pooling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>informativeArrayProb(prob.vec, nr, nc, method = "sd")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="informativeArrayProb_+3A_prob.vec">prob.vec</code></td>
<td>
<p>vector of individual risk probabilities, of length nr * nc.</p>
</td></tr>
<tr><td><code id="informativeArrayProb_+3A_nr">nr</code></td>
<td>
<p>number of rows in the array.</p>
</td></tr>
<tr><td><code id="informativeArrayProb_+3A_nc">nc</code></td>
<td>
<p>number of columns in the array.</p>
</td></tr>
<tr><td><code id="informativeArrayProb_+3A_method">method</code></td>
<td>
<p>character string defining the method to be used for matrix
arrangement. Options include spiral (&quot;<kbd>sd</kbd>&quot;) and gradient (&quot;<kbd>gd</kbd>&quot;)
arrangement. See McMahan et al. (2012) for additional details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of probabilities arranged according to the specified
method.
</p>


<h3>Author(s)</h3>

<p>This function was originally written by Christopher McMahan for
McMahan et al. (2012). The function was obtained from
<a href="http://chrisbilder.com/grouptesting/">http://chrisbilder.com/grouptesting/</a>.
</p>


<h3>References</h3>

<p>McMahan, C., Tebbs, J., Bilder, C. (2012b).
&ldquo;Two-Dimensional Informative Array Testing.&rdquo;
<em>Biometrics</em>, <b>68</b>, 793&ndash;804.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectOrderBeta">expectOrderBeta</a></code> for generating a vector of individual risk
probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the gradient arrangement method to create a matrix
#   of individual risk probabilities for a 10x10 array.
# Depending on the specified probability, alpha level,
#   and overall group size, simulation may be necessary
#   in order to generate the vector of individual
#   probabilities. This is done using the expectOrderBeta()
#   function and requires the user to set a seed in order
#   to reproduce results.
set.seed(1107)
p.vec1 &lt;- expectOrderBeta(p = 0.05, alpha = 2, size = 100)
informativeArrayProb(prob.vec = p.vec1, nr = 10, nc = 10,
                     method = "gd")

# Use the spiral arrangement method to create a matrix
#   of individual risk probabilities for a 5x5 array.
set.seed(8791)
p.vec2 &lt;- expectOrderBeta(p = 0.02, alpha = 0.5, size = 25)
informativeArrayProb(prob.vec = p.vec2, nr = 5, nc = 5,
                     method = "sd")
</code></pre>

<hr>
<h2 id='operatingCharacteristics1'>Calculate operating characteristics for group testing algorithms
that use a single-disease assay</h2><span id='topic+operatingCharacteristics1'></span><span id='topic+opChar1'></span>

<h3>Description</h3>

<p>Calculate operating characteristics, such as the expected
number of tests, for a specified testing configuration using
non-informative and informative hierarchical and array-based group testing
algorithms. Single-disease assays are used at each stage of the algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>operatingCharacteristics1(
  algorithm,
  p = NULL,
  probabilities = NULL,
  Se = 0.99,
  Sp = 0.99,
  hier.config = NULL,
  rowcol.sz = NULL,
  alpha = 2,
  a = NULL,
  print.time = TRUE,
  ...
)

opChar1(
  algorithm,
  p = NULL,
  probabilities = NULL,
  Se = 0.99,
  Sp = 0.99,
  hier.config = NULL,
  rowcol.sz = NULL,
  alpha = 2,
  a = NULL,
  print.time = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="operatingCharacteristics1_+3A_algorithm">algorithm</code></td>
<td>
<p>character string defining the group testing algorithm to be
used. Non-informative testing options include two-stage hierarchical
(&quot;<kbd>D2</kbd>&quot;), three-stage hierarchical (&quot;<kbd>D3</kbd>&quot;), four-stage hierarchical
(&quot;<kbd>D4</kbd>&quot;), square array testing without master pooling (&quot;<kbd>A2</kbd>&quot;), and
square array testing with master pooling (&quot;<kbd>A2M</kbd>&quot;). Informative testing
options include two-stage hierarchical (&quot;<kbd>ID2</kbd>&quot;), three-stage
hierarchical (&quot;<kbd>ID3</kbd>&quot;), four-stage hierarchical (&quot;<kbd>ID4</kbd>&quot;), and
square array testing without master pooling (&quot;<kbd>IA2</kbd>&quot;).</p>
</td></tr>
<tr><td><code id="operatingCharacteristics1_+3A_p">p</code></td>
<td>
<p>overall probability of disease that will be used to generate a
vector/matrix of individual probabilities. For non-informative algorithms,
a homogeneous set of probabilities will be used. For informative algorithms,
the <code><a href="#topic+expectOrderBeta">expectOrderBeta</a></code> function will be used to generate a
heterogeneous set of probabilities. Further details are given under
'Details'. Either <kbd>p</kbd> or <kbd>probabilities</kbd> should be specified, but
not both.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics1_+3A_probabilities">probabilities</code></td>
<td>
<p>a vector of individual probabilities, which is
homogeneous for non-informative testing algorithms and heterogeneous for
informative testing algorithms. Either  <kbd>p</kbd> or <kbd>probabilities</kbd>
should be specified, but not both.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics1_+3A_se">Se</code></td>
<td>
<p>a vector of sensitivity values, where one value is given for each
stage of testing (in order). If a single value is provided, sensitivity
values are assumed to be equal to this value for all stages of testing.
Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics1_+3A_sp">Sp</code></td>
<td>
<p>a vector of specificity values, where one value is given for each
stage of testing (in order). If a single value is provided, specificity
values are assumed to be equal to this value for all stages of testing.
Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics1_+3A_hier.config">hier.config</code></td>
<td>
<p>a matrix specifying the configuration for a hierarchical
testing algorithm. The rows correspond to the stages of testing, the columns
correspond to each individual to be tested, and the cell values
specify the group number of each individual at each stage. Further details
are given under 'Details'. For array testing algorithms, this argument will
be ignored.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics1_+3A_rowcol.sz">rowcol.sz</code></td>
<td>
<p>the row/column size for array testing algorithms. For
hierarchical testing algorithms, this argument will be ignored.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics1_+3A_alpha">alpha</code></td>
<td>
<p>a shape parameter for the beta distribution that specifies the
degree of heterogeneity for the generated probability vector (for
informative testing only).</p>
</td></tr>
<tr><td><code id="operatingCharacteristics1_+3A_a">a</code></td>
<td>
<p>a vector containing indices indicating which individuals to
calculate individual accuracy measures for. If <kbd>NULL</kbd>, individual
accuracy measures will be displayed for all individuals in the algorithm.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics1_+3A_print.time">print.time</code></td>
<td>
<p>a logical value indicating whether the length of time
for calculations should be printed. The default is <kbd>TRUE</kbd>.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics1_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the <code><a href="#topic+expectOrderBeta">expectOrderBeta</a></code>
function, which generates a vector of probabilities for informative testing
algorithms. Further details are given under 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the operating characteristics for
group testing algorithms with an assay that tests for one disease, as
described in Hitt et al. (2019).
</p>
<p>Available algorithms include two-, three-, and four-stage hierarchical
testing and array testing with and without master pooling. Both
non-informative and informative group testing settings are allowed for each
algorithm, except informative array testing with master pooling is
unavailable because this method has not appeared in the group testing
literature. Operating characteristics calculated are expected number of
tests, pooling sensitivity, pooling specificity, pooling positive predictive
value, and pooling negative predictive value for each individual.
</p>
<p>For informative algorithms where the <kbd>p</kbd> argument is specified, the
expected value of order statistics from a beta distribution are found.
These values are used to represent disease risk probabilities for each
individual to be tested. The beta distribution has two parameters: a mean
parameter <kbd>p</kbd> (overall disease prevalence) and a shape parameter
<kbd>alpha</kbd> (heterogeneity level). Depending on the specified <kbd>p</kbd>,
<kbd>alpha</kbd>, and overall group size, simulation may be necessary to
generate the vector of individual probabilities. This is done using
<code><a href="#topic+expectOrderBeta">expectOrderBeta</a></code> and requires the user to set a seed to
reproduce results.
</p>
<p>The sensitivity/specificity values are allowed to vary across stages of
testing. For hierarchical testing, a different sensitivity/specificity value
may be used for each stage of testing. For array testing, a different
sensitivity/specificity value may be used for master pool testing (if
included), row/column testing, and individual testing. The values must be
specified in order of the testing performed. For example, values are
specified as (stage 1, stage 2, stage 3) for three-stage hierarchical
testing or (master pool testing, row/column testing, individual testing) for
array testing with master pooling. A single sensitivity/specificity value
may be specified instead. In this situation, sensitivity/specificity values
for all stages are assumed to be equal.
</p>
<p>The matrix specified  by <kbd>hier.config</kbd> defines the hierarchical group
testing algorithm for <code class="reqn">I</code> individuals. The rows of the matrix
correspond to the stages <code class="reqn">s=1,...,S</code> in the testing algorithm, and the
columns correspond to individuals <code class="reqn">i=1,...I</code>. The cell values within
the matrix represent the group number of individual <code class="reqn">i</code> at stage
<code class="reqn">s</code>. For three-stage, four-stage, and non-informative two-stage
hierarchical testing, the first row of the matrix consists of all ones.
This indicates that all individuals in the algorithm are tested together in
a single group in the first stage of testing. For informative two-stage
hierarchical testing, the initial group (block) is not tested. Thus, the
first row of the matrix consists of the group numbers for each individual
in the first stage of testing. For all hierarchical algorithms, the final
row of the matrix denotes individual testing. Individuals who are not tested
in a particular stage are represented by &quot;NA&quot; (e.g., an individual tested
in a group of size 1 in the second stage of testing would not be tested
again in a third stage of testing). It is important to note that this
matrix represents the testing that could be performed if each group tests
positively at each stage prior to the last. For more details on this matrix
(called a group membership matrix), see Bilder et al. (2019).
</p>
<p>For array testing without master pooling, the <kbd>rowcol.sz</kbd> specified
represents the row/column size for initial (stage 1) testing. For array
testing with master pooling, the <kbd>rowcol.sz</kbd> specified represents the
row/column size for stage 2 testing. This is because the master pool size
is the overall array size, given by the square of the row/column size.
</p>
<p>The displayed overall pooling sensitivity, pooling specificity, pooling
positive predictive value, and pooling negative predictive value are
weighted averages of the corresponding individual accuracy measures for all
individuals within the initial group (or block) for a hierarchical
algorithm, or within the entire array for an array-based algorithm.
Expressions for these averages are provided in the Supplementary
Material for Hitt et al. (2019). These expressions are based on accuracy
definitions given by Altman and Bland (1994a, 1994b).
</p>
<p>The <kbd>operatingCharacteristics1</kbd> function accepts additional arguments,
namely <kbd>num.sim</kbd>, to be passed to the <code><a href="#topic+expectOrderBeta">expectOrderBeta</a></code>
function, which generates a vector of probabilities for informative group
testing algorithms. The <kbd>num.sim</kbd> argument specifies the number of
simulations from the beta distribution when simulation is used. By default,
10,000 simulations are used.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>algorithm</code></td>
<td>
<p>the group testing algorithm used for calculations.</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>the probability of disease or the vector of individual
probabilities, as specified by the user.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>level of heterogeneity for the generated probability vector
(for informative testing only).</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the vector of sensitivity values for each stage of testing.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the vector of specificity values for each stage of testing.</p>
</td></tr>
<tr><td><code>Config</code></td>
<td>
<p>a list specifying elements of the specified testing
configuration, which may include:
</p>

<dl>
<dt>Stage1</dt><dd><p>group size for the first stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Stage2</dt><dd><p>group sizes for the second stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Stage3</dt><dd><p>group sizes for the third stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Block.sz</dt><dd><p>the block size/initial group size for informative Dorfman
testing, which is not tested.</p>
</dd>
<dt>pool.szs</dt><dd><p>group sizes for the first stage of testing for informative
Dorfman testing.</p>
</dd>
<dt>Array.dim</dt><dd><p>the row/column size for array testing.</p>
</dd>
<dt>Array.sz</dt><dd><p>the overall array size for array testing (the square of the
row/column size).</p>
</dd></dl>
</td></tr>
<tr><td><code>p.vec</code></td>
<td>
<p>the sorted vector of individual probabilities, if applicable.</p>
</td></tr>
<tr><td><code>p.mat</code></td>
<td>
<p>the sorted matrix of individual probabilities in gradient
arrangement, if applicable. Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code>ET</code></td>
<td>
<p>the expected testing expenditure to decode all individuals in the
algorithm; this includes all individuals in all groups for hierarchical
algorithms or in the entire array for array testing.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the value of the expected number of tests per individual.</p>
</td></tr>
<tr><td><code>Accuracy</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>Individual</dt><dd><p>a matrix of accuracy measures for each individual
specified in <kbd>a</kbd>. The rows correspond to each unique set of accuracy
measures in the algorithm. Individuals with the same set of accuracy
measures are displayed together in a single row of the matrix. The columns
correspond to the pooling sensitivity, pooling specificity, pooling
positive predictive value, pooling negative predictive value, and the
indices for the individuals in each row of the matrix.</p>
</dd>
<dt>Overall</dt><dd><p>a matrix of overall accuracy measures for the algorithm.
The columns correspond to the pooling sensitivity, pooling specificity,
pooling positive predictive value, and pooling negative predictive value
for the overall algorithm. Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
</table>


<h3>Note</h3>

<p>This function returns the pooling positive and negative
predictive values for all individuals even though these measures are
diagnostic specific; e.g., the pooling positive predictive value should
only be considered for those individuals who have tested positive.
</p>
<p>Additionally, only stage dependent sensitivity and specificity values are
allowed within the program (no group within stage dependent values are
allowed). See Bilder et al. (2019) for additional information.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: Sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: Predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Bilder, C., Tebbs, J., McMahan, C. (2019).
&ldquo;Informative group testing for multiplex assays.&rdquo;
<em>Biometrics</em>, <b>75</b>, 278&ndash;288.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019).
&ldquo;The objective function controversy for group testing: Much ado about nothing?&rdquo;
<em>Statistics in Medicine</em>, <b>38</b>, 4912&ndash;4923.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012a).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>, 287&ndash;296.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012b).
&ldquo;Two-Dimensional Informative Array Testing.&rdquo;
<em>Biometrics</em>, <b>68</b>, 793&ndash;804.
</p>


<h3>See Also</h3>

<p>Other operating characteristic functions: 
<code><a href="#topic+GroupMembershipMatrix">GroupMembershipMatrix</a>()</code>,
<code><a href="#topic+Sterrett">Sterrett</a>()</code>,
<code><a href="#topic+TOD">TOD</a>()</code>,
<code><a href="#topic+halving">halving</a>()</code>,
<code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the operating characteristics for non-informative
#   two-stage hierarchical (Dorfman) testing.
config.mat &lt;- matrix(data = c(rep(1, 10), 1:10),
                     nrow = 2, ncol = 10, byrow = TRUE)
opChar1(algorithm = "D2", p = 0.05, Se = 0.99, Sp = 0.99,
        hier.config = config.mat, print.time = FALSE)

# Calculate the operating characteristics for informative
#   two-stage hierarchical (Dorfman) testing.
# A vector of individual probabilities is generated using
#   the expected value of order statistics from a beta
#   distribution with p = 0.01 and a heterogeneity level
#   of alpha = 0.5.
config.mat &lt;- matrix(data = c(rep(1:3, each = 10), 1:30),
                     nrow = 2, ncol = 30, byrow = TRUE)
set.seed(52613)
opChar1(algorithm = "ID2", p = 0.01, Se = 0.95, Sp = 0.95,
        hier.config = config.mat, alpha = 0.5, num.sim = 10000)
# Equivalent code using a heterogeneous vector of
#   probabilities
set.seed(52613)
probs &lt;- expectOrderBeta(p = 0.01, alpha = 0.5, size = 30)
opChar1(algorithm = "ID2", probabilities = probs,
        Se = 0.95, Sp = 0.95, hier.config = config.mat)

# Calculate the operating characteristics for
#   non-informative three-stage hierarchical testing.
config.mat &lt;- matrix(data = c(rep(1, 18), rep(1:3, each = 5),
                              rep(4, 3), 1:18),
                    nrow = 3, ncol = 18, byrow = TRUE)
opChar1(algorithm = "D3", p = 0.001, Se = 0.95, Sp = 0.95,
        hier.config = config.mat)
opChar1(algorithm = "D3", p = 0.001, Se = c(0.95, 0.95, 0.99),
        Sp = c(0.96, 0.96, 0.98), hier.config = config.mat)

# Calculate the operating characteristics for
#   informative three-stage hierarchical testing,
#   given a heterogeneous vector of probabilities.
config.mat &lt;- matrix(data = c(rep(1, 6), rep(1:2, each = 3),
                              1:6), nrow = 3, ncol = 6,
                     byrow = TRUE)
set.seed(52613)
opChar1(algorithm = "ID3",
         probabilities = c(0.012, 0.014, 0.011, 0.012, 0.010, 0.015),
         Se = 0.99, Sp = 0.99, hier.config = config.mat,
         alpha = 0.5, num.sim = 5000)

# Calculate the operating characteristics for
#   non-informative four-stage hierarchical testing.
config.mat &lt;- matrix(data = c(rep(1, 12), rep(1, 8),
                              rep(2, 2), 3, 4, rep(1, 5),
                              rep(2, 3), 3, 4, rep(NA, 2),
                              1:8, rep(NA, 4)), nrow = 4,
                     ncol = 12, byrow = TRUE)
opChar1(algorithm = "D4", p = 0.041, Se = 0.99, Sp = 0.90,
        hier.config = config.mat)

# Calculate the operating characteristics for
#   informative four-stage hierarchical testing.
# A vector of individual probabilities is generated using
#   the expected value of order statistics from a beta
#   distribution with p = 0.041 and a heterogeneity level
#   of alpha = 0.5.
config.mat &lt;- matrix(data = c(rep(1, 12), rep(1, 8),
                              rep(2, 2), 3, 4, rep(1, 5),
                              rep(2, 3), 3, 4, rep(NA, 2),
                              1:8, rep(NA, 4)), nrow = 4,
                     ncol = 12, byrow = TRUE)
set.seed(5678)
opChar1(algorithm = "ID4", p = 0.041, Se = 0.99, Sp = 0.90,
        hier.config = config.mat, alpha = 0.5)

# Calculate the operating characteristics for
#   non-informative array testing without master pooling.
opChar1(algorithm = "A2", p = 0.005, Se = c(0.95, 0.99),
        Sp = c(0.95, 0.99), rowcol.sz = 8, a = 1)

# Calculate the operating characteristics for
#   informative array testing without master pooling.
# A vector of individual probabilities is generated using
#   the expected value of order statistics from a beta
#   distribution with p = 0.03 and a heterogeneity level
#   of alpha = 2.
set.seed(1002)
opChar1(algorithm = "IA2", p = 0.03, Se = 0.95, Sp = 0.95,
         rowcol.sz = 8, alpha = 2, a = 1:10)

# Calculate the operating characteristics for
#   non-informative array testing with master pooling.
opChar1(algorithm = "A2M", p = 0.02, Se = c(0.95,0.95,0.99),
        Sp = c(0.98,0.98,0.99), rowcol.sz = 5)
</code></pre>

<hr>
<h2 id='operatingCharacteristics2'>Calculate operating characteristics for group testing algorithms
that use a multiplex assay for two diseases</h2><span id='topic+operatingCharacteristics2'></span><span id='topic+opChar2'></span>

<h3>Description</h3>

<p>Calculate operating characteristics, such as the expected
number of tests, for a specified testing configuration using
non-informative and informative hierarchical and array-based group testing
algorithms. Multiplex assays for two diseases are used at each stage of the
algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>operatingCharacteristics2(
  algorithm,
  p.vec = NULL,
  probabilities = NULL,
  alpha = NULL,
  Se,
  Sp,
  hier.config = NULL,
  rowcol.sz = NULL,
  ordering = matrix(data = c(0, 1, 0, 1, 0, 0, 1, 1), nrow = 4, ncol = 2),
  a = NULL,
  print.time = TRUE,
  ...
)

opChar2(
  algorithm,
  p.vec = NULL,
  probabilities = NULL,
  alpha = NULL,
  Se,
  Sp,
  hier.config = NULL,
  rowcol.sz = NULL,
  ordering = matrix(data = c(0, 1, 0, 1, 0, 0, 1, 1), nrow = 4, ncol = 2),
  a = NULL,
  print.time = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="operatingCharacteristics2_+3A_algorithm">algorithm</code></td>
<td>
<p>character string defining the group testing
algorithm to be used. Non-informative testing options include two-stage
hierarchical (&quot;<kbd>D2</kbd>&quot;), three-stage hierarchical (&quot;<kbd>D3</kbd>&quot;), four-stage
hierarchical (&quot;<kbd>D4</kbd>&quot;), five-stage hierarchical (&quot;<kbd>D5</kbd>&quot;),
square array testing without master pooling (&quot;<kbd>A2</kbd>&quot;), and square array
testing with master pooling (&quot;<kbd>A2M</kbd>&quot;). Informative testing options
include two-stage hierarchical (&quot;<kbd>ID2</kbd>&quot;), three-stage hierarchical
(&quot;<kbd>ID3</kbd>&quot;), four-stage hierarchical (&quot;<kbd>ID4</kbd>&quot;), and five-stage
hierarchical (&quot;<kbd>ID5</kbd>&quot;) testing.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics2_+3A_p.vec">p.vec</code></td>
<td>
<p>vector of overall joint probabilities. The joint probabilities
are assumed to be equal for all individuals in the algorithm
(non-informative testing only). There are four joint probabilities to
consider: <code class="reqn">p_{00}</code>, the probability that an individual tests
negative for both diseases; <code class="reqn">p_{10}</code>, the probability that an
individual tests positive only for the first disease; <code class="reqn">p_{01}</code>,
the probability that an individual tests positive only for the second
disease; and <code class="reqn">p_{11}</code>, the probability that an individual tests
positive for both diseases. The joint probabilities must sum to 1. Only one
of <kbd>p.vec</kbd>, <kbd>probabilities</kbd>, or <kbd>alpha</kbd> should be specified.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics2_+3A_probabilities">probabilities</code></td>
<td>
<p>matrix of joint probabilities for each individual,
where rows correspond to the four joint probabilities and columns correspond
to each individual in the algorithm. Only one of <kbd>p.vec</kbd>,
<kbd>probabilities</kbd>, or <kbd>alpha</kbd> should be specified.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics2_+3A_alpha">alpha</code></td>
<td>
<p>a vector containing positive shape parameters of the Dirichlet
distribution (for informative testing only). The vector will be used to
generate a heterogeneous matrix of joint probabilities for each individual.
The vector must have length 4. Further details are given under 'Details'.
Only one of <kbd>p.vec</kbd>, <kbd>probabilities</kbd>, or <kbd>alpha</kbd> should be
specified.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics2_+3A_se">Se</code></td>
<td>
<p>matrix of sensitivity values, where one value is given for each
disease (or infection) at each stage of testing. The rows of the matrix
correspond to each disease <code class="reqn">k=1,2</code>, and the columns of the
matrix correspond to each stage of testing <code class="reqn">s=1,...,S</code>. If a vector of
2 values is provided, the sensitivity values associated with disease
are assumed to be equal to the <code class="reqn">k</code>th value in the vector for
all stages of testing. Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics2_+3A_sp">Sp</code></td>
<td>
<p>a matrix of specificity values, where one value is given for each
disease (or infection) at each stage of testing. The rows of the matrix
correspond to each disease <code class="reqn">k=1,2</code>, and the columns of the
matrix correspond to each stage of testing <code class="reqn">s=1,...,S</code>. If a vector of
2 values is provided, the specificity values associated with disease
<code class="reqn">k</code> are assumed to be equal to the <code class="reqn">k</code>th value in the vector for
all stages of testing. Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics2_+3A_hier.config">hier.config</code></td>
<td>
<p>a matrix specifying the configuration for a hierarchical
testing algorithm. The rows correspond to the stages of testing, the columns
correspond to each individual to be tested, and the cell values
specify the group number of each individual at each stage. Further details
are given under 'Details'. For array testing algorithms, this argument will
be ignored.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics2_+3A_rowcol.sz">rowcol.sz</code></td>
<td>
<p>the row/column size for array testing algorithms. For
hierarchical testing algorithms, this argument will be ignored.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics2_+3A_ordering">ordering</code></td>
<td>
<p>a matrix detailing the ordering for the binary responses of
the diseases. The columns of the matrix correspond to each disease and the
rows of the matrix correspond to each of the 4 sets of binary responses for
two diseases. This ordering is used with the joint probabilities. The
default ordering is (p_00, p_10, p_01, p_11).</p>
</td></tr>
<tr><td><code id="operatingCharacteristics2_+3A_a">a</code></td>
<td>
<p>a vector containing indices indicating which individuals to
calculate individual accuracy measures for. If <kbd>NULL</kbd>, individual
accuracy measures will be displayed for all individuals in the algorithm.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics2_+3A_print.time">print.time</code></td>
<td>
<p>a logical value indicating whether the length of time
for calculations should be printed. The default is <kbd>TRUE</kbd>.</p>
</td></tr>
<tr><td><code id="operatingCharacteristics2_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to functions for hierarchical
testing with multiplex assays for two diseases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the operating characteristics for standard
group testing algorithms with a multiplex assay that tests for two diseases.
Calculations for hierarchical group testing algorithms are performed as
described in Bilder et al. (2019) and calculations for array-based group
testing algorithms are performed as described in Hou et al. (2019).
</p>
<p>Available algorithms include two-, three-, four-, and five-stage
hierarchical testing and array testing with and without master pooling. Both
non-informative and informative group testing settings are allowed for
hierarchical algorithms. Only non-informative group testing settings are
allowed for array testing algorithms. Operating characteristics calculated
are expected number of tests, pooling sensitivity, pooling specificity,
pooling positive predictive value, and pooling negative predictive value for
each individual.
</p>
<p>For informative algorithms where the <kbd>alpha</kbd> argument is specified, a
heterogeneous matrix of joint probabilities for each individual is generated
using the Dirichlet distribution. This is done using
<code>rBeta2009::rdirichlet</code> and requires the user to set a seed to
reproduce results. See Bilder et al. (2019) for additional details on the
use of the Dirichlet distribution for this purpose.
</p>
<p>The sensitivity/specificity values are allowed to vary across stages of
testing. For hierarchical testing, a different sensitivity/specificity value
may be used for each stage of testing. For array testing, a different
sensitivity/specificity value may be used for master pool testing (if
included), row/column testing, and individual testing. The values must be
specified in the order of the testing performed. For example, values are
specified as (stage 1, stage 2, stage 3) for three-stage hierarchical
testing or (master pool testing, row/column testing, individual testing) for
array testing with master pooling. A vector of 2
sensitivity/specificity values may be specified, and sensitivity/specificity
values for all stages of testing are assumed to be equal. The first value in
the vector will be used at each stage of testing for the first disease, and
the second value in the vector will be used at each stage of testing for the
second disease.
</p>
<p>The matrix specified  by <kbd>hier.config</kbd> defines the hierarchical group
testing algorithm for <code class="reqn">I</code> individuals. The rows of the matrix correspond
to the stages <code class="reqn">s=1,...,S</code> in the testing algorithm, and the columns
correspond to individuals <code class="reqn">i=1,...I</code>. The cell values within the matrix
represent the group number of individual <code class="reqn">i</code> at stage <code class="reqn">s</code>. For
three-stage, four-stage, five-stage, and non-informative two-stage
hierarchical testing, the first row of the matrix consists of all ones. This
indicates that all individuals in the algorithm are tested together in a
single group in the first stage of testing. For informative two-stage
hierarchical testing, the initial group (block) is not tested. Thus, the
first row of the matrix consists of the group numbers for each individual
in the first stage of testing. For all hierarchical algorithms, the final
row of the matrix denotes individual testing. Individuals who are not tested
in a particular stage are represented by &quot;NA&quot; (e.g., an individual tested in
a group of size 1 in the second stage of testing would not be tested again
in a third stage of testing). It is important to note that this matrix
represents the testing that could be performed if each group tests
positively at each stage prior to the last. For more details on this matrix
(called a group membership matrix), see Bilder et al. (2019).
</p>
<p>For array testing without master pooling, the <kbd>rowcol.sz</kbd> specified
represents the row/column size for initial (stage 1) testing. For array
testing with master pooling, the <kbd>rowcol.sz</kbd> specified represents the
row/column size for stage 2 testing. This is because the master pool size is
the overall array size, given by the square of the row/column size.
</p>
<p>The displayed overall pooling sensitivity, pooling specificity, pooling
positive predictive value, and pooling negative predictive value are
weighted averages of the corresponding individual accuracy measures for all
individuals within the initial group (or block) for a hierarchical
algorithm, or within the entire array for an array-based algorithm.
Expressions for these averages are provided in the Supplementary Material
for Hitt et al. (2019). These expressions are based on accuracy definitions
given by Altman and Bland (1994a, 1994b).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>algorithm</code></td>
<td>
<p>the group testing algorithm used for calculations.</p>
</td></tr>
<tr><td><code>prob.vec</code></td>
<td>
<p>the vector of joint probabilities provided by the user,
if applicable (for non-informative algorithms only).</p>
</td></tr>
<tr><td><code>joint.p</code></td>
<td>
<p>the matrix of joint probabilities for each individual
provided by the user, if applicable.</p>
</td></tr>
<tr><td><code>alpha.vec</code></td>
<td>
<p>the alpha vector provided by the user, if applicable
(for informative algorithms only).</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the matrix of sensitivity values for each disease at each stage
of testing.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the matrix of specificity values for each disease at each stage
of testing.</p>
</td></tr>
<tr><td><code>Config</code></td>
<td>
<p>a list specifying elements of the specified testing
configuration, which may include:
</p>

<dl>
<dt>Stage1</dt><dd><p>group size for the first stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Stage2</dt><dd><p>group sizes for the second stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Stage3</dt><dd><p>group sizes for the third stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Stage4</dt><dd><p>group sizes for the fourth stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Block.sz</dt><dd><p>the block size/initial group size for informative Dorfman
testing, which is not tested.</p>
</dd>
<dt>pool.szs</dt><dd><p>group sizes for the first stage of testing for informative
Dorfman testing.</p>
</dd>
<dt>Array.dim</dt><dd><p>the row/column size for array testing.</p>
</dd>
<dt>Array.sz</dt><dd><p>the overall array size for array testing (the square of the
row/column size).</p>
</dd></dl>
</td></tr>
<tr><td><code>p.mat</code></td>
<td>
<p>the matrix of joint probabilities for each individual in the
algorithm. Each row corresponds to one of the four joint probabilities.
Each column corresponds to an individual in the testing algorithm.</p>
</td></tr>
<tr><td><code>ET</code></td>
<td>
<p>the expected testing expenditure for the OTC.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the value of the expected number of tests per individual.</p>
</td></tr>
<tr><td><code>Accuracy</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>Disease 1 Individual</dt><dd><p>a matrix of accuracy measures, pertaining to the
first disease, for each individual specified in <kbd>a</kbd>. The rows correspond
to each unique set of accuracy measures in the algorithm. Individuals with
the same set of accuracy measures are displayed together in a single row of
the matrix. The columns correspond to the pooling sensitivity, pooling
specificity, pooling positive predictive value, pooling negative predictive
value, and the indices for the individuals in each row of the matrix.
Individual accuracy measures are not displayed for array testing
algorithms.</p>
</dd>
<dt>Disease 2 Individual</dt><dd><p>a matrix of accuracy measures, pertaining to the
second disease, for each individual specified in <kbd>a</kbd>. The rows
correspond to each unique set of accuracy measures in the algorithm.
Individuals with the same set of accuracy measures are displayed together in
a single row of the matrix. The columns correspond to the pooling
sensitivity, pooling specificity, pooling positive predictive value, pooling
negative predictive value, and the indices for the individuals in each row
of the matrix. Individual accuracy measures are not displayed for array
testing algorithms.</p>
</dd>
<dt>Overall</dt><dd><p>a matrix of overall accuracy measures for the algorithm.
The rows correspond to each disease. The columns correspond to the pooling
sensitivity, pooling specificity, pooling positive predictive value, and
pooling negative predictive value for the overall algorithm. Further
details are given under 'Details'.</p>
</dd></dl>
</td></tr>
</table>


<h3>Note</h3>

<p>This function returns the pooling positive and negative
predictive values for all individuals even though these measures are
diagnostic specific; e.g., the pooling positive predictive value should
only be considered for those individuals who have tested positive.
</p>
<p>Additionally, only stage dependent sensitivity and specificity values are
allowed within the program (no group within stage dependent values are
allowed). See Bilder et al. (2019) for additional information.
</p>


<h3>Author(s)</h3>

<p>This function was written by Brianna D. Hitt. It calls
<kbd>ET.all.stages.new</kbd> and <kbd>PSePSpAllStages</kbd>, which were originally
written by Christopher Bilder for Bilder et al. (2019), and <kbd>ARRAY</kbd>,
which was originally written by Peijie Hou for Hou et al. (2020). The
functions <kbd>ET.all.stages.new</kbd>, <kbd>PSePSpAllStages</kbd>, and <kbd>ARRAY</kbd>
were obtained from <a href="http://chrisbilder.com/grouptesting/">http://chrisbilder.com/grouptesting/</a>. Minor
modifications were made to the functions for inclusion in the binGroup2
package.
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: Sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: Predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Bilder, C., Tebbs, J., McMahan, C. (2019).
&ldquo;Informative group testing for multiplex assays.&rdquo;
<em>Biometrics</em>, <b>75</b>, 278&ndash;288.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019).
&ldquo;The objective function controversy for group testing: Much ado about nothing?&rdquo;
<em>Statistics in Medicine</em>, <b>38</b>, 4912&ndash;4923.
</p>
<p>Hou, P., Tebbs, J., Wang, D., McMahan, C., Bilder, C. (2021).
&ldquo;Array testing with multiplex assays.&rdquo;
<em>Biostatistics</em>, <b>21</b>, 417&ndash;431.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012a).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>, 287&ndash;296.
</p>


<h3>See Also</h3>

<p>Other operating characteristic functions: 
<code><a href="#topic+GroupMembershipMatrix">GroupMembershipMatrix</a>()</code>,
<code><a href="#topic+Sterrett">Sterrett</a>()</code>,
<code><a href="#topic+TOD">TOD</a>()</code>,
<code><a href="#topic+halving">halving</a>()</code>,
<code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the operating characteristics for
#   non-informative two-stage hierarchical
#   (Dorfman) testing.
config.mat &lt;- matrix(data = c(rep(1, 24), 1:24),
                     nrow = 2, ncol = 24, byrow = TRUE)
Se &lt;- matrix(data = c(0.95, 0.95, 0.95, 0.95),
             nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
Sp &lt;- matrix(data = c(0.99, 0.99, 0.99, 0.99),
             nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
opChar2(algorithm = "D2", p.vec = c(0.90, 0.04, 0.04, 0.02),
         Se = Se, Sp = Sp, hier.config = config.mat, print.time = FALSE)

# Calculate the operating characteristics for informative
#   two-stage hierarchical (Dorfman) testing.
# A matrix of joint probabilities for each individual is
#   generated using the Dirichlet distribution.
config.mat &lt;- matrix(data = c(rep(1, 5), rep(2, 4), 3, 1:9, NA),
                     nrow = 2, ncol = 10, byrow = TRUE)
Se &lt;- matrix(data = c(0.95, 0.95, 0.99, 0.99),
             nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
Sp &lt;- matrix(data = c(0.96, 0.96, 0.98, 0.98),
             nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
set.seed(8791)
opChar2(algorithm = "ID2", alpha = c(18.25, 0.75, 0.75, 0.25),
         Se = Se, Sp = Sp, hier.config = config.mat)
# Equivalent code using a heterogeneous matrix of joint
#   probabilities for each individual
set.seed(8791)
p.unordered &lt;- t(rBeta2009::rdirichlet(n = 10,
                            shape = c(18.25, 0.75, 0.75, 0.25)))
p.ordered &lt;- p.unordered[, order(1 - p.unordered[1,])]
opChar2(algorithm = "ID2", probabilities = p.ordered,
        Se = Se, Sp = Sp, hier.config = config.mat)

# Calculate the operating characteristics for
#   non-informative three-stage hierarchical testing.
config.mat &lt;- matrix(data = c(rep(1, 10), rep(1, 5),
                              rep(2, 4), 3, 1:9, NA),
                     nrow = 3, ncol = 10, byrow = TRUE)
Se &lt;- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
Sp &lt;- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
opChar2(algorithm = "D3", p.vec = c(0.95, 0.02, 0.02, 0.01),
         Se = Se, Sp = Sp, hier.config = config.mat)
opChar2(algorithm = "D3", p.vec = c(0.95, 0.02, 0.02, 0.01),
        Se = Se, Sp = Sp, hier.config = config.mat,
        a = c(1, 6, 10))

# Calculate the operating characteristics for informative
#   three-stage hierarchical testing.
# A matrix of joint probabilities for each individual is
#   generated using the Dirichlet distribution.
config.mat &lt;- matrix(data = c(rep(1, 15),
                              rep(c(1, 2, 3), each = 5), 1:15),
                     nrow = 3, ncol = 15, byrow = TRUE)
Se &lt;- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
Sp &lt;- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
opChar2(algorithm = "ID3", alpha = c(18.25, 0.75, 0.75, 0.25),
         Se = Se, Sp = Sp, hier.config = config.mat)

# Calculate the operating characteristics for
#   non-informative four-stage hierarchical testing.
config.mat &lt;- matrix(data = c(rep(1, 12), rep(1, 6), rep(2, 6),
                              rep(1, 4), rep(2, 2), rep(3, 3),
                              rep(4, 3), 1:12),
                     nrow = 4, ncol = 12, byrow = TRUE)
Se &lt;- matrix(data = rep(0.95, 8), nrow = 2, ncol = 4,
             dimnames = list(Infection = 1:2, Stage = 1:4))
Sp &lt;- matrix(data = rep(0.99, 8), nrow = 2, ncol = 4,
             dimnames = list(Infection = 1:2, Stage = 1:4))
opChar2(algorithm = "D4", p.vec = c(0.92, 0.05, 0.02, 0.01),
         Se = Se, Sp = Sp, hier.config = config.mat)

# Calculate the operating characteristics for informative
#   five-stage hierarchical testing.
# A matrix of joint probabilities for each individual is
#   generated using the Dirichlet distribution.
config.mat &lt;- matrix(data = c(rep(1, 20), rep(1, 10), rep(2, 10),
                              rep(c(1, 2, 3, 4), each = 5),
                              rep(1, 3), rep(2, 2), rep(3, 3),
                              rep(4, 2), rep(5, 3), rep(6, 2),
                              rep(7, 3), rep(8, 2), 1:20),
                     nrow = 5, ncol = 20, byrow = TRUE)
Se &lt;- matrix(data = rep(0.95, 10), nrow = 2, ncol = 5,
             dimnames = list(Infection = 1:2, Stage = 1:5))
Sp &lt;- matrix(data = rep(0.99, 10), nrow = 2, ncol = 5,
             dimnames = list(Infection = 1:2, Stage = 1:5))
opChar2(algorithm = "ID5", alpha = c(18.25, 0.75, 0.75, 0.25),
        Se = Se, Sp = Sp, hier.config = config.mat)

# Calculate the operating characteristics for
#   non-informative array testing without master pooling.
Se &lt;- matrix(data = rep(0.95, 4), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
Sp &lt;- matrix(data = rep(0.99, 4), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
opChar2(algorithm = "A2", p.vec = c(0.90, 0.04, 0.04, 0.02),
         Se = Se, Sp = Sp, rowcol.sz = 12)

# Calculate the operating characteristics for
#   non-informative array testing with master pooling.
Se &lt;- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
Sp &lt;- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
opChar2(algorithm = "A2M", p.vec = c(0.90, 0.04, 0.04, 0.02),
         Se = Se, Sp = Sp, rowcol.sz = 10)
</code></pre>

<hr>
<h2 id='OTC1'>Find the optimal testing configuration for group testing algorithms
that use a single-disease assay</h2><span id='topic+OTC1'></span>

<h3>Description</h3>

<p>Find the optimal testing configuration (OTC) using
non-informative and informative hierarchical and array-based group testing
algorithms. Single-disease assays are used at each stage of the algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OTC1(
  algorithm,
  p = NULL,
  probabilities = NULL,
  Se = 0.99,
  Sp = 0.99,
  group.sz,
  obj.fn = "ET",
  weights = NULL,
  alpha = 2,
  trace = TRUE,
  print.time = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OTC1_+3A_algorithm">algorithm</code></td>
<td>
<p>character string defining the group testing algorithm to
be used. Non-informative testing options include two-stage hierarchical
(&quot;<kbd>D2</kbd>&quot;), three-stage hierarchical (&quot;<kbd>D3</kbd>&quot;), square array testing
without master pooling (&quot;<kbd>A2</kbd>&quot;), and square array testing with master
pooling (&quot;<kbd>A2M</kbd>&quot;). Informative testing options include two-stage
hierarchical (&quot;<kbd>ID2</kbd>&quot;), three-stage hierarchical (&quot;<kbd>ID3</kbd>&quot;), and
square array testing without master pooling (&quot;<kbd>IA2</kbd>&quot;).</p>
</td></tr>
<tr><td><code id="OTC1_+3A_p">p</code></td>
<td>
<p>overall probability of disease that will be used to generate a
vector/matrix of individual probabilities. For non-informative algorithms,
a homogeneous set of probabilities will be used. For informative
algorithms, the <code><a href="#topic+expectOrderBeta">expectOrderBeta</a></code> function will be used to
generate a heterogeneous set of probabilities. Further details are given
under 'Details'. Either <kbd>p</kbd> or <kbd>probabilities</kbd> should be specified,
but not both.</p>
</td></tr>
<tr><td><code id="OTC1_+3A_probabilities">probabilities</code></td>
<td>
<p>a vector of individual probabilities, which is
homogeneous for non-informative testing algorithms and heterogeneous for
informative testing algorithms. Either  <kbd>p</kbd> or <kbd>probabilities</kbd>
should be specified, but not both.</p>
</td></tr>
<tr><td><code id="OTC1_+3A_se">Se</code></td>
<td>
<p>a vector of sensitivity values, where one value is given for each
stage of testing (in order). If a single value is provided, sensitivity
values are assumed to be equal to this value for all stages of testing.
Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="OTC1_+3A_sp">Sp</code></td>
<td>
<p>a vector of specificity values, where one value is given for each
stage of testing (in order). If a single value is provided, specificity
values are assumed to be equal to this value for all stages of testing.
Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="OTC1_+3A_group.sz">group.sz</code></td>
<td>
<p>a single group size or range of group sizes for which to
calculate operating characteristics and/or find the OTC. The details of
group size specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="OTC1_+3A_obj.fn">obj.fn</code></td>
<td>
<p>a list of objective functions which are minimized to find the
OTC. The expected number of tests per individual, &quot;<kbd>ET</kbd>&quot;, will always
be calculated. Additional options include &quot;<kbd>MAR</kbd>&quot;
(the expected number of tests divided by the expected number of correct
classifications, described in Malinovsky et al. (2016)), and &quot;<kbd>GR</kbd>&quot;
(a linear combination of the expected number of tests, the number of
misclassified negatives, and the number of misclassified positives,
described in Graff &amp; Roeloffs (1972)). See Hitt et al. (2019) for
additional details. The first objective function specified in this list
will be used to determine the results for the top configurations.
Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="OTC1_+3A_weights">weights</code></td>
<td>
<p>a matrix of up to six sets of weights for the GR function.
Each set of weights is specified by a row of the matrix.</p>
</td></tr>
<tr><td><code id="OTC1_+3A_alpha">alpha</code></td>
<td>
<p>a shape parameter for the betadistribution that specifies the
degree of heterogeneity for the generated probability vector (for
informative testing only).</p>
</td></tr>
<tr><td><code id="OTC1_+3A_trace">trace</code></td>
<td>
<p>a logical value indicating whether the progress of
calculations should be printed for each initial group size provided by
the user. The default is <kbd>TRUE</kbd>.</p>
</td></tr>
<tr><td><code id="OTC1_+3A_print.time">print.time</code></td>
<td>
<p>a logical value indicating whether the length of time
for calculations should be printed. The default is <kbd>TRUE</kbd>.</p>
</td></tr>
<tr><td><code id="OTC1_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the <code><a href="#topic+expectOrderBeta">expectOrderBeta</a></code>
function, which generates a vector of probabilities for informative testing
algorithms. Further details are given under 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the OTC for group testing algorithms
with an assay that tests for one disease and computes the associated
operating characteristics, as described in Hitt et al. (2019).
</p>
<p>Available algorithms include two- and three-stage hierarchical testing and
array testing with and without master pooling. Both non-informative and
informative group testing settings are allowed for each algorithm, except
informative array testing with master pooling is unavailable because this
method has not appeared in the group testing literature. Operating
characteristics calculated are expected number of tests, pooling
sensitivity, pooling specificity, pooling positive predictive value, and
pooling negative predictive value for each individual.
</p>
<p>For informative algorithms where the <kbd>p</kbd> argument is specified, the
expected value of order statistics from a beta distribution are found.
These values are used to represent disease risk probabilities for each
individual to be tested. The beta distribution has two parameters: a mean
parameter <kbd>p</kbd> (overall disease prevalence) and a shape parameter
<kbd>alpha</kbd> (heterogeneity level). Depending on the specified <kbd>p</kbd>,
<kbd>alpha</kbd>, and overall group size, simulation may be necessary to
generate the vector of individual probabilities. This is done using
<code><a href="#topic+expectOrderBeta">expectOrderBeta</a></code> and requires the user to set a seed to
reproduce results.
</p>
<p>Informative two-stage hierarchical (Dorfman) testing is implemented via
the pool-specific optimal Dorfman (PSOD) method described in McMahan et al.
(2012a), where the greedy algorithm proposed for PSOD is replaced by
considering all possible testing configurations. Informative array testing
is implemented via the gradient method (the most efficient array design),
where higher-risk individuals are grouped in the left-most columns of the
array. For additional details on the gradient arrangement method for
informative array testing, see McMahan et al. (2012b).
</p>
<p>The sensitivity/specificity values are allowed to vary across stages of
testing. For hierarchical testing, a different sensitivity/specificity
value may be used for each stage of testing. For array testing, a different
sensitivity/specificity value may be used for master pool testing (if
included), row/column testing, and individual testing. The values must be
specified in order of the testing performed. For example, values are
specified as (stage 1, stage 2, stage 3) for three-stage hierarchical
testing or (master pool testing, row/column testing, individual testing)
for array testing with master pooling. A single sensitivity/specificity
value may be specified instead. In this situation, sensitivity/specificity
values for all stages are assumed to be equal.
</p>
<p>The value(s) specified by <kbd>group.sz</kbd> represent the initial (stage 1)
group size for hierarchical testing and the row/column size for array
testing. For informative two-stage hierarchical testing, the <kbd>group.sz</kbd>
specified represents the block size used in the pool-specific optimal
Dorfman (PSOD) method, where the initial group (block) is not tested. For
more details on informative two-stage hierarchical testing implemented via
the PSOD method, see Hitt et al. (2019) and McMahan et al. (2012a).
</p>
<p>If a single value is provided for <kbd>group.sz</kbd> with array testing or
non-informative two-stage hierarchical testing, operating characteristics
will be calculated and no optimization will be performed. If a single value
is provided for <kbd>group.sz</kbd> with three-stage hierarchical or informative
two-stage hierarchical, the OTC will be found over all possible
configurations. If a range of group sizes is specified, the OTC will be
found over all group sizes.
</p>
<p>In addition to the OTC, operating characteristics for some of the other
configurations corresponding to each initial group size provided by the
user will be displayed. These additional configurations are only determined
for whichever objective function (&quot;ET&quot;, &quot;MAR&quot;, or &quot;GR&quot;) is specified first
in the function call. If &quot;GR&quot; is the objective function listed first, the
first set of corresponding weights will be used. For algorithms where there
is only one configuration for each initial group size (non-informative
two-stage hierarchical and all array testing algorithms), results for each
initial group size are provided. For algorithms where there is more than
one possible configuration for each initial group size (informative
two-stage hierarchical and all three-stage hierarchical algorithms), two
sets of configurations are provided: 1) the best configuration for each
initial group size, and 2) the top 10 configurations for each initial group
size provided by the user. If a single value is provided for <kbd>group.sz</kbd>
with array testing or non-informative two-stage hierarchical testing,
operating characteristics will not be provided for configurations other
than that specified by the user. Results are sorted by the value of the
objective function per individual, <kbd>value</kbd>.
</p>
<p>The displayed overall pooling sensitivity, pooling specificity, pooling
positive predictive value, and pooling negative predictive value are
weighted averages of the corresponding individual accuracy measures for all
individuals within the initial group (or block) for a hierarchical
algorithm, or within the entire array for an array-based algorithm.
Expressions for these averages are provided in the Supplementary
Material for Hitt et al. (2019). These expressions are based on accuracy
definitions given by Altman and Bland (1994a, 1994b). Individual
accuracy measures can be calculated using the
<code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code> (<code><a href="#topic+opChar1">opChar1</a></code>) function.
</p>
<p>The <kbd>OTC1</kbd> function accepts additional arguments, namely <kbd>num.sim</kbd>,
to be passed to the <code><a href="#topic+expectOrderBeta">expectOrderBeta</a></code> function, which generates
a vector of probabilities for informative group testing algorithms. The
<kbd>num.sim</kbd> argument specifies the number of simulations from the beta
distribution when simulation is used. By default, 10,000 simulations are
used.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>algorithm</code></td>
<td>
<p>the group testing algorithm used for calculations.</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>the probability of disease or the vector of individual
probabilities, as specified by the user.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>level of heterogeneity for the generated probability vector
(for informative testing only).</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the vector of sensitivity values for each stage of testing.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the vector of specificity values for each stage of testing.</p>
</td></tr>
<tr><td><code>opt.ET</code>, <code>opt.MAR</code>, <code>opt.GR</code></td>
<td>
<p>a list of results for each
objective function specified by the user, containing:
</p>

<dl>
<dt>OTC</dt><dd><p>a list specifying elements of the optimal testing configuration,
which may include:
</p>

<dl>
<dt>Stage1</dt><dd><p>group size for the first stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Stage2</dt><dd><p>group sizes for the second stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Block.sz</dt><dd><p>the block size/initial group size for informative Dorfman
testing, which is not tested.</p>
</dd>
<dt>pool.szs</dt><dd><p>group sizes for the first stage of testing for informative
Dorfman testing.</p>
</dd>
<dt>Array.dim</dt><dd><p>the row/column size for array testing.</p>
</dd>
<dt>Array.sz</dt><dd><p>the overall array size for array testing (the square of the
row/column size).</p>
</dd></dl>
</dd>
<dt>p.vec</dt><dd><p>the sorted vector of individual probabilities, if applicable.</p>
</dd>
<dt>p.mat</dt><dd><p>the sorted matrix of individual probabilities in gradient
arrangement, if applicable. Further details are given under 'Details'.</p>
</dd>
<dt>ET</dt><dd><p>the expected testing expenditure to decode all individuals in the
algorithm; this includes all individuals in all groups for hierarchical
algorithms or in the entire array for array testing.</p>
</dd>
<dt>value</dt><dd><p>the value of the objective function per individual.</p>
</dd>
<dt>Accuracy</dt><dd><p>a matrix of overall accuracy measures for the
algorithm. The columns correspond to the pooling sensitivity,
pooling specificity, pooling positive predictive value, and
pooling negative predictive value for the overall algorithm.
Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
<tr><td><code>Configs</code></td>
<td>
<p>a data frame containing results for the best configuration
for each initial group size provided by the user. The columns correspond to
the initial group size, configuration (if applicable), overall array size
(if applicable), expected number of tests, value of the objective function
per individual, pooling sensitivity, pooling specificity, pooling positive
predictive value, and pooling negative predictive value. No results are
displayed if a single <kbd>group.sz</kbd> is provided. Further details are given
under 'Details'.</p>
</td></tr>
<tr><td><code>Top.Configs</code></td>
<td>
<p>a data frame containing results for the top overall
configurations across all initial group sizes provided by the user. The
columns correspond to the initial group size, configuration,
expected number of tests, value of the objective function per individual,
pooling sensitivity, pooling specificity, pooling positive predictive
value, and pooling negative predictive value. No results are displayed for
non-informative two-stage hierarchical testing or for array testing
algorithms. Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code>group.sz</code></td>
<td>
<p>Initial group (or block) sizes examined to find the OTC.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function returns the pooling positive and negative
predictive values for all individuals even though these measures are
diagnostic specific; e.g., the pooling positive predictive value should
only be considered for those individuals who have tested positive.
</p>
<p>Additionally, only stage dependent sensitivity and specificity values are
allowed within the program (no group within stage dependent values are
allowed). See Bilder et al. (2019) for additional information.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: Sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: Predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Bilder, C., Tebbs, J., McMahan, C. (2019).
&ldquo;Informative group testing for multiplex assays.&rdquo;
<em>Biometrics</em>, <b>75</b>, 278&ndash;288.
</p>
<p>Graff, L., Roeloffs, R. (1972).
&ldquo;Group testing in the presence of test error; an extension of the Dorfman procedure.&rdquo;
<em>Technometrics</em>, <b>14</b>, 113&ndash;122.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019).
&ldquo;The objective function controversy for group testing: Much ado about nothing?&rdquo;
<em>Statistics in Medicine</em>, <b>38</b>, 4912&ndash;4923.
</p>
<p>Malinovsky, Y., Albert, P., Roy, A. (2016).
&ldquo;Reader reaction: A note on the evaluation of group testing algorithms in the presence of misclassification.&rdquo;
<em>Biometrics</em>, <b>72</b>, 299&ndash;302.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012a).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>, 287&ndash;296.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012b).
&ldquo;Two-Dimensional Informative Array Testing.&rdquo;
<em>Biometrics</em>, <b>68</b>, 793&ndash;804.
</p>


<h3>See Also</h3>

<p>Other OTC functions: 
<code><a href="#topic+OTC2">OTC2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the OTC for non-informative
#   two-stage hierarchical (Dorfman) testing.
OTC1(algorithm = "D2", p = 0.05, Se = 0.99, Sp = 0.99,
     group.sz = 2:100, obj.fn = "ET",
     trace = TRUE, print.time = TRUE)

# Find the OTC for informative two-stage hierarchical
#   (Dorfman) testing.
# A vector of individual probabilities is generated using
#   the expected value of order statistics from a beta
#   distribution with p = 0.01 and a heterogeneity level
#   of alpha = 0.5.
set.seed(52613)
OTC1(algorithm = "ID2", p = 0.01, Se = 0.95, Sp = 0.95,
     group.sz = 50, obj.fn = c("ET", "MAR", "GR"),
     weights = matrix(data = c(1, 1, 10, 10, 0.5, 0.5),
     nrow = 3, ncol = 2, byrow = TRUE), alpha = 0.5,
     trace = FALSE, print.time = TRUE, num.sim = 10000)

# Find the OTC over all possible testing configurations
#   for non-informative three-stage hierarchical testing
#   with a specified group size.
OTC1(algorithm = "D3", p = 0.001, Se = 0.95, Sp = 0.95,
     group.sz = 18, obj.fn = "ET",
     trace = FALSE, print.time = FALSE)

# Find the OTC for non-informative three-stage
#   hierarchical testing.
OTC1(algorithm = "D3", p = 0.06, Se = 0.90, Sp = 0.90,
     group.sz = 3:30, obj.fn = c("ET", "MAR", "GR"),
     weights = matrix(data = c(1, 1, 10, 10, 100, 100),
     nrow = 3, ncol = 2, byrow = TRUE))

# Find the OTC over all possible configurations
#   for informative three-stage hierarchical testing
#   with a specified group size and a heterogeneous
#   vector of probabilities.
set.seed(1234)
OTC1(algorithm = "ID3",
     probabilities = c(0.012, 0.014, 0.011,
                       0.012, 0.010, 0.015),
     Se = 0.99, Sp = 0.99, group.sz = 6,
     obj.fn = "ET",
     alpha = 0.5, num.sim = 5000, trace = FALSE)

# Calculate the operating characteristics for
#   non-informative array testing without master pooling
#   with a specified array size.
OTC1(algorithm = "A2", p = 0.005, Se = 0.95, Sp = 0.95,
     group.sz = 8, obj.fn = "ET", trace = FALSE)

# Find the OTC for informative array testing without
#   master pooling.
# A vector of individual probabilities is generated using
#   the expected value of order statistics from a beta
#   distribution with p = 0.03 and a heterogeneity level
#   of alpha = 2. The probabilities are then arranged in
#   a matrix using the gradient method.
set.seed(1002)
OTC1(algorithm = "IA2", p = 0.03, Se = 0.95, Sp = 0.95,
     group.sz = 2:20, obj.fn = c("ET", "MAR", "GR"),
     weights = matrix(data = c(1, 1, 10, 10, 100, 100),
                      nrow = 3, ncol = 2, byrow = TRUE),
     alpha = 2)

# Find the OTC for non-informative array testing
#   with master pooling. The calculations may not
#   be completed instantaneously.
OTC1(algorithm = "A2M", p = 0.04, Se = 0.90, Sp = 0.90,
     group.sz = 2:20, obj.fn = "ET")
</code></pre>

<hr>
<h2 id='OTC2'>Find the optimal testing configuration for group testing algorithms
that use a multiplex assay for two diseases</h2><span id='topic+OTC2'></span>

<h3>Description</h3>

<p>Find the optimal testing configuration (OTC) using
non-informative and informative hierarchical and array-based group testing
algorithms. Multiplex assays for two diseases are used at each stage of the
algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OTC2(
  algorithm,
  p.vec = NULL,
  probabilities = NULL,
  alpha = NULL,
  Se,
  Sp,
  ordering = matrix(data = c(0, 1, 0, 1, 0, 0, 1, 1), nrow = 4, ncol = 2),
  group.sz,
  trace = TRUE,
  print.time = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OTC2_+3A_algorithm">algorithm</code></td>
<td>
<p>character string defining the group testing
algorithm to be used. Non-informative testing options include two-stage
hierarchical (&quot;<kbd>D2</kbd>&quot;), three-stage hierarchical (&quot;<kbd>D3</kbd>&quot;),
square array testing without master pooling (&quot;<kbd>A2</kbd>&quot;), and square array
testing with master pooling (&quot;<kbd>A2M</kbd>&quot;). Informative testing options
include two-stage hierarchical (&quot;<kbd>ID2</kbd>&quot;) and three-stage hierarchical
(&quot;<kbd>ID3</kbd>&quot;) testing.</p>
</td></tr>
<tr><td><code id="OTC2_+3A_p.vec">p.vec</code></td>
<td>
<p>vector of overall joint probabilities. The joint probabilities
are assumed to be equal for all individuals in the algorithm
(non-informative testing only). There are four joint probabilities to
consider: <code class="reqn">p_{00}</code>, the probability that an individual tests
negative for both diseases; <code class="reqn">p_{10}</code>, the probability that an
individual tests positive only for the first disease; <code class="reqn">p_{01}</code>,
the probability that an individual tests positive only for the second
disease; and <code class="reqn">p_{11}</code>, the probability that an individual tests
positive for both diseases. The joint probabilities must sum to 1. Only one
of <kbd>p.vec</kbd>, <kbd>probabilities</kbd>, or <kbd>alpha</kbd> should be specified.</p>
</td></tr>
<tr><td><code id="OTC2_+3A_probabilities">probabilities</code></td>
<td>
<p>matrix of joint probabilities for each individual,
where rows correspond to the four joint probabilities and columns correspond
to each individual in the algorithm. Only one of <kbd>p.vec</kbd>,
<kbd>probabilities</kbd>, or <kbd>alpha</kbd> should be specified.</p>
</td></tr>
<tr><td><code id="OTC2_+3A_alpha">alpha</code></td>
<td>
<p>vector containing positive shape parameters of the Dirichlet
distribution (for informative testing only). The vector will be used to
generate a heterogeneous matrix of joint probabilities for each individual.
The vector must have length 4. Further details are given under 'Details'.
Only one of <kbd>p.vec</kbd>, <kbd>probabilities</kbd>, or <kbd>alpha</kbd> should be
specified.</p>
</td></tr>
<tr><td><code id="OTC2_+3A_se">Se</code></td>
<td>
<p>matrix of sensitivity values, where one value is given for each
disease (or infection) at each stage of testing. The rows of the matrix
correspond to each disease <code class="reqn">k=1,2</code>, and the columns of the matrix
correspond to each stage of testing <code class="reqn">s=1,...,S</code>. If a vector of 2
values is provided, the sensitivity values associated with disease <code class="reqn">k</code>
are assumed to be equal to the <code class="reqn">k</code>th value in the vector for all stages
of testing. Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="OTC2_+3A_sp">Sp</code></td>
<td>
<p>matrix of specificity values, where one value is given for each
disease (or infection) at each stage of testing. The rows of the matrix
correspond to each disease <code class="reqn">k=1,2</code>, and the columns of the matrix
correspond to each stage of testing <code class="reqn">s=1,...,S</code>. If a vector of 2
values is provided, the specificity values associated with disease <code class="reqn">k</code>
are assumed to be equal to the <code class="reqn">k</code>th value in the vector for all stages
of testing. Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="OTC2_+3A_ordering">ordering</code></td>
<td>
<p>matrix detailing the ordering for the binary responses of
the diseases. The columns of the matrix correspond to each disease and the
rows of the matrix correspond to each of the 4 sets of binary responses for
two diseases. This ordering is used with the joint probabilities. The
default ordering is (p_00, p_10, p_01, p_11).</p>
</td></tr>
<tr><td><code id="OTC2_+3A_group.sz">group.sz</code></td>
<td>
<p>single group size or range of group sizes for which to
calculate operating characteristics and/or find the OTC. The details of
group size specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="OTC2_+3A_trace">trace</code></td>
<td>
<p>a logical value indicating whether the progress of
calculations should be printed for each initial group size provided by
the user. The default is <kbd>TRUE</kbd>.</p>
</td></tr>
<tr><td><code id="OTC2_+3A_print.time">print.time</code></td>
<td>
<p>a logical value indicating whether the length of time
for calculations should be printed. The default is <kbd>TRUE</kbd>.</p>
</td></tr>
<tr><td><code id="OTC2_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to functions for hierarchical
testing with multiplex assays for two diseases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the OTC for standard group testing algorithms
with a multiplex assay that tests for two diseases and computes the
associated operating characteristics. Calculations for hierarchical group
testing algorithms are performed as described in Bilder et al. (2019) and
calculations for array-based group testing algorithms are performed as
described in Hou et al. (2019).
</p>
<p>Available algorithms include two- and three-stage hierarchical testing and
array testing with and without master pooling. Both non-informative and
informative group testing settings are allowed for hierarchical algorithms.
Only non-informative group testing settings are allowed for array testing
algorithms. Operating characteristics calculated are expected number of
tests, pooling sensitivity, pooling specificity, pooling positive
predictive value, and pooling negative predictive value for each individual.
</p>
<p>For informative algorithms where the <kbd>alpha</kbd> argument is specified, a
heterogeneous matrix of joint probabilities for each individual is generated
using the Dirichlet distribution. This is done using
<code>rBeta2009::rdirichlet</code> and requires the user to set a seed to
reproduce results. See Bilder et al. (2019) for additional details on the
use of the Dirichlet distribution for this purpose.
</p>
<p>The sensitivity/specificity values are allowed to vary across stages of
testing. For hierarchical testing, a different sensitivity/specificity value
may be used for each stage of testing. For array testing, a different
sensitivity/specificity value may be used for master pool testing (if
included), row/column testing, and individual testing. The values must be
specified in the order of the testing performed. For example, values are
specified as (stage 1, stage 2, stage 3) for three-stage hierarchical
testing or (master pool testing, row/column testing, individual testing)
for array testing with master pooling. A vector of 2
sensitivity/specificity values may be specified, and sensitivity/specificity
values for all stages of testing are assumed to be equal. The first value
in the vector will be used at each stage of testing for the first disease,
and the second value in the vector will be used at each stage of testing
for the second disease.
</p>
<p>The value(s) specified by <kbd>group.sz</kbd> represent the initial (stage 1)
group size for hierarchical testing and the row/column size for array
testing. If a single value is provided for <kbd>group.sz</kbd> with two-stage
hierarchical or array testing, operating characteristics will be calculated
and no optimization will be performed. If a single value is provided for
<kbd>group.sz</kbd> with three-stage hierarchical, the OTC will be found over all
possible configurations with this initial group size. If a range of group
sizes is specified, the OTC will be found over all group sizes.
</p>
<p>In addition to the OTC, operating characteristics for some of the other
configurations corresponding to each initial group size provided by the user
are displayed. For algorithms where there is only one configuration for each
initial group size (non-informative two-stage hierarchical and all array
testing algorithms), results for each initial group size are provided. For
algorithms where there is more than one possible configuration for each
initial group size (informative two-stage hierarchical and all three-stage
hierarchical algorithms), two sets of configurations are provided: 1) the
best configuration for each initial group size, and 2) the top 10
configurations for each initial group size provided by the user. If a single
value is provided for <kbd>group.sz</kbd> with array testing or non-informative
two-stage hierarchical testing, operating characteristics will not be
provided for configurations other than that specified by the user. Results
are sorted by the value of the objective function per individual,
<kbd>value</kbd>.
</p>
<p>The displayed overall pooling sensitivity, pooling specificity, pooling
positive predictive value, and pooling negative predictive value are
weighted averages of the corresponding individual accuracy measures for all
individuals within the initial group (or block) for a hierarchical
algorithm, or within the entire array for an array-based algorithm.
Expressions for these averages are provided in the Supplementary Material
for Hitt et al. (2019). These expressions are based on accuracy definitions
given by Altman and Bland (1994a, 1994b). Individual accuracy measures can
be calculated using the <code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code>
(<code><a href="#topic+opChar2">opChar2</a></code>) function.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>algorithm</code></td>
<td>
<p>the group testing algorithm used for calculations.</p>
</td></tr>
<tr><td><code>prob.vec</code></td>
<td>
<p>the vector of joint probabilities provided by the user,
if applicable (for non-informative algorithms only).</p>
</td></tr>
<tr><td><code>joint.p</code></td>
<td>
<p>the matrix of joint probabilities for each individual
provided by the user, if applicable.</p>
</td></tr>
<tr><td><code>alpha.vec</code></td>
<td>
<p>the alpha vector provided by the user, if applicable
(for informative algorithms only).</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the matrix of sensitivity values for each disease at each stage
of testing.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the matrix of specificity values for each disease at each stage
of testing.</p>
</td></tr>
<tr><td><code>opt.ET</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>OTC</dt><dd><p>a list specifying elements of the optimal testing configuration,
which may include:
</p>

<dl>
<dt>Stage1</dt><dd><p>group size for the first stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Stage2</dt><dd><p>group sizes for the second stage of hierarchical testing, if
applicable.</p>
</dd>
<dt>Block.sz</dt><dd><p>the block size/initial group size for informative Dorfman
testing, which is not tested.</p>
</dd>
<dt>pool.szs</dt><dd><p>group sizes for the first stage of testing for informative
Dorfman testing.</p>
</dd>
<dt>Array.dim</dt><dd><p>the row/column size for array testing.</p>
</dd>
<dt>Array.sz</dt><dd><p>the overall array size for array testing (the square of the
row/column size).</p>
</dd></dl>
</dd>
<dt>p.mat</dt><dd><p>the matrix of joint probabilities for each individual in the
algorithm. Each row corresponds to one of the four joint probabilities.
Each column corresponds to an individual in the testing algorithm.</p>
</dd>
<dt>ET</dt><dd><p>the expected testing expenditure for the OTC.</p>
</dd>
<dt>value</dt><dd><p>the value of the expected number of tests per individual.</p>
</dd>
<dt>Accuracy</dt><dd><p>the matrix of overall accuracy measures for the algorithm.
The rows correspond to each disease. The columns
correspond to the pooling sensitivity, pooling specificity, pooling positive
predictive value, and pooling negative predictive value for the overall
algorithm. Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
<tr><td><code>Configs</code></td>
<td>
<p>a data frame containing results for the best configuration
for each initial group size provided by the user. The columns correspond to
the initial group size, configuration (if applicable), overall array size
(if applicable), expected number of tests, value of the objective function
per individual, and accuracy measures for each disease. Accuracy measures
include the pooling sensitivity, pooling specificity, pooling positive
predictive value, and pooling negative predictive value. No results are
displayed if a single <kbd>group.sz</kbd> is provided. Further details are given
under 'Details'.</p>
</td></tr>
<tr><td><code>Top.Configs</code></td>
<td>
<p>a data frame containing results for some of the top
configurations for each initial group size provided by the user. The
columns correspond to the initial group size, configuration,
expected number of tests, value of the objective function per individual,
and accuracy measures for each disease. Accuracy measures include the
pooling sensitivity, pooling specificity, pooling positive predictive
value, and pooling negative predictive value. No results are displayed for
non-informative two-stage hierarchical testing or for array testing
algorithms. Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code>group.sz</code></td>
<td>
<p>Initial group (or block) sizes examined to find the OTC.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function returns the pooling positive and negative
predictive values for all individuals even though these measures are
diagnostic specific; e.g., the pooling positive predictive value should
only be considered for those individuals who have tested positive.
</p>
<p>Additionally, only stage dependent sensitivity and specificity values are
allowed within the program (no group within stage dependent values are
allowed). See Bilder et al. (2019) for additional information.
</p>


<h3>Author(s)</h3>

<p>This function was written by Brianna D. Hitt. It calls
<kbd>ET.all.stages.new</kbd> and <kbd>PSePSpAllStages</kbd>, which were originally
written by Christopher Bilder for Bilder et al. (2019), and <kbd>ARRAY</kbd>,
which was originally written by Peijie Hou for Hou et al. (2020). The
functions <kbd>ET.all.stages.new</kbd>, <kbd>PSePSpAllStages</kbd>, and <kbd>ARRAY</kbd>
were obtained from <a href="http://chrisbilder.com/grouptesting/">http://chrisbilder.com/grouptesting/</a>. Minor
modifications were made to the functions for inclusion in the binGroup2
package.
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: Sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: Predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Bilder, C., Tebbs, J., McMahan, C. (2019).
&ldquo;Informative group testing for multiplex assays.&rdquo;
<em>Biometrics</em>, <b>75</b>, 278&ndash;288.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019).
&ldquo;The objective function controversy for group testing: Much ado about nothing?&rdquo;
<em>Statistics in Medicine</em>, <b>38</b>, 4912&ndash;4923.
</p>
<p>Hou, P., Tebbs, J., Wang, D., McMahan, C., Bilder, C. (2021).
&ldquo;Array testing with multiplex assays.&rdquo;
<em>Biostatistics</em>, <b>21</b>, 417&ndash;431.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012a).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>, 287&ndash;296.
</p>


<h3>See Also</h3>

<p>Other OTC functions: 
<code><a href="#topic+OTC1">OTC1</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Find the OTC for non-informative two-stage
#   hierarchical (Dorfman) testing
Se &lt;- matrix(data = c(0.95, 0.95, 0.99, 0.99), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
Sp &lt;- matrix(data = c(0.96, 0.96, 0.98, 0.98), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
OTC2(algorithm = "D2", p.vec = c(0.90, 0.04, 0.04, 0.02),
     Se = Se, Sp = Sp, group.sz = 2:10)

# Find the OTC over all possible testing configurations
#   for informative two-stage hierarchical (Dorfman)
#   testing with a specified group size.
# A matrix of joint probabilities for each individual is
#   generated using the Dirichlet distribution.
Se &lt;- matrix(data = rep(0.95, 4), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
Sp &lt;- matrix(data = rep(0.99, 4), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
set.seed(1002)
OTC2(algorithm = "ID2", alpha = c(18.25, 0.75, 0.75, 0.25),
     Se = Se, Sp = Sp, group.sz = 18:22)

# Find the OTC for non-informative three-stage
#   hierarchical testing.
Se &lt;- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
Sp &lt;- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
OTC2(algorithm = "D3", p.vec = c(0.91, 0.04, 0.04, 0.01),
     Se = Se, Sp = Sp, group.sz = 3:12)

# Find the OTC over all possible configurations
#   for informative three-stage hierarchical
#   testing with a specified group size
#   and a heterogeneous matrix of joint
#   probabilities for each individual.
set.seed(8791)
Se &lt;- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
Sp &lt;- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
p.unordered &lt;- t(rBeta2009::rdirichlet(n = 8,
                            shape = c(18.25, 0.75, 0.75, 0.25)))
p.ordered &lt;- p.unordered[, order(1 - p.unordered[1,])]
OTC2(algorithm = "ID3", probabilities = p.ordered,
         Se = Se, Sp = Sp, group.sz = 8,
         trace = FALSE, print.time = FALSE)

# Find the OTC for non-informative array testing
#   without master pooling.
Se &lt;- matrix(data = rep(0.95, 4), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
Sp &lt;- matrix(data = rep(0.99, 4), nrow = 2, ncol = 2,
             dimnames = list(Infection = 1:2, Stage = 1:2))
OTC2(algorithm = "A2", p.vec = c(0.90, 0.04, 0.04, 0.02),
     Se = Se, Sp = Sp, group.sz = 2:10)

# Find the OTC for non-informative array testing
#   with master pooling.
Se &lt;- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
Sp &lt;- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,
             dimnames = list(Infection = 1:2, Stage = 1:3))
OTC2(algorithm = "A2M", p.vec = c(0.90, 0.04, 0.04, 0.02),
     Se = Se, Sp = Sp, group.sz = 10,
     trace = FALSE, print.time = FALSE)
</code></pre>

<hr>
<h2 id='plot.OTC'>Plot method for optimal testing configuration results</h2><span id='topic+plot.OTC'></span>

<h3>Description</h3>

<p>Produce a plot for objects of class <kbd>"OTC"</kbd>
returned by <code><a href="#topic+OTC1">OTC1</a></code> or <code><a href="#topic+OTC2">OTC2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'OTC'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.OTC_+3A_x">x</code></td>
<td>
<p>an object of class <kbd>"OTC"</kbd>, providing operating
characteristics for the optimal testing configuration and similar
configurations for a group testing algorithm.</p>
</td></tr>
<tr><td><code id="plot.OTC_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a plot for objects of class <kbd>"OTC"</kbd>
returned by <code><a href="#topic+OTC1">OTC1</a></code> or <code><a href="#topic+OTC2">OTC2</a></code>. It plots the expected
number of tests per individual for each similar testing configuration
in the object.
</p>
<p>In addition to the OTC, the <code><a href="#topic+OTC1">OTC1</a></code> and <code><a href="#topic+OTC2">OTC2</a></code>
functions provide operating characteristics for other configurations
corresponding to each initial group size provided by the user. For
algorithms where there is only one configuration for each initial group size
(non-informative two-stage hierarchical and all array testing algorithms),
results for each initial group size are plotted. For algorithms where there
is more than one possible configuration for each initial group size
(informative two-stage hierarchical and all three-stage hierarchical
algorithms), the results corresponding to the best configuration for each
initial group size are plotted.
</p>
<p>If a single value is provided for the <kbd>group.sz</kbd> argument in the
<code><a href="#topic+OTC1">OTC1</a></code> or <code><a href="#topic+OTC2">OTC2</a></code> functions, no plot will be
produced.
</p>
<p>The plot is produced using the <code>ggplot2</code> package. Customization
features from <code>ggplot2</code> are available once the package is loaded.
Examples are shown in the 'Examples' section.
</p>


<h3>Value</h3>

<p>A plot of the expected number of tests per individual for similar
configurations provided in the object.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+OTC1">OTC1</a></code> and <code><a href="#topic+OTC2">OTC2</a></code> for creating an object of class
<kbd>"OTC"</kbd>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Find the optimal testing configuration for
#   non-informative two-stage hierarchical testing.
res1 &lt;- OTC1(algorithm = "D2", p = 0.01, Se = 0.99, Sp = 0.99,
             group.sz = 3:100, obj.fn = c("ET", "MAR", "GR1"),
             weights = matrix(data = c(1, 1), nrow = 1, ncol = 2))
plot(res1)

# Customize the plot using the ggplot2 package.
library(ggplot2)
plot(res1) + ylim(0,1) +
  ggtitle("Similar configurations for Dorfman testing") +
  theme(plot.title = element_text(hjust = 0.5))

# Find the optimal testing configuration for
#   informative three-stage hierarchical testing
res2 &lt;- OTC1(algorithm = "ID3", p = 0.025,
             Se = c(0.95, 0.95, 0.99), Sp = c(0.96, 0.96, 0.98),
             group.sz = 3:15, obj.fn = "ET", alpha = 2)
plot(res2)

# Find the optimal testing configuration for
#   informative array testing without master pooling.
res3 &lt;- OTC1(algorithm = "IA2", p = 0.09, alpha = 2,
             Se = 0.90, Sp = 0.90, group.sz = 3:20, obj.fn = "ET")
plot(res3)

# Find the optimal testing configuration for
#   informative two-stage hierarchical testing.
Se &lt;- matrix(data = c(rep(0.95, 2), rep(0.99, 2)),
             nrow = 2, ncol = 2, byrow = FALSE)
Sp &lt;- matrix(data = c(rep(0.96, 2), rep(0.98, 2)),
             nrow = 2, ncol = 2, byrow = FALSE)
res4 &lt;- OTC2(algorithm = "ID2", alpha = c(18.25, 0.75, 0.75, 0.25),
                Se = Se, Sp = Sp, group.sz = 12:20)
plot(res4)


# Find the optimal testing configuration for
#   non-informative array testing with master pooling.
res5 &lt;- OTC2(algorithm = "A2M", p.vec = c(0.90, 0.04, 0.04, 0.02),
             Se = rep(0.99, 2), Sp = rep(0.99, 2), group.sz = 3:20)
plot(res5)
</code></pre>

<hr>
<h2 id='pmf'>Access the testing probability mass function returned from an object</h2><span id='topic+pmf'></span>

<h3>Description</h3>

<p><code>pmf</code> is a generic function that extracts the probability
mass function from an object (if available) that contains information
aboout a testing configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmf(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmf_+3A_object">object</code></td>
<td>
<p>An object from which the probability mass function is to be extracted.</p>
</td></tr>
<tr><td><code id="pmf_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>pmf</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher R. Bilder
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmf.halving">pmf.halving</a></code> and <code><a href="#topic+pmf.Sterrett">pmf.Sterrett</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- halving(p = rep(0.01, 10), Sp = 1, Se = 1,
               stages = 2, order.p = TRUE)
pmf.halving(res)
</code></pre>

<hr>
<h2 id='pmf.halving'>Extract probability mass function (PMF) from group testing results</h2><span id='topic+pmf.halving'></span>

<h3>Description</h3>

<p>Extract the probability mass function from group testing results
for the halving algorithm (objects of class &quot;halving&quot; returned
by <code><a href="#topic+halving">halving</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'halving'
pmf(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmf.halving_+3A_object">object</code></td>
<td>
<p>An object of class &quot;halving&quot;, created by <code><a href="#topic+halving">halving</a></code>,
from which the PMF is to be extracted.</p>
</td></tr>
<tr><td><code id="pmf.halving_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containing the probability mass function
extracted from the object <kbd>object</kbd>.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- halving(p = rep(0.01, 10), Sp = 1, Se = 1,
               stages = 2, order.p = TRUE)
pmf(res)
</code></pre>

<hr>
<h2 id='pmf.Sterrett'>Extract probability mass function (PMF) from group testing results</h2><span id='topic+pmf.Sterrett'></span>

<h3>Description</h3>

<p>Extract the probability mass function from group testing results
for the Sterrett algorithm (objects of class &quot;Sterrett&quot; returned
by <code><a href="#topic+Sterrett">Sterrett</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Sterrett'
pmf(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmf.Sterrett_+3A_object">object</code></td>
<td>
<p>An object of class &quot;Sterrett&quot;, created by
<code><a href="#topic+Sterrett">Sterrett</a></code>, from which the PMF is to be extracted.</p>
</td></tr>
<tr><td><code id="pmf.Sterrett_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containing the probability mass function
extracted from the object <kbd>object</kbd>.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1231)
p.vec &lt;- rbeta(n = 8, shape1 = 1, shape2 = 10)
res &lt;- Sterrett(p = p.vec, Sp = 0.90, Se = 0.95)
pmf(res)
</code></pre>

<hr>
<h2 id='predict.gtReg'>Predict method for <kbd>gtReg</kbd></h2><span id='topic+predict.gtReg'></span>

<h3>Description</h3>

<p>Obtains predictions for individual observations and
optionally computes the standard errors of those predictions from
objects of class <kbd>"gtReg"</kbd> returned by <code><a href="#topic+gtReg">gtReg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gtReg'
predict(
  object,
  newdata,
  type = c("link", "response"),
  se.fit = FALSE,
  conf.level = NULL,
  na.action = na.pass,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gtReg_+3A_object">object</code></td>
<td>
<p>a fitted object of class <kbd>"gtReg"</kbd>.</p>
</td></tr>
<tr><td><code id="predict.gtReg_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for
variables with which to predict. If omitted, the fitted linear
predictors are used.</p>
</td></tr>
<tr><td><code id="predict.gtReg_+3A_type">type</code></td>
<td>
<p>the type of prediction required. The <kbd>"link"</kbd>
option is on the scale of the linear predictors. The <kbd>"response"</kbd>
option is on the scale of the response variable. Thus, for the
logit model, the <kbd>"link"</kbd> predictions are of log-odds
(probabilities on the logit scale) and  <kbd>type = "response"</kbd>
gives the predicted probabilities.</p>
</td></tr>
<tr><td><code id="predict.gtReg_+3A_se.fit">se.fit</code></td>
<td>
<p>a logical value indicating whether standard errors
are required.</p>
</td></tr>
<tr><td><code id="predict.gtReg_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level of the interval for the
predicted values.</p>
</td></tr>
<tr><td><code id="predict.gtReg_+3A_na.action">na.action</code></td>
<td>
<p>a function determining what should be done with
missing values in <kbd>newdata</kbd>. The default is to predict <kbd>NA</kbd>.</p>
</td></tr>
<tr><td><code id="predict.gtReg_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <kbd>newdata</kbd> is omitted, the predictions are based
on the data used for the fit. When <kbd>newdata</kbd> is present and
contains missing values, how the missing values will be dealt with
is determined by the <kbd>na.action</kbd> argument. In this case, if
<kbd>na.action = na.omit</kbd>, omitted cases will not appear, whereas
if <kbd>na.action = na.exclude</kbd>, omitted cases will appear (in
predictions and standard errors) with value <kbd>NA</kbd>.
</p>


<h3>Value</h3>

<p>If <kbd>se = FALSE</kbd>, a vector or matrix of predictions. If
<kbd>se = TRUE</kbd>, a list containing:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>predictions.</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>estimated standard errors.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>the lower bound of the confidence interval,
if calculated (i.e., <kbd>conf.level</kbd> is specified).</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>the upper bound of the confidence interval,
if calculated (i.e., <kbd>conf.level</kbd> is specified).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Boan Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hivsurv)
fit1 &lt;- gtReg(formula = groupres ~ AGE + EDUC.,
              data = hivsurv, groupn = gnum,
              sens = 0.9, spec = 0.9,
              linkf = "logit", method = "V")
pred.data &lt;- data.frame(AGE = c(15, 25, 30),
                        EDUC. = c(1, 3, 2))
predict(object = fit1, newdata = pred.data,
        type = "link", se.fit = TRUE)
predict(object = fit1, newdata = pred.data,
        type = "response", se.fit = TRUE,
        conf.level = 0.9)
predict(object = fit1, type = "response",
        se.fit = TRUE, conf.level = 0.9)
</code></pre>

<hr>
<h2 id='print.designEst'>Print method for objects of class &quot;designEst&quot;</h2><span id='topic+print.designEst'></span>

<h3>Description</h3>

<p>Print method for objects of class &quot;designEst&quot; created by
<code><a href="#topic+designEst">designEst</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'designEst'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.designEst_+3A_x">x</code></td>
<td>
<p>an object of class &quot;designEst&quot; created by <code><a href="#topic+designEst">designEst</a></code>.</p>
</td></tr>
<tr><td><code id="print.designEst_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>print</code>.
Currently only <code>digits</code> to be passed to <code>signif</code> for
appropriate rounding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out detailing whether the bias restriction was violated,
whether the maximum allowed group size was reached, and the minimum MSE and
associated group size, expected value, variance, and bias.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>

<hr>
<h2 id='print.designPower'>Print method for objects of class &quot;designPower&quot;</h2><span id='topic+print.designPower'></span>

<h3>Description</h3>

<p>Print method for objects of class &quot;designPower&quot;
created by <code><a href="#topic+designPower">designPower</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'designPower'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.designPower_+3A_x">x</code></td>
<td>
<p>an object of class &quot;designPower&quot; created by
<code><a href="#topic+designPower">designPower</a></code>.</p>
</td></tr>
<tr><td><code id="print.designPower_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>print</code>.
Currently only <code>digits</code> to be passed to <code>signif</code> for
appropriate rounding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out detailing whether or not power was reached in
the range of values (<kbd>n</kbd> or <kbd>s</kbd>) provided, the maximal
power reached in the range of values, the alternative hypothesis,
and the assumed true proportion.
</p>


<h3>Author(s)</h3>

<p>This function was originally written as <code>print.bgtDesign</code>
by Frank Schaarschmidt for the <code>binGroup</code> package. Minor
modifications were made for inclusion in the <code>binGroup2</code> package.
</p>

<hr>
<h2 id='print.gtReg'>Print method for <kbd>gtReg</kbd></h2><span id='topic+print.gtReg'></span>

<h3>Description</h3>

<p>Print method for objects obtained by <code><a href="#topic+gtReg">gtReg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gtReg'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gtReg_+3A_x">x</code></td>
<td>
<p>An object of class &quot;gtReg&quot; created by <code><a href="#topic+gtReg">gtReg</a></code>.</p>
</td></tr>
<tr><td><code id="print.gtReg_+3A_digits">digits</code></td>
<td>
<p>digits for rounding.</p>
</td></tr>
<tr><td><code id="print.gtReg_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of the function call, coefficients, and the null and
residual deviance and degrees of freedom.
</p>


<h3>Author(s)</h3>

<p>This function was originally written by Boan Zhang as the
<kbd>print.gt</kbd> function for the <code>binGroup</code> package. Minor modifications
were made for inclusion in the <code>binGroup2</code> package.
</p>

<hr>
<h2 id='print.gtTest'>Print method for objects of class &quot;gtTest&quot;</h2><span id='topic+print.gtTest'></span>

<h3>Description</h3>

<p>Print method for objects of class &quot;gtTest&quot; created
by the <code><a href="#topic+gtTest">gtTest</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gtTest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gtTest_+3A_x">x</code></td>
<td>
<p>An object of class &quot;gtTest&quot; (<code><a href="#topic+gtTest">gtTest</a></code>).</p>
</td></tr>
<tr><td><code id="print.gtTest_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>print</code>.
Currently only <code>digits</code> to be passed to <code>signif</code> for
appropriate rounding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of the p-value and point estimate resulting
from <code><a href="#topic+gtTest">gtTest</a></code>.
</p>


<h3>Author(s)</h3>

<p>This function was originally written as <code>print.bgtTest</code> by
Brad Biggerstaff for the <code>binGroup</code>
package. Minor modifications were made for inclusion of the function in
the <code>binGroup2</code> package.
</p>

<hr>
<h2 id='print.halving'>Print method for objects of class &quot;halving&quot;</h2><span id='topic+print.halving'></span>

<h3>Description</h3>

<p>Print method for objects of class &quot;halving&quot; created
by the <code><a href="#topic+halving">halving</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'halving'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.halving_+3A_x">x</code></td>
<td>
<p>An object of class &quot;halving&quot; (<code><a href="#topic+halving">halving</a></code>).</p>
</td></tr>
<tr><td><code id="print.halving_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>print</code>.
Currently only <code>digits</code> to be passed to <code>signif</code> for
appropriate rounding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of the PMF, expected testing expenditure and variance
of testing expenditure resulting from <code><a href="#topic+halving">halving</a></code>.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>

<hr>
<h2 id='print.opChar'>Print method for operating characteristics results</h2><span id='topic+print.opChar'></span>

<h3>Description</h3>

<p>Print method for objects of class <kbd>"opChar"</kbd> returned by
<code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code> (<kbd>opChar1</kbd>) or
<code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code> (<kbd>opChar2</kbd>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'opChar'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.opChar_+3A_x">x</code></td>
<td>
<p>an object of class <kbd>"opChar"</kbd>, providing the calculated
operating characteristics for a group testing algorithm.</p>
</td></tr>
<tr><td><code id="print.opChar_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>print</code> (e.g.,
<code>digits</code> to be passed to <code>round</code> for appropriate rounding).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of the algorithm, testing configuration, expected number
of tests, expected number of tests per individual, and accuracy measures
for individuals and for the overall algorithm.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>

<hr>
<h2 id='print.OTC'>Print method for optimal testing configuration results</h2><span id='topic+print.OTC'></span>

<h3>Description</h3>

<p>Print method for objects of class <kbd>"OTC"</kbd> returned by
<code><a href="#topic+OTC1">OTC1</a></code> or <code><a href="#topic+OTC2">OTC2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'OTC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.OTC_+3A_x">x</code></td>
<td>
<p>an object of class <kbd>"OTC"</kbd>, providing the optimal testing
configuration results for a group testing algorithm.</p>
</td></tr>
<tr><td><code id="print.OTC_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>print</code> (e.g.,
<code>digits</code> to be passed to <code>round</code> for appropriate rounding).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of the algorithm, testing configuration, expected number
of tests, expected number of tests per individual, and accuracy measures
for individuals and for the overall algorithm.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>

<hr>
<h2 id='print.predict.gtReg'>Print method for <kbd>predict.gtReg</kbd></h2><span id='topic+print.predict.gtReg'></span>

<h3>Description</h3>

<p>Print method for objects obtained by
<code><a href="#topic+predict.gtReg">predict.gtReg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict.gtReg'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.predict.gtReg_+3A_x">x</code></td>
<td>
<p>An object of class &quot;predict.gtReg&quot; created by
<code><a href="#topic+predict.gtReg">predict.gtReg</a></code>.</p>
</td></tr>
<tr><td><code id="print.predict.gtReg_+3A_digits">digits</code></td>
<td>
<p>digits for rounding.</p>
</td></tr>
<tr><td><code id="print.predict.gtReg_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of predictions with rows corresponding to each observation
in <kbd>newdata</kbd> (if provided) or each observation in the data set used
for the fit. The columns correspond to the predictions (<kbd>fit</kbd>), the
estimated standard errors (<kbd>se.fit</kbd>), the lower bound of the confidence
interval (<kbd>lower</kbd>), and the upper bound of the confidence interval
(<kbd>upper</kbd>).
If <kbd>conf.level</kbd> is not specified, the <kbd>lower</kbd> and <kbd>upper</kbd>
columns will not be included. If <kbd>se = FALSE</kbd>, the <kbd>se.fit</kbd> column
will not be included.
</p>


<h3>Author(s)</h3>

<p>Brianna Hitt
</p>

<hr>
<h2 id='print.propCI'>Print method for objects of class &quot;propCI&quot;</h2><span id='topic+print.propCI'></span>

<h3>Description</h3>

<p>Print method for objects of class &quot;propCI&quot; 
created by the <code><a href="#topic+propCI">propCI</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'propCI'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.propCI_+3A_x">x</code></td>
<td>
<p>An object of class &quot;propCI&quot; (<code><a href="#topic+propCI">propCI</a></code>).</p>
</td></tr>
<tr><td><code id="print.propCI_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of the point estimate and confidence interval 
found with <code><a href="#topic+propCI">propCI</a></code>.
</p>


<h3>Author(s)</h3>

<p>This function is a combination of <code>print.poolbindiff</code> and 
<code>print.bgt</code>, written by Brad Biggerstaff for the <code>binGroup</code> 
package. Minor modifications were made for inclusion of the function in 
the <code>binGroup2</code> package.
</p>

<hr>
<h2 id='print.propDiffCI'>Print method for objects of class &quot;propDiffCI&quot;</h2><span id='topic+print.propDiffCI'></span>

<h3>Description</h3>

<p>Print method for objects of class &quot;propDiffCI&quot;
created by the <code><a href="#topic+propDiffCI">propDiffCI</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'propDiffCI'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.propDiffCI_+3A_x">x</code></td>
<td>
<p>An object of class &quot;propDiffCI&quot; (<code><a href="#topic+propDiffCI">propDiffCI</a></code>).</p>
</td></tr>
<tr><td><code id="print.propDiffCI_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of the point estimate and confidence interval
found with <code><a href="#topic+propDiffCI">propDiffCI</a></code>.
</p>


<h3>Author(s)</h3>

<p>This function was originally written as <code>print.poolbindiff</code>
by Brad Biggerstaff for the <code>binGroup</code> package. Minor
modifications were made for inclusion of the function in the
<code>binGroup2</code> package.
</p>

<hr>
<h2 id='print.Sterrett'>Print method for objects of class &quot;Sterrett&quot;</h2><span id='topic+print.Sterrett'></span>

<h3>Description</h3>

<p>Print method for objects of class &quot;Sterrett&quot; created
by the <code><a href="#topic+Sterrett">Sterrett</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Sterrett'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Sterrett_+3A_x">x</code></td>
<td>
<p>An object of class &quot;Sterrett&quot; (<code><a href="#topic+Sterrett">Sterrett</a></code>).</p>
</td></tr>
<tr><td><code id="print.Sterrett_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>print</code>.
Currently only <code>digits</code> to be passed to <code>signif</code> for
appropriate rounding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of the PMF, expected testing expenditure and variance
of testing expenditure resulting from <code><a href="#topic+Sterrett">Sterrett</a></code>.
</p>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>

<hr>
<h2 id='print.summary.gtReg'>Print method for <kbd>summary.gtReg</kbd></h2><span id='topic+print.summary.gtReg'></span>

<h3>Description</h3>

<p>Print method for objects obtained by
<code><a href="#topic+summary.gtReg">summary.gtReg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.gtReg'
print(
  x,
  digits = max(3, getOption("digits") - 3),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.gtReg_+3A_x">x</code></td>
<td>
<p>An object of class &quot;summary.gtReg&quot; created by
<code><a href="#topic+summary.gtReg">summary.gtReg</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.gtReg_+3A_digits">digits</code></td>
<td>
<p>digits for rounding.</p>
</td></tr>
<tr><td><code id="print.summary.gtReg_+3A_signif.stars">signif.stars</code></td>
<td>
<p>a logical value indicating whether significance
stars should be shown.</p>
</td></tr>
<tr><td><code id="print.summary.gtReg_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>printCoefmat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of the function call, deviance residuals (for
simple pooling and halving only), coefficients, null and
residual deviance and degrees of freedom (for simple pooling only),
AIC (for simple pooling and halving only), number of
Gibbs samples (for array testing only), and the number of
iterations.
</p>


<h3>Author(s)</h3>

<p>This function combines code from
<code>print.summary.gt</code> and
<code>print.summary.gt.mp</code>, written by Boan Zhang
for the <code>binGroup</code> package. Minor modifications were
made for inclusion in the <code>binGroup2</code> package.
</p>

<hr>
<h2 id='print.TOD'>Print method for <kbd>TOD</kbd></h2><span id='topic+print.TOD'></span>

<h3>Description</h3>

<p>Print method for objects obtained by
<code><a href="#topic+TOD">TOD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TOD'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.TOD_+3A_x">x</code></td>
<td>
<p>An object of class &quot;TOD&quot; created by
<code><a href="#topic+TOD">TOD</a></code>.</p>
</td></tr>
<tr><td><code id="print.TOD_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A print out of configuration and operating characteristics
found with <code><a href="#topic+TOD">TOD</a></code>.
</p>


<h3>Author(s)</h3>

<p>Chris Bilder
</p>

<hr>
<h2 id='propCI'>Confidence intervals for one proportion in group testing</h2><span id='topic+propCI'></span>

<h3>Description</h3>

<p>Calculates point estimates and confidence intervals for a 
single proportion with group testing data. Methods are available for groups 
of equal or different sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propCI(
  x,
  m,
  n,
  pt.method = "mle",
  ci.method,
  conf.level = 0.95,
  alternative = "two.sided",
  maxiter = 100,
  tol = .Machine$double.eps^0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propCI_+3A_x">x</code></td>
<td>
<p>integer specifying the number of positive groups when groups are 
of equal size, or a vector specifying the number of positive groups among 
the <kbd>n</kbd> groups tested when group sizes differ. If the latter, this 
vector must be of the same length as the <kbd>m</kbd> and <kbd>n</kbd> arguments.</p>
</td></tr>
<tr><td><code id="propCI_+3A_m">m</code></td>
<td>
<p>integer specifying the common size of groups when groups are of 
equal size, or a vector specifying the group sizes when group sizes differ. 
If the latter, this vector must be of the same length as the <kbd>x</kbd> and 
<kbd>n</kbd> arguments.</p>
</td></tr>
<tr><td><code id="propCI_+3A_n">n</code></td>
<td>
<p>integer specifying the number of groups when these groups are of 
equal size, or a vector specifying the corresponding number of groups of 
the sizes <kbd>m</kbd> when group sizes differ. If the latter, this vector must 
be of the same length as the <kbd>x</kbd> and <kbd>m</kbd> arguments.</p>
</td></tr>
<tr><td><code id="propCI_+3A_pt.method">pt.method</code></td>
<td>
<p>character string specifying the point 
estimate to compute. Options include <kbd>"Firth"</kbd> for the 
bias-preventative, <kbd>"Gart"</kbd> and <kbd>"bc-mle"</kbd> for the 
bias-corrected MLE (where the latter allows for backward compatibility), 
and <kbd>"mle"</kbd> for the MLE.</p>
</td></tr>
<tr><td><code id="propCI_+3A_ci.method">ci.method</code></td>
<td>
<p>character string specifying the confidence 
interval to compute. Options include &quot;AC&quot; for the Agresti-Coull interval, 
&quot;bc-skew-score&quot; for the bias- and skewness-corrected interval, &quot;Blaker&quot; 
for the Blaker interval, &quot;CP&quot; for the Clopper-Pearson interval, &quot;exact&quot; 
for the exact interval as given by Hepworth (1996), &quot;lrt&quot; for the 
likelihood ratio test interval, &quot;score&quot; for the Wilson score interval, 
&quot;skew-score&quot; for the skewness-corrected interval, &quot;soc&quot; for the 
second-order corrected interval, and &quot;Wald&quot; for the Wald interval. Note 
that the Agresti-Coull, Blaker, Clopper-Pearson, and second-order corrected 
intervals can only be calculated when <kbd>x</kbd>, <kbd>m</kbd>, and <kbd>n</kbd> are 
given as integers (equal group size case).</p>
</td></tr>
<tr><td><code id="propCI_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="propCI_+3A_alternative">alternative</code></td>
<td>
<p>character string defining the alternative 
hypothesis, either <kbd>"two.sided"</kbd>, <kbd>"less"</kbd>, or <kbd>"greater"</kbd>.</p>
</td></tr>
<tr><td><code id="propCI_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of steps in the iteration of 
confidence limits, for use only with the <kbd>"exact"</kbd> method when 
group sizes differ.</p>
</td></tr>
<tr><td><code id="propCI_+3A_tol">tol</code></td>
<td>
<p>the accuracy required for iterations in internal functions, 
for use with asymptotic intervals when group sizes differ only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Confidence interval methods include the Agresti-Coull 
(<kbd>ci.method = "AC"</kbd>), bias- and skewness-corrected 
(<kbd>ci.method = "bc-skew-score"</kbd>), Blaker (<kbd>ci.method = "Blaker"</kbd>), 
Clopper-Pearson (<kbd>ci.method = "CP"</kbd>), exact (<kbd>ci.method = "exact"</kbd>), 
likelihood ratio test (<kbd>ci.method = "lrt"</kbd>), Wilson score 
(<kbd>ci.method = "score"</kbd>), skewness-corrected 
(<kbd>ci.method = "skew-score"</kbd>), second-order corrected 
(<kbd>ci.method = "soc"</kbd>), and Wald 
(<kbd>ci.method = "Wald"</kbd>) intervals. The Agresti-Coull, Blaker, 
Clopper-Pearson, and second-order corrected intervals are available 
only for the equal group size case.
</p>
<p>Point estimates available include the MLE (<kbd>pt.method = "mle"</kbd>), 
bias-corrected MLE (<kbd>pt.method = "Gart"</kbd> or <kbd>pt.method = "bc-mle"</kbd>), 
and bias-preventative (<kbd>pt.method = "Firth"</kbd>). Only the MLE method 
is available when calculating the Clopper-Pearson, Blaker, Agresti-Coull, 
second-order corrected, or exact intervals.
</p>


<h4>Equal group sizes</h4>

<p>Computation of confidence intervals for group testing with equal group 
sizes are described in Tebbs &amp; Bilder (2004) and Schaarschmidt (2007).</p>
 


<h4>Unequal group sizes</h4>

<p>While the exact method is available when group sizes differ, 
the algorithm becomes computationally very expensive if the number of 
different groups, <kbd>n</kbd>, becomes larger than three. See Hepworth (1996) 
for additional details on the exact method and other methods for 
constructing confidence intervals in group testing situations. For 
computational details and simulation results of the remaining methods, 
see Biggerstaff (2008). See Hepworth &amp; Biggerstaff (2017) for 
recommendations on the best point estimator methods.</p>



<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the proportion.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the point estimator of the proportion.</p>
</td></tr>
<tr><td><code>pt.method</code></td>
<td>
<p>the method used for point estimation.</p>
</td></tr>
<tr><td><code>ci.method</code></td>
<td>
<p>the method used for confidence interval estimation.</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>the confidence level of the interval.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>the alternative specified by the user.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the number of positive groups.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>the group sizes.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the numbers of groups with corresponding group sizes <kbd>m</kbd>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function is a combination of <code>bgtCI</code> and <code>bgtvs</code> 
written by Frank Schaarschmidt and <code>pooledBin</code> written by Brad 
Biggerstaff for the <code>binGroup</code> package. Minor modifications have been 
made for inclusion of the functions in the <code>binGroup2</code> package.
</p>


<h3>References</h3>

<p>Biggerstaff, B. (2008).
&ldquo;Confidence intervals for the difference of proportions estimated from pooled samples.&rdquo;
<em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>13</b>, 478&ndash;496.
</p>
<p>Hepworth, G. (1996).
&ldquo;Exact confidence intervals for proportions estimated by group testing.&rdquo;
<em>Biometrics</em>, <b>52</b>, 1134&ndash;1146.
</p>
<p>Hepworth, G., Biggerstaff, B. (2017).
&ldquo;Bias correction in estimating proportions by pooled testing.&rdquo;
<em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>22</b>, 602&ndash;614.
</p>
<p>Schaarschmidt, F. (2007).
&ldquo;Experimental design for one-sided confidence intervals or hypothesis tests in binomial group testing.&rdquo;
<em>Communications in Biometry and Crop Science</em>, <b>2</b>, 32&ndash;40.
ISSN 1896-0782.
</p>
<p>Tebbs, J., Bilder, C. (2004).
&ldquo;Confidence interval procedures for the probability of disease transmission in multiple-vector-transfer designs.&rdquo;
<em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>9</b>, 75&ndash;90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+propDiffCI">propDiffCI</a></code> for confidence intervals for the 
difference of proportions in group testing, <code><a href="#topic+gtTest">gtTest</a></code> for 
hypothesis tests in group testing, <code><a href="#topic+gtPower">gtPower</a></code> for power 
calculations in group testing, and <code><a href="stats.html#topic+binom.test">binom.test</a></code> for an exact 
confidence interval and test.
</p>
<p>Other estimation functions: 
<code><a href="#topic+designEst">designEst</a>()</code>,
<code><a href="#topic+designPower">designPower</a>()</code>,
<code><a href="#topic+gtPower">gtPower</a>()</code>,
<code><a href="#topic+gtTest">gtTest</a>()</code>,
<code><a href="#topic+gtWidth">gtWidth</a>()</code>,
<code><a href="#topic+propDiffCI">propDiffCI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from Tebbs and Bilder (2004):
#   3 groups out of 24 test positively; 
#   each group has a size of 7.
# Clopper-Pearson interval:
propCI(x = 3, m = 7, n = 24, ci.method = "CP", 
       conf.level = 0.95, alternative = "two.sided")
      
# Clopper-Pearson interval with the bias-corrected 
#   MLE (\kbd{pt.method = "Gart"}). 
propCI(x = 3, m = 7, n = 24, pt.method = "Gart", 
       ci.method = "CP", conf.level = 0.95, 
       alternative = "two.sided")
      
# One-sided Clopper-Pearson interval:
propCI(x = 3, m = 7, n = 24, ci.method = "CP", 
       conf.level = 0.95, alternative = "less")
       
# Blaker interval:
propCI(x = 3, m = 7, n = 24, ci.method = "Blaker", 
       conf.level = 0.95, alternative = "two.sided")
      
# Wilson score interval: 
propCI(x = 3, m = 7, n = 24, ci.method = "score", 
       conf.level = 0.95, alternative = "two.sided")

# Calculate confidence intervals with a group size of 1. 
#   These match those found using the binom.confint() 
#   function from the binom package.
propCI(x = 4, m = 1, n = 10, pt.method = "mle", 
       ci.method = "AC")
propCI(x = 4, m = 1, n = 10, pt.method = "mle", 
       ci.method = "score")
propCI(x = 4, m = 1, n = 10, pt.method = "mle", 
       ci.method = "Wald")

# Example from Hepworth (1996, table 5):
#   1 group out of 2 tests positively with 
#   groups of size 5; also, 
#   2 groups out of 3 test positively with 
#   groups of size 2.
propCI(x = c(1,2), m = c(5,2), n = c(2,3), ci.method = "exact") 

# Bias-preventative point estimate (\kbd{pt.method = "Firth"}) 
#   with an exact confidence interval.
propCI(x = c(1,2), m = c(5,2), n = c(2,3), 
       pt.method = "Firth", ci.method = "exact") 

# Recalculate the example given in
#   Hepworth (1996), table 5:
propCI(x = c(0,0), m = c(5,2), n = c(2,3), ci.method = "exact")
propCI(x = c(0,1), m = c(5,2), n = c(2,3), ci.method = "exact")
propCI(x = c(0,2), m = c(5,2), n = c(2,3), ci.method = "exact")
propCI(x = c(0,3), m = c(5,2), n = c(2,3), ci.method = "exact")
propCI(x = c(1,0), m = c(5,2), n = c(2,3), ci.method = "exact")
propCI(x = c(1,1), m = c(5,2), n = c(2,3), ci.method = "exact")
propCI(x = c(1,2), m = c(5,2), n = c(2,3), ci.method = "exact")
propCI(x = c(1,3), m = c(5,2), n = c(2,3), ci.method = "exact")
propCI(x = c(2,0), m = c(5,2), n = c(2,3), ci.method = "exact")
propCI(x = c(2,1), m = c(5,2), n = c(2,3), ci.method = "exact")
propCI(x = c(2,2), m = c(5,2), n = c(2,3), ci.method = "exact")
propCI(x = c(2,3), m = c(5,2), n = c(2,3), ci.method = "exact")

# Example with multiple groups of various sizes: 
#   0 out of 5 groups test positively with 
#   groups of size 1 (individual testing);
#   0 out of 5 groups test positively with 
#   groups of size 5;
#   1 out of 5 groups test positively with 
#   groups of size 10; and
#   2 out of 5 groups test positively with 
#   groups of size 50.
x1 &lt;- c(0, 0, 1, 2)
m1 &lt;- c(1, 5, 10, 50)
n1 &lt;- c(5, 5, 5, 5)
propCI(x = x1, m = m1, n = n1, pt.method = "Gart", 
       ci.method = "skew-score")
propCI(x = x1, m = m1, n = n1, pt.method = "Gart", 
       ci.method = "score")

# Reproducing estimates from Table 1 in
#   Hepworth &amp; Biggerstaff (2017):
propCI(x = c(1, 2), m = c(20, 5), n = c(8, 8), 
       pt.method = "Firth", ci.method = "lrt")
propCI(x = c(7, 8), m = c(20, 5), n = c(8, 8), 
       pt.method = "Firth", ci.method = "lrt")
</code></pre>

<hr>
<h2 id='propDiffCI'>Confidence intervals for the difference of proportions
in group testing</h2><span id='topic+propDiffCI'></span>

<h3>Description</h3>

<p>Calculates confidence intervals for the difference of two
proportions based on group testing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propDiffCI(
  x1,
  m1,
  x2,
  m2,
  n1 = rep(1, length(x1)),
  n2 = rep(1, length(x2)),
  pt.method = c("Firth", "Gart", "bc-mle", "mle"),
  ci.method = c("skew-score", "bc-skew-score", "score", "lrt", "Wald"),
  conf.level = 0.95,
  tol = .Machine$double.eps^0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propDiffCI_+3A_x1">x1</code></td>
<td>
<p>vector specifying the observed number of positive
groups among the number of groups tested (<kbd>n1</kbd>) in population 1.</p>
</td></tr>
<tr><td><code id="propDiffCI_+3A_m1">m1</code></td>
<td>
<p>vector of corresponding group sizes in population 1.
Must have the same length as <kbd>x1</kbd>.</p>
</td></tr>
<tr><td><code id="propDiffCI_+3A_x2">x2</code></td>
<td>
<p>vector specifying the observed number of positive
groups among the number of groups tested (<kbd>n2</kbd>) in population 2.</p>
</td></tr>
<tr><td><code id="propDiffCI_+3A_m2">m2</code></td>
<td>
<p>vector of corresponding group sizes in population 2.
Must have the same length as <kbd>x2</kbd>.</p>
</td></tr>
<tr><td><code id="propDiffCI_+3A_n1">n1</code></td>
<td>
<p>vector of the corresponding number of groups with
sizes <kbd>m1</kbd>.</p>
</td></tr>
<tr><td><code id="propDiffCI_+3A_n2">n2</code></td>
<td>
<p>vector of the corresponding number of groups with
sizes <kbd>m2</kbd>.</p>
</td></tr>
<tr><td><code id="propDiffCI_+3A_pt.method">pt.method</code></td>
<td>
<p>character string specifying the point estimator to
compute. Options include <kbd>"Firth"</kbd> for the bias-preventative estimator
(Hepworth &amp; Biggerstaff, 2017), the default <kbd>"Gart"</kbd> for the
bias-corrected MLE (Biggerstaff, 2008), <kbd>"bc-mle"</kbd> (same as
<kbd>"Gart"</kbd> for backward compatibility), and <kbd>"mle"</kbd> for the MLE.</p>
</td></tr>
<tr><td><code id="propDiffCI_+3A_ci.method">ci.method</code></td>
<td>
<p>character string specifying the confidence interval to
compute. Options include <kbd>"skew-score"</kbd> for the skewness-corrected,
<kbd>"score"</kbd> for the score (the default), <kbd>"bc-skew-score"</kbd> for the
bias- and skewness-corrected, <kbd>"lrt"</kbd> for the likelihood ratio test,
and <kbd>"Wald"</kbd> for the Wald interval. See Biggerstaff (2008) for
additional details.</p>
</td></tr>
<tr><td><code id="propDiffCI_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="propDiffCI_+3A_tol">tol</code></td>
<td>
<p>the accuracy required for iterations in internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Confidence interval methods include the Wilson score
(<kbd>ci.method = "score"</kbd>), skewness-corrected score
(<kbd>ci.method = "skew-score"</kbd>), bias- and skewness-corrected score
(<kbd>ci.method = "bc-skew-score"</kbd>), likelihood ratio test
(<kbd>ci.method = "lrt"</kbd>), and Wald (<kbd>ci.method = "Wald"</kbd>) interval.
For computational details, simulation results, and recommendations on
confidence interval methods, see Biggerstaff (2008).
</p>
<p>Point estimates available include the MLE (<kbd>pt.method = "mle"</kbd>),
bias-corrected MLE (<kbd>pt.method = "Gart"</kbd> or
<kbd>pt.method = "bc-mle"</kbd>), and bias-preventative
(<kbd>pt.method = "Firth"</kbd>). For additional details and recommendations
on point estimation, see Hepworth and Biggerstaff (2017).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>the estimated difference of proportions.</p>
</td></tr>
<tr><td><code>lcl</code></td>
<td>
<p>the lower confidence limit.</p>
</td></tr>
<tr><td><code>ucl</code></td>
<td>
<p>the upper confidence limit.</p>
</td></tr>
<tr><td><code>pt.method</code></td>
<td>
<p>the method used for point estimation.</p>
</td></tr>
<tr><td><code>ci.method</code></td>
<td>
<p>the method used for confidence interval estimation.</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>the confidence level of the interval.</p>
</td></tr>
<tr><td><code>x1</code></td>
<td>
<p>the numbers of positive groups in population 1.</p>
</td></tr>
<tr><td><code>m1</code></td>
<td>
<p>the sizes of the groups in population 1.</p>
</td></tr>
<tr><td><code>n1</code></td>
<td>
<p>the numbers of groups with corresponding group sizes
<kbd>m1</kbd> in population 1.</p>
</td></tr>
<tr><td><code>x2</code></td>
<td>
<p>the numbers of positive groups in population 2.</p>
</td></tr>
<tr><td><code>m2</code></td>
<td>
<p>the sizes of the groups in population 2.</p>
</td></tr>
<tr><td><code>n2</code></td>
<td>
<p>the numbers of groups with corresponding group sizes
<kbd>m2</kbd> in population 2.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function was originally written as the <code>pooledBinDiff</code>
function by Brad Biggerstaff for the <code>binGroup</code> package. Minor
modifications were made for inclusion of the function in the
<code>binGroup2</code> package.
</p>


<h3>References</h3>

<p>Biggerstaff, B. (2008).
&ldquo;Confidence intervals for the difference of proportions estimated from pooled samples.&rdquo;
<em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>13</b>, 478&ndash;496.
</p>
<p>Hepworth, G., Biggerstaff, B. (2017).
&ldquo;Bias correction in estimating proportions by pooled testing.&rdquo;
<em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>22</b>, 602&ndash;614.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+propCI">propCI</a></code> for confidence intervals for one proportion
in group testing, <code><a href="#topic+gtTest">gtTest</a></code> for hypothesis tests in group
testing, and <code><a href="#topic+gtPower">gtPower</a></code> for power calculations in group testing.
</p>
<p>Other estimation functions: 
<code><a href="#topic+designEst">designEst</a>()</code>,
<code><a href="#topic+designPower">designPower</a>()</code>,
<code><a href="#topic+gtPower">gtPower</a>()</code>,
<code><a href="#topic+gtTest">gtTest</a>()</code>,
<code><a href="#topic+gtWidth">gtWidth</a>()</code>,
<code><a href="#topic+propCI">propCI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate the prevalence in two populations
#   with multiple groups of various sizes:
# Population 1:
#   0 out of 5 groups test positively with
#   groups of size 1 (individual testing);
#   0 out of 5 groups test positively with
#   groups of size 5;
#   1 out of 5 groups test positively with
#   groups of size 10; and
#   2 out of 5 groups test positively with
#   groups of size 50.
# Population 2:
#   0 out of 5 groups test positively with
#   groups of size 1 (individual testing);
#   1 out of 5 groups test positively with
#   groups of size 5;
#   0 out of 5 groups test positively with
#   groups of size 10; and
#   4 out of 5 groups test positively with
#   groups of size 50.
x1 &lt;- c(0, 0, 1, 2)
m &lt;- c(1, 5, 10, 50)
n &lt;- c(5, 5, 5, 5)
x2 &lt;- c(0, 1, 0, 4)
propDiffCI(x1 = x1, m1 = m, x2 = x2, m2 = m, n1 = n, n2 = n,
           pt.method = "Gart", ci.method = "score")

# Compare recommended methods:
propDiffCI(x1 = x1, m1 = m, x2 = x2, m2 = m, n1 = n, n2 = n,
           pt.method = "mle", ci.method = "lrt")

propDiffCI(x1 = x1, m1 = m, x2 = x2, m2 = m, n1 = n, n2 = n,
           pt.method = "mle", ci.method = "score")

propDiffCI(x1 = x1, m1 = m, x2 = x2, m2 = m, n1 = n, n2 = n,
           pt.method = "mle", ci.method = "skew-score")
</code></pre>

<hr>
<h2 id='residuals.gtReg'>Extract model residuals from a fitted group testing model</h2><span id='topic+residuals.gtReg'></span>

<h3>Description</h3>

<p>Extract model residuals from objects of class &quot;gtReg&quot; returned
by <code><a href="#topic+gtReg">gtReg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gtReg'
residuals(object, type = c("deviance", "pearson", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.gtReg_+3A_object">object</code></td>
<td>
<p>An object of class &quot;gtReg&quot;, created by <code><a href="#topic+gtReg">gtReg</a></code>,
from which the model residuals are to be extracted.</p>
</td></tr>
<tr><td><code id="residuals.gtReg_+3A_type">type</code></td>
<td>
<p>The type of residuals which should be returned. Options include
&quot;<kbd>deviance</kbd>&quot; (default), &quot;<kbd>pearson</kbd>&quot;, and &quot;<kbd>response</kbd>&quot;.</p>
</td></tr>
<tr><td><code id="residuals.gtReg_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Residuals of group responses extracted from the object <kbd>object</kbd>.
</p>


<h3>Author(s)</h3>

<p>This function was originally written by Boan Zhang as the
<kbd>residuals.gt</kbd> function for the <code>binGroup</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hivsurv)
fit1 &lt;- gtReg(formula = groupres ~ AGE * EDUC.,
              data = hivsurv, groupn = gnum,
              linkf = "probit")
residuals(object = fit1, type = "pearson")
residuals(object = fit1, type = "deviance")
</code></pre>

<hr>
<h2 id='Sterrett'>Summary measures for Sterrett algorithms</h2><span id='topic+Sterrett'></span>

<h3>Description</h3>

<p>Summary measures for Sterrett algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sterrett(
  p,
  Sp,
  Se,
  plot = FALSE,
  plot.cut.dorf = FALSE,
  cond.prob.plot = FALSE,
  font.name = "sans"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sterrett_+3A_p">p</code></td>
<td>
<p>a vector of individual risk probabilities.</p>
</td></tr>
<tr><td><code id="Sterrett_+3A_sp">Sp</code></td>
<td>
<p>the specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="Sterrett_+3A_se">Se</code></td>
<td>
<p>the sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="Sterrett_+3A_plot">plot</code></td>
<td>
<p>logical; if TRUE, a plot of the informative Sterrett
CDFs will be displayed. Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="Sterrett_+3A_plot.cut.dorf">plot.cut.dorf</code></td>
<td>
<p>logical; if TRUE, the cut-tree for Dorfman
testing will be displayed. Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="Sterrett_+3A_cond.prob.plot">cond.prob.plot</code></td>
<td>
<p>logical; if TRUE, a second axis for the
conditional probability plot will be displayed on the right side
of the plot.</p>
</td></tr>
<tr><td><code id="Sterrett_+3A_font.name">font.name</code></td>
<td>
<p>the name of the font to be used in plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates summary measures for informative
Sterrett algorithms. Informative algorithms include one-stage informative
Sterrett (1SIS), two-stage informative Sterrett (2SIS), full informative
Sterrett (FIS), and Dorfman (two-stage hierarchical testing).
</p>
<p>The mean and standard deviation of the number of tests,
probability mass function (PMF), and cumulative distribution function (CDF)
are calculated for all informative Sterrett algorithms and
Dorfman testing. Conditional PMFs and conditional moments are calculated
for all informative Sterrett algorithms. Subtracting the mean number of
tests for two procedures gives the area difference between their CDFs.
This area difference is calculated for each pairwise comparison of
1SIS, 2SIS, FIS, and Dorfman testing. CDF plots provide a visualization
of how probabilities are distributed over the number of tests. CDFs that
increase more rapidly to 1 correspond to more efficient retesting
procedures.
</p>
<p>Non-informative Sterrett (NIS) decodes positive groups by retesting
individuals at random, so there are <code class="reqn">I!</code> different possible
NIS implementations. CDFs are found by permuting the elements in the
vector of individual risk probabilities and using the FIS CDF expression
without reordering the individual probabilities. That is, the FIS
procedure uses the most efficient NIS implementation, which is to
retest individuals in order of descending probabilities.
When implementing the informative Sterrett algorithms with a large
number of individuals, an algorithm is used to compute the PMF
for the number of tests under FIS. This is done automatically
by <kbd>Sterrett</kbd> for <code class="reqn">I&gt;12</code>. The algorithm is described in
detail in the Appendix of Bilder et al. (2010).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>mean.sd</code></td>
<td>
<p>a data frame containing the mean and standard deviation
of the expected number of tests for one-stage informative Sterrett (1SIS),
two-stage informative Sterrett (2SIS), full informative Sterrett (FIS),
and Dorfman testing.</p>
</td></tr>
<tr><td><code>PMF</code></td>
<td>
<p>a data frame containing the probability mass function
for the number of tests possible for one-stage informative Sterrett (1SIS),
two-stage informative Sterrett (2SIS), full informative Sterrett (FIS),
and Dorfman testing.</p>
</td></tr>
<tr><td><code>CDF</code></td>
<td>
<p>a data frame containing the cumulative distribution function
for the number of tests possible for one-stage informative Sterrett (1SIS),
two-stage informative Sterrett (2SIS), full informative Sterrett (FIS),
and Dorfman testing.</p>
</td></tr>
<tr><td><code>cond.PMF</code></td>
<td>
<p>a data frame containing the conditional probability
mass function for the number of tests possible for one-stage informative
Sterrett (1SIS), two-stage informative Sterrett (2SIS), and full
informative Sterrett (FIS) testing.</p>
</td></tr>
<tr><td><code>cond.moments</code></td>
<td>
<p>a data frame containing the mean and standard deviation
of the conditional moments for one-stage informative
Sterrett (1SIS), two-stage informative Sterrett (2SIS), and full
informative Sterrett (FIS) testing.</p>
</td></tr>
<tr><td><code>save.diff.CDF</code></td>
<td>
<p>a data frame containing the sum of the differences
in the cumulative distribution function for each pairwise comparison of
one-stage informative Sterrett (1SIS), two-stage informative Sterrett
(2SIS), full informative Sterrett (FIS), and Dorfman testing.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a vector containing the probabilities of positivity for each individual.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function was originally written as <kbd>info.gt</kbd>
by Christopher Bilder for Bilder et al. (2010). The function was obtained
from <a href="http://chrisbilder.com/grouptesting/">http://chrisbilder.com/grouptesting/</a>. Minor modifications were
made for inclusion of the function in the <code>binGroup2</code> package.
</p>


<h3>References</h3>

<p>Bilder, C., Tebbs, J., Chen, P. (2010).
&ldquo;Informative retesting.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>105</b>, 942&ndash;955.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectOrderBeta">expectOrderBeta</a></code> for generating a vector of individual risk
probabilities for informative group testing and <code><a href="#topic+opChar1">opChar1</a></code> for
calculating operating characteristics with hierarchical and array-based
group testing algorithms.
</p>
<p>Other operating characteristic functions: 
<code><a href="#topic+GroupMembershipMatrix">GroupMembershipMatrix</a>()</code>,
<code><a href="#topic+TOD">TOD</a>()</code>,
<code><a href="#topic+halving">halving</a>()</code>,
<code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a>()</code>,
<code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: FIS provides the smallest mean
#   number of tests and the smallest standard
#   deviation. 2SIS has slightly larger mean
#   and standard deviation than FIS, but
#   its performance is comparable, indicating
#   2SIS may be preferred because it is
#   easier to implement.
set.seed(1231)
p.vec1 &lt;- rbeta(n = 8, shape1 = 1, shape2 = 10)
save.it1 &lt;- Sterrett(p = p.vec1, Sp = 0.90, Se = 0.95)
save.it1

# Example 2: One individual is "high risk" and
#   the others are "low risk". Since there is
#   only one high-risk individual, the three
#   informative Sterrett procedures perform
#   similarly. All three informative Sterrett
#   procedures offer large improvements over
#   Dorfman testing.
p.vec2 &lt;- c(rep(x = 0.01, times = 9), 0.5)
save.it2 &lt;- Sterrett(p = p.vec2, Sp = 0.99, Se = 0.99)
save.it2

# Example 3: Two individuals are at higher
#   risk than the others. All three informative
#   Sterrett procedures provide large
#   improvements over Dorfman testing.
# Due to the large initial group size, an
#   algorithm (described in the Appendix of
#   Bilder et al. (2010)) is used for FIS.
#   The Sterrett() function does this
#   automatically for I&gt;12.
p.vec3 &lt;- c(rep(x = 0.01, times = 98), 0.1, 0.1)
save.it3 &lt;- Sterrett(p = p.vec3, Sp = 0.99, Se = 0.99)
save.it3
</code></pre>

<hr>
<h2 id='summary.gtReg'>Summary method for <kbd>gtReg</kbd></h2><span id='topic+summary.gtReg'></span>

<h3>Description</h3>

<p>Produce a summary list for objects of class
<kbd>"gtReg"</kbd> returned by <code><a href="#topic+gtReg">gtReg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gtReg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gtReg_+3A_object">object</code></td>
<td>
<p>a fitted object of class <kbd>"gtReg"</kbd>.</p>
</td></tr>
<tr><td><code id="summary.gtReg_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <kbd>coefficients</kbd> component of the results gives a matrix
containing the estimated coefficients and their estimated standard errors.
The third column is their ratio, labeled
<kbd>z ratio</kbd> using Wald tests. A fourth column gives the
two-tailed p-value corresponding to the z-ratio based on a
Wald test. Note that it is possible that there are no residual
degrees of freedom from which to estimate, in which case the
estimate is <kbd>NaN</kbd>.
</p>


<h3>Value</h3>

<p><kbd>summary.gtReg</kbd> returns an object of class
<kbd>"summary.gtReg"</kbd>, a list containing:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the component from <kbd>object</kbd>,
for simple pooling (<kbd>type = "sp"</kbd> in <code><a href="#topic+gtReg">gtReg</a></code>) only.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the component from <kbd>object</kbd>,
for simple pooling (<kbd>type = "sp"</kbd> in <code><a href="#topic+gtReg">gtReg</a></code>) only.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the component from <kbd>object</kbd>,
for simple pooling (<kbd>type = "sp"</kbd> in <code><a href="#topic+gtReg">gtReg</a></code>) only.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the component from <kbd>object</kbd>,
for simple pooling (<kbd>type = "sp"</kbd> in <code><a href="#topic+gtReg">gtReg</a></code>) only.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>the component from <kbd>object</kbd>,
for simple pooling (<kbd>type = "sp"</kbd> in <code><a href="#topic+gtReg">gtReg</a></code>) only.</p>
</td></tr>
<tr><td><code>deviance.resid</code></td>
<td>
<p>the deviance residuals,
for simple pooling (<kbd>type = "sp"</kbd> in <code><a href="#topic+gtReg">gtReg</a></code>) only.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the matrix of coefficients, standard errors,
z-values, and p-values. Aliased coefficients are omitted.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>the component from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the component from <kbd>object</kbd>,
for simple pooling (<kbd>type = "sp"</kbd> in <code><a href="#topic+gtReg">gtReg</a></code>) only.</p>
</td></tr>
<tr><td><code>Gibbs.sample.size</code></td>
<td>
<p>the component from <kbd>object</kbd>,
for array testing (<kbd>type = "array"</kbd> in <code><a href="#topic+gtReg">gtReg</a></code>) only.</p>
</td></tr>
<tr><td><code>cov.mat</code></td>
<td>
<p>the estimated covariance matrix of the estimated
coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The majority of this function was originally written as
<code>summary.gt</code> and <code>summary.gt.mp</code> by Boan Zhang for the
<code>binGroup</code> package. Minor modifications were made to the function
for inclusion in the <code>binGroup2</code> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtReg">gtReg</a></code> for creating an object of class
<kbd>"gtReg"</kbd>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hivsurv)
fit1 &lt;- gtReg(type = "sp",
              formula = groupres ~ AGE + EDUC.,
              data = hivsurv, groupn = gnum,
              sens = 0.9, spec = 0.9,
              method = "Xie")
summary(fit1)

# 5x6 and 4x5 array
set.seed(9128)
sa2a &lt;- gtSim(type = "array", par = c(-7, 0.1),
              size1 = c(5, 4), size2 = c(6, 5),
              sens = 0.95, spec = 0.95)
sa2 &lt;- sa2a$dframe

fit2 &lt;- gtReg(type = "array",
              formula = cbind(col.resp, row.resp) ~ x,
              data = sa2, coln = coln, rown = rown,
              arrayn = arrayn, sens = 0.95, spec = 0.95,
              linkf = "logit", n.gibbs = 1000, tol = 0.005)
summary(fit2)
</code></pre>

<hr>
<h2 id='summary.opChar'>Summary method for operating characteristics results</h2><span id='topic+summary.opChar'></span>

<h3>Description</h3>

<p>Produce a summary list for objects of class
<kbd>"opChar"</kbd> returned by <code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code>
(<kbd>opChar1</kbd>) or <code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code>
(<kbd>opChar2</kbd>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'opChar'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.opChar_+3A_object">object</code></td>
<td>
<p>an object of class <kbd>"opChar"</kbd>, providing the calculated
operating characteristics for a group testing algorithm.</p>
</td></tr>
<tr><td><code id="summary.opChar_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a summary list for objects of
class <kbd>"opChar"</kbd> returned by <code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code>
(<kbd>opChar1</kbd>) or <code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code>
(<kbd>opChar2</kbd>). It formats the testing configuration, expected number
of tests, expected number of tests per individual, and accuracy measures.
</p>
<p>The <kbd>Configuration</kbd> component of the result
gives the testing configuration, which may include the group sizes for
each stage of a hierarchical testing algorithm or the row/column size and
array size for an array testing algorithm. The <kbd>Tests</kbd> component
of the result gives the expected number of tests and the expected
number of tests per individual for the algorithm.
</p>
<p>The <kbd>Accuracy</kbd> component gives the individual accuracy measures for
each individual in <kbd>object</kbd> and the overall accuracy measures for the
algorithm. Accuracy measures included are the pooling sensitivity, pooling
specificity, pooling positive predictive value, and pooling negative
predictive value. The overall accuracy measures displayed are weighted
averages of the corresponding individual accuracy measures for all
individuals in the algorithm. Expressions for these averages are provided
in the Supplementary Material for Hitt et al. (2019). For more information,
see the Details' section for the <code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code>
(<kbd>opChar1</kbd>) or <code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code> (<kbd>opChar2</kbd>)
function.
</p>


<h3>Value</h3>

<p><kbd>summary.opChar</kbd> returns an object of class
<kbd>"summary.opChar"</kbd>, a list containing:
</p>
<table>
<tr><td><code>Algorithm</code></td>
<td>
<p>character string specifying the name of the group testing
algorithm.</p>
</td></tr>
<tr><td><code>Configuration</code></td>
<td>
<p>matrix detailing the configuration from <kbd>object</kbd>.
For hierarchical testing, this includes the group sizes for each stage of
testing. For array testing, this includes the array dimension (row/column
size) and the array size (the total number of individuals in the array).</p>
</td></tr>
<tr><td><code>Tests</code></td>
<td>
<p>matrix detailing the expected number of tests and expected
number of tests per individual from <kbd>object</kbd></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code>Accuracy</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>Individual</dt><dd><p>matrix detailing the accuracy measures for each
individual from <kbd>object</kbd> (for objects returned by <code><a href="#topic+opChar1">opChar1</a></code>).</p>
</dd>
<dt>Disease 1 Individual</dt><dd><p>matrix detailing the accuracy measures
pertaining to disease 1 for each individual from <kbd>object</kbd>
(for objects returned by <code><a href="#topic+opChar2">opChar2</a></code>).</p>
</dd>
<dt>Disease 2 Individual</dt><dd><p>matrix detailing the accuracy measures
pertaining to disease 2 for each individual from <kbd>object</kbd>
(for objects returned by <code><a href="#topic+opChar2">opChar2</a></code>).</p>
</dd>
<dt>Overall</dt><dd><p>matrix detailing the overall accuracy measures for
the algorithm from <kbd>object</kbd>.</p>
</dd></dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a></code> (<kbd>opChar1</kbd>) and
<code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a></code> (<kbd>opChar2</kbd>) for creating
an object of class <kbd>"opChar"</kbd>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the operating characteristics for
#   non-informative four-stage hierarchical testing.
config.mat &lt;- matrix(data = c(rep(1, 24), rep(1, 16),
                              rep(2, 8), rep(1, 8),
                              rep(2, 8), rep(3, 4),
                              rep(4, 2), rep(5, 2), 1:24),
                     nrow = 4, ncol = 24, byrow = TRUE)
calc1 &lt;- opChar1(algorithm = "D4", p = 0.01,
                 Se = 0.99, Sp = 0.99,
                 hier.config = config.mat,
                 a = c(1, 9, 17, 21, 23))
summary(calc1)

# Calculate the operating characteristics for
#   informative array testing without master pooling.
calc2 &lt;- opChar1(algorithm = "IA2", p = 0.025, alpha = 0.5,
                 Se = 0.95, Sp = 0.99, rowcol.sz = 10)
summary(calc2)

# Calculate the operating characteristics for
#   informative two-stage hierarchical testing
#   with a multiplex assay for two diseases.
config.mat &lt;- matrix(data = c(rep(1, 5), rep(2, 4),
                              1, 1:10),
                     nrow = 2, ncol = 10, byrow = TRUE)
Se &lt;- matrix(data = c(rep(0.95, 2), rep(0.99, 2)),
             nrow = 2, ncol = 2, byrow = FALSE)
Sp &lt;- matrix(data = c(rep(0.96, 2), rep(0.98, 2)),
             nrow = 2, ncol = 2, byrow = FALSE)
calc3 &lt;- opChar2(algorithm = "ID2",
                 alpha = c(18.25, 0.75, 0.75, 0.25),
                 Se = Se, Sp = Sp,
                 hier.config = config.mat)
summary(calc3)

# Calculate the operating characteristics for
#   non-informative array testing with master pooling
#   with a multiplex assay for two diseases.
calc4 &lt;- opChar2(algorithm = "A2M",
                 p.vec = c(0.92, 0.05, 0.02, 0.01),
                 Se = rep(0.95, 2), Sp = rep(0.99, 2),
                 rowcol.sz = 8)
summary(calc4)
</code></pre>

<hr>
<h2 id='summary.OTC'>Summary method for optimal testing configuration results</h2><span id='topic+summary.OTC'></span>

<h3>Description</h3>

<p>Produce a summary list for objects of class <kbd>"OTC"</kbd>
returned by <code><a href="#topic+OTC1">OTC1</a></code> or <code><a href="#topic+OTC2">OTC2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'OTC'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.OTC_+3A_object">object</code></td>
<td>
<p>an object of class <kbd>"OTC"</kbd>, providing the optimal testing
configuration and associated operating characteristics for a group testing
algorithm.</p>
</td></tr>
<tr><td><code id="summary.OTC_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a summary list for objects of class
<kbd>"OTC"</kbd> returned by <code><a href="#topic+OTC1">OTC1</a></code> or <code><a href="#topic+OTC2">OTC2</a></code>.
It formats the optimal testing configuration, expected number of tests,
expected number of tests per individual, and accuracy measures.
A summary of the results from <code><a href="#topic+OTC1">OTC1</a></code> includes results for all
objective functions specified by the user.
</p>
<p>The <kbd>OTC</kbd> component of the result gives the optimal testing
configuration, which may include the group sizes for each stage of a
hierarchical testing algorithm or the row/column size and array size for an
array testing algorithm. The <kbd>Tests</kbd> component of the result gives the
expected number of tests and the expected number of tests per individual
for the algorithm.
</p>
<p>The <kbd>Accuracy</kbd> component gives the overall accuracy measures for the
algorithm. Accuracy measures included are the pooling sensitivity, pooling
specificity, pooling positive predictive value, and pooling negative
predictive value. These values are weighted averages of the corresponding
individual accuracy measures for all individuals in the algorithm.
Expressions for these averages are provided in the Supplementary Material
for Hitt et al. (2019). For more information, see the 'Details' section for
the <code><a href="#topic+OTC1">OTC1</a></code> or <code><a href="#topic+OTC2">OTC2</a></code> function.
</p>


<h3>Value</h3>

<p><kbd>summary.OTC</kbd> returns an object of class <kbd>"summary.OTC"</kbd>,
a list containing:
</p>
<table>
<tr><td><code>Algorithm</code></td>
<td>
<p>character string specifying the name of the group testing
algorithm.</p>
</td></tr>
<tr><td><code>OTC</code></td>
<td>
<p>matrix detailing the optimal testing configuration from
<kbd>object</kbd>. For hierarchical testing, this includes the group sizes for
each stage of testing. For array testing, this includes the array dimension
(row/column size) and the array size (the total number of individuals
in the array).</p>
</td></tr>
<tr><td><code>Tests</code></td>
<td>
<p>matrix detailing the expected number of tests and expected
number of tests per individual from <kbd>object</kbd>.</p>
</td></tr>
<tr><td><code>Accuracy</code></td>
<td>
<p>matrix detailing the overall accuracy measures for the
algorithm, including the pooling sensitivity, pooling specificity,
pooling positive predictive value, and pooling negative predictive value
for the algorithm from <kbd>object</kbd>. Further details are found in the
'Details' section.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+OTC1">OTC1</a></code> and <code><a href="#topic+OTC2">OTC2</a></code>
for creating an object of class <kbd>"OTC"</kbd>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the optimal testing configuration for
#   non-informative two-stage hierarchical testing.
res1 &lt;- OTC1(algorithm = "D2", p = 0.01, Se = 0.99, Sp = 0.99,
             group.sz = 2:100, obj.fn = c("ET", "MAR", "GR1"),
             weights = matrix(data = c(1,1), nrow = 1, ncol = 2))
summary(res1)

# Find the optimal testing configuration for
#   informative three-stage hierarchical testing
res2 &lt;- OTC1(algorithm = "ID3", p = 0.025,
             Se = c(0.95, 0.95, 0.99), Sp = c(0.96, 0.96, 0.98),
             group.sz = 3:10, obj.fn = c("ET", "MAR"), alpha = 2)
summary(res2)

# Find the optimal testing configuration for
#   informative array testing without master pooling.
res3 &lt;- OTC1(algorithm = "IA2", p = 0.05, alpha = 2,
             Se = 0.90, Sp = 0.90, group.sz = 2:15,
             obj.fn = "ET")
summary(res3)

# Find the optimal testing configuraiton for
#   informative two-stage hierarchical testing.
Se &lt;- matrix(data = c(rep(0.95, 2), rep(0.99, 2)),
             nrow = 2, ncol = 2, byrow = FALSE)
Sp &lt;- matrix(data = c(rep(0.96, 2), rep(0.98, 2)),
             nrow = 2, ncol = 2, byrow = FALSE)
res4 &lt;- OTC2(algorithm = "ID2",
             alpha = c(18.25, 0.75, 0.75, 0.25),
             Se = Se, Sp = Sp, group.sz = 8)
summary(res4)

# Find the optimal testing configuration for
#   non-informative three-stage hierarchical testing.
Se &lt;- matrix(data = c(rep(0.95, 6)), nrow = 2, ncol = 3)
Sp &lt;- matrix(data = c(rep(0.99, 6)), nrow = 2, ncol = 3)
res5 &lt;- OTC2(algorithm = "D3",
             p.vec = c(0.95, 0.0275, 0.0175, 0.005),
             Se = Se, Sp = Sp, group.sz = 5:12)
summary(res5)

# Find the optimal testing configuration for
#   non-informative array testing with master pooling.
res6 &lt;- OTC2(algorithm = "A2M", p.vec = c(0.90, 0.04, 0.04, 0.02),
             Se = rep(0.99, 2), Sp = rep(0.99, 2), group.sz = 2:12)
summary(res6)
</code></pre>

<hr>
<h2 id='TOD'>Summary measures for the Thresholded Optimal Dorfman (TOD) algorithm</h2><span id='topic+TOD'></span>

<h3>Description</h3>

<p>Summary measures for the Thresholded Optimal Dorfman (TOD)
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOD(p.vec, Se, Sp, max = 15, init.group.sz = NULL, threshold = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TOD_+3A_p.vec">p.vec</code></td>
<td>
<p>a vector of individual risk probabilities.</p>
</td></tr>
<tr><td><code id="TOD_+3A_se">Se</code></td>
<td>
<p>sensitivity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="TOD_+3A_sp">Sp</code></td>
<td>
<p>specificity of the diagnostic test.</p>
</td></tr>
<tr><td><code id="TOD_+3A_max">max</code></td>
<td>
<p>the maximum allowable group size. Further details are given under
'Details'.</p>
</td></tr>
<tr><td><code id="TOD_+3A_init.group.sz">init.group.sz</code></td>
<td>
<p>the initial group size used for TOD, if <kbd>threshold</kbd>
is not specified. Further details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="TOD_+3A_threshold">threshold</code></td>
<td>
<p>the threshold value for TOD. If a threshold is not
specified, one is found algorithmically. Further details are given under
'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the characteristics of an informative two-stage
hierarchical (Dorfman) decoding process. Characteristics found include the
expected expenditure of the decoding process, the variance of the expenditure
of the decoding process, and the pooling sensitivity, pooling specificity,
pooling positive predictive value, and pooling negative predictive value for
each individual and for the overall algorithm. Calculations of these
characteristics are done using equations presented in McMahan et al. (2012).
</p>
<p>Thresholded Optimal Dorfman (TOD) is an informative Dorfman algorithm in
which all <code class="reqn">N</code> individuals are partitioned into two classes, low-risk and
high-risk individuals. The threshold can be specified using the optional
<kbd>threshold</kbd> argument. Alternatively, the TOD algorithm can identify
the optimal threshold value. The low-risk individuals are tested using an
optimal common pool size, and the high-risk individuals are tested
individually. If desired, the user can add the constraint of a maximum
allowable group size (<kbd>max</kbd>), so that each group will contain no more
than the maximum allowable number of individuals.
</p>
<p>The displayed overall pooling sensitivity, pooling specificity, pooling
positive predictive value, and pooling negative predictive value are
weighted averages of the corresponding individual accuracy measures for all
individuals within the initial group (or block) for a hierarchical
algorithm, or within the entire array for an array-based algorithm.
Expressions for these averages are provided in the Supplementary
Material for Hitt et al. (2019). These expressions are based on accuracy
definitions given by Altman and Bland (1994a, 1994b).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>prob</code></td>
<td>
<p>the vector of individual risk probabilities, as specified
by the user.</p>
</td></tr>
<tr><td><code>Se</code></td>
<td>
<p>the sensitivity of the diagnostic test, as specified by the user.</p>
</td></tr>
<tr><td><code>Sp</code></td>
<td>
<p>the specificity of the diagnostic test, as specified by the user.</p>
</td></tr>
<tr><td><code>group.sz</code></td>
<td>
<p>the initial group size used for TOD, if applicable.</p>
</td></tr>
<tr><td><code>thresh.val</code></td>
<td>
<p>the threshold value used for TOD, if applicable.</p>
</td></tr>
<tr><td><code>OTC</code></td>
<td>
<p>a list specifying elements of the optimal testing configuration,
which may include:
</p>

<dl>
<dt>Block.sz</dt><dd><p>the block size/initial group size for informative Dorfman
testing, which is not tested.</p>
</dd>
<dt>pool.szs</dt><dd><p>group sizes for the first stage of testing for informative
Dorfman testing.</p>
</dd></dl>
</td></tr>
<tr><td><code>ET</code></td>
<td>
<p>the expected testing expenditure to decode all individuals in the
algorithm.</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>the variance of the testing expenditure to decode all individuals
in the algorithm.</p>
</td></tr>
<tr><td><code>Accuracy</code></td>
<td>
<p>a list containing:
</p>

<dl>
<dt>Individual</dt><dd><p>a matrix of accuracy measures for each individual.
The rows correspond to each unique set of accuracy
measures in the algorithm. Individuals with the same set of accuracy
measures are displayed together in a single row of the matrix. The columns
correspond to the pool index, the individual risk probability, and the
pooling sensitivity, pooling specificity, pooling positive predictive value,
and pooling negative predictive value for the individuals in each row of the
matrix.</p>
</dd>
<dt>Overall</dt><dd><p>a matrix of overall accuracy measures for the algorithm.
The columns correspond to the pooling sensitivity, pooling specificity,
pooling positive predictive value, and pooling negative predictive value
for the overall algorithm. Further details are given under 'Details'.</p>
</dd></dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brianna D. Hitt
</p>


<h3>References</h3>

<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 1: Sensitivity and specificity.&rdquo;
<em>BMJ</em>, <b>308</b>, 1552.
</p>
<p>Altman, D., Bland, J. (1994).
&ldquo;Diagnostic tests 2: Predictive values.&rdquo;
<em>BMJ</em>, <b>309</b>, 102.
</p>
<p>Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019).
&ldquo;The objective function controversy for group testing: Much ado about nothing?&rdquo;
<em>Statistics in Medicine</em>, <b>38</b>, 4912&ndash;4923.
</p>
<p>McMahan, C., Tebbs, J., Bilder, C. (2012a).
&ldquo;Informative Dorfman Screening.&rdquo;
<em>Biometrics</em>, <b>68</b>, 287&ndash;296.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectOrderBeta">expectOrderBeta</a></code> for generating a vector of individual risk
probabilities.
</p>
<p>Other operating characteristic functions: 
<code><a href="#topic+GroupMembershipMatrix">GroupMembershipMatrix</a>()</code>,
<code><a href="#topic+Sterrett">Sterrett</a>()</code>,
<code><a href="#topic+halving">halving</a>()</code>,
<code><a href="#topic+operatingCharacteristics1">operatingCharacteristics1</a>()</code>,
<code><a href="#topic+operatingCharacteristics2">operatingCharacteristics2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Find the characteristics of an informative
#   Dorfman algorithm, using the TOD procedure.
set.seed(1002)
p.vec &lt;- expectOrderBeta(p = 0.01, alpha = 2, size = 20)
TOD(p = p.vec, Se = 0.95, Sp = 0.95, max = 5,
    threshold = 0.015)

# Example 2: Find the threshold value for the TOD
#   procedure algorithmically. Then, find
#   characteristics of the algorithm.
TOD(p = p.vec, Se = 0.95, Sp = 0.95, max = 5,
    init.group.sz = 10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
