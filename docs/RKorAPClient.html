<!DOCTYPE html><html><head><title>Help for package RKorAPClient</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RKorAPClient}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#association-score-functions'><p>Association score functions</p></a></li>
<li><a href='#ci'><p>Add confidence interval and relative frequency variables</p></a></li>
<li><a href='#collocationAnalysis,KorAPConnection-method'><p>Collocation analysis</p></a></li>
<li><a href='#collocationScoreQuery,KorAPConnection-method'><p>Query frequencies of a node and a collocate and calculate collocation association scores</p></a></li>
<li><a href='#corpusStats,KorAPConnection-method'><p>Fetch information about a (virtual) corpus</p></a></li>
<li><a href='#hc_add_onclick_korap_search'><p>Add KorAP search click events to highchart plots</p></a></li>
<li><a href='#hc_freq_by_year_ci'><p>Plot interactive frequency curves with confidence intervals</p></a></li>
<li><a href='#KorAPConnection-class'><p>Class KorAPConnection</p></a></li>
<li><a href='#KorAPCorpusStats-class'><p>Class KorAPCorpusStats</p></a></li>
<li><a href='#KorAPQuery-class'><p>Class KorAPQuery</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#RKorAPClient-package'><p>RKorAPClient: 'KorAP' Web Service Client Package</p></a></li>
<li><a href='#synsemanticStopwords'><p>Preliminary synsemantic stopwords function</p></a></li>
<li><a href='#textMetadata,KorAPConnection-method'><p>Retrieve metadata for a text, identified by its sigle (id)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'KorAP' Web Service Client Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A client package that makes the 'KorAP' web service API accessible from R.
  The corpus analysis platform 'KorAP' has been developed as a scientific tool to make
  potentially large, stratified and multiply annotated corpora, such as the 'German Reference Corpus DeReKo'
  or the 'Corpus of the Contemporary Romanian Language CoRoLa', accessible for linguists to let them verify
  hypotheses and to find interesting patterns in real language use.
  The 'RKorAPClient' package provides access to 'KorAP' and the corpora behind it for user-created R code,
  as a programmatic alternative to the 'KorAP' web user-interface.
  You can learn more about 'KorAP' and use it directly on 'DeReKo' at <a href="https://korap.ids-mannheim.de/">https://korap.ids-mannheim.de/</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/KorAP/RKorAPClient/">https://github.com/KorAP/RKorAPClient/</a>,
<a href="https://korap.ids-mannheim.de/">https://korap.ids-mannheim.de/</a>,
<a href="https://www.ids-mannheim.de/digspra/kl/projekte/korap">https://www.ids-mannheim.de/digspra/kl/projekte/korap</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/KorAP/RKorAPClient/issues">https://github.com/KorAP/RKorAPClient/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>R.cache, broom, ggplot2, tibble, magrittr, tidyr, dplyr,
lubridate, highcharter, jsonlite, keyring, utils, httr, curl,
methods, PTXQC, purrr, stringr, urltools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lifecycle, testthat</td>
</tr>
<tr>
<td>Collate:</td>
<td>'KorAPConnection.R' 'KorAPCorpusStats.R'
'RKorAPClient-package.R' 'KorAPQuery.R' 'association-scores.R'
'ci.R' 'collocationAnalysis.R' 'collocationScoreQuery.R'
'hc_add_onclick_korap_search.R' 'hc_freq_by_year_ci.R' 'misc.R'
'reexports.R' 'textMetadata.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-24 17:53:54 UTC; kupietz</td>
</tr>
<tr>
<td>Author:</td>
<td>Marc Kupietz [aut, cre],
  Nils Diewald [ctb],
  Leibniz Institute for the German Language [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marc Kupietz &lt;kupietz@ids-mannheim.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='association-score-functions'>Association score functions</h2><span id='topic+association-score-functions'></span><span id='topic+defaultAssociationScoreFunctions'></span><span id='topic+pmi'></span><span id='topic+mi2'></span><span id='topic+mi3'></span><span id='topic+logDice'></span><span id='topic+ll'></span>

<h3>Description</h3>

<p>Functions to calculate different collocation association scores between
a node (target word) and words in a window around the it.
The functions are primarily used by <code><a href="#topic+collocationScoreQuery">collocationScoreQuery()</a></code>.
</p>
<p><strong>pmi</strong>: pointwise mutual information
</p>
<p><strong>mi2</strong>: pointwise mutual information squared (Daille 1994), also referred to as mutual dependency
(Thanopoulos et al. 2002)
</p>
<p><strong>mi3</strong>: pointwise mutual information cubed (Daille 1994), also referred to as log-frequency biased mutual dependency)
(Thanopoulos et al. 2002)
</p>
<p><strong>logDice</strong>: log-Dice coefficient, a heuristic measure that is popular in lexicography (Rychlý 2008)
</p>
<p><strong>ll</strong>: log-likelihood (Dunning 1993) using Stefan Evert's (2004) simplified implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultAssociationScoreFunctions()

pmi(O1, O2, O, N, E, window_size)

mi2(O1, O2, O, N, E, window_size)

mi3(O1, O2, O, N, E, window_size)

logDice(O1, O2, O, N, E, window_size)

ll(O1, O2, O, N, E, window_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="association-score-functions_+3A_o1">O1</code></td>
<td>
<p>observed absolute frequency of node</p>
</td></tr>
<tr><td><code id="association-score-functions_+3A_o2">O2</code></td>
<td>
<p>observed absolute frequency of collocate</p>
</td></tr>
<tr><td><code id="association-score-functions_+3A_o">O</code></td>
<td>
<p>observed absolute frequency of collocation</p>
</td></tr>
<tr><td><code id="association-score-functions_+3A_n">N</code></td>
<td>
<p>corpus size</p>
</td></tr>
<tr><td><code id="association-score-functions_+3A_e">E</code></td>
<td>
<p>expected absolute frequency of collocation (already adjusted to window size)</p>
</td></tr>
<tr><td><code id="association-score-functions_+3A_window_size">window_size</code></td>
<td>
<p>total window size around node (left neighbour count + right neighbour count)</p>
</td></tr>
</table>


<h3>Value</h3>

<div class="sourceCode"><pre>         association score
</pre></div>


<h3>References</h3>

<p>Daille, B. (1994): Approche mixte pour l’extraction automatique de terminologie: statistiques lexicales et filtres linguistiques. PhD thesis, Université Paris 7.
</p>
<p>Thanopoulos, A., Fakotakis, N., Kokkinakis, G. (2002): Comparative evaluation of collocation extraction metrics. In: Proc. of LREC 2002: 620–625.
</p>
<p>Rychlý, Pavel (2008):  A lexicographer-friendly association score. In Proceedings of Recent Advances in Slavonic Natural Language Processing, RASLAN, 6–9. <a href="https://www.fi.muni.cz/usr/sojka/download/raslan2008/13.pdf">https://www.fi.muni.cz/usr/sojka/download/raslan2008/13.pdf</a>.
</p>
<p>Dunning, T. (1993): Accurate methods for the statistics of surprise and coincidence. Comput. Linguist. 19, 1 (March 1993), 61-74.
</p>
<p>Evert, Stefan (2004): The Statistics of Word Cooccurrences: Word Pairs and Collocations. PhD dissertation, IMS, University of Stuttgart. Published in 2005, URN urn:nbn:de:bsz:93-opus-23714.
Free PDF available from <a href="https://purl.org/stefan.evert/PUB/Evert2004phd.pdf">https://purl.org/stefan.evert/PUB/Evert2004phd.pdf</a>
</p>


<h3>See Also</h3>

<p>Other collocation analysis functions: 
<code><a href="#topic+collocationAnalysis+2CKorAPConnection-method">collocationAnalysis,KorAPConnection-method</a></code>,
<code><a href="#topic+collocationScoreQuery+2CKorAPConnection-method">collocationScoreQuery,KorAPConnection-method</a></code>,
<code><a href="#topic+synsemanticStopwords">synsemanticStopwords</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

new("KorAPConnection", verbose = TRUE) %&gt;%
collocationScoreQuery("Perlen", c("verziertes", "Säue"),
  scoreFunctions = append(defaultAssociationScoreFunctions(),
     list(localMI = function(O1, O2, O, N, E, window_size) {
                       O * log2(O/E)
                    })))

## End(Not run)

</code></pre>

<hr>
<h2 id='ci'>Add confidence interval and relative frequency variables</h2><span id='topic+ci'></span><span id='topic+misc-functions'></span><span id='topic+ipm'></span><span id='topic+percent'></span><span id='topic+queryStringToLabel'></span><span id='topic+geom_freq_by_year_ci'></span>

<h3>Description</h3>

<p>Using <code><a href="stats.html#topic+prop.test">prop.test()</a></code>, <code>ci</code> adds three columns to a data frame:
</p>

<ol>
<li><p> relative frequency (<code>f</code>)
</p>
</li>
<li><p> lower bound of a confidence interval (<code>ci.low</code>)
</p>
</li>
<li><p> upper bound of a confidence interval
</p>
</li></ol>

<p>Convenience function for converting frequency tables to instances per
million.
</p>
<p>Convenience function for converting frequency tables of alternative variants
(generated with <code>as.alternatives=TRUE</code>) to percent.
</p>
<p>Converts a vector of query or vc strings to typically appropriate legend labels
by clipping off prefixes and suffixes that are common to all query strings.
</p>
<p>Experimental convenience function for plotting typical frequency by year graphs with confidence intervals using ggplot2.
<strong>Warning:</strong> This function may be moved to a new package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci(df, x = totalResults, N = total, conf.level = 0.95)

ipm(df)

percent(df)

queryStringToLabel(data, pubDateOnly = FALSE, excludePubDate = FALSE)

geom_freq_by_year_ci(mapping = aes(ymin = conf.low, ymax = conf.high), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_+3A_df">df</code></td>
<td>
<p>table returned from <code><a href="#topic+frequencyQuery">frequencyQuery()</a></code></p>
</td></tr>
<tr><td><code id="ci_+3A_x">x</code></td>
<td>
<p>column with the observed absolute frequency.</p>
</td></tr>
<tr><td><code id="ci_+3A_n">N</code></td>
<td>
<p>column with the total frequencies</p>
</td></tr>
<tr><td><code id="ci_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the returned confidence interval. Must
be a single number between 0 and 1.</p>
</td></tr>
<tr><td><code id="ci_+3A_data">data</code></td>
<td>
<p>string or vector of query or vc definition strings</p>
</td></tr>
<tr><td><code id="ci_+3A_pubdateonly">pubDateOnly</code></td>
<td>
<p>discard all but the publication date</p>
</td></tr>
<tr><td><code id="ci_+3A_excludepubdate">excludePubDate</code></td>
<td>
<p>discard publication date constraints</p>
</td></tr>
<tr><td><code id="ci_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="ci_+3A_...">...</code></td>
<td>
<p>Other arguments passed to geom_ribbon, geom_line, and geom_click_point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a table with columns <code>f</code>, <code>conf.low</code>, and <code>conf.high</code>, <code>ipm</code> ads a <code style="white-space: pre;">&#8288;column ipm&#8288;</code>
und multiplies conf.low and <code>conf.high</code> with 10^6.
</p>


<h3>Value</h3>

<p>original table with additional column <code>ipm</code> and converted columns <code>conf.low</code> and <code>conf.high</code>
</p>
<p>original table with converted columns <code>f</code>, <code>conf.low</code> and <code>conf.high</code>
</p>
<p>string or vector of strings with clipped off common prefixes and suffixes
</p>


<h3>See Also</h3>

<p><code>ci</code> is already included in <code><a href="#topic+frequencyQuery">frequencyQuery()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(ggplot2)
kco &lt;- new("KorAPConnection", verbose=TRUE)
expand_grid(year=2015:2018, alternatives=c("Hate Speech", "Hatespeech")) %&gt;%
  bind_cols(corpusQuery(kco, .$alternatives, sprintf("pubDate in %d", .$year))) %&gt;%
  mutate(total=corpusStats(kco, vc=vc)$tokens) %&gt;%
  ci() %&gt;%
  ggplot(aes(x=year, y=f, fill=query, color=query, ymin=conf.low, ymax=conf.high)) +
    geom_point() + geom_line() + geom_ribbon(alpha=.3)

## End(Not run)
## Not run: 

new("KorAPConnection") %&gt;% frequencyQuery("Test", paste0("pubDate in ", 2000:2002)) %&gt;% ipm()

## End(Not run)
## Not run: 

new("KorAPConnection") %&gt;%
    frequencyQuery(c("Tollpatsch", "Tolpatsch"),
    vc=paste0("pubDate in ", 2000:2002),
    as.alternatives = TRUE) %&gt;%
  percent()

## End(Not run)
queryStringToLabel(paste("textType = /Zeit.*/ &amp; pubDate in", c(2010:2019)))
queryStringToLabel(c("[marmot/m=mood:subj]", "[marmot/m=mood:ind]"))
queryStringToLabel(c("wegen dem [tt/p=NN]", "wegen des [tt/p=NN]"))

## Not run: 
library(ggplot2)
kco &lt;- new("KorAPConnection", verbose=TRUE)

expand_grid(condition = c("textDomain = /Wirtschaft.*/", "textDomain != /Wirtschaft.*/"),
            year = (2005:2011)) %&gt;%
  cbind(frequencyQuery(kco, "[tt/l=Heuschrecke]",
                            paste0(.$condition," &amp; pubDate in ", .$year)))  %&gt;%
  ipm() %&gt;%
  ggplot(aes(year, ipm, fill = condition, color = condition)) +
  geom_freq_by_year_ci()

## End(Not run)
</code></pre>

<hr>
<h2 id='collocationAnalysis+2CKorAPConnection-method'>Collocation analysis</h2><span id='topic+collocationAnalysis+2CKorAPConnection-method'></span><span id='topic+collocationAnalysis'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Performs a collocation analysis for the given node (or query)
in the given virtual corpus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KorAPConnection'
collocationAnalysis(
  kco,
  node,
  vc = "",
  lemmatizeNodeQuery = FALSE,
  minOccur = 5,
  leftContextSize = 5,
  rightContextSize = 5,
  topCollocatesLimit = 200,
  searchHitsSampleLimit = 20000,
  ignoreCollocateCase = FALSE,
  withinSpan = ifelse(exactFrequencies, "base/s=s", ""),
  exactFrequencies = TRUE,
  stopwords = append(RKorAPClient::synsemanticStopwords(), node),
  seed = 7,
  expand = length(vc) != length(node),
  maxRecurse = 0,
  addExamples = FALSE,
  thresholdScore = "logDice",
  threshold = 2,
  localStopwords = c(),
  collocateFilterRegex = "^[:alnum:]+-?[:alnum:]*$",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_kco">kco</code></td>
<td>
<p><code><a href="#topic+KorAPConnection">KorAPConnection()</a></code> object (obtained e.g. from <code>new("KorAPConnection")</code></p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_node">node</code></td>
<td>
<p>target word</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_vc">vc</code></td>
<td>
<p>string describing the virtual corpus in which the query should be performed. An empty string (default) means the whole corpus, as far as it is license-wise accessible.</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_lemmatizenodequery">lemmatizeNodeQuery</code></td>
<td>
<p>if TRUE, node query will be lemmatized, i.e. <code style="white-space: pre;">&#8288;x -&gt; [tt/l=x]&#8288;</code></p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_minoccur">minOccur</code></td>
<td>
<p>minimum absolute number of observed co-occurrences to consider a collocate candidate</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_leftcontextsize">leftContextSize</code></td>
<td>
<p>size of the left context window</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_rightcontextsize">rightContextSize</code></td>
<td>
<p>size of the right context window</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_topcollocateslimit">topCollocatesLimit</code></td>
<td>
<p>limit analysis to the n most frequent collocates in the search hits sample</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_searchhitssamplelimit">searchHitsSampleLimit</code></td>
<td>
<p>limit the size of the search hits sample</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_ignorecollocatecase">ignoreCollocateCase</code></td>
<td>
<p>logical, set to TRUE if collocate case should be ignored</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_withinspan">withinSpan</code></td>
<td>
<p>KorAP span specification for collocations to be searched within</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_exactfrequencies">exactFrequencies</code></td>
<td>
<p>if FALSE, extrapolate observed co-occurrence frequencies from frequencies in search hits sample, otherwise retrieve exact co-occurrence frequencies</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_stopwords">stopwords</code></td>
<td>
<p>vector of stopwords not to be considered as collocates</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_seed">seed</code></td>
<td>
<p>seed for random page collecting order</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_expand">expand</code></td>
<td>
<p>if TRUE, <code>node</code> and <code>vc</code> parameters are expanded to all of their combinations</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_maxrecurse">maxRecurse</code></td>
<td>
<p>apply collocation analysis recursively <code>maxRecurse</code> times</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_addexamples">addExamples</code></td>
<td>
<p>If TRUE, examples for instances of collocations will be added in a column <code>example</code>. This makes a difference in particular if <code>node</code> is given as a lemma query.</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_thresholdscore">thresholdScore</code></td>
<td>
<p>association score function (see <code><a href="#topic+association-score-functions">association-score-functions</a></code>) to use for computing the threshold that is applied for recursive collocation analysis calls</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_threshold">threshold</code></td>
<td>
<p>minimum value of <code>thresholdScore</code> function call to apply collocation analysis recursively</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_localstopwords">localStopwords</code></td>
<td>
<p>vector of stopwords that will not be considered as collocates in the current function call, but that will not be passed to recursive calls</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_collocatefilterregex">collocateFilterRegex</code></td>
<td>
<p>allow only collocates matching the regular expression</p>
</td></tr>
<tr><td><code id="collocationAnalysis+2B2CKorAPConnection-method_+3A_...">...</code></td>
<td>
<p>more arguments will be passed to <code><a href="#topic+collocationScoreQuery">collocationScoreQuery()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The collocation analysis is currently implemented on the client side, as some of the
functionality is not yet provided by the KorAP backend. Mainly for this reason
it is very slow (several minutes, up to hours), but on the other hand very flexible.
You can, for example, perform the analysis in arbitrary virtual corpora, use complex node queries,
and look for expression-internal collocates using the focus function (see examples and demo).
</p>
<p>To increase speed at the cost of accuracy and possible false negatives,
you can decrease searchHitsSampleLimit and/or topCollocatesLimit and/or set exactFrequencies to FALSE.
</p>
<p>Note that currently not the tokenization provided by the backend, i.e. the corpus itself, is used, but a tinkered one.
This can also lead to false negatives and to frequencies that differ from corresponding ones acquired via the web
user interface.
</p>


<h3>Value</h3>

<p>Tibble with top collocates, association scores, corresponding URLs for web user interface queries, etc.
</p>


<h3>See Also</h3>

<p>Other collocation analysis functions: 
<code><a href="#topic+association-score-functions">association-score-functions</a></code>,
<code><a href="#topic+collocationScoreQuery+2CKorAPConnection-method">collocationScoreQuery,KorAPConnection-method</a></code>,
<code><a href="#topic+synsemanticStopwords">synsemanticStopwords</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

 # Find top collocates of "Packung" inside and outside the sports domain.
 new("KorAPConnection", verbose = TRUE) %&gt;%
  collocationAnalysis("Packung", vc=c("textClass=sport", "textClass!=sport"),
                      leftContextSize=1, rightContextSize=1, topCollocatesLimit=20) %&gt;%
  dplyr::filter(logDice &gt;= 5)

## End(Not run)

## Not run: 

# Identify the most prominent light verb construction with "in ... setzen".
# Note that, currently, the use of focus function disallows exactFrequencies.
new("KorAPConnection", verbose = TRUE) %&gt;%
  collocationAnalysis("focus(in [tt/p=NN] {[tt/l=setzen]})",
    leftContextSize=1, rightContextSize=0, exactFrequencies=FALSE, topCollocatesLimit=20)

## End(Not run)

</code></pre>

<hr>
<h2 id='collocationScoreQuery+2CKorAPConnection-method'>Query frequencies of a node and a collocate and calculate collocation association scores</h2><span id='topic+collocationScoreQuery+2CKorAPConnection-method'></span><span id='topic+collocationScoreQuery'></span>

<h3>Description</h3>

<p>Computes various collocation association scores
based on <code><a href="#topic+frequencyQuery">frequencyQuery()</a></code>s for a target word and a collocate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KorAPConnection'
collocationScoreQuery(
  kco,
  node,
  collocate,
  vc = "",
  lemmatizeNodeQuery = FALSE,
  lemmatizeCollocateQuery = FALSE,
  leftContextSize = 5,
  rightContextSize = 5,
  scoreFunctions = defaultAssociationScoreFunctions(),
  smoothingConstant = 0.5,
  observed = NA,
  ignoreCollocateCase = FALSE,
  withinSpan = "base/s=s"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_kco">kco</code></td>
<td>
<p><code><a href="#topic+KorAPConnection">KorAPConnection()</a></code> object (obtained e.g. from <code>new("KorAPConnection")</code></p>
</td></tr>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_node">node</code></td>
<td>
<p>target word</p>
</td></tr>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_collocate">collocate</code></td>
<td>
<p>collocate of target word</p>
</td></tr>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_vc">vc</code></td>
<td>
<p>string describing the virtual corpus in which the query should be performed. An empty string (default) means the whole corpus, as far as it is license-wise accessible.</p>
</td></tr>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_lemmatizenodequery">lemmatizeNodeQuery</code></td>
<td>
<p>logical, set to TRUE if node query should be lemmatized, i.e. <code style="white-space: pre;">&#8288;x -&gt; [tt/l=x]&#8288;</code></p>
</td></tr>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_lemmatizecollocatequery">lemmatizeCollocateQuery</code></td>
<td>
<p>logical, set to TRUE if collocate query should be lemmatized, i.e. <code style="white-space: pre;">&#8288;x -&gt; [tt/l=x]&#8288;</code></p>
</td></tr>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_leftcontextsize">leftContextSize</code></td>
<td>
<p>size of the left context window</p>
</td></tr>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_rightcontextsize">rightContextSize</code></td>
<td>
<p>size of the right context window</p>
</td></tr>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_scorefunctions">scoreFunctions</code></td>
<td>
<p>named list of score functions of the form function(O1, O2, O, N, E, window_size), see e.g. <a href="#topic+pmi">pmi</a></p>
</td></tr>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_smoothingconstant">smoothingConstant</code></td>
<td>
<p>smoothing constant will be added to all observed values</p>
</td></tr>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_observed">observed</code></td>
<td>
<p>if collocation frequencies are already known (or estimated from a sample) they can be passed as a vector here, otherwise: NA</p>
</td></tr>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_ignorecollocatecase">ignoreCollocateCase</code></td>
<td>
<p>logical, set to TRUE if collocate case should be ignored</p>
</td></tr>
<tr><td><code id="collocationScoreQuery+2B2CKorAPConnection-method_+3A_withinspan">withinSpan</code></td>
<td>
<p>KorAP span specification for collocations to be searched within</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with query KorAP web request URL, all observed values and association scores
</p>


<h3>See Also</h3>

<p>Other collocation analysis functions: 
<code><a href="#topic+association-score-functions">association-score-functions</a></code>,
<code><a href="#topic+collocationAnalysis+2CKorAPConnection-method">collocationAnalysis,KorAPConnection-method</a></code>,
<code><a href="#topic+synsemanticStopwords">synsemanticStopwords</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

new("KorAPConnection", verbose = TRUE) %&gt;%
  collocationScoreQuery("Grund", "triftiger")

## End(Not run)

## Not run: 

new("KorAPConnection", verbose = TRUE) %&gt;%
collocationScoreQuery("Grund", c("guter", "triftiger"),
   scoreFunctions = list(localMI = function(O1, O2, O, N, E, window_size) { O * log2(O/E) }) )

## End(Not run)

## Not run: 

library(highcharter)
library(tidyr)
new("KorAPConnection", verbose = TRUE) %&gt;%
  collocationScoreQuery("Team", "agil", vc = paste("pubDate in", c(2014:2018)),
                        lemmatizeNodeQuery = TRUE, lemmatizeCollocateQuery = TRUE) %&gt;%
                         pivot_longer(14:last_col(), names_to = "measure", values_to = "score") %&gt;%
  hchart(type="spline", hcaes(label, score, group=measure)) %&gt;%
  hc_add_onclick_korap_search()

## End(Not run)

</code></pre>

<hr>
<h2 id='corpusStats+2CKorAPConnection-method'>Fetch information about a (virtual) corpus</h2><span id='topic+corpusStats+2CKorAPConnection-method'></span><span id='topic+corpusStats'></span>

<h3>Description</h3>

<p>Fetch information about a (virtual) corpus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KorAPConnection'
corpusStats(kco, vc = "", verbose = kco@verbose, as.df = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corpusStats+2B2CKorAPConnection-method_+3A_kco">kco</code></td>
<td>
<p><code><a href="#topic+KorAPConnection">KorAPConnection()</a></code> object (obtained e.g. from <code>new("KorAPConnection")</code></p>
</td></tr>
<tr><td><code id="corpusStats+2B2CKorAPConnection-method_+3A_vc">vc</code></td>
<td>
<p>string describing the virtual corpus. An empty string (default) means the whole corpus, as far as it is license-wise accessible.</p>
</td></tr>
<tr><td><code id="corpusStats+2B2CKorAPConnection-method_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, additional diagnostics are printed.</p>
</td></tr>
<tr><td><code id="corpusStats+2B2CKorAPConnection-method_+3A_as.df">as.df</code></td>
<td>
<p>return result as data frame instead of as S4 object?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>KorAPCorpusStats</code> object with the slots <code>documents</code>, <code>tokens</code>, <code>sentences</code>, <code>paragraphs</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

kco &lt;- new("KorAPConnection")
corpusStats(kco, "pubDate in 2017 &amp; textType=/Zeitung.*/")

## End(Not run)

</code></pre>

<hr>
<h2 id='hc_add_onclick_korap_search'>Add KorAP search click events to highchart plots</h2><span id='topic+hc_add_onclick_korap_search'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Adds on-click events to data points of highcharts that were constructed with
<code><a href="#topic+frequencyQuery">frequencyQuery()</a></code> or <code><a href="#topic+collocationScoreQuery">collocationScoreQuery()</a></code>. Clicks on data points
then launch KorAP web UI queries for the given query term and virtual corpus in
a separate tab.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hc_add_onclick_korap_search(hc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hc_add_onclick_korap_search_+3A_hc">hc</code></td>
<td>
<p>A highchart htmlwidget object generated by e.g. <code><a href="#topic+frequencyQuery">frequencyQuery()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input highchart object with added on-click events.
</p>


<h3>See Also</h3>

<p>Other highcharter-helpers: 
<code><a href="#topic+hc_freq_by_year_ci">hc_freq_by_year_ci</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(highcharter)
library(tidyr)

new("KorAPConnection", verbose = TRUE) %&gt;%
  collocationScoreQuery("Team", "agil", vc = paste("pubDate in", c(2014:2018)),
                        lemmatizeNodeQuery = TRUE, lemmatizeCollocateQuery = TRUE) %&gt;%
                         pivot_longer(c("O", "E")) %&gt;%
  hchart(type="spline", hcaes(label, value, group=name)) %&gt;%
  hc_add_onclick_korap_search()

## End(Not run)

</code></pre>

<hr>
<h2 id='hc_freq_by_year_ci'>Plot interactive frequency curves with confidence intervals</h2><span id='topic+hc_freq_by_year_ci'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Convenience function for plotting typical frequency by year graphs with confidence intervals using highcharter.
</p>
<p><strong>Warning:</strong> This function may be moved to a new package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hc_freq_by_year_ci(
  df,
  as.alternatives = FALSE,
  ylabel = if (as.alternatives) "%" else "ipm",
  smooth = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hc_freq_by_year_ci_+3A_df">df</code></td>
<td>
<p>data frame like the value of a <code><a href="#topic+frequencyQuery">frequencyQuery()</a></code></p>
</td></tr>
<tr><td><code id="hc_freq_by_year_ci_+3A_as.alternatives">as.alternatives</code></td>
<td>
<p>boolean decides whether queries should be treated as mutually exclusive and exhaustive wrt. to some meaningful class (e.g. spelling variants of a certain word form).</p>
</td></tr>
<tr><td><code id="hc_freq_by_year_ci_+3A_ylabel">ylabel</code></td>
<td>
<p>defaults to <code style="white-space: pre;">&#8288;%&#8288;</code> if <code>as.alternatives</code> is <code>TRUE</code> and to <code>ipm</code> otherwise.</p>
</td></tr>
<tr><td><code id="hc_freq_by_year_ci_+3A_smooth">smooth</code></td>
<td>
<p>boolean decides whether the graph is smoothed using the highcharts plot types spline and areasplinerange.</p>
</td></tr>
<tr><td><code id="hc_freq_by_year_ci_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="highcharter.html#topic+hc_add_series">hc_add_series()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A highchart htmlwidget object containing the frequency plot.
</p>


<h3>See Also</h3>

<p>Other highcharter-helpers: 
<code><a href="#topic+hc_add_onclick_korap_search">hc_add_onclick_korap_search</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

year &lt;- c(1990:2018)
alternatives &lt;- c("macht []{0,3} Sinn", "ergibt []{0,3} Sinn")
new("KorAPConnection", verbose = TRUE) %&gt;%
  frequencyQuery(query = alternatives,
                 vc = paste("textType = /Zeit.*/ &amp; pubDate in", year),
                 as.alternatives = TRUE) %&gt;%
  hc_freq_by_year_ci(as.alternatives = TRUE)


kco &lt;- new("KorAPConnection", verbose = TRUE)
expand_grid(
  condition = c("textDomain = /Wirtschaft.*/", "textDomain != /Wirtschaft.*/"),
  year = (2005:2011)
) %&gt;%
  cbind(frequencyQuery(
    kco,
    "[tt/l=Heuschrecke]",
    paste0(.$condition, " &amp; pubDate in ", .$year)
  ))  %&gt;%
  hc_freq_by_year_ci()

## End(Not run)

</code></pre>

<hr>
<h2 id='KorAPConnection-class'>Class KorAPConnection</h2><span id='topic+KorAPConnection-class'></span><span id='topic+KorAPConnection'></span><span id='topic+initialize+2CKorAPConnection-method'></span><span id='topic+persistAccessToken+2CKorAPConnection-method'></span><span id='topic+persistAccessToken'></span><span id='topic+clearAccessToken+2CKorAPConnection-method'></span><span id='topic+clearAccessToken'></span><span id='topic+apiCall+2CKorAPConnection-method'></span><span id='topic+apiCall'></span><span id='topic+clearCache+2CKorAPConnection-method'></span><span id='topic+clearCache'></span><span id='topic+show+2CKorAPConnection-method'></span>

<h3>Description</h3>

<p><code>KorAPConnection</code> objects represent the connection to a KorAP server.
New <code>KorAPConnection</code> objects can be created by <code>new("KorAPConnection")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KorAPConnection'
initialize(
  .Object,
  KorAPUrl = "https://korap.ids-mannheim.de/",
  apiVersion = "v1.0",
  apiUrl,
  accessToken = getAccessToken(KorAPUrl),
  userAgent = "R-KorAP-Client",
  timeout = 240,
  verbose = FALSE,
  cache = TRUE
)

## S4 method for signature 'KorAPConnection'
persistAccessToken(kco, accessToken = kco@accessToken)

## S4 method for signature 'KorAPConnection'
clearAccessToken(kco)

## S4 method for signature 'KorAPConnection'
apiCall(
  kco,
  url,
  json = TRUE,
  getHeaders = FALSE,
  cache = kco@cache,
  timeout = kco@timeout
)

## S4 method for signature 'KorAPConnection'
clearCache(kco)

## S4 method for signature 'KorAPConnection'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KorAPConnection-class_+3A_.object">.Object</code></td>
<td>
<p>KorAPConnection object</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_korapurl">KorAPUrl</code></td>
<td>
<p>URL of the web user interface of the KorAP server instance you want to access.</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_apiversion">apiVersion</code></td>
<td>
<p>which version of KorAP's API you want to connect to.</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_apiurl">apiUrl</code></td>
<td>
<p>URL of the KorAP web service.</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_accesstoken">accessToken</code></td>
<td>
<p>OAuth2 access token. For queries on corpus parts with restricted
access (e.g. textual queries on IPR protected data), you need to authorize
your application with an access token.
How to obtain an access token for the DeReKo KorAP instance is explained in the
<a href="https://github.com/KorAP/RKorAPClient#authorization">authorization section</a>
of the RKorAPClient Readme on GitHub.
</p>
<p>To use authorization based on an access token
in subsequent queries, initialize your KorAP connection with:
</p>
<div class="sourceCode"><pre>kco &lt;- new("KorAPConnection", accessToken="&lt;access token&gt;")
</pre></div>
<p>In order to make the API
token persistent for the currently used <code>KorAPUrl</code> (you can have one
token per KorAPUrl / KorAP server instance), use:
</p>
<div class="sourceCode"><pre>persistAccessToken(kco)
</pre></div>
<p>This will store it in your keyring using the
<code>keyring()</code> package. Subsequent new(&quot;KorAPConnection&quot;) calls will
then automatically retrieve the token from your keying. To stop using a
persisted token, call <code>clearAccessToken(kco)</code>. Please note that for
DeReKo, authorized queries will behave differently inside and outside the
IDS, because of the special license situation. This concerns also cached
results which do not take into account from where a request was issued. If
you experience problems or unexpected results, please try <code>kco &lt;- new("KorAPConnection", cache=FALSE)</code> or use
<code><a href="#topic+clearCache">clearCache()</a></code> to clear the cache completely.</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_useragent">userAgent</code></td>
<td>
<p>user agent string.</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_timeout">timeout</code></td>
<td>
<p>tineout in seconds for API requests (this does not influence server internal timeouts).</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_verbose">verbose</code></td>
<td>
<p>logical that decides whether following operations will default to
be verbose.</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_cache">cache</code></td>
<td>
<p>logical that decides if API calls are cached locally. You can clear
the cache with <code><a href="#topic+clearCache">clearCache()</a></code>.</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_kco">kco</code></td>
<td>
<p>KorAPConnection object</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_url">url</code></td>
<td>
<p>request url</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_json">json</code></td>
<td>
<p>logical that determines if json result is expected</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_getheaders">getHeaders</code></td>
<td>
<p>logical that determines if headers and content should be returned (as a list)</p>
</td></tr>
<tr><td><code id="KorAPConnection-class_+3A_object">object</code></td>
<td>
<p>KorAPConnection object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+KorAPConnection">KorAPConnection()</a></code> object that can be used e.g. with
<code><a href="#topic+corpusQuery">corpusQuery()</a></code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>KorAPUrl</code></dt><dd><p>URL of the web user interface of the KorAP server used in the connection.</p>
</dd>
<dt><code>apiVersion</code></dt><dd><p>requested KorAP API version.</p>
</dd>
<dt><code>indexRevision</code></dt><dd><p>indexRevision code as reported from API via <code>X-Index-Revision</code> HTTP header.</p>
</dd>
<dt><code>apiUrl</code></dt><dd><p>full URL of API including version.</p>
</dd>
<dt><code>accessToken</code></dt><dd><p>OAuth2 access token.</p>
</dd>
<dt><code>userAgent</code></dt><dd><p>user agent string used for connection the API.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>tineout in seconds for API requests (this does not influence server internal timeouts)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>logical that decides whether operations will default to be verbose.</p>
</dd>
<dt><code>cache</code></dt><dd><p>logical that decides if API calls are cached locally.</p>
</dd>
<dt><code>welcome</code></dt><dd><p>list containing HTTP response received from KorAP server welcome function.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

kcon &lt;- new("KorAPConnection", verbose = TRUE)
kq &lt;- corpusQuery(kcon, "Ameisenplage")
kq &lt;- fetchAll(kq)

## End(Not run)

## Not run: 

kcon &lt;- new("KorAPConnection", verbose = TRUE, accessToken="e739u6eOzkwADQPdVChxFg")
kq &lt;- corpusQuery(kcon, "Ameisenplage", metadataOnly=FALSE)
kq &lt;- fetchAll(kq)
kq@collectedMatches$snippet

## End(Not run)

## Not run: 

kco &lt;- new("KorAPConnection", accessToken="e739u6eOzkwADQPdVChxFg")
persistAccessToken(kco)

## End(Not run)

## Not run: 

kco &lt;- new("KorAPConnection")
clearAccessToken(kco)

## End(Not run)

</code></pre>

<hr>
<h2 id='KorAPCorpusStats-class'>Class KorAPCorpusStats</h2><span id='topic+KorAPCorpusStats-class'></span><span id='topic+show+2CKorAPCorpusStats-method'></span>

<h3>Description</h3>

<p><code>KorAPCorpusStats</code> objects can hold information about a corpus or virtual corpus.
<code>KorAPCorpusStats</code> objects can be obtained by the <code><a href="#topic+corpusStats">corpusStats()</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KorAPCorpusStats'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KorAPCorpusStats-class_+3A_object">object</code></td>
<td>
<p>KorAPCorpusStats object</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>vc</code></dt><dd><p>definition of the virtual corpus</p>
</dd>
<dt><code>tokens</code></dt><dd><p>number of tokens</p>
</dd>
<dt><code>documents</code></dt><dd><p>number of documents</p>
</dd>
<dt><code>sentences</code></dt><dd><p>number of sentences</p>
</dd>
<dt><code>paragraphs</code></dt><dd><p>number of paragraphs</p>
</dd>
<dt><code>webUIRequestUrl</code></dt><dd><p>link to the web user interface with the current vc definition</p>
</dd>
</dl>

<hr>
<h2 id='KorAPQuery-class'>Class KorAPQuery</h2><span id='topic+KorAPQuery-class'></span><span id='topic+KorAPQuery'></span><span id='topic+initialize+2CKorAPQuery-method'></span><span id='topic+corpusQuery+2CKorAPConnection-method'></span><span id='topic+corpusQuery'></span><span id='topic+fetchNext+2CKorAPQuery-method'></span><span id='topic+fetchNext'></span><span id='topic+fetchAll+2CKorAPQuery-method'></span><span id='topic+fetchAll'></span><span id='topic+fetchRest+2CKorAPQuery-method'></span><span id='topic+fetchRest'></span><span id='topic+frequencyQuery+2CKorAPConnection-method'></span><span id='topic+frequencyQuery'></span><span id='topic+buildWebUIRequestUrl'></span><span id='topic+format.KorAPQuery'></span><span id='topic+show+2CKorAPQuery-method'></span>

<h3>Description</h3>

<p>This class provides methods to perform different kinds of queries on the KorAP API server.
<code>KorAPQuery</code> objects, which are typically created by the <code><a href="#topic+corpusQuery">corpusQuery()</a></code> method,
represent the current state of a query to a KorAP server.
</p>
<p><strong><code>corpusQuery</code></strong> performs a corpus query via a connection to a KorAP-API-server
</p>
<p><strong><code>fetchNext</code></strong> fetches the next bunch of results of a KorAP query.
</p>
<p><strong><code>fetchAll</code></strong> fetches all results of a KorAP query.
</p>
<p><strong><code>frequencyQuery</code></strong> combines <code><a href="#topic+corpusQuery">corpusQuery()</a></code>, <code><a href="#topic+corpusStats">corpusStats()</a></code> and
<code><a href="#topic+ci">ci()</a></code> to compute a table with the relative frequencies and
confidence intervals of one ore multiple search terms across one or multiple
virtual corpora.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KorAPQuery'
initialize(
  .Object,
  korapConnection = NULL,
  request = NULL,
  vc = "",
  totalResults = 0,
  nextStartIndex = 0,
  fields = c("corpusSigle", "textSigle", "pubDate", "pubPlace", "availability",
    "textClass", "snippet", "tokens"),
  requestUrl = "",
  webUIRequestUrl = "",
  apiResponse = NULL,
  hasMoreMatches = FALSE,
  collectedMatches = NULL
)

## S4 method for signature 'KorAPConnection'
corpusQuery(
  kco,
  query = if (missing(KorAPUrl))
    stop("At least one of the parameters query and KorAPUrl must be specified.", call. =
    FALSE) else httr::parse_url(KorAPUrl)$query$q,
  vc = if (missing(KorAPUrl)) "" else httr::parse_url(KorAPUrl)$query$cq,
  KorAPUrl,
  metadataOnly = TRUE,
  ql = if (missing(KorAPUrl)) "poliqarp" else httr::parse_url(KorAPUrl)$query$ql,
  fields = c("corpusSigle", "textSigle", "pubDate", "pubPlace", "availability",
    "textClass", "snippet", "tokens"),
  accessRewriteFatal = TRUE,
  verbose = kco@verbose,
  expand = length(vc) != length(query),
  as.df = FALSE,
  context = NULL
)

## S4 method for signature 'KorAPQuery'
fetchNext(
  kqo,
  offset = kqo@nextStartIndex,
  maxFetch = maxResultsPerPage,
  verbose = kqo@korapConnection@verbose,
  randomizePageOrder = FALSE
)

## S4 method for signature 'KorAPQuery'
fetchAll(kqo, verbose = kqo@korapConnection@verbose, ...)

## S4 method for signature 'KorAPQuery'
fetchRest(kqo, verbose = kqo@korapConnection@verbose, ...)

## S4 method for signature 'KorAPConnection'
frequencyQuery(
  kco,
  query,
  vc = "",
  conf.level = 0.95,
  as.alternatives = FALSE,
  ...
)

buildWebUIRequestUrl(
  kco,
  query = if (missing(KorAPUrl))
    stop("At least one of the parameters query and KorAPUrl must be specified.", call. =
    FALSE) else httr::parse_url(KorAPUrl)$query$q,
  vc = if (missing(KorAPUrl)) "" else httr::parse_url(KorAPUrl)$query$cq,
  KorAPUrl,
  metadataOnly = TRUE,
  ql = if (missing(KorAPUrl)) "poliqarp" else httr::parse_url(KorAPUrl)$query$ql,
  fields = c("corpusSigle", "textSigle", "pubDate", "pubPlace", "availability",
    "textClass", "snippet", "tokens"),
  accessRewriteFatal = TRUE
)

## S3 method for class 'KorAPQuery'
format(x, ...)

## S4 method for signature 'KorAPQuery'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KorAPQuery-class_+3A_.object">.Object</code></td>
<td>
<p>…</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_korapconnection">korapConnection</code></td>
<td>
<p>KorAPConnection object</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_request">request</code></td>
<td>
<p>query part of the request URL</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_vc">vc</code></td>
<td>
<p>string describing the virtual corpus in which the query should be performed. An empty string (default) means the whole corpus, as far as it is license-wise accessible.</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_totalresults">totalResults</code></td>
<td>
<p>number of hits the query has yielded</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_nextstartindex">nextStartIndex</code></td>
<td>
<p>at what index to start the next fetch of query results</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_fields">fields</code></td>
<td>
<p>(meta)data fields that will be fetched for every match.</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_requesturl">requestUrl</code></td>
<td>
<p>complete URL of the API request</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_webuirequesturl">webUIRequestUrl</code></td>
<td>
<p>URL of a web frontend request corresponding to the API request</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_apiresponse">apiResponse</code></td>
<td>
<p>data-frame representation of the JSON response of the API request</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_hasmorematches">hasMoreMatches</code></td>
<td>
<p>logical that signals if more query results can be fetched</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_collectedmatches">collectedMatches</code></td>
<td>
<p>matches already fetched from the KorAP-API-server</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_kco">kco</code></td>
<td>
<p><code><a href="#topic+KorAPConnection">KorAPConnection()</a></code> object (obtained e.g. from <code>new("KorAPConnection")</code></p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_query">query</code></td>
<td>
<p>string that contains the corpus query. The query language depends on the <code>ql</code> parameter. Either <code>query</code> must be provided or <code>KorAPUrl</code>.</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_korapurl">KorAPUrl</code></td>
<td>
<p>instead of providing the query and vc string parameters, you can also simply copy a KorAP query URL from your browser and use it here (and in <code>KorAPConnection</code>) to provide all necessary information for the query.</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_metadataonly">metadataOnly</code></td>
<td>
<p>logical that determines whether queries should return only metadata without any snippets. This can also be useful to prevent access rewrites. Note that the default value is TRUE.
If you want your corpus queries to return not only metadata, but also KWICS, you need to authorize
your RKorAPClient application as explained in the
<a href="https://github.com/KorAP/RKorAPClient#authorization">authorization section</a>
of the RKorAPClient Readme on GitHub and set the <code>metadataOnly</code> parameter to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_ql">ql</code></td>
<td>
<p>string to choose the query language (see <a href="https://github.com/KorAP/Kustvakt/wiki/Service:-Search-GET#user-content-parameters">section on Query Parameters</a> in the Kustvakt-Wiki for possible values.</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_accessrewritefatal">accessRewriteFatal</code></td>
<td>
<p>abort if query or given vc had to be rewritten due to insufficient rights (not yet implemented).</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_verbose">verbose</code></td>
<td>
<p>print progress information if true</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_expand">expand</code></td>
<td>
<p>logical that decides if <code>query</code> and <code>vc</code> parameters are expanded to all of their combinations</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_as.df">as.df</code></td>
<td>
<p>return result as data frame instead of as S4 object?</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_context">context</code></td>
<td>
<p>string that specifies the size of the left and the right context returned in <code>snippet</code>
(provided that <code>metadataOnly</code> is set to <code>false</code> and that the necessary access right are  met).
The format of the context size specifcation (e.g. <code style="white-space: pre;">&#8288;3-token,3-token&#8288;</code>) is described in the <a href="https://github.com/KorAP/Kustvakt/wiki/Service:-Search-GET">Service: Search GET documentation of the Kustvakt Wiki</a>.
If the parameter is not set, the default context size secification of the KorAP server instance will be used.
Note that you cannot overrule the maximum context size set in the KorAP server instance,
as this is typically legally motivated.</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_kqo">kqo</code></td>
<td>
<p>object obtained from <code><a href="#topic+corpusQuery">corpusQuery()</a></code></p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_offset">offset</code></td>
<td>
<p>start offset for query results to fetch</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_maxfetch">maxFetch</code></td>
<td>
<p>maximum number of query results to fetch</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_randomizepageorder">randomizePageOrder</code></td>
<td>
<p>fetch result pages in pseudo random order if true. Use <code><a href="base.html#topic+set.seed">set.seed()</a></code> to set seed for reproducible results.</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the returned confidence interval (passed through <code><a href="#topic+ci">ci()</a></code>  to <code><a href="stats.html#topic+prop.test">prop.test()</a></code>).</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_as.alternatives">as.alternatives</code></td>
<td>
<p>LOGICAL that specifies if the query terms should be treated as alternatives. If <code>as.alternatives</code> is TRUE, the sum over all query hits, instead of the respective vc token sizes is used as total for the calculation of relative frequencies.</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_x">x</code></td>
<td>
<p>KorAPQuery object</p>
</td></tr>
<tr><td><code id="KorAPQuery-class_+3A_object">object</code></td>
<td>
<p>KorAPQuery object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the <code>as.df</code> parameter, a table or a <code><a href="#topic+KorAPQuery">KorAPQuery()</a></code> object that, among other information, contains the total number of results in <code style="white-space: pre;">&#8288;@totalResults&#8288;</code>. The resulting object can be used to fetch all query results (with <code><a href="#topic+fetchAll">fetchAll()</a></code>) or the next page of results (with <code><a href="#topic+fetchNext">fetchNext()</a></code>).
A corresponding URL to be used within a web browser is contained in <code style="white-space: pre;">&#8288;@webUIRequestUrl&#8288;</code>
Please make sure to check <code style="white-space: pre;">&#8288;$collection$rewrites&#8288;</code> to see if any unforeseen access rewrites of the query's virtual corpus had to be performed.
</p>
<p>The <code>kqo</code> input object with updated slots <code>collectedMatches</code>, <code>apiResponse</code>, <code>nextStartIndex</code>, <code>hasMoreMatches</code>
</p>


<h3>References</h3>

<p><a href="https://ids-pub.bsz-bw.de/frontdoor/index/index/docId/9026">https://ids-pub.bsz-bw.de/frontdoor/index/index/docId/9026</a>
</p>
<p><a href="https://ids-pub.bsz-bw.de/frontdoor/index/index/docId/9026">https://ids-pub.bsz-bw.de/frontdoor/index/index/docId/9026</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KorAPConnection">KorAPConnection()</a></code>, <code><a href="#topic+fetchNext">fetchNext()</a></code>, <code><a href="#topic+fetchRest">fetchRest()</a></code>, <code><a href="#topic+fetchAll">fetchAll()</a></code>, <code><a href="#topic+corpusStats">corpusStats()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Fetch metadata of every query hit for "Ameisenplage" and show a summary
new("KorAPConnection") %&gt;% corpusQuery("Ameisenplage") %&gt;% fetchAll()

## End(Not run)

## Not run: 

# Use the copy of a KorAP-web-frontend URL for an API query of "Ameise" in a virtual corpus
# and show the number of query hits (but don't fetch them).

new("KorAPConnection", verbose = TRUE) %&gt;%
 corpusQuery(KorAPUrl =
   "https://korap.ids-mannheim.de/?q=Ameise&amp;cq=pubDate+since+2017&amp;ql=poliqarp")

## End(Not run)

## Not run: 

# Plot the time/frequency curve of "Ameisenplage"
new("KorAPConnection", verbose=TRUE) %&gt;%
  { . -&gt;&gt; kco } %&gt;%
  corpusQuery("Ameisenplage") %&gt;%
  fetchAll() %&gt;%
  slot("collectedMatches") %&gt;%
  mutate(year = lubridate::year(pubDate)) %&gt;%
  dplyr::select(year) %&gt;%
  group_by(year) %&gt;%
  summarise(Count = dplyr::n()) %&gt;%
  mutate(Freq = mapply(function(f, y)
    f / corpusStats(kco, paste("pubDate in", y))@tokens, Count, year)) %&gt;%
  dplyr::select(-Count) %&gt;%
  complete(year = min(year):max(year), fill = list(Freq = 0)) %&gt;%
  plot(type = "l")

## End(Not run)
## Not run: 

q &lt;- new("KorAPConnection") %&gt;% corpusQuery("Ameisenplage") %&gt;% fetchNext()
q@collectedMatches

## End(Not run)

## Not run: 

q &lt;- new("KorAPConnection") %&gt;% corpusQuery("Ameisenplage") %&gt;% fetchAll()
q@collectedMatches

## End(Not run)

## Not run: 

q &lt;- new("KorAPConnection") %&gt;% corpusQuery("Ameisenplage") %&gt;% fetchRest()
q@collectedMatches

## End(Not run)

## Not run: 

new("KorAPConnection", verbose = TRUE) %&gt;%
  frequencyQuery(c("Mücke", "Schnake"), paste0("pubDate in ", 2000:2003))

## End(Not run)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+bind_cols'></span><span id='topic+mutate'></span><span id='topic+select'></span><span id='topic+group_by'></span><span id='topic+summarise'></span><span id='topic+n'></span><span id='topic+complete'></span><span id='topic+expand_grid'></span><span id='topic+year'></span><span id='topic+as_tibble'></span><span id='topic+tidy'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>broom</dt><dd><p><code><a href="broom.html#topic+reexports">tidy</a></code></p>
</dd>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+bind_cols">bind_cols</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+context">n</a></code>, <code><a href="dplyr.html#topic+select">select</a></code>, <code><a href="dplyr.html#topic+summarise">summarise</a></code></p>
</dd>
<dt>lubridate</dt><dd><p><code><a href="lubridate.html#topic+year">year</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code></p>
</dd>
<dt>tidyr</dt><dd><p><code><a href="tidyr.html#topic+complete">complete</a></code>, <code><a href="tidyr.html#topic+expand_grid">expand_grid</a></code></p>
</dd>
</dl>

<hr>
<h2 id='RKorAPClient-package'>RKorAPClient: 'KorAP' Web Service Client Package</h2><span id='topic+RKorAPClient'></span><span id='topic+RKorAPClient-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A client package that makes the 'KorAP' web service API accessible from R. The corpus analysis platform 'KorAP' has been developed as a scientific tool to make potentially large, stratified and multiply annotated corpora, such as the 'German Reference Corpus DeReKo' or the 'Corpus of the Contemporary Romanian Language CoRoLa', accessible for linguists to let them verify hypotheses and to find interesting patterns in real language use. The 'RKorAPClient' package provides access to 'KorAP' and the corpora behind it for user-created R code, as a programmatic alternative to the 'KorAP' web user-interface. You can learn more about 'KorAP' and use it directly on 'DeReKo' at <a href="https://korap.ids-mannheim.de/">https://korap.ids-mannheim.de/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Marc Kupietz <a href="mailto:kupietz@ids-mannheim.de">kupietz@ids-mannheim.de</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Nils Diewald <a href="mailto:diewald@ids-mannheim.de">diewald@ids-mannheim.de</a> [contributor]
</p>
</li>
<li><p> Leibniz Institute for the German Language [copyright holder, funder]
</p>
</li></ul>



<h3>References</h3>

<p>Kupietz, Marc / Diewald, Nils / Margaretha, Eliza (2020):
RKorAPClient: An R package for accessing the German Reference Corpus DeReKo
via KorAP. In: Calzolari, Nicoletta, Frédéric Béchet, Philippe Blache,
Khalid Choukri, Christopher Cieri,  Thierry Declerck, Sara Goggi,
Hitoshi Isahara, Bente Maegaard, Joseph Mariani, Hélène Mazo,
Asuncion Moreno, Jan Odijk, Stelios Piperidis (eds.):
Proceedings of The 12th Language Resources and Evaluation Conference (LREC 2020)
Marseille: European Language Resources Association (ELRA), 7017-7023.
<a href="http://www.lrec-conf.org/proceedings/lrec2020/pdf/2020.lrec-1.867.pdf">http://www.lrec-conf.org/proceedings/lrec2020/pdf/2020.lrec-1.867.pdf</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/KorAP/RKorAPClient/">https://github.com/KorAP/RKorAPClient/</a>
</p>
</li>
<li> <p><a href="https://korap.ids-mannheim.de/">https://korap.ids-mannheim.de/</a>
</p>
</li>
<li> <p><a href="https://www.ids-mannheim.de/digspra/kl/projekte/korap">https://www.ids-mannheim.de/digspra/kl/projekte/korap</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/KorAP/RKorAPClient/issues">https://github.com/KorAP/RKorAPClient/issues</a>
</p>
</li></ul>


<hr>
<h2 id='synsemanticStopwords'>Preliminary synsemantic stopwords function</h2><span id='topic+synsemanticStopwords'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Preliminary synsemantic stopwords function to be used in collocation analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synsemanticStopwords(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synsemanticStopwords_+3A_...">...</code></td>
<td>
<p>future arguments for language detection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently only suitable for German. See stopwords package for other languages.
</p>


<h3>Value</h3>

<p>Vector of synsemantic stopwords.
</p>


<h3>See Also</h3>

<p>Other collocation analysis functions: 
<code><a href="#topic+association-score-functions">association-score-functions</a></code>,
<code><a href="#topic+collocationAnalysis+2CKorAPConnection-method">collocationAnalysis,KorAPConnection-method</a></code>,
<code><a href="#topic+collocationScoreQuery+2CKorAPConnection-method">collocationScoreQuery,KorAPConnection-method</a></code>
</p>

<hr>
<h2 id='textMetadata+2CKorAPConnection-method'>Retrieve metadata for a text, identified by its sigle (id)</h2><span id='topic+textMetadata+2CKorAPConnection-method'></span><span id='topic+textMetadata'></span>

<h3>Description</h3>

<p>Retrieves metadata for a text, identified by its sigle (id) using the corresponding KorAP API
(see <a href="https://github.com/KorAP/Kustvakt/wiki/Service:-Metadata-Retrieval">Kustvakt Wiki</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KorAPConnection'
textMetadata(kco, textSigle, verbose = kco@verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textMetadata+2B2CKorAPConnection-method_+3A_kco">kco</code></td>
<td>
<p><code><a href="#topic+KorAPConnection">KorAPConnection()</a></code> object (obtained e.g. from <code>new("KorAPConnection")</code>)</p>
</td></tr>
<tr><td><code id="textMetadata+2B2CKorAPConnection-method_+3A_textsigle">textSigle</code></td>
<td>
<p>unique text id (concatenation of corpus, document and text ids, separated by <code>/</code>, e.g. ) or vector thereof</p>
</td></tr>
<tr><td><code id="textMetadata+2B2CKorAPConnection-method_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, additional diagnostics are printed. Defaults to <code>kco@verbose</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble with columns for each metadata property. In case of errors, such as non-existing texts/sigles, the tibble will also contain a column called <code>errors</code>.
If there are metadata columns you cannot make sense of, please ignore them. The function simply returns all the metadata it gets from the server.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
new("KorAPConnection") %&gt;% textMetadata(c("WUD17/A97/08542", "WUD17/B96/57558", "WUD17/A97/08541"))

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
