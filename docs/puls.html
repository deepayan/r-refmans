<!DOCTYPE html><html><head><title>Help for package puls</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {puls}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arctic_2019'><p>NOAA's Arctic Sea Daily Ice Extend Data</p></a></li>
<li><a href='#as_MonoClust.PULS'><p>Coerce a PULS Object to MonoClust Object</p></a></li>
<li><a href='#checkem'><p>First Gate Function</p></a></li>
<li><a href='#fdistmatrix'><p>Distance Between Functional Objects</p></a></li>
<li><a href='#find_split'><p>Find the Best Split</p></a></li>
<li><a href='#ggwave'><p>Plot the Partitioned Functional Wave by PULS</p></a></li>
<li><a href='#plot.PULS'><p>Plot PULS Splitting Rule Tree</p></a></li>
<li><a href='#print.PULS'><p>Print PULS Clustering Result</p></a></li>
<li><a href='#PULS'><p>Partitioning Using Local Subregions (PULS)</p></a></li>
<li><a href='#puls-package'><p>puls: Partitioning Using Local Subregions</p></a></li>
<li><a href='#PULS.object'><p>PULS Tree Object</p></a></li>
<li><a href='#smoothed_arctic'><p>Discrete Form of Smoothed Functional Form of Arctic Data</p></a></li>
<li><a href='#splitter'><p>Split Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Partitioning Using Local Subregions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A method of clustering functional data using
    subregion information of the curves. It is intended to supplement the
    'fda' and 'fda.usc' packages in functional data object clustering. It
    also facilitates the printing and plotting of the results in a tree
    format and limits the partitioning candidates into a specific set of
    subregions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://vinhtantran.github.io/puls/">https://vinhtantran.github.io/puls/</a>,
<a href="https://github.com/vinhtantran/puls">https://github.com/vinhtantran/puls</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vinhtantran/puls/issues">https://github.com/vinhtantran/puls/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster (&ge; 2.0.5), dplyr (&ge; 1.0.0), fda, fda.usc (&ge; 1.3.0),
ggplot2, graphics, monoClust (&ge; 1.2.0), purrr (&ge; 0.3.0),
rlang (&ge; 0.3.0), stats, tibble (&ge; 3.0.0), tidyr (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, lubridate, rmarkdown, testthat, vdiffr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-16 14:43:28 UTC; vinht</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark Greenwood <a href="https://orcid.org/0000-0001-6933-1201"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Tan Tran <a href="https://orcid.org/0000-0001-9881-6339"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tan Tran &lt;vinhtantran@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-16 16:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='arctic_2019'>NOAA's Arctic Sea Daily Ice Extend Data</h2><span id='topic+arctic_2019'></span>

<h3>Description</h3>

<p>A data set containing the daily ice extent at Arctic Sea from 1978 to 2019,
collected by National Oceanic and Atmospheric Administration (NOAA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arctic_2019
</code></pre>


<h3>Format</h3>

<p>A data frame with 13391 rows and 6 variables:
</p>

<dl>
<dt>Year</dt><dd><p>Years of available data (1978&ndash;2019).</p>
</dd>
<dt>Month</dt><dd><p>Month (01&ndash;12).</p>
</dd>
<dt>Day</dt><dd><p>Day of the month indicated in Column Month.</p>
</dd>
<dt>Extent</dt><dd><p>Daily ice extent, to three decimal places.</p>
</dd>
<dt>Missing</dt><dd><p>Whether a day is missing (1) or not (0)).</p>
</dd>
<dt>Source Data</dt><dd><p>data source in NOAA database.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://nsidc.org/data/G02135/versions/3">https://nsidc.org/data/G02135/versions/3</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(lubridate)
library(ggplot2)

data(arctic_2019)

# Create day in the year column to replace Month and Day
north &lt;-
  arctic_2019 %&gt;%
  mutate(yday = yday(make_date(Year, Month, Day)),
         .keep = "all") %&gt;%
  select(Year, yday, Extent)

ggplot(north) +
  geom_linerange(aes(x = yday, ymin = Year - 0.2, ymax = Year + 0.2),
                 size = 0.5, color = "red") +
  scale_y_continuous(breaks = seq(1980, 2020, by = 5),
                     minor_breaks = NULL) +
  labs(x = "Day",
       y = "Year",
       title = "Measurement frequencies were not always the same")
</code></pre>

<hr>
<h2 id='as_MonoClust.PULS'>Coerce a PULS Object to MonoClust Object</h2><span id='topic+as_MonoClust.PULS'></span>

<h3>Description</h3>

<p>An implementation of the <code><a href="monoClust.html#topic+as_MonoClust">monoClust::as_MonoClust()</a></code> S3 method for PULS
object. The purpose of this is to reuse plotting and printing functions from
monoClust package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PULS'
as_MonoClust(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_MonoClust.PULS_+3A_x">x</code></td>
<td>
<p>A PULS object to be coerced to MonoClust object.</p>
</td></tr>
<tr><td><code id="as_MonoClust.PULS_+3A_...">...</code></td>
<td>
<p>For extensibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A MonoClust object coerced from PULS object.
</p>


<h3>See Also</h3>

<p><a href="monoClust.html#topic+MonoClust.object">monoClust::MonoClust.object</a> and <a href="#topic+PULS.object">PULS.object</a>
</p>

<hr>
<h2 id='checkem'>First Gate Function</h2><span id='topic+checkem'></span>

<h3>Description</h3>

<p>This function checks what are available nodes to split and then call
<code>find_split()</code> on each node, then decide which node creates best split, and
call <code>splitter()</code> to perform the split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkem(
  toclust.fd,
  frame,
  cloc,
  dist,
  dsubs,
  dsubsname,
  weights,
  minbucket,
  minsplit,
  spliton,
  method
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkem_+3A_toclust.fd">toclust.fd</code></td>
<td>
<p>A functional data object (i.e., having class <code>fd</code>) created
from <code>fda</code> package. See <code><a href="fda.html#topic+fd">fda::fd()</a></code>.</p>
</td></tr>
<tr><td><code id="checkem_+3A_frame">frame</code></td>
<td>
<p>The split tree transferred as data frame.</p>
</td></tr>
<tr><td><code id="checkem_+3A_cloc">cloc</code></td>
<td>
<p>Vector of current cluster membership.</p>
</td></tr>
<tr><td><code id="checkem_+3A_dist">dist</code></td>
<td>
<p>Distance matrix of all observations in the data.</p>
</td></tr>
<tr><td><code id="checkem_+3A_dsubs">dsubs</code></td>
<td>
<p>Distance matrix calculated on each subregion. A
three-dimensional matrix.</p>
</td></tr>
<tr><td><code id="checkem_+3A_dsubsname">dsubsname</code></td>
<td>
<p>Subregion names.</p>
</td></tr>
<tr><td><code id="checkem_+3A_weights">weights</code></td>
<td>
<p>(Currently unused) Weights on observations.</p>
</td></tr>
<tr><td><code id="checkem_+3A_minbucket">minbucket</code></td>
<td>
<p>The minimum number of data points in one cluster allowed.</p>
</td></tr>
<tr><td><code id="checkem_+3A_minsplit">minsplit</code></td>
<td>
<p>The minimum number of observations that must exist in a node
in order for a split to be attempted.</p>
</td></tr>
<tr><td><code id="checkem_+3A_spliton">spliton</code></td>
<td>
<p>Restrict the partitioning on a specific set of subregions.</p>
</td></tr>
<tr><td><code id="checkem_+3A_method">method</code></td>
<td>
<p>The clustering method you want to run in each subregion. Can be
chosen between <code>pam</code> and <code>ward</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It is not supposed to return anything because global environment was
used. However, if there is nothing left to split, it returns 0 to tell the
caller to stop running the loop.
</p>

<hr>
<h2 id='fdistmatrix'>Distance Between Functional Objects</h2><span id='topic+fdistmatrix'></span>

<h3>Description</h3>

<p>Calculate the distance between functional objects over the defined range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdistmatrix(fd, subrange, distmethod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdistmatrix_+3A_fd">fd</code></td>
<td>
<p>A functional data object <code>fd</code> of <code>fda</code> package.</p>
</td></tr>
<tr><td><code id="fdistmatrix_+3A_subrange">subrange</code></td>
<td>
<p>A vector of two values indicating the value range of
functional object to calculate on.</p>
</td></tr>
<tr><td><code id="fdistmatrix_+3A_distmethod">distmethod</code></td>
<td>
<p>The method for calculating the distance matrix. Choose
between <code>"usc"</code> and <code>"manual"</code>. <code>"usc"</code> uses <code><a href="fda.usc.html#topic+metric.lp">fda.usc::metric.lp()</a></code>
function while <code>"manual"</code> uses squared distance between functions. See
Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If choosing <code>distmethod = "manual"</code>, the L2 distance between all pairs of
functions <code class="reqn">y_i(t)</code> and <code class="reqn">y_j(t)</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">d_R(y_i, y_j) = \sqrt{\int_{a_r}^{b_r} [y_i(t) - y_j(t)]^2 dt}.</code>
</p>



<h3>Value</h3>

<p>A distance matrix with diagonal value and the upper half.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
# Examples taken from fda::Data2fd()
data(gait)
# Function only works on two dimensional data
gait &lt;- gait[, 1:5, 1]
gaitbasis3 &lt;- create.fourier.basis(nbasis = 5)
gaitfd3 &lt;- Data2fd(gait, basisobj = gaitbasis3)

fdistmatrix(gaitfd3, c(0.2, 0.4), "usc")
</code></pre>

<hr>
<h2 id='find_split'>Find the Best Split</h2><span id='topic+find_split'></span>

<h3>Description</h3>

<p>Find the best split in terms of reduction in inertia for the transferred
node, indicate by row. Find the terminal node with the greatest change in
inertia and bi-partition it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_split(
  toclust.fd,
  frame_row,
  cloc,
  dist,
  dsubs,
  dsubsname,
  weights,
  minbucket,
  minsplit,
  spliton,
  method
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_split_+3A_toclust.fd">toclust.fd</code></td>
<td>
<p>A functional data object (i.e., having class <code>fd</code>) created
from <code>fda</code> package. See <code><a href="fda.html#topic+fd">fda::fd()</a></code>.</p>
</td></tr>
<tr><td><code id="find_split_+3A_frame_row">frame_row</code></td>
<td>
<p>One row of the split tree as data frame.</p>
</td></tr>
<tr><td><code id="find_split_+3A_cloc">cloc</code></td>
<td>
<p>Vector of current cluster membership.</p>
</td></tr>
<tr><td><code id="find_split_+3A_dist">dist</code></td>
<td>
<p>Distance matrix of all observations in the data.</p>
</td></tr>
<tr><td><code id="find_split_+3A_dsubs">dsubs</code></td>
<td>
<p>Distance matrix calculated on each subregion. A
three-dimensional matrix.</p>
</td></tr>
<tr><td><code id="find_split_+3A_dsubsname">dsubsname</code></td>
<td>
<p>Subregion names.</p>
</td></tr>
<tr><td><code id="find_split_+3A_weights">weights</code></td>
<td>
<p>(Currently unused) Weights on observations.</p>
</td></tr>
<tr><td><code id="find_split_+3A_minbucket">minbucket</code></td>
<td>
<p>The minimum number of data points in one cluster allowed.</p>
</td></tr>
<tr><td><code id="find_split_+3A_minsplit">minsplit</code></td>
<td>
<p>The minimum number of observations that must exist in a node
in order for a split to be attempted.</p>
</td></tr>
<tr><td><code id="find_split_+3A_spliton">spliton</code></td>
<td>
<p>Restrict the partitioning on a specific set of subregions.</p>
</td></tr>
<tr><td><code id="find_split_+3A_method">method</code></td>
<td>
<p>The clustering method you want to run in each subregion. Can be
chosen between <code>pam</code> and <code>ward</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>frame_row</code> with the next split updated.
</p>

<hr>
<h2 id='ggwave'>Plot the Partitioned Functional Wave by PULS</h2><span id='topic+ggwave'></span>

<h3>Description</h3>

<p>After partitioning using PULS, this function can plot the functional waves
and color different clusters as well as their medoids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggwave(
  toclust.fd,
  intervals,
  puls.obj,
  xlab = NULL,
  ylab = NULL,
  lwd = 0.5,
  alpha = 0.4,
  lwd.med = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggwave_+3A_toclust.fd">toclust.fd</code></td>
<td>
<p>A functional data object (i.e., having class <code>fd</code>) created
from <code>fda</code> package. See <code><a href="fda.html#topic+fd">fda::fd()</a></code>.</p>
</td></tr>
<tr><td><code id="ggwave_+3A_intervals">intervals</code></td>
<td>
<p>A data set (or matrix) with rows are intervals and columns
are the beginning and ending indexes of of the interval.</p>
</td></tr>
<tr><td><code id="ggwave_+3A_puls.obj">puls.obj</code></td>
<td>
<p>A <code>PULS</code> object as a result of <code><a href="#topic+PULS">PULS()</a></code>.</p>
</td></tr>
<tr><td><code id="ggwave_+3A_xlab">xlab</code></td>
<td>
<p>Labels for x-axis. If not provided, the labels stored in <code>fd</code>
object will be used.</p>
</td></tr>
<tr><td><code id="ggwave_+3A_ylab">ylab</code></td>
<td>
<p>Labels for y-axis.  If not provided, the labels stored in <code>fd</code>
object will be used.</p>
</td></tr>
<tr><td><code id="ggwave_+3A_lwd">lwd</code></td>
<td>
<p>Linewidth of normal waves.</p>
</td></tr>
<tr><td><code id="ggwave_+3A_alpha">alpha</code></td>
<td>
<p>Transparency of normal waves.</p>
</td></tr>
<tr><td><code id="ggwave_+3A_lwd.med">lwd.med</code></td>
<td>
<p>Linewidth of medoid waves.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fda)

# Build a simple fd object from already smoothed smoothed_arctic
data(smoothed_arctic)
NBASIS &lt;- 300
NORDER &lt;- 4
y &lt;- t(as.matrix(smoothed_arctic[, -1]))
splinebasis &lt;- create.bspline.basis(rangeval = c(1, 365),
                                    nbasis = NBASIS,
                                    norder = NORDER)
fdParobj &lt;- fdPar(fdobj = splinebasis,
                  Lfdobj = 2,
                  # No need for any more smoothing
                  lambda = .000001)
yfd &lt;- smooth.basis(argvals = 1:365, y = y, fdParobj = fdParobj)

Jan &lt;- c(1, 31); Feb &lt;- c(31, 59); Mar &lt;- c(59, 90)
Apr &lt;- c(90, 120); May &lt;- c(120, 151); Jun &lt;- c(151, 181)
Jul &lt;- c(181, 212); Aug &lt;- c(212, 243); Sep &lt;- c(243, 273)
Oct &lt;- c(273, 304); Nov &lt;- c(304, 334); Dec &lt;- c(334, 365)

intervals &lt;-
  rbind(Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)

PULS4_pam &lt;- PULS(toclust.fd = yfd$fd, intervals = intervals,
                  nclusters = 4, method = "pam")
ggwave(toclust.fd = yfd$fd, intervals = intervals, puls = PULS4_pam)

</code></pre>

<hr>
<h2 id='plot.PULS'>Plot PULS Splitting Rule Tree</h2><span id='topic+plot.PULS'></span>

<h3>Description</h3>

<p>Print the PULS tree in the form of dendrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PULS'
plot(
  x,
  branch = 1,
  margin = c(0.12, 0.02, 0, 0.05),
  text = TRUE,
  which = 4,
  digits = getOption("digits") - 2,
  cols = NULL,
  col.type = c("l", "p", "b"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PULS_+3A_x">x</code></td>
<td>
<p>A <code>PULS</code> object.</p>
</td></tr>
<tr><td><code id="plot.PULS_+3A_branch">branch</code></td>
<td>
<p>Controls the shape of the branches from parent to child node.
Any number from 0 to 1 is allowed. A value of 1 gives square shouldered
branches, a value of 0 give V shaped branches, with other values being
intermediate.</p>
</td></tr>
<tr><td><code id="plot.PULS_+3A_margin">margin</code></td>
<td>
<p>An extra fraction of white space to leave around the borders of
the tree. (Long labels sometimes get cut off by the default computation).</p>
</td></tr>
<tr><td><code id="plot.PULS_+3A_text">text</code></td>
<td>
<p>Whether to print the labels on the tree.</p>
</td></tr>
<tr><td><code id="plot.PULS_+3A_which">which</code></td>
<td>
<p>Labeling modes, which are:
</p>

<ul>
<li><p> 1: only splitting variable names are shown, no splitting rules.
</p>
</li>
<li><p> 2: only splitting rules to the left branches are shown.
</p>
</li>
<li><p> 3: only splitting rules to the right branches are shown.
</p>
</li>
<li><p> 4 (default): splitting rules are shown on both sides of branches.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.PULS_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
<tr><td><code id="plot.PULS_+3A_cols">cols</code></td>
<td>
<p>Whether to shown color bars at leaves or not. It helps matching
this tree plot with other plots whose cluster membership were colored. It
only works when <code>text</code> is <code>TRUE</code>. Either <code>NULL</code>, a vector of one color, or
a vector of colors matching the number of leaves.</p>
</td></tr>
<tr><td><code id="plot.PULS_+3A_col.type">col.type</code></td>
<td>
<p>When <code>cols</code> is set, choose whether the color indicators are
shown in a form of solid lines below the leaves (<code>"l"</code>), or big points
(<code>"p"</code>), or both (<code>"b"</code>).</p>
</td></tr>
<tr><td><code id="plot.PULS_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="monoClust.html#topic+plot.MonoClust">monoClust::plot.MonoClust()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of splitting order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fda)

# Build a simple fd object from already smoothed smoothed_arctic
data(smoothed_arctic)
NBASIS &lt;- 300
NORDER &lt;- 4
y &lt;- t(as.matrix(smoothed_arctic[, -1]))
splinebasis &lt;- create.bspline.basis(rangeval = c(1, 365),
                                    nbasis = NBASIS,
                                    norder = NORDER)
fdParobj &lt;- fdPar(fdobj = splinebasis,
                  Lfdobj = 2,
                  # No need for any more smoothing
                  lambda = .000001)
yfd &lt;- smooth.basis(argvals = 1:365, y = y, fdParobj = fdParobj)

Jan &lt;- c(1, 31); Feb &lt;- c(31, 59); Mar &lt;- c(59, 90)
Apr &lt;- c(90, 120); May &lt;- c(120, 151); Jun &lt;- c(151, 181)
Jul &lt;- c(181, 212); Aug &lt;- c(212, 243); Sep &lt;- c(243, 273)
Oct &lt;- c(273, 304); Nov &lt;- c(304, 334); Dec &lt;- c(334, 365)

intervals &lt;-
  rbind(Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)

PULS4_pam &lt;- PULS(toclust.fd = yfd$fd, intervals = intervals,
                  nclusters = 4, method = "pam")
plot(PULS4_pam)

</code></pre>

<hr>
<h2 id='print.PULS'>Print PULS Clustering Result</h2><span id='topic+print.PULS'></span>

<h3>Description</h3>

<p>Render the PULS split tree in an easy to read format with important
information such as terminal nodes, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PULS'
print(x, spaces = 2L, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PULS_+3A_x">x</code></td>
<td>
<p>A <code>PULS</code> result object.</p>
</td></tr>
<tr><td><code id="print.PULS_+3A_spaces">spaces</code></td>
<td>
<p>Spaces indent between 2 tree levels.</p>
</td></tr>
<tr><td><code id="print.PULS_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
<tr><td><code id="print.PULS_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="monoClust.html#topic+print.MonoClust">monoClust::print.MonoClust()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nicely displayed PULS split tree in text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fda)

# Build a simple fd object from already smoothed smoothed_arctic
data(smoothed_arctic)
NBASIS &lt;- 300
NORDER &lt;- 4
y &lt;- t(as.matrix(smoothed_arctic[, -1]))
splinebasis &lt;- create.bspline.basis(rangeval = c(1, 365),
                                    nbasis = NBASIS,
                                    norder = NORDER)
fdParobj &lt;- fdPar(fdobj = splinebasis,
                  Lfdobj = 2,
                  # No need for any more smoothing
                  lambda = .000001)
yfd &lt;- smooth.basis(argvals = 1:365, y = y, fdParobj = fdParobj)

Jan &lt;- c(1, 31); Feb &lt;- c(31, 59); Mar &lt;- c(59, 90)
Apr &lt;- c(90, 120); May &lt;- c(120, 151); Jun &lt;- c(151, 181)
Jul &lt;- c(181, 212); Aug &lt;- c(212, 243); Sep &lt;- c(243, 273)
Oct &lt;- c(273, 304); Nov &lt;- c(304, 334); Dec &lt;- c(334, 365)

intervals &lt;-
  rbind(Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)

PULS4_pam &lt;- PULS(toclust.fd = yfd$fd, intervals = intervals,
                  nclusters = 4, method = "pam")
print(PULS4_pam)

</code></pre>

<hr>
<h2 id='PULS'>Partitioning Using Local Subregions (PULS)</h2><span id='topic+PULS'></span>

<h3>Description</h3>

<p>PULS function for functional data (only used when you know that the data
shouldn't be converted into functional because it's already smooth, e.g.
your data are step function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PULS(
  toclust.fd,
  method = c("pam", "ward"),
  intervals = c(0, 1),
  spliton = NULL,
  distmethod = c("usc", "manual"),
  labels = toclust.fd$fdnames[2]$reps,
  nclusters = length(toclust.fd$fdnames[2]$reps),
  minbucket = 2,
  minsplit = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PULS_+3A_toclust.fd">toclust.fd</code></td>
<td>
<p>A functional data object (i.e., having class <code>fd</code>) created
from <code>fda</code> package. See <code><a href="fda.html#topic+fd">fda::fd()</a></code>.</p>
</td></tr>
<tr><td><code id="PULS_+3A_method">method</code></td>
<td>
<p>The clustering method you want to run in each subregion. Can be
chosen between <code>pam</code> and <code>ward</code>.</p>
</td></tr>
<tr><td><code id="PULS_+3A_intervals">intervals</code></td>
<td>
<p>A data set (or matrix) with rows are intervals and columns
are the beginning and ending indexes of of the interval.</p>
</td></tr>
<tr><td><code id="PULS_+3A_spliton">spliton</code></td>
<td>
<p>Restrict the partitioning on a specific set of subregions.</p>
</td></tr>
<tr><td><code id="PULS_+3A_distmethod">distmethod</code></td>
<td>
<p>The method for calculating the distance matrix. Choose
between <code>"usc"</code> and <code>"manual"</code>. <code>"usc"</code> uses <code><a href="fda.usc.html#topic+metric.lp">fda.usc::metric.lp()</a></code>
function while <code>"manual"</code> uses squared distance between functions. See
Details.</p>
</td></tr>
<tr><td><code id="PULS_+3A_labels">labels</code></td>
<td>
<p>The name of entities.</p>
</td></tr>
<tr><td><code id="PULS_+3A_nclusters">nclusters</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="PULS_+3A_minbucket">minbucket</code></td>
<td>
<p>The minimum number of data points in one cluster allowed.</p>
</td></tr>
<tr><td><code id="PULS_+3A_minsplit">minsplit</code></td>
<td>
<p>The minimum size of a cluster that can still be considered to
be a split candidate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If choosing <code>distmethod = "manual"</code>, the L2 distance between all pairs of
functions <code class="reqn">y_i(t)</code> and <code class="reqn">y_j(t)</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">d_R(y_i, y_j) = \sqrt{\int_{a_r}^{b_r} [y_i(t) - y_j(t)]^2 dt}.</code>
</p>



<h3>Value</h3>

<p>A <code>PULS</code> object. See <a href="#topic+PULS.object">PULS.object</a> for details.
</p>


<h3>See Also</h3>

<p><code><a href="fda.html#topic+is.fd">fda::is.fd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fda)

# Build a simple fd object from already smoothed smoothed_arctic
data(smoothed_arctic)
NBASIS &lt;- 300
NORDER &lt;- 4
y &lt;- t(as.matrix(smoothed_arctic[, -1]))
splinebasis &lt;- create.bspline.basis(rangeval = c(1, 365),
                                    nbasis = NBASIS,
                                    norder = NORDER)
fdParobj &lt;- fdPar(fdobj = splinebasis,
                  Lfdobj = 2,
                  # No need for any more smoothing
                  lambda = .000001)
yfd &lt;- smooth.basis(argvals = 1:365, y = y, fdParobj = fdParobj)

Jan &lt;- c(1, 31); Feb &lt;- c(31, 59); Mar &lt;- c(59, 90)
Apr &lt;- c(90, 120); May &lt;- c(120, 151); Jun &lt;- c(151, 181)
Jul &lt;- c(181, 212); Aug &lt;- c(212, 243); Sep &lt;- c(243, 273)
Oct &lt;- c(273, 304); Nov &lt;- c(304, 334); Dec &lt;- c(334, 365)

intervals &lt;-
  rbind(Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)

PULS4_pam &lt;- PULS(toclust.fd = yfd$fd, intervals = intervals,
                  nclusters = 4, method = "pam")
PULS4_pam

</code></pre>

<hr>
<h2 id='puls-package'>puls: Partitioning Using Local Subregions</h2><span id='topic+puls'></span><span id='topic+puls-package'></span>

<h3>Description</h3>

<p>A method of clustering functional data using
subregion information of the curves. It is intended to supplement the
'fda' and 'fda.usc' packages in functional data object clustering. It
also facilitates the printing and plotting of the results in a tree
format and limits the partitioning candidates into a specific set of
subregions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tan Tran <a href="mailto:vinhtantran@gmail.com">vinhtantran@gmail.com</a> (<a href="https://orcid.org/0000-0001-9881-6339">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Mark Greenwood <a href="mailto:greenwood@montana.edu">greenwood@montana.edu</a> (<a href="https://orcid.org/0000-0001-6933-1201">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://vinhtantran.github.io/puls/">https://vinhtantran.github.io/puls/</a>
</p>
</li>
<li> <p><a href="https://github.com/vinhtantran/puls">https://github.com/vinhtantran/puls</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/vinhtantran/puls/issues">https://github.com/vinhtantran/puls/issues</a>
</p>
</li></ul>


<hr>
<h2 id='PULS.object'>PULS Tree Object</h2><span id='topic+PULS.object'></span>

<h3>Description</h3>

<p>The structure and objects contained in PULS, an object returned from
the <code><a href="#topic+PULS">PULS()</a></code> function and used as the input in other functions in the
package.
</p>


<h3>Value</h3>


<dl>
<dt>frame</dt><dd><p>Data frame in the form of a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> representing
a tree structure with one row for each node. The columns include:
</p>

<dl>
<dt>number</dt><dd><p>Index of the node. Depth of a node can be derived by
<code>number %/% 2</code>.</p>
</dd>
<dt>var</dt><dd><p>Name of the variable used in the split at a node or
<code>"&lt;leaf&gt;"</code> if it is a leaf node.</p>
</dd>
<dt>n</dt><dd><p>Cluster size, the number of observations in that cluster.</p>
</dd>
<dt>wt</dt><dd><p>Weights of observations. Unusable. Saved for future use.</p>
</dd>
<dt>inertia</dt><dd><p>Inertia value of the cluster at that node.</p>
</dd>
<dt>bipartsplitrow</dt><dd><p>Position of the next split row in the data set
(that position will belong to left node (smaller)).</p>
</dd>
<dt>bipartsplitcol</dt><dd><p>Position of the next split variable in the data
set.</p>
</dd>
<dt>inertiadel</dt><dd><p>Proportion of inertia value of the cluster at that
node to the inertia of the root.</p>
</dd>
<dt>medoid</dt><dd><p>Position of the data point regarded as the medoid of
its cluster.</p>
</dd>
<dt>loc</dt><dd><p>y-coordinate of the splitting node to facilitate showing
on the tree. See <code><a href="#topic+plot.PULS">plot.PULS()</a></code> for details.</p>
</dd>
<dt>inertia_explained</dt><dd><p>Percent inertia explained as described in
Chavent (2007). It is <code style="white-space: pre;">&#8288;1 - (sum(current inertia)/inertial[1])&#8288;</code>.</p>
</dd>
<dt>alt</dt><dd><p>Indicator of an alternative cut yielding the same reduction
in inertia at that split.</p>
</dd>
</dl>
</dd>
<dt>membership</dt><dd><p>Vector of the same length as the number of rows in the
data, containing the value of <code>frame$number</code> corresponding to the leaf
node that an observation falls into.</p>
</dd>
<dt>dist</dt><dd><p>Distance matrix calculated using the method indicated in
<code>distmethod</code> argument of <code><a href="#topic+PULS">PULS()</a></code>.</p>
</dd>
<dt>terms</dt><dd><p>Vector of subregion names in the data that were used to
split.</p>
</dd>
<dt>medoids</dt><dd><p>Named vector of positions of the data points regarded as
medoids of clusters.</p>
</dd>
<dt>alt</dt><dd><p>Indicator of having an alternate splitting route occurred when
splitting.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Chavent, M., Lechevallier, Y., &amp; Briant, O. (2007). DIVCLUS-T: A monothetic
divisive hierarchical clustering method. Computational Statistics &amp; Data
Analysis, 52(2), 687-701. doi: <a href="https://doi.org/10.1016/j.csda.2007.03.013">10.1016/j.csda.2007.03.013</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+PULS">PULS()</a></code>.
</p>

<hr>
<h2 id='smoothed_arctic'>Discrete Form of Smoothed Functional Form of Arctic Data</h2><span id='topic+smoothed_arctic'></span>

<h3>Description</h3>

<p>Raw Arctic data were smoothed and then transformed into functional data using
<code>fda</code> package. To overcome the difficulty of exporting an <code>fda</code> object in a
package, the object was discretized into a data set with 365 columns
corresponding to 365 days a year and 39 rows corresponding to
39 years. The years are from 1979 to 1986, then from 1989 to 2018. The years
1978, 1987, and 1988 were removed because the measurements were not complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothed_arctic
</code></pre>


<h3>Format</h3>

<p>A data frame with 39 rows corresponding to 39 years (1979 to 1986,
1989 to 2019) and 366 columns.
</p>


<h3>See Also</h3>

<p>NOAA's raw data at <a href="#topic+arctic_2019">arctic_2019</a> and the code to generate this data
in data-raw/ folder of source code.
</p>

<hr>
<h2 id='splitter'>Split Function</h2><span id='topic+splitter'></span>

<h3>Description</h3>

<p>Given the Cluster's frame's row position to split at <code>split_row</code>, this
function performs the split, calculate all necessary information for the
splitting tree and cluster memberships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitter(
  toclust.fd,
  split_row,
  frame,
  cloc,
  dist,
  dsubs,
  dsubsname,
  weights,
  method
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitter_+3A_toclust.fd">toclust.fd</code></td>
<td>
<p>A functional data object (i.e., having class <code>fd</code>) created
from <code>fda</code> package. See <code><a href="fda.html#topic+fd">fda::fd()</a></code>.</p>
</td></tr>
<tr><td><code id="splitter_+3A_split_row">split_row</code></td>
<td>
<p>The row index in frame that would be split on.</p>
</td></tr>
<tr><td><code id="splitter_+3A_frame">frame</code></td>
<td>
<p>The split tree transferred as data frame.</p>
</td></tr>
<tr><td><code id="splitter_+3A_cloc">cloc</code></td>
<td>
<p>Vector of current cluster membership.</p>
</td></tr>
<tr><td><code id="splitter_+3A_dist">dist</code></td>
<td>
<p>Distance matrix of all observations in the data.</p>
</td></tr>
<tr><td><code id="splitter_+3A_dsubs">dsubs</code></td>
<td>
<p>Distance matrix calculated on each subregion. A
three-dimensional matrix.</p>
</td></tr>
<tr><td><code id="splitter_+3A_dsubsname">dsubsname</code></td>
<td>
<p>Subregion names.</p>
</td></tr>
<tr><td><code id="splitter_+3A_weights">weights</code></td>
<td>
<p>(Currently unused) Weights on observations.</p>
</td></tr>
<tr><td><code id="splitter_+3A_method">method</code></td>
<td>
<p>The clustering method you want to run in each subregion. Can be
chosen between <code>pam</code> and <code>ward</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>frame</code> and <code>cloc</code> saved in a list.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
