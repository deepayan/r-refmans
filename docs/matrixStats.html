<!DOCTYPE html><html><head><title>Help for package matrixStats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matrixStats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allocMatrix'><p>Allocates an empty vector, matrix or array</p></a></li>
<li><a href='#anyMissing'><p>Checks if there are any missing values in an object or not</p></a></li>
<li><a href='#binCounts'><p>Fast element counting in non-overlapping bins</p></a></li>
<li><a href='#binMeans'><p>Fast mean calculations in non-overlapping bins</p></a></li>
<li><a href='#diff2'><p>Fast lagged differences</p></a></li>
<li><a href='#indexByRow'><p>Translates matrix indices by rows into indices by columns</p></a></li>
<li><a href='#logSumExp'><p>Accurately computes the logarithm of the sum of exponentials</p></a></li>
<li><a href='#matrixStats-package'><p>Package matrixStats</p></a></li>
<li><a href='#mean2'><p>Fast averaging over subset of vector elements</p></a></li>
<li><a href='#product'><p>Calculates the product for each row (column) in a matrix</p></a></li>
<li><a href='#rowAlls'><p>Checks if a value exists / does not exist in each row (column) of a matrix</p></a></li>
<li><a href='#rowAvgsPerColSet'><p>Applies a row-by-row (column-by-column) averaging function to equally-sized</p>
subsets of matrix columns (rows)</a></li>
<li><a href='#rowCollapse'><p>Extracts one cell per row (column) from a matrix</p></a></li>
<li><a href='#rowCounts'><p>Counts the number of occurrences of a specific value</p></a></li>
<li><a href='#rowCumsums'><p>Cumulative sums, products, minima and maxima for each row (column) in a</p>
matrix</a></li>
<li><a href='#rowDiffs'><p>Calculates difference for each row (column) in a matrix</p></a></li>
<li><a href='#rowIQRs'><p>Estimates of the interquartile range for each row (column) in a matrix</p></a></li>
<li><a href='#rowLogSumExps'><p>Accurately computes the logarithm of the sum of exponentials across rows or</p>
columns</a></li>
<li><a href='#rowMads'><p>Standard deviation estimates for each row (column) in a matrix</p></a></li>
<li><a href='#rowMeans2'><p>Calculates the mean for each row (column) in a matrix</p></a></li>
<li><a href='#rowMedians'><p>Calculates the median for each row (column) in a matrix</p></a></li>
<li><a href='#rowOrderStats'><p>Gets an order statistic for each row (column) in a matrix</p></a></li>
<li><a href='#rowQuantiles'><p>Estimates quantiles for each row (column) in a matrix</p></a></li>
<li><a href='#rowRanges'><p>Gets the range of values in each row (column) of a matrix</p></a></li>
<li><a href='#rowRanks'><p>Gets the rank of the elements in each row (column) of a matrix</p></a></li>
<li><a href='#rowSums2'><p>Calculates the sum for each row (column) in a matrix</p></a></li>
<li><a href='#rowTabulates'><p>Tabulates the values in a matrix by row (column).</p></a></li>
<li><a href='#rowVars'><p>Variance estimates for each row (column) in a matrix</p></a></li>
<li><a href='#rowWeightedMeans'><p>Calculates the weighted means for each row (column) in a matrix</p></a></li>
<li><a href='#rowWeightedMedians'><p>Calculates the weighted medians for each row (column) in a matrix</p></a></li>
<li><a href='#signTabulate'><p>Calculates the number of negative, zero, positive and missing values</p></a></li>
<li><a href='#sum2'><p>Fast sum over subset of vector elements</p></a></li>
<li><a href='#validateIndices'><p>Validate indices</p></a></li>
<li><a href='#varDiff'><p>Estimation of scale based on sequential-order differences</p></a></li>
<li><a href='#weightedMad'><p>Weighted Median Absolute Deviation (MAD)</p></a></li>
<li><a href='#weightedMean'><p>Weighted Arithmetic Mean</p></a></li>
<li><a href='#weightedMedian'><p>Weighted Median Value</p></a></li>
<li><a href='#weightedVar'><p>Weighted variance and weighted standard deviation</p></a></li>
<li><a href='#x_OP_y'><p>Fast calculation of 'z &lt;- x OP y' and 'z &lt;- t(t(x) OP y)'</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.12.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>base64enc, ggplot2, knitr, markdown, microbenchmark,
R.devices, R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions that Apply to Rows and Columns of Matrices (and to
Vectors)</td>
</tr>
<tr>
<td>Author:</td>
<td>Henrik Bengtsson [aut, cre, cph],
  Constantin Ahlmann-Eltze [ctb],
  Hector Corrada Bravo [ctb],
  Robert Gentleman [ctb],
  Jan Gleixner [ctb],
  Peter Hickey [ctb],
  Ola Hossjer [ctb],
  Harris Jaffee [ctb],
  Dongcan Jiang [ctb],
  Peter Langfelder [ctb],
  Brian Montgomery [ctb],
  Angelina Panagopoulou [ctb],
  Hugh Parsonage [ctb],
  Jakob Peder Pettersen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henrik Bengtsson &lt;henrikb@braju.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>High-performing functions operating on rows and columns of matrices, e.g. col / rowMedians(), col / rowRanks(), and col / rowSds().  Functions optimized per data type and for subsetted calculations such that both memory usage and processing time is minimized.  There are also optimized vector-based methods, e.g. binMeans(), madDiff() and weightedMedian().</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/HenrikBengtsson/matrixStats">https://github.com/HenrikBengtsson/matrixStats</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/HenrikBengtsson/matrixStats/issues">https://github.com/HenrikBengtsson/matrixStats/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-11 19:55:37 UTC; henrik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-11 22:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='allocMatrix'>Allocates an empty vector, matrix or array</h2><span id='topic+allocMatrix'></span><span id='topic+allocVector'></span><span id='topic+allocArray'></span>

<h3>Description</h3>

<p>Allocates an empty vector, matrix or array faster than the corresponding
function in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocMatrix(nrow, ncol, value = 0, ...)

allocVector(length, value = 0, ...)

allocArray(dim, value = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allocMatrix_+3A_value">value</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> scalar that all elements will
have as value.</p>
</td></tr>
<tr><td><code id="allocMatrix_+3A_length">length</code>, <code id="allocMatrix_+3A_nrow">nrow</code>, <code id="allocMatrix_+3A_ncol">ncol</code>, <code id="allocMatrix_+3A_dim">dim</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code>s specifying the
dimension of the created <code><a href="base.html#topic+vector">vector</a></code>,
<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+array">array</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+vector">vector</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code> and
<code><a href="base.html#topic+array">array</a></code> respectively of the same data type as
<code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>See also <code><a href="base.html#topic+vector">vector</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code> and
<code><a href="base.html#topic+array">array</a></code>.
</p>

<hr>
<h2 id='anyMissing'>Checks if there are any missing values in an object or not</h2><span id='topic+anyMissing'></span><span id='topic+colAnyMissings'></span><span id='topic+rowAnyMissings'></span><span id='topic+colAnyNAs'></span><span id='topic+rowAnyNAs'></span>

<h3>Description</h3>

<p>Checks if there are any missing values in an object or not.
<em>Please use <code>base::anyNA()</code> instead of <code>anyMissing()</code>,
<code>colAnyNAs()</code> instead of <code>colAnyMissings()</code>, and
<code>rowAnyNAs()</code> instead of <code>rowAnyMissings()</code>.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anyMissing(x, idxs = NULL, ...)

colAnyMissings(x, rows = NULL, cols = NULL, ..., useNames = TRUE)

rowAnyMissings(x, rows = NULL, cols = NULL, ..., useNames = TRUE)

colAnyNAs(x, rows = NULL, cols = NULL, ..., useNames = TRUE)

rowAnyNAs(x, rows = NULL, cols = NULL, ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anyMissing_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code>, a <code><a href="base.html#topic+list">list</a></code>, a
<code><a href="base.html#topic+matrix">matrix</a></code>, a <code><a href="base.html#topic+data.frame">data.frame</a></code>, or
<code><a href="base.html#topic+NULL">NULL</a></code>.</p>
</td></tr>
<tr><td><code id="anyMissing_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="anyMissing_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="anyMissing_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="anyMissing_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="anyMissing_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation of this method is optimized for both speed and memory.
The method will return <code><a href="base.html#topic+logical">TRUE</a></code> as soon as a missing
value is detected.
</p>


<h3>Value</h3>

<p>Returns <code><a href="base.html#topic+logical">TRUE</a></code> if a missing value was
detected, otherwise <code><a href="base.html#topic+logical">FALSE</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>Starting with R v3.1.0, there is <code>anyNA()</code> in the <span class="pkg">base</span>,
which provides the same functionality as <code>anyMissing()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- rnorm(n = 1000)
 x[seq(300, length(x), by = 100)] &lt;- NA
 stopifnot(anyMissing(x) == any(is.na(x)))

</code></pre>

<hr>
<h2 id='binCounts'>Fast element counting in non-overlapping bins</h2><span id='topic+binCounts'></span>

<h3>Description</h3>

<p>Counts the number of elements in non-overlapping bins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binCounts(x, idxs = NULL, bx, right = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binCounts_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of K
positions for to be binned and counted.</p>
</td></tr>
<tr><td><code id="binCounts_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="binCounts_+3A_bx">bx</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of B + 1
ordered positions specifying the B &gt; 0 bins <code>[bx[1], bx[2])</code>,
<code>[bx[2], bx[3])</code>, ..., <code>[bx[B], bx[B + 1])</code>.</p>
</td></tr>
<tr><td><code id="binCounts_+3A_right">right</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, the bins are right-closed
(left open), otherwise left-closed (right open).</p>
</td></tr>
<tr><td><code id="binCounts_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>binCounts(x, bx, right = TRUE)</code> gives equivalent results as
<code>rev(binCounts(-x, bx = rev(-bx), right = FALSE))</code>, but is faster
and more memory efficient.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length B with non-negative integers.
</p>


<h3>Missing and non-finite values</h3>

<p>Missing values in <code>x</code> are ignored/dropped.  Missing values in <code>bx</code>
are not allowed and gives an error.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>An alternative for counting occurrences within bins is
<code><a href="graphics.html#topic+hist">hist</a></code>, e.g. <code>hist(x, breaks = bx,
plot = FALSE)$counts</code>.  That approach is ~30-60% slower than
<code>binCounts(..., right = TRUE)</code>.
</p>
<p>To count occurrences of indices <code>x</code> (positive
<code><a href="base.html#topic+integer">integer</a></code>s) in <code>[1, B]</code>, use <code>tabulate(x,
nbins = B)</code>, where <code>x</code> does <em>not</em> have to be sorted first.  For
details, see <code><a href="base.html#topic+tabulate">tabulate</a></code>().
</p>
<p>To average values within bins, see <code><a href="#topic+binMeans">binMeans</a></code>().
</p>

<hr>
<h2 id='binMeans'>Fast mean calculations in non-overlapping bins</h2><span id='topic+binMeans'></span>

<h3>Description</h3>

<p>Computes the sample means in non-overlapping bins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binMeans(y, x, idxs = NULL, bx, na.rm = TRUE, count = TRUE,
  right = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binMeans_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+logical">logical</a></code>
<code><a href="base.html#topic+vector">vector</a></code> of K values to calculate means on.</p>
</td></tr>
<tr><td><code id="binMeans_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of K
positions for to be binned.</p>
</td></tr>
<tr><td><code id="binMeans_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="binMeans_+3A_bx">bx</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of B + 1
ordered positions specifying the B &gt; 0 bins <code>[bx[1], bx[2])</code>,
<code>[bx[2], bx[3])</code>, ..., <code>[bx[B], bx[B + 1])</code>.</p>
</td></tr>
<tr><td><code id="binMeans_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values in <code>y</code>
are dropped before calculating the mean, otherwise not.</p>
</td></tr>
<tr><td><code id="binMeans_+3A_count">count</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, the number of data points
in each bins is returned as attribute <code>count</code>, which is an
<code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length B.</p>
</td></tr>
<tr><td><code id="binMeans_+3A_right">right</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, the bins are right-closed
(left open), otherwise left-closed (right open).</p>
</td></tr>
<tr><td><code id="binMeans_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>binMeans(x, bx, right = TRUE)</code> gives equivalent results as
<code>rev(binMeans(-x, bx = sort(-bx), right = FALSE))</code>, but is faster.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length B.
</p>


<h3>Missing and non-finite values</h3>

<p>Data points where either of <code>y</code> and <code>x</code> is missing are dropped
(and therefore are also not counted).   Non-finite values in <code>y</code> are
not allowed and gives an error.  Missing values in <code>bx</code> are not allowed
and gives an error.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson with initial code contributions by
Martin Morgan [1].
</p>


<h3>References</h3>

<p>[1] R-devel thread <em>Fastest non-overlapping binning mean
function out there?</em> on Oct 3, 2012<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binCounts">binCounts</a></code>().  <code><a href="stats.html#topic+aggregate">aggregate</a></code> and
<code><a href="base.html#topic+mean">mean</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:200
mu &lt;- double(length(x))
mu[1:50] &lt;- 5
mu[101:150] &lt;- -5
y &lt;- mu + rnorm(length(x))

# Binning
bx &lt;- c(0, 50, 100, 150, 200) + 0.5
y_s &lt;- binMeans(y, x = x, bx = bx)

plot(x, y)
for (kk in seq_along(y_s)) {
  lines(bx[c(kk, kk + 1)], y_s[c(kk, kk)], col = "blue", lwd = 2)
}
</code></pre>

<hr>
<h2 id='diff2'>Fast lagged differences</h2><span id='topic+diff2'></span>

<h3>Description</h3>

<p>Computes the lagged and iterated differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff2(x, idxs = NULL, lag = 1L, differences = 1L, ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff2_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length
N.</p>
</td></tr>
<tr><td><code id="diff2_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="diff2_+3A_lag">lag</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the lag.</p>
</td></tr>
<tr><td><code id="diff2_+3A_differences">differences</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the order of
difference.</p>
</td></tr>
<tr><td><code id="diff2_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="diff2_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+NA">NA</a></code>, the default behavior of the 
function about naming support is remained. If <code><a href="base.html#topic+logical">FALSE</a></code>, 
no naming support is done. Else if <code><a href="base.html#topic+logical">TRUE</a></code>, names 
attributes of result are set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length N - <code>differences</code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diff">diff</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diff2(1:10)

</code></pre>

<hr>
<h2 id='indexByRow'>Translates matrix indices by rows into indices by columns</h2><span id='topic+indexByRow'></span>

<h3>Description</h3>

<p>Translates matrix indices by rows into indices by columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexByRow(dim, idxs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indexByRow_+3A_dim">dim</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the length of the &quot;template&quot; matrix.</p>
</td></tr>
<tr><td><code id="indexByRow_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="indexByRow_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
indices.
</p>


<h3>Known limitations</h3>

<p>The current implementation does not support long-vector indices,
because both input and output indices are of type integers.
This means that the indices in argument <code>idxs</code> can only be in
range [1,2^31-1]. Using a greater value will be coerced to
<code>NA_integer_</code>.  Moreover, returned indices can only be in the
same range [1,2^31-1].
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dim &lt;- c(5, 4)
X &lt;- matrix(NA_integer_, nrow = dim[1], ncol = dim[2])
Y &lt;- t(X)
idxs &lt;- seq_along(X)

# Assign by columns
X[idxs] &lt;- idxs
print(X)

# Assign by rows
Y[indexByRow(dim(Y), idxs)] &lt;- idxs
print(Y)

stopifnot(X == t(Y))
</code></pre>

<hr>
<h2 id='logSumExp'>Accurately computes the logarithm of the sum of exponentials</h2><span id='topic+logSumExp'></span>

<h3>Description</h3>

<p>Accurately computes the logarithm of the sum of exponentials, that is,
<code class="reqn">log(sum(exp(lx)))</code>.  If <code class="reqn">lx = log(x)</code>, then this is equivalently to
calculating <code class="reqn">log(sum(x))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logSumExp(lx, idxs = NULL, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logSumExp_+3A_lx">lx</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code>.
Typically <code>lx</code> are <code class="reqn">log(x)</code> values.</p>
</td></tr>
<tr><td><code id="logSumExp_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="logSumExp_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="logSumExp_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, which avoid numerical underflow, is often used when computing
the logarithm of the sum of small numbers (<code class="reqn">|x| &lt;&lt; 1</code>) such as
probabilities.
</p>
<p>This is function is more accurate than <code>log(sum(exp(lx)))</code> when the
values of <code class="reqn">x = exp(lx)</code> are <code class="reqn">|x| &lt;&lt; 1</code>.  The implementation of this
function is based on the observation that </p>
<p style="text-align: center;"><code class="reqn"> log(a + b) = [ la = log(a),
lb = log(b) ] = log( exp(la) + exp(lb) ) = la + log ( 1 + exp(lb - la) ) </code>
</p>

<p>Assuming <code class="reqn">la &gt; lb</code>, then <code class="reqn">|lb - la| &lt; |lb|</code>, and it is less likely
that the computation of <code class="reqn">1 + exp(lb - la)</code> will not underflow/overflow
numerically.  Because of this, the overall result from this function should
be more accurate.  Analogously to this, the implementation of this function
finds the maximum value of <code>lx</code> and subtracts it from the remaining
values in <code>lx</code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> scalar.
</p>


<h3>Benchmarking</h3>

<p>This method is optimized for correctness, that
avoiding underflowing.  It is implemented in native code that is optimized
for speed and memory.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>References</h3>

<p>[1] R Core Team, <em>Writing R Extensions</em>, v3.0.0, April 2013. <br />
[2] Laurent El Ghaoui, <em>Hyper-Textbook: Optimization Models
and Applications</em>, University of California at Berkeley, August 2012.
(Chapter 'Log-Sum-Exp (LSE) Function and Properties') <br />
[3] R-help thread <em>logsumexp function in R</em>, 2011-02-17.
<a href="https://stat.ethz.ch/pipermail/r-help/2011-February/269205.html">https://stat.ethz.ch/pipermail/r-help/2011-February/269205.html</a><br />
</p>


<h3>See Also</h3>

<p>To compute this function on rows or columns of a matrix, see
<code><a href="#topic+rowLogSumExps">rowLogSumExps</a></code>().
</p>
<p>For adding <em>two</em> double values in native code, R provides the C
function <code>logspace_add()</code> [1].  For properties of the
log-sum-exponential function, see [2].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## EXAMPLE #1
lx &lt;- c(1000.01, 1000.02)
y0 &lt;- log(sum(exp(lx)))
print(y0) ## Inf

y1 &lt;- logSumExp(lx)
print(y1) ## 1000.708


## EXAMPLE #2
lx &lt;- c(-1000.01, -1000.02)
y0 &lt;- log(sum(exp(lx)))
print(y0) ## -Inf

y1 &lt;- logSumExp(lx)
print(y1) ## -999.3218


## EXAMPLE #3
## R-help thread 'Beyond double-precision?' on May 9, 2009.

set.seed(1)
x &lt;- runif(50)

## The logarithm of the harmonic mean
y0 &lt;- log(1 / mean(1 / x))
print(y0)  ## -1.600885

lx &lt;- log(x)
y1 &lt;- log(length(x)) - logSumExp(-lx)
print(y1)  ## [1] -1.600885

# Sanity check
stopifnot(all.equal(y1, y0))
</code></pre>

<hr>
<h2 id='matrixStats-package'>Package matrixStats</h2><span id='topic+matrixStats-package'></span><span id='topic+matrixStats'></span>

<h3>Description</h3>

<p>High-performing functions operating on rows and columns of matrices, e.g.
col / rowMedians(), col / rowRanks(), and col / rowSds().  Functions
optimized per data type and for subsetted calculations such that both memory
usage and processing time is minimized.  There are also optimized
vector-based methods, e.g. binMeans(), madDiff() and weightedMedian().
</p>


<h3>How to cite this package</h3>

<p>Henrik Bengtsson (2017). matrixStats: Functions that Apply to Rows and
Columns of Matrices (and to Vectors). R package version 0.52.2.
https://github.com/HenrikBengtsson/matrixStats
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson, Hector Corrada Bravo, Robert Gentleman, Ola
Hossjer, Harris Jaffee, Dongcan Jiang, Peter Langfelder
</p>

<hr>
<h2 id='mean2'>Fast averaging over subset of vector elements</h2><span id='topic+mean2'></span>

<h3>Description</h3>

<p>Computes the sample mean of all or a subset of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean2(x, idxs = NULL, na.rm = FALSE, refine = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean2_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="mean2_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="mean2_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="mean2_+3A_refine">refine</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> and <code>x</code> is
<code><a href="base.html#topic+numeric">numeric</a></code>, then extra effort is used to calculate the
average with greater numerical precision, otherwise not.</p>
</td></tr>
<tr><td><code id="mean2_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mean2(x, idxs)</code> gives equivalent results as <code>mean(x[idxs])</code>,
but is faster and more memory efficient since it avoids the actual
subsetting which requires copying of elements and garbage collection
thereof.
</p>
<p>If <code>x</code> is <code><a href="base.html#topic+numeric">numeric</a></code> and <code>refine = TRUE</code>, then a
two-pass scan is used to calculate the average.  The first scan calculates
the total sum and divides by the number of (non-missing) values.  In the
second scan, this average is refined by adding the residuals towards the
first average.  The <code><a href="base.html#topic+mean">mean</a></code>() uses this approach.
<code>mean2(..., refine = FALSE)</code> is almost twice as fast as
<code>mean2(..., refine = TRUE)</code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> scalar.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code>().
To efficiently sum over a subset, see <code><a href="#topic+sum2">sum2</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
n &lt;- length(x)

idxs &lt;- seq(from = 1, to = n, by = 2)
s1 &lt;- mean(x[idxs])                     # 25
s2 &lt;- mean2(x, idxs = idxs)             # 25
stopifnot(identical(s1, s2))

idxs &lt;- seq(from = n, to = 1, by = -2)
s1 &lt;- mean(x[idxs])                     # 25
s2 &lt;- mean2(x, idxs = idxs)             # 25
stopifnot(identical(s1, s2))

s1 &lt;- mean(x)                           # 55
s2 &lt;- mean2(x)                          # 55
stopifnot(identical(s1, s2))
</code></pre>

<hr>
<h2 id='product'>Calculates the product for each row (column) in a matrix</h2><span id='topic+product'></span><span id='topic+rowProds'></span><span id='topic+colProds'></span>

<h3>Description</h3>

<p>Calculates the product for each row (column) in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>product(x, idxs = NULL, na.rm = FALSE, ...)

rowProds(x, rows = NULL, cols = NULL, na.rm = FALSE,
  method = c("direct", "expSumLog"), ..., useNames = TRUE)

colProds(x, rows = NULL, cols = NULL, na.rm = FALSE,
  method = c("direct", "expSumLog"), ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="product_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="product_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="product_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="product_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="product_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="product_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="product_+3A_method">method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying how each
product is calculated.</p>
</td></tr>
<tr><td><code id="product_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method = "expSumLog"</code>, then then <code><a href="#topic+product">product</a></code>() function is
used, which calculates the product via the logarithmic transform (treating
negative values specially).  This improves the precision and lowers the risk
for numeric overflow.  If <code>method = "direct"</code>, the direct product is
calculated via the <code><a href="base.html#topic+prod">prod</a></code>() function.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length N (K).
</p>


<h3>Missing values</h3>

<p>Note, if <code>method = "expSumLog"</code>, <code>na.rm = FALSE</code>, and <code>x</code>
contains missing values (<code><a href="base.html#topic+NA">NA</a></code> or
<code><a href="base.html#topic+is.finite">NaN</a></code>), then the calculated value is also
missing value.  Note that it depends on platform whether
<code><a href="base.html#topic+is.finite">NaN</a></code> or <code><a href="base.html#topic+NA">NA</a></code> is returned
when an <code><a href="base.html#topic+is.finite">NaN</a></code> exists, cf.
<code><a href="base.html#topic+is.nan">is.nan</a></code>().
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>

<hr>
<h2 id='rowAlls'>Checks if a value exists / does not exist in each row (column) of a matrix</h2><span id='topic+rowAlls'></span><span id='topic+colAlls'></span><span id='topic+allValue'></span><span id='topic+rowAnys'></span><span id='topic+colAnys'></span><span id='topic+anyValue'></span>

<h3>Description</h3>

<p>Checks if a value exists / does not exist in each row (column) of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowAlls(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE,
  dim. = dim(x), ..., useNames = TRUE)

colAlls(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE,
  dim. = dim(x), ..., useNames = TRUE)

allValue(x, idxs = NULL, value = TRUE, na.rm = FALSE, ...)

rowAnys(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE,
  dim. = dim(x), ..., useNames = TRUE)

colAnys(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE,
  dim. = dim(x), ..., useNames = TRUE)

anyValue(x, idxs = NULL, value = TRUE, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowAlls_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowAlls_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowAlls_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowAlls_+3A_value">value</code></td>
<td>
<p>A value to search for.</p>
</td></tr>
<tr><td><code id="rowAlls_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="rowAlls_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.  <em>Comment:</em> The reason for this argument
being named with a period at the end is purely technical (we get a run-time
error if we try to name it <code>dim</code>).</p>
</td></tr>
<tr><td><code id="rowAlls_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowAlls_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
<tr><td><code id="rowAlls_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions takes either a matrix or a vector as input. If a vector,
then argument <code>dim.</code> must be specified and fulfill <code>prod(dim.) ==
length(x)</code>.  The result will be identical to the results obtained when
passing <code>matrix(x, nrow = dim.[1L], ncol = dim.[2L])</code>, but avoids
having to temporarily create/allocate a matrix, if only such is needed
only for these calculations.
</p>


<h3>Value</h3>

<p><code>rowAlls()</code> (<code>colAlls()</code>) returns an
<code><a href="base.html#topic+logical">logical</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length N (K).
Analogously for <code>rowAnys()</code> (<code>rowAlls()</code>).
</p>


<h3>Logical <code>value</code></h3>

<p>When <code>value</code> is logical, the result is as if the function is applied
on <code>as.logical(x)</code>.  More specifically, if <code>x</code> is numeric, then
all zeros are treated as <code>FALSE</code>, non-zero values as <code>TRUE</code>,
and all missing values as <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>rowCounts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(FALSE, nrow = 10, ncol = 5)
x[3:7, c(2, 4)] &lt;- TRUE
x[2:4, ] &lt;- TRUE
x[, 1] &lt;- TRUE
x[5, ] &lt;- FALSE
x[, 5] &lt;- FALSE
print(x)

print(rowCounts(x))       # 1 4 4 4 0 3 3 1 1 1
print(colCounts(x))       # 9 5 3 5 0

print(rowAnys(x))
print(which(rowAnys(x)))  # 1  2  3  4  6  7  8  9 10
print(colAnys(x))
print(which(colAnys(x)))  # 1 2 3 4
</code></pre>

<hr>
<h2 id='rowAvgsPerColSet'>Applies a row-by-row (column-by-column) averaging function to equally-sized
subsets of matrix columns (rows)</h2><span id='topic+rowAvgsPerColSet'></span><span id='topic+colAvgsPerRowSet'></span>

<h3>Description</h3>

<p>Applies a row-by-row (column-by-column) averaging function to equally-sized
subsets of matrix columns (rows).  Each subset is averaged independently of
the others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowAvgsPerColSet(X, W = NULL, rows = NULL, S, FUN = rowMeans, ...,
  na.rm = NA, tFUN = FALSE)

colAvgsPerRowSet(X, W = NULL, cols = NULL, S, FUN = colMeans, ...,
  na.rm = NA, tFUN = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowAvgsPerColSet_+3A_x">X</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> NxM <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="rowAvgsPerColSet_+3A_w">W</code></td>
<td>
<p>An optional <code><a href="base.html#topic+numeric">numeric</a></code> NxM
<code><a href="base.html#topic+matrix">matrix</a></code> of weights.</p>
</td></tr>
<tr><td><code id="rowAvgsPerColSet_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowAvgsPerColSet_+3A_s">S</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> KxJ <code><a href="base.html#topic+matrix">matrix</a></code>
specifying the J subsets.  Each column holds K column (row) indices for the
corresponding subset.</p>
</td></tr>
<tr><td><code id="rowAvgsPerColSet_+3A_fun">FUN</code></td>
<td>
<p>The row-by-row (column-by-column) <code><a href="base.html#topic+function">function</a></code>
used to average over each subset of <code>X</code>.  This function must accept a
<code><a href="base.html#topic+numeric">numeric</a></code> NxK (KxM) <code><a href="base.html#topic+matrix">matrix</a></code> and the
<code><a href="base.html#topic+logical">logical</a></code> argument <code>na.rm</code>, and return a
<code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length N (M).</p>
</td></tr>
<tr><td><code id="rowAvgsPerColSet_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to then <code>FUN</code>
<code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
<tr><td><code id="rowAvgsPerColSet_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) Argument passed to <code>FUN()</code> as
<code>na.rm = na.rm</code>.  If <code><a href="base.html#topic+logical">NA</a></code> (default), then
<code>na.rm = TRUE</code> is used if <code>X</code> or <code>S</code> holds missing values,
otherwise <code>na.rm = FALSE</code>.</p>
</td></tr>
<tr><td><code id="rowAvgsPerColSet_+3A_tfun">tFUN</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, the NxK (KxM)
<code><a href="base.html#topic+matrix">matrix</a></code> passed to <code>FUN()</code> is transposed first.</p>
</td></tr>
<tr><td><code id="rowAvgsPerColSet_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If argument <code>S</code> is a single column vector with indices <code>1:N</code>, then
<code>rowAvgsPerColSet(X, S = S, FUN = rowMeans)</code> gives the same result as
<code>rowMeans(X)</code>.  Analogously, for <code>colAvgsPerRowSet()</code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> JxN (MxJ)
<code><a href="base.html#topic+matrix">matrix</a></code>, where row names equal <code>rownames(X)</code>
(<code>colnames(S)</code>) and column names <code>colnames(S)</code>
(<code>colnames(X)</code>).
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(20 * 6), nrow = 20, ncol = 6)
rownames(X) &lt;- LETTERS[1:nrow(X)]
colnames(X) &lt;- letters[1:ncol(X)]
print(X)


# - - - - - - - - - - - - - - - - - - - - - - - - - -
# Apply rowMeans() for 3 sets of 2 columns
# - - - - - - - - - - - - - - - - - - - - - - - - - -
nbr_of_sets &lt;- 3
S &lt;- matrix(1:ncol(X), ncol = nbr_of_sets)
colnames(S) &lt;- sprintf("s%d", 1:nbr_of_sets)
print(S)

Z &lt;- rowAvgsPerColSet(X, S = S)
print(Z)

# Validation
Z0 &lt;- cbind(s1 = rowMeans(X[, 1:2]),
            s2 = rowMeans(X[, 3:4]),
            s3 = rowMeans(X[, 5:6]))
stopifnot(identical(drop(Z), Z0))


# - - - - - - - - - - - - - - - - - - - - - - - - - -
# Apply colMeans() for 5 sets of 4 rows
# - - - - - - - - - - - - - - - - - - - - - - - - - -
nbr_of_sets &lt;- 5
S &lt;- matrix(1:nrow(X), ncol = nbr_of_sets)
colnames(S) &lt;- sprintf("s%d", 1:nbr_of_sets)
print(S)

Z &lt;- colAvgsPerRowSet(X, S = S)
print(Z)

# Validation
Z0 &lt;- rbind(s1 = colMeans(X[  1:4, ]),
            s2 = colMeans(X[  5:8, ]),
            s3 = colMeans(X[ 9:12, ]),
            s4 = colMeans(X[13:16, ]),
            s5 = colMeans(X[17:20, ]))
stopifnot(identical(drop(Z), Z0))


# - - - - - - - - - - - - - - - - - - - - - - - - - -
# When there is only one "complete" set
# - - - - - - - - - - - - - - - - - - - - - - - - - -
nbr_of_sets &lt;- 1
S &lt;- matrix(1:ncol(X), ncol = nbr_of_sets)
colnames(S) &lt;- sprintf("s%d", 1:nbr_of_sets)
print(S)

Z &lt;- rowAvgsPerColSet(X, S = S, FUN = rowMeans)
print(Z)

Z0 &lt;- rowMeans(X)
stopifnot(identical(drop(Z), Z0))


nbr_of_sets &lt;- 1
S &lt;- matrix(1:nrow(X), ncol = nbr_of_sets)
colnames(S) &lt;- sprintf("s%d", 1:nbr_of_sets)
print(S)

Z &lt;- colAvgsPerRowSet(X, S = S, FUN = colMeans)
print(Z)

Z0 &lt;- colMeans(X)
stopifnot(identical(drop(Z), Z0))
</code></pre>

<hr>
<h2 id='rowCollapse'>Extracts one cell per row (column) from a matrix</h2><span id='topic+rowCollapse'></span><span id='topic+colCollapse'></span>

<h3>Description</h3>

<p>Extracts one cell per row (column) from a matrix.  The implementation is
optimized for memory and speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowCollapse(x, idxs, rows = NULL, dim. = dim(x), ..., useNames = TRUE)

colCollapse(x, idxs, cols = NULL, dim. = dim(x), ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowCollapse_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowCollapse_+3A_idxs">idxs</code></td>
<td>
<p>An index <code><a href="base.html#topic+vector">vector</a></code> of (maximum) length N (K)
specifying the columns (rows) to be extracted.</p>
</td></tr>
<tr><td><code id="rowCollapse_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowCollapse_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.  <em>Comment:</em> The reason for this argument
being named with a period at the end is purely technical (we get a run-time
error if we try to name it <code>dim</code>).</p>
</td></tr>
<tr><td><code id="rowCollapse_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowCollapse_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
<tr><td><code id="rowCollapse_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+vector">vector</a></code> of length N (K).
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p><em>Matrix indexing</em> to index elements in matrices and arrays,
cf. <code><a href="base.html#topic++5B">[</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:27, ncol = 3)

y &lt;- rowCollapse(x, 1)
stopifnot(identical(y, x[, 1]))

y &lt;- rowCollapse(x, 2)
stopifnot(identical(y, x[, 2]))

y &lt;- rowCollapse(x, c(1, 1, 1, 1, 1, 3, 3, 3, 3))
stopifnot(identical(y, c(x[1:5, 1], x[6:9, 3])))

y &lt;- rowCollapse(x, 1:3)
print(y)
y_truth &lt;- c(x[1, 1], x[2, 2], x[3, 3], x[4, 1], x[5, 2],
             x[6, 3], x[7, 1], x[8, 2], x[9, 3])
stopifnot(identical(y, y_truth))
</code></pre>

<hr>
<h2 id='rowCounts'>Counts the number of occurrences of a specific value</h2><span id='topic+rowCounts'></span><span id='topic+colCounts'></span><span id='topic+count'></span>

<h3>Description</h3>

<p>The row- and column-wise functions take either a matrix or a vector as
input. If a vector, then argument <code>dim.</code> must be specified and fulfill
<code>prod(dim.) == length(x)</code>.  The result will be identical to the results
obtained when passing <code>matrix(x, nrow = dim.[1L], ncol = dim.[2L])</code>,
but avoids having to temporarily create/allocate a matrix, if only such is
needed only for these calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowCounts(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE,
  dim. = dim(x), ..., useNames = TRUE)

colCounts(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE,
  dim. = dim(x), ..., useNames = TRUE)

count(x, idxs = NULL, value = TRUE, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowCounts_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowCounts_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowCounts_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowCounts_+3A_value">value</code></td>
<td>
<p>A value to search for.</p>
</td></tr>
<tr><td><code id="rowCounts_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="rowCounts_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.  <em>Comment:</em> The reason for this argument
being named with a period at the end is purely technical (we get a run-time
error if we try to name it <code>dim</code>).</p>
</td></tr>
<tr><td><code id="rowCounts_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowCounts_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
<tr><td><code id="rowCounts_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rowCounts()</code> (<code>colCounts()</code>) returns an
<code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length N (K).
<code>count()</code> returns a scalar of type <code><a href="base.html#topic+integer">integer</a></code> if
the count is less than 2^31-1 (= <code>.Machine$integer.max</code>) otherwise
a scalar of type <code><a href="base.html#topic+double">double</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>rowAlls
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(0:11, nrow = 4, ncol = 3)
x[2:3, 2:3] &lt;- 2:5
x[3, 3] &lt;- NA_integer_
print(x)

print(rowCounts(x, value = 2))
## [1]  0  1 NA  0
print(colCounts(x, value = 2))
## [1]  1  1 NA
print(colCounts(x, value = NA_integer_))
## [1] 0 0 1

print(rowCounts(x, value = 2, na.rm = TRUE))
## [1] 0 1 1 0
print(colCounts(x, value = 2, na.rm = TRUE))
## [1] 1 1 0

print(rowAnys(x, value = 2))
## [1] FALSE  TRUE  TRUE FALSE
print(rowAnys(x, value = NA_integer_))
## [1] FALSE FALSE  TRUE FALSE

print(colAnys(x, value = 2))
## [1] TRUE TRUE   NA
print(colAnys(x, value = 2, na.rm = TRUE))
## [1]  TRUE  TRUE FALSE

print(colAlls(x, value = 2))
## [1] FALSE FALSE FALSE
</code></pre>

<hr>
<h2 id='rowCumsums'>Cumulative sums, products, minima and maxima for each row (column) in a
matrix</h2><span id='topic+rowCumsums'></span><span id='topic+colCumsums'></span><span id='topic+rowCumprods'></span><span id='topic+colCumprods'></span><span id='topic+rowCummins'></span><span id='topic+colCummins'></span><span id='topic+rowCummaxs'></span><span id='topic+colCummaxs'></span>

<h3>Description</h3>

<p>Cumulative sums, products, minima and maxima for each row (column) in a
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowCumsums(x, rows = NULL, cols = NULL, dim. = dim(x), ...,
  useNames = TRUE)

colCumsums(x, rows = NULL, cols = NULL, dim. = dim(x), ...,
  useNames = TRUE)

rowCumprods(x, rows = NULL, cols = NULL, dim. = dim(x), ...,
  useNames = TRUE)

colCumprods(x, rows = NULL, cols = NULL, dim. = dim(x), ...,
  useNames = TRUE)

rowCummins(x, rows = NULL, cols = NULL, dim. = dim(x), ...,
  useNames = TRUE)

colCummins(x, rows = NULL, cols = NULL, dim. = dim(x), ...,
  useNames = TRUE)

rowCummaxs(x, rows = NULL, cols = NULL, dim. = dim(x), ...,
  useNames = TRUE)

colCummaxs(x, rows = NULL, cols = NULL, dim. = dim(x), ...,
  useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowCumsums_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowCumsums_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowCumsums_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowCumsums_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.  <em>Comment:</em> The reason for this argument
being named with a period at the end is purely technical (we get a run-time
error if we try to name it <code>dim</code>).</p>
</td></tr>
<tr><td><code id="rowCumsums_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowCumsums_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> NxK <code><a href="base.html#topic+matrix">matrix</a></code>
of the same mode as <code>x</code>, except when <code>x</code> is of mode
<code><a href="base.html#topic+logical">logical</a></code>, then the return type is
<code><a href="base.html#topic+integer">integer</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+cumsum">cumsum</a></code>(), <code><a href="base.html#topic+cumprod">cumprod</a></code>(),
<code><a href="base.html#topic+cummin">cummin</a></code>(), and <code><a href="base.html#topic+cummax">cummax</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:12, nrow = 4, ncol = 3)
print(x)

yr &lt;- rowCumsums(x)
print(yr)

yc &lt;- colCumsums(x)
print(yc)

yr &lt;- rowCumprods(x)
print(yr)

yc &lt;- colCumprods(x)
print(yc)

yr &lt;- rowCummaxs(x)
print(yr)

yc &lt;- colCummaxs(x)
print(yc)

yr &lt;- rowCummins(x)
print(yr)

yc &lt;- colCummins(x)
print(yc)
</code></pre>

<hr>
<h2 id='rowDiffs'>Calculates difference for each row (column) in a matrix</h2><span id='topic+rowDiffs'></span><span id='topic+colDiffs'></span>

<h3>Description</h3>

<p>Calculates difference for each row (column) in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowDiffs(x, rows = NULL, cols = NULL, lag = 1L, differences = 1L,
  dim. = dim(x), ..., useNames = TRUE)

colDiffs(x, rows = NULL, cols = NULL, lag = 1L, differences = 1L,
  dim. = dim(x), ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowDiffs_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowDiffs_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowDiffs_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowDiffs_+3A_lag">lag</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the lag.</p>
</td></tr>
<tr><td><code id="rowDiffs_+3A_differences">differences</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the order of
difference.</p>
</td></tr>
<tr><td><code id="rowDiffs_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.  <em>Comment:</em> The reason for this argument
being named with a period at the end is purely technical (we get a run-time
error if we try to name it <code>dim</code>).</p>
</td></tr>
<tr><td><code id="rowDiffs_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowDiffs_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> Nx(K-1) or (N-1)xK
<code><a href="base.html#topic+matrix">matrix</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+diff2">diff2</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:27, ncol = 3)

d1 &lt;- rowDiffs(x)
print(d1)

d2 &lt;- t(colDiffs(t(x)))
stopifnot(all.equal(d2, d1))
</code></pre>

<hr>
<h2 id='rowIQRs'>Estimates of the interquartile range for each row (column) in a matrix</h2><span id='topic+rowIQRs'></span><span id='topic+colIQRs'></span><span id='topic+iqr'></span>

<h3>Description</h3>

<p>Estimates of the interquartile range for each row (column) in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowIQRs(x, rows = NULL, cols = NULL, na.rm = FALSE, ...,
  useNames = TRUE)

colIQRs(x, rows = NULL, cols = NULL, na.rm = FALSE, ...,
  useNames = TRUE)

iqr(x, idxs = NULL, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowIQRs_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowIQRs_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowIQRs_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowIQRs_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="rowIQRs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+rowQuantiles">rowQuantiles</a></code>()
(<code>colQuantiles()</code>).</p>
</td></tr>
<tr><td><code id="rowIQRs_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
<tr><td><code id="rowIQRs_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length N (K).
</p>


<h3>Missing values</h3>

<p>Contrary to <code><a href="stats.html#topic+IQR">IQR</a></code>, which gives
an error if there are missing values and <code>na.rm = FALSE</code>, <code>iqr()</code>
and its corresponding row and column-specific functions return
<code><a href="base.html#topic+NA">NA</a></code>_real_.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>See <code><a href="stats.html#topic+IQR">IQR</a></code>.  See <code><a href="#topic+rowSds">rowSds</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

x &lt;- matrix(rnorm(50 * 40), nrow = 50, ncol = 40)
str(x)

# Row IQRs
q &lt;- rowIQRs(x)
print(q)
q0 &lt;- apply(x, MARGIN = 1, FUN = IQR)
stopifnot(all.equal(q0, q))

# Column IQRs
q &lt;- colIQRs(x)
print(q)
q0 &lt;- apply(x, MARGIN = 2, FUN = IQR)
stopifnot(all.equal(q0, q))
</code></pre>

<hr>
<h2 id='rowLogSumExps'>Accurately computes the logarithm of the sum of exponentials across rows or
columns</h2><span id='topic+rowLogSumExps'></span><span id='topic+colLogSumExps'></span>

<h3>Description</h3>

<p>Accurately computes the logarithm of the sum of exponentials across rows or
columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowLogSumExps(lx, rows = NULL, cols = NULL, na.rm = FALSE,
  dim. = dim(lx), ..., useNames = TRUE)

colLogSumExps(lx, rows = NULL, cols = NULL, na.rm = FALSE,
  dim. = dim(lx), ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowLogSumExps_+3A_lx">lx</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> NxK <code><a href="base.html#topic+matrix">matrix</a></code>.
Typically <code>lx</code> are <code class="reqn">log(x)</code> values.</p>
</td></tr>
<tr><td><code id="rowLogSumExps_+3A_rows">rows</code>, <code id="rowLogSumExps_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows
(and/or columns) to operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting
is done.</p>
</td></tr>
<tr><td><code id="rowLogSumExps_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, any missing values are
ignored, otherwise not.</p>
</td></tr>
<tr><td><code id="rowLogSumExps_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="rowLogSumExps_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowLogSumExps_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length N
(K).
</p>


<h3>Benchmarking</h3>

<p>These methods are implemented in native code and have been optimized for
speed and memory.
</p>


<h3>Author(s)</h3>

<p>Native implementation by Henrik Bengtsson.  Original R code by
Nakayama ??? (Japan).
</p>


<h3>See Also</h3>

<p>To calculate the same on vectors, <code><a href="#topic+logSumExp">logSumExp</a></code>().
</p>

<hr>
<h2 id='rowMads'>Standard deviation estimates for each row (column) in a matrix</h2><span id='topic+rowMads'></span><span id='topic+colMads'></span><span id='topic+rowSds'></span><span id='topic+colSds'></span>

<h3>Description</h3>

<p>Standard deviation estimates for each row (column) in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowMads(x, rows = NULL, cols = NULL, center = NULL, constant = 1.4826,
  na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)

colMads(x, rows = NULL, cols = NULL, center = NULL, constant = 1.4826,
  na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)

rowSds(x, rows = NULL, cols = NULL, na.rm = FALSE, refine = TRUE,
  center = NULL, dim. = dim(x), ..., useNames = TRUE)

colSds(x, rows = NULL, cols = NULL, na.rm = FALSE, refine = TRUE,
  center = NULL, dim. = dim(x), ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowMads_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowMads_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowMads_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowMads_+3A_center">center</code></td>
<td>
<p>(optional) The center, defaults to the row means for the
SD estimators and row medians for the MAD estimators.</p>
</td></tr>
<tr><td><code id="rowMads_+3A_constant">constant</code></td>
<td>
<p>A scale factor.  See <code><a href="stats.html#topic+mad">mad</a></code> for details.</p>
</td></tr>
<tr><td><code id="rowMads_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="rowMads_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.  <em>Comment:</em> The reason for this argument
being named with a period at the end is purely technical (we get a run-time
error if we try to name it <code>dim</code>).</p>
</td></tr>
<tr><td><code id="rowMads_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>rowMeans()</code> and
<code>rowSums()</code>.</p>
</td></tr>
<tr><td><code id="rowMads_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
<tr><td><code id="rowMads_+3A_refine">refine</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, 'center' is NULL, and
<code>x</code> is <code><a href="base.html#topic+numeric">numeric</a></code>, then extra effort is used to
calculate the average with greater numerical precision, otherwise not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length N (K).
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="stats.html#topic+mad">mad</a></code> and
<code><a href="stats.html#topic+cor">var</a></code>.  <code><a href="#topic+rowIQRs">rowIQRs</a></code>().
</p>

<hr>
<h2 id='rowMeans2'>Calculates the mean for each row (column) in a matrix</h2><span id='topic+rowMeans2'></span><span id='topic+colMeans2'></span>

<h3>Description</h3>

<p>Calculates the mean for each row (column) in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowMeans2(x, rows = NULL, cols = NULL, na.rm = FALSE, refine = TRUE,
  dim. = dim(x), ..., useNames = TRUE)

colMeans2(x, rows = NULL, cols = NULL, na.rm = FALSE, refine = TRUE,
  dim. = dim(x), ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowMeans2_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowMeans2_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowMeans2_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowMeans2_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="rowMeans2_+3A_refine">refine</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> and
<code>x</code> is <code><a href="base.html#topic+numeric">numeric</a></code>, then extra effort is used to
calculate the average with greater numerical precision, otherwise not.</p>
</td></tr>
<tr><td><code id="rowMeans2_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.  <em>Comment:</em> The reason for this argument
being named with a period at the end is purely technical (we get a run-time
error if we try to name it <code>dim</code>).</p>
</td></tr>
<tr><td><code id="rowMeans2_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowMeans2_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation of <code>rowMeans2()</code> and <code>colMeans2()</code> is
optimized for both speed and memory.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length N (K).
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>

<hr>
<h2 id='rowMedians'>Calculates the median for each row (column) in a matrix</h2><span id='topic+rowMedians'></span><span id='topic+colMedians'></span>

<h3>Description</h3>

<p>Calculates the median for each row (column) in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowMedians(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x),
  ..., useNames = TRUE)

colMedians(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x),
  ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowMedians_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowMedians_+3A_rows">rows</code>, <code id="rowMedians_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows
(and/or columns) to operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting
is done.</p>
</td></tr>
<tr><td><code id="rowMedians_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, <code><a href="base.html#topic+NA">NA</a></code>s
are excluded first, otherwise not.</p>
</td></tr>
<tr><td><code id="rowMedians_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="rowMedians_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowMedians_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation of <code>rowMedians()</code> and <code>colMedians()</code> is
optimized for both speed and memory.  To avoid coercing to
<code><a href="base.html#topic+double">double</a></code>s (and hence memory allocation), there is a
special implementation for <code><a href="base.html#topic+integer">integer</a></code> matrices.  That is,
if <code>x</code> is an <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+matrix">matrix</a></code>,
then <code>rowMedians(as.double(x))</code> (<code>rowMedians(as.double(x))</code>) would
require three times the memory of <code>rowMedians(x)</code>
(<code>colMedians(x)</code>), but all this is avoided.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length N (K).
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson, Harris Jaffee
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+rowWeightedMedians">rowWeightedMedians</a>()</code> and
<code>colWeightedMedians()</code> for weighted medians.
For mean estimates, see <code><a href="#topic+rowMeans2">rowMeans2</a>()</code> and
<code><a href="base.html#topic+colSums">rowMeans</a>()</code>.
</p>

<hr>
<h2 id='rowOrderStats'>Gets an order statistic for each row (column) in a matrix</h2><span id='topic+rowOrderStats'></span><span id='topic+colOrderStats'></span>

<h3>Description</h3>

<p>Gets an order statistic for each row (column) in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowOrderStats(x, rows = NULL, cols = NULL, which, dim. = dim(x), ...,
  useNames = TRUE)

colOrderStats(x, rows = NULL, cols = NULL, which, dim. = dim(x), ...,
  useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowOrderStats_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowOrderStats_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowOrderStats_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowOrderStats_+3A_which">which</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> index in [1,K] ([1,N])
indicating which order statistic to be returned.</p>
</td></tr>
<tr><td><code id="rowOrderStats_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.  <em>Comment:</em> The reason for this argument
being named with a period at the end is purely technical (we get a run-time
error if we try to name it <code>dim</code>).</p>
</td></tr>
<tr><td><code id="rowOrderStats_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowOrderStats_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation of <code>rowOrderStats()</code> is optimized for both speed and
memory.  To avoid coercing to <code><a href="base.html#topic+double">double</a></code>s (and hence memory
allocation), there is a unique implementation for
<code><a href="base.html#topic+integer">integer</a></code> matrices.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length N (K).
</p>


<h3>Missing values</h3>

<p>This method does <em>not</em> handle missing values,
that is, the result corresponds to having <code>na.rm = FALSE</code> (if such an
argument would be available).
</p>


<h3>Author(s)</h3>

<p>The native implementation of <code>rowOrderStats()</code> was adopted by
Henrik Bengtsson from Robert Gentleman's <code>rowQ()</code> in the <span class="pkg">Biobase</span>
package.
</p>


<h3>See Also</h3>

<p>See <code>rowMeans()</code> in <code><a href="base.html#topic+colSums">colSums</a></code>().
</p>

<hr>
<h2 id='rowQuantiles'>Estimates quantiles for each row (column) in a matrix</h2><span id='topic+rowQuantiles'></span><span id='topic+colQuantiles'></span>

<h3>Description</h3>

<p>Estimates quantiles for each row (column) in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowQuantiles(x, rows = NULL, cols = NULL, probs = seq(from = 0, to = 1,
  by = 0.25), na.rm = FALSE, type = 7L, digits = 7L, ...,
  useNames = TRUE, drop = TRUE)

colQuantiles(x, rows = NULL, cols = NULL, probs = seq(from = 0, to = 1,
  by = 0.25), na.rm = FALSE, type = 7L, digits = 7L, ...,
  useNames = TRUE, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowQuantiles_+3A_x">x</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code>, <code><a href="base.html#topic+numeric">numeric</a></code> or
<code><a href="base.html#topic+logical">logical</a></code> NxK <code><a href="base.html#topic+matrix">matrix</a></code> with N &gt;= 0.</p>
</td></tr>
<tr><td><code id="rowQuantiles_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowQuantiles_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowQuantiles_+3A_probs">probs</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J
probabilities in [0, 1].</p>
</td></tr>
<tr><td><code id="rowQuantiles_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="rowQuantiles_+3A_type">type</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the type of estimator.
See <code><a href="stats.html#topic+quantile">quantile</a></code> for more details.</p>
</td></tr>
<tr><td><code id="rowQuantiles_+3A_digits">digits</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the precision of
the formatted percentages. Not used when 'useNames = FALSE'.
In **matrixStats** (&lt; 0.63.0), the default used to be
'max(2L, getOption(&quot;digits&quot;))' inline with R (&lt; 4.1.0).</p>
</td></tr>
<tr><td><code id="rowQuantiles_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="rowQuantiles_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
<tr><td><code id="rowQuantiles_+3A_drop">drop</code></td>
<td>
<p>If TRUE, singleton dimensions in the result are dropped,
otherwise not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a NxJ (KxJ) <code><a href="base.html#topic+matrix">matrix</a></code>, where N (K) is the
number of rows (columns) for which the J quantiles are calculated.
The return type is either integer or numeric depending on <code>type</code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

x &lt;- matrix(rnorm(50 * 40), nrow = 50, ncol = 40)
str(x)

probs &lt;- c(0.25, 0.5, 0.75)

# Row quantiles
q &lt;- rowQuantiles(x, probs = probs)
print(q)
q_0 &lt;- apply(x, MARGIN = 1, FUN = quantile, probs = probs)
stopifnot(all.equal(q_0, t(q)))

# Column IQRs
q &lt;- colQuantiles(x, probs = probs)
print(q)
q_0 &lt;- apply(x, MARGIN = 2, FUN = quantile, probs = probs)
stopifnot(all.equal(q_0, t(q)))
</code></pre>

<hr>
<h2 id='rowRanges'>Gets the range of values in each row (column) of a matrix</h2><span id='topic+rowRanges'></span><span id='topic+rowMins'></span><span id='topic+rowMaxs'></span><span id='topic+colRanges'></span><span id='topic+colMins'></span><span id='topic+colMaxs'></span>

<h3>Description</h3>

<p>Gets the range of values in each row (column) of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowRanges(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x),
  ..., useNames = TRUE)

rowMins(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ...,
  useNames = TRUE)

rowMaxs(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ...,
  useNames = TRUE)

colRanges(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x),
  ..., useNames = TRUE)

colMins(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ...,
  useNames = TRUE)

colMaxs(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ...,
  useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowRanges_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowRanges_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowRanges_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowRanges_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="rowRanges_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.  <em>Comment:</em> The reason for this argument
being named with a period at the end is purely technical (we get a run-time
error if we try to name it <code>dim</code>).</p>
</td></tr>
<tr><td><code id="rowRanges_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowRanges_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rowRanges()</code> (<code>colRanges()</code>) returns a
<code><a href="base.html#topic+numeric">numeric</a></code> Nx2 (Kx2) <code><a href="base.html#topic+matrix">matrix</a></code>, where N
(K) is the number of rows (columns) for which the ranges are calculated.
</p>
<p><code>rowMins()/rowMaxs()</code> (<code>colMins()/colMaxs()</code>) returns a
<code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length N (K).
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowOrderStats">rowOrderStats</a></code>() and <code><a href="base.html#topic+pmin.int">pmin.int</a></code>().
</p>

<hr>
<h2 id='rowRanks'>Gets the rank of the elements in each row (column) of a matrix</h2><span id='topic+rowRanks'></span><span id='topic+colRanks'></span>

<h3>Description</h3>

<p>Gets the rank of the elements in each row (column) of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowRanks(x, rows = NULL, cols = NULL, ties.method = c("max", "average",
  "first", "last", "random", "max", "min", "dense"), dim. = dim(x), ...,
  useNames = TRUE)

colRanks(x, rows = NULL, cols = NULL, ties.method = c("max", "average",
  "first", "last", "random", "max", "min", "dense"), dim. = dim(x),
  preserveShape = FALSE, ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowRanks_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowRanks_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowRanks_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowRanks_+3A_ties.method">ties.method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying how
ties are treated.  For details, see below.</p>
</td></tr>
<tr><td><code id="rowRanks_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.  <em>Comment:</em> The reason for this argument
being named with a period at the end is purely technical (we get a run-time
error if we try to name it <code>dim</code>).</p>
</td></tr>
<tr><td><code id="rowRanks_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowRanks_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
<tr><td><code id="rowRanks_+3A_preserveshape">preserveShape</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> specifying whether the
<code><a href="base.html#topic+matrix">matrix</a></code> returned should preserve the input shape of
<code>x</code>, or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions rank values and treats missing values the same way as
<code><a href="base.html#topic+rank">rank</a></code>().
For equal values (&quot;ties&quot;), argument <code>ties.method</code> determines how these
are ranked among each other.  More precisely, for the following values of
<code>ties.method</code>, each index set of ties consists of:
</p>

<ul>
<li><p><code>"first"</code> - increasing values that are all unique
</p>
</li>
<li><p><code>"last"</code> - decreasing values that are all unique
</p>
</li>
<li><p><code>"min"</code> - identical values equaling the minimum of
their original ranks
</p>
</li>
<li><p><code>"max"</code> - identical values equaling the maximum of
their original ranks
</p>
</li>
<li><p><code>"average"</code> - identical values that equal the sample mean of
their original ranks. Because the average is calculated, the returned
ranks may be non-integer values
</p>
</li>
<li><p><code>"random"</code> - randomly shuffled values of their original ranks.
</p>
</li>
<li><p><code>"dense"</code> - increasing values that are all unique and,
contrary to <code>"first"</code>, never contain any gaps
</p>
</li></ul>

<p>For more information on <code>ties.method = "dense"</code>, see <code>frank()</code> of
the <span class="pkg">data.table</span> package.
For more information on the other alternatives, see <code><a href="base.html#topic+rank">rank</a></code>().
</p>
<p>Note that, due to different randomization strategies, the shuffling order
produced by these functions when using <code>ties.method = "random"</code> does
not reproduce that of <code><a href="base.html#topic+rank">rank</a></code>().
</p>
<p><em>WARNING: For backward-compatibility reasons, the default is
<code>ties.method = "max"</code>, which differs from <code><a href="base.html#topic+rank">rank</a></code>()
which uses <code>ties.method = "average"</code> by default.
Since we plan to change the default behavior in a future version, we recommend
to explicitly specify the intended value of argument <code>ties.method</code>.</em>
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> of type <code><a href="base.html#topic+integer">integer</a></code> is
returned, unless <code>ties.method = "average"</code> when it is of type
<code><a href="base.html#topic+numeric">numeric</a></code>.
</p>
<p>The <code>rowRanks()</code> function always returns an NxK
<code><a href="base.html#topic+matrix">matrix</a></code>, where N (K) is the number of rows (columns)
whose ranks are calculated.
</p>
<p>The <code>colRanks()</code> function returns an NxK <code><a href="base.html#topic+matrix">matrix</a></code>, if
<code>preserveShape = TRUE</code>, otherwise a KxN <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
<p>Any <code><a href="base.html#topic+names">names</a></code> of <code>x</code> are ignored and absent in the
result.
</p>


<h3>Missing values</h3>

<p>Missing values are ranked as <code>NA_integer_</code>, as with <code>na.last = "keep"</code>
in the <code><a href="base.html#topic+rank">rank</a></code>() function.
</p>


<h3>Performance</h3>

<p>The implementation is optimized for both speed and memory.  To avoid
coercing to <code><a href="base.html#topic+double">double</a></code>s (and hence memory allocation),
there is a unique implementation for <code><a href="base.html#topic+integer">integer</a></code> matrices.
Furthermore, it is more memory efficient to do
<code>colRanks(x, preserveShape = TRUE)</code> than
<code>t(colRanks(x, preserveShape = FALSE))</code>.
</p>


<h3>Author(s)</h3>

<p>Hector Corrada Bravo and Harris Jaffee.  Peter Langfelder for adding
'ties.method' support.  Brian Montgomery for adding more 'ties.method's.
Henrik Bengtsson adapted the original native
implementation of <code>rowRanks()</code> from Robert Gentleman's <code>rowQ()</code> in
the <span class="pkg">Biobase</span> package.
</p>


<h3>See Also</h3>

<p>For developers, see also Section Utility functions' in 
'Writing R Extensions manual', particularly the
native functions <code>R_qsort_I()</code> and <code>R_qsort_int_I()</code>.
</p>

<hr>
<h2 id='rowSums2'>Calculates the sum for each row (column) in a matrix</h2><span id='topic+rowSums2'></span><span id='topic+colSums2'></span>

<h3>Description</h3>

<p>Calculates the sum for each row (column) in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowSums2(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x),
  ..., useNames = TRUE)

colSums2(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x),
  ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowSums2_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowSums2_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowSums2_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowSums2_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="rowSums2_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.  <em>Comment:</em> The reason for this argument
being named with a period at the end is purely technical (we get a run-time
error if we try to name it <code>dim</code>).</p>
</td></tr>
<tr><td><code id="rowSums2_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowSums2_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation of <code>rowSums2()</code> and <code>colSums2()</code> is
optimized for both speed and memory.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length N (K).
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>

<hr>
<h2 id='rowTabulates'>Tabulates the values in a matrix by row (column).</h2><span id='topic+rowTabulates'></span><span id='topic+colTabulates'></span>

<h3>Description</h3>

<p>Tabulates the values in a matrix by row (column).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowTabulates(x, rows = NULL, cols = NULL, values = NULL, ...,
  useNames = TRUE)

colTabulates(x, rows = NULL, cols = NULL, values = NULL, ...,
  useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowTabulates_+3A_x">x</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code>, a <code><a href="base.html#topic+logical">logical</a></code>, or
a <code><a href="base.html#topic+raw">raw</a></code> NxK <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="rowTabulates_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowTabulates_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowTabulates_+3A_values">values</code></td>
<td>
<p>An <code><a href="base.html#topic+vector">vector</a></code> of J values of count. If
<code><a href="base.html#topic+NULL">NULL</a></code>, all (unique) values are counted.</p>
</td></tr>
<tr><td><code id="rowTabulates_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowTabulates_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An alternative to these functions, is to use <code>table(x, row(x))</code>
and <code>table(x, col(x))</code>, with the exception that the latter do not
support the <code><a href="base.html#topic+raw">raw</a></code> data type.
When there are no missing values in <code>x</code>, we have that
<code>all(rowTabulates(x) == t(table(x, row(x))))</code> and
<code>all(colTabulates(x) == t(table(x, col(x))))</code>.
When there are missing values, we have that
<code>all(rowTabulates(x) == t(table(x, row(x), useNA = "always")[, seq_len(nrow(x))]))</code> and
<code>all(colTabulates(x) == t(table(x, col(x), useNA = "always")[, seq_len(ncol(x))]))</code>.
</p>


<h3>Value</h3>

<p>Returns a NxJ (KxJ) <code><a href="base.html#topic+matrix">matrix</a></code> where N (K) is the
number of row (column) <code><a href="base.html#topic+vector">vector</a></code>s tabulated and J is the
number of values counted.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:5, nrow = 10, ncol = 5)
print(x)
print(rowTabulates(x))
print(colTabulates(x))
# Count only certain values
print(rowTabulates(x, values = 1:3))


y &lt;- as.raw(x)
dim(y) &lt;- dim(x)
print(y)
print(rowTabulates(y))
print(colTabulates(y))
</code></pre>

<hr>
<h2 id='rowVars'>Variance estimates for each row (column) in a matrix</h2><span id='topic+rowVars'></span><span id='topic+colVars'></span>

<h3>Description</h3>

<p>Variance estimates for each row (column) in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowVars(x, rows = NULL, cols = NULL, na.rm = FALSE, refine = TRUE,
  center = NULL, dim. = dim(x), ..., useNames = TRUE)

colVars(x, rows = NULL, cols = NULL, na.rm = FALSE, refine = TRUE,
  center = NULL, dim. = dim(x), ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowVars_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowVars_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowVars_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowVars_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="rowVars_+3A_refine">refine</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, 'center' is NULL, and
<code>x</code> is <code><a href="base.html#topic+numeric">numeric</a></code>, then extra effort is used to
calculate the average with greater numerical precision, otherwise not.</p>
</td></tr>
<tr><td><code id="rowVars_+3A_center">center</code></td>
<td>
<p>(optional; a vector or length N (K)) If the row (column)
means are already estimated, they can be pre-specified using this argument.
This avoid re-estimating them again.
_Warning: It is important that a non-biased sample mean estimate is passed.
If not, then the variance estimate of the spread will also be biased._
If NULL (default), the row/column means are estimated internally.</p>
</td></tr>
<tr><td><code id="rowVars_+3A_dim.">dim.</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length two specifying the dimension of <code>x</code>, also when not a
<code><a href="base.html#topic+matrix">matrix</a></code>.  <em>Comment:</em> The reason for this argument
being named with a period at the end is purely technical (we get a run-time
error if we try to name it <code>dim</code>).</p>
</td></tr>
<tr><td><code id="rowVars_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>rowMeans()</code> and
<code>rowSums()</code>.</p>
</td></tr>
<tr><td><code id="rowVars_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length N (K).
</p>


<h3>Providing center estimates</h3>

<p>The sample variance is estimated as
</p>
<p><code class="reqn">n/(n-1) * mean((x - center)^2)</code>,
</p>
<p>where <code class="reqn">center</code> is estimated as the sample mean, by default.
In matrixStats (&lt; 0.58.0),
</p>
<p><code class="reqn">n/(n-1) * (mean(x^2) - center^2)</code>
</p>
<p>was used.  Both formulas give the same result _when_ 'center' is the
sample mean estimate.
</p>
<p>Argument 'center' can be used to provide an already existing estimate.
It is important that the sample mean estimate is passed.
If not, then the variance estimate of the spread will be biased.
</p>
<p>For the time being, in order to lower the risk for such mistakes,
argument 'center' is occasionally validated against the sample-mean
estimate.  If a discrepancy is detected, an informative error is
provided to prevent incorrect variance estimates from being used.
For performance reasons, this check is only performed once every 50 times.
The frequency can be controlled by R option 'matrixStats.vars.formula.freq',
whose default can be set by environment variable
'R_MATRIXSTATS_VARS_FORMULA_FREQ'.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>See <code>rowMeans()</code> and <code>rowSums()</code> in
<code><a href="base.html#topic+colSums">colSums</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

x &lt;- matrix(rnorm(20), nrow = 5, ncol = 4)
print(x)

# Row averages
print(rowMeans(x))
print(rowMedians(x))

# Column averages
print(colMeans(x))
print(colMedians(x))


# Row variabilities
print(rowVars(x))
print(rowSds(x))
print(rowMads(x))
print(rowIQRs(x))

# Column variabilities
print(rowVars(x))
print(colSds(x))
print(colMads(x))
print(colIQRs(x))

# Row ranges
print(rowRanges(x))
print(cbind(rowMins(x), rowMaxs(x)))
print(cbind(rowOrderStats(x, which = 1), rowOrderStats(x, which = ncol(x))))

# Column ranges
print(colRanges(x))
print(cbind(colMins(x), colMaxs(x)))
print(cbind(colOrderStats(x, which = 1), colOrderStats(x, which = nrow(x))))


x &lt;- matrix(rnorm(2000), nrow = 50, ncol = 40)

# Row standard deviations
d &lt;- rowDiffs(x)
s1 &lt;- rowSds(d) / sqrt(2)
s2 &lt;- rowSds(x)
print(summary(s1 - s2))

# Column standard deviations
d &lt;- colDiffs(x)
s1 &lt;- colSds(d) / sqrt(2)
s2 &lt;- colSds(x)
print(summary(s1 - s2))
</code></pre>

<hr>
<h2 id='rowWeightedMeans'>Calculates the weighted means for each row (column) in a matrix</h2><span id='topic+rowWeightedMeans'></span><span id='topic+colWeightedMeans'></span>

<h3>Description</h3>

<p>Calculates the weighted means for each row (column) in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowWeightedMeans(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE,
  ..., useNames = TRUE)

colWeightedMeans(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE,
  ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowWeightedMeans_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowWeightedMeans_+3A_w">w</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length
K (N).</p>
</td></tr>
<tr><td><code id="rowWeightedMeans_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowWeightedMeans_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowWeightedMeans_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="rowWeightedMeans_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="rowWeightedMeans_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementations of these methods are optimized for both speed and
memory.  If no weights are given, the corresponding
<code>rowMeans()</code>/<code>colMeans()</code> is used.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length N (K).
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>See <code>rowMeans()</code> and <code>colMeans()</code> in
<code><a href="base.html#topic+colSums">colSums</a></code>() for non-weighted means.  See also
<code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(20), nrow = 5, ncol = 4)
print(x)

# Non-weighted row averages
mu_0 &lt;- rowMeans(x)
mu &lt;- rowWeightedMeans(x)
stopifnot(all.equal(mu, mu_0))

# Weighted row averages (uniform weights)
w &lt;- rep(2.5, times = ncol(x))
mu &lt;- rowWeightedMeans(x, w = w)
stopifnot(all.equal(mu, mu_0))

# Weighted row averages (excluding some columns)
w &lt;- c(1, 1, 0, 1)
mu_0 &lt;- rowMeans(x[, (w == 1), drop = FALSE])
mu &lt;- rowWeightedMeans(x, w = w)
stopifnot(all.equal(mu, mu_0))

# Weighted row averages (excluding some columns)
w &lt;- c(0, 1, 0, 0)
mu_0 &lt;- rowMeans(x[, (w == 1), drop = FALSE])
mu &lt;- rowWeightedMeans(x, w = w)
stopifnot(all.equal(mu, mu_0))

# Weighted averages by rows and columns
w &lt;- 1:4
mu_1 &lt;- rowWeightedMeans(x, w = w)
mu_2 &lt;- colWeightedMeans(t(x), w = w)
stopifnot(all.equal(mu_2, mu_1))
</code></pre>

<hr>
<h2 id='rowWeightedMedians'>Calculates the weighted medians for each row (column) in a matrix</h2><span id='topic+rowWeightedMedians'></span><span id='topic+colWeightedMedians'></span>

<h3>Description</h3>

<p>Calculates the weighted medians for each row (column) in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowWeightedMedians(x, w = NULL, rows = NULL, cols = NULL,
  na.rm = FALSE, ..., useNames = TRUE)

colWeightedMedians(x, w = NULL, rows = NULL, cols = NULL,
  na.rm = FALSE, ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowWeightedMedians_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="rowWeightedMedians_+3A_w">w</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length
K (N).</p>
</td></tr>
<tr><td><code id="rowWeightedMedians_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowWeightedMedians_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="rowWeightedMedians_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="rowWeightedMedians_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+weightedMedian">weightedMedian</a></code>().</p>
</td></tr>
<tr><td><code id="rowWeightedMedians_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementations of these methods are optimized for both speed and
memory.  If no weights are given, the corresponding
<code><a href="#topic+rowMedians">rowMedians</a></code>()/<code>colMedians()</code> is used.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length N (K).
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>Internally, <code><a href="#topic+weightedMedian">weightedMedian</a></code>() is used.
See <code><a href="#topic+rowMedians">rowMedians</a></code>() and <code>colMedians()</code> for non-weighted
medians.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(20), nrow = 5, ncol = 4)
print(x)

# Non-weighted row averages
mu_0 &lt;- rowMedians(x)
mu &lt;- rowWeightedMedians(x)
stopifnot(all.equal(mu, mu_0))

# Weighted row averages (uniform weights)
w &lt;- rep(2.5, times = ncol(x))
mu &lt;- rowWeightedMedians(x, w = w)
stopifnot(all.equal(mu, mu_0))

# Weighted row averages (excluding some columns)
w &lt;- c(1, 1, 0, 1)
mu_0 &lt;- rowMedians(x[, (w == 1), drop = FALSE])
mu &lt;- rowWeightedMedians(x, w = w)
stopifnot(all.equal(mu, mu_0))

# Weighted row averages (excluding some columns)
w &lt;- c(0, 1, 0, 0)
mu_0 &lt;- rowMedians(x[, (w == 1), drop = FALSE])
mu &lt;- rowWeightedMedians(x, w = w)
stopifnot(all.equal(mu, mu_0))

# Weighted averages by rows and columns
w &lt;- 1:4
mu_1 &lt;- rowWeightedMedians(x, w = w)
mu_2 &lt;- colWeightedMedians(t(x), w = w)
stopifnot(all.equal(mu_2, mu_1))
</code></pre>

<hr>
<h2 id='signTabulate'>Calculates the number of negative, zero, positive and missing values</h2><span id='topic+signTabulate'></span>

<h3>Description</h3>

<p>Calculates the number of negative, zero, positive and missing values in a
<code><a href="base.html#topic+numeric">numeric</a></code> vector.  For <code><a href="base.html#topic+double">double</a></code> vectors,
the number of negative and positive infinite values are also counted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signTabulate(x, idxs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signTabulate_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="signTabulate_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="signTabulate_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+name">name</a></code>d <code><a href="base.html#topic+numeric">numeric</a></code>
<code><a href="base.html#topic+vector">vector</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sign">sign</a></code>().
</p>

<hr>
<h2 id='sum2'>Fast sum over subset of vector elements</h2><span id='topic+sum2'></span>

<h3>Description</h3>

<p>Computes the sum of all or a subset of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum2(x, idxs = NULL, na.rm = FALSE, mode = typeof(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum2_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="sum2_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="sum2_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="sum2_+3A_mode">mode</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the data type
of the return value.  Default is to use the same mode as argument <code>x</code>,
unless it is logical when it defaults to <code>"integer"</code>.</p>
</td></tr>
<tr><td><code id="sum2_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sum2(x, idxs)</code> gives equivalent results as <code>sum(x[idxs])</code>, but
is faster and more memory efficient since it avoids the actual subsetting
which requires copying of elements and garbage collection thereof.
</p>
<p>Furthermore, <code>sum2(x, mode = "double")</code> is equivalent to
<code>sum(as.numeric(x))</code> and may therefore be used to avoid integer
overflow(*), but at the same time is much more memory efficient that
the regular <code>sum()</code> function when <code>x</code> is an
<code><a href="base.html#topic+integer">integer</a></code> vector.
</p>
<p>(*) <em>In R (&gt;= 3.5.0), <code>sum(x)</code> will no longer integer overflow
and return <code>NA_integer_</code>. Instead it will return the correct sum in
form of a double value.</em>
</p>


<h3>Value</h3>

<p>Returns a scalar of the data type specified by argument <code>mode</code>.
If <code>mode = "integer"</code>, then integer overflow occurs if the <em>sum</em>
is outside the range of defined integer values.
Note that the intermediate sum (<code>sum(x[1:n])</code>) is internally
represented as a floating point value and will therefore never be outside of
the range.
If <code>mode = "integer"</code> and <code>typeof(x) == "double"</code>, then a warning
is generated.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sum">sum</a></code>().
To efficiently average over a subset, see <code><a href="#topic+mean2">mean2</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
n &lt;- length(x)

idxs &lt;- seq(from = 1, to = n, by = 2)
s1 &lt;- sum(x[idxs])                     # 25
s2 &lt;- sum2(x, idxs = idxs)             # 25
stopifnot(identical(s1, s2))

idxs &lt;- seq(from = n, to = 1, by = -2)
s1 &lt;- sum(x[idxs])                     # 25
s2 &lt;- sum2(x, idxs = idxs)             # 25
stopifnot(identical(s1, s2))

s1 &lt;- sum(x)                           # 55
s2 &lt;- sum2(x)                          # 55
stopifnot(identical(s1, s2))


# Total gives integer overflow
x &lt;- c(.Machine$integer.max, 1L, -.Machine$integer.max)
s1 &lt;- sum(x[1:2])                      # NA_integer_ in R (&lt; 3.5.0)
s2 &lt;- sum2(x[1:2])                     # NA_integer_

# Total gives integer overflow (coerce to numeric)
s1 &lt;- sum(as.numeric(x[1:2]))          # 2147483648
s2 &lt;- sum2(as.numeric(x[1:2]))         # 2147483648
s3 &lt;- sum2(x[1:2], mode = "double")    # 2147483648 w/out copy
stopifnot(identical(s1, s2))
stopifnot(identical(s1, s3))

# Cumulative sum would give integer overflow but not the total
s1 &lt;- sum(x)                           # 1L
s2 &lt;- sum2(x)                          # 1L
stopifnot(identical(s1, s2))
</code></pre>

<hr>
<h2 id='validateIndices'>Validate indices</h2><span id='topic+validateIndices'></span>

<h3>Description</h3>

<p>Computes validated positive indices from given indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateIndices(idxs = NULL, maxIdx, allowOutOfBound = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validateIndices_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="validateIndices_+3A_maxidx">maxIdx</code></td>
<td>
<p>The possible max index.</p>
</td></tr>
<tr><td><code id="validateIndices_+3A_allowoutofbound">allowOutOfBound</code></td>
<td>
<p>Allow positive out of bound to indicate
<code><a href="base.html#topic+NA">NA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>WARNING: This function is defunct and will be removed in a future
version.</em>
</p>


<h3>Value</h3>

<p>Returns a validated integers list indicating the indices.
If some of the indices cannot be represented as an integer, the
indices are returned as doubles.
</p>

<hr>
<h2 id='varDiff'>Estimation of scale based on sequential-order differences</h2><span id='topic+varDiff'></span><span id='topic+sdDiff'></span><span id='topic+madDiff'></span><span id='topic+iqrDiff'></span><span id='topic+rowVarDiffs'></span><span id='topic+colVarDiffs'></span><span id='topic+rowSdDiffs'></span><span id='topic+colSdDiffs'></span><span id='topic+rowMadDiffs'></span><span id='topic+colMadDiffs'></span><span id='topic+rowIQRDiffs'></span><span id='topic+colIQRDiffs'></span>

<h3>Description</h3>

<p>Estimation of scale based on sequential-order differences, corresponding to
the scale estimates provided by <code><a href="stats.html#topic+var">var</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="stats.html#topic+mad">mad</a></code> and
<code><a href="stats.html#topic+IQR">IQR</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varDiff(x, idxs = NULL, na.rm = FALSE, diff = 1L, trim = 0, ...)

sdDiff(x, idxs = NULL, na.rm = FALSE, diff = 1L, trim = 0, ...)

madDiff(x, idxs = NULL, na.rm = FALSE, diff = 1L, trim = 0,
  constant = 1.4826, ...)

iqrDiff(x, idxs = NULL, na.rm = FALSE, diff = 1L, trim = 0, ...)

rowVarDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L,
  trim = 0, ..., useNames = TRUE)

colVarDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L,
  trim = 0, ..., useNames = TRUE)

rowSdDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L,
  trim = 0, ..., useNames = TRUE)

colSdDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L,
  trim = 0, ..., useNames = TRUE)

rowMadDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L,
  trim = 0, ..., useNames = TRUE)

colMadDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L,
  trim = 0, ..., useNames = TRUE)

rowIQRDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L,
  trim = 0, ..., useNames = TRUE)

colIQRDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L,
  trim = 0, ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varDiff_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length
N or a <code><a href="base.html#topic+numeric">numeric</a></code> NxK <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="varDiff_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="varDiff_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="varDiff_+3A_diff">diff</code></td>
<td>
<p>The positional distance of elements for which the difference
should be calculated.</p>
</td></tr>
<tr><td><code id="varDiff_+3A_trim">trim</code></td>
<td>
<p>A <code><a href="base.html#topic+double">double</a></code> in [0,1/2] specifying the fraction
of observations to be trimmed from each end of (sorted) <code>x</code> before
estimation.</p>
</td></tr>
<tr><td><code id="varDiff_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="varDiff_+3A_constant">constant</code></td>
<td>
<p>A scale factor adjusting for asymptotically normal
consistency.</p>
</td></tr>
<tr><td><code id="varDiff_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="varDiff_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="varDiff_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that n-order difference MAD estimates, just like the ordinary MAD
estimate by <code><a href="stats.html#topic+mad">mad</a></code>, apply a correction factor such that
the estimates are consistent with the standard deviation under Gaussian
distributions.
</p>
<p>The interquartile range (IQR) estimates does <em>not</em> apply such a
correction factor.  If asymptotically normal consistency is wanted, the
correction factor for IQR estimate is <code>1 / (2 * qnorm(3/4))</code>, which is
half of that used for MAD estimates, which is <code>1 / qnorm(3/4)</code>.  This
correction factor needs to be applied manually, i.e. there is no
<code>constant</code> argument for the IQR functions.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of
length 1, length N, or length K.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>References</h3>

<p>[1] J. von Neumann et al., <em>The mean square successive
difference</em>.  Annals of Mathematical Statistics, 1941, 12, 153-162.<br />
</p>


<h3>See Also</h3>

<p>For the corresponding non-differentiated estimates, see
<code><a href="stats.html#topic+var">var</a></code>, <code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="stats.html#topic+mad">mad</a></code>
and <code><a href="stats.html#topic+IQR">IQR</a></code>.  Internally, <code><a href="#topic+diff2">diff2</a></code>() is used
which is a faster version of <code><a href="base.html#topic+diff">diff</a></code>().
</p>

<hr>
<h2 id='weightedMad'>Weighted Median Absolute Deviation (MAD)</h2><span id='topic+weightedMad'></span><span id='topic+rowWeightedMads'></span><span id='topic+colWeightedMads'></span>

<h3>Description</h3>

<p>Computes a weighted MAD of a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedMad(x, w = NULL, idxs = NULL, na.rm = FALSE, constant = 1.4826,
  center = NULL, ...)

rowWeightedMads(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE,
  constant = 1.4826, center = NULL, ..., useNames = TRUE)

colWeightedMads(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE,
  constant = 1.4826, center = NULL, ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightedMad_+3A_x">x</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> of type <code><a href="base.html#topic+integer">integer</a></code>,
<code><a href="base.html#topic+numeric">numeric</a></code>, or <code><a href="base.html#topic+logical">logical</a></code>.</p>
</td></tr>
<tr><td><code id="weightedMad_+3A_w">w</code></td>
<td>
<p>a vector of weights the same length as <code>x</code> giving the weights
to use for each element of <code>x</code>. Negative weights are treated as zero
weights. Default value is equal weight to all values.</p>
</td></tr>
<tr><td><code id="weightedMad_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="weightedMad_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="weightedMad_+3A_constant">constant</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> scale factor, cf.
<code><a href="stats.html#topic+mad">mad</a></code>.</p>
</td></tr>
<tr><td><code id="weightedMad_+3A_center">center</code></td>
<td>
<p>Optional <code><a href="base.html#topic+numeric">numeric</a></code> scalar specifying the
center location of the data.  If <code><a href="base.html#topic+NULL">NULL</a></code>, it is estimated
from data.</p>
</td></tr>
<tr><td><code id="weightedMad_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="weightedMad_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="weightedMad_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="weightedMad_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> scalar.
</p>


<h3>Missing values</h3>

<p>Missing values are dropped at the very beginning,
if argument <code>na.rm</code> is <code><a href="base.html#topic+logical">TRUE</a></code>, otherwise not.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>For the non-weighted MAD, see <code><a href="stats.html#topic+mad">mad</a></code>.  Internally
<code><a href="#topic+weightedMedian">weightedMedian</a></code>() is used to calculate the weighted median.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
n &lt;- length(x)

m1 &lt;- mad(x)
m2 &lt;- weightedMad(x)
stopifnot(identical(m1, m2))

w &lt;- rep(1, times = n)
m1 &lt;- weightedMad(x, w)
stopifnot(identical(m1, m2))

# All weight on the first value
w[1] &lt;- Inf
m &lt;- weightedMad(x, w)
stopifnot(m  == 0)

# All weight on the first two values
w[1:2] &lt;- Inf
m1 &lt;- mad(x[1:2])
m2 &lt;- weightedMad(x, w)
stopifnot(identical(m1, m2))

# All weights set to zero
w &lt;- rep(0, times = n)
m &lt;- weightedMad(x, w)
stopifnot(is.na(m))
</code></pre>

<hr>
<h2 id='weightedMean'>Weighted Arithmetic Mean</h2><span id='topic+weightedMean'></span>

<h3>Description</h3>

<p>Computes the weighted sample mean of a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedMean(x, w = NULL, idxs = NULL, na.rm = FALSE, refine = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightedMean_+3A_x">x</code></td>
<td>
<p>An NxK <code><a href="base.html#topic+matrix">matrix</a></code> or, if <code>dim.</code> is specified,
an N * K <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="weightedMean_+3A_w">w</code></td>
<td>
<p>a vector of weights the same length as <code>x</code> giving the weights
to use for each element of <code>x</code>. Negative weights are treated as zero
weights. Default value is equal weight to all values.
If a missing-value weight exists, the result is always a missing value.</p>
</td></tr>
<tr><td><code id="weightedMean_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="weightedMean_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="weightedMean_+3A_refine">refine</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> and <code>x</code> is
<code><a href="base.html#topic+numeric">numeric</a></code>, then extra effort is used to calculate the
average with greater numerical precision, otherwise not.</p>
</td></tr>
<tr><td><code id="weightedMean_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> scalar.  If <code>x</code> is of
zero length, then <code>NaN</code> is returned, which is consistent with
<code><a href="base.html#topic+mean">mean</a></code>().
</p>


<h3>Missing values</h3>

<p>This function handles missing values consistently with
<code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>.  More precisely, if <code>na.rm = FALSE</code>,
then any missing values in either <code>x</code> or <code>w</code> will give result
<code>NA_real_</code>.  If <code>na.rm = TRUE</code>, then all <code>(x, w)</code> data points
for which <code>x</code> is missing are skipped.  Note that if both <code>x</code> and
<code>w</code> are missing for a data points, then it is also skipped (by the same
rule).  However, if only <code>w</code> is missing, then the final results will
always be <code>NA_real_</code> regardless of <code>na.rm</code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code>() and <code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
n &lt;- length(x)

w &lt;- rep(1, times = n)
m0 &lt;- weighted.mean(x, w)
m1 &lt;- weightedMean(x, w)
stopifnot(identical(m1, m0))

# Pull the mean towards zero
w[1] &lt;- 5
m0 &lt;- weighted.mean(x, w)
m1 &lt;- weightedMean(x, w)
stopifnot(identical(m1, m0))

# Put even more weight on the zero
w[1] &lt;- 8.5
m0 &lt;- weighted.mean(x, w)
m1 &lt;- weightedMean(x, w)
stopifnot(identical(m1, m0))

# All weight on the first value
w[1] &lt;- Inf
m0 &lt;- weighted.mean(x, w)
m1 &lt;- weightedMean(x, w)
stopifnot(identical(m1, m0))

# All weight on the last value
w[1] &lt;- 1
w[n] &lt;- Inf
m0 &lt;- weighted.mean(x, w)
m1 &lt;- weightedMean(x, w)
stopifnot(identical(m1, m0))

# All weights set to zero
w &lt;- rep(0, times = n)
m0 &lt;- weighted.mean(x, w)
m1 &lt;- weightedMean(x, w)
stopifnot(identical(m1, m0))
</code></pre>

<hr>
<h2 id='weightedMedian'>Weighted Median Value</h2><span id='topic+weightedMedian'></span>

<h3>Description</h3>

<p>Computes a weighted median of a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedMedian(x, w = NULL, idxs = NULL, na.rm = FALSE,
  interpolate = is.null(ties), ties = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightedMedian_+3A_x">x</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> of type <code><a href="base.html#topic+integer">integer</a></code>,
<code><a href="base.html#topic+numeric">numeric</a></code>, or <code><a href="base.html#topic+logical">logical</a></code>.</p>
</td></tr>
<tr><td><code id="weightedMedian_+3A_w">w</code></td>
<td>
<p>a vector of weights the same length as <code>x</code> giving the weights
to use for each element of <code>x</code>. Negative weights are treated as zero
weights. Default value is equal weight to all values.</p>
</td></tr>
<tr><td><code id="weightedMedian_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="weightedMedian_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether <code><a href="base.html#topic+NA">NA</a></code>
values in <code>x</code> should be stripped before the computation proceeds, or
not.  If <code><a href="base.html#topic+NA">NA</a></code>, no check at all for <code><a href="base.html#topic+NA">NA</a></code>s
is done.</p>
</td></tr>
<tr><td><code id="weightedMedian_+3A_interpolate">interpolate</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, linear interpolation
is used to get a consistent estimate of the weighted median.</p>
</td></tr>
<tr><td><code id="weightedMedian_+3A_ties">ties</code></td>
<td>
<p>If <code>interpolate == FALSE</code>, a character string specifying
how to solve ties between two <code>x</code>'s that are satisfying the weighted
median criteria.  Note that at most two values can satisfy the criteria.
When <code>ties</code> is <code>"min"</code> (&quot;lower weighted median&quot;), the smaller
value of the two is returned and when it is <code>"max"</code> (&quot;upper weighted
median&quot;), the larger value is returned.  If <code>ties</code>
is <code>"mean"</code>, the mean of the two values is returned.  Finally, if
<code>ties</code> is <code>"weighted"</code> (or <code><a href="base.html#topic+NULL">NULL</a></code>) a weighted
average of the two are returned, where the weights are weights of all values
<code>x[i] &lt;= x[k]</code> and <code>x[i] &gt;= x[k]</code>, respectively.</p>
</td></tr>
<tr><td><code id="weightedMedian_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> scalar.
</p>
<p>For the <code>n</code> elements <code>x = c(x[1], x[2], ..., x[n])</code> with positive
weights <code>w = c(w[1], w[2], ..., w[n])</code> such that <code>sum(w) = S</code>, the
<em>weighted median</em> is defined as the element <code>x[k]</code> for which the
total weight of all elements <code>x[i] &lt; x[k]</code> is less or equal to
<code>S/2</code> and for which the total weight of all elements <code>x[i] &gt; x[k]</code>
is less or equal to <code>S/2</code> (c.f. [1]).
</p>
<p>When using linear interpolation, the weighted mean of <code>x[k-1]</code> and
<code>x[k]</code> with weights <code>S[k-1]</code> and <code>S[k]</code> corresponding to the
cumulative weights of those two elements is used as an estimate.
</p>
<p>If <code>w</code> is missing then all elements of <code>x</code> are given the same
positive weight. If all weights are zero, <code><a href="base.html#topic+NA">NA_real_</a></code> is
returned.
</p>
<p>If one or more weights are <code>Inf</code>, it is the same as these weights have
the same weight and the others have zero. This makes things easier for cases
where the weights are result of a division with zero.
</p>
<p>If there are missing values in <code>w</code> that are part of the calculation
(after subsetting and dropping missing values in <code>x</code>), then the final
result is always <code>NA</code> of the same type as <code>x</code>.
</p>
<p>The weighted median solves the following optimization problem:
</p>
<p style="text-align: center;"><code class="reqn">\alpha^* = \arg_\alpha \min \sum_{i = 1}^{n} w_i |x_i-\alpha|</code>
</p>
<p> where
<code class="reqn">x = (x_1, x_2, \ldots, x_n)</code> are scalars and
<code class="reqn">w = (w_1, w_2, \ldots, w_n)</code> are the corresponding &quot;weights&quot; for each
individual <code class="reqn">x</code> value.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson and Ola Hossjer, Centre for Mathematical Sciences,
Lund University.  Thanks to Roger Koenker, Econometrics, University of
Illinois, for the initial ideas.
</p>


<h3>References</h3>

<p>[1] T.H. Cormen, C.E. Leiserson, R.L. Rivest, Introduction to
Algorithms, The MIT Press, Massachusetts Institute of Technology, 1989.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+median">median</a></code>, <code><a href="base.html#topic+mean">mean</a></code>() and
<code><a href="#topic+weightedMean">weightedMean</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
n &lt;- length(x)

m1 &lt;- median(x)                             # 5.5
m2 &lt;- weightedMedian(x)                     # 5.5
stopifnot(identical(m1, m2))

w &lt;- rep(1, times = n)
m1 &lt;- weightedMedian(x, w)                  # 5.5 (default)
m2 &lt;- weightedMedian(x, ties = "weighted")  # 5.5 (default)
m3 &lt;- weightedMedian(x, ties = "min")       # 5
m4 &lt;- weightedMedian(x, ties = "max")       # 6
stopifnot(identical(m1, m2))

# Pull the median towards zero
w[1] &lt;- 5
m1 &lt;- weightedMedian(x, w)                  # 3.5
y &lt;- c(rep(0, times = w[1]), x[-1])         # Only possible for integer weights
m2 &lt;- median(y)                             # 3.5
stopifnot(identical(m1, m2))

# Put even more weight on the zero
w[1] &lt;- 8.5
weightedMedian(x, w)                # 2

# All weight on the first value
w[1] &lt;- Inf
weightedMedian(x, w)                # 1

# All weight on the last value
w[1] &lt;- 1
w[n] &lt;- Inf
weightedMedian(x, w)                # 10

# All weights set to zero
w &lt;- rep(0, times = n)
weightedMedian(x, w)                # NA

# Simple benchmarking
bench &lt;- function(N = 1e5, K = 10) {
  x &lt;- rnorm(N)
  gc()
  t &lt;- c()
  t[1] &lt;- system.time(for (k in 1:K) median(x))[3]
  t[2] &lt;- system.time(for (k in 1:K) weightedMedian(x))[3]
  t &lt;- t / t[1]
  names(t) &lt;- c("median", "weightedMedian")
  t
}

print(bench(N =     5, K = 100))
print(bench(N =    50, K = 100))
print(bench(N =   200, K = 100))
print(bench(N =  1000, K = 100))
print(bench(N =  10e3, K =  20))
print(bench(N = 100e3, K =  20))
</code></pre>

<hr>
<h2 id='weightedVar'>Weighted variance and weighted standard deviation</h2><span id='topic+weightedVar'></span><span id='topic+weightedSd'></span><span id='topic+rowWeightedVars'></span><span id='topic+colWeightedVars'></span><span id='topic+rowWeightedSds'></span><span id='topic+colWeightedSds'></span>

<h3>Description</h3>

<p>Computes a weighted variance / standard deviation of a numeric vector or
across rows or columns of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedVar(x, w = NULL, idxs = NULL, na.rm = FALSE, center = NULL,
  ...)

weightedSd(...)

rowWeightedVars(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE,
  ..., useNames = TRUE)

colWeightedVars(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE,
  ..., useNames = TRUE)

rowWeightedSds(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE,
  ..., useNames = TRUE)

colWeightedSds(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE,
  ..., useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightedVar_+3A_x">x</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> of type <code><a href="base.html#topic+integer">integer</a></code>,
<code><a href="base.html#topic+numeric">numeric</a></code>, or <code><a href="base.html#topic+logical">logical</a></code>.</p>
</td></tr>
<tr><td><code id="weightedVar_+3A_w">w</code></td>
<td>
<p>a vector of weights the same length as <code>x</code> giving the weights
to use for each element of <code>x</code>. Negative weights are treated as zero
weights. Default value is equal weight to all values.</p>
</td></tr>
<tr><td><code id="weightedVar_+3A_idxs">idxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="weightedVar_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
<tr><td><code id="weightedVar_+3A_center">center</code></td>
<td>
<p>Optional <code><a href="base.html#topic+numeric">numeric</a></code> scalar specifying the
center location of the data.  If <code><a href="base.html#topic+NULL">NULL</a></code>, it is estimated
from data.</p>
</td></tr>
<tr><td><code id="weightedVar_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="weightedVar_+3A_rows">rows</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="weightedVar_+3A_cols">cols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of columns to
operate over. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="weightedVar_+3A_usenames">useNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code> (default), names
attributes of the result are set, otherwise not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimator used here is the same as the one used by the &quot;unbiased&quot;
estimator of the <b>Hmisc</b> package. More specifically,
<code>weightedVar(x, w = w) == Hmisc::wtd.var(x, weights = w)</code>,
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> scalar.
</p>


<h3>Missing values</h3>

<p>This function handles missing values consistently with
<code><a href="#topic+weightedMean">weightedMean</a></code>().
More precisely, if <code>na.rm = FALSE</code>, then any missing values in either
<code>x</code> or <code>w</code> will give result <code>NA_real_</code>.
If <code>na.rm = TRUE</code>, then all <code>(x, w)</code> data points for which
<code>x</code> is missing are skipped.  Note that if both <code>x</code> and <code>w</code>
are missing for a data points, then it is also skipped (by the same rule).
However, if only <code>w</code> is missing, then the final results will always
be <code>NA_real_</code> regardless of <code>na.rm</code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>See Also</h3>

<p>For the non-weighted variance, see <code><a href="stats.html#topic+var">var</a></code>.
</p>

<hr>
<h2 id='x_OP_y'>Fast calculation of 'z &lt;- x OP y' and 'z &lt;- t(t(x) OP y)'</h2><span id='topic+x_OP_y'></span><span id='topic+t_tx_OP_y'></span>

<h3>Description</h3>

<p>Fast calculation of 'z &lt;- x OP y' and 'z &lt;- t(t(x) OP y)', where OP can be
+, -, *, and /.  For + and *, na.rm = TRUE will drop missing values first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_OP_y(x, y, OP, xrows = NULL, xcols = NULL, yidxs = NULL,
  commute = FALSE, na.rm = FALSE)

t_tx_OP_y(x, y, OP, xrows = NULL, xcols = NULL, yidxs = NULL,
  commute = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_OP_y_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+logical">logical</a></code>
NxK <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="x_OP_y_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+logical">logical</a></code>
<code><a href="base.html#topic+vector">vector</a></code> of length L.</p>
</td></tr>
<tr><td><code id="x_OP_y_+3A_op">OP</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying which operator to use.</p>
</td></tr>
<tr><td><code id="x_OP_y_+3A_xrows">xrows</code>, <code id="x_OP_y_+3A_xcols">xcols</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of rows
(and/or columns) to operate over 'x'. If <code><a href="base.html#topic+NULL">NULL</a></code>, no
subsetting is done.</p>
</td></tr>
<tr><td><code id="x_OP_y_+3A_yidxs">yidxs</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> indicating subset of elements to
operate over 'y'. If <code><a href="base.html#topic+NULL">NULL</a></code>, no subsetting is done.</p>
</td></tr>
<tr><td><code id="x_OP_y_+3A_commute">commute</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, 'y OP x' ('t(y OP
t(x))') is calculated, otherwise 'x OP y' ('t(t(x) OP y)').</p>
</td></tr>
<tr><td><code id="x_OP_y_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are
excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> NxK
<code><a href="base.html#topic+matrix">matrix</a></code>.
</p>


<h3>Missing values</h3>

<p>If <code>na.rm = TRUE</code>, then missing values are
&quot;dropped&quot; before applying the operator to each pair of values.  For
instance, if <code>x[1, 1]</code> is a missing value, then the result of
<code>x[1, 1] + y[1]</code> equals <code>y[1]</code>.  If also <code>y[1]</code> is a missing
value, then the result is a missing value.  This only applies to additions
and multiplications.  For subtractions and divisions, argument <code>na.rm</code>
is ignored.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1, 2, 3, NA, 5, 6), nrow = 3, ncol = 2)

# Add 'y' to each column
y &lt;- 1:2
z0 &lt;- x + y
z1 &lt;- x_OP_y(x, y, OP = "+")
print(z1)
stopifnot(all.equal(z1, z0))


# Add 'y' to each row
y &lt;- 1:3
z0 &lt;- t(t(x) + y)
z1 &lt;- t_tx_OP_y(x, y, OP = "+")
print(z1)
stopifnot(all.equal(z1, z0))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
