<!DOCTYPE html><html lang="en-US"><head><title>Help for package ravetools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ravetools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#band_pass'><p>Band-pass signals</p></a></li>
<li><a href='#baseline_array'><p>Calculate Contrasts of Arrays in Different Methods</p></a></li>
<li><a href='#butter_max_order'><p>'Butterworth' filter with maximum order</p></a></li>
<li><a href='#check_filter'><p>Check 'Arma' filter</p></a></li>
<li><a href='#collapse'><p>Collapse array</p></a></li>
<li><a href='#convolve'><p>Convolution of <code>1D</code>, <code>2D</code>, <code>3D</code> data via <code>FFT</code></p></a></li>
<li><a href='#decimate'><p>Decimate with 'FIR' or 'IIR' filter</p></a></li>
<li><a href='#design_filter'><p>Design a digital filter</p></a></li>
<li><a href='#design_filter_fir'><p>Design <code>'FIR'</code> filter using <code>firls</code></p></a></li>
<li><a href='#design_filter_iir'><p>Design an 'IIR' filter</p></a></li>
<li><a href='#detrend'><p>Remove the trend for one or more signals</p></a></li>
<li><a href='#diagnose_channel'><p>Show channel signals with diagnostic plots</p></a></li>
<li><a href='#diagnose_filter'><p>Diagnose digital filter</p></a></li>
<li><a href='#dijkstras-path'><p>Calculate distances along a surface</p></a></li>
<li><a href='#fast_cov'><p>Calculate massive covariance matrix in parallel</p></a></li>
<li><a href='#fast_quantile'><p>Compute quantiles</p></a></li>
<li><a href='#fill_surface'><p>Fill a volume cube based on water-tight surface</p></a></li>
<li><a href='#filter_signal'><p>Filter one-dimensional signal</p></a></li>
<li><a href='#filter-window'><p>Filter window functions</p></a></li>
<li><a href='#filtfilt'><p>Forward and reverse filter a one-dimensional signal</p></a></li>
<li><a href='#fir1'><p>Window-based <code>FIR</code> filter design</p></a></li>
<li><a href='#firls'><p>Least-squares linear-phase <code>FIR</code> filter design</p></a></li>
<li><a href='#freqz2'><p>Frequency response of digital filter</p></a></li>
<li><a href='#grow_volume'><p>Grow volume mask</p></a></li>
<li><a href='#internal_rave_function'><p>Get external function from 'RAVE'</p></a></li>
<li><a href='#interpolate_stimulation'><p>Find and interpolate stimulation signals</p></a></li>
<li><a href='#is_not_cran'><p>Internal function</p></a></li>
<li><a href='#left_hippocampus_mask'><p>Left 'Hippocampus' of 'N27-Collin' brain</p></a></li>
<li><a href='#matlab_palette'><p>'Matlab' heat-map plot palette</p></a></li>
<li><a href='#mesh_from_volume'><p>Generate 3D mesh surface from volume data</p></a></li>
<li><a href='#multitaper'><p>Compute 'multitaper' spectral densities of time-series data</p></a></li>
<li><a href='#new_matrix4'><p>Create a <code>Matrix4</code> instance for <code>'Affine'</code> transform</p></a></li>
<li><a href='#new_quaternion'><p>Create a <code>Quaternion</code> instance to store '3D' rotation</p></a></li>
<li><a href='#new_vector3'><p>Create a <code>Vector3</code> instance to store '3D' points</p></a></li>
<li><a href='#notch_filter'><p>Apply 'Notch' filter</p></a></li>
<li><a href='#parallel-options'><p>Set or get thread options</p></a></li>
<li><a href='#plot_signals'><p>Plot one or more signal traces in the same figure</p></a></li>
<li><a href='#pwelch'><p>Calculate 'Welch Periodogram'</p></a></li>
<li><a href='#raw-to-sexp'><p>Convert raw vectors to R vectors</p></a></li>
<li><a href='#rcond_filter_ar'><p>Computer reciprocal condition number of an 'Arma' filter</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#register_volume'><p>Imaging registration using <code>'NiftyReg'</code></p></a></li>
<li><a href='#resample_3d_volume'><p>Sample '3D' volume in the world (anatomical <code>'RAS'</code>) space</p></a></li>
<li><a href='#rgl-call'><p>Safe ways to call package <code>'rgl'</code> without requiring <code>'x11'</code></p></a></li>
<li><a href='#shift_array'><p>Shift array by index</p></a></li>
<li><a href='#vcg_isosurface'><p>Create surface mesh from 3D-array</p></a></li>
<li><a href='#vcg_kdtree_nearest'><p>Find nearest <code>k</code> points</p></a></li>
<li><a href='#vcg_mesh_volume'><p>Compute volume for manifold meshes</p></a></li>
<li><a href='#vcg_raycaster'><p>Cast rays to intersect with mesh</p></a></li>
<li><a href='#vcg_smooth'><p>Implicitly smooth a triangular mesh</p></a></li>
<li><a href='#vcg_sphere'><p>Simple 3-dimensional sphere mesh</p></a></li>
<li><a href='#vcg_uniform_remesh'><p>Sample a surface mesh uniformly</p></a></li>
<li><a href='#vcg_update_normals'><p>Update vertex normal</p></a></li>
<li><a href='#wavelet'><p>'Morlet' wavelet transform (Discrete)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Signal and Image Processing Toolbox for Analyzing Intracranial
Electroencephalography Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Description:</td>
<td>Implemented fast and memory-efficient Notch-filter, 
    Welch-periodogram, discrete wavelet spectrogram for minutes of 
    high-resolution signals, fast 3D convolution, image registration,
    3D mesh manipulation; providing fundamental toolbox for intracranial 
    Electroencephalography (iEEG) pipelines. 
    Documentation and examples about 'RAVE' project are provided at 
    <a href="https://rave.wiki">https://rave.wiki</a>, and the paper by John F. Magnotti, 
    Zhengjia Wang, Michael S. Beauchamp (2020) 
    &lt;<a href="https://doi.org/10.1016%2Fj.neuroimage.2020.117341">doi:10.1016/j.neuroimage.2020.117341</a>&gt;; see 'citation("ravetools")' for 
    details.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dipterix/ravetools/issues">https://github.com/dipterix/ravetools/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rave.wiki">https://rave.wiki</a>, <a href="https://dipterix.org/ravetools/">https://dipterix.org/ravetools/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>fftw3 (libfftw3-dev (deb), or fftw-devel (rpm)),
pkg-config</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Karim Rahim (author of R package 'fftwtools', licensed under
'GPL-2' or later) is the original author of 'src/ffts.h' and
'src/ffts.cpp'. Prerau's Lab wrote the original
'R/multitaper.R', licensed under 'MIT'. Marcus Geelnard wrote
the source code of 'TinyThread' library ('MIT' license) located
at 'inst/include/tthread'. Stefan Schlager wrote the original
code that converts R objects to 'vcg' (see 'src/vcgCommon.h',
licensed under 'GPL-2' or later). Visual Computing Lab is the
copyright holder of 'vcglib' source code (see 'src/vcglib',
licensed under GPL-2 or later).</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, filearray (&ge; 0.1.3), Rcpp, waveslim (&ge;
1.8.2), pracma, digest (&ge; 0.6.29), splines, RNiftyReg (&ge;
2.7.1), R6 (&ge; 2.5.1), gsignal (&ge; 0.3.5)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fftwtools, bit64, grDevices, microbenchmark,
freesurferformats, testthat, vctrs</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-05 02:20:25 UTC; dipterix</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhengjia Wang [aut, cre],
  John Magnotti [aut],
  Michael Beauchamp [aut],
  Trustees of the University of Pennsylvania [cph] (All files in this
    package unless explicitly stated in the file or listed in the
    'Copyright' section below.),
  Karim Rahim [cph, ctb] (Contributed to src/ffts.h and stc/ffts.cpp),
  Thomas Possidente [cph, ctb] (Contributed to R/multitaper.R),
  Michael Prerau [cph, ctb] (Contributed to R/multitaper.R),
  Marcus Geelnard [ctb, cph] (TinyThread library,
    tinythreadpp.bitsnbites.eu, located at inst/include/tthread/),
  Stefan Schlager [ctb, cph] (R-vcg interface, located at
    src/vcgCommon.h),
  Visual Computing Lab, ISTI [ctb, cph] (Copyright holder of vcglib,
    located at src/vcglib/)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhengjia Wang &lt;dipterix.wang@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-05 10:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='band_pass'>Band-pass signals</h2><span id='topic+band_pass'></span><span id='topic+band_pass1'></span><span id='topic+band_pass2'></span>

<h3>Description</h3>

<p>Band-pass signals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>band_pass1(x, sample_rate, lb, ub, domain = 1, ...)

band_pass2(
  x,
  sample_rate,
  lb,
  ub,
  order,
  method = c("fir", "butter"),
  direction = c("both", "forward", "backward"),
  window = "hamming",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="band_pass_+3A_x">x</code></td>
<td>
<p>input signals, numeric vector or matrix. <code>x</code> must be
row-major if input is a matrix: each row is a channel, and each column is
a time-point.</p>
</td></tr>
<tr><td><code id="band_pass_+3A_sample_rate">sample_rate</code></td>
<td>
<p>sampling frequency</p>
</td></tr>
<tr><td><code id="band_pass_+3A_lb">lb</code></td>
<td>
<p>lower frequency bound of the band-passing filter, must be positive</p>
</td></tr>
<tr><td><code id="band_pass_+3A_ub">ub</code></td>
<td>
<p>upper frequency bound of the band-passing filter, must be greater
than the lower bound and smaller than the half of sampling frequency</p>
</td></tr>
<tr><td><code id="band_pass_+3A_domain">domain</code></td>
<td>
<p>1 if <code>x</code> is in time-domain, or 0 if <code>x</code> is in
frequency domain</p>
</td></tr>
<tr><td><code id="band_pass_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="band_pass_+3A_order">order</code></td>
<td>
<p>the order of the filter, must be positive integer and be
less than one-third of the sample rate</p>
</td></tr>
<tr><td><code id="band_pass_+3A_method">method</code></td>
<td>
<p>filter type, choices are <code>'fir'</code> and <code>'butter'</code></p>
</td></tr>
<tr><td><code id="band_pass_+3A_direction">direction</code></td>
<td>
<p>filter direction, choices are <code>'forward'</code>,
<code>'backward'</code>, and <code>'both'</code> directions</p>
</td></tr>
<tr><td><code id="band_pass_+3A_window">window</code></td>
<td>
<p>window type, can be a character, a function, or a vector.
For character, <code>window</code> is a function name in the
<code>signal</code> package, for example, <code>'hanning'</code>; for a function,
<code>window</code> takes one integer argument and returns a numeric vector
with length of that input; for vectors, <code>window</code> is a numeric vector
o length <code>order+1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Filtered signals, vector if <code>x</code> is a vector, or matrix of
the same dimension as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

t &lt;- seq(0, 1, by = 0.0005)
x &lt;- sin(t * 0.4 * pi) + sin(t * 4 * pi) + 2 * sin(t * 120 * pi)

oldpar &lt;- par(mfrow = c(2, 2), mar = c(3.1, 2.1, 3.1, 0.1))
# ---- Using band_pass1 ------------------------------------------------

y1 &lt;- band_pass1(x, 2000, 0.1, 1)
y2 &lt;- band_pass1(x, 2000, 1, 5)
y3 &lt;- band_pass1(x, 2000, 10, 80)

plot(t, x, type = 'l', xlab = "Time", ylab = "",
     main = "Mixture of 0.2, 2, and 60Hz")
lines(t, y1, col = 'red')
lines(t, y2, col = 'blue')
lines(t, y3, col = 'green')
legend(
  "topleft", c("Input", "Pass: 0.1-1Hz", "Pass 1-5Hz", "Pass 10-80Hz"),
  col = c(par("fg"), "red", "blue", "green"), lty = 1,
  cex = 0.6
)

# plot pwelch
pwelch(x, fs = 2000, window = 4000, noverlap = 2000, plot = 1)
pwelch(y1, fs = 2000, window = 4000, noverlap = 2000,
       plot = 2, col = "red")
pwelch(y2, fs = 2000, window = 4000, noverlap = 2000,
       plot = 2, col = "blue")
pwelch(y3, fs = 2000, window = 4000, noverlap = 2000,
       plot = 2, col = "green")


# ---- Using band_pass2 with FIR filters --------------------------------

order &lt;- floor(2000 / 3)
z1 &lt;- band_pass2(x, 2000, 0.1, 1, method = "fir", order = order)
z2 &lt;- band_pass2(x, 2000, 1, 5, method = "fir", order = order)
z3 &lt;- band_pass2(x, 2000, 10, 80, method = "fir", order = order)

plot(t, x, type = 'l', xlab = "Time", ylab = "",
     main = "Mixture of 0.2, 2, and 60Hz")
lines(t, z1, col = 'red')
lines(t, z2, col = 'blue')
lines(t, z3, col = 'green')
legend(
  "topleft", c("Input", "Pass: 0.1-1Hz", "Pass 1-5Hz", "Pass 10-80Hz"),
  col = c(par("fg"), "red", "blue", "green"), lty = 1,
  cex = 0.6
)

# plot pwelch
pwelch(x, fs = 2000, window = 4000, noverlap = 2000, plot = 1)
pwelch(z1, fs = 2000, window = 4000, noverlap = 2000,
       plot = 2, col = "red")
pwelch(z2, fs = 2000, window = 4000, noverlap = 2000,
       plot = 2, col = "blue")
pwelch(z3, fs = 2000, window = 4000, noverlap = 2000,
       plot = 2, col = "green")

# ---- Clean this demo --------------------------------------------------
par(oldpar)

</code></pre>

<hr>
<h2 id='baseline_array'>Calculate Contrasts of Arrays in Different Methods</h2><span id='topic+baseline_array'></span><span id='topic+baseline_array.array'></span>

<h3>Description</h3>

<p>Provides five methods to baseline an array and calculate
contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline_array(x, along_dim, unit_dims = seq_along(dim(x))[-along_dim], ...)

## S3 method for class 'array'
baseline_array(
  x,
  along_dim,
  unit_dims = seq_along(dim(x))[-along_dim],
  method = c("percentage", "sqrt_percentage", "decibel", "zscore", "sqrt_zscore",
    "subtract_mean"),
  baseline_indexpoints = NULL,
  baseline_subarray = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="baseline_array_+3A_x">x</code></td>
<td>
<p>array (tensor) to calculate contrast</p>
</td></tr>
<tr><td><code id="baseline_array_+3A_along_dim">along_dim</code></td>
<td>
<p>integer range from 1 to the maximum dimension of <code>x</code>.
baseline along this dimension, this is usually the time dimension.</p>
</td></tr>
<tr><td><code id="baseline_array_+3A_unit_dims">unit_dims</code></td>
<td>
<p>integer vector, baseline unit: see Details.</p>
</td></tr>
<tr><td><code id="baseline_array_+3A_...">...</code></td>
<td>
<p>passed to other methods</p>
</td></tr>
<tr><td><code id="baseline_array_+3A_method">method</code></td>
<td>
<p>character, baseline method options are:
<code>"percentage"</code>, <code>"sqrt_percentage"</code>, <code>"decibel"</code>,
<code>"zscore"</code>, and <code>"sqrt_zscore"</code></p>
</td></tr>
<tr><td><code id="baseline_array_+3A_baseline_indexpoints">baseline_indexpoints</code></td>
<td>
<p>integer vector, which index points are counted
into baseline window? Each index ranges from 1 to <code>dim(x)[[along_dim]]</code>.
See Details.</p>
</td></tr>
<tr><td><code id="baseline_array_+3A_baseline_subarray">baseline_subarray</code></td>
<td>
<p>sub-arrays that should be used to calculate
baseline; default is <code>NULL</code> (automatically determined by
<code>baseline_indexpoints</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a scenario where we want to baseline a bunch of signals recorded
from different locations. For each location, we record <code>n</code> sessions.
For each session, the signal is further decomposed into frequency-time
domain. In this case, we have the input <code>x</code> in the following form:
</p>
<p style="text-align: center;"><code class="reqn">session x frequency x time x location</code>
</p>

<p>Now we want to calibrate signals for each session, frequency and location
using the first 100 time points as baseline points, then the code will be
</p>
<p style="text-align: center;"><code class="reqn">baseline_array(x, along_dim=3, baseline_window=1:100, unit_dims=c(1,2,4))</code>
</p>

<p><code>along_dim=3</code> is dimension of time, in this case, it's the
third dimension of <code>x</code>. <code>baseline_indexpoints=1:100</code>, meaning
the first 100 time points are used to calculate baseline.
<code>unit_dims</code> defines the unit signal. Its value <code>c(1,2,4)</code>
means the unit signal is per session (first dimension), per frequency
(second) and per location (fourth).
</p>
<p>In some other cases, we might want to calculate baseline across frequencies
then the unit signal is <code class="reqn">frequency x time</code>, i.e. signals that share the
same session and location also share the same baseline. In this case,
we assign <code>unit_dims=c(1,4)</code>.
</p>
<p>There are five baseline methods. They fit for different types of data.
Denote <code class="reqn">z</code> is an unit signal, <code class="reqn">z_0</code> is its baseline slice. Then
these baseline methods are:
</p>

<dl>
<dt><code>"percentage"</code></dt><dd>
<p style="text-align: center;"><code class="reqn">
  \frac{z - \bar{z_{0}}}{\bar{z_{0}}} \times 100\%
</code>
</p>

</dd>
<dt><code>"sqrt_percentage"</code></dt><dd>
<p style="text-align: center;"><code class="reqn">
  \frac{\sqrt{z} - \bar{\sqrt{z_{0}}}}{\bar{\sqrt{z_{0}}}} \times 100\%
</code>
</p>

</dd>
<dt><code>"decibel"</code></dt><dd>
<p style="text-align: center;"><code class="reqn">
  10 \times ( \log_{10}(z) - \bar{\log_{10}(z_{0})} )
</code>
</p>

</dd>
<dt><code>"zscore"</code></dt><dd>
<p style="text-align: center;"><code class="reqn">
  \frac{z-\bar{z_{0}}}{sd(z_{0})}
</code>
</p>

</dd>
<dt><code>"sqrt_zscore"</code></dt><dd>
<p style="text-align: center;"><code class="reqn">
  \frac{\sqrt{z}-\bar{\sqrt{z_{0}}}}{sd(\sqrt{z_{0}})}
</code>
</p>

</dd>
</dl>



<h3>Value</h3>

<p>Contrast array with the same dimension as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set ncores = 2 to comply to CRAN policy. Please don't run this line
ravetools_threads(n_threads = 2L)


library(ravetools)
set.seed(1)

# Generate sample data
dims = c(10,20,30,2)
x = array(rnorm(prod(dims))^2, dims)

# Set baseline window to be arbitrary 10 timepoints
baseline_window = sample(30, 10)

# ----- baseline percentage change ------

# Using base functions
re1 &lt;- aperm(apply(x, c(1,2,4), function(y){
  m &lt;- mean(y[baseline_window])
  (y/m - 1) * 100
}), c(2,3,1,4))

# Using ravetools
re2 &lt;- baseline_array(x, 3, c(1,2,4),
                      baseline_indexpoints = baseline_window,
                      method = 'percentage')

# Check different, should be very tiny (double precisions)
range(re2 - re1)


# Check speed for large dataset, might take a while to profile

ravetools_threads(n_threads = -1)

dims &lt;- c(200,20,300,2)
x &lt;- array(rnorm(prod(dims))^2, dims)
# Set baseline window to be arbitrary 10 timepoints
baseline_window &lt;- seq_len(100)
f1 &lt;- function(){
  aperm(apply(x, c(1,2,4), function(y){
    m &lt;- mean(y[baseline_window])
    (y/m - 1) * 100
  }), c(2,3,1,4))
}
f2 &lt;- function(){
  # equivalent as bl = x[,,baseline_window, ]
  #
  baseline_array(x, along_dim = 3,
                 baseline_indexpoints = baseline_window,
                 unit_dims = c(1,2,4), method = 'percentage')
}
range(f1() - f2())
microbenchmark::microbenchmark(f1(), f2(), times = 10L)





</code></pre>

<hr>
<h2 id='butter_max_order'>'Butterworth' filter with maximum order</h2><span id='topic+butter_max_order'></span>

<h3>Description</h3>

<p>Large filter order might not be optimal, but at lease this function
provides a feasible upper bound for the order such that the
filter has a stable <code>AR</code> component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>butter_max_order(
  w,
  type = c("low", "high", "pass", "stop"),
  r = 10 * log10(2),
  tol = .Machine$double.eps
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="butter_max_order_+3A_w">w</code></td>
<td>
<p>scaled frequency ranging from 0 to 1, where 1 is 'Nyquist' frequency</p>
</td></tr>
<tr><td><code id="butter_max_order_+3A_type">type</code></td>
<td>
<p>filter type</p>
</td></tr>
<tr><td><code id="butter_max_order_+3A_r">r</code></td>
<td>
<p>decibel attenuation at frequency <code>w</code>, default is around
<code>3 dB</code> (half power)</p>
</td></tr>
<tr><td><code id="butter_max_order_+3A_tol">tol</code></td>
<td>
<p>tolerance of reciprocal condition number, default is
<code>.Machine$double.eps</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'Butterworth' filter in 'Arma' form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Find highest order (sharpest transition) of a band-pass filter
sample_rate &lt;- 500
nyquist &lt;- sample_rate / 2

type &lt;- "pass"
w &lt;- c(1, 50) / nyquist
Rs &lt;- 6     # power attenuation at w

# max order filter
filter &lt;- butter_max_order(w, "pass", Rs)

# -6 dB cutoff should be around 1 ~ 50 Hz
diagnose_filter(filter$b, filter$a, fs = sample_rate)

</code></pre>

<hr>
<h2 id='check_filter'>Check 'Arma' filter</h2><span id='topic+check_filter'></span>

<h3>Description</h3>

<p>Check 'Arma' filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_filter(b, a, w = NULL, r_expected = NULL, fs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_filter_+3A_b">b</code></td>
<td>
<p>moving average (<code>MA</code>) polynomial coefficients.</p>
</td></tr>
<tr><td><code id="check_filter_+3A_a">a</code></td>
<td>
<p>auto-regressive (<code>AR</code>) polynomial coefficients.</p>
</td></tr>
<tr><td><code id="check_filter_+3A_w">w</code></td>
<td>
<p>normalized frequency, ranging from 0 to 1, where 1 is 'Nyquist'</p>
</td></tr>
<tr><td><code id="check_filter_+3A_r_expected">r_expected</code></td>
<td>
<p>attenuation in decibel of each <code>w</code></p>
</td></tr>
<tr><td><code id="check_filter_+3A_fs">fs</code></td>
<td>
<p>sample rate, used to infer the frequencies and formatting print
message, not used in calculation; leave it blank by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of power estimation and the reciprocal condition number
of the <code>AR</code> coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# create a butterworth filter with -3dB (half-power) at [1, 5] Hz
# and -60dB stop-band attenuation at [0.5, 6] Hz

sample_rate &lt;- 20
nyquist &lt;- sample_rate / 2

specs &lt;- buttord(
  Wp = c(1, 5) / nyquist,
  Ws = c(0.5, 6) / nyquist,
  Rp = 3,
  Rs = 60
)
filter &lt;- butter(specs)

# filter quality is poor because the AR-coefficients
# creates singular matrix with unstable inverse,
# this will cause `filtfilt` to fail
check_filter(
  b = filter$b, a = filter$a,

  # frequencies (normalized) where power is evaluated
  w = c(1, 5, 0.5, 6) / nyquist,

  # expected power
  r_expected = c(3, 3, 60, 60)

)


</code></pre>

<hr>
<h2 id='collapse'>Collapse array</h2><span id='topic+collapse'></span><span id='topic+collapse.array'></span>

<h3>Description</h3>

<p>Collapse array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse(x, keep, ...)

## S3 method for class 'array'
collapse(
  x,
  keep,
  average = TRUE,
  transform = c("asis", "10log10", "square", "sqrt"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_+3A_x">x</code></td>
<td>
<p>A numeric multi-mode tensor (array), without <code>NA</code></p>
</td></tr>
<tr><td><code id="collapse_+3A_keep">keep</code></td>
<td>
<p>Which dimension to keep</p>
</td></tr>
<tr><td><code id="collapse_+3A_...">...</code></td>
<td>
<p>passed to other methods</p>
</td></tr>
<tr><td><code id="collapse_+3A_average">average</code></td>
<td>
<p>collapse to sum or mean</p>
</td></tr>
<tr><td><code id="collapse_+3A_transform">transform</code></td>
<td>
<p>transform on the data before applying collapsing;
choices are <code>'asis'</code> (no change), <code>'10log10'</code> (used to calculate
decibel), <code>'square'</code> (sum-squared), <code>'sqrt'</code> (square-root and
collapse)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a collapsed array with values to be mean or summation along
collapsing dimensions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set ncores = 2 to comply to CRAN policy. Please don't run this line
ravetools_threads(n_threads = 2L)

# Example 1
x = matrix(1:16, 4)

# Keep the first dimension and calculate sums along the rest
collapse(x, keep = 1)
rowMeans(x)  # Should yield the same result

# Example 2
x = array(1:120, dim = c(2,3,4,5))
result = collapse(x, keep = c(3,2))
compare = apply(x, c(3,2), mean)
sum(abs(result - compare)) # The same, yield 0 or very small number (1e-10)




ravetools_threads(n_threads = -1)

# Example 3 (performance)

# Small data, no big difference
x = array(rnorm(240), dim = c(4,5,6,2))
microbenchmark::microbenchmark(
  result = collapse(x, keep = c(3,2)),
  compare = apply(x, c(3,2), mean),
  times = 1L, check = function(v){
    max(abs(range(do.call('-', v)))) &lt; 1e-10
  }
)

# large data big difference
x = array(rnorm(prod(300,200,105)), c(300,200,105,1))
microbenchmark::microbenchmark(
  result = collapse(x, keep = c(3,2)),
  compare = apply(x, c(3,2), mean),
  times = 1L , check = function(v){
    max(abs(range(do.call('-', v)))) &lt; 1e-10
  })



</code></pre>

<hr>
<h2 id='convolve'>Convolution of <code>1D</code>, <code>2D</code>, <code>3D</code> data via <code>FFT</code></h2><span id='topic+convolve'></span><span id='topic+convolve_signal'></span><span id='topic+convolve_image'></span><span id='topic+convolve_volume'></span>

<h3>Description</h3>

<p>Use the 'Fast-Fourier' transform to compute the convolutions of two data
with zero padding. This function is mainly designed for image convolution.
For forward and backward convolution/filter, see <code><a href="#topic+filtfilt">filtfilt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convolve_signal(x, filter)

convolve_image(x, filter)

convolve_volume(x, filter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convolve_+3A_x">x</code></td>
<td>
<p>one-dimensional signal vector, two-dimensional image, or
three-dimensional volume; numeric or complex</p>
</td></tr>
<tr><td><code id="convolve_+3A_filter">filter</code></td>
<td>
<p>kernel with the same number of dimensions as <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation uses 'Fast-Fourier' transform to perform
<code>1D</code>, <code>2D</code>, or <code>3D</code> convolution. Compared to implementations
using original mathematical definition of convolution, this approach is
much faster, especially for image and volume convolutions.
</p>
<p>The input <code>x</code> is zero-padded beyond edges. This is most common in image
or volume convolution, but less optimal for periodic one-dimensional signals.
Please use other implementations if non-zero padding is needed.
</p>
<p>The convolution results might be different to the ground truth by a precision
error, usually at <code>1e-13</code> level, depending on the <code>'FFTW3'</code>
library precision and implementation.
</p>


<h3>Value</h3>

<p>Convolution results with the same length and dimensions as <code>x</code>.
If <code>x</code> is complex, results will be complex, otherwise results will
be real numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# ---- 1D convolution ------------------------------------
x &lt;- cumsum(rnorm(100))
filter &lt;- dnorm(-2:2)
# normalize
filter &lt;- filter / sum(filter)
smoothed &lt;- convolve_signal(x, filter)

plot(x, pch = 20)
lines(smoothed, col = 'red')

# ---- 2D convolution ------------------------------------
x &lt;- array(0, c(100, 100))
x[
  floor(runif(10, min = 1, max = 100)),
  floor(runif(10, min = 1, max = 100))
] &lt;- 1

# smooth
kernel &lt;- outer(dnorm(-2:2), dnorm(-2:2), FUN = "*")
kernel &lt;- kernel / sum(kernel)

y &lt;- convolve_image(x, kernel)

oldpar &lt;- par(mfrow = c(1,2))
image(x, asp = 1, axes = FALSE, main = "Origin")
image(y, asp = 1, axes = FALSE, main = "Smoothed")
par(oldpar)


</code></pre>

<hr>
<h2 id='decimate'>Decimate with 'FIR' or 'IIR' filter</h2><span id='topic+decimate'></span>

<h3>Description</h3>

<p>Decimate with 'FIR' or 'IIR' filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decimate(x, q, n = if (ftype == "iir") 8 else 30, ftype = "fir")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decimate_+3A_x">x</code></td>
<td>
<p>signal to be decimated</p>
</td></tr>
<tr><td><code id="decimate_+3A_q">q</code></td>
<td>
<p>integer factor to down-sample by</p>
</td></tr>
<tr><td><code id="decimate_+3A_n">n</code></td>
<td>
<p>filter order used in the down-sampling; default is <code>30</code>
if <code>ftype='fir'</code>, or <code>8</code> if <code>ftype='iir'</code></p>
</td></tr>
<tr><td><code id="decimate_+3A_ftype">ftype</code></td>
<td>
<p>filter type, choices are <code>'fir'</code> (default) and
<code>'iir'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is migrated from <code>gsignal</code> package,
but with padding and indexing fixed. The results agree with 'Matlab'.
</p>


<h3>Value</h3>

<p>Decimated signal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1:100
y &lt;- decimate(x, 2, ftype = "fir")
y

# compare with signal package
z &lt;- gsignal::decimate(x, 2, ftype = "fir")

# Compare decimated results
plot(x, type = 'l')
points(seq(1,100, 2), y, col = "green")
points(seq(1,100, 2), z, col = "red")


</code></pre>

<hr>
<h2 id='design_filter'>Design a digital filter</h2><span id='topic+design_filter'></span>

<h3>Description</h3>

<p>Provides 'FIR' and 'IIR' filter options; default is 'FIR', see also
<code><a href="#topic+design_filter_fir">design_filter_fir</a></code>; for 'IIR' filters, see
<code><a href="#topic+design_filter_iir">design_filter_iir</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_filter(
  sample_rate,
  data = NULL,
  method = c("fir_kaiser", "firls", "fir_remez", "butter", "cheby1", "cheby2", "ellip"),
  high_pass_freq = NA,
  high_pass_trans_freq = NA,
  low_pass_freq = NA,
  low_pass_trans_freq = NA,
  passband_ripple = 0.1,
  stopband_attenuation = 40,
  filter_order = NA,
  ...,
  data_size = length(data)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_filter_+3A_sample_rate">sample_rate</code></td>
<td>
<p>data sample rate</p>
</td></tr>
<tr><td><code id="design_filter_+3A_data">data</code></td>
<td>
<p>data to be filtered, can be optional (<code>NULL</code>)</p>
</td></tr>
<tr><td><code id="design_filter_+3A_method">method</code></td>
<td>
<p>filter method, options are <code>"fir"</code> (default),
<code>"butter"</code>, <code>"cheby1"</code>, <code>"cheby2"</code>, and <code>"ellip"</code></p>
</td></tr>
<tr><td><code id="design_filter_+3A_high_pass_freq">high_pass_freq</code>, <code id="design_filter_+3A_low_pass_freq">low_pass_freq</code></td>
<td>
<p>high-pass or low-pass frequency,
see <code><a href="#topic+design_filter_fir">design_filter_fir</a></code> or <code><a href="#topic+design_filter_iir">design_filter_iir</a></code></p>
</td></tr>
<tr><td><code id="design_filter_+3A_high_pass_trans_freq">high_pass_trans_freq</code>, <code id="design_filter_+3A_low_pass_trans_freq">low_pass_trans_freq</code></td>
<td>
<p>transition bandwidths,
see <code><a href="#topic+design_filter_fir">design_filter_fir</a></code> or <code><a href="#topic+design_filter_iir">design_filter_iir</a></code></p>
</td></tr>
<tr><td><code id="design_filter_+3A_passband_ripple">passband_ripple</code></td>
<td>
<p>allowable pass-band ripple in decibel; default is
<code>0.1</code></p>
</td></tr>
<tr><td><code id="design_filter_+3A_stopband_attenuation">stopband_attenuation</code></td>
<td>
<p>minimum stop-band attenuation (in decibel) at
transition frequency; default is <code>40</code> dB.</p>
</td></tr>
<tr><td><code id="design_filter_+3A_filter_order">filter_order</code></td>
<td>
<p>suggested filter order; 'RAVE' may or may not adopt this
suggestion depending on the data and numerical feasibility</p>
</td></tr>
<tr><td><code id="design_filter_+3A_...">...</code></td>
<td>
<p>passed to filter generator functions</p>
</td></tr>
<tr><td><code id="design_filter_+3A_data_size">data_size</code></td>
<td>
<p>used by 'FIR' filter design to determine maximum order,
ignored in 'IIR' filters; automatically derived from <code>data</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>data</code> is specified and non-empty, this function returns
filtered data via forward and backward <code>filtfilt</code>; if <code>data</code> is
<code>NULL</code>, then returns the generator function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

sample_rate &lt;- 200
t &lt;- seq(0, 10, by = 1 / sample_rate)
x &lt;- sin(t * 4 * pi) + sin(t * 20 * pi) +
  2 * sin(t * 120 * pi) + rnorm(length(t), sd = 0.4)

# ---- Using FIR ------------------------------------------------

# Low-pass filter
y1 &lt;- design_filter(
  data = x,
  sample_rate = sample_rate,
  low_pass_freq = 3, low_pass_trans_freq = 0.5
)

# Band-pass cheby1 filter 8-12 Hz with custom transition
y2 &lt;- design_filter(
  data = x,
  method = "cheby1",
  sample_rate = sample_rate,
  low_pass_freq = 12, low_pass_trans_freq = .25,
  high_pass_freq = 8, high_pass_trans_freq = .25
)

y3 &lt;- design_filter(
  data = x,
  sample_rate = sample_rate,
  low_pass_freq = 80,
  high_pass_freq = 30
)

oldpar &lt;- par(mfrow = c(2, 1),
              mar = c(3.1, 2.1, 3.1, 0.1))
plot(t, x, type = 'l', xlab = "Time", ylab = "",
     main = "Mixture of 2, 10, and 60Hz", xlim = c(0,1))
# lines(t, y, col = 'red')
lines(t, y3, col = 'green')
lines(t, y2, col = 'blue')
lines(t, y1, col = 'red')
legend(
  "topleft", c("Input", "Low: 3Hz", "Pass 8-12Hz", "Pass 30-80Hz"),
  col = c(par("fg"), "red", "blue", "green"), lty = 1,
  cex = 0.6
)

# plot pwelch
pwelch(x, fs = sample_rate, window = sample_rate * 2,
       noverlap = sample_rate, plot = 1, ylim = c(-100, 10))
pwelch(y1, fs = sample_rate, window = sample_rate * 2,
       noverlap = sample_rate, plot = 2, col = "red")
pwelch(y2, fs = sample_rate, window = sample_rate * 2,
       noverlap = sample_rate, plot = 2, col = "blue")
pwelch(y3, fs = sample_rate, window = sample_rate * 2,
       noverlap = sample_rate, plot = 2, col = "green")


# ---- Clean this demo --------------------------------------------------
par(oldpar)


</code></pre>

<hr>
<h2 id='design_filter_fir'>Design <code>'FIR'</code> filter using <code><a href="#topic+firls">firls</a></code></h2><span id='topic+design_filter_fir'></span>

<h3>Description</h3>

<p>Design <code>'FIR'</code> filter using <code><a href="#topic+firls">firls</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_filter_fir(
  sample_rate,
  filter_order = NA,
  data_size = NA,
  high_pass_freq = NA,
  high_pass_trans_freq = NA,
  low_pass_freq = NA,
  low_pass_trans_freq = NA,
  stopband_attenuation = 40,
  scale = TRUE,
  method = c("kaiser", "firls", "remez")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_filter_fir_+3A_sample_rate">sample_rate</code></td>
<td>
<p>sampling frequency</p>
</td></tr>
<tr><td><code id="design_filter_fir_+3A_filter_order">filter_order</code></td>
<td>
<p>filter order, leave <code>NA</code> (default) if undecided</p>
</td></tr>
<tr><td><code id="design_filter_fir_+3A_data_size">data_size</code></td>
<td>
<p>minimum length of data to apply the filter, used to
decide the maximum filter order. For 'FIR' filter, data length must be
greater than <code>3xfilter_order</code></p>
</td></tr>
<tr><td><code id="design_filter_fir_+3A_high_pass_freq">high_pass_freq</code></td>
<td>
<p>high-pass frequency; default is <code>NA</code> (no
high-pass filter will be applied)</p>
</td></tr>
<tr><td><code id="design_filter_fir_+3A_high_pass_trans_freq">high_pass_trans_freq</code></td>
<td>
<p>high-pass frequency band-width; default
is automatically inferred from data size.
Frequency <code>high_pass_freq - high_pass_trans_freq</code> is the corner
of the stop-band</p>
</td></tr>
<tr><td><code id="design_filter_fir_+3A_low_pass_freq">low_pass_freq</code></td>
<td>
<p>low-pass frequency; default is <code>NA</code> (no
low-pass filter will be applied)</p>
</td></tr>
<tr><td><code id="design_filter_fir_+3A_low_pass_trans_freq">low_pass_trans_freq</code></td>
<td>
<p>low-pass frequency band-width; default
is automatically inferred from data size.
Frequency <code>low_pass_freq + low_pass_trans_freq</code> is the corner
of the stop-band</p>
</td></tr>
<tr><td><code id="design_filter_fir_+3A_stopband_attenuation">stopband_attenuation</code></td>
<td>
<p>allowable power attenuation (in decibel) at
transition frequency; default is <code>40</code> dB.</p>
</td></tr>
<tr><td><code id="design_filter_fir_+3A_scale">scale</code></td>
<td>
<p>whether to scale the filter for unity gain</p>
</td></tr>
<tr><td><code id="design_filter_fir_+3A_method">method</code></td>
<td>
<p>method to generate 'FIR' filter, default is using
<code><a href="gsignal.html#topic+kaiser">kaiser</a></code> estimate, other choices are
<code><a href="#topic+firls">firls</a></code> (with <code>hamming</code> window) and
<code><a href="gsignal.html#topic+remez">remez</a></code> design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Filter type is determined from <code>high_pass_freq</code> and
<code>low_pass_freq</code>. High-pass frequency is ignored if <code>high_pass_freq</code>
is <code>NA</code>, hence the filter is low-pass filter. When
<code>low_pass_freq</code> is <code>NA</code>, then
the filter is high-pass filter. When both <code>high_pass_freq</code> and
<code>low_pass_freq</code> are valid (positive, less than 'Nyquist'), then
the filter is a band-pass filter if band-pass is less than low-pass
frequency, otherwise the filter is band-stop.
</p>
<p>Although the peak amplitudes are set at 1 by <code>low_pass_freq</code> and
<code>high_pass_freq</code>, the transition from peak amplitude to zero require
a transition, which is tricky but also important to set.
When 'FIR' filters have too steep transition boundaries, the filter tends to
have ripples in peak amplitude, introducing artifacts to the final signals.
When the filter is too flat, components from unwanted frequencies may also
get aliased into the filtered signals. Ideally, the transition bandwidth
cannot be too steep nor too flat. In this function, users may control
the transition frequency bandwidths via <code>low_pass_trans_freq</code> and
<code>high_pass_trans_freq</code>. The power at the end of transition is defined
by <code>stopband_attenuation</code>, with default value of <code>40</code> (i.e.
-40 dB, this number is automatically negated during the calculation).
By design, a low-pass 5 Hz filter with 1 Hz transition bandwidth results in
around -40 dB power at 6 Hz.
</p>


<h3>Value</h3>

<p>'FIR' filter in 'Arma' form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---- Basic -----------------------------

sample_rate &lt;- 500
data_size &lt;- 1000

# low-pass at 5 Hz, with auto transition bandwidth
# from kaiser's method, with default stopband attenuation = 40 dB
filter &lt;- design_filter_fir(
  low_pass_freq = 5,
  sample_rate = sample_rate,
  data_size = data_size
)

# Passband ripple is around 0.08 dB
# stopband attenuation is around 40 dB
print(filter)

diagnose_filter(
  filter$b, filter$a,
  fs = sample_rate,
  n = data_size,
  cutoffs = c(-3, -6, -40),
  vlines = 5
)

# ---- Advanced ---------------------------------------------

sample_rate &lt;- 500
data_size &lt;- 1000

# Rejecting 3-8 Hz, with transition bandwidth 0.5 Hz at both ends
# Using least-square (firls) to generate FIR filter
# Suggesting the filter order n=160
filter &lt;- design_filter_fir(
  low_pass_freq = 3, low_pass_trans_freq = 0.5,
  high_pass_freq = 8, high_pass_trans_freq = 0.5,
  filter_order = 160,
  sample_rate = sample_rate,
  data_size = data_size,
  method = "firls"
)

#
print(filter)

diagnose_filter(
  filter$b, filter$a,
  fs = sample_rate,
  n = data_size,
  cutoffs = c(-1, -40),
  vlines = c(3, 8)
)



</code></pre>

<hr>
<h2 id='design_filter_iir'>Design an 'IIR' filter</h2><span id='topic+design_filter_iir'></span>

<h3>Description</h3>

<p>Design an 'IIR' filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_filter_iir(
  method = c("butter", "cheby1", "cheby2", "ellip"),
  sample_rate,
  filter_order = NA,
  high_pass_freq = NA,
  high_pass_trans_freq = NA,
  low_pass_freq = NA,
  low_pass_trans_freq = NA,
  passband_ripple = 0.1,
  stopband_attenuation = 40
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_filter_iir_+3A_method">method</code></td>
<td>
<p>filter method name, choices are <code>"butter"</code>,
<code>"cheby1"</code>, <code>"cheby2"</code>, and <code>"ellip"</code></p>
</td></tr>
<tr><td><code id="design_filter_iir_+3A_sample_rate">sample_rate</code></td>
<td>
<p>sampling frequency</p>
</td></tr>
<tr><td><code id="design_filter_iir_+3A_filter_order">filter_order</code></td>
<td>
<p>suggested filter order. Notice filters with higher orders
may become numerically unstable, hence this number is only a suggested
number. If the filter is unstable, this function will choose a lower order;
leave this input <code>NA</code> (default) if undecided.</p>
</td></tr>
<tr><td><code id="design_filter_iir_+3A_high_pass_freq">high_pass_freq</code></td>
<td>
<p>high-pass frequency; default is <code>NA</code> (no high-pass
filter will be applied)</p>
</td></tr>
<tr><td><code id="design_filter_iir_+3A_high_pass_trans_freq">high_pass_trans_freq</code></td>
<td>
<p>high-pass frequency band-width; default
is automatically inferred from filter type.</p>
</td></tr>
<tr><td><code id="design_filter_iir_+3A_low_pass_freq">low_pass_freq</code></td>
<td>
<p>low-pass frequency; default is <code>NA</code> (no
low-pass filter will be applied)</p>
</td></tr>
<tr><td><code id="design_filter_iir_+3A_low_pass_trans_freq">low_pass_trans_freq</code></td>
<td>
<p>low-pass frequency band-width; default
is automatically inferred from filter type.</p>
</td></tr>
<tr><td><code id="design_filter_iir_+3A_passband_ripple">passband_ripple</code></td>
<td>
<p>allowable pass-band ripple in decibel; default is
<code>0.1</code></p>
</td></tr>
<tr><td><code id="design_filter_iir_+3A_stopband_attenuation">stopband_attenuation</code></td>
<td>
<p>minimum stop-band attenuation (in decibel) at
transition frequency; default is <code>40</code> dB.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filter in 'Arma' form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sample_rate &lt;- 500

my_diagnose &lt;- function(
    filter, vlines = c(8, 12), cutoffs = c(-3, -6)) {
  diagnose_filter(
    b = filter$b,
    a = filter$a,
    fs = sample_rate,
    vlines = vlines,
    cutoffs = cutoffs
  )
}

# ---- Default using butterworth to generate 8-12 bandpass filter ----

# Butterworth filter with cut-off frequency
# 7 ~ 13 (default transition bandwidth is 1Hz) at -3 dB
filter &lt;- design_filter_iir(
  method = "butter",
  low_pass_freq = 12,
  high_pass_freq = 8,
  sample_rate = 500
)

filter

my_diagnose(filter)

## explicit bandwidths and attenuation (sharper transition)

# Butterworth filter with cut-off frequency
# passband ripple is 0.5 dB (8-12 Hz)
# stopband attenuation is 40 dB (5-18 Hz)
filter &lt;- design_filter_iir(
  method = "butter",
  low_pass_freq = 12, low_pass_trans_freq = 6,
  high_pass_freq = 8, high_pass_trans_freq = 3,
  sample_rate = 500,
  passband_ripple = 0.5,
  stopband_attenuation = 40
)

filter

my_diagnose(filter)

# ---- cheby1 --------------------------------

filter &lt;- design_filter_iir(
  method = "cheby1",
  low_pass_freq = 12,
  high_pass_freq = 8,
  sample_rate = 500
)

my_diagnose(filter)

# ---- cheby2 --------------------------------

filter &lt;- design_filter_iir(
  method = "cheby2",
  low_pass_freq = 12,
  high_pass_freq = 8,
  sample_rate = 500
)

my_diagnose(filter)

# ----- ellip ---------------------------------

filter &lt;- design_filter_iir(
  method = "ellip",
  low_pass_freq = 12,
  high_pass_freq = 8,
  sample_rate = 500
)

my_diagnose(filter)




</code></pre>

<hr>
<h2 id='detrend'>Remove the trend for one or more signals</h2><span id='topic+detrend'></span>

<h3>Description</h3>

<p>'Detrending' is often used before the signal power calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detrend(x, trend = c("constant", "linear"), break_points = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detrend_+3A_x">x</code></td>
<td>
<p>numerical or complex, a vector or a matrix</p>
</td></tr>
<tr><td><code id="detrend_+3A_trend">trend</code></td>
<td>
<p>the trend of the signal; choices are <code>'constant'</code> and
<code>'linear'</code></p>
</td></tr>
<tr><td><code id="detrend_+3A_break_points">break_points</code></td>
<td>
<p>integer vector, or <code>NULL</code>; only used when
<code>trend</code> is <code>'linear'</code> to remove piecewise linear trend; will
throw warnings if <code>trend</code> is <code>'constant'</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The signals with trend removed in matrix form; the number of columns
is the number of signals, and number of rows is length of the signals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(100, mean = 1) + c(
  seq(0, 5, length.out = 50),
  seq(5, 3, length.out = 50))
plot(x)

plot(detrend(x, 'constant'))
plot(detrend(x, 'linear'))
plot(detrend(x, 'linear', 50))

</code></pre>

<hr>
<h2 id='diagnose_channel'>Show channel signals with diagnostic plots</h2><span id='topic+diagnose_channel'></span>

<h3>Description</h3>

<p>The diagnostic plots include 'Welch Periodogram'
(<code><a href="#topic+pwelch">pwelch</a></code>) and histogram (<code><a href="graphics.html#topic+hist">hist</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnose_channel(
  s1,
  s2 = NULL,
  sc = NULL,
  srate,
  name = "",
  try_compress = TRUE,
  max_freq = 300,
  window = ceiling(srate * 2),
  noverlap = window/2,
  std = 3,
  which = NULL,
  main = "Channel Inspection",
  col = c("black", "red"),
  cex = 1.2,
  cex.lab = 1,
  lwd = 0.5,
  plim = NULL,
  nclass = 100,
  start_time = 0,
  boundary = NULL,
  mar = c(3.1, 4.1, 2.1, 0.8) * (0.25 + cex * 0.75) + 0.1,
  mgp = cex * c(2, 0.5, 0),
  xaxs = "i",
  yaxs = "i",
  xline = 1.66 * cex,
  yline = 2.66 * cex,
  tck = -0.005 * (3 + cex),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnose_channel_+3A_s1">s1</code></td>
<td>
<p>the main signal to draw</p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_s2">s2</code></td>
<td>
<p>the comparing signal to draw; usually <code>s1</code> after some filters;
must be in the same sampling rate with <code>s1</code>; can be <code>NULL</code></p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_sc">sc</code></td>
<td>
<p>decimated <code>s1</code> to show if <code>srate</code> is too high; will
be automatically generated if <code>NULL</code></p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_srate">srate</code></td>
<td>
<p>sampling rate</p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_name">name</code></td>
<td>
<p>name of <code>s1</code>, or a vector of two names of <code>s1</code> and
<code>s2</code> if <code>s2</code> is provided</p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_try_compress">try_compress</code></td>
<td>
<p>whether try to compress (decimate) <code>s1</code> if
<code>srate</code> is too high for performance concerns</p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_max_freq">max_freq</code></td>
<td>
<p>the maximum frequency to display in 'Welch Periodograms'</p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_window">window</code>, <code id="diagnose_channel_+3A_noverlap">noverlap</code></td>
<td>
<p>see <code><a href="#topic+pwelch">pwelch</a></code></p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_std">std</code></td>
<td>
<p>the standard deviation of the channel signals used to determine
<code>boundary</code>; default is plus-minus 3 standard deviation</p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_which">which</code></td>
<td>
<p><code>NULL</code> or integer from 1 to 4; if <code>NULL</code>, all plots
will be displayed; otherwise only the subplot will be displayed</p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_main">main</code></td>
<td>
<p>the title of the signal plot</p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_col">col</code></td>
<td>
<p>colors of <code>s1</code> and <code>s2</code></p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_cex">cex</code>, <code id="diagnose_channel_+3A_lwd">lwd</code>, <code id="diagnose_channel_+3A_mar">mar</code>, <code id="diagnose_channel_+3A_cex.lab">cex.lab</code>, <code id="diagnose_channel_+3A_mgp">mgp</code>, <code id="diagnose_channel_+3A_xaxs">xaxs</code>, <code id="diagnose_channel_+3A_yaxs">yaxs</code>, <code id="diagnose_channel_+3A_tck">tck</code>, <code id="diagnose_channel_+3A_...">...</code></td>
<td>
<p>graphical parameters; see
<code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_plim">plim</code></td>
<td>
<p>the y-axis limit to draw in 'Welch Periodograms'</p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_nclass">nclass</code></td>
<td>
<p>number of classes to show in histogram
(<code><a href="graphics.html#topic+hist">hist</a></code>)</p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_start_time">start_time</code></td>
<td>
<p>the starting time of channel (will only be used to draw
signals)</p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_boundary">boundary</code></td>
<td>
<p>a red boundary to show in channel plot; default is
to be automatically determined by <code>std</code></p>
</td></tr>
<tr><td><code id="diagnose_channel_+3A_xline">xline</code>, <code id="diagnose_channel_+3A_yline">yline</code></td>
<td>
<p>distance of axis labels towards ticks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of boundary and y-axis limit used to draw the channel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ravetools)

# Generate 20 second data at 2000 Hz
time &lt;- seq(0, 20, by = 1 / 2000)
signal &lt;- sin( 120 * pi * time) +
  sin(time * 20*pi) +
  exp(-time^2) *
  cos(time * 10*pi) +
  rnorm(length(time))

signal2 &lt;- notch_filter(signal, 2000)

diagnose_channel(signal, signal2, srate = 2000,
                 name = c("Raw", "Filtered"), cex = 1)

</code></pre>

<hr>
<h2 id='diagnose_filter'>Diagnose digital filter</h2><span id='topic+diagnose_filter'></span>

<h3>Description</h3>

<p>Generate frequency response plot with sample-data simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnose_filter(
  b,
  a,
  fs,
  n = 512,
  whole = FALSE,
  sample = stats::rnorm(n, mean = sample_signal(n), sd = 0.2),
  vlines = NULL,
  xlim = "auto",
  cutoffs = c(-3, -6, -12)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnose_filter_+3A_b">b</code></td>
<td>
<p>the moving-average coefficients of an <code>ARMA</code> model</p>
</td></tr>
<tr><td><code id="diagnose_filter_+3A_a">a</code></td>
<td>
<p>the auto-regressive coefficients of an <code>ARMA</code> filter; default
is <code>1</code></p>
</td></tr>
<tr><td><code id="diagnose_filter_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in <code>Hz</code></p>
</td></tr>
<tr><td><code id="diagnose_filter_+3A_n">n</code></td>
<td>
<p>number of points at which to evaluate the frequency response;
default is <code>512</code></p>
</td></tr>
<tr><td><code id="diagnose_filter_+3A_whole">whole</code></td>
<td>
<p>whether to evaluate beyond <code>Nyquist</code> frequency; default
is false</p>
</td></tr>
<tr><td><code id="diagnose_filter_+3A_sample">sample</code></td>
<td>
<p>sample signal of length <code>n</code> for simulation</p>
</td></tr>
<tr><td><code id="diagnose_filter_+3A_vlines">vlines</code></td>
<td>
<p>additional vertical lines (frequencies) to plot</p>
</td></tr>
<tr><td><code id="diagnose_filter_+3A_xlim">xlim</code></td>
<td>
<p>frequency limit of frequency response plot; default is
<code>"auto"</code>, can be <code>"full"</code> or a numeric of length 2</p>
</td></tr>
<tr><td><code id="diagnose_filter_+3A_cutoffs">cutoffs</code></td>
<td>
<p>cutoff decibel powers to draw on the frequency plot, also used
to calculate the frequency limit when <code>xlim</code> is <code>"auto"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


library(ravetools)

# sample rate
srate &lt;- 500

# signal length
npts &lt;- 1000

# band-pass
bpass &lt;- c(1, 50)

# Nyquist
fn &lt;- srate / 2
w &lt;- bpass / fn

# ---- FIR filter ------------------------------------------------
order &lt;- 160

# FIR1 is MA filter, a = 1
filter &lt;- fir1(order, w, "pass")

diagnose_filter(
  b = filter$b, a = filter$a, n = npts,
  fs = srate, vlines = bpass
)

# ---- Butter filter --------------------------------------------
filter &lt;- butter(3, w, "pass")

diagnose_filter(
  b = filter$b, a = filter$a, n = npts,
  fs = srate, vlines = bpass
)



</code></pre>

<hr>
<h2 id='dijkstras-path'>Calculate distances along a surface</h2><span id='topic+dijkstras-path'></span><span id='topic+dijkstras_surface_distance'></span><span id='topic+surface_path'></span>

<h3>Description</h3>

<p>Calculate surface distances of graph or mesh using 'Dijkstra' method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dijkstras_surface_distance(
  positions,
  faces,
  start_node,
  face_index_start = NA,
  max_search_distance = NA,
  ...
)

surface_path(x, target_node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dijkstras-path_+3A_positions">positions</code></td>
<td>
<p>numeric matrix with no <code>NA</code> values. The number of row
is the total count of nodes (vertices), and the number of columns represent
the node dimension. Each row represents a node.</p>
</td></tr>
<tr><td><code id="dijkstras-path_+3A_faces">faces</code></td>
<td>
<p>integer matrix with each row containing indices of nodes. For
graphs, <code>faces</code> is a matrix with two columns defining the connecting
edges; for '3D' mesh, <code>faces</code> is a three-column matrix defining the
face index of mesh triangles.</p>
</td></tr>
<tr><td><code id="dijkstras-path_+3A_start_node">start_node</code></td>
<td>
<p>integer, row index of <code>positions</code> on where to start
calculating the distances. This integer must be 1-indexed and cannot exceed
the total number of <code>positions</code> rows</p>
</td></tr>
<tr><td><code id="dijkstras-path_+3A_face_index_start">face_index_start</code></td>
<td>
<p>integer, the start of the nodes in <code>faces</code>;
please specify this input explicitly if the first node is not contained
in <code>faces</code>.
Default is <code>NA</code> (determined by the minimal number in <code>faces</code>).
The reason to set this input is because some programs use <code>1</code> to
represent the first node, some start from <code>0</code>.</p>
</td></tr>
<tr><td><code id="dijkstras-path_+3A_max_search_distance">max_search_distance</code></td>
<td>
<p>numeric, maximum distance to iterate;
default is <code>NA</code>,
that is to iterate and search the whole mesh</p>
</td></tr>
<tr><td><code id="dijkstras-path_+3A_...">...</code></td>
<td>
<p>reserved for backward compatibility</p>
</td></tr>
<tr><td><code id="dijkstras-path_+3A_x">x</code></td>
<td>
<p>distance calculation results returned by
<code>dijkstras_surface_distance</code> function</p>
</td></tr>
<tr><td><code id="dijkstras-path_+3A_target_node">target_node</code></td>
<td>
<p>the target node number to reach (from the starting node);
<code>target_node</code> is always 1-indexed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dijkstras_surface_distance</code> returns a list distance
table with the meta configurations. <code>surface_path</code> returns a data frame
of the node ID (from <code>start_node</code> to <code>target_node</code>) and cumulative
distance along the shortest path.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---- Toy example --------------------

# Position is 2D, total 6 points
positions &lt;- matrix(runif(6 * 2), ncol = 2)

# edges defines connected nodes
edges &lt;- matrix(ncol = 2, byrow = TRUE, data = c(
  1,2,
  2,3,
  1,3,
  2,4,
  3,4,
  2,5,
  4,5,
  2,5,
  4,6,
  5,6
))

# calculate distances
ret &lt;- dijkstras_surface_distance(
  start_node = 1,
  positions = positions,
  faces = edges,
  face_index_start = 1
)

# get shortest path from the first node to the last
path &lt;- surface_path(ret, target_node = 6)

# plot the results
from_node &lt;- path$path[-nrow(path)]
to_node &lt;- path$path[-1]
plot(positions, pch = 16, axes = FALSE,
     xlab = "X", ylab = "Y", main = "Dijkstra's shortest path")
segments(
  x0 = positions[edges[,1],1], y0 = positions[edges[,1],2],
  x1 = positions[edges[,2],1], y1 = positions[edges[,2],2]
)

points(positions[path$path,], col = "steelblue", pch = 16)
arrows(
  x0 = positions[from_node,1], y0 = positions[from_node,2],
  x1 = positions[to_node,1], y1 = positions[to_node,2],
  col = "steelblue", lwd = 2, length = 0.1, lty = 2
)

points(positions[1,,drop=FALSE], pch = 16, col = "orangered")
points(positions[6,,drop=FALSE], pch = 16, col = "purple3")

# ---- Example with mesh ------------------------------------

## Not run: 

  # Please install the down-stream package `threeBrain`
  # and call library(threeBrain)
  # the following code set up the files

  read.fs.surface &lt;- internal_rave_function(
    "read.fs.surface", "threeBrain")
  default_template_directory &lt;- internal_rave_function(
    "default_template_directory", "threeBrain")
  surface_path &lt;- file.path(default_template_directory(),
                            "N27", "surf", "lh.pial")
  if(!file.exists(surface_path)) {
    internal_rave_function(
      "download_N27", "threeBrain")()
  }

  # Example starts from here ---&gt;
  # Load the mesh
  mesh &lt;- read.fs.surface(surface_path)

  # Calculate the path with maximum radius 100
  ret &lt;- dijkstras_surface_distance(
    start_node = 1,
    positions = mesh$vertices,
    faces = mesh$faces,
    max_search_distance = 100,
    verbose = TRUE
  )

  # get shortest path from the first node to node 43144
  path &lt;- surface_path(ret, target_node = 43144)

  # plot
  from_nodes &lt;- path$path[-nrow(path)]
  to_nodes &lt;- path$path[-1]
  # calculate colors
  pal &lt;- colorRampPalette(
    colors = c("red", "orange", "orange3", "purple3", "purple4")
  )(1001)
  col &lt;- pal[ceiling(
    path$distance / max(path$distance, na.rm = TRUE) * 1000
  ) + 1]
  oldpar &lt;- par(mfrow = c(2, 2), mar = c(0, 0, 0, 0))
  for(xdim in c(1, 2, 3)) {
    if( xdim &lt; 3 ) {
      ydim &lt;- xdim + 1
    } else {
      ydim &lt;- 3
      xdim &lt;- 1
    }
    plot(
      mesh$vertices[, xdim], mesh$vertices[, ydim],
      pch = ".", col = "#BEBEBE33", axes = FALSE,
      xlab = "P - A", ylab = "S - I", asp = 1
    )
    segments(
      x0 = mesh$vertices[from_nodes, xdim],
      y0 = mesh$vertices[from_nodes, ydim],
      x1 = mesh$vertices[to_nodes, xdim],
      y1 = mesh$vertices[to_nodes, ydim],
      col = col
    )
  }

  # plot distance map
  distances &lt;- ret$paths$distance
  col &lt;- pal[ceiling(distances / max(distances, na.rm = TRUE) * 1000) + 1]
  selection &lt;- !is.na(distances)

  plot(
    mesh$vertices[, 2], mesh$vertices[, 3],
    pch = ".", col = "#BEBEBE33", axes = FALSE,
    xlab = "P - A", ylab = "S - I", asp = 1
  )
  points(
    mesh$vertices[selection, c(2, 3)],
    col = col[selection],
    pch = "."
  )

  # reset graphic state
  par(oldpar)


## End(Not run)






</code></pre>

<hr>
<h2 id='fast_cov'>Calculate massive covariance matrix in parallel</h2><span id='topic+fast_cov'></span>

<h3>Description</h3>

<p>Speed up covariance calculation for large matrices. The
default behavior is the same as <code><a href="stats.html#topic+cov">cov</a></code> (<code>'pearson'</code>,
no <code>NA</code> handling).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_cov(x, y = NULL, col_x = NULL, col_y = NULL, df = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_cov_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or data frame; a matrix is highly
recommended to maximize the performance</p>
</td></tr>
<tr><td><code id="fast_cov_+3A_y">y</code></td>
<td>
<p>NULL (default) or a vector, matrix or data frame with compatible
dimensions to x; the default is equivalent to <code>y = x</code></p>
</td></tr>
<tr><td><code id="fast_cov_+3A_col_x">col_x</code></td>
<td>
<p>integers indicating the subset indices (columns) of <code>x</code> to
calculate the covariance, or <code>NULL</code> to include all the columns; default
is <code>NULL</code></p>
</td></tr>
<tr><td><code id="fast_cov_+3A_col_y">col_y</code></td>
<td>
<p>integers indicating the subset indices (columns) of <code>y</code> to
calculate the covariance, or <code>NULL</code> to include all the columns; default
is <code>NULL</code></p>
</td></tr>
<tr><td><code id="fast_cov_+3A_df">df</code></td>
<td>
<p>a scalar indicating the degrees of freedom; default is
<code>nrow(x)-1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A covariance matrix of <code>x</code> and <code>y</code>. Note that there is no
<code>NA</code> handling. Any missing values will lead to <code>NA</code> in the
resulting covariance matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set ncores = 2 to comply to CRAN policy. Please don't run this line
ravetools_threads(n_threads = 2L)

x &lt;- matrix(rnorm(400), nrow = 100)

# Call `cov(x)` to compare
fast_cov(x)

# Calculate covariance of subsets
fast_cov(x, col_x = 1, col_y = 1:2)



# Speed comparison, better to use multiple cores (4, 8, or more)
# to show the differences.

ravetools_threads(n_threads = -1)
x &lt;- matrix(rnorm(100000), nrow = 1000)
microbenchmark::microbenchmark(
  fast_cov = {
    fast_cov(x, col_x = 1:50, col_y = 51:100)
  },
  cov = {
    cov(x[,1:50], x[,51:100])
  },
  unit = 'ms', times = 10
)




</code></pre>

<hr>
<h2 id='fast_quantile'>Compute quantiles</h2><span id='topic+fast_quantile'></span><span id='topic+fast_median'></span><span id='topic+fast_mvquantile'></span><span id='topic+fast_mvmedian'></span>

<h3>Description</h3>

<p>Compute quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_quantile(x, prob = 0.5, na.rm = FALSE, ...)

fast_median(x, na.rm = FALSE, ...)

fast_mvquantile(x, prob = 0.5, na.rm = FALSE, ...)

fast_mvmedian(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_quantile_+3A_x">x</code></td>
<td>
<p>numerical-value vector for <code>fast_quantile</code> and
<code>fast_median</code>, and column-major matrix for <code>fast_mvquantile</code> and
<code>fast_mvmedian</code></p>
</td></tr>
<tr><td><code id="fast_quantile_+3A_prob">prob</code></td>
<td>
<p>a probability with value from 0 to 1</p>
</td></tr>
<tr><td><code id="fast_quantile_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if true, any <code>NA</code> are removed from <code>x</code>
before the quantiles are computed</p>
</td></tr>
<tr><td><code id="fast_quantile_+3A_...">...</code></td>
<td>
<p>reserved for future use</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fast_quantile</code> and <code>fast_median</code> calculate univariate
quantiles (single-value return); <code>fast_mvquantile</code> and <code>fast_mvmedian</code>
calculate multivariate quantiles (for each column, result lengths equal to
the number of columns).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fast_quantile(runif(1000), 0.1)
fast_median(1:100)

x &lt;- matrix(rnorm(100), ncol = 2)
fast_mvquantile(x, 0.2)
fast_mvmedian(x)

# Compare speed for vectors (usually 30% faster)
x &lt;- rnorm(10000)
microbenchmark::microbenchmark(
  fast_median = fast_median(x),
  base_median = median(x),
  # bioc_median = Biobase::rowMedians(matrix(x, nrow = 1)),
  times = 100, unit = "milliseconds"
)

# Multivariate cases
# (5~7x faster than base R)
# (3~5x faster than Biobase rowMedians)
x &lt;- matrix(rnorm(100000), ncol = 20)
microbenchmark::microbenchmark(
  fast_median = fast_mvmedian(x),
  base_median = apply(x, 2, median),
  # bioc_median = Biobase::rowMedians(t(x)),
  times = 10, unit = "milliseconds"
)

</code></pre>

<hr>
<h2 id='fill_surface'>Fill a volume cube based on water-tight surface</h2><span id='topic+fill_surface'></span>

<h3>Description</h3>

<p>Create a cube volume (<code>256</code> 'voxels' on each margin), fill
in the 'voxels' that are inside of the surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_surface(
  surface,
  inflate = 0,
  IJK2RAS = NULL,
  preview = FALSE,
  preview_frame = 128
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_surface_+3A_surface">surface</code></td>
<td>
<p>a surface mesh, can be mesh objects from <code>rgl</code> or
<code>freesurferformats</code> packages</p>
</td></tr>
<tr><td><code id="fill_surface_+3A_inflate">inflate</code></td>
<td>
<p>amount of 'voxels' to inflate on the final result; must be
a non-negative integer. A zero <code>inflate</code> value means the resulting
volume is tightly close to the surface</p>
</td></tr>
<tr><td><code id="fill_surface_+3A_ijk2ras">IJK2RAS</code></td>
<td>
<p>volume 'IJK' (zero-indexed coordinate index) to
<code>'tkrRAS'</code> transform, default is automatically determined
leave it &lsquo;NULL' if you don&rsquo;t know how to set it</p>
</td></tr>
<tr><td><code id="fill_surface_+3A_preview">preview</code></td>
<td>
<p>whether to preview the results; default is false</p>
</td></tr>
<tr><td><code id="fill_surface_+3A_preview_frame">preview_frame</code></td>
<td>
<p>integer from 1 to 256 the depth frame used to generate
preview.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a volume (256 on each margin) and fill in
the volume from a surface mesh. The surface vertex points will be embedded
into the volume first. These points may not be connected together, hence
for each 'voxel', a cube patch will be applied to grow the volume. Then,
the volume will be bucket-filled from a corner, forming a negated mask of
&quot;outside-of-surface&quot; area. The inverted bucket-filled volume is then shrunk
so the mask boundary tightly fits the surface
</p>


<h3>Value</h3>

<p>A list containing the filled volume and parameters used to generate
the volume
</p>


<h3>Author(s)</h3>

<p>Zhengjia Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# takes &gt; 5s to run example

# Generate a sphere
surface &lt;- vcg_sphere()
surface$vb[1:3, ] &lt;- surface$vb[1:3, ] * 50

fill_surface(surface, preview = TRUE)



</code></pre>

<hr>
<h2 id='filter_signal'>Filter one-dimensional signal</h2><span id='topic+filter_signal'></span>

<h3>Description</h3>

<p>The function is written from the scratch. The result has been
compared against the 'Matlab' <code>filter</code> function with one-dimensional
real inputs. Other situations such as matrix <code>b</code> or multi-dimensional
<code>x</code> are not implemented. For double filters (forward-backward),
see <code><a href="#topic+filtfilt">filtfilt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_signal(b, a, x, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_signal_+3A_b">b</code></td>
<td>
<p>one-dimensional real numerical vector, the moving-average
coefficients of an <code>ARMA</code> filter</p>
</td></tr>
<tr><td><code id="filter_signal_+3A_a">a</code></td>
<td>
<p>the auto-regressive (recursive) coefficients of an <code>ARMA</code> filter</p>
</td></tr>
<tr><td><code id="filter_signal_+3A_x">x</code></td>
<td>
<p>numerical vector input (real value)</p>
</td></tr>
<tr><td><code id="filter_signal_+3A_z">z</code></td>
<td>
<p>initial condition, must have length of <code>n-1</code>, where <code>n</code>
is the maximum of lengths of <code>a</code> and <code>b</code>; default is all zeros</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two vectors: the first vector is the filtered signal;
the second vector is the final state of <code>z</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

t &lt;- seq(0, 1, by = 0.01)
x &lt;- sin(2 * pi * t * 2.3)
bf &lt;- gsignal::butter(2, c(0.15, 0.3))

res &lt;- filter_signal(bf$b, bf$a, x)
y &lt;- res[[1]]
z &lt;- res[[2]]

## Matlab (2022a) equivalent:
# t = [0:0.01:1];
# x = sin(2 * pi * t * 2.3);
# [b,a] = butter(2,[.15,.3]);
# [y,z] = filter(b, a, x)


</code></pre>

<hr>
<h2 id='filter-window'>Filter window functions</h2><span id='topic+filter-window'></span><span id='topic+hanning'></span><span id='topic+hamming'></span><span id='topic+blackman'></span><span id='topic+blackmannuttall'></span><span id='topic+blackmanharris'></span><span id='topic+flattopwin'></span><span id='topic+bohmanwin'></span>

<h3>Description</h3>

<p>Filter window functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hanning(n)

hamming(n)

blackman(n)

blackmannuttall(n)

blackmanharris(n)

flattopwin(n)

bohmanwin(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter-window_+3A_n">n</code></td>
<td>
<p>number of time-points in window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of window with length <code>n</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hanning(10)
hamming(11)
blackmanharris(21)

</code></pre>

<hr>
<h2 id='filtfilt'>Forward and reverse filter a one-dimensional signal</h2><span id='topic+filtfilt'></span>

<h3>Description</h3>

<p>The result has been tested against 'Matlab' <code>filtfilt</code>
function. Currently this function only supports one filter at a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filtfilt(b, a, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filtfilt_+3A_b">b</code></td>
<td>
<p>one-dimensional real numerical vector, the moving-average
coefficients of an <code>ARMA</code> filter</p>
</td></tr>
<tr><td><code id="filtfilt_+3A_a">a</code></td>
<td>
<p>the auto-regressive (recursive) coefficients of an <code>ARMA</code> filter</p>
</td></tr>
<tr><td><code id="filtfilt_+3A_x">x</code></td>
<td>
<p>numerical vector input (real value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filtered signal, normally the same length as the input signal
<code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t &lt;- seq(0, 1, by = 0.01)
x &lt;- sin(2 * pi * t * 2.3)
bf &lt;- gsignal::butter(2, c(0.15, 0.3))

res &lt;- filtfilt(bf$b, bf$a, x)

## Matlab (2022a) equivalent:
# t = [0:0.01:1];
# x = sin(2 * pi * t * 2.3);
# [b,a] = butter(2,[.15,.3]);
# res = filtfilt(b, a, x)

</code></pre>

<hr>
<h2 id='fir1'>Window-based <code>FIR</code> filter design</h2><span id='topic+fir1'></span>

<h3>Description</h3>

<p>Generate a <code>fir1</code> filter that is checked against <code>Matlab</code>
<code>fir1</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fir1(
  n,
  w,
  type = c("low", "high", "stop", "pass", "DC-0", "DC-1"),
  window = hamming,
  scale = TRUE,
  hilbert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fir1_+3A_n">n</code></td>
<td>
<p>filter order</p>
</td></tr>
<tr><td><code id="fir1_+3A_w">w</code></td>
<td>
<p>band edges, non-decreasing vector in the range 0 to 1, where 1 is
the <code>Nyquist</code> frequency. A scalar for high-pass or low-pass filters,
a vector pair for band-pass or band-stop, or a vector for an
alternating pass/stop filter.</p>
</td></tr>
<tr><td><code id="fir1_+3A_type">type</code></td>
<td>
<p>type of the filter, one of <code>"low"</code> for a low-pass filter,
<code>"high"</code> for a high-pass filter, <code>"stop"</code> for a stop-band
(band-reject) filter, <code>"pass"</code> for a pass-band filter, <code>"DC-0"</code>
for a band-pass as the first band of a multi-band filter, or <code>"DC-1"</code>
for a band-stop as the first band of a multi-band filter; default <code>"low"</code></p>
</td></tr>
<tr><td><code id="fir1_+3A_window">window</code></td>
<td>
<p>smoothing window function or a numerical vector. The filter is
the same shape as the smoothing window. When <code>window</code> is a function,
<code>window(n+1)</code> will be called, otherwise the length of the window
vector needs to have length of <code>n+1</code>; default: <code>hamming</code></p>
</td></tr>
<tr><td><code id="fir1_+3A_scale">scale</code></td>
<td>
<p>whether to scale the filter; default is true</p>
</td></tr>
<tr><td><code id="fir1_+3A_hilbert">hilbert</code></td>
<td>
<p>whether to use 'Hilbert' transformer; default is false</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>FIR</code> filter coefficients with class <code>'Arma'</code>.
The moving average coefficient is a vector of length <code>n+1</code>.
</p>

<hr>
<h2 id='firls'>Least-squares linear-phase <code>FIR</code> filter design</h2><span id='topic+firls'></span>

<h3>Description</h3>

<p>Produce a linear phase filter from the weighted mean squared such that error
in the specified bands is minimized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firls(N, freq, A, W = NULL, ftype = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="firls_+3A_n">N</code></td>
<td>
<p>filter order, must be even (if odd, then will be increased by one)</p>
</td></tr>
<tr><td><code id="firls_+3A_freq">freq</code></td>
<td>
<p>vector of frequency points in the range from 0 to 1, where 1
corresponds to the <code>Nyquist</code> frequency.</p>
</td></tr>
<tr><td><code id="firls_+3A_a">A</code></td>
<td>
<p>vector of the same length as <code>freq</code> containing the desired
amplitude at each of the points specified in <code>freq</code>.</p>
</td></tr>
<tr><td><code id="firls_+3A_w">W</code></td>
<td>
<p>weighting function that contains one value for each band that
weights the mean squared error in that band. <code>W</code> must be half the
length of <code>freq</code>.</p>
</td></tr>
<tr><td><code id="firls_+3A_ftype">ftype</code></td>
<td>
<p>transformer type; default is <code>""</code>; alternatively,
<code>'h'</code> or <code>'hilbert'</code> for 'Hilbert' transformer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>FIR</code> filter coefficients with class <code>'Arma'</code>.
The moving average coefficient is a vector of length <code>n+1</code>.
</p>

<hr>
<h2 id='freqz2'>Frequency response of digital filter</h2><span id='topic+freqz2'></span>

<h3>Description</h3>

<p>Compute the z-plane frequency response of an <code>ARMA</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqz2(b, a = 1, fs = 2 * pi, n = 512, whole = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="freqz2_+3A_b">b</code></td>
<td>
<p>the moving-average coefficients of an <code>ARMA</code> model</p>
</td></tr>
<tr><td><code id="freqz2_+3A_a">a</code></td>
<td>
<p>the auto-regressive coefficients of an <code>ARMA</code> filter; default
is <code>1</code></p>
</td></tr>
<tr><td><code id="freqz2_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in <code>Hz</code></p>
</td></tr>
<tr><td><code id="freqz2_+3A_n">n</code></td>
<td>
<p>number of points at which to evaluate the frequency response;
default is <code>512</code></p>
</td></tr>
<tr><td><code id="freqz2_+3A_whole">whole</code></td>
<td>
<p>whether to evaluate beyond <code>Nyquist</code> frequency; default
is false</p>
</td></tr>
<tr><td><code id="freqz2_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of frequencies and corresponding responses in complex vector
</p>

<hr>
<h2 id='grow_volume'>Grow volume mask</h2><span id='topic+grow_volume'></span>

<h3>Description</h3>

<p>Grow volume mask
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_volume(volume, x, y = x, z = x, threshold = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grow_volume_+3A_volume">volume</code></td>
<td>
<p>volume mask array, must be 3-dimensional array</p>
</td></tr>
<tr><td><code id="grow_volume_+3A_x">x</code>, <code id="grow_volume_+3A_y">y</code>, <code id="grow_volume_+3A_z">z</code></td>
<td>
<p>size of grow along each direction</p>
</td></tr>
<tr><td><code id="grow_volume_+3A_threshold">threshold</code></td>
<td>
<p>threshold after convolution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary volume mask
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

oldpar &lt;- par(mfrow = c(2,3), mar = c(0.1,0.1,3.1,0.1))

mask &lt;- array(0, c(21,21,21))
mask[11,11,11] &lt;- 1
image(mask[11,,], asp = 1,
      main = "Original mask", axes = FALSE)
image(grow_volume(mask, 2)[11,,], asp = 1,
      main = "Dilated (size=2) mask", axes = FALSE)
image(grow_volume(mask, 5)[11,,], asp = 1,
      main = "Dilated (size=5) mask", axes = FALSE)

mask[11, sample(11,2), sample(11,2)] &lt;- 1
image(mask[11,,], asp = 1,
      main = "Original mask", axes = FALSE)
image(grow_volume(mask, 2)[11,,], asp = 1,
      main = "Dilated (size=2) mask", axes = FALSE)
image(grow_volume(mask, 5)[11,,], asp = 1,
      main = "Dilated (size=5) mask", axes = FALSE)

par(oldpar)


</code></pre>

<hr>
<h2 id='internal_rave_function'>Get external function from 'RAVE'</h2><span id='topic+internal_rave_function'></span>

<h3>Description</h3>

<p>Internal function used for examples relative to 'RAVE' project and should
not be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>internal_rave_function(name, pkg, inherit = TRUE, on_missing = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internal_rave_function_+3A_name">name</code></td>
<td>
<p>function or variable name</p>
</td></tr>
<tr><td><code id="internal_rave_function_+3A_pkg">pkg</code></td>
<td>
<p>'RAVE' package name</p>
</td></tr>
<tr><td><code id="internal_rave_function_+3A_inherit">inherit</code></td>
<td>
<p>passed to <code><a href="base.html#topic+get0">get0</a></code></p>
</td></tr>
<tr><td><code id="internal_rave_function_+3A_on_missing">on_missing</code></td>
<td>
<p>default value to return of no function is found</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function object if found, otherwise <code>on_missing</code>.
</p>

<hr>
<h2 id='interpolate_stimulation'>Find and interpolate stimulation signals</h2><span id='topic+interpolate_stimulation'></span>

<h3>Description</h3>

<p>Find and interpolate stimulation signals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_stimulation(
  x,
  sample_rate,
  duration = 40/sample_rate,
  ord = 4L,
  nknots = 100,
  nsd = 1,
  nstim = NULL,
  regularization = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate_stimulation_+3A_x">x</code></td>
<td>
<p>numerical vector representing a analog signal</p>
</td></tr>
<tr><td><code id="interpolate_stimulation_+3A_sample_rate">sample_rate</code></td>
<td>
<p>sampling frequency</p>
</td></tr>
<tr><td><code id="interpolate_stimulation_+3A_duration">duration</code></td>
<td>
<p>time in second: duration of interpolation</p>
</td></tr>
<tr><td><code id="interpolate_stimulation_+3A_ord">ord</code></td>
<td>
<p>spline order, default is 4</p>
</td></tr>
<tr><td><code id="interpolate_stimulation_+3A_nknots">nknots</code></td>
<td>
<p>a rough number of knots to use, default is 100</p>
</td></tr>
<tr><td><code id="interpolate_stimulation_+3A_nsd">nsd</code></td>
<td>
<p>number of standard deviation to detect stimulation signals, default is 1</p>
</td></tr>
<tr><td><code id="interpolate_stimulation_+3A_nstim">nstim</code></td>
<td>
<p>number of stimulation pulses, default is to auto-detect</p>
</td></tr>
<tr><td><code id="interpolate_stimulation_+3A_regularization">regularization</code></td>
<td>
<p>regularization parameter in case of inverting singular matrices, default is 0.5</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Interpolated signal with an attribute of which sample points are interpolated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x0 &lt;- rnorm(1000) / 5 + sin(1:1000 / 300)

# Simulates pulase signals
x &lt;- x0
x[400:410] &lt;- -100
x[420:430] &lt;- 100

fitted &lt;- interpolate_stimulation(x, 100, duration = 0.3, nknots = 10, nsd = 2)

oldpar &lt;- par(mfrow = c(2, 1))

plot(fitted, type = 'l', col = 'blue', lwd = 2)
lines(x, col = 'red')
lines(x0, col = 'black')
legend("topleft", c("Interpolated", "Observed", "Underlying"),
       lty = 1, col = c("blue", "red", "black"))

pwelch(x0, 100, 200, 100, plot = 1, col = 'black', ylim = c(-50, 50))
pwelch(x, 100, 200, 100, plot = 2, col = 'red')
pwelch(fitted, 100, 200, 100, plot = 2, col = 'blue')

par(oldpar)


</code></pre>

<hr>
<h2 id='is_not_cran'>Internal function</h2><span id='topic+is_not_cran'></span>

<h3>Description</h3>

<p>Do not call this function directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_not_cran(if_interactive = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_not_cran_+3A_if_interactive">if_interactive</code>, <code id="is_not_cran_+3A_verbose">verbose</code></td>
<td>
<p>default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='left_hippocampus_mask'>Left 'Hippocampus' of 'N27-Collin' brain</h2><span id='topic+left_hippocampus_mask'></span>

<h3>Description</h3>

<p>Left 'Hippocampus' of 'N27-Collin' brain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>left_hippocampus_mask
</code></pre>


<h3>Format</h3>

<p>A three-mode integer mask array with values of <code>1</code> ('Hippocampus')
and <code>0</code> (other brain tissues)
</p>

<hr>
<h2 id='matlab_palette'>'Matlab' heat-map plot palette</h2><span id='topic+matlab_palette'></span>

<h3>Description</h3>

<p>'Matlab' heat-map plot palette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matlab_palette()
</code></pre>


<h3>Value</h3>

<p>vector of 64 colors
</p>

<hr>
<h2 id='mesh_from_volume'>Generate 3D mesh surface from volume data</h2><span id='topic+mesh_from_volume'></span>

<h3>Description</h3>

<p>This function is soft-deprecated. Please use
<code><a href="#topic+vcg_mesh_volume">vcg_mesh_volume</a></code>, <code><a href="#topic+vcg_uniform_remesh">vcg_uniform_remesh</a></code>, and
<code><a href="#topic+vcg_smooth_explicit">vcg_smooth_explicit</a></code> or <code><a href="#topic+vcg_smooth_implicit">vcg_smooth_implicit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh_from_volume(
  volume,
  output_format = c("rgl", "freesurfer"),
  IJK2RAS = NULL,
  threshold = 0,
  verbose = TRUE,
  remesh = TRUE,
  remesh_voxel_size = 1,
  remesh_multisample = TRUE,
  remesh_automerge = TRUE,
  smooth = FALSE,
  smooth_lambda = 10,
  smooth_delta = 20,
  smooth_method = "surfPreserveLaplace"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh_from_volume_+3A_volume">volume</code></td>
<td>
<p>3-dimensional volume array</p>
</td></tr>
<tr><td><code id="mesh_from_volume_+3A_output_format">output_format</code></td>
<td>
<p>resulting data format, choices are <code>'rgl'</code> and
<code>'freesurfer'</code></p>
</td></tr>
<tr><td><code id="mesh_from_volume_+3A_ijk2ras">IJK2RAS</code></td>
<td>
<p>volume 'IJK' (zero-indexed coordinate index) to
<code>'tkrRAS'</code> transform, default is automatically determined</p>
</td></tr>
<tr><td><code id="mesh_from_volume_+3A_threshold">threshold</code></td>
<td>
<p>threshold used to create volume mask; the surface will be
created to fit the mask boundaries</p>
</td></tr>
<tr><td><code id="mesh_from_volume_+3A_verbose">verbose</code></td>
<td>
<p>whether to verbose the progress</p>
</td></tr>
<tr><td><code id="mesh_from_volume_+3A_remesh">remesh</code></td>
<td>
<p>whether to re-sample the mesh using <code><a href="#topic+vcg_uniform_remesh">vcg_uniform_remesh</a></code></p>
</td></tr>
<tr><td><code id="mesh_from_volume_+3A_remesh_voxel_size">remesh_voxel_size</code>, <code id="mesh_from_volume_+3A_remesh_multisample">remesh_multisample</code>, <code id="mesh_from_volume_+3A_remesh_automerge">remesh_automerge</code></td>
<td>
<p>see
arguments in <code><a href="#topic+vcg_uniform_remesh">vcg_uniform_remesh</a></code></p>
</td></tr>
<tr><td><code id="mesh_from_volume_+3A_smooth">smooth</code></td>
<td>
<p>whether to smooth the mesh via <code><a href="#topic+vcg_smooth_explicit">vcg_smooth_explicit</a></code></p>
</td></tr>
<tr><td><code id="mesh_from_volume_+3A_smooth_lambda">smooth_lambda</code>, <code id="mesh_from_volume_+3A_smooth_delta">smooth_delta</code>, <code id="mesh_from_volume_+3A_smooth_method">smooth_method</code></td>
<td>
<p>see <code><a href="#topic+vcg_smooth_explicit">vcg_smooth_explicit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>'mesh3d'</code> surface if <code>output_format</code> is 'rgl', or
<code>'fs.surface'</code> surface otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

volume &lt;- array(0, dim = c(8,8,8))
volume[4:5, 4:5, 4:5] &lt;- 1

graphics::image(x = volume[4,,])

# you can use rgl::wire3d(mesh) to visualize the mesh
mesh &lt;- mesh_from_volume(volume, verbose = FALSE)


</code></pre>

<hr>
<h2 id='multitaper'>Compute 'multitaper' spectral densities of time-series data</h2><span id='topic+multitaper'></span><span id='topic+multitaper_config'></span>

<h3>Description</h3>

<p>Compute 'multitaper' spectral densities of time-series data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multitaper_config(
  data_length,
  fs,
  frequency_range = NULL,
  time_bandwidth = 5,
  num_tapers = NULL,
  window_params = c(5, 1),
  nfft = NA,
  detrend_opt = "linear"
)

multitaper(
  data,
  fs,
  frequency_range = NULL,
  time_bandwidth = 5,
  num_tapers = NULL,
  window_params = c(5, 1),
  nfft = NA,
  detrend_opt = "linear"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multitaper_+3A_data_length">data_length</code></td>
<td>
<p>length of data</p>
</td></tr>
<tr><td><code id="multitaper_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in 'Hz'</p>
</td></tr>
<tr><td><code id="multitaper_+3A_frequency_range">frequency_range</code></td>
<td>
<p>frequency range to look at; length of two</p>
</td></tr>
<tr><td><code id="multitaper_+3A_time_bandwidth">time_bandwidth</code></td>
<td>
<p>a number indicating time-half bandwidth product; i.e.
the window duration times the half bandwidth of main lobe; default is
<code>5</code></p>
</td></tr>
<tr><td><code id="multitaper_+3A_num_tapers">num_tapers</code></td>
<td>
<p>number of 'DPSS' tapers to use; default is <code>NULL</code> and
will be automatically computed from <code>floor(2*time_bandwidth - 1)</code></p>
</td></tr>
<tr><td><code id="multitaper_+3A_window_params">window_params</code></td>
<td>
<p>vector of two numbers; the first number is the
window size in seconds; the second number if the step size; default is
<code>c(5, 1)</code></p>
</td></tr>
<tr><td><code id="multitaper_+3A_nfft">nfft</code></td>
<td>
<p>'NFFT' size, positive; see 'Details'</p>
</td></tr>
<tr><td><code id="multitaper_+3A_detrend_opt">detrend_opt</code></td>
<td>
<p>how you want to remove the trend from data window; options
are <code>'linear'</code> (default), <code>'constant'</code>, and <code>'off'</code></p>
</td></tr>
<tr><td><code id="multitaper_+3A_data">data</code></td>
<td>
<p>numerical vector, signal traces</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original source code comes from 'Prerau' Lab (see 'Github'
repository <code>'multitaper_toolbox'</code> under user <code>'preraulab'</code>).
The results tend to agree with their 'Python' implementation with precision
on the order of at <code>1E-7</code> with standard deviation at most <code>1E-5</code>.
The original copy was licensed under a Creative Commons Attribution
'NC'-'SA' 4.0 International License
(<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">https://creativecommons.org/licenses/by-nc-sa/4.0/</a>).
</p>
<p>This package (<code>'ravetools'</code>) redistributes the <code>multitaper</code>
function under minor modifications on <code>nfft</code>. In the original copy
there is no parameter to control the exact numbers of <code>nfft</code>, and
the <code>nfft</code> is always the power of 2. While choosing
<code>nfft</code> to be the power of 2 is always recommended, the modified code
allows other choices.
</p>


<h3>Value</h3>

<p><code>multitaper_config</code> returns a list of configuration parameters
for the filters; <code>multitaper</code> also returns the time, frequency and
corresponding spectral power.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Takes long to run

time &lt;- seq(0, 3, by = 0.001)
x &lt;- sin(time * 20*pi) + exp(-time^2) * cos(time * 10*pi)

res &lt;- multitaper(
  x, 1000, frequency_range = c(0,15),
  time_bandwidth=1.5,
  window_params=c(2,0.01)
)


image(
  x = res$time,
  y = res$frequency,
  z = 10 * log10(res$spec),
  xlab = "Time (s)",
  ylab = 'Frequency (Hz)',
  col = matlab_palette()
)



</code></pre>

<hr>
<h2 id='new_matrix4'>Create a <code>Matrix4</code> instance for <code>'Affine'</code> transform</h2><span id='topic+new_matrix4'></span><span id='topic+as_matrix4'></span>

<h3>Description</h3>

<p>Create a <code>Matrix4</code> instance for <code>'Affine'</code> transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_matrix4()

as_matrix4(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_matrix4_+3A_m">m</code></td>
<td>
<p>a matrix or a vector to be converted to the <code>Matrix4</code> instance;
<code>m</code> must be one of the followings: for matrices, the dimension must be
<code>4x4</code>, <code>3x4</code> (the last row will be <code>0 0 0 1</code>), or
<code>3x3</code> (linear transform); for vectors, the length must be
<code>16</code>, <code>12</code> (will append <code>0 0 0 1</code> internally),
<code>3</code> (translation), or <code>1</code> (scale).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Matrix4</code> instance
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_vector3">new_vector3</a></code>, <code><a href="#topic+new_quaternion">new_quaternion</a></code>
</p>

<hr>
<h2 id='new_quaternion'>Create a <code>Quaternion</code> instance to store '3D' rotation</h2><span id='topic+new_quaternion'></span><span id='topic+as_quaternion'></span>

<h3>Description</h3>

<p>Create instances that mimic the <code>'three.js'</code> syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_quaternion(x = 0, y = 0, z = 0, w = 1)

as_quaternion(q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_quaternion_+3A_x">x</code>, <code id="new_quaternion_+3A_y">y</code>, <code id="new_quaternion_+3A_z">z</code>, <code id="new_quaternion_+3A_w">w</code></td>
<td>
<p>numeric of length one</p>
</td></tr>
<tr><td><code id="new_quaternion_+3A_q">q</code></td>
<td>
<p>R object to be converted to <code>Quaternion</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Quaternion</code> instance
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_vector3">new_vector3</a></code>, <code><a href="#topic+new_matrix4">new_matrix4</a></code>
</p>

<hr>
<h2 id='new_vector3'>Create a <code>Vector3</code> instance to store '3D' points</h2><span id='topic+new_vector3'></span><span id='topic+as_vector3'></span>

<h3>Description</h3>

<p>Create instances that mimic the <code>'three.js'</code> syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_vector3(x = 0, y = 0, z = 0)

as_vector3(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_vector3_+3A_x">x</code>, <code id="new_vector3_+3A_y">y</code>, <code id="new_vector3_+3A_z">z</code></td>
<td>
<p>numeric, must have the same length, <code>'xyz'</code> positions</p>
</td></tr>
<tr><td><code id="new_vector3_+3A_v">v</code></td>
<td>
<p>R object to be converted to <code>Vector3</code> instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Vector3</code> instance
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_matrix4">new_matrix4</a></code>, <code><a href="#topic+new_quaternion">new_quaternion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vec3 &lt;- new_vector3(
  x = 1:9,
  y = 9:1,
  z = rep(c(1,2,3), 3)
)

vec3[]

# transform
m &lt;- new_matrix4()

# rotation xy plane by 30 degrees
m$make_rotation_z(pi / 6)

vec3$apply_matrix4(m)

vec3[]

as_vector3(c(1,2,3))

</code></pre>

<hr>
<h2 id='notch_filter'>Apply 'Notch' filter</h2><span id='topic+notch_filter'></span>

<h3>Description</h3>

<p>Apply 'Notch' filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>notch_filter(
  s,
  sample_rate,
  lb = c(59, 118, 178),
  ub = c(61, 122, 182),
  domain = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="notch_filter_+3A_s">s</code></td>
<td>
<p>numerical vector if <code>domain=1</code> (voltage
signals), or complex vector if <code>domain=0</code></p>
</td></tr>
<tr><td><code id="notch_filter_+3A_sample_rate">sample_rate</code></td>
<td>
<p>sample rate</p>
</td></tr>
<tr><td><code id="notch_filter_+3A_lb">lb</code></td>
<td>
<p>filter lower bound of the frequencies to remove</p>
</td></tr>
<tr><td><code id="notch_filter_+3A_ub">ub</code></td>
<td>
<p>filter upper bound of the frequencies to remove;
shares the same length as <code>lb</code></p>
</td></tr>
<tr><td><code id="notch_filter_+3A_domain">domain</code></td>
<td>
<p><code>1</code> if the input signal is in the
time domain, <code>0</code> if it is in the frequency domain</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mainly used to remove electrical line frequencies
at 60, 120, and 180 <code>Hz</code>.
</p>


<h3>Value</h3>

<p>filtered signal in time domain (real numerical
vector)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

time &lt;- seq(0, 3, 0.005)
s &lt;- sin(120 * pi * time) + rnorm(length(time))

# Welch periodogram shows a peak at 60Hz
pwelch(s, 200, plot = 1, log = "y")

# notch filter to remove 60Hz
s1 &lt;- notch_filter(s, 200, lb = 59, ub = 61)
pwelch(s1, 200, plot = 2, log = "y", col = "red")


</code></pre>

<hr>
<h2 id='parallel-options'>Set or get thread options</h2><span id='topic+parallel-options'></span><span id='topic+detect_threads'></span><span id='topic+ravetools_threads'></span>

<h3>Description</h3>

<p>Set or get thread options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_threads()

ravetools_threads(n_threads = "auto", stack_size = "auto")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parallel-options_+3A_n_threads">n_threads</code></td>
<td>
<p>number of threads to set</p>
</td></tr>
<tr><td><code id="parallel-options_+3A_stack_size">stack_size</code></td>
<td>
<p>Stack size (in bytes) to use for worker threads. The
default used for <code>"auto"</code> is 2MB on 32-bit systems and 4MB on 64-bit
systems.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>detect_threads</code> returns an integer of default threads that
is determined by the number of <code>CPU</code> cores; <code>ravetools_threads</code>
returns nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
detect_threads()

ravetools_threads(n_threads = 2)

</code></pre>

<hr>
<h2 id='plot_signals'>Plot one or more signal traces in the same figure</h2><span id='topic+plot_signals'></span>

<h3>Description</h3>

<p>Plot one or more signal traces in the same figure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_signals(
  signals,
  sample_rate = 1,
  col = graphics::par("fg"),
  space = 0.995,
  space_mode = c("quantile", "absolute"),
  start_time = 0,
  duration = NULL,
  compress = TRUE,
  channel_names = NULL,
  time_shift = 0,
  xlab = "Time (s)",
  ylab = "Electrode",
  lwd = 0.5,
  new_plot = TRUE,
  xlim = NULL,
  cex = 1,
  cex.lab = 1,
  mar = c(3.1, 2.1, 2.1, 0.8) * (0.25 + cex * 0.75) + 0.1,
  mgp = cex * c(2, 0.5, 0),
  xaxs = "r",
  yaxs = "i",
  xline = 1.5 * cex,
  yline = 1 * cex,
  tck = -0.005 * (3 + cex),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_signals_+3A_signals">signals</code></td>
<td>
<p>numerical matrix with each row to be a signal trace and each
column contains the signal values at a time point</p>
</td></tr>
<tr><td><code id="plot_signals_+3A_sample_rate">sample_rate</code></td>
<td>
<p>sampling frequency</p>
</td></tr>
<tr><td><code id="plot_signals_+3A_col">col</code></td>
<td>
<p>signal color, can be vector of one or more</p>
</td></tr>
<tr><td><code id="plot_signals_+3A_space">space</code></td>
<td>
<p>vertical spacing among the traces; for values greater than 1,
the spacing is absolute; default is <code>0.995</code>; for values less equal to 1,
this is the percentile of the whole data. However, the quantile mode can be
manually turned off is <code>"absolute"</code> is required; see <code>space_mode</code></p>
</td></tr>
<tr><td><code id="plot_signals_+3A_space_mode">space_mode</code></td>
<td>
<p>mode of spacing, only used when <code>space</code> is less equal
to one; default is quantile</p>
</td></tr>
<tr><td><code id="plot_signals_+3A_start_time">start_time</code></td>
<td>
<p>the time to start drawing relative to the first column</p>
</td></tr>
<tr><td><code id="plot_signals_+3A_duration">duration</code></td>
<td>
<p>duration of the signal to draw</p>
</td></tr>
<tr><td><code id="plot_signals_+3A_compress">compress</code></td>
<td>
<p>whether to compress signals if the data is too large</p>
</td></tr>
<tr><td><code id="plot_signals_+3A_channel_names">channel_names</code></td>
<td>
<p><code>NULL</code> or a character vector of channel names</p>
</td></tr>
<tr><td><code id="plot_signals_+3A_time_shift">time_shift</code></td>
<td>
<p>the actual start time of the signal. Unlike
<code>start_time</code>, this should be the actual physical time represented
by the first column</p>
</td></tr>
<tr><td><code id="plot_signals_+3A_xlab">xlab</code>, <code id="plot_signals_+3A_ylab">ylab</code>, <code id="plot_signals_+3A_lwd">lwd</code>, <code id="plot_signals_+3A_xlim">xlim</code>, <code id="plot_signals_+3A_cex">cex</code>, <code id="plot_signals_+3A_cex.lab">cex.lab</code>, <code id="plot_signals_+3A_mar">mar</code>, <code id="plot_signals_+3A_mgp">mgp</code>, <code id="plot_signals_+3A_xaxs">xaxs</code>, <code id="plot_signals_+3A_yaxs">yaxs</code>, <code id="plot_signals_+3A_tck">tck</code>, <code id="plot_signals_+3A_...">...</code></td>
<td>
<p>plot
parameters; see <code><a href="base.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot_signals_+3A_new_plot">new_plot</code></td>
<td>
<p>whether to draw a new plot; default is true</p>
</td></tr>
<tr><td><code id="plot_signals_+3A_xline">xline</code>, <code id="plot_signals_+3A_yline">yline</code></td>
<td>
<p>the gap between axis and label</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

n &lt;- 1000
base_signal &lt;- c(rep(0, n/2), sin(seq(0,10,length.out = n/2))) * 10
signals &lt;- rbind(rnorm(n) + base_signal,
                 rbinom(n, 10, 0.3) + base_signal,
                 rt(n, 5) + base_signal)
plot_signals(signals, sample_rate = 100)
plot_signals(signals, sample_rate = 100, start_time = 5)
plot_signals(signals, sample_rate = 100,
             start_time = 5, time_shift = 100)


</code></pre>

<hr>
<h2 id='pwelch'>Calculate 'Welch Periodogram'</h2><span id='topic+pwelch'></span><span id='topic+print.ravetools-pwelch'></span><span id='topic+plot.ravetools-pwelch'></span><span id='topic+mv_pwelch'></span>

<h3>Description</h3>

<p><code>pwelch</code> is for single signal trace only; <code>mv_pwelch</code>
is for multiple traces. Currently <code>mv_pwelch</code> is experimental and
should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwelch(
  x,
  fs,
  window = 64,
  noverlap = window/2,
  nfft = "auto",
  window_family = hamming,
  col = "black",
  xlim = NULL,
  ylim = NULL,
  main = "Welch periodogram",
  plot = 0,
  log = c("xy", "", "x", "y"),
  ...
)

## S3 method for class ''ravetools-pwelch''
print(x, ...)

## S3 method for class ''ravetools-pwelch''
plot(
  x,
  log = c("xy", "x", "y", ""),
  se = FALSE,
  xticks,
  type = "l",
  add = FALSE,
  col = graphics::par("fg"),
  col.se = "orange",
  alpha.se = 0.5,
  lty = 1,
  lwd = 1,
  cex = 1,
  las = 1,
  main = "Welch periodogram",
  xlab,
  ylab,
  xlim = NULL,
  ylim = NULL,
  xaxs = "i",
  yaxs = "i",
  xline = 1.2 * cex,
  yline = 2 * cex,
  mar = c(2.6, 3.8, 2.1, 0.6) * (0.5 + cex/2),
  mgp = cex * c(2, 0.5, 0),
  tck = -0.02 * cex,
  grid = TRUE,
  ...
)

mv_pwelch(
  x,
  margin,
  fs,
  window = 64,
  noverlap = window/2,
  nfft = "auto",
  window_family = hamming
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pwelch_+3A_x">x</code></td>
<td>
<p>numerical vector or a row-major vector, signals.
If <code>x</code> is a matrix, then each row is a channel. For <code>plot</code>
function, <code>x</code> is the instance returned by <code>pwelch</code> function.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_fs">fs</code></td>
<td>
<p>sample rate, average number of time points per second</p>
</td></tr>
<tr><td><code id="pwelch_+3A_window">window</code></td>
<td>
<p>window length in time points, default size is <code>64</code></p>
</td></tr>
<tr><td><code id="pwelch_+3A_noverlap">noverlap</code></td>
<td>
<p>overlap between two adjacent windows, measured in time
points; default is half of the <code>window</code></p>
</td></tr>
<tr><td><code id="pwelch_+3A_nfft">nfft</code></td>
<td>
<p>number of points in window function; default is automatically
determined from input data and window, scaled up to the nearest power of 2</p>
</td></tr>
<tr><td><code id="pwelch_+3A_window_family">window_family</code></td>
<td>
<p>function generator for generating filter windows,
default is <code><a href="#topic+hamming">hamming</a></code>. This can be any window function listed in
the filter window family, or any window generator function from package
<code>gsignal</code>. Default is <code><a href="#topic+hamming">hamming</a></code>. For 'iEEG' users, both
<code>hamming</code> and <code><a href="#topic+blackmanharris">blackmanharris</a></code> are offered by 'EEG-lab';
while <code>blackmanharris</code> offers better attenuation than Hamming windows,
it also has lower spectral resolution. <code>hamming</code> has a 42.5 dB side-lobe
attenuation. This may mask spectral content below this value (relative
to the peak spectral content). Choosing different windows enables
you to make trade-off between resolution (e.g., using a rectangular
window) and side-lobe attenuation (e.g., using a <code><a href="#topic+hanning">hanning</a></code>
window)</p>
</td></tr>
<tr><td><code id="pwelch_+3A_col">col</code>, <code id="pwelch_+3A_xlim">xlim</code>, <code id="pwelch_+3A_ylim">ylim</code>, <code id="pwelch_+3A_main">main</code>, <code id="pwelch_+3A_type">type</code>, <code id="pwelch_+3A_cex">cex</code>, <code id="pwelch_+3A_las">las</code>, <code id="pwelch_+3A_xlab">xlab</code>, <code id="pwelch_+3A_ylab">ylab</code>, <code id="pwelch_+3A_lty">lty</code>, <code id="pwelch_+3A_lwd">lwd</code>, <code id="pwelch_+3A_xaxs">xaxs</code>, <code id="pwelch_+3A_yaxs">yaxs</code>, <code id="pwelch_+3A_mar">mar</code>, <code id="pwelch_+3A_mgp">mgp</code>, <code id="pwelch_+3A_tck">tck</code></td>
<td>
<p>parameters passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="pwelch_+3A_plot">plot</code></td>
<td>
<p>integer, whether to plot the result or not; choices are <code>0</code>, no plot; <code>1</code> plot on a new canvas; <code>2</code> add to existing canvas</p>
</td></tr>
<tr><td><code id="pwelch_+3A_log">log</code></td>
<td>
<p>indicates which axis should be <code>log10</code>-transformed, used by the plot function. For <code>'x'</code> axis, it's <code>log10</code>-transform; for <code>'y'</code> axis, it's <code>10log10</code>-transform (decibel unit). Choices are <code>"xy"</code>, <code>"x"</code>, <code>"y"</code>, and <code>""</code>.</p>
</td></tr>
<tr><td><code id="pwelch_+3A_...">...</code></td>
<td>
<p>will be passed to <code>plot.pwelch</code> or ignored</p>
</td></tr>
<tr><td><code id="pwelch_+3A_se">se</code></td>
<td>
<p>logical or a positive number indicating whether to plot standard
error of mean; default is false. If provided with a number, then a multiple
of standard error will be drawn. This option is only available when power
is in log-scale (decibel unit)</p>
</td></tr>
<tr><td><code id="pwelch_+3A_xticks">xticks</code></td>
<td>
<p>ticks to show on frequency axis</p>
</td></tr>
<tr><td><code id="pwelch_+3A_add">add</code></td>
<td>
<p>logical, whether the plot should be added to existing canvas</p>
</td></tr>
<tr><td><code id="pwelch_+3A_col.se">col.se</code>, <code id="pwelch_+3A_alpha.se">alpha.se</code></td>
<td>
<p>controls the color and opacity of the standard error</p>
</td></tr>
<tr><td><code id="pwelch_+3A_xline">xline</code>, <code id="pwelch_+3A_yline">yline</code></td>
<td>
<p>controls how close the axis labels to the corresponding axes</p>
</td></tr>
<tr><td><code id="pwelch_+3A_grid">grid</code></td>
<td>
<p>whether to draw rectangular grid lines to the plot; only
respected when <code>add=FALSE</code>; default is true</p>
</td></tr>
<tr><td><code id="pwelch_+3A_margin">margin</code></td>
<td>
<p>the margin in which <code>pwelch</code> should be applied to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>'ravetools-pwelch'</code> that contains the
following items:
</p>

<dl>
<dt><code>freq</code></dt><dd><p>frequencies used to calculate the 'periodogram'</p>
</dd>
<dt><code>spec</code></dt><dd><p>resulting spectral power for each frequency</p>
</dd>
<dt><code>window</code></dt><dd><p>window function (in numerical vector) used</p>
</dd>
<dt><code>noverlap</code></dt><dd><p>number of overlapping time-points between two adjacent windows</p>
</dd>
<dt><code>nfft</code></dt><dd><p>number of basis functions</p>
</dd>
<dt><code>fs</code></dt><dd><p>sample rate</p>
</dd>
<dt><code>x_len</code></dt><dd><p>input signal length</p>
</dd>
<dt><code>method</code></dt><dd><p>a character string <code>'Welch'</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(1000)
pwel &lt;- pwelch(x, 100)
pwel

plot(pwel, log = "xy")

</code></pre>

<hr>
<h2 id='raw-to-sexp'>Convert raw vectors to R vectors</h2><span id='topic+raw-to-sexp'></span><span id='topic+raw_to_uint8'></span><span id='topic+raw_to_uint16'></span><span id='topic+raw_to_uint32'></span><span id='topic+raw_to_int8'></span><span id='topic+raw_to_int16'></span><span id='topic+raw_to_int32'></span><span id='topic+raw_to_int64'></span><span id='topic+raw_to_float'></span><span id='topic+raw_to_string'></span>

<h3>Description</h3>

<p>Convert raw vectors to R vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_to_uint8(x)

raw_to_uint16(x)

raw_to_uint32(x)

raw_to_int8(x)

raw_to_int16(x)

raw_to_int32(x)

raw_to_int64(x)

raw_to_float(x)

raw_to_string(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw-to-sexp_+3A_x">x</code></td>
<td>
<p>raw vector of bytes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For numeric conversions, the function names are straightforward.
For example,
<code>raw_to_uintN</code> converts raw vectors to unsigned integers, and
<code>raw_to_intN</code> converts raw vectors to signed integers. The number
<code>'N'</code> stands for the number of bits used to store the integer.
For example <code>raw_to_uint8</code> uses 8 bits (1 byte) to store an integer,
hence the value range is <code>0-255</code>.
</p>
<p>The input data length must be multiple of the element size represented by
the underlying data. For example <code>uint16</code> integer uses 16 bites, and
one raw number uses 8 bits, hence two raw vectors can form one unsigned
integer-16. That is, <code>raw_to_uint16</code> requires the length of input
to be multiple of two. An easy calculation is: the length of <code>x</code> times
8, must be divided by <code>'N'</code> (see last paragraph for definition).
</p>
<p>The returned data uses the closest available R native data type that can
fully represent the data. For example, R does not have single <code>float</code>
type, hence <code>raw_to_float</code> returns <code>double</code> type, which can
represent all possible values in <code>float</code>. For <code>raw_to_uint32</code>,
the potential value range is <code>0 - (2^32-1)</code>. This exceeds the limit of
R integer type <code>(-2^31) - (2^31-1)</code>. Therefore, the returned values
will be real (double float) data type.
</p>
<p>There is no native data type that can store integer-64 data in R, package
<code>bit64</code> provides <code>integer64</code> type, which will be used by
<code>raw_to_int64</code>. Currently there is no solution to convert raw to
unsigned integer-64 type.
</p>
<p><code>raw_to_string</code> converts raw to character string. This function respects
<code>null</code> character, hence is slightly different than the native
<code><a href="base.html#topic+rawToChar">rawToChar</a></code>, which translates raw byte-by-byte. If each
raw byte represents a valid character, then the above two functions returns
the same result. However, when the characters represented by raw bytes are
invalid, <code>raw_to_string</code> will stop parsing and returns only the valid
characters, while <code><a href="base.html#topic+rawToChar">rawToChar</a></code> will still try to parse, and
most likely to result in errors.
Please see Examples for comparisons.
</p>


<h3>Value</h3>

<p>Numeric vectors, except for <code>raw_to_string</code>, which returns
a string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 0x00, 0x7f, 0x80, 0xFF
x &lt;- as.raw(c(0, 127, 128, 255))

raw_to_uint8(x)

# The first bit becomes the integer sign
# 128 -&gt; -128, 255 -&gt; -1
raw_to_int8(x)

## Comments based on little endian system

# 0x7f00 (32512), 0xFF80 (65408 unsigned, or -128 signed)
raw_to_uint16(x)
raw_to_int16(x)

# 0xFF807F00 (4286611200 unsigned, -8356096 signed)
raw_to_uint32(x)
raw_to_int32(x)

# ---------------------------- String ---------------------------

# ASCII case: all valid
x &lt;- charToRaw("This is an ASCII string")

raw_to_string(x)
rawToChar(x)

x &lt;- c(charToRaw("This is the end."),
       as.raw(0),
       charToRaw("*** is invalid"))

# rawToChar will raise error
raw_to_string(x)

# ---------------------------- Integer64 ------------------------
# Runs on little endian system
x &lt;- as.raw(c(0x80, 0x00, 0x7f, 0x80, 0xFF, 0x50, 0x7f, 0x00))

# Calculate bitstring, which concaternates the followings
# 10000000 (0x80), 00000000 (0x00), 01111111 (0x7f), 10000000 (0x80),
# 11111111 (0xFF), 01010000 (0x50), 01111111 (0x7f), 00000000 (0x00)

if(.Platform$endian == "little") {
  bitstring &lt;- paste0(
    "00000000011111110101000011111111",
    "10000000011111110000000010000000"
  )
} else {
  bitstring &lt;- paste0(
    "00000001000000001111111000000001",
    "11111111000010101111111000000000"
  )
}

# This is expected value
bit64::as.integer64(structure(
  bitstring,
  class = "bitstring"
))

# This is actual value
raw_to_int64(x)


</code></pre>

<hr>
<h2 id='rcond_filter_ar'>Computer reciprocal condition number of an 'Arma' filter</h2><span id='topic+rcond_filter_ar'></span>

<h3>Description</h3>

<p>Test whether the filter is numerically stable for <code><a href="#topic+filtfilt">filtfilt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcond_filter_ar(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcond_filter_ar_+3A_a">a</code></td>
<td>
<p>auto-regression coefficient, numerical vector; the first element
must not be zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reciprocal condition number of matrix <code>z1</code>, used in
<code><a href="#topic+filtfilt">filtfilt</a></code>. If the number is less than
<code>.Machine$double.eps</code>, then <code><a href="#topic+filtfilt">filtfilt</a></code> will fail.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_filter">check_filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Butterworth filter with low-pass at 0.1 Hz (order = 4)
filter &lt;- butter(4, 0.1, "low")

# TRUE
rcond_filter_ar(filter$a) &gt; .Machine$double.eps

diagnose_filter(filter$b, filter$a, 500)

# Bad filter (order is too high)
filter &lt;- butter(50, 0.1, "low")

rcond_filter_ar(filter$a) &gt; .Machine$double.eps

# filtfilt needs to inverse a singular matrix
diagnose_filter(filter$b, filter$a, 500)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+butter'></span><span id='topic+buttap'></span><span id='topic+buttord'></span><span id='topic+cheb1ap'></span><span id='topic+cheb1ord'></span><span id='topic+cheb2ap'></span><span id='topic+cheb2ord'></span><span id='topic+cheby1'></span><span id='topic+cheby2'></span><span id='topic+ellip'></span><span id='topic+ellipap'></span><span id='topic+ellipord'></span><span id='topic+resample'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>gsignal</dt><dd><p><code><a href="gsignal.html#topic+buttap">buttap</a></code>, <code><a href="gsignal.html#topic+butter">butter</a></code>, <code><a href="gsignal.html#topic+buttord">buttord</a></code>, <code><a href="gsignal.html#topic+cheb1ap">cheb1ap</a></code>, <code><a href="gsignal.html#topic+cheb1ord">cheb1ord</a></code>, <code><a href="gsignal.html#topic+cheb2ap">cheb2ap</a></code>, <code><a href="gsignal.html#topic+cheb2ord">cheb2ord</a></code>, <code><a href="gsignal.html#topic+cheby1">cheby1</a></code>, <code><a href="gsignal.html#topic+cheby2">cheby2</a></code>, <code><a href="gsignal.html#topic+ellip">ellip</a></code>, <code><a href="gsignal.html#topic+ellipap">ellipap</a></code>, <code><a href="gsignal.html#topic+ellipord">ellipord</a></code>, <code><a href="gsignal.html#topic+resample">resample</a></code></p>
</dd>
</dl>

<hr>
<h2 id='register_volume'>Imaging registration using <code>'NiftyReg'</code></h2><span id='topic+register_volume'></span>

<h3>Description</h3>

<p>Registers 'CT' to 'MRI', or 'MRI' to another 'MRI'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_volume(
  source,
  target,
  method = c("rigid", "affine", "nonlinear"),
  interpolation = c("cubic", "trilinear", "nearest"),
  threads = detect_threads(),
  symmetric = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="register_volume_+3A_source">source</code></td>
<td>
<p>source imaging data, or a <code>'nifti'</code> file path;
for example, 'CT'</p>
</td></tr>
<tr><td><code id="register_volume_+3A_target">target</code></td>
<td>
<p>target imaging data to align to; for example, 'MRI'</p>
</td></tr>
<tr><td><code id="register_volume_+3A_method">method</code></td>
<td>
<p>method of transformation, choices are <code>'rigid'</code>,
<code>'affine'</code>, or <code>'nonlinear'</code></p>
</td></tr>
<tr><td><code id="register_volume_+3A_interpolation">interpolation</code></td>
<td>
<p>how volumes should be interpolated, choices are
<code>'cubic'</code>, <code>'trilinear'</code>, or <code>'nearest'</code></p>
</td></tr>
<tr><td><code id="register_volume_+3A_threads">threads</code>, <code id="register_volume_+3A_symmetric">symmetric</code>, <code id="register_volume_+3A_verbose">verbose</code>, <code id="register_volume_+3A_...">...</code></td>
<td>
<p>see <code><a href="RNiftyReg.html#topic+niftyreg">niftyreg</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="RNiftyReg.html#topic+niftyreg">niftyreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


source &lt;- system.file("extdata", "epi_t2.nii.gz", package="RNiftyReg")
target &lt;- system.file("extdata", "flash_t1.nii.gz", package="RNiftyReg")
aligned &lt;- register_volume(source, target, verbose = FALSE)

source_img &lt;- aligned$source[[1]]
target_img &lt;- aligned$target
aligned_img &lt;- aligned$image

oldpar &lt;- par(mfrow = c(2, 2), mar = c(0.1, 0.1, 3.1, 0.1))

pal &lt;- grDevices::grey.colors(256, alpha = 1)
image(source_img[,,30], asp = 1, axes = FALSE,
      col = pal, main = "Source image")
image(target_img[,,64], asp = 1, axes = FALSE,
      col = pal, main = "Target image")
image(aligned_img[,,64], asp = 1, axes = FALSE,
      col = pal, main = "Aligned image")

# bucket fill and calculate differences
aligned_img[is.nan(aligned_img) | aligned_img &lt;= 1] &lt;- 1
target_img[is.nan(target_img) | aligned_img &lt;= 1] &lt;- 1
diff &lt;- abs(aligned_img / target_img - 1)
image(diff[,,64], asp = 1, axes = FALSE,
      col = pal, main = "Percentage Difference")

par(oldpar)



</code></pre>

<hr>
<h2 id='resample_3d_volume'>Sample '3D' volume in the world (anatomical <code>'RAS'</code>) space</h2><span id='topic+resample_3d_volume'></span>

<h3>Description</h3>

<p>Low-level implementation to sample a '3D' volume into given orientation and
shape via a nearest-neighbor sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_3d_volume(
  x,
  new_dim,
  vox2ras_old,
  vox2ras_new = vox2ras_old,
  na_fill = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample_3d_volume_+3A_x">x</code></td>
<td>
<p>image (volume) to be sampled: <code>dim(x)</code> must have length of 3</p>
</td></tr>
<tr><td><code id="resample_3d_volume_+3A_new_dim">new_dim</code></td>
<td>
<p>target dimension, integers of length 3</p>
</td></tr>
<tr><td><code id="resample_3d_volume_+3A_vox2ras_old">vox2ras_old</code></td>
<td>
<p>from volume index (column-row-slice) to <code>'RAS'</code>
(right-anterior-superior) transform: the volume index starts from 0 (C-style)
instead of 1 (R-style) to comply with <code>'NIfTI'</code> transform.</p>
</td></tr>
<tr><td><code id="resample_3d_volume_+3A_vox2ras_new">vox2ras_new</code></td>
<td>
<p>the targeting transform from volume index to <code>'RAS'</code></p>
</td></tr>
<tr><td><code id="resample_3d_volume_+3A_na_fill">na_fill</code></td>
<td>
<p>default numbers to fill if a pixel is out of bound; default is
<code>NA</code> or <code>as.raw(0)</code> if input <code>x</code> is raw type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A newly sampled volume that aligns with <code>x</code> in the anatomical
<code>'RAS'</code> coordinate system. The underlying storage mode is the same as
<code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# up-sample and rotate image
x &lt;- array(0, c(9, 9, 9))
x[4:6, 4:6, 4:6] &lt;- 1
vox2ras &lt;- matrix(nrow = 4, byrow = TRUE, c(
  0.7071, -0.7071, 0, 0,
  0.7071, 0.7071, 0, -5.5,
  0, 0, 1, -4,
  0, 0, 0, 1
))

new_vox2ras &lt;- matrix(nrow = 4, byrow = TRUE, c(
  0, 0.5, 0, -4,
  0, 0, -0.5, 4,
  0.5, 0, 0, -4,
  0, 0, 0, 1
))

y &lt;- resample_3d_volume(
  x,
  c(17, 17, 17),
  vox2ras_old = vox2ras,
  vox2ras_new = new_vox2ras,
  na_fill = 0
)


image(y[9,,])



</code></pre>

<hr>
<h2 id='rgl-call'>Safe ways to call package <code>'rgl'</code> without requiring <code>'x11'</code></h2><span id='topic+rgl-call'></span><span id='topic+rgl_call'></span><span id='topic+rgl_view'></span><span id='topic+rgl_plot_normals'></span>

<h3>Description</h3>

<p>Internally used for example show-cases. Please install package <code>'rgl'</code>
manually to use these functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl_call(FUN, ...)

rgl_view(expr, quoted = FALSE, env = parent.frame())

rgl_plot_normals(x, length = 1, lwd = 1, col = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgl-call_+3A_fun">FUN</code></td>
<td>
<p><code>'rgl'</code> function name</p>
</td></tr>
<tr><td><code id="rgl-call_+3A_...">...</code></td>
<td>
<p>passed to <code>'rgl'</code> function</p>
</td></tr>
<tr><td><code id="rgl-call_+3A_expr">expr</code></td>
<td>
<p>expression within which <code>'rgl'</code> functions are called</p>
</td></tr>
<tr><td><code id="rgl-call_+3A_quoted">quoted</code></td>
<td>
<p>whether <code>expr</code> is quoted</p>
</td></tr>
<tr><td><code id="rgl-call_+3A_env">env</code></td>
<td>
<p>environment in which <code>expr</code> is evaluated</p>
</td></tr>
<tr><td><code id="rgl-call_+3A_x">x</code></td>
<td>
<p>triangular <code>'mesh3d'</code> object</p>
</td></tr>
<tr><td><code id="rgl-call_+3A_length">length</code>, <code id="rgl-call_+3A_lwd">lwd</code>, <code id="rgl-call_+3A_col">col</code></td>
<td>
<p>normal vector length, size, and color</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# Make sure the example does not run when compiling
# or check the package
if(FALSE) {

  volume &lt;- array(0, dim = c(8,8,8))
  volume[4:5, 4:5, 4:5] &lt;- 1
  mesh &lt;- mesh_from_volume(volume, verbose = FALSE)

  rgl_view({

    rgl_call("shade3d", mesh, col = 3)
    rgl_plot_normals(mesh)

  })

}


</code></pre>

<hr>
<h2 id='shift_array'>Shift array by index</h2><span id='topic+shift_array'></span>

<h3>Description</h3>

<p>Re-arrange arrays in parallel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift_array(x, along_margin, unit_margin, shift_amount)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shift_array_+3A_x">x</code></td>
<td>
<p>array, must have at least matrix</p>
</td></tr>
<tr><td><code id="shift_array_+3A_along_margin">along_margin</code></td>
<td>
<p>which index is to be shifted</p>
</td></tr>
<tr><td><code id="shift_array_+3A_unit_margin">unit_margin</code></td>
<td>
<p>which dimension decides <code>shift_amount</code></p>
</td></tr>
<tr><td><code id="shift_array_+3A_shift_amount">shift_amount</code></td>
<td>
<p>shift amount along <code>along_margin</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple use-case for this function is to think of a matrix where each row
is a signal and columns stand for time. The objective is to align (time-lock)
each signal according to certain events. For each signal, we want to shift
the time points by certain amount.
</p>
<p>In this case, the shift amount is defined by <code>shift_amount</code>, whose
length equals to number of signals. <code>along_margin=2</code> as we want to shift
time points (column, the second dimension) for each signal. <code>unit_margin=1</code>
because the shift amount is depend on the signal number.
</p>


<h3>Value</h3>

<p>An array with same dimensions as the input <code>x</code>, but with
index shifted. The missing elements will be filled with <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set ncores = 2 to comply to CRAN policy. Please don't run this line
ravetools_threads(n_threads = 2L)



x &lt;- matrix(1:10, nrow = 2, byrow = TRUE)
z &lt;- shift_array(x, 2, 1, c(1,2))

y &lt;- NA * x
y[1,1:4] = x[1,2:5]
y[2,1:3] = x[2,3:5]

# Check if z ang y are the same
z - y

# array case
# x is Trial x Frequency x Time
x &lt;- array(1:27, c(3,3,3))

# Shift time for each trial, amount is 1, -1, 0
shift_amount &lt;- c(1,-1,0)
z &lt;- shift_array(x, 3, 1, shift_amount)

oldpar &lt;- par(mfrow = c(3, 2), mai = c(0.8, 0.6, 0.4, 0.1))
for( ii in 1:3 ){
  image(t(x[ii, ,]), ylab = 'Frequency', xlab = 'Time',
        main = paste('Trial', ii))
  image(t(z[ii, ,]), ylab = 'Frequency', xlab = 'Time',
        main = paste('Shifted amount:', shift_amount[ii]))
}
par(oldpar)

</code></pre>

<hr>
<h2 id='vcg_isosurface'>Create surface mesh from 3D-array</h2><span id='topic+vcg_isosurface'></span>

<h3>Description</h3>

<p>Create surface from 3D-array using marching cubes algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcg_isosurface(
  volume,
  threshold_lb = 0,
  threshold_ub = NA,
  vox_to_ras = diag(c(-1, -1, 1, 1))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcg_isosurface_+3A_volume">volume</code></td>
<td>
<p>a volume or a mask volume</p>
</td></tr>
<tr><td><code id="vcg_isosurface_+3A_threshold_lb">threshold_lb</code></td>
<td>
<p>lower-bound threshold for creating the surface; default
is <code>0</code></p>
</td></tr>
<tr><td><code id="vcg_isosurface_+3A_threshold_ub">threshold_ub</code></td>
<td>
<p>upper-bound threshold for creating the surface; default
is <code>NA</code> (no upper-bound)</p>
</td></tr>
<tr><td><code id="vcg_isosurface_+3A_vox_to_ras">vox_to_ras</code></td>
<td>
<p>a <code>4x4</code> <code>'affine'</code> transform matrix indicating the
'voxel'-to-world transform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A triangular mesh of class <code>'mesh3d'</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if(is_not_cran()) {

library(ravetools)
data("left_hippocampus_mask")

mesh &lt;- vcg_isosurface(left_hippocampus_mask)


rgl_view({

  rgl_call("mfrow3d", 1, 2)

  rgl_call("title3d", "Direct ISOSurface")
  rgl_call("shade3d", mesh, col = 2)

  rgl_call("next3d")
  rgl_call("title3d", "ISOSurface + Implicit Smooth")

  rgl_call("shade3d",
           vcg_smooth_implicit(mesh, degree = 2),
           col = 3)
})

}
</code></pre>

<hr>
<h2 id='vcg_kdtree_nearest'>Find nearest <code>k</code> points</h2><span id='topic+vcg_kdtree_nearest'></span>

<h3>Description</h3>

<p>For each point in the query, find the nearest <code>k</code> points in target using
<code>K-D</code> tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcg_kdtree_nearest(target, query, k = 1, leaf_size = 16, max_depth = 64)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcg_kdtree_nearest_+3A_target">target</code></td>
<td>
<p>a matrix with <code>n</code> rows (number of points) and 2 or 3
columns, or a <code>mesh3d</code> object. This is the target point cloud where
nearest distances will be sought</p>
</td></tr>
<tr><td><code id="vcg_kdtree_nearest_+3A_query">query</code></td>
<td>
<p>a matrix with <code>n</code> rows (number of points) and 2 or 3
columns, or a <code>mesh3d</code> object. This is the query point cloud where
for each point, the nearest <code>k</code> points in <code>target</code> will be sought.</p>
</td></tr>
<tr><td><code id="vcg_kdtree_nearest_+3A_k">k</code></td>
<td>
<p>positive number of nearest neighbors to look for</p>
</td></tr>
<tr><td><code id="vcg_kdtree_nearest_+3A_leaf_size">leaf_size</code></td>
<td>
<p>the suggested leaf size for the <code>K-D</code> tree; default is
<code>16</code>; larger leaf size will result in smaller depth</p>
</td></tr>
<tr><td><code id="vcg_kdtree_nearest_+3A_max_depth">max_depth</code></td>
<td>
<p>maximum depth of the <code>K-D</code> tree; default is <code>64</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two matrices: <code>index</code> is a matrix of indices of
<code>target</code> points, whose distances are close to the corresponding
<code>query</code> point. If no point in <code>target</code> is found, then <code>NA</code>
will be presented. Each <code>distance</code> is the corresponding distance
from the query point to the target point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Find nearest point in B with the smallest distance for each point in A

library(ravetools)

n &lt;- 10
A &lt;- matrix(rnorm(n * 2), nrow = n)
B &lt;- matrix(rnorm(n * 4), nrow = n * 2)
result &lt;- vcg_kdtree_nearest(
  target = B, query = A,
   k = 1
)

plot(
  rbind(A, B),
  pch = 20,
  col = c(rep("red", n), rep("black", n * 2)),
  xlab = "x",
  ylab = "y",
  main = "Black: target; Red: query"
)

nearest_points &lt;- B[result$index, ]
arrows(A[, 1],
       A[, 2],
       nearest_points[, 1],
       nearest_points[, 2],
       col = "red",
       length = 0.1)

# ---- Sanity check ------------------------------------------------
nearest_index &lt;- apply(A, 1, function(pt) {
  which.min(colSums((t(B) - pt) ^ 2))
})

result$index == nearest_index



</code></pre>

<hr>
<h2 id='vcg_mesh_volume'>Compute volume for manifold meshes</h2><span id='topic+vcg_mesh_volume'></span>

<h3>Description</h3>

<p>Compute volume for manifold meshes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcg_mesh_volume(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcg_mesh_volume_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class <code>'mesh3d'</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric volume of the mesh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Initial mesh
mesh &lt;- vcg_sphere()

vcg_mesh_volume(mesh)

</code></pre>

<hr>
<h2 id='vcg_raycaster'>Cast rays to intersect with mesh</h2><span id='topic+vcg_raycaster'></span>

<h3>Description</h3>

<p>Cast rays to intersect with mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcg_raycaster(
  x,
  ray_origin,
  ray_direction,
  max_distance = Inf,
  both_sides = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcg_raycaster_+3A_x">x</code></td>
<td>
<p>surface mesh</p>
</td></tr>
<tr><td><code id="vcg_raycaster_+3A_ray_origin">ray_origin</code></td>
<td>
<p>a matrix with 3 rows or a vector of length 3, the positions
of ray origin</p>
</td></tr>
<tr><td><code id="vcg_raycaster_+3A_ray_direction">ray_direction</code></td>
<td>
<p>a matrix with 3 rows or a vector of length 3, the
direction of the ray, will be normalized to length 1</p>
</td></tr>
<tr><td><code id="vcg_raycaster_+3A_max_distance">max_distance</code></td>
<td>
<p>positive maximum distance to cast the normalized ray;
default is infinity. Any invalid distances (negative, zero, or <code>NA</code>)
will be interpreted as unset.</p>
</td></tr>
<tr><td><code id="vcg_raycaster_+3A_both_sides">both_sides</code></td>
<td>
<p>whether to inverse the ray (search both positive and
negative ray directions); default is false</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of ray casting results: whether any intersection is found,
position and face normal of the intersection, distance of the ray, and the
index of the intersecting face (counted from 1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ravetools)
sphere &lt;- vcg_sphere(normals = FALSE)
sphere$vb[1:3, ] &lt;- sphere$vb[1:3, ] + c(10, 10, 10)
vcg_raycaster(
  x = sphere,
  ray_origin = array(c(0, 0, 0, 1, 0, 0), c(3, 2)),
  ray_direction = c(1, 1, 1)
)

</code></pre>

<hr>
<h2 id='vcg_smooth'>Implicitly smooth a triangular mesh</h2><span id='topic+vcg_smooth'></span><span id='topic+vcg_smooth_implicit'></span><span id='topic+vcg_smooth_explicit'></span>

<h3>Description</h3>

<p>Applies smoothing algorithms on a triangular mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcg_smooth_implicit(
  mesh,
  lambda = 0.2,
  use_mass_matrix = TRUE,
  fix_border = FALSE,
  use_cot_weight = FALSE,
  degree = 1L,
  laplacian_weight = 1
)

vcg_smooth_explicit(
  mesh,
  type = c("taubin", "laplace", "HClaplace", "fujiLaplace", "angWeight",
    "surfPreserveLaplace"),
  iteration = 10,
  lambda = 0.5,
  mu = -0.53,
  delta = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcg_smooth_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh stored as object of class 'mesh3d'.</p>
</td></tr>
<tr><td><code id="vcg_smooth_+3A_lambda">lambda</code></td>
<td>
<p>In <code>vcg_smooth_implicit</code>, the amount of smoothness,
useful only if <code>use_mass_matrix</code> is <code>TRUE</code>; default is <code>0.2</code>.
In <code>vcg_smooth_explicit</code>, parameter for <code>'taubin'</code> smoothing.</p>
</td></tr>
<tr><td><code id="vcg_smooth_+3A_use_mass_matrix">use_mass_matrix</code></td>
<td>
<p>logical: whether to use mass matrix to keep the mesh
close to its original position (weighted per area distributed on vertices);
default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="vcg_smooth_+3A_fix_border">fix_border</code></td>
<td>
<p>logical: whether to fix the border vertices of the mesh;
default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="vcg_smooth_+3A_use_cot_weight">use_cot_weight</code></td>
<td>
<p>logical: whether to use cotangent weight; default is
<code>FALSE</code> (using uniform 'Laplacian')</p>
</td></tr>
<tr><td><code id="vcg_smooth_+3A_degree">degree</code></td>
<td>
<p>integer: degrees of 'Laplacian'; default is <code>1</code></p>
</td></tr>
<tr><td><code id="vcg_smooth_+3A_laplacian_weight">laplacian_weight</code></td>
<td>
<p>numeric: weight when <code>use_cot_weight</code> is <code>FALSE</code>;
default is <code>1.0</code></p>
</td></tr>
<tr><td><code id="vcg_smooth_+3A_type">type</code></td>
<td>
<p>method name of explicit smooth, choices are <code>'taubin'</code>,
<code>'laplace'</code>, <code>'HClaplace'</code>, <code>'fujiLaplace'</code>,
<code>'angWeight'</code>, <code>'surfPreserveLaplace'</code>.</p>
</td></tr>
<tr><td><code id="vcg_smooth_+3A_iteration">iteration</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="vcg_smooth_+3A_mu">mu</code></td>
<td>
<p>parameter for <code>'taubin'</code> explicit smoothing.</p>
</td></tr>
<tr><td><code id="vcg_smooth_+3A_delta">delta</code></td>
<td>
<p>parameter for scale-dependent 'Laplacian' smoothing or
maximum allowed angle (in 'Radian') for deviation between surface preserving
'Laplacian'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;mesh3d&quot; with:
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>vertex coordinates</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>vertex normal vectors</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>triangular face index</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
if(is_not_cran()) {

# Prepare mesh with no normals
data("left_hippocampus_mask")

# Grow 2mm on each direction to fill holes
volume &lt;- grow_volume(left_hippocampus_mask, 2)

# Initial mesh
mesh &lt;- vcg_isosurface(volume)

# Start: examples
rgl_view({
  rgl_call("mfrow3d", 2, 4)
  rgl_call("title3d", "Naive ISOSurface")
  rgl_call("shade3d", mesh, col = 2)

  rgl_call("next3d")
  rgl_call("title3d", "Implicit Smooth")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_implicit(mesh, degree = 2))

  rgl_call("next3d")
  rgl_call("title3d", "Explicit Smooth - taubin")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_explicit(mesh, "taubin"))

  rgl_call("next3d")
  rgl_call("title3d", "Explicit Smooth - laplace")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_explicit(mesh, "laplace"))

  rgl_call("next3d")
  rgl_call("title3d", "Explicit Smooth - angWeight")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_explicit(mesh, "angWeight"))

  rgl_call("next3d")
  rgl_call("title3d", "Explicit Smooth - HClaplace")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_explicit(mesh, "HClaplace"))

  rgl_call("next3d")
  rgl_call("title3d", "Explicit Smooth - fujiLaplace")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_explicit(mesh, "fujiLaplace"))

  rgl_call("next3d")
  rgl_call("title3d", "Explicit Smooth - surfPreserveLaplace")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_explicit(mesh, "surfPreserveLaplace"))
})

}

</code></pre>

<hr>
<h2 id='vcg_sphere'>Simple 3-dimensional sphere mesh</h2><span id='topic+vcg_sphere'></span>

<h3>Description</h3>

<p>Simple 3-dimensional sphere mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcg_sphere(sub_division = 3L, normals = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcg_sphere_+3A_sub_division">sub_division</code></td>
<td>
<p>density of vertex in the resulting mesh</p>
</td></tr>
<tr><td><code id="vcg_sphere_+3A_normals">normals</code></td>
<td>
<p>whether the normal vectors should be calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>'mesh3d'</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vcg_sphere()

</code></pre>

<hr>
<h2 id='vcg_uniform_remesh'>Sample a surface mesh uniformly</h2><span id='topic+vcg_uniform_remesh'></span>

<h3>Description</h3>

<p>Sample a surface mesh uniformly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcg_uniform_remesh(
  x,
  voxel_size = NULL,
  offset = 0,
  discretize = FALSE,
  multi_sample = FALSE,
  absolute_distance = FALSE,
  merge_clost = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcg_uniform_remesh_+3A_x">x</code></td>
<td>
<p>surface</p>
</td></tr>
<tr><td><code id="vcg_uniform_remesh_+3A_voxel_size">voxel_size</code></td>
<td>
<p>'voxel' size for space 'discretization'</p>
</td></tr>
<tr><td><code id="vcg_uniform_remesh_+3A_offset">offset</code></td>
<td>
<p>offset position shift of the new surface from the input</p>
</td></tr>
<tr><td><code id="vcg_uniform_remesh_+3A_discretize">discretize</code></td>
<td>
<p>whether to use step function (<code>TRUE</code>) instead of
linear interpolation (<code>FALSE</code>) to calculate the position of the
intersected edge of the marching cube; default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="vcg_uniform_remesh_+3A_multi_sample">multi_sample</code></td>
<td>
<p>whether to calculate multiple samples for more accurate
results (at the expense of more computing time) to remove artifacts; default
is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="vcg_uniform_remesh_+3A_absolute_distance">absolute_distance</code></td>
<td>
<p>whether an unsigned distance field should be
computed. When set to <code>TRUE</code>, non-zero offsets is to be set, and
double-surfaces will be built around the original surface, like a sandwich.</p>
</td></tr>
<tr><td><code id="vcg_uniform_remesh_+3A_merge_clost">merge_clost</code></td>
<td>
<p>whether to merge close vertices; default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="vcg_uniform_remesh_+3A_verbose">verbose</code></td>
<td>
<p>whether to verbose the progress; default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A triangular mesh of class <code>'mesh3d'</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sphere &lt;- vcg_sphere()
mesh &lt;- vcg_uniform_remesh(sphere, voxel_size = 0.45)

if(is_not_cran()) {

rgl_view({

  rgl_call("mfrow3d", 1, 2)

  rgl_call("title3d", "Input")
  rgl_call("wire3d", sphere, col = 2)
  rgl_call("next3d")

  rgl_call("title3d", "Re-meshed to 0.1mm edge distance")
  rgl_call("wire3d", mesh, col = 3)
})

}

</code></pre>

<hr>
<h2 id='vcg_update_normals'>Update vertex normal</h2><span id='topic+vcg_update_normals'></span>

<h3>Description</h3>

<p>Update vertex normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcg_update_normals(
  mesh,
  weight = c("area", "angle"),
  pointcloud = c(10, 0),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcg_update_normals_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh or a point-cloud (matrix of 3 columns)</p>
</td></tr>
<tr><td><code id="vcg_update_normals_+3A_weight">weight</code></td>
<td>
<p>method to compute per-vertex normal vectors: <code>"area"</code>
weighted average of surrounding face normal, or <code>"angle"</code> weighted
vertex normal vectors.</p>
</td></tr>
<tr><td><code id="vcg_update_normals_+3A_pointcloud">pointcloud</code></td>
<td>
<p>integer vector of length 2: containing optional
parameters for normal calculation of point clouds; the first entry
specifies the number of neighboring points to consider; the second
entry specifies the amount of smoothing iterations to be performed.</p>
</td></tr>
<tr><td><code id="vcg_update_normals_+3A_verbose">verbose</code></td>
<td>
<p>whether to verbose the progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>'mesh3d'</code> object with normal vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(is_not_cran()) {

# Prepare mesh with no normal
data("left_hippocampus_mask")
mesh &lt;- vcg_isosurface(left_hippocampus_mask)
mesh$normals &lt;- NULL

# Start: examples
new_mesh &lt;- vcg_update_normals(mesh, weight = "angle",
                               pointcloud = c(10, 10))

rgl_view({
  rgl_call("mfrow3d", 1, 2)
  rgl_call("shade3d", mesh, col = 2)

  rgl_call("next3d")
  rgl_call("shade3d", new_mesh, col = 2)
})
}


</code></pre>

<hr>
<h2 id='wavelet'>'Morlet' wavelet transform (Discrete)</h2><span id='topic+wavelet'></span><span id='topic+wavelet_kernels'></span><span id='topic+morlet_wavelet'></span><span id='topic+wavelet_cycles_suggest'></span>

<h3>Description</h3>

<p>Transform analog voltage signals with 'Morlet'
wavelets: complex wavelet kernels with <code class="reqn">\pi/2</code> phase
differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wavelet_kernels(freqs, srate, wave_num)

morlet_wavelet(
  data,
  freqs,
  srate,
  wave_num,
  precision = c("float", "double"),
  trend = c("constant", "linear", "none"),
  signature = NULL,
  ...
)

wavelet_cycles_suggest(
  freqs,
  frequency_range = c(2, 200),
  cycle_range = c(3, 20)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wavelet_+3A_freqs">freqs</code></td>
<td>
<p>frequency in which <code>data</code> will be projected on</p>
</td></tr>
<tr><td><code id="wavelet_+3A_srate">srate</code></td>
<td>
<p>sample rate, number of time points per second</p>
</td></tr>
<tr><td><code id="wavelet_+3A_wave_num">wave_num</code></td>
<td>
<p>desired number of cycles in wavelet kernels to
balance the precision in time and amplitude (control the
smoothness); positive integers are strongly suggested</p>
</td></tr>
<tr><td><code id="wavelet_+3A_data">data</code></td>
<td>
<p>numerical vector such as analog voltage signals</p>
</td></tr>
<tr><td><code id="wavelet_+3A_precision">precision</code></td>
<td>
<p>the precision of computation; choices are
<code>'float'</code> (default) and <code>'double'</code>.</p>
</td></tr>
<tr><td><code id="wavelet_+3A_trend">trend</code></td>
<td>
<p>choices are <code>'constant'</code>: center the signal at zero;
<code>'linear'</code>: remove the linear trend; <code>'none'</code> do nothing</p>
</td></tr>
<tr><td><code id="wavelet_+3A_signature">signature</code></td>
<td>
<p>signature to calculate kernel path to save, internally used</p>
</td></tr>
<tr><td><code id="wavelet_+3A_...">...</code></td>
<td>
<p>further passed to <code><a href="#topic+detrend">detrend</a></code>;</p>
</td></tr>
<tr><td><code id="wavelet_+3A_frequency_range">frequency_range</code></td>
<td>
<p>frequency range to calculate, default is 2 to 200</p>
</td></tr>
<tr><td><code id="wavelet_+3A_cycle_range">cycle_range</code></td>
<td>
<p>number of cycles corresponding to <code>frequency_range</code>.
For default frequency range (2 - 200), the default <code>cycle_range</code> is
3 to 20. That is, 3 wavelet kernel cycles at 2 Hertz, and 20 cycles at 200
Hertz.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>wavelet_kernels</code> returns wavelet kernels to be
used for wavelet function; <code>morlet_wavelet</code> returns a file-based array
if <code>precision</code> is <code>'float'</code>, or a list of real and imaginary
arrays if <code>precision</code> is <code>'double'</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# generate sine waves
time &lt;- seq(0, 3, by = 0.01)
x &lt;- sin(time * 20*pi) + exp(-time^2) * cos(time * 10*pi)

plot(time, x, type = 'l')

# freq from 1 - 15 Hz; wavelet using float precision
freq &lt;- seq(1, 15, 0.2)
coef &lt;- morlet_wavelet(x, freq, 100, c(2,3))

# to get coefficients in complex number from 1-10 time points
coef[1:10, ]

# power
power &lt;- Mod(coef[])^2

# Power peaks at 5Hz and 10Hz at early stages
# After 1.0 second, 5Hz component fade away
image(power, x = time, y = freq, ylab = "frequency")

# wavelet using double precision
coef2 &lt;- morlet_wavelet(x, freq, 100, c(2,3), precision = "double")
power2 &lt;- (coef2$real[])^2 + (coef2$imag[])^2

image(power2, x = time, y = freq, ylab = "frequency")

# The maximum relative change of power with different precisions
max(abs(power/power2 - 1))

# display kernels
freq &lt;- seq(1, 15, 1)
kern &lt;- wavelet_kernels(freq, 100, c(2,3))
print(kern)

plot(kern)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
