<!DOCTYPE html><html><head><title>Help for package icosa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {icosa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[,gridlayer,ANY,missing-method'><p>Extraction from a gridlayer using indices</p></a></li>
<li><a href='#arcdist'><p>Calculation of distances along arcs</p></a></li>
<li><a href='#arcdistmat'><p>Calculation of distance matrices along arcs</p></a></li>
<li><a href='#arcpoints'><p>Calculation of point coordinates along an arc</p></a></li>
<li><a href='#CarToPol'><p>Conversion of 3d Cartesian coordinates to polar coordinates</p></a></li>
<li><a href='#cellocator'><p>Locate grid faces based on their positions on a map</p></a></li>
<li><a href='#centers'><p>The face centers of an icosahedral grid object</p></a></li>
<li><a href='#chullsphere'><p>Spherical convex hull.</p></a></li>
<li><a href='#edgelength'><p>Lengths of grid edges</p></a></li>
<li><a href='#edges'><p>The edges of a 3d object</p></a></li>
<li><a href='#facelayer-class'><p>A <code>facelayer</code> linked to a <code>trigrid</code> or <code>hexagrid</code> object</p></a></li>
<li><a href='#faces'><p>The faces of a 3d object</p></a></li>
<li><a href='#faces3d'><p>Methods of 3D face plotting.</p></a></li>
<li><a href='#gridensity'><p>Icosahedral grid-based density estimation</p></a></li>
<li><a href='#gridgraph'><p>Create or instantiate an <code>graph</code> class graph from the faces of an icosahedral grid</p></a></li>
<li><a href='#gridlabs'><p>Labels of grid vertices, faces and edges.</p></a></li>
<li><a href='#gridlabs3d'><p>Display the names of the grid elements in 3d plots.</p></a></li>
<li><a href='#guides3d'><p>Guides for 3d spherical plotting.</p></a></li>
<li><a href='#heatMapLegend'><p>Legend for a heatmap with predefined colors.</p></a></li>
<li><a href='#hexagrid-class'><p>Construct a penta-hexagonal icosahedral grid</p></a></li>
<li><a href='#hexguide'><p>Tessellation guide to <code>hexagrid</code> objects</p></a></li>
<li><a href='#icosa'><p>Global Triangular and Hexa-Pentagonal Grids Based on Tessellated Icosahedra</p></a></li>
<li><a href='#length,trigrid-method'><p>The number of faces in a <code>trigrid</code> or <code>hexagrid</code> class object.</p></a></li>
<li><a href='#lines,trigrid-method'><p>Lines method for the <code>trigrid</code> and <code>hexagrid</code> classes</p></a></li>
<li><a href='#lines3d'><p>Methods of 3d line plotting</p></a></li>
<li><a href='#locate'><p>Basic lookup function of coordinates on an icosahedral grid</p></a></li>
<li><a href='#names,gridlayer-method'><p>The face names in a <code>facelayer</code> class object</p></a></li>
<li><a href='#newgraph'><p>Add an igraph object to a predefined slot in an icosahedral grid</p></a></li>
<li><a href='#newsf'><p>Add a <code>sf</code> object to a predefined slot in a <code>trigrid</code> or <code>hexagrid</code> object</p></a></li>
<li><a href='#newsp'><p>Add a <code>SpatialPolygons</code> object to a predefined slot in a <code>trigrid</code> or <code>hexagrid</code> object</p></a></li>
<li><a href='#occupied'><p>Faces occupied by the specified object</p></a></li>
<li><a href='#orientation'><p>Extracting and setting the grid orientation</p></a></li>
<li><a href='#plot'><p>Plot method for the <code>trigrid</code>, <code>hexagrid</code> or <code>facelayer</code> classes</p></a></li>
<li><a href='#plot3d'><p>3d plotting of an icosahedral grid, its subset or a data layer</p></a></li>
<li><a href='#PolToCar'><p>Conversion of polar coordinates to 3d Cartesian coordinates</p></a></li>
<li><a href='#pos'><p>Position of face centers and vertices on a grid</p></a></li>
<li><a href='#resample'><p>Resampling of data involving a <code>trigrid</code> or a <code>hexagrid</code> object.</p></a></li>
<li><a href='#rotate'><p>Rotation of <code>trigrid</code> and <code>hexagrid</code> objects</p></a></li>
<li><a href='#rpsphere'><p>Random point generation on the surface of a sphere</p></a></li>
<li><a href='#SpLines'><p>Create a <code>SpatialLines</code> class object from an icosahedral grid</p></a></li>
<li><a href='#SpPolygons'><p>Spatial polygons from an icosahedral grid</p></a></li>
<li><a href='#subset'><p>Subsetting an icosahedral grid or data layers organized with them</p></a></li>
<li><a href='#surfacearea'><p>Areas of grid cell surfaces</p></a></li>
<li><a href='#surfacecentroid'><p>Surface centroid point of a spherical point cloud</p></a></li>
<li><a href='#translate'><p>Translating an icosahedral grid object in 3d Cartesian space</p></a></li>
<li><a href='#trigrid-class'><p>A triangular icosahedral grid</p></a></li>
<li><a href='#triguide'><p>Tessellation guide to <code>trigrid</code> objects</p></a></li>
<li><a href='#trishape'><p>Shape distortions of the triangular faces and subfaces</p></a></li>
<li><a href='#values'><p>Extract and replace values from a gridlayer-derived object (e.g. <code>link{facelayer}</code>).</p></a></li>
<li><a href='#vertices'><p>The vertices of an icosahedral grid object</p></a></li>
<li><a href='#vicinity'><p>The neighbouring faces of faces in an icosahedral grid</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Global Triangular and Penta-Hexagonal Grids Based on Tessellated
Icosahedra</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.0</td>
</tr>
<tr>
<td>Collate:</td>
<td>zzz.R data.R utils-conversion.R utils-spherical.R
utils-vectors.R grid-build.R grid-lookup.R grid-move.R
grid-subset.R grid-attributes.R grid-graphs.R grid-sp-lines.R
grid-sp-polygons.R grid-sf-polygons.R grid-resample.R
data-gridlayer-basic.R data-gridlayer-attributes.R
data-gridlayer-groupgen.R data-gridlayer-subset.R
data-facelayer-basic.R data-facelayer-graphs.R
data-facelayer-resample.R plot-legend.R plot-2d-grid.R
plot-2d-data.R plot-rgl-util.R plot-rgl-grid.R
plot-rgl-facelayer.R plot-rgl-sp3d.R</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of icosahedral grids in three dimensions. The spherical-triangular tessellation can be set to create grids with custom resolutions. Both the primary triangular and their inverted penta-hexagonal grids can be calculated. Additional functions are provided that allow plotting of the grids and associated data, the interaction of the grids with other raster and vector objects, and treating the grids as a graphs.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-23</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, terra, rgl</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://adamkocsis.github.io/icosa/">https://adamkocsis.github.io/icosa/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, sp, igraph, methods, stats, sf</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/adamkocsis/icosa/issues">https://github.com/adamkocsis/icosa/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam T. Kocsis &lt;adam.t.kocsis@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-23 12:41:19 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam T. Kocsis <a href="https://orcid.org/0000-0002-9028-665X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Deutsche Forschungsgemeinschaft [fnd],
  FAU GeoZentrum Nordbayern [fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-23 14:42:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B+2Cgridlayer+2CANY+2Cmissing-method'>Extraction from a gridlayer using indices</h2><span id='topic++5B+2Cgridlayer+2CANY+2Cmissing-method'></span><span id='topic++5B+2Cgridlayer+2CSpatExtent+2Cmissing-method'></span><span id='topic++5B+3C-+2Cgridlayer+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Cgridlayer-method'></span>

<h3>Description</h3>

<p>Shorthand to the <code><a href="#topic+subset">subset</a></code> function.
</p>
<p>Function to replace specific elements in a gridlayer object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gridlayer,ANY,missing'
x[i]

## S4 method for signature 'gridlayer,SpatExtent,missing'
x[i]

## S4 replacement method for signature 'gridlayer,ANY,ANY'
x[i] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2Cgridlayer+2B2CANY+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+facelayer">facelayer</a></code>) The object to be subsetted.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cgridlayer+2B2CANY+2B2Cmissing-method_+3A_i">i</code></td>
<td>
<p>(<code>logical</code>, <code>numeric</code> or <code><a href="terra.html#topic+ext">SpatExtent</a></code>) The subscript vector, or extent, specifying the faces that are used for subsetting. As in <code><a href="base.html#topic+subset">subset</a></code>.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cgridlayer+2B2CANY+2B2Cmissing-method_+3A_value">value</code></td>
<td>
<p>The replacement values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All these methods are implementing direct replacement in the <code>@values</code> slot of a layer, depending on criteria used for subsetting.
</p>


<h3>Value</h3>

<p>The extraction methods return <code><a href="#topic+facelayer">facelayer</a></code>-class objects.
</p>

<hr>
<h2 id='arcdist'>Calculation of distances along arcs</h2><span id='topic+arcdist'></span>

<h3>Description</h3>

<p>This function calculates the shortest arc distance between two points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcdist(p1, p2, output = "distance", origin = c(0, 0, 0), radius = authRadius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcdist_+3A_p1">p1</code></td>
<td>
<p>(<code>numeric</code>) Vector, XYZ or longitude-latitude coordinates of the first point along the arc.</p>
</td></tr>
<tr><td><code id="arcdist_+3A_p2">p2</code></td>
<td>
<p>(<code>numeric</code>) Vector, XYZ or longitude-latitude coordinates of the last point along the arc.</p>
</td></tr>
<tr><td><code id="arcdist_+3A_output">output</code></td>
<td>
<p>(<code>character</code>) The type of the output value. <code>"distance"</code> will give the distance
in the metric that was fed to the function for the coordinates or the radius.
<code>"deg"</code> will output the the distance in degrees, <code>"rad"</code> will do
so in radians.</p>
</td></tr>
<tr><td><code id="arcdist_+3A_origin">origin</code></td>
<td>
<p>(<code>numeric</code>) Vector, the center of the circle in XYZ coordinates (default is <code>c(0,0,0)</code>).</p>
</td></tr>
<tr><td><code id="arcdist_+3A_radius">radius</code></td>
<td>
<p>(<code>numeric</code>) The radius of the circle in case the input points have polar coordinates only.
Unused when XYZ coordinates are entered. Defaults to the authalic radius of Earth ca. 6371.007km.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>numeric</code> value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates of two points
point1&lt;- c(0,0)
point2&lt;- c(180,0)
arcdist(point1,point2,"distance")
</code></pre>

<hr>
<h2 id='arcdistmat'>Calculation of distance matrices along arcs</h2><span id='topic+arcdistmat'></span>

<h3>Description</h3>

<p>This function calculates the shortest arc distance matrix between two sets of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcdistmat(
  points1,
  points2 = NULL,
  origin = c(0, 0, 0),
  output = "distance",
  radius = authRadius
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcdistmat_+3A_points1">points1</code></td>
<td>
<p>(<code>numeric</code>) Matrix, XYZ or longitude-latitude coordinates of the first set of points.</p>
</td></tr>
<tr><td><code id="arcdistmat_+3A_points2">points2</code></td>
<td>
<p>(<code>numeric</code>) Matrix, XYZ or longitude-latitude coordinates of the second set of points. 
Leave this empty if you want all the arc distances between a set of points</p>
</td></tr>
<tr><td><code id="arcdistmat_+3A_origin">origin</code></td>
<td>
<p>(<code>numeric</code>) Vector, the center of the circle in XYZ coordinates (default is <code>c(0,0,0)</code>).</p>
</td></tr>
<tr><td><code id="arcdistmat_+3A_output">output</code></td>
<td>
<p>(<code>character</code>) The type of the output value. <code>"distance"</code> will give back the distance
in the metric that was fed to the function in the coordinates or the radius.
<code>"deg"</code> will output the the distance in degrees, <code>"rad"</code> will do
so in radians.</p>
</td></tr>
<tr><td><code id="arcdistmat_+3A_radius">radius</code></td>
<td>
<p>(<code>numeric</code>) The radius of the circle in case the input points have polar coordinates only.
Unused when XYZ coordinates are entered. Defaults to the authalic radius of Earth ca. 6371.007km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will create all possible shortest arc distances between points in the two sets,
but not between the points within the sets. The function is useful for great circle distance calculations.
For a symmetrical distance matrix leave the <code>points2</code> argument empty.
</p>


<h3>Value</h3>

<p>A single <code>numeric</code> value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- trigrid(c(4))
res &lt;- arcdistmat(g@vertices)

rand&lt;-rpsphere(500)
res2 &lt;- arcdistmat(g@vertices, rand)

</code></pre>

<hr>
<h2 id='arcpoints'>Calculation of point coordinates along an arc</h2><span id='topic+arcpoints'></span>

<h3>Description</h3>

<p>This function calculates points along an arc between two points and a circle center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcpoints(
  p1,
  p2,
  breaks = 2,
  origin = c(0, 0, 0),
  onlyNew = FALSE,
  output = "cartesian",
  radius = authRadius
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcpoints_+3A_p1">p1</code></td>
<td>
<p>(<code>numeric</code>) Vector, XYZ or longitude-latitude coordinates of the first point along the arc.</p>
</td></tr>
<tr><td><code id="arcpoints_+3A_p2">p2</code></td>
<td>
<p>(<code>numeric</code>) Vector, XYZ or longitude-latitude coordinates of the last point along the arc.</p>
</td></tr>
<tr><td><code id="arcpoints_+3A_breaks">breaks</code></td>
<td>
<p>(<code>integer</code>) The number of points inserted between <code>p1</code> and <code>p2</code>. Has to be positive.</p>
</td></tr>
<tr><td><code id="arcpoints_+3A_origin">origin</code></td>
<td>
<p>(<code>numeric</code>) vector, The center of the circle in XYZ coordinates (default is <code>c(0,0,0)</code>).</p>
</td></tr>
<tr><td><code id="arcpoints_+3A_onlynew">onlyNew</code></td>
<td>
<p>(<code>logical</code>) Should <code>p1</code> and <code>p2</code> be omitted from the result?</p>
</td></tr>
<tr><td><code id="arcpoints_+3A_output">output</code></td>
<td>
<p>(<code>character</code>) The coordinate system of the output points. Can either be <code>"polar"</code> for
longitude-latitude or <code>"cartesian"</code> for XYZ data.</p>
</td></tr>
<tr><td><code id="arcpoints_+3A_radius">radius</code></td>
<td>
<p>(<code>numeric</code>) Single value, the radius of the circle in case the input points have only polar coordinates.
Unused when XYZ coordinates are entered. Defaults to the authalic radius of Earth ca. 6371.007km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function always returns the smaller arc, with angle alpha &lt; pi.
</p>


<h3>Value</h3>

<p>Either an XYZ or a long-lat numeric matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># empty plot
plot(NULL, NULL, xlim=c(-180, 180), ylim=c(-90,90))
# then endpoints of the arc
point1&lt;-c(-45,-70)
point2&lt;-c(130,65)
points(arcpoints(point1, point2, breaks=70, output="polar"))

</code></pre>

<hr>
<h2 id='CarToPol'>Conversion of 3d Cartesian coordinates to polar coordinates</h2><span id='topic+CarToPol'></span><span id='topic+CarToPol+2Cmatrix-method'></span><span id='topic+CarToPol+2Cnumeric-method'></span><span id='topic+CarToPol+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>The function uses basic trigonometric relationships to transform XYZ coordinates to polar coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CarToPol(x, ...)

## S4 method for signature 'matrix'
CarToPol(x, norad = FALSE, origin = c(0, 0, 0))

## S4 method for signature 'numeric'
CarToPol(x, norad = FALSE, origin = c(0, 0, 0))

## S4 method for signature 'data.frame'
CarToPol(x, norad = FALSE, origin = c(0, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CarToPol_+3A_x">x</code></td>
<td>
<p>(<code>matrix</code>, <code>data.frame</code>, <code>numeric</code>) A 3 column data matrix with XYZ coordinates in Cartesian space.</p>
</td></tr>
<tr><td><code id="CarToPol_+3A_...">...</code></td>
<td>
<p>Arguments passed to class-specific methods.</p>
</td></tr>
<tr><td><code id="CarToPol_+3A_norad">norad</code></td>
<td>
<p>(<code>logical</code>). Toggles whether the rho coordinate (distance from origin) should be omitted from the output.</p>
</td></tr>
<tr><td><code id="CarToPol_+3A_origin">origin</code></td>
<td>
<p>(<code>numeric</code>) Vector with length <code>3</code>, the XYZ coordinates of the sphere center.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-column or 2-column <code>numeric</code>, <code>matrix</code> or <code>data.frame</code> with longitude, latitude and, if set accordingly, radius data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some random points
xyz &lt;- rbind(
  c(6371, 0,0),
  c(0, 6371,0),
  c(1000,1000,1000)
)

# conversions
  CarToPol(xyz)
</code></pre>

<hr>
<h2 id='cellocator'>Locate grid faces based on their positions on a map</h2><span id='topic+cellocator'></span>

<h3>Description</h3>

<p>The function returns which grid faces contain the points clicked in a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellocator(gridObj, n, output = "faces", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellocator_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code>) The grid object.</p>
</td></tr>
<tr><td><code id="cellocator_+3A_n">n</code></td>
<td>
<p>(<code>integer</code>) The number of points to be looked up.</p>
</td></tr>
<tr><td><code id="cellocator_+3A_output">output</code></td>
<td>
<p>(<code>character</code>) Type of output: <code>"faces"</code> returns only the face names of the points, <code>"full"</code> returns the coordinates as well.</p>
</td></tr>
<tr><td><code id="cellocator_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="graphics.html#topic+locator">locator</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code>character</code> values, each corresponding to a face identifier.
</p>

<hr>
<h2 id='centers'>The face centers of an icosahedral grid object</h2><span id='topic+centers'></span><span id='topic+centers+2Ctrigrid-method'></span><span id='topic+centers+2Cfacelayer-method'></span>

<h3>Description</h3>

<p>Shorthand function to return the <code>@faceCenters</code> slot of an icosahedral grid or a grid linked to a facelayer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centers(x, ...)

## S4 method for signature 'trigrid'
centers(x, output = "polar")

## S4 method for signature 'facelayer'
centers(x, output = "polar")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centers_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+facelayer">facelayer</a></code>). The grid or linked data layer object.</p>
</td></tr>
<tr><td><code id="centers_+3A_...">...</code></td>
<td>
<p>Arguments passed to the class specific methods.</p>
</td></tr>
<tr><td><code id="centers_+3A_output">output</code></td>
<td>
<p>(<code>character</code>) The coordinate system of the output. Either <code>"polar"</code> or <code>"cartesian"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coordinates of the face centers as a <code>numeric</code> matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- trigrid()
centers(a)
</code></pre>

<hr>
<h2 id='chullsphere'>Spherical convex hull.</h2><span id='topic+chullsphere'></span>

<h3>Description</h3>

<p>This function calculates a possible implementation of the spherical convex hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chullsphere(
  data,
  center = c(0, 0, 0),
  radius = authRadius,
  param = 200,
  strict = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chullsphere_+3A_data">data</code></td>
<td>
<p>(<code>numeric</code>) Matrix, XYZ or longitude-latitude coordinates of the set of points.</p>
</td></tr>
<tr><td><code id="chullsphere_+3A_center">center</code></td>
<td>
<p>(<code>numeric</code>) Vector, The center of the sphere in XYZ coordinates (default is 0,0,0).</p>
</td></tr>
<tr><td><code id="chullsphere_+3A_radius">radius</code></td>
<td>
<p>(<code>numeric</code>) Single value, indicating the radius of the sphere. Defaults to the R2 radius of Earth (6371.007km).</p>
</td></tr>
<tr><td><code id="chullsphere_+3A_param">param</code></td>
<td>
<p>(<code>numeric</code>) Single positive integer, indicates the number of divisions in the centroid projection method. The higher the number, the closer the replacement points are to the centroid.</p>
</td></tr>
<tr><td><code id="chullsphere_+3A_strict">strict</code></td>
<td>
<p>(<code>logical</code>) Strictly convex output is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the method <code>centroidprojection</code> the function calls the <code><a href="#topic+surfacecentroid">surfacecentroid</a></code> 
function to get the a reference point from the shape. Then all the points are 'projected' 
close to this point using the great circles linking them to the reference point.
Each such great circle will be devided to an equal number of points and the closest
will replace the original point coordinates in the convex hull algorithm implemented in <code><a href="grDevices.html#topic+chull">chull</a></code>.
</p>


<h3>Value</h3>

<p>The indices of the data points forming the convex hull as a (<code>numeric</code>) vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some random points
allData &lt;- rpsphere(1000)
# select only a subset
points&lt;-allData[allData[,1]&gt;3000,]
chullsphere(points)


</code></pre>

<hr>
<h2 id='edgelength'>Lengths of grid edges</h2><span id='topic+edgelength'></span><span id='topic+edgelength+2Ctrigrid-method'></span>

<h3>Description</h3>

<p>This function will return the length of all edges in the specified grid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelength(gridObj, ...)

## S4 method for signature 'trigrid'
edgelength(gridObj, output = "distance")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgelength_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code> or <code>{hexagrid}</code>) A grid object.</p>
</td></tr>
<tr><td><code id="edgelength_+3A_...">...</code></td>
<td>
<p>Arguments passed to the class specific methods.</p>
</td></tr>
<tr><td><code id="edgelength_+3A_output">output</code></td>
<td>
<p>(<code>character</code>) The type of the output. <code>"distance"</code> will give back the distance
in the metric that was fed to the function in the coordinates or the radius.
<code>"deg"</code> will output the the distance in degrees, <code>"rad"</code> will do
so in radians.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- trigrid(3)
edges &lt;- edgelength(g, output="deg")
edges

</code></pre>

<hr>
<h2 id='edges'>The edges of a 3d object</h2><span id='topic+edges'></span><span id='topic+edges+2Cobj3d-method'></span><span id='topic+edges+2Cfacelayer-method'></span>

<h3>Description</h3>

<p>Shorthand function to get the edges slot of an icosahedral grid or a grid linked to a facelayer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges(x)

## S4 method for signature 'obj3d'
edges(x)

## S4 method for signature 'facelayer'
edges(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+facelayer">facelayer</a></code>) The grid or linked data object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The edges of the grid, as a <code>character</code> matrix.
</p>

<hr>
<h2 id='facelayer-class'>A <code>facelayer</code> linked to a <code>trigrid</code> or <code>hexagrid</code> object</h2><span id='topic+facelayer-class'></span><span id='topic+facelayer'></span>

<h3>Description</h3>

<p>The grids themselves are scaffolds for the assigned data. The data are stored in containers which are linked to the grids.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="facelayer-class_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+trigrid">trigrid</a></code>) The linked grid object.</p>
</td></tr>
<tr><td><code id="facelayer-class_+3A_value">value</code></td>
<td>
<p>(<code>logical</code>,<code>numeric</code> or <code>character</code>) The <code>facelayer</code> will be initialized with these values/this value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>facelayer</code> class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- trigrid(c(4,4))
fl &lt;- facelayer(g, 1:length(g))
# faces3d(fl)
</code></pre>

<hr>
<h2 id='faces'>The faces of a 3d object</h2><span id='topic+faces'></span><span id='topic+faces+2Ctrigrid-method'></span><span id='topic+faces+2Cgridlayer-method'></span>

<h3>Description</h3>

<p>Shorthand function to get the faces slot of an icosahedral grid or a grid linked to a <code><a href="#topic+facelayer">facelayer</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faces(x)

## S4 method for signature 'trigrid'
faces(x)

## S4 method for signature 'gridlayer'
faces(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faces_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+facelayer">facelayer</a></code>) The grid or facelayer object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The faces of the grid as a <code>character</code> matrix.
</p>

<hr>
<h2 id='faces3d'>Methods of 3D face plotting.</h2><span id='topic+faces3d'></span><span id='topic+faces3d+2Ctrigrid-method'></span><span id='topic+faces3d+2Chexagrid-method'></span><span id='topic+faces3d+2Cfacelayer-method'></span>

<h3>Description</h3>

<p>This function is used to plot the faces of either a <code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+facelayer">facelayer</a></code> object in 3D space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faces3d(x, ...)

## S4 method for signature 'trigrid'
faces3d(x, ...)

## S4 method for signature 'hexagrid'
faces3d(x, ...)

## S4 method for signature 'facelayer'
faces3d(x, col = "heat", breaks = NULL, inclusive = TRUE, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faces3d_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+facelayer">facelayer</a></code> object to be plotted.</p>
</td></tr>
<tr><td><code id="faces3d_+3A_...">...</code></td>
<td>
<p>Further graphical parameters passed to (see <code><a href="rgl.html#topic+plot3d">plot3d</a></code>) and the <code><a href="#topic+heatMapLegend">heatMapLegend</a></code> function.</p>
</td></tr>
<tr><td><code id="faces3d_+3A_col">col</code></td>
<td>
<p>(<code>character</code>) Graphical parameter indicating the colours of the faces. A single value is accepted for <code>logical</code> values. Multiple colors will be passed to <code><a href="grDevices.html#topic+colorRamp">colorRampPalette</a></code>, to create palettes for heat maps in case of <code>numeric</code> values. The default plotting method in this case is the reversed <code><a href="grDevices.html#topic+palettes">heat.colors</a></code>. In case of categorical data, random colors will be chosen.</p>
</td></tr>
<tr><td><code id="faces3d_+3A_breaks">breaks</code></td>
<td>
<p>(<code>numeric</code>) Vector stating the breakpoints between the plotted levels. The argument is passed to the <code><a href="base.html#topic+cut">cut</a></code> function.</p>
</td></tr>
<tr><td><code id="faces3d_+3A_inclusive">inclusive</code></td>
<td>
<p>(<code>logical</code>): If there are values beyond the limits of breaks, should these be represented in the plot (<code>TRUE</code>) or left out completely <code>FALSE</code>?</p>
</td></tr>
<tr><td><code id="faces3d_+3A_legend">legend</code></td>
<td>
<p>(<code>logical</code>) Should the heatmap legend be plotted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is built on the openGL renderer of the R package <code>rgl</code>.
</p>


<h3>Value</h3>

<p>The function does not return any value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a hexagonal grid
    g &lt;- hexagrid(c(2,2))
# plot the grid in 3d space
# faces3d(g)
h &lt;- hexagrid(8)
b &lt;- facelayer(h)
values(b)&lt;- rnorm(length(b))
</code></pre>

<hr>
<h2 id='gridensity'>Icosahedral grid-based density estimation</h2><span id='topic+gridensity'></span>

<h3>Description</h3>

<p>Spatial density estimation algorithm based on rotation of icosahedral grids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridensity(x, y, out, trials = 100, FUN = mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridensity_+3A_x">x</code></td>
<td>
<p>Matrix of longitude, latitude data, <code><a href="sf.html#topic+sf">sf</a></code> class, or <code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a></code> Point cloud.</p>
</td></tr>
<tr><td><code id="gridensity_+3A_y">y</code></td>
<td>
<p><code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code> An icosahedral grid.</p>
</td></tr>
<tr><td><code id="gridensity_+3A_out">out</code></td>
<td>
<p><code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="terra.html#topic+rast">SpatRaster</a></code>output structure.</p>
</td></tr>
<tr><td><code id="gridensity_+3A_trials">trials</code></td>
<td>
<p><code>numeric</code> value, the number of iterations.</p>
</td></tr>
<tr><td><code id="gridensity_+3A_fun">FUN</code></td>
<td>
<p><code>function</code> The function to be applied on the iteration results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any points set can be binned to an icosahedral grid (i.e. number of incidences can be counted), which will be dependent on the exact positions of grid cells. Rotating the grid in 3d space will result in a different distribution of counts. This distribution can be resampled to a standard orientation structure. The size of the icosahedral grid cells act as a bandwidth parameter.
</p>
<p>The implemented algorithm 1) takes a point cloud (<code>x</code>)) and an icosahedral grid <code>y</code> 2) randomly rotates the icosahedral grid, 3) looks up the points falling on grid cells, 4) resamples the grid to a constant orientation object (either <code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="terra.html#topic+rast">SpatRaster</a></code>). Steps 2-4 are repeated <code>trial</code> times, and then <code>FUN</code> is applied to every vector of values that have same spatial position.
</p>


<h3>Value</h3>

<p>Either named numeric vector, or a <code><a href="terra.html#topic+rast">SpatRaster</a></code> object. If FUN is set to <code>NULL</code>, the output will be either a <code>matrix</code> or <code><a href="terra.html#topic+rast">SpatRaster</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example to be run if terra is present
if(requireNamespace("terra", quietly=TRUE)){

 # randomly generated points
 x &lt;- rpsphere(100, output="polar")

 # bandwidth grid
 y &lt;- hexagrid(deg=13)

 # output structure
 out &lt;- terra::rast(res=5)

 # the function
 o &lt;- gridensity(x, y, out, trials=7)

 # visualize results
 terra::plot(o)
 points(x, pch=3)
}

</code></pre>

<hr>
<h2 id='gridgraph'>Create or instantiate an <code><a href="igraph.html#topic+make_graph">graph</a></code> class graph from the faces of an icosahedral grid</h2><span id='topic+gridgraph'></span><span id='topic+gridgraph+2Ctrigrid-method'></span><span id='topic+gridgraph+2Chexagrid-method'></span><span id='topic+gridgraph+2Cfacelayer-method'></span>

<h3>Description</h3>

<p>The function can be applied to both grids and to <code><a href="#topic+facelayer">facelayer</a></code>-class object of <code>logical</code> values. The resulting graph will have the characteristics of the original grid (directed/undirected etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridgraph(x, ...)

## S4 method for signature 'trigrid'
gridgraph(x, directed = FALSE, distances = FALSE)

## S4 method for signature 'hexagrid'
gridgraph(x, directed = FALSE, distances = FALSE)

## S4 method for signature 'facelayer'
gridgraph(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridgraph_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+facelayer">facelayer</a></code>) The icosahedral grid or <code><a href="#topic+facelayer">facelayer</a></code>.</p>
</td></tr>
<tr><td><code id="gridgraph_+3A_...">...</code></td>
<td>
<p>Arguments passed to the class specific methods.</p>
</td></tr>
<tr><td><code id="gridgraph_+3A_directed">directed</code></td>
<td>
<p><code>logical</code> Defaults to <code>FALSE</code>, creating an undirected graph. If <code>TRUE</code>, then the graph will be directed.</p>
</td></tr>
<tr><td><code id="gridgraph_+3A_distances">distances</code></td>
<td>
<p><code>logical</code> Defaults to <code>FALSE</code>. If <code>TRUE</code>, then the distances between the linked faces will be calculated and will be rendered to the edges as <code>"dist"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an undirected igraph graph.
</p>

<hr>
<h2 id='gridlabs'>Labels of grid vertices, faces and edges.</h2><span id='topic+gridlabs'></span>

<h3>Description</h3>

<p>This function will show where the grid elements are located.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridlabs(gridObj, type = "f", crs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridlabs_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code>) An icosahedral grid.</p>
</td></tr>
<tr><td><code id="gridlabs_+3A_type">type</code></td>
<td>
<p>(<code>character</code>) The type of element to be plotted: either <code>"f"</code> (faces), <code>"v"</code> (vertices) or  <code>"e"</code> (edges).</p>
</td></tr>
<tr><td><code id="gridlabs_+3A_crs">crs</code></td>
<td>
<p>(<code>character</code> or <code><a href="sf.html#topic+st_crs">crs</a></code>) A coordinate system for the transformation of coordinates.</p>
</td></tr>
<tr><td><code id="gridlabs_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="graphics.html#topic+text">text</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function has no return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gr &lt;- hexagrid(sp=TRUE)
plot(gr)
gridlabs(gr)
</code></pre>

<hr>
<h2 id='gridlabs3d'>Display the names of the grid elements in 3d plots.</h2><span id='topic+gridlabs3d'></span><span id='topic+gridlabs3d+2Ctrigrid-method'></span><span id='topic+gridlabs3d+2Chexagrid-method'></span>

<h3>Description</h3>

<p>This function will display the names of vertices, faces and edges on 3d plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridlabs3d(gridObj, ...)

## S4 method for signature 'trigrid'
gridlabs3d(gridObj, type = "f", ...)

## S4 method for signature 'hexagrid'
gridlabs3d(gridObj, type = "f", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridlabs3d_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code>) An icosahedral grid.</p>
</td></tr>
<tr><td><code id="gridlabs3d_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="rgl.html#topic+texts">text3d</a></code> function of the <code>rgl</code> package.</p>
</td></tr>
<tr><td><code id="gridlabs3d_+3A_type">type</code></td>
<td>
<p>(<code>character</code>) Vector containing either <code>"f"</code>, <code>"e"</code> or <code>"v"</code>, rendering the names
of either the faces, edges or vertives respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function does not return any value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a hexagonal grid
g &lt;- hexagrid(c(2,2))
# plot the grid in 3d space
# lines3d(g, guides=FALSE)
# labels
# gridlabs3d(g)
</code></pre>

<hr>
<h2 id='guides3d'>Guides for 3d spherical plotting.</h2><span id='topic+guides3d'></span>

<h3>Description</h3>

<p>This function plots 3d guidelines for navigation on the surface of the sphere,
includings the rotational axis and a polar coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guides3d(
  axis = 1.5,
  polgrid = c(30, 30),
  textPG = FALSE,
  res = 1,
  origin = c(0, 0, 0),
  radius = authRadius,
  drad = 1.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guides3d_+3A_axis">axis</code></td>
<td>
<p>(<code>numeric</code>) Draws the -90(lat. deg. ) +90 (lat. deg.) axis. The plotted radius will be <code>axis</code> times the authalic radius, ca. 6371km.</p>
</td></tr>
<tr><td><code id="guides3d_+3A_polgrid">polgrid</code></td>
<td>
<p>(<code>numeric</code>) with the length of <code>2</code>, where the first argument specifies
the size of the longitudinal and the second the latitudinal divisions (degrees). Setting this argument to <code>NULL</code> will turn this feature off.</p>
</td></tr>
<tr><td><code id="guides3d_+3A_textpg">textPG</code></td>
<td>
<p>(<code>logical</code>) Flag indicating whether the coordinate values should be added to the 3d render.</p>
</td></tr>
<tr><td><code id="guides3d_+3A_res">res</code></td>
<td>
<p>(<code>numeric</code>) Graphical resolution of the curves:
the distance in degrees between the points of the rendered guides.</p>
</td></tr>
<tr><td><code id="guides3d_+3A_origin">origin</code></td>
<td>
<p>(<code>numeric</code>) Vector of length=3. Indicates the center of the guiding sphere.</p>
</td></tr>
<tr><td><code id="guides3d_+3A_radius">radius</code></td>
<td>
<p>(<code>numeric</code>) Values indicating the radius of the guiding sphere. Defaults to the R2 radius of Earth (6371.007km).</p>
</td></tr>
<tr><td><code id="guides3d_+3A_drad">drad</code></td>
<td>
<p>(<code>numeric</code>) Value, indicates the position of coordinate 3d text relative to the guiding sphere radius.</p>
</td></tr>
<tr><td><code id="guides3d_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="rgl.html#topic+3dobjects">segments3d</a></code>, <code><a href="rgl.html#topic+3dobjects">lines3d</a></code> and <code><a href="rgl.html#topic+texts">text3d</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is built on the openGL renderer of the R package <code>rgl</code>.
</p>


<h3>Value</h3>

<p>The function does not return any value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a hexagonal grid
  g &lt;- hexagrid(c(2,2))
# plot the grid in 3d space
# plot3d(g, guides=FALSE)
# plot the rotational axis in blue
# guides3d(axis=2, polgrid=NULL, col="blue")
# plot the polar grid at 10 degree resolution
# guides3d(axis=NULL, polgrid=c(10,10), col="red")
# plot some coordinates
# guides3d(axis=NULL, polgrid=c(30,30), textPG=TRUE, col="orange", cex=1.4)
</code></pre>

<hr>
<h2 id='heatMapLegend'>Legend for a heatmap with predefined colors.</h2><span id='topic+heatMapLegend'></span>

<h3>Description</h3>

<p>This function will invoke the <code><a href="graphics.html#topic+plot">plot</a></code> function to draw a heatmap legend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatMapLegend(
  cols,
  vals,
  varName,
  tick.text = NULL,
  tick.cex = 1.5,
  barWidth = 3,
  barHeight = 50,
  tickLength = 1,
  xLeft = 88,
  yBot = 25,
  add = FALSE,
  bounds = c(FALSE, FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatMapLegend_+3A_cols">cols</code></td>
<td>
<p>(<code>character</code>) Vector, containnig the ordered colors that are used for the heatmap.</p>
</td></tr>
<tr><td><code id="heatMapLegend_+3A_vals">vals</code></td>
<td>
<p>(<code>numeric</code>) If <code>tick.text</code> is missing, the lowest value in the heatmap</p>
</td></tr>
<tr><td><code id="heatMapLegend_+3A_varname">varName</code></td>
<td>
<p>(<code>character</code>) The label of the variable name plotted to the heatmap.</p>
</td></tr>
<tr><td><code id="heatMapLegend_+3A_tick.text">tick.text</code></td>
<td>
<p>(<code>numeric</code>) The values on the heatmap legend. If missing, will be calculated with <code>minVal</code> and <code>maxVal</code>.</p>
</td></tr>
<tr><td><code id="heatMapLegend_+3A_tick.cex">tick.cex</code></td>
<td>
<p>(<code>numeric</code>) Letter size of the values on the legend.</p>
</td></tr>
<tr><td><code id="heatMapLegend_+3A_barwidth">barWidth</code></td>
<td>
<p>(<code>numeric</code>) The width (percent) of the bar featuring the colors of the heatmap.</p>
</td></tr>
<tr><td><code id="heatMapLegend_+3A_barheight">barHeight</code></td>
<td>
<p>(<code>numeric</code>) The height (percent)of the bar featuring the colors of the heatmap.</p>
</td></tr>
<tr><td><code id="heatMapLegend_+3A_ticklength">tickLength</code></td>
<td>
<p>(<code>numeric</code>)  The length (percent) of the ticks at the bars.</p>
</td></tr>
<tr><td><code id="heatMapLegend_+3A_xleft">xLeft</code></td>
<td>
<p>(<code>numeric</code>) The x coordinate of the lower left hand corner of the bar.</p>
</td></tr>
<tr><td><code id="heatMapLegend_+3A_ybot">yBot</code></td>
<td>
<p>(<code>numeric</code>) The y coordinate of the lower left hand corner of the bar.</p>
</td></tr>
<tr><td><code id="heatMapLegend_+3A_add">add</code></td>
<td>
<p>(<code>logical</code>) Indicates wheter a new plot should be drawn or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="heatMapLegend_+3A_bounds">bounds</code></td>
<td>
<p>(<code>logical</code>) Vector (length 2) indicating whether open intervals should be indicated for the legend.</p>
</td></tr>
<tr><td><code id="heatMapLegend_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'percents' refer to the plotting area measured from the lower left corner.
</p>


<h3>Value</h3>

<p>The function does not return any value.
</p>

<hr>
<h2 id='hexagrid-class'>Construct a penta-hexagonal icosahedral grid</h2><span id='topic+hexagrid-class'></span><span id='topic+hexagrid'></span>

<h3>Description</h3>

<p>The <code>hexagrid</code> function constrcucts a hexa-pentagonal grid based on the inversion of a 
tessellated icosahedron.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="hexagrid-class_+3A_tessellation">tessellation</code></td>
<td>
<p>(<code>numeric</code>) An integer vector with the tessellation values. Each number
describes the number of new edges replacing one original edge. Multiple series of tessellations
are possible this way. The total tessellation is the product of the tessellation vector. 
Higher values result in more uniform cell sizes, but the larger number of tessellation series,
increases the speed of lookup functions.</p>
</td></tr>
<tr><td><code id="hexagrid-class_+3A_deg">deg</code></td>
<td>
<p>(<code>numeric</code>) The target edge length of the grid in degrees. If provided, the function will select the appropriate tessellation vector from the <code><a href="#topic+hexguide">hexguide</a></code>-table, which is closest to the target. Note that these are unlikely to be the exact matches.</p>
</td></tr>
<tr><td><code id="hexagrid-class_+3A_sp">sp</code></td>
<td>
<p>(<code>logical</code>) Flag indicating whether the <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> class representation of the grid
should be added to the object when the grid is calculated. If set to true the <code><a href="#topic+SpPolygons">SpPolygons</a></code> function will be run with with the resolution parameter set to <code>25</code>. The 
resulting object will be stored in slot <code>@sp</code>. As the calculation of this object can increase the grid creation time substantially
by default this argument has a value <code>FALSE</code>. This can be added on demand by running the function <code><a href="#topic+newsp">newsp</a></code>.</p>
</td></tr>
<tr><td><code id="hexagrid-class_+3A_graph">graph</code></td>
<td>
<p>(<code>logical</code>) Flag indicating whether the <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> class representation of the grid
should be added to the object when the grid is calculated. This argument defaults to <code>TRUE</code> because this option has only minor performance load on the grid 
constructor function. For familiarization with the
object structure, however, setting this parameter to <code>FALSE</code> might help, as invoking <code><a href="utils.html#topic+str">str</a></code> on the 'igraph' class slot of the class might flood the console.</p>
</td></tr>
<tr><td><code id="hexagrid-class_+3A_radius">radius</code></td>
<td>
<p>(<code>numeric</code>) The radius of the grid. Defaults to the authalic radius of Earth.</p>
</td></tr>
<tr><td><code id="hexagrid-class_+3A_center">center</code></td>
<td>
<p>(<code>numeric</code>) The origin of the grid in the reference Cartesian coordinate system. Defaults to <code>c(0,0,0)</code>.</p>
</td></tr>
<tr><td><code id="hexagrid-class_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical</code>) Should messages be printed during grid creation?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inherits from the <code>trigrid</code> class.
</p>
<p>The grid structure functions as a frame for data graining, plotting and
calculations. Data can be stored in layers that are linked to the grid object. In the current version only the 
<code><a href="#topic+facelayer">facelayer</a></code> class is implemented which allows the user to render data to the cells
of the grid which are called faces. 
The grid 'user interface' is made up of four primary tables: the <code>@vertices</code> table for the coordinates of the vertices,
the <code>faceCenters</code> for the coordinates of the centers of faces,
the <code>faces</code> and the <code>edges</code> tables that contain which vertices form which faces and edges respectively.
In these tables, the faces and vertices are sorted to form spirals that go from the north pole in a counter-clockwise
direction. In case grid subsetting is performed these tables get truncated.
</p>
<p>At finer resolutions, the large number of spatial elements render all calculations very resource demanding and slow, 
therefore the hierarchical structure created during the tessellation procedure is retained for efficient implementations.
These data are stored in a list in the slot <code>@skeleton</code> and are 0-indexed integer tables for Rccp-based functions. <code>$v</code> 
stores vertex, <code>$f</code> the edge, and <code>$e</code> contains the edge data for plotting and calculations. In these tables
the original hierarchy based orderings of the units are retained, during subsetting, additional vectors are used to indicate
deactivation of these units. Any sort of meddling with the @skeleton object will lead to unexpected behavior.
</p>


<h3>Value</h3>

<p>A hexagonal grid object, with class <code>hexagrid</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>vertices</code></dt><dd><p>Matrix of the vertex coordinates.</p>
</dd>
<dt><code>faces</code></dt><dd><p>Matrix of the verticies forming the faces</p>
</dd>
<dt><code>edges</code></dt><dd><p>Matrix of the vertices forming the edges.</p>
</dd>
<dt><code>tessellation</code></dt><dd><p>Contains the tessellation vector.</p>
</dd>
<dt><code>orientation</code></dt><dd><p>Contains the grid orientation in xyz 3d space, values in radian.</p>
</dd>
<dt><code>center</code></dt><dd><p>The xyz coordinates of the grid's origin/center.</p>
</dd>
<dt><code>div</code></dt><dd><p>Contains the number of faces that a single face of the previous tessellation level is decomposed to.</p>
</dd>
<dt><code>faceCenters</code></dt><dd><p>Contains the xyz coordinates of the centers of the faces on the surface of the sphere.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- hexagrid(c(8), sf=TRUE)
# based on approximate size (4 degrees edge length)
g1 &lt;- hexagrid(deg=4) 
</code></pre>

<hr>
<h2 id='hexguide'>Tessellation guide to <code><a href="#topic+hexagrid">hexagrid</a></code> objects</h2><span id='topic+hexguide'></span>

<h3>Description</h3>

<p>The table includes basic properties of <code><a href="#topic+hexagrid">hexagrid</a></code>s described with specific tessellation parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexguide
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 120 observations and 18 variables:
</p>

<dl>
<dt><code>total</code></dt><dd><p>The total tessellation of the grid, the number of points inserted between icosahedron vertices along an edge.</p>
</dd>
<dt><code>level1</code></dt><dd><p>Level 1 tessellation.</p>
</dd>
<dt><code>level2</code></dt><dd><p>Level 2 tessellation - second value of the tessellation vector. </p>
</dd>
<dt><code>level3</code></dt><dd><p>Level 3 tessellation - third value of the tessellation vector. </p>
</dd>
<dt><code>level4</code></dt><dd><p>Level 4 tessellation - four value of the tessellation vector. </p>
</dd>
<dt><code>faces</code></dt><dd><p>The number of faces in the grid.</p>
</dd>
<dt><code>vertices</code></dt><dd><p>The number of vertices in the grid.</p>
</dd>
<dt><code>meanEdgeLength_deg</code></dt><dd><p>Mean edge length in degrees.</p>
</dd>
<dt><code>sdEdgeLength_deg</code></dt><dd><p>Standard deviation of edge length in degrees.</p>
</dd>
<dt><code>meanEdgeLength_km</code></dt><dd><p>Mean edge length in kilometers.</p>
</dd>
<dt><code>sdEdgeLength_km</code></dt><dd><p>Standard devation of edge length in kilometers.</p>
</dd>
<dt><code>meanArea_km2</code></dt><dd><p>Mean face area in square-kilometers.</p>
</dd>
<dt><code>sdArea_km2</code></dt><dd><p>Standard deviation of face area in square-kilometers.</p>
</dd>
<dt><code>time</code></dt><dd><p>Time to compute grid with an Intel Xeon E-1650 prcessor.</p>
</dd>
<dt><code>time_sp</code></dt><dd><p>Time to compute grid with an Intel Xeon E-1650 prcessor, with the 'sp' member.</p>
</dd>
<dt><code>size</code></dt><dd><p>The size of the grid in bytes.</p>
</dd>
<dt><code>size_sp</code></dt><dd><p>The size of the grid object in bytes, with the 'sp' member.</p>
</dd>
<dt><code>timeLocate_5000</code></dt><dd><p>Time to locate 5000 points with an Intel Xeon E-1650 processor in seconds.</p>
</dd>
</dl>


<hr>
<h2 id='icosa'>Global Triangular and Hexa-Pentagonal Grids Based on Tessellated Icosahedra</h2><span id='topic+icosa'></span>

<h3>Description</h3>

<p>The <b>icosa</b> package provides tools to aggregate and analyze geographic data
using grids based on tessellated icosahedra. The procedures can be set to provide a grid with a
custom resolution. Both the primary triangular and their inverted penta-
hexagonal grids are available for implementation. Additional functions
are provided to position points (latitude-longitude data) on the grids,
to allow 2D and 3D plotting, use raster and vector spatial data.
</p>


<h3>Details</h3>

<p>This is still the Beta version. Notes about found bugs and suggestions are more than welcome!
</p>


<h3>Author(s)</h3>

<p>Adam T. Kocsis (adam.t.kocsis@gmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a triangular grid
tri &lt;- trigrid(c(2,2))
</code></pre>

<hr>
<h2 id='length+2Ctrigrid-method'>The number of faces in a <code>trigrid</code> or <code>hexagrid</code> class object.</h2><span id='topic+length+2Ctrigrid-method'></span><span id='topic+length+2Cgridlayer-method'></span>

<h3>Description</h3>

<p>The length of the object is interpreted as the number of faces it contains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'trigrid'
length(x)

## S4 method for signature 'gridlayer'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length+2B2Ctrigrid-method_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+facelayer">facelayer</a></code>) The object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer value.
</p>

<hr>
<h2 id='lines+2Ctrigrid-method'>Lines method for the <code>trigrid</code> and <code>hexagrid</code> classes</h2><span id='topic+lines+2Ctrigrid-method'></span>

<h3>Description</h3>

<p>This function will invoke the method of the <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> class.
This function will invoke the <code>lines</code> method of the <code><a href="sf.html#topic+sf">sf</a></code> or the  <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'trigrid'
lines(x, crs = NULL, col = 1, lwd = 1, lty = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines+2B2Ctrigrid-method_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code>) Object.</p>
</td></tr>
<tr><td><code id="lines+2B2Ctrigrid-method_+3A_crs">crs</code></td>
<td>
<p>(<code>character</code> or <code><a href="sf.html#topic+st_crs">crs</a></code>) A coordinate system for the transformation of coordinates.</p>
</td></tr>
<tr><td><code id="lines+2B2Ctrigrid-method_+3A_col">col</code></td>
<td>
<p>Line colors - as in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="lines+2B2Ctrigrid-method_+3A_lwd">lwd</code></td>
<td>
<p>Line thickness - as in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="lines+2B2Ctrigrid-method_+3A_lty">lty</code></td>
<td>
<p>Line type - as in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="lines+2B2Ctrigrid-method_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="sp.html#topic+panel">sp.lines</a></code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function has no return value.
</p>

<hr>
<h2 id='lines3d'>Methods of 3d line plotting</h2><span id='topic+lines3d'></span><span id='topic+lines3d+2Ctrigrid-method'></span><span id='topic+lines3d+2CLine-method'></span><span id='topic+lines3d+2CLines-method'></span><span id='topic+lines3d+2CSpatialLines-method'></span><span id='topic+lines3d+2CSpatialLinesDataFrame-method'></span><span id='topic+lines3d+2CPolygon-method'></span><span id='topic+lines3d+2CPolygons-method'></span><span id='topic+lines3d+2CSpatialPolygons-method'></span><span id='topic+lines3d+2CSpatialPolygonsDataFrame-method'></span>

<h3>Description</h3>

<p>This is a generic function used to plot the edge lines of either a <code>trigrid</code> or a <code>hexagrid</code> object, a <code>facelayer</code>, or <code>Spatial</code> objects in 3d space. The method is also implemented for 
the object classes defined by the package 'sp'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lines3d

## S4 method for signature 'trigrid'
lines3d(x, arcs = FALSE, ...)

## S4 method for signature 'Line'
lines3d(x, radius = authRadius, ...)

## S4 method for signature 'Lines'
lines3d(x, radius = authRadius, ...)

## S4 method for signature 'SpatialLines'
lines3d(x, radius = authRadius, ...)

## S4 method for signature 'SpatialLinesDataFrame'
lines3d(x, radius = authRadius, ...)

## S4 method for signature 'Polygon'
lines3d(x, radius = authRadius, ...)

## S4 method for signature 'Polygons'
lines3d(x, radius = authRadius, ...)

## S4 method for signature 'SpatialPolygons'
lines3d(x, radius = authRadius, ...)

## S4 method for signature 'SpatialPolygonsDataFrame'
lines3d(x, radius = authRadius, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines3d_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code>, <code><a href="#topic+facelayer">facelayer</a></code> or <code>sp</code>) Object to be plotted.</p>
</td></tr>
<tr><td><code id="lines3d_+3A_arcs">arcs</code></td>
<td>
<p><code>logical</code> Value setting whether great circle arcs or segments shall be drawn betwenn the points of the grid.</p>
</td></tr>
<tr><td><code id="lines3d_+3A_...">...</code></td>
<td>
<p>Further graphical parameters passed to (see <code><a href="rgl.html#topic+plot3d">plot3d</a></code>).</p>
</td></tr>
<tr><td><code id="lines3d_+3A_radius">radius</code></td>
<td>
<p>(<code>numeric</code>) Used for plotting objects that inherit from <code>Spatial*</code>. The radius of the sphere the sp objects are plotted with. Default to the authalic (R2) radius of Earth.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>nonstandardGenericFunction</code> of length 1.
</p>


<h3>Details</h3>

<p>The function is built on the openGL renderer of the R package <code>rgl</code>, which needs to be installed for the function to run. Although the function is works without attaching rgl, note that if you want to attach both <code>icosa</code> and <code>rgl</code>,the <code>rgl</code> package has to be loaded ifrst otherwise the function will not be usable.
</p>


<h3>Value</h3>

<p>The function does not return any value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a hexagonal grid
  g &lt;- hexagrid(c(2,2))
# plot the grid in 3d space
#  lines3d(g, col="blue")
</code></pre>

<hr>
<h2 id='locate'>Basic lookup function of coordinates on an icosahedral grid</h2><span id='topic+locate'></span><span id='topic+locate+2Ctrigrid+2Cmatrix-method'></span><span id='topic+locate+2Ctrigrid+2Cnumeric-method'></span><span id='topic+locate+2Ctrigrid+2Cdata.frame-method'></span><span id='topic+locate+2Ctrigrid+2Csf-method'></span><span id='topic+locate+2Ctrigrid+2CSpatialPoints-method'></span><span id='topic+locate+2Ctrigrid+2CSpatialPointsDataFrame-method'></span><span id='topic+locate+2Chexagrid+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Basic lookup function of coordinates on an icosahedral grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate(x, y, ...)

## S4 method for signature 'trigrid,matrix'
locate(x, y, randomborder = FALSE, output = "ui")

## S4 method for signature 'trigrid,numeric'
locate(x, y, ...)

## S4 method for signature 'trigrid,data.frame'
locate(x, y, ...)

## S4 method for signature 'trigrid,sf'
locate(x, y, ...)

## S4 method for signature 'trigrid,SpatialPoints'
locate(x, y, ...)

## S4 method for signature 'trigrid,SpatialPointsDataFrame'
locate(x, y, ...)

## S4 method for signature 'hexagrid,matrix'
locate(x, y, output = "ui", randomborder = FALSE, forceNA = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locate_+3A_x">x</code></td>
<td>
<p>(<code>trigrid</code>, <code>hexagrid</code>) Icosahedral grid object.</p>
</td></tr>
<tr><td><code id="locate_+3A_y">y</code></td>
<td>
<p>(<code>matrix</code>, <code>data.frame</code>, <code>numeric</code> or <code>Spatial</code>) Coordinates of individual points. Can be either a two-dimensional 
matrix of long-lat coordinates, a three-dimensional matrix of XYZ coordinates, 
or a set of points with class <code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a></code> or <code><a href="sp.html#topic+SpatialPoints">SpatialPointsDataFrame</a></code>.</p>
</td></tr>
<tr><td><code id="locate_+3A_...">...</code></td>
<td>
<p>Arguments passed to class specific methods.</p>
</td></tr>
<tr><td><code id="locate_+3A_randomborder">randomborder</code></td>
<td>
<p>(<code>logical</code>) Defaults to <code>FALSE</code>. If <code>TRUE</code>, then the points
falling on vertices and edges will be randomly assigned, otherwise they will be kept as <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="locate_+3A_output">output</code></td>
<td>
<p>(<code>character</code>) Either <code>"ui"</code> or <code>"skeleton"</code>. <code>"ui"</code> returns the face 
names used in the user interface, while <code>"skeleton"</code> returns their 
indices used in back-end procedures.</p>
</td></tr>
<tr><td><code id="locate_+3A_forcena">forceNA</code></td>
<td>
<p>(<code>logical</code>) Suppressing the recursive lookup of points falling on subface boundaries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the cell names (as <code>character</code>) where the input coordinates fall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a grid 
g &lt;- trigrid(4)
# some random points
randomPoints&lt;-rpsphere(4, output="polar")
# cells
locate(g, randomPoints)
</code></pre>

<hr>
<h2 id='names+2Cgridlayer-method'>The face names in a <code><a href="#topic+facelayer">facelayer</a></code> class object</h2><span id='topic+names+2Cgridlayer-method'></span>

<h3>Description</h3>

<p>Function to extract the registered face names to which the <code><a href="#topic+facelayer">facelayer</a></code> renders information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gridlayer'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names+2B2Cgridlayer-method_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+facelayer">facelayer</a></code>) Object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code>character</code> values, the names of the faces.
</p>

<hr>
<h2 id='newgraph'>Add an igraph object to a predefined slot in an icosahedral grid</h2><span id='topic+newgraph'></span><span id='topic+newgraph+2Ctrigrid-method'></span>

<h3>Description</h3>

<p>Add an igraph object to a predefined slot in an icosahedral grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newgraph(gridObj, ...)

## S4 method for signature 'trigrid'
newgraph(gridObj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newgraph_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code>) An icosahedral grid.</p>
</td></tr>
<tr><td><code id="newgraph_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="#topic+gridgraph">gridgraph</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new (<code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code>) object with the recalculated graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a grid
g&lt;-trigrid(4, graph=FALSE)
g&lt;-newgraph(g)

</code></pre>

<hr>
<h2 id='newsf'>Add a <code><a href="sf.html#topic+sf">sf</a></code> object to a predefined slot in a <code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code> object</h2><span id='topic+newsf'></span><span id='topic+newsf+2Ctrigrid-method'></span>

<h3>Description</h3>

<p>Add a <code><a href="sf.html#topic+sf">sf</a></code> object to a predefined slot in a <code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newsf(x, res = NULL)

## S4 method for signature 'trigrid'
newsf(x, res = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newsf_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code>) An icosahedral grid.</p>
</td></tr>
<tr><td><code id="newsf_+3A_res">res</code></td>
<td>
<p>(<code>numeric</code>) The number of points inserted between two vertices, passed to <code><a href="#topic+SpPolygons">SpPolygons</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code> object with the new <code>@sf</code> slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-trigrid(4)
a&lt;-newsf(a)
plot(a)
</code></pre>

<hr>
<h2 id='newsp'>Add a <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> object to a predefined slot in a <code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code> object</h2><span id='topic+newsp'></span><span id='topic+newsp+2Ctrigrid-method'></span>

<h3>Description</h3>

<p>Add a <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> object to a predefined slot in a <code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newsp(gridObj, res = NULL)

## S4 method for signature 'trigrid'
newsp(gridObj, res = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newsp_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code>) An icosahedral grid.</p>
</td></tr>
<tr><td><code id="newsp_+3A_res">res</code></td>
<td>
<p>(<code>numeric</code>) The number of points inserted between two vertices, passed to <code><a href="#topic+SpPolygons">SpPolygons</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code> object with the new <code>@sp</code> slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-trigrid(4)
a&lt;-newsp(a)
plot(a)
</code></pre>

<hr>
<h2 id='occupied'>Faces occupied by the specified object</h2><span id='topic+occupied'></span>

<h3>Description</h3>

<p>This function will return a <code><a href="#topic+facelayer">facelayer</a></code> class object showing which faces are occupied by the input object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occupied(gridObj, data, out = "logical", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occupied_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code>) An icoshedral grid.</p>
</td></tr>
<tr><td><code id="occupied_+3A_data">data</code></td>
<td>
<p>(<code>matrix</code>, <code>data.frame</code> or <code>Spatial</code>) The queried data.</p>
</td></tr>
<tr><td><code id="occupied_+3A_out">out</code></td>
<td>
<p>(<code>character</code>) What shall be the output class? Can be either <code><a href="#topic+facelayer">facelayer</a></code> or <code>logical</code> (default.)</p>
</td></tr>
<tr><td><code id="occupied_+3A_...">...</code></td>
<td>
<p>Arguments passed to the class specific methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function on the <code>OccupiedFaces</code> methods that are specific to grid class and input data.
</p>


<h3>Value</h3>

<p>The function Returns a <code><a href="#topic+facelayer">facelayer</a></code>-class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a grid
g &lt;- trigrid(8, sf=TRUE)

# create random points
randPoints &lt;- rpsphere(100,output="polar")

# the faces occupied by these points
occ &lt;- occupied(g, randPoints)
 
 # plot using sf slot independently
plot(g@sf[occ,"geometry"])
points(randPoints, col="red", pch="+")


</code></pre>

<hr>
<h2 id='orientation'>Extracting and setting the grid orientation</h2><span id='topic+orientation'></span><span id='topic+orientation+2Ctrigrid-method'></span><span id='topic+orientation+3C-'></span><span id='topic+orientation+3C-+2Ctrigrid-method'></span>

<h3>Description</h3>

<p>Extracting and setting the grid orientation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orientation(x, ...)

## S4 method for signature 'trigrid'
orientation(x, display = "deg", ...)

orientation(x) &lt;- value

## S4 replacement method for signature 'trigrid'
orientation(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orientation_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code>): Input grid.</p>
</td></tr>
<tr><td><code id="orientation_+3A_...">...</code></td>
<td>
<p>Values passed on to the <code><a href="#topic+rotate">rotate</a></code> function.</p>
</td></tr>
<tr><td><code id="orientation_+3A_display">display</code></td>
<td>
<p>(<code>character</code>) The output unit. In case it is set to <code>"deg"</code> the output will be in degrees, in case it is <code>"rad"</code>, then radians.</p>
</td></tr>
<tr><td><code id="orientation_+3A_value">value</code></td>
<td>
<p>(<code>numeric</code>) The vector of rotation. Passed as the <code>angles</code> argument of <code><a href="#topic+rotate">rotate</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case the function returns does, it returns the orientation angles of the grid (as <code>numeric</code>).
</p>

<hr>
<h2 id='plot'>Plot method for the <code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+facelayer">facelayer</a></code> classes</h2><span id='topic+plot'></span><span id='topic+plot+2Ctrigrid+2CANY-method'></span><span id='topic+plot+2Cfacelayer+2CANY-method'></span><span id='topic+plot+2Ctrigrid+2Cvector-method'></span><span id='topic+plot+2Ctrigrid+2Ctable-method'></span>

<h3>Description</h3>

<p>This function will invoke the <code>plot</code> method of the <code><a href="sf.html#topic+sf">sf</a></code> or the  <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> class.
</p>
<p>The function passes arguments to the plot method of the <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> class. In case a heatmap is plotted and the plotting device gets resized,
some misalignments can happen. If you want to use a differently sized window, use <code><a href="grDevices.html#topic+x11">x11</a></code> to set the height and width before running the function.
</p>
<p>The function matches data referred to the grid and plots it with sf's plotting methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot

## S4 method for signature 'trigrid,ANY'
plot(x, crs = NULL, ...)

## S4 method for signature 'facelayer,ANY'
plot(
  x,
  crs = NULL,
  col = "heat",
  border = NA,
  alpha = NULL,
  frame = FALSE,
  legend = TRUE,
  breaks = NULL,
  inclusive = TRUE,
  discrete = FALSE,
  ...
)

## S4 method for signature 'trigrid,vector'
plot(x, y, crs = NULL, main = "", ...)

## S4 method for signature 'trigrid,table'
plot(x, y, crs = NULL, main = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+facelayer">facelayer</a></code>) The object to be plotted.</p>
</td></tr>
<tr><td><code id="plot_+3A_crs">crs</code></td>
<td>
<p>(<code>character</code> or <code><a href="sf.html#topic+st_crs">crs</a></code>) A coordinate system for the transformation of coordinates.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code>plot</code> function.</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>
<p>(<code>character</code>) Colors passed to a <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code> in case of the <code><a href="#topic+facelayer">facelayer</a></code> contains <code>logical</code> values, a single value is required (defaults to <code>"red"</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_border">border</code></td>
<td>
<p>(<code>character</code>) Specifies the color of the borders of the cells.</p>
</td></tr>
<tr><td><code id="plot_+3A_alpha">alpha</code></td>
<td>
<p>(<code>character</code>) Two digits for the fill colors, in hexadecimal value between <code>0</code> and <code>255</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_frame">frame</code></td>
<td>
<p>(<code>logical</code>) If <code>TRUE</code> the grid boundaries will be drawn with black.</p>
</td></tr>
<tr><td><code id="plot_+3A_legend">legend</code></td>
<td>
<p>(<code>logical</code>): Should the legend be plotted?</p>
</td></tr>
<tr><td><code id="plot_+3A_breaks">breaks</code></td>
<td>
<p>(<code>numeric</code>) The number of breakpoints between the plotted levels. The argument is passed to the <code><a href="base.html#topic+cut">cut</a></code> function.</p>
</td></tr>
<tr><td><code id="plot_+3A_inclusive">inclusive</code></td>
<td>
<p>(<code>logical</code>): If there are values beyond the limits of breaks, should these be represented in the plot (<code>TRUE</code>) or left out completely <code>FALSE</code>?</p>
</td></tr>
<tr><td><code id="plot_+3A_discrete">discrete</code></td>
<td>
<p>(<code>logical</code>): Do the heatmaps symbolize a discrete or a continuous variable? This argument only affects the legend of the heatmap.</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>A named vector or table with names that refer to face names of the grid.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>The main title of the plot</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>standardGeneric</code> of length 1.
</p>


<h3>Value</h3>

<p>The function has no return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple grid, with sf-representation
gr &lt;- hexagrid(4, sf=TRUE)
dat &lt;- 1:nrow(gr@faces)
names(dat) &lt;- paste0("F", dat)
plot(x=gr, y=dat)
</code></pre>

<hr>
<h2 id='plot3d'>3d plotting of an icosahedral grid, its subset or a data layer</h2><span id='topic+plot3d'></span><span id='topic+plot3d.trigrid'></span><span id='topic+plot3d.hexagrid'></span><span id='topic+plot3d.facelayer'></span>

<h3>Description</h3>

<p>The function is built on the openGL renderer of the R package <code>rgl</code>. The default plotting window size is <code>800x800</code> pixels. In case you want to override this, please
use the function with <code>defaultPar3d=FALSE</code> after running <code><a href="rgl.html#topic+par3d">par3d</a></code><code>(windowRect=&lt;&gt;)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3d(x,...)

## S3 method for class 'trigrid'
plot3d(x, type = c("l"), sphere = NULL, add = FALSE, guides = TRUE, ...)

## S3 method for class 'hexagrid'
plot3d(
  x,
  type = c("l"),
  sphere = NULL,
  color = "gray70",
  add = FALSE,
  guides = TRUE,
  ...
)

## S3 method for class 'facelayer'
plot3d(x, type = "f", frame = TRUE, guides = TRUE, defaultPar3d = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+facelayer">facelayer</a></code>) Object to be plotted.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_type">type</code></td>
<td>
<p>(<code>character</code>) Value specifying the part of the grid to be plotted by the call of the function. 
<code>"v"</code> plots the grid vertex points. 
<code>"e"</code> draws the grid edges.
<code>"f"</code> draws the grid faces.
<code>"c"</code> draws the face centers of the grid.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_sphere">sphere</code></td>
<td>
<p>(<code>numeric</code>) Defaults to <code>NULL</code>, adding a central white sphere to the plot. Assigning a <code>numeric</code> value will draw a new sphere with the given radius,
<code>FALSE</code> does not plot the sphere.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_add">add</code></td>
<td>
<p>(<code>logical</code>) Value indicating whether a new plot shall be drawn, or the currently plotted information should be added to the active <code>rgl</code> device.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_guides">guides</code></td>
<td>
<p>(<code>logical</code>) Value indicating whether the guidelines of the polar coordinate system shall be plotted.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_...">...</code></td>
<td>
<p>Further graphical parameters passed to (see <code><a href="rgl.html#topic+plot3d">plot3d</a></code>).</p>
</td></tr>
<tr><td><code id="plot3d_+3A_color">color</code></td>
<td>
<p>(<code>character</code>) Only for the hexagrid plotting: value/values passed to the <code><a href="#topic+faces3d">faces3d</a></code> function instead of <code>col</code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_frame">frame</code></td>
<td>
<p>(<code>logical</code>) If set to TRUE the grid line structure will be plotted.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_defaultpar3d">defaultPar3d</code></td>
<td>
<p>(<code>logical</code>) Flag indicating whether the default settings for <code><a href="rgl.html#topic+par3d">par3d</a></code> are to be used <code>(windowRect = c(50, 60, 800, 800), zoom=0.8)</code>.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>function</code> of length 1.
</p>


<h3>Value</h3>

<p>The function does not return any value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a hexagonal grid
    g &lt;- hexagrid(c(2,2))
# plot the grid in 3d space
#   plot3d(g, col="blue")
# make a subset to select faces
   subG &lt;- subset(g, c("F5", "F2"))
# plot the subset defined above
#    plot3d(subG, type="f", col=c("orange"), add=TRUE, lwd=1)
</code></pre>

<hr>
<h2 id='PolToCar'>Conversion of polar coordinates to 3d Cartesian coordinates</h2><span id='topic+PolToCar'></span><span id='topic+PolToCar+2Cmatrix-method'></span><span id='topic+PolToCar+2Cnumeric-method'></span><span id='topic+PolToCar+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>The function uses basic trigonometric relationships to transform longitude/latitude coordinates on a sphere to xyz Cartesian coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PolToCar(x, ...)

## S4 method for signature 'matrix'
PolToCar(x, radius = authRadius, origin = c(0, 0, 0))

## S4 method for signature 'numeric'
PolToCar(x, radius = authRadius, origin = c(0, 0, 0))

## S4 method for signature 'data.frame'
PolToCar(x, radius = authRadius, origin = c(0, 0, 0), long = NULL, lat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PolToCar_+3A_x">x</code></td>
<td>
<p>(<code>matrix</code>, <code>numeric</code>, <code>data.frame</code>) A 2-column <code>numeric</code> matrix with the longitude/latitude data.</p>
</td></tr>
<tr><td><code id="PolToCar_+3A_...">...</code></td>
<td>
<p>Arguments passed to class-specific methods.</p>
</td></tr>
<tr><td><code id="PolToCar_+3A_radius">radius</code></td>
<td>
<p>(<code>numeric</code>) The radius of the sphere. Defaults to the R2 radius of Earth (6371.007km).</p>
</td></tr>
<tr><td><code id="PolToCar_+3A_origin">origin</code></td>
<td>
<p>(<code>numeric</code>) Vector with length <code>3</code>, the XYZ coordinates of the sphere center.</p>
</td></tr>
<tr><td><code id="PolToCar_+3A_long">long</code></td>
<td>
<p>(<code>character</code>) If <code>x</code> is a <code>data.frame</code>, then the column used as longitudes.</p>
</td></tr>
<tr><td><code id="PolToCar_+3A_lat">lat</code></td>
<td>
<p>(<code>character</code>) If <code>x</code> is a <code>data.frame</code>, then the column used as latitudes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The authalic mean radius of Earth (6371.007 km) is used by this function as a default. The origin is <code>c(0,0,0)</code>. The precision of these conversions is not exact (see example <code>c(0,90)</code> below),
but should be considered acceptable when applied at a reasonable scale (e.g. for global analyses using data above <code>10e-6</code> meters of resolution).
</p>


<h3>Value</h3>

<p>An xyz 3-column numeric <code>matrix</code>, <code>data.frame</code> or <code>numeric</code>, depending on the class of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>longLat &lt;- rbind(
  c(0,0),
  #note the precision here!
  c(0, 90),
  c(-45,12)
)
# matrix-method
xyz &lt;- PolToCar(longLat)
# numeric-method
xyz2 &lt;- PolToCar(longLat[1,])
# data.frame method
xyz3 &lt;- PolToCar(as.data.frame(longLat))
</code></pre>

<hr>
<h2 id='pos'>Position of face centers and vertices on a grid</h2><span id='topic+pos'></span>

<h3>Description</h3>

<p>This function will retrieve the position of a vertex or a face on a <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+trigrid">trigrid</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pos(gridObj, names, output = "polar")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pos_+3A_gridobj">gridObj</code></td>
<td>
<p>a (<code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+trigrid">trigrid</a></code>) Icosahedral grid object.</p>
</td></tr>
<tr><td><code id="pos_+3A_names">names</code></td>
<td>
<p>(<code>character</code>) Vector of the names that are to be looked up.</p>
</td></tr>
<tr><td><code id="pos_+3A_output">output</code></td>
<td>
<p>(<code>character</code>) The coordinate system in which the names are to be shown: use <code>"polar"</code> for longitude-latitude and <code>"cartesian"</code> for XYZ output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vertex and face names can be mixed in a single <code>names</code> argument.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- trigrid(c(4,4))
pos(g, c("F2", "P6", "dummyname"))


</code></pre>

<hr>
<h2 id='resample'>Resampling of data involving a <code><a href="#topic+trigrid">trigrid</a></code> or a <code><a href="#topic+hexagrid">hexagrid</a></code> object.</h2><span id='topic+resample'></span><span id='topic+resample+2CSpatRaster+2Ctrigrid-method'></span><span id='topic+resample+2Cfacelayer+2Ctrigrid-method'></span><span id='topic+resample+2Cfacelayer+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>The function is used to resolve and resample data stored in <code>SpatRaster</code>s and <code><a href="#topic+facelayer">facelayer</a></code>s so they can be fitted to and can be plotted by using <code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code> objects.
</p>
<p>The function applies different resampling algorithms. Currently there are only two implemented methods, one for upscaling and one for downscaling. The downscaling method &quot;average&quot; will tabluate all face centers from the high resolution grid that fall on a coarse resolution cell and average them. The upscaling method &quot;ebaa&quot; (edge breakpoint area approximation) will estimate the areas covered by the high resolution cells using the number of edge breakpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample

## S4 method for signature 'SpatRaster,trigrid'
resample(x, y, method = "near", na.rm = TRUE)

## S4 method for signature 'facelayer,trigrid'
resample(x, y, method = NULL, res = 5)

## S4 method for signature 'facelayer,SpatRaster'
resample(x, y, method = NULL, res = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>(<code><a href="terra.html#topic+rast">SpatRaster</a></code>, <code><a href="#topic+facelayer">facelayer</a></code>) Object to resample.</p>
</td></tr>
<tr><td><code id="resample_+3A_y">y</code></td>
<td>
<p>(<code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+trigrid">trigrid</a></code>) Object describing the target structure.</p>
</td></tr>
<tr><td><code id="resample_+3A_method">method</code></td>
<td>
<p>(<code>character</code>) The name of the algorithm used for resampling.</p>
</td></tr>
<tr><td><code id="resample_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>logical</code>) If a face contains a missing value, should its value be <code>NA</code> as well (<code>FALSE</code>) or calculate the mean anyway (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="resample_+3A_res">res</code></td>
<td>
<p>(<code>numeric</code>) Value indicating the precision of area estimation during the upscaling (<code>facelayer</code>-method). In case the <code>"ebaa"</code> method is chosen, the variable indicate the number of breaking points on an edge.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>standardGeneric</code> of length 1.
</p>


<h3>Details</h3>

<p>This method is necessary to utilize rasterized data in the <code><a href="#topic+icosa">icosa</a></code> package. The only method currently implemented upscales the raster data and then resolves the values to the <code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code> values, using averages. In the case of resampling <code><a href="terra.html#topic+rast">SpatRaster</a></code>s, the <code>method</code> argument will be passed to the <code><a href="terra.html#topic+resample">resample</a></code> function.
</p>


<h3>Value</h3>

<p>A named <code>numeric</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a grid
g &lt;- trigrid(c(4,4))
# create a data layer
fl &lt;- facelayer(g)
fl@values&lt;-rnorm(length(fl))
# target structure
h &lt;- trigrid(4)
# resampling
res &lt;- resample(fl, h)
fl2&lt;-facelayer(h)
fl2@values[] &lt;- res

</code></pre>

<hr>
<h2 id='rotate'>Rotation of <code><a href="#topic+trigrid">trigrid</a></code> and <code><a href="#topic+hexagrid">hexagrid</a></code> objects</h2><span id='topic+rotate'></span><span id='topic+rotate+2Ctrigrid-method'></span>

<h3>Description</h3>

<p>Rotation of <code><a href="#topic+trigrid">trigrid</a></code> and <code><a href="#topic+hexagrid">hexagrid</a></code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate

## S4 method for signature 'trigrid'
rotate(x, angles = "random", pivot = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code>) Input grid.</p>
</td></tr>
<tr><td><code id="rotate_+3A_angles">angles</code></td>
<td>
<p>(<code>numeric</code>): The <code>vector</code> of rotation in radians (three values in each dimension). If set to <code>"random"</code>, the rotation will be random (default).</p>
</td></tr>
<tr><td><code id="rotate_+3A_pivot">pivot</code></td>
<td>
<p>(<code>numeric</code>): The pivot point of the rotation, <code>vector</code> of xyz coordinates. Defaults to <code>NA</code> indicating that the rotation will be around the center of the grid.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>standardGeneric</code> of length 1.
</p>


<h3>Value</h3>

<p>Another <code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code> class object.
</p>

<hr>
<h2 id='rpsphere'>Random point generation on the surface of a sphere</h2><span id='topic+rpsphere'></span>

<h3>Description</h3>

<p>This function will create a predefined number of points randomly distributed
on the surface of a sphere with a given radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpsphere(n = 1, output = "cartesian", radius = authRadius, origin = c(0, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpsphere_+3A_n">n</code></td>
<td>
<p>(<code>numeric</code>) The number of random points to be created.</p>
</td></tr>
<tr><td><code id="rpsphere_+3A_output">output</code></td>
<td>
<p>(<code>character</code>) The coordinate system of the new points. Can either be 
<code>"cartesian"</code> for XYZ coordiates or <code>"polar"</code> for spherical, 
longitude-latitudes coordinates.</p>
</td></tr>
<tr><td><code id="rpsphere_+3A_radius">radius</code></td>
<td>
<p>(<code>numeric</code>) The radius of the sphere</p>
</td></tr>
<tr><td><code id="rpsphere_+3A_origin">origin</code></td>
<td>
<p>(<code>numeric</code>) The center of the sphere (XYZ coordinates).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses a three dimension normal distribution to generate points, 
which are then projected to the surface of the sphere.
</p>


<h3>Value</h3>

<p>A 3-column (XYZ) or a 2-column (long-lat) <code>numeric</code> matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> randomPoints &lt;- rpsphere(2000, output="polar")
# observe latitudinal pattern
 plot(randomPoints, xlim=c(-180, 180), ylim=c(-90, 90))

</code></pre>

<hr>
<h2 id='SpLines'>Create a <code><a href="sp.html#topic+SpatialLines">SpatialLines</a></code> class object from an icosahedral grid</h2><span id='topic+SpLines'></span><span id='topic+SpLines+2Ctrigrid-method'></span>

<h3>Description</h3>

<p>Create a <code><a href="sp.html#topic+SpatialLines">SpatialLines</a></code> class object from an icosahedral grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpLines(gridObj, ...)

## S4 method for signature 'trigrid'
SpLines(gridObj, dateLine = "break", res = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpLines_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code>) Icosahedral grid object.</p>
</td></tr>
<tr><td><code id="SpLines_+3A_...">...</code></td>
<td>
<p>Specific details of the new <code><a href="sp.html#topic+SpatialLines">SpatialLines</a></code> object.</p>
</td></tr>
<tr><td><code id="SpLines_+3A_dateline">dateLine</code></td>
<td>
<p>(<code>logical</code>)Specifies whether <code>NA</code>s should be introduced at the dateline to break the boundaries of the faces. 
Can be switched off by setting it to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="SpLines_+3A_res">res</code></td>
<td>
<p>(<code>numeric</code>) The number of points inserted between two vertices, or <code>NULL</code>, if this is to be set by the package. The default method increases resolution wiht lower tessellation values, and is higher for higher absolute latitudes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="sp.html#topic+SpatialLines">SpatialLines</a></code>.
</p>

<hr>
<h2 id='SpPolygons'>Spatial polygons from an icosahedral grid</h2><span id='topic+SpPolygons'></span><span id='topic+SpPolygons+2Ctrigrid-method'></span><span id='topic+SpPolygons+2Chexagrid-method'></span>

<h3>Description</h3>

<p>The function will create a <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> class 2d representation of the icosahedral grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpPolygons(gridObj, ...)

## S4 method for signature 'trigrid'
SpPolygons(gridObj, res = NULL)

## S4 method for signature 'hexagrid'
SpPolygons(gridObj, res = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpPolygons_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code>) An icosahedral grid.</p>
</td></tr>
<tr><td><code id="SpPolygons_+3A_...">...</code></td>
<td>
<p>Arguments passed to class-specific methods.</p>
</td></tr>
<tr><td><code id="SpPolygons_+3A_res">res</code></td>
<td>
<p>(<code>numeric</code>) The number of points inserted between two vertices, or <code>NULL</code>, if this is to be set by the package. The default method increases resolution with lower tessellation values, and is higher for higher absolute latitudes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- trigrid()
sp &lt;- SpPolygons(a)
</code></pre>

<hr>
<h2 id='subset'>Subsetting an icosahedral grid or data layers organized with them</h2><span id='topic+subset'></span><span id='topic+subset+2Ctrigrid-method'></span><span id='topic+subset+2Chexagrid-method'></span><span id='topic++5B+2Ctrigrid+2CANY+2CANY-method'></span><span id='topic+subset+2Cgridlayer-method'></span>

<h3>Description</h3>

<p>This is a generic function used to access data from either a triangular or hexagonal grid using the names of the faces, integers or logical vectors.
</p>
<p>The function extracts subsets of the <code>gridlayer</code> depending on different criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset

## S4 method for signature 'trigrid'
subset(x, i)

## S4 method for signature 'hexagrid'
subset(x, i)

## S4 method for signature 'trigrid,ANY,ANY'
x[i]

## S4 method for signature 'gridlayer'
subset(x, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+facelayer">facelayer</a></code>) The object to be subsetted.</p>
</td></tr>
<tr><td><code id="subset_+3A_i">i</code></td>
<td>
<p>(<code>logical</code>, <code>numeric</code> or <code>character</code>) The subscript vector, specifying the faces that are used for subsetting. As in <code><a href="base.html#topic+subset">subset</a></code>.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>standardGeneric</code> of length 1.
</p>


<h3>Details</h3>

<p>The function returns subsets of the grid pertaining to the specified faces that can be used for additional operations (e.g. plotting). 
The subscript vector can be either a logical, character or numeric one. The character vector should contain the names of faces, the logical subscript should have 
the same length as the number of faces in the order in which the faces are present in the <code>faces</code> slot. 
The numeric vector can either refer to indices to the rownames of faces in the faces slot, or
to surfaces bounded by longitude/latitude data. In the latter case, the the vector should contain an element with a names of at least one of the <code>"lomax"</code>, <code>"lamax"</code>, 
<code>"lomin"</code> or <code>"lamin"</code> strings (lo for longitude, la: latitude, min: minimum, max: maximum). In case a subset around the dateline is needed a larger longitude to a smaller longitude value is needed (e.g. between <code>150</code> to <code>-150</code>).
</p>
<p>The following methods are incorporated into the function: If <code>i</code> argument is a vector of integers, they will be interpreted as indices. If the <code>numeric</code> <code>i</code> contains either the lamin, lamax, lomin or lomax names, the subsetting will be done using the latitude-longitude coordinates outlined by these 4 values. Logical subsetting and subsetting by face names are also possible.
</p>


<h3>Value</h3>

<p>Subset of the input grid. The class of the original object is retained, the <code>@skeleton</code> slot contains all previous information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a triangular grid
g &lt;- trigrid(c(2,2))

#make a subset pertaining to the faces
subG1 &lt;- subset(g, c("F1", "F33"))
    
#additional way of subsetting
subG2 &lt;- g[1:15] # selects faces F1 through F15
logicalSub&lt;-sample(c(TRUE,FALSE), nrow(g@faces), replace=TRUE)
subG3 &lt;- g[logicalSub]

#plot the subset in 3d space
# plot3d(subG3)

# previously mentioned case around the dateline
gDateLine&lt;-g[c(lomax=-150, lomin=150)]
# plot3d(gDateLine)
</code></pre>

<hr>
<h2 id='surfacearea'>Areas of grid cell surfaces</h2><span id='topic+surfacearea'></span><span id='topic+surfacearea+2Ctrigrid-method'></span><span id='topic+surfacearea+2Chexagrid-method'></span>

<h3>Description</h3>

<p>This function will return the areas of all cells in the specified grid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfacearea(gridObj)

## S4 method for signature 'trigrid'
surfacearea(gridObj)

## S4 method for signature 'hexagrid'
surfacearea(gridObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfacearea_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code>) Object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector, in the metric that was given to the function in the coordinates or the radius. <code>"deg"</code> will output the the distance in degrees, <code>"rad"</code> will do so in radians.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- trigrid(3)
surfaces &lt;- surfacearea(g)
surfaces

</code></pre>

<hr>
<h2 id='surfacecentroid'>Surface centroid point of a spherical point cloud</h2><span id='topic+surfacecentroid'></span><span id='topic+surfacecentroid+2Cmatrix-method'></span><span id='topic+surfacecentroid+2Cdata.frame-method'></span><span id='topic+surfacecentroid+2CSpatialPoints-method'></span>

<h3>Description</h3>

<p>This function the projected place of the centroid from a pointset on the sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfacecentroid(x, ...)

## S4 method for signature 'matrix'
surfacecentroid(x, output = "polar", center = c(0, 0, 0), radius = authRadius)

## S4 method for signature 'data.frame'
surfacecentroid(x, ...)

## S4 method for signature 'SpatialPoints'
surfacecentroid(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfacecentroid_+3A_x">x</code></td>
<td>
<p>(<code>matrix</code> or <code>data.frame</code>) Numeric data, XYZ or longitude-latitude coordinates of the set of points.</p>
</td></tr>
<tr><td><code id="surfacecentroid_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code>matrix</code>-method.</p>
</td></tr>
<tr><td><code id="surfacecentroid_+3A_output">output</code></td>
<td>
<p>(<code>character</code>) The coordinate system of the output points. Can either be <code>"polar"</code> for
longitude-latitude or <code>"cartesian"</code> for XYZ data.</p>
</td></tr>
<tr><td><code id="surfacecentroid_+3A_center">center</code></td>
<td>
<p>(<code>numeric</code>) The center of the sphere in XYZ coordinates (default is 0,0,0).</p>
</td></tr>
<tr><td><code id="surfacecentroid_+3A_radius">radius</code></td>
<td>
<p>(<code>numeric</code>) The radius of the circle in case the input points have only polar coordinates.
Unused when XYZ coordinates are entered. Defaults to the authalic radius of Earth ca. 6371.007km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements great circle calculations to infer on the place of the centroid, which makes it resource demanding. This is necessary
to avoid a particual error that frequently occurrs with other methods for centroid calculation, namely that the place of the centroid is right,
but on the opposite hemisphere.
</p>


<h3>Value</h3>

<p>Either an XYZ or a long-lat <code>numeric</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some random points
allData &lt;- rpsphere(1000)
# select only a subset
points&lt;-allData[allData[,3]&gt;1500,]
# transform to 2d
 points2 &lt;- CarToPol(points, norad=TRUE)
# the spherical centroid
sc &lt;- surfacecentroid(points2, output="polar")
sc

#3d plot
plot(points2, xlim=c(-180, 180), ylim=c(-90, 90))
points(sc[1], sc[2], col="red", cex=5, pch=3)

</code></pre>

<hr>
<h2 id='translate'>Translating an icosahedral grid object in 3d Cartesian space</h2><span id='topic+translate'></span><span id='topic+translate+2Ctrigrid+2Cnumeric-method'></span><span id='topic+translate+2Chexagrid+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The function translates the coordinates of a grid object with the specified 3d vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate(gridObj, vec)

## S4 method for signature 'trigrid,numeric'
translate(gridObj, vec)

## S4 method for signature 'hexagrid,numeric'
translate(gridObj, vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code>) Icosahedral grid object.</p>
</td></tr>
<tr><td><code id="translate_+3A_vec">vec</code></td>
<td>
<p>(<code>numeric</code>) A vector of length 3. This is the translation vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same grid structure as the input, but with translated coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a grid and plot it
g &lt;- trigrid(3)
# lines3d(g)
# translate the grid to (15000,15000,15000)
g2 &lt;- translate(g, c(15000,15000,15000))
# lines3d(g2)

</code></pre>

<hr>
<h2 id='trigrid-class'>A triangular icosahedral grid</h2><span id='topic+trigrid-class'></span><span id='topic+trigrid'></span>

<h3>Description</h3>

<p><code>trigrid()</code> creates a triangular grid based on the
tessellation of an icosahedron.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="trigrid-class_+3A_tessellation">tessellation</code></td>
<td>
<p>(<code>numeric</code>) An integer vector with the tessellation values. Each number
describes the number of new edges replacing one original edge. Multiple series of tessellations
are possible this way. The total tessellation is the product of the tessellation vector. 
Higher values result in more uniform cell sizes, but the larger number of tessellation series
increases the speed of lookup functions.</p>
</td></tr>
<tr><td><code id="trigrid-class_+3A_deg">deg</code></td>
<td>
<p>(<code>numeric</code>) The target edge length of the grid in degrees. If provided, the function will select the appropriate tessellation vector from the <code><a href="#topic+triguide">triguide</a></code>-table, which is closest to the target. Note that these are unlikely to be the exact matches.</p>
</td></tr>
<tr><td><code id="trigrid-class_+3A_sp">sp</code></td>
<td>
<p>(<code>logical</code>) Flag indicating whether the <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> class representation of the grid
should be added to the object when the grid is calculated. If set to <code>TRUE</code> the <code>SpPolygons()</code> function will be run with with the resolution parameter set to 25. The 
resulting object will be stored in slot <code>@sp</code>. As the calculation of this object can substantially increase the grid creation time,
by default this argument has a value of <code>FALSE</code>. The <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> class representation can be added on demand by running the function <code>newsp</code>.</p>
</td></tr>
<tr><td><code id="trigrid-class_+3A_graph">graph</code></td>
<td>
<p>(<code>logical</code>) Flag indicating whether the <code>'igraph'</code> class representation of the grid
should be added to the object when the grid is calculated. This argument defaults to <code>TRUE</code> because this option has only minor performance load on the grid 
constructor function. For familiarization with the
object structure, however, setting this parameter to <code>FALSE</code> might help, as invoking <code><a href="utils.html#topic+str">str</a></code> on the <code>'igraph'</code> class slot of the class might flood the console.</p>
</td></tr>
<tr><td><code id="trigrid-class_+3A_radius">radius</code></td>
<td>
<p>(<code>numeric</code>) The radius of the grid. Defaults to the authalic radius of Earth.</p>
</td></tr>
<tr><td><code id="trigrid-class_+3A_center">center</code></td>
<td>
<p>(<code>numeric</code>) The origin of the grid in the reference Cartesian coordinate system. Defaults to (0,0,0).</p>
</td></tr>
<tr><td><code id="trigrid-class_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical</code>) Should messages be printed during grid creation?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The grid structure functions as a frame for data graining, plotting and spatial
calculations. Data can be stored in layers that are linked to the grid object. In the current version only the 
<code>facelayer</code> class is implemented, which allows the user to render data to the cells
of the grid, which are usually referred to as faces. 
The grid 'user interface' is made up of four primary tables: the <code>@vertices</code> table for the coordinates of the vertices,
the <code>faceCenters</code> for the coordinates of the centers of faces,
the <code>faces</code> and the <code>edges</code> tables that contain which vertices form which faces and edges respectively.
In these tables, the faces and vertices are sorted to form spirals that go from the north pole in a counter-clockwise
direction. In case grid subsetting is performed these tables get truncated.
</p>
<p>At finer resolutions, the large number of spatial elements render all calculations resource demanding and slow, 
therefore the hierarchical structure created during the tessellation procedure is retained for efficient implementation.
These data are stored in a list in the slot <code>@skeleton</code> and are 0-indexed integer tables for Rccp-based functions. <code>$v</code> 
stores vertex, <code>$f</code> the edge, and <code>$e</code> contains the edge data for plotting and calculations. In these tables
the original hierarchy based orderings of the units are retained, during subsetting, additional vectors are used to indicate
deactivation of these units. Any sort of meddling with the <code>@skeleton</code> object will lead to unexpected behavior.
</p>


<h3>Value</h3>

<p>A triangular grid object, with class <code>trigrid</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>vertices</code></dt><dd><p>Matrix of the vertex XYZ coordinates.</p>
</dd>
<dt><code>faces</code></dt><dd><p>Matrix of the verticies forming the faces.</p>
</dd>
<dt><code>edges</code></dt><dd><p>Matrix of the vertices forming the edges.</p>
</dd>
<dt><code>tessellation</code></dt><dd><p>Contains the tessellation vector.</p>
</dd>
<dt><code>orientation</code></dt><dd><p>Contains the grid orientation in xyz 3d space, values in radian relative to the (0,1,0) direction.</p>
</dd>
<dt><code>center</code></dt><dd><p>is the xyz coordinates of the grids origin/center.</p>
</dd>
<dt><code>div</code></dt><dd><p>vector contains the number of faces that a single face of the previous tessellation level is decomposed to.</p>
</dd>
<dt><code>faceCenters</code></dt><dd><p>contains the xyz coordinates of the centers of the faces on the surface of the sphere.</p>
</dd>
<dt><code>belts</code></dt><dd><p>Vector of integers indicating the belt the face belongs to.</p>
</dd>
<dt><code>edgeLength</code></dt><dd><p>the length of an average edge in km and degrees.</p>
</dd>
<dt><code>graph</code></dt><dd><p>an 'igraph' class graph object.</p>
</dd>
<dt><code>length</code></dt><dd><p>integer vector of length=3. The number of vertices, edges and faces in this order.</p>
</dd>
<dt><code>crs</code></dt><dd><p>a CRS class object, by design this is the authalic sphere (ESRI:37008)</p>
</dd>
<dt><code>r</code></dt><dd><p>the radius of the grid</p>
</dd>
<dt><code>sp</code></dt><dd><p>The SpatialPolygons representation of the grid. If missing, it can be created with newsp().</p>
</dd>
<dt><code>sf</code></dt><dd><p>The sf representation of the grid. If missing, it can be created with newsf().</p>
</dd>
<dt><code>skeleton</code></dt><dd><p>data tables with sequential indexing for the C functions.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># single tessellation value
g &lt;- trigrid(c(8))
g
# series of tessellations
g1 &lt;- trigrid(c(2,3,4))
g1
# based on approximate size (4 degrees edge length)
g2 &lt;- trigrid(deg=4) 
</code></pre>

<hr>
<h2 id='triguide'>Tessellation guide to <code><a href="#topic+trigrid">trigrid</a></code> objects</h2><span id='topic+triguide'></span>

<h3>Description</h3>

<p>The table includes basic properties of <code><a href="#topic+trigrid">trigrid</a></code>s described with specific tessellation parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triguide
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 120 observations and 18 variables:
</p>

<dl>
<dt><code>total</code></dt><dd><p>The total tessellation of the grid, the number of points inserted between icosahedron vertices along an edge.</p>
</dd>
<dt><code>level1</code></dt><dd><p>Level 1 tessellation.</p>
</dd>
<dt><code>level2</code></dt><dd><p>Level 2 tessellation - second value of the tessellation vector. </p>
</dd>
<dt><code>level3</code></dt><dd><p>Level 3 tessellation - third value of the tessellation vector. </p>
</dd>
<dt><code>level4</code></dt><dd><p>Level 4 tessellation - four value of the tessellation vector. </p>
</dd>
<dt><code>faces</code></dt><dd><p>The number of faces in the grid.</p>
</dd>
<dt><code>vertices</code></dt><dd><p>The number of vertices in the grid.</p>
</dd>
<dt><code>meanEdgeLength_deg</code></dt><dd><p>Mean edge length in degrees.</p>
</dd>
<dt><code>sdEdgeLength_deg</code></dt><dd><p>Standard deviation of edge length in degrees.</p>
</dd>
<dt><code>meanEdgeLength_km</code></dt><dd><p>Mean edge length in kilometers.</p>
</dd>
<dt><code>sdEdgeLength_km</code></dt><dd><p>Standard devation of edge length in kilometers.</p>
</dd>
<dt><code>meanArea_km2</code></dt><dd><p>Mean face area in square-kilometers.</p>
</dd>
<dt><code>sdArea_km2</code></dt><dd><p>Standard deviation of face area in square-kilometers.</p>
</dd>
<dt><code>time</code></dt><dd><p>Time to compute grid with an Intel Xeon E-1650 prcessor.</p>
</dd>
<dt><code>time_sp</code></dt><dd><p>Time to compute grid with an Intel Xeon E-1650 prcessor, with the 'sp' member.</p>
</dd>
<dt><code>size</code></dt><dd><p>The size of the grid in bytes.</p>
</dd>
<dt><code>size_sp</code></dt><dd><p>The size of the grid object in bytes, with the 'sp' member.</p>
</dd>
<dt><code>timeLocate_5000</code></dt><dd><p>Time to locate 5000 points with an Intel Xeon E-1650 processor in seconds.</p>
</dd>
</dl>


<hr>
<h2 id='trishape'>Shape distortions of the triangular faces and subfaces</h2><span id='topic+trishape'></span><span id='topic+trishape+2Ctrigrid-method'></span><span id='topic+trishape+2Chexagrid-method'></span>

<h3>Description</h3>

<p>This function will return a value that is proportional to the irregularity of a triangonal face or subface. The ratio of the lengths of the shortest and the longest edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trishape(gridObj)

## S4 method for signature 'trigrid'
trishape(gridObj)

## S4 method for signature 'hexagrid'
trishape(gridObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trishape_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code>) Object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value is exactly <code>1</code> for an equilateral triangle, and becomes <code>0</code> as one of the edges approach <code>0</code>.
</p>


<h3>Value</h3>

<p>A named <code>numeric</code> vector, one value for every face of the grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- trigrid(3)
shape &lt;- trishape(g)


</code></pre>

<hr>
<h2 id='values'>Extract and replace values from a gridlayer-derived object (e.g. <code>link{facelayer}</code>).</h2><span id='topic+values'></span><span id='topic+values+2Cgridlayer-method'></span><span id='topic+values+3C-'></span><span id='topic+values+3C-+2Cgridlayer+2CANY-method'></span><span id='topic+values+3C-+2Cgridlayer-method'></span>

<h3>Description</h3>

<p>The function will get the <code>@values</code> slot of a <code><a href="#topic+facelayer">facelayer</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>values(x,...)

## S4 method for signature 'gridlayer'
values(x)

values(x) &lt;- value

## S4 replacement method for signature 'gridlayer,ANY'
values(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="values_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+facelayer">facelayer</a></code>) Object.</p>
</td></tr>
<tr><td><code id="values_+3A_value">value</code></td>
<td>
<p>(<code>logical</code>, <code>character</code> or <code>numeric</code>) Replacement values.</p>
</td></tr>
<tr><td><code id="values_+3A_...">...</code></td>
<td>
<p>Arguments passed to class-specific methods. (Not used.)</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>standardGeneric</code> of length 1.
</p>
<p>An object of class <code>standardGeneric</code> of length 1.
</p>

<hr>
<h2 id='vertices'>The vertices of an icosahedral grid object</h2><span id='topic+vertices'></span><span id='topic+vertices+2Ctrigrid-method'></span><span id='topic+vertices+2Cfacelayer-method'></span>

<h3>Description</h3>

<p>Shorthand function to return the vertices slot of an icosahedral grid or a grid linked to a facelayer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertices(x, ...)

## S4 method for signature 'trigrid'
vertices(x, output = "polar")

## S4 method for signature 'facelayer'
vertices(x, output = "polar")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertices_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code>, <code><a href="#topic+hexagrid">hexagrid</a></code> or <code><a href="#topic+facelayer">facelayer</a></code>) The icosahedral grid, or linked data object.</p>
</td></tr>
<tr><td><code id="vertices_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to class-specific methods.</p>
</td></tr>
<tr><td><code id="vertices_+3A_output">output</code></td>
<td>
<p>(<code>character</code>) The coordinate system of output.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- trigrid(1)
vertices(a)
</code></pre>

<hr>
<h2 id='vicinity'>The neighbouring faces of faces in an icosahedral grid</h2><span id='topic+vicinity'></span><span id='topic+vicinity+2Ctrigrid+2Ccharacter-method'></span>

<h3>Description</h3>

<p>This function will return neighbouring faces of the input faces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vicinity(gridObj, faces, ...)

## S4 method for signature 'trigrid,character'
vicinity(
  gridObj,
  faces,
  order = 1,
  output = "vector",
  self = TRUE,
  namedorder = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vicinity_+3A_gridobj">gridObj</code></td>
<td>
<p>(<code><a href="#topic+trigrid">trigrid</a></code> or <code><a href="#topic+hexagrid">hexagrid</a></code>) Icosahedral grid object.</p>
</td></tr>
<tr><td><code id="vicinity_+3A_faces">faces</code></td>
<td>
<p>(<code>character</code>) A vector specifying names of faces.</p>
</td></tr>
<tr><td><code id="vicinity_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="igraph.html#topic+ego">ego</a></code> function.</p>
</td></tr>
<tr><td><code id="vicinity_+3A_order">order</code></td>
<td>
<p>(<code>numeric</code>) Passed to the <code><a href="igraph.html#topic+ego">ego</a></code> function, an integer value specifying the size of the neighborhood around a face.</p>
</td></tr>
<tr><td><code id="vicinity_+3A_output">output</code></td>
<td>
<p>(<code>character</code>) The type of the output. The default <code>"vector"</code> 
will give back the names of the faces that adjacent to the faces specified, 
including themselves. <code>"list"</code> will return a list.</p>
</td></tr>
<tr><td><code id="vicinity_+3A_self">self</code></td>
<td>
<p>(<code>logical</code>) Flag indicating whether the input faces should be in the output. For the <code>"list"</code> output option, the input face names will be
omitted only from those character vectors that contain face names that are related to the face in question.</p>
</td></tr>
<tr><td><code id="vicinity_+3A_namedorder">namedorder</code></td>
<td>
<p>(<code>logical</code>) Should the orders of the neighbouring cells be reported (<code>TRUE</code>) or just the names of the cells (default, <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector or a <code>list</code> of <code>character</code> vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- trigrid(3)
ne &lt;- vicinity(g, c("F4", "F10"))
ne

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
