<!DOCTYPE html><html><head><title>Help for package sendigR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sendigR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dbCreateIndexes'><p>Create indexes in SEND database</p></a></li>
<li><a href='#dbCreateSchema'><p>Create a SEND schema in an open and empty database</p></a></li>
<li><a href='#dbDeleteStudies'><p>Delete one or more studies in SEND database</p></a></li>
<li><a href='#dbImportOneStudy'><p>Import SEND study data in SAS xport format into a SEND database from a single</p>
study folder</a></li>
<li><a href='#dbImportStudies'><p>Import SEND study data in SAS xport format into a SEND database from a</p>
hierarchy study folders.</a></li>
<li><a href='#disconnectDB'><p>Disconnect from the open database.</p></a></li>
<li><a href='#execSendDashboard'><p>Execute sendDashboard app</p></a></li>
<li><a href='#gen_vocab'><p>Create json file for vocabulary mappings.</p>
Keys are synonyms and values are the CDISC Controlled Terminology Submission values.
Vocabularies are defined by column values from the tab-delimited files.</a></li>
<li><a href='#genericQuery'><p>Execute database query and returns fetched rows.</p></a></li>
<li><a href='#getControlSubj'><p>Extract a list of control animals for a list of studies</p></a></li>
<li><a href='#getFindingsPhase'><p>Extract a set of findings for a specified study phase - or just add phase</p>
for each animal.</a></li>
<li><a href='#getFindingsSubjAge'><p>Add the subject age at finding time - and optionally extract the set of</p>
findings within a specified range of age.</a></li>
<li><a href='#getStudiesSDESIGN'><p>Extract a list of SEND studies with a specified study design - or just add</p>
actual study design for each study.</a></li>
<li><a href='#getStudiesSTSTDTC'><p>Extract a list of SEND studies with study start date within a specified</p>
interval - or just add actual study start date for each study</a></li>
<li><a href='#getSubjData'><p>Extract data from a subject level domain.</p></a></li>
<li><a href='#getSubjRoute'><p>Extract the set of animals of the specified route of administration - or just</p>
add actual route of administration for each animal.</a></li>
<li><a href='#getSubjSex'><p>Extract the set of animals of the specified sex - or just add the sex of each</p>
animal.</a></li>
<li><a href='#getSubjSpeciesStrain'><p>Extract the set of animals of the specified species and strain - or just add</p>
the species and strain for each animal.</a></li>
<li><a href='#getTabColLabels'><p>Get labels for columns in a data.table</p></a></li>
<li><a href='#initEnvironment'><p>Initialize the environment.</p></a></li>
<li><a href='#standardize_file'><p>Standardizes SEND xpt files using CDISC controlled terminologies</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Enable Cross-Study Analysis of 'CDISC' 'SEND' Datasets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A system enables cross study Analysis by extracting and filtering study data for 
    control animals from  'CDISC' 'SEND' Study Repository. 
    These data types are supported: Body Weights, Laboratory test results and Microscopic findings. 
    These database types are supported: 'SQLite' and 'Oracle'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/phuse-org/sendigR">https://github.com/phuse-org/sendigR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/phuse-org/sendigR/issues">https://github.com/phuse-org/sendigR/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>RSQLite, data.table, readxl, magrittr, xfun, stringr,
DescTools, parsedate, shiny, shinydashboard, htmltools, DT,
dplyr, ggplot2, Hmisc, haven, plotly, cicerone, reticulate,
sjlabelled</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, logr, shinycssloaders, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Python(&gt;=3.9.6)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-17 02:48:35 UTC; wangw106</td>
</tr>
<tr>
<td>Author:</td>
<td>Bo Larsen [aut],
  Yousuf Ali [aut],
  Kevin Snyder [aut],
  William Houser [aut],
  Brianna Paisley [aut],
  Cmsabbir Ahmed [aut],
  Susan Butler [aut],
  Michael Rosentreter [aut],
  Michael Denieu [aut],
  Wenxian Wang [cre, aut],
  BioCelerate [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wenxian Wang &lt;wenxian.wang@bms.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-18 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dbCreateIndexes'>Create indexes in SEND database</h2><span id='topic+dbCreateIndexes'></span>

<h3>Description</h3>

<p>Create a set of indexes on the tables in an SQLite SEND database to
optimize performance of extraction of data from the different functions in
the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbCreateIndexes(dbToken, replaceExisting = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbCreateIndexes_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="dbCreateIndexes_+3A_replaceexisting">replaceExisting</code></td>
<td>
<p>Mandatory, character<br />
Whether an already existing set of indexes in the database may be replaced
by a new set of indexes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the indexes are named <code>&lt;domain name&gt;_sendigr_&lt;nn&gt;</code> - .e.g.
<code>TS_sendigr_01</code>.<br />
If any additional indexes are manually created in the database, avoid to
include 'sendigr' in the name, because all existing indexes with that
included in the name will be initially deleted when execution the function
with <code>replaceExisting = TRUE</code>.<br />
It's recommended to wait with the creation of the indexes until the major
amount of studies to be loaded in to the database are loaded.
</p>
<p>The database must be an SQLite database - no other types of databases are
supported by this function.
</p>


<h3>Value</h3>

<p>No return value, called for side effects<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
createAllIndexes(myDbToken)

## End(Not run)

</code></pre>

<hr>
<h2 id='dbCreateSchema'>Create a SEND schema in an open and empty database</h2><span id='topic+dbCreateSchema'></span>

<h3>Description</h3>

<p>Create all the domains and variables which are described in the SEND IG
versions 3.0 and 3.1 in the database - i.e. a union of domains from the
SEND IG versions and in each domain a union of variables from the SEND IG
versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbCreateSchema(dbToken)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbCreateSchema_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The database must be an SQLite database - no other types of databases are
supported by this function.
</p>


<h3>Value</h3>

<p>No return value, called for side effects<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create an empty SQLite database and create the SEND schema
myDbToken &lt;- initEnvironment(dbType = 'sqlite',
                             dbPath ='/mydatapath/db/send.db',
                             dbCreate = TRUE)
dbCreateSchema(myDbToken)

## End(Not run)
</code></pre>

<hr>
<h2 id='dbDeleteStudies'>Delete one or more studies in SEND database</h2><span id='topic+dbDeleteStudies'></span>

<h3>Description</h3>

<p>Deletes data from all domains for one or more studies in an SQLite based SEND
database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbDeleteStudies(dbToken, studyIdList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbDeleteStudies_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="dbDeleteStudies_+3A_studyidlist">studyIdList</code></td>
<td>
<p>Mandatory, character<br />
A list or vector of study id values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The database must be a SQLite database - no other types of databases are
supported by this function.
</p>


<h3>Value</h3>

<p>No return value, called for side effects<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# delete one study
dbDeleteStudies(myDbToken, '122312')
# delete multiple studies
dbDeleteStudies(myDbToken, list('122312', '552343', '0942347'))

## End(Not run)
</code></pre>

<hr>
<h2 id='dbImportOneStudy'>Import SEND study data in SAS xport format into a SEND database from a single
study folder</h2><span id='topic+dbImportOneStudy'></span>

<h3>Description</h3>

<p>Check each of the SAS xpt file located in the specified folder - import
content from file and load it into the corresponding SEND domain table in the
open database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbImportOneStudy(dbToken, xptPath, overWrite = FALSE, checkRequiredVars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbImportOneStudy_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="dbImportOneStudy_+3A_xptpath">xptPath</code></td>
<td>
<p>Mandatory, character<br />
Location of the SAS xport files</p>
</td></tr>
<tr><td><code id="dbImportOneStudy_+3A_overwrite">overWrite</code></td>
<td>
<p>Mandatory, boolean<br />
Whether an already existing study in the database may be overwritten by
newly imported data.</p>
</td></tr>
<tr><td><code id="dbImportOneStudy_+3A_checkrequiredvars">checkRequiredVars</code></td>
<td>
<p>Mandatory, boolean<br />
Whether not-required domains are checked for existence and content of
required variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These requirements to the content of the folder must be fulfilled:
</p>

<ol>
<li><p> The folder must contain some SAS xport files named
<code>[send domain].xpt</code> - the case of the file names doesn't care
</p>
</li>
<li><p> A minimum set of required domain files must be included:
<code>ts.xpt</code>, <code>tx.xpt</code>, <code>dm.xpt</code>.
</p>
</li>
<li><p> Each xpt file must contain one data table with same name as the file
name - i.e. a send domain name.
</p>
</li>
<li><p> Each xpt file must contain a non-empty STUDYID value in each row equal
to the value of TS.STUDYID.
</p>
</li>
<li><p> Each xpt file must contain a set of required column(s).<br />
In general it's (where relevant for the different kinds of domains):<br />
<code>STUDYID, DOMAIN, --SEQ, USUBJID, --TESTCD, --TEST,--ORRES, --ORRESU,
   --STRESC, --STRESN, --STRESU</code>
</p>
</li>
<li><p> The DOMAIN variable must contain the name of the actual domain in
all rows
</p>
</li></ol>

<p>The last two requirements are checked for the required domains in all cases.
For other domains, these two requirements are only checked if parameter
<code>checkRequiredVars = TRUE</code>.<br />
</p>
<p>If an error is detected, the import and load of data is canceled, and further
execution is aborted (i.e. error message is written to the console).<br />
These error situations are checked and reported:
</p>

<ul>
<li><p> Any of the requirements 1 to 3 are not fulfilled or any of the
following requirements are not fulfilled for one of the required domains
</p>
</li>
<li><p> A study with the same value if STUDYID exists in the database and
parameter <code>overWrite = FALSE</code>.
</p>
</li></ul>

<p>If one of the requirements 4 to 6 are not fulfilled for a not-required
domain, this domain is excluded from the import. These kinds of issues are
reported as one warning message to the console when data has been loaded.<br />
</p>
<p>Some non-critical issues, which doesn't prohibit data to be loaded to the
database may be detected. These are reported as one warning message to the
console when data has been loaded (together with eventual warning messages
for skipped domains).<br />
These non-critical issues are checked and reported:
</p>

<ul>
<li><p> The study folder contains one or more xpt file(s) with names(s) not
matching SEND domain name(s).<br />
Such files are ignored by the import/load process.
</p>
</li>
<li><p> An imported data tables contains one or more column(s) which
do(es)n't exist(s) in the corresponding domain.
</p>
</li></ul>

<p>The database must be an SQLite database - no other types of databases are
supported by this function.
</p>


<h3>Value</h3>

<p>No return value, called for side effects<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Do not overwrite if study already exists in the database
dbImportOneStudy(myDbToken,'/mydatapath/studies/1213443')
# Allow to overwrite data if study already exists in the database
dbImportOneStudy(myDbToken,'/mydatapath/studies/786756', overwrite = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='dbImportStudies'>Import SEND study data in SAS xport format into a SEND database from a
hierarchy study folders.</h2><span id='topic+dbImportStudies'></span>

<h3>Description</h3>

<p>For each non-empty folder below the specified root folder, the actions to
import a set of SAS xpt files into the opened SQLlite database described
for function <a href="#topic+dbImportOneStudy">dbImportOneStudy</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbImportStudies(
  dbToken,
  xptPathRoot,
  overWrite = FALSE,
  checkRequiredVars = TRUE,
  verbose = FALSE,
  logFilePath = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbImportStudies_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="dbImportStudies_+3A_xptpathroot">xptPathRoot</code></td>
<td>
<p>Mandatory, character<br />
Root location of a set of sub folders - each sub folder with a set of SAS xport
files for one study to import.<br />
The folder tree is traversed recursively - i.e. a multilevel folder
hierarchy is allowed.</p>
</td></tr>
<tr><td><code id="dbImportStudies_+3A_overwrite">overWrite</code></td>
<td>
<p>Mandatory, boolean<br />
Whether an already existing study in the database may be overwritten by
newly imported data.</p>
</td></tr>
<tr><td><code id="dbImportStudies_+3A_checkrequiredvars">checkRequiredVars</code></td>
<td>
<p>Mandatory, boolean<br />
Whether not-required domains are checked for existence and content of
required variables</p>
</td></tr>
<tr><td><code id="dbImportStudies_+3A_verbose">verbose</code></td>
<td>
<p>Mandatory, boolean<br />
Whether the status of the import shall be continuously written to the
console for for each processed sub folder.</p>
</td></tr>
<tr><td><code id="dbImportStudies_+3A_logfilepath">logFilePath</code></td>
<td>
<p>Optional, character<br />
A path to a folder to contain a log file with the status of the import for
each processed sub folder.<br />
The name of the log file is <code>logFilePath/dbImportStudies_&lt;date &amp;
  time&gt;.log</code> where <code>&lt;date &amp; time&gt;</code> is the actual date and time in format
<code>YYYYmmdd_HH24MISS</code> - e.g. <code>dbImportStudies_20210323_084150.log</code>
if the function was called 23. March 2021 at 8:41:50</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The status for the processing of each sub folder is caught and returned as
described below.<br />
If parameter <code>verbose = TRUE</code>, the status for each processed sub folder
is also printed to the console each time a sub folder has been processed -
i.e. it's possible to followed the progress of the import process.
If parameter <code>logFilePath</code> has been specified with an existing path to a
folder, the status for each processed sub folder is also printed to a log
file in this folder each time a sub folder has been processed.
</p>
<p>The database must be an SQLite database - no other types of databases are
supported by this function.
</p>


<h3>Value</h3>

<p>A list containing a named element with the import status for each
of the processed sub folders.<br />
Each of the statuses are one of three variants:
</p>

<ul>
<li><p> 'OK' - the SAS xport files has been imported to the database with
no errors or warnings
</p>
</li>
<li><p> 'Warning: [list of warnings]' - the SAS xport files has been
imported to the database but have one or more warnings
</p>
</li>
<li><p> 'Cancelled: [error message]' - the SAS xport files have not been
imported to the database because an error has been detected.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Import studies from a set of folders - do not allow to overwrite
# existing study data in the database, follow the progress
dbImportStudies(myDbToken,'/mydatapath/studies', verbose = TRUE)
# Import studies from another set of folders - allow to overwrite existing
# study data in the database
dbImportStudies(myDbToken,'/mydatapath/project123/studies', overwrite = TRUE)
# Import studies from a set of folders , save the status of each study load
# in a log file
dbImportStudies(myDbToken,'/mydatapath/studies',
                logFilePath = '/my/log file/path')

## End(Not run)
</code></pre>

<hr>
<h2 id='disconnectDB'>Disconnect from the open database.</h2><span id='topic+disconnectDB'></span>

<h3>Description</h3>

<p>Close database session and disconnect from open database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disconnectDB(dbToken)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disconnectDB_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
disconnectDB()

## End(Not run)
</code></pre>

<hr>
<h2 id='execSendDashboard'>Execute sendDashboard app</h2><span id='topic+execSendDashboard'></span>

<h3>Description</h3>

<p>Executes an encapsulated Shiny which to query, visualize and extract historical
control data from a SEND database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>execSendDashboard(dbToken)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="execSendDashboard_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory - token for the open database connection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function does not return anything, but it is possible to extract
data from the app in different formats to use for further processing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dbToken &lt;- initEnvironment(dbType='sqlite', dbPath='/path/to/database/send.db')
execSendDashboard(dbToken)
disconnectDB(dbToken)

## End(Not run)
</code></pre>

<hr>
<h2 id='gen_vocab'>Create json file for vocabulary mappings.
Keys are synonyms and values are the CDISC Controlled Terminology Submission values.
Vocabularies are defined by column values from the tab-delimited files.</h2><span id='topic+gen_vocab'></span>

<h3>Description</h3>

<p>Create json file for vocabulary mappings.
Keys are synonyms and values are the CDISC Controlled Terminology Submission values.
Vocabularies are defined by column values from the tab-delimited files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_vocab(in_file, out_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_vocab_+3A_in_file">in_file</code></td>
<td>
<p>Mandatory.<br />
List of tab-delimited files with synonyms and preferred terms.</p>
</td></tr>
<tr><td><code id="gen_vocab_+3A_out_path">out_path</code></td>
<td>
<p>Mandatory.<br />
output json filename. <br /></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gen_vocab(list(infile1, infile2),jsonfile)

## End(Not run)
</code></pre>

<hr>
<h2 id='genericQuery'>Execute database query and returns fetched rows.</h2><span id='topic+genericQuery'></span>

<h3>Description</h3>

<p>The function executes a SQL select statements in the database and returns
the fetched set of rows as a data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genericQuery(dbToken, queryString, queryParams = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genericQuery_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="genericQuery_+3A_querystring">queryString</code></td>
<td>
<p>Mandatory, character.<br />
The select statement to execute</p>
</td></tr>
<tr><td><code id="genericQuery_+3A_queryparams">queryParams</code></td>
<td>
<p>Optional, character.<br />
A variable with values for bind variable referenced in the where clause of
the select statement</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.table with the set of fetched rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
genericQuery(dbToken,
             'select studyid, tsseq, tsgrpid, tsparmcd, tsval from ts')
genericQuery(dbToken,
             'select studyid, tsval from ts where tsprmcd = "SDESIGN" and studyid in (:1)',
             list("1234546","222333","444555"))

## End(Not run)
</code></pre>

<hr>
<h2 id='getControlSubj'>Extract a list of control animals for a list of studies</h2><span id='topic+getControlSubj'></span>

<h3>Description</h3>

<p>Returns a data table with a list of animals belonging to the groups for
negative control in the given list of studies.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getControlSubj(dbToken, studyList, inclUncertain = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getControlSubj_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory.<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="getControlSubj_+3A_studylist">studyList</code></td>
<td>
<p>Mandatory, data.table.<br />
A table with a list of studies to limit the output to be within this
set of studies.<br />
The table must include a column named 'STUDYID'.</p>
</td></tr>
<tr><td><code id="getControlSubj_+3A_incluncertain">inclUncertain</code></td>
<td>
<p>Mandatory, boolean.<br />
Indicates whether animals, which cannot be identified as neither negative
nor positive control (i.e. uncertain animals), shall be included or not in
the output data table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The set of animals contains all animals from DM where the SETCD
is associated with a TX parameter 'TCNTRL'. Negative control animals are
further defined by
</p>

<ul>
<li><p>  either containing a word from a set of words, to
automatically distinguish it as a negative control:
</p>

<ul>
<li><p> ['placebo', 'untreated', 'sham']
</p>
</li></ul>

</li>
<li><p> or containing a combination of a word  from of two lists:
</p>

<ol>
<li><p> ['negative', 'saline', 'peg', 'vehicle', 'citrate', 'dextrose', 'water', 'air']
</p>
</li>
<li><p> ['item', 'control', 'article']
</p>
</li></ol>

</li></ul>

<p>Animals are in all cases excluded (i.e. whether <code>inclUncertain=TRUE</code> or
<code>inclUncertain=FALSE</code>) from the output set, when they are identified as
positive control animals - i.e. they are associated with a TX parameter
'TCNTRL' containing a word from this set of words:
</p>

<ul>
<li><p> ['positive','reference']
</p>
</li></ul>

<p>The age in days at reference start date is calculated for each animal based
on the age related variables in DM:
</p>

<ol>
<li><p> If BRTHDTC is populated compute DM.RFSTDTC – DM.BRTHDTC + 1
</p>
</li>
<li><p> Else If AGE is populated convert from units specified in AGEU to days.
</p>
</li>
<li><p> Else If AGETXT is populated convert the mid-point of the range from
units specified in AGEU to days.<br />
These AGEU units are handled with the described conversion from value to
number of days:
</p>

<ul>
<li><p> DAYS
</p>
</li>
<li><p> WEEKS   : value * 7
</p>
</li>
<li><p> MONTHS  : value * 365/12
</p>
</li>
<li><p> YEARS   : value * 365
</p>
</li></ul>

</li></ol>

<p>If input parameter <code>inclUncertain=TRUE</code>, uncertain animals are included
in the output set. These uncertain situations are identified and reported (in
column UNCERTAIN_MSG):
</p>

<ul>
<li><p> TX parameter 'TCNTRL' is missing
</p>
</li>
<li><p> TXVAL for TX parameter 'TCNTRL' cannot be identified as Negative or
Positive control according to the algorithm described above
</p>
</li></ul>



<h3>Value</h3>

<p>The function return a data.table with columns:
</p>

<ul>
<li><p> STUDYID       (character)
</p>
</li>
<li><p> Additional columns contained in the <code>studyList</code> table
</p>
</li>
<li><p> TCNTRL        (character)<br />
The value of the TX parameter TCNTRL which is used for identification
of whether it is a negative control group or not
</p>
</li>
<li><p> USUBJID       (character)
</p>
</li>
<li><p> RFSTDTC       (character)
</p>
</li>
<li><p> DM_AGEDAYS    (integer)<br />
The calculated age in days of the animal at the reference start day
- i.e. the age registered in DM.
</p>
</li>
<li><p> DSDECOD    (character)<br />
The standardized disposition term for the animal
</p>
</li>
<li><p> DS_AGEDAYS    (integer)<br />
The calculated age in days of the animal at the disposition
</p>
</li>
<li><p> NO_AGE_MSG    (character)<br />
Empty or contains the reason if a DM_AGEDAYS couldn't be calculated
</p>
</li>
<li><p> UNCERTAIN_MSG (character)<br />
Included when parameter <code>inclUncertain=TRUE</code>.<br />
Contains the reason for an uncertain animal is NA for rows for
confident identified negative control animals.
</p>
</li>
<li><p> NOT_VALID_MSG (character)<br />
Included if the column is included in data table specified in
<code>studyList</code>,
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
controlAnimals &lt;- getControlSubj(myDbToken, allSTudies)

## End(Not run)
</code></pre>

<hr>
<h2 id='getFindingsPhase'>Extract a set of findings for a specified study phase - or just add phase
for each animal.</h2><span id='topic+getFindingsPhase'></span>

<h3>Description</h3>

<p>Returns a data table with the set of findings rows included in the
<code>findings</code> of the phase(s) specified in the <code>phaseFilter</code>.<br />
If the <code>phaseFilter</code> is empty (null, na or empty string), all rows from
<code>findings</code> are returned with the an additional PHASE column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFindingsPhase(
  dbToken,
  findings,
  phaseFilter = NULL,
  inclUncertain = FALSE,
  noFilterReportUncertain = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFindingsPhase_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="getFindingsPhase_+3A_findings">findings</code></td>
<td>
<p>Mandatory, data.table.<br />
A data.table with the set of finding rows to process.<br />
The table must include at least columns named
</p>

<ul>
<li><p> STUDYID
</p>
</li>
<li><p> USUBJID
</p>
</li>
<li><p> DOMAIN
</p>
</li>
<li><p> domainSEQ
</p>
</li>
<li><p> domainDTC
</p>
</li></ul>

<p>where domain is the name of the actual findings domain - e.g. LBSEQ and
LBDTC</p>
</td></tr>
<tr><td><code id="getFindingsPhase_+3A_phasefilter">phaseFilter</code></td>
<td>
<p>Optional, character.<br />
The phase value criterion to be used for filtering of the list of animals.<br />
It can be a single string, a vector or a list of multiple strings.</p>
</td></tr>
<tr><td><code id="getFindingsPhase_+3A_incluncertain">inclUncertain</code></td>
<td>
<p>Mandatory, boolean.<br />
Only relevant if the <code>phaseFilter</code> is not empty.<br />
Indicates whether finding rows for which the phase cannot be confidently
identified shall be included or not in the output data table.</p>
</td></tr>
<tr><td><code id="getFindingsPhase_+3A_nofilterreportuncertain">noFilterReportUncertain</code></td>
<td>
<p>Mandatory, boolean.<br />
Only relevant if the <code>phaseFilter</code> is empty.<br />
Indicates if the reason should be included if the phase cannot be
confidently decided for an animal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logic for the extraction is based on the subject elements and the trial
design domains - for each finding row:
</p>

<ul>
<li><p> The related subject element is found in SE as the row where the
value of domainDTC is within the interval from SESTDTC to SEENDTC
</p>
</li>
<li><p> The actual EPOCH is found in TA in the row matching the found
element (via the ETCD value)
</p>
</li>
<li><p> The actual study phase is derived from the EPOCH value matching at
set of text patterns
</p>
</li></ul>

<p>For pooled findings rows - i.e. POOLID is populated instead of USUBJID - the
phase is identified per animal included in the each pool and finding, and if all
identified phases are equal per pool and finding, the identified phase are
returned per pool and finding.
</p>
<p>The populated value of a phase is one of:
</p>

<ul>
<li><p> 'Screening'<br />
If TA.EPOCH fulfills one:
</p>

<ul>
<li><p> contains 'pre' followed by one of
['treat','trt','dos',test','study','exposure']
</p>
</li>
<li><p> contains one of
['acclimat','screen','baseline','allocat','random']
</p>
</li></ul>

</li>
<li><p> 'Recovery'<br />
If TA.EPOCH doesn't fulfill the pattern for 'Screening' and fulfills one
of:
</p>

<ul>
<li><p> contains 'recovery'
</p>
</li>
<li><p> contains 'post' followed by one of
['treat','trt','dos','test','study','exposure']
</p>
</li></ul>

</li>
<li><p> 'Treatment'<br />
If TA.EPOCH doesn't fulfill the patterns for 'Screening' or 'Recovery'
and fulfills both:
</p>

<ul>
<li><p> contains one of
['treat','trt','dos','test','exposure']
</p>
</li>
<li><p> does not contain any of
['off','non'|','free'|','holiday']
</p>
</li></ul>

</li>
<li><p> 'Uncertain'<br />
If the TA.EPOCH is empty or does not fulfills any of the requirements
described for the three phases above.
</p>
</li></ul>

<p>If input parameter <code>inclUncertain=TRUE</code>, findings rows where the phase
cannot be confidently identified are included in the output set. These
uncertain situations are identified and reported (in column UNCERTAIN_MSG):
</p>

<ul>
<li><p> One of the date/time values SESTDTC, SEENDTC or domainDTC is empty
or contains an invalid ISO 8601 value
</p>
</li>
<li><p> The value of domainDTC is included in more then one SESTDTC/SEENDTC
interval
</p>
</li>
<li><p> The EPOCH value does not match any of the patterns identifying the
set of possible study phases.
</p>
</li>
<li><p> Different phases have been identified for individual subjects in a
pool for a given finding
</p>
</li></ul>

<p>The same checks are performed and reported in column NOT_VALID_MSG if
<code>phaseFilter</code> is empty and <code>noFilterReportUncertain=TRUE</code>.
</p>


<h3>Value</h3>

<p>The function returns a data.table with columns in this order:
</p>

<ul>
<li><p> All columns contained in the <code>findings</code> input table (original
order except optional UNCERTAIN_MSG and NOT_VALID_MSG)
</p>
</li>
<li><p> PHASE          (character)
</p>
</li>
<li><p> UNCERTAIN_MSG  (character)<br />
Included when parameter <code>inclUncertain=TRUE</code>.<br />
In case the phase cannot be confidently matched during the
filtering of data, the column contains an indication of the reason.<br />
If any uncertainties have been identified for individual subjects included in
pools for pooled finding rows, all messages for subjects per pool/findings
are merged together and reported as one message per pool/finding.<br />
Is NA for rows where phase can be confidently matched.<br />
A non-empty UNCERTAIN_MSG value generated by this function is merged with
non-empty UNCERTAIN_MSG values which may exist in the input set of findings
specified in <code>findings</code> - separated by '|'.
</p>
</li>
<li><p> NOT_VALID_MSG (character)<br />
Included when parameter <code>noFilterReportUncertain=TRUE</code>.<br />
In case the phase cannot be confidently decided, the column
contains an indication of the reason.<br />
Is NA for rows where phase can be confidently decided.<br />
A non-empty NOT_VALID_MSG value generated by this function is merged with
non-empty NOT_VALID_MSG values which may exist in the input set of findings
<code>findings</code> - separated by '|'.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract LB rows for the Treatment phase - include uncertain rows
getFindingsPhase(dbToken, lb,
                 phaseFilter = 'Treatment',
                 inclUncertain = TRUE)
# No filtering, just add PHASE to FW rows - do not include messages when
# the phase cannot be confidently identified
getFindingsPhase(dbToken, fw,
                 noFilterReportUncertain = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='getFindingsSubjAge'>Add the subject age at finding time - and optionally extract the set of
findings within a specified range of age.</h2><span id='topic+getFindingsSubjAge'></span>

<h3>Description</h3>

<p>Returns a data table with the set of findings rows included in the
<code>findings</code> where the age of subjects at finding time is within the
interval specified in <code>fromAge</code> to <code>fromAge</code>.<br />
If the <code>fromAge</code> and <code>fromAge</code> are empty (null, na or empty
string), all rows from <code>findings</code> are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFindingsSubjAge(
  dbToken,
  findings,
  animalList,
  fromAge = NULL,
  toAge = NULL,
  inclUncertain = FALSE,
  noFilterReportUncertain = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFindingsSubjAge_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="getFindingsSubjAge_+3A_findings">findings</code></td>
<td>
<p>Mandatory, data.table.<br />
A table with the set of input finding rows to process.<br />
The table must include at least columns named
</p>

<ul>
<li> <p><code>STUDYID</code>
</p>
</li>
<li> <p><code>USUBJID</code>
</p>
</li>
<li> <p><code>DOMAIN</code>
</p>
</li>
<li> <p><code>[domain]SEQ</code>
</p>
</li>
<li> <p><code>[domain]DY</code>
</p>
</li>
<li> <p><code>[domain]DTC</code>
</p>
</li></ul>

<p>where <code>[domain]</code> is the name of the actual findings domain - e.g. <code>LBSEQ</code>, <code>LBDY</code>
and <code>LBDTC</code></p>
</td></tr>
<tr><td><code id="getFindingsSubjAge_+3A_animallist">animalList</code></td>
<td>
<p>Mandatory, data.table.<br />
A data with the set of animals included in the <code>findings</code> table
(may contain more animals than included in <code>findings</code>).<br />
The data set must contain at least these columns returned by the function <a href="#topic+getControlSubj">getControlSubj</a>
</p>

<ul>
<li> <p><code>STUDYID</code>
</p>
</li>
<li> <p><code>USUBJID</code>
</p>
</li>
<li> <p><code>RFSTDTC</code>
</p>
</li>
<li> <p><code>DM_AGEDAYS</code>
</p>
</li>
<li> <p><code>NO_AGE_MSG</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="getFindingsSubjAge_+3A_fromage">fromAge</code></td>
<td>
<p>Optional, character <br />
The start of age interval to extract.<br />
Must be in a string in this format:<br />
<code>[value][age unit]</code> where <code>[age unit]</code> is one of
</p>

<ul>
<li> <p><code>d, day, days</code>
</p>
</li>
<li> <p><code>w, week, weeks</code>
</p>
</li>
<li> <p><code>m, month, months</code>
</p>
</li>
<li> <p><code>y, year, years</code>
</p>
</li></ul>

<p>The unit is case-insensitive, space(s) between age value and unit is
allowed.</p>
</td></tr>
<tr><td><code id="getFindingsSubjAge_+3A_toage">toAge</code></td>
<td>
<p>Optional. character <br />
The start of age interval to extract.<br />
Must be in a string in in the same format as described for <code>fromAge</code>.</p>
</td></tr>
<tr><td><code id="getFindingsSubjAge_+3A_incluncertain">inclUncertain</code></td>
<td>
<p>Mandatory, boolean.<br />
Only relevant if the <code>fromAge</code> and/or <code>toAge</code> is/are not empty.<br />
Indicates whether finding rows for which the age at finding time cannot be
confidently identified, shall be included or not in the output data table.</p>
</td></tr>
<tr><td><code id="getFindingsSubjAge_+3A_nofilterreportuncertain">noFilterReportUncertain</code></td>
<td>
<p>Optional, boolean.<br />
Only relevant if the <code>fromAge</code> and <code>toAge</code> are empty.<br />
Indicates if the reason should be included if the age at finding time cannot
be confidently decided for an animal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In both situation, the subject age at finding time is calculated into an
additional column <code>AGEDAYS</code> for each row in <code>findings</code> combined
with the the additional input data.table <code>animalList</code> using this
algorithm:
</p>

<ul>
<li><p> Determine the number of study days between study start and findings
</p>

<ul>
<li><p> if <code>findings.[domain]DY</code> is populated
</p>

<ul>
<li><p> If <code>findings.[domain]DY &gt; 0</code> then use
<code>findings.[domain]DY - 1</code>
</p>
</li>
<li><p> Else use <code>findings.[domain]DY</code>
</p>
</li></ul>

</li>
<li><p> Else If <code>findings.[domain]DTC</code> is populated compute
<code>animalList.RFSTDTC – findings.[domain]DTC</code> in days<br /> where
<code>animalList.RFSTDTC</code> is each subject's reference start date
(<code>DM.RFSTDTC</code>)
</p>
</li></ul>

</li>
<li><p> Animal age at time of finding is then calculated as
<code>animalList.AGEDAYS + [study days between study start and
        findings]</code><br />
where <code>animalList.AGEDAYS</code> is the  subject age at reference
start date(calculated during extraction of control subjects in
<code><a href="#topic+getControlSubj">getControlSubj</a></code>.
</p>
</li>
<li><p> For pooled findings rows - i.e. POOLID is populated instead of
USUBJID - the animal age at time of finding is calculated per animal
included in the each pool and finding.
</p>

<ul>
<li><p> If all calculated ages are equal within a pool and finding,
the calculated age is populated for this pool/finding.
</p>
</li>
<li><p> If all calculated ages are within the same time internal
(2 days) within a pool and finding, the minimum calculated age
plus 1 day is populated for this pool/finding.
</p>
</li></ul>

</li></ul>

<p>If both <code>fromAge</code> and <code>toAge</code> values are specified - all the rows
from the input table <code>findings</code> where value of the calculated
<code>AGEDYAS</code> is within the interval of the specified start/end age interval
are returned - including the values equal to the start/end age values.<br />
If only a <code>fromAge</code> value is specified - all the rows from the input
table <code>findings</code> where value of <code>AGEDYAS</code> equal to or greater than
the input age are returned.<br />
If only a <code>toAge</code> value is specified - all the rows from input table
<code>findings</code> where value of AGEDAYS is equal to or less than the input age
are extracted and returned.
The input age value(s) is/are converted to days before extraction of rows
from the input data tables using the input value(s) as filter - using this
conversion:
</p>

<ul>
<li> <p><code>DAYS</code>
</p>
</li>
<li> <p><code>WEEKS   : value * 7</code>
</p>
</li>
<li> <p><code>MONTHS  : value * 365/12</code>
</p>
</li>
<li> <p><code>YEARS   : value * 365</code>
</p>
</li></ul>

<p>If input parameter <code>inclUncertain=TRUE</code>, findings rows where the age at
finding time cannot be confidently identified are included in the output set.
These uncertain situations are identified and reported (in column
UNCERTAIN_MSG):
</p>

<ul>
<li><p> No age at reference time  has been calculated for subject
(<code>animalList.AGEDAYS</code>)
</p>
</li>
<li><p> Reference start time  is missing or contains invalid ISO8601 date
value for subject (<code>animalList.RFSTDTC</code>).
</p>
</li>
<li><p> Missing <code>[domain]DY</code> value and missing or invalid ISO8601 date
<code>[domain]DTC</code> value for finding
</p>
</li>
<li><p> For pooled findings:
</p>

<ul>
<li><p> More than two days between minimum and maximum of
<code>animalList.AGEDAYS</code> for the set of animals in a pool.
</p>
</li>
<li><p> Different values in <code>animalList.RFSTDTC</code> for the set of
animals in a pool.
</p>
</li></ul>

</li></ul>

<p>The same checks are performed and reported in column <code>NOT_VALID_MSG</code> if
<code>fromAge</code> and <code>fromAge</code> are empty and <code>noFilterReportUncertain
= TRUE</code>.
</p>


<h3>Value</h3>

<p>The function returns a data.table with columns in this order:
</p>

<ul>
<li><p> All columns contained in the <code>findings</code> input table (original
order except optional <code>UNCERTAIN_MSG</code> and <code>NOT_VALID_MSG</code>)
</p>
</li>
<li> <p><code>AGEDAYS</code>        (character)<br />
The subject age at finding time calculated in days. Is <code>NA</code> if thge age
cannot be confidently calculated.
</p>
</li>
<li> <p><code>UNCERTAIN_MSG</code>  (character)<br />
Included when parameter <code>inclUncertain=TRUE</code>.<br />
In case the age at finding time cannot be confidently matched during the
filtering of data, the column contains an indication of the reason.<br />
If any uncertainties have been identified for individual subjects included in
pools for pooled finding rows, one  message for is reported per pool/finding.<br />
Is NA for rows where the age at finding time can be confidently matched.<br />
A non-empty <code>UNCERTAIN_MSG</code> value generated by this function is merged with
non-empty <code>UNCERTAIN_MSG</code> values which may exist in the input set of findings
specified in <code>findings</code> - separated by '|'.
</p>
</li>
<li> <p><code>NOT_VALID_MSG</code> (character)<br />
Included when parameter <code>noFilterReportUncertain=TRUE</code>.<br />
In case the age at finding time cannot be confidently calculated, the column
contains an indication of the reason.<br />
Is NA for rows where age at finding time can be confidently calculated.<br />
A non-empty <code>NOT_VALID_MSG</code> value generated by this function is merged with
non-empty <code>NOT_VALID_MSG</code> values which may exist in the input set of findings
<code>findings</code> - separated by '|'.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract LB rows for the animals at age between 8 and 12 weeks at finding
# time - include uncertain rows
getFindingsSubjAge(dbToken = db,
                   findings = lb,
                   animalList = animals,
                   fromAge = '8w',
                   toAge = '12w',
                   inclUncertain = TRUE)
# No filtering, just add AGEDAYS to FW rows - do not include messages when
# the AGEDAYS cannot be confidently identified
getFindingsSubjAge(dbToken = db, findings = fw,  animalList = animals,
                   noFilterReportUncertain = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='getStudiesSDESIGN'>Extract a list of SEND studies with a specified study design - or just add
actual study design for each study.</h2><span id='topic+getStudiesSDESIGN'></span>

<h3>Description</h3>

<p>Returns a data table with the list of study ids from TS where the value of
TSVAL for the TSPARMCD 'SDESIGN' is equal to a given study design.<br />
If the <code>studyDesignFilter</code> is empty (null, na or empty string) - all
rows for the TSPARMCD 'SDESIGN' are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStudiesSDESIGN(
  dbToken,
  studyList = NULL,
  studyDesignFilter = NULL,
  exclusively = TRUE,
  inclUncertain = FALSE,
  noFilterReportUncertain = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStudiesSDESIGN_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory.<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="getStudiesSDESIGN_+3A_studylist">studyList</code></td>
<td>
<p>Optional, data.table.<br />
A table with the list of studies to process. If empty, all studies in
the data base are processed<br />
The table must include at least a column named 'STUDYID'</p>
</td></tr>
<tr><td><code id="getStudiesSDESIGN_+3A_studydesignfilter">studyDesignFilter</code></td>
<td>
<p>Mandatory, character. The study design to use as
criterion for filtering of the study id values. It can be a single string,
a vector or a list of multiple strings.</p>
</td></tr>
<tr><td><code id="getStudiesSDESIGN_+3A_exclusively">exclusively</code></td>
<td>
<p>Mandatory, boolean.
</p>

<ul>
<li><p> TRUE: Include studies only for studies with no other study
design(s) than included in <code>studyDesignFilter</code>.
</p>
</li>
<li><p> FALSE: Include all studies with study design matching
<code>studyDesignFilter</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getStudiesSDESIGN_+3A_incluncertain">inclUncertain</code></td>
<td>
<p>Mandatory, boolean.<br />
Indicates whether study ids with SDESIGN value which are is missing or wrong
shall be included or not in the output data table.</p>
</td></tr>
<tr><td><code id="getStudiesSDESIGN_+3A_nofilterreportuncertain">noFilterReportUncertain</code></td>
<td>
<p>Mandatory, boolean<br />
Only relevant if the <code>studyDesignFilter</code> is empty.<br />
Indicates if the reason should be included if the SDESIGN cannot be
confidently decided for an animal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracts the set of studies from TS where the value of TSVAL for the TSPARMCD
'SDESIGN' is equal to a given study design.<br />
The comparison of study design values are done case insensitive.<br />
</p>
<p>If a data table with a list of studies is specified in <code>studyList</code>, only
the subset of studies included in that set is processed.
</p>
<p>If input parameter <code>inclUncertain=TRUE</code>, uncertain animals are included
in the output set. These uncertain situations are identified and reported (in
column UNCERTAIN_MSG):
</p>

<ul>
<li><p> without any row for TSPARMCD='SDESIGN' or
</p>
</li>
<li><p> TSVAL doesn't contain a value included in the  CDISC CT list
'DESIGN' for TSPARMCD='SDESIGN' (case insensitive comparison)
</p>
</li></ul>

<p>The same checks are performed and reported in column NOT_VALID_MSG if
<code>studyDesignFilter</code> is empty and <code>noFilterReportUncertain=TRUE</code>.
</p>


<h3>Value</h3>

<p>The function returns a data.table with columns:
</p>

<ul>
<li><p> STUDYID       (character)
</p>
</li>
<li><p> Additional columns contained in the <code>studyList</code> table (if such
an input table is given)
</p>
</li>
<li><p> SDESIGN       (character)<br />
If multiple TSPARMCD 'SDESIGN' values are extratced for a studies, all the
values are merged into a comma separated string.
</p>
</li>
<li><p> UNCERTAIN_MSG (character)<br />
Included when parameter <code>inclUncertain=TRUE</code>.<br />
Contains indication of whether STSTDTC is missing of has wrong
format.<br />
Is NA for rows where SDESIGN is valid.<br />
A non-empty UNCERTAIN_MSG value generated by this function is merged with
non-empty UNCERTAIN_MSG values which may exist in the optional input set of
studies specified in <code>studyList</code> - separated by '|'.
</p>
</li>
<li><p> NOT_VALID_MSG (character)<br />
Included when parameter <code>noFilterReportUncertain=TRUE</code>.<br />
In case the SDESIGN cannot be confidently decided, the column contains an
indication of the reason.<br />
Is NA for rows where SDESIGN can be confidently decided.<br />
A non-empty NOT_VALID_MSG value generated by this function is merged with
non-empty NOT_VALID_MSG values which may exist in the input set of studies
specified in <code>studyList</code> - separated by '|'.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
GetStudyListSDESIGN(myDbToken, 'PARALLEL')

## End(Not run)
</code></pre>

<hr>
<h2 id='getStudiesSTSTDTC'>Extract a list of SEND studies with study start date within a specified
interval - or just add actual study start date for each study</h2><span id='topic+getStudiesSTSTDTC'></span>

<h3>Description</h3>

<p>Returns a data table with the list of study ids from TS where the value of
TSVAL for the TSPARMCD 'STSTDTC' is within a a given date interval.<br />
If the <code>fromDTC</code> and<code>toDTC</code> are empty (null, na or empty string)
</p>

<ul>
<li><p> all rows for the TSPARMCD 'STSTDTC' are returned.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>getStudiesSTSTDTC(
  dbToken,
  studyList = NULL,
  fromDTC = NULL,
  toDTC = NULL,
  inclUncertain = FALSE,
  noFilterReportUncertain = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStudiesSTSTDTC_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory.<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="getStudiesSTSTDTC_+3A_studylist">studyList</code></td>
<td>
<p>Optional.<br />
A data.table with the list of studies to process. If empty, all studies in
the data base are processed <br />
The table must include at least a column named 'STUDYID'.</p>
</td></tr>
<tr><td><code id="getStudiesSTSTDTC_+3A_fromdtc">fromDTC</code></td>
<td>
<p>Optional (either or both of <code>fromDTC</code> and <code>toDTC</code>
must be filled).<br />
The start of the date interval to extract - must be in ISO8601 date format.</p>
</td></tr>
<tr><td><code id="getStudiesSTSTDTC_+3A_todtc">toDTC</code></td>
<td>
<p>Optional (either or both of <code>fromDTC</code> and <code>toDTC</code> must be filled).<br />
The end of the date interval to extract - must be in ISO8601 date format.</p>
</td></tr>
<tr><td><code id="getStudiesSTSTDTC_+3A_incluncertain">inclUncertain</code></td>
<td>
<p>Mandatory, boolean.<br />
Indicates whether study ids with STSTDTC which are are missing or wrong
shall be included or not in the output data table.</p>
</td></tr>
<tr><td><code id="getStudiesSTSTDTC_+3A_nofilterreportuncertain">noFilterReportUncertain</code></td>
<td>
<p>Mandatory, boolean<br />
Only relevant if the <code>fromDTC</code> and<code>toDTC</code> are empty.<br />
Indicates if the reason should be included if the STSTDTC cannot be
confidently decided for an animal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracts the set of study ids from TS where the value of TSVAL for the
TSPARMCD 'STSTDTC' falls within a specified start/end date interval in IS8601
format (input parameters <code>fromDTC</code>/<code>toDTC</code>).<br />
</p>
<p>Both complete and incomplete input start/end dates can be handled.
</p>

<ul>
<li><p> If only a year is specified - the date set to the first of January that
year.
</p>
</li>
<li><p> If only a year and month is specified - the date set to the first day
in that month.
</p>
</li>
<li><p> If a time part is included in a specified input start/end date, it is
ignored.
</p>
</li></ul>

<p>If both a start and end input date are specified - all the STUDYID values
from TS where TSVAL for TSPARMCD 'STSTDTC' is with the interval of the
specified start/end date interval are extracted and returned - including the
values equal to the start/end dates. are included.<br />
</p>
<p>If only a start input date is specified - all the STUDYID values from TS
where TSVAL for TSPARMCD 'STSTDTC' is equal to or later than the input date
are extracted and returned.<br />
</p>
<p>If only an end date is specified - all the STUDYID values from TS where TSVAL
for TSPARMCD 'STSTDTC' is equal to or earlier than the are date are extracted
and returned.<br />
</p>
<p>If a data table with a list of studies is specified in <code>studyList</code>, only
the subset of studies included in that set is processed.<br />
</p>
<p>If input <code>inclUncertain</code> is TRUE, uncertain studies are included in the
output set. These uncertain situations are identified and reported (in column
UNCERTAIN_MSG):
</p>

<ul>
<li><p> TS contains now row for TSPARMCD='STSTDTC'
</p>
</li>
<li><p> TSVAL contains an invalid ISO8601 date format for TSPARMCD='STSTDTC'
</p>
</li></ul>

<p>The same checks are performed and reported in column NOT_VALID_MSG if
<code>fromDTC</code> and <code>toDTC</code> are empty and
<code>noFilterReportUncertain=TRUE</code>.
</p>


<h3>Value</h3>

<p>The function return a data.table with columns:
</p>

<ul>
<li><p> STUDYID       (character)
</p>
</li>
<li><p> Additional columns contained in the <code>studyList</code> table (if such an input
table is given)
</p>
</li>
<li><p> STSTDTC       (character - ISO8601 format)
</p>
</li>
<li><p> UNCERTAIN_MSG (character)<br />
Only included when parameter <code>inclUncertain=TRUE</code>.<br />
Contains indication of whether STSTDTC is missing of has wrong
format.<br />
Is NA for rows where SDESIGN is valid.<br />
A non-empty UNCERTAIN_MSG value generated by this function is merged with
non-empty UNCERTAIN_MSG values which may exist in the optional input set of
studies specified in <code>studyList</code> - separated by '|'.
</p>
</li>
<li><p> NOT_VALID_MSG (character)<br />
Included when parameter <code>noFilterReportUncertain=TRUE</code>.<br />
In case the STSTDTC cannot be confidently decided, the column contains an
indication of the reason.<br />
Is NA for rows where STSTDTC can be confidently decided.<br />
A non-empty NOT_VALID_MSG value generated by this function is merged with
non-empty NOT_VALID_MSG values which may exist in the input set of studies
specified in <code>studyList</code> - separated by '|'.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
GetStudyListSTSTDTC(myDbToken, allSTudies, '2018','2020')

## End(Not run)
</code></pre>

<hr>
<h2 id='getSubjData'>Extract data from a subject level domain.</h2><span id='topic+getSubjData'></span>

<h3>Description</h3>

<p>Extracts and returns all rows from the specified <code>domain</code> for the set
of subjects included in <code>animalList</code>.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubjData(dbToken, animalList, domain, colList = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSubjData_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="getSubjData_+3A_animallist">animalList</code></td>
<td>
<p>Mandatory, data.table.<br />
A table with the list of animals to be included in the output data.<br />
The table must include at least columns named 'STUDYID' and 'USUBJID'.</p>
</td></tr>
<tr><td><code id="getSubjData_+3A_domain">domain</code></td>
<td>
<p>Mandatory, character, not case sensitive.<br />
The name of the domain table to extract data from.<br />
The name must be a subject level domain - i.e. a table including a 'USUBJID'
column.</p>
</td></tr>
<tr><td><code id="getSubjData_+3A_collist">colList</code></td>
<td>
<p>Optional, character, not case sensitive.<br />
The list of columns to be extracted from the specified domain table.<br />
It can be a single string, a vector or a list of multiple strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data.table with all the rows for the animals
included in <code>animalList</code>.<br />
If no columns have been specified in <code>colList</code>, all the columns in
the table <code>colList</code> are included.<br />
If a list of columns have been specified in <code>colList</code>, these are
included. In addition, a set of columns are always included, whether they
are included in <code>colList</code> or not:
</p>

<ul>
<li><p> To ensure each row can be uniquely identified:
</p>

<ul>
<li><p> DOMAIN
</p>
</li>
<li><p> STUDYID
</p>
</li>
<li><p> USUBJID
</p>
</li>
<li><p> POOLID (if it exists)
</p>
</li>
<li><p> domainSEQ (if it exists)
</p>
</li></ul>

</li>
<li><p> For finding tables - to support age calculation and evaluation of
study phase:
</p>

<ul>
<li><p> domainDTC
</p>
</li>
<li><p> domainDY
</p>
</li></ul>

</li></ul>

<p>The order of the columns are as they are defined for the domain in the
SEND IG.<br />
The data table contains both
</p>

<ul>
<li><p> subject level data - i.e. rows where USUBJID is not empty
</p>
</li>
<li><p> if applicable for the <code>domain</code>, pool level data - i.e. rows
where POOLID is not empty.<br />
In this case, all pools, which includes any of the subjects included in
<code>animalList</code>, are included
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract all columns from DM:
getSubjData(myDbToken, myControlAnimals, 'dm')

# Extract selected columns from LB:
getSubjData(myDbToken, myControlAnimals, 'LB',
            list('LBTESTCD', 'LBCAT',
                 'LBSTRESC', 'LBSTRESN', 'LBSTRESU',
                 'LBSTAT', 'LBREASND',
                 'LBTPT'))

## End(Not run)

</code></pre>

<hr>
<h2 id='getSubjRoute'>Extract the set of animals of the specified route of administration - or just
add actual route of administration for each animal.</h2><span id='topic+getSubjRoute'></span>

<h3>Description</h3>

<p>Returns a data table with the set of animals included in the
<code>animalList</code> matching the route of administration specified in the
<code>routeFilter</code>.<br />
If the <code>routeFilter</code> is empty (null, na or empty string) - all rows from
<code>animalList</code> are returned with an additional populated ROUTE column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubjRoute(
  dbToken,
  animalList,
  routeFilter = NULL,
  exclusively = FALSE,
  matchAll = FALSE,
  inclUncertain = FALSE,
  noFilterReportUncertain = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSubjRoute_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="getSubjRoute_+3A_animallist">animalList</code></td>
<td>
<p>Mandatory, data.table.<br />
A table with the list of animals to process.<br />
The table must include at least columns named 'STUDYID' and 'USUBJID'.</p>
</td></tr>
<tr><td><code id="getSubjRoute_+3A_routefilter">routeFilter</code></td>
<td>
<p>Optional, character.<br />
The route of administration value(s) to use as criterion for filtering of the
input data table.<br />
It can be a single string, a vector or a list of multiple strings.</p>
</td></tr>
<tr><td><code id="getSubjRoute_+3A_exclusively">exclusively</code></td>
<td>
<p>Mandatory if <code>routeFilter</code> is non empty, boolean.
</p>

<ul>
<li><p> TRUE: Include animals only for studies with no other routes then
included in <code>routeFilter</code>.
</p>
</li>
<li><p> FALSE: Include animals for all studies with route
matching <code>routeFilter</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getSubjRoute_+3A_matchall">matchAll</code></td>
<td>
<p>Mandatory if <code>routeFilter</code> is non empty, boolean.
</p>

<ul>
<li><p> TRUE: Include animals only for studies with route(s) matching all
values in <code>routeFilter</code>.
</p>
</li>
<li><p> FALSE: Include animals for all studies with route matching at least
one value in <code>routeFilter</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getSubjRoute_+3A_incluncertain">inclUncertain</code></td>
<td>
<p>Mandatory if <code>routeFilter</code> is non empty, boolean,.<br />
Indicates whether animals for which the route cannot be confidently
identified shall be included or not in the output data table.</p>
</td></tr>
<tr><td><code id="getSubjRoute_+3A_nofilterreportuncertain">noFilterReportUncertain</code></td>
<td>
<p>Mandatory if <code>routeFilter</code> is empty, boolean<br />
Only relevant if the <code>routeFilter</code> is empty.<br />
Indicates if the reason should be included if the route cannot be
confidently decided for an animal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The route of administration per animal are identified by a hierarchical
lookup in these domains
</p>

<ul>
<li><p> EX - If a distinct not empty EXROUTE value is found for animal, this
is included in the output.<br />
</p>
</li>
<li><p> TS - if a distinct TS parameter 'ROUTE' value exists for the study,
this is included in the output.<br />
</p>
</li></ul>

<p>The comparison of route values is done case insensitive and trimmed for
leading/trailing blanks.
</p>
<p>If input parameter <code>inclUncertain=TRUE</code>, uncertain animals are included
in the output set. These uncertain situations are identified and reported (in
column UNCERTAIN_MSG):
</p>

<ul>
<li><p> TS parameter ROUTE is missing for study and no EX rows contain a
EXROUTE value for the animal
</p>
</li>
<li><p> The selected EXROUTE or TS parameter ROUTE value is invalid (not CT
value - CDISC SEND code list ROUTE)
</p>
</li>
<li><p> Multiple EXROUTE values have been found for the animal
</p>
</li>
<li><p> Multiple TS parameter ROUTE values are registered for study but no EX
rows contain a EXROUTE value for the animal
</p>
</li>
<li><p> The found EXROUTE value for animal is not included in the TS
parameter ROUTE value(s) registered for study
</p>
</li></ul>

<p>The same checks are performed and reported in column NOT_VALID_MSG if
<code>routeFilter</code> is empty and <code>noFilterReportUncertain=TRUE</code>.
</p>


<h3>Value</h3>

<p>The function returns a data.table with columns:
</p>

<ul>
<li><p> STUDYID       (character)
</p>
</li>
<li><p> Additional columns contained in the <code>animalList</code> table
</p>
</li>
<li><p> ROUTE         (character)<br />
The value is always returned in uppercase and trimmed for leading/trailing
blanks.
</p>
</li>
<li><p> UNCERTAIN_MSG (character)<br />
Included when parameter <code>inclUncertain=TRUE</code>.<br />
In case the ROUTE cannot be confidently matched during the filtering of data,
the column contains an indication of the reason.<br />
Is NA for rows where ROUTE can be confidently matched.<br />
A non-empty UNCERTAIN_MSG value generated by this function is merged with
non-empty UNCERTAIN_MSG values which may exist in the input set of animals
specified in <code>animalList</code> - separated by '|'.
</p>
</li>
<li><p> NOT_VALID_MSG (character)<br />
Included when parameter <code>noFilterReportUncertain=TRUE</code>.<br />
In case the ROUTE cannot be confidently decided, the column contains an
indication of the reason.<br />
Is NA for rows where the ROUTE can be confidently decided.<br />
A non-empty NOT_VALID_MSG value generated by this function is merged with
non-empty NOT_VALID_MSG values which may exist in the input set of animals
<code>animalList</code> - separated by '|'.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract animals administered oral or oral gavage plus uncertain animals
getSubjRoute(dbToken, controlAnimals,
             routeFilter = c('ORAL', 'ORAL GAVAGE'),
             inclUncertain = TRUE)
# Extract animals administered oral or oral gavage.
# Do only include studies which include both route values
getSubjRoute(dbToken, controlAnimals,
             routeFilter = c('ORAL', 'ORAL GAVAGE'),
             matchAll = TRUE)
# Extract animals administered subcutaneous.
# Include only animals from studies which do not contain other route values
getSubjRoute(dbToken, controlAnimals,
             routeFilter = 'subcutaneous',
             exclusively = TRUE)
# No filtering, just add ROUTE - do not include messages when
# these values cannot be confidently found
getSubjRoute(dbToken, controlAnimals,
             noFilterReportUncertain = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSubjSex'>Extract the set of animals of the specified sex - or just add the sex of each
animal.</h2><span id='topic+getSubjSex'></span>

<h3>Description</h3>

<p>Returns a data table with the set of animals included in the
<code>animalList</code> of the sex specified in the <code>sexFilter</code>.<br />
If the <code>sexFilter</code> is empty (null, na or empty string) - all rows from
<code>animalList</code> are returned with the an additional populated SEX column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubjSex(
  dbToken,
  animalList,
  sexFilter = NULL,
  inclUncertain = FALSE,
  noFilterReportUncertain = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSubjSex_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="getSubjSex_+3A_animallist">animalList</code></td>
<td>
<p>Mandatory, data.table.<br />
A table with the list of animals to process.<br />
The table must include at least columns named 'STUDYID' and 'USUBJID'.</p>
</td></tr>
<tr><td><code id="getSubjSex_+3A_sexfilter">sexFilter</code></td>
<td>
<p>Optional, character.<br />
The sex value criterion to be used for filtering of the list of animals.<br />
It can be a single string, a vector or a list of multiple strings.</p>
</td></tr>
<tr><td><code id="getSubjSex_+3A_incluncertain">inclUncertain</code></td>
<td>
<p>Mandatory, boolean.<br />
Indicates whether animals for which the sex cannot be confidently identified
shall be included or not in the output data table.</p>
</td></tr>
<tr><td><code id="getSubjSex_+3A_nofilterreportuncertain">noFilterReportUncertain</code></td>
<td>
<p>Mandatory, boolean.<br />
Only relevant if the <code>sexFilter</code> is empty.<br />
Indicates if the reason should be included if the sex cannot be confidently
decided for an animal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sex value is decided from the DM.SEX variable.<br />
The comparison of DM.SEX with the given value(s) in <code>sexFilter</code> is done
case-insensitive.
</p>
<p>If input parameter <code>inclUncertain=TRUE</code>, uncertain animals are included
in the output set. These uncertain situations are identified and reported (in
column UNCERTAIN_MSG):
</p>

<ul>
<li><p> The DM.SEX value is empty or invalid (not CT value - CDISC codelist
SEX - case insensitive comparison)
</p>
</li></ul>

<p>The same checks are performed and reported in column NOT_VALID_MSG if
<code>sexFilter</code> is empty and <code>noFilterReportUncertain=TRUE</code>.
</p>


<h3>Value</h3>

<p>The function returns a data.table with columns:
</p>

<ul>
<li><p> STUDYID       (character)
</p>
</li>
<li><p> Additional columns contained in the <code>animalList</code> table
</p>
</li>
<li><p> SEX          (character)
</p>
</li>
<li><p> UNCERTAIN_MSG (character)<br />
Included when parameter <code>inclUncertain=TRUE</code>.<br />
In case the sex cannot be confidently matched during the filtering of data,
the column contains an indication of the reason.<br />
Is NA for rows where SEX can be confidently matched.<br />
A non-empty UNCERTAIN_MSG value generated by this function is merged with
non-empty UNCERTAIN_MSG values which may exist in the input set of animals
specified in <code>animalList</code> - separated by '|'.
</p>
</li>
<li><p> NOT_VALID_MSG (character)<br />
Included when parameter <code>noFilterReportUncertain=TRUE</code>.<br />
In case the sex cannot be confidently decided, the column contains an
indication of the reason.<br />
Is NA for rows where sex can be confidently decided.<br />
A non-empty NOT_VALID_MSG value generated by this function is merged with
non-empty NOT_VALID_MSG values which may exist in the input set of animals
<code>animalList</code> - separated by '|'.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getSubjSex(myDbToken, controlAnimals, 'M')

## End(Not run)
</code></pre>

<hr>
<h2 id='getSubjSpeciesStrain'>Extract the set of animals of the specified species and strain - or just add
the species and strain for each animal.</h2><span id='topic+getSubjSpeciesStrain'></span>

<h3>Description</h3>

<p>Returns a data table with the set of animals included in the
<code>animalList</code> matching the species and strain specified in the
<code>speciesFilter</code> and <code>strainFilter</code>.<br />
If the <code>speciesFilter</code> and <code>strainFilter</code> are empty (null, na or
empty string) - all rows from <code>animalList</code> are returned with additional
populated SPECIES and STRAIN columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubjSpeciesStrain(
  dbToken,
  animalList,
  speciesFilter = NULL,
  strainFilter = NULL,
  inclUncertain = FALSE,
  exclusively = FALSE,
  noFilterReportUncertain = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSubjSpeciesStrain_+3A_dbtoken">dbToken</code></td>
<td>
<p>Mandatory<br />
Token for the open database connection (see <code><a href="#topic+initEnvironment">initEnvironment</a></code>).</p>
</td></tr>
<tr><td><code id="getSubjSpeciesStrain_+3A_animallist">animalList</code></td>
<td>
<p>Mandatory, data.table.<br />
A table with the list of animals to process.<br />
The table must include at least columns named 'STUDYID' and 'USUBJID'.</p>
</td></tr>
<tr><td><code id="getSubjSpeciesStrain_+3A_speciesfilter">speciesFilter</code></td>
<td>
<p>Optional, character.<br />
The species value(s) to use as criterion for filtering of the input data
table.<br />
It can be a single string, a vector or a list of multiple strings.</p>
</td></tr>
<tr><td><code id="getSubjSpeciesStrain_+3A_strainfilter">strainFilter</code></td>
<td>
<p>Optional, character.<br />
The strain value(s) to use as criterion for filtering of the input data
table.<br />
It is only valid to specify value(s) if one or more values have been
specified for parameter <code>speciesFilter</code><br />
It can be a single string, a vector or a list of multiple strings.
When multiple values are specified for <code>speciesFilter</code>, each strain
value must be prefixed by species and ':' , e.g.
<code>c('RAT:WISTAR','DOG: BEAGLE')</code>.<br />
There may be included any number of blanks after ':'</p>
</td></tr>
<tr><td><code id="getSubjSpeciesStrain_+3A_incluncertain">inclUncertain</code></td>
<td>
<p>Mandatory, boolean.<br />
Indicates whether animals for which the species or strain cannot be
confidently identified shall be included or not in the output data table.</p>
</td></tr>
<tr><td><code id="getSubjSpeciesStrain_+3A_exclusively">exclusively</code></td>
<td>
<p>Mandatory, boolean.
</p>

<ul>
<li><p> TRUE: Include animals only for studies with no other species and
optional strains then included in <code>speciesFilter</code> and
<code>strainFilter</code>
</p>
</li>
<li><p> FALSE: Include animals for all studies with species and strain
matching <code>speciesFilter</code> and <code>strainFilter</code> respectively.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getSubjSpeciesStrain_+3A_nofilterreportuncertain">noFilterReportUncertain</code></td>
<td>
<p>Optional, boolean.<br />
Only relevant if the <code>speciesFilter</code> and  <code>strainFilter</code> are
empty.<br />
Indicates if the reason should be included if the species or strain cannot
be confidently decided for an animal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The species and strain per animal respectively are identified by a
hierarchical lookup in these domains
</p>

<ul>
<li><p> DM - If the DM.SPECIES (DM.STRAIN) isn't empty, this value is
included in the output.<br />
</p>
</li>
<li><p> TX - if a TX parameter 'SPECIES' ('STRAIN') exists for the group
related to the animal, the TXVAL value for this is included in the
output.<br />
</p>
</li>
<li><p> TS - if a TS parameter 'SPECIES' ('STRAIN') exists, this is included
in the output.<br />
</p>
</li></ul>

<p>The comparisons of species/strain values is done case insensitive and trimmed
for leading/trailing blanks.
</p>
<p>If input parameter <code>inclUncertain=TRUE</code>, uncertain animals are included
in the output set. These uncertain situations are identified and reported for
SPECIES and STRAIN respectively (in column UNCERTAIN_MSG):
</p>

<ul>
<li><p> TS parameter SPECIES/STRAIN is missing or invalid (not CT value -
CDISC SEND code list SPECIES/STRAIN) and TX parameter SPECIES/STRAIN is
missing or invalid (not CT value) and DM.SPECIES/STRAIN is missing or
invalid (not CT value)
</p>
</li>
<li><p> Different values of SPECIES/STRAIN across TS, TX and DM for studies
where no or only one TS parameter SPECIES/STRAIN is registered
</p>
</li>
<li><p> Multiple TS parameter SPECIES/STRAIN values are registered for study
and TX parameter SPECIES/STRAIN and/or DM.SPECIES/STRAIN do not match any
of the TS values.
</p>
</li>
<li><p>  Multiple TS parameter SPECIES/STRAIN values are registered for study
and TX parameter SPECIES/STRAIN and DM.SPECIES/STRAIN are unequal.
</p>
</li></ul>

<p>The same checks are performed and reported in column NOT_VALID_MSG if
<code>speciesFilter</code> and <code>strainFilter</code> are empty and
<code>noFilterReportUncertain=TRUE</code>.
</p>


<h3>Value</h3>

<p>The function returns a data.table with columns:
</p>

<ul>
<li><p> STUDYID       (character)
</p>
</li>
<li><p> Additional columns contained in the <code>animalList</code> table
</p>
</li>
<li><p> SPECIES       (character)
The value is always returned in uppercase and trimmed for leading/trailing
blanks.
</p>
</li>
<li><p> STRAIN        (character)
The value is always returned in uppercase and trimmed for leading/trailing
blanks.
</p>
</li>
<li><p> UNCERTAIN_MSG (character)<br />
Included when parameter <code>inclUncertain=TRUE</code>.<br />
In case the species or strain cannot be confidently matched during the
filtering of data, the column contains an indication of the reason.<br />
Is NA for rows where species and strain can be confidently matched.<br />
A non-empty UNCERTAIN_MSG value generated by this function is merged with
non-empty UNCERTAIN_MSG values which may exist in the input set of animals
specified in <code>animalList</code> - separated by '|'.
</p>
</li>
<li><p> NOT_VALID_MSG (character)<br />
Included when parameter <code>noFilterReportUncertain=TRUE</code>.<br />
In case the species or strain cannot be confidently decided, the column
contains an indication of the reason.<br />
Is NA for rows where species and strain can be confidently decided.<br />
A non-empty NOT_VALID_MSG value generated by this function is merged with
non-empty NOT_VALID_MSG values which may exist in the input set of animals
<code>animalList</code> - separated by '|'.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract rats and mice plus uncertain animals
getSubjSpeciesStrain(dbToken, controlAnimals,
                     speciesFilter = c('RAT', 'MOUSE'),
                     inclUncertain = TRUE)
# Extract Spargue-Dawley rats plus uncertain animals.
# Include only animals from studies which do not contain other species or
# strains
getSubjSpeciesStrain(dbToken, controlAnimals,
                     speciesFilter = 'RAT',
                     strainFilter = 'SPRAGUE-DAWLEY',
                     inclUncertain = TRUE,
                     exclusively = TRUE,
                     noFilterReportUncertain = TRUE)
# Extract Wistar rats and and Beagle dogs - and no uncertain animals
getSubjSpeciesStrain(dbToken, controlAnimals,
                     speciesFilter = c('RAT', 'DOG'),
                     strainFilter = c('RAT: WISTAR', 'DOG: BEAGLE'))
# No filtering, just add SPECIES and STRAIN - do not include messages when
# these values cannot be confidently found
getSubjSpeciesStrain(dbToken, controlAnimals,
                     noFilterReportUncertain = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='getTabColLabels'>Get labels for columns in a data.table</h2><span id='topic+getTabColLabels'></span>

<h3>Description</h3>

<p>Get labels for columns in a data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTabColLabels(table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTabColLabels_+3A_table">table</code></td>
<td>
<p>Mandatory<br />
The data.table to get column labels for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with each column/label pair. If a column have no
defined label, the label is 'na'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
colLabels = getTabColLabels(controlAnimalsAll)

## End(Not run)
</code></pre>

<hr>
<h2 id='initEnvironment'>Initialize the environment.</h2><span id='topic+initEnvironment'></span>

<h3>Description</h3>

<p>Open or create a SEND database and return a token for the open database
connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initEnvironment(
  dbType = NULL,
  dbPath = NULL,
  dbCreate = FALSE,
  dbUser = NULL,
  dbPwd = NULL,
  dbSchema = NULL,
  ctFile = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initEnvironment_+3A_dbtype">dbType</code></td>
<td>
<p>Mandatory, character<br />
The type of database, valid values (case insensitive):
</p>

<ul>
<li><p> 'sqlite'
</p>
</li>
<li><p> 'oracle'
</p>
</li></ul>
</td></tr>
<tr><td><code id="initEnvironment_+3A_dbpath">dbPath</code></td>
<td>
<p>Mandatory, character<br />
The path to the database (path to file or another kind of db reference)</p>
</td></tr>
<tr><td><code id="initEnvironment_+3A_dbcreate">dbCreate</code></td>
<td>
<p>Mandatory, boolean<br />
If <code>TRUE</code>, a new database is to be created - this is only valid for
<code>dbType</code> 'sqlite'</p>
</td></tr>
<tr><td><code id="initEnvironment_+3A_dbuser">dbUser</code></td>
<td>
<p>Mandatory, character - if login credentials are required for the
specific db type<br />
The user name to be used for login to database.</p>
</td></tr>
<tr><td><code id="initEnvironment_+3A_dbpwd">dbPwd</code></td>
<td>
<p>Mandatory, character - if login credentials are required for the
specific db type<br />
The password to be used for login to database.</p>
</td></tr>
<tr><td><code id="initEnvironment_+3A_dbschema">dbSchema</code></td>
<td>
<p>Optional, character<br />
The table owner of the SEND table in the specific database.<br />
This parameter is only relevant to specify if it is necessary to prefix
table names with schema in SQL statements i the database.</p>
</td></tr>
<tr><td><code id="initEnvironment_+3A_ctfile">ctFile</code></td>
<td>
<p>Optional, character.<br />
Name (full path) of CDISC CT file in Excel xls format to be imported.
Only relevant to use if another CDISC CT version than the version
included in packages is wanted.<br /></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the function is executed with parameter <code>dbCreate=FALSE</code> (default),
a connection to the specified database is opened. Dependent of the type of
database (parameter <code>dbType</code>), a login using specified user credentials
(parameters <code>dbUser</code> and <code>dbPwd</code>) may be done.<br />
The database must contain a set of tables representing the SEND domains
compliant with SEND IG version 3.0 and/on 3.1.<br />
</p>
<p>If the function is executed with parameter <code>dbCreate=TRUE</code>, an empty
database is created and opened. This is only supported for a SQLite database,
i.e. parameter <code>dbType='sqlite'</code>. The SEND domain tables may then be
created by execution of the function <code><a href="#topic+dbCreateSchema">dbCreateSchema</a></code>.
</p>
<p>Besides the open database connection, a set of CDISC SEND controlled
terminology values are imported. If parameter <code>ctFile</code> is specified with
a path to an Excel file containing a CDISC SEND ct version downloaded from
<a href="https://evs.nci.nih.gov/ftp1/CDISC/SEND/">https://evs.nci.nih.gov/ftp1/CDISC/SEND/</a>, the content
from this file is imported and used by some of the package's functions.
Else a set of CDISC SEND CT values which are included in the  packages is
used by the package's functions. It's the newest CDISC SEND CT version at the
time of the build of the current version of the package which is included.
</p>


<h3>Value</h3>

<p>The function returns a token which is a data structure describing
the open database connection. This token must be given as input parameter
to all functions accessing the actual database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
db &lt;- initEnvironment(dbType='sqlite',
                      dbPath='//servername/SendData/db/send.db',
                      ctFile='//servername/SendData/metadata/SEND_Terminology_2019-12-27.xls')
db &lt;- initEnvironment(dbType='oracle',
                      dbPath='dbserver:1521/send_db',
                      dbUser='ME',
                      dbPwd='mypassword',
                      dbSchema = 'send',
                      ctFile='//servername/SendData/metadata/SEND_Terminology_2019-12-27.xls')

## End(Not run)


</code></pre>

<hr>
<h2 id='standardize_file'>Standardizes SEND xpt files using CDISC controlled terminologies</h2><span id='topic+standardize_file'></span>

<h3>Description</h3>

<p>Standardizes SEND xpt files using CDISC controlled terminologies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_file(input_xpt_dir, output_xpt_dir, json_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_file_+3A_input_xpt_dir">input_xpt_dir</code></td>
<td>
<p>Mandatory.<br />
input folder name with xpt files under the folder.<br /></p>
</td></tr>
<tr><td><code id="standardize_file_+3A_output_xpt_dir">output_xpt_dir</code></td>
<td>
<p>Mandatory.<br />
output folder name for writing the cleaned xpt files. <br /></p>
</td></tr>
<tr><td><code id="standardize_file_+3A_json_file">json_file</code></td>
<td>
<p>Mandatory.<br />
json filename used for mapping. <br /></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects<br />
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
