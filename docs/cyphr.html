<!DOCTYPE html><html><head><title>Help for package cyphr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cyphr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cyphr'><p>High Level Encryption Wrappers</p></a></li>
<li><a href='#data_admin_init'><p>Encrypted data administration</p></a></li>
<li><a href='#data_request_access'><p>User commands</p></a></li>
<li><a href='#encrypt'><p>Easy encryption and decryption</p></a></li>
<li><a href='#encrypt_data'><p>Encrypt and decrypt data and other things</p></a></li>
<li><a href='#key_openssl'><p>Symmetric encryption with openssl</p></a></li>
<li><a href='#key_sodium'><p>Symmetric encryption with sodium</p></a></li>
<li><a href='#keypair_openssl'><p>Asymmetric encryption with openssl</p></a></li>
<li><a href='#keypair_sodium'><p>Asymmetric encryption with sodium</p></a></li>
<li><a href='#rewrite_register'><p>Register functions to work with encrypt/decrypt</p></a></li>
<li><a href='#session_key_refresh'><p>Refresh the session key</p></a></li>
<li><a href='#ssh_keygen'><p>Create ssh keypairs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>High Level Encryption Wrappers</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Encryption wrappers, using low-level support from
    'sodium' and 'openssl'.  'cyphr' tries to smooth over some pain
    points when using encryption within applications and data analysis
    by wrapping around differences in function names and arguments in
    different encryption providing packages.  It also provides
    high-level wrappers for input/output functions for seamlessly
    adding encryption to existing analyses.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/cyphr">https://github.com/ropensci/cyphr</a>,
<a href="https://docs.ropensci.org/cyphr/">https://docs.ropensci.org/cyphr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/cyphr/issues">https://github.com/ropensci/cyphr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>getPass, openssl (&ge; 0.9.9), sodium (&ge; 1.2.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-20 09:55:38 UTC; rich</td>
</tr>
<tr>
<td>Author:</td>
<td>Rich FitzJohn [aut, cre],
  Jai Ranganathan [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rich FitzJohn &lt;rich.fitzjohn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-20 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cyphr'>High Level Encryption Wrappers</h2><span id='topic+cyphr'></span>

<h3>Description</h3>

<p>Encryption wrappers, using low-level support from sodium and openssl.
</p>


<h3>Details</h3>

<p>It is <em>strongly</em> recommended that you read <em>both</em> vignettes before
attempting to use <code>cyphr</code>.
</p>

<ul>
<li> <p><a href="https://docs.ropensci.org/cyphr/articles/cyphr.html">introduction</a>;
in R: <code>vignette("cyphr", package = "cyphr")</code>
</p>
</li>
<li> <p><a href="https://docs.ropensci.org/cyphr/articles/data.html">data vignette</a>;
in R: <code>vignette("data", package = "cyphr")</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rich FitzJohn (rich.fitzjohn@gmail.com)
</p>

<hr>
<h2 id='data_admin_init'>Encrypted data administration</h2><span id='topic+data_admin_init'></span><span id='topic+data_admin_authorise'></span><span id='topic+data_admin_list_requests'></span><span id='topic+data_admin_list_keys'></span>

<h3>Description</h3>

<p>Encrypted data administration; functions for setting up, adding
users, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_admin_init(path_data, path_user = NULL, quiet = FALSE)

data_admin_authorise(
  path_data = NULL,
  hash = NULL,
  path_user = NULL,
  yes = FALSE,
  quiet = FALSE
)

data_admin_list_requests(path_data = NULL)

data_admin_list_keys(path_data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_admin_init_+3A_path_data">path_data</code></td>
<td>
<p>Path to the data set.  We will store a bunch of
things in a hidden directory within this path.  By default in
most functions we will search down the tree until we find the
.cyphr directory</p>
</td></tr>
<tr><td><code id="data_admin_init_+3A_path_user">path_user</code></td>
<td>
<p>Path to the directory with your ssh key.
Usually this can be omitted.</p>
</td></tr>
<tr><td><code id="data_admin_init_+3A_quiet">quiet</code></td>
<td>
<p>Suppress printing of informative messages.</p>
</td></tr>
<tr><td><code id="data_admin_init_+3A_hash">hash</code></td>
<td>
<p>A vector of hashes to add.  If provided, each hash can
be the binary or string representation of the hash to add.  Or
omit to add each request.</p>
</td></tr>
<tr><td><code id="data_admin_init_+3A_yes">yes</code></td>
<td>
<p>Skip the confirmation prompt?  If any request is
declined then the function will throw an error on exit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data_admin_init</code> initialises the system; it will create a
data key if it does not exist and authorise you.  If it already
exists and you do not have access it will throw an error.
</p>
<p><code>data_admin_authorise</code> authorises a key by creating a key to
the data that the user can use in conjunction with their personal
key.
</p>
<p><code>data_admin_list_requests</code> lists current requests.
</p>
<p><code>data_admin_list_keys</code> lists known keys that can access the
data.  Note that this is <em>not secure</em>; keys not listed here
may still be able to access the data (if a key was authorised and
moved elsewhere for example).  Conversely, if the user has deleted
or changed their key they will not be able to access the data
despite the key being listed here.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data_request_access">data_request_access()</a></code> for requesting access
to the data, and and <code>data_key</code> for using the data
itself.  But for a much more thorough overview, see the vignette
(<code>vignette("data", package = "cyphr")</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The workflow here does not really lend itself to an example,
# please see the vignette instead.

# First we need a set of user ssh keys.  In a non example
# environment your personal ssh keys will probably work well, but
# hopefully they are password protected so cannot be used in
# examples.  The password = FALSE argument is only for testing,
# and should not be used for data that you care about.
path_ssh_key &lt;- tempfile()
cyphr::ssh_keygen(path_ssh_key, password = FALSE)

# Initialise the data directory, using this key path.  Ordinarily
# the path_user argument would not be needed because we would be
# using your user ssh keys:
path_data &lt;- tempfile()
dir.create(path_data, FALSE, TRUE)
cyphr::data_admin_init(path_data, path_user = path_ssh_key)

# Now you can get the data key
key &lt;- cyphr::data_key(path_data, path_user = path_ssh_key)

# And encrypt things with it
cyphr::encrypt_string("hello", key)

# See the vignette for more details.  This is not the best medium
# to explore this.

# Cleanup
unlink(path_ssh_key, recursive = TRUE)
unlink(path_data, recursive = TRUE)
</code></pre>

<hr>
<h2 id='data_request_access'>User commands</h2><span id='topic+data_request_access'></span><span id='topic+data_key'></span>

<h3>Description</h3>

<p>User commands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_request_access(path_data = NULL, path_user = NULL, quiet = FALSE)

data_key(
  path_data = NULL,
  path_user = NULL,
  test = TRUE,
  quiet = FALSE,
  cache = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_request_access_+3A_path_data">path_data</code></td>
<td>
<p>Path to the data.  If not given, then we look
recursively down below the working directory for a &quot;.cyphr&quot;
directory, and use that as the data directory.</p>
</td></tr>
<tr><td><code id="data_request_access_+3A_path_user">path_user</code></td>
<td>
<p>Path to the directory with your user key.
Usually this can be omitted.  This argument is passed in as both
<code>pub</code> and <code>key</code> to <code><a href="#topic+keypair_openssl">keypair_openssl()</a></code>.
Briefly, if this argument is not given we look at the
environment variables <code>USER_PUBKEY</code> and <code>USER_KEY</code> -
if set then these must refer to path of your public and private
keys.  If these environment variables are not set then we fall
back on <code style="white-space: pre;">&#8288;~/.ssh/id_rsa.pub&#8288;</code> and <code style="white-space: pre;">&#8288;~/.ssh/id_rsa&#8288;</code>,
which should work in most environments.  Alternatively, provide
a path to a directory where the file <code>id_rsa.pub</code> and
<code>id_rsa</code> can be found.</p>
</td></tr>
<tr><td><code id="data_request_access_+3A_quiet">quiet</code></td>
<td>
<p>Suppress printing of informative messages.</p>
</td></tr>
<tr><td><code id="data_request_access_+3A_test">test</code></td>
<td>
<p>Test that the encryption is working?  (Recommended)</p>
</td></tr>
<tr><td><code id="data_request_access_+3A_cache">cache</code></td>
<td>
<p>Cache the key within the session.  This will be
useful if you are using ssh keys that have passwords, as if the
key is found within the cache, then you will not have to
re-enter your password.  Using <code>cache = FALSE</code> neither
looks for the key in the cache, nor saves it.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# The workflow here does not really lend itself to an example,
# please see the vignette.

# Suppose that Alice has created a data directory:
path_alice &lt;- tempfile()
cyphr::ssh_keygen(path_alice, password = FALSE)
path_data &lt;- tempfile()
dir.create(path_data, FALSE, TRUE)
cyphr::data_admin_init(path_data, path_user = path_alice)

# If Bob can also write to the data directory (e.g., it is a
# shared git repo, on a shared drive, etc), then he can request
# access
path_bob &lt;- tempfile()
cyphr::ssh_keygen(path_bob, password = FALSE)
hash &lt;- cyphr::data_request_access(path_data, path_user = path_bob)

# Alice can authorise Bob
cyphr::data_admin_authorise(path_data, path_user = path_alice, yes = TRUE)

# After which Bob can get the data key
cyphr::data_key(path_data, path_user = path_bob)

# See the vignette for more details.  This is not the best medium
# to explore this.

# Cleanup
unlink(path_alice, recursive = TRUE)
unlink(path_bob, recursive = TRUE)
unlink(path_data, recursive = TRUE)
</code></pre>

<hr>
<h2 id='encrypt'>Easy encryption and decryption</h2><span id='topic+encrypt'></span><span id='topic+decrypt'></span><span id='topic+encrypt_'></span><span id='topic+decrypt_'></span>

<h3>Description</h3>

<p>Wrapper functions for encryption.  These functions wrap
expressions that produce or consume a file and arrange to encrypt
(for producing functions) or decrypt (for consuming functions).
The forms with a trailing underscore (<code>encrypt_</code>,
<code>decrypt_</code>) do not use any non-standard evaluation and may be
more useful for programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encrypt(expr, key, file_arg = NULL, envir = parent.frame())

decrypt(expr, key, file_arg = NULL, envir = parent.frame())

encrypt_(expr, key, file_arg = NULL, envir = parent.frame())

decrypt_(expr, key, file_arg = NULL, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encrypt_+3A_expr">expr</code></td>
<td>
<p>A single expression representing a function call that
would be called for the side effect of creating or reading a
file.</p>
</td></tr>
<tr><td><code id="encrypt_+3A_key">key</code></td>
<td>
<p>A <code>cyphr_key</code> object describing the
encryption approach to use.</p>
</td></tr>
<tr><td><code id="encrypt_+3A_file_arg">file_arg</code></td>
<td>
<p>Optional hint indicating which argument to
<code>expr</code> is the filename.  This is done automatically for
some built-in functions.</p>
</td></tr>
<tr><td><code id="encrypt_+3A_envir">envir</code></td>
<td>
<p>Environment in which <code>expr</code> is to be evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions will not work for all functions.  For example
<code>pdf</code>/<code>dev.off</code> will create a file but we can't wrap
those up (yet!).  Functions that <em>modify</em> a file (e.g.,
appending) also will not work and may cause data loss.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To do anything we first need a key:
key &lt;- cyphr::key_sodium(sodium::keygen())

# Encrypted write.csv - note how any number of arguments to
# write.csv will be passed along
path &lt;- tempfile(fileext = ".csv")
cyphr::encrypt(write.csv(iris, path, row.names = FALSE), key)

# The new file now exists, but you would not be able to read it
# with read.csv because it is now binary data.
file.exists(path)

# Wrap the read.csv call with cyphr::decrypt()
dat &lt;- cyphr::decrypt(read.csv(path, stringsAsFactors = FALSE), key)
head(dat)

file.remove(path)

# If you have a function that is not supported you can specify the
# filename argument directly.  For example, with "write.dcf" the
# filename argument is called "file"; we can pass that along
path &lt;- tempfile()
cyphr::encrypt(write.dcf(list(a = 1), path), key, file_arg = "file")

# Similarly for decryption:
cyphr::decrypt(read.dcf(path), key, file_arg = "file")
</code></pre>

<hr>
<h2 id='encrypt_data'>Encrypt and decrypt data and other things</h2><span id='topic+encrypt_data'></span><span id='topic+encrypt_object'></span><span id='topic+encrypt_string'></span><span id='topic+encrypt_file'></span><span id='topic+decrypt_data'></span><span id='topic+decrypt_object'></span><span id='topic+decrypt_string'></span><span id='topic+decrypt_file'></span>

<h3>Description</h3>

<p>Encrypt and decrypt raw data, objects, strings and files.  The
core functions here are <code>encrypt_data</code> and
<code>decrypt_data</code> which take raw data and decrypt it, writing
either to file or returning a raw vector.  The other functions
encrypt and decrypt arbitrary R objects (<code>encrypt_object</code>,
<code>decrypt_object</code>), strings (<code>encrypt_string</code>,
<code>decrypt_string</code>) and files (<code>encrypt_file</code>,
<code>decrypt_file</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encrypt_data(data, key, dest = NULL)

encrypt_object(object, key, dest = NULL, rds_version = NULL)

encrypt_string(string, key, dest = NULL)

encrypt_file(path, key, dest = NULL)

decrypt_data(data, key, dest = NULL)

decrypt_object(data, key)

decrypt_string(data, key)

decrypt_file(path, key, dest = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encrypt_data_+3A_data">data</code></td>
<td>
<p>(for <code>encrypt_data</code>, <code>decrypt_data</code>,
<code>decrypt_object</code>, <code>decrypt_string</code>) a raw vector with
the data to be encrypted or decrypted.  For the decryption
functions this must be data derived by encrypting something or
you will get an error.</p>
</td></tr>
<tr><td><code id="encrypt_data_+3A_key">key</code></td>
<td>
<p>A <code>cyphr_key</code> object describing the encryption approach
to use.</p>
</td></tr>
<tr><td><code id="encrypt_data_+3A_dest">dest</code></td>
<td>
<p>The destination filename for the encrypted or
decrypted data, or <code>NULL</code> to return a raw vector.  This is
not used by <code>decrypt_object</code> or <code>decrypt_string</code> which
always return an object or string.</p>
</td></tr>
<tr><td><code id="encrypt_data_+3A_object">object</code></td>
<td>
<p>(for <code>encrypt_object</code>) an arbitrary R object to
encrypt.  It will be serialised to raw first (see
<a href="base.html#topic+serialize">serialize</a>).</p>
</td></tr>
<tr><td><code id="encrypt_data_+3A_rds_version">rds_version</code></td>
<td>
<p>RDS serialisation version to use (see
<a href="base.html#topic+serialize">serialize</a>.  The default in R version 3.3 and below is version
2 - in the R 3.4 series version 3 was introduced and is becoming
the default.  Version 3 format serialisation is not understood
by older versions so if you need to exchange data with older R
versions, you will need to use <code>rds_version = 2</code>.  The default
argument here (<code>NULL</code>) will ensure the same serialisation is
used as R would use by default.</p>
</td></tr>
<tr><td><code id="encrypt_data_+3A_string">string</code></td>
<td>
<p>(for <code>encrypt_string</code>) a scalar character
vector to encrypt.  It will be converted to raw first with
<a href="base.html#topic+charToRaw">charToRaw</a>.</p>
</td></tr>
<tr><td><code id="encrypt_data_+3A_path">path</code></td>
<td>
<p>(for <code>encrypt_file</code>) the name of a file to
encrypt.  It will first be read into R as binary (see
<a href="base.html#topic+readBin">readBin</a>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>key &lt;- key_sodium(sodium::keygen())
# Some super secret data we want to encrypt:
x &lt;- runif(10)
# Convert the data into a raw vector:
data &lt;- serialize(x, NULL)
data
# Encrypt the data; without the key above we will never be able to
# decrypt this.
data_enc &lt;- encrypt_data(data, key)
data_enc
# Our random numbers:
unserialize(decrypt_data(data_enc, key))
# Same as the never-encrypted version:
x

# This can be achieved more easily using `encrypt_object`:
data_enc &lt;- encrypt_object(x, key)
identical(decrypt_object(data_enc, key), x)

# Encrypt strings easily:
str_enc &lt;- encrypt_string("secret message", key)
str_enc
decrypt_string(str_enc, key)
</code></pre>

<hr>
<h2 id='key_openssl'>Symmetric encryption with openssl</h2><span id='topic+key_openssl'></span>

<h3>Description</h3>

<p>Wrap an openssl symmetric (aes) key.  This can be used with the
functions <code><a href="#topic+encrypt_data">encrypt_data()</a></code> and
<code><a href="#topic+decrypt_data">decrypt_data()</a></code>, along with the higher level wrappers
<code><a href="#topic+encrypt">encrypt()</a></code> and <code><a href="#topic+decrypt">decrypt()</a></code>.  With a symmetric
key, everybody uses the same key for encryption and decryption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>key_openssl(key, mode = "cbc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="key_openssl_+3A_key">key</code></td>
<td>
<p>An openssl aes key (i.e., an object of class <code>aes</code>).</p>
</td></tr>
<tr><td><code id="key_openssl_+3A_mode">mode</code></td>
<td>
<p>The encryption mode to use.  Options are <code>cbc</code>,
<code>ctr</code> and <code>gcm</code> (see the <code>openssl</code> package for
more details)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Create a new key
key &lt;- cyphr::key_openssl(openssl::aes_keygen())
key

# With this key encrypt a string
secret &lt;- cyphr::encrypt_string("my secret string", key)
# And decrypt it again:
cyphr::decrypt_string(secret, key)
</code></pre>

<hr>
<h2 id='key_sodium'>Symmetric encryption with sodium</h2><span id='topic+key_sodium'></span>

<h3>Description</h3>

<p>Wrap a sodium symmetric key.  This can be used with the functions
<code><a href="#topic+encrypt_data">encrypt_data()</a></code> and <code><a href="#topic+decrypt_data">decrypt_data()</a></code>, along
with the higher level wrappers <code><a href="#topic+encrypt">encrypt()</a></code> and
<code><a href="#topic+decrypt">decrypt()</a></code>.  With a symmetric key, everybody uses the
same key for encryption and decryption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>key_sodium(key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="key_sodium_+3A_key">key</code></td>
<td>
<p>A sodium key (i.e., generated with <code><a href="sodium.html#topic+keygen">sodium::keygen()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Create a new key
key &lt;- cyphr::key_sodium(sodium::keygen())
key

# With this key encrypt a string
secret &lt;- cyphr::encrypt_string("my secret string", key)
# And decrypt it again:
cyphr::decrypt_string(secret, key)
</code></pre>

<hr>
<h2 id='keypair_openssl'>Asymmetric encryption with openssl</h2><span id='topic+keypair_openssl'></span>

<h3>Description</h3>

<p>Wrap a pair of openssl keys.  You should pass your private key and
the public key of the person that you are communicating with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keypair_openssl(
  pub,
  key,
  envelope = TRUE,
  password = NULL,
  authenticated = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keypair_openssl_+3A_pub">pub</code></td>
<td>
<p>An openssl public key.  Usually this will be the path
to the key, in which case it may either the path to a public key
or be the path to a directory containing a file
<code>id_rsa.pub</code>.  If <code>NULL</code>, then your public key will be
used (found via the environment variable <code>USER_PUBKEY</code>,
then <code style="white-space: pre;">&#8288;~/.ssh/id_rsa.pub&#8288;</code>).  However, it is not that common
to use your own public key - typically you want either the
sender of a message you are going to decrypt, or the recipient
of a message you want to send.</p>
</td></tr>
<tr><td><code id="keypair_openssl_+3A_key">key</code></td>
<td>
<p>An openssl private key.  Usually this will be the path
to the key, in which case it may either the path to a private
key or be the path to a directory containing a file.  You may
specify <code>NULL</code> here, in which case the environment variable
<code>USER_KEY</code> is checked and if that is not defined then
<code style="white-space: pre;">&#8288;~/.ssh/id_rsa&#8288;</code> will be used.</p>
</td></tr>
<tr><td><code id="keypair_openssl_+3A_envelope">envelope</code></td>
<td>
<p>A logical indicating if &quot;envelope&quot; encryption
functions should be used.  If so, then we use
<code><a href="openssl.html#topic+encrypt_envelope">openssl::encrypt_envelope()</a></code> and
<code><a href="openssl.html#topic+encrypt_envelope">openssl::decrypt_envelope()</a></code>.  If <code>FALSE</code> then we use
<code><a href="openssl.html#topic+rsa_encrypt">openssl::rsa_encrypt()</a></code> and <code><a href="openssl.html#topic+rsa_encrypt">openssl::rsa_decrypt()</a></code>.
See the openssl docs for further details.  The main effect of
this is that using <code>envelope = TRUE</code> will allow you to
encrypt much larger data than <code>envelope = FALSE</code>; this is
because openssl asymmetric encryption can only encrypt data up
to the size of the key itself.</p>
</td></tr>
<tr><td><code id="keypair_openssl_+3A_password">password</code></td>
<td>
<p>A password for the private key.  If <code>NULL</code>
then you will be prompted interactively for your password, and
if a string then that string will be used as the password (but
be careful in scripts!)</p>
</td></tr>
<tr><td><code id="keypair_openssl_+3A_authenticated">authenticated</code></td>
<td>
<p>Logical, indicating if the result should be
signed with your public key.  If <code>TRUE</code> then your key will
be verified on decryption.  This provides tampering detection.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+keypair_sodium">keypair_sodium()</a></code> for a similar function using
sodium keypairs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Note this uses password = FALSE for use in examples only, but
# this should not be done for any data you actually care about.

# Note that the vignette contains much more information than this
# short example and should be referred to before using these
# functions.

# Generate two keypairs, one for Alice, and one for Bob
path_alice &lt;- tempfile()
path_bob &lt;- tempfile()
cyphr::ssh_keygen(path_alice, password = FALSE)
cyphr::ssh_keygen(path_bob, password = FALSE)

# Alice wants to send Bob a message so she creates a key pair with
# her private key and bob's public key (she does not have bob's
# private key).
pair_alice &lt;- cyphr::keypair_openssl(pub = path_bob, key = path_alice)

# She can then encrypt a secret message:
secret &lt;- cyphr::encrypt_string("hi bob", pair_alice)
secret

# Bob wants to read the message so he creates a key pair using
# Alice's public key and his private key:
pair_bob &lt;- cyphr::keypair_openssl(pub = path_alice, key = path_bob)

cyphr::decrypt_string(secret, pair_bob)

# Clean up
unlink(path_alice, recursive = TRUE)
unlink(path_bob, recursive = TRUE)
</code></pre>

<hr>
<h2 id='keypair_sodium'>Asymmetric encryption with sodium</h2><span id='topic+keypair_sodium'></span>

<h3>Description</h3>

<p>Wrap a pair of sodium keys for asymmetric encryption.  You should
pass your private key and the public key of the person that you
are communicating with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keypair_sodium(pub, key, authenticated = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keypair_sodium_+3A_pub">pub</code></td>
<td>
<p>A sodium public key.  This is either a raw vector of
length 32 or a path to file containing the contents of the key
(written by <code><a href="base.html#topic+writeBin">writeBin()</a></code>).</p>
</td></tr>
<tr><td><code id="keypair_sodium_+3A_key">key</code></td>
<td>
<p>A sodium private key.  This is either a raw vector of
length 32 or a path to file containing the contents of the key
(written by <code><a href="base.html#topic+writeBin">writeBin()</a></code>).</p>
</td></tr>
<tr><td><code id="keypair_sodium_+3A_authenticated">authenticated</code></td>
<td>
<p>Logical, indicating if authenticated
encryption (via <code><a href="sodium.html#topic+messaging">sodium::auth_encrypt()</a></code> /
<code><a href="sodium.html#topic+messaging">sodium::auth_decrypt()</a></code>) should be used.  If <code>FALSE</code>
then <code><a href="sodium.html#topic+simple">sodium::simple_encrypt()</a></code> /
<code><a href="sodium.html#topic+simple">sodium::simple_decrypt()</a></code> will be used.  The difference is
that with <code>authenticated = TRUE</code> the message is signed with
your private key so that tampering with the message will be
detected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>NOTE</em>: the order here (pub, key) is very important; if the
wrong order is used you cannot decrypt things.  Unfortunately
because sodium keys are just byte sequences there is nothing to
distinguish the public and private keys so this is a pretty easy
mistake to make.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+keypair_openssl">keypair_openssl()</a></code> for a similar function using
openssl keypairs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate two keypairs, one for Alice, and one for Bob
key_alice &lt;- sodium::keygen()
pub_alice &lt;- sodium::pubkey(key_alice)
key_bob &lt;- sodium::keygen()
pub_bob &lt;- sodium::pubkey(key_bob)

# Alice wants to send Bob a message so she creates a key pair with
# her private key and bob's public key (she does not have bob's
# private key).
pair_alice &lt;- cyphr::keypair_sodium(pub = pub_bob, key = key_alice)

# She can then encrypt a secret message:
secret &lt;- cyphr::encrypt_string("hi bob", pair_alice)
secret

# Bob wants to read the message so he creates a key pair using
# Alice's public key and his private key:
pair_bob &lt;- cyphr::keypair_sodium(pub = pub_alice, key = key_bob)

cyphr::decrypt_string(secret, pair_bob)
</code></pre>

<hr>
<h2 id='rewrite_register'>Register functions to work with encrypt/decrypt</h2><span id='topic+rewrite_register'></span>

<h3>Description</h3>

<p>Add information about argument rewriting so that they can be used
with <a href="#topic+encrypt">encrypt</a> and <a href="#topic+decrypt">decrypt</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rewrite_register(package, name, arg, fn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rewrite_register_+3A_package">package</code></td>
<td>
<p>The name of the package with the function to
support (as a scalar character).  If your function has no
package (e.g., a function you are working on outside of a
package, use &quot;&quot; as the name).</p>
</td></tr>
<tr><td><code id="rewrite_register_+3A_name">name</code></td>
<td>
<p>The name of the function to support.</p>
</td></tr>
<tr><td><code id="rewrite_register_+3A_arg">arg</code></td>
<td>
<p>The name of the argument in the target function that
refers to the file that should be encrypted or decrypted.  This
is the value you would pass through to <code>file_arg</code> in
<a href="#topic+encrypt">encrypt</a>.</p>
</td></tr>
<tr><td><code id="rewrite_register_+3A_fn">fn</code></td>
<td>
<p>Optional (and should be rare) argument used to work
around functions that pass all their arguments through to a
second function as dots.  This is how <code>read.csv</code> works.  If
needed this function is a length-2 character vector in the form
&quot;package&quot;, &quot;name&quot; with the actual function that is used.  But
this should be very rare!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If your package uses cyphr, it might be useful to add this as
an <code>.onLoad()</code> hook.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The saveRDS function is already supported.  But if we wanted to
# support it we could look at the arguments for the function:
args(saveRDS)
# The 'file' argument is the one that refers to the filename, so
# we'd write:
cyphr::rewrite_register("base", "saveRDS", "file")
# It's non-API but you can see what is supported in the package by
# looking at
ls(cyphr:::db)
</code></pre>

<hr>
<h2 id='session_key_refresh'>Refresh the session key</h2><span id='topic+session_key_refresh'></span>

<h3>Description</h3>

<p>Refresh the session key, invalidating all keys created by
<code><a href="#topic+key_openssl">key_openssl()</a></code>, <code><a href="#topic+keypair_openssl">keypair_openssl()</a></code>,
<code><a href="#topic+key_sodium">key_sodium()</a></code> and <code><a href="#topic+keypair_sodium">keypair_sodium()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>session_key_refresh()
</code></pre>


<h3>Details</h3>

<p>Running this function will invalidate <em>all</em> keys loaded with
the above functions.  It should not be needed very often.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Be careful - if you run this then all keys loaded from file will
# no longer work until reloaded
if (FALSE) {
  cyphr::session_key_refresh()
}
</code></pre>

<hr>
<h2 id='ssh_keygen'>Create ssh keypairs</h2><span id='topic+ssh_keygen'></span>

<h3>Description</h3>

<p>Create openssl key pairs in the manner of <code>ssh-keygen</code>(1).
In general this should not be used (generate keys yourself with
<code>ssh-keygen</code> at the command line.  However this is useful for
testing and demonstration so I have included it to make that
easier.  Once a keypair has been generated it can be used with
<code><a href="#topic+keypair_openssl">keypair_openssl()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssh_keygen(path = tempfile(), password = TRUE, use_shell = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssh_keygen_+3A_path">path</code></td>
<td>
<p>A directory in which to create a keypair.  If the path
does not exist it will be created.</p>
</td></tr>
<tr><td><code id="ssh_keygen_+3A_password">password</code></td>
<td>
<p>The password for the key.  The default will prompt
interactively (but without echoing the password).  Other valid
options are <code>FALSE</code> (no password) or a string.</p>
</td></tr>
<tr><td><code id="ssh_keygen_+3A_use_shell">use_shell</code></td>
<td>
<p>Try to use <code>ssh-keygen</code> (the shell utility)
rather than functions in the <code>openssl</code> package.  This will
be necessary on at least very old versions of OS/X (Yosemite and
older at least) where the keys generated by the <code>openssl</code>
package cannot be read by the system ssh commands (e.g.,
<code>ssh-add</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>path</code>, invisibly.  This is useful in the case
where <code>path</code> is <code><a href="base.html#topic+tempfile">tempfile()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a new key in a temporary directory:
path &lt;- cyphr::ssh_keygen(password = FALSE)
dir(path) # will contain id_rsa and id_rsa.pub

# This key can now be used via keypair_openssl:
key &lt;- cyphr::keypair_openssl(path, path)
secret &lt;- cyphr::encrypt_string("hello", key)
cyphr::decrypt_string(secret, key)

# Cleanup
unlink(path, recursive = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
