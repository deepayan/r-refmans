<!DOCTYPE html><html><head><title>Help for package accessibility</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {accessibility}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accessibility'><p>accessibility: Transport accessibility measures</p></a></li>
<li><a href='#balancing_cost'><p>Balancing cost accessibility measure</p></a></li>
<li><a href='#concentration_index'><p>Concentration Index</p></a></li>
<li><a href='#cost_to_closest'><p>Minimum travel cost to closest N number of opportunities</p></a></li>
<li><a href='#cumulative_cutoff'><p>Cumulative access based on a travel cost cutoff</p></a></li>
<li><a href='#cumulative_interval'><p>Cumulative access based on maximum travel time interval</p></a></li>
<li><a href='#decay_binary'><p>Binary (a.k.a. step) decay function</p></a></li>
<li><a href='#decay_exponential'><p>Negative exponential decay function</p></a></li>
<li><a href='#decay_linear'><p>Linear decay function</p></a></li>
<li><a href='#decay_logistic'><p>Logistic decay function</p></a></li>
<li><a href='#decay_power'><p>Inverse power decay function</p></a></li>
<li><a href='#decay_stepped'><p>Stepped decay function</p></a></li>
<li><a href='#fgt_poverty'><p>Foster-Greer-Thorbecke (FGT) poverty measures</p></a></li>
<li><a href='#floating_catchment_area'><p>Floating catchment area accessibility</p></a></li>
<li><a href='#gini_index'><p>Gini Index</p></a></li>
<li><a href='#gravity'><p>Gravity-based accessibility measures</p></a></li>
<li><a href='#palma_ratio'><p>Palma Ratio</p></a></li>
<li><a href='#spatial_availability'><p>Spatial availability</p></a></li>
<li><a href='#theil_t'><p>Theil T Index</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Transport Accessibility Measures</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of fast and convenient functions to help conducting
    accessibility analyses. Given a pre-computed travel cost matrix and a
    land use dataset (containing the location of jobs, healthcare and
    population, for example), the package allows one to calculate
    accessibility levels and accessibility poverty and inequality. The
    package covers the majority of the most commonly used accessibility
    measures (such as cumulative opportunities, gravity-based and floating
    catchment areas methods), as well as the most frequently used
    inequality and poverty metrics (such as the Palma ratio, the
    concentration and Theil indices and the FGT family of measures).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ipeaGIT/accessibility">https://github.com/ipeaGIT/accessibility</a>,
<a href="https://ipeagit.github.io/accessibility/">https://ipeagit.github.io/accessibility/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ipeaGIT/accessibility/issues">https://github.com/ipeaGIT/accessibility/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, data.table, Hmisc, Rdpack (&ge; 0.7), stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, knitr, rmarkdown, sf, testthat, tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 20:44:17 UTC; dhersz</td>
</tr>
<tr>
<td>Author:</td>
<td>Rafael H. M. Pereira
    <a href="https://orcid.org/0000-0003-2125-7465"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Daniel Herszenhut <a href="https://orcid.org/0000-0001-8066-1105"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Joey Reid [ctb],
  Ipea - Institute for Applied Economic Research [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Herszenhut &lt;dhersz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-06 23:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='accessibility'>accessibility: Transport accessibility measures</h2><span id='topic+accessibility'></span><span id='topic+_PACKAGE'></span><span id='topic+accessibility-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A set of fast and convenient functions to help conducting accessibility analyses. Given a pre-computed travel cost matrix and a land use dataset (containing the location of jobs, healthcare and population, for example), the package allows one to calculate accessibility levels and accessibility poverty and inequality. The package covers the majority of the most commonly used accessibility measures (such as cumulative opportunities, gravity-based and floating catchment areas methods), as well as the most frequently used inequality and poverty metrics (such as the Palma ratio, the concentration and Theil indices and the FGT family of measures).
</p>


<h3>Usage</h3>

<p>Please check the vignettes for more on the package usage:
</p>

<ul>
<li><p> Introduction to accessibility: calculating accessibility measures. Run
<code>vignette("accessibility")</code> or check it on the <a href="https://ipeagit.github.io/accessibility/articles/accessibility.html">website</a>.
</p>
</li>
<li><p> Decay functions. Run <code>vignette("decay_functions", package = "accessibility")</code> or check it on the <a href="https://ipeagit.github.io/accessibility/articles/decay_functions.html">website</a>.
</p>
</li>
<li><p> Calculating accessibility inequality and poverty. Run
<code>vignette("inequality_and_poverty", package = "accessibility")</code> or check it
on the
<a href="https://ipeagit.github.io/accessibility/articles/inequality_and_poverty.html">website</a>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Daniel Herszenhut <a href="mailto:dhersz@gmail.com">dhersz@gmail.com</a> (<a href="https://orcid.org/0000-0001-8066-1105">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Rafael H. M. Pereira <a href="mailto:rafa.pereira.br@gmail.com">rafa.pereira.br@gmail.com</a> (<a href="https://orcid.org/0000-0003-2125-7465">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Joey Reid [contributor]
</p>
</li>
<li><p> Ipea - Institute for Applied Economic Research [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ipeaGIT/accessibility">https://github.com/ipeaGIT/accessibility</a>
</p>
</li>
<li> <p><a href="https://ipeagit.github.io/accessibility/">https://ipeagit.github.io/accessibility/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ipeaGIT/accessibility/issues">https://github.com/ipeaGIT/accessibility/issues</a>
</p>
</li></ul>


<hr>
<h2 id='balancing_cost'>Balancing cost accessibility measure</h2><span id='topic+balancing_cost'></span>

<h3>Description</h3>

<p>Calculates the balancing cost measure, which is defined as the travel cost
required to reach as many opportunities as the number of people in a given
origin. Originally proposed by
Barboza et al. (2021), under the name
&quot;balancing time&quot;.
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balancing_cost(
  travel_matrix,
  land_use_data,
  opportunity,
  travel_cost,
  demand,
  cost_increment = 1,
  group_by = character(0),
  fill_missing_ids = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balancing_cost_+3A_travel_matrix">travel_matrix</code></td>
<td>
<p>A data frame. The travel matrix describing the costs
(i.e. travel time, distance, monetary cost, etc.) between the origins and
destinations in the study area. Must contain the columns <code>from_id</code>, <code>to_id</code>
and any others specified in <code>travel_cost</code>.</p>
</td></tr>
<tr><td><code id="balancing_cost_+3A_land_use_data">land_use_data</code></td>
<td>
<p>A data frame. The distribution of opportunities within
the study area cells. Must contain the columns <code>id</code> and any others
specified in <code>opportunity</code>.</p>
</td></tr>
<tr><td><code id="balancing_cost_+3A_opportunity">opportunity</code></td>
<td>
<p>A string. The name of the column in <code>land_use_data</code>
with the number of opportunities/resources/services to be considered when
calculating accessibility levels.</p>
</td></tr>
<tr><td><code id="balancing_cost_+3A_travel_cost">travel_cost</code></td>
<td>
<p>A string. The name of the column in <code>travel_matrix</code>
with the travel cost between origins and destinations.</p>
</td></tr>
<tr><td><code id="balancing_cost_+3A_demand">demand</code></td>
<td>
<p>A string. The name of the column in <code>land_use_data</code> with the
number of people in each origin that will be considered potential
competitors.</p>
</td></tr>
<tr><td><code id="balancing_cost_+3A_cost_increment">cost_increment</code></td>
<td>
<p>A number. The cost increment that should be used when
defining the travel cost distribution from which the potential balancing
costs will be picked. For example, an increment of 1 tends to suitable for
travel time distributions, meaning that the function will first check if
any origins reach their balancing cost with a travel time of 0 minutes,
then 1 minute, 2 minutes, 3, 4, ..., etc. A increment of 1 might be too big
for a distribution of monetary costs, on the other hand, which could
possibly benefit from a smaller increment of 0.05, for example, resulting
in the function looking for balancing costs first at a cost of 0, then
0.05, 0.10, ..., etc. Defaults to 1.</p>
</td></tr>
<tr><td><code id="balancing_cost_+3A_group_by">group_by</code></td>
<td>
<p>A <code>character</code> vector. When not <code>character(0)</code> (the default),
indicates the <code>travel_matrix</code> columns that should be used to group the
accessibility estimates by. For example, if <code>travel_matrix</code> includes a
departure time column, that specifies the departure time of each entry in
the data frame, passing <code>"departure_time"</code> to this parameter results in
accessibility estimates grouped by origin and by departure time.</p>
</td></tr>
<tr><td><code id="balancing_cost_+3A_fill_missing_ids">fill_missing_ids</code></td>
<td>
<p>A <code>logical</code>. When calculating grouped accessibility
estimates (i.e. when <code>by_col</code> is not <code>NULL</code>), some combinations of groups
and origins may be missing. For example, if a single trip can depart from
origin <code>A</code> at 7:15am and reach destination <code>B</code> within 55 minutes, but no
trips departing from <code>A</code> at 7:30am can be completed at all, this second
combination will not be included in the output. When <code>TRUE</code> (the default),
the function identifies which combinations would be left out and fills
their respective accessibility values with 0, which incurs in a
performance penalty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the accessibility estimates for each
origin/destination (depending if <code>active</code> is <code>TRUE</code> or <code>FALSE</code>) in the
travel matrix.
</p>
<p>A data frame containing the accessibility estimates for each origin
in the travel matrix. Origins marked with a <code>NA</code> balancing cost never reach
as many opportunities as there is people residing in them, given the
specified travel matrix.
</p>


<h3>References</h3>

<p>Barboza MH, Carneiro MS, Falavigna C, Luz G, Orrico R (2021).
&ldquo;Balancing Time: Using a New Accessibility Measure in Rio de Janeiro.&rdquo;
<em>Journal of Transport Geography</em>, <b>90</b>, 102924.
ISSN 09666923, <a href="https://doi.org/10.1016/j.jtrangeo.2020.102924">doi:10.1016/j.jtrangeo.2020.102924</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_dir &lt;- system.file("extdata", package = "accessibility")
travel_matrix &lt;- readRDS(file.path(data_dir, "travel_matrix.rds"))
land_use_data &lt;- readRDS(file.path(data_dir, "land_use_data.rds"))

bc &lt;- balancing_cost(
  travel_matrix,
  land_use_data,
  opportunity = "jobs",
  travel_cost = "travel_time",
  demand = "population"
)
head(bc)

</code></pre>

<hr>
<h2 id='concentration_index'>Concentration Index</h2><span id='topic+concentration_index'></span>

<h3>Description</h3>

<p>Calculates the Concentration Index (CI) of a given accessibility
distribution. This measures estimates the extent to which accessibility
inequalities are systematically associated with individuals' socioeconomic
levels. CI values can theoretically vary between -1 and +1 (when all
accessibility is concentrated in the most or in the least disadvantaged
person, respectively). Negative values indicate that inequalities favor the
poor, while positive values indicate a pro-rich bias. The function supports
calculating the standard relative CI and the corrected CI, as proposed by
Erreygers (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concentration_index(
  accessibility_data,
  sociodemographic_data,
  opportunity,
  population,
  income,
  type,
  group_by = character(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concentration_index_+3A_accessibility_data">accessibility_data</code></td>
<td>
<p>A data frame. The accessibility levels whose
inequality should be calculated. Must contain the columns <code>id</code> and any
others specified in <code>opportunity</code>.</p>
</td></tr>
<tr><td><code id="concentration_index_+3A_sociodemographic_data">sociodemographic_data</code></td>
<td>
<p>A data frame. The distribution of
sociodemographic characteristics of the population in the study area cells.
Must contain the columns <code>id</code> and any others specified in <code>population</code> and
<code>income</code>.</p>
</td></tr>
<tr><td><code id="concentration_index_+3A_opportunity">opportunity</code></td>
<td>
<p>A string. The name of the column in <code>accessibility_data</code>
with the accessibility levels to be considerend when calculating inequality
levels.</p>
</td></tr>
<tr><td><code id="concentration_index_+3A_population">population</code></td>
<td>
<p>A string. The name of the column in <code>sociodemographic_data</code>
with the number of people in each cell. Used to weigh accessibility levels
when calculating inequality.</p>
</td></tr>
<tr><td><code id="concentration_index_+3A_income">income</code></td>
<td>
<p>A string. The name of the column in <code>sociodemographic_data</code>
with the income variable that should be used to sort the population from
the least to the most privileged. Please note that this variable should
describe income per capita (e.g. mean income per capita, household income
per capita, etc), instead of the total amount of income in each cell. Also
note that, while income is generally used to rank population groups, any
variable that can be used to describe one's socioeconomic status, such as
education level, can be passed to this argument, as long as it can be
numerically ordered (in which higher values denote higher socioeconomic
status).</p>
</td></tr>
<tr><td><code id="concentration_index_+3A_type">type</code></td>
<td>
<p>A string. Which type of Concentration Index to calculate. Current
available options are <code>"standard"</code> and <code>"corrected"</code>.</p>
</td></tr>
<tr><td><code id="concentration_index_+3A_group_by">group_by</code></td>
<td>
<p>A <code>character</code> vector. When not <code>character(0)</code> (the default),
indicates the <code>accessibility_data</code> columns that should be used to group the
inequality estimates by. For example, if <code>accessibility_data</code> includes a
<code>scenario</code> column that identifies distinct scenarios that each
accessibility estimates refer to (e.g. before and after a transport policy
intervention), passing <code>"scenario"</code> to this parameter results in inequality
estimates grouped by scenario.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the inequality estimates for the study area.
</p>


<h3>References</h3>

<p>Erreygers G (2009).
&ldquo;Correcting the Concentration Index.&rdquo;
<em>Journal of Health Economics</em>, <b>28</b>(2), 504&ndash;515.
ISSN 0167-6296, <a href="https://doi.org/10.1016/j.jhealeco.2008.02.003">doi:10.1016/j.jhealeco.2008.02.003</a>.
</p>


<h3>See Also</h3>

<p>Other inequality: 
<code><a href="#topic+gini_index">gini_index</a>()</code>,
<code><a href="#topic+palma_ratio">palma_ratio</a>()</code>,
<code><a href="#topic+theil_t">theil_t</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_dir &lt;- system.file("extdata", package = "accessibility")
travel_matrix &lt;- readRDS(file.path(data_dir, "travel_matrix.rds"))
land_use_data &lt;- readRDS(file.path(data_dir, "land_use_data.rds"))

access &lt;- cumulative_cutoff(
  travel_matrix,
  land_use_data,
  cutoff = 30,
  opportunity = "jobs",
  travel_cost = "travel_time"
)

ci &lt;- concentration_index(
  access,
  sociodemographic_data = land_use_data,
  opportunity = "jobs",
  population = "population",
  income = "income_per_capita",
  type = "corrected"
)
ci

</code></pre>

<hr>
<h2 id='cost_to_closest'>Minimum travel cost to closest N number of opportunities</h2><span id='topic+cost_to_closest'></span>

<h3>Description</h3>

<p>Calculates the minimum travel cost to the closest N number of opportunities.
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_to_closest(
  travel_matrix,
  land_use_data,
  opportunity,
  travel_cost,
  n = 1,
  group_by = character(0),
  active = TRUE,
  fill_missing_ids = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cost_to_closest_+3A_travel_matrix">travel_matrix</code></td>
<td>
<p>A data frame. The travel matrix describing the costs
(i.e. travel time, distance, monetary cost, etc.) between the origins and
destinations in the study area. Must contain the columns <code>from_id</code>, <code>to_id</code>
and any others specified in <code>travel_cost</code>.</p>
</td></tr>
<tr><td><code id="cost_to_closest_+3A_land_use_data">land_use_data</code></td>
<td>
<p>A data frame. The distribution of opportunities within
the study area cells. Must contain the columns <code>id</code> and any others
specified in <code>opportunity</code>.</p>
</td></tr>
<tr><td><code id="cost_to_closest_+3A_opportunity">opportunity</code></td>
<td>
<p>A string. The name of the column in <code>land_use_data</code>
with the number of opportunities/resources/services to be considered when
calculating accessibility levels.</p>
</td></tr>
<tr><td><code id="cost_to_closest_+3A_travel_cost">travel_cost</code></td>
<td>
<p>A string. The name of the column in <code>travel_matrix</code>
with the travel cost between origins and destinations.</p>
</td></tr>
<tr><td><code id="cost_to_closest_+3A_n">n</code></td>
<td>
<p>A <code>numeric</code> vector. The minimum number of opportunities that should
be considered. Defaults to 1. If more than one value is provided, the
output includes an extra column specifying the number of opportunities that
the minimum travel cost refers to.</p>
</td></tr>
<tr><td><code id="cost_to_closest_+3A_group_by">group_by</code></td>
<td>
<p>A <code>character</code> vector. When not <code>character(0)</code> (the default),
indicates the <code>travel_matrix</code> columns that should be used to group the
accessibility estimates by. For example, if <code>travel_matrix</code> includes a
departure time column, that specifies the departure time of each entry in
the data frame, passing <code>"departure_time"</code> to this parameter results in
accessibility estimates grouped by origin and by departure time.</p>
</td></tr>
<tr><td><code id="cost_to_closest_+3A_active">active</code></td>
<td>
<p>A logical. Whether to calculate active accessibility (the
of opportunities that can be reached from a given origin, the default) or
passive accessibility (by how many people each destination can be reached).</p>
</td></tr>
<tr><td><code id="cost_to_closest_+3A_fill_missing_ids">fill_missing_ids</code></td>
<td>
<p>A <code>logical</code>. Calculating minimum travel cost to
closest N number of opportunities may result in missing ids in the output
if they cannot reach the specified amount of opportunities across all
destinations they can reach. For example, estimating the minimum travel
time that an origin that can only reach 4 opportunities takes to reach 5
opportunities resulting in such origin not being included in the output.
When <code>TRUE</code> (the default), the function identifies which ids would be left
out from the output and fill their respective minimum travel costs with
<code>Inf</code>, which incurs in a performance penalty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the accessibility estimates for each
origin/destination (depending if <code>active</code> is <code>TRUE</code> or <code>FALSE</code>) in the
travel matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_dir &lt;- system.file("extdata", package = "accessibility")
travel_matrix &lt;- readRDS(file.path(data_dir, "travel_matrix.rds"))
land_use_data &lt;- readRDS(file.path(data_dir, "land_use_data.rds"))

df &lt;- cost_to_closest(
  travel_matrix,
  land_use_data,
  n = 1,
  opportunity = "schools",
  travel_cost = "travel_time"
)
head(df)

df &lt;- cost_to_closest(
  travel_matrix,
  land_use_data,
  n = c(1, 2),
  opportunity = "schools",
  travel_cost = "travel_time"
)
head(df)

</code></pre>

<hr>
<h2 id='cumulative_cutoff'>Cumulative access based on a travel cost cutoff</h2><span id='topic+cumulative_cutoff'></span>

<h3>Description</h3>

<p>Calculates the number of opportunities accessible under a given specified
travel cost cutoff.
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulative_cutoff(
  travel_matrix,
  land_use_data,
  opportunity,
  travel_cost,
  cutoff,
  group_by = character(0),
  active = TRUE,
  fill_missing_ids = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulative_cutoff_+3A_travel_matrix">travel_matrix</code></td>
<td>
<p>A data frame. The travel matrix describing the costs
(i.e. travel time, distance, monetary cost, etc.) between the origins and
destinations in the study area. Must contain the columns <code>from_id</code>, <code>to_id</code>
and any others specified in <code>travel_cost</code>.</p>
</td></tr>
<tr><td><code id="cumulative_cutoff_+3A_land_use_data">land_use_data</code></td>
<td>
<p>A data frame. The distribution of opportunities within
the study area cells. Must contain the columns <code>id</code> and any others
specified in <code>opportunity</code>.</p>
</td></tr>
<tr><td><code id="cumulative_cutoff_+3A_opportunity">opportunity</code></td>
<td>
<p>A string. The name of the column in <code>land_use_data</code>
with the number of opportunities/resources/services to be considered when
calculating accessibility levels.</p>
</td></tr>
<tr><td><code id="cumulative_cutoff_+3A_travel_cost">travel_cost</code></td>
<td>
<p>A <code>character</code> vector. The name of the columns in
<code>travel_matrix</code> with the travel costs between origins and destinations to
be considered in the calculation.</p>
</td></tr>
<tr><td><code id="cumulative_cutoff_+3A_cutoff">cutoff</code></td>
<td>
<p>Either a <code>numeric</code> vector or a list of <code>numeric</code> vectors, one
for each cost specified in <code>travel_cost</code>. The travel cost cutoffs to
consider when calculating accessibility levels. If a list, the function
finds every single possible cutoff combination and use them to calculate
accessibility (e.g. if one specifies that travel time cutoffs should be 30
and 60 minutes and that monetary cost cutoffs should be 5 and 10 dollars,
the output includes accessibility estimates limited at 30 min &amp; 5 dollars,
30 min &amp; 10 dollars, 60 min &amp; 5 dollars and 60 min &amp; 10 dollars). In these
cases, cost constraints are considered simultaneously - i.e. only trips
that take 30 minutes or less AND 5 dollars or less to be completed, for
example, are included in the accessibility output. The cutoff parameter is
not included in the final output if the input includes only a single cutoff
for a single travel cost.</p>
</td></tr>
<tr><td><code id="cumulative_cutoff_+3A_group_by">group_by</code></td>
<td>
<p>A <code>character</code> vector. When not <code>character(0)</code> (the default),
indicates the <code>travel_matrix</code> columns that should be used to group the
accessibility estimates by. For example, if <code>travel_matrix</code> includes a
departure time column, that specifies the departure time of each entry in
the data frame, passing <code>"departure_time"</code> to this parameter results in
accessibility estimates grouped by origin and by departure time.</p>
</td></tr>
<tr><td><code id="cumulative_cutoff_+3A_active">active</code></td>
<td>
<p>A logical. Whether to calculate active accessibility (the
of opportunities that can be reached from a given origin, the default) or
passive accessibility (by how many people each destination can be reached).</p>
</td></tr>
<tr><td><code id="cumulative_cutoff_+3A_fill_missing_ids">fill_missing_ids</code></td>
<td>
<p>A <code>logical</code>. Calculating cumulative accessibility may
result in missing ids if the they cannot reach any of the destinations
within the specified travel cost cutoff. For example, using a travel time
cutoff of 20 minutes, when estimating the accessibility of origin <code>A</code> that
can only reach destinations with more than 40 minutes results in id <code>A</code>
not being included in the output. When <code>TRUE</code> (the default), the function
identifies which origins would be left out and fills their respective
accessibility values with 0, which incurs in a performance penalty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the accessibility estimates for each
origin/destination (depending if <code>active</code> is <code>TRUE</code> or <code>FALSE</code>) in the
travel matrix.
</p>


<h3>See Also</h3>

<p>Other cumulative access: 
<code><a href="#topic+cumulative_interval">cumulative_interval</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_dir &lt;- system.file("extdata", package = "accessibility")
travel_matrix &lt;- readRDS(file.path(data_dir, "travel_matrix.rds"))
land_use_data &lt;- readRDS(file.path(data_dir, "land_use_data.rds"))

# active accessibility: number of schools accessible from each origin
df &lt;- cumulative_cutoff(
  travel_matrix = travel_matrix,
  land_use_data = land_use_data,
  cutoff = 30,
  opportunity = "schools",
  travel_cost = "travel_time"
)
head(df)

df &lt;- cumulative_cutoff(
  travel_matrix = travel_matrix,
  land_use_data = land_use_data,
  cutoff = c(30, 60),
  opportunity = "schools",
  travel_cost = "travel_time"
)
head(df)

# passive accessibility: number of people that can reach each destination
df &lt;- cumulative_cutoff(
  travel_matrix = travel_matrix,
  land_use_data = land_use_data,
  cutoff = 30,
  opportunity = "population",
  travel_cost = "travel_time",
  active = FALSE
)
head(df)

# using multiple travel costs
pareto_frontier &lt;- readRDS(file.path(data_dir, "pareto_frontier.rds"))

df &lt;- cumulative_cutoff(
  pareto_frontier,
  land_use_data = land_use_data,
  opportunity = "jobs",
  travel_cost = c("travel_time", "monetary_cost"),
  cutoff = list(c(20, 30), c(0, 5, 10))
)
head(df)

</code></pre>

<hr>
<h2 id='cumulative_interval'>Cumulative access based on maximum travel time interval</h2><span id='topic+cumulative_interval'></span>

<h3>Description</h3>

<p>Calculates the average or median number of opportunities that can be reached
considering multiple maximum travel cost thresholds within a given travel
cost interval specified by the user. The time interval cumulative
accessibility measures was originally proposed by
Tomasiello et al. (2023).
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulative_interval(
  travel_matrix,
  land_use_data,
  opportunity,
  travel_cost,
  interval,
  interval_increment = 1,
  summary_function = stats::median,
  group_by = character(0),
  active = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulative_interval_+3A_travel_matrix">travel_matrix</code></td>
<td>
<p>A data frame. The travel matrix describing the costs
(i.e. travel time, distance, monetary cost, etc.) between the origins and
destinations in the study area. Must contain the columns <code>from_id</code>, <code>to_id</code>
and any others specified in <code>travel_cost</code>.</p>
</td></tr>
<tr><td><code id="cumulative_interval_+3A_land_use_data">land_use_data</code></td>
<td>
<p>A data frame. The distribution of opportunities within
the study area cells. Must contain the columns <code>id</code> and any others
specified in <code>opportunity</code>.</p>
</td></tr>
<tr><td><code id="cumulative_interval_+3A_opportunity">opportunity</code></td>
<td>
<p>A string. The name of the column in <code>land_use_data</code>
with the number of opportunities/resources/services to be considered when
calculating accessibility levels.</p>
</td></tr>
<tr><td><code id="cumulative_interval_+3A_travel_cost">travel_cost</code></td>
<td>
<p>A string. The name of the column in <code>travel_matrix</code>
with the travel cost between origins and destinations.</p>
</td></tr>
<tr><td><code id="cumulative_interval_+3A_interval">interval</code></td>
<td>
<p>A <code>numeric</code> vector of length 2. Indicates the start and end
points of the interval of travel cost thresholds to be used. The first
entry must be lower than the second.</p>
</td></tr>
<tr><td><code id="cumulative_interval_+3A_interval_increment">interval_increment</code></td>
<td>
<p>A <code>numeric</code>. How many travel cost units separate
the cutoffs used to calculate the accessibility estimates which will be
used to calculate the summary estimate within the specified interval.
Should be thought as the resolution of the distribution of travel costs
within the interval. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cumulative_interval_+3A_summary_function">summary_function</code></td>
<td>
<p>A function. This function is used to summarize a
distribution of accessibility estimates within a travel cost interval as a
single value. Can be any function that takes an arbitrary number of
numeric values as as input and returns a single number as output. Defaults
to <code><a href="stats.html#topic+median">stats::median()</a></code>.</p>
</td></tr>
<tr><td><code id="cumulative_interval_+3A_group_by">group_by</code></td>
<td>
<p>A <code>character</code> vector. When not <code>character(0)</code> (the default),
indicates the <code>travel_matrix</code> columns that should be used to group the
accessibility estimates by. For example, if <code>travel_matrix</code> includes a
departure time column, that specifies the departure time of each entry in
the data frame, passing <code>"departure_time"</code> to this parameter results in
accessibility estimates grouped by origin and by departure time.</p>
</td></tr>
<tr><td><code id="cumulative_interval_+3A_active">active</code></td>
<td>
<p>A logical. Whether to calculate active accessibility (the
of opportunities that can be reached from a given origin, the default) or
passive accessibility (by how many people each destination can be reached).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the accessibility estimates for each
origin/destination (depending if <code>active</code> is <code>TRUE</code> or <code>FALSE</code>) in the
travel matrix.
</p>


<h3>References</h3>

<p>Tomasiello DB, Herszenhut D, Oliveira JLA, Braga CKV, Pereira RHM (2023).
&ldquo;A Time Interval Metric for Cumulative Opportunity Accessibility.&rdquo;
<em>Applied Geography</em>, <b>157</b>, 103007.
ISSN 0143-6228, <a href="https://doi.org/10.1016/j.apgeog.2023.103007">doi:10.1016/j.apgeog.2023.103007</a>.
</p>


<h3>See Also</h3>

<p>Other cumulative access: 
<code><a href="#topic+cumulative_cutoff">cumulative_cutoff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_dir &lt;- system.file("extdata", package = "accessibility")
travel_matrix &lt;- readRDS(file.path(data_dir, "travel_matrix.rds"))
land_use_data &lt;- readRDS(file.path(data_dir, "land_use_data.rds"))

df &lt;- cumulative_interval(
  travel_matrix = travel_matrix,
  land_use_data = land_use_data,
  interval = c(20, 30),
  opportunity = "schools",
  travel_cost = "travel_time"
)
head(df)

df &lt;- cumulative_interval(
  travel_matrix = travel_matrix,
  land_use_data = land_use_data,
  interval = c(40, 80),
  opportunity = "jobs",
  travel_cost = "travel_time"
)
head(df)

</code></pre>

<hr>
<h2 id='decay_binary'>Binary (a.k.a. step) decay function</h2><span id='topic+decay_binary'></span>

<h3>Description</h3>

<p>Returns a binary weighting function (frequently used to calculate cumulative
opportunities measures) to be used inside accessibility calculating
functions.
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decay_binary(cutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decay_binary_+3A_cutoff">cutoff</code></td>
<td>
<p>A <code>numeric</code> vector. The numbers indicating the travel cost
cutoffs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>function</code> that takes a generic travel cost vector (<code>numeric</code>) as
an input and returns a <code>list</code> of weight vectors (a list of <code>numeric</code>
vectors, named after the arguments passed to the decay function).
</p>


<h3>See Also</h3>

<p>Other decay functions: 
<code><a href="#topic+decay_exponential">decay_exponential</a>()</code>,
<code><a href="#topic+decay_linear">decay_linear</a>()</code>,
<code><a href="#topic+decay_logistic">decay_logistic</a>()</code>,
<code><a href="#topic+decay_power">decay_power</a>()</code>,
<code><a href="#topic+decay_stepped">decay_stepped</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weighting_function &lt;- decay_binary(cutoff = 30)

weighting_function(c(20, 35))

weighting_function &lt;- decay_binary(cutoff = c(30, 45))

weighting_function(c(20, 35))

</code></pre>

<hr>
<h2 id='decay_exponential'>Negative exponential decay function</h2><span id='topic+decay_exponential'></span>

<h3>Description</h3>

<p>Returns a negative exponential weighting function to be used inside
accessibility calculating functions.
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decay_exponential(decay_value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decay_exponential_+3A_decay_value">decay_value</code></td>
<td>
<p>A <code>numeric</code> vector. The calibration parameters that, when
multiplied by the travel cost, are used as the exponent of <code>e</code> in the
negative exponential function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>function</code> that takes a generic travel cost vector (<code>numeric</code>) as
an input and returns a <code>list</code> of weight vectors (a list of <code>numeric</code>
vectors, named after the arguments passed to the decay function).
</p>


<h3>See Also</h3>

<p>Other decay functions: 
<code><a href="#topic+decay_binary">decay_binary</a>()</code>,
<code><a href="#topic+decay_linear">decay_linear</a>()</code>,
<code><a href="#topic+decay_logistic">decay_logistic</a>()</code>,
<code><a href="#topic+decay_power">decay_power</a>()</code>,
<code><a href="#topic+decay_stepped">decay_stepped</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weighting_function &lt;- decay_exponential(decay_value = 0.1)

weighting_function(c(20, 30))

weighting_function &lt;- decay_exponential(decay_value = c(0.1, 0.2))

weighting_function(c(20, 30))

</code></pre>

<hr>
<h2 id='decay_linear'>Linear decay function</h2><span id='topic+decay_linear'></span>

<h3>Description</h3>

<p>Returns a linear weighting function to be used inside accessibility
calculating functions.
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decay_linear(cutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decay_linear_+3A_cutoff">cutoff</code></td>
<td>
<p>A <code>numeric</code> vector. Indicates the travel cost cutoffs until
which the weighting factor decays linearly. From this point onward the
weight is equal to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>function</code> that takes a generic travel cost vector (<code>numeric</code>) as
an input and returns a <code>list</code> of weight vectors (a list of <code>numeric</code>
vectors, named after the arguments passed to the decay function).
</p>


<h3>See Also</h3>

<p>Other decay functions: 
<code><a href="#topic+decay_binary">decay_binary</a>()</code>,
<code><a href="#topic+decay_exponential">decay_exponential</a>()</code>,
<code><a href="#topic+decay_logistic">decay_logistic</a>()</code>,
<code><a href="#topic+decay_power">decay_power</a>()</code>,
<code><a href="#topic+decay_stepped">decay_stepped</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weighting_function &lt;- decay_linear(cutoff = 30)

weighting_function(c(20, 35))

weighting_function &lt;- decay_linear(cutoff = c(30, 45))

weighting_function(c(20, 35))

</code></pre>

<hr>
<h2 id='decay_logistic'>Logistic decay function</h2><span id='topic+decay_logistic'></span>

<h3>Description</h3>

<p>Returns a logistic weighting function (in which the weights
follow the distribution of a reversed cumulative logistic curve) to be
used inside accessibility calculating functions. The logistic curve is
parameterized with the cutoff that sets its inflection point and the standard
deviation that sets its steepness.
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decay_logistic(cutoff, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decay_logistic_+3A_cutoff">cutoff</code></td>
<td>
<p>A <code>numeric</code> vector. The cost value that serves as the
inflection point of the cumulative logistic curve.</p>
</td></tr>
<tr><td><code id="decay_logistic_+3A_sd">sd</code></td>
<td>
<p>A <code>numeric</code> vector with same length as <code>cutoff</code>. The standard
deviation of the logistic curve. Values near 0 result in weighting curves
that approximate binary decay, while higher values tend to linearize the
decay.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using a function created with <code>decay_logistic()</code>, the output is
named after the combination of cutoffs (<code>"c"</code>) and standard deviations
(<code>"sd"</code>) - e.g. given the cutoffs <code>c(30, 40)</code> and the standard deviations
<code>c(10, 20)</code>, the first element of the output will be named <code>"c30;sd10"</code> and
the second will be named <code>"c40;sd20"</code>. This function uses the adjusted
logistic decay curve proposed by
Bauer and Groneberg (2016), in which the
condition f(0) = 1 is met (i.e. the weight of an opportunity whose cost to
reach is 0 is 1).
</p>


<h3>Value</h3>

<p>A <code>function</code> that takes a generic travel cost vector (<code>numeric</code>) as
input and returns a vector of weights (<code>numeric</code>).
</p>


<h3>References</h3>

<p>Bauer J, Groneberg DA (2016).
&ldquo;Measuring Spatial Accessibility of Health Care Providers &ndash; Introduction of a Variable Distance Decay Function within the Floating Catchment Area (FCA) Method.&rdquo;
<em>PLOS ONE</em>, <b>11</b>(7), e0159148.
ISSN 1932-6203, <a href="https://doi.org/10.1371/journal.pone.0159148">doi:10.1371/journal.pone.0159148</a>.
</p>


<h3>See Also</h3>

<p>Other decay functions: 
<code><a href="#topic+decay_binary">decay_binary</a>()</code>,
<code><a href="#topic+decay_exponential">decay_exponential</a>()</code>,
<code><a href="#topic+decay_linear">decay_linear</a>()</code>,
<code><a href="#topic+decay_power">decay_power</a>()</code>,
<code><a href="#topic+decay_stepped">decay_stepped</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weighting_function &lt;- decay_logistic(cutoff = 30, sd = 5)

weighting_function(c(0, 30, 45, 60))

weighting_function &lt;- decay_logistic(cutoff = c(30, 45), sd = c(5, 10))

weighting_function(c(0, 30, 45, 60))

</code></pre>

<hr>
<h2 id='decay_power'>Inverse power decay function</h2><span id='topic+decay_power'></span>

<h3>Description</h3>

<p>Returns an inverse power weighting function to be used inside accessibility
calculating functions.
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decay_power(decay_value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decay_power_+3A_decay_value">decay_value</code></td>
<td>
<p>A <code>numeric</code> vector. The calibration parameters to be used
as the exponents in the inverse power function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>function</code> that takes a generic travel cost vector (<code>numeric</code>) as
an input and returns a <code>list</code> of weight vectors (a list of <code>numeric</code>
vectors, named after the arguments passed to the decay function).
</p>


<h3>See Also</h3>

<p>Other decay functions: 
<code><a href="#topic+decay_binary">decay_binary</a>()</code>,
<code><a href="#topic+decay_exponential">decay_exponential</a>()</code>,
<code><a href="#topic+decay_linear">decay_linear</a>()</code>,
<code><a href="#topic+decay_logistic">decay_logistic</a>()</code>,
<code><a href="#topic+decay_stepped">decay_stepped</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weighting_function &lt;- decay_power(decay_value = 0.1)

weighting_function(c(20, 35))

weighting_function &lt;- decay_power(decay_value = c(0.1, 0.2))

weighting_function(c(20, 35))

</code></pre>

<hr>
<h2 id='decay_stepped'>Stepped decay function</h2><span id='topic+decay_stepped'></span>

<h3>Description</h3>

<p>Returns a stepped weighting function to be used inside accessibility
calculating functions.
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decay_stepped(steps, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decay_stepped_+3A_steps">steps</code></td>
<td>
<p>A <code>numeric</code> vector or a list of <code>numeric</code> vectors. The travel
cost steps, in ascending order. Please do not include travel cost 0 as a
step: this is already handled by the function.</p>
</td></tr>
<tr><td><code id="decay_stepped_+3A_weights">weights</code></td>
<td>
<p>A <code>numeric</code> vector with same length as <code>steps</code> or a list of
<code>numeric</code> vectors whose lengths are equal to the lengths of the elements of
same index in <code>steps</code>. The values, between 0 and 1, that the function
assumes at each step. Please do not include weight 1 as the first value:
this is already handled by the function. The function considers the steps'
intervals &quot;open on the right&quot;, meaning that the function assumes the step
value at the actual step, not right after it. Please see the illustrative
examples for effects of this assumption on the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When both <code>steps</code> and <code>weights</code> parameters are given <code>list</code>s, their
content are matched element-wise to define each stepped weighting function
</p>

<ul>
<li><p> i.e. the first element of <code>steps</code> is matched to the first element of
<code>weights</code>, the second element of <code>steps</code> is matched to the second of
<code>weights</code>, etc. When using a function created with <code>decay_stepped()</code>, the
output is named after the combination of steps (<code>"s"</code>) and weights (<code>"w"</code>)
</p>
</li>
<li><p> e.g. given the steps <code>c(10, 20, 30)</code> and the weights <code>c(0.66, 0.33, 0)</code>,
the output will be named <code>"s(10,20,30);w(0.66,0.33,0)"</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>function</code> that takes a generic travel cost vector (<code>numeric</code>) as
an input and returns a vector of weights (<code>numeric</code>).
</p>


<h3>See Also</h3>

<p>Other decay functions: 
<code><a href="#topic+decay_binary">decay_binary</a>()</code>,
<code><a href="#topic+decay_exponential">decay_exponential</a>()</code>,
<code><a href="#topic+decay_linear">decay_linear</a>()</code>,
<code><a href="#topic+decay_logistic">decay_logistic</a>()</code>,
<code><a href="#topic+decay_power">decay_power</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weighting_function &lt;- decay_stepped(
  c(10, 20, 30, 40),
  weights = c(0.75, 0.5, 0.25, 0)
)

weighting_function(c(5, 25, 35, 45))

weighting_function &lt;- decay_stepped(
  list(c(10, 20, 30, 40), c(10, 20, 30, 40)),
  weights = list(c(0.75, 0.5, 0.25, 0), c(0.8, 0.6, 0.4, 0.2))
)

weighting_function(c(5, 25, 35, 45))

# intervals are open on the right, so the values change exactly at each step
weighting_function(c(0, 10, 20, 30, 40))

</code></pre>

<hr>
<h2 id='fgt_poverty'>Foster-Greer-Thorbecke (FGT) poverty measures</h2><span id='topic+fgt_poverty'></span>

<h3>Description</h3>

<p>Calculates the FGT metrics, a family of poverty measures originally proposed
by Foster et al. (1984) that capture the
extent and severity of poverty within an accessibility distribution. The FGT
family is composed of three measures that differ based on the <code class="reqn">\alpha</code>
parameter used to calculate them (either 0, 1 or 2) and which also changes
their interpretation. Please see the details section for more information on
the interpretation of the measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgt_poverty(
  accessibility_data,
  sociodemographic_data,
  opportunity,
  population,
  poverty_line,
  group_by = character(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgt_poverty_+3A_accessibility_data">accessibility_data</code></td>
<td>
<p>A data frame. The accessibility levels whose
poverty levels should be calculated. Must contain the columns <code>id</code> and any
others specified in <code>opportunity</code>.</p>
</td></tr>
<tr><td><code id="fgt_poverty_+3A_sociodemographic_data">sociodemographic_data</code></td>
<td>
<p>A data frame. The distribution of
sociodemographic characteristics of the population in the study area cells.
Must contain the columns <code>id</code> and any others specified in <code>population</code>.</p>
</td></tr>
<tr><td><code id="fgt_poverty_+3A_opportunity">opportunity</code></td>
<td>
<p>A string. The name of the column in <code>accessibility_data</code>
with the accessibility levels to be considerend when calculating
accessibility poverty.</p>
</td></tr>
<tr><td><code id="fgt_poverty_+3A_population">population</code></td>
<td>
<p>A string. The name of the column in <code>sociodemographic_data</code>
with the number of people in each cell. Used to weigh accessibility levels
when calculating poverty.</p>
</td></tr>
<tr><td><code id="fgt_poverty_+3A_poverty_line">poverty_line</code></td>
<td>
<p>A <code>numeric</code>. The poverty line below which individuals are
considered to be in accessibility poverty.</p>
</td></tr>
<tr><td><code id="fgt_poverty_+3A_group_by">group_by</code></td>
<td>
<p>A <code>character</code> vector. When not <code>character(0)</code> (the default),
indicates the <code>accessibility_data</code> columns that should be used to group the
poverty estimates by. For example, if <code>accessibility_data</code> includes a
<code>race</code> column that specifies the racial category of the population (e.g.
<code>"black"</code> and <code>"white"</code>) that each entry refers to, passing <code>"race"</code> to
this parameter results in poverty estimates grouped by race.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the three poverty estimates (FGT0, FGT1 and
FGT2) for the study area.
</p>


<h3>Interpretation of FGT measures</h3>

<p>The interpretation of each FGT measure depends on the <code class="reqn">\alpha</code> parameter
used to calculate it:
</p>

<ul>
<li><p> with <code class="reqn">\alpha = 0</code> (FGT0) the measure captures the <em>extent</em> of poverty
as a simple headcount - i.e. the proportion of people below the poverty line;
</p>
</li>
<li><p> with <code class="reqn">\alpha = 1</code> (FGT1) the measure, also know as the &quot;poverty gap
index&quot;, captures the <em>severity</em> of poverty as the average percentage distance
between the poverty line and the accessibility of individuals below the
poverty line;
</p>
</li>
<li><p> with <code class="reqn">\alpha = 2</code> (FGT2) the measure simultaneously captures the
<em>extent</em> and the <em>severity</em> of poverty by calculating the number of people
below the poverty line weighted by the size of the accessibility shortfall
relative to the poverty line.
</p>
</li></ul>

<p>FGT values range from 0 to 1. A value of 0 indicates that every individual is
above the poverty line. When every individual is below the poverty line,
however, FGT0 value is 1 and FGT1 and FGT2 values approach 1.
</p>


<h3>References</h3>

<p>Foster J, Greer J, Thorbecke E (1984).
&ldquo;A Class of Decomposable Poverty Measures.&rdquo;
<em>Econometrica</em>, <b>52</b>(3), 761&ndash;766.
ISSN 0012-9682, <a href="https://doi.org/10.2307/1913475">doi:10.2307/1913475</a>, 1913475.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_dir &lt;- system.file("extdata", package = "accessibility")
travel_matrix &lt;- readRDS(file.path(data_dir, "travel_matrix.rds"))
land_use_data &lt;- readRDS(file.path(data_dir, "land_use_data.rds"))

access &lt;- cumulative_cutoff(
  travel_matrix,
  land_use_data,
  cutoff = 30,
  opportunity = "jobs",
  travel_cost = "travel_time"
)

poverty &lt;- fgt_poverty(
  access,
  opportunity = "jobs",
  sociodemographic_data = land_use_data,
  population = "population",
  poverty_line = 95368
)
poverty

</code></pre>

<hr>
<h2 id='floating_catchment_area'>Floating catchment area accessibility</h2><span id='topic+floating_catchment_area'></span>

<h3>Description</h3>

<p>Calculates accessibility accounting for the competition of resources using a
measure from the floating catchment area (FCA) family. Please see the
details for the available FCA measures.
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>floating_catchment_area(
  travel_matrix,
  land_use_data,
  opportunity,
  travel_cost,
  demand,
  method,
  decay_function,
  group_by = character(0),
  fill_missing_ids = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="floating_catchment_area_+3A_travel_matrix">travel_matrix</code></td>
<td>
<p>A data frame. The travel matrix describing the costs
(i.e. travel time, distance, monetary cost, etc.) between the origins and
destinations in the study area. Must contain the columns <code>from_id</code>, <code>to_id</code>
and any others specified in <code>travel_cost</code>.</p>
</td></tr>
<tr><td><code id="floating_catchment_area_+3A_land_use_data">land_use_data</code></td>
<td>
<p>A data frame. The distribution of opportunities within
the study area cells. Must contain the columns <code>id</code> and any others
specified in <code>opportunity</code>.</p>
</td></tr>
<tr><td><code id="floating_catchment_area_+3A_opportunity">opportunity</code></td>
<td>
<p>A string. The name of the column in <code>land_use_data</code>
with the number of opportunities/resources/services to be considered when
calculating accessibility levels.</p>
</td></tr>
<tr><td><code id="floating_catchment_area_+3A_travel_cost">travel_cost</code></td>
<td>
<p>A string. The name of the column in <code>travel_matrix</code>
with the travel cost between origins and destinations.</p>
</td></tr>
<tr><td><code id="floating_catchment_area_+3A_demand">demand</code></td>
<td>
<p>A string. The name of the column in <code>land_use_data</code> with the
number of people in each origin that will be considered potential
competitors.</p>
</td></tr>
<tr><td><code id="floating_catchment_area_+3A_method">method</code></td>
<td>
<p>A string. Which floating catchment area measure to use.
Current available options are <code>"2sfca"</code> and <code>"bfca"</code>. More info in the
details.</p>
</td></tr>
<tr><td><code id="floating_catchment_area_+3A_decay_function">decay_function</code></td>
<td>
<p>A <code>fuction</code> that converts travel cost into an
impedance factor used to weight opportunities. This function should take a
<code>numeric</code> vector and also return a <code>numeric</code> vector as output, with the
same length as the input. For convenience, the package currently includes
the following functions: <code><a href="#topic+decay_binary">decay_binary()</a></code>, <code><a href="#topic+decay_exponential">decay_exponential()</a></code>,
<code><a href="#topic+decay_power">decay_power()</a></code> and <code><a href="#topic+decay_stepped">decay_stepped()</a></code>. See the documentation of each decay
function for more details.</p>
</td></tr>
<tr><td><code id="floating_catchment_area_+3A_group_by">group_by</code></td>
<td>
<p>A <code>character</code> vector. When not <code>character(0)</code> (the default),
indicates the <code>travel_matrix</code> columns that should be used to group the
accessibility estimates by. For example, if <code>travel_matrix</code> includes a
departure time column, that specifies the departure time of each entry in
the data frame, passing <code>"departure_time"</code> to this parameter results in
accessibility estimates grouped by origin and by departure time.</p>
</td></tr>
<tr><td><code id="floating_catchment_area_+3A_fill_missing_ids">fill_missing_ids</code></td>
<td>
<p>A <code>logical</code>. When calculating grouped accessibility
estimates (i.e. when <code>by_col</code> is not <code>NULL</code>), some combinations of groups
and origins may be missing. For example, if a single trip can depart from
origin <code>A</code> at 7:15am and reach destination <code>B</code> within 55 minutes, but no
trips departing from <code>A</code> at 7:30am can be completed at all, this second
combination will not be included in the output. When <code>TRUE</code> (the default),
the function identifies which combinations would be left out and fills
their respective accessibility values with 0, which incurs in a
performance penalty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the accessibility estimates for each
origin/destination (depending if <code>active</code> is <code>TRUE</code> or <code>FALSE</code>) in the
travel matrix.
</p>


<h3>Details</h3>

<p>The package currently includes two built-in FCA measures:
</p>

<ul>
<li><p> 2SFCA - the 2-Step Floating Catchment Area measure was the first
accessibility metric in the FCA family. It was originally proposed by
Luo and Wang (2003).
</p>
</li>
<li><p> BFCA - the Balanced Floating Catchment Area measure calculates
accessibility accounting for competition effects while simultaneously
correcting for issues of inflation of demand and service levels that are
present in other FCA measures. It was originally proposed by
Paez et al. (2019) and named in
Pereira et al. (2021).
</p>
</li></ul>



<h3>References</h3>

<p>Luo W, Wang F (2003).
&ldquo;Measures of Spatial Accessibility to Health Care in a GIS Environment: Synthesis and a Case Study in the Chicago Region.&rdquo;
<em>Environment and Planning B: Planning and Design</em>, <b>30</b>(6), 865&ndash;884.
ISSN 0265-8135, 1472-3417, <a href="https://doi.org/10.1068/b29120">doi:10.1068/b29120</a>.<br /><br /> Paez A, Higgins CD, Vivona SF (2019).
&ldquo;Demand and Level of Service Inflation in Floating Catchment Area (FCA) Methods.&rdquo;
<em>PLOS ONE</em>, <b>14</b>(6), e0218773.
ISSN 1932-6203, <a href="https://doi.org/10.1371/journal.pone.0218773">doi:10.1371/journal.pone.0218773</a>.<br /><br /> Pereira RHM, Braga CKV, Servo LM, Serra B, Amaral P, Gouveia N, Paez A (2021).
&ldquo;Geographic Access to COVID-19 Healthcare in Brazil Using a Balanced Float Catchment Area Approach.&rdquo;
<em>Social Science &amp; Medicine</em>, <b>273</b>, 113773.
ISSN 0277-9536, <a href="https://doi.org/10.1016/j.socscimed.2021.113773">doi:10.1016/j.socscimed.2021.113773</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_dir &lt;- system.file("extdata", package = "accessibility")
travel_matrix &lt;- readRDS(file.path(data_dir, "travel_matrix.rds"))
land_use_data &lt;- readRDS(file.path(data_dir, "land_use_data.rds"))

# 2SFCA with a step decay function
df &lt;- floating_catchment_area(
  travel_matrix,
  land_use_data,
  method = "2sfca",
  decay_function = decay_binary(cutoff = 50),
  opportunity = "jobs",
  travel_cost = "travel_time",
  demand = "population"
)
head(df)


# BFCA with an exponential decay function
df &lt;- floating_catchment_area(
  travel_matrix,
  land_use_data,
  method = "bfca",
  decay_function = decay_exponential(decay_value = 0.5),
  opportunity = "jobs",
  travel_cost = "travel_time",
  demand = "population"
)
head(df)

</code></pre>

<hr>
<h2 id='gini_index'>Gini Index</h2><span id='topic+gini_index'></span>

<h3>Description</h3>

<p>Calculates the Gini Index of a given accessibility distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini_index(
  accessibility_data,
  sociodemographic_data,
  opportunity,
  population,
  group_by = character(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gini_index_+3A_accessibility_data">accessibility_data</code></td>
<td>
<p>A data frame. The accessibility levels whose
inequality should be calculated. Must contain the columns <code>id</code> and any
others specified in <code>opportunity</code>.</p>
</td></tr>
<tr><td><code id="gini_index_+3A_sociodemographic_data">sociodemographic_data</code></td>
<td>
<p>A data frame. The distribution of
sociodemographic characteristics of the population in the study area cells.
Must contain the columns <code>id</code> and any others specified in <code>population</code>.</p>
</td></tr>
<tr><td><code id="gini_index_+3A_opportunity">opportunity</code></td>
<td>
<p>A string. The name of the column in <code>accessibility_data</code>
with the accessibility levels to be considerend when calculating inequality
levels.</p>
</td></tr>
<tr><td><code id="gini_index_+3A_population">population</code></td>
<td>
<p>A string. The name of the column in <code>sociodemographic_data</code>
with the number of people in each cell. Used to weigh accessibility levels
when calculating inequality.</p>
</td></tr>
<tr><td><code id="gini_index_+3A_group_by">group_by</code></td>
<td>
<p>A <code>character</code> vector. When not <code>character(0)</code> (the default),
indicates the <code>accessibility_data</code> columns that should be used to group the
inequality estimates by. For example, if <code>accessibility_data</code> includes a
<code>scenario</code> column that identifies distinct scenarios that each
accessibility estimates refer to (e.g. before and after a transport policy
intervention), passing <code>"scenario"</code> to this parameter results in inequality
estimates grouped by scenario.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the inequality estimates for the study area.
</p>


<h3>See Also</h3>

<p>Other inequality: 
<code><a href="#topic+concentration_index">concentration_index</a>()</code>,
<code><a href="#topic+palma_ratio">palma_ratio</a>()</code>,
<code><a href="#topic+theil_t">theil_t</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_dir &lt;- system.file("extdata", package = "accessibility")
travel_matrix &lt;- readRDS(file.path(data_dir, "travel_matrix.rds"))
land_use_data &lt;- readRDS(file.path(data_dir, "land_use_data.rds"))

access &lt;- cumulative_cutoff(
  travel_matrix,
  land_use_data,
  cutoff = 30,
  opportunity = "jobs",
  travel_cost = "travel_time"
)

gini &lt;- gini_index(
  access,
  sociodemographic_data = land_use_data,
  opportunity = "jobs",
  population = "population"
)
gini

</code></pre>

<hr>
<h2 id='gravity'>Gravity-based accessibility measures</h2><span id='topic+gravity'></span>

<h3>Description</h3>

<p>Calculates gravity-based accessibility using a decay function specified by
the user.
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gravity(
  travel_matrix,
  land_use_data,
  opportunity,
  travel_cost,
  decay_function,
  group_by = character(0),
  active = TRUE,
  fill_missing_ids = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gravity_+3A_travel_matrix">travel_matrix</code></td>
<td>
<p>A data frame. The travel matrix describing the costs
(i.e. travel time, distance, monetary cost, etc.) between the origins and
destinations in the study area. Must contain the columns <code>from_id</code>, <code>to_id</code>
and any others specified in <code>travel_cost</code>.</p>
</td></tr>
<tr><td><code id="gravity_+3A_land_use_data">land_use_data</code></td>
<td>
<p>A data frame. The distribution of opportunities within
the study area cells. Must contain the columns <code>id</code> and any others
specified in <code>opportunity</code>.</p>
</td></tr>
<tr><td><code id="gravity_+3A_opportunity">opportunity</code></td>
<td>
<p>A string. The name of the column in <code>land_use_data</code>
with the number of opportunities/resources/services to be considered when
calculating accessibility levels.</p>
</td></tr>
<tr><td><code id="gravity_+3A_travel_cost">travel_cost</code></td>
<td>
<p>A string. The name of the column in <code>travel_matrix</code>
with the travel cost between origins and destinations.</p>
</td></tr>
<tr><td><code id="gravity_+3A_decay_function">decay_function</code></td>
<td>
<p>A <code>fuction</code> that converts travel cost into an
impedance factor used to weight opportunities. This function should take a
<code>numeric</code> vector and also return a <code>numeric</code> vector as output, with the
same length as the input. For convenience, the package currently includes
the following functions: <code><a href="#topic+decay_binary">decay_binary()</a></code>, <code><a href="#topic+decay_exponential">decay_exponential()</a></code>,
<code><a href="#topic+decay_power">decay_power()</a></code> and <code><a href="#topic+decay_stepped">decay_stepped()</a></code>. See the documentation of each decay
function for more details.</p>
</td></tr>
<tr><td><code id="gravity_+3A_group_by">group_by</code></td>
<td>
<p>A <code>character</code> vector. When not <code>character(0)</code> (the default),
indicates the <code>travel_matrix</code> columns that should be used to group the
accessibility estimates by. For example, if <code>travel_matrix</code> includes a
departure time column, that specifies the departure time of each entry in
the data frame, passing <code>"departure_time"</code> to this parameter results in
accessibility estimates grouped by origin and by departure time.</p>
</td></tr>
<tr><td><code id="gravity_+3A_active">active</code></td>
<td>
<p>A logical. Whether to calculate active accessibility (the
of opportunities that can be reached from a given origin, the default) or
passive accessibility (by how many people each destination can be reached).</p>
</td></tr>
<tr><td><code id="gravity_+3A_fill_missing_ids">fill_missing_ids</code></td>
<td>
<p>A <code>logical</code>. When calculating grouped accessibility
estimates (i.e. when <code>by_col</code> is not <code>NULL</code>), some combinations of groups
and origins may be missing. For example, if a single trip can depart from
origin <code>A</code> at 7:15am and reach destination <code>B</code> within 55 minutes, but no
trips departing from <code>A</code> at 7:30am can be completed at all, this second
combination will not be included in the output. When <code>TRUE</code> (the default),
the function identifies which combinations would be left out and fills
their respective accessibility values with 0, which incurs in a
performance penalty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the accessibility estimates for each
origin/destination (depending if <code>active</code> is <code>TRUE</code> or <code>FALSE</code>) in the
travel matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_dir &lt;- system.file("extdata", package = "accessibility")
travel_matrix &lt;- readRDS(file.path(data_dir, "travel_matrix.rds"))
land_use_data &lt;- readRDS(file.path(data_dir, "land_use_data.rds"))

df_linear &lt;- gravity(
  travel_matrix,
  land_use_data,
  decay_function = decay_linear(cutoff = 50),
  opportunity = "schools",
  travel_cost = "travel_time"
)
head(df_linear)

df_exp &lt;- gravity(
  travel_matrix,
  land_use_data,
  decay_function = decay_exponential(decay_value = 0.5),
  opportunity = "schools",
  travel_cost = "travel_time"
)
head(df_exp)

</code></pre>

<hr>
<h2 id='palma_ratio'>Palma Ratio</h2><span id='topic+palma_ratio'></span>

<h3>Description</h3>

<p>Calculates the Palma Ratio of a given accessibility distribution. Originally
defined as the income share of the richest 10% of a population divided by the
income share of the poorest 40%, this measure has been adapted in transport
planning as the average accessibility of the richest 10% divided by the
average accessibility of the poorest 40%.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palma_ratio(
  accessibility_data,
  sociodemographic_data,
  opportunity,
  population,
  income,
  group_by = character(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palma_ratio_+3A_accessibility_data">accessibility_data</code></td>
<td>
<p>A data frame. The accessibility levels whose
inequality should be calculated. Must contain the columns <code>id</code> and any
others specified in <code>opportunity</code>.</p>
</td></tr>
<tr><td><code id="palma_ratio_+3A_sociodemographic_data">sociodemographic_data</code></td>
<td>
<p>A data frame. The distribution of
sociodemographic characteristics of the population in the study area cells.
Must contain the columns <code>id</code> and any others specified in <code>population</code> and
<code>income</code>.</p>
</td></tr>
<tr><td><code id="palma_ratio_+3A_opportunity">opportunity</code></td>
<td>
<p>A string. The name of the column in <code>accessibility_data</code>
with the accessibility levels to be considerend when calculating inequality
levels.</p>
</td></tr>
<tr><td><code id="palma_ratio_+3A_population">population</code></td>
<td>
<p>A string. The name of the column in <code>sociodemographic_data</code>
with the number of people in each cell. Used to weigh accessibility levels
when calculating inequality.</p>
</td></tr>
<tr><td><code id="palma_ratio_+3A_income">income</code></td>
<td>
<p>A string. The name of the column in <code>sociodemographic_data</code>
with the income variable that should be used to classify the population in
socioeconomic groups. Please note that this variable should describe income
per capita (e.g. mean income per capita, household income per capita, etc),
instead of the total amount of income in each cell.</p>
</td></tr>
<tr><td><code id="palma_ratio_+3A_group_by">group_by</code></td>
<td>
<p>A <code>character</code> vector. When not <code>character(0)</code> (the default),
indicates the <code>accessibility_data</code> columns that should be used to group the
inequality estimates by. For example, if <code>accessibility_data</code> includes a
<code>scenario</code> column that identifies distinct scenarios that each
accessibility estimates refer to (e.g. before and after a transport policy
intervention), passing <code>"scenario"</code> to this parameter results in inequality
estimates grouped by scenario.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the inequality estimates for the study area.
</p>


<h3>See Also</h3>

<p>Other inequality: 
<code><a href="#topic+concentration_index">concentration_index</a>()</code>,
<code><a href="#topic+gini_index">gini_index</a>()</code>,
<code><a href="#topic+theil_t">theil_t</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_dir &lt;- system.file("extdata", package = "accessibility")
travel_matrix &lt;- readRDS(file.path(data_dir, "travel_matrix.rds"))
land_use_data &lt;- readRDS(file.path(data_dir, "land_use_data.rds"))

access &lt;- cumulative_cutoff(
  travel_matrix,
  land_use_data,
  cutoff = 30,
  opportunity = "jobs",
  travel_cost = "travel_time"
)

palma &lt;- palma_ratio(
  access,
  sociodemographic_data = land_use_data,
  opportunity = "jobs",
  population = "population",
  income = "income_per_capita"
)
palma

</code></pre>

<hr>
<h2 id='spatial_availability'>Spatial availability</h2><span id='topic+spatial_availability'></span>

<h3>Description</h3>

<p>Calculates spatial availability, an accessibility measured proposed by
Soukhov et al. (2023) that takes into
account competition effects. The accessibility levels that result from using
this measure are proportional both to the demand in each origin and to the
travel cost it takes to reach the destinations.
</p>
<p>This function is generic over any kind of numeric travel cost,
such as distance, time and money.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_availability(
  travel_matrix,
  land_use_data,
  opportunity,
  travel_cost,
  demand,
  decay_function,
  alpha = 1,
  group_by = character(0),
  fill_missing_ids = TRUE,
  detailed_results = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_availability_+3A_travel_matrix">travel_matrix</code></td>
<td>
<p>A data frame. The travel matrix describing the costs
(i.e. travel time, distance, monetary cost, etc.) between the origins and
destinations in the study area. Must contain the columns <code>from_id</code>, <code>to_id</code>
and any others specified in <code>travel_cost</code>.</p>
</td></tr>
<tr><td><code id="spatial_availability_+3A_land_use_data">land_use_data</code></td>
<td>
<p>A data frame. The distribution of opportunities within
the study area cells. Must contain the columns <code>id</code> and any others
specified in <code>opportunity</code>.</p>
</td></tr>
<tr><td><code id="spatial_availability_+3A_opportunity">opportunity</code></td>
<td>
<p>A string. The name of the column in <code>land_use_data</code>
with the number of opportunities/resources/services to be considered when
calculating accessibility levels.</p>
</td></tr>
<tr><td><code id="spatial_availability_+3A_travel_cost">travel_cost</code></td>
<td>
<p>A string. The name of the column in <code>travel_matrix</code>
with the travel cost between origins and destinations.</p>
</td></tr>
<tr><td><code id="spatial_availability_+3A_demand">demand</code></td>
<td>
<p>A string. The name of the column in <code>land_use_data</code> with the
number of people in each origin that will be considered potential
competitors.</p>
</td></tr>
<tr><td><code id="spatial_availability_+3A_decay_function">decay_function</code></td>
<td>
<p>A <code>fuction</code> that converts travel cost into an
impedance factor used to weight opportunities. This function should take a
<code>numeric</code> vector and also return a <code>numeric</code> vector as output, with the
same length as the input. For convenience, the package currently includes
the following functions: <code><a href="#topic+decay_binary">decay_binary()</a></code>, <code><a href="#topic+decay_exponential">decay_exponential()</a></code>,
<code><a href="#topic+decay_power">decay_power()</a></code> and <code><a href="#topic+decay_stepped">decay_stepped()</a></code>. See the documentation of each decay
function for more details.</p>
</td></tr>
<tr><td><code id="spatial_availability_+3A_alpha">alpha</code></td>
<td>
<p>A <code>numeric</code>. A parameter used to modulate the effect of demand
by population. When less than 1, opportunities are allocated more rapidly
to smaller centers relative to larger ones; values higher than 1 achieve
the opposite effect.</p>
</td></tr>
<tr><td><code id="spatial_availability_+3A_group_by">group_by</code></td>
<td>
<p>A <code>character</code> vector. When not <code>character(0)</code> (the default),
indicates the <code>travel_matrix</code> columns that should be used to group the
accessibility estimates by. For example, if <code>travel_matrix</code> includes a
departure time column, that specifies the departure time of each entry in
the data frame, passing <code>"departure_time"</code> to this parameter results in
accessibility estimates grouped by origin and by departure time.</p>
</td></tr>
<tr><td><code id="spatial_availability_+3A_fill_missing_ids">fill_missing_ids</code></td>
<td>
<p>A <code>logical</code>. When calculating grouped accessibility
estimates (i.e. when <code>by_col</code> is not <code>NULL</code>), some combinations of groups
and origins may be missing. For example, if a single trip can depart from
origin <code>A</code> at 7:15am and reach destination <code>B</code> within 55 minutes, but no
trips departing from <code>A</code> at 7:30am can be completed at all, this second
combination will not be included in the output. When <code>TRUE</code> (the default),
the function identifies which combinations would be left out and fills
their respective accessibility values with 0, which incurs in a
performance penalty.</p>
</td></tr>
<tr><td><code id="spatial_availability_+3A_detailed_results">detailed_results</code></td>
<td>
<p>A <code>logical</code>. Whether to return spatial availability
results aggregated by origin-destination pair (<code>TRUE</code>) or by origin
(<code>FALSE</code>, the default). When <code>TRUE</code>, the output also includes the demand,
impedance and combined balancing factors used to calculate spatial
availability. Please note that the argument <code>fill_missing_ids</code>
does not affect the output when <code>detailed_results</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the accessibility estimates for each
origin/destination (depending if <code>active</code> is <code>TRUE</code> or <code>FALSE</code>) in the
travel matrix.
</p>


<h3>References</h3>

<p>Soukhov A, Páez A, Higgins CD, Mohamed M (2023).
&ldquo;Introducing Spatial Availability, a Singly-Constrained Measure of Competitive Accessibility.&rdquo;
<em>PLOS ONE</em>, <b>18</b>(1), e0278468.
ISSN 1932-6203, <a href="https://doi.org/10.1371/journal.pone.0278468">doi:10.1371/journal.pone.0278468</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# the example below is based on Soukhov et al. (2023) paper

travel_matrix &lt;- data.table::data.table(
  from_id = rep(c("A", "B", "C"), each = 3),
  to_id = as.character(rep(1:3, 3)),
  travel_time = c(15, 30, 100, 30, 15, 100, 100, 100, 15)
)
land_use_data &lt;- data.table::data.table(
  id = c("A", "B", "C", "1", "2", "3"),
  population = c(50000, 150000, 10000, 0, 0, 0),
  jobs = c(0, 0, 0, 100000, 100000, 10000)
)

df &lt;- spatial_availability(
  travel_matrix,
  land_use_data,
  opportunity = "jobs",
  travel_cost = "travel_time",
  demand = "population",
  decay_function = decay_exponential(decay_value = 0.1)
)
df

detailed_df &lt;- spatial_availability(
  travel_matrix,
  land_use_data,
  opportunity = "jobs",
  travel_cost = "travel_time",
  demand = "population",
  decay_function = decay_exponential(decay_value = 0.1),
  detailed_results = TRUE
)
detailed_df

</code></pre>

<hr>
<h2 id='theil_t'>Theil T Index</h2><span id='topic+theil_t'></span>

<h3>Description</h3>

<p>Calculates the Theil T Index of a given accessibility distribution. Values
range from 0 (when all individuals have exactly the same accessibility
levels) to the natural log of <em>n</em>, in which <em>n</em> is the number of individuals
in the accessibility dataset. If the individuals can be classified into
mutually exclusive and completely exhaustive groups, the index can be
decomposed into a between-groups inequaliy component and a within-groups
component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theil_t(
  accessibility_data,
  sociodemographic_data,
  opportunity,
  population,
  socioeconomic_groups = NULL,
  group_by = character(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theil_t_+3A_accessibility_data">accessibility_data</code></td>
<td>
<p>A data frame. The accessibility levels whose
inequality should be calculated. Must contain the columns <code>id</code> and any
others specified in <code>opportunity</code>.</p>
</td></tr>
<tr><td><code id="theil_t_+3A_sociodemographic_data">sociodemographic_data</code></td>
<td>
<p>A data frame. The distribution of
sociodemographic characteristics of the population in the study area cells.
Must contain the columns <code>id</code> and any others specified in <code>population</code> and
<code>socioeconomic_groups</code>.</p>
</td></tr>
<tr><td><code id="theil_t_+3A_opportunity">opportunity</code></td>
<td>
<p>A string. The name of the column in <code>accessibility_data</code>
with the accessibility levels to be considerend when calculating inequality
levels.</p>
</td></tr>
<tr><td><code id="theil_t_+3A_population">population</code></td>
<td>
<p>A string. The name of the column in <code>sociodemographic_data</code>
with the number of people in each cell. Used to weigh accessibility levels
when calculating inequality.</p>
</td></tr>
<tr><td><code id="theil_t_+3A_socioeconomic_groups">socioeconomic_groups</code></td>
<td>
<p>A string. The name of the column in
<code>sociodemographic_data</code> whose values identify the socioeconomic groups that
should be used to calculate the between- and within-groups inequality
levels. If <code>NULL</code> (the default), between- and within-groups components are
not calculated and only the total aggregate inequality is returned.</p>
</td></tr>
<tr><td><code id="theil_t_+3A_group_by">group_by</code></td>
<td>
<p>A <code>character</code> vector. When not <code>character(0)</code> (the default),
indicates the <code>accessibility_data</code> columns that should be used to group the
inequality estimates by. For example, if <code>accessibility_data</code> includes a
<code>scenario</code> column that identifies distinct scenarios that each
accessibility estimates refer to (e.g. before and after a transport policy
intervention), passing <code>"scenario"</code> to this parameter results in inequality
estimates grouped by scenario.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>socioeconomic_groups</code> is <code>NULL</code>, a data frame containing the
total Theil T estimates for the study area. If not, a list containing three
dataframes: one summarizing the total inequality and the between- and
within-groups components, one listing the contribution of each group to the
between-groups component and another listing the contribution of each group
to the within-groups component.
</p>


<h3>See Also</h3>

<p>Other inequality: 
<code><a href="#topic+concentration_index">concentration_index</a>()</code>,
<code><a href="#topic+gini_index">gini_index</a>()</code>,
<code><a href="#topic+palma_ratio">palma_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_dir &lt;- system.file("extdata", package = "accessibility")
travel_matrix &lt;- readRDS(file.path(data_dir, "travel_matrix.rds"))
land_use_data &lt;- readRDS(file.path(data_dir, "land_use_data.rds"))

access &lt;- cumulative_cutoff(
  travel_matrix,
  land_use_data,
  cutoff = 30,
  opportunity = "jobs",
  travel_cost = "travel_time"
)

ti &lt;- theil_t(
  access,
  sociodemographic_data = land_use_data,
  opportunity = "jobs",
  population = "population"
)
ti

# to calculate inequality between and within income deciles, we pass
# "income_decile" to socioeconomic_groups.
# some cells, however, are classified as in the decile NA because their
# income per capita is NaN, as they don't have any population. we filter
# these cells from our accessibility data, otherwise the output would include
# NA values (note that subsetting the data like this doesn't affect the
# assumption that groups are completely exhaustive, because cells with NA
# income decile don't have any population)

na_decile_ids &lt;- land_use_data[is.na(land_use_data$income_decile), ]$id
access &lt;- access[! access$id %in% na_decile_ids, ]
sociodem_data &lt;- land_use_data[! land_use_data$id %in% na_decile_ids, ]

ti &lt;- theil_t(
  access,
  sociodemographic_data = sociodem_data,
  opportunity = "jobs",
  population = "population",
  socioeconomic_groups = "income_decile"
)
ti

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
