<!DOCTYPE html><html lang="en"><head><title>Help for package adana</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adana}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adana-package'><p>Adaptive Nature-inspired Algorithms for Hybrid Genetic Optimization</p></a></li>
<li><a href='#adana'><p>Adaptive Nature-inspired Algorithms for Hybrid Genetic Optimization</p></a></li>
<li><a href='#adana1'>
<p>Adaptive Dynamic Algorithm (Adana 1)</p></a></li>
<li><a href='#adana2'>
<p>Adaptive Dynamic Algorithm (Adana 2)</p></a></li>
<li><a href='#adana3'>
<p>Dynamic mutation and crossover function (Adana 3)</p></a></li>
<li><a href='#atc'>
<p>Asymmetric Two-Point Crossover (ATC)</p></a></li>
<li><a href='#ax'>
<p>Avarage Crossover</p></a></li>
<li><a href='#bestsol'><p>Best solution monitoring function</p></a></li>
<li><a href='#bin2gray'><p>Convert from binary to gray code integer</p></a></li>
<li><a href='#bin2int'><p>Convert Binary Numbers to Integers</p></a></li>
<li><a href='#bitmut'>
<p>Bit Flip Mutation</p></a></li>
<li><a href='#blxa'>
<p>Blended Crossover (BLX-<code class="reqn">\alpha</code>)</p></a></li>
<li><a href='#blxab'>
<p>Blended crossover-<code class="reqn">\alpha\beta</code> (BLX-<code class="reqn">\alpha\beta</code>)</p></a></li>
<li><a href='#boundmut'>
<p>Boundary Mutation</p></a></li>
<li><a href='#bsearchmut1'>
<p>Boundary Search Mutation 1</p></a></li>
<li><a href='#bsearchmut2'>
<p>Boundary Search Mutation 2</p></a></li>
<li><a href='#bx'>
<p>Box Crossover / Flat Crossover</p></a></li>
<li><a href='#calcM'>
<p>Calculate the number of bits in the binary representation of the integer vector</p></a></li>
<li><a href='#cpc'>
<p>Count-preserving Crossover (CPC)</p></a></li>
<li><a href='#cross'>
<p>Crossover</p></a></li>
<li><a href='#cx'>
<p>Cycle Crossover (CX)</p></a></li>
<li><a href='#dc'>
<p>Discrete Crossover</p></a></li>
<li><a href='#decode'>
<p>Convert from binary number to real number</p></a></li>
<li><a href='#decode4int'>
<p>Convert binary vectors to integer vectors</p></a></li>
<li><a href='#decodepop'>
<p>Convert binary number matrix to real number matrix</p></a></li>
<li><a href='#disc'>
<p>Disrespectful Crossover (DISC)</p></a></li>
<li><a href='#dismut'>
<p>Displacement mutation</p></a></li>
<li><a href='#ebx'>
<p>Extended Box Crossover</p></a></li>
<li><a href='#eclc'>
<p>Exchange/Linkage Crossover (EC,LC)</p></a></li>
<li><a href='#elitism'>
<p>Elistist Replacement (Elitism) Function</p></a></li>
<li><a href='#elx'>
<p>Extended-Line Crossover (ELX)</p></a></li>
<li><a href='#encode'>
<p>Convert from real number to binary number</p></a></li>
<li><a href='#encode4int'>
<p>Convert integer vectors to binary vectors</p></a></li>
<li><a href='#encodepop'>
<p>Binary encoding of real number matrix</p></a></li>
<li><a href='#erx'>
<p>Edge Recombination Crossover (ERX)</p></a></li>
<li><a href='#evaluate'>
<p>Calculate the fitness values of population</p></a></li>
<li><a href='#findoptima'><p>Finds peaks and valleys on the curve of a function with single variable</p></a></li>
<li><a href='#fixpcmut'>
<p>Static crossover and mutation rate</p></a></li>
<li><a href='#gaussmut'>
<p>Gauss Mutation</p></a></li>
<li><a href='#gaussmut2'>
<p>Gauss Mutation 2</p></a></li>
<li><a href='#gaussmut3'>
<p>Gauss Mutation 3</p></a></li>
<li><a href='#geomx'>
<p>Geometric Crossover</p></a></li>
<li><a href='#gray2bin'>
<p>Convert gray code to binary integer #1</p></a></li>
<li><a href='#gray2bin2'>
<p>Convert gray code to binary integer #2</p></a></li>
<li><a href='#grdelall'>
<p>Delete-All Replacement</p></a></li>
<li><a href='#grmuplambda'>
<p>Mu+Lambda replacement function 1</p></a></li>
<li><a href='#grmuplambda2'>
<p>Mu+Lambda replacement function 2 (delete the worst <code class="reqn">\lambda</code>)</p></a></li>
<li><a href='#grmuplambda3'>
<p>Mu+Lambda replacement function 3</p></a></li>
<li><a href='#grmuplambda4'>
<p>Mu+Lambda replacement function 4</p></a></li>
<li><a href='#grmuvlambda'>
<p>Mu &amp; Lambda Replacement Function</p></a></li>
<li><a href='#grrobin'>
<p>Round Robin Replacement Function</p></a></li>
<li><a href='#hc'>
<p>Heuristic Crossover</p></a></li>
<li><a href='#hgaoptim'>
<p>GA + optim hybridization function</p></a></li>
<li><a href='#hgaoptimx'>
<p>GA + optimx hybridization function</p></a></li>
<li><a href='#hgaroi'>
<p>GA + ROI hybridization function</p></a></li>
<li><a href='#hux'>
<p>Heuristic Uniform Crossover</p></a></li>
<li><a href='#icx'>
<p>Improved Cycle Crossover (ICX)</p></a></li>
<li><a href='#ilmdhc'>
<p>ILM/DHC adaptation function</p></a></li>
<li><a href='#initbin'>
<p>Initialize the population with binary encoding</p></a></li>
<li><a href='#initialize'>
<p>Initialize function</p></a></li>
<li><a href='#initnorm'>
<p>Normal distribution based initialization</p></a></li>
<li><a href='#initperm'>
<p>Permutation coded initialization</p></a></li>
<li><a href='#initval'>
<p>Value encoded initialization</p></a></li>
<li><a href='#insmut'>
<p>Insertation Mutation</p></a></li>
<li><a href='#insswapmut'>
<p>Insertion + Inversion Mutation</p></a></li>
<li><a href='#int2bin'><p>Convert an integer to binary coded number</p></a></li>
<li><a href='#invdismut'>
<p>Displacement + Inversion Mutation</p></a></li>
<li><a href='#invmut'>
<p>Inversion Mutation</p></a></li>
<li><a href='#invswapmut'>
<p>Swap + Inversion Mutation</p></a></li>
<li><a href='#kpx'>
<p>k-point Crossover</p></a></li>
<li><a href='#lapx'>
<p>Laplace Crossover</p></a></li>
<li><a href='#lax'>
<p>Local Arithmetic Crossover</p></a></li>
<li><a href='#leitingzhi'>
<p>Lei &amp; Tingzhi Adaptation Function</p></a></li>
<li><a href='#maxone'>
<p>MAXONE fitness function</p></a></li>
<li><a href='#maxone1'>
<p>MAXONE1 fitness function</p></a></li>
<li><a href='#maxone2'>
<p>maxone2 fitness function</p></a></li>
<li><a href='#minone'>
<p>minone fitness function</p></a></li>
<li><a href='#monprogress'>
<p>Monitor Fitness Value Progress</p></a></li>
<li><a href='#mpmx'>
<p>Modified Partially Mapped Crossover</p></a></li>
<li><a href='#mpx'>
<p>Maximal Preservative Crossover (MPX)</p></a></li>
<li><a href='#mutate'>
<p>Function of Mutation Application</p></a></li>
<li><a href='#mx'>
<p>Mask crossover</p></a></li>
<li><a href='#nunimut'>
<p>Non-uniform Mutation</p></a></li>
<li><a href='#nunimut2'>
<p>Adaptive Non-uniform mutation</p></a></li>
<li><a href='#ox'>
<p>Order Crossover (OX)</p></a></li>
<li><a href='#ox2'>
<p>Order-based crossover (OX2)</p></a></li>
<li><a href='#pbx'>
<p>Position-Based Crossover (PBX)</p></a></li>
<li><a href='#pbx2'>
<p>Position-Based Crossover 2 (PBX2)</p></a></li>
<li><a href='#plotfitness'>
<p>Fitness statistics graph by GA generations</p></a></li>
<li><a href='#pmx'>
<p>Partially Mapped Crossover</p></a></li>
<li><a href='#powmut'>
<p>Power Mutation</p></a></li>
<li><a href='#powmut2'>
<p>Power Mutation 2</p></a></li>
<li><a href='#px1'>
<p>One-point Crossover</p></a></li>
<li><a href='#randmut'>
<p>Random Resetting Mutation</p></a></li>
<li><a href='#randmut2'>
<p>Random mutation 2</p></a></li>
<li><a href='#randmut3'>
<p>Random mutation 3</p></a></li>
<li><a href='#randmut4'>
<p>Random mutation 4</p></a></li>
<li><a href='#raoc'>
<p>Randomized And/Or Crossover (RAOC)</p></a></li>
<li><a href='#rrc'>
<p>Random Respectful Crossover (RRC)</p></a></li>
<li><a href='#rsc'>
<p>Reduced Surrogate Cross</p></a></li>
<li><a href='#sax'>
<p>Single Arithmetic Crossover</p></a></li>
<li><a href='#sc'>
<p>Shuffle Crossover</p></a></li>
<li><a href='#selboltour'>
<p>Boltzmann Tournament Selection</p></a></li>
<li><a href='#seldet'>
<p>Deterministic Selection</p></a></li>
<li><a href='#select'>
<p>Select parents for the mating pool</p></a></li>
<li><a href='#selers'>
<p>Exponantial Ranking Selection</p></a></li>
<li><a href='#selescale'>
<p>Exponent Scaling</p></a></li>
<li><a href='#sellrs'>
<p>Linear Ranking Selection 1</p></a></li>
<li><a href='#sellrs2'>
<p>Linear Ranking Selection 2</p></a></li>
<li><a href='#sellrs3'>
<p>Linear Ranking Selection 3</p></a></li>
<li><a href='#sellscale'>
<p>Fitness Linear Scaling</p></a></li>
<li><a href='#selnlrs'>
<p>Nonlinear Ranking Selection</p></a></li>
<li><a href='#selpscale'>
<p>Power-law Scaling</p></a></li>
<li><a href='#selrand'>
<p>Random selection</p></a></li>
<li><a href='#selrscale'>
<p>Rank Scaling</p></a></li>
<li><a href='#selrscale2'>
<p>Rank Scaling 2</p></a></li>
<li><a href='#selrss'>
<p>Remainder Stochastic Selection</p></a></li>
<li><a href='#selrswrp'>
<p>Random selection with replacement and proportion</p></a></li>
<li><a href='#selrws'>
<p>Roulette wheel selection 1</p></a></li>
<li><a href='#selrws2'>
<p>Roulette wheel selection 2</p></a></li>
<li><a href='#selsscale'>
<p>Sigma Scaling</p></a></li>
<li><a href='#selsscale2'>
<p>Sigma scaling 2</p></a></li>
<li><a href='#selsus'>
<p>Stochastic Universal Selection</p></a></li>
<li><a href='#seltour'>
<p>Tournament Selection</p></a></li>
<li><a href='#seltour2'>
<p>Tournament Selection 2</p></a></li>
<li><a href='#seltrunc'>
<p>Truncation Selection</p></a></li>
<li><a href='#selwscale'>
<p>Window Scaling</p></a></li>
<li><a href='#show'>
<p>Function to visualize iteration results</p></a></li>
<li><a href='#shufmut'>
<p>Shuffle Mutation</p></a></li>
<li><a href='#smc'>
<p>Sinusoidal Motion Crossover (SMC)</p></a></li>
<li><a href='#spherex'>
<p>Sphere Crossover</p></a></li>
<li><a href='#ssrfamtour'>
<p>Replacement function via family tournament</p></a></li>
<li><a href='#ssrgenitor'>
<p>Genitor replacement function</p></a></li>
<li><a href='#ssrmup1'>
<p>Mu+1 replacement function</p></a></li>
<li><a href='#ssrx'>
<p>Mixed replacement function</p></a></li>
<li><a href='#swapmut'>
<p>Swap Mutation</p></a></li>
<li><a href='#terminate'>
<p>Termination Control Function</p></a></li>
<li><a href='#unimut'>
<p>Uniform Mutation</p></a></li>
<li><a href='#upmx'>
<p>Uniform Partial Mapped Crossover</p></a></li>
<li><a href='#ux'>
<p>Uniform crossover 1</p></a></li>
<li><a href='#ux2'>
<p>Uniform Crossover 2</p></a></li>
<li><a href='#wax'>
<p>Whole Arithmetic Crossover</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Adaptive Nature-Inspired Algorithms for Hybrid Genetic
Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Zeynel Cebeci [aut, cre], Erkut Tekeli [aut], Cagatay Cebeci [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Erkut Tekeli &lt;etekeli@atu.edu.tr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The Genetic Algorithm (GA) is a type of optimization method of Evolutionary Algorithms. It uses the biologically inspired operators such as mutation, crossover, selection and replacement.Because of their global search and robustness abilities, GAs have been widely utilized in machine learning, expert systems, data science, engineering, life sciences and many other areas of research and business. However, the regular GAs need the techniques to improve their efficiency in computing time and performance in finding global optimum using some adaptation and hybridization strategies. The adaptive GAs (AGA) increase the convergence speed and success of regular GAs by setting the parameters crossover and mutation probabilities dynamically. The hybrid GAs combine the exploration strength of a stochastic GAs with the exact convergence ability of any type of deterministic local search algorithms such as simulated-annealing, in addition to other nature-inspired algorithms such as ant colony optimization, particle swarm optimization etc. The package 'adana' includes a rich working environment with its many functions that make possible to build and work regular GA, adaptive GA, hybrid GA and hybrid adaptive GA for any kind of optimization problems. Cebeci, Z. (2021, ISBN: 9786254397448).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, optimx, ROI, ROI.plugin.optimx</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-22 13:51:30 UTC; pc</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-23 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adana-package'>Adaptive Nature-inspired Algorithms for Hybrid Genetic Optimization</h2><span id='topic+adana-package'></span>

<h3>Description</h3>

<p>The package <span class="pkg">adana</span> provides the functions related to the hyrid adaptive genetic algorithms for solving optimization problems.
</p>


<h3>Details</h3>

<p>The Genetic Algorithm (GA) is a type of optimization method of Evolutionary Algorithms. It uses the biologically inspired operators such as mutation, crossover, selection and replacement.Because of their global search and robustness abilities, GAs have been widely utilized in machine learning, expert systems, data science, engineering, life sciences and many other areas of research and business. However, the regular GAs need the techniques to improve their efficiences in computing time and performance in finding global optimum using some adaptation and hybridization strategies. The adaptive GAs (AGA) increase the convergence speed and success of regular GAs by setting the parameters crossover and mutation probabilities dynamically. The hybrid GAs combine the exploration strength of a stochastic GAs with the exact convergence ability of any type of deterministic local search algorithms such as simulated-annealing, in addition to other nature-inspired algorithms such as ant colony optimization, particle swarm optimization etc. The package 'adana' includes a rich working environment with its many functions that make possible to build and work regular GA, adaptive GA, hybrid GA and hybrid adaptive GA for any kind of optimization problems.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci, Erkut Tekeli</p>


<h3>References</h3>

<p>Cebeci, Z. (2021). R ile Genetik Algoritmalar ve Optimizasyon Uygulamalari [Genetic Algorithms and Optimization Applications with R], 535 p. Nobel Academic Publishing. Ankara
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adana">adana</a></code>
</p>

<hr>
<h2 id='adana'>Adaptive Nature-inspired Algorithms for Hybrid Genetic Optimization
</h2><span id='topic+adana'></span>

<h3>Description</h3>

<p>The adana function is a GA function that can be used for any single-objective optimization problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adana(gatype = "gga", objective = "max", maxiter = 100, initfunc = initbin, fitfunc,
      selfunc = seltour, crossfunc = px1, mutfunc = bitmut, replace = elitism,
      adapfunc = NULL, hgafunc = NULL, monitorfunc = NULL, n = 100, m = 8,
      lb = rep(0, 8), ub = rep(1, 8), nmode = "real", type = 1, permset = 0:9,
      prevpop = NULL, selt = 2, selbc = 0.5, selc = 2, selk = 1.005, sells = 1.5,
      selns = 0.5, selps = 0.5, sels = 1.5, selt0 = 50, selw = 2, reptype = FALSE,
      cxpc = 0.9, cxpc2 = 0.8, cxon = 2, cxk = 2, cxps = 0.5, cxa = 0, cxb = 0.15,
      cxealfa = 1, cxalfa = 0.5, mutpm = 0.05, mutpm2 = 0.2, mutb = 2, mutpow = 2,
      mutq = 0.5, mutmy = c(), mutsdy = c(), adapa = 0.75, adapb = 0.5, adapc = 0.1,
      adapd = 0.1, hgastep = 10, hgans = 1, hgaftype = "w", reps = 1, repk = 10,
      lambda = 1, tercrit = c(1), abdif = 1e-06, bestdif = 1e-06, objval = 0,
      optdif = 1e-06, rmcnt = 10, rmdif = 1e-06, phidif = 1e-06, rangedif = 1e-06,
      meandif = 1e-06, sddif = 1e-06, mincv = 0.001, simlev = 0.95, maxtime = 60,
      keepbest = TRUE, parfile = NULL, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adana_+3A_gatype">gatype</code></td>
<td>
<p>Type of GA. </p>
<ul>
<li><p>&quot;gga&quot;: generational GA  </p>
</li>
<li><p>&quot;ssga&quot;: steady state GA </p>
</li></ul>
 <p>Default value is &quot;gga&quot;</p>
</td></tr>
<tr><td><code id="adana_+3A_objective">objective</code></td>
<td>
<p>Type of optimization. </p>
<ul>
<li><p>&quot;min&quot;: minimization  </p>
</li>
<li><p>&quot;max&quot;: maximization </p>
</li></ul>
 <p>Default value is &quot;max&quot;</p>
</td></tr>
<tr><td><code id="adana_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum generation number 
</p>
<p>Default value is 100</p>
</td></tr>
<tr><td><code id="adana_+3A_initfunc">initfunc</code></td>
<td>
<p>Name of fitness function. </p>
<ul>
<li><p>&quot;initbin&quot; : for binary-coded  
</p>
</li>
<li><p>&quot;initval&quot; : for value-coded 
</p>
</li>
<li><p>&quot;initperm&quot;: for permutation-coded
</p>
</li>
<li><p>or user-defined initialize function</p>
</li></ul>
 
<p>Default value is &quot;initbin&quot;</p>
</td></tr>
<tr><td><code id="adana_+3A_fitfunc">fitfunc</code></td>
<td>
<p>Fitness function</p>
</td></tr>
<tr><td><code id="adana_+3A_selfunc">selfunc</code></td>
<td>
<p>Name of the selection function  
</p>
<p>Default value is &quot;seltour&quot;</p>
</td></tr>
<tr><td><code id="adana_+3A_crossfunc">crossfunc</code></td>
<td>
<p>Name of the crossover function  
</p>
<p>Default value is &quot;px1&quot;</p>
</td></tr>
<tr><td><code id="adana_+3A_mutfunc">mutfunc</code></td>
<td>
<p>Name of the mutation function  
</p>
<p>Default value is &quot;bitmut&quot;</p>
</td></tr>
<tr><td><code id="adana_+3A_replace">replace</code></td>
<td>
<p>Name of the replacement function  
</p>
<p>Default value is &quot;elitism&quot;</p>
</td></tr>
<tr><td><code id="adana_+3A_adapfunc">adapfunc</code></td>
<td>
<p>Name of the adaptation function</p>
</td></tr>
<tr><td><code id="adana_+3A_hgafunc">hgafunc</code></td>
<td>
<p>The name of the function that will do the hybridization.</p>
</td></tr>
<tr><td><code id="adana_+3A_monitorfunc">monitorfunc</code></td>
<td>
<p>Monitoring function</p>
</td></tr>
<tr><td><code id="adana_+3A_n">n</code></td>
<td>
<p>Population size</p>
</td></tr>
<tr><td><code id="adana_+3A_m">m</code></td>
<td>
<p>Length of chromosome</p>
</td></tr>
<tr><td><code id="adana_+3A_lb">lb</code></td>
<td>
<p>A vector containing lower bounds for variables in value-coded problems</p>
</td></tr>
<tr><td><code id="adana_+3A_ub">ub</code></td>
<td>
<p>A vector containing upper bounds for variables in value-coded problems</p>
</td></tr>
<tr><td><code id="adana_+3A_nmode">nmode</code></td>
<td>
<p>Value mode for initiating value-coding problems
</p>
<ul>
<li><p>&quot;integer&quot;  </p>
</li>
<li><p>&quot;real&quot; </p>
</li></ul>
 <p>Default value is &quot;real&quot;</p>
</td></tr>
<tr><td><code id="adana_+3A_type">type</code></td>
<td>
<p>Integer indicating the type of initialization matrix.
</p>
<ul>
<li><p>1 : contains the chromosome, fitness value and generation number.
</p>
</li>
<li><p>2 : contains only the chromosome. 
</p>
</li></ul>

</td></tr>        
<tr><td><code id="adana_+3A_permset">permset</code></td>
<td>
<p>A vector containing the ordinal values to be used in permutation-coded initialization.
</p>
<p>Default value is 0:9
</p>
</td></tr>
<tr><td><code id="adana_+3A_prevpop">prevpop</code></td>
<td>
<p>A matrix containing previously prepared chromosomes during initialization.</p>
</td></tr>
<tr><td><code id="adana_+3A_selt">selt</code></td>
<td>
<p>The tournament size for the seltour and seltour2 functions.
</p>
<p>Default value is 2.
</p>
</td></tr>
<tr><td><code id="adana_+3A_selbc">selbc</code></td>
<td>
<p>The base parameter for the selers function.
</p>
<p>Default value is 0.5.
</p>
</td></tr>
<tr><td><code id="adana_+3A_selc">selc</code></td>
<td>
<p>Scale parameter for selsscale and selsscale2 functions
</p>
<p>Default value is 2.
</p>
</td></tr>
<tr><td><code id="adana_+3A_selk">selk</code></td>
<td>
<p>Power parameter for selpscale function
</p>
<p>Default value is 1.005.
</p>
</td></tr>
<tr><td><code id="adana_+3A_sells">sells</code></td>
<td>
<p>Scale parameter for sellscale function
</p>
<p>Default value is 1.5.
</p>
</td></tr>
<tr><td><code id="adana_+3A_selns">selns</code></td>
<td>
<p>Polynomal coefficient for selnlrs function
</p>
<p>Default value is 0.5.
</p>
</td></tr>
<tr><td><code id="adana_+3A_selps">selps</code></td>
<td>
<p>Cut-point threshold value for seltrunc function.
</p>
<p>Default value is 0.5.
</p>
</td></tr>
<tr><td><code id="adana_+3A_sels">sels</code></td>
<td>
<p>Selection pressure for sellrs, sellrs3 and selrscale2 functions.
</p>
<p>Default value is 1.5.
</p>
</td></tr>
<tr><td><code id="adana_+3A_selt0">selt0</code></td>
<td>
<p>The starting temperature for selboltour function.
</p>
<p>Default value is 50.
</p>
</td></tr>
<tr><td><code id="adana_+3A_selw">selw</code></td>
<td>
<p>Window size for selwscale function.
</p>
<p>Default value is 2.
</p>
</td></tr>
<tr><td><code id="adana_+3A_reptype">reptype</code></td>
<td>
<p>TRUE value is entered for the sampling with replacement when the seltour and seltour2 are used.
</p>
<p>Default value is FALSE.
</p>
</td></tr>
<tr><td><code id="adana_+3A_cxpc">cxpc</code></td>
<td>
<p>Crossover ratio
</p>
<p>Default value is 0.9.
</p>
</td></tr>
<tr><td><code id="adana_+3A_cxpc2">cxpc2</code></td>
<td>
<p>Adapted crossover ratio for the leitingzhi function.</p>
</td></tr>
<tr><td><code id="adana_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring per mating in crossover.
</p>
<p>Default value is 2.
</p>
</td></tr>
<tr><td><code id="adana_+3A_cxk">cxk</code></td>
<td>
<p>Number of cut-points for multi-point crossover.
</p>
<p>Default value is 2.
</p>
</td></tr>
<tr><td><code id="adana_+3A_cxps">cxps</code></td>
<td>
<p>Probability threshold value for hux, ux, ux2, dc crossovers.
</p>
<p>Default value is 0.5.
</p>
</td></tr>
<tr><td><code id="adana_+3A_cxa">cxa</code></td>
<td>
<p>Location Parameter for lapx crossover
</p>
<p>Default value is 0.
</p>
</td></tr>
<tr><td><code id="adana_+3A_cxb">cxb</code></td>
<td>
<p>Scale Parameter for lapx crossover
</p>
<p>Default value is 0.15
</p>
</td></tr>
<tr><td><code id="adana_+3A_cxealfa">cxealfa</code></td>
<td>
<p>The random alpha value for sax, wax, ebx crosses. It is determined dynamically, but for some controlled studies, a fixed value can be assigned.</p>
</td></tr>
<tr><td><code id="adana_+3A_cxalfa">cxalfa</code></td>
<td>
<p>The random alpha value for sax, wax, ebx crosses. It is determined dynamically, but for some controlled studies, a fixed value can be assigned.</p>
</td></tr>
<tr><td><code id="adana_+3A_mutpm">mutpm</code></td>
<td>
<p>Mutation rate
</p>
<p>Default value is 0.05
</p>
</td></tr>
<tr><td><code id="adana_+3A_mutpm2">mutpm2</code></td>
<td>
<p>Adaptive mutation rate</p>
</td></tr>
<tr><td><code id="adana_+3A_mutb">mutb</code></td>
<td>
<p>The exponent value used to avoid uniformity in unimut and nunimut2.
</p>
<p>Default value is 0.5
</p>
</td></tr>
<tr><td><code id="adana_+3A_mutpow">mutpow</code></td>
<td>
<p>The exponent value for powmut and powmut2 functions.
</p>
<p>Default value is 2.
</p>
</td></tr>
<tr><td><code id="adana_+3A_mutq">mutq</code></td>
<td>
<p>A number. Value of q for bsearchmut1
</p>
<p>Default value is 0.5
</p>
</td></tr>
<tr><td><code id="adana_+3A_mutmy">mutmy</code></td>
<td>
<p>A vector. Vector of means of genes</p>
</td></tr>
<tr><td><code id="adana_+3A_mutsdy">mutsdy</code></td>
<td>
<p>A vector. Vector of standard deviations of genes</p>
</td></tr>
<tr><td><code id="adana_+3A_adapa">adapa</code></td>
<td>
<p>Adaptation threshold a for leitingzhi function
</p>
<p>Default value is 0.5
</p>
</td></tr>
<tr><td><code id="adana_+3A_adapb">adapb</code></td>
<td>
<p>Adaptation threshold b for leitingzhi function
</p>
<p>Default value is 0.75
</p>
</td></tr>
<tr><td><code id="adana_+3A_adapc">adapc</code></td>
<td>
<p>Crossover adaptation threshold for adana3 function 
</p>
<p>Default value is 0.2
</p>
</td></tr>
<tr><td><code id="adana_+3A_adapd">adapd</code></td>
<td>
<p>Mutation adaptation threshold for adana3 function 
</p>
<p>Default value is 0.05
</p>
</td></tr>
<tr><td><code id="adana_+3A_hgastep">hgastep</code></td>
<td>
<p>In a hybrid GA implementation, it is an integer indicating how many generations the hybrid optimization algorithm will be called.
</p>
<p>Default value is 10
</p>
</td></tr>
<tr><td><code id="adana_+3A_hgans">hgans</code></td>
<td>
<p>Number of individuals to be transferred to the Optim.
</p>
<p>Default value is 2</p>
</td></tr>
<tr><td><code id="adana_+3A_hgaftype">hgaftype</code></td>
<td>
<p>Types of fitness to transfer. </p>

<ul>
<li><p>w: individuals with the worst fitness value
</p>
</li>
<li><p>b: individuals with the best fitness value
</p>
</li>
<li><p>r: randomly selected individuals
</p>
</li></ul>

<p>Default value is &quot;w&quot;
</p>
</td></tr>
<tr><td><code id="adana_+3A_reps">reps</code></td>
<td>
<p>The number of the best individuals to be selected when elitism is applied.
</p>
<p>Default value is 1.
</p>
</td></tr>
<tr><td><code id="adana_+3A_repk">repk</code></td>
<td>
<p>The selection pressure parameter for the Round Robin function.
</p>
<p>Default value is 10.
</p>
</td></tr>
<tr><td><code id="adana_+3A_lambda">lambda</code></td>
<td>
<p>Total number of offspring in replacement algorithms in steady-state replacement type GAs
</p>
<p>Default value is 1.
</p>
</td></tr>
<tr><td><code id="adana_+3A_tercrit">tercrit</code></td>
<td>
<p>A vector for termination criterion
</p>
<p>Default value is (1,13).
</p>
</td></tr>
<tr><td><code id="adana_+3A_abdif">abdif</code></td>
<td>
<p>It is an approach difference value used by the termination criterion 6.
</p>
<p>Default value is 1e-06.
</p>
</td></tr>
<tr><td><code id="adana_+3A_bestdif">bestdif</code></td>
<td>
<p>The approach value to the global optimum value.
</p>
<p>Default value is 1e-06.
</p>
</td></tr>
<tr><td><code id="adana_+3A_objval">objval</code></td>
<td>
<p>Global optimum. Used by some termination criterion. This criterion is used if the global optimum of the problem is known.</p>
</td></tr>
<tr><td><code id="adana_+3A_optdif">optdif</code></td>
<td>
<p>It is an approach difference value used by the termination criterion 3.
</p>
<p>Default value is 1e-06.
</p>
</td></tr>
<tr><td><code id="adana_+3A_rmcnt">rmcnt</code></td>
<td>
<p>k value used by the termination criterion 5.
</p>
<p>Default value is 10.
</p>
</td></tr>
<tr><td><code id="adana_+3A_rmdif">rmdif</code></td>
<td>
<p>It is an approach difference value used by the termination criterion 5.
</p>
<p>Default value is 1e-06.
</p>
</td></tr>
<tr><td><code id="adana_+3A_phidif">phidif</code></td>
<td>
<p>It is an approach difference value used by the termination criterion 10.
</p>
<p>Default value is 1e-06.
</p>
</td></tr>
<tr><td><code id="adana_+3A_rangedif">rangedif</code></td>
<td>
<p>It is an approach difference value used by the termination criterion 8.
</p>
<p>Default value is 1e-06.
</p>
</td></tr>
<tr><td><code id="adana_+3A_meandif">meandif</code></td>
<td>
<p>It is an approach difference value used by the termination criterion 4.
</p>
<p>Default value is 1e-06.
</p>
</td></tr>
<tr><td><code id="adana_+3A_sddif">sddif</code></td>
<td>
<p>It is an approach difference value used by the termination criterion 7.
</p>
<p>Default value is 1e-06.
</p>
</td></tr>
<tr><td><code id="adana_+3A_mincv">mincv</code></td>
<td>
<p>Minimum coefficient of variance used by the termination criterion 9.
</p>
<p>Default value is 0.001.
</p>
</td></tr>
<tr><td><code id="adana_+3A_simlev">simlev</code></td>
<td>
<p>It is an approach difference value used by the termination criterion 7.
</p>
<p>Default value is 0.99.
</p>
</td></tr>
<tr><td><code id="adana_+3A_maxtime">maxtime</code></td>
<td>
<p>It is maximum runtime (minute) value used by the termination criterion 12.
</p>
<p>Default value is 60.
</p>
</td></tr>
<tr><td><code id="adana_+3A_keepbest">keepbest</code></td>
<td>
<p>If the keepbest parameter is TRUE, the best solution value, chromosome, and generation number are saved in the list named bestsol.
</p>
<p>Default value is TRUE.
</p>
</td></tr>
<tr><td><code id="adana_+3A_parfile">parfile</code></td>
<td>
<p>The name of the file where the parameter values are defined if any.
</p>
<p>Default value is NULL.
</p>
</td></tr>
<tr><td><code id="adana_+3A_verbose">verbose</code></td>
<td>
<p>TRUE is assigned to display the statistics of fitness values obtained at the end of the loop in the GA study.
</p>
<p>Default value is FALSE.
</p>
</td></tr>
<tr><td><code id="adana_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the <code>initialize</code>, <code>select</code>, <code>cross</code>, <code>mutate</code>, <code>hgafunc</code>, and <code>show</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>adana</code> function is a genetic algorithm function that can be used for all kinds of single-objective optimization problems. The adana function, unlike other GA packages, not only has adaptive GA functions, but also offers specially developed deterministic and self-adaptive techniques called <code><a href="#topic+adana1">adana1</a></code>, <code><a href="#topic+adana2">adana2</a></code>, and <code><a href="#topic+adana3">adana3</a></code>, and is easily hybridized with other optimization methods inspired by nature. Besides, the adana function supports the use of monitors to monitor the progress of the GA run. In addition to containing many crossover and mutation operators, it is coded with a plug-and-play approach so that the user can add custom operator functions that he has developed.
</p>
<p>The initialization population is created by using the name of the initialization function and other parameters passed to <code>initfunc</code> with the <code><a href="#topic+initialize">initialize</a></code> function. The fit values of individuals in the population are calculated using <code>fitfunc</code>, which is passed to the <code><a href="#topic+evaluate">evaluate</a></code> function before each iteration. Then, the termination conditions are checked according to the criteria specified in the termination criteria (<code>tercrit</code>) argument via the <code><a href="#topic+terminate">terminate</a></code> function. When the termination condition is not met, <code>adana</code> GA continues to run and searches for the best solution. If the <code>keepbest</code> argument is TRUE, the best solution value, chromosome, and generation number are saved in the list named <code>bestsol</code>.
</p>
<p>Since the <code>adana</code> function allows adaptive GA studies, from which it is named, it runs a function that is passed with the <code>adapfunc</code> argument and contains the code of the adaptation algorithm. This adaptation function returns the crossover and mutation rates by recalculating. Thus, it strengthens the GA with its exploitation and exploration adaptations.
</p>
<p>In order to determine the individuals to be selected for the mating pool, the selection process is done with the <code>selfunc</code> selection function transferred to the <code><a href="#topic+select">select</a></code> function.
</p>
<p>The crossover of selected individuals is executed with the crossover operator in the <code>crossfunc</code> argument passed to the <code><a href="#topic+cross">cross</a></code> function.
</p>
<p>Mutation operations are performed with the mutation operator function assigned to <code>mutfunc</code> by the <code><a href="#topic+mutate">mutate</a></code> function.
</p>
<p>Finally, for GA, replacement is performed by passing the parent population and the offspring population to the <code><a href="base.html#topic+replace">replace</a></code> function.
</p>
<p>Hybridization with other optimization techniques can also be done before an iteration of the GA is complete. For this, the hybridization function passed to the <code>hgafunc</code> argument is used. Other parameters that need the optimization technique called in the hybridization function call, are also passed.
</p>
<p>Progress made in each GA generation can be monitored visually with a monitor function. For this, the monitor function passed to the <code>monitorfunc</code> argument is used.
</p>
<p>In GA implementations, if the required parameters for R functions that perform selection, crossover, mutation, renewal, and other operations are not entered in the function call, their default values are used. The user can change these parameters during the function call to suit the problem. However, there are many parameters used by the <code>adana</code> function and the functions it calls. It may be more practical to use the parameters by saving them to a file. The <code>parfile</code> argument can be used for this purpose.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>genfits</code></td>
<td>
<p>A matrix containing statistics for generations.</p>
</td></tr>
<tr><td><code>initpop</code></td>
<td>
<p>A matrix containing the initial population</p>
</td></tr>
<tr><td><code>finalpop</code></td>
<td>
<p>A matrix containing the final population</p>
</td></tr>
<tr><td><code>bestsol</code></td>
<td>
<p>Value of the best solution</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>Objective of the optimization, <em>min</em> or <em>max</em></p>
</td></tr>
<tr><td><code>tcode</code></td>
<td>
<p>Termination code</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Cebeci, Z. (2021). R ile Genetik Algoritmalar ve Optimizasyon Uygulamalari, 535 p. Ankara:Nobel Akademik Yayincilik. 
</p>


<h3>See Also</h3>

<p>GA Operators:
<code><a href="#topic+initialize">initialize</a></code>,
<code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+terminate">terminate</a></code>,
<code><a href="#topic+select">select</a></code>,
<code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+mutate">mutate</a></code>
</p>
<p>Initialize Functions:
<code><a href="#topic+initbin">initbin</a></code>,
<code><a href="#topic+initval">initval</a></code>,
<code><a href="#topic+initperm">initperm</a></code>,
<code><a href="#topic+initnorm">initnorm</a></code>
</p>
<p>Selection Functions:
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code>,
<code><a href="#topic+sellrs">sellrs</a></code>,
<code><a href="#topic+sellrs2">sellrs2</a></code>,
<code><a href="#topic+sellrs3">sellrs3</a></code>,
<code><a href="#topic+selnlrs">selnlrs</a></code>,
<code><a href="#topic+selers">selers</a></code>,
<code><a href="#topic+seltrunc">seltrunc</a></code> 
</p>
<p>Crossover Functions:
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>
<p>Mutation Functions:
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,        
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,   
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,  
<code><a href="#topic+dismut">dismut</a></code>,
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>
<p>Replacement Functions:
<code><a href="#topic+grdelall">grdelall</a></code>,
<code><a href="#topic+elitism">elitism</a></code>,
<code><a href="#topic+grmuplambda">grmuplambda</a></code>, 
<code><a href="#topic+grmuplambda2">grmuplambda2</a></code>, 
<code><a href="#topic+grmuplambda3">grmuplambda3</a></code>, 
<code><a href="#topic+grmuplambda4">grmuplambda4</a></code>, 
<code><a href="#topic+grmuvlambda">grmuvlambda</a></code>, 
<code><a href="#topic+grrobin">grrobin</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrgenitor">ssrgenitor</a></code>, 
<code><a href="#topic+ssrfamtour">ssrfamtour</a></code>, 
<code><a href="#topic+ssrx">ssrx</a></code>
</p>
<p>Adaptation Functions:
<code><a href="#topic+fixpcmut">fixpcmut</a></code>,
<code><a href="#topic+ilmdhc">ilmdhc</a></code>,
<code><a href="#topic+adana1">adana1</a></code>,
<code><a href="#topic+adana2">adana2</a></code>,
<code><a href="#topic+adana3">adana3</a></code>,
<code><a href="#topic+leitingzhi">leitingzhi</a></code>
</p>
<p>Hybridization Functions:
<code><a href="#topic+hgaoptim">hgaoptim</a></code>,
<code><a href="#topic+hgaoptimx">hgaoptimx</a></code>,
<code><a href="#topic+hgaroi">hgaroi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Preparing data
material = c("knife", "tin", "potato", "coffee", "sleeping bag", "rope", "compass")
weigth = c(1, 5, 10, 1, 7, 5, 1)
point = c(10, 20, 15, 2, 30, 10, 30)
kspdata = data.frame(material, weigth, point)
capacity = 100

# Fitness Function
kspfit2 = function(x, ...) {
  tpoint = x %*% kspdata$point
  tweigth = x %*% kspdata$weigth
  G1 = tweigth-capacity 
  fitval = tpoint-max(0,G1)^2     
  return(fitval)
}

# Run GA
n = 20
m = nrow(kspdata)
niter = 100
kspGGA = adana(n=n, m=m, maxiter=niter, objective="max", gatype="gga",
  initfunc=initbin, fitfunc=kspfit2, selfunc=seltour, 
  crossfunc=kpx, mutfunc=bitmut, replace=elitism,
  selt=2, reps=4, repk=5, cxon=2, cxk=3, cxpc=0.8, 
  mutpm=0.05, tercrit=c(1), keepbest=TRUE,
  verbose=TRUE, monitorfunc=monprogress)
  
head(kspGGA$finalpop)        # Display Final Population
head(kspGGA$genfits)         # Display Fitness Values According to Generations
bestsol(kspGGA)              # Display Best Solution  
kspdata[kspGGA$bestsol$chromosome == 1, ]    # Display Best Chromosome
</code></pre>

<hr>
<h2 id='adana1'>
Adaptive Dynamic Algorithm (Adana 1)
</h2><span id='topic+adana1'></span>

<h3>Description</h3>

<p>Adana-1 is an adaptation function that calculates the mutation rates to be applied in generations by sine wave modeling (Cebeci, 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adana1(g, gmax, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adana1_+3A_g">g</code></td>
<td>
<p>Current generation</p>
</td></tr>
<tr><td><code id="adana1_+3A_gmax">gmax</code></td>
<td>
<p>Maximum generation</p>
</td></tr>
<tr><td><code id="adana1_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pc</code></td>
<td>
<p>Crossover rate</p>
</td></tr>
<tr><td><code>pm</code></td>
<td>
<p>Mutation rate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Cebeci, Z. (2021). R ile Genetik Algoritmalar ve Optimizasyon Uygulamalari, 535 p. Ankara:Nobel Akademik Yayincilik. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixpcmut">fixpcmut</a></code>,
<code><a href="#topic+ilmdhc">ilmdhc</a></code>,
<code><a href="#topic+adana2">adana2</a></code>,
<code><a href="#topic+leitingzhi">leitingzhi</a></code>,
<code><a href="#topic+adana3">adana3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gmax &lt;- 1000
g &lt;- c(1, 10, 50, 100, 250, 500, 750, gmax)
adana1(g=g, gmax=gmax)
</code></pre>

<hr>
<h2 id='adana2'>
Adaptive Dynamic Algorithm (Adana 2)
</h2><span id='topic+adana2'></span>

<h3>Description</h3>

<p>Adana-2 is an adaptation function that calculates the mutation rates to be applied in generations by square root modeling (Cebeci, 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adana2(g, gmax, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adana2_+3A_g">g</code></td>
<td>
<p>Current generation</p>
</td></tr>
<tr><td><code id="adana2_+3A_gmax">gmax</code></td>
<td>
<p>Maximum generation</p>
</td></tr>
<tr><td><code id="adana2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pc</code></td>
<td>
<p>Crossover rate</p>
</td></tr>
<tr><td><code>pm</code></td>
<td>
<p>Mutation rate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Cebeci, Z. (2021). R ile Genetik Algoritmalar ve Optimizasyon Uygulamalari, 535 p. Ankara:Nobel Akademik Yayincilik. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixpcmut">fixpcmut</a></code>,
<code><a href="#topic+ilmdhc">ilmdhc</a></code>,
<code><a href="#topic+adana1">adana1</a></code>,
<code><a href="#topic+leitingzhi">leitingzhi</a></code>,
<code><a href="#topic+adana3">adana3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gmax &lt;- 1000
g &lt;- c(1, 10, 50, 100, 250, 500, 750, gmax)
adana1(g=g, gmax=gmax)
</code></pre>

<hr>
<h2 id='adana3'>
Dynamic mutation and crossover function (Adana 3)
</h2><span id='topic+adana3'></span>

<h3>Description</h3>

<p>This adaptation function proposed by Cebeci (2021) is an adaptation function that takes into account the cooperation of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adana3(fitvals, g, gmax, cxpc, mutpm,
                  adapc, adapd, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adana3_+3A_fitvals">fitvals</code></td>
<td>
<p>A vector. Fitness values of current generation</p>
</td></tr>
<tr><td><code id="adana3_+3A_g">g</code></td>
<td>
<p>Current generation</p>
</td></tr>
<tr><td><code id="adana3_+3A_gmax">gmax</code></td>
<td>
<p>Maximum generation</p>
</td></tr>
<tr><td><code id="adana3_+3A_cxpc">cxpc</code></td>
<td>
<p>Crossover rate. 0 &lt;= cxpc &lt;= 1</p>
</td></tr>
<tr><td><code id="adana3_+3A_mutpm">mutpm</code></td>
<td>
<p>Mutation  rate. 0 &lt;= mutpm &lt;= 1</p>
</td></tr>
<tr><td><code id="adana3_+3A_adapc">adapc</code></td>
<td>
<p>Adaptation threshold for crossover rate. 0 &lt;= adapa &lt;= 1. default is 0.05</p>
</td></tr>
<tr><td><code id="adana3_+3A_adapd">adapd</code></td>
<td>
<p>Adaptation threshold for mutation rate. 0 &lt;= adapb &lt;= 1. default is 0.05</p>
</td></tr>
<tr><td><code id="adana3_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pc</code></td>
<td>
<p>Crossover rate</p>
</td></tr>
<tr><td><code>pm</code></td>
<td>
<p>Mutation rate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Cebeci, Z. (2021). R ile Genetik Algoritmalar ve Optimizasyon Uygulamalari, 535 p. Ankara:Nobel Akademik Yayincilik. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixpcmut">fixpcmut</a></code>,
<code><a href="#topic+ilmdhc">ilmdhc</a></code>,
<code><a href="#topic+adana1">adana1</a></code>,
<code><a href="#topic+adana2">adana2</a></code>,
<code><a href="#topic+leitingzhi">leitingzhi</a></code>
</p>

<hr>
<h2 id='atc'>
Asymmetric Two-Point Crossover (ATC)
</h2><span id='topic+atc'></span>

<h3>Description</h3>

<p>The Asymmetric Two-Point Crossover (ATC) operator relies on the two-point crossover being implemented differently for Parent1 and Parent2 (Yuan, 2002). Offspring2 is generated by a standard two-point crossover. However, in the generation of Offspring1, the part between the cut points is taken from Parent2, while the other parts are completed from Parent1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atc(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="atc_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="atc_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="atc_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="atc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Yuan B. (2002). Deterministic crowding, recombination and self-similarity. In <em>Proc. of the 2002 Cong. on Evolutionary Computation</em> (Cat. No. 02TH8600) (Vol. 2, pp. 1516-1521). IEEE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
atc(parent1, parent2)
</code></pre>

<hr>
<h2 id='ax'>
Avarage Crossover
</h2><span id='topic+ax'></span>

<h3>Description</h3>

<p>The AX operator calculates the simple arithmetic mean of the parental chromosomes. Therefore, it is a single-output operator and generates a single offspring (Gwiazda, 2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ax(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ax_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="ax_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="ax_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="ax_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Gwiazda T.D. (2006). <em>Genetic Algorithms Reference</em>. Vol. I: Crossover for Single-Objective Numerical Optimization Problems. Tomaszgwiadze E-books, Poland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
ax(parent1, parent2, cxon=1)
</code></pre>

<hr>
<h2 id='bestsol'>Best solution monitoring function</h2><span id='topic+bestsol'></span>

<h3>Description</h3>

<p>Display best solution from result of GA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestsol(garesult)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bestsol_+3A_garesult">garesult</code></td>
<td>
<p>GA result object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Display chromosome, fitness value and generation number of best solution.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>

<hr>
<h2 id='bin2gray'>Convert from binary to gray code integer</h2><span id='topic+bin2gray'></span>

<h3>Description</h3>

<p>The function bin2gray converts a binary coded number to gray coded integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin2gray(bin)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bin2gray_+3A_bin">bin</code></td>
<td>
<p>A binary coded number. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bin2gray function works as a compliment of the gray2bin function.</p>


<h3>Value</h3>

<p>Returns the gray coded integer equivalent of the input number.</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gray2bin">gray2bin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  bin = c(1,0,1,1)
  bin2gray(bin)     # returns 1110
  
  bin = c(1,0,1,0)
  bin2gray(bin)     # returns 1111
</code></pre>

<hr>
<h2 id='bin2int'>Convert Binary Numbers to Integers</h2><span id='topic+bin2int'></span>

<h3>Description</h3>

<p>The function bin2int converts a binary coded number to integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin2int(bin)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bin2int_+3A_bin">bin</code></td>
<td>
<p>A binary coded number. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bin2int function works as a compliment of the int2bin function.</p>


<h3>Value</h3>

<p>Returns the integer equivalent of the input number.</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+int2bin">int2bin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1,1,1,1,1,0,1,0,0)
bin2int(x)  # returns 500
</code></pre>

<hr>
<h2 id='bitmut'>
Bit Flip Mutation
</h2><span id='topic+bitmut'></span>

<h3>Description</h3>

<p>The Bit Flip Mutation operator converts the bit at a randomly selected point to its allele.
</p>
<p>This operator is used on binary encoded chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bitmut(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bitmut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="bitmut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,
<code><a href="#topic+nunimut2">nunimut2</a></code>,  
<code><a href="#topic+powmut">powmut</a></code>,
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offspring = c(1,1,0,1,0,1,0,1,0,0)
bitmut(offspring)
</code></pre>

<hr>
<h2 id='blxa'>
Blended Crossover (BLX-<code class="reqn">\alpha</code>) 
</h2><span id='topic+blxa'></span>

<h3>Description</h3>

<p>Eshelman and Schaffer (1993) proposed an algorithm called Blended-<code class="reqn">\alpha</code> Crossover (BLX-<code class="reqn">\alpha</code>) by introducing the concept of interval scheme to be applied in real-valued problems (Takahashi &amp; Kita, 2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blxa(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blxa_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="blxa_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="blxa_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="blxa_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Eshelman, L.J. and Schaffer, J.D. (1993). Real-coded genetic algorithms and interval schemata. In <em>Foundations of Genetic Algorithms</em>, Vol. 2, pp. 187-202, Elsevier.
</p>
<p>Takahashi, M. and Kita, H. (2001). A crossover operator using independent component analysis for real-coded genetic algorithms. In <em>Proc. of the 2001 Cong. on Evolutionary Computation (IEEE Cat.No. 01TH8546)</em>, Vol. 1, pp. 643-649. IEEE.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ebeveyn1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
ebeveyn2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
blxa(ebeveyn1, ebeveyn2, cxon=3)
</code></pre>

<hr>
<h2 id='blxab'>
Blended crossover-<code class="reqn">\alpha\beta</code> (BLX-<code class="reqn">\alpha\beta</code>)
</h2><span id='topic+blxab'></span>

<h3>Description</h3>

<p>Blended crossover-<code class="reqn">\alpha\beta</code> is another version of the Blended crossover-<code class="reqn">\alpha</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blxab(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blxab_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="blxab_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="blxab_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="blxab_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
blxab(parent1, parent2)
</code></pre>

<hr>
<h2 id='boundmut'>
Boundary Mutation
</h2><span id='topic+boundmut'></span>

<h3>Description</h3>

<p>The Boundary Mutation operator is a mutation operator that changes the value of a randomly selected gene in the chromosome with the upper or lower limit value for that gene.
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundmut(y, lb, ub, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boundmut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="boundmut_+3A_lb">lb</code></td>
<td>
<p>A vector. Lower bounds of genes</p>
</td></tr>
<tr><td><code id="boundmut_+3A_ub">ub</code></td>
<td>
<p>A vector. Upper bounds of genes</p>
</td></tr>
<tr><td><code id="boundmut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,
<code><a href="#topic+nunimut2">nunimut2</a></code>,  
<code><a href="#topic+powmut">powmut</a></code>,
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(2, 1, 3, 1, 0, 4)
ub = c(10, 15, 8, 5, 6, 9)
offspring = c(8, 6, 4, 1, 3, 7)
boundmut(offspring, lb=lb, ub=ub)
</code></pre>

<hr>
<h2 id='bsearchmut1'>
Boundary Search Mutation 1
</h2><span id='topic+bsearchmut1'></span>

<h3>Description</h3>

<p>Boundary Search Mutation-1 is an algorithm based on probing the boundaries of the convenience region in constraint processing for NLP optimization (Michalewicz &amp; Schoenauer, 1996). Two genes are randomly selected from the chromosome and one of them is multiplied by a random factor at the q value, while the other gene is multiplied by <code class="reqn">1/q</code>.
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsearchmut1(y, mutq, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsearchmut1_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="bsearchmut1_+3A_mutq">mutq</code></td>
<td>
<p>A number. Value of q</p>
</td></tr>
<tr><td><code id="bsearchmut1_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>A vector. The numbers of the mutated genes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Michalewicz, Z. and Schoenauer, M. (1996). Evolutionary algorithms for constrained parameter optimization problems. <em>Evolutionary Computation</em>, 4(1), 1-32. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offspring = c(8, 6, 4, 1, 3)
#set.seed(12)
bsearchmut1(offspring)
mutq = 0.5
#set.seed(12)
bsearchmut1(offspring, mutq=mutq)
</code></pre>

<hr>
<h2 id='bsearchmut2'>
Boundary Search Mutation 2
</h2><span id='topic+bsearchmut2'></span>

<h3>Description</h3>

<p>Boundary Search Mutation-2 is an algorithm based on searching the convenience region boundaries in constraint processing for NLP optimization (Michalewicz &amp; Schoenauer, 1996). Two genes are randomly selected from the chromosome and one is multiplied by the random value p, while the other gene is multiplied by the q value calculated using p.
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsearchmut2(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsearchmut2_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="bsearchmut2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>A vector. The numbers of the mutated genes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Michalewicz, Z. and Schoenauer, M. (1996). Evolutionary algorithms for constrained parameter optimization problems. <em>Evolutionary Computation</em>, 4(1), 1-32. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offspring = c(8, 6, 4, 1, 3)
bsearchmut2(offspring)
</code></pre>

<hr>
<h2 id='bx'>
Box Crossover / Flat Crossover
</h2><span id='topic+bx'></span>

<h3>Description</h3>

<p>In the parent chromosomes, the randomly selected value between the minimum and maximum values of each gene is assigned as the value of that gene in the offspring chromosome (Herrera et.al, 1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bx(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="bx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="bx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="bx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Herrera, F., Lozano, M. and Verdegay J.L. (1998). Tackling real-coded genetic algorithms: Operators and tools for behavioural analysis. <em>Artificial Intelligence Review</em>, 12(4), 265-319. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
bx(parent1, parent2)
</code></pre>

<hr>
<h2 id='calcM'>
Calculate the number of bits in the binary representation of the integer vector
</h2><span id='topic+calcM'></span>

<h3>Description</h3>

<p>The function CalcM calculates the number of bits in the binary representation of the integer vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcM(ub, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcM_+3A_ub">ub</code></td>
<td>
<p>A vector containing upper bounds</p>
</td></tr>
<tr><td><code id="calcM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the upper bounds of the integer vector to calculate the number of bits in the binary representation of an integer vector.
</p>


<h3>Value</h3>

<p>A vector of the numbers of bits for binary representation of an integer vector.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+encode4int">encode4int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ub = c(10, 10, 10)
calcM(ub)
</code></pre>

<hr>
<h2 id='cpc'>
Count-preserving Crossover (CPC)
</h2><span id='topic+cpc'></span>

<h3>Description</h3>

<p>Count-preserving Crossover (CPC) is an operator that assumes the same number of chromosomes equal to 1 in each chromosome in the initial population and tries to preserve this number (Hartley &amp; Konstam, 1993; Gwiazda 2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpc(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpc_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="cpc_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="cpc_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="cpc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Hartley S.J. and Konstam A.H. (1993). Using genetic algorithms to generates Steiner triple systems. In <em>Proc. of the 1993 ACM Conf. on Computer Science</em> (pp. 366-371).
</p>
<p>Gwiazda T.D. (2006). <em>Genetic Algorithms Reference</em>. Vol. I: Crossover for Single-Objective Numerical Optimization Problems. Tomaszgwiadze E-books, Poland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
cpc(parent1, parent2)
</code></pre>

<hr>
<h2 id='cross'>
Crossover
</h2><span id='topic+cross'></span>

<h3>Description</h3>

<p>It is a wrapper function that calls crossover operators from a single function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross(crossfunc, matpool, cxon, cxpc, gatype, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cross_+3A_crossfunc">crossfunc</code></td>
<td>
<p>The name of the crossover operator</p>
</td></tr>
<tr><td><code id="cross_+3A_matpool">matpool</code></td>
<td>
<p>A matrix. Mating pool containing selected individuals.</p>
</td></tr>
<tr><td><code id="cross_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="cross_+3A_cxpc">cxpc</code></td>
<td>
<p>Crossover Ratio. Default value is 0.95</p>
</td></tr>
<tr><td><code id="cross_+3A_gatype">gatype</code></td>
<td>
<p>Indicates the GA type. &quot;gga&quot; is assigned for generational refresh, and &quot;ssga&quot; for steady-state refresh.</p>
</td></tr>
<tr><td><code id="cross_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Cebeci, Z. (2021). R ile Genetik Algoritmalar ve Optimizasyon Uygulamalari, 535 p. Ankara:Nobel Akademik Yayincilik.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genpop = initbin(12,8)                             #Initial population
m = ncol(genpop)-2                                 #Number of Gene
sumx = function(x, ...) (sum(x))                   #Fitness Function
fitvals = evaluate(fitfunc=sumx, genpop[,1:m])     #Fitness Values
genpop[,"fitval"] = fitvals
selidx = select(selfunc=selrws, fitvals)           #Selection of Parents
matpool = genpop[selidx,]                          #Mating Pool
offsprings = cross(crossfunc=px1, matpool=matpool, #Crossing
 cxon=2, cxpc=0.8, gatype="gga")
offsprings
offsprings = cross(crossfunc=kpx, matpool=matpool,
  cxon=2, cxpc=0.8, gatype="ssga", cxps=0.5, cxk=2)
offsprings
</code></pre>

<hr>
<h2 id='cx'>
Cycle Crossover (CX)
</h2><span id='topic+cx'></span>

<h3>Description</h3>

<p>The Cycle Crossover (CX) is an algorithm that considers the gene order in the parental chromosomes (Oliver et.al., 1987).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cx(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="cx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="cx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="cx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Oliver, I.M., Smith, D. and Holland J.R. (1987). Study of the permutation crossover operators on the traveler salesman problem. In <em>Grefenstette, J.J. (ed). Genetic Algorithms and Their Applications, Proc. of the 2nd Int. Conf</em>. Hillsdale, New Jersey: Lawrence Erlbaum, pp. 224-230. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 =c(9, 8, 2, 1, 7, 4, 5, 0, 6, 3)
parent2 =c(1, 2, 3, 4, 5, 6, 7, 8, 9, 0)
cx(parent1, parent2)
</code></pre>

<hr>
<h2 id='dc'>
Discrete Crossover
</h2><span id='topic+dc'></span>

<h3>Description</h3>

<p>The Discrete Crossover (DC) operator is an operator that swaps parent genes if a randomly selected value in the range [0,1] for each gene in the chromosome is greater than or equal to a given threshold value, and does not change if it is less than the threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc(x1, x2, cxon, cxps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dc_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="dc_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="dc_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="dc_+3A_cxps">cxps</code></td>
<td>
<p>Threshold value. 0 &lt;= cxps &lt;= 1</p>
</td></tr>
<tr><td><code id="dc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
dc(parent1, parent2, cxps=0.6)
</code></pre>

<hr>
<h2 id='decode'>
Convert from binary number to real number
</h2><span id='topic+decode'></span>

<h3>Description</h3>

<p>The function decode converts a binary number with m digits to a real number between the lower and upper bound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode(bin, lb, ub, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decode_+3A_bin">bin</code></td>
<td>
<p>A binary number</p>
</td></tr>
<tr><td><code id="decode_+3A_lb">lb</code></td>
<td>
<p>Lower bound of real number</p>
</td></tr>
<tr><td><code id="decode_+3A_ub">ub</code></td>
<td>
<p>Upper bound of real number</p>
</td></tr>
<tr><td><code id="decode_+3A_m">m</code></td>
<td>
<p>Number of the digits of output value.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>This function converts a binary number with m digits to its real equivalent expressed in the range [lb, ub].
</p>


<h3>Value</h3>

<p>Returns the real equivalent of the input number.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+encode">encode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(0,1,0,0,0,0,1,1)
decode(x, lb=50, ub=250, m=8)
</code></pre>

<hr>
<h2 id='decode4int'>
Convert binary vectors to integer vectors
</h2><span id='topic+decode4int'></span>

<h3>Description</h3>

<p>The function decode4int converts each element in a given binary vector to a integer number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode4int(x, M, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decode4int_+3A_x">x</code></td>
<td>
<p>A vector containing binary numbers</p>
</td></tr>
<tr><td><code id="decode4int_+3A_m">M</code></td>
<td>
<p>A vector containing the number of bits of each binary in the x.</p>
</td></tr>
<tr><td><code id="decode4int_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts each element in the binary vector passed with the x argument to an integer. The M argument refers to the number of bits of each binary in the x vector.
</p>


<h3>Value</h3>

<p>A vector of integer for input binary vector 
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+encode4int">encode4int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>binmat = c(0,0,1,1,1,0,0,1,0,0,1,0)
M = c(4,4,4)
intmat = decode4int(binmat, M=M)
intmat
</code></pre>

<hr>
<h2 id='decodepop'>
Convert binary number matrix to real number matrix
</h2><span id='topic+decodepop'></span>

<h3>Description</h3>

<p>The decodepop function generates  a real-valued population from a population encoded with binary representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decodepop(x, lb, ub, m,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decodepop_+3A_x">x</code></td>
<td>
<p>A vector containing binary numbers</p>
</td></tr>
<tr><td><code id="decodepop_+3A_lb">lb</code></td>
<td>
<p>A vector containing lower bounds for variables</p>
</td></tr>
<tr><td><code id="decodepop_+3A_ub">ub</code></td>
<td>
<p>A vector containing upper bounds for variables</p>
</td></tr>
<tr><td><code id="decodepop_+3A_m">m</code></td>
<td>
<p>Length for each variable</p>
</td></tr>
<tr><td><code id="decodepop_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real-valued matrix
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+encodepop">encodepop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(2.5, -2, 0)
ub = c(4.3, 2, 1.5)
eps = c(0.1, 1, 0.01)
#d = nchar(sub('^+','',sub("\.",'',eps)))-1

d = grep('.', strsplit(as.character(eps), '')[[1]])-1
x = round(runif(5, lb[1],ub[1]),d[1])
y = round(runif(5, lb[2],ub[2]),d[2])
w = round(runif(5, lb[3],ub[3]),d[3])
pop = cbind(x, y, w)
pop    
encpop = encodepop(pop, lb=lb, ub=ub, eps=eps)
pop = encpop$binmat 
m = encpop$m
decpop = decodepop(pop, lb=lb, ub=ub, m=m)
decpop
for(j in 1:ncol(decpop)) decpop[,j]=round(decpop[,j], d[j])
decpop
</code></pre>

<hr>
<h2 id='disc'>
Disrespectful Crossover (DISC)
</h2><span id='topic+disc'></span>

<h3>Description</h3>

<p>Disrespectful Crossover (DISC) is an operator that breaks down similarities or reinforces differences in parental chromosomes (Watson &amp; Pollack, 2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disc(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disc_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="disc_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="disc_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="disc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Watson R.A. and Pollack J.B. (2000). Recombination without respect: Schema combination and disruption in genetic algorithm crossover. In <em>Proc. of the 2nd Annual Conf. on Genetic and Evolutionary Computation</em> (pp. 112-119). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
disc(parent1, parent2)
</code></pre>

<hr>
<h2 id='dismut'>
Displacement mutation
</h2><span id='topic+dismut'></span>

<h3>Description</h3>

<p>The Displacement mutation cuts the genes between two randomly determined cut-points from the chromosome as a subset and then inserts them, starting from a randomly selected location (Michalewicz, 1992). 
</p>
<p>This operator is used in problems with permutation encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dismut(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dismut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="dismut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutrange</code></td>
<td>
<p>A vector. The numbers of begining and ending of the mutated genes.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The number of insertation location.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Michalewicz, Z. (1992). <em>Genetic Algorithms + Data Structures = Evolution Programs</em>. Berlin-Heidelberg: Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,        
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,   
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offspring = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
dismut(offspring)
</code></pre>

<hr>
<h2 id='ebx'>
Extended Box Crossover
</h2><span id='topic+ebx'></span>

<h3>Description</h3>

<p>Extended Box Crossover (EBX) was proposed by Yoon and Kim (2012) as the more advanced form of Box Crossover (BX). In the EBX operator, the minimum and maximum values are weighted by an alpha factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebx(x1, x2, lb, ub, cxon, cxalfa, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ebx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="ebx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="ebx_+3A_lb">lb</code></td>
<td>
<p>A vector. Lower bounds of each gene in the chromosomes.</p>
</td></tr>
<tr><td><code id="ebx_+3A_ub">ub</code></td>
<td>
<p>A vector. Upper bounds of each gene in the chromosomes.</p>
</td></tr>
<tr><td><code id="ebx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="ebx_+3A_cxalfa">cxalfa</code></td>
<td>
<p>A vector. Alpha value for each gene in the chromosomes. If no value is entered, they are randomly selected by the function in the range [0,1].</p>
</td></tr>
<tr><td><code id="ebx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Yoon, Y. and Kim, Y.H. (2012). The roles of crossover and mutation in real-coded genetic algorithms. In <em>Bioinspired Computational Algorithms anf Their Applications (ed. S. Gao)</em>, London: INTECH Open Acces Publisher. pp. 65-82.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(0, 0, 0, 0, 0, 0)
ub = c(2, 3, 1, 2, 4, 3)
parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
ebx(parent1, parent2, lb, ub)
</code></pre>

<hr>
<h2 id='eclc'>
Exchange/Linkage Crossover (EC,LC)
</h2><span id='topic+eclc'></span>

<h3>Description</h3>

<p>Linkage Crossover (LC) is an operator based on the repositioning of a randomly selected fragment from one of the parents, starting from a randomly selected location in the offspring chromosome (Harik &amp; Goldberg, 1997). It is also called Exchange Crossover (EC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eclc(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eclc_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="eclc_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="eclc_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="eclc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Harik, G.D. and Goldberg, D.E. (1997). Learning linkage. <em>Foundation of Genetic Algorithms</em> Ch. 4, Morgan-Kaufmann. pp. 247-262. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
eclc(parent1, parent2)
</code></pre>

<hr>
<h2 id='elitism'>
Elistist Replacement (Elitism) Function
</h2><span id='topic+elitism'></span>

<h3>Description</h3>

<p>The reproduction of individuals with the highest fitness is called elitism. The elitism operator copies a certain number of individuals into the new population. Other individuals are selected from among the offspring in proportion to their fitness values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elitism(parpop, offpop, reps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elitism_+3A_parpop">parpop</code></td>
<td>
<p>A matrix. Parent population</p>
</td></tr>
<tr><td><code id="elitism_+3A_offpop">offpop</code></td>
<td>
<p>A matrix. Offspring population</p>
</td></tr>
<tr><td><code id="elitism_+3A_reps">reps</code></td>
<td>
<p>Number of elite individuals</p>
</td></tr>
<tr><td><code id="elitism_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the new generation.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grdelall">grdelall</a></code>,
<code><a href="#topic+grmuplambda">grmuplambda</a></code>, 
<code><a href="#topic+grmuplambda2">grmuplambda2</a></code>, 
<code><a href="#topic+grmuplambda3">grmuplambda3</a></code>, 
<code><a href="#topic+grmuplambda4">grmuplambda4</a></code>, 
<code><a href="#topic+grmuvlambda">grmuvlambda</a></code>, 
<code><a href="#topic+grrobin">grrobin</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrgenitor">ssrgenitor</a></code>, 
<code><a href="#topic+ssrfamtour">ssrfamtour</a></code>, 
<code><a href="#topic+ssrx">ssrx</a></code>
</p>

<hr>
<h2 id='elx'>
Extended-Line Crossover (ELX)
</h2><span id='topic+elx'></span>

<h3>Description</h3>

<p>With the Extended-Line Crossover (ELX) operator, offspring are generated on a line determined by the variable values in the parental chromosomes. ELX identifies the possible line from which offspring can be generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elx(x1, x2, lb, ub, cxon, cxealfa, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="elx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="elx_+3A_lb">lb</code></td>
<td>
<p>A vector. Lower bounds of each gene in the chromosomes.</p>
</td></tr>
<tr><td><code id="elx_+3A_ub">ub</code></td>
<td>
<p>A vector. Upper bounds of each gene in the chromosomes.</p>
</td></tr>
<tr><td><code id="elx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="elx_+3A_cxealfa">cxealfa</code></td>
<td>
<p>A number. Expansion rate </p>
</td></tr>
<tr><td><code id="elx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(0, 0, 0, 0, 0, 0)
ub = c(2, 3, 1, 2, 4, 3)
parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
elx(parent1, parent2, lb, ub, cxealfa=1000)
</code></pre>

<hr>
<h2 id='encode'>
Convert from real number to binary number
</h2><span id='topic+encode'></span>

<h3>Description</h3>

<p>The function encode converts a real number to a binary number with m digits between the given lower bound and upper bound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode(real, lb, ub, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="encode_+3A_real">real</code></td>
<td>
<p>A real number</p>
</td></tr>
<tr><td><code id="encode_+3A_lb">lb</code></td>
<td>
<p>Lower bound of real number</p>
</td></tr>
<tr><td><code id="encode_+3A_ub">ub</code></td>
<td>
<p>Upper bound of real number</p>
</td></tr>
<tr><td><code id="encode_+3A_m">m</code></td>
<td>
<p>Number of the digits of output value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a real number to its binary equivalent expressed in m digits in the range [lb, ub].
</p>


<h3>Value</h3>

<p>Returns the binary equivalent of the input number.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decode">decode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = 102.5
encode(x, lb=50, ub=250, m=8)
</code></pre>

<hr>
<h2 id='encode4int'>
Convert integer vectors to binary vectors
</h2><span id='topic+encode4int'></span>

<h3>Description</h3>

<p>The function encode4int converts each element in a given integer vector to a binary number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode4int(x, M, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="encode4int_+3A_x">x</code></td>
<td>
<p>A vector containing integer numbers</p>
</td></tr>
<tr><td><code id="encode4int_+3A_m">M</code></td>
<td>
<p>A vector containing the number of bits in the binary representation of each integer variable.</p>
</td></tr>
<tr><td><code id="encode4int_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts each element in the integer vector passed with the x argument to a binary number. The M argument refers to the number of bits in the binary representation of each integer variable.
</p>


<h3>Value</h3>

<p>A vector of binary representation of input vector 
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decode4int">decode4int</a></code>,
<code><a href="#topic+calcM">calcM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 5
lb = c(0, 0, 0)
ub = c(10, 10, 10)
set.seed(1)
intmat = matrix(round(runif(3*n, lb, ub)), nr=n, nc=3) 
colnames(intmat) = paste0("v",1:3)
head(intmat)
M = calcM(ub)
M
binmat = matrix(NA, nrow=n, ncol=sum(M))
for(i in 1:n)
  binmat[i,] = encode4int(intmat[i,], M=M)
head(binmat)
</code></pre>

<hr>
<h2 id='encodepop'>
Binary encoding of real number matrix
</h2><span id='topic+encodepop'></span>

<h3>Description</h3>

<p>The encodepop function generates a population encoded with binary representation from a real-valued population given as a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encodepop(x, lb, ub, eps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="encodepop_+3A_x">x</code></td>
<td>
<p>A vector containing real numbers</p>
</td></tr>
<tr><td><code id="encodepop_+3A_lb">lb</code></td>
<td>
<p>A vector containing lower bounds for variables</p>
</td></tr>
<tr><td><code id="encodepop_+3A_ub">ub</code></td>
<td>
<p>A vector containing upper bounds for variables</p>
</td></tr>
<tr><td><code id="encodepop_+3A_eps">eps</code></td>
<td>
<p>Sensitivity vector containing desired sensitivity values for each variable</p>
</td></tr>
<tr><td><code id="encodepop_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>binmat</code></td>
<td>
<p>A binary coded matrix as counterpart of real-valued input matrix</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>A vector containing bit length of each variable</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decodepop">decodepop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(2.5, -2, 0)
ub = c(4.3, 2, 1.5)
eps = c(0.1, 1, 0.01)
#d = nchar(sub('^+','',sub("\.",'',eps)))-1
d = grep('.', strsplit(as.character(eps), '')[[1]])-1
x = round(runif(5, lb[1],ub[1]),d[1])
y = round(runif(5, lb[2],ub[2]),d[2])
w = round(runif(5, lb[3],ub[3]),d[3])
pop = cbind(x, y, w)
pop
encpop = encodepop(pop, lb, ub, eps)
head(encpop$binmat[,1:10])
m = encpop$m
m
</code></pre>

<hr>
<h2 id='erx'>
Edge Recombination Crossover (ERX)
</h2><span id='topic+erx'></span>

<h3>Description</h3>

<p>The Edge Recombination Crossover (ERX) operator ignores outbound directions, that is, it evaluates a chromosome with an undirected edge loop (Whitley et.al., 1989). This operator is based on the concept of neighborhood, as the main idea is to prioritize the edges common to both parents when creating offspring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erx(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="erx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="erx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="erx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="erx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Whitley, L.D., Starkweather, T. and D'Ann, F. (1989). Scheduling problems and traveling salesman: the genetic edge recombination operator. In <em>Proc. of ICGA</em>, Vol. 89, pp. 133-40.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 3, 5, 6, 4, 2, 8, 7)
parent2 = c(1, 4, 2, 3, 6, 5, 7, 8)
erx(parent1, parent2, cxon=2)
</code></pre>

<hr>
<h2 id='evaluate'>
Calculate the fitness values of population
</h2><span id='topic+evaluate'></span>

<h3>Description</h3>

<p>Calculates the fitness value of a population using the fitness function given with the fitfunc argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate(fitfunc, population, objective, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_+3A_fitfunc">fitfunc</code></td>
<td>
<p>Fitness function</p>
</td></tr>
<tr><td><code id="evaluate_+3A_population">population</code></td>
<td>
<p>Population matrix</p>
</td></tr>
<tr><td><code id="evaluate_+3A_objective">objective</code></td>
<td>
<p>&ldquo;max&rdquo; or &ldquo;min&rdquo;</p>
</td></tr>
<tr><td><code id="evaluate_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of fitness values for each induvidual in population.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>population = initbin()
head(population, 5)
m = ncol(population)-2
fitvals = evaluate(maxone, population[,1:m], objective="max")
head(fitvals, 5)
</code></pre>

<hr>
<h2 id='findoptima'>Finds peaks and valleys on the curve of a function with single variable</h2><span id='topic+findoptima'></span>

<h3>Description</h3>

<p>This function finds the peaks and valleys on the curve of user-defined functions with one variable. 
The function also plots the function curve that can be used to demonstrate the points for local optima and 
global optimum in a optimization problem. </p>


<h3>Usage</h3>

<pre><code class='language-R'>findoptima(x, type="max", pflag=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findoptima_+3A_x">x</code></td>
<td>
<p>a vector of variable</p>
</td></tr>
<tr><td><code id="findoptima_+3A_type">type</code></td>
<td>
<p>Either &ldquo;max&rdquo; (the default) or &ldquo;min&rdquo;. The peaks are 
found when <code>type="max"</code> and the valleys are found
when <code>type="max"</code>.</p>
</td></tr>
<tr><td><code id="findoptima_+3A_pflag">pflag</code></td>
<td>
<p>if this is TRUE, the first and last values are also checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The findoptima function finds all the peaks and valleys in a given function curve. The points can be colorized with different colors. See the example below.
</p>


<h3>Value</h3>

<p>Returns a vector of indices of the peaks or valleys on the function curve.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Cebeci Z. (2021). <em>R ile Genetik Algoritmalar ve Optimizasyon Uygulamalari</em>. Ankara:Nobel Akademik Yayincilik</p>


<h3>Examples</h3>

<pre><code class='language-R'>fx &lt;- function(x) -sin(x)-sin(2*x)-cos(3*x) + 3
x &lt;- seq(-2*pi, 2*pi, by=0.001)
curve(fx, x)
cr &lt;- curve(fx, x, lwd=2)
xy &lt;- cbind(cr$x, cr$y)
peaks &lt;- findoptima(cr$y, type = "max")
valleys &lt;- findoptima(cr$y, type = "min")

## Finds peaks and valleys
peaks &lt;- findoptima(cr$y, type="max")
valleys &lt;-  findoptima(cr$y, type="min")

## Plotting the function curve and local optima and global optimum
points(xy[peaks,], pch=19, cex=1.2, col=2)
points(xy[valleys,], pch=18, cex=1.2, col=4)
gmin &lt;- valleys[which.min(xy[valleys,2])]
gmax &lt;- peaks[which.min(xy[valleys,2])]
points(xy[gmax,1], xy[gmax,2], pch=19, cex=2, col=2)
points(xy[gmin,1], xy[gmin,2], pch=18, cex=2, col=4)
text(xy[gmax,1], xy[gmax,2], labels="Glob.Max", pos=2, cex=0.8, col=1)
text(xy[gmin,1], xy[gmin,2], labels="Glob.Min", pos=2, cex=0.8, col=1)
</code></pre>

<hr>
<h2 id='fixpcmut'>
Static crossover and mutation rate
</h2><span id='topic+fixpcmut'></span>

<h3>Description</h3>

<p>The function is used when the crossover and mutation rates are not changed throughout the GA run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixpcmut(cxpc, mutpm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixpcmut_+3A_cxpc">cxpc</code></td>
<td>
<p>Crossover rate</p>
</td></tr>
<tr><td><code id="fixpcmut_+3A_mutpm">mutpm</code></td>
<td>
<p>Mutation rate</p>
</td></tr>
<tr><td><code id="fixpcmut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pc</code></td>
<td>
<p>Crossover rate</p>
</td></tr>
<tr><td><code>pm</code></td>
<td>
<p>Mutation rate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ilmdhc">ilmdhc</a></code>,
<code><a href="#topic+adana1">adana1</a></code>,
<code><a href="#topic+adana2">adana2</a></code>,
<code><a href="#topic+leitingzhi">leitingzhi</a></code>,
<code><a href="#topic+adana3">adana3</a></code>
</p>

<hr>
<h2 id='gaussmut'>
Gauss Mutation
</h2><span id='topic+gaussmut'></span>

<h3>Description</h3>

<p>Gauss Mutation is an operator made by adding randomly selected values from a normal distribution with a mean of 0 and a standard deviation of sigma to a randomly selected gene in the chromosome (Michalewicz, 1995; Back et.al., 1991; Fogel, 1995).
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussmut(y, mutsdy, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussmut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="gaussmut_+3A_mutsdy">mutsdy</code></td>
<td>
<p>A vector. Vector of standard deviations of genes</p>
</td></tr>
<tr><td><code id="gaussmut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Michalewicz, Z. (1995). Genetic algorithms, numerical optimizations and constraints. In  <em>Proc. of the 6th. Int. Conf. on Genetic Algorithms</em>, pp. 151-158. Morgan Kaufmann.
</p>
<p>Back, T., Hoffmeister, F. and Schwefel, H.F. (1991). A survey of elolution strategies. In <em>Proc. of the 4th. Int. Conf. on Genetic Algorithms (eds. R.K. Belew and L.B. Booker)</em>, pp. 2-9. Morgan Kaufmann.
</p>
<p>Fogel D.B. (1995). Evolutionary computation. Toward a new philosophy of machine intellegence. Piscataway, NJ: IEEE Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mutsdy = c(1, 1.5, 1.01, 0.4, 1.5, 1.2)
offspring = c(8, 6, 4, 1, 3, 7)
set.seed(12)
gaussmut(offspring)
</code></pre>

<hr>
<h2 id='gaussmut2'>
Gauss Mutation 2
</h2><span id='topic+gaussmut2'></span>

<h3>Description</h3>

<p>Gauss Mutation-2 is an operator by adding a randomly selected value from the standard normal distribution to a randomly selected gene in the chromosome.
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussmut2(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussmut2_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="gaussmut2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offspring = c(8, 6, 4, 1, 3, 7)
set.seed(12)
gaussmut2(offspring)
</code></pre>

<hr>
<h2 id='gaussmut3'>
Gauss Mutation 3
</h2><span id='topic+gaussmut3'></span>

<h3>Description</h3>

<p>GM is an operator made by adding randomly selected values from a normal distribution with mean and standard deviation of MU and SIGMA, respectively, to a randomly selected gene in the chromosome.
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussmut3(y, mutmy, mutsdy, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussmut3_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="gaussmut3_+3A_mutmy">mutmy</code></td>
<td>
<p>A vector. Vector of means of genes</p>
</td></tr>
<tr><td><code id="gaussmut3_+3A_mutsdy">mutsdy</code></td>
<td>
<p>A vector. Vector of standard deviations of genes</p>
</td></tr>
<tr><td><code id="gaussmut3_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mutmy = c(5, 5, 2, 4, 3, 4)
mutsdy = c(1, 1.5, 1.01, 0.4, 1.5, 1.2)
offspring = c(8, 6, 4, 1, 3, 7)
set.seed(12)
gaussmut(offspring, mutmy=mutmy, mutsdy=mutsdy)
</code></pre>

<hr>
<h2 id='geomx'>
Geometric Crossover
</h2><span id='topic+geomx'></span>

<h3>Description</h3>

<p>Geometric Crossover is used to search for applicable region boundaries in constraint processing in NLP problems (Michalewicz &amp; Schoenauer, 1996). It generates one offspring per each cross.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geomx(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geomx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="geomx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="geomx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="geomx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Michalewicz, Z. and Schoenauer, M. (1996). Evolutionary Algorithms for constrained parameter optimization problems. <em>Evoltionary Computation</em>, 4(1), 1-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
geomx(parent1, parent2)
</code></pre>

<hr>
<h2 id='gray2bin'>
Convert gray code to binary integer #1
</h2><span id='topic+gray2bin'></span>

<h3>Description</h3>

<p>The function gray2bin converts gray coded integer to a binary coded number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gray2bin(gray)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gray2bin_+3A_gray">gray</code></td>
<td>
<p> A gray coded number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gray2bin function works as a compliment of the bin2gray function.
</p>


<h3>Value</h3>

<p>Returns the binary coded integer equivalent of the input number.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bin2gray">bin2gray</a></code>,
<code><a href="#topic+gray2bin2">gray2bin2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gray = c(1,1,1,0)
gray2bin(gray)       # returns 1011
gray = c(1,1,1,1)
gray2bin(gray)       # returns 1010
</code></pre>

<hr>
<h2 id='gray2bin2'>
Convert gray code to binary integer #2
</h2><span id='topic+gray2bin2'></span>

<h3>Description</h3>

<p>The function gray2bin2 converts a gray-coded integer to a binary-coded number. 
The conversion function is performed according to the algorithm given by Chakraborty and Janikov (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gray2bin2(gray)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gray2bin2_+3A_gray">gray</code></td>
<td>
<p>A gray coded number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To convert gray coded numbers to binary numbers, a conversion function is defined using the algorithm given by Chakraborty and Janikov (2003). This function is a generic function that does not use the xor operator.
</p>


<h3>Value</h3>

<p>Returns the binary coded integer equivalent of the input number.</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Chakraborty, U.K., and Janikow C.Z. (2003). An analysis of Gray versus binary encoding in genetic search. Information Sciences, 156 (3-4), 253-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bin2gray">bin2gray</a></code>,
<code><a href="#topic+gray2bin">gray2bin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gray = c(1,1,1,0) 
gray2bin2(gray)       # returns 1011

gray = c(1,1,1,1)
gray2bin2(gray)       # returns 1010

</code></pre>

<hr>
<h2 id='grdelall'>
Delete-All Replacement
</h2><span id='topic+grdelall'></span>

<h3>Description</h3>

<p>All members of the current population are deleted, the new population is created entirely from offspring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grdelall(parpop, offpop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grdelall_+3A_parpop">parpop</code></td>
<td>
<p>A matrix. Parent population</p>
</td></tr>
<tr><td><code id="grdelall_+3A_offpop">offpop</code></td>
<td>
<p>A matrix. Offspring population</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the new generation.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elitism">elitism</a></code>,
<code><a href="#topic+grmuplambda">grmuplambda</a></code>, 
<code><a href="#topic+grmuplambda2">grmuplambda2</a></code>, 
<code><a href="#topic+grmuplambda3">grmuplambda3</a></code>, 
<code><a href="#topic+grmuplambda4">grmuplambda4</a></code>, 
<code><a href="#topic+grmuvlambda">grmuvlambda</a></code>, 
<code><a href="#topic+grrobin">grrobin</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrgenitor">ssrgenitor</a></code>, 
<code><a href="#topic+ssrfamtour">ssrfamtour</a></code>, 
<code><a href="#topic+ssrx">ssrx</a></code>
</p>

<hr>
<h2 id='grmuplambda'>
Mu+Lambda replacement function 1
</h2><span id='topic+grmuplambda'></span>

<h3>Description</h3>

<p>The Mu+Lamda replacement is based on the selection of the fittest parents and offspring as individuals of the new generation population (Smith et.al., 1999; Jenkins et.al., 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grmuplambda(parpop, offpop, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grmuplambda_+3A_parpop">parpop</code></td>
<td>
<p>A matrix. Parent population</p>
</td></tr>
<tr><td><code id="grmuplambda_+3A_offpop">offpop</code></td>
<td>
<p>A matrix. Offspring population</p>
</td></tr>
<tr><td><code id="grmuplambda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the new generation.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Smith, A.E. and Vavak F. (1999). Replacement strategies in steady state genetic algorithms: Static environments. <em>Foundations of Genetic Algorithms</em>. pp. 499-505.
</p>
<p>Jenkins, A., Gupta, V., Myrick, A. and Lenoir, M. (2019). Variations of Genetic Algorithms. <em>arXiv preprint arXiv:1911.00490</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grdelall">grdelall</a></code>,
<code><a href="#topic+elitism">elitism</a></code>, 
<code><a href="#topic+grmuplambda2">grmuplambda2</a></code>, 
<code><a href="#topic+grmuplambda3">grmuplambda3</a></code>, 
<code><a href="#topic+grmuplambda4">grmuplambda4</a></code>, 
<code><a href="#topic+grmuvlambda">grmuvlambda</a></code>, 
<code><a href="#topic+grrobin">grrobin</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrgenitor">ssrgenitor</a></code>, 
<code><a href="#topic+ssrfamtour">ssrfamtour</a></code>, 
<code><a href="#topic+ssrx">ssrx</a></code>
</p>

<hr>
<h2 id='grmuplambda2'>
Mu+Lambda replacement function 2 (delete the worst <code class="reqn">\lambda</code>)
</h2><span id='topic+grmuplambda2'></span>

<h3>Description</h3>

<p>Parents and offspring are ranked separately according to their compatibility among themselves. Then <code class="reqn">\lambda</code> offspring with the best fitness value is replaced by <code class="reqn">\lambda</code> parent with the worst fitness value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grmuplambda2(parpop, offpop, lambda, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grmuplambda2_+3A_parpop">parpop</code></td>
<td>
<p>A matrix. Parent population</p>
</td></tr>
<tr><td><code id="grmuplambda2_+3A_offpop">offpop</code></td>
<td>
<p>A matrix. Offspring population</p>
</td></tr>
<tr><td><code id="grmuplambda2_+3A_lambda">lambda</code></td>
<td>
<p>Number of individuals renewed in the population</p>
</td></tr>
<tr><td><code id="grmuplambda2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the new generation.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grdelall">grdelall</a></code>,
<code><a href="#topic+elitism">elitism</a></code>, 
<code><a href="#topic+grmuplambda">grmuplambda</a></code>, 
<code><a href="#topic+grmuplambda3">grmuplambda3</a></code>, 
<code><a href="#topic+grmuplambda4">grmuplambda4</a></code>, 
<code><a href="#topic+grmuvlambda">grmuvlambda</a></code>, 
<code><a href="#topic+grrobin">grrobin</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrgenitor">ssrgenitor</a></code>, 
<code><a href="#topic+ssrfamtour">ssrfamtour</a></code>, 
<code><a href="#topic+ssrx">ssrx</a></code>
</p>

<hr>
<h2 id='grmuplambda3'>
Mu+Lambda replacement function 3 
</h2><span id='topic+grmuplambda3'></span>

<h3>Description</h3>

<p>After the offspring are ranked according to their fitness values, the <code class="reqn">\lambda</code> best fit offspring are replaced by <code class="reqn">\lambda</code> parents randomly selected from the current parent population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grmuplambda3(parpop, offpop, lambda, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grmuplambda3_+3A_parpop">parpop</code></td>
<td>
<p>A matrix. Parent population</p>
</td></tr>
<tr><td><code id="grmuplambda3_+3A_offpop">offpop</code></td>
<td>
<p>A matrix. Offspring population</p>
</td></tr>
<tr><td><code id="grmuplambda3_+3A_lambda">lambda</code></td>
<td>
<p>Number of individuals renewed in the population</p>
</td></tr>
<tr><td><code id="grmuplambda3_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the new generation.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grdelall">grdelall</a></code>,
<code><a href="#topic+elitism">elitism</a></code>, 
<code><a href="#topic+grmuplambda">grmuplambda</a></code>, 
<code><a href="#topic+grmuplambda2">grmuplambda2</a></code>, 
<code><a href="#topic+grmuplambda4">grmuplambda4</a></code>, 
<code><a href="#topic+grmuvlambda">grmuvlambda</a></code>, 
<code><a href="#topic+grrobin">grrobin</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrgenitor">ssrgenitor</a></code>, 
<code><a href="#topic+ssrfamtour">ssrfamtour</a></code>, 
<code><a href="#topic+ssrx">ssrx</a></code></p>

<hr>
<h2 id='grmuplambda4'>
Mu+Lambda replacement function 4 
</h2><span id='topic+grmuplambda4'></span>

<h3>Description</h3>

<p>In the current population, randomly selected <code class="reqn">\lambda</code> parents are replaced by randomly selected <code class="reqn">\lambda</code> offspring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grmuplambda4(parpop, offpop, lambda, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grmuplambda4_+3A_parpop">parpop</code></td>
<td>
<p>A matrix. Parent population</p>
</td></tr>
<tr><td><code id="grmuplambda4_+3A_offpop">offpop</code></td>
<td>
<p>A matrix. Offspring population</p>
</td></tr>
<tr><td><code id="grmuplambda4_+3A_lambda">lambda</code></td>
<td>
<p>Number of individuals renewed in the population</p>
</td></tr>
<tr><td><code id="grmuplambda4_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the new generation.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grdelall">grdelall</a></code>,
<code><a href="#topic+elitism">elitism</a></code>, 
<code><a href="#topic+grmuplambda">grmuplambda</a></code>, 
<code><a href="#topic+grmuplambda2">grmuplambda2</a></code>, 
<code><a href="#topic+grmuplambda3">grmuplambda3</a></code>, 
<code><a href="#topic+grmuvlambda">grmuvlambda</a></code>, 
<code><a href="#topic+grrobin">grrobin</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrgenitor">ssrgenitor</a></code>, 
<code><a href="#topic+ssrfamtour">ssrfamtour</a></code>, 
<code><a href="#topic+ssrx">ssrx</a></code>
</p>

<hr>
<h2 id='grmuvlambda'>
Mu &amp; Lambda Replacement Function
</h2><span id='topic+grmuvlambda'></span>

<h3>Description</h3>

<p>In this renewal strategy, after the offspring are ranked according to their fitness values, the number of the population of the offspring with the best fitness value is replaced by the parents (Schwefel, 1981). To use this renewal algorithm, it is necessary to produce many more offspring than the population count.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grmuvlambda(parpop, offpop, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grmuvlambda_+3A_parpop">parpop</code></td>
<td>
<p>A matrix. Parent population</p>
</td></tr>
<tr><td><code id="grmuvlambda_+3A_offpop">offpop</code></td>
<td>
<p>A matrix. Offspring population</p>
</td></tr>
<tr><td><code id="grmuvlambda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the new generation.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grdelall">grdelall</a></code>,
<code><a href="#topic+elitism">elitism</a></code>, 
<code><a href="#topic+grmuplambda">grmuplambda</a></code>, 
<code><a href="#topic+grmuplambda2">grmuplambda2</a></code>, 
<code><a href="#topic+grmuplambda3">grmuplambda3</a></code>, 
<code><a href="#topic+grmuplambda4">grmuplambda4</a></code>, 
<code><a href="#topic+grrobin">grrobin</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrgenitor">ssrgenitor</a></code>, 
<code><a href="#topic+ssrfamtour">ssrfamtour</a></code>, 
<code><a href="#topic+ssrx">ssrx</a></code>
</p>

<hr>
<h2 id='grrobin'>
Round Robin Replacement Function
</h2><span id='topic+grrobin'></span>

<h3>Description</h3>

<p>The parent and offspring populations are combined. Then, each individual in the combined population is compared with k randomly selected individuals. In these double tournaments, if an individual has higher fitness than the individual they are compared to, +1 point is obtained. The new population is created from the individuals with the highest score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grrobin(parpop, offpop, repk, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grrobin_+3A_parpop">parpop</code></td>
<td>
<p>A matrix. Parent population</p>
</td></tr>
<tr><td><code id="grrobin_+3A_offpop">offpop</code></td>
<td>
<p>A matrix. Offspring population</p>
</td></tr>
<tr><td><code id="grrobin_+3A_repk">repk</code></td>
<td>
<p>Number of Comparisons</p>
</td></tr>
<tr><td><code id="grrobin_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the new generation.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grdelall">grdelall</a></code>,
<code><a href="#topic+elitism">elitism</a></code>, 
<code><a href="#topic+grmuplambda">grmuplambda</a></code>, 
<code><a href="#topic+grmuplambda2">grmuplambda2</a></code>, 
<code><a href="#topic+grmuplambda3">grmuplambda3</a></code>, 
<code><a href="#topic+grmuplambda4">grmuplambda4</a></code>, 
<code><a href="#topic+grmuvlambda">grmuvlambda</a></code>, 
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrgenitor">ssrgenitor</a></code>, 
<code><a href="#topic+ssrfamtour">ssrfamtour</a></code>, 
<code><a href="#topic+ssrx">ssrx</a></code>
</p>

<hr>
<h2 id='hc'>
Heuristic Crossover
</h2><span id='topic+hc'></span>

<h3>Description</h3>

<p>The Heuristic Crossover (HC) operator is a conditional operator (Herrera et.al, 1998; Umbarkar &amp; Sheth, 2005). A random r value is generated in the range [0,1]. Then if Parent2's fitness value is greater than or equal to Parent1's fitness value, the difference between them is weighted by r and added to Parent2. It is subtracted in minimization problems. This operator produces a single offspring, but due to the random value of r, repeated offspring may result in different offspring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hc(x1, x2, fitfunc, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hc_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="hc_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="hc_+3A_fitfunc">fitfunc</code></td>
<td>
<p>Fitness Function</p>
</td></tr>
<tr><td><code id="hc_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="hc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Herrera, F., Lozano, M. and Verdegay, J.L. (1998). Tackling real-coded genetic algorithms: Operators and tools for behavioural analysis. <em>Artificial Intellegence Review</em>, 12(4), 265-319
Umbarkar, A.J. and Sheth P.D. (2015). Crossover operators in genetic algorithms: A riview, <em>ICTACT Journal on Soft Computing</em>, 6(1), 1083-1092.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitfunc = function(x, ...) 2*(x[1]-1)^2 + 5*(x[2]-2)^2 + 10
parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
hc(parent1, parent2, fitfunc)
</code></pre>

<hr>
<h2 id='hgaoptim'>
GA + optim hybridization function
</h2><span id='topic+hgaoptim'></span>

<h3>Description</h3>

<p>This function allows GA to hybridize with methods in the optim general-purpose optimization function for n-variable problems in R's basic <em>stats</em> package (R Core Team, 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgaoptim(genpop, fitfunc, hgaparams,
                    hgaftype, hgans, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hgaoptim_+3A_genpop">genpop</code></td>
<td>
<p>A matrix of individuals in the current population and their fitness values.</p>
</td></tr>
<tr><td><code id="hgaoptim_+3A_fitfunc">fitfunc</code></td>
<td>
<p>Fitness function</p>
</td></tr>
<tr><td><code id="hgaoptim_+3A_hgaparams">hgaparams</code></td>
<td>
<p>A list of parameters defined for use by the Optim function.</p>
</td></tr>
<tr><td><code id="hgaoptim_+3A_hgaftype">hgaftype</code></td>
<td>
<p>Types of fitness to transfer. </p>

<ul>
<li><p>w: individuals with the worst fitness value
</p>
</li>
<li><p>b: individuals with the best fitness value
</p>
</li>
<li><p>r: randomly selected individuals
</p>
</li></ul>

</td></tr>
<tr><td><code id="hgaoptim_+3A_hgans">hgans</code></td>
<td>
<p>Number of individuals to be transferred to the Optim.</p>
</td></tr>
<tr><td><code id="hgaoptim_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the updated population.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>R Core Team. (2021). R: A language and environmental for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hgaoptimx">hgaoptimx</a></code>,
<code><a href="#topic+hgaroi">hgaroi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hgaparams = list(method="Nelder-Mead", poptim=0.05, pressel=0.5,
  control = list(fnscale=1, maxit=100))
n = 5                   # Size of population 
m = 2                   # Number of variables
lb = c(-5.12, -5.12)    # Lower bounds for sample data
ub = c(5.12, 5.12)      # Upper bounds for sample data
genpop = initval(n, m, lb=lb, ub=ub) # Sample population
fitfunc = function(x, ...) 2*(x[1]-1)^2 + 5*(x[2]-2)^2 + 10
fitvals = evaluate(fitfunc, genpop[,1:m])
genpop[,"fitval"]=fitvals
genpop
newpop = hgaoptim(genpop, fitfunc, hgaparams, hgaftype="r", hgans=3)
newpop
</code></pre>

<hr>
<h2 id='hgaoptimx'>
GA + optimx hybridization function
</h2><span id='topic+hgaoptimx'></span>

<h3>Description</h3>

<p>This function allows GA to hybridize with methods in the <em>optimx</em> package (Nash &amp; Varadhan, 2011; Nash, 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgaoptimx(genpop, fitfunc, hgaparams,
                     hgaftype, hgans, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hgaoptimx_+3A_genpop">genpop</code></td>
<td>
<p>A matrix of individuals in the current population and their fitness values.</p>
</td></tr>
<tr><td><code id="hgaoptimx_+3A_fitfunc">fitfunc</code></td>
<td>
<p>Fitness function</p>
</td></tr>
<tr><td><code id="hgaoptimx_+3A_hgaparams">hgaparams</code></td>
<td>
<p>A list of parameters defined for use by the Optim function.</p>
</td></tr>
<tr><td><code id="hgaoptimx_+3A_hgaftype">hgaftype</code></td>
<td>
<p>Types of fitness to transfer. </p>

<ul>
<li><p>w: individuals with the worst fitness value
</p>
</li>
<li><p>b: individuals with the best fitness value
</p>
</li>
<li><p>r: randomly selected individuals
</p>
</li></ul>

</td></tr>
<tr><td><code id="hgaoptimx_+3A_hgans">hgans</code></td>
<td>
<p>Number of individuals to be transferred to the Optim.</p>
</td></tr>
<tr><td><code id="hgaoptimx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the updated population.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Nash, J.C. and Varadhan, R. (2011). Unified optimization algorithms to aid software system users: optimx for R. <em>Journal of Statistical Software</em>, 43(9), 1-14. URL http://www.jstatsoft.org/v43/i09.
Nash, J.C. (2014). On best practice optimization methods in R.  <em>Journal of Statistical Software</em>, 60(2), 1-14. URL http://www.jstatsoft.org/v60/i02.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hgaoptim">hgaoptim</a></code>,
<code><a href="#topic+hgaroi">hgaroi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 5                                # Size of population 
m = 2                                # Number of Variables
lb = c(-5.12, -5.12)                 # Lower bounds of sample data
ub = c(5.12, 5.12)                   # Upper bounds of sample data
hgaparams = list(method="L-BFGS-B", 
  poptim=0.05, pressel=0.5,
  lower=lb, upper=ub,
  control=list(maximize=FALSE, maxit=100))
genpop = initval(n, m, lb=lb, ub=ub) # Sample population
fitfunc = function(x, ...) 2*(x[1]-1)^2 + 5*(x[2]-2)^2 + 10
fitvals = evaluate(fitfunc, genpop[,1:m])
genpop[,"fitval"]=fitvals
genpop
genpop = hgaoptimx(genpop, fitfunc, hgaparams, hgaftype="r", hgans=3)
genpop
</code></pre>

<hr>
<h2 id='hgaroi'>
GA + ROI hybridization function
</h2><span id='topic+hgaroi'></span>

<h3>Description</h3>

<p>This function allows GA to hybridize with methods in the <em>ROI</em> package (Theussl et.al., 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgaroi(genpop, fitfunc, hgaparams,
                  hgaftype, hgans, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hgaroi_+3A_genpop">genpop</code></td>
<td>
<p>A matrix of individuals in the current population and their fitness values.</p>
</td></tr>
<tr><td><code id="hgaroi_+3A_fitfunc">fitfunc</code></td>
<td>
<p>Fitness function</p>
</td></tr>
<tr><td><code id="hgaroi_+3A_hgaparams">hgaparams</code></td>
<td>
<p>A list of parameters defined for use by the Optim function.</p>
</td></tr>
<tr><td><code id="hgaroi_+3A_hgaftype">hgaftype</code></td>
<td>
<p>Types of fitness to transfer. </p>

<ul>
<li><p>w: individuals with the worst fitness value
</p>
</li>
<li><p>b: individuals with the best fitness value
</p>
</li>
<li><p>r: randomly selected individuals
</p>
</li></ul>

</td></tr>
<tr><td><code id="hgaroi_+3A_hgans">hgans</code></td>
<td>
<p>Number of individuals to be transferred to the Optim.</p>
</td></tr>
<tr><td><code id="hgaroi_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the updated population.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Theussl, S., Schwendinger, F. and Hornik, K. (2020). ROI: An extensible R optimization infrastructure.  <em>Journal of Statistical Software</em>, 94(15), 1-64.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hgaoptim">hgaoptim</a></code>,
<code><a href="#topic+hgaoptimx">hgaoptimx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 5                                 # Size of population 
m = 2                                 # Number of variable
lb = c(-5.12, -5.12)                  # Lower bounds of sample data
ub = c(5.12, 5.12)                    # Upper bounds of sample data
hgaparams = list(method="L-BFGS-B", 
  poptim=0.05, pressel=0.5,
  lower=lb, upper=ub,
  control=list(maxit=100))
genpop = initval(n, m, lb=lb, ub=ub)  # Sample population
fitfunc = function(x, ...) 2*(x[1]-1)^2 + 5*(x[2]-2)^2 + 10
fitvals = evaluate(fitfunc, genpop[,1:m])
genpop[,"fitval"]=fitvals
genpop
genpop = hgaroi(genpop, fitfunc, hgaparams, 
  hgaftype="r", hgans=3)
genpop
</code></pre>

<hr>
<h2 id='hux'>
Heuristic Uniform Crossover
</h2><span id='topic+hux'></span>

<h3>Description</h3>

<p>&quot;Heuristic Uniform Crossover&quot; is an algorithm that works by detecting genes that differ to control the level of disruption in Parental chromosomes (De Jong &amp; Spears, 1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hux(x1, x2, cxon, cxps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hux_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="hux_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="hux_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="hux_+3A_cxps">cxps</code></td>
<td>
<p>It determines the rate of gene exchange between the chromosomes of the parents.</p>
</td></tr>
<tr><td><code id="hux_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>De Jong, K.A. and Spears, W. (1991). On the virtues of parameterized uniform crossover. In <em>Proc. of the 4th Int. Conf. on Genetic Algorithms</em>. Morgan Kaufman Publishers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
hux(parent1, parent2)
</code></pre>

<hr>
<h2 id='icx'>
Improved Cycle Crossover (ICX)
</h2><span id='topic+icx'></span>

<h3>Description</h3>

<p>ICX is based on a deterministic algorithm that can produce up to 2 offspring (Hussain et.al., 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icx(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="icx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="icx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="icx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="icx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Hussain, A., Muhammad, Y.S. and Sajid, M.N. (2018). An improved genetic algorithm crossover operator for traveling salesman problem. <em>Turkish Journal of Mathematics and Computer Science</em>, 9, 1-13. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(3, 4, 8, 2, 7, 1, 6, 5)
parent2 = c(4, 2, 5, 1, 6, 8, 3, 7)
icx(parent1, parent2)
</code></pre>

<hr>
<h2 id='ilmdhc'>
ILM/DHC adaptation function
</h2><span id='topic+ilmdhc'></span>

<h3>Description</h3>

<p>ILM/DHC is an adaptive function with an increasing low mutation rate (ILM) and a decreasing high crossover rate (DHC) as the generation progresses (Hassanat et.al., 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ilmdhc(g, gmax, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ilmdhc_+3A_g">g</code></td>
<td>
<p>Current generation</p>
</td></tr>
<tr><td><code id="ilmdhc_+3A_gmax">gmax</code></td>
<td>
<p>Maximum generation</p>
</td></tr>
<tr><td><code id="ilmdhc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pc</code></td>
<td>
<p>Crossover rate</p>
</td></tr>
<tr><td><code>pm</code></td>
<td>
<p>Mutation rate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Hassanat, A., Almohammadi, K., Alkafaween, E., Abunawas, E., Hammouri, A. and Prasath, V.B. (2019). Choosing mutation and crossover ratios for genetic algorithm: A review with a new dynamic approach. <em>Information</em>, 10(12), 390.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixpcmut">fixpcmut</a></code>,
<code><a href="#topic+adana1">adana1</a></code>,
<code><a href="#topic+adana2">adana2</a></code>,
<code><a href="#topic+leitingzhi">leitingzhi</a></code>,
<code><a href="#topic+adana3">adana3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N = 50
gmax = 1000
g = c(1, 10, 50, 100, 250, 500, 750, gmax)
pc = ilmdhc(g=g, gmax=gmax)$pc
pc
nc = round(pc*N)
nc
pm = ilmdhc(g=g, gmax=gmax)$pm
pm
nm = round(pm*N)
nm
nm = ifelse (!nm, 1, nm)
nm
plot(pm, type="l", col=4, lwd=2, lty=1, xaxt="n", ylab="Ratio", xlab="Generation")
lines(pc, type="l", col=2, lwd=2, lty=2)
legend("top", inset=.02, c("pm","pc"), col=c(4,2), lty=c(1,2), horiz=TRUE, cex=0.8)
axis(1, at=1:length(g),labels=g, col.axis="red", las=2)
</code></pre>

<hr>
<h2 id='initbin'>
Initialize the population with binary encoding
</h2><span id='topic+initbin'></span>

<h3>Description</h3>

<p>The initbin function is an initialization function that can be used for binary encoding. It generates an initial population of population size n and chromosome length m.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initbin(n, m, prevpop, type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initbin_+3A_n">n</code></td>
<td>
<p>Population size</p>
</td></tr>
<tr><td><code id="initbin_+3A_m">m</code></td>
<td>
<p>Chromosome length</p>
</td></tr>
<tr><td><code id="initbin_+3A_prevpop">prevpop</code></td>
<td>
<p>Matrix of solutions used in heuristic and hybrid initialization</p>
</td></tr>
<tr><td><code id="initbin_+3A_type">type</code></td>
<td>
<p>Type of output matrix</p>
</td></tr>
<tr><td><code id="initbin_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output matrix includes only chromosomes of initial population when <code>type=2</code>, otherwise The output matrix includes 
chromosomes of initial population and additional two empty columns for generation number and fitness values.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initval">initval</a></code>,
<code><a href="#topic+initperm">initperm</a></code>,
<code><a href="#topic+initnorm">initnorm</a></code>,
<code><a href="#topic+initialize">initialize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 20  #Population size (number of chromosemes)
m = 5   #Number of gene (chromosome length)
population = initbin(n, m)
head(population, 4)
tail(population, 4)
</code></pre>

<hr>
<h2 id='initialize'>
Initialize function
</h2><span id='topic+initialize'></span>

<h3>Description</h3>

<p>The initialize function is a function that wraps various initialization functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize(initfunc, n, m, type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initialize_+3A_initfunc">initfunc</code></td>
<td>
<p>Initialization function</p>
</td></tr>
<tr><td><code id="initialize_+3A_n">n</code></td>
<td>
<p>Population size</p>
</td></tr>
<tr><td><code id="initialize_+3A_m">m</code></td>
<td>
<p>Chromosome length (number of variables)</p>
</td></tr>
<tr><td><code id="initialize_+3A_type">type</code></td>
<td>
<p>Type of output matrix</p>
</td></tr>  
<tr><td><code id="initialize_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output matrix includes only chromosomes of initial population when <code>type=2</code>, otherwise The output matrix includes 
chromosomes of initial population and additional two empty columns for generation number and fitness values.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initbin">initbin</a></code>,
<code><a href="#topic+initval">initval</a></code>,
<code><a href="#topic+initperm">initperm</a></code>,
<code><a href="#topic+initnorm">initnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initpop = initialize(initfunc=initbin, n=6, m=4) 
initpop
</code></pre>

<hr>
<h2 id='initnorm'>
Normal distribution based initialization
</h2><span id='topic+initnorm'></span>

<h3>Description</h3>

<p>The pmean and psd arguments of this function represent the mean and standard deviation of a normally distributed population, respectively. Using these parameters, the function generates a random initial population with n individuals and m variables.~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initnorm(n, m, pmean, psd, type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initnorm_+3A_n">n</code></td>
<td>
<p>Population size</p>
</td></tr>
<tr><td><code id="initnorm_+3A_m">m</code></td>
<td>
<p>Chromosome length (number of variables)</p>
</td></tr>
<tr><td><code id="initnorm_+3A_pmean">pmean</code></td>
<td>
<p>Mean of normal distribution</p>
</td></tr> 
<tr><td><code id="initnorm_+3A_psd">psd</code></td>
<td>
<p>Standard deviation of normal distribution</p>
</td></tr> 
<tr><td><code id="initnorm_+3A_type">type</code></td>
<td>
<p>Type of output matrix</p>
</td></tr> 
<tr><td><code id="initnorm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output matrix includes only chromosomes of initial population when <code>type=2</code>, otherwise The output matrix includes 
chromosomes of initial population and additional two empty columns for generation number and fitness values.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initbin">initbin</a></code>,
<code><a href="#topic+initval">initval</a></code>,
<code><a href="#topic+initperm">initperm</a></code>,
<code><a href="#topic+initialize">initialize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initpop = initialize(initfunc=initnorm, n=20, m=5, 
  pmean=50, psd=5, type=2) 
head(initpop,3)
</code></pre>

<hr>
<h2 id='initperm'>
Permutation coded initialization
</h2><span id='topic+initperm'></span>

<h3>Description</h3>

<p>This function generates an initial population when each variable of the chromosomes is desired to be encoded on a rank scale or permutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initperm(n, permset, prevpop, type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initperm_+3A_n">n</code></td>
<td>
<p>Population size</p>
</td></tr>
<tr><td><code id="initperm_+3A_permset">permset</code></td>
<td>
<p>A vector of permutation set</p>
</td></tr>
<tr><td><code id="initperm_+3A_prevpop">prevpop</code></td>
<td>
<p>Matrix of solutions used in heuristic and hybrid initialization</p>
</td></tr>
<tr><td><code id="initperm_+3A_type">type</code></td>
<td>
<p>Type of output matrix</p>
</td></tr>
<tr><td><code id="initperm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike other initialization function inputs, the initperm function has an argument called permset. This argument is a vector containing permutation set values. The permutation set can contain numbers or letters. In the initial population, each variable randomly takes any value from this set, but there cannot be two of the same value in a chromosome.
</p>


<h3>Value</h3>

<p>The output matrix includes only chromosomes of initial population when <code>type=2</code>, otherwise The output matrix includes 
chromosomes of initial population and additional two empty columns for generation number and fitness values.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initbin">initbin</a></code>,
<code><a href="#topic+initval">initval</a></code>,
<code><a href="#topic+initnorm">initnorm</a></code>,
<code><a href="#topic+initialize">initialize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 20   #Population size (number of chromosemes)
m = 6    #number of Variables
lb = c(10, 2, 5, 100, 50, 25)
ub = c(40, 8, 20, 500, 250, 90)
population = initval(n, m, lb=lb, ub=ub, nmode="integer")
tail(population, 3)
</code></pre>

<hr>
<h2 id='initval'>
Value encoded initialization
</h2><span id='topic+initval'></span>

<h3>Description</h3>

<p>Initialize the population with integer or real numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initval(n, m, prevpop, lb, ub, nmode="real", type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initval_+3A_n">n</code></td>
<td>
<p>Population size</p>
</td></tr>
<tr><td><code id="initval_+3A_m">m</code></td>
<td>
<p>Chromosome length (number of variables)</p>
</td></tr>
<tr><td><code id="initval_+3A_prevpop">prevpop</code></td>
<td>
<p>Matrix of solutions used in heuristic and hybrid initialization</p>
</td></tr>
<tr><td><code id="initval_+3A_lb">lb</code></td>
<td>
<p>Lower bound of each variables</p>
</td></tr>
<tr><td><code id="initval_+3A_ub">ub</code></td>
<td>
<p>Upper bound of each variables</p>
</td></tr>
<tr><td><code id="initval_+3A_nmode">nmode</code></td>
<td>
<p>Type of variables (&ldquo;integer&rdquo; or &ldquo;real&rdquo;)</p>
</td></tr>  
<tr><td><code id="initval_+3A_type">type</code></td>
<td>
<p>Type of output matrix</p>
</td></tr>
<tr><td><code id="initval_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With this function, populations are initialized with integer and/or real numbers depending on the GA problem. In this case, the value type must be known. Furthermore, the lower and upper bound values for each variable must be known. If desired, heuristic or mixed initialization can be done with the <code>prevpop</code> argument.
</p>


<h3>Value</h3>

<p>The output matrix includes only chromosomes of initial population when <code>type=2</code>, otherwise The output matrix includes 
chromosomes of initial population and additional two empty columns for generation number and fitness values.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initbin">initbin</a></code>,
<code><a href="#topic+initperm">initperm</a></code>,
<code><a href="#topic+initnorm">initnorm</a></code>,
<code><a href="#topic+initialize">initialize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 15  #Population size (number of chromosemes)
m = 4   #number of Variables
population = initval(n, m)
head(population, 3)
tail(population, 3)
</code></pre>

<hr>
<h2 id='insmut'>
Insertation Mutation
</h2><span id='topic+insmut'></span>

<h3>Description</h3>

<p>SM is inserted back in a different place into the chromosome by removing a randomly selected gene from the chromosome.
</p>
<p>This operator is used in problems with permutation encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insmut(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="insmut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="insmut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
<tr><td><code>mutpoint</code></td>
<td>
<p>The number of inserted location of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,        
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,   
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offspring = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
insmut(offspring)
</code></pre>

<hr>
<h2 id='insswapmut'>
Insertion + Inversion Mutation
</h2><span id='topic+insswapmut'></span>

<h3>Description</h3>

<p>It is a mutation operator that combines insertion and inversion mutation.
</p>
<p>This operator is used in problems with permutation encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insswapmut(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="insswapmut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="insswapmut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>A vector. The numbers of begining and ending of the mutated genes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,        
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,   
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,  
<code><a href="#topic+dismut">dismut</a></code>,
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offspring = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
insswapmut(offspring)
</code></pre>

<hr>
<h2 id='int2bin'>Convert an integer to binary coded number</h2><span id='topic+int2bin'></span>

<h3>Description</h3>

<p>The function int2bin converts integers to binary coded numbers.</p>


<h3>Usage</h3>

<pre><code class='language-R'>int2bin(int, m)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="int2bin_+3A_int">int</code></td>
<td>
<p>Input number (integer)</p>
</td></tr>
<tr><td><code id="int2bin_+3A_m">m</code></td>
<td>
<p>Number of the digits of output value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the binary coded number of the integer number given in the input.</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+int2bin">int2bin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>int2bin(250)      # returns 11111010
int2bin(250, 9)   # returns 011111010
</code></pre>

<hr>
<h2 id='invdismut'>
Displacement + Inversion Mutation
</h2><span id='topic+invdismut'></span>

<h3>Description</h3>

<p>It is a mutation operator that combines displacement and inversion mutation.
</p>
<p>This operator is used in problems with permutation encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invdismut(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invdismut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="invdismut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutrange</code></td>
<td>
<p>A vector. The numbers of begining and ending of the mutated genes.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The number of insertation location.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,        
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,   
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,  
<code><a href="#topic+dismut">dismut</a></code>,
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offspring = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
invdismut(offspring)
</code></pre>

<hr>
<h2 id='invmut'>
Inversion Mutation
</h2><span id='topic+invmut'></span>

<h3>Description</h3>

<p>Inversion Mutation selects a subset of genes and inverses the genes in the subset (Hollad, 1975; Fogel, 1990).
</p>
<p>This operator is used in problems with permutation or binary encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invmut(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invmut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="invmut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutrange</code></td>
<td>
<p>A vector. The numbers of begining and ending of the mutated genes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Holland, J. (1975). <em>Adaptation in Naturel and Articial Systems</em>, Ann Arbor: University of Michigan Press.
</p>
<p>Fogel D.B. (1995). Evolutionary computation. Toward a new philosophy of machine intellegence. Piscataway, NJ: IEEE Press.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,        
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,   
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offspring = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
invmut(offspring)
</code></pre>

<hr>
<h2 id='invswapmut'>
Swap + Inversion Mutation
</h2><span id='topic+invswapmut'></span>

<h3>Description</h3>

<p>It is a mutation operator that combines swap and inversion mutation.
</p>
<p>This operator is used in problems with permutation encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invswapmut(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invswapmut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="invswapmut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>A vector. The numbers of begining and ending of the mutated genes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,        
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,   
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,  
<code><a href="#topic+dismut">dismut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offspring = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
invswapmut(offspring)
</code></pre>

<hr>
<h2 id='kpx'>
k-point Crossover
</h2><span id='topic+kpx'></span>

<h3>Description</h3>

<p>In the k-PX cross, the parent chromosomes are cut from two or more points and transferred to the offspring, providing more diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kpx(x1, x2, cxon, cxk, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kpx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="kpx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="kpx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="kpx_+3A_cxk">cxk</code></td>
<td>
<p>Number of cut points</p>
</td></tr>
<tr><td><code id="kpx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
kpx(parent1, parent2)
</code></pre>

<hr>
<h2 id='lapx'>
Laplace Crossover
</h2><span id='topic+lapx'></span>

<h3>Description</h3>

<p>Laplace Crossover (LAPX) is a crossover operator that uses a location parameter and a scaling parameter (Krishnamoorthy, 2006; Deep et.al., 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapx(x1, x2, cxon, cxa, cxb, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lapx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="lapx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="lapx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="lapx_+3A_cxa">cxa</code></td>
<td>
<p>Location Parameter</p>
</td></tr>
<tr><td><code id="lapx_+3A_cxb">cxb</code></td>
<td>
<p>Scale Parameter. (<code> cxb &gt; 0 </code>) </p>
</td></tr>
<tr><td><code id="lapx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Krishnamoorthy, K. (2006). <em>Handbook of Statistical Distributions with Applications</em>. Chapman &amp; Hall/CRC
</p>
<p>Deep, K., Singh, K.P., Kansal, M.L. and Mohan, C. (2009). A real-coded genetic algorithm for solving integer and mixed integer optimization problems. <em>Applied Mathematics and Computation</em>, 212(2): 505-518.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
lapx(parent1, parent2, cxon=3)
</code></pre>

<hr>
<h2 id='lax'>
Local Arithmetic Crossover
</h2><span id='topic+lax'></span>

<h3>Description</h3>

<p>New offspring are generated by applying an arithmetic mean on the parents' chromosomes with a different random weight for each gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lax(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lax_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="lax_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="lax_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="lax_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
lax(parent1, parent2, cxon=3)
</code></pre>

<hr>
<h2 id='leitingzhi'>
Lei &amp; Tingzhi Adaptation Function
</h2><span id='topic+leitingzhi'></span>

<h3>Description</h3>

<p>This adaptation function proposed by Lei &amp; Tingzhi (1994) is an adaptation function that takes into account the cooperation of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leitingzhi(fitvals, cxpc, cxpc2, 
                      mutpm, mutpm2, adapa, adapb, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leitingzhi_+3A_fitvals">fitvals</code></td>
<td>
<p>A vector. Fitness values of current generation</p>
</td></tr>
<tr><td><code id="leitingzhi_+3A_cxpc">cxpc</code></td>
<td>
<p>Crossover rate for adaptation. 0 &lt;= cxpc &lt;= 1. default is 0.9</p>
</td></tr>
<tr><td><code id="leitingzhi_+3A_cxpc2">cxpc2</code></td>
<td>
<p>Crossover rate for adaptation. 0 &lt;= cxpc2 &lt;= 1. default is 0.5</p>
</td></tr>
<tr><td><code id="leitingzhi_+3A_mutpm">mutpm</code></td>
<td>
<p>Mutation  rate for adaptation. 0 &lt;= mutpm &lt;= 1. default is 0.05</p>
</td></tr>
<tr><td><code id="leitingzhi_+3A_mutpm2">mutpm2</code></td>
<td>
<p>Mutation  rate for adaptation. 0 &lt;= mutpm2 &lt;= 1. default is 0.2</p>
</td></tr>
<tr><td><code id="leitingzhi_+3A_adapa">adapa</code></td>
<td>
<p>Adaptation threshold for average of fitness values. 0 &lt;= adapa &lt;= 1. default is 0.7</p>
</td></tr>
<tr><td><code id="leitingzhi_+3A_adapb">adapb</code></td>
<td>
<p>Adaptation threshold for minimum of fitness values. 0.5 &lt;= adapb &lt;= 1. default is 0.5</p>
</td></tr>
<tr><td><code id="leitingzhi_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pc</code></td>
<td>
<p>Crossover rate</p>
</td></tr>
<tr><td><code>pm</code></td>
<td>
<p>Mutation rate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Lei, W. and Tingzhi, S. (2004). An improved adaptive genetic algorithm and its application to image segmentation. In <em>Proc. of 5th Int. Conf. on Artificial Neural Network and Genetic Algorithms</em>, pp. 112-119.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixpcmut">fixpcmut</a></code>,
<code><a href="#topic+ilmdhc">ilmdhc</a></code>,
<code><a href="#topic+adana1">adana1</a></code>,
<code><a href="#topic+adana2">adana2</a></code>,
<code><a href="#topic+adana3">adana3</a></code>
</p>

<hr>
<h2 id='maxone'>
MAXONE fitness function
</h2><span id='topic+maxone'></span>

<h3>Description</h3>

<p>Fitness function that calculates the number of 1s in each individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxone(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxone_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="maxone_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of 1s
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxone1">maxone1</a></code>, 
<code><a href="#topic+maxone2">maxone2</a></code>, 
<code><a href="#topic+minone">minone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C2 = c(1, 1, 1, 0, 1, 0, 0, 0)
maxone(C2)
C3 = c(1, 1, 1, 1, 1, 1, 1, 1)
maxone(C3)
</code></pre>

<hr>
<h2 id='maxone1'>
MAXONE1 fitness function
</h2><span id='topic+maxone1'></span>

<h3>Description</h3>

<p>Fitness function that calculates the number of 1s in each individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxone1(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxone1_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="maxone1_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of 1s
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxone">maxone</a></code>, 
<code><a href="#topic+maxone2">maxone2</a></code>, 
<code><a href="#topic+minone">minone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C2 = c(1, 1, 1, 0, 1, 0, 0, 0)
maxone1(C2)
C3 = c(1, 1, 1, 1, 1, 1, 1, 1)
maxone1(C3)
</code></pre>

<hr>
<h2 id='maxone2'>
maxone2 fitness function
</h2><span id='topic+maxone2'></span>

<h3>Description</h3>

<p>Calculates the sum of each row of a matrix or data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxone2(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxone2_+3A_x">x</code></td>
<td>
<p>A matrix or a data frame</p>
</td></tr>
<tr><td><code id="maxone2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector includes sum of each row in a matrix or data frame
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxone1">maxone1</a></code>, 
<code><a href="#topic+maxone">maxone</a></code>, 
<code><a href="#topic+minone">minone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>binmat = matrix(nrow=5, ncol=8, byrow=TRUE, c(
1, 0, 1, 0, 1, 1, 1, 0,
1, 1, 1, 0, 1, 0, 0, 0,
1, 1, 1, 1, 1, 1, 1, 1,
0, 1, 0, 1, 0, 1, 1, 1,
0, 0, 0, 0, 0, 0, 0, 0
))
rownames(binmat) = paste0("C",1:5)
maxone2(binmat)
</code></pre>

<hr>
<h2 id='minone'>
minone fitness function 
</h2><span id='topic+minone'></span>

<h3>Description</h3>

<p>Calculates the inverse of the sum of each row of a matrix or data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minone(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minone_+3A_x">x</code></td>
<td>
<p>A matrix or a data frame</p>
</td></tr>
<tr><td><code id="minone_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector includes the inverse of the sum of each row in a matrix or data frame
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxone">maxone</a></code>, 
<code><a href="#topic+maxone1">maxone1</a></code>, 
<code><a href="#topic+maxone2">maxone2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>binmat = matrix(nrow=5, ncol=8, byrow=TRUE, c(
1, 0, 1, 0, 1, 1, 1, 0,
1, 1, 1, 0, 1, 0, 0, 0,
1, 1, 1, 1, 1, 1, 1, 1,
0, 1, 0, 1, 0, 1, 1, 1,
0, 0, 0, 0, 0, 0, 0, 0
))
rownames(binmat) = paste0("C",1:5)
minone(binmat)
</code></pre>

<hr>
<h2 id='monprogress'>
Monitor Fitness Value Progress
</h2><span id='topic+monprogress'></span>

<h3>Description</h3>

<p>Monprogress function performs by creating a line plot of the best fitness value found across generations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monprogress(g, genfits, objective, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monprogress_+3A_g">g</code></td>
<td>
<p>Generation number</p>
</td></tr>
<tr><td><code id="monprogress_+3A_genfits">genfits</code></td>
<td>
<p>A matrix for fitness values</p>
</td></tr>
<tr><td><code id="monprogress_+3A_objective">objective</code></td>
<td>
<p>Type of optimization. &quot;min&quot; or &quot;max&quot;</p>
</td></tr>
<tr><td><code id="monprogress_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for the side effect of drawing a plot.</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+show">show</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 100
genfits = matrix(NA, nrow=n, ncol=5)
genfits[1,3] = 50
objective = "max"
for(i in 1:(n-1)){
  g=i
  monprogress(g=g, genfits=genfits, objective=objective)
  genfits[g+1, 3] = genfits[g, 3] + runif(1, -2, 5)
}
</code></pre>

<hr>
<h2 id='mpmx'>
Modified Partially Mapped Crossover
</h2><span id='topic+mpmx'></span>

<h3>Description</h3>

<p>Modified Partially Mapped Crossover (MPMX) is a crossover operator for permutation encoded chromosomes. Each of the offspring uses sequencing information partially determined by each of their parents. Two different cut points are randomly determined. The part outside of the two cut points is replaced. Pieces between the two cut points are complemented from the original parental genes. However, if the same genes are found among the copied genes, they are changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpmx(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpmx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="mpmx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="mpmx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="mpmx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(0, 8, 4, 5, 6, 7, 1, 2, 3, 9)
parent2 = c(6, 7, 1, 2, 4, 8, 3, 5, 9, 0)
mpmx(parent1, parent2)
</code></pre>

<hr>
<h2 id='mpx'>
Maximal Preservative Crossover (MPX)
</h2><span id='topic+mpx'></span>

<h3>Description</h3>

<p>The Maximal Preservative Crossover (MPX) operator is an operator that tries to preserve good edges but ensure adequate gene exchange between parents (Muhlenbein et.al., 1988).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpx(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="mpx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="mpx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="mpx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Muhlenbein, H., Gorges-Schleuter, M. and Kramer, O. (1988). Evolution algorithms in combinatorial optimization. <em>Parallel Computing</em>, 7(1), 65-85.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(0, 8, 4, 5, 6, 7, 1, 2, 3, 9)
parent2 = c(6, 7, 1, 2, 4, 8, 3, 5, 9, 0)
mpx(parent1, parent2)
</code></pre>

<hr>
<h2 id='mutate'>
Function of Mutation Application
</h2><span id='topic+mutate'></span>

<h3>Description</h3>

<p>With mutation, the chromosomes of individuals are randomly changed and sent to the next generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate(mutfunc, population, mutpm, gatype, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate_+3A_mutfunc">mutfunc</code></td>
<td>
<p>The name of the mutation operator</p>
</td></tr>
<tr><td><code id="mutate_+3A_population">population</code></td>
<td>
<p>A matrix. Population of offspring to be mutated</p>
</td></tr>
<tr><td><code id="mutate_+3A_mutpm">mutpm</code></td>
<td>
<p>Mutation Rate</p>
</td></tr>
<tr><td><code id="mutate_+3A_gatype">gatype</code></td>
<td>
<p>Indicates the GA type. &quot;gga&quot; is assigned for generational refresh, and &quot;ssga&quot; for steady-state refresh.</p>
</td></tr>
<tr><td><code id="mutate_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the mutated offsprings
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Cebeci, Z. (2021). R ile Genetik Algoritmalar ve Optimizasyon Uygulamalari, 535 p. Ankara:Nobel Akademik Yayincilik. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,        
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,   
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,  
<code><a href="#topic+dismut">dismut</a></code>,
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offsprings=initbin(25,5)
offsprings[,"fitval"] = evaluate(maxone, offsprings[,1:(ncol(offsprings)-2)])
head(offsprings, 4)          # mutant individual may be further ahead.
mutatedpop = mutate(mutfunc=bitmut, population=offsprings, mutpm=0.1, gatype="gga")
mutatedpop[,"fitval"] = evaluate(maxone, mutatedpop[,1:(ncol(mutatedpop)-2)])
head(mutatedpop, 4)
</code></pre>

<hr>
<h2 id='mx'>
Mask crossover
</h2><span id='topic+mx'></span>

<h3>Description</h3>

<p>This crossover function copies parent1 and parent2 to offspring1 and offspring2, respectively. A vector of length m is then randomly generated for each parent, containing the values 0 and 1. Elements in this vector are then compared for each gene location. If the element at the ith position of the first vector is equal to that of the second vector, no change is made. However, if the first is 0 and the second is 1, the ith gene of Parent2 is copied as the ith gene of Offspring1. If the ith elements of the vectors are 1 and 0, the i th gene of Parent1 is copied as the i th gene of Offspring2 (Louis &amp; Rawlins, 1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mx(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="mx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="mx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="mx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Louis S.J. and Rawlins G.J. (1991). Designer Genetic Algorithms: Genetic Algorithms in Structure Design. In <em>4th Int. Conf. on Genetic Algorithms</em>. (pp. 53-60)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
mx(parent1, parent2, cxon=3)
</code></pre>

<hr>
<h2 id='nunimut'>
Non-uniform Mutation
</h2><span id='topic+nunimut'></span>

<h3>Description</h3>

<p>The nunimut operator is a mutation operator that adjusts for generations by reducing the mutation severity according to genetic progression (Michalewicz, 1994).
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nunimut(y, lb, ub, g, gmax, mutb, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nunimut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="nunimut_+3A_lb">lb</code></td>
<td>
<p>A vector. Lower bounds of genes</p>
</td></tr>
<tr><td><code id="nunimut_+3A_ub">ub</code></td>
<td>
<p>A vector. Upper bounds of genes</p>
</td></tr>
<tr><td><code id="nunimut_+3A_g">g</code></td>
<td>
<p>Current generation number.</p>
</td></tr>
<tr><td><code id="nunimut_+3A_gmax">gmax</code></td>
<td>
<p>Maximum generation number.</p>
</td></tr>
<tr><td><code id="nunimut_+3A_mutb">mutb</code></td>
<td>
<p>An exponent parameter that sets non-uniformity</p>
</td></tr>  
<tr><td><code id="nunimut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Michalewicz, . (1994).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut2">nunimut2</a></code>,  
<code><a href="#topic+powmut">powmut</a></code>,
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(2, 1, 3, 1, 0, 4)
ub = c(10, 15, 8, 5, 6, 9)
offspring = c(8, 6, 4, 1, 3, 7)
set.seed(12)
nunimut(offspring, lb=lb, ub=ub, g=1, gmax=100, mutb=0.5)
set.seed(12)
nunimut(offspring, lb=lb, ub=ub, g=50, gmax=100, mutb=0.5)
</code></pre>

<hr>
<h2 id='nunimut2'>
Adaptive Non-uniform mutation
</h2><span id='topic+nunimut2'></span>

<h3>Description</h3>

<p>This operator is an adaptive mutation operator that increases the probability of the mutation severity approaching 0 as the number of generations increases.
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nunimut2(y, lb, ub, g, gmax, mutb, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nunimut2_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="nunimut2_+3A_lb">lb</code></td>
<td>
<p>A vector. Lower bounds of genes</p>
</td></tr>
<tr><td><code id="nunimut2_+3A_ub">ub</code></td>
<td>
<p>A vector. Upper bounds of genes</p>
</td></tr>
<tr><td><code id="nunimut2_+3A_g">g</code></td>
<td>
<p>Current generation number.</p>
</td></tr>
<tr><td><code id="nunimut2_+3A_gmax">gmax</code></td>
<td>
<p>Maximum generation number.</p>
</td></tr>
<tr><td><code id="nunimut2_+3A_mutb">mutb</code></td>
<td>
<p>An exponent parameter that sets non-uniformity</p>
</td></tr>   
<tr><td><code id="nunimut2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+powmut">powmut</a></code>,
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(2, 1, 3, 1, 0, 4)
ub = c(10, 15, 8, 5, 6, 9)
offspring = c(8, 6, 4, 1, 3, 7)
set.seed(12)
nunimut2(offspring, lb=lb, ub=ub, g=1, gmax=100, mutb=0.5)
set.seed(12)
nunimut2(offspring, lb=lb, ub=ub, g=50, gmax=100, mutb=0.5)
</code></pre>

<hr>
<h2 id='ox'>
Order Crossover (OX)
</h2><span id='topic+ox'></span>

<h3>Description</h3>

<p>Order Crossover (OX) is a crossover operator for permutation encoded chromosomes. It is a different variant of PMX and it receives a part of the offspring chromosome from Parent1 and the remaining part from Parent2 in a certain sequence (Davis, 1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ox(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ox_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="ox_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="ox_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="ox_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Davis, L. (1985). Appliying adaptive algorithms to epistatic domains. In <em>Proc. of the Int. Joint Conf. on Artificial Intellegence</em>, Vol. 85, pp. 162-164.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(3, 4, 8, 2, 7, 1, 6, 5)
parent2 = c(4, 2, 5, 1, 6, 8, 3, 7)
ox(parent1, parent2)
</code></pre>

<hr>
<h2 id='ox2'>
Order-based crossover (OX2)
</h2><span id='topic+ox2'></span>

<h3>Description</h3>

<p>Order-based crossover (OX2) is a crossover operator for permutation encoded chromosomes. It is an operator that forces the order of several randomly selected positions in one parent to the other parent (Syswerda, 1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ox2(x1, x2, cxon, cxoxk, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ox2_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="ox2_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="ox2_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="ox2_+3A_cxoxk">cxoxk</code></td>
<td>
<p>Number of genes to be changed</p>
</td></tr>
<tr><td><code id="ox2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Sysweda, G. (1991). Schedule optimization using genetic algorithms. <em>Handbook of Genetic Algorithms</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 2, 3, 4, 5, 6, 7, 8)
parent2 = c(4, 2, 5, 1, 6, 8, 3, 7)
ox2(parent1, parent2)
</code></pre>

<hr>
<h2 id='pbx'>
Position-Based Crossover (PBX)
</h2><span id='topic+pbx'></span>

<h3>Description</h3>

<p>The Position-Based Crossover (PBX) operator inserts a different number of randomly selected genes in one parent into the same position in Offspring1, then rounds off the other genes in sequence according to their positions in the other parent (Syswerda, 1991). Other offspring are generated similarly if desired or necessary. PBX is an operator that tries to ensure diversity in recombination while taking care to preserve position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbx(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pbx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="pbx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="pbx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="pbx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Syswerda, G. (1991). Schedule optimization using genetic algorithms. <em>Handbook of Genetic Algorithms</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(3, 4, 8, 2, 7, 1, 6, 5)
parent2 = c(4, 2, 5, 1, 6, 8, 3, 7)
pbx(parent1, parent2, cxon=2)
</code></pre>

<hr>
<h2 id='pbx2'>
Position-Based Crossover 2 (PBX2)
</h2><span id='topic+pbx2'></span>

<h3>Description</h3>

<p>The Position-Based Crossover (PBX) operator inserts a different number of randomly selected genes in one parent into the same position in Offspring1, then rounds off the other genes in sequence according to their positions in the other parent (Syswerda, 1991). Other offspring are generated similarly if desired or necessary. PBX is an operator that tries to ensure diversity in recombination while taking care to preserve position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbx2(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pbx2_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="pbx2_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="pbx2_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="pbx2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Syswerda, G. (1991). Schedule optimization using genetic algorithms. <em>Handbook of Genetic Algorithms</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ebeveyn1 = c(3, 4, 8, 2, 7, 1, 6, 5)
ebeveyn2 = c(4, 2, 5, 1, 6, 8, 3, 7)
pbx2(ebeveyn1, ebeveyn2, cxon=2)
</code></pre>

<hr>
<h2 id='plotfitness'>
Fitness statistics graph by GA generations
</h2><span id='topic+plotfitness'></span>

<h3>Description</h3>

<p>Fitness statistics graph by GA generations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotfitness(genfits, options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotfitness_+3A_genfits">genfits</code></td>
<td>
<p>A matrix. Best fitness of each generation</p>
</td></tr>
<tr><td><code id="plotfitness_+3A_options">options</code></td>
<td>
<p>A vector. Statistics to be plotted. 
</p>
 <ul>
<li><p>1: minimum </p>
</li>
<li><p>2: maximum </p>
</li>
<li><p>3: average </p>
</li>
<li><p>4: Q1   </p>
</li>
<li><p>5: median  </p>
</li>
<li><p>6: Q3 </p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for the side effect of drawing a plot.</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>

<hr>
<h2 id='pmx'>
Partially Mapped Crossover
</h2><span id='topic+pmx'></span>

<h3>Description</h3>

<p>Partially Mapped Crossover (PMX) is the most commonly used crossover operator for permutation encoded chromosomes. Each of the offspring uses sequencing information partially determined by each of their parents (Goldberg &amp; Lingle, 1985). Two different cut points are randomly determined. The part between the two cut points is replaced. Pieces outside of the two cut points are complemented from the original parental genes. However, if the same genes are found among the copied genes, they are changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmx(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="pmx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="pmx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="pmx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Goldberg, D.E. and Lingle, R. (1985). Alleles, loci, and the traveling salesman problem. In <em>Proc. of an international conference on genetic algorithms and their applications</em>. Vol. 154, pp. 154-159. Carnegie-Mellon University, Pittsburgh, PA.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(3, 4, 8, 2, 7, 1, 6, 5)
parent2 = c(4, 2, 5, 1, 6, 8, 3, 7)
pmx(parent1, parent2, cxon=2)
</code></pre>

<hr>
<h2 id='powmut'>
Power Mutation
</h2><span id='topic+powmut'></span>

<h3>Description</h3>

<p>Power Mutation is an operator that generates a mutation in a random gene at a certain power of a random number.
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powmut(y, lb, ub, mutpow, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powmut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="powmut_+3A_lb">lb</code></td>
<td>
<p>A vector. Lower bounds of genes</p>
</td></tr>
<tr><td><code id="powmut_+3A_ub">ub</code></td>
<td>
<p>A vector. Upper bounds of genes</p>
</td></tr>
<tr><td><code id="powmut_+3A_mutpow">mutpow</code></td>
<td>
<p>An exponent parameter</p>
</td></tr>   
<tr><td><code id="powmut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(2, 1, 3, 1, 0, 4)
ub = c(10, 15, 8, 5, 6, 9)
offspring = c(8, 6, 4, 1, 3, 7)
set.seed(12)
powmut(offspring, lb=lb, ub=ub, mutpow=3)
</code></pre>

<hr>
<h2 id='powmut2'>
Power Mutation 2
</h2><span id='topic+powmut2'></span>

<h3>Description</h3>

<p>Power Mutation is an operator that generates a mutation in a random gene at a certain power of a random number. In this operator, a different exponent parameter can be given for each gene.
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powmut2(y, lb, ub, mutpow, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powmut2_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="powmut2_+3A_lb">lb</code></td>
<td>
<p>A vector. Lower bounds of genes</p>
</td></tr>
<tr><td><code id="powmut2_+3A_ub">ub</code></td>
<td>
<p>A vector. Upper bounds of genes</p>
</td></tr>
<tr><td><code id="powmut2_+3A_mutpow">mutpow</code></td>
<td>
<p>A vector of exponent parameter</p>
</td></tr> 
<tr><td><code id="powmut2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(2, 1, 3, 1, 0, 4)
ub = c(10, 15, 8, 5, 6, 9)
mutpow = c(3, 0.5, 0.5, 2, 3, 1)
offspring = c(8, 6, 4, 1, 3, 7)
set.seed(12)
powmut2(offspring, lb=lb, ub=ub, mutpow=mutpow)
</code></pre>

<hr>
<h2 id='px1'>
One-point Crossover
</h2><span id='topic+px1'></span>

<h3>Description</h3>

<p>One-point crossover is where randomly selected parent chromosomes from the mating pool are cut at one point and then recombine to generate off-springs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>px1(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="px1_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="px1_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="px1_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="px1_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
px1(parent1, parent2)
</code></pre>

<hr>
<h2 id='randmut'>
Random Resetting Mutation
</h2><span id='topic+randmut'></span>

<h3>Description</h3>

<p>The Random Resetting Mutation operator replaces the value of a randomly selected gene with a randomly selected value between the allowed limits for that gene.
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randmut(y, lb, ub, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randmut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="randmut_+3A_lb">lb</code></td>
<td>
<p>A vector. Lower bounds of genes</p>
</td></tr>
<tr><td><code id="randmut_+3A_ub">ub</code></td>
<td>
<p>A vector. Upper bounds of genes</p>
</td></tr>
<tr><td><code id="randmut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,
<code><a href="#topic+nunimut2">nunimut2</a></code>,  
<code><a href="#topic+powmut">powmut</a></code>,
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(2, 1, 3, 1, 0, 4)
ub = c(10, 15, 8, 5, 6, 9)
offspring = c(8, 6, 4, 1, 3, 7)
randmut(offspring, lb, ub)
</code></pre>

<hr>
<h2 id='randmut2'>
Random mutation 2
</h2><span id='topic+randmut2'></span>

<h3>Description</h3>

<p>For each gene, if a random number is less than the mutation rate, the gene's value is modified by adding a random value selected from the normal distribution with a mean of zero and a standard deviation of 0.1x(ub-lb).
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randmut2(y, lb, ub, mutpm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randmut2_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="randmut2_+3A_lb">lb</code></td>
<td>
<p>A vector. Lower bounds of genes</p>
</td></tr>
<tr><td><code id="randmut2_+3A_ub">ub</code></td>
<td>
<p>A vector. Upper bounds of genes</p>
</td></tr>
<tr><td><code id="randmut2_+3A_mutpm">mutpm</code></td>
<td>
<p>Mutation rate</p>
</td></tr>
<tr><td><code id="randmut2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,
<code><a href="#topic+nunimut2">nunimut2</a></code>,  
<code><a href="#topic+powmut">powmut</a></code>,
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c( 2,  1, 3, 1, 0, 4)
ub = c(10, 15, 8, 5, 6, 9)
offspring = c(8, 6, 4, 1, 3, 7)
randmut2(offspring, lb=lb, ub=ub, mutpm=0.1)
</code></pre>

<hr>
<h2 id='randmut3'>
Random mutation 3
</h2><span id='topic+randmut3'></span>

<h3>Description</h3>

<p>For each gene, if a random number is less than the mutation rate, the gene's mean value is zero and its standard deviation is |ub-lb| The random value selected from the normal distribution is changed by adding it (Yoon &amp; Kim, 2012).
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randmut3(y, lb, ub, mutpm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randmut3_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="randmut3_+3A_lb">lb</code></td>
<td>
<p>A vector. Lower bounds of genes</p>
</td></tr>
<tr><td><code id="randmut3_+3A_ub">ub</code></td>
<td>
<p>A vector. Upper bounds of genes</p>
</td></tr>
<tr><td><code id="randmut3_+3A_mutpm">mutpm</code></td>
<td>
<p>Mutation rate</p>
</td></tr>
<tr><td><code id="randmut3_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Yoon, Y. and Kim, Y.H. (2012). The roles of crossover and mutation in real-coded  genetic algorithms. In <em>Bioinspired Computational Algorithms and Their Applications (ed. S. Gao)</em>. London: INTECH Open Access Publisher. pp. 65-82.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,
<code><a href="#topic+nunimut2">nunimut2</a></code>,  
<code><a href="#topic+powmut">powmut</a></code>,
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(2, 1, 3, 1, 0, 4)
ub = c(10, 15, 8, 5, 6, 9)
offspring = c(8, 6, 4, 1, 3, 7)
randmut3(offspring, lb=lb, ub=ub, mutpm=0.1)
</code></pre>

<hr>
<h2 id='randmut4'>
Random mutation 4 
</h2><span id='topic+randmut4'></span>

<h3>Description</h3>

<p>An alternative random mutation operator proposed by Wijayaningrum et.al. (2017).
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randmut4(y, lb, ub,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randmut4_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="randmut4_+3A_lb">lb</code></td>
<td>
<p>A vector. Lower bounds of genes</p>
</td></tr>
<tr><td><code id="randmut4_+3A_ub">ub</code></td>
<td>
<p>A vector. Upper bounds of genes</p>
</td></tr>
<tr><td><code id="randmut4_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Wijayaningrum, V.N., Starkweather, T. and D'ann, F. (2017). Scheduling problemsand traveling salesman: The genetic edge recombination operators. In <em>Proc. of ICGA</em>, Vol. 89, pp. 133-40.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,
<code><a href="#topic+nunimut2">nunimut2</a></code>,  
<code><a href="#topic+powmut">powmut</a></code>,
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(2, 1, 3, 1, 0, 4)
ub = c(10, 15, 8, 5, 6, 9)
offspring = c(8, 6, 4, 1, 3, 7)
randmut4(offspring, lb=lb, ub=ub)
</code></pre>

<hr>
<h2 id='raoc'>
Randomized And/Or Crossover (RAOC)
</h2><span id='topic+raoc'></span>

<h3>Description</h3>

<p>The Randomized And/Or Crossover (RAOC) operator processes parental chromosomes with AND/OR. According to the value of a randomly selected number, one of the offspring is determined by AND and the other is determined by the OR operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raoc(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raoc_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="raoc_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="raoc_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="raoc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
raoc(parent1, parent2)
</code></pre>

<hr>
<h2 id='rrc'>
Random Respectful Crossover (RRC)
</h2><span id='topic+rrc'></span>

<h3>Description</h3>

<p>It is a crossover function that transfers genes that are equal at a particular locus on the parent chromosomes to the offspring as they are while transferring the different ones randomly (Radcliffe, 1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrc(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rrc_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="rrc_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="rrc_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="rrc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Radcliffe N.J. (1991). Forma analysis and Random Restpectful Recombination. In <em>4th Int. Conf. on Genetic Algorithms</em>. Vol. 91, pp. 222-229. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
rrc(parent1, parent2)
</code></pre>

<hr>
<h2 id='rsc'>
Reduced Surrogate Cross
</h2><span id='topic+rsc'></span>

<h3>Description</h3>

<p>Minimizes undesirable crossover results when parents have the same or many identical genes (Booker, 1987).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsc(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rsc_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="rsc_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="rsc_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="rsc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Booker L.B. (1987). Improving Search in Genetic Algorithms, in <em>Genetic Algorithms and Simulated Anneling</em>, Morgan Kaufmann Publishing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
rsc(parent1, parent2)
</code></pre>

<hr>
<h2 id='sax'>
Single Arithmetic Crossover 
</h2><span id='topic+sax'></span>

<h3>Description</h3>

<p>The Single Arithmetic Crossover (SAX) operator calculates the arithmetic mean by multiplying the parts of the Parents after a randomly determined breakpoint by a random value. Other elements remain the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sax(x1, x2, cxon, cxalfa, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sax_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="sax_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="sax_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="sax_+3A_cxalfa">cxalfa</code></td>
<td>
<p>Alpha value. If no value is entered, it is randomly selected by the function in the range [0,1].</p>
</td></tr>
<tr><td><code id="sax_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
sax(parent1, parent2)
</code></pre>

<hr>
<h2 id='sc'>
Shuffle Crossover
</h2><span id='topic+sc'></span>

<h3>Description</h3>

<p>After the SC operator determines a random cut point, it randomly shuffles both parental chromosomes and performs a single-point crossover.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sc_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="sc_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="sc_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="sc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
sc(parent1, parent2)
</code></pre>

<hr>
<h2 id='selboltour'>
Boltzmann Tournament Selection
</h2><span id='topic+selboltour'></span>

<h3>Description</h3>

<p>In the Boltzman tournament, the initial selection pressure is low. Therefore, every individual, whether low or high fitness value, has a chance to be selected. In the following generations, the selection pressure gradually increases. In other words, individuals with high fitness value are forced to be selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selboltour(fitvals, ns, selt0, selg, selgmax, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selboltour_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selboltour_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selboltour_+3A_selt0">selt0</code></td>
<td>
<p>Number, Initial temperature</p>
</td></tr>
<tr><td><code id="selboltour_+3A_selg">selg</code></td>
<td>
<p>Current generation number</p>
</td></tr>
<tr><td><code id="selboltour_+3A_selgmax">selgmax</code></td>
<td>
<p>Maximum generation number</p>
</td></tr>
<tr><td><code id="selboltour_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6, -1, 2, 4, 5)             # Fitness Values
cnames = paste0("C",1:length(fitvals))  # Chromosome Names
matpool = selboltour(fitvals, selt0=100, selg=5, selgmax=100)
cat(cnames[matpool],"\n")
matpool = selboltour(fitvals, selt0=100, selg=95, selgmax=100)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='seldet'>
Deterministic Selection
</h2><span id='topic+seldet'></span>

<h3>Description</h3>

<p>Deterministic Selection is similar to Remainder Stochastic Selection. The expected value of each individual in the mating pool is calculated. Individuals are copied directly into the mating pool by the exact number of expected values. Then, sorting is done according to the fraction part of the expected values. In this case, the individuals with the highest fractions go to the top of the list to be selected. The number of individuals required to complete the mating pool to population size is selected by going from the beginning of the list to the end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seldet(fitvals, ns, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seldet_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="seldet_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="seldet_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>      
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6, 1, 2, 4, 5)
cnames = paste0("C",1:length(fitvals))
matpool = seldet(fitvals)
cat("Selected chromosomes: ", cnames[matpool], "\n")
</code></pre>

<hr>
<h2 id='select'>
Select parents for the mating pool
</h2><span id='topic+select'></span>

<h3>Description</h3>

<p>The select function is a function that wraps all parent selection algorithms. It is coded for call purposes from adana main function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select(selfunc, fitvals, ns, selb, selbc,
                  selc, selk, sells, selns, selps, sels, selt, 
                  selt0, selw, selg, selgmax, fmin, reptype, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_+3A_selfunc">selfunc</code></td>
<td>
<p>Name of selection function</p>
</td></tr>
<tr><td><code id="select_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="select_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="select_+3A_selb">selb</code></td>
<td>
<p>Exponent coefficent,  (<code>selb &gt;= 0.0</code>)</p>
</td></tr>  
<tr><td><code id="select_+3A_selbc">selbc</code></td>
<td>
<p>Base of exponent</p>
</td></tr>  
<tr><td><code id="select_+3A_selc">selc</code></td>
<td>
<p>Scaling parameter</p>
</td></tr>  
<tr><td><code id="select_+3A_selk">selk</code></td>
<td>
<p>Power factor</p>
</td></tr>  
<tr><td><code id="select_+3A_sells">sells</code></td>
<td>
<p>Scaling factor</p>
</td></tr>  
<tr><td><code id="select_+3A_selns">selns</code></td>
<td>
<p>Number of Selection pressure</p>
</td></tr>  
<tr><td><code id="select_+3A_selps">selps</code></td>
<td>
<p>Percentage of Selection,  (<code>0.0 &lt;= selps &lt;= 1.0</code>)</p>
</td></tr>
<tr><td><code id="select_+3A_sels">sels</code></td>
<td>
<p>Selection pressure,   (<code>1.0 &lt;= sels &lt;= 2.0</code>)</p>
</td></tr>  
<tr><td><code id="select_+3A_selt">selt</code></td>
<td>
<p>Number of tournament size</p>
</td></tr>  
<tr><td><code id="select_+3A_selt0">selt0</code></td>
<td>
<p>Number, Initial temperature</p>
</td></tr>
<tr><td><code id="select_+3A_selw">selw</code></td>
<td>
<p>Number, Window Size</p>
</td></tr>
<tr><td><code id="select_+3A_selg">selg</code></td>
<td>
<p>Current generation number</p>
</td></tr>  
<tr><td><code id="select_+3A_selgmax">selgmax</code></td>
<td>
<p>Maximum generation number</p>
</td></tr>  
<tr><td><code id="select_+3A_fmin">fmin</code></td>
<td>
<p>The number to subtract from all fitness values.</p>
</td></tr>  
<tr><td><code id="select_+3A_reptype">reptype</code></td>
<td>
<p>Type of Sampling, <code>TRUE : without repetitions</code>, <code>FALSE : with repetitions</code></p>
</td></tr>  
<tr><td><code id="select_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Cebeci, Z. (2021). R ile Genetik Algoritmalar ve Optimizasyon Uygulamalari, 535 p. Ankara:Nobel Akademik Yayincilik. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code>,
<code><a href="#topic+sellrs">sellrs</a></code>,
<code><a href="#topic+sellrs2">sellrs2</a></code>,
<code><a href="#topic+sellrs3">sellrs3</a></code>,
<code><a href="#topic+selnlrs">selnlrs</a></code>,
<code><a href="#topic+selers">selers</a></code>,
<code><a href="#topic+seltrunc">seltrunc</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create population
population = initialize(initfunc=initbin, n=10, m=8)
head(population, 5)
# Calculate fitness values
m = ncol(population)-2
fitvals = evaluate(maxone, population[,1:m])
population[,"fitval"] = fitvals
head(population, 5)
# Select parents by RWS
selidx = select(selfunc=selrws, fitvals=fitvals)
matpool = population[selidx,]
head(matpool, 5)
# Selected chromosomes
table(rownames(matpool))
</code></pre>

<hr>
<h2 id='selers'>
Exponantial Ranking Selection
</h2><span id='topic+selers'></span>

<h3>Description</h3>

<p>The Exponantial Ranking Selection operator is a selection operator that uses probabilities obtained by exponentially weighting the ordinal numbers of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selers(fitvals, ns, selbc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selers_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selers_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selers_+3A_selbc">selbc</code></td>
<td>
<p>Base of exponent</p>
</td></tr>
<tr><td><code id="selers_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code>,
<code><a href="#topic+sellrs">sellrs</a></code>,
<code><a href="#topic+sellrs2">sellrs2</a></code>,
<code><a href="#topic+sellrs3">sellrs3</a></code>,
<code><a href="#topic+selnlrs">selnlrs</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6, -1, 2, 4, 5) 
cnames = paste0("C",1:length(fitvals)) 
matpool = selers(fitvals, selbc=0.1)
cat(cnames[matpool],"\n")
matpool = selers(fitvals, selbc=0.8)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='selescale'>
Exponent Scaling
</h2><span id='topic+selescale'></span>

<h3>Description</h3>

<p>The Exponent Scaling operator is the selection operator in which the fitness values are scaled by the simulated annealing method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selescale(fitvals, ns, selb, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selescale_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selescale_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selescale_+3A_selb">selb</code></td>
<td>
<p>Exponent coefficent,  (<code>selb &gt;= 0.0</code>)</p>
</td></tr> 
<tr><td><code id="selescale_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6.1, 3.5, 6.2, 4.4, 5.2)
cnames = paste0("C",1:length(fitvals))
matpool = selescale(fitvals, selb=0.1)
cat(cnames[matpool],"\n")
matpool = selescale(fitvals, selb=2)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='sellrs'>
Linear Ranking Selection 1
</h2><span id='topic+sellrs'></span>

<h3>Description</h3>

<p>The Linear Ranking Selection operator selects via probabilities obtained using ordered numbers according to their fitness values (Pohlheim, 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sellrs(fitvals, ns, sels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sellrs_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="sellrs_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="sellrs_+3A_sels">sels</code></td>
<td>
<p>Selection pressure,   (<code>1.0 &lt;= sels &lt;= 2.0</code>)</p>
</td></tr>
<tr><td><code id="sellrs_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Pohlheim, H. (2020). Tutorial for &quot;GEATbx: Genetic and Evolutionary Algorithms Toolbox for use with MATLAB&quot;, Version 3.30, URL http://www.geatbx.com/ver_3_3/algindex-02html#P181_11564.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6.1, 3.5, 6.2, 4.4, 5.2)    # Fitness Values
cnames = paste0("C",1:length(fitvals))  # Chromosome Names
matpool = sellrs(fitvals)
cat(cnames[matpool],"\n")
matpool = sellrs(fitvals, sels=2)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='sellrs2'>
Linear Ranking Selection 2
</h2><span id='topic+sellrs2'></span>

<h3>Description</h3>

<p>The Linear Ranking Selection-2 operator selects via probabilities obtained using ordered numbers according to their fitness values. Selection pressure is not applied in this algorithm (Scrucca, 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sellrs2(fitvals, ns, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sellrs2_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="sellrs2_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="sellrs2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Scrucca, L. (2013). GA: A package for Genetic Algorithms in R. <em>Journal of Statistical Software</em>, 53(4), 1-37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code>,
<code><a href="#topic+sellrs">sellrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6.1, 3.5, 6.2, 4.4, 5.2)
cnames = paste0("C",1:length(fitvals))
matpool = sellrs2(fitvals)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='sellrs3'>
Linear Ranking Selection 3
</h2><span id='topic+sellrs3'></span>

<h3>Description</h3>

<p>The LRS operator selects through probabilities obtained using ordered numbers according to their fitness values. In this algorithm, the selection pressure can be adjusted with the s parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sellrs3(fitvals, ns, sels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sellrs3_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="sellrs3_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="sellrs3_+3A_sels">sels</code></td>
<td>
<p>Selection pressure,   (<code>1.0 &lt;= sels &lt;= 2.0</code>)</p>
</td></tr>
<tr><td><code id="sellrs3_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code>,
<code><a href="#topic+sellrs">sellrs</a></code>,
<code><a href="#topic+sellrs2">sellrs2</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6.1, 3.5, 6.2, 4.4, 5.2)
cnames = paste0("C",1:length(fitvals)) 
matpool = sellrs3(fitvals)
cat(cnames[matpool],"\n")
matpool = sellrs3(fitvals, sels=2)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='sellscale'>
Fitness Linear Scaling
</h2><span id='topic+sellscale'></span>

<h3>Description</h3>

<p>The Fitness Linear Scaling operator scales the fitness values using a linear regression model and performs the selection (Louis, 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sellscale(fitvals, ns, sells, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sellscale_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="sellscale_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="sellscale_+3A_sells">sells</code></td>
<td>
<p>Scaling factor</p>
</td></tr>
<tr><td><code id="sellscale_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Louis, S.J. (2019). Scaling in Genetic Algorithms. URL https://www.cse.unr.edu/~sushil/class/gas/notes/scaling.pdf 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6.1, 3.5, 6.2, 4.4, 5.2)
cnames = paste0("C",1:length(fitvals))
matpool = sellscale(fitvals)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='selnlrs'>
Nonlinear Ranking Selection
</h2><span id='topic+selnlrs'></span>

<h3>Description</h3>

<p>The Nonlinear Ranking Selection is a nonlinear selection method that applies higher selection pressure than the Linear Ranking Selection (Pholheim, 1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selnlrs(fitvals, ns, selns, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selnlrs_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selnlrs_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selnlrs_+3A_selns">selns</code></td>
<td>
<p>Number of Selection pressure</p>
</td></tr>
<tr><td><code id="selnlrs_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Pholheim, H. (1995). Ein genetischer algorithmus mit mehrfachpopulationen zur numerischen optimierung. <em>at-Automatisierungstechnik</em>, 43(3), 127-135.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code>,
<code><a href="#topic+sellrs">sellrs</a></code>,
<code><a href="#topic+sellrs2">sellrs2</a></code>,
<code><a href="#topic+sellrs3">sellrs3</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6.1, 3.5, 6.2, 4.4, 5.2)
cnames = paste0("C",1:length(fitvals))
matpool = selnlrs(fitvals)
cat(cnames[matpool],"\n")
matpool = selnlrs(fitvals, selns=0.1)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='selpscale'>
Power-law Scaling
</h2><span id='topic+selpscale'></span>

<h3>Description</h3>

<p>the Power-law Scaling is a selection method in which the <em>k</em>th power of the fit values is used as the scaled fit values (Gillies, 1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selpscale(fitvals, ns, selk, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selpscale_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selpscale_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selpscale_+3A_selk">selk</code></td>
<td>
<p>Power factor</p>
</td></tr> 
<tr><td><code id="selpscale_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Gillies, A.M. (1985). Machine learning procedures for generating image domain feature detectors. PhD thesis, University of Michigan, Ann Arbor.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6.1, 3.5, 6.2, 4.4, 5.2)
cnames = paste0("C",1:length(fitvals))
matpool = selpscale(fitvals, selk=1.1)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='selrand'>
Random selection
</h2><span id='topic+selrand'></span>

<h3>Description</h3>

<p>Random selection is the process of selecting parents completely randomly from the current population, regardless of the individual's fitness values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selrand(fitvals, ns, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selrand_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selrand_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selrand_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Random selection is done by simple random sampling method with replacement. Each individual has an equal chance <code>(p = 1/n)</code> of being selected.
</p>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+seltrunc">seltrunc</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code>,
<code><a href="#topic+sellrs">sellrs</a></code>,
<code><a href="#topic+sellrs2">sellrs2</a></code>,
<code><a href="#topic+sellrs3">sellrs3</a></code>,
<code><a href="#topic+selnlrs">selnlrs</a></code>,
<code><a href="#topic+selers">selers</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6, -1, 2, 4, 5)            # Fitness values
cnames = paste0("C",1:length(fitvals)) # Chromose names
matpool = selrand(fitvals)
cat("Selected Chromosomes: ", cnames[matpool], "\n")
</code></pre>

<hr>
<h2 id='selrscale'>
Rank Scaling
</h2><span id='topic+selrscale'></span>

<h3>Description</h3>

<p>The Rank Scaling is a selection method in which fitness values are scaled according to their ordinal number. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selrscale(fitvals, ns, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selrscale_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selrscale_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selrscale_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6.1, 3.5, 6.2, 4.4, 5.2)
cnames = paste0("C",1:length(fitvals))
matpool = selrscale(fitvals)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='selrscale2'>
Rank Scaling 2
</h2><span id='topic+selrscale2'></span>

<h3>Description</h3>

<p>The Rank Scaling-2 is a selection method in which fitness values are scaled according to their ordinal number. Selection pressure can be adjusted by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selrscale2(fitvals, ns, sels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selrscale2_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selrscale2_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selrscale2_+3A_sels">sels</code></td>
<td>
<p>Scaling factor,  (<code>1.0 &lt;= sels &lt;= 2.0</code>)</p>
</td></tr>  
<tr><td><code id="selrscale2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>     
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6.1, 3.5, 6.2, 4.4, 5.2)
cnames = paste0("C",1:length(fitvals))
matpool = selrscale2(fitvals)
cat(cnames[matpool],"\n")
matpool = selrscale2(fitvals, sels=2)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='selrss'>
Remainder Stochastic Selection
</h2><span id='topic+selrss'></span>

<h3>Description</h3>

<p>The fitness probability of individuals is multiplied by the population size to calculate the number of times the individual will reproduce in the mating pool, ie the expected number of copies. The expected number of copies is a fractional number. An exact fraction of the expected number of copies of the individual is sent to the mating pool. It is also determined whether it can go back to the mating pool for the fraction part (Brindle, 1981).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selrss(fitvals, ns, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selrss_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selrss_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selrss_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Brindle, A. (1981). Genetic algorithms for function optimization. PhD thesis, University of Alberta.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code> ,
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>       
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6, 1, 2, 4, 5)
cnames = paste0("C",1:length(fitvals))
matpool = selrss(fitvals)
cat("Selected Chromosomes: ", cnames[matpool], "\n")
</code></pre>

<hr>
<h2 id='selrswrp'>
Random selection with replacement and proportion
</h2><span id='topic+selrswrp'></span>

<h3>Description</h3>

<p>Random selection is made by simple random sampling method with replacements, based on the fitness values of individuals. Each individual has the chance to be selected proportionally to their fitness value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selrswrp(fitvals, ns, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selrswrp_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selrswrp_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selrswrp_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+seltrunc">seltrunc</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code>,
<code><a href="#topic+sellrs">sellrs</a></code>,
<code><a href="#topic+sellrs2">sellrs2</a></code>,
<code><a href="#topic+sellrs3">sellrs3</a></code>,
<code><a href="#topic+selnlrs">selnlrs</a></code>,
<code><a href="#topic+selers">selers</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6, 1, 2, 4, 5)              # Fitness Values
cnames = paste0("C",1:length(fitvals))  # Chromosome names
matpool = selrswrp(fitvals)
cat("Selected Chromosomes: ", cnames[matpool], "\n")
</code></pre>

<hr>
<h2 id='selrws'>
Roulette wheel selection 1
</h2><span id='topic+selrws'></span>

<h3>Description</h3>

<p>This function provides the opportunity to take more than one place in the mating pool in proportion to the fitness value of each individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selrws(fitvals, ns, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selrws_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selrws_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selrws_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+seltrunc">seltrunc</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code>,
<code><a href="#topic+sellrs">sellrs</a></code>,
<code><a href="#topic+sellrs2">sellrs2</a></code>,
<code><a href="#topic+sellrs3">sellrs3</a></code>,
<code><a href="#topic+selnlrs">selnlrs</a></code>,
<code><a href="#topic+selers">selers</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6, 1, 2, 4, 5)
cnames = paste0("C",1:length(fitvals))
matpool = selrws(fitvals)
cat("Selected Chromosomes: ", cnames[matpool], "\n")
</code></pre>

<hr>
<h2 id='selrws2'>
Roulette wheel selection 2
</h2><span id='topic+selrws2'></span>

<h3>Description</h3>

<p>This function provides the opportunity to take more than one place in the mating pool in proportion to the fitness value of each individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selrws2(fitvals, ns, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selrws2_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selrws2_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selrws2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+seltrunc">seltrunc</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code>,
<code><a href="#topic+sellrs">sellrs</a></code>,
<code><a href="#topic+sellrs2">sellrs2</a></code>,
<code><a href="#topic+sellrs3">sellrs3</a></code>,
<code><a href="#topic+selnlrs">selnlrs</a></code>,
<code><a href="#topic+selers">selers</a></code>   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6, 1, 2, 4, 5)
cnames = paste0("C",1:length(fitvals))
matpool = selrws(fitvals)
cat("Selected Chromosomes: ", cnames[matpool], "\n")
</code></pre>

<hr>
<h2 id='selsscale'>
Sigma Scaling
</h2><span id='topic+selsscale'></span>

<h3>Description</h3>

<p>Sigma Scaling is based on the mean rather than the worst fitness value as in Window Scaling. In Sigma Scaling, an individual's fitness is a function of the population mean and population standard deviation (Forrest, 1985; Goldberg, 1989).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selsscale(fitvals, ns, selc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selsscale_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selsscale_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selsscale_+3A_selc">selc</code></td>
<td>
<p>Scaling parameter</p>
</td></tr>
<tr><td><code id="selsscale_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Forrest, S. (1985). Documentation of prisoner's dilemma and norms programs that use the genetic algorithm. Technical report, University of Michigan.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>     
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6.1, 3.5, 6.2, 4.4, 5.2)
cnames = paste0("C",1:length(fitvals))
matpool = selsscale(fitvals, selc=2)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='selsscale2'>
Sigma scaling 2
</h2><span id='topic+selsscale2'></span>

<h3>Description</h3>

<p>Sigma Scaling is based on the mean rather than the worst fitness value as in Window Scaling. In Sigma Scaling, an individual's fitness is a function of the population mean and population standard deviation. In this approach, if the scaled value is less than zero, it is set to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selsscale2(fitvals, ns, selc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selsscale2_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selsscale2_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selsscale2_+3A_selc">selc</code></td>
<td>
<p>Scaling parameter</p>
</td></tr>
<tr><td><code id="selsscale2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6.1, 3.5, 6.2, 4.4, 5.2)
cnames = paste0("C",1:length(fitvals))
matpool = selsscale2(fitvals)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='selsus'>
Stochastic Universal Selection
</h2><span id='topic+selsus'></span>

<h3>Description</h3>

<p>The Stochastic Universal Selection is the Roulette Wheel Selection method with multiple winning points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selsus(fitvals, ns, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selsus_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selsus_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selsus_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>       
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6, 1, 2, 4, 5)
cnames = paste0("C",1:length(fitvals))
matpool = selsus(fitvals)
cat("Selected Chromosomes: ", cnames[matpool], "\n")
</code></pre>

<hr>
<h2 id='seltour'>
Tournament Selection
</h2><span id='topic+seltour'></span>

<h3>Description</h3>

<p>The best one is selected in the group consisting of t individuals selected by random sampling with or without replacement from the current population (Smith et.al, 1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seltour(fitvals, ns, selt, reptype, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seltour_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="seltour_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="seltour_+3A_selt">selt</code></td>
<td>
<p>Number of tournament size</p>
</td></tr>
<tr><td><code id="seltour_+3A_reptype">reptype</code></td>
<td>
<p>Type of Sampling, <code>TRUE : without repetitions</code>, <code>FALSE : with repetitions</code></p>
</td></tr> 
<tr><td><code id="seltour_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Smith, R.E., Goldberg, D.E. and Earickson, J.A. (1991). SGA-C: A C-language implementation of a simple gewnetic algorithm. Technical report 91002, Illinois Genetic Algorithms Laboratory, Urbana, IL, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>selt = 2                               # Size of tournament
fitvals = c(6, -1, 2, 4, 5)            # Fitness values
cnames = paste0("C",1:length(fitvals)) # Chromosome names
matpool = seltour(fitvals, selt=selt)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='seltour2'>
Tournament Selection 2
</h2><span id='topic+seltour2'></span>

<h3>Description</h3>

<p>Each individual is given a chance to participate in the tournament at least once in selection by tournament in this function. For this reason, individuals participating in the tournament cannot participate in another tournament, but after the tournament of all individuals is completed, they can get a chance to participate in another tournament (Nicolau, 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seltour2(fitvals, ns, selt, reptype, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seltour2_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="seltour2_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="seltour2_+3A_selt">selt</code></td>
<td>
<p>Number of tournament size</p>
</td></tr>
<tr><td><code id="seltour2_+3A_reptype">reptype</code></td>
<td>
<p>Type of Sampling, <code>TRUE : without repetitions</code>, <code>FALSE : with repetitions</code></p>
</td></tr> 
<tr><td><code id="seltour2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Nicolau, M. (2009). Application of a simple binary genetic algorithm to a noiseless testbed benchmark. In <em>Proc. genetic and Evolutionary Computation Conf. (GECCO)</em>, Montreal, Canada.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code>,
<code><a href="#topic+sellrs">sellrs</a></code>,
<code><a href="#topic+sellrs2">sellrs2</a></code>,
<code><a href="#topic+sellrs3">sellrs3</a></code>,
<code><a href="#topic+selnlrs">selnlrs</a></code>,
<code><a href="#topic+selers">selers</a></code>,
<code><a href="#topic+seltrunc">seltrunc</a></code>,
<code><a href="#topic+select">select</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>selt = 2                    # Size of tournament
fitvals = c(6, -1, 2, 4, 5) # Fitness values
cnames = paste0("C",1:length(fitvals)) # Chromosome names
matpool = seltour2(fitvals, selt=selt)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='seltrunc'>
Truncation Selection
</h2><span id='topic+seltrunc'></span>

<h3>Description</h3>

<p>Individuals in the population are ranked according to their fitness value and individuals with higher fitness value than a determined threshold value are included in the mating pool.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seltrunc(fitvals, ns, selps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seltrunc_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="seltrunc_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="seltrunc_+3A_selps">selps</code></td>
<td>
<p>Percentage of Selection,  (<code>0.0 &lt;= selps &lt;= 1.0</code>)</p>
</td></tr>
<tr><td><code id="seltrunc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,  
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selwscale">selwscale</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,  
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>,
<code><a href="#topic+selboltour">selboltour</a></code>,
<code><a href="#topic+sellrs">sellrs</a></code>,
<code><a href="#topic+sellrs2">sellrs2</a></code>,
<code><a href="#topic+sellrs3">sellrs3</a></code>,
<code><a href="#topic+selnlrs">selnlrs</a></code>,
<code><a href="#topic+selers">selers</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6, -1, 2, 4, 5) 
cnames = paste0("C",1:length(fitvals)) 
matpool = seltrunc(fitvals, selps=0.60)
cat(cnames[matpool],"\n")  
</code></pre>

<hr>
<h2 id='selwscale'>
Window Scaling
</h2><span id='topic+selwscale'></span>

<h3>Description</h3>

<p>Window Scaling is a method based on subtracting the worst fitness value from the other fitness values. In this case, since the scaled values of the worst fit individuals will be 0, these individuals will not be given a chance to be selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selwscale(fitvals, ns, fmin, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selwscale_+3A_fitvals">fitvals</code></td>
<td>
<p>Vector of fitness values belonging to individuals</p>
</td></tr>
<tr><td><code id="selwscale_+3A_ns">ns</code></td>
<td>
<p>Number of individuals to be selected</p>
</td></tr>
<tr><td><code id="selwscale_+3A_fmin">fmin</code></td>
<td>
<p>The number to subtract from all fitness values.</p>
</td></tr>
<tr><td><code id="selwscale_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indices of randomly selected individuals are returned.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>,
<code><a href="#topic+selrand">selrand</a></code>,
<code><a href="#topic+selrswrp">selrswrp</a></code>,
<code><a href="#topic+selrws">selrws</a></code>,
<code><a href="#topic+selrws2">selrws2</a></code>,
<code><a href="#topic+selsus">selsus</a></code>,
<code><a href="#topic+seldet">seldet</a></code>,
<code><a href="#topic+selrss">selrss</a></code>,
<code><a href="#topic+selsscale">selsscale</a></code>,
<code><a href="#topic+selsscale2">selsscale2</a></code>,
<code><a href="#topic+sellscale">sellscale</a></code>,
<code><a href="#topic+selrscale">selrscale</a></code>,
<code><a href="#topic+selrscale2">selrscale2</a></code>,
<code><a href="#topic+selpscale">selpscale</a></code>,
<code><a href="#topic+selescale">selescale</a></code>,
<code><a href="#topic+seltour">seltour</a></code>,
<code><a href="#topic+seltour2">seltour2</a></code>       
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitvals = c(6.1, 3.5, 6.2, 4.4, 5.2)
fmin = min(fitvals)
cnames = paste0("C",1:length(fitvals))
matpool = selwscale(fitvals, fmin=fmin)
cat(cnames[matpool],"\n")
fitvals = fitvals[matpool]
fitvals
matpool = selwscale(fitvals, fmin=fmin)
cat(cnames[matpool],"\n")
fitvals = fitvals[matpool]
fitvals
fmin = min(fitvals)
matpool = selwscale(fitvals, fmin=fmin)
cat(cnames[matpool],"\n")
</code></pre>

<hr>
<h2 id='show'>
Function to visualize iteration results
</h2><span id='topic+show'></span>

<h3>Description</h3>

<p>The show function provides access to user-defined visualization functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show(monitorfunc, g, genfits, objective, x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_+3A_monitorfunc">monitorfunc</code></td>
<td>
<p>Monitoring function</p>
</td></tr>
<tr><td><code id="show_+3A_g">g</code></td>
<td>
<p>Generation number</p>
</td></tr>
<tr><td><code id="show_+3A_genfits">genfits</code></td>
<td>
<p>A matrix for fitness values</p>
</td></tr>
<tr><td><code id="show_+3A_objective">objective</code></td>
<td>
<p>Type of optimization. &quot;min&quot; or &quot;max&quot;</p>
</td></tr>
<tr><td><code id="show_+3A_x">x</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="show_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NA
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monprogress">monprogress</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 100
genfits = matrix(NA, nrow=n, ncol=5)
genfits[1,3] = 50
objective = "max"
monitorfunc = monprogress
for(i in 1:(n-1)){
  g=i
  show(monitorfunc,  g=g, genfits=genfits, 
    objective=objective, x=NULL)
  genfits[g+1, 3] = genfits[g, 3] + runif(1, -2, 5)
}
</code></pre>

<hr>
<h2 id='shufmut'>
Shuffle Mutation
</h2><span id='topic+shufmut'></span>

<h3>Description</h3>

<p>Shuffle Mutation works by randomly shuffling the values in a randomly selected subset of the chromosome (Syswerda, 1991).
</p>
<p>This operator is used in problems with permutation encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shufmut(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shufmut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="shufmut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutrange</code></td>
<td>
<p>A vector. The numbers of begining and ending of the mutated genes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Syswerda, G. (1991). Schedule optimization using genetic algorithms. <em>Handbook of Genetic Algorithms</em>.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,        
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,   
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offspring = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
shufmut(offspring)
</code></pre>

<hr>
<h2 id='smc'>
Sinusoidal Motion Crossover (SMC)
</h2><span id='topic+smc'></span>

<h3>Description</h3>

<p>The proposed algorithm with the name of SMC is a simple algorithm that works deterministic and alternatively (Kumar &amp; Panneerselvam, 2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smc(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smc_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="smc_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="smc_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="smc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Varun Kumar, S.G. and Panneerselvam R. (2017). A Study of Crossover Operators for Genetic Algorithms to Solve VRP and its Variants and New Sinusoidal Motion Crossover Operator. <em>International Journal of Computational Intelligence Research</em>. Vol 13, Number 7, pp. 1717-1733
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 2, 3, 4, 5, 6, 7, 8) 
parent2 = c(4, 6, 7, 3, 2, 1, 8, 6)
smc(parent1, parent2)
</code></pre>

<hr>
<h2 id='spherex'>
Sphere Crossover
</h2><span id='topic+spherex'></span>

<h3>Description</h3>

<p>Sphere Crossover is an operator performed by applying Sphere equality to parent chromosomes. It generates one offspring per each cross.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spherex(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spherex_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="spherex_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="spherex_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="spherex_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
spherex(parent1, parent2)
</code></pre>

<hr>
<h2 id='ssrfamtour'>
Replacement function via family tournament
</h2><span id='topic+ssrfamtour'></span>

<h3>Description</h3>

<p>The two most compatible between the two parents and their offspring are added to the new generation population, while those with low fitness are discarded (Sivanandam et.al., 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssrfamtour(parpop, offpop, reppars, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssrfamtour_+3A_parpop">parpop</code></td>
<td>
<p>A matrix. Parent population</p>
</td></tr>
<tr><td><code id="ssrfamtour_+3A_offpop">offpop</code></td>
<td>
<p>A matrix. Offspring population</p>
</td></tr>
<tr><td><code id="ssrfamtour_+3A_reppars">reppars</code></td>
<td>
<p>A vector. Indices of the parents</p>
</td></tr>
<tr><td><code id="ssrfamtour_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the new generation.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Sivanandam et.al., (2007).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grdelall">grdelall</a></code>,
<code><a href="#topic+elitism">elitism</a></code>, 
<code><a href="#topic+grmuplambda">grmuplambda</a></code>, 
<code><a href="#topic+grmuplambda2">grmuplambda2</a></code>, 
<code><a href="#topic+grmuplambda3">grmuplambda3</a></code>, 
<code><a href="#topic+grmuplambda4">grmuplambda4</a></code>, 
<code><a href="#topic+grmuvlambda">grmuvlambda</a></code>, 
<code><a href="#topic+grrobin">grrobin</a></code>,
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrgenitor">ssrgenitor</a></code>, 
<code><a href="#topic+ssrx">ssrx</a></code>
</p>

<hr>
<h2 id='ssrgenitor'>
Genitor replacement function
</h2><span id='topic+ssrgenitor'></span>

<h3>Description</h3>

<p>The offspring obtained by mating two randomly selected parents from the mating pool is placed in the place of the worst individual in the current population (Whitley, 1988).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssrgenitor(parpop, offpop, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssrgenitor_+3A_parpop">parpop</code></td>
<td>
<p>A matrix. Parent population</p>
</td></tr>
<tr><td><code id="ssrgenitor_+3A_offpop">offpop</code></td>
<td>
<p>A matrix. Offspring population</p>
</td></tr>
<tr><td><code id="ssrgenitor_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the new generation.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Whitley, L.D. (1988). GENITOR: A different genetic algorithm. In <em>Proc. of the Rocky Mountain conf. on artificial intellegence</em>, pp. 118-130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grdelall">grdelall</a></code>,
<code><a href="#topic+elitism">elitism</a></code>, 
<code><a href="#topic+grmuplambda">grmuplambda</a></code>, 
<code><a href="#topic+grmuplambda2">grmuplambda2</a></code>, 
<code><a href="#topic+grmuplambda3">grmuplambda3</a></code>, 
<code><a href="#topic+grmuplambda4">grmuplambda4</a></code>, 
<code><a href="#topic+grmuvlambda">grmuvlambda</a></code>, 
<code><a href="#topic+grrobin">grrobin</a></code>,
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrfamtour">ssrfamtour</a></code>, 
<code><a href="#topic+ssrx">ssrx</a></code>
</p>

<hr>
<h2 id='ssrmup1'>
Mu+1 replacement function
</h2><span id='topic+ssrmup1'></span>

<h3>Description</h3>

<p>Two randomly selected parents from the mating pool are mated to produce one or more offspring. The fit value of an individual randomly selected from the population is compared with the offspring with the highest fitness value. If the fitness value of the offspring is higher, the offspring is replaced with the individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssrmup1(parpop, offpop, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssrmup1_+3A_parpop">parpop</code></td>
<td>
<p>A matrix. Parent population</p>
</td></tr>
<tr><td><code id="ssrmup1_+3A_offpop">offpop</code></td>
<td>
<p>A matrix. Offspring population</p>
</td></tr>
<tr><td><code id="ssrmup1_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the new generation.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grdelall">grdelall</a></code>,
<code><a href="#topic+elitism">elitism</a></code>, 
<code><a href="#topic+grmuplambda">grmuplambda</a></code>, 
<code><a href="#topic+grmuplambda2">grmuplambda2</a></code>, 
<code><a href="#topic+grmuplambda3">grmuplambda3</a></code>, 
<code><a href="#topic+grmuplambda4">grmuplambda4</a></code>, 
<code><a href="#topic+grmuvlambda">grmuvlambda</a></code>, 
<code><a href="#topic+grrobin">grrobin</a></code>,
<code><a href="#topic+ssrgenitor">ssrgenitor</a></code>, 
<code><a href="#topic+ssrfamtour">ssrfamtour</a></code>, 
<code><a href="#topic+ssrx">ssrx</a></code>
</p>

<hr>
<h2 id='ssrx'>
Mixed replacement function
</h2><span id='topic+ssrx'></span>

<h3>Description</h3>

<p>The offspring with the best fitness value takes the place of an individual randomly selected from among the individuals excluding their parents and the individual with the worst fitness value in the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssrx(parpop, offpop, reppars, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssrx_+3A_parpop">parpop</code></td>
<td>
<p>A matrix. Parent population</p>
</td></tr>
<tr><td><code id="ssrx_+3A_offpop">offpop</code></td>
<td>
<p>A matrix. Offspring population</p>
</td></tr>
<tr><td><code id="ssrx_+3A_reppars">reppars</code></td>
<td>
<p>A vector. Indices of the parents</p>
</td></tr>
<tr><td><code id="ssrx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Population of the new generation.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grdelall">grdelall</a></code>,
<code><a href="#topic+elitism">elitism</a></code>, 
<code><a href="#topic+grmuplambda">grmuplambda</a></code>, 
<code><a href="#topic+grmuplambda2">grmuplambda2</a></code>, 
<code><a href="#topic+grmuplambda3">grmuplambda3</a></code>, 
<code><a href="#topic+grmuplambda4">grmuplambda4</a></code>, 
<code><a href="#topic+grmuvlambda">grmuvlambda</a></code>, 
<code><a href="#topic+grrobin">grrobin</a></code>,
<code><a href="#topic+ssrmup1">ssrmup1</a></code>, 
<code><a href="#topic+ssrgenitor">ssrgenitor</a></code>, 
<code><a href="#topic+ssrfamtour">ssrfamtour</a></code>
</p>

<hr>
<h2 id='swapmut'>
Swap Mutation
</h2><span id='topic+swapmut'></span>

<h3>Description</h3>

<p>SM is the reciprocal exchange of the values of two randomly selected genes on the chromosome (Banzhaf, 1990).
</p>
<p>This operator is used in problems with permutation or binary encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swapmut(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swapmut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="swapmut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>A vector. The numbers of the mutated genes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Banzhaf, W. (1990). The &quot;molecular&quot; traveling salesman. <em>Biological Cybernetics</em>, 64(1), 7-14.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+unimut">unimut</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,  
<code><a href="#topic+nunimut2">nunimut2</a></code>,
<code><a href="#topic+powmut">powmut</a></code>,   
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,        
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>offspring = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
swapmut(offspring)
</code></pre>

<hr>
<h2 id='terminate'>
Termination Control Function
</h2><span id='topic+terminate'></span>

<h3>Description</h3>

<p>The function of terminating the genetic algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terminate(tercrit, maxiter, objective, t, genfits,
                     fitvals, objval, optdif, rmcnt, rmdif, abdif, mincv,
                     sddif, rangedif, simlev, phidif, meandif, bestdif,
                     stime, maxtime)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terminate_+3A_tercrit">tercrit</code></td>
<td>
<p>A vector. Indications of termination criteria.</p>
</td></tr>
<tr><td><code id="terminate_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum iteration</p>
</td></tr>
<tr><td><code id="terminate_+3A_objective">objective</code></td>
<td>
<p>?????</p>
</td></tr>
<tr><td><code id="terminate_+3A_t">t</code></td>
<td>
<p>Generation number</p>
</td></tr>
<tr><td><code id="terminate_+3A_genfits">genfits</code></td>
<td>
<p>A matrix. Best fitness of each generation</p>
</td></tr>
<tr><td><code id="terminate_+3A_fitvals">fitvals</code></td>
<td>
<p>Fitness values of current generation</p>
</td></tr>
<tr><td><code id="terminate_+3A_objval">objval</code></td>
<td>
<p>Global optimum value</p>
</td></tr>
<tr><td><code id="terminate_+3A_optdif">optdif</code></td>
<td>
<p>Difference from global optimum value</p>
</td></tr>
<tr><td><code id="terminate_+3A_rmcnt">rmcnt</code></td>
<td>
<p>k value for minimum difference of the mean of the last k best fitness values.</p>
</td></tr>
<tr><td><code id="terminate_+3A_rmdif">rmdif</code></td>
<td>
<p>The minimum difference between the mean of the last k best fitness values and the best fitness value in the current generation.</p>
</td></tr>
<tr><td><code id="terminate_+3A_abdif">abdif</code></td>
<td>
<p>Minimum difference between best fitness value and mean of fitness values</p>
</td></tr>
<tr><td><code id="terminate_+3A_mincv">mincv</code></td>
<td>
<p>Minimum coefficient of variance</p>
</td></tr>
<tr><td><code id="terminate_+3A_sddif">sddif</code></td>
<td>
<p>The minimum difference between the last two standard deviations.</p>
</td></tr>
<tr><td><code id="terminate_+3A_rangedif">rangedif</code></td>
<td>
<p>Minimum and maximum difference (range of change)</p>
</td></tr>
<tr><td><code id="terminate_+3A_simlev">simlev</code></td>
<td>
<p>Similarity percentage of fitness values</p>
</td></tr>
<tr><td><code id="terminate_+3A_phidif">phidif</code></td>
<td>
<p>Phi convergence</p>
</td></tr>
<tr><td><code id="terminate_+3A_meandif">meandif</code></td>
<td>
<p>The minimum difference between the last two fitness values</p>
</td></tr>
<tr><td><code id="terminate_+3A_bestdif">bestdif</code></td>
<td>
<p>Percentage of difference between the last two best fitness values</p>
</td></tr>
<tr><td><code id="terminate_+3A_stime">stime</code></td>
<td>
<p>System time saved before starting GA</p>
</td></tr>
<tr><td><code id="terminate_+3A_maxtime">maxtime</code></td>
<td>
<p>Maximum running time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Termination criterion
</p>
<p>0 : No termination
</p>
<p>1 : Maximum iteration
</p>
<p>2 : Reaching the global optimum value
</p>
<p>3 : Converging the global optimum
</p>
<p>4 : The minimum difference between the last two fitness values
</p>
<p>5 : Percentage of difference between the last two best fitness values
</p>
<p>6 : Minimum difference of the mean of the last k best fitness values
</p>
<p>7 : Minimum difference between best fitness value and mean of fitness values
</p>
<p>8 : The minimum difference between the last two standard deviations.
</p>
<p>9 : Minimum and maximum difference (range of change)
</p>
<p>10: Minimum coefficient of variance
</p>
<p>11: Phi convergence
</p>
<p>12: Similarity percentage of fitness values
</p>
<p>13: Maximum running time
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>

<hr>
<h2 id='unimut'>
Uniform Mutation
</h2><span id='topic+unimut'></span>

<h3>Description</h3>

<p>The Random Resetting Mutation operator replaces the value of a randomly selected gene with a randomly selected value between the allowed limits for that gene (Michalewicz, 1994).
</p>
<p>This operator is used for value encoded (integer or real number) chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unimut(y, lb, ub, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unimut_+3A_y">y</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code id="unimut_+3A_lb">lb</code></td>
<td>
<p>A vector. Lower bounds of genes</p>
</td></tr>
<tr><td><code id="unimut_+3A_ub">ub</code></td>
<td>
<p>A vector. Upper bounds of genes</p>
</td></tr>
<tr><td><code id="unimut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mutant</code></td>
<td>
<p>A vector. Chromosome of the offspring</p>
</td></tr>
<tr><td><code>mutgen</code></td>
<td>
<p>The number of the mutated gene.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Michalewicz, . (1994).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+bitmut">bitmut</a></code>,
<code><a href="#topic+randmut">randmut</a></code>,
<code><a href="#topic+randmut2">randmut2</a></code>,
<code><a href="#topic+randmut3">randmut3</a></code>,
<code><a href="#topic+randmut4">randmut4</a></code>,
<code><a href="#topic+boundmut">boundmut</a></code>,
<code><a href="#topic+nunimut">nunimut</a></code>,
<code><a href="#topic+nunimut2">nunimut2</a></code>,  
<code><a href="#topic+powmut">powmut</a></code>,
<code><a href="#topic+powmut2">powmut2</a></code>,   
<code><a href="#topic+gaussmut">gaussmut</a></code>,   
<code><a href="#topic+gaussmut2">gaussmut2</a></code>,   
<code><a href="#topic+gaussmut3">gaussmut3</a></code>,   
<code><a href="#topic+bsearchmut1">bsearchmut1</a></code>,   
<code><a href="#topic+bsearchmut2">bsearchmut2</a></code>,        
<code><a href="#topic+swapmut">swapmut</a></code>,   
<code><a href="#topic+invmut">invmut</a></code>,   
<code><a href="#topic+shufmut">shufmut</a></code>,   
<code><a href="#topic+insmut">insmut</a></code>,   
<code><a href="#topic+dismut">dismut</a></code>,  
<code><a href="#topic+invswapmut">invswapmut</a></code>,
<code><a href="#topic+insswapmut">insswapmut</a></code>,
<code><a href="#topic+invdismut">invdismut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb = c(2, 1, 3, 1, 0, 4)
ub = c(10, 15, 8, 5, 6, 9)
offspring = c(8, 6, 4, 1, 3, 7)
unimut(offspring, lb, ub)
</code></pre>

<hr>
<h2 id='upmx'>
Uniform Partial Mapped Crossover
</h2><span id='topic+upmx'></span>

<h3>Description</h3>

<p>Uniform Partial Mapped Crossover (UPMX) is a crossover operator for permutation encoded chromosomes. Parent1 is cloned into Offspring1. A random point v1 is chosen. The gene at point v1 in Parent2 is determined. The v2 point carrying this gene is determined in Offspring1. The genes at v1 and v2 are swapped. These processes are repeated k times (Migkikh et.al., 1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upmx(x1, x2, cxon, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upmx_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="upmx_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="upmx_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="upmx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Migkikh, V.V., Topchy, A.A., Kureichick, V.M. and Tetelbaum, A.Y. (1996). Combined Genetic and local search algorithm for the quadratic assignment problem. In <em>Proc. of IC on Evolutionary Computation and Its Applications, EvCA</em>, 96, 335-341.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(0, 8, 4, 5, 6, 7, 1, 2, 3, 9)
parent2 = c(6, 7, 1, 2, 4, 8, 3, 5, 9, 0)
upmx(parent1, parent2)
</code></pre>

<hr>
<h2 id='ux'>
Uniform crossover 1
</h2><span id='topic+ux'></span>

<h3>Description</h3>

<p>In a uniform crossover, the number of crossover points is not fixed and evaluates each gene independently (De Jong &amp; Spears, 1991). In other words, it generalizes multi-point crossover as each gene locus is viewed as a potential crossover point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ux(x1, x2, cxon, cxps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ux_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="ux_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="ux_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="ux_+3A_cxps">cxps</code></td>
<td>
<p>It determines the rate of gene exchange between the chromosomes of the parents.</p>
</td></tr>
<tr><td><code id="ux_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>De Jong, K.A. and Spears, W. (1991). On the virtues of parameterized uniform crossover. In <em>Proc. of the 4th Int. Conf. on Genetic Algorithms</em>. Morgan Kaufman Publishers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
ux(parent1, parent2, cxon=3)
</code></pre>

<hr>
<h2 id='ux2'>
Uniform Crossover 2
</h2><span id='topic+ux2'></span>

<h3>Description</h3>

<p>In a uniform crossover, the number of crossover points is not fixed and evaluates each gene independently (De Jong &amp; Spears, 1991). In other words, it generalizes multi-point crossover as each gene locus is viewed as a potential crossover point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ux2(x1, x2, cxon, cxps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ux2_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="ux2_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="ux2_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="ux2_+3A_cxps">cxps</code></td>
<td>
<p>It determines the rate of gene exchange between the chromosomes of the parents.</p>
</td></tr>
<tr><td><code id="ux2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>De Jong, K.A. and Spears, W. (1991). On the virtues of parameterized uniform crossover. In <em>Proc. of the 4th Int. Conf. on Genetic Algorithms</em>. Morgan Kaufman Publishers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+wax">wax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1, 0, 1, 0, 1, 1, 1, 0)
parent2 = c(1, 1, 1, 0, 1, 0, 0, 1)
ux2(parent1, parent2, cxon=2)
</code></pre>

<hr>
<h2 id='wax'>
Whole Arithmetic Crossover
</h2><span id='topic+wax'></span>

<h3>Description</h3>

<p>New offspring are produced by applying an arithmetic mean to all of the parents' chromosomes. (Davis, 1985; Back et.al, 1991; Michalewicz &amp; Janikov, 1991; Michalewicz, 1992; Michalewicz, 1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wax(x1, x2, cxon, cxalfa, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wax_+3A_x1">x1</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-1.</p>
</td></tr>
<tr><td><code id="wax_+3A_x2">x2</code></td>
<td>
<p>A vector. It contains the chromosomal information of parent-2.</p>
</td></tr>
<tr><td><code id="wax_+3A_cxon">cxon</code></td>
<td>
<p>Number of offspring to be generated as a result of crossover</p>
</td></tr>
<tr><td><code id="wax_+3A_cxalfa">cxalfa</code></td>
<td>
<p>Alpha value. If no value is entered, it is randomly selected by the function in the range [0,1].</p>
</td></tr>
<tr><td><code id="wax_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the generated offsprings.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci &amp; Erkut Tekeli
</p>


<h3>References</h3>

<p>Davis, L. (1985). Aplaying adaptive algorithms to epistatics domains. In <em>Proc. of the Int. Joint Conf. on Artificial Intellengence</em>, Vol. 85, pp. 162-164.
</p>
<p>Back, T., Hoffmeister, F. and Schwefel, H.P. (1991). A survey of evolution strategies. In <em>Proc. of the 4th Int. Conf. on Genetic Algorithms</em>, pp. 2-9. Morgan Kaufmann.
</p>
<p>Michalewicz, Z. and Janikov, S.J. (1991). Genetic algorithms for numerical optimization. <em>Statistics and Computing</em>, 1(2), 75-91.
</p>
<p>Michalewicz, Z. (1992). <em>Genetic algorithms + data structures = evolution programs</em>. Berlin-Heidelberg: Springer Verlag. 
</p>
<p>Michalewicz, Z. (1995). Genetic algorithms, numerical optimization and constraints. In <em>Proc. of the 4th Int. Conf. on Genetic Algorithms</em>. pp. 151-158. Morgan Kaufmann. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross</a></code>,
<code><a href="#topic+px1">px1</a></code>,
<code><a href="#topic+kpx">kpx</a></code>,
<code><a href="#topic+sc">sc</a></code>,
<code><a href="#topic+rsc">rsc</a></code>,
<code><a href="#topic+hux">hux</a></code>,
<code><a href="#topic+ux">ux</a></code>,
<code><a href="#topic+ux2">ux2</a></code>,
<code><a href="#topic+mx">mx</a></code>,
<code><a href="#topic+rrc">rrc</a></code>,
<code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+atc">atc</a></code>,
<code><a href="#topic+cpc">cpc</a></code>,
<code><a href="#topic+eclc">eclc</a></code>,
<code><a href="#topic+raoc">raoc</a></code>,
<code><a href="#topic+dc">dc</a></code>,
<code><a href="#topic+ax">ax</a></code>,
<code><a href="#topic+hc">hc</a></code>,
<code><a href="#topic+sax">sax</a></code>,
<code><a href="#topic+lax">lax</a></code>,
<code><a href="#topic+bx">bx</a></code>,
<code><a href="#topic+ebx">ebx</a></code>,
<code><a href="#topic+blxa">blxa</a></code>,
<code><a href="#topic+blxab">blxab</a></code>,
<code><a href="#topic+lapx">lapx</a></code>,
<code><a href="#topic+elx">elx</a></code>,
<code><a href="#topic+geomx">geomx</a></code>,
<code><a href="#topic+spherex">spherex</a></code>,
<code><a href="#topic+pmx">pmx</a></code>,
<code><a href="#topic+mpmx">mpmx</a></code>,
<code><a href="#topic+upmx">upmx</a></code>,
<code><a href="#topic+ox">ox</a></code>,
<code><a href="#topic+ox2">ox2</a></code>,
<code><a href="#topic+mpx">mpx</a></code>,
<code><a href="#topic+erx">erx</a></code>,
<code><a href="#topic+pbx">pbx</a></code>,
<code><a href="#topic+pbx2">pbx2</a></code>,
<code><a href="#topic+cx">cx</a></code>,
<code><a href="#topic+icx">icx</a></code>,
<code><a href="#topic+smc">smc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent1 = c(1.1, 1.6, 0.0, 1.1, 1.4, 1.2)
parent2 = c(1.2, 0.0, 0.0, 1.5, 1.2, 1.4)
wax(parent1, parent2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
