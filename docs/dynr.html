<!DOCTYPE html><html lang="en"><head><title>Help for package dynr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dynr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dynr-package'>
<p>Dynamic Models with Regime-Switching</p></a></li>
<li><a href='#autoplot.dynrTaste'><p>The ggplot of the outliers estimates.</p></a></li>
<li><a href='#coef.dynrModel'><p>Extract fitted parameters from a dynrCook Object</p></a></li>
<li><a href='#confint.dynrCook'><p>Confidence Intervals for Model Parameters</p></a></li>
<li><a href='#diag+2Ccharacter-method'><p>Create a diagonal matrix from a character vector</p></a></li>
<li><a href='#dynr.config'><p>Check that dynr in configured properly</p></a></li>
<li><a href='#dynr.cook'><p>Cook a dynr model to estimate its free parameters</p></a></li>
<li><a href='#dynr.data'><p>Create a list of data for parameter estimation (cooking dynr) using <code>dynr.cook</code></p></a></li>
<li><a href='#dynr.flowField'><p>A Function to plot the flow or velocity field for a one or two dimensional</p>
autonomous ODE system from the phaseR package written by Michael J. Grayling.</a></li>
<li><a href='#dynr.ggplot'><p>The ggplot of the smoothed state estimates and the most likely regimes</p></a></li>
<li><a href='#dynr.ldl'><p>LDL Decomposition for Matrices</p></a></li>
<li><a href='#dynr.mi'><p>Multiple Imputation of dynrModel objects</p></a></li>
<li><a href='#dynr.model'><p>Create a dynrModel object for parameter estimation (cooking dynr) using <code>dynr.cook</code></p></a></li>
<li><a href='#dynr.plotFreq'><p>Plot of the estimated frequencies of the regimes across all individuals and time points</p>
based on their smoothed regime probabilities</a></li>
<li><a href='#dynr.taste'><p>Detect outliers in state space models.</p></a></li>
<li><a href='#dynr.taste2'><p>Re-fit state-space model using the estimated outliers.</p></a></li>
<li><a href='#dynr.trajectory'><p>A Function to perform numerical integration of the chosen ODE system,</p>
for a user-specified set of initial conditions. Plots the resulting solution(s)
in the phase plane. This function from the phaseR package written by
Michael J. Grayling.</a></li>
<li><a href='#dynr.version'><p>Current Version String</p></a></li>
<li><a href='#dynrCook-class'><p>The dynrCook Class</p></a></li>
<li><a href='#dynrDynamics-class'><p>The dynrDynamics Class</p></a></li>
<li><a href='#dynrInitial-class'><p>The dynrInitial Class</p></a></li>
<li><a href='#dynrMeasurement-class'><p>The dynrMeasurement Class</p></a></li>
<li><a href='#dynrModel-class'><p>The dynrModel Class</p></a></li>
<li><a href='#dynrNoise-class'><p>The dynrNoise Class</p></a></li>
<li><a href='#dynrRecipe-class'><p>The dynrRecipe Class</p></a></li>
<li><a href='#dynrRegimes-class'><p>The dynrRegimes Class</p></a></li>
<li><a href='#dynrTrans-class'><p>The dynrTrans Class</p></a></li>
<li><a href='#EMG'><p>Single-subject time series of facial electromyography data</p></a></li>
<li><a href='#EMGsim'><p>Simulated single-subject time series to capture features of facial electromyography data</p></a></li>
<li><a href='#ExpandRandomAsLVModel'><p>Extend a user-specified model to include random varibles</p></a></li>
<li><a href='#getdx'><p>A wrapper function to call functions in the fda package to obtain</p>
smoothed estimated derivatives at a specified order</a></li>
<li><a href='#internalModelPrep'><p>Do internal model preparation for dynr</p></a></li>
<li><a href='#LinearOsc'><p>Simulated time series data for a deterministic linear damped oscillator model</p></a></li>
<li><a href='#LogisticSetPointSDE'><p>Simulated time series data for a stochastic linear damped oscillator model with logistic time-varying setpoints</p></a></li>
<li><a href='#logLik.dynrCook'><p>Extract the log likelihood from a dynrCook Object</p></a></li>
<li><a href='#names+2CdynrCook-method'><p>Extract the free parameter names of a dynrCook object</p></a></li>
<li><a href='#names+2CdynrModel-method'><p>Extract the free parameter names of a dynrModel object</p></a></li>
<li><a href='#nobs.dynrCook'><p>Extract the number of observations for a dynrCook object</p></a></li>
<li><a href='#nobs.dynrModel'><p>Extract the number of observations for a dynrModel object</p></a></li>
<li><a href='#NonlinearDFAsim'><p>Simulated multi-subject time series based on a dynamic factor analysis model with nonlinear relations at the latent level</p></a></li>
<li><a href='#oscData'><p>Another simulated multilevel multi-subject time series of a damped oscillator model</p></a></li>
<li><a href='#Oscillator'><p>Simulated time series data of a damped linear oscillator</p></a></li>
<li><a href='#Outliers'><p>Simulated time series data for detecting outliers.</p></a></li>
<li><a href='#PFAsim'><p>Simulated time series data of a multisubject process factor analysis</p></a></li>
<li><a href='#plot.dynrCook'><p>Plot method for dynrCook objects</p></a></li>
<li><a href='#plotFormula'><p>Plot the formula from a model</p></a></li>
<li><a href='#plotGCV'><p>A function to evaluate the generalized cross-validation (GCV) values</p>
associated with derivative estimates via Bsplines at a range of specified
smoothing parameter (lambda) values</a></li>
<li><a href='#PPsim'><p>Simulated time series data for multiple eco-systems based on a predator-and-prey model</p></a></li>
<li><a href='#predict.dynrModel'><p><code>predict</code> method for <code>dynrModel</code> objects</p></a></li>
<li><a href='#prep.formulaDynamics'><p>Recipe function for specifying dynamic functions using formulas</p></a></li>
<li><a href='#prep.initial'><p>Recipe function for preparing the initial conditions for the model.</p></a></li>
<li><a href='#prep.loadings'><p>Recipe function to quickly create factor loadings</p></a></li>
<li><a href='#prep.matrixDynamics'><p>Recipe function for creating Linear Dynamics using matrices</p></a></li>
<li><a href='#prep.measurement'><p>Prepare the measurement recipe</p></a></li>
<li><a href='#prep.noise'><p>Recipe function for specifying the measurement error and process noise covariance structures</p></a></li>
<li><a href='#prep.regimes'><p>Recipe function for creating regime switching (Markov transition) functions</p></a></li>
<li><a href='#prep.tfun'><p>Create a dynrTrans object to handle the transformations and inverse</p>
transformations of model paramters</a></li>
<li><a href='#printex'><p>The printex Method</p></a></li>
<li><a href='#RSPPsim'><p>Simulated time series data for multiple eco-systems based on a regime-switching predator-and-prey model</p></a></li>
<li><a href='#summary.dynrCook'><p>Get the summary of a dynrCook object</p></a></li>
<li><a href='#theta_plot'><p>A function to plot simple slopes and region of significance.</p></a></li>
<li><a href='#TrueInit_Y14'><p>Simulated multilevel multi-subject time series of a Van der Pol Oscillator</p></a></li>
<li><a href='#VARsim'><p>Simulated time series data for multiple imputation in dynamic modeling.</p></a></li>
<li><a href='#vcov.dynrCook'><p>Extract the Variance-Covariance Matrix of a dynrCook object</p></a></li>
<li><a href='#vdpData'><p>Another simulated multilevel multi-subject time series of a Van der Pol Oscillator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Dynamic Models with Regime-Switching</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael D. Hunter &lt;mike.dynr@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dynrr.github.io/">https://dynrr.github.io/</a>, <a href="https://github.com/mhunter1/dynr">https://github.com/mhunter1/dynr</a></td>
</tr>
<tr>
<td>Contact:</td>
<td>&lt;dynr@googlegroups.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Matrix (&ge; 1.5-0), numDeriv, xtable, latex2exp, grid,
reshape2, plyr, mice, magrittr, methods, fda, car, stringi,
tibble, deSolve, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, roxygen2 (&ge; 3.1), knitr, rmarkdown, RcppGSL</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Intensive longitudinal data have become increasingly prevalent in
    various scientific disciplines. Many such data sets are noisy, multivariate,
    and multi-subject in nature. The change functions may also be continuous,
    or continuous but interspersed with periods of discontinuities (i.e.,
    showing regime switches). The package 'dynr' (Dynamic Modeling in R) is an
    R package that implements a set of computationally efficient algorithms for
    handling a broad class of linear and nonlinear discrete- and continuous-time
    models with regime-switching properties under the constraint of linear
    Gaussian measurement functions. The discrete-time models can generally
    take on the form of a state-space or difference equation model. The
    continuous-time models are generally expressed as a set of ordinary or
    stochastic differential equations. All estimation and computations are
    performed in C, but users are provided with the option to specify the
    model of interest via a set of simple and easy-to-learn model specification
    functions in R. Model fitting can be performed using single-subject time
    series data or multiple-subject longitudinal data. Ou, Hunter, &amp; Chow
    (2019) &lt;<a href="https://doi.org/10.32614%2FRJ-2019-012">doi:10.32614%2FRJ-2019-012</a>&gt; provided a detailed introduction to the
    interface and more information on the algorithms.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>'dynrData.R' 'dynrRecipe.R' 'dynrModelInternal.R'
'dynrModel.R' 'dynrCook.R' 'dynrPlot.R' 'dynrFuncAddress.R'
'dynrMi.R' 'dynrTaste.R' 'dynrVersion.R' 'dataDoc.R'
'dynrGetDerivs.R' 'dynrPredict.R'</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.16-105</td>
</tr>
<tr>
<td>Biarch:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 23:29:18 UTC; mhunter</td>
</tr>
<tr>
<td>Author:</td>
<td>Lu Ou [aut],
  Michael D. Hunter <a href="https://orcid.org/0000-0002-3651-6709"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sy-Miin Chow <a href="https://orcid.org/0000-0003-1938-027X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Linying Ji [aut],
  Meng Chen [aut],
  Hui-Ju Hung [aut],
  Jungmin Lee [aut],
  Yanling Li [aut],
  Jonathan Park [aut],
  Massachusetts Institute of Technology [cph],
  S. G. Johnson [cph],
  Benoit Scherrer [cph],
  Dieter Kraft [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 05:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='dynr-package'>
Dynamic Models with Regime-Switching
</h2><span id='topic+dynr-package'></span><span id='topic+dynr'></span>

<h3>Description</h3>

<p>Intensive longitudinal data have become increasingly prevalent in
    various scientific disciplines. Many such data sets are noisy, multivariate,
    and multi-subject in nature. The change functions may also be continuous,
    or continuous but interspersed with periods of discontinuities (i.e.,
    showing regime switches). The package 'dynr' (Dynamic Modeling in R) is an
    R package that implements a set of computationally efficient algorithms for
    handling a broad class of linear and nonlinear discrete- and continuous-time
    models with regime-switching properties under the constraint of linear
    Gaussian measurement functions. The discrete-time models can generally
    take on the form of a state-space or difference equation model. The
    continuous-time models are generally expressed as a set of ordinary or
    stochastic differential equations. All estimation and computations are
    performed in C, but users are provided with the option to specify the
    model of interest via a set of simple and easy-to-learn model specification
    functions in R. Model fitting can be performed using single-subject time
    series data or multiple-subject longitudinal data. Ou, Hunter, &amp; Chow
    (2019) &lt;doi:10.32614%2FRJ-2019-012&gt; provided a detailed introduction to the
    interface and more information on the algorithms.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> dynr</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-11-27</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Dynamic Models with Regime-Switching</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Lu", "Ou", role="aut"),
    person(c("Michael", "D."), "Hunter", role=c("aut", "cre"), email="mike.dynr@gmail.com", comment=c(ORCID = "0000-0002-3651-6709")),
    person("Sy-Miin", "Chow", role="aut", comment=c(ORCID = "0000-0003-1938-027X")),
	person("Linying", "Ji", role="aut", email=""),
	person("Meng", "Chen", role="aut", email=""),
	person("Hui-Ju", "Hung", role="aut", email=""),
	person("Jungmin", "Lee", role="aut", email="leejapply@gmail.com"),
	person("Yanling", "Li", role="aut", email=""),
	person("Jonathan", "Park", role="aut", email=""),
	person("Massachusetts Institute of Technology", role="cph"),
	person("S. G.", "Johnson", role="cph"),
	person("Benoit", "Scherrer", role="cph"),
	person("Dieter", "Kraft", role="cph"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Michael D. Hunter &lt;mike.dynr@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://dynrr.github.io/, https://github.com/mhunter1/dynr</td>
</tr>
<tr>
 <td style="text-align: left;">
Contact: </td><td style="text-align: left;"> &lt;dynr@googlegroups.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.0.0), ggplot2</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> MASS, Matrix (&gt;= 1.5-0), numDeriv, xtable, latex2exp, grid,
reshape2, plyr, mice, magrittr, methods, fda, car, stringi,
tibble, deSolve, Rdpack</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> testthat, roxygen2 (&gt;= 3.1), knitr, rmarkdown, RcppGSL</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Intensive longitudinal data have become increasingly prevalent in
    various scientific disciplines. Many such data sets are noisy, multivariate,
    and multi-subject in nature. The change functions may also be continuous,
    or continuous but interspersed with periods of discontinuities (i.e.,
    showing regime switches). The package 'dynr' (Dynamic Modeling in R) is an
    R package that implements a set of computationally efficient algorithms for
    handling a broad class of linear and nonlinear discrete- and continuous-time
    models with regime-switching properties under the constraint of linear
    Gaussian measurement functions. The discrete-time models can generally
    take on the form of a state-space or difference equation model. The
    continuous-time models are generally expressed as a set of ordinary or
    stochastic differential equations. All estimation and computations are
    performed in C, but users are provided with the option to specify the
    model of interest via a set of simple and easy-to-learn model specification
    functions in R. Model fitting can be performed using single-subject time
    series data or multiple-subject longitudinal data. Ou, Hunter, &amp; Chow
    (2019) &lt;doi:10.32614%2FRJ-2019-012&gt; provided a detailed introduction to the
    interface and more information on the algorithms.</td>
</tr>
<tr>
 <td style="text-align: left;">
SystemRequirements: </td><td style="text-align: left;"> GNU make</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Collate: </td><td style="text-align: left;"> 'dynrData.R' 'dynrRecipe.R' 'dynrModelInternal.R'
'dynrModel.R' 'dynrCook.R' 'dynrPlot.R' 'dynrFuncAddress.R'
'dynrMi.R' 'dynrTaste.R' 'dynrVersion.R' 'dataDoc.R'
'dynrGetDerivs.R' 'dynrPredict.R'</td>
</tr>
<tr>
 <td style="text-align: left;">
RdMacros: </td><td style="text-align: left;"> Rdpack</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1.16-105</td>
</tr>
<tr>
 <td style="text-align: left;">
Biarch: </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 5.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Lu Ou [aut],
  Michael D. Hunter [aut, cre] (&lt;https://orcid.org/0000-0002-3651-6709&gt;),
  Sy-Miin Chow [aut] (&lt;https://orcid.org/0000-0003-1938-027X&gt;),
  Linying Ji [aut],
  Meng Chen [aut],
  Hui-Ju Hung [aut],
  Jungmin Lee [aut],
  Yanling Li [aut],
  Jonathan Park [aut],
  Massachusetts Institute of Technology [cph],
  S. G. Johnson [cph],
  Benoit Scherrer [cph],
  Dieter Kraft [cph]</td>
</tr>
<tr>
 <td style="text-align: left;">
Archs: </td><td style="text-align: left;"> x64</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
EMG                     Single-subject time series of facial
                        electromyography data
EMGsim                  Simulated single-subject time series to capture
                        features of facial electromyography data
ExpandRandomAsLVModel   Extend a user-specified model to include random
                        varibles
LinearOsc               Simulated time series data for a deterministic
                        linear damped oscillator model
LogisticSetPointSDE     Simulated time series data for a stochastic
                        linear damped oscillator model with logistic
                        time-varying setpoints
NonlinearDFAsim         Simulated multi-subject time series based on a
                        dynamic factor analysis model with nonlinear
                        relations at the latent level
Oscillator              Simulated time series data of a damped linear
                        oscillator
Outliers                Simulated time series data for detecting
                        outliers.
PFAsim                  Simulated time series data of a multisubject
                        process factor analysis
PPsim                   Simulated time series data for multiple
                        eco-systems based on a predator-and-prey model
RSPPsim                 Simulated time series data for multiple
                        eco-systems based on a regime-switching
                        predator-and-prey model
TrueInit_Y14            Simulated multilevel multi-subject time series
                        of a Van der Pol Oscillator
VARsim                  Simulated time series data for multiple
                        imputation in dynamic modeling.
autoplot.dynrTaste      The ggplot of the outliers estimates.
coef.dynrModel          Extract fitted parameters from a dynrCook
                        Object
confint.dynrCook        Confidence Intervals for Model Parameters
diag,character-method   Create a diagonal matrix from a character
                        vector
dynr-package            Dynamic Models with Regime-Switching
dynr.config             Check that dynr in configured properly
dynr.cook               Cook a dynr model to estimate its free
                        parameters
dynr.data               Create a list of data for parameter estimation
                        (cooking dynr) using 'dynr.cook'
dynr.flowField          A Function to plot the flow or velocity field
                        for a one or two dimensional autonomous ODE
                        system from the phaseR package written by
                        Michael J. Grayling.
dynr.ggplot             The ggplot of the smoothed state estimates and
                        the most likely regimes
dynr.ldl                LDL Decomposition for Matrices
dynr.mi                 Multiple Imputation of dynrModel objects
dynr.model              Create a dynrModel object for parameter
                        estimation (cooking dynr) using 'dynr.cook'
dynr.plotFreq           Plot of the estimated frequencies of the
                        regimes across all individuals and time points
                        based on their smoothed regime probabilities
dynr.taste              Detect outliers in state space models.
dynr.taste2             Re-fit state-space model using the estimated
                        outliers.
dynr.trajectory         A Function to perform numerical integration of
                        the chosen ODE system, for a user-specified set
                        of initial conditions. Plots the resulting
                        solution(s) in the phase plane. This function
                        from the phaseR package written by Michael J.
                        Grayling.
dynr.version            Current Version String
dynrCook-class          The dynrCook Class
dynrDynamics-class      The dynrDynamics Class
dynrInitial-class       The dynrInitial Class
dynrMeasurement-class   The dynrMeasurement Class
dynrModel-class         The dynrModel Class
dynrNoise-class         The dynrNoise Class
dynrRecipe-class        The dynrRecipe Class
dynrRegimes-class       The dynrRegimes Class
dynrTrans-class         The dynrTrans Class
getdx                   A wrapper function to call functions in the fda
                        package to obtain smoothed estimated
                        derivatives at a specified order
internalModelPrep       Do internal model preparation for dynr
logLik.dynrCook         Extract the log likelihood from a dynrCook
                        Object
names,dynrCook-method   Extract the free parameter names of a dynrCook
                        object
names,dynrModel-method
                        Extract the free parameter names of a dynrModel
                        object
nobs.dynrCook           Extract the number of observations for a
                        dynrCook object
nobs.dynrModel          Extract the number of observations for a
                        dynrModel object
oscData                 Another simulated multilevel multi-subject time
                        series of a damped oscillator model
plot.dynrCook           Plot method for dynrCook objects
plotFormula             Plot the formula from a model
plotGCV                 A function to evaluate the generalized
                        cross-validation (GCV) values associated with
                        derivative estimates via Bsplines at a range of
                        specified smoothing parameter (lambda) values
predict.dynrModel       'predict' method for 'dynrModel' objects
prep.formulaDynamics    Recipe function for specifying dynamic
                        functions using formulas
prep.initial            Recipe function for preparing the initial
                        conditions for the model.
prep.loadings           Recipe function to quickly create factor
                        loadings
prep.matrixDynamics     Recipe function for creating Linear Dynamics
                        using matrices
prep.measurement        Prepare the measurement recipe
prep.noise              Recipe function for specifying the measurement
                        error and process noise covariance structures
prep.regimes            Recipe function for creating regime switching
                        (Markov transition) functions
prep.tfun               Create a dynrTrans object to handle the
                        transformations and inverse transformations of
                        model paramters
printex                 The printex Method
summary.dynrCook        Get the summary of a dynrCook object
theta_plot              A function to plot simple slopes and region of
                        significance.
vcov.dynrCook           Extract the Variance-Covariance Matrix of a
                        dynrCook object
vdpData                 Another simulated multilevel multi-subject time
                        series of a Van der Pol Oscillator
</pre>
<p>Because the <span class="pkg">dynr</span> package compiles C code in response to user input, more setup is required for the <span class="pkg">dynr</span> package than for many others. We acknowledge that this additional setup can be bothersome, but we believe the ease of use for the rest of the package and the wide variety of models it is possible to fit with it will compensate for this initial burden.  Hopefully you will agree!
</p>
<p>See the installation vignette referenced in the Examples section below for installation instructions.
</p>
<p>The naming convention for <span class="pkg">dynr</span> exploits the pronunciation of the package name, <span class="pkg">dynr</span>, pronounced the same as &ldquo;dinner&rdquo;. That is, the names of functions and methods are specifically designed to relate to things done surrounding dinner, such as gathering ingredients (e.g., the data), preparing recipes, cooking, and serving the finished product. The general procedure for using the <span class="pkg">dynr</span> package can be summarized in five steps as below. 
</p>

<ol>
<li><p> Data are prepared using with the <code>dynr.data()</code> function. 
</p>
</li>
<li> <p><em>Recipes</em> are prepared. To each part of a model there is a corresponding <code>prep.*()</code> recipe function. Examples of such <code>prep.*()</code> functions include: <code>prep.measurement()</code>, <code>prep.matrixDynamics()</code>, <code>prep.formulaDynamics()</code>, <code>prep.initial()</code>, <code>prep.noise()</code>, and <code>prep.regimes()</code>.
</p>
</li>
<li><p> The function <code>dynr.model()</code> mixes the data and recipes together into a model object of class <code>dynrModel</code>.
</p>
</li>
<li><p> The model is cooked with <code>dynr.cook()</code>.
</p>
</li>
<li><p> Results from model fitting and related estimation are served using functions such as <code>summary()</code>, <code>plot()</code>, <code>dynr.ggplot()</code> (or its alias <code>autoplot()</code>), <code>plotFormula()</code>, and <code>printex()</code>.
</p>
</li></ol>



<h3>Note</h3>

<p>State-space modeling, 
dynamic model, 
differential equation, 
regime switching, 
nonlinear
</p>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Michael D. Hunter &lt;mike.dynr@gmail.com&gt;
</p>


<h3>References</h3>

<p>Chow S, Grimm KJ, Guillaume F, Dolan CV, McArdle JJ (2013).
&ldquo;Regime-switching bivariate dual change score model.&rdquo;
<em>Multivariate Behavioral Research</em>, <b>48</b>(4), 463-502.
<a href="https://doi.org/10.1080/00273171.2013.787870">doi:10.1080/00273171.2013.787870</a>.
</p>
<p>Chow S, Zhang G (2013).
&ldquo;Nonlinear Regime-Switching State-Space (RSSS) Models.&rdquo;
<em>Psychometrika: Application Reviews and Case Studies</em>, <b>78</b>(4), 740-768.
<a href="https://doi.org/10.1007/s11336-013-9330-8">doi:10.1007/s11336-013-9330-8</a>.
</p>
<p>Ou L, Hunter MD, Chow S (2019).
&ldquo;What's for dynr: A package for linear and nonlinear dynamic modeling in R.&rdquo;
<em>The R Journal</em>, <b>11</b>(1), 1-20.
</p>
<p>Yang M, Chow S (2010).
&ldquo;Using state-space model with regime switching to represent the dynamics of Facial electromyography (EMG) data.&rdquo;
<em>Psychometrika: Application and Case Studies</em>, <b>74</b>(4), 744-771.
<a href="https://doi.org/10.1007/s11336-010-9176-2">doi:10.1007/s11336-010-9176-2</a>.
</p>
<p>Chow S, Ou L, Ciptadi A, Prince E, You D, Hunter MD, Rehg JM, Rozga A, Messinger DS (2018).
&ldquo;Representing sudden shifts in intensive dyadic interaction data using differential equation models with regime switching.&rdquo;
<em>Psychometrika</em>, <b>83</b>, 476-510.
<a href="https://doi.org/10.1007/s11336-018-9605-1">doi:10.1007/s11336-018-9605-1</a>.
</p>


<h3>See Also</h3>

<p>For other annotated tutorials using the <span class="pkg">dynr</span> package see
<a href="https://quantdev.ssri.psu.edu/resources/what%E2%80%99s-dynr-package-linear-and-nonlinear-dynamic-modeling-r">https://quantdev.ssri.psu.edu/resources/what%E2%80%99s-dynr-package-linear-and-nonlinear-dynamic-modeling-r</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For installation instructions see the package vignette below
## Not run: 
vignette(package='dynr', 'InstallationForUsers')

## End(Not run)
# This should open a pdf/html file to guide you through proper
#  installation and configuration.

#For illustrations of the functions in dynr, check out some of the demo examples in:
## Not run: 
demo(package='dynr')

## End(Not run)

#For example, to run the demo 'LinearSDE' type
# the following without the comment character (#) in front of it.
## Not run: 
demo('LinearSDE', package='dynr')

## End(Not run)
</code></pre>

<hr>
<h2 id='autoplot.dynrTaste'>The ggplot of the outliers estimates.</h2><span id='topic+autoplot.dynrTaste'></span>

<h3>Description</h3>

<p>The ggplot of the outliers estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynrTaste'
autoplot(object, numSubjDemo = 2, idtoPlot = NULL,
  names.state = NULL, names.observed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.dynrTaste_+3A_object">object</code></td>
<td>
<p>A dynrTaste object.</p>
</td></tr>
<tr><td><code id="autoplot.dynrTaste_+3A_numsubjdemo">numSubjDemo</code></td>
<td>
<p>The number of subjects, who have 
largest joint chi-square statistic, to be selected  for plotting.</p>
</td></tr>
<tr><td><code id="autoplot.dynrTaste_+3A_idtoplot">idtoPlot</code></td>
<td>
<p>Values of the ID variable to plot.</p>
</td></tr>
<tr><td><code id="autoplot.dynrTaste_+3A_names.state">names.state</code></td>
<td>
<p>(optional) The names of the states to be plotted, which should be a subset of the state.names slot of the measurement slot of dynrModel. If NULL, the t statistic plots for all state variables will be included.</p>
</td></tr>
<tr><td><code id="autoplot.dynrTaste_+3A_names.observed">names.observed</code></td>
<td>
<p>(optional) The names of the observed variables to be plotted, which should be a subset of the obs.names slot of the measurement slot of dynrModel. If NULL, the t statistic plots for all observed variables will be included.</p>
</td></tr>
<tr><td><code id="autoplot.dynrTaste_+3A_...">...</code></td>
<td>
<p>Place holder for other arguments. Please do not use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of ggplot objects for each ID. 
The plots of chi-square statistics (joint and independent),
and the plots of t statistic for <code>names.state</code> and <code>names.observed</code> will be included.
Users can modify the ggplot objects using ggplot grammar.
If a <code>filename</code> is provided, a pdf of plots will be saved additionally.
</p>

<hr>
<h2 id='coef.dynrModel'>Extract fitted parameters from a dynrCook Object</h2><span id='topic+coef.dynrCook'></span><span id='topic+coef.dynrModel'></span><span id='topic+coef+3C-'></span><span id='topic+coef+3C-.dynrModel'></span>

<h3>Description</h3>

<p>aliases coef.dynrModel coef&lt;- coef&lt;-.dynrModel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynrModel'
coef(object, ...)

coef(object) &lt;- value

## S3 replacement method for class 'dynrModel'
coef(object) &lt;- value

## S3 method for class 'dynrCook'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.dynrModel_+3A_object">object</code></td>
<td>
<p>The dynrCook object for which the coefficients are desired</p>
</td></tr>
<tr><td><code id="coef.dynrModel_+3A_...">...</code></td>
<td>
<p>further named arguments, ignored for this method</p>
</td></tr>
<tr><td><code id="coef.dynrModel_+3A_value">value</code></td>
<td>
<p>values for setting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the fitted parameters.
</p>


<h3>See Also</h3>

<p>Other S3 methods <code><a href="#topic+logLik.dynrCook">logLik.dynrCook</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a minimal cooked model called 'cook'
require(dynr)

meas &lt;- prep.measurement(
	values.load=matrix(c(1, 0), 1, 2),
	params.load=matrix(c('fixed', 'fixed'), 1, 2),
	state.names=c("Position","Velocity"),
	obs.names=c("y1"))

ecov &lt;- prep.noise(
	values.latent=diag(c(0, 1), 2),
	params.latent=diag(c('fixed', 'dnoise'), 2),
	values.observed=diag(1.5, 1),
	params.observed=diag('mnoise', 1))

initial &lt;- prep.initial(
	values.inistate=c(0, 1),
	params.inistate=c('inipos', 'fixed'),
	values.inicov=diag(1, 2),
	params.inicov=diag('fixed', 2))

dynamics &lt;- prep.matrixDynamics(
	values.dyn=matrix(c(0, -0.1, 1, -0.2), 2, 2),
	params.dyn=matrix(c('fixed', 'spring', 'fixed', 'friction'), 2, 2),
	isContinuousTime=TRUE)

data(Oscillator)
data &lt;- dynr.data(Oscillator, id="id", time="times", observed="y1")

model &lt;- dynr.model(dynamics=dynamics, measurement=meas,
	noise=ecov, initial=initial, data=data)

## Not run: 
cook &lt;- dynr.cook(model,
	verbose=FALSE, optimization_flag=FALSE, hessian_flag=FALSE)

# Now grab the coef!
coef(cook)

## End(Not run)
</code></pre>

<hr>
<h2 id='confint.dynrCook'>Confidence Intervals for Model Parameters</h2><span id='topic+confint.dynrCook'></span>

<h3>Description</h3>

<p>Confidence Intervals for Model Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynrCook'
confint(object, parm, level = 0.95,
  type = c("delta.method", "endpoint.transformation"),
  transformation = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.dynrCook_+3A_object">object</code></td>
<td>
<p>a fitted model object</p>
</td></tr>
<tr><td><code id="confint.dynrCook_+3A_parm">parm</code></td>
<td>
<p>which parameters are to be given confidence intervals</p>
</td></tr>
<tr><td><code id="confint.dynrCook_+3A_level">level</code></td>
<td>
<p>the confidence level</p>
</td></tr>
<tr><td><code id="confint.dynrCook_+3A_type">type</code></td>
<td>
<p>The type of confidence interval to compute. See details. Partial name matching is used.</p>
</td></tr>
<tr><td><code id="confint.dynrCook_+3A_transformation">transformation</code></td>
<td>
<p>For <code>type='endpoint.transformation'</code> the transformation function used.</p>
</td></tr>
<tr><td><code id="confint.dynrCook_+3A_...">...</code></td>
<td>
<p>further named arguments. Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>parm</code> argument can be a numeric vector or a vector of names. If it is missing then it defaults to using all the parameters.
</p>
<p>These are Wald-type confidence intervals based on the standard errors of the (transformed) parameters.  Wald-type confidence intervals are known to be inaccurate for variance parameters, particularly when the variance is near zero (See references for issues with Wald-type confidence intervals).
</p>


<h3>Value</h3>

<p>A matrix with columns giving lower and upper confidence limits for each parameter. These will be labelled as (1-level)/2 and 1 - (1-level)/2 as a percentage (e.g. by default 2.5
</p>


<h3>References</h3>

<p>Pritikin, J.N., Rappaport, L.M. &amp; Neale, M.C.  (In Press). Likelihood-Based Confidence Intervals for a Parameter With an Upper or Lower Bound.  Structural Equation Modeling.  DOI: 10.1080/10705511.2016.1275969
</p>
<p>Neale, M. C. &amp; Miller M. B. (1997). The use of likelihood based confidence intervals in genetic models. Behavior Genetics, 27(2), 113-120.
</p>
<p>Pek, J. &amp; Wu, H. (2015). Profile likelihood-based confidence intervals and regions for structural equation models. Psychometrica, 80(4), 1123-1145.
</p>
<p>Wu, H. &amp; Neale, M. C. (2012). Adjusted confidence intervals for a bounded parameter. Behavior genetics, 42(6), 886-898.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Minimal model
require(dynr)

meas &lt;- prep.measurement(
	values.load=matrix(c(1, 0), 1, 2),
	params.load=matrix(c('fixed', 'fixed'), 1, 2),
	state.names=c("Position","Velocity"),
	obs.names=c("y1"))

ecov &lt;- prep.noise(
	values.latent=diag(c(0, 1), 2),
	params.latent=diag(c('fixed', 'dnoise'), 2),
	values.observed=diag(1.5, 1),
	params.observed=diag('mnoise', 1))

initial &lt;- prep.initial(
	values.inistate=c(0, 1),
	params.inistate=c('inipos', 'fixed'),
	values.inicov=diag(1, 2),
	params.inicov=diag('fixed', 2))

dynamics &lt;- prep.matrixDynamics(
	values.dyn=matrix(c(0, -0.1, 1, -0.2), 2, 2),
	params.dyn=matrix(c('fixed', 'spring', 'fixed', 'friction'), 2, 2),
	isContinuousTime=TRUE)

data(Oscillator)
data &lt;- dynr.data(Oscillator, id="id", time="times", observed="y1")

model &lt;- dynr.model(dynamics=dynamics, measurement=meas,
	noise=ecov, initial=initial, data=data)

## Not run: 
cook &lt;- dynr.cook(model,
	verbose=FALSE, optimization_flag=FALSE, hessian_flag=FALSE)

# Now get the confidence intervals
# But note that they are nonsense because we set hessian_flag=FALSE !!!!
confint(cook)

## End(Not run)
</code></pre>

<hr>
<h2 id='diag+2Ccharacter-method'>Create a diagonal matrix from a character vector</h2><span id='topic+diag'></span><span id='topic+diag+2Ccharacter-method'></span><span id='topic+diag.character'></span>

<h3>Description</h3>

<p>Create a diagonal matrix from a character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
diag(x = 1, nrow, ncol)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diag+2B2Ccharacter-method_+3A_x">x</code></td>
<td>
<p>Character vector used to create the matrix</p>
</td></tr>
<tr><td><code id="diag+2B2Ccharacter-method_+3A_nrow">nrow</code></td>
<td>
<p>Numeric. Number of rows for the resulting matrix.</p>
</td></tr>
<tr><td><code id="diag+2B2Ccharacter-method_+3A_ncol">ncol</code></td>
<td>
<p>Numeric. Number of columns for the resulting matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We create a new method for <code>diag</code> with character input.  The default behavior for missing <code>nrow</code> and/or <code>ncol</code> arguments is the same
as for the <code><a href="#topic+diag">diag</a></code> function in the base package.  Off-diagonal entries
are filled with &quot;0&quot;.
</p>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diag(letters[1:3])
</code></pre>

<hr>
<h2 id='dynr.config'>Check that dynr in configured properly</h2><span id='topic+dynr.config'></span>

<h3>Description</h3>

<p>Check that dynr in configured properly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.config(verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.config_+3A_verbose">verbose</code></td>
<td>
<p>logical.  Whether to print messages during/after checks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'dynr' package requires additional set-up and configuration beyond
just installing the package.  In particular, it requires compiling C code
along with GSL to run (cook) models.  This function runs some basic checks
of the configuration.  We check that (1) R is on the PATH variable, (2)
Rtools exists and is on the PATH variable for Windows, (3) a C compiler
is available, and (4) GSL is available and on the PATH.
</p>
<p>In general, see the 'Installation for Users' vignette for set-up and
configuration instructions.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: dynr.config()
</code></pre>

<hr>
<h2 id='dynr.cook'>Cook a dynr model to estimate its free parameters</h2><span id='topic+dynr.cook'></span>

<h3>Description</h3>

<p>Cook a dynr model to estimate its free parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.cook(dynrModel, conf.level = 0.95, infile, optimization_flag = TRUE,
  hessian_flag = TRUE, verbose = TRUE, weight_flag = FALSE,
  debug_flag = FALSE, perturb_flag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.cook_+3A_dynrmodel">dynrModel</code></td>
<td>
<p>a dynr model compiled using dynr.model, consisting of recipes for submodels, 
starting values, parameter names, and C code for each submodel</p>
</td></tr>
<tr><td><code id="dynr.cook_+3A_conf.level">conf.level</code></td>
<td>
<p>a cumulative proportion indicating the level of desired confidence intervals for
the final parameter estimates (default is .95)</p>
</td></tr>
<tr><td><code id="dynr.cook_+3A_infile">infile</code></td>
<td>
<p>(not required for models specified through the recipe functions) the name of a file 
that has the C codes for all dynr submodels for those interested in specifying a model directly in C</p>
</td></tr>
<tr><td><code id="dynr.cook_+3A_optimization_flag">optimization_flag</code></td>
<td>
<p>a flag (TRUE/FALSE) indicating whether optimization is to be done.</p>
</td></tr>
<tr><td><code id="dynr.cook_+3A_hessian_flag">hessian_flag</code></td>
<td>
<p>a flag (TRUE/FALSE) indicating whether the Hessian matrix is to be calculated.</p>
</td></tr>
<tr><td><code id="dynr.cook_+3A_verbose">verbose</code></td>
<td>
<p>a flag (TRUE/FALSE) indicating whether more detailed intermediate output during the 
estimation process should be printed</p>
</td></tr>
<tr><td><code id="dynr.cook_+3A_weight_flag">weight_flag</code></td>
<td>
<p>a flag (TRUE/FALSE) indicating whether the negative log likelihood function should 
be weighted by the length of the time series for each individual</p>
</td></tr>
<tr><td><code id="dynr.cook_+3A_debug_flag">debug_flag</code></td>
<td>
<p>a flag (TRUE/FALSE) indicating whether users want additional dynr output that can 
be used for diagnostic purposes</p>
</td></tr>
<tr><td><code id="dynr.cook_+3A_perturb_flag">perturb_flag</code></td>
<td>
<p>a flag (TRUE/FLASE) indicating whether to perturb the latent states during estimation. Only useful for ensemble forecasting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Free parameter estimation uses the SLSQP routine from NLOPT.
</p>
<p>The typical items returned in the cooked model are the filtered and smoothed latent variable estimates. 
<code>eta_smooth_final</code>, <code>error_cov_smooth_final</code> and <code>pr_t_given_T</code> are respectively 
time-varying smoothed latent variable mean estimates, smoothed error covariance estimates, 
and smoothed regime probability. 
<code>eta_filtered</code>, <code>error_cov_filtered</code> and <code>pr_t_given_t</code> are respectively 
time-varying filtered latent variable mean estimates, filtered error covariance matrix estimates, 
and filtered regime probability.
Note that if <code>theta.formula</code> is provided in <code>dynrModel@dynamics</code>, this assumes  that random effects are present in the dynamic equation. This would call an internal function to insert the random effect components as additional state variables. In this case, the last set of elements (rows) in <code>eta_smooth_final</code> would contain the estimated random effect components.
</p>
<p>When <code>debug_flag</code> is TRUE, then additional information is passed into the cooked model. 
<code>eta_predicted</code>, <code>error_cov_predicted</code>, <code>innov_vec</code>, and <code>residual_cov</code> are respectively 
time-varying predicted latent variable mean estimates, predicted error covariance matrix estimates, the error/residual estimates (innovation vector),
and the error/residual covariance matrix estimates.
</p>
<p>The exit flag given after optimization has finished is from the SLSQP optimizer.  Generally, error codes have negative values and successful codes have positive values.  However, codes 5 and 6 do not indicate the model converged, but rather simply ran out of iterations or time, respectively.  A more full description of each code is available at <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values">https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values</a> and is also listed in the table below.
</p>

<table>
<tr>
 <td style="text-align: left;">
NLOPT Term </td><td style="text-align: center;"> Numeric Code </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
SUCCESS </td><td style="text-align: center;"> 1 </td><td style="text-align: left;"> Generic success return value. </td>
</tr>
<tr>
 <td style="text-align: left;">
STOPVAL_REACHED </td><td style="text-align: center;"> 2 </td><td style="text-align: left;"> Optimization stopped because stopval (above) was reached. </td>
</tr>
<tr>
 <td style="text-align: left;">
FTOL_REACHED </td><td style="text-align: center;"> 3 </td><td style="text-align: left;"> Optimization stopped because ftol_rel or ftol_abs (above) was reached. </td>
</tr>
<tr>
 <td style="text-align: left;">
XTOL_REACHED </td><td style="text-align: center;"> 4 </td><td style="text-align: left;"> Optimization stopped because xtol_rel or xtol_abs (above) was reached. </td>
</tr>
<tr>
 <td style="text-align: left;">
MAXEVAL_REACHED </td><td style="text-align: center;"> 5 </td><td style="text-align: left;"> Optimization stopped because maxeval (above) was reached. </td>
</tr>
<tr>
 <td style="text-align: left;">
MAXTIME_REACHED </td><td style="text-align: center;"> 6 </td><td style="text-align: left;"> Optimization stopped because maxtime (above) was reached. </td>
</tr>
<tr>
 <td style="text-align: left;">
FAILURE </td><td style="text-align: center;"> -1 </td><td style="text-align: left;"> Generic failure code. </td>
</tr>
<tr>
 <td style="text-align: left;">
INVALID_ARGS </td><td style="text-align: center;"> -2 </td><td style="text-align: left;"> Invalid arguments (e.g. lower bounds are bigger than upper bounds, an unknown algorithm was specified, etcetera). </td>
</tr>
<tr>
 <td style="text-align: left;">
OUT_OF_MEMORY </td><td style="text-align: center;"> -3 </td><td style="text-align: left;"> Ran out of memory. </td>
</tr>
<tr>
 <td style="text-align: left;">
ROUNDOFF_LIMITED </td><td style="text-align: center;"> -4 </td><td style="text-align: left;"> Halted because roundoff errors limited progress. (In this case, the optimization still typically returns a useful result.) </td>
</tr>
<tr>
 <td style="text-align: left;">
FORCED_STOP </td><td style="text-align: center;"> -5 </td><td style="text-align: left;"> Halted because of a forced termination: the user called nlopt_force_stop(opt) on the optimization's nlopt_opt object opt from the user's objective function or constraints. </td>
</tr>
<tr>
 <td style="text-align: left;">
NONFINITE_FIT </td><td style="text-align: center;"> -6 </td><td style="text-align: left;"> Fit function is not finite (i.e., is NA, NaN, Inf or -Inf). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The last row of this table corresponding to an exit code of -6, is not from NLOPT, but rather is specific to the <code>dynr</code> package.
</p>


<h3>Value</h3>

<p>Object of class dynrCook.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+autoplot">autoplot</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+confint">confint</a></code>,
<code><a href="stats.html#topic+deviance">deviance</a></code>, <code><a href="methods.html#topic+initialize">initialize</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>,
<code><a href="base.html#topic+names">names</a></code>, <code><a href="stats.html#topic+nobs">nobs</a></code>, <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code>,
<code><a href="methods.html#topic+show">show</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Minimal model
require(dynr)

meas &lt;- prep.measurement(
	values.load=matrix(c(1, 0), 1, 2),
	params.load=matrix(c('fixed', 'fixed'), 1, 2),
	state.names=c("Position","Velocity"),
	obs.names=c("y1"))

ecov &lt;- prep.noise(
	values.latent=diag(c(0, 1), 2),
	params.latent=diag(c('fixed', 'dnoise'), 2),
	values.observed=diag(1.5, 1),
	params.observed=diag('mnoise', 1))

initial &lt;- prep.initial(
	values.inistate=c(0, 1),
	params.inistate=c('inipos', 'fixed'),
	values.inicov=diag(1, 2),
	params.inicov=diag('fixed', 2))

dynamics &lt;- prep.matrixDynamics(
	values.dyn=matrix(c(0, -0.1, 1, -0.2), 2, 2),
	params.dyn=matrix(c('fixed', 'spring', 'fixed', 'friction'), 2, 2),
	isContinuousTime=TRUE)

data(Oscillator)
data &lt;- dynr.data(Oscillator, id="id", time="times", observed="y1")

model &lt;- dynr.model(dynamics=dynamics, measurement=meas,
	noise=ecov, initial=initial, data=data)

## Not run: 
# Now cook the model!
cook &lt;- dynr.cook(model,
	verbose=FALSE, optimization_flag=FALSE, hessian_flag=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='dynr.data'>Create a list of data for parameter estimation (cooking dynr) using <code><a href="#topic+dynr.cook">dynr.cook</a></code></h2><span id='topic+dynr.data'></span>

<h3>Description</h3>

<p>Create a list of data for parameter estimation (cooking dynr) using <code><a href="#topic+dynr.cook">dynr.cook</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.data(dataframe, id = "id", time = "time", observed, covariates)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.data_+3A_dataframe">dataframe</code></td>
<td>
<p>either a &ldquo;ts&rdquo; class object of time series data for a single subject or 
a data frame object of data for potentially multiple subjects that contain a column of subject ID numbers 
(i.e., an ID variable), a column indicating subject-specific measurement occasions
(i.e., a TIME variable), at least one column of observed values, and any number of covariates. 
If the data are fit to a discrete-time model, the TIME variable should contain subject-specific sequences 
of (subsets of) consecutively equally spaced numbers (e.g, 1, 2, 3, ...). That is, the
program assumes that the input data.frame is equally spaced with potential missingness. If
the measurement occasions for a subject are a subset of an arithmetic sequence but are not
consecutive, NAs will be inserted automatically to create an equally spaced data set before
estimation.
If the data are fit to a continuous-time model, the TIME varibles can contain subject-specific increasing sequences 
of irregularly spaced real numbers.  
Missing values in the observed variables shoud be indicated by NA. Missing values in covariates are not allowed. 
That is, missing values in the covariates, if there are any, should be imputed first.</p>
</td></tr>
<tr><td><code id="dynr.data_+3A_id">id</code></td>
<td>
<p>a character string of the name of the ID variable in the data. Optional for a &ldquo;ts&rdquo; class object.</p>
</td></tr>
<tr><td><code id="dynr.data_+3A_time">time</code></td>
<td>
<p>a character string of the name of the TIME variable in the data. Optional for a &ldquo;ts&rdquo; class object.</p>
</td></tr>
<tr><td><code id="dynr.data_+3A_observed">observed</code></td>
<td>
<p>a vector of character strings of the names of the observed variables in the data. 
Optional for a &ldquo;ts&rdquo; class object.</p>
</td></tr>
<tr><td><code id="dynr.data_+3A_covariates">covariates</code></td>
<td>
<p>(optional) a vector of character strings of the names of the covariates in the data,
which can be missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components as needed for <code>dynr.model</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EMGsim)
dd &lt;- dynr.data(EMGsim, id = 'id', time = 'time', observed = 'EMG', covariates = 'self')

z &lt;- ts(matrix(rnorm(300), 100, 3), start = c(1961, 1), frequency = 12)
dz &lt;- dynr.data(z)
</code></pre>

<hr>
<h2 id='dynr.flowField'>A Function to plot the flow or velocity field for a one or two dimensional 
autonomous ODE system from the phaseR package written by Michael J. Grayling.</h2><span id='topic+dynr.flowField'></span>

<h3>Description</h3>

<p>A Function to plot the flow or velocity field for a one or two dimensional 
autonomous ODE system from the phaseR package written by Michael J. Grayling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.flowField(deriv, xlim, ylim, parameters = NULL, system = "two.dim",
  points = 21, col = "gray", arrow.type = "equal", arrow.head = 0.05,
  frac = 1, add = TRUE, xlab = "x", ylab = "y", state.names = c("x",
  "y"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.flowField_+3A_deriv">deriv</code></td>
<td>
<p>A function computing the derivative at a point for the ODE system 
to be analysed. For examples see the phaseR package guide.</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_xlim">xlim</code></td>
<td>
<p>A vector of length two setting the lower and upper limits of the variable 
to be plotted on the horizontal axis (usually the first variable returned by the function deriv)</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_ylim">ylim</code></td>
<td>
<p>A vector of length two setting the lower and upper limits of the variable 
to be plotted on the vertical axis (usually the second variable returned by the function deriv)</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_parameters">parameters</code></td>
<td>
<p>Parameters of the ODE system, to be passed to deriv. 
Supplied as a vector; the order of the parameters can be found from the 
deriv file. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_system">system</code></td>
<td>
<p>Set to either &quot;one.dim&quot; or &quot;two.dim&quot; to indicate the type of system 
being analysed. Defaults to &quot;two.dim&quot;.</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_points">points</code></td>
<td>
<p>Sets the density of the line segments to be plotted. Defaults to 11.</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_col">col</code></td>
<td>
<p>Sets the color of the plotted line segments. Defaults to &quot;gray&quot;. 
Should be a vector of length one. Will be reset accordingly if it is a vector of the wrong length.</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_arrow.type">arrow.type</code></td>
<td>
<p>Sets the type of line segments plotted. Options include:
&quot;proportional&quot; = the length of the line segments reflects the magnitude of the derivative. 
&quot;equal&quot; the line segments take equal lengths, simply reflecting the gradient of 
the derivative(s). Defaults to &quot;equal&quot;.</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_arrow.head">arrow.head</code></td>
<td>
<p>Sets the length of the arrow heads. Passed to arrows. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_frac">frac</code></td>
<td>
<p>Sets the fraction of the theoretical maximum length line segments can take 
without overlapping, that they can actually attain. In practice, frac can be set to greater 
than 1 without line segments overlapping.</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_add">add</code></td>
<td>
<p>Logical. Defaults to TRUE.
TRUE = the flow field is added to an existing plot; FALSE = a new plot is created.</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis of the resulting plot. Defaults to &quot;x&quot;.</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis of the resulting plot. Defaults to &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_state.names">state.names</code></td>
<td>
<p>State names for ode functions that do not use positional states</p>
</td></tr>
<tr><td><code id="dynr.flowField_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to either plot or arrows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
add, arrow.head, arrow.type, col, deriv, dx, dy, frac, parameters, points,
system, x, xlab, xlim, y, ylab, ylim. Most of these components correspond simply
to their original input values. 
</p>
<p>The only new elements are:
</p>
<p>dx = A matrix. In the case of a two dimensional system, the values of the 
derivative of the first dependent derivative at all evaluated points.
</p>
<p>dy = A matrix. In the case of a two dimensional system, the values of the derivative of the second dependent variable at all evaluated points. In the case of a one dimensional system, the values of the derivative of the dependent variable at all evaluated points.
</p>
<p>x	= A vector. In the case of a two dimensional system, the values of the first dependent variable at which the derivatives were computed. In the case of a one dimensional system, the values of the independent variable at which the derivatives were computed.
</p>
<p>y	= A vector. In the case of a two dimensional system, the values of the second dependent variable at which the derivatives were computed. In the case of a one dimensional system, the values of the dependent variable at which the derivatives were computed.
</p>


<h3>Note</h3>

<p>The phaseR package was taken off cran as off 10/1/2019 so we are 
exporting some selected functions from phaseR_2.0 published on 8/20/2018.
For details of these functions please see original documentations on the
phaseR package.
</p>


<h3>References</h3>

<p>Grayling, Michael J. (2014). phaseR: An R Package for Phase Plane Analysis of Autonomous
ODE Systems. The R Journal, 6(2), 43-51. DOI: 10.32614/RJ-2014-023. Available at
https://doi.org/10.32614/RJ-2014-023
</p>

<hr>
<h2 id='dynr.ggplot'>The ggplot of the smoothed state estimates and the most likely regimes</h2><span id='topic+autoplot.dynrCook'></span><span id='topic+dynr.ggplot'></span>

<h3>Description</h3>

<p>The ggplot of the smoothed state estimates and the most likely regimes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.ggplot(res, dynrModel, style = 1, numSubjDemo = 2, idtoPlot = c(),
  names.state, names.observed, names.regime, shape.values, title, ylab,
  is.bw = FALSE, colorPalette = "Set2", fillPalette = "Set2",
  mancolorPalette, manfillPalette, ...)

## S3 method for class 'dynrCook'
autoplot(object, dynrModel, style = 1, numSubjDemo = 2,
  idtoPlot = c(), names.state, names.observed, names.regime, shape.values,
  title, ylab, is.bw = FALSE, colorPalette = "Set2", fillPalette = "Set2",
  mancolorPalette, manfillPalette, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.ggplot_+3A_res">res</code></td>
<td>
<p>The dynr object returned by <code>dynr.cook()</code>.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_dynrmodel">dynrModel</code></td>
<td>
<p>The model object to plot.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_style">style</code></td>
<td>
<p>The style of the plot. If style is 1 (default), user-selected smoothed state variables are plotted. If style is 2, user-selected observed-versus-predicted values are plotted.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_numsubjdemo">numSubjDemo</code></td>
<td>
<p>The number of subjects to be randomly selected for plotting.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_idtoplot">idtoPlot</code></td>
<td>
<p>Values of the ID variable to plot.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_names.state">names.state</code></td>
<td>
<p>(optional) The names of the states to be plotted, which should be a subset of the state.names slot of the measurement slot of dynrModel.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_names.observed">names.observed</code></td>
<td>
<p>(optional) The names of the observed variables to be plotted, which should be a subset of the obs.names slot of the measurement slot of dynrModel.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_names.regime">names.regime</code></td>
<td>
<p>(optional) The names of the regimes to be plotted, which can be missing.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_shape.values">shape.values</code></td>
<td>
<p>(optional) A vector of values that correspond to the shapes of the points, which can be missing. See the R documentation on pch for details on possible shapes.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_title">title</code></td>
<td>
<p>(optional) A title of the plot.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_ylab">ylab</code></td>
<td>
<p>(optional) The label of the y axis.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_is.bw">is.bw</code></td>
<td>
<p>Is plot in black and white? The default is FALSE.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_colorpalette">colorPalette</code></td>
<td>
<p>A color palette for lines and dots. It is a value passed to the palette argument of the <code>ggplot2::scale_colour_brewer()</code> function. These palettes are in the R package <span class="pkg">RColorBrewer</span>. One can find them by attaching the package with <code>library(RColorBrewer)</code> and run <code>display.brewer.all()</code>.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_fillpalette">fillPalette</code></td>
<td>
<p>A color palette for blocks. It is a value passed to the palette argument of the <code>ggplot2::scale_fill_brewer()</code> function. These palettes are in the package <span class="pkg">RColorBrewer</span>. One can find them by attaching the package with <code>library(RColorBrewer)</code> and run <code>display.brewer.all()</code>.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_mancolorpalette">mancolorPalette</code></td>
<td>
<p>(optional) A color palette for manually scaling the colors of lines and dots. It is a vector passed to the values argument of the <code>ggplot2::scale_colour_manual</code> function.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_manfillpalette">manfillPalette</code></td>
<td>
<p>(optional) A color palette for manually scaling the colors of filled blocks. It is a vector passed to the values argument of the <code>ggplot2::scale_fill_manual</code> function.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_...">...</code></td>
<td>
<p>A list of elements that modify the existing ggplot theme. Consult the <code>ggplot2::theme()</code> function in the R package <span class="pkg">ggplot2</span> for more options.</p>
</td></tr>
<tr><td><code id="dynr.ggplot_+3A_object">object</code></td>
<td>
<p>The same as res. The dynr object returned by dynr.cook().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function outputs a ggplot layer that can be modified using functions in the package <span class="pkg">ggplot2</span>. That is, one can add layers, scales, coords and facets with the &quot;+&quot; sign. In an example below, the <code>ggplot2::ylim()</code> function is used to modify the limits of the y axis of the graph. More details can be found on <a href="https://ggplot2.tidyverse.org/">https://ggplot2.tidyverse.org/</a> and <a href="https://ggplot2.tidyverse.org/reference/">https://ggplot2.tidyverse.org/reference/</a>.
</p>
<p>The two functions <code>dynr.ggplot()</code> and <code>autoplot()</code> as identical aliases of one another.  The <code>autoplot()</code> function is an S3 method from the package <span class="pkg">ggplot2</span> that allows many objects to be plotted and works like the base <code>plot()</code> function.
</p>


<h3>Value</h3>

<p>ggplot object
</p>
<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following code is part of a demo example in dynr
## Not run: 
demo(RSLinearDiscreteYang, package='dynr')
p &lt;- dynr.ggplot(yum, dynrModel = rsmod, style = 1,
 	names.regime = c("Deactivated", "Activated"),
 	title = "(B) Results from RS-AR model", numSubjDemo = 1,
 	shape.values = c(1),
 	text = element_text(size = 16),
 	is.bw = TRUE)
# One can modify the limits on the y axis by using '+'
p + ggplot2::ylim(-2, 4)

autoplot(yum, dynrModel = rsmod, style = 1,
	names.regime = c("Deactivated", "Activated"),
	title = "(B) Results from RS-AR model", numSubjDemo = 1,
	shape.values = c(1),
	text = element_text(size = 16),
	is.bw = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='dynr.ldl'>LDL Decomposition for Matrices</h2><span id='topic+dynr.ldl'></span>

<h3>Description</h3>

<p>LDL Decomposition for Matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.ldl(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.ldl_+3A_x">x</code></td>
<td>
<p>a numeric matrix
</p>
<p>This is a wrapper function around the <code><a href="base.html#topic+chol">chol</a></code> function.
The goal is to factor a square, symmetric, positive (semi-)definite matrix into the product of a lower triangular matrix, a diagonal matrix, and the transpose of the lower triangular matrix.
The value returned is a lower triangular matrix with the elements of D on the diagonal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>

<hr>
<h2 id='dynr.mi'>Multiple Imputation of dynrModel objects</h2><span id='topic+dynr.mi'></span>

<h3>Description</h3>

<p>Multiple Imputation of dynrModel objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.mi(dynrModel, which.aux = NULL, which.lag = NULL, lag = 0,
  which.lead = NULL, lead = 0, m = 5, iter = 5, imp.obs = FALSE,
  imp.exo = TRUE, diag = TRUE, Rhat = 1.1, conf.level = 0.95,
  verbose = TRUE, seed = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.mi_+3A_dynrmodel">dynrModel</code></td>
<td>
<p>dynrModel object. data and model setup</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_which.aux">which.aux</code></td>
<td>
<p>character. names of the auxiliary variables used in the imputation model</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_which.lag">which.lag</code></td>
<td>
<p>character. names of the variables to create lagged responses for imputation purposes</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_lag">lag</code></td>
<td>
<p>integer. number of lags of variables in the imputation model</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_which.lead">which.lead</code></td>
<td>
<p>character. names of the variables to create leading responses for imputation purposes</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_lead">lead</code></td>
<td>
<p>integer. number of leads of variables in the imputation model</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_m">m</code></td>
<td>
<p>integer. number of multiple imputations</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_iter">iter</code></td>
<td>
<p>integer. number of MCMC iterations in each imputation</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_imp.obs">imp.obs</code></td>
<td>
<p>logical. flag to impute the observed dependent variables</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_imp.exo">imp.exo</code></td>
<td>
<p>logical. flag to impute the exogenous variables</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_diag">diag</code></td>
<td>
<p>logical. flag to use convergence diagnostics</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_rhat">Rhat</code></td>
<td>
<p>numeric. value of the Rhat statistic used as the criterion in convergence diagnostics</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_conf.level">conf.level</code></td>
<td>
<p>numeric. confidence level used to generate confidence intervals</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_verbose">verbose</code></td>
<td>
<p>logical. flag to print the intermediate output during the estimation process</p>
</td></tr>
<tr><td><code id="dynr.mi_+3A_seed">seed</code></td>
<td>
<p>integer. random number seed to be used in the MI procedure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the demo, <code>demo(package='dynr', 'MILinearDiscrete')</code>, for an illustrative example 
of using <code>dynr.mi</code> to implement multiple imputation with 
a vector autoregressive model.
</p>


<h3>Value</h3>

<p>an object of &lsquo;dynrMi&rsquo; class
that is a list containing:
1. the imputation information, including a data set 
containing structured lagged and leading variables and 
a &lsquo;mids&rsquo; object from mice() function;
2. the diagnostic information, including trace plots,
an Rhat plot and a matrix containing Rhat values;
3. the estimation results, including parameter estimates,
standard error estimates and confidence intervals.
</p>


<h3>References</h3>

<p>Ji, L., Chow, S-M., Schermerhorn, A.C., Jacobson, N.C., &amp; Cummings, E.M. (2018). Handling 
Missing Data in the Modeling of Intensive Longitudinal Data. Structural Equation Modeling: 
A Multidisciplinary Journal, 1-22.
</p>
<p>Yanling Li, Linying Ji, Zita Oravecz, Timothy R. Brick,
Michael D. Hunter, and Sy-Miin Chow. (2019).
dynr.mi: An R Program for Multiple Imputation in Dynamic Modeling.
International Journal of Computer, Electrical, Automation, Control
and Information Engineering, 13, 302-311.
</p>

<hr>
<h2 id='dynr.model'>Create a dynrModel object for parameter estimation (cooking dynr) using <code><a href="#topic+dynr.cook">dynr.cook</a></code></h2><span id='topic+dynr.model'></span>

<h3>Description</h3>

<p>Create a dynrModel object for parameter estimation (cooking dynr) using <code><a href="#topic+dynr.cook">dynr.cook</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.model(dynamics, measurement, noise, initial, data, ...,
  outfile = tempfile())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.model_+3A_dynamics">dynamics</code></td>
<td>
<p>a dynrDynamics object prepared with <code><a href="#topic+prep.formulaDynamics">prep.formulaDynamics</a></code> 
or <code><a href="#topic+prep.matrixDynamics">prep.matrixDynamics</a></code></p>
</td></tr>
<tr><td><code id="dynr.model_+3A_measurement">measurement</code></td>
<td>
<p>a dynrMeasurement object prepared with <code><a href="#topic+prep.loadings">prep.loadings</a></code> 
or <code><a href="#topic+prep.measurement">prep.measurement</a></code></p>
</td></tr>
<tr><td><code id="dynr.model_+3A_noise">noise</code></td>
<td>
<p>a dynrNoise object prepared with <code><a href="#topic+prep.noise">prep.noise</a></code></p>
</td></tr>
<tr><td><code id="dynr.model_+3A_initial">initial</code></td>
<td>
<p>a dynrInitial object prepared with <code><a href="#topic+prep.initial">prep.initial</a></code></p>
</td></tr>
<tr><td><code id="dynr.model_+3A_data">data</code></td>
<td>
<p>a dynrData object made with <code><a href="#topic+dynr.data">dynr.data</a></code></p>
</td></tr>
<tr><td><code id="dynr.model_+3A_...">...</code></td>
<td>
<p>additional arguments specifying other dynrRecipe objects. Argument regimes is for 
a dynrRegimes object prepared with <code><a href="#topic+prep.regimes">prep.regimes</a></code> and argument transform is for 
a dynrTrans object prepared with <code><a href="#topic+prep.tfun">prep.tfun</a></code>.</p>
</td></tr>
<tr><td><code id="dynr.model_+3A_outfile">outfile</code></td>
<td>
<p>a character string of the name of the output C script of model functions to be compiled 
for parameter estimation. The default is the name for a potential temporary file returned by tempfile().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>dynrModel</code> is a collection of recipes.  The recipes are constructed with the functions <code><a href="#topic+prep.measurement">prep.measurement</a></code>, <code><a href="#topic+prep.noise">prep.noise</a></code>, <code><a href="#topic+prep.formulaDynamics">prep.formulaDynamics</a></code>, <code><a href="#topic+prep.matrixDynamics">prep.matrixDynamics</a></code>, <code><a href="#topic+prep.initial">prep.initial</a></code>, and in the case of regime-switching models <code><a href="#topic+prep.regimes">prep.regimes</a></code>.  Additionally, data must be prepared with <code><a href="#topic+dynr.data">dynr.data</a></code> and added to the model.
</p>
<p>Several <em>named</em> arguments can be passed into the <code>...</code> section of the function.  These include
</p>

<ul>
<li><p> Argument <code>regimes</code> is for a dynrRegimes object prepared with <code><a href="#topic+prep.regimes">prep.regimes</a></code>
</p>
</li>
<li><p> Argument <code>transform</code> is for a dynrTrans object prepared with <code><a href="#topic+prep.tfun">prep.tfun</a></code>.
</p>
</li>
<li><p> Argument <code>options</code> a list of options. Check the NLopt website <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#stopping-criteria">https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#stopping-criteria</a>
for details. Available options for use with a dynrModel object 
include xtol_rel, stopval, ftol_rel, ftol_abs, maxeval, and maxtime, 
all of which control the termination conditions for parameter optimization. The examples below show a case where options were set.
</p>
</li></ul>

<p>There are several available methods for <code>dynrModel</code> objects.
</p>

<ul>
<li><p> The dollar sign ($) can be used to both get objects out of a model and to set pieces of the model.
</p>
</li>
<li> <p><code>names</code> returns the names of the free parameters in a model.
</p>
</li>
<li> <p><code><a href="#topic+printex">printex</a></code> prints LaTeX expressions for the equations that compose a model. The output can then be readily typeset for inclusion in presentations and papers.
</p>
</li>
<li> <p><code>nobs</code> gives the total number of observations (e.g. all times across all people)
</p>
</li>
<li> <p><code>coef</code> gives the free parameter starting values.  Free parameters can also be assigned with <code>coef(model) &lt;- aNamedVectorOfCoefficients</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Object of class 'dynrModel'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a minimal model called 'model'
# without 'cooking' (i.e., estimating parameters)
require(dynr)

meas &lt;- prep.measurement(
	values.load=matrix(c(1, 0), 1, 2),
	params.load=matrix(c('fixed', 'fixed'), 1, 2),
	state.names=c("Position","Velocity"),
	obs.names=c("y1"))

ecov &lt;- prep.noise(
	values.latent=diag(c(0, 1), 2),
	params.latent=diag(c('fixed', 'dnoise'), 2),
	values.observed=diag(1.5, 1),
	params.observed=diag('mnoise', 1))

initial &lt;- prep.initial(
	values.inistate=c(0, 1),
	params.inistate=c('inipos', 'fixed'),
	values.inicov=diag(1, 2),
	params.inicov=diag('fixed', 2))

dynamics &lt;- prep.matrixDynamics(
	values.dyn=matrix(c(0, -0.1, 1, -0.2), 2, 2),
	params.dyn=matrix(c('fixed', 'spring', 'fixed', 'friction'), 2, 2),
	isContinuousTime=TRUE)

data(Oscillator)
data &lt;- dynr.data(Oscillator, id="id", time="times", observed="y1")

# Now here's the model!
model &lt;- dynr.model(dynamics=dynamics, measurement=meas,
	noise=ecov, initial=initial, data=data)
</code></pre>

<hr>
<h2 id='dynr.plotFreq'>Plot of the estimated frequencies of the regimes across all individuals and time points
based on their smoothed regime probabilities</h2><span id='topic+dynr.plotFreq'></span>

<h3>Description</h3>

<p>Plot of the estimated frequencies of the regimes across all individuals and time points
based on their smoothed regime probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.plotFreq(res, dynrModel, names.regime, title, xlab, ylab, textsize = 12,
  print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.plotFreq_+3A_res">res</code></td>
<td>
<p>The dynr object returned by dynr.cook().</p>
</td></tr>
<tr><td><code id="dynr.plotFreq_+3A_dynrmodel">dynrModel</code></td>
<td>
<p>The model object to plot.</p>
</td></tr>
<tr><td><code id="dynr.plotFreq_+3A_names.regime">names.regime</code></td>
<td>
<p>(optional) Names of the regimes (must match the length of the number of regimes)</p>
</td></tr>
<tr><td><code id="dynr.plotFreq_+3A_title">title</code></td>
<td>
<p>(optional) Title of the plot.</p>
</td></tr>
<tr><td><code id="dynr.plotFreq_+3A_xlab">xlab</code></td>
<td>
<p>(optional) Label of the x-axis.</p>
</td></tr>
<tr><td><code id="dynr.plotFreq_+3A_ylab">ylab</code></td>
<td>
<p>(optional) Label of the y-axis.</p>
</td></tr>
<tr><td><code id="dynr.plotFreq_+3A_textsize">textsize</code></td>
<td>
<p>(default = 12) Text size for the axis labels and title (= textsize + 2).</p>
</td></tr>
<tr><td><code id="dynr.plotFreq_+3A_print">print</code></td>
<td>
<p>(default = TRUE) A flag for whether the plot should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='dynr.taste'>Detect outliers in state space models.</h2><span id='topic+dynr.taste'></span>

<h3>Description</h3>

<p>Compute shocks and chi-squared diagnostics following
Chow, Hamaker, and Allaire (2009).  Using Innovative Outliers to
Detect Discrete Shifts in Dynamics in Group-Based State-Space Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.taste(dynrModel, dynrCook = NULL, which.state, which.obs,
  conf.level = 0.99, alternative = c("two.sided", "less", "greater"),
  debug_flag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.taste_+3A_dynrmodel">dynrModel</code></td>
<td>
<p>an object of &lsquo;dynrModel&rsquo; class.</p>
</td></tr>
<tr><td><code id="dynr.taste_+3A_dynrcook">dynrCook</code></td>
<td>
<p>the &lsquo;dynrCook&rsquo; object fitted with &lsquo;debug_flag=TRUE&rsquo; for the &lsquo;dynrModel&rsquo; object. The default is NULL.
If the dynrCook object were not provided, or the object were cooked
with &lsquo;debug_flag=FALSE&rsquo;,
<code>dynr.taste</code> will fit the dynrModel object with &lsquo;debug_flag=TRUE&rsquo; internally.</p>
</td></tr>
<tr><td><code id="dynr.taste_+3A_which.state">which.state</code></td>
<td>
<p>a character vector of the names of latent variables. 
The outlier detection process will be applied only to the chosen variable. 
If the argument is NA, all the latent variables will be excluded in the outlier detection process. 
If the argument is missing (defalut), all the latent variables will be chosen.</p>
</td></tr>
<tr><td><code id="dynr.taste_+3A_which.obs">which.obs</code></td>
<td>
<p>a character vector of the names of measured or observed variables.
The outlier detection process will be applied only to the chosen variable. 
If the argument is NA, all the measured variables will be excluded in the outlier detection process. 
If the argument is missing (defalut), all the measured variables will be chosen.</p>
</td></tr>
<tr><td><code id="dynr.taste_+3A_conf.level">conf.level</code></td>
<td>
<p>a numeric of confidence level that is used for
outliers detection tests (chi-square test and t-test). The default is 0.99.</p>
</td></tr>
<tr><td><code id="dynr.taste_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis of t-test,
must be one of &ldquo;two.sided&rdquo; (default), &ldquo;greater&rdquo;  or &ldquo;less&rdquo;.</p>
</td></tr>
<tr><td><code id="dynr.taste_+3A_debug_flag">debug_flag</code></td>
<td>
<p>a logical. 'TRUE' for output of by-products related to t-value calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of &lsquo;dynrTaste&rsquo; class
that is a list containing lists of results from the outlier detection process.
Vectors of ID and measured time points are included for later use,
such as in dynr.taste2.
The values, p-values, and shock points related to 
&lsquo;joint&rsquo; chi-square, &lsquo;independent&rsquo; chi-square, and t statistic
for innovative and additive outliers are following in that order.
The estimated delta for innovative and additive components are in the last.
If <code>debug_flag</code> is <code>TRUE</code>, 
The by-products of the Kalman filter and smoother (Q, S, s, F_inv, N, u, r) would be added at the end.
See the reference for definition of the notations.
The t statistic (estimate of an outlier divided by standard error of the outlier) of the last time point is NA, 
because the Kalman smoothing process starts with setting r and N to zero for the last time point 
(core elements of calculating estimates and the standard errors of outliers) 
that lead to 0/0 of the t statistic of the last time point.
For the time-varing models, more NAs would appear at the end of times because the Kalman smoother needs more time points to obtain all elements of r nad N from limited number of observed variables in the model. 
</p>
<p>The &lsquo;delta_chi&rsquo; list comprises magnitude of innovative (Latent) and additive (Observed) outliers, &lsquo;delta.L&rsquo; and &lsquo;delta.O&rsquo;,
when chi-square statitics is used to detect outliers.
The &lsquo;delta_t&rsquo; list comprises magnitude of innovative (Latent) and additive (Observed) outliers, &lsquo;delta.L&rsquo; and &lsquo;delta.O&rsquo;,
when t statitics is used to detect outliers.
</p>


<h3>References</h3>

<p>Chow, S.-M., Hamaker, E. L., &amp; Allaire, J. C. (2009).
Using innovative outliers to detect discrete shifts in dynamics in group-based state-space models. _Multivariate Behavioral Research_, 44, 465-496.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See the demo for outlier detection, OutlierDetection.R
dynrCook &lt;- dynr.cook(dynrModel)
dynrTaste &lt;- dynr.taste(dynrModel, dynrCook)

# Detect outliers related to 'eta1' out of, say, three latent
# variables c("eta1", "eta2", "eta3"), and all measured variables.
dynrTaste &lt;- dynr.taste(dynrModel, dynrCook, which.state=c("eta1"))

## End(Not run)
</code></pre>

<hr>
<h2 id='dynr.taste2'>Re-fit state-space model using the estimated outliers.</h2><span id='topic+dynr.taste2'></span>

<h3>Description</h3>

<p>The function <code>dynr.taste2{}</code> update the <code>dynrModel</code>
object applying outliers from the <code>dynrTaste</code> object,
or outliers from users. The function then re-cook the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.taste2(dynrModel, dynrCook, dynrTaste, delta_inn = c("t", "ind", "jnt",
  "null"), delta_add = c("t", "ind", "jnt", "null"), delta_L = NULL,
  delta_O = NULL, cook = TRUE, verbose = FALSE,
  newOutfile = "new_taste.c")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.taste2_+3A_dynrmodel">dynrModel</code></td>
<td>
<p>an object of dynrModel class.</p>
</td></tr>
<tr><td><code id="dynr.taste2_+3A_dynrcook">dynrCook</code></td>
<td>
<p>an object of dynrCook class.</p>
</td></tr>
<tr><td><code id="dynr.taste2_+3A_dynrtaste">dynrTaste</code></td>
<td>
<p>an object of dynrTaste class. The default is NULL.</p>
</td></tr>
<tr><td><code id="dynr.taste2_+3A_delta_inn">delta_inn</code></td>
<td>
<p>a character string for a method detecting &lsquo;inn&rsquo;ovative outliers,
which must be one of &ldquo;t&rdquo; (default), &ldquo;ind&rdquo;, &ldquo;jnt&rdquo; or &ldquo;null&rdquo;.
According to the method,
corresponding delta estimates (magnitude of estimated outliers) 
will be included in the new dynrModel in output.
&lsquo;t&rsquo; represents the t statistic, &lsquo;ind&rsquo; represents the independent chi-square statistic,
&lsquo;jnt&rsquo; represents the joint chi-square statistic.
If no outliers are assumed, &ldquo;null&rdquo; can be used.</p>
</td></tr>
<tr><td><code id="dynr.taste2_+3A_delta_add">delta_add</code></td>
<td>
<p>a character string for a method detecting &lsquo;add&rsquo;itive outliers,
which must be one of &ldquo;t&rdquo; (default), &ldquo;ind&rdquo;, &ldquo;jnt&rdquo; or &ldquo;null&rdquo;.
According to the method,
corresponding delta estimates will be included in the new dynrModel.</p>
</td></tr>
<tr><td><code id="dynr.taste2_+3A_delta_l">delta_L</code></td>
<td>
<p>a data.frame containing user-specified latent outliers.
The delta estimates from <code>dynrTaste</code> will be ignored.
The number of rows should equal to the total time points, and the number of columns should equal to the number of latent variables.</p>
</td></tr>
<tr><td><code id="dynr.taste2_+3A_delta_o">delta_O</code></td>
<td>
<p>a data.frame containing user-specified observed outliers.
The delta estimates from <code>dynrTaste</code>, and 
arguments of <code>delta_inn</code> and <code>delta_add</code> will be ignored.
The number of rows should equal to the total time points, and the number of columns should equal to the number of observed variables.</p>
</td></tr>
<tr><td><code id="dynr.taste2_+3A_cook">cook</code></td>
<td>
<p>a logical specifying whether the newly built model
would be cooked by 'dynr.cook' function.
The default is TRUE. When 'cook=FALSE', only the newly built model will be saved for the output.</p>
</td></tr>
<tr><td><code id="dynr.taste2_+3A_verbose">verbose</code></td>
<td>
<p>a logical specifying the verbose argument
of the new cook object. The default is FALSE.</p>
</td></tr>
<tr><td><code id="dynr.taste2_+3A_newoutfile">newOutfile</code></td>
<td>
<p>a character string for <code>outfile</code>
argument of <code>dynr.model</code> function
to create new <code>dynrModel</code> object.
The default is &quot;new_taste.c&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>dynrTaste</code> should be the dynrTaste object
that is output of the <code>dynr.taste</code> function the argument <code>dynrModel</code> is applied.
</p>
<p>The argument <code>dynrTaste</code> can be <code>NULL</code>,
if user-specified outliers are offered by the arguments
<code>delta_L</code> and <code>delta_O</code>.
</p>


<h3>Value</h3>

<p>a list with the two arguments;
a new <code>dynrModel</code> object the outliers are applied,
and a <code>dynrCook</code> object the new <code>dynrModel</code> object is cooked.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See the demo for outlier detection, OutlierDetection.R
dynrCook &lt;- dynr.cook(dynrModel)
dynrTaste &lt;- dynr.taste(dynrModel, dynrCook)

# Detect outliers related to 'eta1' out of, say, three latent
# variables c("eta1", "eta2", "eta3"), and all measured variables.
taste2 &lt;- dynr.taste2(dynrModel, dynrCook, dynrTaste)

## End(Not run)
</code></pre>

<hr>
<h2 id='dynr.trajectory'>A Function to perform numerical integration of the chosen ODE system, 
for a user-specified set of initial conditions. Plots the resulting solution(s) 
in the phase plane. This function from the phaseR package written by 
Michael J. Grayling.</h2><span id='topic+dynr.trajectory'></span>

<h3>Description</h3>

<p>A Function to perform numerical integration of the chosen ODE system, 
for a user-specified set of initial conditions. Plots the resulting solution(s) 
in the phase plane. This function from the phaseR package written by 
Michael J. Grayling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.trajectory(deriv, y0 = NULL, n = NULL, tlim, tstep = 0.01,
  parameters = NULL, system = "two.dim", col = "black", add = TRUE,
  state.names = c("x", "y"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.trajectory_+3A_deriv">deriv</code></td>
<td>
<p>A function computing the derivative at a point for the specified 
ODE system. See the phaseR package guide for more examples.</p>
</td></tr>
<tr><td><code id="dynr.trajectory_+3A_y0">y0</code></td>
<td>
<p>The initial condition(s) (ICs). In one-dimensional system, this can 
either be a single number indicating a single IC or a vector indicating multiple 
ICs. In two-dimensional system, this can either be a vector of length two 
reflecting the location of the two dependent variables initially, 
or it can be matrix where each row reflects a different set of ICs. 
Alternatively this can be left blank and the user can use locator to specify initial condition(s) on a plot. In this case, for one dimensional systems, all initial conditions are taken at tlim[1], even if not selected so on the graph. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="dynr.trajectory_+3A_n">n</code></td>
<td>
<p>If y0 is left NULL so initial conditions can be specified using 
locator, n sets the number of initial conditions to be chosen. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="dynr.trajectory_+3A_tlim">tlim</code></td>
<td>
<p>Sets the limits of the independent variable for which the solution 
should be plotted. Should be a vector of length two. If tlim[2] &gt; tlim[1], 
then tstep should be negative to indicate a backwards trajectory.</p>
</td></tr>
<tr><td><code id="dynr.trajectory_+3A_tstep">tstep</code></td>
<td>
<p>The step length of the independent variable, used 
in numerical integration. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="dynr.trajectory_+3A_parameters">parameters</code></td>
<td>
<p>Parameters of the ODE system, to be passed to deriv. 
Supplied as a vector; the order of the parameters can be found from the deriv file. 
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="dynr.trajectory_+3A_system">system</code></td>
<td>
<p>Set to either &quot;one.dim&quot; or &quot;two.dim&quot; to indicate the type of 
system being analysed. Defaults to &quot;two.dim&quot;.</p>
</td></tr>
<tr><td><code id="dynr.trajectory_+3A_col">col</code></td>
<td>
<p>The color(s) to plot the trajectories in. Will be reset accordingly if it is a vector not of the length of the number of initial conditions. Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="dynr.trajectory_+3A_add">add</code></td>
<td>
<p>Logical.  Defaults to TRUE.
TRUE = the trajectories added to an existing plot; FALSE = a new plot is created.</p>
</td></tr>
<tr><td><code id="dynr.trajectory_+3A_state.names">state.names</code></td>
<td>
<p>State names for the ODE functions that do not use positional states</p>
</td></tr>
<tr><td><code id="dynr.trajectory_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to either plot or arrows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
add, col, deriv, n, parameters, system, tlim, tstep, t, x, y, ylab, y0. 
Most of these components correspond simply to their original input values. 
</p>
<p>The only new elements are:
t = A vector containing the values of the independent variable at each integration step.
</p>
<p>x	= In the two dimensional system case, a matrix whose columns are the 
numerically computed values of the first dependent variable for each set of ICs.
</p>
<p>y	= In the two dimensional system case, a matrix whose columns are the numerically computed values of the second dependent variable for each initial condition. In the one dimensional system case, a matrix whose columns are the numerically computed values of the dependent variable for each initial condition.
</p>
<p>y0	= As per input, but converted to a matrix if supplied as a vector initially.
</p>


<h3>Note</h3>

<p>The phaseR package was taken off cran as off 10/1/2019 so we are 
exporting some selected functions from phaseR_2.0 published on 8/20/2018.
For details of these functions please see original documentations on the
phaseR package.
</p>


<h3>References</h3>

<p>Grayling, Michael J. (2014). phaseR: An R Package for Phase Plane Analysis of Autonomous
ODE Systems. The R Journal, 6(2), 43-51. DOI: 10.32614/RJ-2014-023. Available at
https://doi.org/10.32614/RJ-2014-023
</p>

<hr>
<h2 id='dynr.version'>Current Version String</h2><span id='topic+dynr.version'></span>

<h3>Description</h3>

<p>Current Version String
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynr.version(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynr.version_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print detailed information to the console (default)
</p>
<p>This function returns a string with the current version number of dynr. Optionally (with verbose = TRUE (the default)), it prints a message containing the version of R and the platform.  The primary purpose of the function is for bug reporting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (length-one) object of class 'package_version'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dynr.version()
dynr.version(verbose=FALSE)
packageVersion("dynr")
</code></pre>

<hr>
<h2 id='dynrCook-class'>The dynrCook Class</h2><span id='topic++24+2CdynrCook-method'></span><span id='topic+dynrCook-class'></span><span id='topic+dynrDebug-class'></span><span id='topic+print+2CdynrCook-method'></span><span id='topic+show+2CdynrCook-method'></span>

<h3>Description</h3>

<p>The dynrCook Class
</p>


<h3>Details</h3>

<p>This is an internal class structure.  You should not use it directly.
Use <code><a href="#topic+dynr.cook">dynr.cook</a></code> instead.
</p>

<hr>
<h2 id='dynrDynamics-class'>The dynrDynamics Class</h2><span id='topic+dynrDynamics-class'></span><span id='topic+dynrDynamicsFormula-class'></span><span id='topic+dynrDynamicsMatrix-class'></span>

<h3>Description</h3>

<p>The dynrDynamics Class
</p>


<h3>Details</h3>

<p>This is an internal class structure.  The classes <code>dynrDynamicsFormula-class</code> 
and <code>dynrDynamicsMatrix-class</code> are subclasses of this.  However, you should 
not use it directly.
Use <code><a href="#topic+prep.matrixDynamics">prep.matrixDynamics</a></code> or <code><a href="#topic+prep.formulaDynamics">prep.formulaDynamics</a></code> instead.
</p>

<hr>
<h2 id='dynrInitial-class'>The dynrInitial Class</h2><span id='topic+dynrInitial-class'></span>

<h3>Description</h3>

<p>The dynrInitial Class
</p>


<h3>Details</h3>

<p>This is an internal class structure.  You should not use it directly.
Use <code><a href="#topic+prep.initial">prep.initial</a></code> instead.
</p>

<hr>
<h2 id='dynrMeasurement-class'>The dynrMeasurement Class</h2><span id='topic+dynrMeasurement-class'></span>

<h3>Description</h3>

<p>The dynrMeasurement Class
</p>


<h3>Details</h3>

<p>This is an internal class structure.  You should not use it directly.
Use <code><a href="#topic+prep.measurement">prep.measurement</a></code> or <code><a href="#topic+prep.loadings">prep.loadings</a></code> instead.
</p>

<hr>
<h2 id='dynrModel-class'>The dynrModel Class</h2><span id='topic++24+2CdynrModel-method'></span><span id='topic++24+3C-+2CdynrModel-method'></span><span id='topic+dynrModel-class'></span><span id='topic+print+2CdynrModel-method'></span><span id='topic+show+2CdynrModel-method'></span>

<h3>Description</h3>

<p>The dynrModel Class
</p>


<h3>Details</h3>

<p>This is an internal class structure.  You should not use it directly.
Use <code><a href="#topic+dynr.model">dynr.model</a></code> instead.
</p>

<hr>
<h2 id='dynrNoise-class'>The dynrNoise Class</h2><span id='topic+dynrNoise-class'></span>

<h3>Description</h3>

<p>The dynrNoise Class
</p>


<h3>Details</h3>

<p>This is an internal class structure.  You should not use it directly.
Use <code><a href="#topic+prep.noise">prep.noise</a></code> instead.
</p>

<hr>
<h2 id='dynrRecipe-class'>The dynrRecipe Class</h2><span id='topic++24+2CdynrRecipe-method'></span><span id='topic+dynrRecipe-class'></span><span id='topic+print+2CdynrRecipe-method'></span><span id='topic+show+2CdynrRecipe-method'></span>

<h3>Description</h3>

<p>The dynrRecipe Class
</p>


<h3>Details</h3>

<p>This is an internal class structure.  You should not use it directly.
The following are all subclasses of this class: <code><a href="#topic+dynrMeasurement-class">dynrMeasurement-class</a></code>, 
<code><a href="#topic+dynrDynamics-class">dynrDynamics-class</a></code>, <code><a href="#topic+dynrRegimes-class">dynrRegimes-class</a></code>, 
<code><a href="#topic+dynrInitial-class">dynrInitial-class</a></code>, <code><a href="#topic+dynrNoise-class">dynrNoise-class</a></code>, 
and <code><a href="#topic+dynrTrans-class">dynrTrans-class</a></code>.  Recipes are the things that 
go into a <code><a href="#topic+dynrModel-class">dynrModel-class</a></code> using <code><a href="#topic+dynr.model">dynr.model</a></code>.
Use the recipe prep functions (<code><a href="#topic+prep.measurement">prep.measurement</a></code>, 
<code><a href="#topic+prep.formulaDynamics">prep.formulaDynamics</a></code>, <code><a href="#topic+prep.matrixDynamics">prep.matrixDynamics</a></code>, 
<code><a href="#topic+prep.regimes">prep.regimes</a></code>, <code><a href="#topic+prep.initial">prep.initial</a></code>, <code><a href="#topic+prep.noise">prep.noise</a></code>, 
or <code><a href="#topic+prep.tfun">prep.tfun</a></code>) to create these classes instead.
</p>

<hr>
<h2 id='dynrRegimes-class'>The dynrRegimes Class</h2><span id='topic+dynrRegimes-class'></span>

<h3>Description</h3>

<p>The dynrRegimes Class
</p>


<h3>Details</h3>

<p>This is an internal class structure.  You should not use it directly.
Use <code><a href="#topic+prep.regimes">prep.regimes</a></code> instead.
</p>

<hr>
<h2 id='dynrTrans-class'>The dynrTrans Class</h2><span id='topic+dynrTrans-class'></span>

<h3>Description</h3>

<p>The dynrTrans Class
</p>


<h3>Details</h3>

<p>This is an internal class structure.  You should not use it directly.
Use <code><a href="#topic+prep.tfun">prep.tfun</a></code> instead.
</p>

<hr>
<h2 id='EMG'>Single-subject time series of facial electromyography data</h2><span id='topic+EMG'></span>

<h3>Description</h3>

<p>A dataset obtained and analyzed in Yang and Chow (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EMG)
</code></pre>


<h3>Format</h3>

<p>A data frame with 695 rows and 4 variables</p>


<h3>Details</h3>

<p>Reference:
Yang, M-S. &amp; Chow, S-M. (2010). Using state-space models with regime switching to
represent the dynamics of facial electromyography (EMG) data. Psychometrika, 74(4), 744-771
</p>
<p>The variables are as follows:
</p>

<ul>
<li><p> id. ID of the participant (= 1 in this case, over 695 time points)
</p>
</li>
<li><p> time Time in seconds
</p>
</li>
<li><p> iEMG. Observed integrated facial electromyograhy data
</p>
</li>
<li><p> SelfReport. Covariate - the individual's concurrent self-reports
</p>
</li></ul>


<hr>
<h2 id='EMGsim'>Simulated single-subject time series to capture features of facial electromyography data</h2><span id='topic+EMGsim'></span>

<h3>Description</h3>

<p>A dataset simulated using an autoregressive model of order (AR(1)) with
regime-specific AR weight, intercept, and slope for a covariate. This model
is a special case of Model 1 in Yang and Chow (2010) in which the moving average
coefficient is set to zero.
</p>
<p>Reference:
Yang, M-S. &amp; Chow, S-M. (2010). Using state-space models with regime switching to 
represent the dynamics of facial electromyography (EMG) data. Psychometrika, 74(4), 744-771
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EMGsim)
</code></pre>


<h3>Format</h3>

<p>A data frame with 500 rows and 6 variables</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li><p> id. ID of the participant (= 1 in this case, over 500 time points)
</p>
</li>
<li><p> EMG. Hypothetical observed facial electromyograhy data
</p>
</li>
<li><p> self. Covariate - the individual's concurrent self-reports
</p>
</li>
<li><p> truestate. The true score of the individual's EMG at each time point
</p>
</li>
<li><p> trueregime. The true underlying regime for the individual at each time point
</p>
</li></ul>


<hr>
<h2 id='ExpandRandomAsLVModel'>Extend a user-specified model to include random varibles</h2><span id='topic+ExpandRandomAsLVModel'></span>

<h3>Description</h3>

<p>Extend a user-specified model to include random varibles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpandRandomAsLVModel(dynrModel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpandRandomAsLVModel_+3A_dynrmodel">dynrModel</code></td>
<td>
<p>a dynrModel object prepared with recipe functions <code><a href="#topic+prep.formulaDynamics">prep.formulaDynamics</a></code>, <code><a href="#topic+prep.measurement">prep.measurement</a></code>, <code><a href="#topic+prep.noise">prep.noise</a></code>, <code><a href="#topic+prep.initial">prep.initial</a></code>, <code><a href="#topic+dynr.data">dynr.data</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>dynrModel</code> is a collection of recipes.  The recipes are constructed with the functions unctions <code><a href="#topic+prep.formulaDynamics">prep.formulaDynamics</a></code>, <code><a href="#topic+prep.measurement">prep.measurement</a></code>, <code><a href="#topic+prep.noise">prep.noise</a></code>, <code><a href="#topic+prep.initial">prep.initial</a></code>. Additionally, data must be prepared with <code><a href="#topic+dynr.data">dynr.data</a></code> and added to the model.
</p>


<h3>Value</h3>

<p>an object of dynrModel that is the expanede model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># model &lt;- dynr.model(dynamics=dynm, measurement=meas, noise=mdcov,
#  initial=initial, data=data, outfile="osc.cpp")
# extended_model &lt;- ExpandRandomAsLVModel(model)


# For full demo examples, see:
# demo(OscWithRand, package="dynr")
# demo(VDPwithRand, package="dynr")
</code></pre>

<hr>
<h2 id='getdx'>A wrapper function to call functions in the fda package to obtain
smoothed estimated derivatives at a specified order</h2><span id='topic+getdx'></span>

<h3>Description</h3>

<p>A wrapper function to call functions in the fda package to obtain
smoothed estimated derivatives at a specified order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getdx(theTimes, norder, roughPenaltyMax, lambda, dataMatrix, derivOrder)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getdx_+3A_thetimes">theTimes</code></td>
<td>
<p>The time points at which derivative estimation are requested</p>
</td></tr>
<tr><td><code id="getdx_+3A_norder">norder</code></td>
<td>
<p>Order of Bsplines - usually 2 higher than roughPenaltyMax</p>
</td></tr>
<tr><td><code id="getdx_+3A_roughpenaltymax">roughPenaltyMax</code></td>
<td>
<p>Penalization order. Usually set to 2 higher than the highest-order derivatives desired</p>
</td></tr>
<tr><td><code id="getdx_+3A_lambda">lambda</code></td>
<td>
<p>A positive smoothing parameter: larger &ndash;&gt; more smoothing</p>
</td></tr>
<tr><td><code id="getdx_+3A_datamatrix">dataMatrix</code></td>
<td>
<p>Data of size total number of time points x  total number of subjects</p>
</td></tr>
<tr><td><code id="getdx_+3A_derivorder">derivOrder</code></td>
<td>
<p>The order of the desired derivative estimates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
1. out (a matrix containing the derivative estimates
at the specified order that matches the dimension of dataMatrix); 
2. basisCoef (estimated basis coefficients); 3. basis2 (basis functions)
</p>


<h3>References</h3>

<p>Chow, S-M. (2019). Practical Tools and Guidelines for Exploring and Fitting Linear 
and Nonlinear Dynamical Systems Models. Multivariate Behavioral Research. https://www.nihms.nih.gov/pmc/articlerender.fcgi?artid=1520409
</p>
<p>Chow, S-M., *Bendezu, J. J., Cole, P. M., &amp; Ram, N. (2016). A Comparison of Two-
Stage Approaches for Fitting Nonlinear Ordinary Differential Equation (ODE) 
Models with Mixed Effects. Multivariate Behavioral Research, 51, 154-184. Doi: 10.1080/00273171.2015.1123138.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("LinearOsc")
# Number of subjects is 10
numP &lt;- length(unique(LinearOsc$ID))
# Number of time points is 100
numT &lt;- max(table(LinearOsc$ID))
out2 &lt;- matrix(LinearOsc$x, ncol=numP, byrow=FALSE)
theTimes &lt;- LinearOsc$theTimes[1:numT]
# Order of Bsplines - usually 2 higher than roughPenaltyMax
norder &lt;- 6
# Penalization order
roughPenaltyMax &lt;- 4 
# Pick lambda value that gives the low GCV
# Could/should use plotGCV instead
sp &lt;- 1/2
# Smoothed level
x &lt;- getdx(theTimes, norder, roughPenaltyMax, sp, out2, 0)[[1]]
# Smoothed 1st derivs
dx &lt;- getdx(theTimes, norder, roughPenaltyMax, sp, out2, 1)[[1]]
# Smoothed 2nd derivs
d2x = getdx(theTimes, norder, roughPenaltyMax, sp, out2, 2)[[1]]
</code></pre>

<hr>
<h2 id='internalModelPrep'>Do internal model preparation for dynr</h2><span id='topic+internalModelPrep'></span>

<h3>Description</h3>

<p>Principally, this function takes a host of arguments and gives back
a list that importantly includes the function addresses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>internalModelPrep(num_regime, dim_latent_var, xstart, ub, lb,
  options = default.model.options, isContinuousTime, infile, outfile,
  compileLib, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internalModelPrep_+3A_num_regime">num_regime</code></td>
<td>
<p>An integer number of the regimes.</p>
</td></tr>
<tr><td><code id="internalModelPrep_+3A_dim_latent_var">dim_latent_var</code></td>
<td>
<p>An integer number of the latent variables.</p>
</td></tr>
<tr><td><code id="internalModelPrep_+3A_xstart">xstart</code></td>
<td>
<p>The starting values for parameter estimation.</p>
</td></tr>
<tr><td><code id="internalModelPrep_+3A_ub">ub</code></td>
<td>
<p>The upper bounds of the estimated parameters.</p>
</td></tr>
<tr><td><code id="internalModelPrep_+3A_lb">lb</code></td>
<td>
<p>The lower bounds of the estimated parameters.</p>
</td></tr>
<tr><td><code id="internalModelPrep_+3A_options">options</code></td>
<td>
<p>A list of NLopt estimation options. By default, xtol_rel=1e-7, stopval=-9999, ftol_rel=-1, ftol_abs=-1, maxeval=as.integer(-1), and maxtime=-1.</p>
</td></tr>
<tr><td><code id="internalModelPrep_+3A_iscontinuoustime">isContinuousTime</code></td>
<td>
<p>A binary flag indicating whether the model is a continuous-time model (FALSE/0 = no; TRUE/1 = yes)</p>
</td></tr>
<tr><td><code id="internalModelPrep_+3A_infile">infile</code></td>
<td>
<p>Input file name</p>
</td></tr>
<tr><td><code id="internalModelPrep_+3A_outfile">outfile</code></td>
<td>
<p>Output file name</p>
</td></tr>
<tr><td><code id="internalModelPrep_+3A_compilelib">compileLib</code></td>
<td>
<p>Whether to compile the libary anew</p>
</td></tr>
<tr><td><code id="internalModelPrep_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag for verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of model statements to be passed to dynr.cook().
</p>

<hr>
<h2 id='LinearOsc'>Simulated time series data for a deterministic linear damped oscillator model</h2><span id='topic+LinearOsc'></span>

<h3>Description</h3>

<p>The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LinearOsc)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 3 variables</p>


<h3>Details</h3>


<ul>
<li><p> ID. ID of the systems (1 to 10)
</p>
</li>
<li><p> x. Latent level variable
</p>
</li>
<li><p> theTimes. Measured time Points
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># The following was used to generate the data
#--------------------------------------
## Not run: 
Osc &lt;- function(t, prevState, parms) {
  x1 &lt;- prevState[1] # x1[t]
  x2 &lt;- prevState[2] # x2[t]
  eta1 = parms[1]
  zeta1 = parms[2]
  with(as.list(parms), {
   dx1 &lt;- x2
    dx2 &lt;- eta1*x1 + zeta1*x2 
    res&lt;-c(dx1,dx2)
    list(res)
  }
  )
}
n = 10 #Number of subjects
T = 100 #Number of time points
deltaT = .1 #dt
lastT = deltaT*T #Value of t_{i,T}
theTimes  = seq(0, lastT, length=T)  #A list of time values

eta = -.8
zeta = -.1
out1 = matrix(NA,T*n,1)
trueOut = matrix(NA,T*n,1)
parms = c(eta, zeta)
  for (i in 1:n){
  xstart = c(rnorm(1,0,2),rnorm(1,0,.5))
  out &lt;- lsoda(as.numeric(xstart), theTimes, Osc, parms)
  trueOut[(1+(i-1)*T):(i*T)] = out[,2]
  out1[(1+(i-1)*T):(i*T)] = out[,2]+rnorm(T,0,1)
  }

LinearOsc= data.frame(ID=rep(1:n,each=T),x=out1[,1],
                  theTimes=rep(theTimes,n))
save(LinearOsc,file="LinearOsc.rda")

## End(Not run)
</code></pre>

<hr>
<h2 id='LogisticSetPointSDE'>Simulated time series data for a stochastic linear damped oscillator model with logistic time-varying setpoints</h2><span id='topic+LogisticSetPointSDE'></span>

<h3>Description</h3>

<p>A dataset simulated using a continuous-time stochastic linear damped oscillator model.
The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LogisticSetPointSDE)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2410 rows and 6 variables</p>


<h3>Details</h3>


<ul>
<li><p> id. ID of the systems (1 to 10)
</p>
</li>
<li><p> times. Time index (241 time points for each system)
</p>
</li>
<li><p> x. Latent level variable
</p>
</li>
<li><p> y. Latent first derivative variable
</p>
</li>
<li><p> z. True values of time-varying setpoints
</p>
</li>
<li><p> obsy. Observed level
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># The following was used to generate the data
#---------------------------------------
## Not run: 
require(Sim.DiffProc)
freq &lt;- -1
damp &lt;- -.1
mu &lt;- -2
r &lt;- .5
b &lt;- .1
sigma1 &lt;- 0.1
sigma2 &lt;- 0.1
fx &lt;- expression(y, freq*(x-z) + damp*y, r*z*(1-b*z))
gx &lt;- expression(0, sigma1, 0)
r3dall &lt;- c()
for (j in 1:10){
  r3dtemp &lt;- c(-5,0,.1)
  r3d &lt;- r3dtemp
  for (i in seq(0.125, 30, by=0.125)){
    mod3dtemp &lt;- snssde3d(drift=fx, diffusion=gx, M=1, t0=i-0.125,
        x0=as.numeric(r3dtemp), T=i, N=500, type="str",
        method="smilstein")
    r3dtemp &lt;- rsde3d(mod3dtemp,at=i)
    r3d &lt;-rbind(r3d,r3dtemp)
  }
  r3dall &lt;- rbind(r3dall, cbind(r3d, id=j))
}

r3dall$obsy &lt;- r3dall$x+rnorm(length(r3dall$x),0,1)
write.table(r3dall, file="LogisticSetPointSDE.txt")

## End(Not run)
</code></pre>

<hr>
<h2 id='logLik.dynrCook'>Extract the log likelihood from a dynrCook Object</h2><span id='topic+deviance.dynrCook'></span><span id='topic+logLik.dynrCook'></span>

<h3>Description</h3>

<p>Extract the log likelihood from a dynrCook Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynrCook'
logLik(object, ...)

## S3 method for class 'dynrCook'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.dynrCook_+3A_object">object</code></td>
<td>
<p>The dynrCook object for which the log likelihood is desired</p>
</td></tr>
<tr><td><code id="logLik.dynrCook_+3A_...">...</code></td>
<td>
<p>further named arguments, ignored for this method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'df' attribute for this object is the number of freely estimated parameters. The 'nobs' attribute is the total number of rows of data, adding up the number of time points for each person.
</p>
<p>The <code>deviance</code> method returns minus two times the log likelihood.
</p>


<h3>Value</h3>

<p>In the case of <code>logLik</code>, an object of class <code>logLik</code>.
</p>


<h3>See Also</h3>

<p>Other S3 methods <code><a href="#topic+coef.dynrCook">coef.dynrCook</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Minimal model
require(dynr)

meas &lt;- prep.measurement(
	values.load=matrix(c(1, 0), 1, 2),
	params.load=matrix(c('fixed', 'fixed'), 1, 2),
	state.names=c("Position","Velocity"),
	obs.names=c("y1"))

ecov &lt;- prep.noise(
	values.latent=diag(c(0, 1), 2),
	params.latent=diag(c('fixed', 'dnoise'), 2),
	values.observed=diag(1.5, 1),
	params.observed=diag('mnoise', 1))

initial &lt;- prep.initial(
	values.inistate=c(0, 1),
	params.inistate=c('inipos', 'fixed'),
	values.inicov=diag(1, 2),
	params.inicov=diag('fixed', 2))

dynamics &lt;- prep.matrixDynamics(
	values.dyn=matrix(c(0, -0.1, 1, -0.2), 2, 2),
	params.dyn=matrix(c('fixed', 'spring', 'fixed', 'friction'), 2, 2),
	isContinuousTime=TRUE)

data(Oscillator)
data &lt;- dynr.data(Oscillator, id="id", time="times", observed="y1")

model &lt;- dynr.model(dynamics=dynamics, measurement=meas,
	noise=ecov, initial=initial, data=data)

## Not run: 
cook &lt;- dynr.cook(model,
	verbose=FALSE, optimization_flag=FALSE, hessian_flag=FALSE)

# Now get the log likelihood!
logLik(cook)

## End(Not run)
</code></pre>

<hr>
<h2 id='names+2CdynrCook-method'>Extract the free parameter names of a dynrCook object</h2><span id='topic+names+2CdynrCook-method'></span>

<h3>Description</h3>

<p>Extract the free parameter names of a dynrCook object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dynrCook'
names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names+2B2CdynrCook-method_+3A_x">x</code></td>
<td>
<p>The dynrCook object from which the free parameter names are desired</p>
</td></tr>
</table>

<hr>
<h2 id='names+2CdynrModel-method'>Extract the free parameter names of a dynrModel object</h2><span id='topic+names+2CdynrModel-method'></span>

<h3>Description</h3>

<p>Extract the free parameter names of a dynrModel object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dynrModel'
names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names+2B2CdynrModel-method_+3A_x">x</code></td>
<td>
<p>The dynrModel object from which the free parameter names are desired</p>
</td></tr>
</table>

<hr>
<h2 id='nobs.dynrCook'>Extract the number of observations for a dynrCook object</h2><span id='topic+nobs.dynrCook'></span>

<h3>Description</h3>

<p>Extract the number of observations for a dynrCook object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynrCook'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs.dynrCook_+3A_object">object</code></td>
<td>
<p>A fitted model object</p>
</td></tr>
<tr><td><code id="nobs.dynrCook_+3A_...">...</code></td>
<td>
<p>Further named arguments. Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We return the total number of rows of data, adding up the number of time points for each person. For some purposes, you may want the mean number of observations per person or the number of people instead.  These are not currently supported via <code>nobs</code>.
</p>


<h3>Value</h3>

<p>A single number. The total number of observations across all IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Minimal model
require(dynr)

meas &lt;- prep.measurement(
	values.load=matrix(c(1, 0), 1, 2),
	params.load=matrix(c('fixed', 'fixed'), 1, 2),
	state.names=c("Position","Velocity"),
	obs.names=c("y1"))

ecov &lt;- prep.noise(
	values.latent=diag(c(0, 1), 2),
	params.latent=diag(c('fixed', 'dnoise'), 2),
	values.observed=diag(1.5, 1),
	params.observed=diag('mnoise', 1))

initial &lt;- prep.initial(
	values.inistate=c(0, 1),
	params.inistate=c('inipos', 'fixed'),
	values.inicov=diag(1, 2),
	params.inicov=diag('fixed', 2))

dynamics &lt;- prep.matrixDynamics(
	values.dyn=matrix(c(0, -0.1, 1, -0.2), 2, 2),
	params.dyn=matrix(c('fixed', 'spring', 'fixed', 'friction'), 2, 2),
	isContinuousTime=TRUE)

data(Oscillator)
data &lt;- dynr.data(Oscillator, id="id", time="times", observed="y1")

model &lt;- dynr.model(dynamics=dynamics, measurement=meas,
	noise=ecov, initial=initial, data=data)

## Not run: 
cook &lt;- dynr.cook(model,
	verbose=FALSE, optimization_flag=FALSE, hessian_flag=FALSE)

# Now get the total number of observations
nobs(cook)

## End(Not run)
</code></pre>

<hr>
<h2 id='nobs.dynrModel'>Extract the number of observations for a dynrModel object</h2><span id='topic+nobs.dynrModel'></span>

<h3>Description</h3>

<p>Extract the number of observations for a dynrModel object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynrModel'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs.dynrModel_+3A_object">object</code></td>
<td>
<p>An unfitted model object</p>
</td></tr>
<tr><td><code id="nobs.dynrModel_+3A_...">...</code></td>
<td>
<p>Further named arguments. Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We return the total number of rows of data, adding up the number of time points for each person. For some purposes, you may want the mean number of observations per person or the number of people instead.  These are not currently supported via <code>nobs</code>.
</p>


<h3>Value</h3>

<p>A single number. The total number of observations across all IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a minimal uncooked model called 'model'
# That is, without esimating parameters
require(dynr)

meas &lt;- prep.measurement(
	values.load=matrix(c(1, 0), 1, 2),
	params.load=matrix(c('fixed', 'fixed'), 1, 2),
	state.names=c("Position","Velocity"),
	obs.names=c("y1"))

ecov &lt;- prep.noise(
	values.latent=diag(c(0, 1), 2),
	params.latent=diag(c('fixed', 'dnoise'), 2),
	values.observed=diag(1.5, 1),
	params.observed=diag('mnoise', 1))

initial &lt;- prep.initial(
	values.inistate=c(0, 1),
	params.inistate=c('inipos', 'fixed'),
	values.inicov=diag(1, 2),
	params.inicov=diag('fixed', 2))

dynamics &lt;- prep.matrixDynamics(
	values.dyn=matrix(c(0, -0.1, 1, -0.2), 2, 2),
	params.dyn=matrix(c('fixed', 'spring', 'fixed', 'friction'), 2, 2),
	isContinuousTime=TRUE)

data(Oscillator)
data &lt;- dynr.data(Oscillator, id="id", time="times", observed="y1")

model &lt;- dynr.model(dynamics=dynamics, measurement=meas,
	noise=ecov, initial=initial, data=data)

# Now get the total number of observations!
nobs(model)
</code></pre>

<hr>
<h2 id='NonlinearDFAsim'>Simulated multi-subject time series based on a dynamic factor analysis model with nonlinear relations at the latent level</h2><span id='topic+NonlinearDFAsim'></span>

<h3>Description</h3>

<p>A dataset simulated using a discrete-time nonlinear dynamic factor analysis model
with 6 observed indicators for identifying two latent factors: individuals'
positive and negative emotions. Proposed by Chow and Zhang (2013), the model was inspired 
by models of affect and it posits that the two latent factors follow a vector autoregressive
process of order 1 (VAR(1)) with parameters that vary between two possible regimes:
(1) an &quot;independent&quot; regime in which the lagged influences between positive and negative
emotions are zero; (2) a &quot;high-activation&quot; regime to capture instances
on which the lagged influences between PA and NA intensify when an individual's previous 
levels of positive and negative emotions were unusually high or low (see Model 2 in Chow &amp; Zhang).
</p>
<p>Reference:
Chow, S-M, &amp; Zhang, G. (2013). Regime-switching nonlinear dynamic factor analysis 
models. Psychometrika, 78(4), 740-768.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NonlinearDFAsim)
</code></pre>


<h3>Format</h3>

<p>A data frame with 3000 rows and 8 variables</p>


<h3>Details</h3>


<ul>
<li><p> id. ID of the participant (1 to 10)
</p>
</li>
<li><p> time. Time index (300 time points from each subject)
</p>
</li>
<li><p> y1-y3. Observed indicators for positive emotion
</p>
</li>
<li><p> y4-y6. Observed indicators for negative emotion
</p>
</li></ul>


<hr>
<h2 id='oscData'>Another simulated multilevel multi-subject time series of a damped oscillator model</h2><span id='topic+oscData'></span>

<h3>Description</h3>

<p>The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oscData)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1,800 rows and 6 variables</p>


<h3>Details</h3>


<ul>
<li><p> id. Person ID
</p>
</li>
<li><p> times. Continuous time of measurement
</p>
</li>
<li><p> y1. Observed score 1
</p>
</li>
<li><p> u1. Covariate 1
</p>
</li>
<li><p> u2. Covariate 2
</p>
</li>
<li><p> trueb. True value of person-specific random effect	
</p>
</li></ul>


<hr>
<h2 id='Oscillator'>Simulated time series data of a damped linear oscillator</h2><span id='topic+Oscillator'></span>

<h3>Description</h3>

<p>A dataset simulated using a damped linear oscillator model in continuous time
with 1 observed indicator for identifying two latent factors (position and velocity).
The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Oscillator)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 5 variables</p>


<h3>Details</h3>


<ul>
<li><p> id. ID of the systems (1 to 1 because this is a single person)
</p>
</li>
<li><p> y1. Noisy observed position
</p>
</li>
<li><p> times. Time index (1000 time points) spaced at one unit intervals
</p>
</li>
<li><p> x1. True latent position
</p>
</li>
<li><p> x2. True latent velocity
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># The following was used to generate the data
#--------------------------------------
# Data Generation
## Not run: 
require(mvtnorm)
require(Matrix)

xdim &lt;- 2
udim &lt;- 1
ydim &lt;- 1
tdim &lt;- 1000
set.seed(315)
tA &lt;- matrix(c(0, -.3, 1, -.7), xdim, xdim)
tB &lt;- matrix(c(0), xdim, udim)
tC &lt;- matrix(c(1, 0), ydim, xdim)
tD &lt;- matrix(c(0), ydim, udim)
tQ &lt;- matrix(c(0), xdim, xdim); diag(tQ) &lt;- c(0, 2.2)
tR &lt;- matrix(c(0), ydim, ydim); diag(tR) &lt;- c(1.5)

x0 &lt;- matrix(c(0, 1), xdim, 1)
P0 &lt;- diag(c(1), xdim)
tdx &lt;- matrix(0, xdim, tdim+1)
tx &lt;- matrix(0, xdim, tdim+1)
tu &lt;- matrix(0, udim, tdim)
ty &lt;- matrix(0, ydim, tdim)

tT &lt;- matrix(0:tdim, nrow=1, ncol=tdim+1)

tI &lt;- diag(1, nrow=xdim)

tx[,1] &lt;- x0
for(i in 2:(tdim+1)){
	q &lt;- t(rmvnorm(1, rep(0, xdim), tQ))
	tdx[,i] &lt;- tA %*% tx[,i-1] + tB %*% tu[,i-1] + q
	expA &lt;- as.matrix(expm(tA * (tT[,i]-tT[,i-1])))
	intA &lt;- solve(tA) %*% (expA - tI)
	tx[,i] &lt;- expA %*% tx[, i-1] + intA %*% tB %*% tu[,i-1] + intA %*% q
	ty[,i-1] &lt;- tC %*% tx[,i] + tD %*% tu[,i-1] + t(rmvnorm(1, rep(0, ydim), tR))
}



rownames(ty) &lt;- paste('y', 1:ydim, sep='')
rownames(tx) &lt;- paste('x', 1:xdim, sep='')
simdata &lt;- cbind(id=rep(1, tdim), t(ty), times=tT[,-1], t(tx)[-1,])
 write.table(simdata, file='Oscillator.txt', row.names=FALSE, col.names=TRUE)

plot(tx[1,], type='l')
plot(tT[,-1], ty[1,], type='l')

## End(Not run)
</code></pre>

<hr>
<h2 id='Outliers'>Simulated time series data for detecting outliers.</h2><span id='topic+Outliers'></span>

<h3>Description</h3>

<p>This is a list object containing true outliers, the dataset, and the saved result from running dynr.taste.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Outliers)
</code></pre>


<h3>Format</h3>

<p>A data frame with 6000 rows and 6 variables</p>


<h3>Details</h3>

<p>The true outliers for observed variables are saved in &lsquo;Outliers$generated$shockO&rsquo;.
</p>

<ul>
<li><p> id. Six outliers were added for each ID. 
</p>
</li>
<li><p> time_O. Time points where the outliers were added.
</p>
</li>
<li><p> obs. Variable indices where the outliers were added.
</p>
</li>
<li><p> shock.O. The magnitude of outliers.
</p>
</li></ul>

<p>The true outliers for state variables are saved in &lsquo;Outliers$generated$shockL&rsquo;.
</p>

<ul>
<li><p> id. Three outliers were added for each ID. 
</p>
</li>
<li><p> time_L. Time points where the outliers were added.
</p>
</li>
<li><p> lat. Variable indices where the outliers were added.
</p>
</li>
<li><p> shock.L. The magnitude of outliers.
</p>
</li></ul>

<p>A dataset simulated based on state-space model including the outliers. The data is saved in &lsquo;Outliers$generated$y&rsquo;.
The variables are as follows:
</p>

<ul>
<li><p> id. ID of the systems (1 to 100)
</p>
</li>
<li><p> times. Time indices (100 time points for each participant)
</p>
</li>
<li><p> V1 - V6. observed variables
</p>
</li></ul>

<p>The detected innovative outliers from dynr.taste for this dataset, which is used for testing whether the dynr.taste replicate the same result. The data is saved in &lsquo;Outliers$detect_O&rsquo;.
The variables are as follows:
</p>

<ul>
<li><p> id. IDs
</p>
</li>
<li><p> time_L. Time points where the outliers were detected
</p>
</li>
<li><p> obs. Variable indices for observed variables where the outliers were detected
</p>
</li></ul>

<p>The detected additive outliers from dynr.taste for this dataset, which is used for testing whether the dynr.taste replicate the same result. The data is saved in &lsquo;Outliers$detect_L&rsquo;.
The variables are as follows:
</p>

<ul>
<li><p> id. IDs
</p>
</li>
<li><p> time_L. Time points where the outliers were detected
</p>
</li>
<li><p> obs. Variable indices for latent variables where the outliers were detected
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 #The following was used to generate the data
 #---------------------------------------
 lambda &lt;- matrix(c(1.0, 0.0,
 0.9, 0.0,
 0.8, 0.0,
 0.0, 1.0,
 0.0, 0.9,
 0.0, 0.8), ncol=2, byrow=TRUE)
 psi &lt;- matrix(c(0.3, -0.1,
                 -0.1, 0.3), ncol=2, byrow=TRUE)
 beta &lt;- matrix(c(0.8, -0.2,
                  -0.2,  0.7), ncol=2, byrow=TRUE)
 theta &lt;- diag(c(0.2, 0.2, 0.2, 0.2, 0.2, 0.2), ncol=6, nrow=6)
 nlat &lt;- 2; nobs &lt;- 6
 mean_0 &lt;- rep(0, nlat)
 psi_inf &lt;- diag(1, 2*2) - kronecker(beta, beta)
 psi_inf_inv &lt;- try(solve(psi_inf), silent=TRUE)
 if("try-error" %in% class(psi_inf_inv)) {
   psi_inf_inv &lt;- MASS::ginv(psi_inf)}
 psi_0 &lt;- psi_inf_inv %*% as.vector(psi)
 dim(psi_0) &lt;- c(2, 2)
 # measurement error covariance matrix
 mea_cov &lt;- lambda %*% psi_0 %*% t(lambda) + theta
 resL &lt;- lapply(1:100, function(subj) {
   # initial state
   eta_0 &lt;- mvtnorm::rmvnorm(1, mean=mean_0, sigma=psi_0)#[1,nlat]
   zeta_0 &lt;- mvtnorm::rmvnorm(1, mean=rep(0, nlat), sigma=psi)
   eta &lt;- matrix(0, nrow=time, ncol=nlat)
   eta[1, ] &lt;- beta %*% t(eta_0) + t(zeta_0) 
   zeta &lt;- mvtnorm::rmvnorm(time, mean=rep(0, nlat), sigma=psi)
   # random shock generation
   # to avoid shock appearing too early or late (first and last 3)
   shkLat_time &lt;- sample(4:(time-3), nshockLat)
   shk_lat &lt;- sample(1:nlat, nshockLat, replace=TRUE)
   shockLatIdx &lt;- matrix(c(shkLat_time, shk_lat), ncol=2)
   shockSignL &lt;- sample(c(1,-1), nshockLat, replace=TRUE)
   colnames(shockLatIdx) &lt;- c("time_L","lat")
   shockLatV &lt;- shockSignL*( shockMag*sqrt(diag(shockPsi)))[shockLatIdx[,"lat"]]
   shockLatM &lt;- matrix(0, time, nlat)
   shockLatM[shockLatIdx] &lt;- shockLatV
   shkObs_time &lt;- sample(4:(time-3), nshockObs)
   shk_obs &lt;- sample(1:nobs, nshockObs, replace=TRUE)
   shockObsIdx &lt;- matrix(c(shkObs_time, shk_obs), ncol=2)
   shockSignO &lt;- sample(c(1,-1), nshockObs, replace=TRUE)
   colnames(shockObsIdx) &lt;- c("time_O","obs")
   shockObsV &lt;- shockSignO*( shockMag*sqrt(diag(mea_cov)) )[shockObsIdx[,"obs"]]
   shockObsM &lt;- matrix(0, time, nobs)
   shockObsM[shockObsIdx] &lt;- shockObsV
   # generate state process WITH shock
   for (t in 1:(time-1)) {
     eta[t+1, ] &lt;- shockLatM[t, ] + beta %*% eta[t, ] + zeta[t, ]
   }
   # generate observed process
   y &lt;- shockObsM + eta %*% t(lambda) +
     mvtnorm::rmvnorm(time, mean=rep(0, nobs), sigma=theta)# epsilon
 }
 
## End(Not run)
</code></pre>

<hr>
<h2 id='PFAsim'>Simulated time series data of a multisubject process factor analysis</h2><span id='topic+PFAsim'></span>

<h3>Description</h3>

<p>A multiple subject dataset simulated using a two factor process factor analysis model in discrete time
with 6 observed indicators for identifying two latent factors.
The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PFAsim)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2,500 rows and 10 variables</p>


<h3>Details</h3>


<ul>
<li><p> ID. Person ID variable (1 to 50 because there are 50 simulated people)
</p>
</li>
<li><p> Time. Time ID variable (1 to 50 because there are 50 time points)
</p>
</li>
<li><p> V1. Noisy observed variable 1
</p>
</li>
<li><p> V2. Noisy observed variable 2
</p>
</li>
<li><p> V3. Noisy observed variable 3
</p>
</li>
<li><p> V4. Noisy observed variable 4
</p>
</li>
<li><p> V5. Noisy observed variable 5
</p>
</li>
<li><p> V6. Noisy observed variable 6
</p>
</li>
<li><p> F1. True latent variable 1 scores
</p>
</li>
<li><p> F2. True latent variable 2 scores
</p>
</li></ul>

<p>Variables V1, V2, and V3 load on F1, whereas variables V4, V5, V6 load on F2.  The true values of the factor loadings are 1, 2, 1, 1, 2, and 1, respectively.  The true measurement error variance is 0.5 for all variables.  The true dynamic noise covariance has F1 with a variance of 2.77, F2 with a variance of 8.40, and their covariance is 2.47.  The across-time dynamics have autoregressive effects of 0.5 for both F1 and F2 with a cross-lagged effect from F1 to F2 at 0.4.  The cross-lagged effect from F2 to F1 is zero.  The true initial latent state distribution as mean zero and a diagonal covariance matrix with var(F1) = 2 and var(F2) = 1.  The generating model is the same for all individuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following was used to generate the data
## Not run: 
set.seed(12345678)
library(mvtnorm)
# setting up matrices
time      &lt;- 50
# Occasions to throw out to wash away the effects of initial condition
npad      &lt;- 0
np        &lt;- 50
ne        &lt;- 2 #Number of latent variables
ny        &lt;- 6 #Number of manifest variables
# Residual variance-covariance matrix
psi       &lt;- matrix(c(2.77, 2.47,
                      2.47, 8.40),
                    ncol = ne, byrow = T)
# Lambda matrix containing contemporaneous relations among
# observed variables and 2 latent variables. 
lambda    &lt;- matrix(c(1, 0,
                      2, 0,
                      1, 0,
                      0, 1,
                      0, 2,
                      0, 1),
                    ncol = ne, byrow = TRUE)
# Measurement error variances
theta     &lt;- diag(.5, ncol = ny, nrow = ny)
# Lagged directed relations among variables
beta      &lt;- matrix(c(0.5, 0,
                      0.4, 0.5), 
                    ncol = ne, byrow = TRUE)
a0        &lt;- mvtnorm::rmvnorm(1, mean = c(0, 0),
                                 sigma = matrix(c(2,0,0,1),ncol=ne))
yall &lt;- matrix(0,nrow = time*np, ncol = ny)
eall &lt;- matrix(0,nrow = time*np, ncol = ne)
for (p in 1:np){
  # Latent variable residuals
  zeta      &lt;- mvtnorm::rmvnorm(time+npad, mean = c(0, 0), sigma = psi)
  # Measurement errors
  epsilon   &lt;- rmvnorm(time, mean = c(0, 0, 0, 0, 0, 0), sigma = theta)
  # Set up matrix for contemporaneous variables
  etaC      &lt;- matrix(0, nrow = ne, ncol = time + npad)
  # Set up matrix for lagged variables
  etaL      &lt;- matrix(0, nrow = ne, ncol = time + npad + 1)
  
  etaL[,1]  &lt;- a0
  etaC[,1] &lt;- a0
  # generate factors
  for (i in 2:(time+npad)){
    etaL[ ,i] &lt;- etaC[,i-1]
    etaC[ ,i]   &lt;- beta %*% etaL[ ,i] + zeta[i, ]
  }
  etaC &lt;- etaC[,(npad+1):(npad+time)]
  eta &lt;- t(etaC)
  
  # generate observed series
  y   &lt;- matrix(0, nrow = time, ncol = ny)
  for (i in 1:nrow(y)){
    y[i, ] &lt;- lambda %*% eta[i, ] + epsilon[i, ]
  }
  yall[(1+(p-1)*time):(p*time),] &lt;- y
  eall[(1+(p-1)*time):(p*time),] &lt;- eta
}
yall &lt;- cbind(rep(1:np,each=time),rep(1:time,np),yall)
yeall &lt;- cbind(yall,eall)
write.table(yeall,'PFAsim.txt',row.names=FALSE,
  col.names=c("ID", "Time", paste0("V", 1:ny), paste0("F", 1:ne)))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.dynrCook'>Plot method for dynrCook objects</h2><span id='topic+plot.dynrCook'></span>

<h3>Description</h3>

<p>Plot method for dynrCook objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynrCook'
plot(x, dynrModel, style = 1, names.state, names.observed,
  printDyn = TRUE, printMeas = TRUE, textsize = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dynrCook_+3A_x">x</code></td>
<td>
<p>dynrCook object</p>
</td></tr>
<tr><td><code id="plot.dynrCook_+3A_dynrmodel">dynrModel</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="plot.dynrCook_+3A_style">style</code></td>
<td>
<p>The style of the plot in the first panel. If style is 1 (default), user-selected smoothed state variables are plotted. If style is 2, user-selected observed-versus-predicted values are plotted.</p>
</td></tr>
<tr><td><code id="plot.dynrCook_+3A_names.state">names.state</code></td>
<td>
<p>(optional) The names of the states to be plotted, which should be a subset of the state.names slot of the measurement slot of dynrModel.</p>
</td></tr>
<tr><td><code id="plot.dynrCook_+3A_names.observed">names.observed</code></td>
<td>
<p>(optional) The names of the observed variables to be plotted, which should be a subset of the obs.names slot of the measurement slot of dynrModel.</p>
</td></tr>
<tr><td><code id="plot.dynrCook_+3A_printdyn">printDyn</code></td>
<td>
<p>A logical value indicating whether or not to plot the formulas for the dynamic model</p>
</td></tr>
<tr><td><code id="plot.dynrCook_+3A_printmeas">printMeas</code></td>
<td>
<p>A logical value indicating whether or not to plot the formulas for the measurement model</p>
</td></tr>
<tr><td><code id="plot.dynrCook_+3A_textsize">textsize</code></td>
<td>
<p>numeric. Font size used in the plot.</p>
</td></tr>
<tr><td><code id="plot.dynrCook_+3A_...">...</code></td>
<td>
<p>Further named arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper around <code><a href="#topic+dynr.ggplot">dynr.ggplot</a></code>.  A great benefit of it is that it shows the model equations in a plot.
</p>


<h3>Value</h3>

<p>ggplot object.
</p>

<hr>
<h2 id='plotFormula'>Plot the formula from a model</h2><span id='topic+plotFormula'></span>

<h3>Description</h3>

<p>Plot the formula from a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFormula(dynrModel, ParameterAs, printDyn = TRUE, printMeas = TRUE,
  printRS = FALSE, textsize = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotFormula_+3A_dynrmodel">dynrModel</code></td>
<td>
<p>The model object to plot.</p>
</td></tr>
<tr><td><code id="plotFormula_+3A_parameteras">ParameterAs</code></td>
<td>
<p>The parameter values or names to plot. The underscores in parameter names are saved for 
use of subscripts.  Greek letters can be specified as corresponding LaTeX symbols without backslashes (e.g., &quot;lambda&quot;) 
and printed as greek letters.</p>
</td></tr>
<tr><td><code id="plotFormula_+3A_printdyn">printDyn</code></td>
<td>
<p>A logical value indicating whether or not to plot the formulas for the dynamic model.</p>
</td></tr>
<tr><td><code id="plotFormula_+3A_printmeas">printMeas</code></td>
<td>
<p>A logical value indicating whether or not to plot the formulas for the measurement model</p>
</td></tr>
<tr><td><code id="plotFormula_+3A_printrs">printRS</code></td>
<td>
<p>logical. Whether or not to print the regime-switching model. The default is FALSE.</p>
</td></tr>
<tr><td><code id="plotFormula_+3A_textsize">textsize</code></td>
<td>
<p>The text size use in the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function typesets a set of formulas that represent the model.  Typical inputs to the <code>ParameterAs</code> argument are (1) the starting values for a model, (2) the final estimated values for a model, and (3) the parameter names.  These are accessible with (1) <code>model$xstart</code>, (2) <code>coef(cook)</code>, and (3) <code>model$param.names</code> or <code>names(coef(cook))</code>, respectively.
</p>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='plotGCV'>A function to evaluate the generalized cross-validation (GCV) values 
associated with derivative estimates via Bsplines at a range of specified 
smoothing parameter (lambda) values</h2><span id='topic+plotGCV'></span>

<h3>Description</h3>

<p>A function to evaluate the generalized cross-validation (GCV) values 
associated with derivative estimates via Bsplines at a range of specified 
smoothing parameter (lambda) values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGCV(theTimes, norder, roughPenaltyMax, dataMatrix, lowLambda, upLambda,
  lambdaInt, isPlot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotGCV_+3A_thetimes">theTimes</code></td>
<td>
<p>The time points at which derivative estimation are requested</p>
</td></tr>
<tr><td><code id="plotGCV_+3A_norder">norder</code></td>
<td>
<p>Order of Bsplines - usually 2 higher than roughPenaltyMax</p>
</td></tr>
<tr><td><code id="plotGCV_+3A_roughpenaltymax">roughPenaltyMax</code></td>
<td>
<p>Penalization order. Usually set to 2 higher than the highest-order derivatives desired</p>
</td></tr>
<tr><td><code id="plotGCV_+3A_datamatrix">dataMatrix</code></td>
<td>
<p>Data of size total number of time points x  total number of subjects</p>
</td></tr>
<tr><td><code id="plotGCV_+3A_lowlambda">lowLambda</code></td>
<td>
<p>Lower limit of lambda values to be tested. Here, lambda is a 
positive smoothing parameter, with larger values resulting in greater smoothing)</p>
</td></tr>
<tr><td><code id="plotGCV_+3A_uplambda">upLambda</code></td>
<td>
<p>Upper limit of lambda</p>
</td></tr>
<tr><td><code id="plotGCV_+3A_lambdaint">lambdaInt</code></td>
<td>
<p>The interval of lambda values to be tested.</p>
</td></tr>
<tr><td><code id="plotGCV_+3A_isplot">isPlot</code></td>
<td>
<p>A binary flag on whether to plot the gcv values (0 = no, 1 = yes)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing:
1. lambda values; 2. edf (effective degrees of freedom); 
3. GCV (Generalized cross-validation value as averaged across units (e.g., subjects))
</p>


<h3>References</h3>

<p>Chow, S-M. (2019). Practical Tools and Guidelines for Exploring and Fitting Linear 
and Nonlinear Dynamical Systems Models. Multivariate Behavioral Research. https://www.nihms.nih.gov/pmc/articlerender.fcgi?artid=1520409
</p>
<p>Chow, S-M., *Bendezu, J. J., Cole, P. M., &amp; Ram, N. (2016). A Comparison of Two-
Stage Approaches for Fitting Nonlinear Ordinary Differential Equation (ODE) 
Models with Mixed Effects. Multivariate Behavioral Research, 51, 154-184. Doi: 10.1080/00273171.2015.1123138.
</p>

<hr>
<h2 id='PPsim'>Simulated time series data for multiple eco-systems based on a predator-and-prey model</h2><span id='topic+PPsim'></span>

<h3>Description</h3>

<p>A dataset simulated using a continuous-time nonlinear predator-and-prey model
with 2 observed indicators for identifying two latent factors. The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PPsim)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 6 variables</p>


<h3>Details</h3>


<ul>
<li><p> id. ID of the systems (1 to 20)
</p>
</li>
<li><p> time. Time index (50 time points for each system)
</p>
</li>
<li><p> prey. The true population of the prey species
</p>
</li>
<li><p> predator. The true population of the predator species
</p>
</li>
<li><p> x. Observed indicator for the population of the prey species
</p>
</li>
<li><p> y. Observed indicator for the population of the predator species
</p>
</li></ul>


<hr>
<h2 id='predict.dynrModel'><code>predict</code> method for <code>dynrModel</code> objects</h2><span id='topic+predict.dynrModel'></span>

<h3>Description</h3>

<p><code>predict</code> method for <code>dynrModel</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynrModel'
predict(object, newdata = NULL, interval = c("none",
  "confidence", "prediction"), method = c("kalman", "ensemble"),
  level = 0.95, type = c("latent", "observed"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.dynrModel_+3A_object">object</code></td>
<td>
<p>a dynrModel object from which predictions are desired</p>
</td></tr>
<tr><td><code id="predict.dynrModel_+3A_newdata">newdata</code></td>
<td>
<p>an optional <code>data.frame</code> or <code>ts</code> object. See details.</p>
</td></tr>
<tr><td><code id="predict.dynrModel_+3A_interval">interval</code></td>
<td>
<p>character indicating what kind of intervals are desired.  'none' gives no intervals, 'confidence', gives confidence intervals, 'prediction' gives prediction intervals.</p>
</td></tr>
<tr><td><code id="predict.dynrModel_+3A_method">method</code></td>
<td>
<p>character the method used to create the forecasts.  See details.</p>
</td></tr>
<tr><td><code id="predict.dynrModel_+3A_level">level</code></td>
<td>
<p>the confidence or predictions level, ignored if not using intervals</p>
</td></tr>
<tr><td><code id="predict.dynrModel_+3A_type">type</code></td>
<td>
<p>character the type of thing you want predicted: latent variables or manifest variables.</p>
</td></tr>
<tr><td><code id="predict.dynrModel_+3A_...">...</code></td>
<td>
<p>further named arguments, e.g., <code>size</code> for the ensemble size when using the ensemble prediction</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>newdata</code> argument is either a <code>data.frame</code> or <code>ts</code> object.  It passed as the <code>dataframe</code> argument of <code>dynr.data</code> and must accept the same further arguments as the data in the model passed in the <code>object</code> argument (e.g., same <code>id</code>, <code>time</code>, <code>observed</code>, and <code>covariates</code> arguments).
</p>
<p>The available methods for prediction are 'kalman' and 'ensemble'.  The 'kalman' method uses the Kalman filter to create predictions.  The 'ensemble' method simulates a set of initial conditions and lets those run forward in time.  The distribution of this ensemble provides the predictions.  The mean is the value predicted.  The quantiles of the distribution provide the intervals.
</p>


<h3>Value</h3>

<p>A list of the prediction estimates, intervals, and ensemble members.
</p>

<hr>
<h2 id='prep.formulaDynamics'>Recipe function for specifying dynamic functions using formulas</h2><span id='topic+prep.formulaDynamics'></span>

<h3>Description</h3>

<p>Recipe function for specifying dynamic functions using formulas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.formulaDynamics(formula, startval = numeric(0),
  isContinuousTime = FALSE, jacobian, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep.formulaDynamics_+3A_formula">formula</code></td>
<td>
<p>a list of formulas specifying the drift or state-transition 
equations for the latent variables in continuous or discrete time, respectively.</p>
</td></tr>
<tr><td><code id="prep.formulaDynamics_+3A_startval">startval</code></td>
<td>
<p>a named vector of starting values of the parameters in the 
formulas for estimation with parameter names as its name. If there are no free parameters in 
the dynamic functions, leave startval as the default <code>numeric(0)</code>.</p>
</td></tr>
<tr><td><code id="prep.formulaDynamics_+3A_iscontinuoustime">isContinuousTime</code></td>
<td>
<p>if True, the left hand side of the formulas represent 
the first-order derivatives of the specified variables; if False, the left hand 
side of the formulas represent the current state of the specified variable while 
the same variable on the righ hand side is its previous state.</p>
</td></tr>
<tr><td><code id="prep.formulaDynamics_+3A_jacobian">jacobian</code></td>
<td>
<p>(optional) a list of formulas specifying the analytic jacobian matrices 
containing the analytic differentiation function of the dynamic functions with respect to
the latent variables. If this is not provided, dynr will invoke an automatic differentiation
procedure to compute the jacobian functions.</p>
</td></tr>
<tr><td><code id="prep.formulaDynamics_+3A_...">...</code></td>
<td>
<p>further named arguments. Some of these arguments may include:
</p>
<p><code>theta.formula</code> specifies a list consisting of formula(s) of the form 
<code>list (par ~ 1 * b_0  + covariate_1 * b_1 + ... + covariate_p * b_p 
 + 1 * rand_par)</code>, where <code>par</code> is a parameter is a unit- (e.g., person-) 
specific that appears in a dynamic formula and is assumed to follow
a linear mixed effects structure. Here, <code>b_p</code> are fixed effects 
parameters; <code>covariate_1</code>, ..., <code>covariate_p</code> are known covariates as predeclared in
<code>dynr.data</code>, and <code>rand_par</code> is a random effect component representing unit i's random deviation
in <code>par</code> value from that predicted by <code>b_0 + covariate_1*b_1 + ... + covariate_p*b_p</code>. 
</p>
<p><code>random.names</code> specifies names of random effect components in the <code>theta.formula</code>
</p>
<p><code>random.params.inicov</code> specifies names of elements in the covariance matrix of the random effect components
</p>
<p><code>random.values.inicov</code> specifies starting values of elements in the covariance matrix of the random effect components</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function defines the dynamic functions of the model either in discrete time or in continuous time.
The function can be either linear or nonlinear, with free or fixed parameters, numerical constants, 
covariates, and other mathematical functions that define the dynamics of the latent variables.
Every latent variable in the model needs to be defined by a differential (for continuous time model), or
difference (for discrete time model) equation.  The names of the latent variables should match 
the specification in <code>prep.measurement()</code>.
For nonlinear models, the estimation algorithm generally needs a Jacobian matrix that contains
elements of first differentiations of the dynamic functions with respect to the latent variables
in the model. For most nonlinear models, such differentiations can be handled automatically by
dynr. However, in some cases, such as when the absolute function (<code>abs</code>) is used, the automatic
differentiation would fail and the user may need to provide his/her own Jacobian functions.
When <code>theta.formula</code> and other accompanying elements in &quot;<code>...</code>&quot; are provided, the program
automatically inserts the random effect components specified in random.names as additional
latent (state) variables in the model, and estimate (cook) this expanded model. Do check
that the expanded model satisfies conditions such as observability for the estimation to work.
</p>


<h3>Value</h3>

<p>Object of class 'dynrDynamicsFormula'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In this example, we present how to define the dynamics of a bivariate dual change score model
# (McArdle, 2009). This is a linear model and the user does not need to worry about 
# providing any jacobian function (the default). 
 
# We start by creating a list of formula that describes the model. In this model, we have four 
# latent variables, which are "readLevel", "readSlope", "mathLevel", and "math Slope".  The right-
# hand side of each formula gives a function that defines the dynamics.   
 
 formula &lt;- list(
          list(readLevel~ (1+beta.read)*readLevel + readSlope + gamma.read*mathLevel,
          readSlope~ readSlope,
          mathLevel~ (1+beta.math)*mathLevel + mathSlope + gamma.math*readLevel, 
          mathSlope~ mathSlope
          ))

# Then we use prep.formulaDynamics() to define the formula, starting value of the parameters in
# the model, and state the model is in discrete time by setting isContinuousTime=FALSE.
 
dynm  &lt;- prep.formulaDynamics(formula=formula,
                             startval=c(beta.read = -.5, beta.math = -.5, 
                                        gamma.read = .3, gamma.math = .03
                             ), isContinuousTime=FALSE)


# For a full demo example of regime switching nonlinear discrete time model, you
# may refer to a tutorial on 
# \url{https://quantdev.ssri.psu.edu/tutorials/dynr-rsnonlineardiscreteexample}

#Not run: 
#For a full demo example that uses user-supplied analytic jacobian functions see:
#demo(RSNonlinearDiscrete, package="dynr")
formula &lt;- list(
    list(
      x1 ~ a1*x1,
      x2 ~ a2*x2),
    list(
      x1 ~ a1*x1 + c12*(exp(abs(x2)))/(1+exp(abs(x2)))*x2,
      x2 ~ a2*x2 + c21*(exp(abs(x1)))/(1+exp(abs(x1)))*x1)
  )
jacob &lt;- list(
  list(x1~x1~a1,
      x2~x2~a2),
  list(x1~x1~a1,
      x1~x2~c12*(exp(abs(x2))/(exp(abs(x2))+1)+x2*sign(x2)*exp(abs(x2))/(1+exp(abs(x2))^2)),
      x2~x2~a2,
      x2~x1~c21*(exp(abs(x1))/(exp(abs(x1))+1)+x1*sign(x1)*exp(abs(x1))/(1+exp(abs(x1))^2))))
dynm &lt;- prep.formulaDynamics(formula=formula, startval=c( a1=.3, a2=.4, c12=-.5, c21=-.5),
                             isContinuousTime=FALSE, jacobian=jacob)

#For a full demo example that uses automatic jacobian functions (the default) see:
#demo(RSNonlinearODE , package="dynr")
formula=list(prey ~ a*prey - b*prey*predator, predator ~ -c*predator + d*prey*predator)
dynm &lt;- prep.formulaDynamics(formula=formula,
                          startval=c(a = 2.1, c = 0.8, b = 1.9, d = 1.1),
                          isContinuousTime=TRUE)

#For a full demo example that includes unit-specific random effects in theta.formula see:
#demo(OscWithRand, package="dynr")
formula &lt;- list(x ~ dx,
               dx ~ eta_i * x + zeta*dx)
theta.formula  = list (eta_i ~ 1 * eta0  + u1 * eta1 + u2 * eta2 + 1 * b_eta)
dynm &lt;- prep.formulaDynamics(formula=formula,
                           startval=c(eta0=-1, eta1=.1, eta2=-.1,zeta=-.02),
                           isContinuousTime=TRUE,
                           theta.formula=theta.formula,
                           random.names=c('b_eta'),
                           random.params.inicov=matrix(c('sigma2_b_eta'), ncol=1,byrow=TRUE),
                           random.values.inicov=matrix(c(0.1), ncol=1,byrow=TRUE))
</code></pre>

<hr>
<h2 id='prep.initial'>Recipe function for preparing the initial conditions for the model.</h2><span id='topic+prep.initial'></span>

<h3>Description</h3>

<p>Recipe function for preparing the initial conditions for the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.initial(values.inistate, params.inistate, values.inicov, params.inicov,
  values.regimep = 1, params.regimep = 0, covariates, deviation = FALSE,
  refRow)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep.initial_+3A_values.inistate">values.inistate</code></td>
<td>
<p>a vector or list of vectors of the starting or fixed values of the initial state vector in one or more regimes.  May also be a matrix or list of matrices.</p>
</td></tr>
<tr><td><code id="prep.initial_+3A_params.inistate">params.inistate</code></td>
<td>
<p>a vector or list of vectors of the parameter names that appear in the initial state vector in one or more regimes. If an element is 0 or &quot;fixed&quot;, the corresponding element is fixed at the value specified in the values vector; Otherwise, the corresponding element is to be estimated with the starting value specified in the values vector.  May also be a matrix or list of matrices.</p>
</td></tr>
<tr><td><code id="prep.initial_+3A_values.inicov">values.inicov</code></td>
<td>
<p>a positive definite matrix or a list of positive definite matrices of the starting or fixed values of the initial error covariance structure(s) in one or more regimes. If only one matrix is specified for a regime-switching dynamic model, the initial error covariance structure stays the same across regimes. To ensure the matrix is positive definite in estimation, we apply LDL transformation to the matrix. Values are hence automatically adjusted for this purpose.</p>
</td></tr>
<tr><td><code id="prep.initial_+3A_params.inicov">params.inicov</code></td>
<td>
<p>a matrix or list of matrices of the parameter names that appear in the initial error covariance(s) in one or more regimes. If an element is 0 or &quot;fixed&quot;, the corresponding element is fixed at the value specified in the values matrix; Otherwise, the corresponding element is to be estimated with the starting value specified in the values matrix. If only one matrix is specified for a regime-switching dynamic model, the process noise structure stays the same across regimes. If a list is specified, any two sets of the parameter names as in two matrices should be either the same or totally different to ensure proper parameter estimation.</p>
</td></tr>
<tr><td><code id="prep.initial_+3A_values.regimep">values.regimep</code></td>
<td>
<p>a vector/matrix of the starting or fixed values of the initial probabilities of being in each regime. By default, the initial probability of being in the first regime is fixed at 1.</p>
</td></tr>
<tr><td><code id="prep.initial_+3A_params.regimep">params.regimep</code></td>
<td>
<p>a vector/matrix of the parameter indices of the initial probabilities of 
being in each regime. If an element is 0 or &quot;fixed&quot;, the corresponding element is fixed at the value 
specified in the &quot;values&quot; vector/matrix; Otherwise, the corresponding element is to be estimated 
with the starting value specified in the values vector/matrix.</p>
</td></tr>
<tr><td><code id="prep.initial_+3A_covariates">covariates</code></td>
<td>
<p>character vector of the names of the (person-level) covariates</p>
</td></tr>
<tr><td><code id="prep.initial_+3A_deviation">deviation</code></td>
<td>
<p>logical. Whether to use the deviation form or not.  See Details.</p>
</td></tr>
<tr><td><code id="prep.initial_+3A_refrow">refRow</code></td>
<td>
<p>numeric. Which row is treated at the reference.  See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial condition model includes specifications for the intial state vector, 
initial error covariance matrix, initial probabilities of 
being in each regime and all associated parameter specifications.
The initial probabilities are specified in multinomial logistic regression form.  When there are no covariates, this implies multinomial logistic regression with intercepts only.  In particular, the initial probabilities not not specified on a 0 to 1 probability scale, but rather a negative infinity to positive infinity log odds scale.  Fixing an initial regime probability to zero does not mean zero probability.  It translates to a comparison log odds scale against which other regimes will be judged.
</p>
<p>The structure of the initial state vector and the initial probability vector depends on the presence of covariates.  When there are no covariates these should be vectors, or equivalently single-column matrices.  When there are covariates they should have <code class="reqn">c+1</code> columns for <code class="reqn">c</code> covariates.  For <code>values.regimep</code> and <code>params.regimep</code> the number of rows should be the number of regimes.  For <code>inistate</code> and <code>inicov</code> the number of rows should be the number of latent states.  Of course, <code>inicov</code> is a square and symmetric so its number of rows should be the same as its number of columns.
</p>
<p>When <code>deviation=FALSE</code>, the non-deviation form of the multinomial logistic regression is used. This form has a separate intercept term for each entry of the initial probability vector. When <code>deviation=TRUE</code>, the deviation form of the multinomial logistic regression is used. This form has an intercept term that is common to all rows of the initial probability vector. The rows are then distinguished by their own individual deviations from the common intercept. The deviation form requires the same reference row constraint as the non-deviation form (described below). By default the reference row is taken to be the row with all zero covariate effects.  Of course, if there are no covariates and the deviation form is desired, then the user must provide the reference row.
</p>
<p>The <code>refRow</code> argument determines which row is used as the intercept row. It is only
used in the deviation form (i.e. <code>deviation=TRUE</code>). In the deviation form, one row of <code>values.regimep</code> and <code>params.regimep</code> contains the intercepts, other rows contain deviations from these intercepts. The <code>refRow</code> argument says which row contains the intercept terms. The default behavior for <code>refRow</code> is to detect the reference row automatically based on which parameters are <code>fixed</code>.  If we have problems detecting which is the reference row, then we provide error messages that are as helpful as we can make them.
</p>


<h3>Value</h3>

<p>Object of class 'dynrInitial'
</p>


<h3>See Also</h3>

<p>Methods that can be used include: <code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+printex">printex</a></code>, <code><a href="methods.html#topic+show">show</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### No-covariates
# Single regime, no covariates
# latent states are position and velocity
# initial position is free and called 'inipos'
# initial slope is fixed at 1
# initial covariance is fixed to a diagonal matrix of 1s
initialNoC &lt;- prep.initial(
	values.inistate=c(0, 1),
	params.inistate=c('inipos', 'fixed'),
	values.inicov=diag(1, 2),
	params.inicov=diag('fixed', 2))

#### One covariate
# Single regime, one covariate on the inital mean
# latent states are position and velocity
# initial covariance is fixed to a diagonal matrix of 1s
# initial latent means have
#   nrow = numLatentState, ncol = numCovariates + 1
# initial position has free intercept and free u1 effect
# initial slope is fixed at 1
initialOneC &lt;- prep.initial(
	values.inistate=matrix(
		c(0, .5,
		  1,  0), byrow=TRUE,
		nrow=2, ncol=2),
	params.inistate=matrix(
		c('iniPosInt', 'iniPosSlopeU1',
		'fixed', 'fixed'), byrow=TRUE,
		nrow=2, ncol=2),
	values.inicov=diag(1, 2),
	params.inicov=diag('fixed', 2),
	covariates='u1')

#### Regime-switching, one covariate
# latent states are position and velocity
# initial covariance is fixed to a diagonal matrix of 1s
# initial latent means have
#   nrow = numLatentState, ncol = numCovariates + 1
# initial position has free intercept and free u1 effect
# initial slope is fixed at 1
# There are 3 regimes but the mean and covariance
#   are not regime-switching.
initialRSOneC &lt;- prep.initial(
	values.regimep=matrix(
		c(1, 1,
		  0, 1,
		  0, 0), byrow=TRUE,
		nrow=3, ncol=2),
	params.regimep=matrix(
		c('r1int', 'r1slopeU1',
		  'r2int', 'r2slopeU2',
		  'fixed', 'fixed'), byrow=TRUE,
		nrow=3, ncol=2),
	values.inistate=matrix(
		c(0, .5,
		  1,  0), byrow=TRUE,
		nrow=2, ncol=2),
	params.inistate=matrix(
		c('iniPosInt', 'iniPosSlopeU1',
		'fixed', 'fixed'), byrow=TRUE,
		nrow=2, ncol=2),
	values.inicov=diag(1, 2),
	params.inicov=diag('fixed', 2),
	covariates='u1')

</code></pre>

<hr>
<h2 id='prep.loadings'>Recipe function to quickly create factor loadings</h2><span id='topic+prep.loadings'></span>

<h3>Description</h3>

<p>Recipe function to quickly create factor loadings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.loadings(map, params = NULL, idvar, exo.names = character(0),
  intercept = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep.loadings_+3A_map">map</code></td>
<td>
<p>list giving how the latent variables map onto the observed variables</p>
</td></tr>
<tr><td><code id="prep.loadings_+3A_params">params</code></td>
<td>
<p>parameter numbers</p>
</td></tr>
<tr><td><code id="prep.loadings_+3A_idvar">idvar</code></td>
<td>
<p>names of the variables used to identify the factors</p>
</td></tr>
<tr><td><code id="prep.loadings_+3A_exo.names">exo.names</code></td>
<td>
<p>names of the exogenous covariates</p>
</td></tr>
<tr><td><code id="prep.loadings_+3A_intercept">intercept</code></td>
<td>
<p>logical. Whether to include freely esimated intercepts</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default pattern for 'idvar' is to fix the first factor loading 
for each factor to one.  The variable names listed in 'idvar' have 
their factor loadings fixed to one.  However, if the names of the 
latent variables are used for 'idvar', then all the factor loadings
will be freely estimated and you should fix the factor variances 
in the noise part of the model (e.g. <code><a href="#topic+prep.noise">prep.noise</a></code>).
</p>
<p>This function does not have the full set of features possible in 
the dynr package. In particular, it does not have any regime-swtiching.
Covariates can be included with the <code>exo.names</code> argument, but
all covariate effects are freely estimated and the starting values
are all zero.  Likewise, intercepts can be included with the <code>intercept</code>
logical argument, but all intercept terms are freely estimated with 
zero as the starting value.
For complete functionality use <code><a href="#topic+prep.measurement">prep.measurement</a></code>.
</p>


<h3>Value</h3>

<p>Object of class 'dynrMeasurement'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Single factor model with one latent variable fixing first loading
prep.loadings(list(eta1=paste0('y', 1:4)), paste0("lambda_", 2:4))

#Single factor model with one latent variable fixing the fourth loading
prep.loadings(list(eta1=paste0('y', 1:4)), paste0("lambda_", 1:3), idvar='y4')

#Single factor model with one latent variable freeing all loadings
prep.loadings(list(eta1=paste0('y', 1:4)), paste0("lambda_", 1:4), idvar='eta1')

#Single factor model with one latent variable fixing first loading
# and freely estimated intercept
prep.loadings(list(eta1=paste0('y', 1:4)), paste0("lambda_", 2:4),
 intercept=TRUE)

#Single factor model with one latent variable fixing first loading
# and freely estimated covariate effects for u1 and u2
prep.loadings(list(eta1=paste0('y', 1:4)), paste0("lambda_", 2:4),
 exo.names=paste0('u', 1:2))

# Two factor model with simple structure
prep.loadings(list(eta1=paste0('y', 1:4), eta2=paste0('y', 5:7)), 
paste0("lambda_", c(2:4, 6:7)))

#Two factor model with repeated use of a free parameter
prep.loadings(list(eta1=paste0('y', 1:4), eta2=paste0('y', 5:8)), 
paste0("lambda_", c(2:4, 6:7, 4)))

#Two factor model with a cross loading
prep.loadings(list(eta1=paste0('y', 1:4), eta2=c('y5', 'y2', 'y6')), 
paste0("lambda_", c("21", "31", "41", "22", "62")))
</code></pre>

<hr>
<h2 id='prep.matrixDynamics'>Recipe function for creating Linear Dynamics using matrices</h2><span id='topic+prep.matrixDynamics'></span>

<h3>Description</h3>

<p>Recipe function for creating Linear Dynamics using matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.matrixDynamics(params.dyn = NULL, values.dyn, params.exo = NULL,
  values.exo = NULL, params.int = NULL, values.int = NULL, covariates,
  isContinuousTime)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep.matrixDynamics_+3A_params.dyn">params.dyn</code></td>
<td>
<p>the matrix of parameter names for the transition matrix in the 
specified linear dynamic model</p>
</td></tr>
<tr><td><code id="prep.matrixDynamics_+3A_values.dyn">values.dyn</code></td>
<td>
<p>the matrix of starting/fixed values for the transition matrix in the 
specified linear dynamic model</p>
</td></tr>
<tr><td><code id="prep.matrixDynamics_+3A_params.exo">params.exo</code></td>
<td>
<p>the matrix of parameter names for the regression slopes of covariates on the latent variables (see details)</p>
</td></tr>
<tr><td><code id="prep.matrixDynamics_+3A_values.exo">values.exo</code></td>
<td>
<p>matrix of starting/fixed values for the regression slopes of covariates on the latent variables (see details)</p>
</td></tr>
<tr><td><code id="prep.matrixDynamics_+3A_params.int">params.int</code></td>
<td>
<p>vector of names for intercept parameters in the dynamic model specified as a matrix or list of matrices.</p>
</td></tr>
<tr><td><code id="prep.matrixDynamics_+3A_values.int">values.int</code></td>
<td>
<p>vector of intercept values in the dynamic model specified as matrix or list of matrices. Contains starting/fixed values of the intercepts.</p>
</td></tr>
<tr><td><code id="prep.matrixDynamics_+3A_covariates">covariates</code></td>
<td>
<p>the names or the index numbers of the covariates used in the dynamic model</p>
</td></tr>
<tr><td><code id="prep.matrixDynamics_+3A_iscontinuoustime">isContinuousTime</code></td>
<td>
<p>logical. When TRUE, use a continuous time model.  When FALSE use a discrete time model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A recipe function for specifying the deterministic portion of a set of linear dynamic functions as:
</p>
<p>Discrete-time model: eta(t+1) = int + dyn*eta(t) + exo*x(t), 
where eta(t) is a vector of latent variables, x(t) is a vector of covariates,
int, dyn, and exo are vectors and matrices specified via the arguments *.int, *.dyn, and *.exo. 
</p>
<p>Continuous-time model: d/dt eta(t) = int + dyn*eta(t) + exo*x(t), 
where eta(t) is a vector of latent variables, x(t) is a vector of covariates,
int, dyn, and exo are vectors and matrices specified via the arguments *.int, *.dyn, and *.exo.
</p>
<p>The left-hand side of the dynamic model consists of a vector of latent variables for the next time point in the discrete-time case,
and the vector of derivatives for the latent variables at the current time point in the continuous-time case.
</p>
<p>For models with regime-switching dynamic functions, the user will need to provide a list of the *.int, *.dyn, and *.exo arguments. 
(when they are specified to take on values other than the default of zero vectors and matrices), or if a single set of vectors/matrices are provided, the same 
vectors/matrices are assumed to hold across regimes.
</p>
<p><code>prep.matrixDynamics</code> serves as an alternative to <code><a href="#topic+prep.formulaDynamics">prep.formulaDynamics</a></code>.
</p>


<h3>Value</h3>

<p>Object of class 'dynrDynamicsMatrix'
</p>


<h3>See Also</h3>

<p>Methods that can be used include: <code><a href="base.html#topic+print">print</a></code>, <code><a href="methods.html#topic+show">show</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Single-regime, continuous-time model. For further details run: 
#demo(RSNonlinearDiscrete, package="dynr"))
dynamics &lt;- prep.matrixDynamics(
    values.dyn=matrix(c(0, -0.1, 1, -0.2), 2, 2),
    params.dyn=matrix(c('fixed', 'spring', 'fixed', 'friction'), 2, 2),
    isContinuousTime=TRUE)

#Two-regime, continuous-time model. For further details run: 
#demo(RSNonlinearDiscrete, package="dynr"))
dynamics &lt;- prep.matrixDynamics(
    values.dyn=list(matrix(c(0, -0.1, 1, -0.2), 2, 2),
                    matrix(c(0, -0.1, 1, 0), 2, 2)),
    params.dyn=list(matrix(c('fixed', 'spring', 'fixed', 'friction'), 2, 2),
                    matrix(c('fixed', 'spring', 'fixed', 'fixed'), 2, 2)),
    isContinuousTime=TRUE) 
</code></pre>

<hr>
<h2 id='prep.measurement'>Prepare the measurement recipe</h2><span id='topic+prep.measurement'></span>

<h3>Description</h3>

<p>Prepare the measurement recipe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.measurement(values.load, params.load = NULL, values.exo = NULL,
  params.exo = NULL, values.int = NULL, params.int = NULL, obs.names,
  state.names, exo.names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep.measurement_+3A_values.load">values.load</code></td>
<td>
<p>matrix of starting or fixed values for factor loadings. 
For models with regime-specific factor loadings provide a list of matrices of factor loadings.</p>
</td></tr>
<tr><td><code id="prep.measurement_+3A_params.load">params.load</code></td>
<td>
<p>matrix or list of matrices. Contains parameter names of the factor loadings.</p>
</td></tr>
<tr><td><code id="prep.measurement_+3A_values.exo">values.exo</code></td>
<td>
<p>matrix or list of matrices. Contains starting/fixed values of the covariate regression slopes.</p>
</td></tr>
<tr><td><code id="prep.measurement_+3A_params.exo">params.exo</code></td>
<td>
<p>matrix or list of matrices. Parameter names of the covariate regression slopes.</p>
</td></tr>
<tr><td><code id="prep.measurement_+3A_values.int">values.int</code></td>
<td>
<p>vector of intercept values specified as matrix or list of matrices. Contains starting/fixed values of the intercepts.</p>
</td></tr>
<tr><td><code id="prep.measurement_+3A_params.int">params.int</code></td>
<td>
<p>vector of names for intercept parameters specified as a matrix or list of matrices.</p>
</td></tr>
<tr><td><code id="prep.measurement_+3A_obs.names">obs.names</code></td>
<td>
<p>vector of names for the observed variables in the order they appear in the measurement model.</p>
</td></tr>
<tr><td><code id="prep.measurement_+3A_state.names">state.names</code></td>
<td>
<p>vector of names for the latent variables in the order they appear in the measurement model.</p>
</td></tr>
<tr><td><code id="prep.measurement_+3A_exo.names">exo.names</code></td>
<td>
<p>(optional) vector of names for the exogenous variables in the order they appear in the measurement model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values.* arguments give the starting and fixed values for their respective matrices.
The params.* arguments give the free parameter labels for their respective matrices.
Numbers can be used as labels.
The number 0 and the character 'fixed' are reserved for fixed parameters.
</p>
<p>When a single matrix is given to values.*, that matrix is not regime-switching.
Correspondingly, when a list of length r is given, that matrix is regime-switching with values and params for the r regimes in the elements of the list.
</p>


<h3>Value</h3>

<p>Object of class 'dynrMeasurement'
</p>


<h3>See Also</h3>

<p>Methods that can be used include: <code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+printex">printex</a></code>, <code><a href="methods.html#topic+show">show</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prep.measurement(diag(1, 5), diag("lambda", 5))
prep.measurement(matrix(1, 5, 5), diag(paste0("lambda_", 1:5)))
prep.measurement(diag(1, 5), diag(0, 5)) #identity measurement model

#Regime-switching measurement model where the first latent variable is
# active for regime 1, and the second latent variable is active for regime 2
# No free parameters are present.
prep.measurement(values.load=list(matrix(c(1,0), 1, 2), matrix(c(0, 1), 1, 2)))
</code></pre>

<hr>
<h2 id='prep.noise'>Recipe function for specifying the measurement error and process noise covariance structures</h2><span id='topic+prep.noise'></span>

<h3>Description</h3>

<p>Recipe function for specifying the measurement error and process noise covariance structures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.noise(values.latent, params.latent, values.observed, params.observed, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep.noise_+3A_values.latent">values.latent</code></td>
<td>
<p>a positive definite matrix or a list of positive definite matrices of the starting or fixed values of the process noise covariance structure(s) in one or more regimes. If only one matrix is specified for a regime-switching dynamic model, the process noise covariance structure stays the same across regimes. To ensure the matrix is positive definite in estimation, we apply LDL transformation to the matrix. Values are hence automatically adjusted for this purpose.</p>
</td></tr>
<tr><td><code id="prep.noise_+3A_params.latent">params.latent</code></td>
<td>
<p>a matrix or list of matrices of the parameter names that appear in the process noise covariance(s) in one or more regimes. If an element is 0 or &quot;fixed&quot;, the corresponding element is fixed at the value specified in the values matrix; Otherwise, the corresponding element is to be estimated with the starting value specified in the values matrix. If only one matrix is specified for a regime-switching dynamic model, the process noise structure stays the same across regimes. If a list is specified, any two sets of the parameter names as in two matrices should be either the same or totally different to ensure proper parameter estimation.  See Details.</p>
</td></tr>
<tr><td><code id="prep.noise_+3A_values.observed">values.observed</code></td>
<td>
<p>a positive definite matrix or a list of positive definite matrices of the starting or fixed values of the measurement error covariance structure(s) in one or more regimes. If only one matrix is specified for a regime-switching measurement model, the measurement noise covariance structure stays the same across regimes. To ensure the matrix is positive definite in estimation, we apply LDL transformation to the matrix. Values are hence automatically adjusted for this purpose.</p>
</td></tr>
<tr><td><code id="prep.noise_+3A_params.observed">params.observed</code></td>
<td>
<p>a matrix or list of matrices of the parameter names that appear in the measurement error covariance(s) in one or more regimes. If an element is 0 or &quot;fixed&quot;, the corresponding element is fixed at the value specified in the values matrix; Otherwise, the corresponding element is to be estimated with the starting value specified in the values matrix. If only one matrix is specified for a regime-switching dynamic model, the process noise structure stays the same across regimes. If a list is specified, any two sets of the parameter names as in two matrices should be either the same or totally different to ensure proper parameter estimation.  See Details.</p>
</td></tr>
<tr><td><code id="prep.noise_+3A_...">...</code></td>
<td>
<p>Further named arguments.  Currently we only accept 'covariates' and 'var.formula'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments of this function should generally be either matrices or lists of matrices.  Lists of matrices are used for regime-switching models with each list element corresponding to a regime.  Thus, a list of three matrices implies a three-regime model.  Single matrices are for non-regime-switching models.  Some checking is done to ensure that the number of regimes implied by one part of the model matches that implied by the others.  For example, the noise model (<code>prep.noise</code>) cannot suggest three regimes when the measurement model (<code><a href="#topic+prep.measurement">prep.measurement</a></code>) suggests two regimes. An exception to this rule is single-regime (i.e. non-regime-switching) components.  For instance, the noise model can have three regimes even though the measurement model implies one regime.  The single-regime components are simply assumed to be invariant across regimes.
</p>
<p>Care should be taken that the parameters names for the latent covariances do not overlap with the parameters in the observed covariances.  Likewise, the parameter names for the latent covariances in each regime should either be identical or completely distinct. Because the LDL' transformation is applied to the covariances, sharing a parameter across regimes may cause problems with the parameter estimation.
</p>
<p>Use $ to show specific arguments from a dynrNoise object (see examples).
</p>


<h3>Value</h3>

<p>Object of class 'dynrNoise'
</p>


<h3>See Also</h3>

<p><code><a href="#topic+printex">printex</a></code> to show the covariance matrices in latex.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two latent variables and one observed variable in a one-regime model
Noise &lt;- prep.noise(values.latent=diag(c(0.8, 1)),
    params.latent=diag(c('fixed', "e_x")), 
    values.observed=diag(1.5,1), params.observed=diag("e_y", 1))
# For matrices that can be import to latex:
printex(Noise, show=TRUE)
# If you want to check specific arguments you've specified, for example,
# values for variance structure of the latent variables
Noise$values.latent

# Two latent variables and one observed variable in a two-regime model
Noise &lt;- prep.noise(values.latent=list(diag(c(0.8, 1)), diag(c(0.8, 1))),
    params.latent=list(diag(c('fixed', "e_x1")), diag(c('fixed', "e_x2"))),
    values.observed=list(diag(1.5,1), diag(0.5,1)),
    params.observed=list(diag("e_y1", 1), diag("e_y2",1)))
# If the error and noise structures are assumed to be the same across regimes,
#  it is okay to use matrices instead of lists.
</code></pre>

<hr>
<h2 id='prep.regimes'>Recipe function for creating regime switching (Markov transition) functions</h2><span id='topic+prep.regimes'></span>

<h3>Description</h3>

<p>Recipe function for creating regime switching (Markov transition) functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.regimes(values, params, covariates, deviation = FALSE, refRow)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep.regimes_+3A_values">values</code></td>
<td>
<p>matrix giving the values. Should have (number of Regimes) rows 
and (number of regimes x number of covariates) columns</p>
</td></tr>
<tr><td><code id="prep.regimes_+3A_params">params</code></td>
<td>
<p>matrix of the same size as &quot;values&quot; consisting of the names of the parameters</p>
</td></tr>
<tr><td><code id="prep.regimes_+3A_covariates">covariates</code></td>
<td>
<p>a vector of the names of the covariates to be used in the regime-switching functions</p>
</td></tr>
<tr><td><code id="prep.regimes_+3A_deviation">deviation</code></td>
<td>
<p>logical. Whether to use the deviation form or not.  See Details.</p>
</td></tr>
<tr><td><code id="prep.regimes_+3A_refrow">refRow</code></td>
<td>
<p>numeric. Which row is treated at the reference.  See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that each row of the transition probability matrix must sum to one. To accomplish this
fix at least one transition log odds parameter in each row of &quot;values&quot; (including its intercept 
and the regression slopes of all covariates) to 0.
</p>
<p>When <code>deviation=FALSE</code>, the non-deviation form of the multinomial logistic regression is used. This form has a separate intercept term for each entry of the transition probability matrix (TPM). When <code>deviation=TRUE</code>, the deviation form of the multinomial logistic regression is used. This form has an intercept term that is common to each column of the TPM. The rows are then distinguished by their own individual deviations from the common intercept. The deviation form requires the same reference column constraint as the non-deviation form; however, the deviation form also requires one row to be indicated as the reference row (described below). By default the reference row is taken to be the same as the reference column.
</p>
<p>The <code>refRow</code> argument determines which row is used as the intercept row. It is only
used in the deviation form (i.e. <code>deviation=TRUE</code>). In the deviation form, one row of <code>values</code> and <code>params</code> contains the intercepts, other rows contain deviations from these intercepts. The <code>refRow</code> argument says which row contains the intercept terms. The default behavior for <code>refRow</code> is to be the same as the reference column.  The reference column is automatically detected. If we have problems detecting which is the reference column, then we provide error messages that are as helpful as we can make them.
</p>


<h3>Value</h3>

<p>Object of class 'dynrRegimes'
</p>


<h3>See Also</h3>

<p>Methods that can be used include: <code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+printex">printex</a></code>, <code><a href="methods.html#topic+show">show</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Two-regime example with a covariate, x; log odds (LO) parameters represented in default form,
#2nd regime set to be the reference regime (i.e., have LO parameters all set to 0).
#The values and params matrices are of size 2 (numRegimes=2) x 4 (numRegimes*(numCovariates+1)).
#    The LO of staying within the 1st regime (corresponding to the (1,1) entry in the
#              2 x 2 transition probability matrix for the 2 regimes) = a_11 + d_11*x
#    The log odds of switching from the 1st to the 2nd regime (the (1,2) entry in the
#              transition probability matrix) = 0
#    The log odds of moving from regime 2 to regime 1 (the (2,1) entry) = a_21 + d_21*x
#    The log odds of staying within the 2nd regime (the (2,2) entry) = 0
b &lt;- prep.regimes(
values=matrix(c(8,-1,rep(0,2),
               -4,.1,rep(0,2)),
             nrow=2, ncol=4, byrow=TRUE), 
params=matrix(c("a_11","d_11x",rep("fixed",2),
               "a_21","d_21x",rep("fixed",2)), 
             nrow=2, ncol=4, byrow=TRUE), covariates=c("x"))
 
# Same example as above, but expressed in deviation form by specifying 'deviation = TRUE'
#    The LO of staying within the 1st regime (corresponding to the (1,1) entry in the
#              2 x 2 transition probability matrix for the 2 regimes) = a_21 + a_11 + d_11*x
#    The log odds of switching from the 1st to the 2nd regime (the (1,2) entry in the
#              transition probability matrix) = 0
#    The log odds of moving from regime 2 to regime 1 (the (2,1) entry) = a_21 + d_21*x
#    The log odds of staying within the 2nd regime (the (2,2) entry) = 0            
b &lt;- prep.regimes(
values=matrix(c(8,-1,rep(0,2),
               -4,.1,rep(0,2)),
             nrow=2, ncol=4, byrow=TRUE), 
params=matrix(c("a_11","d_11x",rep("fixed",2),
               "a_21","d_21x",rep("fixed",2)), 
             nrow=2, ncol=4, byrow=TRUE), covariates=c("x"), deviation = TRUE)
             
#An example of regime-switching with no covariates. The diagonal entries are fixed
#at zero for identification purposes
b &lt;- prep.regimes(values=matrix(0, 3, 3), 
params=matrix(c('fixed', 'p12', 'p13', 
                'p21', 'fixed', 'p23', 
                'p31', 'p32', 'fixed'), 3, 3, byrow=TRUE))

#An example of regime-switching with no covariates. The parameters for the second regime are 
#  fixed at zero for identification purposes, making the second regime the reference regime.
b &lt;- prep.regimes(values=matrix(0, 3, 3), 
params=matrix(c('p11', 'fixed', 'p13',
                'p21', 'fixed', 'p23', 
                'p31', 'fixed', 'p33'), 3, 3, byrow=TRUE))

#2 regimes with three covariates
b &lt;- prep.regimes(values=matrix(c(0), 2, 8), 
params=matrix(c(paste0('p', 8:15), rep(0, 8)), 2, 8), 
covariates=c('x1', 'x2', 'x3'))

</code></pre>

<hr>
<h2 id='prep.tfun'>Create a dynrTrans object to handle the transformations and inverse 
transformations of model paramters</h2><span id='topic+prep.tfun'></span>

<h3>Description</h3>

<p>Create a dynrTrans object to handle the transformations and inverse 
transformations of model paramters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.tfun(formula.trans, formula.inv, transCcode = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep.tfun_+3A_formula.trans">formula.trans</code></td>
<td>
<p>a list of formulae for transforming freed parameters 
other than variance-covariance parameters during the optimization process. 
These transformation functions may be helpful for transforming parameters 
that would normally appear on a constrained scale to an unconstrained 
scale (e.g., parameters that can only take on positive values can be 
subjected to exponential transformation to ensure positivity.)</p>
</td></tr>
<tr><td><code id="prep.tfun_+3A_formula.inv">formula.inv</code></td>
<td>
<p>a list of formulae that inverse the transformation 
on the free parameters and will be used to calculate the starting values 
of the parameters.</p>
</td></tr>
<tr><td><code id="prep.tfun_+3A_transccode">transCcode</code></td>
<td>
<p>a logical value indicating whether the functions in 
formula.trans need to be transformed to functions in C. The default 
for transCcode is TRUE, which means that the formulae will be translated 
to C functions and utilized during the optimization process. 
If transCcode = FALSE, the transformations are only performed at the end 
of the optimization process for standard error calculations but not 
during the optimization process.
##'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prepares a dynr recipe that specifies the names of the parameters that are 
to be subjected to user-supplied transformation functions and the 
corresponding transformation and reverse-transformation functions. 
This can be very handy in fitting dynamic models in which certain parameters can 
only take on permissible values in particular ranges (e.g., a parameter may 
have to positive). Note that all variance-covariance parameters in the model
are automatically subjected to transformation functions to ensure that
the resultant covariance matrices are positive-definite. Thus, no additional
transformation functions are needed for variance-covariance parameters.
</p>


<h3>Value</h3>

<p>Object of class 'dynrTrans'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Specifies a transformation recipe, r20, that subjects the parameters
#'r10' and 'r20' to exponential transformation to ensure that they are positive.
trans &lt;-prep.tfun(formula.trans=list(r10~exp(r10), r20~exp(r20)),
                  formula.inv=list(r10~log(r10),r20~log(r20)))

</code></pre>

<hr>
<h2 id='printex'>The printex Method</h2><span id='topic+printex'></span><span id='topic+printex+2CdynrCook-method'></span><span id='topic+printex+2CdynrDynamicsFormula-method'></span><span id='topic+printex+2CdynrDynamicsMatrix-method'></span><span id='topic+printex+2CdynrInitial-method'></span><span id='topic+printex+2CdynrMeasurement-method'></span><span id='topic+printex+2CdynrModel-method'></span><span id='topic+printex+2CdynrNoise-method'></span><span id='topic+printex+2CdynrRegimes-method'></span>

<h3>Description</h3>

<p>The printex Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printex(object, ParameterAs, printDyn = TRUE, printMeas = TRUE,
  printInit = FALSE, printRS = FALSE, outFile, show, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printex_+3A_object">object</code></td>
<td>
<p>The dynr object (recipe, model, or cooked model).</p>
</td></tr>
<tr><td><code id="printex_+3A_parameteras">ParameterAs</code></td>
<td>
<p>The parameter values or names to plot. The underscores in parameter names are 
saved for use of subscripts.  Greek letters can be specified as corresponding LaTeX symbols without ##' backslashes (e.g., &quot;lambda&quot;) and printed as greek letters.</p>
</td></tr>
<tr><td><code id="printex_+3A_printdyn">printDyn</code></td>
<td>
<p>logical. Whether or not to print the dynamic model. The default is TRUE.</p>
</td></tr>
<tr><td><code id="printex_+3A_printmeas">printMeas</code></td>
<td>
<p>logical. Whether or not to print the measurement model. The default is TRUE.</p>
</td></tr>
<tr><td><code id="printex_+3A_printinit">printInit</code></td>
<td>
<p>logical. Whether or not to print the initial conditions. The default is FALSE.</p>
</td></tr>
<tr><td><code id="printex_+3A_printrs">printRS</code></td>
<td>
<p>logical. Whether or not to print the regime-switching model. The default is FALSE.</p>
</td></tr>
<tr><td><code id="printex_+3A_outfile">outFile</code></td>
<td>
<p>The name of the output tex file.</p>
</td></tr>
<tr><td><code id="printex_+3A_show">show</code></td>
<td>
<p>logical indicator of whether or not to show the result in the console.</p>
</td></tr>
<tr><td><code id="printex_+3A_...">...</code></td>
<td>
<p>Further named arguments, passed to internal method. 
<code>AsMatrix</code> is a logical indicator of whether to put the object in matrix form.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a general way of getting a LaTeX string for recipes, 
models, and cooked models.  It is a great way to check that 
you specified the model or recipe you think you did before 
estimating its free parameters (cooking).  After the model 
is cooked, you can use it to get LaTeX code with the estimated 
parameters in it.
</p>
<p>Typical inputs to the <code>ParameterAs</code> argument are (1) the starting values for a model, (2) the final estimated values for a model, and (3) the parameter names.  These are accessible with (1) <code>model$xstart</code>, (2) <code>coef(cook)</code>, and (3) <code>model$param.names</code> or <code>names(coef(cook))</code>, respectively.
</p>


<h3>Value</h3>

<p>character text suitable for use fiel LaTeX
</p>


<h3>See Also</h3>

<p>A way to put this in a plot with <code><a href="#topic+plotFormula">plotFormula</a></code>
</p>

<hr>
<h2 id='RSPPsim'>Simulated time series data for multiple eco-systems based on a regime-switching predator-and-prey model</h2><span id='topic+RSPPsim'></span>

<h3>Description</h3>

<p>A dataset simulated using a regime-switching continuous-time nonlinear predator-and-prey model
with 2 observed indicators for identifying two latent factors. The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(RSPPsim)
</code></pre>


<h3>Format</h3>

<p>A data frame with 6000 rows and 8 variables</p>


<h3>Details</h3>


<ul>
<li><p> id. ID of the systems (1 to 20)
</p>
</li>
<li><p> time. Time index (300 time points for each system)
</p>
</li>
<li><p> prey. The true population of the prey species
</p>
</li>
<li><p> predator. The true population of the predator species
</p>
</li>
<li><p> x. Observed indicator for the population of the prey species
</p>
</li>
<li><p> y. Observed indicator for the population of the predator species
</p>
</li>
<li><p> cond. A time-varying covariate indicating the conditions of the respective eco-system across time which 
affects the regime-switching transition matrix
</p>
</li>
<li><p> regime. The true regime indicators across time (1 and 2).
</p>
</li></ul>


<hr>
<h2 id='summary.dynrCook'>Get the summary of a dynrCook object</h2><span id='topic+summary.dynrCook'></span>

<h3>Description</h3>

<p>Get the summary of a dynrCook object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynrCook'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.dynrCook_+3A_object">object</code></td>
<td>
<p>The dynrCook object for which the summary is desired.</p>
</td></tr>
<tr><td><code id="summary.dynrCook_+3A_...">...</code></td>
<td>
<p>Further named arguments, passed to the print method (e.g., <code>digits</code> and <code>signif.stars</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary gives information on the free parameters estimated: names, parameter values, numerical Hessian-based standard errors, t-values (values divided by standard errors), and standard-error based confidence intervals.  Additionally, the likelihood, AIC, and BIC are provided.
</p>
<p>Note that an exclamation point (!) in the final column of the summary table indicates that
the standard error and confidence interval for this parameter may not be trustworthy. The corresponding
element of the (transformed, inverse) Hessian was negative and an absolute value was taken to make it positive.
</p>


<h3>Value</h3>

<p>Object of class summary.dynrCook.  Primarily used for showing the results of a fitted model.
</p>

<hr>
<h2 id='theta_plot'>A function to plot simple slopes and region of significance.</h2><span id='topic+theta_plot'></span>

<h3>Description</h3>

<p>A function to plot simple slopes and region of significance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta_plot(.lm, predictor, moderator, alpha = 0.05, jn = F, title0,
  predictorLab, moderatorLab)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theta_plot_+3A_.lm">.lm</code></td>
<td>
<p>A regression object from running a linear model of the form: 
lm(y~ x1+x2+x1:x2), yielding: y = b0 + b1*x1 + b2*x2 + b3*x1*x2 + residual. 
In this case, one may rewrite the lm as y = b0 + (b1+b3*x2)*x1 + b2*x2 + residual,
where (b1+b3*x2) is referred to as the simple slope of x1, x1 is the predictor,
and x2 is the moderator whose values yield different simple slope values for x1.</p>
</td></tr>
<tr><td><code id="theta_plot_+3A_predictor">predictor</code></td>
<td>
<p>The independent variable for which simple slope is requested</p>
</td></tr>
<tr><td><code id="theta_plot_+3A_moderator">moderator</code></td>
<td>
<p>The moderator whose values affect the simple slopes of the predictor. 
Appears on the horizontal axis.</p>
</td></tr>
<tr><td><code id="theta_plot_+3A_alpha">alpha</code></td>
<td>
<p>The designated alpha level for the Johnson-Neyman technique</p>
</td></tr>
<tr><td><code id="theta_plot_+3A_jn">jn</code></td>
<td>
<p>A binary flag requesting the Johnson-Neyman test (T or F)</p>
</td></tr>
<tr><td><code id="theta_plot_+3A_title0">title0</code></td>
<td>
<p>Title for the plot</p>
</td></tr>
<tr><td><code id="theta_plot_+3A_predictorlab">predictorLab</code></td>
<td>
<p>Label for the predictor</p>
</td></tr>
<tr><td><code id="theta_plot_+3A_moderatorlab">moderatorLab</code></td>
<td>
<p>Label for the moderator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A region of significance plot with simple slopes of the predictor on
the vertical axis, and values of the moderator on the horizontal axis.
</p>


<h3>References</h3>

<p>Adapted from functions written by Marco Bachl to perform the Johnson-Neyman test 
and produce a plot of simple slopes and region of significance available at:
https://rpubs.com/bachl/jn-plot
</p>

<hr>
<h2 id='TrueInit_Y14'>Simulated multilevel multi-subject time series of a Van der Pol Oscillator</h2><span id='topic+TrueInit_Y14'></span>

<h3>Description</h3>

<p>A dataset simulated using methods described in the reference below.
</p>
<p>Reference:
Chow, S., Lu, Z., Sherwood, A., and Zhu, H. (2016). Fitting Nonlinear Ordinary
Differential Equation Models with Random Effects and Unknown Initial Conditions
Using the Stochastic Approximation Expectation-Maximization (SAEM) Algorithm.
Psychometrika, 81(1), 102-134.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TrueInit_Y14)
</code></pre>


<h3>Format</h3>

<p>A data frame with 60,000 rows and 10 variables</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li><p> batch. Batch number from simulation
</p>
</li>
<li><p> kk. Unclear
</p>
</li>
<li><p> trueInit. True initial condition
</p>
</li>
<li><p> id. Person ID
</p>
</li>
<li><p> time. Continuous time of measurement
</p>
</li>
<li><p> y1. Observed score 1
</p>
</li>
<li><p> y2. Observed score 2
</p>
</li>
<li><p> y3. Observed score 3
</p>
</li>
<li><p> co1. Covariate 1
</p>
</li>
<li><p> co2. Covariate 2
</p>
</li></ul>


<hr>
<h2 id='VARsim'>Simulated time series data for multiple imputation in dynamic modeling.</h2><span id='topic+VARsim'></span>

<h3>Description</h3>

<p>A dataset simulated using a vector autoregressive (VAR) model of order 1 with 
two observed variables and two covariates. Data are generated following 
the simulation design illustrated by Ji and colleagues (2018). Specifically, 
missing data are generated following the missing at random (MAR) condition under which 
the probability of missingness in both dependent variables and covariates is conditioned
on two completely observed auxiliary variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VARsim)
</code></pre>


<h3>Format</h3>

<p>A data frame with 10000 rows and 8 variables</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li><p> ID. ID of the participant (1 to 100)
</p>
</li>
<li><p> Time. Time index (100 time points from each subject)
</p>
</li>
<li><p> ca. Covariate 1
</p>
</li>
<li><p> cn. Covariate 2
</p>
</li>
<li><p> wp. Dependent variable 1
</p>
</li>
<li><p> hp. Dependent variable 2
</p>
</li>
<li><p> x1. Auxiliary variable 1
</p>
</li>
<li><p> x2. Auxiliary variable 2
</p>
</li></ul>



<h3>References</h3>

<p>Ji, L., Chow, S-M., Schermerhorn, A.C., Jacobson, N.C., &amp; Cummings, E.M. (2018). Handling 
Missing Data in the Modeling of Intensive Longitudinal Data. Structural Equation Modeling: 
A Multidisciplinary Journal, 1-22.
</p>

<hr>
<h2 id='vcov.dynrCook'>Extract the Variance-Covariance Matrix of a dynrCook object</h2><span id='topic+vcov.dynrCook'></span>

<h3>Description</h3>

<p>Extract the Variance-Covariance Matrix of a dynrCook object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynrCook'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.dynrCook_+3A_object">object</code></td>
<td>
<p>The dynrCook object for which the variance-covariance matrix is desired</p>
</td></tr>
<tr><td><code id="vcov.dynrCook_+3A_...">...</code></td>
<td>
<p>further named arguments, ignored by this method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the inverse Hessian of the transformed parameters.
</p>


<h3>Value</h3>

<p>matrix.  Asymptotic variance-covariance matrix of the transformed parameters.
</p>

<hr>
<h2 id='vdpData'>Another simulated multilevel multi-subject time series of a Van der Pol Oscillator</h2><span id='topic+vdpData'></span>

<h3>Description</h3>

<p>A dataset simulated using methods described in the reference below.
</p>
<p>Reference:
Chow, S., Lu, Z., Sherwood, A., and Zhu, H. (2016). Fitting Nonlinear Ordinary
Differential Equation Models with Random Effects and Unknown Initial Conditions
Using the Stochastic Approximation Expectation-Maximization (SAEM) Algorithm.
Psychometrika, 81(1), 102-134.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vdpData)
</code></pre>


<h3>Format</h3>

<p>A data frame with 10,000 rows and 11 variables</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li><p> batch. Batch number from simulation
</p>
</li>
<li><p> kk. Unclear
</p>
</li>
<li><p> trueInit. True initial condition
</p>
</li>
<li><p> id. Person ID
</p>
</li>
<li><p> time. Continuous time of measurement
</p>
</li>
<li><p> y1. Observed score 1
</p>
</li>
<li><p> y2. Observed score 2
</p>
</li>
<li><p> y3. Observed score 3
</p>
</li>
<li><p> u1. Covariate 1
</p>
</li>
<li><p> u2. Covariate 2
</p>
</li>
<li><p> trueb. True value of person-specific random effect	
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
