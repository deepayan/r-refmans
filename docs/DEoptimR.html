<!DOCTYPE html><html><head><title>Help for package DEoptimR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DEoptimR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#JDEoptim'>
<p>Bound-Constrained and Nonlinear Constrained Single-Objective Optimization</p>
via Differential Evolution</a></li>
<li><a href='#NCDEoptim'>
<p>Bound-Constrained and Nonlinear Constrained Multimodal Optimization</p>
via Differential Evolution</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-28</td>
</tr>
<tr>
<td>Title:</td>
<td>Differential Evolution Optimization in Pure R</td>
</tr>
<tr>
<td>Description:</td>
<td>Differential Evolution (DE) stochastic heuristic algorithms for
    global optimization of problems with and without general constraints.
    The aim is to curate a collection of its variants that
    (1) do not sacrifice simplicity of design,
    (2) are essentially tuning-free, and
    (3) can be efficiently implemented directly in the R language.
    Currently, it provides implementations of the algorithms 'jDE' by
    Brest et al. (2006) &lt;<a href="https://doi.org/10.1109%2FTEVC.2006.872133">doi:10.1109/TEVC.2006.872133</a>&gt; for single-objective
    optimization and 'NCDE' by Qu et al. (2012) &lt;<a href="https://doi.org/10.1109%2FTEVC.2011.2161873">doi:10.1109/TEVC.2011.2161873</a>&gt;
    for multimodal optimization (single-objective problems with
    multiple solutions).</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Enhances:</td>
<td>robustbase</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Author:</td>
<td>Eduardo L. T. Conceicao [aut, cre],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo L. T. Conceicao &lt;mail@eduardoconceicao.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>robustbase</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>981</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2023-09-28 18:31:04</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-07 05:00:20 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-28 18:45:11 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='JDEoptim'>
Bound-Constrained and Nonlinear Constrained Single-Objective Optimization
via Differential Evolution
</h2><span id='topic+JDEoptim'></span>

<h3>Description</h3>

<p>A bespoke implementation of the &lsquo;jDE&rsquo; variant by
Brest <em>et al.</em> (2006) <a href="https://doi.org/10.1109/TEVC.2006.872133">doi:10.1109/TEVC.2006.872133</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JDEoptim(lower, upper, fn,
         constr = NULL, meq = 0, eps = 1e-05,
         NP = 10*length(lower), Fl = 0.1, Fu = 1,
         tau_F = 0.1, tau_CR = 0.1, tau_pF = 0.1,
         jitter_factor = 0.001,
         tol = 1e-15, maxiter = 200*length(lower), fnscale = 1,
         compare_to = c("median", "max"),
         add_to_init_pop = NULL,
         trace = FALSE, triter = 1,
         details = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JDEoptim_+3A_lower">lower</code>, <code id="JDEoptim_+3A_upper">upper</code></td>
<td>
<p>numeric vectors of <em>lower</em> and <em>upper</em>
bounds for the parameters to be optimized over.  Must be finite
(<code><a href="Matrix.html#topic+is.finite">is.finite</a></code>) as they bound the hyper-rectangle
of the initial random population.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_fn">fn</code></td>
<td>
<p>(nonlinear) objective <code><a href="base.html#topic+function">function</a></code> to be
<em>minimized</em>.  It takes as first argument the vector of
parameters over which minimization is to take place.  It must return
the value of the function at that point.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_constr">constr</code></td>
<td>
<p>an optional <code><a href="base.html#topic+function">function</a></code> for specifying the
<em>left-hand side</em> of nonlinear constraints under which
we want to minimize <code>fn</code>.
Nonlinear equalities should be given first and defined to equal zero
(<code class="reqn">h_j(X) = 0</code>), followed by nonlinear inequalities defined as
lesser than zero (<code class="reqn">g_i(X) \le 0</code>).
This function takes the vector of parameters as its first argument
and returns a real vector with the length of the total number of
constraints.  It defaults to <code>NULL</code>, meaning that
<em>bound-constrained</em> minimization is used.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_meq">meq</code></td>
<td>
<p>an optional positive integer specifying that the first
<code>meq</code> constraints are treated as <em>equality</em> constraints,
and all the remaining as <em>inequality</em> constraints.  Defaults to
<code>0</code> (inequality constraints only).</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_eps">eps</code></td>
<td>
<p>maximal admissible constraint violation for equality constraints.
An optional real vector of small positive tolerance values with length
<code>meq</code> used in the transformation of equalities into inequalities
of the form <code class="reqn">|h_j(X)| - \epsilon \le 0</code>.  A scalar value is expanded
to apply to all equality constraints.  Default is <code>1e-5</code>.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_np">NP</code></td>
<td>
<p>an optional positive integer giving the number of candidate
solutions in the randomly distributed initial population.  Defaults to
<code>10*length(lower)</code>.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_fl">Fl</code></td>
<td>
<p>an optional scalar which represents the minimum value that the
<em>scaling factor</em> <code>F</code> could take.  Default is <code>0.1</code>,
which is almost always satisfactory.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_fu">Fu</code></td>
<td>
<p>an optional scalar which represents the maximum value that
the <em>scaling factor</em> <code>F</code> could take.  Default is <code>1</code>,
which is almost always satisfactory.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_tau_f">tau_F</code></td>
<td>
<p>an optional scalar which represents the probability that
the <em>scaling factor</em> <code>F</code> is updated.  Defaults to <code>0.1</code>,
which is almost always satisfactory.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_tau_cr">tau_CR</code></td>
<td>
<p>an optional constant value which represents the probability
that the <em>crossover probability</em> <code>CR</code> is updated.  Defaults to
<code>0.1</code>, which is almost always satisfactory.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_tau_pf">tau_pF</code></td>
<td>
<p>an optional scalar which represents the probability that
the <em>mutation probability</em> <code class="reqn">p_F</code> in the mutation strategy
DE/rand/1/either-or is updated.  Defaults to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_jitter_factor">jitter_factor</code></td>
<td>
<p>an optional tuning constant for <em>jitter</em>.
If <code>NULL</code> only <em>dither</em> is used.  Defaults to <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_tol">tol</code></td>
<td>
<p>an optional positive scalar giving the tolerance for the
stopping criterion.  Default is <code>1e-15</code>.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_maxiter">maxiter</code></td>
<td>
<p>an optional positive integer specifying the maximum
number of iterations that may be performed before the algorithm is halted.
Defaults to <code>200*length(lower)</code>.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_fnscale">fnscale</code></td>
<td>
<p>an optional positive scalar specifying the typical
magnitude of <code>fn</code>.  It is used only in the <em>stopping criterion</em>.
Defaults to <code>1</code>.  See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_compare_to">compare_to</code></td>
<td>
<p>an optional character string controlling which function
should be applied to the <code>fn</code> values of the candidate solutions
in a generation to be compared with the so-far best one when evaluating
the <em>stopping criterion</em>.  If &ldquo;<code>median</code>&rdquo; the <code>median</code>
function is used; else, if &ldquo;<code>max</code>&rdquo; the <code>max</code> function
is used.  It defaults to &ldquo;<code>median</code>&rdquo;.  See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_add_to_init_pop">add_to_init_pop</code></td>
<td>
<p>an optional real vector of length <code>length(lower)</code>
or <code><a href="base.html#topic+matrix">matrix</a></code> with <code>length(lower)</code> rows specifying
initial values of the parameters to be optimized which are appended to
the randomly generated initial population.  It defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_trace">trace</code></td>
<td>
<p>an optional logical value indicating if a trace of the
iteration progress should be printed.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_triter">triter</code></td>
<td>
<p>an optional positive integer giving the frequency of tracing
(every <code>triter</code> iterations) when <code>trace = TRUE</code>.  Default is
<code>triter = 1</code>, in which case
<code>iteration : &lt; value of stopping test &gt; ( value of best solution ) best solution { index of violated constraints }</code>
is printed at each iteration.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_details">details</code></td>
<td>
<p>an optional logical value.  If <code>TRUE</code> the output
will contain the parameters in the final population and their
respective <code>fn</code> values.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="JDEoptim_+3A_...">...</code></td>
<td>
<p>optional additional arguments passed to <code>fn</code>
and <code>constr</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Overview:</dt><dd>
<p>The setting of the <em>control parameters</em> of canonical
Differential Evolution (DE) is crucial for the algorithm's performance.
Unfortunately, when the generally recommended values for these parameters
(see, <em>e.g.</em>, Storn and Price, 1997) are unsuitable for use,
their determination is often difficult and time consuming.
The jDE algorithm proposed in Brest <em>et al.</em> (2006) employs a simple
self-adaptive scheme to perform the automatic setting of
control parameters scale factor <code>F</code> and crossover rate <code>CR</code>.
</p>
<p>This implementation differs from the original description, most notably
in the use of the <em>DE/rand/1/either-or</em> mutation strategy
(Price <em>et al.</em>, 2005), combination of <em>jitter with dither</em>
(Storn, 2008), and the random initialization of <code>F</code> and <code>CR</code>.
The mutation operator brings an additional control parameter, the
mutation probability <code class="reqn">p_F</code>, which is self-adapted in the
same manner as <code>CR</code>.
</p>
<p>As done by jDE and its variants (Brest <em>et al.</em>, 2021) each worse
parent in the current population is <em>immediately replaced</em>
(asynchronous update) by its newly generated better or equal offspring
(Babu and Angira, 2006) instead of updating the current population with
all the new solutions at the same time as in classical DE
(synchronous update).
</p>
<p>As the algorithm subsamples via <code><a href="base.html#topic+sample">sample</a>()</code>
which from <span class="rlang"><b>R</b></span> version 3.6.0 depends on <code><a href="base.html#topic+RNGkind">RNGkind</a>(*,
      sample.kind)</code>, exact reproducibility of results from <span class="rlang"><b>R</b></span> versions
3.5.3 and earlier requires setting <code><a href="base.html#topic+RNGversion">RNGversion</a>("3.5.0")</code>.
In any case, do use <code><a href="base.html#topic+set.seed">set.seed</a>()</code> additionally for
reproducibility!
</p>
</dd>
<dt>Constraint Handling:</dt><dd>
<p>Constraint handling is done using the approach described in
Zhang and Rangaiah (2012), but with a <em>different reduction
updating scheme</em> for the constraint relaxation value (<code class="reqn">\mu</code>).
Instead of doing it once for every generation or iteration,
the reduction is triggered for two cases when the <em>constraints only
contain inequalities</em>.  Firstly, every time a feasible solution
is selected for replacement in the next generation by a new feasible
trial candidate solution with a better objective function value.
Secondly, whenever a current infeasible solution gets replaced by a
feasible one.  If the constraints <em>include equalities</em>, then the
reduction is not triggered in this last case.  This constitutes an
original feature of the implementation.
</p>
<p>The performance of any constraint handling technique for metaheuristics
is severely impaired by a small feasible region.  Therefore, equality
constraints are particularly difficult to handle due to the tiny
feasible region they define.  So, instead of explicitly including all
equality constraints in the formulation of the optimization problem,
it might prove advantageous to eliminate some of them.
This is done by expressing one variable <code class="reqn">x_k</code> in terms of the
remaining others for an equality constraint <code class="reqn">h_j(X) = 0</code>
where <code class="reqn">X = [x_1,\ldots,x_k,\ldots,x_d]</code> is the vector of solutions,
thereby obtaining a relationship as
<code class="reqn">x_k = R_{k,j}([x_1,\ldots,x_{k-1},x_{k+1},\ldots,x_d])</code>.
In this way both the variable <code class="reqn">x_k</code> and the
equality constraint <code class="reqn">h_j(X) = 0</code> can be removed altogether from the
original optimization formulation, since the value of <code class="reqn">x_k</code> can be
calculated during the search process by the relationship <code class="reqn">R_{k,j}</code>.
Notice, however, that two additional inequalities
</p>
<p style="text-align: center;"><code class="reqn">l_k \le R_{k,j}([x_1,\ldots,x_{k-1},x_{k+1},\ldots,x_d]) \le u_k,</code>
</p>

<p>where the values <code class="reqn">l_k</code> and <code class="reqn">u_k</code> are the lower and upper bounds
of <code class="reqn">x_k</code>, respectively, must be provided in order to obtain an
equivalent formulation of the problem.  For guidance and examples on
applying this approach see Wu <em>et al.</em> (2015).
</p>
<p>Bound constraints are enforced by the <em>midpoint base</em> approach
(see, <em>e.g.</em>, Biedrzycki <em>et al.</em>, 2019).
</p>
</dd>
<dt>Discrete and Integer Variables:</dt><dd>
<p>Any DE variant is easily extended to deal with <em>mixed integer
nonlinear programming</em> problems using a small variation of the technique
presented by Lampinen and Zelinka (1999).  Integer values are obtained by
means of the <code>floor()</code> function <em>only</em> in the evaluation
of the objective function and constraints, whereas DE itself still uses
continuous variables.  Additionally, each upper bound of the integer
variables should be added by <code>1</code>.
</p>
<p>Notice that the final solution needs to be converted with <code>floor()</code>
to obtain its <em>integer</em> elements.
</p>
</dd>
<dt>Stopping Criterion:</dt><dd>
<p>The algorithm is stopped if
</p>
<p style="text-align: center;"><code class="reqn">\frac{\mathrm{compare\_to}\{[\mathrm{fn}(X_1),\ldots,\mathrm{fn}(X_\mathrm{npop})]\} - \mathrm{fn}(X_\mathrm{best})}{\mathrm{fnscale}} \le \mathrm{tol},</code>
</p>

<p>where the &ldquo;best&rdquo; individual <code class="reqn">X_\mathrm{best}</code> is the
<em>feasible</em> solution with the lowest objective function value in the
population and the total number of elements in the population,
<code>npop</code>, is <code>NP+NCOL(add_to_init_pop)</code>.
For <code>compare_to = "max"</code> this is the <em>Diff</em> criterion
studied by Zielinski and Laur (2008) among several other alternatives,
which was found to yield the best results.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>The best set of parameters found.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of <code>fn</code> corresponding to <code>par</code>.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations taken by the algorithm.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>An integer code.  <code>0</code> indicates successful completion.
<code>1</code> indicates that the iteration limit <code>maxiter</code>
has been reached.</p>
</td></tr>
</table>
<p>and if <code>details = TRUE</code>:
</p>
<table>
<tr><td><code>poppar</code></td>
<td>
<p>Matrix of dimension <code>(length(lower), npop)</code>, with columns
corresponding to the parameter vectors remaining in the population.</p>
</td></tr>
<tr><td><code>popcost</code></td>
<td>
<p>The values of <code>fn</code> associated with <code>poppar</code>,
vector of length <code>npop</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is possible to perform a warm start, <em>i.e.</em>, starting from the
previous run and resume optimization, using <code>NP = 0</code> and the
component <code>poppar</code> for the <code>add_to_init_pop</code> argument.
</p>


<h3>Author(s)</h3>

<p>Eduardo L. T. Conceicao <a href="mailto:mail@eduardoconceicao.org">mail@eduardoconceicao.org</a>
</p>


<h3>References</h3>

<p>Babu, B. V. and Angira, R. (2006)
Modified differential evolution (MDE) for optimization of
non-linear chemical processes.
<em>Computers and Chemical Engineering</em> <b>30</b>, 989&ndash;1002.
<a href="https://doi.org/10.1016/j.compchemeng.2005.12.020">doi:10.1016/j.compchemeng.2005.12.020</a>.
</p>
<p>Biedrzycki, R., Arabas, J. and Jagodzinski, D. (2019)
Bound constraints handling in differential evolution: An experimental study.
<em>Swarm and Evolutionary Computation</em> <b>50</b>, 100453.
<a href="https://doi.org/10.1016/j.swevo.2018.10.004">doi:10.1016/j.swevo.2018.10.004</a>.
</p>
<p>Brest, J., Greiner, S., Boskovic, B., Mernik, M. and Zumer, V. (2006)
Self-adapting control parameters in differential evolution: A
comparative study on numerical benchmark problems.
<em>IEEE Transactions on Evolutionary Computation</em> <b>10</b>, 646&ndash;657.
<a href="https://doi.org/10.1109/TEVC.2006.872133">doi:10.1109/TEVC.2006.872133</a>.
</p>
<p>Brest, J., Maucec, M. S. and Boskovic, B. (2021)
Self-adaptive differential evolution algorithm with population size reduction
for single objective bound-constrained optimization: Algorithm j21;
in <em>2021 IEEE Congress on Evolutionary Computation (CEC)</em>.
IEEE, pp. 817&ndash;824.
<a href="https://doi.org/10.1109/CEC45853.2021.9504782">doi:10.1109/CEC45853.2021.9504782</a>.
</p>
<p>Lampinen, J. and Zelinka, I. (1999).
Mechanical engineering design optimization by differential evolution;
in Corne, D., Dorigo, M. and Glover, F., Eds.,
<em>New Ideas in Optimization</em>.
McGraw-Hill, pp. 127&ndash;146.
</p>
<p>Price, K. V., Storn, R. M. and Lampinen, J. A. (2005)
<em>Differential evolution: A practical approach to global optimization</em>.
Springer, Berlin, Heidelberg, pp. 117&ndash;118.
<a href="https://doi.org/10.1007/3-540-31306-0_2">doi:10.1007/3-540-31306-0_2</a>.
</p>
<p>Storn, R. (2008)
Differential evolution research &mdash; Trends and open questions;
in Chakraborty, U. K., Ed.,
<em>Advances in differential evolution</em>.
SCI 143, Springer, Berlin, Heidelberg, pp. 11&ndash;12.
<a href="https://doi.org/10.1007/978-3-540-68830-3_1">doi:10.1007/978-3-540-68830-3_1</a>.
</p>
<p>Storn, R. and Price, K. (1997)
Differential evolution - A simple and efficient heuristic for global
optimization over continuous spaces.
<em>Journal of Global Optimization</em> <b>11</b>, 341&ndash;359.
<a href="https://doi.org/10.1023/A%3A1008202821328">doi:10.1023/A:1008202821328</a>.
</p>
<p>Wu, G., Pedrycz, W., Suganthan, P. N. and Mallipeddi, R. (2015)
A variable reduction strategy for evolutionary algorithms handling
equality constraints.
<em>Applied Soft Computing</em> <b>37</b>, 774&ndash;786.
<a href="https://doi.org/10.1016/j.asoc.2015.09.007">doi:10.1016/j.asoc.2015.09.007</a>.
</p>
<p>Zhang, H. and Rangaiah, G. P. (2012)
An efficient constraint handling method with integrated differential
evolution for numerical and engineering optimization.
<em>Computers and Chemical Engineering</em> <b>37</b>, 74&ndash;88.
<a href="https://doi.org/10.1016/j.compchemeng.2011.09.018">doi:10.1016/j.compchemeng.2011.09.018</a>.
</p>
<p>Zielinski, K. and Laur, R. (2008)
Stopping criteria for differential evolution in constrained
single-objective optimization;
in Chakraborty, U. K., Ed.,
<em>Advances in differential evolution</em>.
SCI 143, Springer, Berlin, Heidelberg, pp. 111&ndash;138.
<a href="https://doi.org/10.1007/978-3-540-68830-3_4">doi:10.1007/978-3-540-68830-3_4</a>.
</p>


<h3>See Also</h3>

<p>Function <code><a href="DEoptim.html#topic+DEoptim">DEoptim</a>()</code> in the <a href="https://CRAN.R-project.org/package=DEoptim"><span class="pkg">DEoptim</span></a> package
has many more options than <code>JDEoptim()</code>, but does not allow constraints
in the same flexible manner.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# NOTE: Examples were excluded from testing
#       to reduce package check time.

# Use a preset seed so test values are reproducible.
set.seed(1234)

# Bound-constrained optimization

#   Griewank function
#
#   -600 &lt;= xi &lt;= 600, i = {1, 2, ..., n}
#   The function has a global minimum located at
#   x* = (0, 0, ..., 0) with f(x*) = 0. Number of local minima
#   for arbitrary n is unknown, but in the two dimensional case
#   there are some 500 local minima.
#
#   Source:
#     Ali, M. Montaz, Khompatraporn, Charoenchai, and
#     Zabinsky, Zelda B. (2005).
#     A numerical evaluation of several stochastic algorithms
#     on selected continuous global optimization test problems.
#     Journal of Global Optimization 31, 635-672.
#     https://doi.org/10.1007/s10898-004-9972-2
griewank &lt;- function(x) {
    1 + crossprod(x)/4000 - prod( cos(x/sqrt(seq_along(x))) )
}

JDEoptim(rep(-600, 10), rep(600, 10), griewank,
         tol = 1e-7, trace = TRUE, triter = 50)

# Nonlinear constrained optimization

#   0 &lt;= x1 &lt;= 34, 0 &lt;= x2 &lt;= 17, 100 &lt;= x3 &lt;= 300
#   The global optimum is
#   (x1, x2, x3; f) = (0, 16.666667, 100; 189.311627).
#
#   Source:
#     Westerberg, Arthur W., and Shah, Jigar V. (1978).
#     Assuring a global optimum by the use of an upper bound
#     on the lower (dual) bound.
#     Computers and Chemical Engineering 2, 83-92.
#     https://doi.org/10.1016/0098-1354(78)80012-X
fcn &lt;-
    list(obj = function(x) {
             35*x[1]^0.6 + 35*x[2]^0.6
         },
         eq = 2,
         con = function(x) {
             x1 &lt;- x[1]; x3 &lt;- x[3]
             c(600*x1 - 50*x3 - x1*x3 + 5000,
               600*x[2] + 50*x3 - 15000)
         })

JDEoptim(c(0, 0, 100), c(34, 17, 300),
         fn = fcn$obj, constr = fcn$con, meq = fcn$eq,
         tol = 1e-7, trace = TRUE, triter = 50)

#   Designing a pressure vessel
#   Case A: all variables are treated as continuous
#
#   1.1 &lt;= x1 &lt;= 12.5*, 0.6 &lt;= x2 &lt;= 12.5*,
#   0.0 &lt;= x3 &lt;= 240.0*, 0.0 &lt;= x4 &lt;= 240.0
#   Roughly guessed*
#   The global optimum is (x1, x2, x3, x4; f) =
#   (1.100000, 0.600000, 56.99482, 51.00125; 7019.031).
#
#   Source:
#     Lampinen, Jouni, and Zelinka, Ivan (1999).
#     Mechanical engineering design optimization
#     by differential evolution.
#     In: David Corne, Marco Dorigo and Fred Glover (Editors),
#     New Ideas in Optimization, McGraw-Hill, pp 127-146
pressure_vessel_A &lt;-
    list(obj = function(x) {
             x1 &lt;- x[1]; x2 &lt;- x[2]; x3 &lt;- x[3]; x4 &lt;- x[4]
             0.6224*x1*x3*x4 + 1.7781*x2*x3^2 +
             3.1611*x1^2*x4 + 19.84*x1^2*x3
         },
         con = function(x) {
             x1 &lt;- x[1]; x2 &lt;- x[2]; x3 &lt;- x[3]; x4 &lt;- x[4]
             c(0.0193*x3 - x1,
               0.00954*x3 - x2,
               750.0*1728.0 - pi*x3^2*x4 - 4/3*pi*x3^3)
         })

JDEoptim(c( 1.1,  0.6,   0.0,   0.0),
         c(12.5, 12.5, 240.0, 240.0),
         fn = pressure_vessel_A$obj,
         constr = pressure_vessel_A$con,
         tol = 1e-7, trace = TRUE, triter = 50)

# Mixed integer nonlinear programming

#   Designing a pressure vessel
#   Case B: solved according to the original problem statements
#           steel plate available in thicknesses multiple
#           of 0.0625 inch
#
#   wall thickness of the
#   shell 1.1 [18*0.0625] &lt;= x1 &lt;= 12.5 [200*0.0625]
#   heads 0.6 [10*0.0625] &lt;= x2 &lt;= 12.5 [200*0.0625]
#         0.0 &lt;= x3 &lt;= 240.0, 0.0 &lt;= x4 &lt;= 240.0
#   The global optimum is (x1, x2, x3, x4; f) =
#   (1.125 [18*0.0625], 0.625 [10*0.0625],
#    58.29016, 43.69266; 7197.729).
pressure_vessel_B &lt;-
    list(obj = function(x) {
             x1 &lt;- floor(x[1])*0.0625
             x2 &lt;- floor(x[2])*0.0625
             x3 &lt;- x[3]; x4 &lt;- x[4]
             0.6224*x1*x3*x4 + 1.7781*x2*x3^2 +
             3.1611*x1^2*x4 + 19.84*x1^2*x3
         },
         con = function(x) {
             x1 &lt;- floor(x[1])*0.0625
             x2 &lt;- floor(x[2])*0.0625
             x3 &lt;- x[3]; x4 &lt;- x[4]
             c(0.0193*x3 - x1,
               0.00954*x3 - x2,
               750.0*1728.0 - pi*x3^2*x4 - 4/3*pi*x3^3)
         })

res &lt;- JDEoptim(c( 18,    10,     0.0,   0.0),
                c(200+1, 200+1, 240.0, 240.0),
                fn = pressure_vessel_B$obj,
                constr = pressure_vessel_B$con,
                tol = 1e-7, trace = TRUE, triter = 50)
res
# Now convert to integer x1 and x2
c(floor(res$par[1:2]), res$par[3:4])

</code></pre>

<hr>
<h2 id='NCDEoptim'>
Bound-Constrained and Nonlinear Constrained Multimodal Optimization
via Differential Evolution
</h2><span id='topic+NCDEoptim'></span>

<h3>Description</h3>

<p>A bespoke implementation of the &lsquo;NCDE&rsquo;
(neighborhood based crowding DE) algorithm by
Qu <em>et al.</em> (2012) <a href="https://doi.org/10.1109/TEVC.2011.2161873">doi:10.1109/TEVC.2011.2161873</a>,
assisted with the dynamic archive mechanism of
Epitropakis <em>et al.</em> (2013) <a href="https://doi.org/10.1109/CEC.2013.6557556">doi:10.1109/CEC.2013.6557556</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCDEoptim(lower, upper, fn,
          constr = NULL, meq = 0, eps = 1e-5,
          crit = 1e-5, niche_radius = NULL, archive_size = 100,
          reinit_if_solu_in_arch = TRUE,
          NP = 100, Fl = 0.1, Fu = 1, CRl = 0, CRu = 1.1,
          nbngbrsl = NP/20, nbngbrsu = NP/5,
          tau_F = 0.1, tau_CR = 0.1, tau_pF = 0.1,
          tau_nbngbrs = 0.1,
          jitter_factor = 0.001,
          maxiter = 2000,
          add_to_init_pop = NULL,
          trace = FALSE, triter = 1,
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NCDEoptim_+3A_lower">lower</code>, <code id="NCDEoptim_+3A_upper">upper</code></td>
<td>
<p>numeric vectors, the lower and upper bounds of the
search space (<em>box constraints</em>); must be finite
(<code><a href="Matrix.html#topic+is.finite">is.finite</a></code>).</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_fn">fn</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> to be <strong>minimized</strong> that takes a
numeric vector <code class="reqn">X_i</code> as first argument and returns the value of the
objective.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_constr">constr</code></td>
<td>
<p>a vector <code><a href="base.html#topic+function">function</a></code> specifying the
<strong>left-hand side</strong> of equality constraints defined to equal zero
(<code class="reqn">h_j(X_i) = 0,\; j = 1,\ldots,\mathrm{meq}</code>),
followed by inequality constraints defined as lesser than zero
(<code class="reqn">g_j(X_i) \le 0,\; j = \mathrm{meq}+1,\ldots</code>).  This function takes
<code class="reqn">X_i</code> as its first argument and returns a numeric vector with the same
length of the total number of constraints.  It defaults to <code>NULL</code>,
which means that <strong>bound-constrained</strong> minimization is used.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_meq">meq</code></td>
<td>
<p>an integer, the first <code>meq</code> constraints are
<em>equality</em> constraints whereas the remaining ones are
<em>inequality</em> constraints.  Defaults to <code>0</code>
(inequality constraints only).</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_eps">eps</code></td>
<td>
<p>the maximal admissible constraint violation for
equality constraints.  A numeric vector of small positive tolerance values
with length <code>meq</code> used in the transformation of equalities into
inequalities of the form <code class="reqn">|h_j(X_i)| - \epsilon \le 0</code>.  A scalar value
is expanded to apply to all equality constraints.  Default is <code>1e-5</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_crit">crit</code></td>
<td>
<p>a numeric, the acceptance threshold on the archive strategy.  If
<code><a href="base.html#topic+isTRUE">isTRUE</a>(<a href="Matrix.html#topic+all.equal">all.equal</a>(fn(X_best_so_far_in_archive), fn(X_i), tolerance = crit))</code>,
a solution <code class="reqn">X_i</code> is checked for possible insertion into the
dynamic archive.  Defaults to <code>1e-5</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_niche_radius">niche_radius</code></td>
<td>
<p>a numeric, the absolute tolerance used to decide whether
the solution <code class="reqn">X_i</code> is <em>identical</em> to an already existing
local or global solution <em>in the archive</em>.  It defaults to <code>NULL</code>,
meaning that the niche radius is adaptively chosen during the search.
Results are <strong>much better</strong> if one is able to provide
a reasonable value.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_archive_size">archive_size</code></td>
<td>
<p>an integer, the maximum number of solutions that
can be kept in the archive; entries above this limit are discarded.
Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_reinit_if_solu_in_arch">reinit_if_solu_in_arch</code></td>
<td>
<p>a logical, if <code>TRUE</code>, any solution
<code class="reqn">X_i</code> already in the archive <strong>reinitializes</strong> its nearest neighbor
<em>in the population</em> within the range
<code class="reqn">[\mathrm{lower}, \mathrm{upper}]</code>.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_np">NP</code></td>
<td>
<p>an integer, the population size.  Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_fl">Fl</code></td>
<td>
<p>a numeric, the minimum value that the
<em>scaling factor</em> <code>F</code> could take.  It defaults to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_fu">Fu</code></td>
<td>
<p>a numeric, the maximum value that the
<em>scaling factor</em> <code>F</code> could take.  It defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_crl">CRl</code></td>
<td>
<p>a numeric, the minimum value to be used for the
<em>crossover constant</em> <code>CR</code>.  It defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_cru">CRu</code></td>
<td>
<p>a numeric, the maximum value to be used for the
<em>crossover constant</em> <code>CR</code>.  It defaults to <code>1.1</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_nbngbrsl">nbngbrsl</code></td>
<td>
<p>an integer, the lower limit for the
<em>neighborhood size</em> <code>nbngbrs</code>.
It defaults to <code>1/20</code> of the population size.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_nbngbrsu">nbngbrsu</code></td>
<td>
<p>an integer, the upper limit for the
<em>neighborhood size</em> <code>nbngbrs</code>.
It defaults to <code>1/5</code> of the population size.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_tau_f">tau_F</code></td>
<td>
<p>a numeric, the probability that the
<em>scaling factor</em> <code>F</code> is updated.  Defaults to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_tau_cr">tau_CR</code></td>
<td>
<p>a numeric, the probability that the
<em>crossover constant</em> <code>CR</code> is updated.  Defaults to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_tau_pf">tau_pF</code></td>
<td>
<p>a numeric, the probability that the
<em>mutation probability</em> <code class="reqn">p_F</code> in the mutation strategy
DE/rand/1/either-or is updated.  Defaults to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_tau_nbngbrs">tau_nbngbrs</code></td>
<td>
<p>a numeric, the probability that the
<em>neighborhood size</em> <code>nbngbrs</code> is updated.  Defaults to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_jitter_factor">jitter_factor</code></td>
<td>
<p>a numeric, the tuning constant for <em>jitter</em>.
If <code>NULL</code> only <em>dither</em> is used.  Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_maxiter">maxiter</code></td>
<td>
<p>an integer, the maximum number of iterations allowed which is
the <strong>stopping condition</strong>.  Default is <code>2000</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_add_to_init_pop">add_to_init_pop</code></td>
<td>
<p>numeric vector of length <code>length(lower)</code> or
column-wise <code><a href="base.html#topic+matrix">matrix</a></code> with <code>length(lower)</code> rows specifying
initial candidate solutions which are appended to the randomly generated
initial population.  Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_trace">trace</code></td>
<td>
<p>a logical, determines whether or not to monitor the
iteration process.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_triter">triter</code></td>
<td>
<p>an integer, trace output is printed at every
<code>triter</code> iterations.  Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="NCDEoptim_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>fn</code> and <code>constr</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation differs mainly from the original &lsquo;NCDE&rsquo; algorithm
of Qu <em>et al.</em> (2012) by employing the archiving procedure proposed
in Epitropakis <em>et al.</em> (2013) and the adaptive &lsquo;jDE&rsquo; strategy
instead of canonical Diferential Evolution.  The key reason for archiving
good solutions during the search process is to prevent them from being lost
during evolution.  Constraints are tackled through the
<code class="reqn">\varepsilon</code>-constrained method as proposed
in Poole and Allen (2019).  The &lsquo;jDE&rsquo; and
<code class="reqn">\varepsilon</code>-constrained mechanisms are applied in the same way
as in <code><a href="#topic+JDEoptim">JDEoptim</a></code>, but with <em>synchronous</em> mode of
population update.  In contrast, the reinitialization in the current
population triggered by already found solutions is done <em>asynchronously</em>.
</p>
<p>Each line of trace output follows the format of:
</p>
<p><code>iteration : &lt; value of niche radius &gt; population&gt;&gt; ( value of best solution ) best solution { index of violated constraints } archive&gt;&gt; [ number of solutions found ] ( value of best solution ) best solution</code>
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>solution_arch</code></td>
<td>
<p>a <code><a href="base.html#topic+matrix">matrix</a></code> whose columns are the
local and global minima stored in the <strong>archive</strong> of feasible solutions
in ascending order of the objective function values.</p>
</td></tr>
<tr><td><code>objective_arch</code></td>
<td>
<p>the values of <code class="reqn">\mathrm{fn}(X_i)</code> for the
corresponding columns of <code>solution_arch</code>.</p>
</td></tr>
<tr><td><code>solution_pop</code></td>
<td>
<p>a <code><a href="base.html#topic+matrix">matrix</a></code> whose columns are the
local and global minima stored in the <strong>final population</strong>
in ascending order of the objective function values;
feasible solutions come first followed by the infeasible ones.</p>
</td></tr>
<tr><td><code>objective_pop</code></td>
<td>
<p>the values of <code class="reqn">\mathrm{fn}(X_i)</code> for the
corresponding columns of <code>solution_pop</code>.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations used.</p>
</td></tr>
</table>
<p>and if there are general constraints present:
</p>
<table>
<tr><td><code>constr_value_arch</code></td>
<td>
<p>a <code><a href="base.html#topic+matrix">matrix</a></code> whose columns contain
the values of the constraints for <code>solution_arch</code>.</p>
</td></tr>
<tr><td><code>constr_value_pop</code></td>
<td>
<p>a <code><a href="base.html#topic+matrix">matrix</a></code> whose columns contain
the values of the constraints for <code>solution_pop</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><b>This function is in an experimental stage.</b>
</p>


<h3>Author(s)</h3>

<p>Eduardo L. T. Conceicao <a href="mailto:mail@eduardoconceicao.org">mail@eduardoconceicao.org</a>
</p>


<h3>References</h3>

<p>Epitropakis, M. G., Li, X. and Burke, E. K. (2013)
A dynamic archive niching differential evolution algorithm
for multimodal optimization;
in <em>2013 IEEE Congress on Evolutionary Computation (CEC)</em>.
IEEE, pp. 79&ndash;86.
<a href="https://doi.org/10.1109/CEC.2013.6557556">doi:10.1109/CEC.2013.6557556</a>.
</p>
<p>Poole, D. J. and Allen, C. B. (2019)
Constrained niching using differential evolution.
<em>Swarm and Evolutionary Computation</em> <b>44</b>, 74&ndash;100.
<a href="https://doi.org/10.1016/j.swevo.2018.11.004">doi:10.1016/j.swevo.2018.11.004</a>.
</p>
<p>Qu, B. Y., Suganthan, P. N. and Liang, J. J. (2012)
Differential evolution with neighborhood mutation for multimodal optimization.
<em>IEEE Transactions on Evolutionary Computation</em> <b>16</b>, 601&ndash;614.
<a href="https://doi.org/10.1109/TEVC.2011.2161873">doi:10.1109/TEVC.2011.2161873</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# NOTE: Examples were excluded from testing
#       to reduce package check time.

# Use a preset seed so test values are reproducible.
set.seed(1234)

# Warning: the examples are run using a very small number of
# iterations to decrease execution time.

# Bound-constrained optimization

#   Vincent function
#
#   f(x) = -mean(sin(10*log(x)))
#
#   0.25 &lt;= xi &lt;= 10, i = {1, 2, ..., n}
#   The function has 6^n global minima without local minima.

NCDEoptim(c(0.25, 0.25), c(10, 10),
          function(x) -mean(sin(10*log(x))),
          niche_radius = 0.2,
          maxiter = 200, trace = TRUE, triter = 20)

# Nonlinear constrained optimization

#   Function F10 of Poole and Allen (2019)
#
#   f(x) = -sin(5*pi*x)^6 + 1
#   subject to:
#   g(x) = -cos(10*pi*x) &lt;= 0
#
#   0 &lt;= x &lt;= 1
#   The 10 global optima are
#   (x1*, ..., x10*; f*) = ((2*(1:10) - 1)/20; 0.875).

NCDEoptim(0, 1,
          function(x) -sin(5*pi*x)^6 + 1,
          function(x) -cos(10*pi*x),
          niche_radius = 0.05,
          maxiter = 200, trace = TRUE, triter = 20)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
