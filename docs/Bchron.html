<!DOCTYPE html><html><head><title>Help for package Bchron</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Bchron}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#Bchron'><p>Bchron: Radiocarbon dating, age-depth modelling, relative sea level rate estimation, and non-parametric phase modelling</p></a></li>
<li><a href='#BchronCalibrate'><p>Fast radiocarbon calibration</p></a></li>
<li><a href='#BchronCheck'><p>Check data for input into BchronCalibrate or Bchronology</p></a></li>
<li><a href='#BchronDensity'><p>Non-parametric phase model</p></a></li>
<li><a href='#BchronDensityFast'><p>Non-parametric phase model (faster version)</p></a></li>
<li><a href='#Bchronology'><p>Runs the Compound Poisson-Gamma chronology model of Haslett and Parnell (2008)</p></a></li>
<li><a href='#BchronRSL'><p>Relative sea level rate (RSL) estimation</p></a></li>
<li><a href='#choosePositions'><p>Compute positions to date next which result in maximal decrease of chronological uncertainty</p></a></li>
<li><a href='#coreInfluence'><p>Find the influence of dates in a pair of Bchronology runs across the core</p></a></li>
<li><a href='#createCalCurve'><p>Create a new calibration curve</p></a></li>
<li><a href='#dateInfluence'><p>Find the influence of the dates in a Bchronology run</p></a></li>
<li><a href='#Glendalough'><p>Glendalough data</p></a></li>
<li><a href='#hdr'><p>Calculate highest density regions for Bchron calibrated ages</p></a></li>
<li><a href='#intcal13'><p>Northern hemisphere 2013 calibration curve</p></a></li>
<li><a href='#intcal20'><p>Northern hemisphere 2020 calibration curve</p></a></li>
<li><a href='#marine13'><p>Marine 2013 calibration curve</p></a></li>
<li><a href='#marine20'><p>Marine 2020 calibration curve</p></a></li>
<li><a href='#normal'><p>Data for dummy calibration of normally distributed ages</p></a></li>
<li><a href='#plot.BchronCalibratedDates'><p>Plot calibrated dates from a BchronCalibrate run</p></a></li>
<li><a href='#plot.BchronDensityRun'><p>Plot output from <code>BchronDensity</code></p></a></li>
<li><a href='#plot.BchronDensityRunFast'><p>Plot run from <code>BchronDensityFast</code></p></a></li>
<li><a href='#plot.BchronologyRun'><p>Plot output from Bchronology</p></a></li>
<li><a href='#plot.BchronRSLRun'><p>Plot output from BchronRSL</p></a></li>
<li><a href='#predict.BchronologyRun'><p>Predict ages of other positions for a BchronologyRun object</p></a></li>
<li><a href='#sampleAges'><p>Get sample ages from a set of Bchron calibrated dates</p></a></li>
<li><a href='#shcal13'><p>Southern hemisphere 2013 calibration curve</p></a></li>
<li><a href='#shcal20'><p>Southern hemisphere 2020 calibration curve</p></a></li>
<li><a href='#Sluggan'><p>Sluggan Moss data</p></a></li>
<li><a href='#summary.BchronCalibratedDates'><p>Summarise a BchronCalibrate object</p></a></li>
<li><a href='#summary.BchronDensityRun'><p>Summarise a Bchron density object</p></a></li>
<li><a href='#summary.BchronologyRun'><p>Summarise a Bchronology object</p></a></li>
<li><a href='#summary.BchronRSLRun'><p>Summarise a BchronRSL run</p></a></li>
<li><a href='#TestChronData'><p>Example chronology file for use with the BchronRSL function.</p></a></li>
<li><a href='#TestRSLData'><p>Relative sea level data</p></a></li>
<li><a href='#unCalibrate'><p>Uncalibrate a Radiocarbon date</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Radiocarbon Dating, Age-Depth Modelling, Relative Sea Level Rate
Estimation, and Non-Parametric Phase Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>4.7.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-06-09</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://andrewcparnell.github.io/Bchron/">https://andrewcparnell.github.io/Bchron/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/andrewcparnell/Bchron/issues">https://github.com/andrewcparnell/Bchron/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, MASS, coda, mclust, ggplot2, ggridges, magrittr, purrr,
ggforce, dplyr, scales, stringr, checkmate</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Enables quick calibration of radiocarbon dates under various 
  calibration curves (including user generated ones); age-depth modelling 
  as per the algorithm of Haslett and Parnell (2008) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9876.2008.00623.x">doi:10.1111/j.1467-9876.2008.00623.x</a>&gt;; Relative sea level 
  rate estimation incorporating time uncertainty in polynomial regression 
  models (Parnell and Gehrels 2015) &lt;<a href="https://doi.org/10.1002%2F9781118452547.ch32">doi:10.1002/9781118452547.ch32</a>&gt;; non-parametric phase modelling via 
  Gaussian mixtures as a means to determine the activity of a site 
  (and as an alternative to the Oxcal function SUM; currently 
  unpublished), and reverse calibration of dates from calibrated into 
  un-calibrated years (also unpublished).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat (&ge; 3.0.0), rmarkdown, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-09 16:04:16 UTC; andrewparnell</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Parnell [cre, aut],
  Nathan McJames [ctb],
  Bruna Wundervald [ctb],
  Keefe Murphy [ctb],
  Mateus Maia [ctb],
  Amin Shoari Nejad [ctb],
  Yong Chen Goh [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Parnell &lt;Andrew.Parnell@mu.ie&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-10 05:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='Bchron'>Bchron: Radiocarbon dating, age-depth modelling, relative sea level rate estimation, and non-parametric phase modelling</h2><span id='topic+Bchron'></span>

<h3>Description</h3>

<p>This package enables quick calibration of radiocarbon dates under various calibration curves (including user generated ones); Age-depth modelling as per the algorithm of Haslett and Parnell (2008); Relative sea level rate estimation incorporating time uncertainty in polynomial regression models; and non-parametric phase modelling via Gaussian mixtures as a means to determine the activity of a site (and as an alternative to the Oxcal function SUM)
</p>


<h3>Bchron functions</h3>

<p>The most important functions are <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code> to calibrate radiocarbon (and non-radiocarbon) dates, <code><a href="#topic+Bchronology">Bchronology</a></code> for the age-depth model of Haslett and Parnell (2008), <code><a href="#topic+BchronRSL">BchronRSL</a></code> to get rate estimates for relative sea level data, <code><a href="#topic+BchronDensity">BchronDensity</a></code> and <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code> for non-parametric phase modelling of age data. See the help files for these functions for examples. See the vignette for more complete documentation
</p>

<hr>
<h2 id='BchronCalibrate'>Fast radiocarbon calibration</h2><span id='topic+BchronCalibrate'></span>

<h3>Description</h3>

<p>A fast function for calibrating large numbers of radiocarbon dates involving multiple calibration curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BchronCalibrate(
  ages,
  ageSds,
  calCurves = rep("intcal20", length(ages)),
  ids = NULL,
  positions = NULL,
  pathToCalCurves = system.file("data", package = "Bchron"),
  allowOutside = FALSE,
  eps = 1e-05,
  dfs = rep(100, length(ages))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BchronCalibrate_+3A_ages">ages</code></td>
<td>
<p>A vector of ages provided in years before 1950.</p>
</td></tr>
<tr><td><code id="BchronCalibrate_+3A_agesds">ageSds</code></td>
<td>
<p>A vector of 1-sigma values for the ages given above</p>
</td></tr>
<tr><td><code id="BchronCalibrate_+3A_calcurves">calCurves</code></td>
<td>
<p>A vector of values containing either <code>intcal20</code>, <code>shcal20</code>, <code>marine20</code>, or <code>normal</code> (older calibration curves are supposed such as intcal13). Should be the same length the number of ages supplied. Non-standard calibration curves can be used provided they are supplied in the same format as those previously mentioned and are placed in the same directory. Normal indicates a normally-distributed (non-14C) age.</p>
</td></tr>
<tr><td><code id="BchronCalibrate_+3A_ids">ids</code></td>
<td>
<p>ID names for each age</p>
</td></tr>
<tr><td><code id="BchronCalibrate_+3A_positions">positions</code></td>
<td>
<p>Position values (e.g. depths) for each age. In the case of layers of non-zero thickness, this should be the middle value of the slice</p>
</td></tr>
<tr><td><code id="BchronCalibrate_+3A_pathtocalcurves">pathToCalCurves</code></td>
<td>
<p>File path to where the calibration curves are located. Defaults to the system directory where the 3 standard calibration curves are stored.</p>
</td></tr>
<tr><td><code id="BchronCalibrate_+3A_allowoutside">allowOutside</code></td>
<td>
<p>Whether to allow calibrations to run outside the range of the calibration curve. By default this is turned off as calibrations outside of the range of the calibration curve can cause severe issues with probability ranges of calibrated dates</p>
</td></tr>
<tr><td><code id="BchronCalibrate_+3A_eps">eps</code></td>
<td>
<p>Cut-off point for density calculation. A value of eps&gt;0 removes ages from the output which have negligible probability density</p>
</td></tr>
<tr><td><code id="BchronCalibrate_+3A_dfs">dfs</code></td>
<td>
<p>Degrees-of-freedom values for the t-distribution associated with the calibration calculation. A large value indicates Gaussian distributions assumed for the 14C ages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a direct numerical integration strategy for computing calibrated radiocarbon ages. The steps for each 14C age are approximately as follows:
1) Create a grid of ages covering the range of the calibration curve
2) Calculate the probability of each age according to the 14C age, the standard deviation supplied and the calibration curve
3) Normalise the probabilities so that they sum to 1
4) Remove any probabilities that are less than the value given for eps
Multiple calibration curves can be specified so that each 14C age can have a different curve. For ages that are not 14C, use the 'normal' calibration curve which treats the ages as normally distributed with given standard deviation
</p>


<h3>Value</h3>

<p>A list of lists where each element corresponds to a single age. Each element contains:
</p>
<table>
<tr><td><code>ages</code></td>
<td>
<p>The original age supplied</p>
</td></tr>
<tr><td><code>ageSds</code></td>
<td>
<p>The original age standard deviation supplied</p>
</td></tr>
<tr><td><code>positions</code></td>
<td>
<p>The position of the age (usually the depth)</p>
</td></tr>
<tr><td><code>calCurves</code></td>
<td>
<p>The calibration curve used for that age</p>
</td></tr>
<tr><td><code>ageGrid</code></td>
<td>
<p>A grid of age values over which the density was created</p>
</td></tr>
<tr><td><code>densities</code></td>
<td>
<p>A vector of probability values indicating the probability value for each element in <code>ageGrid</code></p>
</td></tr>
<tr><td><code>ageLab</code></td>
<td>
<p>The label given to the age variable</p>
</td></tr>
<tr><td><code>positionLab</code></td>
<td>
<p>The label given to the position variable</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Bchronology">Bchronology</a></code>, <code><a href="#topic+BchronRSL">BchronRSL</a></code>, <code><a href="#topic+BchronDensity">BchronDensity</a></code>, <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>, <code><a href="#topic+createCalCurve">createCalCurve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calibrate a single age
ages1 &lt;- BchronCalibrate(
  ages = 11553,
  ageSds = 230,
  calCurves = "intcal20",
  ids = "Date-1"
)
summary(ages1)
plot(ages1)

# Or plot with Calibration curve
plot(ages1, includeCal = TRUE)

# Calibrate multiple ages with different calibration curves
ages2 &lt;- BchronCalibrate(
  ages = c(3445, 11553, 7456),
  ageSds = c(50, 230, 110),
  calCurves = c("intcal20", "intcal20", "shcal20")
)
summary(ages2)
plot(ages2)

# Calibrate multiple ages with multiple calibration curves and including depth
ages3 &lt;- BchronCalibrate(
  ages = c(3445, 11553),
  ageSds = c(50, 230),
  positions = c(100, 150),
  calCurves = c("intcal20", "normal")
)
summary(ages3)
plot(ages3, withPositions = TRUE)
</code></pre>

<hr>
<h2 id='BchronCheck'>Check data for input into BchronCalibrate or Bchronology</h2><span id='topic+BchronCheck'></span>

<h3>Description</h3>

<p>Function to be used for checking the data formats in <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code> and <code><a href="#topic+Bchronology">Bchronology</a></code>. Mostly to be used internally to avoid Bchron running into problems with bad data specifications, but might also be useful for
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BchronCheck(
  ages,
  ageSds,
  positions = NULL,
  pathToCalCurves = NULL,
  calCurves = NULL,
  positionThicknesses = NULL,
  ids = NULL,
  outlierProbs = NULL,
  predictPositions = NULL,
  artificialThickness = NULL,
  allowOutside = NULL,
  iterations = NULL,
  thetaStart = NULL,
  burn = NULL,
  thin = NULL,
  extractDate = NULL,
  maxExtrap = NULL,
  thetaMhSd = NULL,
  muMhSd = NULL,
  psiMhSd = NULL,
  ageScaleVal = NULL,
  positionEps = NULL,
  positionNormalise = NULL,
  eps = NULL,
  dfs = NULL,
  type = c("BchronCalibrate", "Bchronology")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BchronCheck_+3A_ages">ages</code></td>
<td>
<p>A vector of ages provided in years before 1950.</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_agesds">ageSds</code></td>
<td>
<p>A vector of 1-sigma values for the ages given above</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_positions">positions</code></td>
<td>
<p>Position values (e.g. depths) for each age. In the case of layers of non-zero thickness, this should be the middle value of the slice</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_pathtocalcurves">pathToCalCurves</code></td>
<td>
<p>File path to where the calibration curves are located. Defaults to the system directory where the 3 standard calibration curves are stored.</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_calcurves">calCurves</code></td>
<td>
<p>A vector of values containing either <code>intcal20</code>, <code>shcal20</code>, <code>marine20</code>, or <code>normal</code> (older calibration curves are supposed such as intcal13). Should be the same length the number of ages supplied. Non-standard calibration curves can be used provided they are supplied in the same format as those previously mentioned and are placed in the same directory. Normal indicates a normally-distributed (non-14C) age.</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_positionthicknesses">positionThicknesses</code></td>
<td>
<p>Thickness values for each of the positions. The thickness value should be the full thickness value of the slice. By default set to zero.</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_ids">ids</code></td>
<td>
<p>ID names for each age</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_outlierprobs">outlierProbs</code></td>
<td>
<p>A vector of prior outlier probabilities, one for each age. Defaults to 0.01</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_predictpositions">predictPositions</code></td>
<td>
<p>A vector of positions (e.g. depths) at which predicted age values are required. Defaults to a sequence of length 100 from the top position to the bottom position</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_artificialthickness">artificialThickness</code></td>
<td>
<p>Amount to add to the thickness values in the case of equal positions with no <code>positionThicknesses</code>. Bchron may fail if <code>positionThicknesses</code> are zero and some positions are repeated. This value is added on to the zero thicknesses (only in the case of repeated positions) to stop this failure.</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_allowoutside">allowOutside</code></td>
<td>
<p>Whether to allow calibrations to run outside the range of the calibration curve. By default this is turned off as calibrations outside of the range of the calibration curve can cause severe issues with probability ranges of calibrated dates</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_iterations">iterations</code></td>
<td>
<p>The number of iterations to run the procedure for</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_thetastart">thetaStart</code></td>
<td>
<p>A set of starting values for the calendar ages estimated by Bchron. If NULL uses a function to estimate the ages. These should be in the same units as the posterior ages required. See example below for usage.</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_burn">burn</code></td>
<td>
<p>The number of starting iterations to discard</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_thin">thin</code></td>
<td>
<p>The step size for every iteration to keep beyond the burn-in</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_extractdate">extractDate</code></td>
<td>
<p>The top age of the core. Used for extrapolation purposes so that no extrapolated ages go beyond the top age of the core. Defaults to the current year</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_maxextrap">maxExtrap</code></td>
<td>
<p>The maximum number of extrapolations to perform before giving up and setting the predicted ages to NA. Useful for when large amounts of extrapolation are required, i.e. some of the <code>predictPositions</code> are a long way from the dated positions</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_thetamhsd">thetaMhSd</code></td>
<td>
<p>The Metropolis-Hastings standard deviation for the age parameters</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_mumhsd">muMhSd</code></td>
<td>
<p>The Metropolis-Hastings standard deviation for the Compound Poisson-Gamma mean</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_psimhsd">psiMhSd</code></td>
<td>
<p>The Metropolis-Hastings standard deviation for the Compound Poisson-Gamma scale</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_agescaleval">ageScaleVal</code></td>
<td>
<p>A scale value for the ages. <code>Bchronology</code> works best when the ages are scaled to be approximately between 0 and 100. The default value is thus 1000 for ages given in years.</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_positioneps">positionEps</code></td>
<td>
<p>A small value used to check whether simulated positions are far enough apart to avoid numerical underflow errors. If errors occur in model runs (e.g. <code>missing value where TRUE/FALSE needed</code> increase this value)</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_positionnormalise">positionNormalise</code></td>
<td>
<p>Whether to normalise the position values. <code>Bchronology</code> works best when the positions are normalised to be between 0 and 1 The default value is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_eps">eps</code></td>
<td>
<p>Cut-off point for density calculation. A value of eps&gt;0 removes ages from the output which have negligible probability density</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_dfs">dfs</code></td>
<td>
<p>Degrees-of-freedom values for the t-distribution associated with the calibration calculation. A large value indicates Gaussian distributions assumed for the 14C ages</p>
</td></tr>
<tr><td><code id="BchronCheck_+3A_type">type</code></td>
<td>
<p>Whether this function has been called to check parameters for calibration purposes (<code>BchronCalibrate</code>) or chronology purposes (<code>Bchronology</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns nothing other than a message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Glendalough)

# Check the Glendalough data are in the right format
with(
  Glendalough,
  BchronCheck(ages,
    ageSds,
    position,
    pathToCalCurves = system.file("data", package = "Bchron"),
    calCurves,
    type = "BchronCalibrate"
  )
)
</code></pre>

<hr>
<h2 id='BchronDensity'>Non-parametric phase model</h2><span id='topic+BchronDensity'></span>

<h3>Description</h3>

<p>This function runs a non-parametric phase model on 14C and non-14C ages via Gaussian Mixture density estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BchronDensity(
  ages,
  ageSds,
  calCurves,
  pathToCalCurves = system.file("data", package = "Bchron"),
  dfs = rep(100, length(ages)),
  numMix = 50,
  iterations = 10000,
  burn = 2000,
  thin = 8,
  updateAges = FALSE,
  store_density = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BchronDensity_+3A_ages">ages</code></td>
<td>
<p>A vector of ages (most likely 14C)</p>
</td></tr>
<tr><td><code id="BchronDensity_+3A_agesds">ageSds</code></td>
<td>
<p>A vector of 1-sigma values for the ages given above</p>
</td></tr>
<tr><td><code id="BchronDensity_+3A_calcurves">calCurves</code></td>
<td>
<p>A vector of values containing either <code>intcal20</code>, <code>shcal20</code>, <code>marine20</code>, or <code>normal</code> (older calibration curves such as intcal13 are also supported). Should be the same length the number of ages supplied. Non-standard calibration curves can be used provided they are supplied in the same format as those previously mentioned and are placed in the same directory. Normal indicates a normally-distributed (non-14C) age.</p>
</td></tr>
<tr><td><code id="BchronDensity_+3A_pathtocalcurves">pathToCalCurves</code></td>
<td>
<p>File path to where the calibration curves are located. Defaults to the system directory where the 3 standard calibration curves are stored</p>
</td></tr>
<tr><td><code id="BchronDensity_+3A_dfs">dfs</code></td>
<td>
<p>Degrees-of-freedom values for the t-distribution associated with the calibration calculation. A large value indicates Gaussian distributions assumed for the 14C ages</p>
</td></tr>
<tr><td><code id="BchronDensity_+3A_nummix">numMix</code></td>
<td>
<p>The number of mixture components in the phase model. Might need to be increased if the data set is large and the phase behaviour is very complex</p>
</td></tr>
<tr><td><code id="BchronDensity_+3A_iterations">iterations</code></td>
<td>
<p>The number of iterations to run for</p>
</td></tr>
<tr><td><code id="BchronDensity_+3A_burn">burn</code></td>
<td>
<p>The number of starting iterations to discard</p>
</td></tr>
<tr><td><code id="BchronDensity_+3A_thin">thin</code></td>
<td>
<p>The step size of iterations to keep</p>
</td></tr>
<tr><td><code id="BchronDensity_+3A_updateages">updateAges</code></td>
<td>
<p>Whether or not to update ages as part of the MCMC run. Default is FALSE. Changing this to TRUE will improve performance but will fit a slightly invalid model</p>
</td></tr>
<tr><td><code id="BchronDensity_+3A_store_density">store_density</code></td>
<td>
<p>Whether or not to store the density and age grid. Useful for plotting the output in other packages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model places a Gaussian mixture prior distribution on the calibrated ages and so estimates the density of the overall set of radiocarbon ages. It is designed to be a probabilistic version of the Oxcal SUM command which takes calibrated ages and sums the probability distributions with the aim of estimating activity through age as a proxy.
</p>


<h3>Value</h3>

<p>An object of class <code>BchronDensityRun</code> with the following elements:
</p>

<ul>
<li><p>thetaThe posterior samples of the restricted ages
</p>
</li>
<li><p>pPosterior samples of the mixture proportions
</p>
</li>
<li><p>muValues of the means of each Gaussian mixture
</p>
</li>
<li><p>calAgesThe calibrated ages from <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>
</p>
</li>
<li><p>GThe number of mixture components. Equal to numMix
</p>
</li>
<li><p>age_gridA grid of ages used for the final density estimate
</p>
</li>
<li><p>densityThe density estimate based on the above age grid
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+Bchronology">Bchronology</a></code>, <code><a href="#topic+BchronRSL">BchronRSL</a></code>, <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code> for a faster approximate version of this function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read in some data from Sluggan Moss
data(Sluggan)

# Run the model
SlugDens &lt;- with(
  Sluggan,
  BchronDensity(
    ages = ages,
    ageSds = ageSds,
    calCurves = calCurves
  )
)

# plot it
plot(SlugDens)

</code></pre>

<hr>
<h2 id='BchronDensityFast'>Non-parametric phase model (faster version)</h2><span id='topic+BchronDensityFast'></span>

<h3>Description</h3>

<p>This function runs a non-parametric phase model on 14C and non-14C ages via Gaussian Mixture density estimation through the mclust package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BchronDensityFast(
  ages,
  ageSds,
  calCurves,
  pathToCalCurves = system.file("data", package = "Bchron"),
  dfs = rep(100, length(ages)),
  samples = 2000,
  G = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BchronDensityFast_+3A_ages">ages</code></td>
<td>
<p>A vector of ages (most likely 14C)</p>
</td></tr>
<tr><td><code id="BchronDensityFast_+3A_agesds">ageSds</code></td>
<td>
<p>A vector of 1-sigma values for the ages given above</p>
</td></tr>
<tr><td><code id="BchronDensityFast_+3A_calcurves">calCurves</code></td>
<td>
<p>A vector of values containing either <code>intcal20</code>, <code>shcal20</code>, <code>marine20</code>, or <code>normal</code> (older calibration curves such as intcal13 are also supported). Should be the same length the number of ages supplied. Non-standard calibration curves can be used provided they are supplied in the same format as those previously mentioned and are placed in the same directory. Normal indicates a normally-distributed (non-14C) age.</p>
</td></tr>
<tr><td><code id="BchronDensityFast_+3A_pathtocalcurves">pathToCalCurves</code></td>
<td>
<p>File path to where the calibration curves are located. Defaults to the system directory where the 3 standard calibration curves are stored.</p>
</td></tr>
<tr><td><code id="BchronDensityFast_+3A_dfs">dfs</code></td>
<td>
<p>Degrees-of-freedom values for the t-distribution associated with the calibration calculation. A large value indicates Gaussian distributions assumed for the 14C ages</p>
</td></tr>
<tr><td><code id="BchronDensityFast_+3A_samples">samples</code></td>
<td>
<p>Number of samples of calibrated dates required</p>
</td></tr>
<tr><td><code id="BchronDensityFast_+3A_g">G</code></td>
<td>
<p>Number of Gaussian mixture components</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a faster approximate version of <code><a href="#topic+BchronDensity">BchronDensity</a></code> that uses the <code>densityMclust</code> function to compute the Gaussian mixtures for a set of calibrated ages. The method is an approximation as it does not fit a fully Bayesian model as <code><a href="#topic+BchronDensity">BchronDensity</a></code> does. It is designed to be a probabilistic version of the Oxcal SUM command which takes calibrated ages and sums the probability distributions with the aim of estimating activity through age as a proxy.
</p>


<h3>Value</h3>

<p>An object of class <code>BchronDensityRunFast</code> with the following components:
</p>
<table>
<tr><td><code>out</code></td>
<td>
<p>The output from the run of <code>densityMclust</code> with the given number of mixture components</p>
</td></tr>
<tr><td><code>calAges</code></td>
<td>
<p>The calibrated ages from the <code><a href="#topic+BchronDensity">BchronDensity</a></code> function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Bchronology">Bchronology</a></code>, <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>, <code><a href="#topic+BchronRSL">BchronRSL</a></code>, <code><a href="#topic+BchronDensity">BchronDensity</a></code> for a slower exact version of this function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read in some data from Sluggan Moss
data(Sluggan)

# Run the model
SlugDensFast &lt;- with(
  Sluggan,
  BchronDensityFast(
    ages = ages,
    ageSds = ageSds,
    calCurves = calCurves
  )
)

# plot it
plot(SlugDensFast)

</code></pre>

<hr>
<h2 id='Bchronology'>Runs the Compound Poisson-Gamma chronology model of Haslett and Parnell (2008)</h2><span id='topic+Bchronology'></span>

<h3>Description</h3>

<p>Fits a non-parametric chronology model to age/position data according to the Compound Poisson-Gamma model defined by Haslett and Parnell (2008) &lt;DOI:10.1111/j.1467-9876.2008.00623.x&gt;. This version uses a slightly modified Markov chain Monte Carlo fitting algorithm which aims to converge quicker and requires fewer iterations. It also a slightly modified procedure for identifying outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bchronology(
  ages,
  ageSds,
  positions,
  positionThicknesses = rep(0, length(ages)),
  calCurves = rep("intcal20", length(ages)),
  ids = NULL,
  outlierProbs = rep(0.01, length(ages)),
  predictPositions = seq(min(positions), max(positions), length = 100),
  pathToCalCurves = system.file("data", package = "Bchron"),
  artificialThickness = 0.01,
  allowOutside = FALSE,
  iterations = 10000,
  burn = 2000,
  thin = 8,
  extractDate = 1950 - as.numeric(format(Sys.time(), "%Y")),
  maxExtrap = 1000,
  thetaStart = NULL,
  thetaMhSd = 0.5,
  muMhSd = 0.1,
  psiMhSd = 0.1,
  ageScaleVal = 1000,
  positionEps = 1e-05,
  positionNormalise = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bchronology_+3A_ages">ages</code></td>
<td>
<p>A vector of ages provided in years before 1950.</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_agesds">ageSds</code></td>
<td>
<p>A vector of 1-sigma values for the ages given above</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_positions">positions</code></td>
<td>
<p>Position values (e.g. depths) for each age. In the case of layers of non-zero thickness, this should be the middle value of the slice</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_positionthicknesses">positionThicknesses</code></td>
<td>
<p>Thickness values for each of the positions. The thickness value should be the full thickness value of the slice. By default set to zero.</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_calcurves">calCurves</code></td>
<td>
<p>A vector of values containing either <code>intcal20</code>, <code>shcal20</code>, <code>marine20</code>, or <code>normal</code> (older calibration curves are supposed such as intcal13). Should be the same length the number of ages supplied. Non-standard calibration curves can be used provided they are supplied in the same format as those previously mentioned and are placed in the same directory. Normal indicates a normally-distributed (non-14C) age.</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_ids">ids</code></td>
<td>
<p>ID names for each age</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_outlierprobs">outlierProbs</code></td>
<td>
<p>A vector of prior outlier probabilities, one for each age. Defaults to 0.01</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_predictpositions">predictPositions</code></td>
<td>
<p>A vector of positions (e.g. depths) at which predicted age values are required. Defaults to a sequence of length 100 from the top position to the bottom position</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_pathtocalcurves">pathToCalCurves</code></td>
<td>
<p>File path to where the calibration curves are located. Defaults to the system directory where the 3 standard calibration curves are stored.</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_artificialthickness">artificialThickness</code></td>
<td>
<p>Amount to add to the thickness values in the case of equal positions with no <code>positionThicknesses</code>. Bchron may fail if <code>positionThicknesses</code> are zero and some positions are repeated. This value is added on to the zero thicknesses (only in the case of repeated positions) to stop this failure.</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_allowoutside">allowOutside</code></td>
<td>
<p>Whether to allow calibrations to run outside the range of the calibration curve. By default this is turned off as calibrations outside of the range of the calibration curve can cause severe issues with probability ranges of calibrated dates</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_iterations">iterations</code></td>
<td>
<p>The number of iterations to run the procedure for</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_burn">burn</code></td>
<td>
<p>The number of starting iterations to discard</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_thin">thin</code></td>
<td>
<p>The step size for every iteration to keep beyond the burn-in</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_extractdate">extractDate</code></td>
<td>
<p>The top age of the core. Used for extrapolation purposes so that no extrapolated ages go beyond the top age of the core. Defaults to the current year</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_maxextrap">maxExtrap</code></td>
<td>
<p>The maximum number of extrapolations to perform before giving up and setting the predicted ages to NA. Useful for when large amounts of extrapolation are required, i.e. some of the <code>predictPositions</code> are a long way from the dated positions</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_thetastart">thetaStart</code></td>
<td>
<p>A set of starting values for the calendar ages estimated by Bchron. If NULL uses a function to estimate the ages. These should be in the same units as the posterior ages required. See example below for usage.</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_thetamhsd">thetaMhSd</code></td>
<td>
<p>The Metropolis-Hastings standard deviation for the age parameters</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_mumhsd">muMhSd</code></td>
<td>
<p>The Metropolis-Hastings standard deviation for the Compound Poisson-Gamma mean</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_psimhsd">psiMhSd</code></td>
<td>
<p>The Metropolis-Hastings standard deviation for the Compound Poisson-Gamma scale</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_agescaleval">ageScaleVal</code></td>
<td>
<p>A scale value for the ages. <code>Bchronology</code> works best when the ages are scaled to be approximately between 0 and 100. The default value is thus 1000 for ages given in years.</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_positioneps">positionEps</code></td>
<td>
<p>A small value used to check whether simulated positions are far enough apart to avoid numerical underflow errors. If errors occur in model runs (e.g. <code>missing value where TRUE/FALSE needed</code> increase this value)</p>
</td></tr>
<tr><td><code id="Bchronology_+3A_positionnormalise">positionNormalise</code></td>
<td>
<p>Whether to normalise the position values. <code>Bchronology</code> works best when the positions are normalised to be between 0 and 1 The default value is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Bchronology</code> function fits a compound Poisson-Gamma distribution to the increments between the dated levels. This involves a stochastic linear interpolation step where the age gaps are Gamma distributed, and the position gaps are Exponential. Radiocarbon and non-radiocarbon dates (including outliers) are updated within the function also by MCMC.
</p>


<h3>Value</h3>

<p>A list of class <code>BchronologyRun</code> which include elements:
</p>
<table>
<tr><td><code>theta</code></td>
<td>
<p>The posterior estimated values of the ages</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>The posterior estimated outlier values (1=outlier, 2=not outlier). The means of this parameter give the posterior estimated outlier probabilities</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The posterior values of the Compound Poisson-Gamma mean</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>The posterior values of the Compound Poisson-Gamma scale</p>
</td></tr>
<tr><td><code>thetaPredict</code></td>
<td>
<p>The posterior estimated ages for each of the values in predictPosition</p>
</td></tr>
<tr><td><code>predictPositions</code></td>
<td>
<p>The positions at which estimated ages were required</p>
</td></tr>
<tr><td><code>calAges</code></td>
<td>
<p>The calibrated ages as output from <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code></p>
</td></tr>
<tr><td><code>inputVals</code></td>
<td>
<p>All of the input values to the <code>Bchronology</code> run</p>
</td></tr>
</table>


<h3>References</h3>

<p>Haslett, J., and Parnell, A. C. (2008). A simple monotone process with application to radiocarbon-dated depth chronologies. Journal of the Royal Statistical Society, Series C, 57, 399-418. DOI:10.1111/j.1467-9876.2008.00623.x
Parnell, A. C., Haslett, J., Allen, J. R. M., Buck, C. E., and Huntley, B. (2008). A flexible approach to assessing synchroneity of past events using Bayesian reconstructions of sedimentation history. Quaternary Science Reviews, 27(19-20), 1872-1885. DOI:10.1016/j.quascirev.2008.07.009
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>, <code><a href="#topic+BchronRSL">BchronRSL</a></code>, <code><a href="#topic+BchronDensity">BchronDensity</a></code>, <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data from Glendalough
data(Glendalough)

# Run in Bchronology - all but first age uses intcal20
GlenOut &lt;- with(
  Glendalough,
  Bchronology(
    ages = ages,
    ageSds = ageSds,
    calCurves = calCurves,
    positions = position,
    positionThicknesses = thickness,
    ids = id,
    predictPositions = seq(0, 1500, by = 10)
  )
)

# Summarise it a few different ways
summary(GlenOut) # Default is for quantiles of ages at predictPosition values
summary(GlenOut, type = "convergence") # Check model convergence
summary(GlenOut, type = "outliers") # Look at outlier probabilities

# Predict for some new positions
predictAges &lt;- predict(GlenOut,
  newPositions = c(150, 725, 1500),
  newPositionThicknesses = c(5, 0, 20)
)

# Plot the output
plot(GlenOut) +
  ggplot2::labs(
    title = "Glendalough",
    xlab = "Age (cal years BP)",
    ylab = "Depth (cm)"
  )

# If you need to specify your own starting values
startingAges &lt;- c(0, 2000, 10000, 11000, 13000, 13500)
GlenOut &lt;- with(
  Glendalough,
  Bchronology(
    ages = ages,
    ageSds = ageSds,
    calCurves = calCurves,
    positions = position,
    positionThicknesses = thickness,
    ids = id,
    predictPositions = seq(0, 1500, by = 10),
    thetaStart = startingAges
  )
)


</code></pre>

<hr>
<h2 id='BchronRSL'>Relative sea level rate (RSL) estimation</h2><span id='topic+BchronRSL'></span>

<h3>Description</h3>

<p>Relative sea level rate (RSL) estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BchronRSL(
  BchronologyRun,
  RSLmean,
  RSLsd,
  degree = 1,
  iterations = 10000,
  burn = 2000,
  thin = 8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BchronRSL_+3A_bchronologyrun">BchronologyRun</code></td>
<td>
<p>Output from a run of <code><a href="#topic+Bchronology">Bchronology</a></code></p>
</td></tr>
<tr><td><code id="BchronRSL_+3A_rslmean">RSLmean</code></td>
<td>
<p>A vector of RSL mean estimates of the same length as the number of predictPositions given to the <code><a href="#topic+Bchronology">Bchronology</a></code> function</p>
</td></tr>
<tr><td><code id="BchronRSL_+3A_rslsd">RSLsd</code></td>
<td>
<p>A vector RSL standard deviations of the same length as the number of predictPositions given to the <code><a href="#topic+Bchronology">Bchronology</a></code> function</p>
</td></tr>
<tr><td><code id="BchronRSL_+3A_degree">degree</code></td>
<td>
<p>The degree of the polynomial regression: linear=1 (default), quadratic=2, etc. Supports up to degree 5, though this will depend on the data given</p>
</td></tr>
<tr><td><code id="BchronRSL_+3A_iterations">iterations</code></td>
<td>
<p>The number of MCMC iterations to run</p>
</td></tr>
<tr><td><code id="BchronRSL_+3A_burn">burn</code></td>
<td>
<p>The number of starting iterations to discard</p>
</td></tr>
<tr><td><code id="BchronRSL_+3A_thin">thin</code></td>
<td>
<p>The step size of iterations to discard</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits an errors-in-variables regression model to relative sea level (RSL) data. An errors-in-variables regression model allows for uncertainty in the explanatory variable, here the age of sea level data point. The algorithm is more fully defined in the reference below
</p>


<h3>Value</h3>

<p>An object of class BchronRSLRun with elements
itemize
</p>









<h3>References</h3>

<p>Andrew C. Parnell and W. Roland Gehrels (2013) 'Using chronological models in late holocene sea level reconstructions from salt marsh sediments' In: I. Shennan, B.P. Horton, and A.J. Long (eds). Handbook of Sea Level Research. Chichester: Wiley
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>, <code><a href="#topic+Bchronology">Bchronology</a></code>, <code><a href="#topic+BchronDensity">BchronDensity</a></code>, <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load in data
data(TestChronData)
data(TestRSLData)

# Run through Bchronology
RSLrun &lt;- with(TestChronData, Bchronology(
  ages = ages,
  ageSds = ageSds,
  positions = position,
  positionThicknesses = thickness,
  ids = id,
  calCurves = calCurves,
  predictPositions = TestRSLData$Depth
))

# Now run through BchronRSL
RSLrun2 &lt;- BchronRSL(RSLrun, RSLmean = TestRSLData$RSL, RSLsd = TestRSLData$Sigma, degree = 3)

# Summarise it
summary(RSLrun2)

# Plot it
plot(RSLrun2)

</code></pre>

<hr>
<h2 id='choosePositions'>Compute positions to date next which result in maximal decrease of chronological uncertainty</h2><span id='topic+choosePositions'></span>

<h3>Description</h3>

<p>This function finds, for a given current chronology, created via
<code><a href="#topic+Bchronology">Bchronology</a></code>, which positions (depths) to date next
If N = 1 it just finds the position with the biggest uncertainty
If N&gt;1 it puts a date at the N = 1 position and re-runs
<code><a href="#topic+Bchronology">Bchronology</a></code> with the extra psuedo date. It uses the
<code><a href="#topic+unCalibrate">unCalibrate</a></code> function with the un-calibrated age estimated
at the median of the chronology and the sd as specified via the
<code>newSds</code> argument. Other arguments specify the new thicknesses,
calibration curves, and outlier probabilities for newly inserted psuedo-dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choosePositions(
  bchrRun,
  N = 1,
  newSds = 30,
  newThicknesses = 0,
  positions = bchrRun$predictPositions,
  newCalCurve = "intcal20",
  newOutlierProb = 0.05,
  level = 0.5,
  plot = TRUE,
  count = 1,
  linesAt = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choosePositions_+3A_bchrrun">bchrRun</code></td>
<td>
<p>A run of the current chronology as output from <code><a href="#topic+Bchronology">Bchronology</a></code></p>
</td></tr>
<tr><td><code id="choosePositions_+3A_n">N</code></td>
<td>
<p>The number of new positions required</p>
</td></tr>
<tr><td><code id="choosePositions_+3A_newsds">newSds</code></td>
<td>
<p>The new standard deviations of the psuedo-added dates</p>
</td></tr>
<tr><td><code id="choosePositions_+3A_newthicknesses">newThicknesses</code></td>
<td>
<p>The new thicknesses of the psuedo-added dates</p>
</td></tr>
<tr><td><code id="choosePositions_+3A_positions">positions</code></td>
<td>
<p>The positions allowed to estimate the new positions to date. Defaults to the value of <code>predictPositions</code> from the
<code><a href="#topic+Bchronology">Bchronology</a></code> run</p>
</td></tr>
<tr><td><code id="choosePositions_+3A_newcalcurve">newCalCurve</code></td>
<td>
<p>The new calibration curve of the psuedo-added dates</p>
</td></tr>
<tr><td><code id="choosePositions_+3A_newoutlierprob">newOutlierProb</code></td>
<td>
<p>The new outlier probabilities of the psuedo-added dates</p>
</td></tr>
<tr><td><code id="choosePositions_+3A_level">level</code></td>
<td>
<p>The confidence level required for minimising the uncertainty. Defaults to 50%. (Note: this will be estimated more robustly than the 95% level)</p>
</td></tr>
<tr><td><code id="choosePositions_+3A_plot">plot</code></td>
<td>
<p>Whether to plot the chronologies as they are produced</p>
</td></tr>
<tr><td><code id="choosePositions_+3A_count">count</code></td>
<td>
<p>Counter function (not for use other than by the function itself)</p>
</td></tr>
<tr><td><code id="choosePositions_+3A_linesat">linesAt</code></td>
<td>
<p>Horizontal line positions (not for use other than by the function itself)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Some plots and the positions to date next
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bchronology">Bchronology</a></code> for the main function to create chronologies, <code><a href="#topic+unCalibrate">unCalibrate</a></code> for the ability to invert calendar dates for a given calibration curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Glendalough)
GlenOut &lt;- Bchronology(
  ages = Glendalough$ages,
  ageSds = Glendalough$ageSds,
  calCurves = Glendalough$calCurves,
  positions = Glendalough$position,
  positionThicknesses = Glendalough$thickness,
  ids = Glendalough$id,
  predictPositions = seq(0, 1500, by = 10)
)

# Find out which two positions (depths) to date if we have room for two more dates
# Here going to choose 3 new positions to date
newPositions &lt;- choosePositions(GlenOut, N = 3)
print(newPositions)

# Suppose you are only interested in dating the new depths at 500, 600, or 700 cm
newPositions2 &lt;- choosePositions(GlenOut,
  N = 2,
  positions = seq(500, 700, by = 10)
)
print(newPositions2)

</code></pre>

<hr>
<h2 id='coreInfluence'>Find the influence of dates in a pair of Bchronology runs across the core</h2><span id='topic+coreInfluence'></span>

<h3>Description</h3>

<p>This function takes as input two <code><a href="#topic+Bchronology">Bchronology</a></code> runs and compares the uncertainty intervals. It does this by
computing the mean uncertainty across the core (<code>type = 'mean'</code>) at a specified percentile level (e.g. 95%) and
subsequently reporting the reduction/increase in uncertainty between the two runs. Both cores must
have the same set of depths/positions at regular intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coreInfluence(
  bchrRun1,
  bchrRun2,
  percentile = 0.95,
  type = c("plot", "summary", "max"),
  ageTolerance = 500,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coreInfluence_+3A_bchrrun1">bchrRun1</code></td>
<td>
<p>The output of a run of the <code><a href="#topic+Bchronology">Bchronology</a></code> function</p>
</td></tr>
<tr><td><code id="coreInfluence_+3A_bchrrun2">bchrRun2</code></td>
<td>
<p>The output of another run of the <code><a href="#topic+Bchronology">Bchronology</a></code> function, possibly with different dates.
Note this must have the same value of <code>predictPositions</code> as <code>bchrRun1</code></p>
</td></tr>
<tr><td><code id="coreInfluence_+3A_percentile">percentile</code></td>
<td>
<p>The value of the percentile to compare the uncertainties. Default is 95%</p>
</td></tr>
<tr><td><code id="coreInfluence_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> will return a plot of the difference in uncertainties at the specified percentile level.
If <code>summary</code> will return text output of the reduction in uncertainty at each position. If <code>max</code> will return the
position of the maximum decrease in uncertainty and a list of all the positions where the reduction in uncertainty exceeds the value of
<code>ageTolerance</code></p>
</td></tr>
<tr><td><code id="coreInfluence_+3A_agetolerance">ageTolerance</code></td>
<td>
<p>A value in years for which to report the positions at which the reduction in uncertainty exceeds this value.</p>
</td></tr>
<tr><td><code id="coreInfluence_+3A_...">...</code></td>
<td>
<p>Additional arguments to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, if the <code>ageTolerance</code> value is 500 years, then <code>coreInfluence</code> will return all of the positions at
which the uncertainty reduction is bigger than 500.
</p>


<h3>Value</h3>

<p>Depending on type will outputs some text and plots providing the influence values for the cores in question.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bchronology">Bchronology</a></code>,  <code><a href="#topic+choosePositions">choosePositions</a></code>, <code><a href="#topic+dateInfluence">dateInfluence</a></code> for finding the influence of removing a single date from a core
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Glendalough)
# Start with a run that remove two dates
GlenOut1 &lt;- Bchronology(
  ages = Glendalough$ages[-c(3:4)],
  ageSds = Glendalough$ageSds[-c(3:4)],
  calCurves = Glendalough$calCurves[-c(3:4)],
  positions = Glendalough$position[-c(3:4)],
  positionThicknesses = Glendalough$thickness[-c(3:4)],
  ids = Glendalough$id[-c(3:4)],
  predictPositions = seq(0, 1500, by = 10)
)
GlenOut2 &lt;- Bchronology(
  ages = Glendalough$ages,
  ageSds = Glendalough$ageSds,
  calCurves = Glendalough$calCurves,
  positions = Glendalough$position,
  positionThicknesses = Glendalough$thickness,
  ids = Glendalough$id,
  predictPositions = seq(0, 1500, by = 10)
)

# Now compare their influence
coreInfluence(GlenOut1,
  GlenOut2,
  type = c("max", "plot"),
  xlab = "Age (cal years BP)",
  ylab = "Depth (cm)",
  main = "Chronology difference at 95% for
              Glendalough removing two dates",
  las = 1
)

</code></pre>

<hr>
<h2 id='createCalCurve'>Create a new calibration curve</h2><span id='topic+createCalCurve'></span>

<h3>Description</h3>

<p>A function for creating a new calibration curve not already available in Bchron
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createCalCurve(
  name,
  calAges,
  uncalAges,
  oneSigma = rep(0, length(calAges)),
  pathToCalCurves = getwd(),
  createFile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createCalCurve_+3A_name">name</code></td>
<td>
<p>The name of the new calibration curve</p>
</td></tr>
<tr><td><code id="createCalCurve_+3A_calages">calAges</code></td>
<td>
<p>A vector of the calendar/calibrated ages in years before present</p>
</td></tr>
<tr><td><code id="createCalCurve_+3A_uncalages">uncalAges</code></td>
<td>
<p>A vector of values of uncalibrated ages in appropriate units (e.g. 14C years BP)</p>
</td></tr>
<tr><td><code id="createCalCurve_+3A_onesigma">oneSigma</code></td>
<td>
<p>The one sigma (one standard deviation) values in uncalibrated units. If left blank it assumes these are all zero</p>
</td></tr>
<tr><td><code id="createCalCurve_+3A_pathtocalcurves">pathToCalCurves</code></td>
<td>
<p>The path to the calibration curves. Will write by default to the working directory</p>
</td></tr>
<tr><td><code id="createCalCurve_+3A_createfile">createFile</code></td>
<td>
<p>whether to write out the new file or not. Only turned off for testing purposes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All calibration curves are stored by Bchron in the standard R gzipped text format. You can find the location of the calibration curves by typing <code>system.file('data',package='Bchron')</code>. Any created calibration curve will be converted to this format. However R packages are not allowed to write to this directory so it is up to the user to put the resulting calibration curve file in the appropriate directory. It can then be used as in the examples below. However note that re-installing Bchron will likely over-write previously created calibration curves so you should make sure to store the code used to create it. As a short-cut to copying it by hand you can instead use the <code>file.copy</code> command in the example below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load in the calibration curve with:
intcal09 &lt;- read.table(system.file("extdata/intcal09.14c", package = "Bchron"), sep = ",")
# Run createCalCurve
createCalCurve(
  name = "intcal09", calAges = intcal09[, 1],
  uncalAges = intcal09[, 2], oneSigma = intcal09[, 3]
)

# Copy the file to the right place
file.copy(
  from = "intcal09.rda",
  to = system.file("data", package = "Bchron"),
  overwrite = TRUE
) # Only need this if you've run it more than once

# Calibrate the ages under two calibration curves
age_09 &lt;- BchronCalibrate(
  ages = 15500, ageSds = 150,
  calCurves = "intcal09", ids = "My Date",
  pathToCalCurves = getwd()
)
age_20 &lt;- BchronCalibrate(ages = 15500, ageSds = 150, calCurves = "intcal20")

# Finally plot the difference
library(ggplot2)
plot(age_09) +
  geom_line(
    data = as.data.frame(age_20$Date1),
    aes(x = ageGrid, y = densities), col = "red"
  ) +
  ggtitle("Intcal09 vs Intcal20")

## End(Not run)
</code></pre>

<hr>
<h2 id='dateInfluence'>Find the influence of the dates in a Bchronology run</h2><span id='topic+dateInfluence'></span>

<h3>Description</h3>

<p>This function takes as input a <code><a href="#topic+Bchronology">Bchronology</a></code> run and allows the user to estimate a value of 'influence' for either a particular date (by name or number), for all dates in a core (<code>whichDate = 'all'</code>), or for all internal dates (<code>whichDate = 'internal'</code>). It measures the influence by either the Kullback-Leibler divergence (<code>KL</code>), the absolute mean difference (<code>absMeanDiff</code>), or the absolute median difference (<code>absMedianDiff</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dateInfluence(
  bchrRun,
  whichDate = "all",
  measure = c("KL", "absMeanDiff", "absMedianDiff")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dateInfluence_+3A_bchrrun">bchrRun</code></td>
<td>
<p>The output of a run of the <code><a href="#topic+Bchronology">Bchronology</a></code> function</p>
</td></tr>
<tr><td><code id="dateInfluence_+3A_whichdate">whichDate</code></td>
<td>
<p>The chosen date to remove. Either <code>'all'</code> which removes each date in turn, or <code>'internal'</code> which removes all but the top/bottom dates, or the date number (in the order same order as in argument 1), or the name of the date from the Bchronology run output file.</p>
</td></tr>
<tr><td><code id="dateInfluence_+3A_measure">measure</code></td>
<td>
<p>Either <code>'KL'</code> for Kullback Leibler divergence (recommended); or <code>'absMeanDiff'</code> or <code>'absMedianDiff'</code> for distances in years from the mean/median age respectively</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>KL</code> measure is preferred as it takes account of the full probability distributions but it lacks a simple interpretation. The best way to use it is with <code>whichDate = 'all'</code>: the largest value corresponds to the most influential date in the chronology. For simpler interpretation use <code>measure = 'absMeanDiff'</code> or <code>measure = 'absMedianDiff'</code> as for these the influence is measured in years.
</p>
<p>When the predictPositions from the original <code>Bchronology</code> run do not include those of the date(s) being left out then the function uses the closest position and reports the change.
</p>


<h3>Value</h3>

<p>Outputs some text providing the influence values for the date(s) in question. If given an assignment value also return a list containing all the probability distributions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bchronology">Bchronology</a></code>, <code><a href="#topic+summary.BchronologyRun">summary.BchronologyRun</a></code>, <code><a href="#topic+coreInfluence">coreInfluence</a></code>, <code><a href="#topic+choosePositions">choosePositions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Glendalough)
GlenOut &lt;- Bchronology(
  ages = Glendalough$ages,
  ageSds = Glendalough$ageSds,
  calCurves = Glendalough$calCurves,
  positions = Glendalough$position,
  positionThicknesses = Glendalough$thickness,
  ids = Glendalough$id,
  predictPositions = seq(0, 1500, by = 10)
)
dateInfluence(GlenOut, whichDate = 4, measure = "absMeanDiff")

</code></pre>

<hr>
<h2 id='Glendalough'>Glendalough data</h2><span id='topic+Glendalough'></span>

<h3>Description</h3>

<p>Chronology data for Glendalough data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Glendalough)
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 observations on the following 6 variables:
</p>

<dl>
<dt><code>id</code></dt><dd><p>ID of each age</p>
</dd>
<dt><code>ages</code></dt><dd><p>Age in (14C) years BP</p>
</dd>
<dt><code>ageSds</code></dt><dd><p>Age standard deviations</p>
</dd>
<dt><code>position</code></dt><dd><p>Depths in cm</p>
</dd>
<dt><code>thickness</code></dt><dd><p>Thicknesses in cm</p>
</dd>
<dt><code>calCurves</code></dt><dd><p>Calibration curve for each age</p>
</dd>
</dl>



<h3>Details</h3>

<p>This Glendalough data can be used with <code><a href="#topic+Bchronology">Bchronology</a></code> or <code><a href="#topic+BchronDensity">BchronDensity</a></code>
</p>


<h3>Source</h3>

<p>Haslett, J., Whiley, M., Bhattacharya, S., Mitchell, F. J. G., Allen, J. R. M., Huntley, B., \&amp; Salter-Townshend, M. (2006). Bayesian palaeoclimate reconstruction. Journal of the Royal Statistical Society, Series A, 169, 395-438.
</p>

<hr>
<h2 id='hdr'>Calculate highest density regions for Bchron calibrated ages</h2><span id='topic+hdr'></span>

<h3>Description</h3>

<p>A function for computing highest density regions (HDRs)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdr(date, prob = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hdr_+3A_date">date</code></td>
<td>
<p>A calibrated Bchron date, via e.g. <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code></p>
</td></tr>
<tr><td><code id="hdr_+3A_prob">prob</code></td>
<td>
<p>The desired probability interval, in the range(0, 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of this function is a list of contiguous ranges which cover the probability interval requested. A highest density region might have multiple such ranges if the calibrated date is multi-modal. These differ from credible intervals, which are always contiguous but will not be a good representation of a multi-modal probability distribution.
</p>


<h3>Value</h3>

<p>A list where each element is one of the contiguous sets making up the HDR
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calibrate multiple ages and summarise them
ages &lt;- BchronCalibrate(
  ages = 11553, ageSds = 230,
  calCurves = "intcal20"
)
# Get samples
hdr(ages$Date1)
</code></pre>

<hr>
<h2 id='intcal13'>Northern hemisphere 2013 calibration curve</h2><span id='topic+intcal13'></span>

<h3>Description</h3>

<p>Northern hemisphere 2013 calibration curve. The first 3 columns are the calibrated age (in years BP), the radiocarbon age (in 14C years BP), and the 1 sigma standard error (also in 14C years BP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(intcal13)
</code></pre>


<h3>Format</h3>

<p>A data frame with 5141 observations on 5 variables.
</p>


<h3>Details</h3>

<p>For full details and reference see http://intcal.org/blurb.html. For usage details see <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>
</p>

<hr>
<h2 id='intcal20'>Northern hemisphere 2020 calibration curve</h2><span id='topic+intcal20'></span>

<h3>Description</h3>

<p>Northern hemisphere 2020 calibration curve. The first 3 columns are the calibrated age (in years BP), the radiocarbon age (in 14C years BP), and the 1 sigma standard error (also in 14C years BP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(intcal20)
</code></pre>


<h3>Format</h3>

<p>A data frame with 9501 observations on 5 variables.
</p>


<h3>Details</h3>

<p>For full details and reference see http://intcal.org/blurb.html. For usage details see <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>
</p>

<hr>
<h2 id='marine13'>Marine 2013 calibration curve</h2><span id='topic+marine13'></span>

<h3>Description</h3>

<p>Marine 2013 calibration curve. The first 3 columns are the calibrated age (in years BP), the radiocarbon age (in 14C years BP), and the 1 sigma standard error (also in 14C years BP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(marine13)
</code></pre>


<h3>Format</h3>

<p>A data frame with 4801 observations on 5 variables
</p>


<h3>Details</h3>

<p>For full details and reference see http://intcal.org/blurb.html. For usage details see <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>
</p>

<hr>
<h2 id='marine20'>Marine 2020 calibration curve</h2><span id='topic+marine20'></span>

<h3>Description</h3>

<p>Marine 2020 calibration curve. The first 3 columns are the calibrated age (in years BP), the radiocarbon age (in 14C years BP), and the 1 sigma standard error (also in 14C years BP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(marine20)
</code></pre>


<h3>Format</h3>

<p>A data frame with 5501 observations on 5 variables
</p>


<h3>Details</h3>

<p>For full details and reference see http://intcal.org/blurb.html. For usage details see <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>
</p>

<hr>
<h2 id='normal'>Data for dummy calibration of normally distributed ages</h2><span id='topic+normal'></span>

<h3>Description</h3>

<p>Data for dummy calibration of normally distributed ages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(normal)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2 observations on 3 variables.
</p>


<h3>Details</h3>

<p>This is dummy data so that <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code> can calibrate normally distributed dates.
</p>

<hr>
<h2 id='plot.BchronCalibratedDates'>Plot calibrated dates from a BchronCalibrate run</h2><span id='topic+plot.BchronCalibratedDates'></span>

<h3>Description</h3>

<p>Plots calibrated radiocarbon dates from a <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code> run. Has options to plot on a position (usually depth) scale if supplied with the original run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BchronCalibratedDates'
plot(
  x,
  date = NULL,
  withPositions = ifelse(length(x) &gt; 1 &amp; !is.null(x[[1]]$positions) &amp; !includeCal,
    TRUE, FALSE),
  includeCal = FALSE,
  dateHeight = 100,
  dateLabels = TRUE,
  dateLabelSize = 2,
  nudgeX = 0,
  nudgeY = 0,
  fillCol = rgb(47/255, 79/255, 79/255, 0.5),
  withHDR = TRUE,
  ageScale = c("bp", "bc", "b2k"),
  scaleReverse = TRUE,
  pathToCalCurves = system.file("data", package = "Bchron"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BchronCalibratedDates_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code></p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_date">date</code></td>
<td>
<p>Either numbers or date names to plot (only used if multiple dates have been calibrated)</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_withpositions">withPositions</code></td>
<td>
<p>Whether to plot with positions (i.e. using the position values as the y axis). By default TRUE if <code>x</code> has more than one date and contains positions</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_includecal">includeCal</code></td>
<td>
<p>Whether to plot the date alongside the calibration curve (with 95% uncertainty bands) and the normally distributed uncalibrated date.</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_dateheight">dateHeight</code></td>
<td>
<p>The height of the dates in the plot in the same units as the position values. Only relevant if <code>withPositions=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_datelabels">dateLabels</code></td>
<td>
<p>Whether to add the names of the dates to the left of them. Default TRUE</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_datelabelsize">dateLabelSize</code></td>
<td>
<p>Size of the date labels</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_nudgex">nudgeX</code></td>
<td>
<p>The amount to move the date labels in the x direction. Can be negative. See <code><a href="ggplot2.html#topic+geom_text">geom_text</a></code> for details</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_nudgey">nudgeY</code></td>
<td>
<p>The amount to move the date labels in the y direction. Can be negative. See <code><a href="ggplot2.html#topic+geom_text">geom_text</a></code> for details</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_fillcol">fillCol</code></td>
<td>
<p>A colour to fill the date densities when <code>withPositions</code> is TRUE, or HDR ranges when it is FALSE</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_withhdr">withHDR</code></td>
<td>
<p>Whether to plot the 95% highest density region values</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_agescale">ageScale</code></td>
<td>
<p>Either <code>bp</code> for years before present, <code>bc</code> for years BC/AD (BC will be negative), <code>b2k</code> for years before 2000. Others not supported (yet).</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_scalereverse">scaleReverse</code></td>
<td>
<p>Whether to reverse the x-axis scale. Defaults to TRUE which works best for dates presented in e.g. years BP</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_pathtocalcurves">pathToCalCurves</code></td>
<td>
<p>The Bchron path to calibration curves. Defaults to the package location might need to be set to another folder if user defined calibration curves are being used</p>
</td></tr>
<tr><td><code id="plot.BchronCalibratedDates_+3A_...">...</code></td>
<td>
<p>Other arguments to plot (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These plots are intended to be pretty basic and used simply for quick information. Users are encouraged to learn the R plotting features to produce publication quality graphics
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>, <code><a href="#topic+Bchronology">Bchronology</a></code>, <code><a href="#topic+BchronRSL">BchronRSL</a></code>, <code><a href="#topic+BchronDensity">BchronDensity</a></code>, <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>
</p>

<hr>
<h2 id='plot.BchronDensityRun'>Plot output from <code>BchronDensity</code></h2><span id='topic+plot.BchronDensityRun'></span>

<h3>Description</h3>

<p>Plot output from <code>BchronDensity</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BchronDensityRun'
plot(
  x,
  plotDates = TRUE,
  plotRawSum = FALSE,
  plotPhase = TRUE,
  phaseProb = 0.95,
  dateTransparency = 0.4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BchronDensityRun_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+BchronDensity">BchronDensity</a></code></p>
</td></tr>
<tr><td><code id="plot.BchronDensityRun_+3A_plotdates">plotDates</code></td>
<td>
<p>Whether to plot the individual calibrated dates</p>
</td></tr>
<tr><td><code id="plot.BchronDensityRun_+3A_plotrawsum">plotRawSum</code></td>
<td>
<p>Whether to plot the raw sum of the probability distributions</p>
</td></tr>
<tr><td><code id="plot.BchronDensityRun_+3A_plotphase">plotPhase</code></td>
<td>
<p>Whether to plot the phase values</p>
</td></tr>
<tr><td><code id="plot.BchronDensityRun_+3A_phaseprob">phaseProb</code></td>
<td>
<p>The probability value for the phase identification</p>
</td></tr>
<tr><td><code id="plot.BchronDensityRun_+3A_datetransparency">dateTransparency</code></td>
<td>
<p>The transparency value for the dates (default 0.4)</p>
</td></tr>
<tr><td><code id="plot.BchronDensityRun_+3A_...">...</code></td>
<td>
<p>Other graphical commands. See <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See  <code><a href="#topic+BchronDensity">BchronDensity</a></code> for examples, also <code><a href="#topic+Bchronology">Bchronology</a></code>, <code><a href="#topic+BchronRSL">BchronRSL</a></code>, and <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code> for a faster approximate version of this function
</p>

<hr>
<h2 id='plot.BchronDensityRunFast'>Plot run from <code>BchronDensityFast</code></h2><span id='topic+plot.BchronDensityRunFast'></span>

<h3>Description</h3>

<p>Plots output from <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BchronDensityRunFast'
plot(x, plotDates = TRUE, plotSum = FALSE, dateTransparency = 0.4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BchronDensityRunFast_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code></p>
</td></tr>
<tr><td><code id="plot.BchronDensityRunFast_+3A_plotdates">plotDates</code></td>
<td>
<p>Whether to include individual age pdfs (default TRUE)</p>
</td></tr>
<tr><td><code id="plot.BchronDensityRunFast_+3A_plotsum">plotSum</code></td>
<td>
<p>Whether to include sum of age pdfs (default FALSE)</p>
</td></tr>
<tr><td><code id="plot.BchronDensityRunFast_+3A_datetransparency">dateTransparency</code></td>
<td>
<p>The transparency value for the dates (default 0.4)</p>
</td></tr>
<tr><td><code id="plot.BchronDensityRunFast_+3A_...">...</code></td>
<td>
<p>Other graphical parameters, see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a basic plot of output for a run of <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>
</p>


<h3>See Also</h3>

<p>Examples in <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>, and see <code><a href="#topic+BchronDensity">BchronDensity</a></code>, for a slower, more accurate version of this function
</p>

<hr>
<h2 id='plot.BchronologyRun'>Plot output from Bchronology</h2><span id='topic+plot.BchronologyRun'></span>

<h3>Description</h3>

<p>Plots output from a run of <code><a href="#topic+Bchronology">Bchronology</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BchronologyRun'
plot(
  x,
  dateHeight = 100,
  dateLabels = TRUE,
  dateLabelSize = 2,
  dateCol = rgb(47/255, 79/255, 79/255, 0.5),
  chronCol = "deepskyblue4",
  chronTransparency = 0.75,
  alpha = 0.95,
  nudgeX = 0,
  nudgeY = 0,
  expandX = if (dateLabels) {     c(0.1, 0) } else {     c(0, 0) },
  expandY = c(0.05, 0),
  ageScale = c("bp", "bc", "b2k"),
  scaleReverse = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BchronologyRun_+3A_x">x</code></td>
<td>
<p>The object created by <code><a href="#topic+Bchronology">Bchronology</a></code></p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_dateheight">dateHeight</code></td>
<td>
<p>The height of the dates in the plot (on the same scale as the positions)</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_datelabels">dateLabels</code></td>
<td>
<p>Whether to label the dates on the vertical axis (default TRUE)</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_datelabelsize">dateLabelSize</code></td>
<td>
<p>The size of the date labels</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_datecol">dateCol</code></td>
<td>
<p>The colour of the date labels</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_chroncol">chronCol</code></td>
<td>
<p>The colour of the chronology uncertainty ribbon to be plotted</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_chrontransparency">chronTransparency</code></td>
<td>
<p>The amount of transparency for the chronology ribbon</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_alpha">alpha</code></td>
<td>
<p>The credible interval of the chronology run to be plotted. Defaults to 95 percent</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_nudgex">nudgeX</code></td>
<td>
<p>The amount to move the date labels in the x direction. Can be negative. See <code><a href="ggplot2.html#topic+geom_text">geom_text</a></code> for details</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_nudgey">nudgeY</code></td>
<td>
<p>The amount to move the date labels in the y direction. Can be negative. See <code><a href="ggplot2.html#topic+geom_text">geom_text</a></code> for details</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_expandx">expandX</code></td>
<td>
<p>The amount to expand the horizontal axis in case part are missed off the plot. See <code><a href="ggplot2.html#topic+expand_limits">expand_limits</a></code> for details</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_expandy">expandY</code></td>
<td>
<p>The amount to expand the vertical axis in case part are missed off the plot. See <code><a href="ggplot2.html#topic+expand_limits">expand_limits</a></code> for details</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_agescale">ageScale</code></td>
<td>
<p>Either <code>bp</code> for years before present, <code>bc</code> for years BC/AD (BC will be negative), <code>b2k</code> for years before 2000. Others not supported (yet).</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_scalereverse">scaleReverse</code></td>
<td>
<p>Whether to reverse the x-axis scale. Defaults to TRUE which works best for dates presented in e.g. years BP</p>
</td></tr>
<tr><td><code id="plot.BchronologyRun_+3A_...">...</code></td>
<td>
<p>Other arguments to plot (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a simple plot of the chronology output. The height of the date densities in the plots can be manipulated via the <code>dateHeight</code> argument which is represented in the same units as the positions/depths provided. More detailed plots can be created by manipulating the Bchronology object as required.
</p>


<h3>See Also</h3>

<p>For examples see <code><a href="#topic+Bchronology">Bchronology</a></code>. Also <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>, <code><a href="#topic+BchronRSL">BchronRSL</a></code>, <code><a href="#topic+BchronDensity">BchronDensity</a></code>, <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>
</p>

<hr>
<h2 id='plot.BchronRSLRun'>Plot output from BchronRSL</h2><span id='topic+plot.BchronRSLRun'></span>

<h3>Description</h3>

<p>Plot output from the <code><a href="#topic+BchronRSL">BchronRSL</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BchronRSLRun'
plot(
  x,
  type = c("RSL", "rate", "accel"),
  alpha = 0.95,
  ellipseCol = "darkslategray",
  lineCol = "deepskyblue4",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BchronRSLRun_+3A_x">x</code></td>
<td>
<p>An object created by <code><a href="#topic+BchronRSL">BchronRSL</a></code></p>
</td></tr>
<tr><td><code id="plot.BchronRSLRun_+3A_type">type</code></td>
<td>
<p>One of <code>RSL</code>, <code>rate</code>, or <code>accel</code>. If <code>RSL</code> produces a plot of RSL estimates from the model. If <code>rate</code>, produces rate estimates. If <code>accel</code> produces acceleration estimates.</p>
</td></tr>
<tr><td><code id="plot.BchronRSLRun_+3A_alpha">alpha</code></td>
<td>
<p>confidence level used for plotting ellipses</p>
</td></tr>
<tr><td><code id="plot.BchronRSLRun_+3A_ellipsecol">ellipseCol</code></td>
<td>
<p>The colour of the ellipse used for plotting dates</p>
</td></tr>
<tr><td><code id="plot.BchronRSLRun_+3A_linecol">lineCol</code></td>
<td>
<p>The colour of the sea level curve lines</p>
</td></tr>
<tr><td><code id="plot.BchronRSLRun_+3A_...">...</code></td>
<td>
<p>Other arguments to plot (currently ignored)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>, <code><a href="#topic+Bchronology">Bchronology</a></code>, <code><a href="#topic+BchronRSL">BchronRSL</a></code>, <code><a href="#topic+BchronDensity">BchronDensity</a></code>, <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>
</p>

<hr>
<h2 id='predict.BchronologyRun'>Predict ages of other positions for a BchronologyRun object</h2><span id='topic+predict.BchronologyRun'></span>

<h3>Description</h3>

<p>This function will predict the ages of new positions (usually depths) based on a previous run of the function <code><a href="#topic+Bchronology">Bchronology</a></code>. It will also allow for thickness uncertainties to be included in the resulting ages, for example when the age of a particular event is desired
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BchronologyRun'
predict(
  object,
  newPositions,
  newPositionThicknesses = NULL,
  maxExtrap = 500,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.BchronologyRun_+3A_object">object</code></td>
<td>
<p>Output from a run of <code><a href="#topic+Bchronology">Bchronology</a></code></p>
</td></tr>
<tr><td><code id="predict.BchronologyRun_+3A_newpositions">newPositions</code></td>
<td>
<p>A vector of new positions at which to find ages</p>
</td></tr>
<tr><td><code id="predict.BchronologyRun_+3A_newpositionthicknesses">newPositionThicknesses</code></td>
<td>
<p>A vector of thicknesses for the above positions. Must be the same length as <code>newPositions</code></p>
</td></tr>
<tr><td><code id="predict.BchronologyRun_+3A_maxextrap">maxExtrap</code></td>
<td>
<p>The maximum new of extrapolation attempts. It might be worth increasing this if you are extrapolating a long way from the other dated positions</p>
</td></tr>
<tr><td><code id="predict.BchronologyRun_+3A_...">...</code></td>
<td>
<p>Other arguments to predict (not currently supported)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension num_samples by num_positions so that each row represents a set of monotonic sample predicted ages
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>, <code><a href="#topic+Bchronology">Bchronology</a></code> <code><a href="#topic+BchronRSL">BchronRSL</a></code>, <code><a href="#topic+BchronDensity">BchronDensity</a></code>, <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>
</p>

<hr>
<h2 id='sampleAges'>Get sample ages from a set of Bchron calibrated dates</h2><span id='topic+sampleAges'></span>

<h3>Description</h3>

<p>A function for extracting sample ages from Bchron calibrated dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleAges(CalDates, n_samp = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleAges_+3A_caldates">CalDates</code></td>
<td>
<p>A list created from either <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>.</p>
</td></tr>
<tr><td><code id="sampleAges_+3A_n_samp">n_samp</code></td>
<td>
<p>The desired number of samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes it is useful to have a set of sample calendar ages for your calibrated dates. For example the samples might be required to create a credible/confidence interval, or to create another non-trivial function of calibrated dates, such as differences. By default the <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code> function provides a grid of ages and an associated density, similar to OxCal. This function extracts that information and uses the <code><a href="base.html#topic+sample">sample</a></code> function to output the desired number of samples
</p>


<h3>Value</h3>

<p>A vector of length <code>n_samp</code> containing sample ages for the specified date
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calibrate multiple ages and summarise them
ages &lt;- BchronCalibrate(
  ages = c(3445, 11553, 7456), ageSds = c(50, 230, 110),
  calCurves = c("intcal20", "intcal20", "shcal20")
)
# Get samples
age_samples &lt;- sampleAges(ages)
# Create a credible interval and the median for each date
apply(age_samples, 2, quantile, probs = c(0.05, 0.5, 0.95))
</code></pre>

<hr>
<h2 id='shcal13'>Southern hemisphere 2013 calibration curve</h2><span id='topic+shcal13'></span>

<h3>Description</h3>

<p>Southern hemisphere 2013 calibration curve. The first 3 columns are the calibrated age (in years BP), the radiocarbon age (in 14C years BP), and the 1 sigma standard error (also in 14C years BP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shcal13)
</code></pre>


<h3>Format</h3>

<p>A data frame with 5141 observations on 5 variables.
</p>


<h3>Details</h3>

<p>For full details and reference see http://intcal.org/blurb.html. For usage details see <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>
</p>

<hr>
<h2 id='shcal20'>Southern hemisphere 2020 calibration curve</h2><span id='topic+shcal20'></span>

<h3>Description</h3>

<p>Southern hemisphere 2020 calibration curve. The first 3 columns are the calibrated age (in years BP), the radiocarbon age (in 14C years BP), and the 1 sigma standard error (also in 14C years BP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shcal20)
</code></pre>


<h3>Format</h3>

<p>A data frame with 9501 observations on 5 variables.
</p>


<h3>Details</h3>

<p>For full details and reference see http://intcal.org/blurb.html. For usage details see <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>
</p>

<hr>
<h2 id='Sluggan'>Sluggan Moss data</h2><span id='topic+Sluggan'></span>

<h3>Description</h3>

<p>Chronology data for Sluggan Moss data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Sluggan)
</code></pre>


<h3>Format</h3>

<p>A data frame with 31 observations on the following 6 variables:
</p>

<dl>
<dt><code>id</code></dt><dd><p>ID of each age</p>
</dd>
<dt><code>ages</code></dt><dd><p>Age in (14C) years BP</p>
</dd>
<dt><code>ageSds</code></dt><dd><p>Age standard deviations</p>
</dd>
<dt><code>position</code></dt><dd><p>Depths in cm</p>
</dd>
<dt><code>thickness</code></dt><dd><p>Thicknesses in cm</p>
</dd>
<dt><code>calCurves</code></dt><dd><p>Calibration curve for each age</p>
</dd>
</dl>



<h3>Details</h3>

<p>This Sluggan Moss data can be downloaded from the European Pollen Database: <a href="http://www.europeanpollendatabase.net">http://www.europeanpollendatabase.net</a>. For usage see <code><a href="#topic+Bchronology">Bchronology</a></code> or <code><a href="#topic+BchronDensity">BchronDensity</a></code>
</p>


<h3>Source</h3>

<p>Smith, A. G., \&amp; Goddard, I. C. (1991). A 12,500 year record of vegetational history at Sluggan Bog, Co. Antrim, N. Ireland (incorporating a pollen zone scheme for the non-specialist). New Phytologist, 118, 167-187.
</p>

<hr>
<h2 id='summary.BchronCalibratedDates'>Summarise a BchronCalibrate object</h2><span id='topic+summary.BchronCalibratedDates'></span>

<h3>Description</h3>

<p>Produces summary output from a <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code> run, including the highest density regions for the calibrated ages for given probability levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BchronCalibratedDates'
summary(object, prob = 95, ..., digits = max(3, getOption("digits") - 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BchronCalibratedDates_+3A_object">object</code></td>
<td>
<p>The output of a run of <code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code></p>
</td></tr>
<tr><td><code id="summary.BchronCalibratedDates_+3A_prob">prob</code></td>
<td>
<p>A percentage value (between 0 and 100) at which the highest density regions for each age are calculated</p>
</td></tr>
<tr><td><code id="summary.BchronCalibratedDates_+3A_...">...</code></td>
<td>
<p>Further arguments (not currently supported)</p>
</td></tr>
<tr><td><code id="summary.BchronCalibratedDates_+3A_digits">digits</code></td>
<td>
<p>Significant digits to display (not currently supported)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>, <code><a href="#topic+Bchronology">Bchronology</a></code>, <code><a href="#topic+BchronRSL">BchronRSL</a></code>, <code><a href="#topic+BchronDensity">BchronDensity</a></code>, <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>
</p>

<hr>
<h2 id='summary.BchronDensityRun'>Summarise a Bchron density object</h2><span id='topic+summary.BchronDensityRun'></span>

<h3>Description</h3>

<p>Summarise a <code><a href="#topic+BchronDensity">BchronDensity</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BchronDensityRun'
summary(object, prob = 0.95, ..., digits = max(3, getOption("digits") - 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BchronDensityRun_+3A_object">object</code></td>
<td>
<p>Output from a run of <code><a href="#topic+BchronDensity">BchronDensity</a></code></p>
</td></tr>
<tr><td><code id="summary.BchronDensityRun_+3A_prob">prob</code></td>
<td>
<p>Probability for identifying phases</p>
</td></tr>
<tr><td><code id="summary.BchronDensityRun_+3A_...">...</code></td>
<td>
<p>Other arguments (not currently supported)</p>
</td></tr>
<tr><td><code id="summary.BchronDensityRun_+3A_digits">digits</code></td>
<td>
<p>Number of digits to report values</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+BchronDensity">BchronDensity</a></code>
</p>

<hr>
<h2 id='summary.BchronologyRun'>Summarise a Bchronology object</h2><span id='topic+summary.BchronologyRun'></span>

<h3>Description</h3>

<p>Summarise a <code><a href="#topic+Bchronology">Bchronology</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BchronologyRun'
summary(
  object,
  type = c("quantiles", "outliers", "convergence", "sed_rate", "acc_rate", "max_var"),
  probs = c(0.025, 0.25, 0.5, 0.75, 0.975),
  useExisting = TRUE,
  numPos = 3,
  ...,
  digits = max(3, getOption("digits") - 3)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BchronologyRun_+3A_object">object</code></td>
<td>
<p>Output from a run of <code><a href="#topic+Bchronology">Bchronology</a></code></p>
</td></tr>
<tr><td><code id="summary.BchronologyRun_+3A_type">type</code></td>
<td>
<p>Type of output required. The default (quantiles) gives the quantiles of the ages for each position in <code>predictPositions</code> from <code><a href="#topic+Bchronology">Bchronology</a></code>. The other options provide outlier probabilities, convergence diagnostics, accumulation rates, sedimentation rate, and positions of maximum age variance</p>
</td></tr>
<tr><td><code id="summary.BchronologyRun_+3A_probs">probs</code></td>
<td>
<p>Probabilities (between 0 and 1) at which to summarise the predicted chronologies</p>
</td></tr>
<tr><td><code id="summary.BchronologyRun_+3A_useexisting">useExisting</code></td>
<td>
<p>Whether to use the predicted chronologies/positions to calculate the sedimentation rate (if TRUE - default) or to re-create them based on a unit-scaled position grid (if FALSE). The latter will be a little bit slower but will provide better sedimentation rate estimates if the original positions are not on a unit scale (e.g. each cm)</p>
</td></tr>
<tr><td><code id="summary.BchronologyRun_+3A_numpos">numPos</code></td>
<td>
<p>The number of positions at which to provide the maximum variance</p>
</td></tr>
<tr><td><code id="summary.BchronologyRun_+3A_...">...</code></td>
<td>
<p>Other arguments (not currently supported)</p>
</td></tr>
<tr><td><code id="summary.BchronologyRun_+3A_digits">digits</code></td>
<td>
<p>Number of digits to report values</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>, <code><a href="#topic+Bchronology">Bchronology</a></code> <code><a href="#topic+BchronRSL">BchronRSL</a></code>, <code><a href="#topic+BchronDensity">BchronDensity</a></code>, <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>
</p>

<hr>
<h2 id='summary.BchronRSLRun'>Summarise a BchronRSL run</h2><span id='topic+summary.BchronRSLRun'></span>

<h3>Description</h3>

<p>Summarise a <code><a href="#topic+BchronRSL">BchronRSL</a></code> run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BchronRSLRun'
summary(
  object,
  type = c("parameters", "RSL", "rate", "accel"),
  age_grid = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BchronRSLRun_+3A_object">object</code></td>
<td>
<p>The output from a run of <code><a href="#topic+BchronRSL">BchronRSL</a></code></p>
</td></tr>
<tr><td><code id="summary.BchronRSLRun_+3A_type">type</code></td>
<td>
<p>One of <code>parameters</code>, <code>RSL</code>, <code>rate</code>, or <code>accel</code>. If <code>parameters</code>, provides posterior credibility intervals of the regression coefficients. If <code>RSL</code> provides predicted RSL values. If <code>rate</code>, provides rate estimates. If <code>accel</code> provides acceleration estimates.</p>
</td></tr>
<tr><td><code id="summary.BchronRSLRun_+3A_age_grid">age_grid</code></td>
<td>
<p>An optional age grid for computing RSL, rate, or acceleration estimates. If not provided uses the age range of the Bchronology run</p>
</td></tr>
<tr><td><code id="summary.BchronRSLRun_+3A_...">...</code></td>
<td>
<p>Other arguments to functions (not currently implemented)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+BchronCalibrate">BchronCalibrate</a></code>, <code><a href="#topic+Bchronology">Bchronology</a></code>, <code><a href="#topic+BchronRSL">BchronRSL</a></code>, <code><a href="#topic+BchronDensity">BchronDensity</a></code>, <code><a href="#topic+BchronDensityFast">BchronDensityFast</a></code>
</p>

<hr>
<h2 id='TestChronData'>Example chronology file for use with the BchronRSL function.</h2><span id='topic+TestChronData'></span>

<h3>Description</h3>

<p>Some example chronology data for use with the <code><a href="#topic+BchronRSL">BchronRSL</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TestChronData)
</code></pre>


<h3>Format</h3>

<p>A data frame with 27 observations on the following 6 variables:
</p>

<dl>
<dt><code>id</code></dt><dd><p>ID names</p>
</dd>
<dt><code>ages</code></dt><dd><p>Ages in years BP</p>
</dd>
<dt><code>ageSds</code></dt><dd><p>Ages standard deviations in years BP</p>
</dd>
<dt><code>position</code></dt><dd><p>Depths in cm</p>
</dd>
<dt><code>thickness</code></dt><dd><p>Thicknesses in cm</p>
</dd>
<dt><code>calCurves</code></dt><dd><p>Calibration curve for each age</p>
</dd>
</dl>



<h3>Source</h3>

<p>Andrew C. Parnell and W. Roland Gehrels (2013) 'Using chronological models in late holocene sea level reconstructions from salt marsh sediments' In: I. Shennan, B.P. Horton, and A.J. Long (eds). Handbook of Sea Level Research. Chichester: Wiley
</p>

<hr>
<h2 id='TestRSLData'>Relative sea level data</h2><span id='topic+TestRSLData'></span>

<h3>Description</h3>

<p>A set of relative sea level data for use with <code><a href="#topic+BchronRSL">BchronRSL</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TestRSLData)
</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on the following 3 variables:
</p>

<dl>
<dt><code>Depth</code></dt><dd><p>Depth in cm</p>
</dd>
<dt><code>RSL</code></dt><dd><p>Relative sea level in m</p>
</dd>
<dt><code>Sigma</code></dt><dd><p>Standard deviation of RSL measurement</p>
</dd>
</dl>



<h3>Source</h3>

<p>Andrew C. Parnell and W. Roland Gehrels (2013) 'Using chronological models in late holocene sea level reconstructions from salt marsh sediments' In: I. Shennan, B.P. Horton, and A.J. Long (eds). Handbook of Sea Level Research. Chichester: Wiley
</p>

<hr>
<h2 id='unCalibrate'>Uncalibrate a Radiocarbon date</h2><span id='topic+unCalibrate'></span>

<h3>Description</h3>

<p>Uncalibrate a Radiocarbon date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unCalibrate(
  calAges,
  calCurve = "intcal20",
  type = c("samples", "ages"),
  pathToCalCurves = system.file("data", package = "Bchron"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unCalibrate_+3A_calages">calAges</code></td>
<td>
<p>Either a vector of calibrated ages (when <code>type = 'ages'</code>), or a vector of calibrated samples (<code>type = 'samples'</code>)</p>
</td></tr>
<tr><td><code id="unCalibrate_+3A_calcurve">calCurve</code></td>
<td>
<p>he calibration curve to use. Only a single calibration curve is currently supported</p>
</td></tr>
<tr><td><code id="unCalibrate_+3A_type">type</code></td>
<td>
<p>Either 'ages' which uncalibrates a calibrated age values without error (i.e. just a lookup on the calibration curve), or a 'samples' which estimates both an uncalibrated mean age and a standard deviation</p>
</td></tr>
<tr><td><code id="unCalibrate_+3A_pathtocalcurves">pathToCalCurves</code></td>
<td>
<p>The path to the calibration curve directory. Defaults to the location of the standard calibration curves given in the package</p>
</td></tr>
<tr><td><code id="unCalibrate_+3A_...">...</code></td>
<td>
<p>Other arguments to the <code><a href="stats.html#topic+optim">optim</a></code> function used to match the probability distributions under <code>type = 'samples'</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a vector of uncalibrated ages (<code>type = 'ages'</code>) or a list containing the estimated mean age and standard deviation (<code>type = 'samples'</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Single version outputting just an uncalibrated age
unCalibrate(2350, type = "ages")

# Vector version giving a vector of uncalibrated ages
unCalibrate(
  calAge = c(2350, 4750, 11440),
  calCurve = "shcal20",
  type = "ages"
)

# A version where calibrated standard deviations are required too
calAge &lt;- BchronCalibrate(
  ages = 11255,
  ageSds = 25,
  calCurves = "intcal20"
)
calSampleAges &lt;- sampleAges(calAge)

# Uncalibrate the above
unCalibrate(calSampleAges,
  type = "samples"
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
