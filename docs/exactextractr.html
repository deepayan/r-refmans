<!DOCTYPE html><html><head><title>Help for package exactextractr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {exactextractr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.resultColumns'><p>Return column names to be used for summary operations</p></a></li>
<li><a href='#.valueWeightIndexes'><p>Compute indexes for the value and weight layers that should be</p>
processed together</a></li>
<li><a href='#coverage_fraction'><p>Compute the fraction of raster cells covered by a polygon</p></a></li>
<li><a href='#exact_extract'><p>Extract or summarize values from rasters</p></a></li>
<li><a href='#exact_resample'><p>Resample a raster to a new grid</p></a></li>
<li><a href='#exactextractr-package'><p>exactextractr: Fast Extraction from Raster Datasets using Polygons</p></a></li>
<li><a href='#rasterize_polygons'><p>Create a raster approximation of a polygon coverage</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fast Extraction from Raster Datasets using Polygons</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Quickly and accurately summarizes raster values over polygonal areas ("zonal statistics").</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GEOS (&gt;= 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.12), methods, raster, sf (&ge; 0.9.0),</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://isciences.gitlab.io/exactextractr/">https://isciences.gitlab.io/exactextractr/</a>,
<a href="https://github.com/isciences/exactextractr">https://github.com/isciences/exactextractr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/isciences/exactextractr/issues">https://github.com/isciences/exactextractr/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, foreign, knitr, ncdf4, rmarkdown, testthat, terra (&ge;
1.5.17)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-12 15:54:24 UTC; dan</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Baston [aut, cre],
  ISciences, LLC [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Baston &lt;dbaston@isciences.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-20 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.resultColumns'>Return column names to be used for summary operations</h2><span id='topic+.resultColumns'></span>

<h3>Description</h3>

<p>Return column names to be used for summary operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.resultColumns(
  value_names,
  weight_names,
  fun,
  full_colnames,
  quantiles = numeric(),
  unique_values = numeric(),
  colname_fun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".resultColumns_+3A_value_names">value_names</code></td>
<td>
<p>names of value raster layers</p>
</td></tr>
<tr><td><code id=".resultColumns_+3A_weight_names">weight_names</code></td>
<td>
<p>names of weighting raster layers</p>
</td></tr>
<tr><td><code id=".resultColumns_+3A_fun">fun</code></td>
<td>
<p>functions or names of summary operations</p>
</td></tr>
<tr><td><code id=".resultColumns_+3A_full_colnames">full_colnames</code></td>
<td>
<p>return a complete column name even when there is no
ambiguity?</p>
</td></tr>
<tr><td><code id=".resultColumns_+3A_quantiles">quantiles</code></td>
<td>
<p>quantiles to use when <code>stat_names</code> contains <code>quantile</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of column names
</p>

<hr>
<h2 id='.valueWeightIndexes'>Compute indexes for the value and weight layers that should be
processed together</h2><span id='topic+.valueWeightIndexes'></span>

<h3>Description</h3>

<p>Compute indexes for the value and weight layers that should be
processed together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.valueWeightIndexes(num_values, num_weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".valueWeightIndexes_+3A_num_values">num_values</code></td>
<td>
<p>number of layers in value raster</p>
</td></tr>
<tr><td><code id=".valueWeightIndexes_+3A_num_weights">num_weights</code></td>
<td>
<p>number of layers in weighting raster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with <code>values</code> and <code>weights</code> elements
providing layer indexes
</p>

<hr>
<h2 id='coverage_fraction'>Compute the fraction of raster cells covered by a polygon</h2><span id='topic+coverage_fraction'></span><span id='topic+coverage_fraction+2CRasterLayer+2Csf-method'></span><span id='topic+coverage_fraction+2CRasterLayer+2Csfc_MULTIPOLYGON-method'></span><span id='topic+coverage_fraction+2CRasterLayer+2Csfc_POLYGON-method'></span><span id='topic+coverage_fraction+2CSpatRaster+2Csf-method'></span><span id='topic+coverage_fraction+2CSpatRaster+2Csfc_MULTIPOLYGON-method'></span><span id='topic+coverage_fraction+2CSpatRaster+2Csfc_POLYGON-method'></span>

<h3>Description</h3>

<p>Compute the fraction of raster cells covered by a polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer,sf'
coverage_fraction(x, y, crop = FALSE)

## S4 method for signature 'RasterLayer,sfc_MULTIPOLYGON'
coverage_fraction(x, y, crop)

## S4 method for signature 'RasterLayer,sfc_POLYGON'
coverage_fraction(x, y, crop)

## S4 method for signature 'SpatRaster,sf'
coverage_fraction(x, y, crop = FALSE)

## S4 method for signature 'SpatRaster,sfc_MULTIPOLYGON'
coverage_fraction(x, y, crop)

## S4 method for signature 'SpatRaster,sfc_POLYGON'
coverage_fraction(x, y, crop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coverage_fraction_+3A_x">x</code></td>
<td>
<p>a (possibly empty) <code>RasterLayer</code> whose resolution and
extent will be used for the generated <code>RasterLayer</code>.</p>
</td></tr>
<tr><td><code id="coverage_fraction_+3A_y">y</code></td>
<td>
<p>a <code>sf</code> object with polygonal geometries</p>
</td></tr>
<tr><td><code id="coverage_fraction_+3A_crop">crop</code></td>
<td>
<p>if <code>TRUE</code>, each generated <code>RasterLayer</code> will be
cropped to the extent of its associated feature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a <code>RasterLayer</code> for each feature in <code>y</code>.
Values of the raster represent the fraction of each
cell in <code>x</code> that is covered by <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rast &lt;- raster::raster(matrix(1:100, ncol=10), xmn=0, ymn=0, xmx=10, ymx=10)
poly &lt;- sf::st_as_sfc('POLYGON ((2 2, 7 6, 4 9, 2 2))')

cov_frac &lt;- coverage_fraction(rast, poly)[[1]]
</code></pre>

<hr>
<h2 id='exact_extract'>Extract or summarize values from rasters</h2><span id='topic+exact_extract'></span><span id='topic+exact_extract+2CRaster+2Csf-method'></span><span id='topic+exact_extract+2CRaster+2CSpatialPolygonsDataFrame-method'></span><span id='topic+exact_extract+2CRaster+2CSpatialPolygons-method'></span><span id='topic+exact_extract+2CRaster+2Csfc_MULTIPOLYGON-method'></span><span id='topic+exact_extract+2CRaster+2Csfc_POLYGON-method'></span><span id='topic+exact_extract+2CRaster+2Csfc_GEOMETRY-method'></span><span id='topic+exact_extract+2CRaster+2Csfc_GEOMETRYCOLLECTION-method'></span><span id='topic+exact_extract+2CSpatRaster+2Csf-method'></span><span id='topic+exact_extract+2CSpatRaster+2CSpatialPolygonsDataFrame-method'></span><span id='topic+exact_extract+2CSpatRaster+2CSpatialPolygons-method'></span><span id='topic+exact_extract+2CSpatRaster+2Csfc_MULTIPOLYGON-method'></span><span id='topic+exact_extract+2CSpatRaster+2Csfc_POLYGON-method'></span><span id='topic+exact_extract+2CSpatRaster+2Csfc_GEOMETRY-method'></span><span id='topic+exact_extract+2CSpatRaster+2Csfc_GEOMETRYCOLLECTION-method'></span>

<h3>Description</h3>

<p>Extracts the values of cells in a raster (<code>RasterLayer</code>, <code>RasterStack</code>
<code>RasterBrick</code>, or <code>SpatRaster</code>) that are covered by polygons in a
simple feature collection (<code>sf</code> or <code>sfc</code>) or <code>SpatialPolygonsDataFrame</code>.
Returns either a summary of the extracted values or the extracted values
themselves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster,sf'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'Raster,SpatialPolygonsDataFrame'
exact_extract(x, y, ...)

## S4 method for signature 'Raster,SpatialPolygons'
exact_extract(x, y, ...)

## S4 method for signature 'Raster,sfc_MULTIPOLYGON'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'Raster,sfc_POLYGON'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'Raster,sfc_GEOMETRY'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'Raster,sfc_GEOMETRYCOLLECTION'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'SpatRaster,sf'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'SpatRaster,SpatialPolygonsDataFrame'
exact_extract(x, y, ...)

## S4 method for signature 'SpatRaster,SpatialPolygons'
exact_extract(x, y, ...)

## S4 method for signature 'SpatRaster,sfc_MULTIPOLYGON'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'SpatRaster,sfc_POLYGON'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'SpatRaster,sfc_GEOMETRY'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)

## S4 method for signature 'SpatRaster,sfc_GEOMETRYCOLLECTION'
exact_extract(
  x,
  y,
  fun = NULL,
  ...,
  weights = NULL,
  append_cols = NULL,
  coverage_area = FALSE,
  default_value = NA_real_,
  default_weight = NA_real_,
  include_area = FALSE,
  include_cell = FALSE,
  include_cols = NULL,
  include_xy = FALSE,
  force_df = FALSE,
  full_colnames = FALSE,
  stack_apply = FALSE,
  summarize_df = FALSE,
  quantiles = NULL,
  progress = TRUE,
  max_cells_in_memory = 3e+07,
  grid_compat_tol = 0.001,
  colname_fun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exact_extract_+3A_x">x</code></td>
<td>
<p>a <code>RasterLayer</code>, <code>RasterStack</code>, <code>RasterBrick</code>, or <code>SpatRaster</code></p>
</td></tr>
<tr><td><code id="exact_extract_+3A_y">y</code></td>
<td>
<p>a <code>sf</code>, <code>sfc</code>, <code>SpatialPolygonsDataFrame</code>, or <code>SpatialPolygons</code>
object with polygonal geometries</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_fun">fun</code></td>
<td>
<p>an optional function or character vector, as described below</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code>fun</code></p>
</td></tr>
<tr><td><code id="exact_extract_+3A_weights">weights</code></td>
<td>
<p>a weighting raster to be used with the <code>weighted_mean</code>
and <code>weighted_sum</code> summary operations or a user-defined
summary function. When <code>weights</code> is set to <code>'area'</code>, the
cell areas of <code>x</code> will be calculated and used as weights.</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_append_cols">append_cols</code></td>
<td>
<p>when <code>fun</code> is not <code>NULL</code>, an optional character vector
of columns from <code>y</code> to be included in returned data frame.</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_coverage_area">coverage_area</code></td>
<td>
<p>if <code>TRUE</code>, output pixel <code>coverage_area</code>
instead of <code>coverage_fraction</code></p>
</td></tr>
<tr><td><code id="exact_extract_+3A_default_value">default_value</code></td>
<td>
<p>an optional value to use instead of <code>NA</code> in <code>x</code></p>
</td></tr>
<tr><td><code id="exact_extract_+3A_default_weight">default_weight</code></td>
<td>
<p>an optional value to use instead of <code>NA</code> in <code>weights</code></p>
</td></tr>
<tr><td><code id="exact_extract_+3A_include_area">include_area</code></td>
<td>
<p>if <code>TRUE</code>, and <code>fun</code> is <code>NULL</code>, augment
the data frame for each feature with a column
for the cell area. If the units of the raster CRS are
degrees, the area in square meters will be calculated
based on a spherical approximation of Earth. Otherwise,
a Cartesian area will be calculated (and will be the
same for all pixels.) If <code>TRUE</code> and <code>fun</code> is
not <code>NULL</code>, add <code>area</code> to the data frame passed
to <code>fun</code> for each feature.</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_include_cell">include_cell</code></td>
<td>
<p>if <code>TRUE</code>, and <code>fun</code> is <code>NULL</code>, augment
the data frame for each feature with a column
for the cell index (<code>cell</code>). If <code>TRUE</code> and
<code>fun</code> is not <code>NULL</code>, add <code>cell</code> to the
data frame passed to <code>fun</code> for each feature.</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_include_cols">include_cols</code></td>
<td>
<p>an optional character vector of column names in
<code>y</code> to be added to the data frame for each
feature that is either returned (when <code>fun</code> is
<code>NULL</code>) or passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_include_xy">include_xy</code></td>
<td>
<p>if <code>TRUE</code>, and <code>fun</code> is <code>NULL</code>, augment
the returned data frame for each feature with columns
for cell center coordinates (<code>x</code> and <code>y</code>). If
<code>TRUE</code> and <code>fun</code> is not <code>NULL</code>, add
<code>x</code> and <code>y</code> to the data frame passed to <code>fun</code>
for each feature.</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_force_df">force_df</code></td>
<td>
<p>always return a data frame instead of a vector, even if
<code>x</code> has only one layer and <code>fun</code> has length 1</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_full_colnames">full_colnames</code></td>
<td>
<p>include the names of <code>x</code> and <code>weights</code> in
the names of the data frame for each feature, even if
<code>x</code> or <code>weights</code> has only one layer.
This is useful when the results of multiple
calls to <code>exact_extract</code> are combined with
<code>cbind</code>.</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_stack_apply">stack_apply</code></td>
<td>
<p>if <code>TRUE</code>, apply <code>fun</code> independently to
each layer or <code>x</code> (and its corresponding layer
of <code>weights</code>, if provided.) The number of
layers in <code>x</code> and <code>weights</code> must equal
each other or <code>1</code>, in which case the
single layer raster will be recycled.
If <code>FALSE</code>, apply <code>fun</code> to all layers of
<code>x</code> (and <code>weights</code>) simultaneously.</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_summarize_df">summarize_df</code></td>
<td>
<p>pass values, coverage fraction/area, and weights to
<code>fun</code> as a single data frame instead of
separate arguments.</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_quantiles">quantiles</code></td>
<td>
<p>quantiles to be computed when <code>fun = 'quantile'</code></p>
</td></tr>
<tr><td><code id="exact_extract_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code>, display a progress bar during processing</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_max_cells_in_memory">max_cells_in_memory</code></td>
<td>
<p>the maximum number of raster cells to load at
a given time when using a named summary operation
for <code>fun</code> (as opposed to a function defined using
R code). If a polygon covers more than <code>max_cells_in_memory</code>
raster cells, it will be processed in multiple chunks.</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_grid_compat_tol">grid_compat_tol</code></td>
<td>
<p>require value and weight grids to align within
<code>grid_compat_tol</code> times the smaller of the two
grid resolutions.</p>
</td></tr>
<tr><td><code id="exact_extract_+3A_colname_fun">colname_fun</code></td>
<td>
<p>an optional function used to construct column names.
Should accept arguments <code>values</code> (name of value layer),
<code>weights</code> (name of weight layer), <code>fun_name</code> (value of
<code>fun</code>), <code>fun_value</code> (value associated with <code>fun</code>, for
<code style="white-space: pre;">&#8288;fun %in% c('quantile', 'frac', 'weighted_frac)&#8288;</code>
<code>nvalues</code> (number of value layers), <code>weights</code>
(number of weight layers)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>exact_extract</code> extracts the values of cells in a raster that are covered
by polygonal features in a simple feature collection (<code>sf</code> or <code>sfc</code>) or
<code>SpatialPolygonDataFrame</code>, as well as the fraction or area of each cell that
is covered by the feature. Pixels covered by all parts of the polygon are
considered. If an (invalid) multipart polygon covers the same pixels more
than once, the pixel may have a coverage fraction greater than one.
</p>
<p>The function can either return pixel values directly to the caller, or can
return the result of a predefined summary operation or user-defined R
function applied to the values. These three approaches are described in the
subsections below.
</p>


<h4>Returning extracted values directly</h4>

<p>If <code>fun</code> is not specified, <code>exact_extract</code> will return a list with
one data frame for each feature in the input feature collection. The data
frame will contain a column with cell values from each layer in the input
raster (and optional weighting raster) and a column indicating
the fraction or area of the cell that is covered by the polygon.
</p>
<p>If the input rasters have only one layer, the value and weight columns in the
data frame will be named <code>values</code> or <code>weights</code>. When the input rasters have
more than one layer, the columns will be named according to <code>names(x)</code> and
<code>names(weights)</code>. The column containing pixel coverage will be called
<code>coverage_fraction</code> when <code>coverage_area = FALSE</code>, or <code>coverage_area</code> when
<code>coverage_area = TRUE</code>. Additional columns can be added to the returned data
frames with the <code>include_area</code>, <code>include_cell</code>, and <code>include_xy</code> arguments.
</p>
<p>If the output data frames for multiple features are to be combined (e.g.,
with <code>rbind</code>), it may be useful to include identifying column(s) from the
input features in the returned data frames using <code>include_cols</code>.
</p>



<h4>Predefined summary operations</h4>

<p>Often the individual pixel values are not needed; only one or more summary
statistics (e.g., mean, sum) is required for each feature. Common summary
statistics can be calculated by <code>exact_extract</code> directly using a predefined
summary operation. Where possible, this approach is advantageous because it
allows the package to calculate the statistics incrementally, avoiding the
need to store all pixel values in memory at the same time. This allows the
package to process arbitrarily large data with a small amount of memory. (The
<code>max_pixels_in_memory</code> argument can be used to fine-tune the amount of memory
made available to <code>exact_extract</code>.)
</p>
<p>To summarize pixel values using a predefined summary option, <code>fun</code> should be
set to a character vector of one or more operation names. If the input raster
has a single layer and a single summary operation is specified,
<code>exact_extract</code> will return a vector with the result of the summary operation
for each feature in the input. If the input raster has multiple layers, or if
multiple summary operations are specified, <code>exact_extract</code> will return a data
frame with a row for each feature and a column for each summary operation /
layer combination. (The <code>force_df</code> option can be used to always return a data
frame instead of a vector.)
</p>
<p>The following summary operations are supported:
</p>

<ul>
<li> <p><code>min</code> - the minimum non-<code>NA</code> value in any raster cell wholly or
partially covered by the polygon
</p>
</li>
<li> <p><code>max</code> - the maximum non-<code>NA</code> value in any raster cell wholly or
partially covered by the polygon
</p>
</li>
<li> <p><code>count</code> - the sum of fractions of raster cells with non-<code>NA</code>
values covered by the polygon
</p>
</li>
<li> <p><code>sum</code>   - the sum of non-<code>NA</code> raster cell values, multiplied by
the fraction of the cell that is covered by the polygon
</p>
</li>
<li> <p><code>mean</code> - the mean cell value, weighted by the fraction of each cell
that is covered by the polygon
</p>
</li>
<li> <p><code>median</code> - the median cell value, weighted by the fraction of each cell
that is covered by the polygon
</p>
</li>
<li> <p><code>quantile</code> - arbitrary quantile(s) of cell values, specified in
<code>quantiles</code>, weighted by the fraction of each cell that is
covered by the polygon
</p>
</li>
<li> <p><code>mode</code> - the most common cell value, weighted by the fraction of
each cell that is covered by the polygon. Where multiple
values occupy the same maximum number of weighted cells,
the largest value will be returned.
</p>
</li>
<li> <p><code>majority</code> - synonym for <code>mode</code>
</p>
</li>
<li> <p><code>minority</code> - the least common cell value, weighted by the fraction
of each cell that is covered by the polygon. Where
multiple values occupy the same minimum number of
weighted cells, the smallest value will be returned.
</p>
</li>
<li> <p><code>variety</code> - the number of distinct values in cells that are wholly or
partially covered by the polygon.
</p>
</li>
<li> <p><code>variance</code> - the population variance of cell values, weighted by the
fraction of each cell that is covered by the polygon.
</p>
</li>
<li> <p><code>stdev</code> - the population standard deviation of cell values, weighted by
the fraction of each cell that is covered by the polygon.
</p>
</li>
<li> <p><code>coefficient_of_variation</code> - the population coefficient of variation of
cell values, weighted by the fraction of each
cell that is covered by the polygon.
</p>
</li>
<li> <p><code>weighted_mean</code> - the mean cell value, weighted by the product of
the fraction of each cell covered by the polygon
and the value of a second weighting raster provided
as <code>weights</code>
</p>
</li>
<li> <p><code>weighted_sum</code> - the sum of defined raster cell values, multiplied by
the fraction of each cell that is covered by the polygon
and the value of a second weighting raster provided
as <code>weights</code>
</p>
</li>
<li> <p><code>weighted_stdev</code> - the population standard deviation of cell values,
weighted by the product of the fraction of each cell
covered by the polygon and the value of a second
weighting raster provided as <code>weights</code>
</p>
</li>
<li> <p><code>weighted_variance</code> - the population variance of cell values, weighted by
the product of the fraction of each cell covered by
the polygon and the value of a second weighting
raster provided as <code>weights</code>
</p>
</li>
<li> <p><code>frac</code> - returns one column for each possible value of <code>x</code>, with the
the fraction of defined raster cells that are equal to that
value.
</p>
</li>
<li> <p><code>weighted_frac</code> - returns one column for each possible value of <code>x</code>,
with the fraction of defined cells that are equal
to that value, weighted by <code>weights.</code>
</p>
</li></ul>

<p>In all of the summary operations, <code>NA</code> values in the the primary raster (<code>x</code>)
raster are ignored (i.e., <code>na.rm = TRUE</code>.) If <code>NA</code> values occur in the
weighting raster, the result of the weighted operation will be <code>NA</code>. <code>NA</code>
values in both <code>x</code> and <code>weights</code> can be replaced on-the-fly using the
<code>default_value</code> and <code>default_weight</code> arguments.
</p>



<h4>User-defined summary functions</h4>

<p>If no predefined summary operation is suitable, a user-defined R function may
be provided as <code>fun</code>. The function will be called once for each feature and
must return either a single value or a data frame. The results of the
function for each feature will be combined and returned by <code>exact_extract</code>.
</p>
<p>The simplest way to write a summary function is to set
argument <code>summarize_df = TRUE</code>. (For backwards compatibility, this is not the
default.) In this mode, the summary function takes the signature
<code style="white-space: pre;">&#8288;function(df, ...)&#8288;</code> where <code>df</code> is the same data frame that would be returned
by <code>exact_extract</code> with <code>fun = NULL</code>.
</p>
<p>With <code>summarize_df = FALSE</code>, the function must have the signature
<code style="white-space: pre;">&#8288;function(values, coverage_fractions, ...)&#8288;</code> when weights are not used, and
<code style="white-space: pre;">&#8288;function(values, coverage_fractions, weights, ...)&#8288;</code> when weights are used.
If the value and weight rasters each have a single layer, the function arguments
will be vectors; if either has multiple layers, the function arguments will
be data frames, with column names taken from the names of the value/weight
rasters. Values brought in through the <code>include_xy</code>, <code>include_area</code>,
<code>include_cell</code>, and <code>include_cols</code> arguments will be added to the <code>values</code>
data frame. For most applications, it is simpler to set <code>summarize_df = TRUE</code>
and work with all inputs in a single data frame.
</p>



<h3>Value</h3>

<p>a vector, data frame, or list of data frames, depending on the type
of <code>x</code> and the value of <code>fun</code> (see Details)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rast &lt;- raster::raster(matrix(1:100, ncol=10), xmn=0, ymn=0, xmx=10, ymx=10)
poly &lt;- sf::st_as_sfc('POLYGON ((2 2, 7 6, 4 9, 2 2))')

# named summary operation on RasterLayer, returns vector
exact_extract(rast, poly, 'mean')

# two named summary operations on RasterLayer, returns data frame
exact_extract(rast, poly, c('min', 'max'))

# named summary operation on RasterStack, returns data frame
stk &lt;- raster::stack(list(a=rast, b=sqrt(rast)))
exact_extract(stk, poly, 'mean')

# named weighted summary operation, returns vector
weights &lt;- raster::raster(matrix(runif(100), ncol=10), xmn=0, ymn=0, xmx=10, ymx=10)
exact_extract(rast, poly, 'weighted_mean', weights=weights)

# custom summary function, returns vector
exact_extract(rast, poly, function(value, cov_frac) length(value[cov_frac &gt; 0.9]))

</code></pre>

<hr>
<h2 id='exact_resample'>Resample a raster to a new grid</h2><span id='topic+exact_resample'></span><span id='topic+exact_resample+2CRasterLayer+2CRasterLayer-method'></span><span id='topic+exact_resample+2CSpatRaster+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Resample a raster to a new grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterLayer,RasterLayer'
exact_resample(x, y, fun, coverage_area = FALSE)

## S4 method for signature 'SpatRaster,SpatRaster'
exact_resample(x, y, fun, coverage_area = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exact_resample_+3A_x">x</code></td>
<td>
<p>a <code>RasterLayer</code> or <code>SpatRaster</code> to be resampled</p>
</td></tr>
<tr><td><code id="exact_resample_+3A_y">y</code></td>
<td>
<p>a raster of the same class as <code>x</code> with a grid definition to
which <code>x</code> should be resampled</p>
</td></tr>
<tr><td><code id="exact_resample_+3A_fun">fun</code></td>
<td>
<p>a named summary operation or R function to be used for the resampling</p>
</td></tr>
<tr><td><code id="exact_resample_+3A_coverage_area">coverage_area</code></td>
<td>
<p>use cell coverage areas instead of coverage fractions
in <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a resampled version of <code>x</code>, returned as a <code>RasterLayer</code> or
<code>SpatRaster</code>, depending on the values of <code>x</code> and <code>y</code>
</p>

<hr>
<h2 id='exactextractr-package'>exactextractr: Fast Extraction from Raster Datasets using Polygons</h2><span id='topic+exactextractr'></span><span id='topic+exactextractr-package'></span>

<h3>Description</h3>

<p>Quickly and accurately summarizes raster values over polygonal areas (&quot;zonal statistics&quot;).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Daniel Baston <a href="mailto:dbaston@isciences.com">dbaston@isciences.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> ISciences, LLC [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://isciences.gitlab.io/exactextractr/">https://isciences.gitlab.io/exactextractr/</a>
</p>
</li>
<li> <p><a href="https://github.com/isciences/exactextractr">https://github.com/isciences/exactextractr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/isciences/exactextractr/issues">https://github.com/isciences/exactextractr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='rasterize_polygons'>Create a raster approximation of a polygon coverage</h2><span id='topic+rasterize_polygons'></span><span id='topic+rasterize_polygons+2Csf+2CRasterLayer-method'></span><span id='topic+rasterize_polygons+2Csf+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Returns a raster whose values indicate the index of the polygon covering
each cell. Where multiple polygons cover the same cell, the index of the
polygon covering the greatest area will be used, with the lowest index
returned in the case of ties. Cells that are not covered by any polygon,
or whose total covered fraction is less than <code>min_coverage</code>, will be
set to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sf,RasterLayer'
rasterize_polygons(x, y, min_coverage = 0)

## S4 method for signature 'sf,SpatRaster'
rasterize_polygons(x, y, min_coverage = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterize_polygons_+3A_x">x</code></td>
<td>
<p>a <code>sf</code> or <code>sfc</code> object with polygonal geometries</p>
</td></tr>
<tr><td><code id="rasterize_polygons_+3A_y">y</code></td>
<td>
<p>a (possibly empty) <code>RasterLayer</code> whose resolution and
extent will be used for the generated <code>RasterLayer</code>.</p>
</td></tr>
<tr><td><code id="rasterize_polygons_+3A_min_coverage">min_coverage</code></td>
<td>
<p>minimum fraction of a cell that must be covered by
polygons to be included in the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>RasterLayer</code> or <code>SpatRaster</code>, consistent with the type of <code>y</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
