<!DOCTYPE html><html lang="en"><head><title>Help for package ebTobit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ebTobit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BileAcid'><p>Bile Acid Data</p></a></li>
<li><a href='#ConvexDual'><p>Convex Optimization of the Kiefer-Wolfowitz NPMLE</p></a></li>
<li><a href='#ConvexPrimal'><p>Convex Optimization of the Kiefer-Wolfowitz NPMLE</p></a></li>
<li><a href='#ebTobit'><p>Empirical Bayes Matrix Estimation under a Tobit Likelihood</p></a></li>
<li><a href='#EM'><p>Nonparametric Maximum Likelihood via Expectation Maximization</p></a></li>
<li><a href='#fitted.ebTobit'><p>Fitted Estimates of an ebTobit object</p></a></li>
<li><a href='#is.ebTobit'><p>Validate ebTobit Object</p></a></li>
<li><a href='#lik_GaussianPIC'><p>Helper Function - generate likelihood for pair (L,R) and mean gr</p></a></li>
<li><a href='#likMat'><p>Helper Function - generate likelihood matrix</p></a></li>
<li><a href='#logLik.ebTobit'><p>Marginal Log-likelihood of an ebTobit object</p></a></li>
<li><a href='#new_ebTobit'><p>Create a new ebTobit object</p></a></li>
<li><a href='#posterior_L1mediod.ebTobit'><p>Compute the Posterior L1 Mediod of an ebTobit object</p></a></li>
<li><a href='#posterior_mean.ebTobit'><p>Compute Posterior Mean of an ebTobit object</p></a></li>
<li><a href='#posterior_mode.ebTobit'><p>Compute Posterior Mode of an ebTobit object</p></a></li>
<li><a href='#predict.ebTobit'><p>Fitted Estimates of an ebTobit object</p></a></li>
<li><a href='#tobit_sd'><p>Fit Tobit Standard Deviation via Maximum Likelihood</p></a></li>
<li><a href='#tobit_sd_mle'><p>Maximum Likelihood Estimator for a Single Standard Deviation Parameter</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Empirical Bayesian Tobit Matrix Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-03</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation tools for multidimensional Gaussian means using
    empirical Bayesian g-modeling. Methods are able to handle fully observed data as
    well as left-, right-, and interval-censored observations (Tobit
    likelihood); descriptions of these methods can be found in Barbehenn and
    Zhao (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2306.07239">doi:10.48550/arXiv.2306.07239</a>&gt;. Additional, lower-level functionality based
    on Kiefer and Wolfowitz (1956) &lt;<a href="https://doi.org/10.1214%2Faoms%2F1177728066">doi:10.1214/aoms/1177728066</a>&gt; and Jiang and
    Zhang (2009) &lt;<a href="https://doi.org/10.1214%2F08-AOS638">doi:10.1214/08-AOS638</a>&gt; is provided that can be used to
    accelerate many empirical Bayes and nonparametric maximum likelihood
    problems.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/barbehenna/ebTobit">https://github.com/barbehenna/ebTobit</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/barbehenna/ebTobit/issues">https://github.com/barbehenna/ebTobit/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), RcppParallel, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>REBayes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppParallel</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-03 22:50:23 UTC; altonbarbehenn</td>
</tr>
<tr>
<td>Author:</td>
<td>Alton Barbehenn <a href="https://orcid.org/0009-0000-3364-7204"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sihai Dave Zhao [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alton Barbehenn &lt;altonbarbehenn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-03 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BileAcid'>Bile Acid Data</h2><span id='topic+BileAcid'></span>

<h3>Description</h3>

<p>A bile acid data set taken from Lei et al. (2018)
<a href="https://doi.org/10.1096/fj.201700055R">doi:10.1096/fj.201700055R</a> via Wei et al. (2018)
<a href="https://doi.org/10.1371/journal.pcbi.1005973">doi:10.1371/journal.pcbi.1005973</a>
(corresponding GitHub repository: https://github.com/WandeRum/GSimp). The 
values in <code>BileAcid</code> can be assumed to be independent log-normal 
measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BileAcid
</code></pre>


<h3>Format</h3>

<p>A data frame with 198 rows and 34 variables. Each row is a patient id
and each column is an bile acid measurement.
</p>

<hr>
<h2 id='ConvexDual'>Convex Optimization of the Kiefer-Wolfowitz NPMLE</h2><span id='topic+ConvexDual'></span>

<h3>Description</h3>

<p>This method only works if there is a working installation of <code>REBayes</code>
available. See the <code>REBayes</code> package and corresponding papers for more
implementation details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvexDual(A, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConvexDual_+3A_a">A</code></td>
<td>
<p>numeric matrix likelihoods</p>
</td></tr>
<tr><td><code id="ConvexDual_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>Rmosek</code> such as <code>rtol</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix <code>A</code> is structured as follows: A_ij = P(X_i | theta = t_j),
where X_i is the i'th observation and t_j is the j'th set of
parameters/grid-point.
</p>


<h3>Value</h3>

<p>a vector containing the fitted prior
</p>

<hr>
<h2 id='ConvexPrimal'>Convex Optimization of the Kiefer-Wolfowitz NPMLE</h2><span id='topic+ConvexPrimal'></span>

<h3>Description</h3>

<p>This method only works if there is a working installation of <code>REBayes</code>
available. See the <code>REBayes</code> package and corresponding papers for more
implementation details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvexPrimal(A, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConvexPrimal_+3A_a">A</code></td>
<td>
<p>numeric matrix likelihoods</p>
</td></tr>
<tr><td><code id="ConvexPrimal_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>Rmosek</code> such as <code>rtol</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix <code>A</code> is structured as follows: A_ij = P(X_i | theta = t_j),
where X_i is the i'th observation and t_j is the j'th set of
parameters/grid-point.
</p>


<h3>Value</h3>

<p>a vector containing the fitted prior
</p>

<hr>
<h2 id='ebTobit'>Empirical Bayes Matrix Estimation under a Tobit Likelihood</h2><span id='topic+ebTobit'></span>

<h3>Description</h3>

<p>Fit and estimate the nonparametric maximum likelihood estimator in R^p
(p &gt;= 1) when the likelihood is Gaussian and possibly interval censored. If
p = 1, then <code>L</code>, <code>R</code>, and <code>gr</code> may be vectors (they are
immediately converted into matrices internally).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebTobit(
  L,
  R = L,
  gr = (R + L)/2,
  s1 = 1,
  algorithm = "EM",
  pos_lik = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ebTobit_+3A_l">L</code></td>
<td>
<p>n x p matrix of lower bounds on observations</p>
</td></tr>
<tr><td><code id="ebTobit_+3A_r">R</code></td>
<td>
<p>n x p matrix of upper bounds on observations</p>
</td></tr>
<tr><td><code id="ebTobit_+3A_gr">gr</code></td>
<td>
<p>m x p matrix of grid points</p>
</td></tr>
<tr><td><code id="ebTobit_+3A_s1">s1</code></td>
<td>
<p>a single numeric standard deviation or an n x p matrix of standard
deviations</p>
</td></tr>
<tr><td><code id="ebTobit_+3A_algorithm">algorithm</code></td>
<td>
<p>method to fit prior, either a function or function name</p>
</td></tr>
<tr><td><code id="ebTobit_+3A_pos_lik">pos_lik</code></td>
<td>
<p>boolean indicating whether to lower-bound the likelihood
matrix with <code>.Machine$double.xmin</code> (default: TRUE); helps avoid possible
divide-by-zero errors in <code>algorithm</code></p>
</td></tr>
<tr><td><code id="ebTobit_+3A_...">...</code></td>
<td>
<p>further arguments passed into fitting method such as <code>rtol</code>
and <code>maxiter</code>, see for example <code><a href="#topic+EM">EM</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each observation is stored in a pair of matrices, <code>L</code> and <code>R</code>. If
L_ij = R_ij then a direct measurement X_ij ~ N(theta, s1^2) is made; 
if L_ij &lt; R_ij then the measurement is censored so that L_ij &lt; X_ij &lt; R_ij.
</p>
<p>To use a custom fitting algorithm, define a function <code>MyAlg</code> that
takes in an n x m likelihood matrix: P_ij = P(L_i, R_i | theta = t_j) and
returns a vector of estimated prior weights for t_j. Once <code>MyAlg</code> is
defined, fit the prior by using <code>algorithm = "MyAlg"</code> or use the
function itself <code>algorithm = MyAlg</code>.
</p>
<p>Alternative fitting algorithms &quot;ConvexPrimal&quot;and &quot;ConvexDual&quot; have been
(wrappers of <code>REBayes::KWPrimal</code> and <code>REBayes::KWDual</code>,
respectively) included and can be used if MOSEK and <code>REBayes</code> are
properly installed.
</p>


<h3>Value</h3>

<p>a fitted <code>ebTobit</code> object containing at least the prior weights,
corresponding grid/support points, and likelihood matrix relating the grid to
the observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 100
p &lt;- 5
r &lt;- 2
U.true &lt;- matrix(stats::rexp(n*r), n, r)
V.true &lt;- matrix(sample(x = c(1,4,7), 
                        size = p*r, 
                        replace = TRUE, 
                        prob = c(0.7, 0.2, 0.1)), 
                 p, r)
TH &lt;- tcrossprod(U.true, V.true)
X &lt;- TH + matrix(stats::rnorm(n*p), n, p)

# fit uncensored method
fit1 &lt;- ebTobit(X)

# fit left-censored method
ldl &lt;- 1 # lower and upper detection limits
udl &lt;- Inf
L &lt;- ifelse(X &lt; ldl, 0, ifelse(X &lt;= udl, X, udl))
R &lt;- ifelse(X &lt; ldl, ldl, ifelse(X &lt;= udl, X, Inf))
fit2 &lt;- ebTobit(L, R)
</code></pre>

<hr>
<h2 id='EM'>Nonparametric Maximum Likelihood via Expectation Maximization</h2><span id='topic+EM'></span>

<h3>Description</h3>

<p>Compute the nonparametric maximum likelihood estimate given a likelihood
matrix. The matrix A is structured so that A_{ij} = f(X_i | theta_j) for
some grid of potential parameter values theta_1, ..., theta_p and
observations X_1, ..., X_n. The parameters, theta_j, can be multidimensional
because all that is required is the likelihood. Convergence is achieved when
the relative improvements of the log-likelihood is below the provided
tolerance level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM(A, maxiter = 10000L, rtol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM_+3A_a">A</code></td>
<td>
<p>numeric matrix likelihoods</p>
</td></tr>
<tr><td><code id="EM_+3A_maxiter">maxiter</code></td>
<td>
<p>early stopping condition</p>
</td></tr>
<tr><td><code id="EM_+3A_rtol">rtol</code></td>
<td>
<p>convergence tolerance: abs(loss_new - loss_old)/abs(loss_old)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the estimated prior distribution (a vector of masses corresponding
to the columns of A)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
t = sample(c(0,5), size = 100, replace = TRUE)
x = t + stats::rnorm(100)
gr = seq(from = min(x), to = max(x), length.out = 50)
A = stats::dnorm(outer(x, gr, "-"))
EM(A)
## Not run: 
# compare to solution from rmosek (requires additional library installation):
all.equal(
    REBayes::KWPrimal(A = A, d = rep(1, 50), w = rep(1/100, 100))$f,
    EM(A, maxiter = 1e+6, rtol = 1e-16), # EM alg converges slowly
    tolerance = 0.01
)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitted.ebTobit'>Fitted Estimates of an ebTobit object</h2><span id='topic+fitted.ebTobit'></span>

<h3>Description</h3>

<p>Compute either the posterior mean (default) or posterior L1 mediod which
corresponds to the posterior median in one-dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebTobit'
fitted(object, method = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.ebTobit_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code><a href="#topic+ebTobit">ebTobit</a></code></p>
</td></tr>
<tr><td><code id="fitted.ebTobit_+3A_method">method</code></td>
<td>
<p>either &quot;mean&quot;, &quot;L1mediod&quot;, or &quot;mode&quot; corresponding to the 
methods: <code>posterior_*.ebTobit()</code></p>
</td></tr>
<tr><td><code id="fitted.ebTobit_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix containing the posterior estimates for measurements in the
fit empirical Bayes model <code>object</code>
</p>

<hr>
<h2 id='is.ebTobit'>Validate ebTobit Object</h2><span id='topic+is.ebTobit'></span>

<h3>Description</h3>

<p>Validate ebTobit Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ebTobit(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.ebTobit_+3A_object">object</code></td>
<td>
<p>any R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean: TRUE if the object is a valid <code><a href="#topic+ebTobit">ebTobit</a></code> object
</p>

<hr>
<h2 id='lik_GaussianPIC'>Helper Function - generate likelihood for pair (L,R) and mean gr</h2><span id='topic+lik_GaussianPIC'></span>

<h3>Description</h3>

<p>Compute P(L_i, R_i | theta = t_k) for observations (L_i, R_i) and grid of
mean t_k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lik_GaussianPIC(L, R, gr, s1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lik_GaussianPIC_+3A_l">L</code></td>
<td>
<p>numeric vector of lower bounds</p>
</td></tr>
<tr><td><code id="lik_GaussianPIC_+3A_r">R</code></td>
<td>
<p>numeric vector of upper bounds</p>
</td></tr>
<tr><td><code id="lik_GaussianPIC_+3A_gr">gr</code></td>
<td>
<p>numeric vector of means</p>
</td></tr>
<tr><td><code id="lik_GaussianPIC_+3A_s1">s1</code></td>
<td>
<p>numeric vector of standard deviations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the likelihood under partial interval censoring
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set-up
p = 15
gr = stats::rnorm(p)
L = R = stats::rnorm(p)
missing.idx = sample.int(n = p, size = p/5)
L[missing.idx] = L[missing.idx] - stats::runif(length(missing.idx), 0, 1)
R[missing.idx] = R[missing.idx] + stats::runif(length(missing.idx), 0, 1)

# R solution
lik = prod(ifelse(
           L == R,
           stats::dnorm(L-gr),
           stats::pnorm(R-gr) - stats::pnorm(L-gr)))

# Compare R to RcppParallel method
all.equal(lik, lik_GaussianPIC(L, R, gr, rep(1,p)))
</code></pre>

<hr>
<h2 id='likMat'>Helper Function - generate likelihood matrix</h2><span id='topic+likMat'></span>

<h3>Description</h3>

<p>Compute a matrix L whose entries are L[i,k] = P(L_i, R_i | theta = t_k) for
observations (L_i, R_i) and grid of means t_k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likMat(L, R, gr, s1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="likMat_+3A_l">L</code></td>
<td>
<p>n x p matrix of lower bounds</p>
</td></tr>
<tr><td><code id="likMat_+3A_r">R</code></td>
<td>
<p>n x p matrix of upper bounds</p>
</td></tr>
<tr><td><code id="likMat_+3A_gr">gr</code></td>
<td>
<p>m x p matrix of candidate means</p>
</td></tr>
<tr><td><code id="likMat_+3A_s1">s1</code></td>
<td>
<p>n x p matrix of standard deviations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the n x m likelihood matrix under partial interval censoring
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set-up
n = 100; m = 50; p = 5
gr = matrix(stats::rnorm(m*p), m, p)
L = R = matrix(stats::rnorm(n*p), n, p)
s1 = matrix(1, n, p)
missing.idx = sample.int(n = n*p, size = p*p)
L[missing.idx] = L[missing.idx] - stats::runif(p, 0, 1)

# R solution
lik = matrix(nrow = n, ncol = m)
for (i in 1:n) {
    for(k in 1:m) {
        lik[i,k] = prod(ifelse(
            L[i,] == R[i,],
            stats::dnorm(L[i,]-gr[k,], sd = s1[i,]),
            stats::pnorm(R[i,]-gr[k,], sd = s1[i,]) - stats::pnorm(L[i,]-gr[k,], sd = s1[i,])
        ))
    }
}

# Compare R to RcppParallel method
all.equal(lik, likMat(L, R, gr, s1))
</code></pre>

<hr>
<h2 id='logLik.ebTobit'>Marginal Log-likelihood of an ebTobit object</h2><span id='topic+logLik.ebTobit'></span>

<h3>Description</h3>

<p>Marginal Log-likelihood of an ebTobit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebTobit'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.ebTobit_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code><a href="#topic+ebTobit">ebTobit</a></code></p>
</td></tr>
<tr><td><code id="logLik.ebTobit_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log likelihood for the fitted empirical Bayes model in <code>object</code>
</p>

<hr>
<h2 id='new_ebTobit'>Create a new ebTobit object</h2><span id='topic+new_ebTobit'></span>

<h3>Description</h3>

<p>Validate the provided elements and populate the object. Current methods
require that <code>gr</code> is numeric for that calculation of posterior
statistics (mean and mediod).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_ebTobit(prior, gr, lik)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_ebTobit_+3A_prior">prior</code></td>
<td>
<p>numeric vector of non-negative weights (sums to one)</p>
</td></tr>
<tr><td><code id="new_ebTobit_+3A_gr">gr</code></td>
<td>
<p>numeric matrix of support points</p>
</td></tr>
<tr><td><code id="new_ebTobit_+3A_lik">lik</code></td>
<td>
<p>numeric matrix of likelihoods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>EBayesMat</code> object containing at least the prior weights,
corresponding grid/support points, and likelihood matrix relating the grid to
the observations
</p>

<hr>
<h2 id='posterior_L1mediod.ebTobit'>Compute the Posterior L1 Mediod of an ebTobit object</h2><span id='topic+posterior_L1mediod.ebTobit'></span>

<h3>Description</h3>

<p>The posterior L1 mediod is defined as \arg\min_y E |y - t|_1 where the
expectation is taken over the posterior t|X=x. Here the posterior L1 mediod
is evaluated for each of the observations used to fit <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_L1mediod.ebTobit(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_L1mediod.ebTobit_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code><a href="#topic+ebTobit">ebTobit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix of posterior L1 mediods for the fitted empirical
Bayes model in <code>object</code>
</p>

<hr>
<h2 id='posterior_mean.ebTobit'>Compute Posterior Mean of an ebTobit object</h2><span id='topic+posterior_mean.ebTobit'></span>

<h3>Description</h3>

<p>Compute Posterior Mean of an ebTobit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_mean.ebTobit(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_mean.ebTobit_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code><a href="#topic+ebTobit">ebTobit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix of posterior means for the fitted empirical Bayes
model in <code>object</code>
</p>

<hr>
<h2 id='posterior_mode.ebTobit'>Compute Posterior Mode of an ebTobit object</h2><span id='topic+posterior_mode.ebTobit'></span>

<h3>Description</h3>

<p>Compute Posterior Mode of an ebTobit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_mode.ebTobit(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_mode.ebTobit_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code><a href="#topic+ebTobit">ebTobit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix of posterior modes for the fitted empirical
Bayes model in <code>object</code>
</p>

<hr>
<h2 id='predict.ebTobit'>Fitted Estimates of an ebTobit object</h2><span id='topic+predict.ebTobit'></span>

<h3>Description</h3>

<p>Compute either the posterior mean (default) or posterior L1 mediod which
corresponds to the posterior median in one-dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebTobit'
predict(object, L, R = L, s1 = 1, method = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ebTobit_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code><a href="#topic+ebTobit">ebTobit</a></code></p>
</td></tr>
<tr><td><code id="predict.ebTobit_+3A_l">L</code></td>
<td>
<p>n x p matrix of lower bounds on observations</p>
</td></tr>
<tr><td><code id="predict.ebTobit_+3A_r">R</code></td>
<td>
<p>n x p matrix of upper bounds on observations</p>
</td></tr>
<tr><td><code id="predict.ebTobit_+3A_s1">s1</code></td>
<td>
<p>a single numeric standard deviation or an n x p matrix of standard
deviations</p>
</td></tr>
<tr><td><code id="predict.ebTobit_+3A_method">method</code></td>
<td>
<p>either &quot;mean&quot;, &quot;L1mediod&quot;, or &quot;mode&quot; corresponding to the 
methods: <code>posterior_*.ebTobit()</code></p>
</td></tr>
<tr><td><code id="predict.ebTobit_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of posterior estimates for new observations under the
provided, pre-fit empirical Bayes model <code>object</code>
</p>

<hr>
<h2 id='tobit_sd'>Fit Tobit Standard Deviation via Maximum Likelihood</h2><span id='topic+tobit_sd'></span>

<h3>Description</h3>

<p>Fit the matrix of standard deviations given censored observations current
mean estimates. Currently there are four models for S implemented: global,
column-specific, row-specific, and rank-1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tobit_sd(
  L,
  R,
  mu = matrix(colMeans(L + R)/2, nrow(L), ncol(L), byrow = TRUE),
  sd.structure = "global",
  interval = c(1e-04, 100),
  tol = .Machine$double.eps^0.25,
  maxiter = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tobit_sd_+3A_l">L</code></td>
<td>
<p>matrix of lower bounds on observations (n x p)</p>
</td></tr>
<tr><td><code id="tobit_sd_+3A_r">R</code></td>
<td>
<p>matrix of upper bounds on observations (n x p)</p>
</td></tr>
<tr><td><code id="tobit_sd_+3A_mu">mu</code></td>
<td>
<p>matrix of known means (n x p)</p>
</td></tr>
<tr><td><code id="tobit_sd_+3A_sd.structure">sd.structure</code></td>
<td>
<p>structure imposed on noise level estimates, must be one
of: &quot;global&quot;, &quot;column&quot;, &quot;row&quot;, or &quot;rank1&quot;</p>
</td></tr>
<tr><td><code id="tobit_sd_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval defining
the convex search space (default: <code>c(1e-4, 1e+2)</code>)</p>
</td></tr>
<tr><td><code id="tobit_sd_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy</p>
</td></tr>
<tr><td><code id="tobit_sd_+3A_maxiter">maxiter</code></td>
<td>
<p>early stopping condition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of maximum likelihood estimates for each observation's 
standard deviation (n x p)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n = 100; p = 5; r = 2
U.true = matrix(stats::rexp(n*r), n, r)
V.true = matrix(sample(x = c(1,4,7),
                       size = p*r, 
                       replace = TRUE, 
                       prob = c(0.7, 0.2, 0.1)), 
                p, r)
TH = tcrossprod(U.true, V.true)
X = TH + matrix(stats::rnorm(n*p, sd = 1), n, p)
ldl &lt;- 0.1 # lower detection limit, known to be non-negative
L &lt;- ifelse(X &lt; ldl, 0, X)
R &lt;- ifelse(X &lt; ldl, ldl, X)

tobit_sd(L, R, mu = TH)
tobit_sd(L, R, mu = TH, sd.structure = "column")
</code></pre>

<hr>
<h2 id='tobit_sd_mle'>Maximum Likelihood Estimator for a Single Standard Deviation Parameter</h2><span id='topic+tobit_sd_mle'></span>

<h3>Description</h3>

<p>Use standard numerical optimization methods to maximize the log-likelihood of
the given problem. If all of the data is passed in, this method computes the
global estimate of standard deviation. By passing in a subset of the data,
more specific estimates can be made (ex column-specific standard deviations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tobit_sd_mle(
  L,
  R,
  mu = matrix(mean(L + R)/2, nrow(L), ncol(L)),
  interval = c(1e-04, 100),
  tol = .Machine$double.eps^0.25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tobit_sd_mle_+3A_l">L</code></td>
<td>
<p>matrix of lower bounds on observations (n x p)</p>
</td></tr>
<tr><td><code id="tobit_sd_mle_+3A_r">R</code></td>
<td>
<p>matrix of upper bounds on observations (n x p)</p>
</td></tr>
<tr><td><code id="tobit_sd_mle_+3A_mu">mu</code></td>
<td>
<p>matrix of known means (n x p)</p>
</td></tr>
<tr><td><code id="tobit_sd_mle_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval defining
the convex search space (default: <code>c(1e-4, 1e+2)</code>)</p>
</td></tr>
<tr><td><code id="tobit_sd_mle_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing estimate (maximum) and log-likelihood (objective)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n = 100; p = 5; r = 2
U.true = matrix(stats::rexp(n*r), n, r)
V.true = matrix(sample(x = c(1,4,7),
                       size = p*r, 
                       replace = TRUE, 
                       prob = c(0.7, 0.2, 0.1)), 
                p, r)
TH = tcrossprod(U.true, V.true)
X = TH + matrix(stats::rnorm(n*p, sd = 1), n, p)
ldl &lt;- 0.1 # lower detection limit, known to be non-negative
L &lt;- ifelse(X &lt; ldl, 0, X)
R &lt;- ifelse(X &lt; ldl, ldl, X)
tobit_sd_mle(L, R, mu = TH)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
