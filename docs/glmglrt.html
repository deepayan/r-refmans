<!DOCTYPE html><html><head><title>Help for package glmglrt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glmglrt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#confint_contrast'><p>Confidence interval estimation of contrasts</p></a></li>
<li><a href='#df_for_wald'><p>Gets the degree of freedom for Wald tests involving the model</p></a></li>
<li><a href='#estimate_confint_contrast'><p>Computes point estimates, confidence intervals and P-values of a contrast</p></a></li>
<li><a href='#estimate_contrast'><p>Point estimates of contrasts</p></a></li>
<li><a href='#fixcoef'><p>Generic function to get fixed effects of a model</p></a></li>
<li><a href='#glmglrt'><p>glmglrt: GLRT P-Values in Generalized Linear Models</p></a></li>
<li><a href='#override_summary'><p>Overrides the Generalized Linear Models summary methods</p></a></li>
<li><a href='#p_value_contrast'><p>Hypothesis tests on contrasts</p></a></li>
<li><a href='#p_value.glm'><p>Computing p-values of hypothesis tests on coefficients of Generalized Linear Models and other</p></a></li>
<li><a href='#print.summary.glmglrt'><p>Prints the summary generated by <code>summarylr</code></p></a></li>
<li><a href='#ps_newtonRaphson'><p>Newton-Raphson algorithm when parameters may not be estimable outside of their parameter space</p></a></li>
<li><a href='#summarylr'><p>Summarizes a glm, adding a column of GLRT or Rao score P-values</p></a></li>
<li><a href='#vcov_fixcoef'><p>Gets the variance-covariance matrix of fixed effects of a fitted model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>GLRT P-Values in Generalized Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>André GILLIBERT &lt;andre.gillibert@chu-rouen.fr&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>André GILLIBERT [aut, cre]</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to compute Generalized Likelihood Ratio Tests (GLRT) also known as Likelihood Ratio Tests (LRT) and Rao's score tests of simple
   and complex contrasts of Generalized Linear Models (GLMs). It provides the same interface as summary.glm(), adding GLRT P-values,
   less biased than Wald's P-values and consistent with profile-likelihood confidence interval generated by confint().
   See Wilks (1938) &lt;<a href="https://doi.org/10.1214%2Faoms%2F1177732360">doi:10.1214/aoms/1177732360</a>&gt; for the LRT chi-square approximation.
   See Rao (1948) &lt;<a href="https://doi.org/10.1017%2FS0305004100023987">doi:10.1017/S0305004100023987</a>&gt; for Rao's score test.
   See Wald (1943) &lt;<a href="https://doi.org/10.2307%2F1990256">doi:10.2307/1990256</a>&gt; for Wald's test.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, parameters (&ge; 0.1.0), MASS</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), lme4, nlme, datasets, nnet, survival,
lmerTest, mgcv, gam, multcomp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-03 22:17:34 UTC; andre.gillibert</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-07 08:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='confint_contrast'>Confidence interval estimation of contrasts</h2><span id='topic+confint_contrast'></span><span id='topic+confint_contrast.default'></span>

<h3>Description</h3>

<p>This S3 generic function allows the computation of confidence intervals of contrasts
(i.e. linear combinations) of fixed-effects in many models.
The default implementation computes Wald's confidence intervals with any model as long as it consistently implements <code><a href="#topic+fixcoef">fixcoef</a></code>, <code><a href="#topic+vcov_fixcoef">vcov_fixcoef</a></code> and <code><a href="#topic+df_for_wald">df_for_wald</a></code>.
It is also specialized for GLMs with Wald's, LRT and Rao's confidence intervals and may be specialized with other models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confint_contrast(
  model,
  contrast,
  method = NULL,
  level = 0.95,
  alternative = c("two.sided", "less", "greater"),
  ...
)

## Default S3 method:
confint_contrast(
  model,
  contrast,
  method = NULL,
  level = 0.95,
  alternative = c("two.sided", "less", "greater"),
  clevel_logit_tol = 1e-05,
  deriv_rel_SE = 1e-04,
  ...,
  force = FALSE,
  debuglevel = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint_contrast_+3A_model">model</code></td>
<td>
<p>a fitted statistical model such as a glm or a coxph.</p>
</td></tr>
<tr><td><code id="confint_contrast_+3A_contrast">contrast</code></td>
<td>
<p>numeric vector of the same length as the number of coefficients in the model; it describes the contrast <code>sum(contrast*fixcoef(model))</code>.</p>
</td></tr>
<tr><td><code id="confint_contrast_+3A_method">method</code></td>
<td>
<p>character string value; specification of the algorithm used (implementation dependent). NULL must be accepted.
Suggested values are &quot;LRT&quot; for inverted likelihood ratio test, &quot;Rao&quot; for inverted Rao's score test, &quot;Wald&quot; for inverted Wald's test.</p>
</td></tr>
<tr><td><code id="confint_contrast_+3A_level">level</code></td>
<td>
<p>numeric value between 0 and 1; nominal confidence level.</p>
</td></tr>
<tr><td><code id="confint_contrast_+3A_alternative">alternative</code></td>
<td>
<p>character value; either &quot;two.sided&quot;, &quot;less&quot; or &quot;greater&quot;, specifying a two-sided or one-sided confidence interval.</p>
</td></tr>
<tr><td><code id="confint_contrast_+3A_...">...</code></td>
<td>
<p>Additional parameters that may be used by some implementations.</p>
</td></tr>
<tr><td><code id="confint_contrast_+3A_clevel_logit_tol">clevel_logit_tol</code></td>
<td>
<p>numeric value; the difference of logit(1-level) that can be tolerated for convergence of the algorithm.</p>
</td></tr>
<tr><td><code id="confint_contrast_+3A_deriv_rel_se">deriv_rel_SE</code></td>
<td>
<p>numeric value; the delta for the numeric derivative, used for the Newton-Raphson algorithm applied to the logit(1-pvalue).
It is expressed as a multiplicative factor for the Standard Error of the contrast.</p>
</td></tr>
<tr><td><code id="confint_contrast_+3A_force">force</code></td>
<td>
<p>logical; if TRUE, force computation of P-values in case of convergence problems.</p>
</td></tr>
<tr><td><code id="confint_contrast_+3A_debuglevel">debuglevel</code></td>
<td>
<p>integer value; set to 0 (default) to disable warnings, 1 to enable warnings and 2 to enable warnings and notes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should consistent with <code><a href="#topic+estimate_contrast">estimate_contrast</a></code> and <code><a href="#topic+p_value_contrast">p_value_contrast</a></code> as they are designed to be used together.
If a null hypothesis (H0) is specified, it MUST be ignored by <code>confint_contrast</code> as in <code>estimate_contrast</code>.
If you want to make it consistent with <code>p_value_contrast</code> you may subtract H0 from the output of <code>estimate_contrast</code> and <code>confint_contrast</code>.
</p>
<p>When alternative is &quot;less&quot; or  &quot;greater&quot;, one-sided confidence intervals are generated.
</p>


<h3>Value</h3>

<p>A vector of length 2. The first value MUST be named &quot;lower&quot; and be the lower bound of the confidence interval.
The second value MUST be named &quot;upper&quot; and be the upper bound of the confidence interval.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Default implementation
Supports Wald's test on a wide range of models, including <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+lm">mlm</a></code>,
<code><a href="stats.html#topic+glm">stats::glm</a></code>, <code><a href="MASS.html#topic+glm.nb">negbin</a></code>, <code><a href="MASS.html#topic+polr">MASS::polr</a></code>,
<code><a href="MASS.html#topic+rlm">MASS::rlm</a></code> (with normality assumptions, defeating the purpose of rlm), <code><a href="nlme.html#topic+lme">nlme::lme</a></code>, 
<code><a href="nlme.html#topic+gls">nlme::gls</a></code>, <code><a href="lme4.html#topic+lmer">lme4::lmer</a></code>, <code><a href="lme4.html#topic+glmer">lme4::glmer</a></code>, 
<code><a href="mgcv.html#topic+gam">mgcv::gam</a></code>, <code><a href="gam.html#topic+gam">gam::gam</a></code>, <code><a href="survival.html#topic+coxph">survival::coxph</a></code>, 
<code><a href="survival.html#topic+survreg">survival::survreg</a></code>, 
<code><a href="nnet.html#topic+multinom">nnet::multinom</a></code>, <code><a href="stats.html#topic+nls">stats::nls</a></code>.
</p>
<p>It can be easily extended by implementing three generic functions:
<code><a href="#topic+fixcoef">fixcoef</a></code>, <code><a href="#topic+vcov_fixcoef">vcov_fixcoef</a></code> and <code><a href="#topic+df_for_wald">df_for_wald</a></code>.
If the implementations of <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code> and <code><a href="stats.html#topic+df.residual">df.residual</a></code> are consistent,
you do not have to implement <code>fixcoef</code>, <code>vcov_fixcoef</code> and <code>df_for_wald</code>.
</p>
<p>It also provides <code>method="LRT"</code> and <code>method="Rao"</code> on <code><a href="stats.html#topic+glm">stats::glm</a></code> and <code>method="LRT"</code> on
negative binomials (<code><a href="MASS.html#topic+glm.nb">negbin</a></code>) models.
It is implemented by inverting tests performed by <code><a href="#topic+p_value_contrast">p_value_contrast</a></code>, with the help of the Newton-Raphson algorithm
on the logit of the two-sided P-value.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Contrast functions: 
<code><a href="#topic+estimate_confint_contrast">estimate_confint_contrast</a>()</code>,
<code><a href="#topic+estimate_contrast">estimate_contrast</a>()</code>,
<code><a href="#topic+p_value_contrast">p_value_contrast</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
model1 = glm(family="gaussian", data=mtcars, hp ~ 0+factor(gear))
# do cars with 5 gears have more horse power (hp) than cars with 4 gears ?
confint_contrast(model1, c(0,-1,1))

# now, we fit an equivalent model (same distribution and same predictions)
model2 = glm(family=gaussian(log), data=mtcars, hp ~ 0+factor(gear))

# do cars with 5 gears have at least twice the horse power than cars with 4 gears ?

confint_contrast(model2, c(0,-1,0.5))

</code></pre>

<hr>
<h2 id='df_for_wald'>Gets the degree of freedom for Wald tests involving the model</h2><span id='topic+df_for_wald'></span><span id='topic+df_for_wald.glm'></span><span id='topic+df_for_wald.default'></span>

<h3>Description</h3>

<p>This generic function is used by <code><a href="#topic+p_value_contrast.default">p_value_contrast.default</a></code> to
get the number of degrees of freedom of the <a href="stats.html#topic+TDist">t distribution</a> that
approximates the point estimate of the contrast divided by its standard error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_for_wald(object, ...)

## S3 method for class 'glm'
df_for_wald(object, ...)

## Default S3 method:
df_for_wald(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_for_wald_+3A_object">object</code></td>
<td>
<p>statistical model;</p>
</td></tr>
<tr><td><code id="df_for_wald_+3A_...">...</code></td>
<td>
<p>Unused by <code>p_value_contrast.default</code>, but may be useful to some custom specializations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is quite similar to <code><a href="stats.html#topic+df.residual">df.residual</a></code> but it should return Inf when the Student's t
distribution is less appropriate than the normal distribution.
</p>


<h3>Value</h3>

<p>A finite value or Inf for normal distribution approximation.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>glm</code>: Returns <code><a href="stats.html#topic+df.residual">df.residual</a></code> for linear gaussian models and Inf
for all other models in order to make Wald's tests consistent with the behavior of <code><a href="stats.html#topic+summary.glm">stats::summary.glm(object)</a></code>
</p>
</li>
<li> <p><code>default</code>: Simple proxy to <code><a href="stats.html#topic+df.residual">df.residual</a></code> but replaces NAs with Inf
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Wald-related functions: 
<code><a href="#topic+fixcoef">fixcoef</a>()</code>,
<code><a href="#topic+p_value_contrast">p_value_contrast</a>()</code>,
<code><a href="#topic+vcov_fixcoef">vcov_fixcoef</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 10 observations, one coefficient, 9 degrees of freedom
df_for_wald(glm(I(1:10) ~ 1))
# returns Inf (non-gaussian-identity model)
df_for_wald(glm(family="poisson", c(10,20,30) ~ 1))
data(mtcars)
# returns Inf (non-gaussian-identity model)
df_for_wald(glm(family="binomial", data=mtcars, I(hp &gt; median(hp)) ~ cyl))
</code></pre>

<hr>
<h2 id='estimate_confint_contrast'>Computes point estimates, confidence intervals and P-values of a contrast</h2><span id='topic+estimate_confint_contrast'></span>

<h3>Description</h3>

<p>This function combines outputs from <code><a href="#topic+estimate_contrast">estimate_contrast</a></code>, <code><a href="#topic+confint_contrast">confint_contrast</a></code> and <code><a href="#topic+p_value_contrast">p_value_contrast</a></code> 
to provide a 4-values vector with point estimate (1st value), lower and upper boundaries of the confidence interval (2nd and 3rd values)
and P-value (4th value) comparing the contrast to <code>H0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_confint_contrast(
  model,
  contrast,
  method = NULL,
  level = 0.95,
  force = FALSE,
  debuglevel = 1,
  H0 = 0,
  alternative = c("two.sided", "less", "greater"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_confint_contrast_+3A_model">model</code></td>
<td>
<p>a fitted statistical model such as a glm or a coxph.</p>
</td></tr>
<tr><td><code id="estimate_confint_contrast_+3A_contrast">contrast</code></td>
<td>
<p>numeric vector of the same length as the number of coefficients in the model; it describes the contrast <code>sum(contrast*fixcoef(model))</code>.</p>
</td></tr>
<tr><td><code id="estimate_confint_contrast_+3A_method">method</code></td>
<td>
<p>character string value; specification of the algorithm used (implementation dependent). NULL must be accepted. The default method is &quot;Wald&quot;.
With the default <code>confint_contrast</code> and <code>p_value_contrast</code>, the only supported values are: &quot;Wald&quot;, &quot;wald&quot; and &quot;SlowWald&quot;.
All three are equivalent but &quot;SlowWald&quot; is slower and is used for debug purpose only. If <code>confint_contrast</code> and <code>p_value_contrast</code> are
specialized, they may provide other methods.</p>
</td></tr>
<tr><td><code id="estimate_confint_contrast_+3A_level">level</code></td>
<td>
<p>numeric value between 0 and 1; nominal two-sided confidence level of the confidence interval.</p>
</td></tr>
<tr><td><code id="estimate_confint_contrast_+3A_force">force</code></td>
<td>
<p>logical; if TRUE, force computation of P-values in case of convergence problems.</p>
</td></tr>
<tr><td><code id="estimate_confint_contrast_+3A_debuglevel">debuglevel</code></td>
<td>
<p>integer value; set to 0 (default) to disable warnings, 1 to enable warnings and 2 to enable warnings and notes.</p>
</td></tr>
<tr><td><code id="estimate_confint_contrast_+3A_h0">H0</code></td>
<td>
<p>numeric value; the value of the contrast under the null hypothesis.</p>
</td></tr>
<tr><td><code id="estimate_confint_contrast_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,</p>
</td></tr>
<tr><td><code id="estimate_confint_contrast_+3A_...">...</code></td>
<td>
<p>Additional parameters that may be used by some implementations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When alternative is &quot;less&quot; or  &quot;greater&quot;, a one-sided confidence interval and a one-sided P-value are generated.
If H0 is not zero, the P-value compares the estimate to the value of H0, but the estimate and confidence interval are unchanged.
</p>


<h3>See Also</h3>

<p>Other Contrast functions: 
<code><a href="#topic+confint_contrast">confint_contrast</a>()</code>,
<code><a href="#topic+estimate_contrast">estimate_contrast</a>()</code>,
<code><a href="#topic+p_value_contrast">p_value_contrast</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
model1 = glm(family="gaussian", data=mtcars, hp ~ 0+factor(gear))
# do cars with 5 gears have more horse power (hp) than cars with 4 gears ?
estimate_confint_contrast(model1, c(0,-1,1))

# now, we fit an equivalent model (same distribution and same predictions)
model2 = glm(family=gaussian(log), data=mtcars, hp ~ 0+factor(gear))

# do cars with 5 gears have at least twice the horse power than cars with 4 gears ?

estimate_confint_contrast(model2, c(0,-1,0.5))
</code></pre>

<hr>
<h2 id='estimate_contrast'>Point estimates of contrasts</h2><span id='topic+estimate_contrast'></span><span id='topic+estimate_contrast.default'></span>

<h3>Description</h3>

<p>This S3 generic function allows the computation of point estimates of contrasts
(i.e. linear combinations) of fixed-effects in many models
The default implementation computes Wald's confidence intervals with any model as long as it implements <code><a href="#topic+fixcoef">fixcoef</a></code>, returning a vector of fixed effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_contrast(model, contrast, method = NULL, ...)

## Default S3 method:
estimate_contrast(model, contrast, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_contrast_+3A_model">model</code></td>
<td>
<p>a fitted statistical model such as a glm or a coxph.</p>
</td></tr>
<tr><td><code id="estimate_contrast_+3A_contrast">contrast</code></td>
<td>
<p>numeric vector of the same length as the number of coefficients in the model; it describes the contrast <code>sum(contrast*fixcoef(model))</code>.</p>
</td></tr>
<tr><td><code id="estimate_contrast_+3A_method">method</code></td>
<td>
<p>character string value; specification of the algorithm used (implementation dependent). NULL must be accepted.
Suggested values are &quot;ML&quot; for maximum-likelihood, &quot;REML&quot; for restricted maximum-likelihood and &quot;OLS&quot; for ordinary least squares.</p>
</td></tr>
<tr><td><code id="estimate_contrast_+3A_...">...</code></td>
<td>
<p>Additional parameters that may be used by some implementations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should consistent with <code><a href="#topic+confint_contrast">confint_contrast</a></code> and <code><a href="#topic+p_value_contrast">p_value_contrast</a></code> as they are designed to be used together.
If a null hypothesis (H0) is specified, it MUST be ignored by <code>estimate_contrast</code>.
If you want to make it consistent with p_value_contrast you may substract H0 from the output of <code>estimate_contrast</code> and <code>confint_contrast</code>.
</p>


<h3>Value</h3>

<p>A single numeric value (vector of length 1) equal to the point estimate of the contrast, with the name &quot;pvalue&quot;.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Compute contrasts of fixed-effects in any model implementing <code><a href="#topic+fixcoef">fixcoef</a></code>.
It basically computes <code>sum(fixcoef(model) * contrast)</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Contrast functions: 
<code><a href="#topic+confint_contrast">confint_contrast</a>()</code>,
<code><a href="#topic+estimate_confint_contrast">estimate_confint_contrast</a>()</code>,
<code><a href="#topic+p_value_contrast">p_value_contrast</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
model1 = glm(family="gaussian", data=mtcars, hp ~ 0+factor(gear))
# do cars with 5 gears have more horse power (hp) than cars with 4 gears ?
estimate_contrast(model1, c(0,-1,1))

# now, we fit an equivalent model (same distribution and same predictions)
model2 = glm(family=gaussian(log), data=mtcars, hp ~ 0+factor(gear))

# do cars with 5 gears have at least twice the horse power than cars with 4 gears ?

estimate_contrast(model1, c(0,-1,0.5))

</code></pre>

<hr>
<h2 id='fixcoef'>Generic function to get fixed effects of a model</h2><span id='topic+fixcoef'></span><span id='topic+fixcoef.lmerMod'></span><span id='topic+fixcoef.glmerMod'></span><span id='topic+fixcoef.lmerModLmerTest'></span><span id='topic+fixcoef.lme'></span><span id='topic+fixcoef.multinom'></span><span id='topic+fixcoef.mlm'></span><span id='topic+fixcoef.default'></span>

<h3>Description</h3>

<p>This is a generic S3 function that gets point estimates of fixed effects of a statistical model, implemented on a wide range of models and that can be extended to new models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixcoef(model, ...)

## S3 method for class 'lmerMod'
fixcoef(model, ...)

## S3 method for class 'glmerMod'
fixcoef(model, ...)

## S3 method for class 'lmerModLmerTest'
fixcoef(model, ...)

## S3 method for class 'lme'
fixcoef(model, ...)

## S3 method for class 'multinom'
fixcoef(model, ...)

## S3 method for class 'mlm'
fixcoef(model, ...)

## Default S3 method:
fixcoef(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixcoef_+3A_model">model</code></td>
<td>
<p>a fitted statistical model</p>
</td></tr>
<tr><td><code id="fixcoef_+3A_...">...</code></td>
<td>
<p>argument unused by <code><a href="#topic+p_value_contrast.default">p_value_contrast.default</a></code> but that may be useful to some specializations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It must return only estimates of fixed-effects of a model. Random effects are ignored.
The <code><a href="base.html#topic+names">names</a></code> of the element of this vector must be consistent
with the <code>rownames</code> and <code>colnames</code>
of the variance-covariance matrix that <code><a href="#topic+vcov_fixcoef">vcov_fixcoef</a></code> returns.
The <code>vcov_fixcoef</code> function, on the same model, must return a matrix
with the same number and names of rows and columns as the length of the vector returned by <code>fixcoef</code>.
</p>
<p>The functions <code><a href="#topic+vcov_fixcoef">vcov_fixcoef</a></code> and <code><a href="#topic+fixcoef">fixcoef</a></code> would be pointless if the behavior of
<code><a href="stats.html#topic+vcov">vcov</a></code> and <code><a href="stats.html#topic+coef">coef</a></code> were not inconsistent from package to package.
</p>
<p><code>fixcoef</code> and <code>vcov_fixcoef</code>, together with <code><a href="#topic+df_for_wald">df_for_wald</a></code> are used by <code><a href="#topic+p_value_contrast.default">p_value_contrast.default</a></code>
</p>


<h3>Value</h3>

<p>Simple numeric vector with one item for each fixed effect of the model.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>lmerMod</code>: implementation for <code><a href="lme4.html#topic+lmer">lme4::lmer</a></code>
</p>
</li>
<li> <p><code>glmerMod</code>: implementation for <code><a href="lme4.html#topic+glmer">lme4::glmer</a></code>
</p>
</li>
<li> <p><code>lmerModLmerTest</code>: implementation for <code><a href="lmerTest.html#topic+lmer">lmerTest::lmer</a></code>
</p>
</li>
<li> <p><code>lme</code>: implementation for <code><a href="nlme.html#topic+lme">nlme::lme</a></code>
</p>
</li>
<li> <p><code>multinom</code>: implementation for <code><a href="nnet.html#topic+multinom">nnet::multinom</a></code>
</p>
</li>
<li> <p><code>mlm</code>: implementation for multiple responses linear models generated by <code><a href="stats.html#topic+lm">stats::lm</a></code> when the response is a matrix.
It transforms the matrix to a vector, consistent with <code><a href="stats.html#topic+vcov">stats::vcov</a></code>.
</p>
</li>
<li> <p><code>default</code>: default implementation, simply calls coef(model).
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Wald-related functions: 
<code><a href="#topic+df_for_wald">df_for_wald</a>()</code>,
<code><a href="#topic+p_value_contrast">p_value_contrast</a>()</code>,
<code><a href="#topic+vcov_fixcoef">vcov_fixcoef</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
fixcoef(lm(data=mtcars, hp ~ 1)) # get mean horse power of cars listed in mtcars
</code></pre>

<hr>
<h2 id='glmglrt'>glmglrt: GLRT P-Values in Generalized Linear Models</h2><span id='topic+glmglrt'></span>

<h3>Description</h3>

<p>This package has been developed to provide Generalized Likelihood Ratio Tests (GLRT)
also known as Likelihood Ratio Tests (LRT) to Generalized Linear Models (GLMs).
The <a href="stats.html#topic+stats">stats</a> package do support LRT P-values with <code><a href="stats.html#topic+anova">anova</a></code> and
derived confidence intervals with <code>confint()</code>, but provides Wald's P-values with
the <code><a href="stats.html#topic+summary.glm">summary</a></code> function.
This is unfortunate for two reasons: Wald's P-values may be inconsistent with profile-likelihood
confidence intervals and Wald's P-values, on small samples are more biased than LRT P-values, for
non-gaussian models. The <code><a href="stats.html#topic+anova">anova</a></code> function is not as simple as
<code><a href="stats.html#topic+summary.glm">summary</a></code>, since it requires manually fitting two models.
</p>


<h3>Summary function</h3>

<p>This package provides a way to override (see <a href="#topic+override_summary">override_summary</a>) the standard <code><a href="stats.html#topic+summary.glm">summary.glm</a></code> function
by a <code><a href="#topic+summarylr">summarylr</a></code> function that provides LRT and/or Rao's score P-values.
</p>


<h3>Functions to estimate contrasts</h3>

<p>It also provides functions <code><a href="#topic+estimate_contrast">estimate_contrast</a></code>, <code><a href="#topic+confint_contrast">confint_contrast</a></code> and <code><a href="#topic+p_value_contrast">p_value_contrast</a></code>
to estimate contrasts of coefficients of GLMs with LRT, Rao's and Wald's hypothesis tests and confidence intervals
This is an alternative to <code><a href="multcomp.html#topic+glht">multcomp::glht</a></code> without
Wald's approximation ! It also provides a less powerful <code><a href="#topic+p_value.glm">p_value.glm</a></code> method for the S3 generic
<a href="parameters.html#topic+p_value">parameters::p_value</a>. It also extends this S3 generic for a variety
of models as <code><a href="parameters.html#topic+p_value.default">p_value.default</a></code>. That time, the only method supported for all models, is Wald's method.
</p>

<hr>
<h2 id='override_summary'>Overrides the Generalized Linear Models summary methods</h2><span id='topic+override_summary'></span>

<h3>Description</h3>

<p>This function overrides the <code><a href="stats.html#topic+summary.glm">summary.glm</a></code>
and <code><a href="stats.html#topic+summary.glm">summary.negbin</a></code> S3 methods
by the <code><a href="#topic+summarylr">summarylr</a></code> function in the calling environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>override_summary()
</code></pre>


<h3>Details</h3>

<p>Although some minor compatibility issues may exist when calling this function in the global environment,
most scripts should work with it. Indeed <code><a href="#topic+summarylr">summarylr</a></code> behaves like <code><a href="stats.html#topic+summary.glm">summary.glm</a></code>
but adds a $extra field containing P-value info. The first letter of the field name ('e') is unique, avoiding problems
with scripts that access fields with short names (e.g. model$x for model$xlevels).
</p>


<h3>See Also</h3>

<p>Other Extended GLM summary functions: 
<code><a href="#topic+print.summary.glmglrt">print.summary.glmglrt</a>()</code>,
<code><a href="#topic+summarylr">summarylr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model = glm(family="binomial", cbind(50,30) ~ 1)
override_summary()
summary(model) # Additional 'LRT P-value' column
</code></pre>

<hr>
<h2 id='p_value_contrast'>Hypothesis tests on contrasts</h2><span id='topic+p_value_contrast'></span><span id='topic+p_value_contrast.glm'></span><span id='topic+p_value_contrast.default'></span>

<h3>Description</h3>

<p>This S3 generic function allows the computation of P-values associated to
hypothesis tests of contrasts (i.e. linear combinations) of fixed-effects in a model.
The default implementation computes Wald's P-values with any model as long as it consistently implements <code><a href="#topic+fixcoef">fixcoef</a></code>, <code><a href="#topic+vcov_fixcoef">vcov_fixcoef</a></code> and <code><a href="#topic+df_for_wald">df_for_wald</a></code>.
It is also specialized for GLMs and negative binomial models (see <code><a href="MASS.html#topic+glm.nb">MASS::glm.nb</a></code>) with Wald's, LRT and Rao's P-values and may be specialized with other models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_value_contrast(
  model,
  contrast,
  alternative = c("two.sided", "less", "greater"),
  H0 = 0,
  method = NULL,
  ...
)

## S3 method for class 'glm'
p_value_contrast(
  model,
  contrast,
  alternative = c("two.sided", "less", "greater"),
  H0 = 0,
  method = c("LRT", "Rao", "Chisq", "F", "Wald", "wald"),
  ...,
  debuglevel = 1,
  force = FALSE
)

## Default S3 method:
p_value_contrast(
  model,
  contrast,
  alternative = c("two.sided", "less", "greater"),
  H0 = 0,
  method = "Wald",
  ...,
  debuglevel = 0,
  force = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_value_contrast_+3A_model">model</code></td>
<td>
<p>a fitted statistical model such as a glm or a coxph.</p>
</td></tr>
<tr><td><code id="p_value_contrast_+3A_contrast">contrast</code></td>
<td>
<p>numeric vector of the same length as the number of coefficients in the model; it describes the contrast <code>sum(contrast*fixcoef(model))</code>.</p>
</td></tr>
<tr><td><code id="p_value_contrast_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;. You can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="p_value_contrast_+3A_h0">H0</code></td>
<td>
<p>numeric value; the value of the contrast under the null hypothesis.</p>
</td></tr>
<tr><td><code id="p_value_contrast_+3A_method">method</code></td>
<td>
<p>character string value; specification of the algorithm used (implementation dependent).
Suggested values are &quot;Wald&quot;, &quot;LRT&quot;, &quot;Rao&quot; and &quot;exact&quot; for, respectively, Wald's asymptotic normality and/or student test,
the Generalized Likelihood Ratio Test, Rao's score test and non-asymptotic exact tests. Other values may be allowed.</p>
</td></tr>
<tr><td><code id="p_value_contrast_+3A_...">...</code></td>
<td>
<p>Additional parameters that may be used by some implementations.</p>
</td></tr>
<tr><td><code id="p_value_contrast_+3A_debuglevel">debuglevel</code></td>
<td>
<p>integer value; set to 0 (default) to disable warnings, 1 to enable warnings and 2 to enable warnings and notes.</p>
</td></tr>
<tr><td><code id="p_value_contrast_+3A_force">force</code></td>
<td>
<p>logical; if TRUE, force computation of P-values in case of convergence problems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every implementation MUST support specification of the alternative hypothesis
(alternative argument) and null hypothesis (H0 argument).
</p>


<h3>Value</h3>

<p>A single numeric value (vector of length 1) equal to the one-sided (for alternative=&quot;less&quot; or &quot;greater&quot;) or two-sided P-value
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>glm</code>: It supports Wald (method=&quot;Wald&quot;),
Generalized Likelihood Ratio Tests (method=&quot;LRT&quot;) and Rao's score tests (method=&quot;Rao&quot;).
It works for <code><a href="stats.html#topic+glm">stats::glm</a></code> models and negative binomial models (<code><a href="MASS.html#topic+glm.nb">MASS::glm.nb</a></code>) with method=&quot;LRT&quot; and method=&quot;Wald&quot;.
</p>
</li>
<li> <p><code>default</code>: Supports Wald's test on a wide range of models, including <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+lm">mlm</a></code>,
<code><a href="stats.html#topic+glm">stats::glm</a></code>, <code><a href="MASS.html#topic+glm.nb">negbin</a></code>, <code><a href="MASS.html#topic+polr">MASS::polr</a></code>,
<code><a href="MASS.html#topic+rlm">MASS::rlm</a></code> (with normality assumptions, defeating the purpose of rlm), <code><a href="nlme.html#topic+lme">nlme::lme</a></code>, 
<code><a href="nlme.html#topic+gls">nlme::gls</a></code>, <code><a href="lme4.html#topic+lmer">lme4::lmer</a></code>, <code><a href="lme4.html#topic+glmer">lme4::glmer</a></code>, 
<code><a href="mgcv.html#topic+gam">mgcv::gam</a></code>, <code><a href="gam.html#topic+gam">gam::gam</a></code>, <code><a href="survival.html#topic+coxph">survival::coxph</a></code>, 
<code><a href="survival.html#topic+survreg">survival::survreg</a></code>, 
<code><a href="nnet.html#topic+multinom">nnet::multinom</a></code>, <code><a href="stats.html#topic+nls">stats::nls</a></code>.
</p>
<p>It can be easily extended by implementing three generic functions:
<code><a href="#topic+fixcoef">fixcoef</a></code>, <code><a href="#topic+vcov_fixcoef">vcov_fixcoef</a></code> and <code><a href="#topic+df_for_wald">df_for_wald</a></code>.
If the implementations of <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code> and <code><a href="stats.html#topic+df.residual">df.residual</a></code> are consistent,
you do not have to implement <code>fixcoef</code>, <code>vcov_fixcoef</code> and <code>df_for_wald</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Wald-related functions: 
<code><a href="#topic+df_for_wald">df_for_wald</a>()</code>,
<code><a href="#topic+fixcoef">fixcoef</a>()</code>,
<code><a href="#topic+vcov_fixcoef">vcov_fixcoef</a>()</code>
</p>
<p>Other Contrast functions: 
<code><a href="#topic+confint_contrast">confint_contrast</a>()</code>,
<code><a href="#topic+estimate_confint_contrast">estimate_confint_contrast</a>()</code>,
<code><a href="#topic+estimate_contrast">estimate_contrast</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
model1 = glm(family="gaussian", data=mtcars, hp ~ 0+factor(gear))
# do cars with 5 gears have more horse power (hp) than cars with 4 gears ?
p_value_contrast(model1, c(0,-1,1), alternative="greater")

# now, we fit an equivalent model (same distribution and same predictions)
model2 = glm(family=gaussian(log), data=mtcars, hp ~ 0+factor(gear))

# do cars with 5 gears have at least twice the horse power than cars with 4 gears ?

# the following two tests are equivalent
p_value_contrast(model1, c(0,-1,0.5), alternative="greater", method="LRT", H0=0)
p_value_contrast(model2, c(0,-1,1), alternative="greater", method="LRT", H0=log(2))

# the following two tests are close but not equivalent
p_value_contrast(model1, c(0,-1,0.5), alternative="greater", method="Wald", H0=0)
p_value_contrast(model2, c(0,-1,1), alternative="greater", method="Wald", H0=log(2))
</code></pre>

<hr>
<h2 id='p_value.glm'>Computing p-values of hypothesis tests on coefficients of Generalized Linear Models and other</h2><span id='topic+p_value.glm'></span>

<h3>Description</h3>

<p>This S3 method is a specialization of <code><a href="parameters.html#topic+p_value">parameters::p_value</a></code>
for <code><a href="stats.html#topic+glm">stats::glm</a></code> models.
By default, it computes Wald's P-values that are known to be more biased than LRT P-values,
but the behavior can be overriden by the method=&quot;LRT&quot; argument.
This is for compatibility with the default method of <code><a href="parameters.html#topic+p_value">parameters::p_value</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
p_value(
  model,
  method = NULL,
  parm = NULL,
  alternative = c("two.sided", "less", "greater"),
  H0 = 0,
  debuglevel = 1,
  force = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_value.glm_+3A_model">model</code></td>
<td>
<p>glm object; as obtained by calling <code><a href="stats.html#topic+glm">stats::glm</a></code> or <code><a href="MASS.html#topic+glm.nb">MASS::glm.nb</a></code>.</p>
</td></tr>
<tr><td><code id="p_value.glm_+3A_method">method</code></td>
<td>
<p>character value; may either be &quot;LRT&quot; (synonym &quot;Chisq&quot;), &quot;Rao&quot;, &quot;wald&quot; (default value, synonym &quot;Wald&quot; and &quot;F&quot;).</p>
</td></tr>
<tr><td><code id="p_value.glm_+3A_parm">parm</code></td>
<td>
<p>integer or character vector or NULL; specify coefficients to test, by name or indexes.
the default parm=NULL outputs all coefficients.</p>
</td></tr>
<tr><td><code id="p_value.glm_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;. You can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="p_value.glm_+3A_h0">H0</code></td>
<td>
<p>numeric vector of length 1 or of the same length as parm; the value of the coefficient under the null hypothesis. Zero by default.</p>
</td></tr>
<tr><td><code id="p_value.glm_+3A_debuglevel">debuglevel</code></td>
<td>
<p>integer value; set to 0 (default) to disable warnings, 1 to enable warnings and 2 to enable warnings and notes.</p>
</td></tr>
<tr><td><code id="p_value.glm_+3A_force">force</code></td>
<td>
<p>logical; if TRUE, force computation of P-values in case of convergence problems.</p>
</td></tr>
<tr><td><code id="p_value.glm_+3A_...">...</code></td>
<td>
<p>Ignored arguments. Allows compatibility with the generic <code><a href="parameters.html#topic+p_value">parameters::p_value</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with two columns; the first column, Parameter represents the name of the coefficient
and p (second column) represents the P-value of the hypothesis test against H0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("parameters")
mod = glm(family="poisson", c(2,30) ~ c(0,1), offset=log(c(8,30)))
# Wald's tests (biased)
p_value(mod)
# Rao score tests (biased)
p_value(mod, method="Rao")
# LRT tests (less biased)
p_value(mod, method="LRT")

# only test slope (faster since only one test is performed)
p_value(mod, method="LRT", parm=2)
# is slope greater than log(2) ?
p_value(mod, method="LRT", parm=2, H0=log(2), alternative="greater")
</code></pre>

<hr>
<h2 id='print.summary.glmglrt'>Prints the summary generated by <code><a href="#topic+summarylr">summarylr</a></code></h2><span id='topic+print.summary.glmglrt'></span>

<h3>Description</h3>

<p>This function prints a <code>summary.glmglrt</code> object generated by <code><a href="#topic+summarylr">summarylr</a></code>.
It works like the standard <code><a href="stats.html#topic+summary.glm">summary.glm</a></code> function but additionnally
displays columns showing Rao or LRT P-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.glmglrt'
print(
  x,
  ...,
  has.Pvalue = TRUE,
  tst.ind = 3,
  debuglevel = NULL,
  keep.wald = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.glmglrt_+3A_x">x</code></td>
<td>
<p>a <code>summary.glmglrt</code> object generated by <code><a href="#topic+summarylr">summarylr</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.glmglrt_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="stats.html#topic+summary.glm">stats::print.summary.glm</a></code> then <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>. The most useful ones are <code>digits</code> and <code>signif.stars</code>.</p>
</td></tr>
<tr><td><code id="print.summary.glmglrt_+3A_has.pvalue">has.Pvalue</code></td>
<td>
<p>logical value; passed to <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>; if TRUE, the P-value column is formatted by <code><a href="base.html#topic+format.pval">format.pval</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.glmglrt_+3A_tst.ind">tst.ind</code></td>
<td>
<p>integer vector of length&gt;=0; passed to <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>; it changes the format of these columns, assuming they are statistics columns.</p>
</td></tr>
<tr><td><code id="print.summary.glmglrt_+3A_debuglevel">debuglevel</code></td>
<td>
<p>NULL or integer value; set to NULL to use the debuglevel argument that was specified in  <code><a href="#topic+summarylr">summarylr</a></code>, 0 (default) to disable warnings, 1 to enable warnings and 2 to enable warnings and notes.</p>
</td></tr>
<tr><td><code id="print.summary.glmglrt_+3A_keep.wald">keep.wald</code></td>
<td>
<p>NULL or logical; set to NULL to use the keep.wald argument that was specified in <code><a href="#topic+summarylr">summarylr</a></code>. If TRUE, the standard Wald's P-values are displayed. If FALSE, the standard Wald's P-values are hidden.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Extended GLM summary functions: 
<code><a href="#topic+override_summary">override_summary</a>()</code>,
<code><a href="#topic+summarylr">summarylr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model = glm(family="binomial", cbind(50,30) ~ 1)
print(summarylr(model),signif.stars=FALSE,digits=10)

</code></pre>

<hr>
<h2 id='ps_newtonRaphson'>Newton-Raphson algorithm when parameters may not be estimable outside of their parameter space</h2><span id='topic+ps_newtonRaphson'></span>

<h3>Description</h3>

<p>This is used by <code><a href="#topic+confint_contrast.default">confint_contrast.default</a></code> to find the lower and upper boundaries of the confidence interval so that they have a P-value equal to 1-level.
This makes it possible to compute contrast on log-binomial models when solutions are close to the boundaries of the parameter space 
and Newton-Raphson may compute some intermediate values outside of the valid parameter space, leading to P-values equal to NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps_newtonRaphson(
  rootfun,
  x,
  xabstol = 1e-05,
  derivdelta = xabstol,
  yabstol = 1e-05,
  niter = 100,
  extraiter = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ps_newtonRaphson_+3A_rootfun">rootfun</code></td>
<td>
<p>a function taking a single numeric value. The algorithm searches for a root (zero) of this function.</p>
</td></tr>
<tr><td><code id="ps_newtonRaphson_+3A_x">x</code></td>
<td>
<p>a single numeric value; starting value, not too far from the root of rootfun.</p>
</td></tr>
<tr><td><code id="ps_newtonRaphson_+3A_xabstol">xabstol</code></td>
<td>
<p>a single numeric value; when two consecutive iterations of the algorithm lead to x solutions with a difference larger than xabstol, 
the algorithm has not yet converged and continues to run. Set to Inf, if you want to only want to rely on yabstol.</p>
</td></tr>
<tr><td><code id="ps_newtonRaphson_+3A_derivdelta">derivdelta</code></td>
<td>
<p>a single numeric value; the numeric delta used for numeric derivation of rootfun (assessed at x-derivdelta and x+derivdelta)</p>
</td></tr>
<tr><td><code id="ps_newtonRaphson_+3A_yabstol">yabstol</code></td>
<td>
<p>a single numeric value; when the algorithm leads to a y=rootfun(x) larger (in absolute value) than yabstol, the algorithm has not yet converged 
and continues to run. Set to Inf, if you want to only want to rely on xabstol.</p>
</td></tr>
<tr><td><code id="ps_newtonRaphson_+3A_niter">niter</code></td>
<td>
<p>a single integer value; the maximum number of iterations before considering that the algorithm failed to converge.</p>
</td></tr>
<tr><td><code id="ps_newtonRaphson_+3A_extraiter">extraiter</code></td>
<td>
<p>a single integer value; the number of extra iterations performed once convergence has been found.
This is useful to make sure that convergence is good on platforms having high floating point precision allowing to use, at the same time,
a weak convergence tolerance to make sure it converges on platforms having low floating point precision.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It assumes that <code>rootfun</code> is NA above the upper boundary of the parameter space and below the lower boundary of the parameter space.
The parameter space must not have &quot;holes&quot; (i.e. valid, then invalid, then valid again).
Invalid values are described by NA. The actual interval of valid values are automatically found by the algorithm, so you do 
not have to explicitly specify the minimum and maximum values of the parameter space.
</p>


<h3>Value</h3>

<p>a list object with the following fields:
</p>

<dl>
<dt><code>root</code></dt><dd><p>the x value so that rootfun(x) is as close as possible to 0</p>
</dd>
<dt><code>f.root</code></dt><dd><p>rootfun(root)</p>
</dd>
<dt><code>yabstol</code></dt><dd><p>the parameter of the same name</p>
</dd>
<dt><code>iter</code></dt><dd><p>the number of iterations of the Newton-Raphson algorithm performed before reaching convergence</p>
</dd>
<dt><code>estim.prec</code></dt><dd><p>the latest move (on the x variable) done before convergence</p>
</dd>
<dt><code>prevx</code></dt><dd><p>the previous x value, in the algorithm, just before x=root was reached</p>
</dd>
<dt><code>prevy</code></dt><dd><p>rootfun(prevx)</p>
</dd>
<dt><code>prevder</code></dt><dd><p>numeric derivative of rootfun at prevx</p>
</dd>
</dl>


<hr>
<h2 id='summarylr'>Summarizes a glm, adding a column of GLRT or Rao score P-values</h2><span id='topic+summarylr'></span>

<h3>Description</h3>

<p><code>summarylr</code> is an improved summary function for standard glm (stats package) adding LRT or Rao score P-values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarylr(
  object,
  dispersion = NULL,
  correlation = FALSE,
  symbolic.cor = FALSE,
  ...,
  force = FALSE,
  debuglevel = level_warning,
  method = "LRT",
  keep.wald = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarylr_+3A_object">object</code></td>
<td>
<p>glm object; as obtained by calling <code><a href="stats.html#topic+glm">stats::glm</a></code> or <code><a href="MASS.html#topic+glm.nb">MASS::glm.nb</a></code>.</p>
</td></tr>
<tr><td><code id="summarylr_+3A_dispersion">dispersion</code></td>
<td>
<p>the dispersion parameter for the family used. Either a single numerical value or NULL (the default), when it is inferred from object (see <code><a href="stats.html#topic+summary.glm">stats::summary.glm</a></code>).</p>
</td></tr>
<tr><td><code id="summarylr_+3A_correlation">correlation</code></td>
<td>
<p>logical; if TRUE, the correlation matrix of the estimated parameters is returned and printed (see <code><a href="stats.html#topic+summary.glm">stats::summary.glm</a></code>).</p>
</td></tr>
<tr><td><code id="summarylr_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical; if TRUE, print the correlations in a symbolic form (see <code><a href="stats.html#topic+symnum">symnum</a></code>) rather than as numbers (see <code><a href="stats.html#topic+summary.glm">stats::summary.glm</a></code>).</p>
</td></tr>
<tr><td><code id="summarylr_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stats.html#topic+summary.glm">stats::summary.glm</a></code></p>
</td></tr>
<tr><td><code id="summarylr_+3A_force">force</code></td>
<td>
<p>logical; if TRUE, force computation of P-values in case of convergence problems.</p>
</td></tr>
<tr><td><code id="summarylr_+3A_debuglevel">debuglevel</code></td>
<td>
<p>integer value; set to 0 (default) to disable warnings, 1 to enable warnings and 2 to enable warnings and notes.</p>
</td></tr>
<tr><td><code id="summarylr_+3A_method">method</code></td>
<td>
<p>NULL or character vector of length 0, 1 or 2; may be code&quot;LRT&quot; or <code>"Rao"</code> or <code>c("LRT", "Rao")</code> to compute specified P-values.
You can set <code>method=NULL</code> to compute no additional P-values.</p>
</td></tr>
<tr><td><code id="summarylr_+3A_keep.wald">keep.wald</code></td>
<td>
<p>logical; if TRUE, the standard Wald's P-values are kept in the output of <code><a href="#topic+print.summary.glmglrt">print.summary.glmglrt</a></code>. Even if keep.wald=FALSE, the standard wald P-values are not erased from the <code>summary.glmglrt</code> object. They are only hidden by <code><a href="#topic+print.summary.glmglrt">print.summary.glmglrt</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works the same as the standard <code><a href="stats.html#topic+summary.glm">summary.glm</a></code> function but provides additionnal parameters
The core parameter <code>method="LRT"</code> makes <code>summarylr</code> adds a column <code>LRT P-value</code>
to the output. This P-value is computed by repeatdly fitting the model dropping
one coefficient at a time and using the <code><a href="stats.html#topic+anova.glm">anova.glm(test=&quot;Chisq&quot;)</a></code> function to perform
generalized likelihood ratio test by approximation of the deviance difference
to a chi-square distribution. This provides P-values less biased than the standard Wald P-values
that <code>summary</code> provides. Moreover, this LRT method is consistent with the profile likelihood
confidence intervals that <code><a href="MASS.html#topic+confint">confint.glm</a></code> provides.
The option <code>method="Rao"</code> generates Rao's score P-values. <code>method="Chisq"</code> is synonymous to <code>method="LRT"</code>.
For exhaustivity, the option <code>method="Wald"</code> (synonym &quot;wald&quot;, &quot;F&quot;) generates Wald's P-values.
Several methods can be used, e.g. <code>method=c("LRT","Rao")</code> computes both LRT and Rao P-values. New methods may be added in the future.
</p>
<p>Extra parameters are passed-through to the <code><a href="stats.html#topic+summary.glm">summary.glm</a></code> function.
</p>


<h3>Value</h3>

<p>It returns a summary object of type <code>summary.glmglrt</code> that gets pretty printed by <code>link[glmglrt:print.summary.glmglrt]{print.summary.glmglrt}</code>
The return value is an S3 object compatible with <code><a href="stats.html#topic+summary.glm">stats::summary.glm</a></code> but with an additional field <code>$extra</code> field having sub-fields.
<code>$extra$pvalues</code> is a numeric matrix with columns &quot;LRT P-value&quot; and/or &quot;Rao P-value&quot;, containing the relevant P-values. As new columns may be added in future, you should rely on column names rather than column indexes. Only P-values of methods requested in the <code>method</code> parameter are stored in this matrix.
<code>$extra$debuglevel</code> is equal to the <code>debuglevel</code> passed to <code>summarylr</code>.
<code>$extra$keep.wald</code> is equal to the <code>keep.wald</code> passed to <code>summarylr</code>.
In case of convergence problems, the field <code>$extra$problem_of_convergence</code> will be added. It will be a character string with the value <code>"general"</code> (because model$converged = FALSE), <code>"all"</code> (because all coefficients have huge variances) or <code>"specific"</code> (because at least one coefficient has a huge variance). Other problem strings may be added in the future.
If <a href="stats.html#topic+glm">weights</a> are specified in a way that make P-values invalid, the field <code>$extra$problem_weights</code> will be added as a character string describing the problem. Actually, the only known problem is <code>"non-constant"</code>.
</p>


<h3>See Also</h3>

<p>Other Extended GLM summary functions: 
<code><a href="#topic+override_summary">override_summary</a>()</code>,
<code><a href="#topic+print.summary.glmglrt">print.summary.glmglrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summarylr(glm(family="binomial", cbind(5,3)~1))
data(mtcars)
# do not properly converge (warnings)
mtcars$outcome = mtcars$disp &gt; median(mtcars$disp)
mod=glm(family=binomial(log), data=mtcars,outcome ~ 0+qsec+wt,start=c(-0.1,0.3))
summarylr(mod) # warns that P-values are not computed because model did not converge
summarylr(mod, force=TRUE) # compute P-values anyway !
# also works with negative binomial models
summarylr(MASS::glm.nb(data=mtcars, I(cyl*gear) ~ 1+wt,link="sqrt"),test="LRT")
</code></pre>

<hr>
<h2 id='vcov_fixcoef'>Gets the variance-covariance matrix of fixed effects of a fitted model</h2><span id='topic+vcov_fixcoef'></span><span id='topic+vcov_fixcoef.default'></span><span id='topic+vcov_fixcoef.survreg'></span>

<h3>Description</h3>

<p>This is a generic S3 function that gets the variance-covariance matrix of fixed effects of a statistical model, implemented on a wide range of models and that can be extended to new models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcov_fixcoef(model, ...)

## Default S3 method:
vcov_fixcoef(model, ...)

## S3 method for class 'survreg'
vcov_fixcoef(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov_fixcoef_+3A_model">model</code></td>
<td>
<p>a fitted statistical model</p>
</td></tr>
<tr><td><code id="vcov_fixcoef_+3A_...">...</code></td>
<td>
<p>argument unused by <code><a href="#topic+p_value_contrast.default">p_value_contrast.default</a></code> but that may be useful to some specializations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It must return variance-covariance for fixed effects of a model, not random effects nor scale parameters.
The <code>rownames</code> and <code>colnames</code> of the returned matrix
must be consistent with <code><a href="base.html#topic+names">names</a></code> of <code><a href="#topic+fixcoef">fixcoef</a>(object)</code>.
</p>
<p>The functions <code><a href="#topic+vcov_fixcoef">vcov_fixcoef</a></code> and <code><a href="#topic+fixcoef">fixcoef</a></code> would be pointless if the behavior of
<code><a href="stats.html#topic+vcov">vcov</a></code> and <code><a href="stats.html#topic+coef">coef</a></code> were not inconsistent from package to package.
</p>
<p><code>fixcoef</code> and <code>vcov_fixcoef</code>, together with <code><a href="#topic+df_for_wald">df_for_wald</a></code> are used by <code><a href="#topic+p_value_contrast.default">p_value_contrast.default</a></code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: default implementation, simple proxy of <code><a href="stats.html#topic+vcov">vcov</a>(model)</code>
</p>
</li>
<li> <p><code>survreg</code>: implementation for survreg, removing the extra column for Scale
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Wald-related functions: 
<code><a href="#topic+df_for_wald">df_for_wald</a>()</code>,
<code><a href="#topic+fixcoef">fixcoef</a>()</code>,
<code><a href="#topic+p_value_contrast">p_value_contrast</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
mod = lm(data=mtcars, hp ~ cyl+wt)
est = fixcoef(mod) # get estimates
SE = sqrt(diag(vcov_fixcoef(mod))) # get standard errors of estimates
z  = est/SE # get z-score of estimates
df = df_for_wald(mod) # degrees of freedom
pvalues = 2*pt(-abs(z), df=df) # get two-sided P-values
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
