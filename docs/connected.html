<!DOCTYPE html><html lang="en"><head><title>Help for package connected</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {connected}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#con_check'><p>Check connectedness of multiple factors in a dataframe</p></a></li>
<li><a href='#con_concur'><p>View concurrence of two factors in a dataframe using a matrix plot.</p></a></li>
<li><a href='#con_filter'><p>Filter a dataframe using two-way criteria to increase connectedness</p></a></li>
<li><a href='#con_view'><p>View connectedness of two factors in a dataframe using a levelplot</p></a></li>
<li><a href='#data_eccleston'><p>Data from Eccleston &amp; Russell</p></a></li>
<li><a href='#data_fernando'><p>Data from Fernando et al.</p></a></li>
<li><a href='#data_searle'><p>Data from Searle</p></a></li>
<li><a href='#data_student'>
<p>Simulated Data of Student Test Scores</p></a></li>
<li><a href='#data_tosh'><p>Data from Tosh</p></a></li>
<li><a href='#data_weeks1'><p>Data from Weeks &amp; Williams example 1</p></a></li>
<li><a href='#data_weeks2'><p>Data from Weeks &amp; Williams example 2</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Visualize and Improve Connectedness of Factors in Tables</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Visualize the connectedness of factors in two-way tables.
  Perform two-way filtering to improve the degree of connectedness.
  See Weeks &amp; Williams (1964) &lt;<a href="https://doi.org/10.1080%2F00401706.1964.10490188">doi:10.1080/00401706.1964.10490188</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, lattice, lfe, reshape2, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>agridat, dplyr, janitor, knitr, lme4, lucid, rmarkdown,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kwstat.github.io/connected/">https://kwstat.github.io/connected/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kwstat/connected/issues">https://github.com/kwstat/connected/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-03 19:01:50 UTC; wrightkevi</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Wright <a href="https://orcid.org/0000-0002-0617-8673"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Wright &lt;kw.stat@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-05 13:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='con_check'>Check connectedness of multiple factors in a dataframe</h2><span id='topic+con_check'></span>

<h3>Description</h3>

<p>Multiple factors in a dataframe are said to be connected if a model matrix
based on those factors is full rank.
</p>
<p>This function provides a formula interface to the lfe::compfactor() function
to check for connectedness of the factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>con_check(data = NULL, formula = NULL, WW = TRUE, dropNA = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="con_check_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="con_check_+3A_formula">formula</code></td>
<td>
<p>A formula with multiple factor names in the dataframe,
like <code>y ~ f1 + f2 + f3</code></p>
</td></tr>
<tr><td><code id="con_check_+3A_ww">WW</code></td>
<td>
<p>Pass-through argument to <code>compfactor</code></p>
</td></tr>
<tr><td><code id="con_check_+3A_dropna">dropNA</code></td>
<td>
<p>If TRUE, observed data that are <code>NA</code> will be dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with integers representing the group membership of each observation.
</p>


<h3>Author(s)</h3>

<p>Kevin Wright
</p>


<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In the data_eccleston dataframe, each pair of factors is connected.
con_check(data_eccleston, ~ row + trt)
con_check(data_eccleston, ~ col + trt)
con_check(data_eccleston, ~ row + col)
# But all three factors are COMPLETELY disconnected into 16 groups.
con_check(data_eccleston, ~ row + col + trt)

</code></pre>

<hr>
<h2 id='con_concur'>View concurrence of two factors in a dataframe using a matrix plot.</h2><span id='topic+con_concur'></span>

<h3>Description</h3>

<p>Draws a concurrence plot of 2 factors in a dataframe.
For example, in a multi-environment yield trial (testing multiple crop
varieties in multple environments) it is interesting to examine the
balance of the testing pattern.
For each pair of environments, how many genotypes are tested
in both environments? The concurrence plot shows the amount of
connectedness (number of varieties) of the environments with each other.
</p>
<p>By default, missing values in the response are deleted.
</p>
<p>Replicated combinations of the two factors are ignored.
(This could be changed if someone has a need.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>con_concur(
  data,
  formula,
  dropNA = TRUE,
  xlab = "",
  ylab = "",
  cex.x = 0.7,
  cex.y = 0.7,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="con_concur_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="con_concur_+3A_formula">formula</code></td>
<td>
<p>A formula with multiple factor names in the dataframe,
like <code>y ~ f1 / f2</code>.</p>
</td></tr>
<tr><td><code id="con_concur_+3A_dropna">dropNA</code></td>
<td>
<p>If TRUE, observed data that are <code>NA</code> will be dropped.</p>
</td></tr>
<tr><td><code id="con_concur_+3A_xlab">xlab</code></td>
<td>
<p>Label for x axis</p>
</td></tr>
<tr><td><code id="con_concur_+3A_ylab">ylab</code></td>
<td>
<p>Label for y axis</p>
</td></tr>
<tr><td><code id="con_concur_+3A_cex.x">cex.x</code></td>
<td>
<p>Scale factor for x axis tick labels.  Default 0.7.</p>
</td></tr>
<tr><td><code id="con_concur_+3A_cex.y">cex.y</code></td>
<td>
<p>Scale factor for y axis tick labels  Default 0.7.</p>
</td></tr>
<tr><td><code id="con_concur_+3A_...">...</code></td>
<td>
<p>Other parameters passed to the levelplot() function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lattice graphics object
</p>


<h3>Author(s)</h3>

<p>Kevin Wright
</p>


<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(lattice)
bar = transform(lattice::barley, env=factor(paste(site,year)))
set.seed(123)
bar &lt;- bar[sample(1:nrow(bar), 70, replace=TRUE),]
con_concur(bar, yield ~ variety / env, cex.x=0.75, cex.y=.3)

</code></pre>

<hr>
<h2 id='con_filter'>Filter a dataframe using two-way criteria to increase connectedness</h2><span id='topic+con_filter'></span>

<h3>Description</h3>

<p>Traditional filtering (subsetting) of data is typically performed via
some criteria based on the <em>columns</em> of the data.
</p>
<p>In contrast, this function performs filtering of data based on the
<em>joint</em> rows and columns of a matrix-view of two factors.
</p>
<p>Conceptually, the idea is to re-shape two or three columns of a dataframe
into a matrix, and then delete entire rows (or columns) of the matrix if
there are too many missing cells in a row (or column).
</p>
<p>The two most useful applications of two-way filtering are to:
</p>

<ol>
<li><p> Remove a factor level that has few interactions with another factor.
This is especially useful in linear models to remove rare factor
combinations.
</p>
</li>
<li><p> Remove a factor level that has any missing interactions with another
factor. This is especially useful with biplots of a matrix to remove
rows or columns that have missing values.
</p>
</li></ol>

<p>A formula syntax is used to specify the two-way filtering criteria.
</p>
<p>Some examples may provide the easiest understanding.
</p>
<p>dat &lt;- data.frame(state=c(&quot;NE&quot;,&quot;NE&quot;, &quot;IA&quot;, &quot;NE&quot;, &quot;IA&quot;),
year=c(1,2,2,3,3), value=11:15)
</p>
<p>When the 'value' column is re-shaped into a matrix it looks like:
</p>
<p>state/year |  1 |  2 |  3 |
NE | 11 | 12 | 14 |
IA |    | 13 | 15 |
</p>
<p>Drop states with too much missing combinations.
Keep only states with &quot;at least 3 years per state&quot;
con_filter(dat, ~ 3 * year / state)
NE    1    11
NE    2    12
NE    3    14
</p>
<p>Keep only years with &quot;at least 2 states per year&quot;
con_filter(dat, ~ 2 * state / year)
NE    2    12
IA    2    13
NE    3    14
IA    3    15
</p>
<p>If the constant number in the formula is less than 1.0, this is
interpreted as a <em>fraction</em>.
Keep only states with &quot;at least 75% of years per state&quot;
con_filter(dat, ~ .75 * year / state)
</p>
<p>It is possible to include another factor on either side of the slash &quot;/&quot;.
Suppose the data had another factor for political party called &quot;party&quot;.
Keep only states with &quot;at least 2 combinations of party:year per state&quot;
con_filter(dat, ~ 2 * party:year / state)
</p>
<p>If the formula contains a response variable, missing values are dropped
first, then the two-way filtering is based on the factor combinations.
con_filter(dat, value ~ 2 * state / year)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>con_filter(data, formula, verbose = TRUE, returndropped = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="con_filter_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="con_filter_+3A_formula">formula</code></td>
<td>
<p>A formula with two factor names in the dataframe
that specifies the criteria for filtering,
like <code>y ~ 2 * f1 / f2</code></p>
</td></tr>
<tr><td><code id="con_filter_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print some diagnostic information about what data
is being deleted. (Similar to the 'tidylog' package).</p>
</td></tr>
<tr><td><code id="con_filter_+3A_returndropped">returndropped</code></td>
<td>
<p>If TRUE, return the dropped rows instead of the
kept rows. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original dataframe is returned, minus rows that are filtered out.
</p>


<h3>Author(s)</h3>

<p>Kevin Wright
</p>


<h3>References</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(
  gen = c("G3", "G4", "G1", "G2", "G3", "G4", "G5",
          "G1", "G2", "G3", "G4", "G5",
          "G1", "G2", "G3", "G4", "G5",
          "G1", "G2", "G3", "G4", "G5"),
  env = c("E1", "E1", "E1", "E1", "E1", "E1", "E1",
          "E2", "E2", "E2", "E2", "E2",
          "E3", "E3", "E3", "E3", "E3",
          "E4", "E4", "E4", "E4", "E4"),
  yield = c(65, 50, NA, NA, 65, 50, 60,
            NA, 71, 76, 80, 82,
            90, 93, 95, 102, 97,
            98, 102, 105, 130, 135))

# How many observations are there for each combination of gen*env?
with( subset(dat, !is.na(yield)) , table(gen,env) )

# Note, if there is no response variable, the two-way filtering is based
# only on the presence of the factor combinations.
dat1 &lt;- con_filter(dat, ~ 4*env / gen)

# If there is a response variable, missing values are dropped first,
# then the two-way filtering is based on the factor combinations.

dat1 &lt;- con_filter(dat, yield ~ 4*env/gen)
dat1 &lt;- con_filter(dat, yield ~ 5*env/ gen)
dat1 &lt;- con_filter(dat, yield ~ 6*gen/ env)
dat1 &lt;- con_filter(dat, yield ~ .8 *env / gen)
dat1 &lt;- con_filter(dat, yield ~ .8* gen / env)
dat1 &lt;- con_filter(dat, yield ~ 7 * env / gen)

</code></pre>

<hr>
<h2 id='con_view'>View connectedness of two factors in a dataframe using a levelplot</h2><span id='topic+con_view'></span>

<h3>Description</h3>

<p>If there is replication for the treatment combination cells in a
two-way table, the replications are averaged together (or counted)
before constructing the heatmap.
</p>
<p>By default, rows and columns are clustered using the 'incidence' matrix of 0s and 1s.
</p>
<p>The function checks to see if the cells in the heatmap form a connected
set.  If not, the data is divided into connected subsets and the subset
group number is shown within each cell.
</p>
<p>By default, missing values in the response are deleted.
</p>
<p>Factor levels are shown along the left and bottom sides.
</p>
<p>The number of cells in each column/row is shown along the top/right sides.
</p>
<p>If the 2 factors are disconnected, the group membership ID is shown in
each cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>con_view(
  data,
  formula,
  fun.aggregate = mean,
  xlab = "",
  ylab = "",
  cex.num = 0.75,
  cex.x = 0.7,
  cex.y = 0.7,
  col.regions = RedGrayBlue,
  cluster = "incidence",
  dropNA = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="con_view_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="con_view_+3A_formula">formula</code></td>
<td>
<p>A formula with two (or more) factor names in the dataframe
like <code>yield ~ f1 *f2</code></p>
</td></tr>
<tr><td><code id="con_view_+3A_fun.aggregate">fun.aggregate</code></td>
<td>
<p>The function to use for aggregating data in cells. Default is mean.</p>
</td></tr>
<tr><td><code id="con_view_+3A_xlab">xlab</code></td>
<td>
<p>Label for x axis</p>
</td></tr>
<tr><td><code id="con_view_+3A_ylab">ylab</code></td>
<td>
<p>Label for y axis</p>
</td></tr>
<tr><td><code id="con_view_+3A_cex.num">cex.num</code></td>
<td>
<p>Disjoint group number.</p>
</td></tr>
<tr><td><code id="con_view_+3A_cex.x">cex.x</code></td>
<td>
<p>Scale factor for x axis tick labels.  Default 0.7.</p>
</td></tr>
<tr><td><code id="con_view_+3A_cex.y">cex.y</code></td>
<td>
<p>Scale factor for y axis tick labels  Default 0.7.</p>
</td></tr>
<tr><td><code id="con_view_+3A_col.regions">col.regions</code></td>
<td>
<p>Function for color regions. Default RedGrayBlue.</p>
</td></tr>
<tr><td><code id="con_view_+3A_cluster">cluster</code></td>
<td>
<p>If &quot;incidence&quot;, cluster rows and columns by the
incidence matrix. If FALSE, no clustering is performed.</p>
</td></tr>
<tr><td><code id="con_view_+3A_dropna">dropNA</code></td>
<td>
<p>If TRUE, observed data that are <code>NA</code> will be dropped.</p>
</td></tr>
<tr><td><code id="con_view_+3A_...">...</code></td>
<td>
<p>Other parameters passed to the levelplot() function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lattice graphics object
</p>


<h3>Author(s)</h3>

<p>Kevin Wright
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(lattice)
bar = transform(lattice::barley, env=factor(paste(site,year)))
set.seed(123)
bar &lt;- bar[sample(1:nrow(bar), 70, replace=TRUE),]
con_view(bar, yield ~ variety * env, cex.x=1, cex.y=.3, cluster=FALSE)

# Create a heatmap of cell counts
w2b = colorRampPalette(c('wheat','black'))
con_view(bar, yield ~ variety * env, fun.aggregate=length,
  cex.x=1, cex.y=.3, col.regions=w2b, cluster=FALSE)

# Example from paper by Fernando et al. (1983).
set.seed(42)
data_fernando = transform(data_fernando,
  y=stats::rnorm(9, mean=100))
con_view(data_fernando, y ~ gen*herd, cluster=FALSE,
     main = "Fernando unsorted")
con_view(data_fernando, y ~ gen*herd, cluster=TRUE,
     main = "Fernando unsorted")

# Example from Searle (1971), Linear Models, p. 325
dat2 = transform(data_searle,
  y=stats::rnorm(nrow(data_searle)) + 100)

con_view(dat2, y ~ f1*f2, cluster=FALSE, main="data_searle unsorted") 
con_view(dat2, y ~ f1*f2, main="data_searle clustered")

</code></pre>

<hr>
<h2 id='data_eccleston'>Data from Eccleston &amp; Russell</h2><span id='topic+data_eccleston'></span>

<h3>Description</h3>

<p>Data from Eccleston &amp; Russell
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_eccleston
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 16 rows and 3 columns.
</p>


<h3>Details</h3>

<p>A dataframe with 3 treatment factors.
Each pair of factors is connected, but the 3 factors are disconnected.
The 'trt' column uses numbers to match Eccleston (Table 1, Design 1)
and letters to match Foulley (Table 13.3).
</p>


<h3>Source</h3>

<p>Eccleston, J. and K. Russell (1975).
Connectedness and orthogonality in multi-factor designs.
Biometrika, 62, 341-345.
https://doi.org/10.1093/biomet/62.2.341
</p>


<h3>References</h3>

<p>Foulley, J. L., Bouix, J., Goffinet, B., &amp; Elsen, J. M. (1990).
Connectedness in Genetic Evaluation.
Advanced Series in Agricultural Sciences, 277–308.
https://doi.org/10.1007/978-3-642-74487-7_13
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Each pair of factors is connected
con_check(data_eccleston, ~ row + trt)
con_check(data_eccleston, ~ col + trt)
con_check(data_eccleston, ~ row + col)
# But all three factors are COMPLETELY disconnected
con_check(data_eccleston, ~ row + col + trt)

set.seed(42)
data_eccleston &lt;- transform(data_eccleston,
  y = rnorm(nrow(data_eccleston), mean=100))
con_view(data_eccleston, y ~ row*col, xlab="row", ylab="col")
con_view(data_eccleston, y ~ row*trt, xlab="row", ylab="trt")
con_view(data_eccleston, y ~ col*trt, xlab="col", ylab="trt")

</code></pre>

<hr>
<h2 id='data_fernando'>Data from Fernando et al.</h2><span id='topic+data_fernando'></span>

<h3>Description</h3>

<p>Data from Fernando et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_fernando
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 9 rows and 2 columns.
</p>


<h3>Details</h3>

<p>A dataframe with 2 treatment factors.
The treatment combinations form 2 disconnected groups.
</p>


<h3>Source</h3>

<p>Fernando et al. (1983).
Identifying All Connected Subsets In A Two-Way Classification Without Interaction.
J. of Dairy Science, 66, 1399-1402. Table 1.
https://doi.org/10.3168/jds.S0022-0302(83)81951-1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lfe)
cbind(data_fernando,
      .group=con_check(data_fernando, ~ gen + herd))
library(connected)
set.seed(42)
data_fernando = transform(data_fernando,
  y=stats::rnorm(9, mean=100))
con_view(data_fernando, y ~ gen*herd, cluster=FALSE,
  main = "Fernando unsorted")
con_view(data_fernando, y ~ gen*herd, main="Fernando clustered")

</code></pre>

<hr>
<h2 id='data_searle'>Data from Searle</h2><span id='topic+data_searle'></span>

<h3>Description</h3>

<p>Data from Searle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_searle
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 14 rows and 2 columns.
</p>


<h3>Details</h3>

<p>A dataframe with 2 treatment factors.
The treatment combinations form 3 disconnected groups.
</p>


<h3>Source</h3>

<p>Searle (1971).
Linear Models. Page 324.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cbind(data_searle,
      .group=con_check(data_searle, ~ f1 + f2))
data_searle = transform(data_searle,
  y = rnorm(nrow(data_searle), mean=100))
con_view(data_searle, y ~ f1*f2, cluster=FALSE, main="Searle unsorted")
con_view(data_searle, y ~ f1*f2, main="Searle clustered")

</code></pre>

<hr>
<h2 id='data_student'>
Simulated Data of Student Test Scores
</h2><span id='topic+data_student'></span>

<h3>Description</h3>

<p>Simulated Data of Student Test Scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("data_student")</code></pre>


<h3>Format</h3>

<p>A data frame with 41 observations on the following 4 variables.
</p>

<dl>
<dt><code>student</code></dt><dd><p>student ID</p>
</dd>
<dt><code>class</code></dt><dd><p>class/subject</p>
</dd>
<dt><code>test1</code></dt><dd><p>score on test 1</p>
</dd>
<dt><code>test2</code></dt><dd><p>score on test 2</p>
</dd>
</dl>



<h3>Details</h3>

<p>This simulated data imagines the following scenario:
</p>
<p>In a school, 12 students (A-M) were tested in 6 classes (math, chemistry,
physics, art, horticulture, welding).
</p>
<p>Not all students were enrolled in all classes.
</p>
<p>In each class, students were given test 1, then later test 2.
Test scores could be 0-100.
</p>
<p>(Using 2 tests is typical for learning assessment, measuring
intervention effectiveness, comparison of test forms, etc.)
</p>
<p>Some students missed class on the day of a test and had no score for
that test.
</p>
<p>Student B felt ill during art test 1 and was allowed to re-take test 1
(both test 1 scores are included and the same test 2 score was used). 
</p>


<h3>Source</h3>

<p>None
</p>


<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_student)
</code></pre>

<hr>
<h2 id='data_tosh'>Data from Tosh</h2><span id='topic+data_tosh'></span>

<h3>Description</h3>

<p>Data from Tosh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_tosh
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 15 rows and 3 columns.
</p>


<h3>Details</h3>

<p>A dataframe with 3 treatment factors.
The treatment combinations form 2 disconnected groups.
</p>


<h3>Source</h3>

<p>Tosh, J. J., and J. W. Wilton. (1990).
Degree of connectedness in mixed models.
Proceedings of the 4th World Congress on Genetics applied to Livestock Production, 480-483.
Page 481.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cbind(data_tosh,
      .group=con_check(data_tosh, ~ a + b + c))
data_tosh = transform(data_tosh,
  y = rnorm(nrow(data_tosh), mean=100))
library(connected)
con_view(data_tosh, y ~ b * c)

</code></pre>

<hr>
<h2 id='data_weeks1'>Data from Weeks &amp; Williams example 1</h2><span id='topic+data_weeks1'></span>

<h3>Description</h3>

<p>Data from Weeks &amp; Williams example 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_weeks1
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 16 rows and 3 columns.
</p>


<h3>Details</h3>

<p>A dataframe with 3 treatment factors.
The treatment combinations are connected.
</p>
<p>Note: This data is based on Table 1 of Weeks &amp; Williams.
Table 2 is missing treatment combination (1,2,4).
</p>


<h3>Source</h3>

<p>Weeks, David L. &amp; Donald R. Williams (1964).
A Note on the Determination of Connectedness in an N-Way Cross Classification.
Technometrics, 6:3, 319-324. Table 1.
http://dx.doi.org/10.1080/00401706.1964.10490188
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lfe)
cbind(data_weeks1,
      .group=con_check(data_weeks1, ~ f1+f2+f3))

</code></pre>

<hr>
<h2 id='data_weeks2'>Data from Weeks &amp; Williams example 2</h2><span id='topic+data_weeks2'></span>

<h3>Description</h3>

<p>Data from Weeks &amp; Williams example 2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_weeks2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 62 rows and 3 columns.
</p>


<h3>Details</h3>

<p>A dataframe with 3 treatment factors.
The treatment combinations form 4 disconnected groups.
</p>
<p>Note: This data is based on Table 3 of Weeks &amp; Williams.
The groups defined in the text are missing some combinations.
</p>


<h3>Source</h3>

<p>Weeks, David L. &amp; Donald R. Williams (1964).
A Note on the Determination of Connectedness in an N-Way Cross Classification.
Technometrics, 6:3, 319-324. Table 3.
http://dx.doi.org/10.1080/00401706.1964.10490188
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lfe)
cbind(data_weeks2,
      .group=con_check(data_weeks2, ~f1 + f2 + f3))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
