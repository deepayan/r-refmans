<!DOCTYPE html><html><head><title>Help for package maps</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {maps}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#area.map'>
<p>Area of projected map regions</p></a></li>
<li><a href='#canada.cities'>
<p>Database of Canadian cities</p></a></li>
<li><a href='#county'>
<p>United States County Map</p></a></li>
<li><a href='#county.fips'>
<p>FIPS county codes for US County Map</p></a></li>
<li><a href='#france'>
<p>France Map</p></a></li>
<li><a href='#identify.map'>
<p>Identify regions on a map</p></a></li>
<li><a href='#internal'><p>Internally Required Functions</p></a></li>
<li><a href='#internal2'><p>Internally Required Functions</p></a></li>
<li><a href='#iso.expand'>
<p>Identify countries by ISO 3166 codes (2 or 3 letters) or by Sovereignty.</p></a></li>
<li><a href='#iso3166'>
<p>ISO 3166 country codes (2 or 3 letters) and sovereignty.</p></a></li>
<li><a href='#italy'>
<p>Italy Map</p></a></li>
<li><a href='#lakes'>
<p>World lakes database</p></a></li>
<li><a href='#map'>
<p>Draw Geographical Maps</p></a></li>
<li><a href='#map.axes'>
<p>Draw Axes on Geographical Maps</p></a></li>
<li><a href='#map.cities'>
<p>Add Cities to Existing Map</p></a></li>
<li><a href='#map.scale'>
<p>Add Scale to Existing Unprojected Map</p></a></li>
<li><a href='#map.text'>
<p>Draw a map with labeled regions</p></a></li>
<li><a href='#map.where'>
<p>Locate points on a map</p></a></li>
<li><a href='#match.map'>
<p>Index map regions</p></a></li>
<li><a href='#nz'>
<p>New Zealand Basic Map</p></a></li>
<li><a href='#ozone'><p>Sample datasets</p></a></li>
<li><a href='#polygon'><p>Polygon functions</p></a></li>
<li><a href='#smooth.map'>
<p>Smooth out aggregated data</p></a></li>
<li><a href='#Spatial2map'>
<p>Read SpatialPolygons and SpatialLines objects</p></a></li>
<li><a href='#state'>
<p>United States State Boundaries Map</p></a></li>
<li><a href='#state.carto'>
<p>United States State Population Cartogram Map</p></a></li>
<li><a href='#state.fips'>
<p>FIPS state codes for US 48 State Map</p></a></li>
<li><a href='#state.vbm'>
<p>United States State Visibility Base Map</p></a></li>
<li><a href='#us.cities'>
<p>Database of US cities</p></a></li>
<li><a href='#usa'>
<p>United States Coast Map</p></a></li>
<li><a href='#world'>
<p>Low (mid) resolution World Map</p></a></li>
<li><a href='#world.cities'>
<p>Database of world cities</p></a></li>
<li><a href='#world2'>
<p>Pacific Centric Low resolution World Map</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Draw Geographical Maps</td>
</tr>
<tr>
<td>Version:</td>
<td>3.4.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Original S code by Richard A. Becker and Allan R. Wilks.
	R version by Ray Brownrigg.
        Enhancements by Thomas P Minka and Alex Deckmyn.</td>
</tr>
<tr>
<td>Description:</td>
<td>Display of maps.  Projection code and larger maps are in
             separate packages ('mapproj' and 'mapdata').</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, utils</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mapproj (&ge; 1.2-0), mapdata (&ge; 2.3.0), sp, rnaturalearth</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Deckmyn &lt;alex.deckmyn@meteo.be&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-15 11:26:58 UTC; alex</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-15 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='area.map'>
Area of projected map regions
</h2><span id='topic+area.map'></span>

<h3>Description</h3>

<p>Computes the areas of regions in a projected map.</p>


<h3>Usage</h3>

<pre><code class='language-R'>area.map(m, regions = ".", sqmi=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area.map_+3A_m">m</code></td>
<td>
<p>a map object containing named polygons (created with
<code>fill = TRUE</code>).</p>
</td></tr>
<tr><td><code id="area.map_+3A_regions">regions</code></td>
<td>
<p>a character vector naming one of more regions, as in
<code><a href="#topic+map">map</a></code>.</p>
</td></tr>
<tr><td><code id="area.map_+3A_sqmi">sqmi</code></td>
<td>
<p>If <code>TRUE</code>, measure area in square miles.  Otherwise
keep the units of <code>m</code>.</p>
</td></tr>
<tr><td><code id="area.map_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+match.map">match.map</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The area of each matching region in the map is computed, and
regions which match the same element of <code>regions</code> have their
areas combined.  Each region is assumed planar, with vertices
specified by the <code>x</code> and <code>y</code> components of the map object.
</p>
<p>The correct use of this function is to first use <code><a href="#topic+map">map</a></code> to
create polygons and project the coordinates onto a plane, then apply
<code>area.map</code> to compute the area of the projected regions.
If the projection is area-preserving (such as <code>albers</code>),
then these areas will match the area on the globe, up to a
constant.  To get an absolute area in square miles, the <code>sqmi</code>
option will scale the result, depending on the projection.
</p>
<p>The coordinates from <code><a href="#topic+map">map</a></code> are affected by 
its <code>resolution</code> argument, so use <code>resolution=0</code> for the most
accurate areas.
</p>


<h3>Value</h3>

<p>a named vector of region areas.
</p>


<h3>NOTE</h3>

<p>The <code>sqmi</code> option assumes the coordinates have been projected
with the <a href="mapproj.html#topic+mapproject">mapproject</a> function.
</p>


<h3>Author(s)</h3>

<p>Tom Minka</p>


<h3>See Also</h3>

<p><code>area.polygon</code>, <code>apply.polygon</code></p>


<h3>Examples</h3>

<pre><code class='language-R'># because the projection is rectangular, these are not true areas on the globe.
m = map("state", fill = TRUE, plot = FALSE)
area.map(m)
area.map(m, ".*dakota")
area.map(m, c("North Dakota", "South Dakota"))

if(require(mapproj)) {
  # true areas on the globe
  m = map("state", proj="bonne", param=45, fill=TRUE, plot=FALSE)
  # North Dakota is listed as 70,704 square miles
  area.map(m, "North Dakota")
}
</code></pre>

<hr>
<h2 id='canada.cities'>
Database of Canadian cities
</h2><span id='topic+canada.cities'></span>

<h3>Description</h3>

<p>This database is of Canadian cities of population greater than about 1,000.
Also included are province capitals of any population size.
</p>


<h3>Format</h3>

<p>A list with 6 components, namely &quot;name&quot;, &quot;country.etc&quot;, &quot;pop&quot;, &quot;lat&quot;,
&quot;long&quot;, and &quot;capital&quot;, containing the city name, the province
abbreviation, approximate population (as at January 2006), latitude,
longitude and capital status indication (0 for non-capital, 1 for
capital, 2 for provincial
</p>
<p>capital.
</p>


<h3>NOTE</h3>

<p>Some of the city names may be out of date.  Please send
any corrections to the package maintainer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map.cities">map.cities</a></code>
</p>

<hr>
<h2 id='county'>
United States County Map
</h2><span id='topic+county'></span><span id='topic+countyMapEnv'></span>

<h3>Description</h3>

<p>This database produces a map of the counties of the United States mainland
generated from US Department of the Census data (see the reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(countyMapEnv)
</code></pre>


<h3>Format</h3>

<p>The data file is merely a character string which
specifies the name of an environment variable which contains the
base location of the binary files used by the map drawing functions.
This environment variable (<code>R_MAP_DATA_DIR</code> for the datasets in the
maps package) is set at package load time <em>if it does not
already exist</em>.  Hence setting the environment variable before loading
the package can override the default location of the binary datasets.
</p>


<h3>References</h3>

<p>Richard A. Becker, and Allan R. Wilks,
&quot;Maps in S&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [93.2], 1993.</em>
</p>
<p>Richard A. Becker, and Allan R. Wilks,
&quot;Constructing a Geographical Database&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [95.2], 1995.</em>
</p>
<p>US Department of Commerce, Census Bureau,
<em>County Boundary File,</em>
computer tape, available from Customer Services,
Bureau of the Census, Washingdon DC 20233.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map('county', 'iowa', fill = TRUE, col = palette())
</code></pre>

<hr>
<h2 id='county.fips'>
FIPS county codes for US County Map
</h2><span id='topic+county.fips'></span>

<h3>Description</h3>

<p>A database matching FIPS codes to maps package county and state names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(county.fips)</code></pre>


<h3>Format</h3>

<p>A list with 2 components, namely &quot;fips&quot; and &quot;polyname&quot;, containing the
FIPS number and respective state or county polygon name. Note that &quot;fips&quot; is represented as an integer, so any leading zero (which is part of the fips code) is not shown by default.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+state.fips">state.fips</a></code>
</p>

<hr>
<h2 id='france'>
France Map
</h2><span id='topic+france'></span><span id='topic+franceMapEnv'></span>

<h3>Description</h3>

<p>This france database comes from the NUTS III (Tertiary Administrative
Units of the European Community) database of the United Nations
Environment Programme (UNEP) GRID-Geneva data sets. These were prepared
around 1989, and so may be somewhat out of date.
</p>
<p>Users of data sets supplied through UNEP/GRID are requested to
incorporate in output products and reports acknowledgements to the
originator of the data and to the fact that they were acquired through
UNEP/GRID. Appropriate wording may be &quot;UNESCO (1987) through
UNEP/GRID-Geneva&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(franceMapEnv)</code></pre>


<h3>Format</h3>

<p>The data file is merely a character string which
specifies the name of an environment variable which contains the
base location of the binary files used by the map drawing functions.
This environment variable (<code>R_MAP_DATA_DIR</code> for the datasets in the
maps package) is set at package load time <em>if it does not
already exist</em>. Hence setting the environment variable before loading
the package can override the default location of the binary datasets.
</p>


<h3>Details</h3>

<p>This map database can now easily be replaced by data taken directly from free sources, e.g. Natural Earth (see example).
</p>


<h3>References</h3>

<p>Richard A. Becker, and Allan R. Wilks,
&quot;Maps in S&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [93.2], 1993.</em>
</p>
<p>Richard A. Becker, and Allan R. Wilks,
&quot;Constructing a Geographical Database&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [95.2], 1995.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map('france', fill = TRUE, col = 1:10)
# replace by a public domain map at higher resolution:
# fr1 &lt;- rnaturalearth::ne_states("france")
# this still includes overseas domains, so we remove those:
# france2 &lt;- map(fr1, xlim=c(-20, 20), ylim=c(30, 60), lforce="e",
#                fill=TRUE, plot=FALSE)
</code></pre>

<hr>
<h2 id='identify.map'>
Identify regions on a map
</h2><span id='topic+identify.map'></span>

<h3>Description</h3>

<p>Identifies the map regions clicked by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'map'
identify(x, n = 1, index = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify.map_+3A_x">x</code></td>
<td>
<p>a map object containing named polygons.</p>
</td></tr>
<tr><td><code id="identify.map_+3A_n">n</code></td>
<td>
<p>the number of clicks to wait for.</p>
</td></tr>
<tr><td><code id="identify.map_+3A_index">index</code></td>
<td>
<p>If TRUE, returns the index of the polygon, rather than
its name.</p>
</td></tr>
<tr><td><code id="identify.map_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="graphics.html#topic+identify.default">identify.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current algorithm is somewhat crude &mdash; selects the region whose
centroid is closest to the click.  A more sophisticated approach would
use <code><a href="#topic+map.where">map.where</a></code>.
</p>


<h3>Value</h3>

<p>a character vector of length <code>n</code>, naming the selected regions.
</p>


<h3>Author(s)</h3>

<p>Tom Minka</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+identify">identify</a></code>, <code><a href="#topic+map.where">map.where</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>identify(map("state", fill = TRUE, col = 0))
if(require(mapproj))
  identify(map("world", proj = "lagrange", fill = TRUE, col = 0, wrap=c(-180,180,-90)))
</code></pre>

<hr>
<h2 id='internal'>Internally Required Functions</h2><span id='topic+internal'></span><span id='topic+makepoly'></span><span id='topic+mapgetg'></span><span id='topic+mapgetl'></span><span id='topic+mapname'></span><span id='topic+mapthin'></span><span id='topic+maptype'></span>

<h3>Description</h3>

<p>These functions are called internally and will generally not be
required by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makepoly(xy, gonsize, keep)
mapgetg(database, gons, fill, xlim, ylim)
mapgetl(database, lines, xlim, ylim, fill)
mapname(database, patterns, exact)
mapthin(xy, delta, symmetric)
maptype(database)
</code></pre>

<hr>
<h2 id='internal2'>Internally Required Functions</h2><span id='topic+internal2'></span><span id='topic+char.to.ascii'></span><span id='topic+is.regexp'></span><span id='topic+indicators.factor'></span><span id='topic+insert'></span><span id='topic+match.map.slow'></span><span id='topic+match.map.grep'></span><span id='topic+map.poly'></span><span id='topic+map.wrap'></span><span id='topic+map.wrap.poly'></span><span id='topic+map.clip.poly'></span><span id='topic+subgroup'></span><span id='topic+gp.smooth'></span><span id='topic+kernel.smooth'></span><span id='topic+kernel.region.region'></span><span id='topic+kernel.region.x'></span><span id='topic+.map.range'></span>

<h3>Description</h3>

<p>These functions are called internally and will generally not be
required by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char.to.ascii(s)
is.regexp(s)
indicators.factor(y)
insert(x, i, v)
match.map.slow(nam, regions, warn = FALSE)
match.map.grep(nam, regions, warn = FALSE)
map.poly(database, regions = ".", exact = FALSE, xlim = NULL, ylim = NULL,
         boundary = TRUE, interior = TRUE, fill = FALSE, as.polygon = FALSE,
         namefield="name")
map.wrap(p, xlim=NULL)
map.wrap.poly(data, xlim, poly = FALSE, antarctica = -89.5)
map.clip.poly(data, xlim = c(NA, NA), ylim = c(NA, NA), poly = FALSE)
subgroup(x, i)
gp.smooth(x, z, xo, lambda, r)
kernel.smooth(x, z, xo, lambda, region = NULL, normalize = TRUE)
kernel.region.region(x, region, lambda)
kernel.region.x(x, region, z, lambda)
.map.range(new)
</code></pre>

<hr>
<h2 id='iso.expand'>
Identify countries by ISO 3166 codes (2 or 3 letters) or by Sovereignty.
</h2><span id='topic+sov.expand'></span><span id='topic+iso.expand'></span><span id='topic+iso.alpha'></span>

<h3>Description</h3>

<p>This data set and the simple look-up functions allow to build lists of counrtries for the world map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	iso.expand(a, regex=TRUE)
	sov.expand(sov, regex=TRUE)
        iso.alpha(x, n=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iso.expand_+3A_a">a</code></td>
<td>
<p>A vector of ISO codes. All elements should have the same length, either 2 or 3 letters. Not case sensitive.</p>
</td></tr>
<tr><td><code id="iso.expand_+3A_sov">sov</code></td>
<td>
<p>A vector of country names. The result is a list of all countries that fall under their sovereignty. Case sensitive, must fit completeley.</p>
</td></tr>
<tr><td><code id="iso.expand_+3A_regex">regex</code></td>
<td>
<p>If TRUE (default), the return vector has the same length as the input (<code>a</code> or <code>sov</code>), but the entries may be regular expressions.
If FALSE, the result is a vector of polygon names. This may be more readable, but the return vector may be longer than the input.</p>
</td></tr>
<tr><td><code id="iso.expand_+3A_x">x</code></td>
<td>
<p>Vector of country names, may include colons.</p>
</td></tr>
<tr><td><code id="iso.expand_+3A_n">n</code></td>
<td>
<p>An integer identitying which ISO code is required. Allowed values are 2 and 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ISO 3166-1 standard identifies countries by a 2 and 3 letter codes.
<code>iso.expand</code> translates these codes into the country names as used by 
the <code>world</code> data base. <code>iso.alpha</code> does the reverse.  
Some countries have different ISO codes for different regions 
(e.g. China:Hong Kong has ISO code HK). In such cases, <code>iso.alpha</code> will 
return the main code, but <code>iso.expand</code> will return a regular expression 
that excludes some parts.
</p>


<h3>Value</h3>

<p><code>iso.expand</code> returns vector of country names. When used as input for <code>map</code> it will plot all the countries as identified either by their sovereignty or by ISO codes. If <code>regex=FALSE</code> the length of the vector may be shorter or longer than the input. If <code>regex=TRUE</code>, the results are concatenated in regular expressions. This format is less readable, but can be used as input e.g. for <code>match.map</code>.
<code>iso.alpha</code> always returns a vector of the same length as the input,  containing the 2- or 3-letter codes.
</p>


<h3>NOTE</h3>

<p>These functions use regular expressions and the results will often not work well with <code>map(...,exact=TRUE)</code>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match.map">match.map</a></code>,<code><a href="#topic+map.text">map.text</a></code>,<code><a href="#topic+iso3166">iso3166</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># France and all its overseas departments, territories etc.
sov.expand("France") # France and all its overseas departments, territories etc.

# Canary Islands are not included in map("Spain")
iso.expand("ES")
map(regions=sov.expand("Spain"))

# draw a map with ISO codes as labels:
wm &lt;- map("world", fill=TRUE, col=0, xlim=c(-10,40), ylim=c(30,60))
# take out islands, but you loose e.g. UK, New Zealand, small island states
nam &lt;- grep(":", wm$names, inv=TRUE, val=TRUE)
# ad ISO codes as label
map.text(wm, regions=nam, label=iso.alpha(nam), col=2, exact=TRUE, add=TRUE)
</code></pre>

<hr>
<h2 id='iso3166'>
ISO 3166 country codes (2 or 3 letters) and sovereignty.
</h2><span id='topic+iso3166'></span>

<h3>Description</h3>

<p>This data set lists all ISO3166 country codes and the sovereignty for each country in the list. Some entries are regular expressions.
</p>


<h3>Format</h3>

<p>A data frame with 5 columns: &quot;a2&quot;, &quot;a3&quot;, &quot;name&quot;, &quot;mapname&quot;, &quot;sovereignty&quot;. These contain the 2- and 3-letter ISO code, the official name,  the (possibly shorter) name used in the map data base, and the sovereign country.
</p>


<h3>Details</h3>

<p>The ISO 3166-1 standard identifies countries by a 2 and 3 letter codes. This table listst these for all countries on the world map. This data set also serves as basis for the function iso.expand() and its siblings.</p>


<h3>NOTE</h3>

<p>Some countries have different ISO codes for some regions. To deal with such particular cases, the &quot;mapname&quot; column may sometimes contain (perl-style) regular expressions rather than simply a country name. For instance, &quot;FI&quot; has mapname &quot;Finland(?!:Aland)&quot;, because the Aland islands have a different ISO code. Other codes may appear in two rows if certain parts of countries are not written with the main country as base name. Usually, that is for compatibility with the legacy world data base. 
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iso.expand">iso.expand</a></code>
</p>

<hr>
<h2 id='italy'>
Italy Map
</h2><span id='topic+italy'></span><span id='topic+italyMapEnv'></span>

<h3>Description</h3>

<p>This italy database comes from the NUTS III (Tertiary Administrative
Units of the European Community) database of the United Nations
Environment Programme (UNEP) GRID-Geneva data sets. These were prepared
around 1989, and so may be somewhat out of date.
</p>
<p>Users of data sets supplied through UNEP/GRID are requested to
incorporate in output products and reports acknowledgements to the
originator of the data and to the fact that they were acquired through
UNEP/GRID. Appropriate wording may be &quot;UNESCO (1987) through
UNEP/GRID-Geneva&quot;. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(italyMapEnv)</code></pre>


<h3>Format</h3>

<p>The data file is merely a character string which
specifies the name of an environment variable which contains the
base location of the binary files used by the map drawing functions.
This environment variable (<code>R_MAP_DATA_DIR</code> for the datasets in the
maps package) is set at package load time <em>if it does not
already exist</em>. Hence setting the environment variable before loading
the package can override the default location of the binary datasets.
</p>


<h3>References</h3>

<p>Richard A. Becker, and Allan R. Wilks,
&quot;Maps in S&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [93.2], 1993.</em>
</p>
<p>Richard A. Becker, and Allan R. Wilks,
&quot;Constructing a Geographical Database&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [95.2], 1995.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map('italy', fill = TRUE, col = 1:10)
</code></pre>

<hr>
<h2 id='lakes'>
World lakes database
</h2><span id='topic+lakes'></span><span id='topic+lakesMapEnv'></span>

<h3>Description</h3>

<p>This database contains a selection of large lakes (and islands within) taken from the Natural Earth 1:50m map, the same data source as the (v3.0) world map. The lake boundaries are consistent with the 'world' database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lakesMapEnv)</code></pre>


<h3>Format</h3>

<p>The data file is merely a character string which
specifies the name of an environment variable which contains the
base location of the binary files used by the map drawing functions.
This environment variable (<code>R_MAP_DATA_DIR</code> for the datasets in the
maps package) is set at package load time <em>if it does not
already exist</em>.  Hence setting the environment variable before loading
the package can override the default location of the binary datasets.
</p>


<h3>Source</h3>

<p>The data in this data base is derived from the public domain GIS project Natural Earth, the file &quot;ne_50m_lakes&quot;. The Natural Earth data set is available from <a href="https://www.naturalearthdata.com">https://www.naturalearthdata.com</a>.</p>


<h3>References</h3>

<p><em>Natural Earth project</em>
<a href="https://www.naturalearthdata.com">https://www.naturalearthdata.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map('world')
map('lakes', add=TRUE, fill=TRUE, col='white', boundary='black')
</code></pre>

<hr>
<h2 id='map'>
Draw Geographical Maps
</h2><span id='topic+map'></span>

<h3>Description</h3>

<p>Draw lines and polygons as specified by a map database.</p>


<h3>Usage</h3>

<pre><code class='language-R'>map(database = "world", regions = ".", exact = FALSE, boundary = TRUE,
  interior = TRUE, projection = "", parameters = NULL, orientation = NULL,
  fill = FALSE, col = 1, plot = TRUE, add = FALSE, namesonly = FALSE,
  xlim = NULL, ylim = NULL, wrap = FALSE, resolution = if (plot) 1 else 0,
  type = "l", bg = par("bg"), mar = c(4.1, 4.1, par("mar")[3], 0.1),
  myborder = 0.01, namefield="name", lforce="n", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_database">database</code></td>
<td>

<p>character string naming a geographical database, a list of
<code>x</code>, <code>y</code>, and <code>names</code> obtained from a previous call to
<code>map</code> or a spatial object of class <code>SpatialPolygons</code> or <code>SpatialLines</code>.
The string choices include a <code><a href="#topic+world">world</a></code> map,
three USA databases (<code><a href="#topic+usa">usa</a></code>, <code><a href="#topic+state">state</a></code>,
<code><a href="#topic+county">county</a></code>), and more (type <code>help(package='maps')</code> to see the package index). If the requied database is in a different package that has not been attached, the string may be started with &quot;packagename::&quot;. The
location of the map databases may be overridden by setting the
<code>R_MAP_DATA_DIR</code> environment variable.
</p>
</td></tr>
<tr><td><code id="map_+3A_regions">regions</code></td>
<td>

<p>character vector that names the polygons to draw.
Each database is composed of a collection of polygons, and each polygon has
a unique name.
When a region is composed of more than one polygon, the individual polygons
have the name of the region, followed by a colon and a qualifier,
as in <code>michigan:north</code> and <code>michigan:south</code>.
Each element of <code>regions</code> is matched
against the polygon names in the database and, according to
<code>exact</code>, a subset is selected for drawing. The regions may also be 
defined using (perl) regular expressions. This makes it possible to use 
'negative' expressions like <code>"Norway(?!:Svalbard)"</code>, which means Norway
and all islands except Svalbard. All entries are case insensitive.
The default selects all polygons in the database.
</p>
</td></tr>
<tr><td><code id="map_+3A_exact">exact</code></td>
<td>

<p>If <code>TRUE</code>, only exact matches with <code>regions</code> are
selected for drawing.
If <code>FALSE</code>, each element of <code>regions</code> is matched
as a regular expression
against the polygon names in the database and all matches are selected
for drawing.
</p>
</td></tr>
<tr><td><code id="map_+3A_boundary">boundary</code></td>
<td>

<p>If <code>FALSE</code>, boundary segments are not drawn.
A boundary segment is a line segment of the map that bounds only
one of the polygons to be drawn.
This argument is ignored if <code>fill</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="map_+3A_interior">interior</code></td>
<td>

<p>If <code>FALSE</code>, interior segments are not drawn.
An interior segment is a line segment of the map that bounds two
of the polygons to be drawn.
This argument is ignored if <code>fill</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="map_+3A_projection">projection</code></td>
<td>

<p>character string that names a map projection to use.
See <code><a href="mapproj.html#topic+mapproject">mapproject</a></code> (in the <code>mapproj</code> library).
The default is to use a rectangular projection with the aspect ratio
chosen so that longitude and latitude scales are equivalent at the
center of the picture.
</p>
</td></tr>
<tr><td><code id="map_+3A_parameters">parameters</code></td>
<td>

<p>numeric vector of parameters for use with the
<code>projection</code> argument.
This argument is optional only in the sense that certain
projections do not require additional parameters.
If a projection does require additional parameters, these
must be given in the <code>parameters</code> argument.
</p>
</td></tr>
<tr><td><code id="map_+3A_orientation">orientation</code></td>
<td>

<p>a vector <code>c(latitude, longitude, rotation)</code> describing where
the map should be centered and a clockwise rotation (in degrees)
about this center.
</p>
</td></tr>
<tr><td><code id="map_+3A_fill">fill</code></td>
<td>

<p>logical flag that says whether to draw lines or fill areas.
If <code>FALSE</code>, the lines bounding each region will be drawn (but
only once, for interior lines).
If <code>TRUE</code>, each region will be filled using colors from the
<code>col =</code> argument, and bounding lines are drawn by default using <code>par("fg")</code>.
To hide the bounding lines, use <code>border=NA</code> (see <code>...</code>).
</p>
</td></tr>
<tr><td><code id="map_+3A_col">col</code></td>
<td>

<p>vector of colors.
If <code>fill</code> is <code>FALSE</code>, the first color is used for plotting
all lines, and any other colors are ignored.
Otherwise, the colors are matched one-one with the polygons
that get selected by the <code>region</code> argument (and are reused
cyclically, if necessary). If <code>fill = TRUE</code>, the default boundary line colour 
is given by <code>par("fg")</code>. To change this, you can use the <code>border</code> 
argument (see '...').
A color of <code>NA</code> causes the corresponding region to be deleted
from the list of polygons to be drawn.
Polygon colors are assigned <em>after</em> polygons are deleted due to values
of the <code>xlim</code> and <code>ylim</code> arguments.
</p>
</td></tr>
<tr><td><code id="map_+3A_plot">plot</code></td>
<td>

<p>logical flag that specifies whether plotting
should be done.
If <code>plot</code> is <code>TRUE</code> the return value of <code>map</code> will
not be printed automatically .
</p>
</td></tr>
<tr><td><code id="map_+3A_add">add</code></td>
<td>

<p>logical flag that specifies whether to add to the
current plot.
If <code>FALSE</code>, a new plot is begun, and a new coordinate
system is set up.
</p>
</td></tr>
<tr><td><code id="map_+3A_namesonly">namesonly</code></td>
<td>

<p>If <code>TRUE</code>, the return value will be a character vector of
the names of the selected polygons.  See the Value section below.
</p>
</td></tr>
<tr><td><code id="map_+3A_xlim">xlim</code></td>
<td>

<p>two element numeric
vector giving a range of longitudes, expressed
in degrees, to which drawing
should be restricted.
Longitude is measured in degrees east of Greenwich, so that, in particular,
locations in the USA have negative longitude.
If <code>fill = TRUE</code>, polygons selected by <code>region</code> must be entirely inside
the <code>xlim</code> range.
The default value of this argument spans the entire longitude range
of the <code>database</code>.
</p>
</td></tr>
<tr><td><code id="map_+3A_ylim">ylim</code></td>
<td>

<p>two element 
numeric vector giving a range of latitudes,
expressed in degrees, to which drawing
should be restricted.
Latitude is measured in degrees north of the
equator, so that, in particular,
locations in the USA have positive latitude.
If <code>fill = TRUE</code>, polygons selected by <code>region</code> must be entirely inside
the <code>ylim</code> range.
The default value of this argument spans the entire latitude range
of the <code>database</code>.
</p>
</td></tr>
<tr><td><code id="map_+3A_wrap">wrap</code></td>
<td>
<p>Boolean or a numeric vector. If TRUE, lines that cross too far across the map
(due to a strange projection) are omitted. If wrap is a vector of length 2 or more, it is interpreted as the longitude range to be used for a global map, e.g. <code>c(-180,180)</code> or <code>c(0,360)</code>. This wrapping even works when <code>fill=TRUE</code> and is performed before any projection (so the range must always be in degrees). However, the wrapping is performed <em>after</em> <code>xlim, ylim</code> are applied, so these options should probably never be combined. If there is a third component, this signifies the latitude at which Antarctica will be &quot;closed&quot;. The default value is -89.9. Special values are <code>NA</code> (don't draw Antarctica at all) and 0 (draw the line at the latitude of the extremal points, not at a fixed lower latitude). </p>
</td></tr>
<tr><td><code id="map_+3A_resolution">resolution</code></td>
<td>

<p>number that specifies the resolution with which
to draw the map.
Resolution 0 is the full resolution of the database.
Otherwise, just before polylines are plotted they are thinned:
roughly speaking, successive points on the polyline that are
within <code>resolution</code> device pixels of one another are collapsed
to a single point (see the Reference for further details).
Thinning is not performed if <code>plot = FALSE</code> or when polygons are drawn (<code>fill = TRUE</code> or <code>database</code> is a list of polygons).
</p>
</td></tr>
<tr><td><code id="map_+3A_type">type</code></td>
<td>

<p>character string that controls drawing of the map.
Aside from the default <code>type = "l"</code>, the value <code>type = "n"</code>
can be used
to set up the coordinate system and projection for a map that will
be added to in later calls.
</p>
</td></tr>
<tr><td><code id="map_+3A_bg">bg</code></td>
<td>

<p>background color.
</p>
</td></tr>
<tr><td><code id="map_+3A_mar">mar</code></td>
<td>

<p>margins, as in <code><a href="graphics.html#topic+par">par</a></code>.  Defaults allow for map.axes().
</p>
</td></tr>
<tr><td><code id="map_+3A_myborder">myborder</code></td>
<td>

<p>scalar or vector of length 2 specifying the porportion of the plot
to add to the defined or computed limits as borders.
</p>
</td></tr>
<tr><td><code id="map_+3A_namefield">namefield</code></td>
<td>

<p>A vector of column names to be used as region name if <code>database</code> is a <code>SpatialPolygonsDataFrame</code>. Ignored in all other cases.
</p>
</td></tr>
<tr><td><code id="map_+3A_lforce">lforce</code></td>
<td>
<p>Limit enforcement. Only taken into account if <code>xlim</code> and/or <code>ylim</code> are defined and (for &quot;s&quot; and &quot;l&quot;) a projection is used. Possible values are <code>"n"</code> (none) <code>"e"</code> (exact),<code>"s"</code> (small),<code>"l"</code> (large). 
If <code>lforce="e"</code>, map data is restricted exactly to the given limits prior to projection. This option affects the output value of the map, not only the plot window.
If <code>lforce="s"</code>, the four corners defined by <code>xlim</code> and <code>ylim</code> are projected and the plot window is restricted to the largest rectangle inside this region. 
<code>"l"</code> will result in a larger rectangle that includes the four corners. However, the parts that fall outside the original limits may not be complete (only polygons that partially fall inside the boundaries are included). This will also work with <code>fill=TRUE</code>. In this case the output value of the data is not changed, only the plot window is affected. These options are only useful for some projections.</p>
</td></tr>
<tr><td><code id="map_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>polygon</code> or <code>lines</code>. Of particular interest may be the options <code>border</code> and<code>lty</code> that control the color and line type of the polygon borders when <code>fill = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simplest form of use of this function is:
</p>
<pre>map(mymap)</pre>
<p>where <code>mymap</code> is the returned value from a previous call to
<code>map()</code>.
</p>


<h3>Value</h3>

<p>If <code>plot = TRUE</code>, a plot is made where 
the polygons selected from <code>database</code>, through the
<code>regions</code>, <code>xlim</code>, and <code>ylim</code> arguments, are outlined
(<code>fill</code> is <code>FALSE</code>) or filled (<code>fill</code> is <code>TRUE</code>)
with the colors in <code>col</code>.  
</p>
<p>The return value is a list with
<code>x</code>, <code>y</code>, <code>range</code>, and <code>names</code> components.  
This object can be used as a <code>database</code> for successive calls
to <code>map</code> and functions.
If <code>fill</code> is <code>FALSE</code>, the <code>x</code> and <code>y</code> vectors are
the coordinates of successive polylines, separated by <code>NA</code>s.  If
<code>fill</code> is <code>TRUE</code>, the <code>x</code> and <code>y</code> vectors have
coordinates of successive polygons, again separated by <code>NA</code>s.
Thus the return value can be handed directly to <code>lines</code> or
<code>polygon</code>, as appropriate.
</p>
<p>When <code>namesonly</code> is <code>TRUE</code>, only the names component is returned.
</p>
<p>After a call to <code>map</code> for which the <code>projection</code> argument was
specified there will be a global variable <code>.Last.projection</code>
containing information about the projection used.
This will be consulted in subsequent calls to <code>map</code> which use
<code>projection = ''</code>.
</p>


<h3>References</h3>

<p>Richard A. Becker, and Allan R. Wilks,
&quot;Maps in S&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [93.2], 1993.</em>
<a href="https://web.archive.org/web/20050825145143/http://www.research.att.com/areas/stat/doc/93.2.ps">https://web.archive.org/web/20050825145143/http://www.research.att.com/areas/stat/doc/93.2.ps</a>
</p>
<p>Richard A. Becker, and Allan R. Wilks,
&quot;Constructing a Geographical Database&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [95.2], 1995.</em>
<a href="https://web.archive.org/web/20050825145143/http://www.research.att.com/areas/stat/doc/95.2.ps">https://web.archive.org/web/20050825145143/http://www.research.att.com/areas/stat/doc/95.2.ps</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map.text">map.text</a></code>, <code><a href="#topic+map.axes">map.axes</a></code>,
<code><a href="#topic+map.scale">map.scale</a></code>, <code><a href="mapproj.html#topic+map.grid">map.grid</a></code> (in the <code>mapproj</code> library),
<code><a href="graphics.html#topic+polygon">polygon</a></code>, <code><a href="#topic+SpatialPolygons2map">SpatialPolygons2map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map()	# low resolution map of the world
map(wrap = c(0,360), fill = TRUE, col = 2) # pacific-centered map of the world
map(wrap = c(0, 360, NA), fill = TRUE, col = 2) # idem, without Antarctica
map('usa')	# national boundaries
map('county', 'new jersey')	# county map of New Jersey
map('state', region = c('new york', 'new jersey', 'penn'))	# map of three states
map("state", ".*dakota", myborder = 0)	# map of the dakotas
map.axes()				# show the effect of myborder = 0
if(require(mapproj))
  map('state', proj = 'bonne', param = 45)	# Bonne equal-area projection of states

# names of the San Juan islands in Washington state
map('county', 'washington,san', names = TRUE, plot = FALSE)

# national boundaries in one linetype, states in another
# (figure 5 in the reference)
map("state", interior = FALSE)
map("state", boundary = FALSE, lty = 2, add = TRUE)

# plot the ozone data on a base map
# (figure 4 in the reference)
data(ozone)
map("state", xlim = range(ozone$x), ylim = range(ozone$y))
text(ozone$x, ozone$y, ozone$median)
box()
if(require(mapproj)) {	# mapproj is used for  projection="polyconic"
  # color US county map by 2009 unemployment rate
  # match counties to map using FIPS county codes
  # Based on J's solution to the "Choropleth Challenge"
  # http://blog.revolutionanalytics.com/2009/11/choropleth-challenge-result.html

  # load data
  # unemp includes data for some counties not on the "lower 48 states" county
  # map, such as those in Alaska, Hawaii, Puerto Rico, and some tiny Virginia
  #  cities
  data(unemp)
  data(county.fips)

  # define color buckets
  colors = c("#F1EEF6", "#D4B9DA", "#C994C7", "#DF65B0", "#DD1C77", "#980043")
  unemp$colorBuckets &lt;- as.numeric(cut(unemp$unemp, c(0, 2, 4, 6, 8, 10, 100)))
  leg.txt &lt;- c("&lt;2%", "2-4%", "4-6%", "6-8%", "8-10%", "&gt;10%")

  # align data with map definitions by (partial) matching state,county
  # names, which include multiple polygons for some counties
  cnty.fips &lt;- county.fips$fips[match(map("county", plot=FALSE)$names,
    county.fips$polyname)]
  colorsmatched &lt;- unemp$colorBuckets [match(cnty.fips, unemp$fips)]

  # draw map
  map("county", col = colors[colorsmatched], fill = TRUE, resolution = 0,
    lty = 0, projection = "polyconic")
  map("state", col = "white", fill = FALSE, add = TRUE, lty = 1, lwd = 0.2,
    projection="polyconic")
  title("unemployment by county, 2009")
  legend("topright", leg.txt, horiz = TRUE, fill = colors)

  # Choropleth Challenge example, based on J's solution, see:
  # http://blog.revolutionanalytics.com/2009/11/choropleth-challenge-result.html
  # To see the faint county boundaries, use RGui menu:  File/SaveAs/PDF
}
</code></pre>

<hr>
<h2 id='map.axes'>
Draw Axes on Geographical Maps
</h2><span id='topic+map.axes'></span>

<h3>Description</h3>

<p>Draws a set of axes on an existing map.</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.axes(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.axes_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>axis</code> or <code>box</code>.</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>x- and y-axes are drawn for the currently displayed map.  These will
display in longitude and latitude (if no projection= has been
specified in the map() call).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map("state")
map.axes(cex.axis=0.8)
</code></pre>

<hr>
<h2 id='map.cities'>
Add Cities to Existing Map
</h2><span id='topic+map.cities'></span>

<h3>Description</h3>

<p>Adds city locations and (optionally) names to an existing map using a
specified database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.cities(x = world.cities, country = "", label = NULL, minpop = 0,
maxpop = Inf, capitals = 0, cex = par("cex"), projection = FALSE,
parameters = NULL, orientation = NULL, pch = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.cities_+3A_x">x</code></td>
<td>

<p>Name of database. See <code><a href="#topic+world.cities">world.cities</a></code> to determine the structure of
the database.
</p>
</td></tr>
<tr><td><code id="map.cities_+3A_country">country</code></td>
<td>

<p>If the string country is specified, limit the displayed cities to be
from within the specified country, province or state (depending on how
the database has been constructed).
</p>
</td></tr>
<tr><td><code id="map.cities_+3A_label">label</code></td>
<td>

<p>If <code>TRUE</code>, label all cities.  If <code>NULL</code>,
the cities will be labelled unless there are 20 or more.
</p>
</td></tr>
<tr><td><code id="map.cities_+3A_minpop">minpop</code></td>
<td>

<p>The minimum value of population below which a particular city will not
be shown.
</p>
</td></tr>
<tr><td><code id="map.cities_+3A_maxpop">maxpop</code></td>
<td>

<p>The maximum value of population above which a particular city will not
be shown.
</p>
</td></tr>
<tr><td><code id="map.cities_+3A_capitals">capitals</code></td>
<td>

<p>Selection of capitals-only display. Capitals may be 1 (country capital),
2 (provincial, state, or regional capital) or 3 (local capital). See
<code><a href="#topic+world.cities">world.cities</a></code> for further information.
</p>
</td></tr>
<tr><td><code id="map.cities_+3A_cex">cex</code></td>
<td>

<p>The value of cex acts to override the current value of character size
expansion.
</p>
</td></tr>
<tr><td><code id="map.cities_+3A_projection">projection</code></td>
<td>

<p>Boolean or character value.  If <code>FALSE</code> (the default), no
projection is assumed, if <code>TRUE</code>, the previous projection is used,
otherwise a character string that names a map projection to use.
See <code><a href="mapproj.html#topic+mapproject">mapproject</a></code> (in the <code>mapproj</code> library).
</p>
</td></tr>
<tr><td><code id="map.cities_+3A_parameters">parameters</code></td>
<td>

<p>numeric vector of parameters for use with the <code>projection</code>
argument.  This argument is optional only in the sense that certain
projections do not require additional parameters.  If a projection
does require additional parameters, these must be given in the
<code>parameters</code> argument.
</p>
</td></tr>
<tr><td><code id="map.cities_+3A_orientation">orientation</code></td>
<td>

<p>a vector <code>c(latitude, longitude, rotation)</code> describing where
the map should be centered and a clockwise rotation (in degrees)
about this center.
</p>
</td></tr>
<tr><td><code id="map.cities_+3A_pch">pch</code></td>
<td>

<p>plotting character to use for marking city location. See
<code><a href="graphics.html#topic+points">points</a></code> for options.
</p>
</td></tr>
<tr><td><code id="map.cities_+3A_...">...</code></td>
<td>

<p>Further plotting parameters may be specified as for the commands
<code><a href="graphics.html#topic+points">points</a></code> and <code><a href="graphics.html#topic+text">text</a></code>.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The database is searched for all cities matching the specified criteria
and fitting within the limits of the plot currently displayed.  The
default database is of all cities that have a population greater than a
certain threshold or which are capital cities of a country or island
territory.  The threshold varies from country to country, but in
general is no higher than about 40,000.  The data were originally obtained from Stefan Helders' website (http://www.world-gazetteer.com),
which now redirects to <a href="http://www.populationmondiale.com">http://www.populationmondiale.com</a>. There are no recent updates available.
</p>
<p>There are three supplied databases, world.cities (the default), us.cities
and canada.cities.  The latter two, which need to be made available by
using a <code>'data()'</code> call, include the state or province name with the
city name (thanks to John Woodruff <a href="mailto:jpwoodruff@irisinternet.net">jpwoodruff@irisinternet.net</a>
for the state and province information).
</p>
<p>Note that if the underlying map is &quot;Pacific-centric&quot;, i.e. longitudes
exceed 180 degrees, and a projection is used, then the map.cities data
must be transformed appropriately.
</p>


<h3>Value</h3>

<p>No value is returned from map.cities.
</p>


<h3>Side Effects</h3>

<p>All cities within the boundaries of the plot containing the current map
are added to the plot.  Note that it is possible that the boundaries of
the plot exceed the boundaries of the map requested, and so more cities
than were expected might be shown.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+world.cities">world.cities</a></code>, <code><a href="#topic+canada.cities">canada.cities</a></code>,
<code><a href="#topic+us.cities">us.cities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map("world", "China")
map.cities(country = "China", capitals = 2)
map("state", "New Jersey")
data(us.cities)
map.cities(us.cities, country="NJ")
</code></pre>

<hr>
<h2 id='map.scale'>
Add Scale to Existing Unprojected Map
</h2><span id='topic+map.scale'></span>

<h3>Description</h3>

<p>Adds a scale to an existing map, both as a ratio and a distance gauge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.scale(x, y, relwidth = 0.15, metric = TRUE, ratio = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.scale_+3A_x">x</code></td>
<td>

<p>Horizontal location of left end of distance gauge.  If not specified,
this will be taken to be near the lower left corner of the map.
</p>
</td></tr>
<tr><td><code id="map.scale_+3A_y">y</code></td>
<td>

<p>Vertical location of left end of distance gauge.  If not specified,
this will be taken to be near the lower left corner of the map.
</p>
</td></tr>
<tr><td><code id="map.scale_+3A_relwidth">relwidth</code></td>
<td>

<p>Proportion of width of display to be used for the scale.  The default is
0.15 (15%).
</p>
</td></tr>
<tr><td><code id="map.scale_+3A_metric">metric</code></td>
<td>

<p>If <code>TRUE</code>, the distance gauge will be in km, otherwise miles.
</p>
</td></tr>
<tr><td><code id="map.scale_+3A_ratio">ratio</code></td>
<td>

<p>If <code>FALSE</code>, the scale ratio of the map is not displayed.
</p>
</td></tr>
<tr><td><code id="map.scale_+3A_...">...</code></td>
<td>

<p>Further plotting parameters may be specified as for the command text().
</p>
</td></tr></table>


<h3>Details</h3>

<p>The scale is calculated from the displayed graph's plotting parameters,
and the latitude of the location at which the distance gauge will be
displayed.
</p>


<h3>Value</h3>

<p>The exact calculated scale is returned.
</p>


<h3>NOTE</h3>

<p>This function is meaningful only if no projection= has been specified
in the call to map().
</p>


<h3>Side Effects</h3>

<p>A scale is added to the currently displayed map. This takes the form of
an approximate 1:n scale (containing 2-3 significant digits), above a
distance gauge which is reasonably accurate for the latitude at which it
appears.  The circumference at the given latitude is interpolated from a
radius of 6356.78 km at the pole and 6378.16 km at the equator.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map.axes">map.axes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map("world", "China")
map.scale()
</code></pre>

<hr>
<h2 id='map.text'>
Draw a map with labeled regions
</h2><span id='topic+map.text'></span>

<h3>Description</h3>

<p>Like <code><a href="#topic+map">map</a></code>, but labels the regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.text(database, regions = ".", exact = FALSE, labels, cex = 0.75,
add = FALSE, move = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.text_+3A_database">database</code></td>
<td>
<p>character string naming a geographical database, or a list of
<code>x</code>, <code>y</code>, and <code>names</code> obtained from a previous call to
<code>map</code>.</p>
</td></tr>
<tr><td><code id="map.text_+3A_regions">regions</code></td>
<td>
<p>character vector that names the polygons to draw.</p>
</td></tr>
<tr><td><code id="map.text_+3A_exact">exact</code></td>
<td>
<p>If 'TRUE', only exact matches with 'regions' are selected
for drawing.</p>
</td></tr>
<tr><td><code id="map.text_+3A_labels">labels</code></td>
<td>
<p>character vector of labels, one for each region
selected.  Defaults to the names in the database.</p>
</td></tr>
<tr><td><code id="map.text_+3A_cex">cex</code></td>
<td>
<p>character expansion factor.</p>
</td></tr>
<tr><td><code id="map.text_+3A_add">add</code></td>
<td>
<p>If <code>FALSE</code>, a map is drawn, then labels placed on top.  If
<code>TRUE</code>, labels are added to the existing map.</p>
</td></tr>
<tr><td><code id="map.text_+3A_move">move</code></td>
<td>
<p>If <code>TRUE</code>, labels are moved so that they don't
overlap.  Requires the <code>mining</code> library (not in CRAN, contact
tpminka@media.mit.edu).</p>
</td></tr>
<tr><td><code id="map.text_+3A_...">...</code></td>
<td>
<p>Other arguments are the same as in <code><a href="#topic+map">map</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>add = FALSE</code>, a map is drawn by calling <code><a href="#topic+map">map</a></code>.
Then the label for each region is placed at the centroid of the region
polygon.
</p>
<p>The return value is a map object, as from <code><a href="#topic+map">map</a></code>.
</p>


<h3>Author(s)</h3>

<p>Tom Minka</p>


<h3>Examples</h3>

<pre><code class='language-R'>map.text("world", "ira")    # iran and iraq
map.text("state", "penn")
map.text("county", "penn")  # Pennsylvania counties
map.text("county", "new jersey")  # New Jersey counties
</code></pre>

<hr>
<h2 id='map.where'>
Locate points on a map
</h2><span id='topic+map.where'></span>

<h3>Description</h3>

<p>Returns the region names containing given locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.where(database = "world", x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.where_+3A_database">database</code></td>
<td>
<p>character string naming a geographical database, or a list of
<code>x</code>, <code>y</code>, and <code>names</code>.
See the documentation for <a href="#topic+map">map</a> for more details.</p>
</td></tr>
<tr><td><code id="map.where_+3A_x">x</code></td>
<td>
<p>vector of longitudes.</p>
</td></tr>
<tr><td><code id="map.where_+3A_y">y</code></td>
<td>
<p>vector of latitudes.</p>
</td></tr>
<tr><td><code id="map.where_+3A_...">...</code></td>
<td>
<p>Options for <code>SpatialPolygons2map</code>, only used if <code>database</code> is of type <code>SpatialPolygonsDataFrame</code></p>
</td></tr></table>
<p>.
</p>


<h3>Value</h3>

<p>A list of character strings, naming the map region that each
(longitude, latitude) pair falls into.
</p>


<h3>Note</h3>

<p>For points close to a border (polygon boundary), the result may be wrong if the
resolution of the database is insufficient.
This function may also give erroneous results if the database contains
enclaves. For instance, a point in San Marino may also be identified 
as being in Italy.
</p>


<h3>Author(s)</h3>

<p>Tom Minka</p>


<h3>See Also</h3>

<p><code>in.polygon</code></p>


<h3>Examples</h3>

<pre><code class='language-R'># NYC
map.where("state", -73.8, 41)
# Auckland
map.where("nz", 174.6, -36.92)
# find both in the world
map.where(x = c(174.6, -73.8), y = c(-36.92, 41))
# with a map object:
m = map("state", "new york", fill = TRUE, plot = FALSE)
map.where(m, -73.8, 41)
</code></pre>

<hr>
<h2 id='match.map'>
Index map regions
</h2><span id='topic+match.map'></span>

<h3>Description</h3>

<p>Assigns an index to each map region, useful for map coloring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.map(database, regions, exact = FALSE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.map_+3A_database">database</code></td>
<td>

<p>character string naming a geographical database, or a map object.
See the documentation for <code><a href="#topic+map">map</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="match.map_+3A_regions">regions</code></td>
<td>

<p>a vector of names, or more generally regular expressions
to match against the map region names.
</p>
</td></tr>
<tr><td><code id="match.map_+3A_exact">exact</code></td>
<td>
<p>If <code>TRUE</code>, only exact matches with <code>regions</code>
are considered.  Otherwise each element of <code>regions</code> is assumed
to be a regular expression.
Matches are always case-insensitive.</p>
</td></tr>
<tr><td><code id="match.map_+3A_warn">warn</code></td>
<td>
<p>If <code>TRUE</code>, a warning is printed when an element of
<code>regions</code> matches nothing in the map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an integer vector giving an index to each region in the database.
The index is the index of the string in <code>regions</code> which matches the
region name.  Matching is done as in <code><a href="#topic+map">map</a></code>.
More specifically, all regions <code>r</code> whose name matches 
<code>regions[i]</code> will have index <code>i</code>.
Unmatched regions will have index <code>NA</code>.
Overlapping matches cause an error.
</p>
<p>This behavior differs from <code><a href="base.html#topic+pmatch">pmatch</a></code> because a single entry
in <code>regions</code> may match several entries in the map.
</p>


<h3>Author(s)</h3>

<p>Tom Minka</p>


<h3>References</h3>

<p>Richard A. Becker, and Allan R. Wilks,
&quot;Maps in S&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report, 1991.</em>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># filled map showing Republican vote in 1900
# (figure 6 in the reference)
data(state, package = "datasets")
data(votes.repub)
state.to.map &lt;- match.map("state", state.name)
x &lt;- votes.repub[state.to.map, "1900"]
gray.colors &lt;- function(n) gray(rev(0:(n - 1))/n)
color &lt;- gray.colors(100)[floor(x)]
map("state", fill = TRUE, col = color); map("state", add = TRUE)
</code></pre>

<hr>
<h2 id='nz'>
New Zealand Basic Map
</h2><span id='topic+nz'></span><span id='topic+nzMapEnv'></span>

<h3>Description</h3>

<p>This database produce a map of New Zealand at a basic level of
detail.  The &lsquo;&quot;nz&quot;&rsquo; database includes the 3 main Islands and 19 smaller
coastal islands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nzMapEnv)</code></pre>


<h3>Format</h3>

<p>The data file is merely a character string which
specifies the name of an environment variable which contains the
base location of the binary files used by the map drawing functions.
This environment variable (<code>R_MAP_DATA_DIR</code> for the datasets in the
maps package) is set at package load time <em>if it does not
already exist</em>.  Hence setting the environment variable before loading
the package can override the default location of the binary datasets.
</p>


<h3>References</h3>

<p>Richard A. Becker, and Allan R. Wilks,
&quot;Maps in S&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [93.2], 1993.</em>
</p>
<p>Richard A. Becker, and Allan R. Wilks,
&quot;Constructing a Geographical Database&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [95.2], 1995.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map('nz')
map('nz', xlim = c(166, 179), ylim = c(-48, -34))
</code></pre>

<hr>
<h2 id='ozone'>Sample datasets</h2><span id='topic+ozone'></span><span id='topic+votes.repub'></span><span id='topic+unemp'></span>

<h3>Description</h3>

<p>Datasets used to illustrate map functions.
</p>
<p><code>ozone</code> contains the median of daily maxima ozone concentration in 41 US cities for June 1974 through August 1974. Concentrations are in parts per billion (ppb).
</p>
<p><code>unemp</code> Has population and unemployment percentage for US counties.
</p>
<p><code>votes.repub</code> contains the percentage republican votes in the 1900 election.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ozone)
data(unemp)
data(votes.repub)
</code></pre>


<h3>References</h3>

<p>Cleveland, W.S., Kleiner, B., McRae, J.E., Warner, J.L., and Pasceri, P.E. ,
&quot;The Analysis of Ground-Level Ozone Data from New Jersey, New York, Connecticut, and Massachusetts: Data Quality Assessment and Temporal and Geographical Properties&quot;, <em>Bell Laboratories Memorandum, 1975</em>.
</p>

<hr>
<h2 id='polygon'>Polygon functions</h2><span id='topic+apply.polygon'></span><span id='topic+area.polygon'></span><span id='topic+centroid.polygon'></span><span id='topic+as.matrix.polygon'></span><span id='topic+closed.polygon'></span><span id='topic+in.polygon'></span><span id='topic+in.one.polygon'></span><span id='topic+num.polygons'></span><span id='topic+sub.polygon'></span>

<h3>Description</h3>

<p>These functions are called internally and will generally not be
required by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area.polygon(p)
centroid.polygon(p)
## S3 method for class 'polygon'
as.matrix(x, ...)
closed.polygon(p)
in.one.polygon(p, x)
in.polygon(p, x)
num.polygons(p)
sub.polygon(p, i)
</code></pre>

<hr>
<h2 id='smooth.map'>
Smooth out aggregated data
</h2><span id='topic+smooth.map'></span>

<h3>Description</h3>

<p>Increases the resolution of data aggregated over map regions,
by either smoothing or interpolation.
Also fills in missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.map(m, z, res = 50, span = 1/10, averages = FALSE, type = c("smooth",
"interp"), merge = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.map_+3A_m">m</code></td>
<td>
<p>a map object</p>
</td></tr>
<tr><td><code id="smooth.map_+3A_z">z</code></td>
<td>
<p>a named vector</p>
</td></tr>
<tr><td><code id="smooth.map_+3A_res">res</code></td>
<td>
<p>a vector of length two, specifying the resolution of the
sampling grid in
each dimension.  If a single number, it is taken as the vertical
resolution, with double taken as the horizontal resolution.</p>
</td></tr>
<tr><td><code id="smooth.map_+3A_span">span</code></td>
<td>
<p>kernel parameter (larger = smoother).
<code>span = Inf</code> is a special case which invokes the cubic spline kernel.
<code>span</code> is automatically scaled by the map size, and is
independent of <code>res</code>.</p>
</td></tr>
<tr><td><code id="smooth.map_+3A_averages">averages</code></td>
<td>
<p>If <code>TRUE</code>, the values in <code>z</code> are interpreted
as averages over the regions.  Otherwise they are interpreted as totals.</p>
</td></tr>
<tr><td><code id="smooth.map_+3A_type">type</code></td>
<td>
<p>see details.</p>
</td></tr>
<tr><td><code id="smooth.map_+3A_merge">merge</code></td>
<td>
<p>If <code>TRUE</code>, a region named in <code>z</code> includes
all matching regions in the map (according to
<code><a href="#topic+match.map">match.map</a></code>).
If <code>FALSE</code>, a region named in
<code>z</code> is assumed to refer to exactly one region on the map.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>type = "smooth"</code>, the region totals are first converted
into point measurements on the
sampling grid, by dividing the total for a region among all sample
points inside it.  Then it is a regular kernel smoothing 
problem.  Note that the region totals are not preserved.
</p>
<p>The prediction <code class="reqn">z_o</code> for
location <code class="reqn">x_o</code> (a vector) is the average of <code>z</code> for
nearby sample points:
</p>
<p style="text-align: center;"><code class="reqn">z_o = \frac{\sum_x k(x, x_o) z(x)}{\sum_x k(x, x_o)}</code>
</p>

<p style="text-align: center;"><code class="reqn">k(x, x_o) = exp(-\lambda ||x - x_o||^2)</code>
</p>

<p><code class="reqn">\lambda</code> is determined from <code>span</code>.
Note that <code class="reqn">x_o</code> is over the same sampling grid as
<code class="reqn">x</code>, but <code class="reqn">z_o</code> is not necessarily the same as
<code class="reqn">z(x_o)</code>.
</p>
<p>For <code>type = "interp"</code>, the region totals are preserved by the
higher-resolution function.
The function is assumed to come from a
Gaussian process with kernel <code class="reqn">k</code>.  The measurement <code>z[r]</code>
is assumed to be the sum of the function over the discrete sample
points inside region <code>r</code>.
This leads to a simple formula for the covariance matrix of <code>z</code>
and the cross-covariance between <code>zo</code> and <code>z</code>.
The prediction is the cross-covariance times the inverse covariance
times <code>z</code>.  Unlike Tobler's method, the predictions are not
constrained to live within the original data range,
so there tends to be &quot;ringing&quot; effects.
</p>
<p>See the references for more details.
</p>


<h3>Value</h3>

<p>A data frame with columns <code>x</code>, <code>y</code>, and <code>z</code>
giving the smoothed value <code>z</code> for locations (x, y).
Currently the (x, y) values form a grid, but this is not
guaranteed in the future.
</p>


<h3>Author(s)</h3>

<p>Tom Minka</p>


<h3>References</h3>

<p>W.F. Eddy and A. Mockus. 
An example of the estimation and display of a smoothly varying
function of time and space - the incidence of disease mumps.
<em>Journal of the American Society for Information Science</em>,
45(9):686-693, 1994.
<a href="https://web.eecs.utk.edu/~audris/papers/jasis.pdf">https://web.eecs.utk.edu/~audris/papers/jasis.pdf</a>
</p>
<p>W. R. Tobler.  Smooth pycnophylactic interpolation for
geographical regions.  <em>Journal of the American Statistical
Association</em> 74:519-530, 1979.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compare to the example for match.map
data(state, package = "datasets")
data(votes.repub)
z = votes.repub[, "1900"]
m = map("state", fill = TRUE, plot = FALSE)
# use a small span to fill in, but not smooth, the data
# increase the resolution to get better results
fit = smooth.map(m, z, span = 1/100, merge = TRUE, ave = TRUE)
mat = tapply(fit$z, fit[1:2], mean)
gray.colors &lt;- function(n) gray(rev(0:(n - 1))/n)
par(bg = "blue")
filled.contour(mat, color.palette = gray.colors, nlev = 32, asp = 1)
# another way to visualize:
image(mat, col = gray.colors(100))

# for a higher degree of smoothing:
# fit = smooth.map(m, z, merge = TRUE, ave = TRUE)
# interpolation, state averages are preserved:
# fit = smooth.map(m, z, merge = TRUE, ave = TRUE, type = "interp")
</code></pre>

<hr>
<h2 id='Spatial2map'>
Read SpatialPolygons and SpatialLines objects
</h2><span id='topic+Spatial2map'></span><span id='topic+SpatialPolygons2map'></span><span id='topic+SpatialLines2map'></span>

<h3>Description</h3>

<p>These functions transform some classes provided by the package <code>sp</code> into a simple list that can be used by map().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	SpatialPolygons2map(database, namefield=NULL)
	SpatialLines2map(database, namefield=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spatial2map_+3A_database">database</code></td>
<td>
<p>A <code>SpatialPolygons</code> or <code>SpatialLines</code> object.</p>
</td></tr>
<tr><td><code id="Spatial2map_+3A_namefield">namefield</code></td>
<td>
<p>The name of a data column in <code>database</code> to be used for naming the polygons (or lines). If it is a vector of names, these are all used and separated by a colon ':'. Not case sensitive. So if the database contains columns that only differ by case, you get a warning and namefield is not used at all.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'map' list object only preserves co-ordinates and polygon names. All other information available in the original data is lost.
</p>
<p>The option <code>namefield</code> is only taken into account if <code>database</code> is class <code>Spatial[]DataFrame</code>. <code>namefield</code> may be a vector of column names, e.g. to get polygons named as 'country:state'.</p>


<h3>Value</h3>

<p>A list with four components: <code>x, y, names, range</code>, similar to the return value of <code>map()</code>. This data can be used as a database for <code>map()</code>. The lines and polygons are separated by NA.</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>,<code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code> (in the <code>sp</code> library).
</p>

<hr>
<h2 id='state'>
United States State Boundaries Map
</h2><span id='topic+state'></span><span id='topic+stateMapEnv'></span>

<h3>Description</h3>

<p>This database produces a map of the states of the United States mainland
generated from US Department of the Census data (see the reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stateMapEnv)</code></pre>


<h3>Format</h3>

<p>The data file is merely a character string which
specifies the name of an environment variable which contains the
base location of the binary files used by the map drawing functions.
This environment variable (<code>R_MAP_DATA_DIR</code> for the datasets in the
maps package) is set at package load time <em>if it does not
already exist</em>.  Hence setting the environment variable before loading
the package can override the default location of the binary datasets.
</p>


<h3>References</h3>

<p>Richard A. Becker, and Allan R. Wilks,
&quot;Maps in S&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [93.2], 1993.</em>
</p>
<p>Richard A. Becker, and Allan R. Wilks,
&quot;Constructing a Geographical Database&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [95.2], 1995.</em>
</p>
<p>US Department of Commerce, Census Bureau,
<em>County Boundary File,</em>
computer tape, available from Customer Services,
Bureau of the Census, Washingdon DC 20233.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map('state', fill = TRUE, col = palette())
</code></pre>

<hr>
<h2 id='state.carto'>
United States State Population Cartogram Map
</h2><span id='topic+state.carto'></span><span id='topic+state.cartoMapEnv'></span><span id='topic+state.carto.center'></span>

<h3>Description</h3>

<p>This database produces a cartogram of the states of the United States
mainland based on CartoDraw, roughly proportional to population (see
references).
</p>
<p><code>state.carto.center</code> are coordinates of the state centers
for annotation purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stateMapEnv)
data(state.carto.center)
</code></pre>


<h3>Format</h3>

<p>The data file is merely a character string which
specifies the name of an environment variable which contains the
base location of the binary files used by the map drawing functions.
This environment variable (<code>R_MAP_DATA_DIR</code> for the datasets in the
maps package) is set at package load time <em>if it does not
already exist</em>.  Hence setting the environment variable before loading
the package can override the default location of the binary datasets.
</p>


<h3>References</h3>

<p>Richard A. Becker, and Allan R. Wilks,
&quot;Maps in S&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [93.2], 1993.</em>
</p>
<p>Richard A. Becker, and Allan R. Wilks,
&quot;Constructing a Geographical Database&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [95.2], 1995.</em>
</p>
<p>CartoDraw,
<a href="http://www.computer.org/csdl/trans/tg/2004/01/v0095-abs.html">http://www.computer.org/csdl/trans/tg/2004/01/v0095-abs.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map('state.carto', fill = TRUE, col = palette())
</code></pre>

<hr>
<h2 id='state.fips'>
FIPS state codes for US 48 State Map
</h2><span id='topic+state.fips'></span>

<h3>Description</h3>

<p>A database matching FIPS codes to maps package state names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(state.fips)</code></pre>


<h3>Format</h3>

<p>A list with 6 components, namely &quot;fips&quot;, &quot;ssa&quot;, &quot;region&quot;, &quot;division&quot;,
&quot;abb&quot; and &quot;polyname&quot;, containing the US Census Bureau FIPS, SSA, REGION
and DIVISION numbers, the standard state abbreviation and the respective
state polygon name. Note that &quot;fips&quot; is represented as an integer, so any leading zero (which is part of the fips code) is not shown by default.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+county.fips">county.fips</a></code>
</p>

<hr>
<h2 id='state.vbm'>
United States State Visibility Base Map
</h2><span id='topic+state.vbm'></span><span id='topic+state.vbmMapEnv'></span><span id='topic+state.vbm.center'></span>

<h3>Description</h3>

<p>This database produces a map of the states of the United States
mainland. The Visibility Base Map was created by Mark Monmonier
to provide simplified state shapes with sufficient areas to allow
annotations in even the small states.
</p>
<p><code>state.vbm.center</code> are coordinates of the state centers
for annotation purposes. The states are alphabetically ordered, in the same order as the map. So state names can be matched via e.g. <code>map(state.vbm, plot=FALSE)$name</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(state.vbmMapEnv)
data(state.vbm.center)
</code></pre>


<h3>Format</h3>

<p>The data file is merely a character string which
specifies the name of an environment variable which contains the
base location of the binary files used by the map drawing functions.
This environment variable (<code>R_MAP_DATA_DIR</code> for the datasets in the
maps package) is set at package load time <em>if it does not
already exist</em>.  Hence setting the environment variable before loading
the package can override the default location of the binary datasets.
</p>


<h3>References</h3>

<p>Richard A. Becker, and Allan R. Wilks,
&quot;Maps in S&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [93.2], 1993.</em>
</p>
<p>Richard A. Becker, and Allan R. Wilks,
&quot;Constructing a Geographical Database&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [95.2], 1995.</em>
</p>
<p>Mark Monmonier and George Schnell,
&quot;The Study of Population&quot;,
<em>Elements, Patterns, Processes. Charles E. Merrill. Columbus, OH. 1982.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map('state.vbm', fill = TRUE, col = palette())
</code></pre>

<hr>
<h2 id='us.cities'>
Database of US cities
</h2><span id='topic+us.cities'></span>

<h3>Description</h3>

<p>This database is of us cities of population greater than about 40,000.
Also included are state capitals of any population size.
</p>


<h3>Format</h3>

<p>A list with 6 components, namely &quot;name&quot;, &quot;country.etc&quot;, &quot;pop&quot;,  &quot;lat&quot;,
&quot;long&quot;, and &quot;capital&quot;, containing the city name, the state abbreviation,
approximate population (as at January 2006), latitude, longitude and
capital status indication (0 for non-capital, 1 for capital, 2 for state
capital.
</p>


<h3>NOTE</h3>

<p>Some of the city names may be out of date.  Please send
any corrections to the package maintainer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map.cities">map.cities</a></code>
</p>

<hr>
<h2 id='usa'>
United States Coast Map
</h2><span id='topic+usa'></span><span id='topic+usaMapEnv'></span>

<h3>Description</h3>

<p>This database produces a map of the United States mainland generated from
US Department of the Census data (see the reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(usaMapEnv)</code></pre>


<h3>Format</h3>

<p>The data file is merely a character string which
specifies the name of an environment variable which contains the
base location of the binary files used by the map drawing functions.
This environment variable (<code>R_MAP_DATA_DIR</code> for the datasets in the
maps package) is set at package load time <em>if it does not
already exist</em>.  Hence setting the environment variable before loading
the package can override the default location of the binary datasets.
</p>


<h3>References</h3>

<p>Richard A. Becker, and Allan R. Wilks,
&quot;Maps in S&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [93.2], 1993.</em>
</p>
<p>Richard A. Becker, and Allan R. Wilks,
&quot;Constructing a Geographical Database&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [95.2], 1995.</em>
</p>
<p>US Department of Commerce, Census Bureau,
<em>County Boundary File,</em>
computer tape, available from Customer Services,
Bureau of the Census, Washingdon DC 20233.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map('usa')
</code></pre>

<hr>
<h2 id='world'>
Low (mid) resolution World Map
</h2><span id='topic+world'></span><span id='topic+worldMapEnv'></span>

<h3>Description</h3>

<p>This world map (updated in 2013) is imported from the public domain Natural Earth project (the 1:50m resolution version). It replaces a much older version based on the CIA World Data Bank II data.
The old legacy data is still available in the package <code>mapdata</code> (v2.3.0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(worldMapEnv)</code></pre>


<h3>Format</h3>

<p>The data file is merely a character string which
specifies the name of an environment variable which contains the
base location of the binary files used by the map drawing functions.
This environment variable (<code>R_MAP_DATA_DIR_WORLD</code>) is set at package load time <em>if it does not
already exist</em>.  Hence setting the environment variable before loading
the package can override the default location of the binary datasets.
</p>


<h3>Details</h3>

<p>As of version 3.1, the <code>world</code> database no longer contains any lakes. These have been moved to a separate database called <code>lakes</code>.
The legacy world map (dating from around 1990) has been removed from the package and is now available from the <code>mapdata</code> package in two different resolutions (worldHires and worldLores).
</p>


<h3>Source</h3>

<p>The Natural Earth data set is in the public domain and available from <a href="https://www.naturalearthdata.com">https://www.naturalearthdata.com</a>.
</p>


<h3>References</h3>

<p>Richard A. Becker, and Allan R. Wilks,
&quot;Maps in S&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [93.2], 1993.</em>
</p>
<p>Richard A. Becker, and Allan R. Wilks,
&quot;Constructing a Geographical Database&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [95.2], 1995.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>,<code><a href="#topic+lakes">lakes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># notice how some polygons extend beyond the [-180,180] interval:
map('world', fill = TRUE, col = 1:10)
# if you wrap at [-180,180], you also can get a clean closure of Antarctica
map('world', fill = TRUE, col = 1:10, wrap=c(-180,180) )
</code></pre>

<hr>
<h2 id='world.cities'>
Database of world cities
</h2><span id='topic+world.cities'></span>

<h3>Description</h3>

<p>This database is primarily of world cities of population greater than
about 40,000.  Also included are capital cities of any population size, and
many smaller towns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(world.cities)</code></pre>


<h3>Format</h3>

<p>A list with 6 components, namely &quot;name&quot;, &quot;country.etc&quot;, &quot;pop&quot;, &quot;lat&quot;,
&quot;long&quot;, and &quot;capital&quot;, containing the city name, the country name,
approximate population (as at January 2006), latitude, longitude and
capital status indication (0 for non-capital, 1 for capital, 2 for China
Municipalities, and 3 for China Provincial capitals)
</p>


<h3>NOTE</h3>

<p>Some of the country names and city names may be out of date.  Please send
any corrections to the package maintainer.
</p>


<h3>Source</h3>

<p>The data were originally obtained from Stefan Helders' website (http://www.world-gazetteer.com),
which now redirects to <a href="http://www.populationmondiale.com">http://www.populationmondiale.com</a>. There are no recent updates available.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map.cities">map.cities</a></code>
</p>

<hr>
<h2 id='world2'>
Pacific Centric Low resolution World Map
</h2><span id='topic+world2'></span><span id='topic+world2MapEnv'></span>

<h3>Description</h3>

<p>This is an alternative version of the <code>world</code> database 
based on latitudes [0, 360), which then has the Pacific
Ocean in the centre of the map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(world2MapEnv)</code></pre>


<h3>Format</h3>

<p>The data file is merely a character string which
specifies the name of an environment variable which contains the
base location of the binary files used by the map drawing functions.
This environment variable (<code>R_MAP_DATA_DIR_WORLD</code> for the datasets in the
maps package) is set at package load time <em>if it does not
already exist</em>.  Hence setting the environment variable before loading
the package can override the default location of the binary datasets.
</p>


<h3>NOTE</h3>

<p>This data set is in fact largely obsolete. Often the same (more general) result can be obtained by using wrapping:
</p>
<p>map(&quot;world&quot;, wrap=c(0,360))
</p>
<p>This will also work fine with <code>fill=TRUE</code> or any other appropriate longitude interval (e.g. <code>c(-90,270)</code>).
</p>
<p>However, <code>world2</code> is useful when setting <code>xlim</code> to an interval crossing the 180 meridian.
</p>


<h3>Source</h3>

<p>The public domain Natural Earth data set is available from <a href="https://www.naturalearthdata.com">https://www.naturalearthdata.com</a>.
</p>


<h3>References</h3>

<p>Richard A. Becker, and Allan R. Wilks,
&quot;Maps in S&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [93.2], 1993.</em>
</p>
<p>Richard A. Becker, and Allan R. Wilks,
&quot;Constructing a Geographical Database&quot;,
<em>AT&amp;T Bell Laboratories Statistics Research Report [95.2], 1995.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>, <code><a href="#topic+world">world</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map('world2', xlim = c(100, 300))
map.axes()
# xlim is performed before wrapping:
map('world', wrap=c(0,360), xlim = c(100, 300))
# so to emulate "world2":
ww2 &lt;- map('world', wrap=c(0,360), plot=FALSE, fill=TRUE)
map(ww2, xlim = c(100, 300), fill=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
