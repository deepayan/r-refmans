<!DOCTYPE html><html><head><title>Help for package readmoRe</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {readmoRe}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#get.nlines'><p>Determine the number of lines in a (large) text file without importing it.</p></a></li>
<li><a href='#get.sep'><p>Determine field delimiter in text files</p></a></li>
<li><a href='#get.skip'><p>Determine Number of Rows to be Skipped in Text Files</p></a></li>
<li><a href='#read.to.list'><p>Read various input file formats into a list of data frames. Wrapper function for 'read2list' to automate</p>
reading further and avoid errors due to missing folders or files.</a></li>
<li><a href='#read2list'><p>Read various input file formats into a list of data frames</p></a></li>
<li><a href='#readmoRe'><p>Utilities for data import</p></a></li>
<li><a href='#rm.empty.cols'><p>Remove Empty Columns From an Imported Excel Sheet</p></a></li>
<li><a href='#rm.newline.chars'><p>Remove 'newline' Characters From Imported Excel Sheets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Utilities for Importing and Manipulating Biomedical Data Files</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-12</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-08-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Vidal Fey</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vidal Fey &lt;vidal.fey@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to read various file types into one list of data structures, usually, but not limited to, data frames.
  Excel files are read sheet-wise, i.e., all or a selection of sheets can be read. Field delimiters and decimal
  separators are determined automatically.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), R.utils, utils</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, xml2, readxl, plyr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-17 12:16:23 UTC; fsvife</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-19 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='get.nlines'>Determine the number of lines in a (large) text file without importing it.</h2><span id='topic+get.nlines'></span>

<h3>Description</h3>

<p>Determine the number of lines in a (large) text file without importing it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.nlines(file, n = 1, pattern = NULL, incl.header = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.nlines_+3A_file">file</code></td>
<td>
<p><code>character of length 1</code>. File path.</p>
</td></tr>
<tr><td><code id="get.nlines_+3A_n">n</code></td>
<td>
<p><code>integer</code>. Maximum number of lines to read when determining the 'skip' value. Passed to 'get.skip'.</p>
</td></tr>
<tr><td><code id="get.nlines_+3A_pattern">pattern</code></td>
<td>
<p><code>character</code>. Search pattern to find a certain row in 'file'. Passed to 'get.skip'.</p>
</td></tr>
<tr><td><code id="get.nlines_+3A_incl.header">incl.header</code></td>
<td>
<p><code>logical</code>. Should the file header be included in the count? Length of the header will be determined by 'get.skip'
and the 'pattern' argument. Defaults to 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer value.
</p>

<hr>
<h2 id='get.sep'>Determine field delimiter in text files</h2><span id='topic+get.sep'></span>

<h3>Description</h3>

<p>Determine field delimiter in text files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.sep(file, n = 1, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.sep_+3A_file">file</code></td>
<td>
<p><code>character</code>. Path name of a text file.</p>
</td></tr>
<tr><td><code id="get.sep_+3A_n">n</code></td>
<td>
<p><code>integer</code>. Number of lines to be read by <code>readLines</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="get.sep_+3A_pattern">pattern</code></td>
<td>
<p><code>character</code>. Search pattern to find a specific line for determining the delimiter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If successful, the filed delimiter. If more than on of the possible delimiters is found, an error is returned.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+readLines">readLines</a></code>
</p>

<hr>
<h2 id='get.skip'>Determine Number of Rows to be Skipped in Text Files</h2><span id='topic+get.skip'></span>

<h3>Description</h3>

<p><code>get.skip</code> attempts to determine the number of rows that could be skipped when reading text files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.skip(file, n = 1, pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.skip_+3A_file">file</code></td>
<td>
<p>(<code>character</code>). The file name.</p>
</td></tr>
<tr><td><code id="get.skip_+3A_n">n</code></td>
<td>
<p>(<code>integer</code>). The number of lines to be read by <code>readLines()</code>.</p>
</td></tr>
<tr><td><code id="get.skip_+3A_pattern">pattern</code></td>
<td>
<p>(<code>character</code>). A search pattern like, e.g., a column  name that is used to find a particular
line in the file to determine the codeskip value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>skip</code> value. If no value is determined 0 (zero) is returned.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+readLines">readLines</a></code>
</p>

<hr>
<h2 id='read.to.list'>Read various input file formats into a list of data frames. Wrapper function for 'read2list' to automate
reading further and avoid errors due to missing folders or files.</h2><span id='topic+read.to.list'></span>

<h3>Description</h3>

<p><code>read.to.list</code> is meant to act as a universal reading function as it attempts to read
a number of different file formats into a list of data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.to.list(
  dat,
  type,
  folder,
  nsheets = 1,
  sheet = NULL,
  keep.tibble = FALSE,
  skip = 0,
  sep = NULL,
  lines = FALSE,
  dec = NULL,
  ...,
  verbose = TRUE,
  x.verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.to.list_+3A_dat">dat</code></td>
<td>
<p><code>character</code>. File path.</p>
</td></tr>
<tr><td><code id="read.to.list_+3A_type">type</code></td>
<td>
<p><code>character</code>. File extension to be read: one of &quot;.txt&quot;, &quot;.tsv&quot;, &quot;.csv&quot;, &quot;.vcf&quot;, &quot;.gtf&quot;,
&quot;.gff&quot;, &quot;.xls&quot;, &quot;.xlsx&quot;, &quot;.xdr&quot;, &quot;.RData&quot;, &quot;.rds&quot;, &quot;.rda&quot;, &quot;.xml&quot;. See details.</p>
</td></tr>
<tr><td><code id="read.to.list_+3A_folder">folder</code></td>
<td>
<p><code>character</code>. Folder where the file is found.</p>
</td></tr>
<tr><td><code id="read.to.list_+3A_nsheets">nsheets</code></td>
<td>
<p><code>integer</code>. Number of sheets to be read if file is of type &quot;.xls&quot; or &quot;.xlsx&quot;. All sheets starting from 1 up to the
given number in the respective data file will be read. If more than one file is read this must be be an integer vector with the
numbers of sheets in exactly the same order as the files.</p>
</td></tr>
<tr><td><code id="read.to.list_+3A_sheet">sheet</code></td>
<td>
<p><code>integer</code> or <code>list</code>. Sheet(s) to be read if file is of type &quot;.xls&quot; or &quot;.xlsx&quot;. The sheets defined by the given integer in the
respective data file will be read. If more than one file is read this must be be a list with the sheet number(s) in exactly
the same order as the files. If there are many files and only one sheet vector the same sheet(s) wi√∂l be read from
all files.</p>
</td></tr>
<tr><td><code id="read.to.list_+3A_keep.tibble">keep.tibble</code></td>
<td>
<p><code>logical</code>. Should the data from Excel files read with <code>readxl::read_excel</code> be coerce to 
<code>data.frames</code> or kept in the original <code>tibble</code> format? Defaults to FALSE, i.e., a <code>data.frame</code>
is returned.</p>
</td></tr>
<tr><td><code id="read.to.list_+3A_skip">skip</code></td>
<td>
<p><code>integer</code>. Number of lines to skip from the top of the file.</p>
</td></tr>
<tr><td><code id="read.to.list_+3A_sep">sep</code></td>
<td>
<p><code>character</code>. Field delimiter passed to 'read.delim' when reading text files.</p>
</td></tr>
<tr><td><code id="read.to.list_+3A_lines">lines</code></td>
<td>
<p><code>lines</code>. Should the file be read line by line into a character vector by readLines()?</p>
</td></tr>
<tr><td><code id="read.to.list_+3A_dec">dec</code></td>
<td>
<p><code>character</code>. The decimal separator for numbers.</p>
</td></tr>
<tr><td><code id="read.to.list_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to functions.</p>
</td></tr>
<tr><td><code id="read.to.list_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Should verbose output be printed?</p>
</td></tr>
<tr><td><code id="read.to.list_+3A_x.verbose">x.verbose</code></td>
<td>
<p><code>logical</code>. Should extended verbose output be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Excel files (file extension .xls or .xlsx) will be read by <code>readxl::read_excel</code>. A test is attempted
to determine whether the input file is genuinely derived from Excel or only named like an nExcel file. If the latter,
it will be attempted to read it as text file.
Text files are read as tables or by line if <code>lines</code> is <code>TRUE</code>.
For text files, field delimiters and decimal separators are determined automatically if not provided.
Files with the extensions .txt&quot;, &quot;.tsv&quot;, &quot;.csv&quot;, &quot;.gtf&quot; and &quot;.gff&quot; are treated and read as text files.
VCF files are also treated as text files but can noly be read in full (incl. header) if read by line. Otherwise,
if <code>skip</code> is <code>0</code>, the line with the column names will be determined automatically and the file read
as delimited text file.
XML files are read by <code>xml2::read_xml</code>.
&quot;.RData&quot; files are loaded and assigned a name.
&quot;.rds&quot; and &quot;.rda&quot; files are read by <code>readRDS</code>.
&quot;.xdr&quot; files are read by <code>R.utils::loadObject</code>.
</p>


<h3>Value</h3>

<p>A list of tibbles/data frames.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+readLines">readLines</a></code>
</p>
<p><code><a href="utils.html#topic+read.delim">read.delim</a></code>
</p>
<p><code><a href="readxl.html#topic+read_excel">read_excel</a></code>
</p>
<p><code><a href="base.html#topic+load">load</a></code>
</p>
<p><code><a href="R.utils.html#topic+loadObject">loadObject</a></code>
</p>
<p><code><a href="base.html#topic+readRDS">readRDS</a></code>
</p>
<p><code><a href="#topic+read2list">read2list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The function readxl::read_excel is used internally to read Excel files.
# The example used their example data.
readxl_datasets &lt;- readxl::readxl_example("datasets.xlsx")
# A randomly generated data frame was saved to a tab-separated text file
# and two different R object files.
tsv_datasets &lt;- dir(system.file("extdata", package = "readmoRe"), full.names = TRUE)
# All example data are read into a list. From the Excel file, the first
# sheet is read.
dat &lt;- read.to.list(c(readxl_datasets, tsv_datasets))
# All example data are read into a list. From the Excel file, the first
# 3 sheets are read.
dat &lt;- read.to.list(c(readxl_datasets, tsv_datasets), nsheets=3)
# All example data are read into a list. From the Excel file, sheets 1 and
# 4 are read.
dat &lt;- read.to.list(c(readxl_datasets, tsv_datasets), sheet=c(1, 4))
# From two Excel files, different sheets are read: 1 and 4 from the first
# file and 2 and 3 from the second.
# (For simplicity, the same example file is used.)
dat &lt;- read.to.list(c(readxl_datasets, readxl_datasets), sheet=list(c(1, 4), c(2, 3)))
</code></pre>

<hr>
<h2 id='read2list'>Read various input file formats into a list of data frames</h2><span id='topic+read2list'></span>

<h3>Description</h3>

<p><code>read2list</code> is meant to act as a universal reading function as it attempts to read
a number of different file formats into a list of data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read2list(
  dat,
  nsheets = 1,
  sheet = NULL,
  keep.tibble = FALSE,
  skip = 0,
  sep = NULL,
  lines = FALSE,
  dec = NULL,
  ...,
  verbose = TRUE,
  x.verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read2list_+3A_dat">dat</code></td>
<td>
<p><code>character</code>. File path.</p>
</td></tr>
<tr><td><code id="read2list_+3A_nsheets">nsheets</code></td>
<td>
<p><code>integer</code>. Number of sheets to be read if file is of type &quot;.xls&quot; or &quot;.xlsx&quot;. All sheets starting from 1 up to the
given number in the respective data file will be read. If more than one file is read this must be be an integer vector with the
numbers of sheets in exactly the same order as the files.</p>
</td></tr>
<tr><td><code id="read2list_+3A_sheet">sheet</code></td>
<td>
<p><code>integer</code> or <code>list</code>. Sheet(s) to be read if file is of type &quot;.xls&quot; or &quot;.xlsx&quot;. The sheets defined by the given integer in the
respective data file will be read. If more than one file is read this must be be a list with the sheet number(s) in exactly
the same order as the files. If there are many files and only one sheet vector the same sheet(s) wi√∂l be read from
all files.</p>
</td></tr>
<tr><td><code id="read2list_+3A_keep.tibble">keep.tibble</code></td>
<td>
<p><code>logical</code>. Should the data from Excel files read with <code>readxl::read_excel</code> be coerce to 
<code>data.frames</code> or kept in the original <code>tibble</code> format? Defaults to FALSE, i.e., a <code>data.frame</code>
is returned.</p>
</td></tr>
<tr><td><code id="read2list_+3A_skip">skip</code></td>
<td>
<p><code>integer</code>. Number of lines to skip from the top of the file.</p>
</td></tr>
<tr><td><code id="read2list_+3A_sep">sep</code></td>
<td>
<p><code>character</code>. Field delimiter passed to 'read.delim' when reading text files.</p>
</td></tr>
<tr><td><code id="read2list_+3A_lines">lines</code></td>
<td>
<p><code>lines</code>. Should the file be read line by line into a character vector by readLines()?</p>
</td></tr>
<tr><td><code id="read2list_+3A_dec">dec</code></td>
<td>
<p><code>character</code>. The decimal separator for numbers.</p>
</td></tr>
<tr><td><code id="read2list_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to functions.</p>
</td></tr>
<tr><td><code id="read2list_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Should verbose output be printed?</p>
</td></tr>
<tr><td><code id="read2list_+3A_x.verbose">x.verbose</code></td>
<td>
<p><code>logical</code>. Should extended verbose output be printed?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.delim">read.delim</a></code>
</p>
<p><code><a href="readxl.html#topic+read_excel">read_excel</a></code>
</p>
<p><code><a href="#topic+read.to.list">read.to.list</a></code>
</p>

<hr>
<h2 id='readmoRe'>Utilities for data import</h2><span id='topic+readmoRe'></span>

<h3>Description</h3>

<p>A collection of utilities for reading and importing data into R by performing (usually small) manipulations of
data structures such as data frames, matrices and list and automatically determining import parameters.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> readmoRe</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Initial version: </td><td style="text-align: left;"> 0.1-0</td>
</tr>
<tr>
 <td style="text-align: left;">
Created: </td><td style="text-align: left;"> 2011-01-07</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The main function of the package is <code>read.to.list</code> which reads a number of different file formats into a list of data objects
such as data frames, depending on the source file.
</p>


<h3>Author(s)</h3>

<p>Vidal Fey &lt;vidal.fey@gmail.com&gt;
</p>

<hr>
<h2 id='rm.empty.cols'>Remove Empty Columns From an Imported Excel Sheet</h2><span id='topic+rm.empty.cols'></span>

<h3>Description</h3>

<p><code>rm.empty.cols</code> removes columns that have only <code>NAs</code> <em>AND</em> whose names
start with a capital 'X' (unless <span class="option">na.only</span> is <code>TRUE</code> in which case all <code>NA</code> columns
will be removed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.empty.cols(x, na.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm.empty.cols_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>). A data frame resulting from an imported Excel sheet by means of <code>read.xls</code></p>
</td></tr>
<tr><td><code id="rm.empty.cols_+3A_na.only">na.only</code></td>
<td>
<p>(<code>logical</code>). Should all 'NA' columns be removed and not only those with a column name starting
with X as generated by Excel (see details section)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Empty columns in Excel sheets are imported to <code>NA</code> columns in the resulting data frame.
Columns that did not have a column name in the spread sheet will result in data frame column names
starting with 'X'. <code>rm.empty.cols</code> makes use of these two criteria to identify columns that
can safely be removed from the data frame.
</p>


<h3>Value</h3>

<p>A data frame.
</p>

<hr>
<h2 id='rm.newline.chars'>Remove 'newline' Characters From Imported Excel Sheets</h2><span id='topic+rm.newline.chars'></span>

<h3>Description</h3>

<p><code>rm.newline.chars</code> removes &lsquo;newline&rsquo; characters (<code>\n</code>) from any column of a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.newline.chars(x, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm.newline.chars_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>). A data frame resulting from an imported Excel sheet by means of <code>read.xls</code>.</p>
</td></tr>
<tr><td><code id="rm.newline.chars_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical</code>). Should verbose output be printed, defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;Newline&rsquo; characters in data frame rows are read verbatim and will cause rows in output
text files to be distributed across two ore more lines. Such characters, entered accidentally or
deliberately in the source Excel file, should be avoided. This function removes all &lsquo;newline&rsquo;
characters found at the end of a line or replaces them when found within the line text.
</p>


<h3>Value</h3>

<p>A data frame.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
