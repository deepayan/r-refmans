<!DOCTYPE html><html><head><title>Help for package lsbclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lsbclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lsbclust-package'><p>Least Squares Latent Class Matrix Factorization</p></a></li>
<li><a href='#akmeans'><p>K-Means Over One Way of An Three-Way Array</p></a></li>
<li><a href='#bicomp'><p>Bilinear Decomposition of a Matrix</p></a></li>
<li><a href='#carray'><p>Double-Centre a Three-way Array</p></a></li>
<li><a href='#cfsim'><p>Compare Simulation Results</p></a></li>
<li><a href='#cfsim.akmeans'><p>Compare LSBCLUST Simulation Results</p></a></li>
<li><a href='#cfsim.lsbclust'><p>Compare LSBCLUST Simulation Results</p></a></li>
<li><a href='#cfsim.T3Clusf'><p>Compare LSBCLUST Simulation Results</p></a></li>
<li><a href='#cl_class_ids.int.lsbclust'><p>S3 export</p></a></li>
<li><a href='#ClustMeans'><p>C++ Function for Cluster Means</p></a></li>
<li><a href='#cmat'><p>Centring Matrix</p></a></li>
<li><a href='#dcars'><p>Dutch Cars Data</p></a></li>
<li><a href='#fitted.akmeans'><p>Extract Fitted Values for akmeans</p></a></li>
<li><a href='#fitted.lsbclust'><p>Extract Fitted Values for LSBCLUST</p></a></li>
<li><a href='#fitted.T3Clusf'><p>Extract Fitted Values for T3Clusf</p></a></li>
<li><a href='#genproc'><p>Generalized Procrustes Rotation</p></a></li>
<li><a href='#indarr'><p>Create Array of Indicator Matrices</p></a></li>
<li><a href='#int.lsbclust'><p>Interaction Clustering in Least Squares Bilinear Clustering</p></a></li>
<li><a href='#KMeansW'><p>C++ Function for Weighted K-Means</p></a></li>
<li><a href='#LossMat'><p>C++ Function for Interaction Loss Function</p></a></li>
<li><a href='#lov'><p>List-of-values Data Set</p></a></li>
<li><a href='#lsbclust'><p>Least-squares Bilinear Clustering of Three-way Data</p></a></li>
<li><a href='#meanbiplot'><p>Biplots of</p></a></li>
<li><a href='#meanheatmap'><p>Plot Heatmap of A Matrix</p></a></li>
<li><a href='#orc.lsbclust'><p>K-means on the Overall Mean, Row Margins or Column Margins</p></a></li>
<li><a href='#plot.bicomp'><p>Plot a <code>bicomp</code> Object</p></a></li>
<li><a href='#plot.col.kmeans'><p>Plot method for class 'col.kmeans'</p></a></li>
<li><a href='#plot.int.lsbclust'><p>Plot Method for Class 'int.lsbclust'</p></a></li>
<li><a href='#plot.lsbclust'><p>Plot method for class 'lsbclust'</p></a></li>
<li><a href='#plot.ovl.kmeans'><p>Plot method for class 'ovl.kmeans'</p></a></li>
<li><a href='#plot.row.kmeans'><p>Plot method for class 'row.kmeans'</p></a></li>
<li><a href='#plot.step.lsbclust'><p>Plot method for class 'step.lsbclust'</p></a></li>
<li><a href='#plot.T3Clusf'><p>Plot Method for Class 'T3Clusf'</p></a></li>
<li><a href='#print.lsbclust'><p>Print method for object of class 'lsbclust'</p></a></li>
<li><a href='#rlsbclust'><p>Simulate from LSBCLUST Model</p></a></li>
<li><a href='#rorth'><p>Generate A Random Orthonormal Matrix</p></a></li>
<li><a href='#sim_lsbclust'><p>Simulate and Analyze LSBCLUST</p></a></li>
<li><a href='#simsv'><p>Randomly Generate Positive Singular Values</p></a></li>
<li><a href='#step.lsbclust'><p>Model Search for lsbclust</p></a></li>
<li><a href='#summary.int.lsbclust'><p>Summary Method for Class &quot;int.lsbclust&quot;</p></a></li>
<li><a href='#summary.lsbclust'><p>Summary Method for Class &quot;lsbclust&quot;</p></a></li>
<li><a href='#supermarkets'><p>Dutch Supermarkets Data Set</p></a></li>
<li><a href='#T3Clusf'><p>T3Clusf: Tucker3 Fuzzy Cluster Analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Least-Squares Bilinear Clustering for Three-Way Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-04-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Pieter Schoonees [aut, cre],
  Patrick Groenen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pieter Schoonees &lt;schoonees@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for performing least-squares bilinear clustering of
    three-way data. The method uses the bilinear decomposition (or bi-additive
    model) to model two-way matrix slices while clustering over the third way.
    Up to four different types of clusters are included, one for each term of the
    bilinear decomposition. In this way, matrices are clustered simultaneously on
    (a subset of) their overall means, row margins, column margins and row-column
    interactions. The orthogonality of the bilinear model results in separability of
    the joint clustering problem into four separate ones. Three of these sub-problems
    are specific k-means problems, while a special algorithm is implemented for the
    interactions. Plotting methods are provided, including biplots for the low-rank
    approximations of the interactions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), stats, ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr, clue, grid, gridExtra, reshape2, Rcpp, mvtnorm,
graphics, methods, doParallel, foreach, parallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>best</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-15 08:43:58 UTC; pieter</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-15 09:32:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='lsbclust-package'>Least Squares Latent Class Matrix Factorization</h2><span id='topic+lsbclust-package'></span>

<h3>Description</h3>

<p>Funtions for least squares latent class matrix factorizations.
</p>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees [aut, cre], Patrick J.F. Groenen [aut]
</p>


<h3>References</h3>

<p>Van Rosmalen, J., Van Herk, H., &amp; Groenen, P. J. F. (2010). Identifying response styles: A latent-class bilinear multinomial logit model. <em>Journal of Marketing Research</em>, 47(1), 157-172.
</p>

<hr>
<h2 id='akmeans'>K-Means Over One Way of An Three-Way Array</h2><span id='topic+akmeans'></span>

<h3>Description</h3>

<p>Vectorize matrix slices over a specific way of an three-way array, and
conduct <code><a href="stats.html#topic+kmeans">kmeans</a></code> on it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>akmeans(data, centers, margin = 3L, ndim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="akmeans_+3A_data">data</code></td>
<td>
<p>Three-way data array</p>
</td></tr>
<tr><td><code id="akmeans_+3A_centers">centers</code></td>
<td>
<p>Passed to <code><a href="stats.html#topic+kmeans">kmeans</a></code></p>
</td></tr>
<tr><td><code id="akmeans_+3A_margin">margin</code></td>
<td>
<p>Integer indicating which way to cluster over</p>
</td></tr>
<tr><td><code id="akmeans_+3A_ndim">ndim</code></td>
<td>
<p>The rank of the low dimensional approximation of the matrix
slices to construct before clustering (using <code><a href="base.html#topic+svd">svd</a></code>)</p>
</td></tr>
<tr><td><code id="akmeans_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="stats.html#topic+kmeans">kmeans</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
res &lt;- akmeans(data = carray(dcars), margin = 3L, centers = 5, nstart = 10)
</code></pre>

<hr>
<h2 id='bicomp'>Bilinear Decomposition of a Matrix</h2><span id='topic+bicomp'></span>

<h3>Description</h3>

<p>Decomposes a matrix into an overall mean matrix, row margins matrix, column margins matrix
and an interaction matrix, depending on <code>delta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicomp(x, delta = c(1, 1, 1, 1), which = 0L:4L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bicomp_+3A_x">x</code></td>
<td>
<p>A matrix to be decomposed.</p>
</td></tr>
<tr><td><code id="bicomp_+3A_delta">delta</code></td>
<td>
<p>A vector of length four with 0/1 entries which controls the type of
decomposition made.</p>
</td></tr>
<tr><td><code id="bicomp_+3A_which">which</code></td>
<td>
<p>A vector giving the elements to return, with 0 = original data, 1 = overall means, 
2 = row means, 3 = column means and 4 = interactions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bicomp</code>, possible also inheriting from class <code>data.frame</code>, 
which is either a named list with the required components, or a single matrix if a single 
component is requested. An additional attribute <code>return_type</code> gives information on the type 
of matrices returned.
</p>

<hr>
<h2 id='carray'>Double-Centre a Three-way Array</h2><span id='topic+carray'></span>

<h3>Description</h3>

<p>Double-centre the matrix slices of a three-way array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carray(array, margin = 3L, rows = TRUE, columns = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carray_+3A_array">array</code></td>
<td>
<p>A three-way array</p>
</td></tr>
<tr><td><code id="carray_+3A_margin">margin</code></td>
<td>
<p>The way of the array over which the centring must be done</p>
</td></tr>
<tr><td><code id="carray_+3A_rows">rows</code></td>
<td>
<p>Logical indicating whether to centre the rows of the matrix slices</p>
</td></tr>
<tr><td><code id="carray_+3A_columns">columns</code></td>
<td>
<p>Logical indicating whether to centre the columns of the matrix slices</p>
</td></tr>
</table>

<hr>
<h2 id='cfsim'>Compare Simulation Results</h2><span id='topic+cfsim'></span>

<h3>Description</h3>

<p>Generic function to compare simulation results in <span class="pkg">lsbclust</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfsim(fitted, actual, method = c("diag", "cRand"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfsim_+3A_fitted">fitted</code></td>
<td>
<p>An object of class <code>lsbclust</code> containing the fitted results.</p>
</td></tr>
<tr><td><code id="cfsim_+3A_actual">actual</code></td>
<td>
<p>An object of class <code>lsbclust_sim</code> containing the simulated data.</p>
</td></tr>
<tr><td><code id="cfsim_+3A_method">method</code></td>
<td>
<p>The type of statistics to calculate, passed to <code><a href="clue.html#topic+cl_agreement">cl_agreement</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cfsim.lsbclust">cfsim.lsbclust</a></code>, <code><a href="#topic+cfsim.T3Clusf">cfsim.T3Clusf</a></code>
</p>

<hr>
<h2 id='cfsim.akmeans'>Compare LSBCLUST Simulation Results</h2><span id='topic+cfsim.akmeans'></span>

<h3>Description</h3>

<p>This function compares cluster membership and parameter estimates for the results of
<code><a href="#topic+akmeans">akmeans</a></code> on simulated data, constructed using <code><a href="#topic+rlsbclust">rlsbclust</a></code>, 
to the true underlying values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'akmeans'
cfsim(fitted, actual, method = c("diag", "cRand"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfsim.akmeans_+3A_fitted">fitted</code></td>
<td>
<p>An object of class <code>akmeans</code> containing the fitted results.</p>
</td></tr>
<tr><td><code id="cfsim.akmeans_+3A_actual">actual</code></td>
<td>
<p>An object of class <code>lsbclust_sim</code> containing the simulated data.</p>
</td></tr>
<tr><td><code id="cfsim.akmeans_+3A_method">method</code></td>
<td>
<p>The method for calculating cluster agreement across random starts, passed on
to <code><a href="clue.html#topic+cl_agreement">cl_agreement</a></code>. None is calculated when set to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate LSBCLUST data, fit akmeans on double-centered data, and compare
set.seed(1)
dat &lt;- rlsbclust(ndata = 1, nobs = 100, size = c(10, 8), nclust = c(5, 4, 6, 5))
dat[[1]]$data &lt;- carray(dat[[1]]$data)
res &lt;- akmeans(data = dat[[1]]$data, centers = 5, margin = 3, ndim = 2)
cfsim(res, dat[[1]])
</code></pre>

<hr>
<h2 id='cfsim.lsbclust'>Compare LSBCLUST Simulation Results</h2><span id='topic+cfsim.lsbclust'></span>

<h3>Description</h3>

<p>This function compares cluster membership and parameter estimates for the results of
<code><a href="#topic+lsbclust">lsbclust</a></code> on simulated data to the true underlying values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lsbclust'
cfsim(fitted, actual, method = c("diag", "cRand"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfsim.lsbclust_+3A_fitted">fitted</code></td>
<td>
<p>An object of class <code>lsbclust</code> containing the fitted results.</p>
</td></tr>
<tr><td><code id="cfsim.lsbclust_+3A_actual">actual</code></td>
<td>
<p>An object of class <code>lsbclust_sim</code> containing the simulated data.</p>
</td></tr>
<tr><td><code id="cfsim.lsbclust_+3A_method">method</code></td>
<td>
<p>The type of statistics to calculate, passed to <code><a href="clue.html#topic+cl_agreement">cl_agreement</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate LSBCLUST data, fit LSBCLUST, and compare
set.seed(1)
dat &lt;- rlsbclust(ndata = 1, nobs = 100, size = c(10, 8), nclust = c(5, 4, 6, 5))
res &lt;- lsbclust(data = dat[[1]]$data, nclust = c(5, 4, 6, 5))
cfsim(res, dat[[1]])
</code></pre>

<hr>
<h2 id='cfsim.T3Clusf'>Compare LSBCLUST Simulation Results</h2><span id='topic+cfsim.T3Clusf'></span>

<h3>Description</h3>

<p>This function compares cluster membership and parameter estimates for the results of
<code><a href="#topic+T3Clusf">T3Clusf</a></code> on simulated data, using <code><a href="#topic+rlsbclust">rlsbclust</a></code>, 
to the true underlying values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'T3Clusf'
cfsim(fitted, actual, method = c("diag", "cRand"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfsim.T3Clusf_+3A_fitted">fitted</code></td>
<td>
<p>An object of class <code>lsbclust</code> containing the fitted results.</p>
</td></tr>
<tr><td><code id="cfsim.T3Clusf_+3A_actual">actual</code></td>
<td>
<p>An object of class <code>lsbclust_sim</code> containing the simulated data.</p>
</td></tr>
<tr><td><code id="cfsim.T3Clusf_+3A_method">method</code></td>
<td>
<p>The method for calculating cluster agreement across random starts, passed on
to <code><a href="clue.html#topic+cl_agreement">cl_agreement</a></code>. None is calculated when set to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate LSBCLUST data, fit T3Clusf on double-centered data, and compare
set.seed(1)
dat &lt;- rlsbclust(ndata = 1, nobs = 100, size = c(10, 8), nclust = c(5, 4, 6, 5))
dat[[1]]$data &lt;- carray(dat[[1]]$data)
res &lt;- T3Clusf(X = dat[[1]]$data, Q = 2, G = 5)
cfsim(res, dat[[1]])
</code></pre>

<hr>
<h2 id='cl_class_ids.int.lsbclust'>S3 export</h2><span id='topic+cl_class_ids.int.lsbclust'></span><span id='topic+is.cl_partition.int.lsbclust'></span><span id='topic+is.cl_hard_partition.int.lsbclust'></span><span id='topic+cl_class_ids.lsbclust_sim_part'></span><span id='topic+is.cl_partition.lsbclust_sim_part'></span><span id='topic+is.cl_hard_partition.lsbclust_sim_part'></span><span id='topic+cl_class_ids.T3Clusf'></span><span id='topic+is.cl_partition.T3Clusf'></span><span id='topic+is.cl_hard_partition.T3Clusf'></span><span id='topic+cl_class_ids.akmeans'></span><span id='topic+is.cl_partition.akmeans'></span><span id='topic+is.cl_hard_partition.akmeans'></span>

<h3>Description</h3>

<p>These export
into the framework set out in package <span class="pkg">clue</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'int.lsbclust'
cl_class_ids(x)

## S3 method for class 'int.lsbclust'
is.cl_partition(x)

## S3 method for class 'int.lsbclust'
is.cl_hard_partition(x)

## S3 method for class 'lsbclust_sim_part'
cl_class_ids(x)

## S3 method for class 'lsbclust_sim_part'
is.cl_partition(x)

## S3 method for class 'lsbclust_sim_part'
is.cl_hard_partition(x)

## S3 method for class 'T3Clusf'
cl_class_ids(x)

## S3 method for class 'T3Clusf'
is.cl_partition(x)

## S3 method for class 'T3Clusf'
is.cl_hard_partition(x)

## S3 method for class 'akmeans'
cl_class_ids(x)

## S3 method for class 'akmeans'
is.cl_partition(x)

## S3 method for class 'akmeans'
is.cl_hard_partition(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_class_ids.int.lsbclust_+3A_x">x</code></td>
<td>
<p>An object of class <code>int.lsclust</code></p>
</td></tr>
</table>

<hr>
<h2 id='ClustMeans'>C++ Function for Cluster Means</h2><span id='topic+ClustMeans'></span>

<h3>Description</h3>

<p>This function calculates the cluster means in vectorized form based on the current
value of the clustering vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClustMeans(nclust, start, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClustMeans_+3A_nclust">nclust</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="ClustMeans_+3A_start">start</code></td>
<td>
<p>The current clustering vector.</p>
</td></tr>
<tr><td><code id="ClustMeans_+3A_data">data</code></td>
<td>
<p>The concatenated data, with J * K rows and N columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with <code>nclust</code> rows and <code>J*K</code> columns.
</p>

<hr>
<h2 id='cmat'>Centring Matrix</h2><span id='topic+cmat'></span>

<h3>Description</h3>

<p>A utility function for calculating centring matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmat(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmat_+3A_k">k</code></td>
<td>
<p>An integer determining the dimensions of the centring matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='dcars'>Dutch Cars Data</h2><span id='topic+dcars'></span>

<h3>Description</h3>

<p>This data set relates to 187 Dutch households rating 10 automobile manufacturers according 
to 8 variables (original Dutch terms in parentheses): price (prijsniveau), design (vormgeving), safety (veiligheid), operating cost (gebruikskosten), )
sportiness (sportiviteit), size (modelgrootte), reliability (betrouwbaarheid) and feautures (uitrusting). 
A rating scale from 1 to 10 was used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcars
</code></pre>


<h3>Format</h3>

<p>A three-way array with cars in the first dimension, variables in the second and 
consumers in the third dimension.
</p>

<p>The items and labels for the endpoints of the scales are (original Dutch labels in parentheses):
</p>
<dl>
<dt>Affordability</dt><dd><p>A rating from 1 = Expensive (duur) to 10 = Cheap (goedkoop)</p>
</dd>
<dt>Attractiveness</dt><dd><p>A rating from 1 = Ugly (lelijk) to 10 = Beautiful (mooi)</p>
</dd>
<dt>Safety</dt><dd><p>A rating from 1 = Bad (slecht) to 10 = Good (goed)</p>
</dd>
<dt>OperatingCost</dt><dd><p>A rating from 1 = Low (laag) to 10 = High (hoog)</p>
</dd>
<dt>Sportiness</dt><dd><p>A rating from 1 = Slow (langzaam) to 10 = Fast (snel)</p>
</dd>
<dt>Size</dt><dd><p>A rating from 1 = Large (groot) to 10 = Small (klein)</p>
</dd>
<dt>Reliability</dt><dd><p>A rating from 1 = Bad (slecht) to 10 = Good (goed)</p>
</dd>
<dt>Features</dt><dd><p>A rating from 1 = Simple (eenvoudig) to 10 = Luxurious (luxe)</p>
</dd>
</dl>


<h3>Details</h3>

<p>The original sample consisted of 188 households. However, one of these households (code 87845) was discarded 
because it appears that they used a rating scale from 0 to 10 instead of from 1 to 10. Note that all rating scales has
been reversed so that higher scores are better for most items. The exceptions are OperatingCost and Size, where larger
values mean higher costs and smaller cars respectively.
</p>


<h3>Source</h3>

<p>Tammo Bijmolt, Michel van de Velden
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dcars")
set.seed(5448)
m &lt;- lsbclust(data = dcars, delta = c(1, 1, 1, 1), nclust = c(5, 3, 6, 8), nstart = 5, 
              nstart.kmeans = 10, parallel = FALSE, fixed = "columns")
</code></pre>

<hr>
<h2 id='fitted.akmeans'>Extract Fitted Values for akmeans</h2><span id='topic+fitted.akmeans'></span>

<h3>Description</h3>

<p>An S3 method for <code><a href="stats.html#topic+fitted">fitted</a></code> for class <code>"akmeans"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'akmeans'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.akmeans_+3A_object">object</code></td>
<td>
<p>An object of class <code>"akmeans"</code></p>
</td></tr>
<tr><td><code id="fitted.akmeans_+3A_...">...</code></td>
<td>
<p>Unimplemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array approximating the original data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+akmeans">akmeans</a></code>
</p>

<hr>
<h2 id='fitted.lsbclust'>Extract Fitted Values for LSBCLUST</h2><span id='topic+fitted.lsbclust'></span>

<h3>Description</h3>

<p>An S3 method for <code><a href="stats.html#topic+fitted">fitted</a></code> for class <code>"lsbclust"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lsbclust'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lsbclust_+3A_object">object</code></td>
<td>
<p>An object of class <code>"lsbclust"</code></p>
</td></tr>
<tr><td><code id="fitted.lsbclust_+3A_...">...</code></td>
<td>
<p>Unimplemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array approximating the original data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsbclust">lsbclust</a></code>
</p>

<hr>
<h2 id='fitted.T3Clusf'>Extract Fitted Values for T3Clusf</h2><span id='topic+fitted.T3Clusf'></span>

<h3>Description</h3>

<p>An S3 method for <code><a href="stats.html#topic+fitted">fitted</a></code> for class <code>"T3Clusf"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'T3Clusf'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.T3Clusf_+3A_object">object</code></td>
<td>
<p>An object of class <code>"T3Clusf"</code></p>
</td></tr>
<tr><td><code id="fitted.T3Clusf_+3A_...">...</code></td>
<td>
<p>Unimplemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array approximating the original data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+T3Clusf">T3Clusf</a></code>
</p>

<hr>
<h2 id='genproc'>Generalized Procrustes Rotation</h2><span id='topic+genproc'></span>

<h3>Description</h3>

<p>This function finds K orthogonal rotation matrices so that the rotated versions of the input 
configurations match each other optimally in the least-squares sense. The algorithm depends on the
starting values for the rotation matrices. At present identity matrices are used as starting values.
Only rotations / reflections are considered &ndash; no scaling or translation factors are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genproc(configs, maxit = 50L, reltol = 1e-06, random = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genproc_+3A_configs">configs</code></td>
<td>
<p>A list of original configuration matrices</p>
</td></tr>
<tr><td><code id="genproc_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations allowed</p>
</td></tr>
<tr><td><code id="genproc_+3A_reltol">reltol</code></td>
<td>
<p>The relative error tolerance for determining numeric convergence.</p>
</td></tr>
<tr><td><code id="genproc_+3A_random">random</code></td>
<td>
<p>Logical indicating whether or not to use random starts (only applicable when the
dimensionality is two).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gower, J. C., &amp; Dijksterhuis, G. B. (2004). Procrustes problems (Vol. 3). Oxford: Oxford University Press.
</p>

<hr>
<h2 id='indarr'>Create Array of Indicator Matrices</h2><span id='topic+indarr'></span>

<h3>Description</h3>

<p>This function takes a <code>matrix</code> or <code>data.frame</code> and the number of rating categories <code>maxcat</code>
and produces a three-way array of <code>m</code> by <code>maxcat</code> indicator matrices, one for each of the <code>n</code> rows.
The input <code>x</code> must be a <code>matrix</code> or <code>data.frame</code> of dimensions <code>n</code> by <code>m</code> 
which contains the ratings on a scale of 1 to <code>maxcat</code> for <code>m</code> items. Note that missing values
(<code>NA</code>'s) will not appear in the columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indarr(x, maxcat, na.add = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indarr_+3A_x">x</code></td>
<td>
<p>a <code>matrix</code> of <code>data.frame</code></p>
</td></tr>
<tr><td><code id="indarr_+3A_maxcat">maxcat</code></td>
<td>
<p>an integer indicating the maximum of the rating scale (which is assumed to start with 1)</p>
</td></tr>
<tr><td><code id="indarr_+3A_na.add">na.add</code></td>
<td>
<p>logical indicating whether to add a designated category for missings or not. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of rating by item indicator matrices.
</p>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lov")
arr &lt;- indarr(lov[1:10, 1:9], maxcat = 9)
str(arr)
</code></pre>

<hr>
<h2 id='int.lsbclust'>Interaction Clustering in Least Squares Bilinear Clustering</h2><span id='topic+int.lsbclust'></span>

<h3>Description</h3>

<p>This function implements the interaction clustering part of the Least Squares Bilinear Clustering
method of Schoonees, Groenen and Van de Velden (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int.lsbclust(data, margin = 3L, delta, nclust, ndim = 2,
  fixed = c("none", "rows", "columns"), nstart = 50, starts = NULL,
  alpha = 0.5, parallel = FALSE, mc.cores = detectCores() - 1,
  maxit = 100, verbose = 1, method = "diag", minsize = 3L,
  return_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int.lsbclust_+3A_data">data</code></td>
<td>
<p>A three-way array representing the data.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_margin">margin</code></td>
<td>
<p>An integer giving the single subscript of <code>data</code> over which the clustering 
will be applied.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_delta">delta</code></td>
<td>
<p>A four-element binary vector (logical or numeric) indicating which sum-to-zero 
constraints must be enforced.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_nclust">nclust</code></td>
<td>
<p>An integer giving the desired number of clusters. If it is a vector, the algorithm
will be run for each element.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_ndim">ndim</code></td>
<td>
<p>The required rank for the approximation of the interactions (a scalar).</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_fixed">fixed</code></td>
<td>
<p>One of <code>"none"</code>, <code>"rows"</code> or <code>"columns"</code> indicating whether to fix neither
sets of coordinates, or whether to fix the row or column coordinates across clusters respectively.
If a vector is supplied, only the first element will be used.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_nstart">nstart</code></td>
<td>
<p>The number of random starts to use.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_starts">starts</code></td>
<td>
<p>A list containing starting configurations for the cluster membership vector. If not
supplied, random initializations will be generated.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value in [0, 1] which determines how the singular values are distributed
between rows and columns.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_parallel">parallel</code></td>
<td>
<p>Logical indicating whether to parallelize over different starts or not.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use in case <code>parallel = TRUE</code>, passed to
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_verbose">verbose</code></td>
<td>
<p>Integer controlling the amount of information printed: 0 = no information, 
1 = Information on random starts and progress, and 2 = information is printed after
each iteration for the interaction clustering.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_method">method</code></td>
<td>
<p>The method for calculating cluster agreement across random starts, passed on
to <code><a href="clue.html#topic+cl_agreement">cl_agreement</a></code>. None is calculated when set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_minsize">minsize</code></td>
<td>
<p>Integer giving the minimum size of cluster to uphold when reinitializing
empty clusters.</p>
</td></tr>
<tr><td><code id="int.lsbclust_+3A_return_data">return_data</code></td>
<td>
<p>Logical indicating whether to include the data in the return
value or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>int.lsb</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("supermarkets")
out &lt;- int.lsbclust(data = supermarkets, margin = 3, delta = c(1,1,0,0), nclust = 4, ndim = 2, 
           fixed = "rows", nstart = 1, alpha = 0)
</code></pre>

<hr>
<h2 id='KMeansW'>C++ Function for Weighted K-Means</h2><span id='topic+KMeansW'></span><span id='topic+ComputeMeans'></span><span id='topic+AssignCluster'></span>

<h3>Description</h3>

<p>This function does a weighted K-means clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeMeans(cm, data, weight, nclust)

AssignCluster(data, weight, M, nclust)

KMeansW(nclust, start, data, weight, eps = 1e-08, IterMax = 100L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KMeansW_+3A_cm">cm</code></td>
<td>
<p>Numeric vector of class indicators.</p>
</td></tr>
<tr><td><code id="KMeansW_+3A_data">data</code></td>
<td>
<p>The concatenated data, with N rows and M columns. Currently, the columns are clustered.</p>
</td></tr>
<tr><td><code id="KMeansW_+3A_weight">weight</code></td>
<td>
<p>The vector of length <code>nrows(data)</code> with weights with nonnegative elements.</p>
</td></tr>
<tr><td><code id="KMeansW_+3A_nclust">nclust</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="KMeansW_+3A_m">M</code></td>
<td>
<p>Matrix of cluster means.</p>
</td></tr>
<tr><td><code id="KMeansW_+3A_start">start</code></td>
<td>
<p>The current cluster membership vector.</p>
</td></tr>
<tr><td><code id="KMeansW_+3A_eps">eps</code></td>
<td>
<p>Numerical absolute convergence criteria for the K-means.</p>
</td></tr>
<tr><td><code id="KMeansW_+3A_itermax">IterMax</code></td>
<td>
<p>Integer giving the maximum number of iterations allowed for the K-means.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the folowing values.
</p>
<table>
<tr><td><code>centers</code></td>
<td>
<p>the <code>nclust</code> by M matrix <code>centers</code> of cluster means.</p>
</td></tr> 
<tr><td><code>cluster</code></td>
<td>
<p>vector of length N with cluster memberships.</p>
</td></tr> 
<tr><td><code>loss</code></td>
<td>
<p>vector of length <code>IterMax</code> with the first entries containing the loss.</p>
</td></tr> 
<tr><td><code>iterations</code></td>
<td>
<p>the number of iterations used (corresponding to the number 
of nonzero entries in <code>loss</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
clustmem &lt;- sample.int(n = 10, size = 100, replace = TRUE)
mat &lt;- rbind(matrix(rnorm(30*4, mean = 3), nrow = 30), 
             matrix(rnorm(30*4, mean = -2), nrow = 30), 
             matrix(rnorm(40*4, mean = 0), nrow = 40))
wt &lt;- runif(100)
testMeans &lt;- lsbclust:::ComputeMeans(cm = clustmem, data = mat, weight = wt, nclust = 3)
testK &lt;- lsbclust:::KMeansW(start = clustmem, data = mat, weight = wt, nclust = 3)
</code></pre>

<hr>
<h2 id='LossMat'>C++ Function for Interaction Loss Function</h2><span id='topic+LossMat'></span>

<h3>Description</h3>

<p>This function calculates the loss function for the interaction clustering
for all data slices and clusters means. The inputs are numeric matrices.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="LossMat_+3A_x">x</code></td>
<td>
<p>The data matrix, with the N slices strung out as vectors in the columns.</p>
</td></tr>
<tr><td><code id="LossMat_+3A_y">y</code></td>
<td>
<p>The matrix of cluster means, with each mean represented by a row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with <code>nclust</code> rows and <code>N</code> columns.
</p>

<hr>
<h2 id='lov'>List-of-values Data Set</h2><span id='topic+lov'></span>

<h3>Description</h3>

<p>This is the list-of-values data set used in Van Rosmalen, Van Herk &amp; Groenen (2010). 
Column names and factor labels differ slightly from that paper. Missing values are encoded as 
<code>NA</code> as usual. The first nine columns are items answered on a nine-point rating scale, with
rating 1 representing 'very important' and category 9 'not important at all'. The respondents
were asked how important each of these items are as a guiding principle in their lives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("lov")
</code></pre>


<h3>Format</h3>

<p>A data frame with 4514 observations on the following 12 variables.
</p>
 
<dl>
<dt>Belonging</dt><dd><p>a numeric vector; 'a sense of belonging'</p>
</dd>
<dt>Excitement</dt><dd><p>a numeric vector</p>
</dd> 
<dt>Relationships</dt><dd><p>a numeric vector; 'warm relationships with others'</p>
</dd> 
<dt>Self-fulfilment</dt><dd><p>a numeric vector</p>
</dd>
<dt>Respected</dt><dd><p>a numeric vector; 'being well-respected'</p>
</dd> 
<dt>Enjoyment</dt><dd><p>a numeric vector; 'fun and enjoyment'</p>
</dd> 
<dt>Security</dt><dd><p>a numeric vector</p>
</dd>
<dt>Self-respect</dt><dd><p>a numeric vector</p>
</dd>
<dt>Accomplishment</dt><dd><p>a numeric vector; 'a sense of accomplishment'</p>
</dd> 
<dt>Country</dt><dd><p>a factor with levels <code>Britain</code>, <code>France</code>, <code>Germany</code>, 
<code>Italy</code> and <code>Spain</code></p>
</dd> 
<dt>Education</dt><dd><p>a factor with levels <code>Low</code> and <code>High</code></p>
</dd> 
<dt>Age</dt><dd><p>a factor with levels <code>-25</code>, <code>25-39</code>, <code>40-54</code> and <code>55+</code></p>
</dd></dl>


<h3>Source</h3>

<p>Joost van Rosmalen
</p>


<h3>References</h3>

<p>Van Rosmalen, J., Van Herk, H., &amp; Groenen, P. J. (2010). Identifying 
response styles: A latent-class bilinear multinomial logit model. 
<em>Journal of Marketing Research</em>, 47(1), 157-172.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lov")

## Construct array
lovarr &lt;- indarr(lov[, 1:9], maxcat = 9)

## Run analysis
set.seed(13841)
fit &lt;- lsbclust(data = lovarr, margin = 3, delta = c(0, 1, 0, 0), nclust = c(NA, 11, NA, 5), 
                 fixed = "rows", nstart = 1, iter.max = 50, nstart.kmeans = 10)
</code></pre>

<hr>
<h2 id='lsbclust'>Least-squares Bilinear Clustering of Three-way Data</h2><span id='topic+lsbclust'></span>

<h3>Description</h3>

<p>This function clusters along one way of a three-way array (as specified by <code>margin</code>) while
decomposing along the other two dimensions. Four types of clusterings are allowed based on the
respective two-way slices of the array: on the overall means, row margins, column margins and the 
interactions between rows and columns. Which clusterings can be fit is determined by the vector
<code>delta</code>, with four binary elements. All orthogonal models are fitted. 
The nonorthogonal case <code>delta = (1, 1, 0, 0)</code> returns an error. See the reference for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsbclust(data, margin = 3L, delta = c(1L, 1L, 1L, 1L), nclust,
  ndim = 2L, fixed = c("none", "rows", "columns"), nstart = 20L,
  starts = NULL, nstart.kmeans = 500L, alpha = 0.5,
  parallel = FALSE, maxit = 100L, verbose = 1, method = "diag",
  type = NULL, sep.nclust = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsbclust_+3A_data">data</code></td>
<td>
<p>A three-way array representing the data.</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_margin">margin</code></td>
<td>
<p>An integer giving the single subscript of <code>data</code> over which the clustering 
will be applied.</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_delta">delta</code></td>
<td>
<p>A four-element binary vector (logical or numeric) indicating which sum-to-zero 
constraints must be enforced.</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_nclust">nclust</code></td>
<td>
<p>A vector of length four giving the number of clusters for the overall mean, the row
margins, the column margins and the interactions (in that order) respectively. Alternatively, a
vector of length one, in which case all components will have the same number of clusters.</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_ndim">ndim</code></td>
<td>
<p>The required rank for the approximation of the interactions (a scalar).</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_fixed">fixed</code></td>
<td>
<p>One of <code>"none"</code>, <code>"rows"</code> or <code>"columns"</code> indicating whether to fix neither
sets of coordinates, or whether to fix the row or column coordinates across clusters respectively.
If a vector is supplied, only the first element will be used (passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_nstart">nstart</code></td>
<td>
<p>The number of random starts to use for the interaction clustering.</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_starts">starts</code></td>
<td>
<p>A list containing starting configurations for the cluster membership vector. If not
supplied, random initializations will be generated (passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_nstart.kmeans">nstart.kmeans</code></td>
<td>
<p>The number of random starts to use in <code><a href="stats.html#topic+kmeans">kmeans</a></code>.</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value in [0, 1] which determines how the singular values are distributed
between rows and columns (passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_parallel">parallel</code></td>
<td>
<p>Logical indicating whether to parallel over different starts or not 
(passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations allowed in the interaction clustering.</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_verbose">verbose</code></td>
<td>
<p>Integer controlling the amount of information printed: 0 = no information, 
1 = Information on random starts and progress, and 2 = information is printed after
each iteration for the interaction clustering.</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_method">method</code></td>
<td>
<p>The method for calculating cluster agreement across random starts, passed on
to <code><a href="clue.html#topic+cl_agreement">cl_agreement</a></code> (passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_type">type</code></td>
<td>
<p>One of <code>"rows"</code>, <code>"columns"</code> or <code>"overall"</code> (or a unique abbreviation of 
one of these) indicating whether clustering should be done on row margins, column margins or
the overall means of the two-way slices respectively. If more than one opion are supplied, the
algorithm is run for all (unique) options supplied (passed to <code><a href="#topic+orc.lsbclust">orc.lsbclust</a></code>). This
is an optional argument.</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_sep.nclust">sep.nclust</code></td>
<td>
<p>Logical indicating how nclust should be used across different <code>type</code>'s.
If <code>sep.nclust</code> is <code>TRUE</code>, <code>nclust</code> is recycled so that each <code>type</code> can
have a different number of clusters. If <code>sep.nclust</code> is <code>FALSE</code>, the same vector
<code>nclust</code> is used for all <code>type</code>'s.</p>
</td></tr>
<tr><td><code id="lsbclust_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="stats.html#topic+kmeans">kmeans</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of S3 class <code>lsbclust</code> which has slots:
</p>
<table>
<tr><td><code>overall</code></td>
<td>
<p>Object of class <code>ovl.kmeans</code> for the overall means clustering</p>
</td></tr>
<tr><td><code>rows</code></td>
<td>
<p>Object of class <code>row.kmeans</code> for the row means clustering</p>
</td></tr>
<tr><td><code>columns</code></td>
<td>
<p>Object of class <code>col.kmeans</code> for the column means clustering</p>
</td></tr>
<tr><td><code>interactions</code></td>
<td>
<p>Object of class <code>int.lsbclust</code> for the interaction clustering</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call used to create the object</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>The value of <code>delta</code> in the fit</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Breakdown of the degrees-of-freedom across the different subproblems</p>
</td></tr>
<tr><td><code>loss</code></td>
<td>
<p>Breakdown of the loss across subproblems</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Time taken in seconds to calculate the solution</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>Matrix of cluster membership per observation for all cluster types</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schoonees, P.C., Groenen, P.J.F., Van de Velden, M. Least-squares Bilinear Clustering
of Three-way Data. Econometric Institute Report, EI2014-23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+int.lsbclust">int.lsbclust</a></code>, <code><a href="#topic+orc.lsbclust">orc.lsbclust</a></code>
</p>

<hr>
<h2 id='meanbiplot'>Biplots of</h2><span id='topic+meanbiplot'></span>

<h3>Description</h3>

<p>Construct simple two-dimensional biplots given matrices representing the rows
and columns of a two-dimensional matrix using <span class="pkg">ggplot2</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanbiplot(rows, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanbiplot_+3A_rows">rows</code></td>
<td>
<p>A list of matrices representing the rows</p>
</td></tr>
<tr><td><code id="meanbiplot_+3A_cols">cols</code></td>
<td>
<p>A list of matrices representing the columns</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
dat &lt;- rlsbclust(ndata = 1, nobs = 100, size = c(10, 8), nclust = c(5, 4, 6, 5))
meanbiplot(dat[[1]]$interactions$C, dat[[1]]$interactions$D)
</code></pre>

<hr>
<h2 id='meanheatmap'>Plot Heatmap of A Matrix</h2><span id='topic+meanheatmap'></span>

<h3>Description</h3>

<p>Construct a heatmap of a matrix using <span class="pkg">ggplot2</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanheatmap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanheatmap_+3A_x">x</code></td>
<td>
<p>Matrix or list of matrices to be plotted</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
dat &lt;- rlsbclust(ndata = 1, nobs = 100, size = c(6, 6), nclust = c(5, 4, 6, 5))
meanheatmap(Map(tcrossprod, dat[[1]]$interactions$C, dat[[1]]$interactions$D))
</code></pre>

<hr>
<h2 id='orc.lsbclust'>K-means on the Overall Mean, Row Margins or Column Margins</h2><span id='topic+orc.lsbclust'></span><span id='topic+ovl.kmeans'></span><span id='topic+row.kmeans'></span><span id='topic+col.kmeans'></span>

<h3>Description</h3>

<p>This function conducts k-means on the overall mean, the row margins or column margins of a set
of N matrices. These matrices are two-way slices of a three-dimensional array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orc.lsbclust(data, margin = 3L, delta, nclust, sep.nclust = TRUE,
  type = NULL, verbose = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orc.lsbclust_+3A_data">data</code></td>
<td>
<p>A three-way array representing the data.</p>
</td></tr>
<tr><td><code id="orc.lsbclust_+3A_margin">margin</code></td>
<td>
<p>An integer giving the single subscript of <code>data</code> over which the clustering 
will be applied.</p>
</td></tr>
<tr><td><code id="orc.lsbclust_+3A_delta">delta</code></td>
<td>
<p>A four-element binary vector (logical or numeric) indicating which sum-to-zero 
constraints must be enforced.</p>
</td></tr>
<tr><td><code id="orc.lsbclust_+3A_nclust">nclust</code></td>
<td>
<p>An integer giving the desired number of clusters. In case <code>type</code> specifies 
more than one method, <code>nclust</code> can be a vector containing the number of 
clusters to be determined for each type of cluster, and in the correct order as determined by
<code>type</code> (after matching the arguments). If <code>type</code> is of length greater than one and 
<code>nclust</code> is of length one, the behaviour is governed by <code>sep.nclust</code>.</p>
</td></tr>
<tr><td><code id="orc.lsbclust_+3A_sep.nclust">sep.nclust</code></td>
<td>
<p>Logical indicating how nclust should be used across different <code>type</code>'s.
If <code>sep.nclust</code> is <code>TRUE</code>, <code>nclust</code> is recycled so that each <code>type</code> can
have a different number of clusters. If <code>sep.nclust</code> is <code>FALSE</code>, the same vector
<code>nclust</code> is used for all <code>type</code>'s.</p>
</td></tr>
<tr><td><code id="orc.lsbclust_+3A_type">type</code></td>
<td>
<p>One of <code>"overall"</code>, <code>"rows"</code> or <code>"columns"</code> (or a unique abbreviation of 
one of these) indicating whether clustering should be done on row margins, column margins or
the overall means of the two-way slices respectively. If more than one opion are supplied, the
algorithm is run for all (unique) options supplied.</p>
</td></tr>
<tr><td><code id="orc.lsbclust_+3A_verbose">verbose</code></td>
<td>
<p>Integer controlling the amount of information printed: 0 = no information, 
1 = Information on random starts and progress, and 2 = information is printed after
each iteration for the interaction clustering.</p>
</td></tr>
<tr><td><code id="orc.lsbclust_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="stats.html#topic+kmeans">kmeans</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a subset of the classes <code>row.kmeans</code>, <code>col.kmeans</code> and 
<code>ovl.kmeans</code> which are specific versions of class <code>kmeans</code>. In case <code>type</code> is a vector, a list
is returned containing the results for each of the (unique) elements of <code>type</code>, with the
same classes as before. See <code><a href="stats.html#topic+kmeans">kmeans</a></code> for an overview of the structure of these objects.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kmeans">kmeans</a></code>
</p>

<hr>
<h2 id='plot.bicomp'>Plot a <code>bicomp</code> Object</h2><span id='topic+plot.bicomp'></span>

<h3>Description</h3>

<p>Plot method for an object of class <code>bicomp</code> (see <code><a href="#topic+bicomp">bicomp</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bicomp'
plot(x, which = 0L:4L, arrange = TRUE,
  col = c("red4", "beige", "blue4"), strip.legend = TRUE,
  add.titles = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bicomp_+3A_x">x</code></td>
<td>
<p>An object of class <code>bicomp</code>.</p>
</td></tr>
<tr><td><code id="plot.bicomp_+3A_which">which</code></td>
<td>
<p>A numeric vector indicating which matrices to plot, with 0 = original data, 
1 = overall means, 2 = row means, 3 = column means and 4 = interactions.</p>
</td></tr>
<tr><td><code id="plot.bicomp_+3A_arrange">arrange</code></td>
<td>
<p>Logical indicating whether the arrange  the plots side-by-side
via <code><a href="gridExtra.html#topic+grid.arrange">grid.arrange</a></code> or not.</p>
</td></tr>
<tr><td><code id="plot.bicomp_+3A_col">col</code></td>
<td>
<p>A character vector of length three giving the parameters 
<code>low</code>, <code>mid</code> and <code>high</code> for <code><a href="ggplot2.html#topic+scale_fill_gradient2">scale_fill_gradient2</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bicomp_+3A_strip.legend">strip.legend</code></td>
<td>
<p>Logical indicating whether to strip the legend off the plot or not.</p>
</td></tr>
<tr><td><code id="plot.bicomp_+3A_add.titles">add.titles</code></td>
<td>
<p>Logical indicating whether to add titles to the plots or not.</p>
</td></tr>
<tr><td><code id="plot.bicomp_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="ggplot2.html#topic+theme">theme</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.col.kmeans'>Plot method for class 'col.kmeans'</h2><span id='topic+plot.col.kmeans'></span>

<h3>Description</h3>

<p>Simple plot method for object of class 'col.kmeans' as output by <code><a href="#topic+orc.lsbclust">orc.lsbclust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'col.kmeans'
plot(x, which = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.col.kmeans_+3A_x">x</code></td>
<td>
<p>An object of class <code>col.kmeans</code></p>
</td></tr>
<tr><td><code id="plot.col.kmeans_+3A_which">which</code></td>
<td>
<p>Which type of plot to produce (only 3 types are implemented).</p>
</td></tr>
<tr><td><code id="plot.col.kmeans_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="ggplot2.html#topic+theme">theme</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dcars")
m &lt;- orc.lsbclust(data = dcars, margin = 3, delta = c(1,1,1,1), nclust = 5, type = "columns")
plot(m)
</code></pre>

<hr>
<h2 id='plot.int.lsbclust'>Plot Method for Class 'int.lsbclust'</h2><span id='topic+plot.int.lsbclust'></span>

<h3>Description</h3>

<p>Two-dimensional plot method for object of class 'int.lsbclust' as output by <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'int.lsbclust'
plot(x, which = seq_len(nclust),
  plot.type = c("biplots", "means", "estimates"), segments = NULL,
  biplot.axes = TRUE, nmarkers = 5, alpha = NULL,
  check.alpha = TRUE, fix.alpha = FALSE, probs = 0,
  arrange = FALSE, fix.limits = TRUE, limit.exp = 1.05,
  lambda.scale = TRUE, procrustes.rotation = x$fixed == "none",
  fix.lambda = FALSE, labs.grey = TRUE, label.0 = FALSE,
  tick.length = 0.0075 * diff(lims), axis.col = "grey60",
  label.size = 3, axis.size = 0.25, axis.title.size = 4,
  draw.axis = NULL, points.col = list(rows = "red", columns = "blue2"),
  offset.tick.labels = 3.5, offset.axis.title = list(rows = 0.015 *
  max(nchar(rnms)), columns = 0.015 * max(nchar(cnms))),
  axis.arrow = grid::arrow(angle = 20, length = grid::unit(0.0175,
  "npc")), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.int.lsbclust_+3A_x">x</code></td>
<td>
<p>An object of class <code>int.lsbclust</code>.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_which">which</code></td>
<td>
<p>A vector indicating which item segments to plot.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_plot.type">plot.type</code></td>
<td>
<p>Character string giving the type of plots to produce: either <code>"biplots"</code>
for the biplots approximating the cluster means, <code>"means"</code> for level plots of the cluster means 
themselves or <code>"estimates"</code> for level plots of the low-rank approximations of the cluster means 
(as represented in the biplots).</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_segments">segments</code></td>
<td>
<p>A logical vector with two elements,  indicating whether the rows and columns should 
be plotted as line segments or not.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_biplot.axes">biplot.axes</code></td>
<td>
<p>A logical indicating whether to plot calibrated biplot axes for the line
segments indicated in <code>segments</code> or not.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_nmarkers">nmarkers</code></td>
<td>
<p>Either a single integer giving the number of desired markers per biplot axis 
for all axes, or a named list. This is passed as the argument <code>n</code> to <code><a href="base.html#topic+pretty">pretty</a></code>. See
<code>Details</code> for information on the list option.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value in [0, 1] which determines how the singular values are distributed
between rows and columns. It will trigger a recomputation of the updates if it does not correspond
to the value used when fitting the model. Do not confuse this with the term &quot;alpha&quot; used in the
context of colour transparency.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_check.alpha">check.alpha</code></td>
<td>
<p>Logical indicating whether to look for a better alpha. This is only used when
<code>alpha = NULL</code> is used. Do not confuse this with the term &quot;alpha&quot; used in the
context of colour transparency.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_fix.alpha">fix.alpha</code></td>
<td>
<p>Logical indicating whether to fix alpha across all clusters or not 
when <code>fixed == "none"</code>. Do not confuse this with the term &quot;alpha&quot; used in the
context of colour transparency.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_probs">probs</code></td>
<td>
<p>Argument passed to <code><a href="stats.html#topic+quantile">quantile</a></code> to determine the alpha value. The 
corresponding quantile of the distances of all points in the biplots to the origin will be
used to determine alpha in case check.alpha = TRUE.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_arrange">arrange</code></td>
<td>
<p>Logical indicating whether to arrange the plots side-by-side
via <code><a href="gridExtra.html#topic+grid.arrange">grid.arrange</a></code> or not.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_fix.limits">fix.limits</code></td>
<td>
<p>Logical indicating whether biplot x- and y-limits must be fixed across clusters
or not. Note that this is automatically set to <code>TRUE</code> when <code>fixed == "rows"</code> or 
<code>fixed == "columns"</code>. When limits are fixed, the axis calibrations are also turned off.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_limit.exp">limit.exp</code></td>
<td>
<p>A numeric expansion factor applied multiplicatively to the plot limits, but only
when <code>fixed</code> equals <code>"rows"</code> or <code>"columns"</code>.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_lambda.scale">lambda.scale</code></td>
<td>
<p>Logical indicating whether to apply lambda scaling to the coordinates or not.
If true, the scaling is done such that the average squared distance to the origin is equal
for the row and column coordinates.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_procrustes.rotation">procrustes.rotation</code></td>
<td>
<p>Logical indicating whether to do Procrustes rotations so that the
location of the axes indicated as segments (see argument <code>segments</code>) are similar
across configurations.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_fix.lambda">fix.lambda</code></td>
<td>
<p>Logical indicating whether to fix lambda across all clusters or not.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_labs.grey">labs.grey</code></td>
<td>
<p>Logical indicating whether to apply greying to the text labels are well.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_label.0">label.0</code></td>
<td>
<p>Logical indicating whether to label the origin or not.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_tick.length">tick.length</code></td>
<td>
<p>The required tick length as a <code><a href="grid.html#topic+unit">unit</a></code> object. It defaults to a 
propoprtion of the width of the plot region (through lazy evaluation).</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_axis.col">axis.col</code></td>
<td>
<p>The colour of the biplot axes.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_label.size">label.size</code></td>
<td>
<p>The size of the labels for the markers on the biplot axes.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_axis.size">axis.size</code></td>
<td>
<p>Line size for biplot axes.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_axis.title.size">axis.title.size</code></td>
<td>
<p>Size of biplot axis titles.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_draw.axis">draw.axis</code></td>
<td>
<p>A list with up to two components which must be named <code>"rows"</code> and 
<code>"columns"</code>. Each element contains a vector indicating which biplot axes should be drawn. 
The vectors can be character vectors containing the names of the axes to be drawn, numeric
vectors containing indices indicating which axes to draw, or logical vectors indicating which 
biplot axes to draw. In case of the default value <code>NULL</code>, the elements of <code>segments</code>
are used for the <code>"rows"</code> and <code>"columns"</code> entries.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_points.col">points.col</code></td>
<td>
<p>A named list containing the colours to use for plotting the sets of points. The 
elements <code>"rows"</code> and <code>"columns"</code> contain vectors giving the colours for the points. Single
element vectors are recycled across the different points, otherwise the vectors must be of the 
appropriate length.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_offset.tick.labels">offset.tick.labels</code></td>
<td>
<p>A numeric value giving the offset factor of the biplot axis marker labels
from their respective tick marks. Higher (lower) values lead to labels being further from 
(nearer to) their respective tick marks.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_offset.axis.title">offset.axis.title</code></td>
<td>
<p>A names list of (up to) two numeric values giving the fixed length offset of the 
biplot axis title label from the end of the axis segment. The two elements must have names 
<code>"rows"</code> and code&quot;columns&quot;.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_axis.arrow">axis.arrow</code></td>
<td>
<p>An <code><a href="grid.html#topic+arrow">arrow</a></code> object to be used for the endpoints of biplot axis 
segment lines. This is passed to <code><a href="ggplot2.html#topic+geom_segment">geom_segment</a></code>.</p>
</td></tr>
<tr><td><code id="plot.int.lsbclust_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+theme">theme</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case <code>nmarkers</code> is a list, it can have up to two elements. These are required to be named 
<code>"rows"</code> and/or <code>"columns"</code>, otherwise an error will be thrown. The elements of the list
contains either single numeric values each or numeric vectors of the appropriate lengths
indicating the <code>n</code> argument passed to <code><a href="base.html#topic+pretty">pretty</a></code>.
</p>
<p>In some cases, the row and/or column fit values can contain non-finite values. If that occurs,
colour transparency cannot and will not be used for that particular element (and this can vary between clusters). 
This relates to the  alpha parameter in the plotting routines.
</p>

<hr>
<h2 id='plot.lsbclust'>Plot method for class 'lsbclust'</h2><span id='topic+plot.lsbclust'></span>

<h3>Description</h3>

<p>This plot method simply plots each of the components in the list of class <code>lsbclust</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lsbclust'
plot(x, type = c("overall", "rows", "columns",
  "interactions"), biplot.axes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lsbclust_+3A_x">x</code></td>
<td>
<p>An object of class <code>orc.kmeans</code></p>
</td></tr>
<tr><td><code id="plot.lsbclust_+3A_type">type</code></td>
<td>
<p>A character vector indicating which component(s) of <code>x</code> to plot: a combination of
<code>"overall"</code>, <code>"rows"</code>, <code>"columns"</code> and <code>"interactions"</code>.</p>
</td></tr>
<tr><td><code id="plot.lsbclust_+3A_biplot.axes">biplot.axes</code></td>
<td>
<p>A logical indicating whether to plot calibrated biplot axes for the line
segments indicated in <code>segments</code> or not.</p>
</td></tr>
<tr><td><code id="plot.lsbclust_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plot methods of the respective components, typically
to <code><a href="ggplot2.html#topic+theme">theme</a></code>. Use e.g. <code>plot(x$interactions)</code> for more control over the respective
plots.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.int.lsbclust">plot.int.lsbclust</a></code>, <code><a href="#topic+plot.ovl.kmeans">plot.ovl.kmeans</a></code>, 
<code><a href="#topic+plot.row.kmeans">plot.row.kmeans</a></code>, <code><a href="#topic+plot.col.kmeans">plot.col.kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dcars")
m &lt;- lsbclust(data = dcars, margin = 3, delta = c(1, 1, 1, 1), nclust = 5, nstart = 1)
plot(m)
</code></pre>

<hr>
<h2 id='plot.ovl.kmeans'>Plot method for class 'ovl.kmeans'</h2><span id='topic+plot.ovl.kmeans'></span>

<h3>Description</h3>

<p>Simple plot method for object of class 'ovl.kmeans' as output by <code><a href="#topic+orc.lsbclust">orc.lsbclust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ovl.kmeans'
plot(x, which = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ovl.kmeans_+3A_x">x</code></td>
<td>
<p>An object of class <code>ovl.kmeans</code></p>
</td></tr>
<tr><td><code id="plot.ovl.kmeans_+3A_which">which</code></td>
<td>
<p>Which type of plot to produce. Currently only <code>which = 1</code> is implemented.</p>
</td></tr>
<tr><td><code id="plot.ovl.kmeans_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="ggplot2.html#topic+theme">theme</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dcars")
m &lt;- orc.lsbclust(data = dcars, margin = 3, delta = c(1,1,1,1), nclust = 5, type = "overall")
plot(m)
</code></pre>

<hr>
<h2 id='plot.row.kmeans'>Plot method for class 'row.kmeans'</h2><span id='topic+plot.row.kmeans'></span>

<h3>Description</h3>

<p>Simple plot method for object of class 'row.kmeans' as output by <code><a href="#topic+orc.lsbclust">orc.lsbclust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'row.kmeans'
plot(x, which = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.row.kmeans_+3A_x">x</code></td>
<td>
<p>An object of class <code>row.kmeans</code></p>
</td></tr>
<tr><td><code id="plot.row.kmeans_+3A_which">which</code></td>
<td>
<p>Which type of plot to produce (only 3 types are implemented).</p>
</td></tr>
<tr><td><code id="plot.row.kmeans_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="ggplot2.html#topic+theme">theme</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dcars")
m &lt;- orc.lsbclust(data = dcars, margin = 3, delta = c(1,1,1,1), nclust = 5, type = "rows")
plot(m)
</code></pre>

<hr>
<h2 id='plot.step.lsbclust'>Plot method for class 'step.lsbclust'</h2><span id='topic+plot.step.lsbclust'></span>

<h3>Description</h3>

<p>Plot 'step.lsbclust' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'step.lsbclust'
plot(x, which = 1L:5L, col.all = NULL,
  arrange = FALSE, chull = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.step.lsbclust_+3A_x">x</code></td>
<td>
<p>An object of class <code>step.lsbclust</code></p>
</td></tr>
<tr><td><code id="plot.step.lsbclust_+3A_which">which</code></td>
<td>
<p>Which type of plot to produce.</p>
</td></tr>
<tr><td><code id="plot.step.lsbclust_+3A_col.all">col.all</code></td>
<td>
<p>A character vector of length one indicating which of <code>"overall"</code>, 
<code>"rows"</code>, <code>"columns"</code> or <code>"interactions"</code> should be mapped to colour in the
plot for all possible models. Care needs to be taken that the stated component is included in
the fit.</p>
</td></tr>
<tr><td><code id="plot.step.lsbclust_+3A_arrange">arrange</code></td>
<td>
<p>Logical indicating whether the arrange  the plots side-by-side
via <code><a href="gridExtra.html#topic+grid.arrange">grid.arrange</a></code> or not.</p>
</td></tr>
<tr><td><code id="plot.step.lsbclust_+3A_chull">chull</code></td>
<td>
<p>Logical indicating whether to plot the estimated convex hull or not.</p>
</td></tr>
<tr><td><code id="plot.step.lsbclust_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="ggplot2.html#topic+theme">theme</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>

<hr>
<h2 id='plot.T3Clusf'>Plot Method for Class 'T3Clusf'</h2><span id='topic+plot.T3Clusf'></span>

<h3>Description</h3>

<p>Two-dimensional plot method for object of class 'T3Clusf' as output by <code><a href="#topic+T3Clusf">T3Clusf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'T3Clusf'
plot(x, which = seq_len(nclust), arrange = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.T3Clusf_+3A_x">x</code></td>
<td>
<p>An object of class <code>T3Clusf</code>.</p>
</td></tr>
<tr><td><code id="plot.T3Clusf_+3A_which">which</code></td>
<td>
<p>An integer vector indicating which item segments to plot.</p>
</td></tr>
<tr><td><code id="plot.T3Clusf_+3A_arrange">arrange</code></td>
<td>
<p>Logical indicating whether to arrange the plots on a single page or not</p>
</td></tr>
<tr><td><code id="plot.T3Clusf_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="ggplot2.html#topic+theme">theme</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='print.lsbclust'>Print method for object of class 'lsbclust'</h2><span id='topic+print.lsbclust'></span>

<h3>Description</h3>

<p>Print a 'lsbclust' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lsbclust'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lsbclust_+3A_x">x</code></td>
<td>
<p>An object of class 'lsbclust'</p>
</td></tr>
<tr><td><code id="print.lsbclust_+3A_...">...</code></td>
<td>
<p>Unimplemented.</p>
</td></tr>
</table>

<hr>
<h2 id='rlsbclust'>Simulate from LSBCLUST Model</h2><span id='topic+rlsbclust'></span>

<h3>Description</h3>

<p>Simulate three-way arrays adhering to the LSBCLUST framework (see <code><a href="#topic+lsbclust">lsbclust</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsbclust(ndata = 50L, nobs, size, nclust, clustsize = NULL,
  delta = rep(1L, 4L), ndim = 2L, alpha = 0.5, fixed = c("none",
  "rows", "columns"), err_sd = 1, svmins = 1, svmax = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsbclust_+3A_ndata">ndata</code></td>
<td>
<p>Integer giving the number of data sets to generate with the same underlying
parameters.</p>
</td></tr>
<tr><td><code id="rlsbclust_+3A_nobs">nobs</code></td>
<td>
<p>Integer giving the number of observations to sample.</p>
</td></tr>
<tr><td><code id="rlsbclust_+3A_size">size</code></td>
<td>
<p>Vector with two elements giving the number of rows and columns respectively
of each simulated observation.</p>
</td></tr>
<tr><td><code id="rlsbclust_+3A_nclust">nclust</code></td>
<td>
<p>A vector of length four giving the number of clusters for the overall mean, the row
margins, the column margins and the interactions (in that order) respectively. Alternatively, a
vector of length one, in which case all components will have the same number of clusters.</p>
</td></tr>
<tr><td><code id="rlsbclust_+3A_clustsize">clustsize</code></td>
<td>
<p>A list of length four, with each element containing a vector 
of the same length as the corresponding entry in <code>nclust</code>, indicating the 
number of elements to contribute to each sample. Naturally, each of these 
vectors must sum to <code>nobs</code>, or an error will result. Positional matching 
are used, in the order &quot;overall&quot;, &quot;rows&quot;, &quot;columns&quot; and &quot;interactions&quot;. If 
<code>NULL</code>, all clusters will be of equal size.</p>
</td></tr>
<tr><td><code id="rlsbclust_+3A_delta">delta</code></td>
<td>
<p>A four-element binary vector (logical or numeric) indicating which sum-to-zero 
constraints must be enforced.</p>
</td></tr>
<tr><td><code id="rlsbclust_+3A_ndim">ndim</code></td>
<td>
<p>The required rank for the approximation of the interactions (a scalar).</p>
</td></tr>
<tr><td><code id="rlsbclust_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value in [0, 1] which determines how the singular values are distributed
between rows and columns (passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="rlsbclust_+3A_fixed">fixed</code></td>
<td>
<p>One of <code>"none"</code>, <code>"rows"</code> or <code>"columns"</code> indicating whether to fix neither
sets of coordinates, or whether to fix the row or column coordinates across clusters respectively.
If a vector is supplied, only the first element will be used (passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="rlsbclust_+3A_err_sd">err_sd</code></td>
<td>
<p>The standard deviation of the error distribution, as passed to 
<code><a href="stats.html#topic+rnorm">rnorm</a></code></p>
</td></tr>
<tr><td><code id="rlsbclust_+3A_svmins">svmins</code></td>
<td>
<p>Vector of minimum values for the singular values 
(as passed to <code><a href="#topic+simsv">simsv</a></code>). Optionally, if all minima are equal,
a single numeric value which will be expanded to the correct length.</p>
</td></tr>
<tr><td><code id="rlsbclust_+3A_svmax">svmax</code></td>
<td>
<p>The maximum possible singular value (as passed to <code><a href="#topic+simsv">simsv</a></code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Nothing fixed, balanced classes
set.seed(1)
dat &lt;- rlsbclust(ndata = 1, nobs = 100, size = c(10, 8), nclust = c(5, 4, 6, 5))
res &lt;- lsbclust(data = dat[[1]]$data, nclust = c(5, 4, 6, 5))
cfsim(res, dat[[1]])

## Rows fixed, balanced classes
set.seed(2)
dat &lt;- rlsbclust(ndata = 1, nobs = 100, size = c(10, 8), nclust = c(5, 4, 6, 5), 
                 fixed = "rows")
res &lt;- lsbclust(data = dat[[1]]$data, nclust = c(5, 4, 6, 5), fixed = "rows")
cfsim(res, dat[[1]])

## Rows fixed, unbalanced classes
set.seed(3)
dat &lt;- rlsbclust(ndata = 1, nobs = 100, size = c(10, 8), nclust = c(5, 4, 6, 5), 
                 fixed = "columns", 
                 clustsize = list(NULL, NULL, c(40, 25, 15, 10, 5, 5), c(40, 25, 15, 10, 10)))
res &lt;- lsbclust(data = dat[[1]]$data, nclust = c(5, 4, 6, 5), fixed = "columns")
cfsim(res, dat[[1]])
</code></pre>

<hr>
<h2 id='rorth'>Generate A Random Orthonormal Matrix</h2><span id='topic+rorth'></span>

<h3>Description</h3>

<p>Uniformly sample an orthornormal matrix from the collection of all possible 
orthonormal matrices of a certain size. The QR decomposition is used on a 
matrix containing Gaussian random numbers. The QR decomposition might not
be the most efficient algorithm under some circumstances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rorth(nrow, ncol, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rorth_+3A_nrow">nrow</code></td>
<td>
<p>Integer giving the number of rows required.</p>
</td></tr>
<tr><td><code id="rorth_+3A_ncol">ncol</code></td>
<td>
<p>Integer giving the number of columns required.</p>
</td></tr>
<tr><td><code id="rorth_+3A_sd">sd</code></td>
<td>
<p>The standard deviation passed to <code><a href="stats.html#topic+rnorm">rnorm</a></code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Stewart, G. W. (1980). The efficient generation of random orthogonal matrices with an 
application to condition estimators. <em>SIAM Journal on Numerical Analysis</em>, 17(3), 403-409.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
rorth(5, 2)
</code></pre>

<hr>
<h2 id='sim_lsbclust'>Simulate and Analyze LSBCLUST</h2><span id='topic+sim_lsbclust'></span>

<h3>Description</h3>

<p>Perform a single simulation run for the LSBCLUST model. Multiple data sets 
are generated for a single set of underlying parameters,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_lsbclust(ndata, nobs, size, nclust, clustsize = NULL,
  delta = rep(1L, 4L), ndim = 2L, alpha = 0.5, fixed = c("none",
  "rows", "columns"), err_sd = 1, svmins = 0.5, svmax = 5,
  seed = NULL, parallel = FALSE, parallel_data = TRUE, verbose = 0,
  nstart_T3 = 20L, nstart_ak = 20L, mc.cores = detectCores() - 1,
  include_fits = FALSE, include_data = FALSE, nstart, nstart.kmeans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_lsbclust_+3A_ndata">ndata</code></td>
<td>
<p>Integer giving the number of data sets to generate with the same underlying
parameters.</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_nobs">nobs</code></td>
<td>
<p>Integer giving the number of observations to sample.</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_size">size</code></td>
<td>
<p>Vector with two elements giving the number of rows and columns respectively
of each simulated observation.</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_nclust">nclust</code></td>
<td>
<p>A vector of length four giving the number of clusters for the overall mean, the row
margins, the column margins and the interactions (in that order) respectively. Alternatively, a
vector of length one, in which case all components will have the same number of clusters.</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_clustsize">clustsize</code></td>
<td>
<p>A list of length four, with each element containing a vector 
of the same length as the corresponding entry in <code>nclust</code>, indicating the 
number of elements to contribute to each sample. Naturally, each of these 
vectors must sum to <code>nobs</code>, or an error will result. Positional matching 
are used, in the order &quot;overall&quot;, &quot;rows&quot;, &quot;columns&quot; and &quot;interactions&quot;. If 
<code>NULL</code>, all clusters will be of equal size.</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_delta">delta</code></td>
<td>
<p>A four-element binary vector (logical or numeric) indicating which sum-to-zero 
constraints must be enforced.</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_ndim">ndim</code></td>
<td>
<p>The required rank for the approximation of the interactions (a scalar).</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value in [0, 1] which determines how the singular values are distributed
between rows and columns (passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_fixed">fixed</code></td>
<td>
<p>One of <code>"none"</code>, <code>"rows"</code> or <code>"columns"</code> indicating whether to fix neither
sets of coordinates, or whether to fix the row or column coordinates across clusters respectively.
If a vector is supplied, only the first element will be used (passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_err_sd">err_sd</code></td>
<td>
<p>The standard deviation of the error distribution, as passed to 
<code><a href="stats.html#topic+rnorm">rnorm</a></code></p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_svmins">svmins</code></td>
<td>
<p>Vector of minimum values for the singular values 
(as passed to <code><a href="#topic+simsv">simsv</a></code>). Optionally, if all minima are equal,
a single numeric value which will be expanded to the correct length.</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_svmax">svmax</code></td>
<td>
<p>The maximum possible singular value (as passed to <code><a href="#topic+simsv">simsv</a></code>)</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_seed">seed</code></td>
<td>
<p>An optional seed to be set for the random number generator</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_parallel">parallel</code></td>
<td>
<p>Logical indicating whether to parallelize over random starts. 
Note that <code>parallel_data</code> has precedence over this</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_parallel_data">parallel_data</code></td>
<td>
<p>Logical indicating whether to parallelize over the data sets. If 
<code>FALSE</code>, parallelization is done over random starts (depending on <code>parallel</code>).</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_verbose">verbose</code></td>
<td>
<p>Integer giving the number of iterations after which the loss values is printed.</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_nstart_t3">nstart_T3</code></td>
<td>
<p>The number of random starts to use for <code><a href="#topic+T3Clusf">T3Clusf</a></code></p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_nstart_ak">nstart_ak</code></td>
<td>
<p>The number of random starts to use for <code><a href="#topic+akmeans">akmeans</a></code></p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use, passed to <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code></p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_include_fits">include_fits</code></td>
<td>
<p>Logical indicating whether to include the model fits, or
or only the fit statistics</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_include_data">include_data</code></td>
<td>
<p>Logical indicating whether to include the simulated data 
fitted on, or only the results</p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_nstart">nstart</code></td>
<td>
<p>From <code><a href="#topic+lsbclust">lsbclust</a></code></p>
</td></tr>
<tr><td><code id="sim_lsbclust_+3A_nstart.kmeans">nstart.kmeans</code></td>
<td>
<p>From <code><a href="#topic+lsbclust">lsbclust</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
res &lt;- sim_lsbclust(ndata = 5, nobs = 100, size = c(10, 8), nclust = rep(5, 4), 
                    verbose = 0, nstart_T3 = 2, nstart_ak = 1, parallel_data = FALSE,
                    nstart = 2, nstart.kmeans = 5 )

</code></pre>

<hr>
<h2 id='simsv'>Randomly Generate Positive Singular Values</h2><span id='topic+simsv'></span>

<h3>Description</h3>

<p>Generate random singular values for a specified number of clusters
for use in simulations. A mixture distribution is used with truncation to ensure that the
singular values differ between clusters, are ordered, and are nonnegative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsv(nclust, ndim = 2, mins = 1, max = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simsv_+3A_nclust">nclust</code></td>
<td>
<p>Integer giving the number of clusters for which to sample singular values.</p>
</td></tr>
<tr><td><code id="simsv_+3A_ndim">ndim</code></td>
<td>
<p>Integer; the number of singular values required.</p>
</td></tr>
<tr><td><code id="simsv_+3A_mins">mins</code></td>
<td>
<p>Numeric vector of length <code>ndim</code> giving the minimum values for the 
respective singular values.</p>
</td></tr>
<tr><td><code id="simsv_+3A_max">max</code></td>
<td>
<p>Numeric value giving the maximum possible value for the mean of the cluster-
specific singular value distribution, relative to the <code>mins</code></p>
</td></tr>
</table>

<hr>
<h2 id='step.lsbclust'>Model Search for lsbclust</h2><span id='topic+step.lsbclust'></span>

<h3>Description</h3>

<p>Fit <code><a href="#topic+lsbclust">lsbclust</a></code> models for different numbers of clusters and/or different values of 
<code>delta</code>. The resulting output can be inspected through its <code>plot</code> method to facilitate 
model selection. Each component of the model is fitted separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step.lsbclust(data, margin = 3L, delta = c(1, 1, 1, 1), nclust,
  ndim = 2, fixed = c("none", "rows", "columns"), nstart = 20,
  starts = NULL, nstart.kmeans = 500, alpha = 0.5,
  parallel = FALSE, maxit = 100, verbose = -1, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step.lsbclust_+3A_data">data</code></td>
<td>
<p>A three-way array representing the data.</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_margin">margin</code></td>
<td>
<p>An integer giving the single subscript of <code>data</code> over which the clustering 
will be applied.</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_delta">delta</code></td>
<td>
<p>A four-element binary vector (logical or numeric) indicating which sum-to-zero 
constraints must be enforced.</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_nclust">nclust</code></td>
<td>
<p>Either a vector giving the number of clusters which will be applied to each element
of the model, that is to (a subset of) the overall mean, row margins, column margins and 
interactions. If it is a list, arguments are matched by the names <code>"overall"</code>, <code>"rows"</code>
<code>"columns"</code> and <code>"interactions"</code>. If the list does not have names, the components are 
extracted in the aforementioned order.</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_ndim">ndim</code></td>
<td>
<p>The required rank for the approximation of the interactions (a scalar).</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_fixed">fixed</code></td>
<td>
<p>One of <code>"none"</code>, <code>"rows"</code> or <code>"columns"</code> indicating whether to fix neither
sets of coordinates, or whether to fix the row or column coordinates across clusters respectively.
If a vector is supplied, only the first element will be used (passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_nstart">nstart</code></td>
<td>
<p>The number of random starts to use for the interaction clustering.</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_starts">starts</code></td>
<td>
<p>A list containing starting configurations for the cluster membership vector. If not
supplied, random initializations will be generated (passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_nstart.kmeans">nstart.kmeans</code></td>
<td>
<p>The number of random starts to use in <code><a href="stats.html#topic+kmeans">kmeans</a></code>.</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value in [0, 1] which determines how the singular values are distributed
between rows and columns (passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_parallel">parallel</code></td>
<td>
<p>Logical indicating whether to parallelize over different starts or not 
(passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations allowed in the interaction clustering.</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_verbose">verbose</code></td>
<td>
<p>The number of iterations after which information on progress is provided 
(passed to <code><a href="#topic+int.lsbclust">int.lsbclust</a></code>).</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_type">type</code></td>
<td>
<p>One of <code>"rows"</code>, <code>"columns"</code> or <code>"overall"</code> (or a unique abbreviation of 
one of these) indicating whether clustering should be done on row margins, column margins or
the overall means of the two-way slices respectively. If more than one opion are supplied, the
algorithm is run for all (unique) options supplied (passed to <code><a href="#topic+orc.lsbclust">orc.lsbclust</a></code>). This
is an optional argument.</p>
</td></tr>
<tr><td><code id="step.lsbclust_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="stats.html#topic+kmeans">kmeans</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- step.lsbclust(data = dcars, margin = 3, delta = c(1, 0, 1, 0), nclust = 4:5, 
                     ndim = 2, fixed = "columns", nstart = 1, nstart.kmeans = 100, 
                     parallel = FALSE)
                     
## For a list of all deltas                     
delta &lt;- expand.grid(replicate(4, c(0,1), simplify = FALSE))
delta &lt;- with(delta, delta[!(Var1 == 0 &amp; Var3 == 1), ])
delta &lt;- with(delta, delta[!(Var2 == 0 &amp; Var4 == 1),])
delta &lt;- delta[-4,]
delta &lt;- as.list(as.data.frame(t(delta)))
m2 &lt;- step.lsbclust(data = dcars, margin = 3, delta = delta, nclust = 4:5, 
                     ndim = 2, fixed = "columns", nstart = 1, nstart.kmeans = 100, 
                     parallel = FALSE)
</code></pre>

<hr>
<h2 id='summary.int.lsbclust'>Summary Method for Class &quot;int.lsbclust&quot;</h2><span id='topic+summary.int.lsbclust'></span>

<h3>Description</h3>

<p>Some goodness-of-fit diagnostics are provided for all three margins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'int.lsbclust'
summary(object, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.int.lsbclust_+3A_object">object</code></td>
<td>
<p>An object of class 'int.lsbclust'.</p>
</td></tr>
<tr><td><code id="summary.int.lsbclust_+3A_digits">digits</code></td>
<td>
<p>The number of digits in the printed output.</p>
</td></tr>
<tr><td><code id="summary.int.lsbclust_+3A_...">...</code></td>
<td>
<p>Unimplemented.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.lsbclust'>Summary Method for Class &quot;lsbclust&quot;</h2><span id='topic+summary.lsbclust'></span>

<h3>Description</h3>

<p>Summarize a <code>lsbclust</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lsbclust'
summary(object, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lsbclust_+3A_object">object</code></td>
<td>
<p>An object of class 'lsbclust'.</p>
</td></tr>
<tr><td><code id="summary.lsbclust_+3A_digits">digits</code></td>
<td>
<p>The number of digits in the printed output.</p>
</td></tr>
<tr><td><code id="summary.lsbclust_+3A_...">...</code></td>
<td>
<p>Unimplemented.</p>
</td></tr>
</table>

<hr>
<h2 id='supermarkets'>Dutch Supermarkets Data Set</h2><span id='topic+supermarkets'></span>

<h3>Description</h3>

<p>This data set relates to 220 consumers rating 10 Dutch supermarket chains according 
to 8 variables. A rating scale from 1 to 10 was used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supermarkets
</code></pre>


<h3>Format</h3>

<p>A three-way array with supermarkets in the first dimension, variables in the second and 
consumers in the third dimension.</p>


<h3>Source</h3>

<p>Michel van de Velden
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("supermarkets")
fit &lt;- lsbclust(data = supermarkets, nclust = 6, fixed = "rows", nstart = 2)
</code></pre>

<hr>
<h2 id='T3Clusf'>T3Clusf: Tucker3 Fuzzy Cluster Analysis</h2><span id='topic+T3Clusf'></span>

<h3>Description</h3>

<p>This is an implementation of the T3Clusf algorithm of Rocci &amp; Vichi (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T3Clusf(X, Q, R = Q, G = 2, margin = 3L, alpha = 1, eps = 1e-08,
  maxit = 100L, verbose = 1, nstart = 1L, parallel = TRUE,
  mc.cores = detectCores() - 1L, minsize = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T3Clusf_+3A_x">X</code></td>
<td>
<p>Three-way data array, with no missing values.</p>
</td></tr>
<tr><td><code id="T3Clusf_+3A_q">Q</code></td>
<td>
<p>Integer giving the number of dimensions required for mode B (variables).
This is the first mode of the array, excluding the mode clustered over (see <code>margin</code>).</p>
</td></tr>
<tr><td><code id="T3Clusf_+3A_r">R</code></td>
<td>
<p>Integer giving the number of dimensions required for mode C (occasions). 
This is the second mode of the array, excluding the mode clustered over (see <code>margin</code>).</p>
</td></tr>
<tr><td><code id="T3Clusf_+3A_g">G</code></td>
<td>
<p>Integer giving the number of clusters required.</p>
</td></tr>
<tr><td><code id="T3Clusf_+3A_margin">margin</code></td>
<td>
<p>Integer giving the margin of the array to cluster over. The remaining two
modes, in the original order, corresponds to <code>Q</code> and <code>R</code>.</p>
</td></tr>
<tr><td><code id="T3Clusf_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value giving the fuzziness parameter.</p>
</td></tr>
<tr><td><code id="T3Clusf_+3A_eps">eps</code></td>
<td>
<p>Small numeric value giving the empirical convergence threshold.</p>
</td></tr>
<tr><td><code id="T3Clusf_+3A_maxit">maxit</code></td>
<td>
<p>Integer giving the maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="T3Clusf_+3A_verbose">verbose</code></td>
<td>
<p>Integer giving the number of iterations after which the loss values are printed.</p>
</td></tr>
<tr><td><code id="T3Clusf_+3A_nstart">nstart</code></td>
<td>
<p>Integer giving the number of random starts required.</p>
</td></tr>
<tr><td><code id="T3Clusf_+3A_parallel">parallel</code></td>
<td>
<p>Logical indicating whether to parallelize over random starts if 
<code>nstart &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="T3Clusf_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Argument passed to <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.</p>
</td></tr>
<tr><td><code id="T3Clusf_+3A_minsize">minsize</code></td>
<td>
<p>Integer giving the minimum size of cluster to uphold when reinitializing
empty clusters.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rocci, R., &amp; Vichi, M. (2005). <em>Three-mode component analysis with crisp or fuzzy partition of units</em>. 
Psychometrika, 70(4), 715-736.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dcars")
set.seed(13)
res &lt;- T3Clusf(X = carray(dcars), Q = 3, R = 2, G = 3, alpha = 1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
