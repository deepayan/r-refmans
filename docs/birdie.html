<!DOCTYPE html><html><head><title>Help for package birdie</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {birdie}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#birdie-package'><p>birdie: Bayesian Instrumental Regression for Disparity Estimation</p></a></li>
<li><a href='#birdie'><p>Fit BIRDiE Models</p></a></li>
<li><a href='#birdie-class'><p>Class &quot;birdie&quot; of BIRDiE Models</p></a></li>
<li><a href='#birdie-family'><p>BIRDiE Complete-Data Model Families</p></a></li>
<li><a href='#birdie.ctrl'><p>Control of BIRDiE Model Fitting</p></a></li>
<li><a href='#bisg'><p>Bayesian Improved Surname Geocoding (BISG)</p></a></li>
<li><a href='#census_race_geo_table'><p>Download Census Race Data</p></a></li>
<li><a href='#disparities'><p>Compute Racial Disparities from Model Estimates</p></a></li>
<li><a href='#est_weighted'><p>Calculate Weighted Estimate of (Discrete) Outcomes By Race</p></a></li>
<li><a href='#p_r_natl'><p>National Racial Demographics</p></a></li>
<li><a href='#preproc'><p>Preprocess Last Names and Geographic Identifiers</p></a></li>
<li><a href='#pseudo_vf'><p>A pseudo-voterfile</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Instrumental Regression for Disparity Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian models for accurately estimating conditional 
    distributions by race, using Bayesian Improved Surname Geocoding (BISG) 
    probability estimates of individual race. Implements the methods described
    in McCartan, Fisher, Goldin, Ho and Imai (2024) &lt;<a href="https://doi.org/10.3386%2Fw32373">doi:10.3386/w32373</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang (&ge; 0.1.2), Rcpp (&ge; 0.12.0), cli, vctrs, generics,
dplyr, methods, stringi, stringr, RcppParallel (&ge; 5.0.1),
SQUAREM</td>
</tr>
<tr>
<td>Suggests:</td>
<td>daarem, easycensus, wru, knitr, roxygen2, rmarkdown, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.0), cli, BH (&ge; 1.66.0), RcppEigen (&ge;
0.3.3.3.0), RcppParallel (&ge; 5.0.1), RcppThread, StanHeaders
(&ge; 2.18.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, C++17</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CoryMcCartan/birdie">https://github.com/CoryMcCartan/birdie</a>,
<a href="https://corymccartan.com/birdie/">https://corymccartan.com/birdie/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CoryMcCartan/birdie/issues">https://github.com/CoryMcCartan/birdie/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-10 17:23:19 UTC; cmccartan</td>
</tr>
<tr>
<td>Author:</td>
<td>Cory McCartan [aut, cre],
  Kosuke Imai [ctb],
  Daniel Ho [ctb],
  Jacob Goldin [ctb],
  Robin Fisher [ctb],
  The Stan Development Team [cph] (include/rstan)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cory McCartan &lt;mccartan@psu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-11 12:10:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='birdie-package'>birdie: Bayesian Instrumental Regression for Disparity Estimation</h2><span id='topic+birdie-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Bayesian models for accurately estimating conditional distributions by race, using Bayesian Improved Surname Geocoding (BISG) probability estimates of individual race. Implements the methods described in McCartan, Fisher, Goldin, Ho and Imai (2024) <a href="https://doi.org/10.3386/w32373">doi:10.3386/w32373</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Cory McCartan <a href="mailto:mccartan@psu.edu">mccartan@psu.edu</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Kosuke Imai <a href="mailto:imai@harvard.edu">imai@harvard.edu</a> [contributor]
</p>
</li>
<li><p> Daniel Ho <a href="mailto:dho@law.stanford.edu">dho@law.stanford.edu</a> [contributor]
</p>
</li>
<li><p> Jacob Goldin <a href="mailto:jsgoldin@uchicago.edu">jsgoldin@uchicago.edu</a> [contributor]
</p>
</li>
<li><p> Robin Fisher <a href="mailto:robin.fisher@treasury.gov">robin.fisher@treasury.gov</a> [contributor]
</p>
</li>
<li><p> The Stan Development Team (include/rstan) [copyright holder]
</p>
</li></ul>



<h3>References</h3>

<p>McCartan, C., Fisher, R., Goldin, J., Ho, D.E., &amp; Imai, K. (2024).
Estimating Racial Disparities when Race is Not Observed.
Available at <a href="https://www.nber.org/papers/w32373">https://www.nber.org/papers/w32373</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/CoryMcCartan/birdie">https://github.com/CoryMcCartan/birdie</a>
</p>
</li>
<li> <p><a href="https://corymccartan.com/birdie/">https://corymccartan.com/birdie/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/CoryMcCartan/birdie/issues">https://github.com/CoryMcCartan/birdie/issues</a>
</p>
</li></ul>


<hr>
<h2 id='birdie'>Fit BIRDiE Models</h2><span id='topic+birdie'></span>

<h3>Description</h3>

<p>Fits one of three possible Bayesian Instrumental Regression for Disparity
Estimation (BIRDiE) models to BISG probabilities and covariates. The simplest
Categorical-Dirichlet model ([cat_dir()]) is appropriate when there are no
covariates or when all covariates are discrete and fully interacted with
another. The more general Categorical mixed-effects model ([cat_mixed()]) is
a supports any number of fixed effects and up to one random intercept. For
continuous outcomes a Normal linear model is available ([gaussian()]).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>birdie(
  r_probs,
  formula,
  data,
  family = cat_dir(),
  prior = NULL,
  weights = NULL,
  algorithm = c("em", "gibbs", "em_boot"),
  iter = 400,
  warmup = 50,
  prefix = "pr_",
  ctrl = birdie.ctrl()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="birdie_+3A_r_probs">r_probs</code></td>
<td>
<p>A data frame or matrix of BISG probabilities, with one row per
individual. The output of [bisg()] can be used directly here.</p>
</td></tr>
<tr><td><code id="birdie_+3A_formula">formula</code></td>
<td>
<p>A two-sided formula object describing the model structure. The
left-hand side is the outcome variable, which must be discrete. A single
random intercept term, denoted with a vertical bar ('&quot;(1 | &lt;term&gt;)&quot;'), is
supported on the right-hand side.</p>
</td></tr>
<tr><td><code id="birdie_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables named in 'formula'.</p>
</td></tr>
<tr><td><code id="birdie_+3A_family">family</code></td>
<td>
<p>A description of the complete-data model type to fit. Options
are:
</p>
<p>- [cat_dir()]: Categorical-Dirichlet model. All covariates must be fully
interacted.
- [cat_mixed()]: Categorical mixed-effects model. Up to one random effect
is supported.
- [gaussian()]: Linear model.
</p>
<p>See the Details section below for more information on the various models.</p>
</td></tr>
<tr><td><code id="birdie_+3A_prior">prior</code></td>
<td>
<p>A list with entries specifying the model prior.
</p>
<p>- For the 'cat_dir' model, the only entry is 'alpha', which should be a matrix
of Dirichlet hyperparameters. The matrix should have one row for every
level of the outcome variable and one column for every racial group. The
default prior (used when 'prior=NULL') is an empirical Bayes prior equal to
the weighted-mean estimate of the outcome-race table. A fully
noninformative prior with all entries set to <code class="reqn">\epsilon</code> can be obtained
by setting 'prior=NA'. When 'prior=NULL' and 'algorithm=&quot;em&quot;' or
'&quot;em_boot&quot;', 1 is added to the prior so that the posterior mode, rather
than the mean, is shrunk toward these values.
- For the 'cat_mixed' model, the 'prior' list should contain three scalar entries:
'scale_int', the standard deviation on the Normal prior for the intercepts
(which control the global estimates of 'Y|R'), 'scale_beta', the standard
deviation on the Normal prior for the fixed effects, and 'scale_sigma', the
prior mean of the standard deviation of the random intercepts. These can be
a single scalar or a vector with an entry for each racial group.
- For the 'gaussian' model, the 'prior' list  should contain two entries:
'scale_int', controlling, the standard deviation on the Normal prior for
the intercepts (which control the global estimates of 'Y|R'), and
'scale_beta', controlling the standard deviation on the Normal prior for
the fixed effects. These must be a single scalar. Each is expressed in
terms of the estimated residual standard deviation (i.e., they are
multiplied together to form the &quot;true&quot; prior).
</p>
<p>The prior is stored after model fitting in the '$prior' element of the
fitted model object.</p>
</td></tr>
<tr><td><code id="birdie_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector specifying likelihood weights.</p>
</td></tr>
<tr><td><code id="birdie_+3A_algorithm">algorithm</code></td>
<td>
<p>The inference algorithm to use. One of 3 options:
</p>
<p>- '&quot;em&quot;': An expectation-maximization algorithm which will perform inference
for the maximum a posteriori (MAP) parameter values. Computationally
efficient and supported by all the model families. No uncertainty
quantification.
- '&quot;gibbs&quot;': A Gibbs sampler for performing full Bayesian inference.
Generally more computationally demanding than the EM algorithm, but
provides uncertainty quantification. Currently supported for 'cat_dir()' and
'gaussian()' model families. Computation-reliability tradeoff can
be controlled with 'iter' argument.
- '&quot;em_boot&quot;': Bootstrapped version of EM algorithm. Number of bootstrap
replicates controlled by 'iter' parameter. Provides approximate uncertainty
quantification. Currently supported for 'cat_dir()' and
'gaussian()' model families.</p>
</td></tr>
<tr><td><code id="birdie_+3A_iter">iter</code></td>
<td>
<p>The number of post-warmup Gibbs samples, or the number of
bootstrap replicates to use to compute approximate standard errors for the
main model estimates. Only available when 'family=cat_dir()' or
'gaussian()'. Ignored if 'algorithm=&quot;em&quot;'.
</p>
<p>For bootstrapping, when there are fewer than 1,000 individuals or 100 or
fewer replicates, a Bayesian bootstrap is used instead (i.e., weights are
drawn from a <code class="reqn">\text{Dirichlet}(1, 1, ..., 1)</code> distribution, which
produces more reliable estimates.</p>
</td></tr>
<tr><td><code id="birdie_+3A_warmup">warmup</code></td>
<td>
<p>Number of warmup iterations for Gibbs sampling.
Ignored unless 'algorithm=&quot;gibbs&quot;'.</p>
</td></tr>
<tr><td><code id="birdie_+3A_prefix">prefix</code></td>
<td>
<p>If 'r_probs' is a data frame, the columns containing racial
probabilities will be selected as those with names starting with 'prefix'.
The default will work with the output of [bisg()].</p>
</td></tr>
<tr><td><code id="birdie_+3A_ctrl">ctrl</code></td>
<td>
<p>A list containing control parameters for the EM algorithm and
optimization routines. A list in the proper format can be made using
[birdie.ctrl()].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, 'birdie()' uses an expectation-maximization (EM) routine to find
the maximum *a posteriori* (MAP) estimate for the specified model. Asymptotic
variance-covariance matrices for the MAP estimate are available for the
Categorical-Dirichlet and Normal linear models via bootstrapping.
Full Bayesian inference is supported via Gibbs sampling for the
Categorical-Dirichlet and Normal linear models as well.
</p>
<p>Whatever model or method is used, a finite-population estimate of the
outcome-given-race distribution for the entire observed sample is always
calculated and stored as '$est' in the returned object, which can be accessed
with [coef.birdie()] as well.
</p>
<p>The Categorical-Dirichlet model is specified as follows: </p>
<p style="text-align: center;"><code class="reqn">
    Y_i \mid R_i, X_i, \Theta \sim \text{Categorical}(\theta_{R_iX_i}) \\
    \theta_{rx} \sim \text{Dirichlet}(\alpha_r),
</code>
</p>
<p> where <code class="reqn">Y</code> is the outcome variable, <code class="reqn">R</code> is race, <code class="reqn">X</code> are
covariates (fixed effects), and <code class="reqn">\theta_{rx}</code> and <code class="reqn">\alpha_r</code> are
vectors with length matching the number of levels of the outcome variable.
There is one vector <code class="reqn">\theta_{rx}</code> for every combination of race and
covariates, hence the need for 'formula' to either have no covariates or a
fully interacted structure.
</p>
<p>The Categorical mixed-effects model is specified as follows: </p>
<p style="text-align: center;"><code class="reqn">
    Y_i \mid R_i, X_i, \Theta \sim \text{Categorical}(g^{-1}(\mu_{R_iX_i})) \\
    \mu_{rxy} = W\beta_{ry} + Zu_{ry} \\
    u_{r} \mid \vec\sigma_{r}, L_r \sim \mathcal{N}(0,
     \text{diag}(\vec\sigma_{r})C_r\text{diag}(\vec\sigma_{r})) \\
    \beta_{ry} \sim \mathcal{N}(0, s^2_{r\beta}) \\
    \sigma_{ry} \sim \text{Inv-Gamma}(4, 3s_{r\sigma}) \\
    C_r \sim \text{LKJ}(2),
</code>
</p>
<p> where <code class="reqn">\beta_{ry}</code> are the fixed effects, <code class="reqn">u_{ry}</code> is the random
intercept, and <code class="reqn">g</code> is a softmax link function.
Estimates for <code class="reqn">\beta_{ry}</code> and <code class="reqn">\sigma_{ry}</code> are stored in the
'$beta' and '$sigma' elements of the fitted model object.
</p>
<p>The Normal linear model is specified as follows: </p>
<p style="text-align: center;"><code class="reqn">
    Y_i \mid R_i, \vec X_i, \Theta \sim \mathcal{N}(\vec X_i^\top\vec\theta, \sigma^2) \\
    \sigma^2 \sim \text{Inv-Gamma}(n_\sigma/2, l_\sigma^2 n_\sigma/2) \\
    \beta_{\text{intercept}} \sim \mathcal{N}(0, s^2_\text{int}) \\
    \beta_k \sim \mathcal{N}(0, s^2_\beta), \\
</code>
</p>
<p> where <code class="reqn">\vec\theta</code> is a vector of linear model coefficients.
Estimates for <code class="reqn">\theta</code> and <code class="reqn">\sigma</code> are stored in the
'$beta' and '$sigma' elements of the fitted model object.
</p>
<p>More details on the models and their properties may be found in the paper
referenced below.
</p>


<h3>Value</h3>

<p>An object of class ['birdie'][birdie::birdie-class], for which many
methods are available. The model estimates may be accessed with
[coef.birdie()], and updated BISG probabilities (conditioning on the
outcome) may be accessed with [fitted.birdie()]. Uncertainty estimates, if
available, can be accessed with '$se' and [vcov.birdie()].
</p>


<h3>References</h3>

<p>McCartan, C., Fisher, R., Goldin, J., Ho, D.E., &amp; Imai, K. (2024).
Estimating Racial Disparities when Race is Not Observed.
Available at <a href="https://www.nber.org/papers/w32373">https://www.nber.org/papers/w32373</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pseudo_vf)

r_probs = bisg(~ nm(last_name) + zip(zip), data=pseudo_vf)

# Process zip codes to remove missing values
pseudo_vf$zip = proc_zip(pseudo_vf$zip)

fit = birdie(r_probs, turnout ~ 1, data=pseudo_vf)
print(fit)
fit$se # uncertainty quantification

fit = birdie(r_probs, turnout ~ zip, data=pseudo_vf, algorithm="gibbs")

fit = birdie(r_probs, turnout ~ (1 | zip), data=pseudo_vf,
             family=cat_mixed(), ctrl=birdie.ctrl(abstol=1e-3))

summary(fit)
coef(fit)
fitted(fit)


</code></pre>

<hr>
<h2 id='birdie-class'>Class &quot;birdie&quot; of BIRDiE Models</h2><span id='topic+birdie-class'></span><span id='topic+coef.birdie'></span><span id='topic+fitted.birdie'></span><span id='topic+residuals.birdie'></span><span id='topic+predict.birdie'></span><span id='topic+simulate.birdie'></span><span id='topic+plot.birdie'></span><span id='topic+tidy.birdie'></span><span id='topic+glance.birdie'></span><span id='topic+augment.birdie'></span><span id='topic+formula.birdie'></span><span id='topic+family.birdie'></span><span id='topic+nobs.birdie'></span><span id='topic+vcov.birdie'></span><span id='topic+print.birdie'></span><span id='topic+summary.birdie'></span>

<h3>Description</h3>

<p>The output of [birdie()] is an object of class 'birdie', which supports
many generic functions. Notably 'coef.birdie()' returns the main model
estimates of outcome given race, and 'fitted.birdie()' returns a table
analogous to the output of [bisg()] with updated race probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'birdie'
coef(object, subgroup = FALSE, ...)

## S3 method for class 'birdie'
fitted(object, ...)

## S3 method for class 'birdie'
residuals(object, x_only = FALSE, ...)

## S3 method for class 'birdie'
predict(object, adj = NULL, ...)

## S3 method for class 'birdie'
simulate(object, nsim = 1, seed = NULL, ...)

## S3 method for class 'birdie'
plot(x, log = FALSE, ...)

## S3 method for class 'birdie'
tidy(x, subgroup = FALSE, ...)

## S3 method for class 'birdie'
glance(x, ...)

## S3 method for class 'birdie'
augment(x, data, ...)

## S3 method for class 'birdie'
formula(x, ...)

## S3 method for class 'birdie'
family(object, ...)

## S3 method for class 'birdie'
nobs(object, ...)

## S3 method for class 'birdie'
vcov(object, ...)

## S3 method for class 'birdie'
print(x, ...)

## S3 method for class 'birdie'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="birdie-class_+3A_object">object</code>, <code id="birdie-class_+3A_x">x</code></td>
<td>
<p>A 'birdie' model object</p>
</td></tr>
<tr><td><code id="birdie-class_+3A_subgroup">subgroup</code></td>
<td>
<p>If 'TRUE', return subgroup-level (rather than marginal)
coefficient estimates as a 3D array.</p>
</td></tr>
<tr><td><code id="birdie-class_+3A_...">...</code></td>
<td>
<p>Potentially further arguments passed from other methods</p>
</td></tr>
<tr><td><code id="birdie-class_+3A_x_only">x_only</code></td>
<td>
<p>if 'TRUE', calculate fitted values using covariates only (i.e.,
without using surnames).</p>
</td></tr>
<tr><td><code id="birdie-class_+3A_adj">adj</code></td>
<td>
<p>A point in the simplex that describes how BISG probabilities
will be thresholded to produce point predictions. The probabilities are
divided by 'adj', then the racial category with the highest probability is
predicted. Can be used to trade off types of prediction error. Must be
nonnegative but will be normalized to sum to 1. The default is to make no
adjustment.</p>
</td></tr>
<tr><td><code id="birdie-class_+3A_nsim">nsim</code></td>
<td>
<p>The number of vectors to simulate. Defaults to 1.</p>
</td></tr>
<tr><td><code id="birdie-class_+3A_seed">seed</code></td>
<td>
<p>Used to seed the random number generator. See [stats::simulate()].</p>
</td></tr>
<tr><td><code id="birdie-class_+3A_log">log</code></td>
<td>
<p>If 'TRUE', plot estimated probabilities on a log scale.</p>
</td></tr>
<tr><td><code id="birdie-class_+3A_data">data</code></td>
<td>
<p>A data frame to augment with 'Pr(R | Y, X, S)' probabilities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internal structure of 'birdie' objects is not designed to be accessed
directly. The generics listed here should be used instead.
</p>


<h3>Value</h3>

<p>Varies, depending on the method. See generic functions' documentation
for details.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>coef(birdie)</code>: Return estimated outcome-given-race distributions.
When 'subgroup=FALSE' this always returns a finite-population estimate of
the outcome-given-race distribution for the observed sample.
</p>
</li>
<li> <p><code>fitted(birdie)</code>: Return an updated race probability table. [bisg()]
estimates 'Pr(R | G, X, S)'; this table is 'Pr(R | Y, G, X, S, Theta-hat)'.
</p>
</li>
<li> <p><code>residuals(birdie)</code>: Return the residuals for the outcome variable as a
matrix. Useful in sensitivity analyses and to get an idea of how well race,
location, names, etc. predict the outcome.
</p>
</li>
<li> <p><code>predict(birdie)</code>: Create point predictions of individual race. Returns
factor vector of individual race labels. Strongly not recommended for any
kind of inferential purpose, as biases may be extreme and in unpredictable
directions.
</p>
</li>
<li> <p><code>simulate(birdie)</code>: Simulate race from the posterior distribution
'Pr(R | Y, G, X, S, Theta-hat)'. Does not account for uncertainty in model
parameters.
</p>
</li>
<li> <p><code>plot(birdie)</code>: Visualize the estimated conditional distributions
for a BIRDiE model. If available, marginal standard error estimates ('$se')
will be visualized with 95
</p>
</li>
<li> <p><code>tidy(birdie)</code>: Put BIRDiE model coefficients in a tidy format.
</p>
</li>
<li> <p><code>glance(birdie)</code>: Glance at a BIRDiE model.
</p>
</li>
<li> <p><code>augment(birdie)</code>: Augment data with individual race predictions from a BIRDiE model.
</p>
</li>
<li> <p><code>formula(birdie)</code>: Extract the formula used to specify a BIRDiE model.
</p>
</li>
<li> <p><code>family(birdie)</code>: Return the BIRDiE complete-data model family.
</p>
</li>
<li> <p><code>nobs(birdie)</code>: Return the number of observations used to fit a BIRDiE model.
</p>
</li>
<li> <p><code>vcov(birdie)</code>: Return the estimated variance-covariance matrix for
the BIRDiE model estimates, if available.
</p>
</li>
<li> <p><code>print(birdie)</code>: Print a summary of the model fit.
</p>
</li>
<li> <p><code>summary(birdie)</code>: Print a more detailed summary of the model fit.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>methods(class="birdie")

</code></pre>

<hr>
<h2 id='birdie-family'>BIRDiE Complete-Data Model Families</h2><span id='topic+birdie-family'></span><span id='topic+cat_dir'></span><span id='topic+cat_mixed'></span>

<h3>Description</h3>

<p>BIRDiE supports a number of complete-data outcome models, including
categorical regression models. Models specific to BIRDiE are listed here.
See the Details section of [birdie()] for more information about each
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_dir(link = "identity")

cat_mixed(link = "softmax")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="birdie-family_+3A_link">link</code></td>
<td>
<p>The link function. Only one option available for categorical
regression models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class 'family' containing the specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat_dir()
cat_mixed()

</code></pre>

<hr>
<h2 id='birdie.ctrl'>Control of BIRDiE Model Fitting</h2><span id='topic+birdie.ctrl'></span>

<h3>Description</h3>

<p>Constructs control parameters for BIRDiE model fitting.
All arguments have defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>birdie.ctrl(
  abstol = 1e-06,
  reltol = 1e-06,
  max_iter = 1000,
  fix_sigma = FALSE,
  accel = c("squarem", "anderson", "daarem", "none"),
  order = switch(match.arg(accel), none = 0L, anderson = -1L, daarem = -1L, squarem = 1L),
  anderson_restart = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="birdie.ctrl_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance used in checking convergence or in
estimating linear model coefficients.</p>
</td></tr>
<tr><td><code id="birdie.ctrl_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance used in checking convergence.
Ignored if 'accel = &quot;squarem&quot;' or '&quot;daarem&quot;'.</p>
</td></tr>
<tr><td><code id="birdie.ctrl_+3A_max_iter">max_iter</code></td>
<td>
<p>The maximum number of EM iterations.</p>
</td></tr>
<tr><td><code id="birdie.ctrl_+3A_fix_sigma">fix_sigma</code></td>
<td>
<p>If 'TRUE' when 'model=gaussian()', fix sigma to an initial
estimate, in order to avoid estimation collapse when the outcomes are
discrete.</p>
</td></tr>
<tr><td><code id="birdie.ctrl_+3A_accel">accel</code></td>
<td>
<p>The acceleration algorithm to use in doing EM. The default
'&quot;squarem&quot;' is good for most purposes, though '&quot;anderson&quot;' may be faster
when there are few parameters or very tight tolerances. '&quot;daarem&quot;' is an
excellent choice as well that works across a range of problems, though it
requires installing the small 'daarem' package. '&quot;none&quot;' is not
recommended unless other algorithms are running into numerical issues.
See the references below for details on these schemes.</p>
</td></tr>
<tr><td><code id="birdie.ctrl_+3A_order">order</code></td>
<td>
<p>The order to use in the acceleration algorithm. Interpretation
varies by algorithm. Can range from 1 (default) to 3 for SQUAREM and from 1
to the number of parameters for Anderson and DAAREM (default -1 allows the
order to be determined by problem size).</p>
</td></tr>
<tr><td><code id="birdie.ctrl_+3A_anderson_restart">anderson_restart</code></td>
<td>
<p>Whether to use restarts in Anderson acceleration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the control parameters.
</p>


<h3>References</h3>

<p>Varadhan, R., &amp; Roland, C. (2004). Squared extrapolation methods (SQUAREM): A
new class of simple and efficient numerical schemes for accelerating the
convergence of the EM algorithm.
</p>
<p>Walker, H. F., &amp; Ni, P. (2011). Anderson acceleration for fixed-point
iterations. SIAM Journal on Numerical Analysis, 49(4), 1715-1735.
</p>
<p>Henderson, N. C., &amp; Varadhan, R. (2019). Damped Anderson acceleration with
restarts and monotonicity control for accelerating EM and EM-like algorithms.
Journal of Computational and Graphical Statistics, 28(4), 834-846.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(birdie.ctrl(max_iter=100))

</code></pre>

<hr>
<h2 id='bisg'>Bayesian Improved Surname Geocoding (BISG)</h2><span id='topic+bisg'></span><span id='topic+bisg_me'></span><span id='topic+summary.bisg'></span><span id='topic+predict.bisg'></span><span id='topic+simulate.bisg'></span>

<h3>Description</h3>

<p>Calculates individual probabilities of belonging to racial groups given last
name, location, and other covariates (optional). The standard function
'bisg()' treats the input tables as fixed. An alternative function
'bisg_me()', assumes that the input tables are subject to measurement error,
and uses a Gibbs sampler to impute the individual race probabilities, using
the model of Imai et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bisg(
  formula,
  data = NULL,
  p_r = p_r_natl(),
  p_rgx = NULL,
  p_rs = NULL,
  save_rgx = TRUE
)

bisg_me(
  formula,
  data = NULL,
  p_r = p_r_natl(),
  p_rgx = NULL,
  p_rs = NULL,
  iter = 1000,
  warmup = 100,
  cores = 1L
)

## S3 method for class 'bisg'
summary(object, p_r = NULL, ...)

## S3 method for class 'bisg'
predict(object, adj = NULL, ...)

## S3 method for class 'bisg'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bisg_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the BISG model. Must include the special
term 'nm()' to identify the surname variable. Certain geographic variables
can be identified similarly: 'zip()' for ZIP codes, and 'state()' for
states. If no other predictor variables are provided, then 'bisg()' will
automatically be able to build a table of census data to use in inference.
If other predictor variables are included, or if other geographic
identifiers are used, then the user must specify the 'p_rgx' argument below.
The left-hand side of the formula is ignored.
See the examples section below for sample formulas.</p>
</td></tr>
<tr><td><code id="bisg_+3A_data">data</code></td>
<td>
<p>The data frame containing the variables in 'formula'.</p>
</td></tr>
<tr><td><code id="bisg_+3A_p_r">p_r</code></td>
<td>
<p>The prior distribution of race in the sample, as a numeric vector.
Defaults to U.S. demographics as provided by [p_r_natl()].
Can also set 'p_r=&quot;est&quot;' or '&quot;estimate&quot;' to estimate this from the
geographic distribution.  Since the prior distribution on race strongly
affects the calibration of the BISG probabilities and thus the accuracy of
downstream estimates, users are encouraged to think carefully about an
appropriate value for 'p_r'.  If no prior information on the racial makeup
of the sample is available, and yet the sample is very different from the
overall U.S. population, then 'p_r=&quot;estimate&quot;' will likely produce superior
results.</p>
</td></tr>
<tr><td><code id="bisg_+3A_p_rgx">p_rgx</code></td>
<td>
<p>The distribution of race given location (G) and other covariates
(X) specified in 'formula'. Should be provided as a data frame, with columns
matching the predictors in 'formula', and additional columns for each
racial group containing the conditional probability for that racial group
given the predictors. For example, if Census tracts are the only predictors,
'p_rgx' should be a data frame with a tract column and columns 'white',
'black', etc. containing the racial distribution of each tract.
If 'formula' contains only labeled terms (like 'zip()'), then by default
'p_rgx' will be constructed automatically from the most recent Census data.
This table will be normalized by row, so it can be provided as population
counts as well. Counts are required for 'bisg_me()'.
The [census_race_geo_table()] function can be helpful to prepare tables,
as can be the 'build_dec()' and 'build_acs()' functions in the 'censable'
package.</p>
</td></tr>
<tr><td><code id="bisg_+3A_p_rs">p_rs</code></td>
<td>
<p>The distribution of race given last name. As with 'p_rgx', should
be provided as a data frame, with a column of names and additional columns
for each racial group. Users should not have to specify this argument in
most cases, as the table will be built from published Census surname tables
automatically. Counts are required for 'bisg_me()'.</p>
</td></tr>
<tr><td><code id="bisg_+3A_save_rgx">save_rgx</code></td>
<td>
<p>If 'TRUE', save the 'p_rgx' table (matched to each
individual) as the '&quot;p_rgx&quot;' and '&quot;gx&quot;' attributes of the output.
Necessary for some sensitivity analyses.</p>
</td></tr>
<tr><td><code id="bisg_+3A_iter">iter</code></td>
<td>
<p>How many sampling iterations in the Gibbs sampler</p>
</td></tr>
<tr><td><code id="bisg_+3A_warmup">warmup</code></td>
<td>
<p>How many burn-in iterations in the Gibbs sampler</p>
</td></tr>
<tr><td><code id="bisg_+3A_cores">cores</code></td>
<td>
<p>How many parallel cores to use in computation. Around 4 seems to
be optimal, even if more are available.</p>
</td></tr>
<tr><td><code id="bisg_+3A_object">object</code></td>
<td>
<p>An object of class 'bisg', the result of running [bisg()].</p>
</td></tr>
<tr><td><code id="bisg_+3A_...">...</code></td>
<td>
<p>Additional arguments to generic methods (ignored).</p>
</td></tr>
<tr><td><code id="bisg_+3A_adj">adj</code></td>
<td>
<p>A point in the simplex that describes how BISG probabilities
will be thresholded to produce point predictions. The probabilities are
divided by 'adj', then the racial category with the highest probability is
predicted. Can be used to trade off types of prediction error. Must be
nonnegative but will be normalized to sum to 1. The default is to make no
adjustment.</p>
</td></tr>
<tr><td><code id="bisg_+3A_nsim">nsim</code></td>
<td>
<p>The number of vectors to simulate. Defaults to 1.</p>
</td></tr>
<tr><td><code id="bisg_+3A_seed">seed</code></td>
<td>
<p>Used to seed the random number generator. See [stats::simulate()].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'bisg', which is just a data frame with some
additional attributes. The data frame has rows matching the input data and
columns for the race probabilities.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>summary(bisg)</code>: Summarize predicted race probabilities. Returns vector of individual entropies.
</p>
</li>
<li> <p><code>predict(bisg)</code>: Create point predictions of individual race. Returns factor
vector of individual race labels. Strongly not recommended for any kind of
inferential purpose, as biases may be extreme and in unpredictable
directions.
</p>
</li>
<li> <p><code>simulate(bisg)</code>: Simulate race from the 'Pr(R | G, X, S)' distribution.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>bisg()</code>: The standard BISG model.
</p>
</li>
<li> <p><code>bisg_me()</code>: The measurement error BISG model.
</p>
</li></ul>


<h3>References</h3>

<p>Elliott, M. N., Fremont, A., Morrison, P. A., Pantoja, P., and Lurie, N.
(2008). A new method for estimating race/ethnicity and associated disparities
where administrative records lack self-reported race/ethnicity. *Health
Services Research*, 43(5p1):1722–1736.
</p>
<p>Fiscella, K. and Fremont, A. M. (2006). Use of geocoding and surname analysis
to estimate race and ethnicity. *Health Services Research*,
41(4p1):1482–1500.
</p>
<p>Imai, K., Olivella, S., &amp; Rosenman, E. T. (2022). Addressing census data
problems in race imputation via fully Bayesian Improved Surname Geocoding and
name supplements. *Science Advances*, 8(49), eadc9824.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pseudo_vf)
bisg(~ nm(last_name), data=pseudo_vf)

r_probs = bisg(~ nm(last_name) + zip(zip), data=pseudo_vf)
summary(r_probs)
head(predict(r_probs))

data(pseudo_vf)
bisg_me(~ nm(last_name) + zip(zip), data=pseudo_vf)
</code></pre>

<hr>
<h2 id='census_race_geo_table'>Download Census Race Data</h2><span id='topic+census_race_geo_table'></span>

<h3>Description</h3>

<p>Downloads and prepares race-by-geography tables from U.S. census data, using
the ['easycensus'][easycensus::easycensus] package. Requires that an api key
be set up through [easycensus::cens_auth()] in that package, usually by
storing it in the 'CENSUS_API_KEY' environment variable. Supports data from
the decennial census and the American Community Survey at a variety of levels
of geographic detail. The output of this function can be used directly in
[bisg()].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>census_race_geo_table(
  geo = c("us", "state", "county", "zcta", "tract"),
  ...,
  year = 2010,
  survey = c("dec", "acs1", "acs5"),
  GEOIDs = TRUE,
  counts = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="census_race_geo_table_+3A_geo">geo</code></td>
<td>
<p>The geographic level to return. Common options are listed in the
function signature, but any of the geographies listed at
[easycensus::cens_geo()] may be used.</p>
</td></tr>
<tr><td><code id="census_race_geo_table_+3A_...">...</code></td>
<td>
<p>Further subgeographies to return, as in [easycensus::cens_geo()].</p>
</td></tr>
<tr><td><code id="census_race_geo_table_+3A_year">year</code></td>
<td>
<p>The year for the data</p>
</td></tr>
<tr><td><code id="census_race_geo_table_+3A_survey">survey</code></td>
<td>
<p>The data product to use: either the decennial census ('&quot;dec&quot;'),
or the the 1-year or 5-year ACS.</p>
</td></tr>
<tr><td><code id="census_race_geo_table_+3A_geoids">GEOIDs</code></td>
<td>
<p>If 'TRUE', return the 'GEOID' column as the unique geographic
identifier; if 'FALSE', return a human-readable name. For example, with
'geo=&quot;state&quot;', setting 'GEOIDs=FALSE' will return a column named 'state'
with entries like '&quot;Massachusetts&quot;'.</p>
</td></tr>
<tr><td><code id="census_race_geo_table_+3A_counts">counts</code></td>
<td>
<p>If 'TRUE', return the table as actual population counts; if
'FALSE', return table as percentages within each geography.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with geographic identifier column(s) and six columns
'white', 'black', etc. containing the counts or proportion of
residents in each racial group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>census_race_geo_table("zcta", year=2010)
## Not run: 
# Census API key required
census_race_geo_table("us", year=2010)
census_race_geo_table("state", year=2021, survey="acs1")
census_race_geo_table("state", year=2021, survey="acs1", GEOIDs=FALSE) 
## End(Not run)
</code></pre>

<hr>
<h2 id='disparities'>Compute Racial Disparities from Model Estimates</h2><span id='topic+disparities'></span>

<h3>Description</h3>

<p>This function lets you easily compute differences in conditional expectations
between all pairs of specified racial groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disparities(x, subgroup = FALSE, races = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disparities_+3A_x">x</code></td>
<td>
<p>A 'birdie' model object.</p>
</td></tr>
<tr><td><code id="disparities_+3A_subgroup">subgroup</code></td>
<td>
<p>If 'TRUE', return subgroup-level (rather than marginal)
disparity estimates.</p>
</td></tr>
<tr><td><code id="disparities_+3A_races">races</code></td>
<td>
<p>A character vector of racial groups to compute disparities for.
The special value 'TRUE', the default, computes disparities for all racial
groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing a row with every possible disparity for the
specified 'races', which are identified by columns 'race_1' and 'race_2'.
The reported disparity is 'estimate_1 - estimate_2'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pseudo_vf)
r_probs = bisg(~ nm(last_name) + zip(zip), data=pseudo_vf)
fit = birdie(r_probs, turnout ~ 1, data=pseudo_vf)

disparities(fit)
disparities(fit, races=c("white", "black"))

</code></pre>

<hr>
<h2 id='est_weighted'>Calculate Weighted Estimate of (Discrete) Outcomes By Race</h2><span id='topic+est_weighted'></span><span id='topic+print.est_weighted'></span><span id='topic+summary.est_weighted'></span>

<h3>Description</h3>

<p>Calculates the &quot;standard&quot; weighted estimator of conditional distributions of
an outcome variable <code class="reqn">Y</code> by race <code class="reqn">R</code>, using BISG probabilities.  This
estimator, while commonly used, is only appropriate if <code class="reqn">Y \perp R \mid X, S</code>,
where <code class="reqn">S</code> and <code class="reqn">X</code> are the last names and covariates (possibly
including geography) used in making the BISG probabilities. In most cases
this assumption is not plausible and [birdie()] should be used instead. See
the references below for more discussion as to selecting the right estimator.
</p>
<p>Up to Monte Carlo error, the weighted estimate is equivalent to performing
multiple imputations of the race vector from the BISG probabilities and then
using them inside a weighted average or linear regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_weighted(
  r_probs,
  formula,
  data = NULL,
  weights = NULL,
  prefix = "pr_",
  se_boot = 0
)

## S3 method for class 'est_weighted'
print(x, ...)

## S3 method for class 'est_weighted'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_weighted_+3A_r_probs">r_probs</code></td>
<td>
<p>A data frame or matrix of BISG probabilities, with one row per
individual. The output of [bisg()] can be used directly here.</p>
</td></tr>
<tr><td><code id="est_weighted_+3A_formula">formula</code></td>
<td>
<p>A two-sided formula object describing the estimator structure.
The left-hand side is the outcome variable, which must be discrete.
Subgroups for which to calculate estimates may be specified by adding
covariates on the right-hand side. Subgroup estimates are available with
'coef(..., subgroup=TRUE)' and 'tidy(..., subgroup=TRUE)'.</p>
</td></tr>
<tr><td><code id="est_weighted_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables named in 'formula'.</p>
</td></tr>
<tr><td><code id="est_weighted_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector specifying weights.</p>
</td></tr>
<tr><td><code id="est_weighted_+3A_prefix">prefix</code></td>
<td>
<p>If 'r_probs' is a data frame, the columns containing racial
probabilities will be selected as those with names starting with 'prefix'.
The default will work with the output of [bisg()].</p>
</td></tr>
<tr><td><code id="est_weighted_+3A_se_boot">se_boot</code></td>
<td>
<p>The number of bootstrap replicates to use to compute
an approximate covariance matrix for the estimator. If no bootstrapping is
used, an analytical estimate of standard errors will be returned as '$se'.
For bootstrapping, when there are fewer than 1,000 individuals or 100 or
fewer replicates, a Bayesian bootstrap is used instead (i.e., weights are
drawn from a <code class="reqn">\text{Dirichlet}(1, 1, ..., 1)</code> distribution, which
produces more reliable estimates.</p>
</td></tr>
<tr><td><code id="est_weighted_+3A_...">...</code></td>
<td>
<p>Additional arguments to generic methods (ignored).</p>
</td></tr>
<tr><td><code id="est_weighted_+3A_object">object</code>, <code id="est_weighted_+3A_x">x</code></td>
<td>
<p>An object of class 'est_weighted'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'est_weighted', inheriting from
['birdie'][birdie::birdie-class], for which many methods are available. The
model estimates may be accessed with 'coef()'. Uncertainty estimates, if
available, can be accessed with '$se' and [vcov.birdie()].
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(est_weighted)</code>: Print a summary of the model fit.
</p>
</li>
<li> <p><code>summary(est_weighted)</code>: Print a more detailed summary of the model fit.
</p>
</li></ul>


<h3>References</h3>

<p>McCartan, C., Fisher, R., Goldin, J., Ho, D.E., &amp; Imai, K. (2024).
Estimating Racial Disparities when Race is Not Observed.
Available at <a href="https://www.nber.org/papers/w32373">https://www.nber.org/papers/w32373</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pseudo_vf)

r_probs = bisg(~ nm(last_name) + zip(zip), data=pseudo_vf)

# Process zip codes to remove missing values
pseudo_vf$zip = proc_zip(pseudo_vf$zip)

est_weighted(r_probs, turnout ~ 1, data=pseudo_vf)

est = est_weighted(r_probs, turnout ~ zip, data=pseudo_vf)
tidy(est, subgroup=TRUE)

</code></pre>

<hr>
<h2 id='p_r_natl'>National Racial Demographics</h2><span id='topic+p_r_natl'></span>

<h3>Description</h3>

<p>Returns the proportion of the U.S. population in six racial groups in a given
year. Group definitions necessarily follow those used by the Census Bureau in
its surname tables:
* 'white': Non-Hispanic White alone
* 'black': Non-Hispanic Black alone
* 'hisp': Hispanic, any race
* 'asian': Non-Hispanic Asian, Native Hawaiian, or Pacific Islander alone
* 'aian': Non-Hispanic American Indian/Alaska Native
* 'other': Non-Hispanic, two or more races, or other race
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_r_natl(year = 2021, vap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_r_natl_+3A_year">year</code></td>
<td>
<p>The year to return demographics for.</p>
</td></tr>
<tr><td><code id="p_r_natl_+3A_vap">vap</code></td>
<td>
<p>If 'TRUE', return statistics for the voting-age population (18+)
rather than the full U.S. population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector of length 6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p_r_natl(year=2010)

</code></pre>

<hr>
<h2 id='preproc'>Preprocess Last Names and Geographic Identifiers</h2><span id='topic+preproc'></span><span id='topic+proc_zip'></span><span id='topic+proc_state'></span><span id='topic+proc_name'></span>

<h3>Description</h3>

<p>These functions are called automatically by [bisg()] but may be useful,
especially when geographic variables are included in a [birdie()] model.
'proc_zip()' and 'proc_state()' preprocess their corresponding geographic
identifiers. States are partially matched to state names and abbreviations
and are returned as FIPS codes. ZIP codes are crosswalked to Census ZCTAs.
Missing identifiers are replaced with '&quot;&lt;none&gt;&quot;'.
'proc_name()' processes last names in accordance with Census processing rules
(&lt;https://www2.census.gov/topics/genealogy/2010surnames/surnames.pdf&gt;).
Names are converted to Latin characters, capitalized, stripped of prefixes
and suffixes, and otherwise standardized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proc_zip(x)

proc_state(x)

proc_name(x, to_latin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preproc_+3A_x">x</code></td>
<td>
<p>A character vector of names or geographic identifiers to process</p>
</td></tr>
<tr><td><code id="preproc_+3A_to_latin">to_latin</code></td>
<td>
<p>If 'TRUE', convert names to Latin characters only. Strongly
recommended if non-Latin characters are present, since these will not match
Census tables. However, the conversion is slightly time-consuming and so
can be disabled with this flag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A processed character vector
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>proc_zip()</code>: Match ZIP codes to ZCTAs and fill in missing values.
</p>
</li>
<li> <p><code>proc_state()</code>: Match state names and abbreviations and fill in missing values.
</p>
</li>
<li> <p><code>proc_name()</code>: Process names to a Census-standardized format.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>proc_name("Smith Jr.")
proc_zip("00501")
proc_state("Washington")
</code></pre>

<hr>
<h2 id='pseudo_vf'>A pseudo-voterfile</h2><span id='topic+pseudo_vf'></span>

<h3>Description</h3>

<p>A dataset containing 5,000 fake voter records.
Created by randomizing a subset of the North Carolina voter file.
Turnout records are completely randomly generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_vf
</code></pre>


<h3>Format</h3>

<p>A data frame with 5,000 rows and 4 records:
</p>

<dl>
<dt>last_name</dt><dd><p>Voter's last name</p>
</dd>
<dt>zip</dt><dd><p>5-digit ZIP code. May be NA</p>
</dd>
<dt>race</dt><dd><p>One of &quot;white&quot;, &quot;black&quot;, &quot;hisp&quot;, &quot;asian&quot;, &quot;aian&quot;, or &quot;other&quot;</p>
</dd>
<dt>turnout</dt><dd><p>1 if the voter voted in the most recent election, 0 otherwise</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.ncsbe.gov/results-data/voter-registration-data">https://www.ncsbe.gov/results-data/voter-registration-data</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pseudo_vf)
print(pseudo_vf)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+glance'></span><span id='topic+augment'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code>, <code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
