<!DOCTYPE html><html lang="en"><head><title>Help for package sbfc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sbfc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sbfc-package'>
<p>Selective Bayesian Forest Classifier</p></a></li>
<li><a href='#corral_augmented'><p>Augmented corral data set: synthetic data with correlated attributes augmented with noise features</p></a></li>
<li><a href='#data_disc'><p>Data set discretization and formatting</p></a></li>
<li><a href='#edge_density_plot'><p>Plots the density of edges in a given group over the MCMC iterations</p></a></li>
<li><a href='#heart'><p>Heart disease data set: disease outcomes given health attributes</p></a></li>
<li><a href='#logposterior_plot'><p>Log posterior  plot</p></a></li>
<li><a href='#madelon'><p>Madelon data set: synthetic data from NIPS 2003 feature selection challenge</p></a></li>
<li><a href='#sbfc'><p>Selective Bayesian Forest Classifier (SBFC) algorithm</p></a></li>
<li><a href='#sbfc_graph'><p>SBFC graph</p></a></li>
<li><a href='#signal_size_plot'><p>Trace plot of Group 1 size</p></a></li>
<li><a href='#signal_var_proportion'><p>Signal variable proportion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Selective Bayesian Forest Classifier</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-01-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Viktoriya Krakovna</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Viktoriya Krakovna &lt;vkrakovna@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/vkrakovna/sbfc">https://github.com/vkrakovna/sbfc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vkrakovna/sbfc/issues">https://github.com/vkrakovna/sbfc/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>An MCMC algorithm for simultaneous feature selection and classification, 
    and visualization of the selected features and feature interactions. 
    An implementation of SBFC by Krakovna, Du and Liu (2015), &lt;<a href="https://doi.org/10.48550/arXiv.1506.02371">doi:10.48550/arXiv.1506.02371</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), DiagrammeR</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.2), Matrix, discretization</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-15 16:25:22 UTC; vkrakovna</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-15 17:02:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='sbfc-package'>
Selective Bayesian Forest Classifier
</h2><span id='topic+sbfc-package'></span>

<h3>Description</h3>

<p>An MCMC algorithm for simultaneous feature selection and classification, 
    and visualization of the selected features and feature interactions. 
    An implementation of SBFC by Krakovna, Du and Liu (2015), &lt;arXiv:1506.02371&gt;.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> sbfc</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Selective Bayesian Forest Classifier</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-01-15</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Viktoriya Krakovna</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Viktoriya Krakovna &lt;vkrakovna@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/vkrakovna/sbfc</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/vkrakovna/sbfc/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> An MCMC algorithm for simultaneous feature selection and classification, 
    and visualization of the selected features and feature interactions. 
    An implementation of SBFC by Krakovna, Du and Liu (2015), &lt;arXiv:1506.02371&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.10), DiagrammeR</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 0.12.2),
Matrix,
discretization</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp, RcppArmadillo</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> true</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
corral_augmented        Augmented corral data set: synthetic data with
                        correlated attributes augmented with noise
                        features
data_disc               Data set discretization and formatting
edge_density_plot       Plots the density of edges in a given group
                        over the MCMC iterations
heart                   Heart disease data set: disease outcomes given
                        health attributes
logposterior_plot       Log posterior plot
madelon                 Madelon data set: synthetic data from NIPS 2003
                        feature selection challenge
sbfc                    Selective Bayesian Forest Classifier (SBFC)
                        algorithm
sbfc-package            Selective Bayesian Forest Classifier
sbfc_graph              SBFC graph
signal_size_plot        Trace plot of Group 1 size
signal_var_proportion   Signal variable proportion
</pre>
<p>Run the SBFC algorithm on a data set using the <code>sbfc</code> function.
Make SBFC graphs based on the MCMC samples using the <code>sbfc_graph</code> function.
Other analysis, e.g. feature selection plots using <code>signal_var_proportion</code> (based on how often each variable appeared in the signal group).</p>


<h3>Author(s)</h3>

<p>Viktoriya Krakovna
Maintainer: Viktoriya Krakovna &lt;vkrakovna@gmail.com&gt;
</p>

<hr>
<h2 id='corral_augmented'>Augmented corral data set: synthetic data with correlated attributes augmented with noise features</h2><span id='topic+corral_augmented'></span>

<h3>Description</h3>

<p>This is an artificial domain where the target concept is (X1^X2) V (X3^X4). <br />
Data set from John et al (1994). Training and test splits from SGI. <br />
The first 6 features are the real features from the original corral data set.
The rest are noise features added by V. Krakovna by shuffling copies of real features.<br />
The SBFC paper uses subsets of this data set with the first 100 and 1000 features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(corral_augmented)
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>TrainX</code></dt><dd><p>A matrix with 128 rows and 10000 columns.</p>
</dd>
<dt><code>TrainY</code></dt><dd><p>A vector with 128 rows.</p>
</dd>
</dl>



<h3>References</h3>

<p><a href="https://ai.stanford.edu/~ronnyk/ml94.pdf">John et al (1994) paper introducing the corral data set</a>
</p>
<p><a href="https://arxiv.org/abs/1506.02371">SBFC paper describing augmentation of corral data set</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corral_result = sbfc(data=list(TrainX=corral_augmented$TrainX[,1:6],
                                         TrainY = corral_augmented$TrainY))
corral100_result = sbfc(data=list(TrainX=corral_augmented$TrainX[,1:100], 
                                  TrainY = corral_augmented$TrainY))
</code></pre>

<hr>
<h2 id='data_disc'>Data set discretization and formatting</h2><span id='topic+data_disc'></span>

<h3>Description</h3>

<p>Removes rows containing missing data, and discretizes the data set using Minimum Description Length Partitioning (MDLP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_disc(data, n_train = NULL, missing = "?")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_disc_+3A_data">data</code></td>
<td>
<p>Data frame, where the last column must be the class variable.</p>
</td></tr>
<tr><td><code id="data_disc_+3A_n_train">n_train</code></td>
<td>
<p>Number of data frame rows to use as the training set - the rest are used for the test set. If NULL, all rows are used for training, and there is no test set (default=NULL).</p>
</td></tr>
<tr><td><code id="data_disc_+3A_missing">missing</code></td>
<td>
<p>Label that denotes missing values in your data frame (default='?').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A discretized data set:
</p>
     
<dl>
<dt><code>TrainX</code></dt><dd><p>Matrix containing the training data.</p>
</dd>
<dt><code>TrainY</code></dt><dd><p>Vector containing the class labels for the training data.</p>
</dd>
<dt><code>TestX</code></dt><dd><p>Matrix containing the test data (optional).</p>
</dd>
<dt><code>TestY</code></dt><dd><p>Vector containing the class labels for the test data (optional).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
iris_disc = data_disc(iris)
</code></pre>

<hr>
<h2 id='edge_density_plot'>Plots the density of edges in a given group over the MCMC iterations</h2><span id='topic+edge_density_plot'></span>

<h3>Description</h3>

<p>Plots the edge density for the given group for a range of the MCMC iterations (indicated by <code>start</code> and <code>end</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_density_plot(sbfc_result, group, start = 0, end = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edge_density_plot_+3A_sbfc_result">sbfc_result</code></td>
<td>
<p>An object of class <code>sbfc</code>.</p>
</td></tr>
<tr><td><code id="edge_density_plot_+3A_group">group</code></td>
<td>
<p>Which group (0 or 1) to plot edge density for.</p>
</td></tr>
<tr><td><code id="edge_density_plot_+3A_start">start</code></td>
<td>
<p>The start of the included range of MCMC iterations (default=0, i.e. starting with the first iteration).</p>
</td></tr>
<tr><td><code id="edge_density_plot_+3A_end">end</code></td>
<td>
<p>The end of the included range of MCMC iterations (default=1, i.e. ending with the last iteration).</p>
</td></tr>
</table>

<hr>
<h2 id='heart'>Heart disease data set: disease outcomes given health attributes</h2><span id='topic+heart'></span>

<h3>Description</h3>

<p>Data set from UCI repository, discretized using the <code>mdlp</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(heart)
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>TrainX</code></dt><dd><p>A matrix with 270 rows and 13 columns.</p>
</dd>
<dt><code>TrainY</code></dt><dd><p>A vector with 270 rows.</p>
</dd>
</dl>



<h3>References</h3>

<p><a href="https://archive.ics.uci.edu/ml/datasets/Statlog+(Heart)">UCI heart data set</a>
</p>

<hr>
<h2 id='logposterior_plot'>Log posterior  plot</h2><span id='topic+logposterior_plot'></span>

<h3>Description</h3>

<p>Plots the log posterior for a range of the MCMC iterations (indicated by <code>start</code> and <code>end</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logposterior_plot(sbfc_result, start = 0, end = 1, type = "trace")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logposterior_plot_+3A_sbfc_result">sbfc_result</code></td>
<td>
<p>An object of class <code>sbfc</code>.</p>
</td></tr>
<tr><td><code id="logposterior_plot_+3A_start">start</code></td>
<td>
<p>The start of the included range of MCMC iterations (default=0, i.e. starting with the first iteration).</p>
</td></tr>
<tr><td><code id="logposterior_plot_+3A_end">end</code></td>
<td>
<p>The end of the included range of MCMC iterations (default=1, i.e. ending with the last iteration).</p>
</td></tr>
<tr><td><code id="logposterior_plot_+3A_type">type</code></td>
<td>
<p>Type of plot (either <code>trace</code> or <code>acf</code>, default=<code>trace</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='madelon'>Madelon data set: synthetic data from NIPS 2003 feature selection challenge</h2><span id='topic+madelon'></span>

<h3>Description</h3>

<p>This is a two-class classification problem. 
The difficulty is that the problem is multivariate and highly non-linear. 
Of the 500 features, 20 are real features, 480 are noise features. <br />
Data set from UCI repository, discretized using median cutoffs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(madelon)
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>TrainX</code></dt><dd><p>A matrix with 2000 rows and 500 columns.</p>
</dd>
<dt><code>TrainY</code></dt><dd><p>A vector with 2000 rows.</p>
</dd>
<dt><code>TestX</code></dt><dd><p>A matrix with 600 rows and 500 columns.</p>
</dd>
<dt><code>TestY</code></dt><dd><p>A vector with 600 rows.</p>
</dd>
</dl>



<h3>References</h3>

<p><a href="https://archive.ics.uci.edu/ml/datasets/Madelon">UCI madelon data set</a>
</p>

<hr>
<h2 id='sbfc'>Selective Bayesian Forest Classifier (SBFC) algorithm</h2><span id='topic+sbfc'></span>

<h3>Description</h3>

<p>Runs the SBFC algorithm on a discretized data set. To discretize your data, use the <code><a href="#topic+data_disc">data_disc</a></code> command.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbfc(
  data,
  nstep = NULL,
  thin = 50,
  burnin_denom = 5,
  cv = T,
  thinoutputs = F,
  alpha = 5,
  y_penalty = 1,
  x_penalty = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sbfc_+3A_data">data</code></td>
<td>
<p>Discretized data set:
</p>
     
<dl>
<dt><code>TrainX</code></dt><dd><p>Matrix containing the training data.</p>
</dd>
<dt><code>TrainY</code></dt><dd><p>Vector containing the class labels for the training data.</p>
</dd>
<dt><code>TestX</code></dt><dd><p>Matrix containing the test data (optional).</p>
</dd>
<dt><code>TestY</code></dt><dd><p>Vector containing the class labels for the test data (optional).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sbfc_+3A_nstep">nstep</code></td>
<td>
<p>Number of MCMC steps, default max(10000, 10 * ncol(TrainX)).</p>
</td></tr>
<tr><td><code id="sbfc_+3A_thin">thin</code></td>
<td>
<p>Thinning factor for the MCMC.</p>
</td></tr>
<tr><td><code id="sbfc_+3A_burnin_denom">burnin_denom</code></td>
<td>
<p>Denominator of the fraction of total MCMC steps discarded as burnin (default=5).</p>
</td></tr>
<tr><td><code id="sbfc_+3A_cv">cv</code></td>
<td>
<p>Do cross-validation on the training set (if test set is not provided).</p>
</td></tr>
<tr><td><code id="sbfc_+3A_thinoutputs">thinoutputs</code></td>
<td>
<p>Return thinned MCMC outputs (parents, groups, trees, logposterior), rather than all outputs (default=FALSE).</p>
</td></tr>
<tr><td><code id="sbfc_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet hyperparameter(default=1)</p>
</td></tr>
<tr><td><code id="sbfc_+3A_y_penalty">y_penalty</code></td>
<td>
<p>Prior coefficient for y-edges, which penalizes signal group size (default=1)</p>
</td></tr>
<tr><td><code id="sbfc_+3A_x_penalty">x_penalty</code></td>
<td>
<p>Prior coefficient for x-edges, which penalizes tree size (default=4)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data needs to be discretized before running SBFC. <br />
If the test data matrix TestX is provided, SBFC runs on the entire training set TrainX, and provides predicted class labels for the test data. 
If the test data class vector TestY is provided, the accuracy is computed. 
If the test data matrix TestX is not provided, and cv is set to TRUE, SBFC performs cross-validation on the training data set TrainX, 
and returns predicted classes and accuracy for the training data. <br />
</p>


<h3>Value</h3>

<p>An object of class <code>sbfc</code>:
</p>
     
<dl>
<dt><code>accuracy</code></dt><dd><p>Classification accuracy (on the test set if provided, otherwise cross-validation accuracy on training set).</p>
</dd>
<dt><code>predictions</code></dt><dd><p>Vector of class label predictions (for the test set if provided, otherwise for the training set).</p>
</dd>
<dt><code>probabilities</code></dt><dd><p>Matrix of class label probabilities (for the test set if provided, otherwise for the training set).</p>
</dd>
<dt><code>runtime</code></dt><dd><p>Total runtime of the algorithm in seconds.</p>
</dd>
<dt><code>parents</code></dt><dd><p>Matrix representing the structures sampled by MCMC, where parents[i,j] is the index of the parent of node j at iteration i (0 if node is a root).</p>
</dd>
<dt><code>groups</code></dt><dd><p>Matrix representing the structures sampled by MCMC, where groups[i,j] indicates which group node j belongs to at iteration j (0 is noise, 1 is signal).</p>
</dd>
<dt><code>trees</code></dt><dd><p>Matrix representing the structures sampled by MCMC, where trees[i,j] indicates which tree node j belongs to at iteration j.</p>
</dd>
<dt><code>logposterior</code></dt><dd><p>Vector representing the log posterior at each iteration of the MCMC.</p>
</dd>
<dt>Parameters</dt><dd><p><code>nstep</code>, <code>thin</code>, <code>burnin_denom</code>, <code>cv</code>, <code>thinoutputs</code>, <code>alpha</code>, <code>y_penalty</code>, <code>x_penalty</code>.</p>
</dd>
</dl>

<p>If <code>cv=TRUE</code>, the MCMC samples from the first fold are returned (<code>parents</code>, <code>groups</code>, <code>trees</code>, <code>logposterior</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(madelon)
madelon_result = sbfc(madelon)
data(heart)
heart_result = sbfc(heart, cv=FALSE)
</code></pre>

<hr>
<h2 id='sbfc_graph'>SBFC graph</h2><span id='topic+sbfc_graph'></span>

<h3>Description</h3>

<p>Plots a sampled MCMC graph or an average of sampled graphs using Graphviz. <br />
In average graphs, nodes are color-coded according to importance - the proportion of samples where the node appeared in Group 1 (dark-shaded nodes appear more often).
In average graphs, thickness of edges also corresponds to importance: the proportion of samples where the edge appeared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbfc_graph(
  sbfc_result,
  iter = 10000,
  average = T,
  edge_cutoff = 0.1,
  single_noise_nodes = F,
  labels = paste0("X", 1:ncol(sbfc_result$parents)),
  save_graphviz_code = F,
  colorscheme = "blues",
  ncolors = 7,
  width = NULL,
  height = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sbfc_graph_+3A_sbfc_result">sbfc_result</code></td>
<td>
<p>An object of class <code>sbfc</code>.</p>
</td></tr>
<tr><td><code id="sbfc_graph_+3A_iter">iter</code></td>
<td>
<p>MCMC iteration of the sampled graph to plot, if <code>average=F</code> (default=10000).</p>
</td></tr>
<tr><td><code id="sbfc_graph_+3A_average">average</code></td>
<td>
<p>Plot an average of sampled MCMC graphs (default=TRUE).</p>
</td></tr>
<tr><td><code id="sbfc_graph_+3A_edge_cutoff">edge_cutoff</code></td>
<td>
<p>The average graph includes edges that appear in at least this fraction of the sampled graphs, if <code>average=T</code> (default=0.1).</p>
</td></tr>
<tr><td><code id="sbfc_graph_+3A_single_noise_nodes">single_noise_nodes</code></td>
<td>
<p>Plot single-node trees that appear in the noise group (Group 0) in at least 80 percent of the samples, which can be numerous for high-dimensional data sets (default=FALSE).</p>
</td></tr>
<tr><td><code id="sbfc_graph_+3A_labels">labels</code></td>
<td>
<p>A vector of node labels (default=<code>c("X1","X2",...)</code>).</p>
</td></tr>
<tr><td><code id="sbfc_graph_+3A_save_graphviz_code">save_graphviz_code</code></td>
<td>
<p>Save the Graphviz source code in a .gv file (default=FALSE).</p>
</td></tr>
<tr><td><code id="sbfc_graph_+3A_colorscheme">colorscheme</code></td>
<td>
<p><a href="http://www.graphviz.org/doc/info/colors.html">Graphviz color scheme</a> for the nodes (default=&quot;blues&quot;).</p>
</td></tr>
<tr><td><code id="sbfc_graph_+3A_ncolors">ncolors</code></td>
<td>
<p>number of colors in the palette (default=7).</p>
</td></tr>
<tr><td><code id="sbfc_graph_+3A_width">width</code></td>
<td>
<p>An optional parameter for specifying the width of the resulting graphic in pixels.</p>
</td></tr>
<tr><td><code id="sbfc_graph_+3A_height">height</code></td>
<td>
<p>An optional parameter for specifying the height of the resulting graphic in pixels.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(madelon)
madelon_result = sbfc(madelon)
sbfc_graph(madelon_result) 
sbfc_graph(madelon_result, average=FALSE, iter=5000) # graph for 5000th iteration
sbfc_graph(madelon_result, single_noise_nodes=TRUE) # wide graph with 480 single nodes

data(heart)
heart_result = sbfc(heart)
heart_labels = c("Age", "Sex", "Chest Pain", "Rest Blood Pressure", "Cholesterol", 
"Blood Sugar", "Rest ECG", "Max Heart Rate", "Angina", "ST Depression", "ST Slope",
"Fluoroscopy Colored Vessels", "Thalassemia")
sbfc_graph(heart_result, labels=heart_labels, width=700)
</code></pre>

<hr>
<h2 id='signal_size_plot'>Trace plot of Group 1 size</h2><span id='topic+signal_size_plot'></span>

<h3>Description</h3>

<p>Plots the Group 1 size for a range of the MCMC iterations (indicated by <code>start</code> and <code>end</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_size_plot(sbfc_result, start = 0, end = 1, samples = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signal_size_plot_+3A_sbfc_result">sbfc_result</code></td>
<td>
<p>An object of class <code>sbfc</code>.</p>
</td></tr>
<tr><td><code id="signal_size_plot_+3A_start">start</code></td>
<td>
<p>The start of the included range of MCMC iterations (default=0, i.e. starting with the first iteration).</p>
</td></tr>
<tr><td><code id="signal_size_plot_+3A_end">end</code></td>
<td>
<p>The end of the included range of MCMC iterations (default=1, i.e. ending with the last iteration).</p>
</td></tr>
<tr><td><code id="signal_size_plot_+3A_samples">samples</code></td>
<td>
<p>Calculate signal group size based on sampled MCMC graphs after burn-in and thinning,
rather than graphs from all iterations (default=FALSE).</p>
</td></tr>
</table>

<hr>
<h2 id='signal_var_proportion'>Signal variable proportion</h2><span id='topic+signal_var_proportion'></span>

<h3>Description</h3>

<p>For each variable, computes the proportion of the samples in which this variable is in the signal group (Group 1). 
Plots the top <code>nvars</code> variables in decreasing order of signal proportion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_var_proportion(
  sbfc_result,
  nvars = 10,
  samples = F,
  labels = paste0("X", 1:ncol(sbfc_result$parents)),
  label_size = 1,
  rotate_labels = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signal_var_proportion_+3A_sbfc_result">sbfc_result</code></td>
<td>
<p>An object of class <code>sbfc</code>.</p>
</td></tr>
<tr><td><code id="signal_var_proportion_+3A_nvars">nvars</code></td>
<td>
<p>Number of top signal variables to include in the plot (default=10).</p>
</td></tr>
<tr><td><code id="signal_var_proportion_+3A_samples">samples</code></td>
<td>
<p>Calculate signal variable proportion based on sampled MCMC graphs after burn-in and thinning,
rather than graphs from all iterations (default=FALSE).</p>
</td></tr>
<tr><td><code id="signal_var_proportion_+3A_labels">labels</code></td>
<td>
<p>A vector of node labels (default=<code>c("X1","X2",...)</code>).</p>
</td></tr>
<tr><td><code id="signal_var_proportion_+3A_label_size">label_size</code></td>
<td>
<p>Size of variable labels on the X-axis (default=1).</p>
</td></tr>
<tr><td><code id="signal_var_proportion_+3A_rotate_labels">rotate_labels</code></td>
<td>
<p>Rotate x-axis labels by 90 degrees to make them vertical (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Signal proportion for the top <code>nvars</code> variables in decreasing order.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
