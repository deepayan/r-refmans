<!DOCTYPE html><html><head><title>Help for package eatATA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<script type="text/javascript" src="mathjax-config.js"></script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eatATA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acrossFormsConstraint'><p>Constrain the sum of item values across multiple forms.</p></a></li>
<li><a href='#analyzeBlockExclusion'><p>Analyze block exclusiveness</p></a></li>
<li><a href='#analyzeComplexBlockExclusion'><p>Analyze complex block exclusiveness</p></a></li>
<li><a href='#appendSolution'><p>Append a <code>useSolver</code> output</p></a></li>
<li><a href='#autoItemValuesMinMaxConstraint'><p>Create single value constraints with minimum and maximum.</p></a></li>
<li><a href='#calculateExpectedRT'><p>Calculate Cumulants Lognormal Response Time Distribution</p></a></li>
<li><a href='#calculateIIF'><p>Calculate Item Information Function</p></a></li>
<li><a href='#cappedMaximinObjective'><p>Capped Maximin Constraint.</p></a></li>
<li><a href='#combineConstraints'><p>Combine constraints</p></a></li>
<li><a href='#computeTargetValues'><p>Compute target values based on the item pool.</p></a></li>
<li><a href='#depletePoolConstraint'><p>Use complete item pool.</p></a></li>
<li><a href='#dummiesToFactor'><p>Convert dummy variables to factor.</p></a></li>
<li><a href='#getMean3PLN'><p>Calculate Cumulants Lognormal Response Time Distribution</p></a></li>
<li><a href='#inspectSolution'><p>Inspect a <code>useSolver</code> output</p></a></li>
<li><a href='#itemCategoryConstraint'><p>Create item category constraints.</p></a></li>
<li><a href='#itemCategoryRangeConstraint'><p>Create item category constraints with minimum and maximum.</p></a></li>
<li><a href='#itemExclusionConstraint'><p>Create item inclusion or exclusion constraints.</p></a></li>
<li><a href='#items_diao'><p>Small simulated item pool example.</p></a></li>
<li><a href='#items_lsa'><p>Simulated item pool example.</p></a></li>
<li><a href='#items_mini'><p>Small simulated item pool example.</p></a></li>
<li><a href='#items_pilot'><p>Small simulated item pool example.</p></a></li>
<li><a href='#items_vera'><p>Small artificial item pool example.</p></a></li>
<li><a href='#itemsPerFormConstraint'><p>Create number of items per test form constraints.</p></a></li>
<li><a href='#itemTuples'><p>Create item tuples.</p></a></li>
<li><a href='#itemUsageConstraint'><p>Create item usage constraints.</p></a></li>
<li><a href='#itemValuesConstraint'><p>Constrain the sum of item values per form.</p></a></li>
<li><a href='#itemValuesRangeConstraint'><p>Create single value constraints with minimum and maximum.</p></a></li>
<li><a href='#matrixExclusionTuples'><p>Create item exclusion tuples from matrix.</p></a></li>
<li><a href='#maximinObjective'><p>Maximin Constraint.</p></a></li>
<li><a href='#maxObjective'><p>Max Constraint.</p></a></li>
<li><a href='#minimaxObjective'><p>Minimax Constraint.</p></a></li>
<li><a href='#minObjective'><p>Min Constraint.</p></a></li>
<li><a href='#stemInclusionTuples'><p>Create item inclusion tuples from item stem.</p></a></li>
<li><a href='#useSolver'><p>Use a solver for a list of constraints.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Create Constraints for Small Test Assembly Problems</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides simple functions to create constraints for small test assembly problems 
    (e.g. van der Linden (2005, ISBN: 978-0-387-29054-6)) using sparse matrices. Currently, 
    'GLPK', 'lpSolve', 'Symphony', and 'Gurobi' are supported as solvers. The 'gurobi' package is not available from 
    any mainstream repository; see <a href="https://www.gurobi.com/downloads/">https://www.gurobi.com/downloads/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/beckerbenj/eatATA">https://github.com/beckerbenj/eatATA</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, methods, Rglpk, mathjaxr, lpSolve</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), covr, knitr, rmarkdown, readxl,
Rsymphony</td>
</tr>
<tr>
<td>Enhances:</td>
<td>gurobi</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 15:34:57 UTC; beckerbz</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Becker [aut, cre],
  Dries Debeer [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Becker &lt;b.becker@iqb.hu-berlin.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 16:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='acrossFormsConstraint'>Constrain the sum of item values across multiple forms.</h2><span id='topic+acrossFormsConstraint'></span>

<h3>Description</h3>

<p>Create constraints related to item values. That is, the created
constraints assure that the sum of the item values (<code>itemValues</code>) across test forms is either
(a) smaller than or equal to (<code>operator = "&lt;="</code>), (b) equal to
(<code>operator = "="</code>), or (c) greater than or equal to (<code>operator = "&gt;="</code>)
the chosen <code>targetValue</code>. Note that the length of <code>itemValues</code> should
equal to the number of the length of <code>whichForms</code> times <code>whichItems</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acrossFormsConstraint(
  nForms,
  nItems = NULL,
  operator = c("&lt;=", "=", "&gt;="),
  targetValue,
  whichForms = seq_len(nForms),
  whichItems = NULL,
  itemIDs = NULL,
  itemValues = NULL,
  info_text = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acrossFormsConstraint_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="acrossFormsConstraint_+3A_nitems">nItems</code></td>
<td>
<p>Number of items in the item pool [optional to create <code>itemIDs</code> automatically].</p>
</td></tr>
<tr><td><code id="acrossFormsConstraint_+3A_operator">operator</code></td>
<td>
<p>A character indicating which operator should be used in the
constraints, with three possible values: <code>"&lt;="</code>, <code>"="</code>,
or <code>"&gt;="</code>. See details for more information.</p>
</td></tr>
<tr><td><code id="acrossFormsConstraint_+3A_targetvalue">targetValue</code></td>
<td>
<p>the target value. The target sum of item values across
test forms.</p>
</td></tr>
<tr><td><code id="acrossFormsConstraint_+3A_whichforms">whichForms</code></td>
<td>
<p>An integer vector indicating across which test forms the
sum should constrained. Defaults to all the test forms.</p>
</td></tr>
<tr><td><code id="acrossFormsConstraint_+3A_whichitems">whichItems</code></td>
<td>
<p>A vector indicating which items should be constrained. Defaults to all the items.</p>
</td></tr>
<tr><td><code id="acrossFormsConstraint_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
<tr><td><code id="acrossFormsConstraint_+3A_itemvalues">itemValues</code></td>
<td>
<p>a vector of item values for which the sum across test forms should be constrained. The item values will be repeated for each form. Defaults to a vector with ones for all items in the pool.</p>
</td></tr>
<tr><td><code id="acrossFormsConstraint_+3A_info_text">info_text</code></td>
<td>
<p>a character string of length 1, to be used in the <code>"info"</code>-attribute of the resulting <code>constraint</code>-object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"constraint"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## constraints to make sure that accross test form 1 and 3, only 4 items
##  of items 1:10 appear. Note that the constraint should be used in
##  in combination with constraining item overlap between the forms.
constr1 &lt;- combineConstraints(
  acrossFormsConstraint(nForms = 3,
                        operator = "=", targetValue = 4,
                        whichForms = c(1, 3),
                        itemValues = c(rep(1, 10), rep(0, 10)),
                        itemIDs = 1:20),
  itemUsageConstraint(nForms = 3, nItems = 20, operator = "=", targetValue = 1,
                      itemIDs = 1:20)
                    )

## or alternatively
constr2 &lt;- combineConstraints(
  acrossFormsConstraint(nForms = 3, nItems = 20,
                        operator = "=", targetValue = 4,
                        whichForms = c(1, 3),
                        whichItems = 1:10,
                        itemIDs = 1:20),
  itemUsageConstraint(nForms = 3, nItems = 20, operator = "=", targetValue = 1,
                      itemIDs = 1:20)
                    )

</code></pre>

<hr>
<h2 id='analyzeBlockExclusion'>Analyze block exclusiveness</h2><span id='topic+analyzeBlockExclusion'></span>

<h3>Description</h3>

<p>Use exclusion tuples information to determine which assembled test blocks are exclusive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyzeBlockExclusion(
  solverOut,
  items,
  idCol,
  exclusionTuples,
  formName = "form"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyzeBlockExclusion_+3A_solverout">solverOut</code></td>
<td>
<p>Object created by <code>useSolver</code> function.</p>
</td></tr>
<tr><td><code id="analyzeBlockExclusion_+3A_items">items</code></td>
<td>
<p>Original <code>data.frame</code> containing information on item level.</p>
</td></tr>
<tr><td><code id="analyzeBlockExclusion_+3A_idcol">idCol</code></td>
<td>
<p>Column name in <code>items</code> containing item IDs. These will be used for matching to the solver output.</p>
</td></tr>
<tr><td><code id="analyzeBlockExclusion_+3A_exclusiontuples">exclusionTuples</code></td>
<td>
<p><code>data.frame</code> with two columns, containing tuples with
item IDs which should be in test
forms exclusively. Must be the same object as used in <code><a href="#topic+itemExclusionConstraint">itemExclusionConstraint</a></code>.</p>
</td></tr>
<tr><td><code id="analyzeBlockExclusion_+3A_formname">formName</code></td>
<td>
<p>A character vector with names to give to the forms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If exclusion tuples have been used to assemble test forms (using the <code><a href="#topic+itemExclusionConstraint">itemExclusionConstraint</a></code>
function), the resulting
item blocks might also be exclusive. Using the initially used item exclusion tuples and the optimal solution
given by <code>useSolver</code> this function determines, which item blocks are exclusive and can not be together in an
assembled test form.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of block exclusions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Full workflow using itemExclusionTuples
# Example data.frame
items &lt;- data.frame(ID = c("items1", "items2", "items3", "items4"),
                     exclusions = c("items2, items3", NA, NA, NA),
                     stringsAsFactors = FALSE)

# Create tuples
exTuples2 &lt;- itemTuples(items = items, idCol = "ID", infoCol = "exclusions",
                    sepPattern = ", ")

#' ## Create constraints
exclusion_constraint &lt;- itemExclusionConstraint(nForms = 2, itemTuples = exTuples2,
                                                itemIDs = items$ID)
depletion_constraint &lt;- depletePoolConstraint(2, nItems = 4,
                                                itemIDs = items$ID)
target_constraint &lt;- minimaxObjective(nForms = 2,
                                          itemValues = c(3, 1.5, 2, 4),
                                          targetValue = 1,
                                          itemIDs = items$ID)

opt_solution &lt;- useSolver(list(exclusion_constraint, target_constraint,
                                        depletion_constraint))

analyzeBlockExclusion(opt_solution, items = items, idCol = "ID",
                       exclusionTuples = exTuples2)


</code></pre>

<hr>
<h2 id='analyzeComplexBlockExclusion'>Analyze complex block exclusiveness</h2><span id='topic+analyzeComplexBlockExclusion'></span>

<h3>Description</h3>

<p>Use exclusion tuples information from independent test assembly problems to determine which assembled
test blocks are exclusive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyzeComplexBlockExclusion(
  solverOut_list,
  items_list,
  idCol,
  exclusionTuples_list
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyzeComplexBlockExclusion_+3A_solverout_list">solverOut_list</code></td>
<td>
<p>List of objects created by <code>useSolver</code>.</p>
</td></tr>
<tr><td><code id="analyzeComplexBlockExclusion_+3A_items_list">items_list</code></td>
<td>
<p>List of original <code>data.frame</code> containing information on item level.</p>
</td></tr>
<tr><td><code id="analyzeComplexBlockExclusion_+3A_idcol">idCol</code></td>
<td>
<p>Column name in <code>items</code> containing item IDs. These will be used for matching to the solver output.</p>
</td></tr>
<tr><td><code id="analyzeComplexBlockExclusion_+3A_exclusiontuples_list">exclusionTuples_list</code></td>
<td>
<p>List of <code>data.frames</code> with two columns, containing tuples with item IDs which
should be in test forms exclusively. Must be the same objects as used in <code><a href="#topic+itemExclusionConstraint">itemExclusionConstraint</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If exclusion tuples have been used to assemble test forms (using the <code><a href="#topic+itemExclusionConstraint">itemExclusionConstraint</a></code>
function), the resulting
item blocks might also be exclusive. Using the initially used item exclusion tuples and the optimal solution
given by <code>useSolver</code> this function determines, which item blocks are exclusive and can not be together in an
assembled test form. <code>analyzeComplexBlockExclusion</code> allows analyzing block exclusiveness from separate test
assembly problems. This can be useful if test forms consist of blocks containing different domains or dimensions.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of block exclusions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Full workflow using itemExclusionTuples
# tbd


</code></pre>

<hr>
<h2 id='appendSolution'>Append a <code>useSolver</code> output</h2><span id='topic+appendSolution'></span>

<h3>Description</h3>

<p>Append a <code>useSolver</code> output of a successfully solved optimization problem to the initial item pool <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appendSolution(solverOut, items, idCol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appendSolution_+3A_solverout">solverOut</code></td>
<td>
<p>Object created by <code>useSolver</code> function.</p>
</td></tr>
<tr><td><code id="appendSolution_+3A_items">items</code></td>
<td>
<p>Original <code>data.frame</code> containing information on item level.</p>
</td></tr>
<tr><td><code id="appendSolution_+3A_idcol">idCol</code></td>
<td>
<p>Column name or column number in <code>items</code> containing item IDs. These will be used for matching to the solver output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function merges the initial item pool information in <code>items</code> to the solver output in <code>solverOut</code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example item pool
items &lt;- data.frame(ID = 1:10,
itemValues = c(-4, -4, -2, -2, -1, -1, 20, 20, 0, 0))

## Test Assembly
usage &lt;- itemUsageConstraint(nForms = 2, operator = "=",
                             targetValue = 1, itemIDs = items$ID)
perForm &lt;- itemsPerFormConstraint(nForms = 2, operator = "=",
                                  targetValue = 5, itemIDs = items$ID)
target &lt;- minimaxObjective(nForms = 2,
                               itemValues = items$itemValues,
                               targetValue = 0, itemIDs = items$ID)
sol &lt;- useSolver(allConstraints = list(usage, perForm, target),
                                  solver = "lpSolve")

## Append Solution to existing item information
out &lt;- appendSolution(sol, items = items, idCol = 1)

</code></pre>

<hr>
<h2 id='autoItemValuesMinMaxConstraint'>Create single value constraints with minimum and maximum.</h2><span id='topic+autoItemValuesMinMaxConstraint'></span>

<h3>Description</h3>

<p><code><a href="#topic+itemValuesDeviationConstraint">itemValuesDeviationConstraint</a></code> creates constraints related to an item parameter/value. <code>autoItemValuesMixMax</code> automatically
determines the appropriate <code>targetValue</code> and then calls <code><a href="#topic+itemValuesDeviationConstraint">itemValuesDeviationConstraint</a></code>. The function only works for
(dichotomous) dummy indicators with values 0 or 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoItemValuesMinMaxConstraint(
  nForms,
  itemValues,
  testLength = NULL,
  allowedDeviation = NULL,
  relative = FALSE,
  verbose = TRUE,
  itemIDs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoItemValuesMinMaxConstraint_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="autoItemValuesMinMaxConstraint_+3A_itemvalues">itemValues</code></td>
<td>
<p>Item parameter/values for which the sum per test form should be constrained.</p>
</td></tr>
<tr><td><code id="autoItemValuesMinMaxConstraint_+3A_testlength">testLength</code></td>
<td>
<p>to be documented.</p>
</td></tr>
<tr><td><code id="autoItemValuesMinMaxConstraint_+3A_alloweddeviation">allowedDeviation</code></td>
<td>
<p>Numeric value of length 1. How much deviance is allowed from target values?</p>
</td></tr>
<tr><td><code id="autoItemValuesMinMaxConstraint_+3A_relative">relative</code></td>
<td>
<p>Is the <code>allowedDeviation</code> expressed as a proportion?</p>
</td></tr>
<tr><td><code id="autoItemValuesMinMaxConstraint_+3A_verbose">verbose</code></td>
<td>
<p>Should calculated values be reported?</p>
</td></tr>
<tr><td><code id="autoItemValuesMinMaxConstraint_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two scenarios are possible when automatically determining the target value:
(a) Either items with the selected property could be exactly
distributed across test forms or (b) this is not possible. An example would be 2 test forms and 4 multiple choice items (a) or 2 test
forms and 5 multiple choice items (b). If (a), the tolerance level works exactly as one would expect. If (b) the tolerance level is
adapted, meaning that if tolerance level is 0 in example (b), allowed values are 2 or 3 multiple choice items per test form. For detailed documentation on how the minimum and maximum are calculated
see also <code><a href="#topic+computeTargetValues">computeTargetValues</a></code>.
</p>


<h3>Value</h3>

<p>A sparse matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>autoItemValuesMinMaxConstraint(2, itemValues = c(0, 1, 0, 1))

</code></pre>

<hr>
<h2 id='calculateExpectedRT'>Calculate Cumulants Lognormal Response Time Distribution</h2><span id='topic+calculateExpectedRT'></span><span id='topic+calculateExpectedRTvar'></span>

<h3>Description</h3>

<p>These functions have been deprecated. See <code><a href="#topic+getMean3PLN">getMean3PLN</a></code> or <code><a href="#topic+getVar3PLN">getVar3PLN</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateExpectedRT(lambda, phi, zeta, sdEpsi)

calculateExpectedRTvar(lambda, phi, zeta, sdEpsi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateExpectedRT_+3A_lambda">lambda</code></td>
<td>
<p>Vector of time intensity parameters.</p>
</td></tr>
<tr><td><code id="calculateExpectedRT_+3A_phi">phi</code></td>
<td>
<p>[optional] Vector of speed sensitivity parameters.</p>
</td></tr>
<tr><td><code id="calculateExpectedRT_+3A_zeta">zeta</code></td>
<td>
<p>Vector of person speed parameters.</p>
</td></tr>
<tr><td><code id="calculateExpectedRT_+3A_sdepsi">sdEpsi</code></td>
<td>
<p>Vector of item specific residual variances.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>calculateExpectedRT()</code>: Calculate mean 3PLN
</p>
</li>
<li> <p><code>calculateExpectedRTvar()</code>: Calculate mean 2PLN
</p>
</li></ul>

<hr>
<h2 id='calculateIIF'>Calculate Item Information Function</h2><span id='topic+calculateIIF'></span>

<h3>Description</h3>

<p>Calculate item information function given item parameters of the 1PL, 2PL or 3PL IRT model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateIIF(A = rep(1, length(B)), B, C = rep(0, length(B)), theta, D = 1.7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateIIF_+3A_a">A</code></td>
<td>
<p>Vector of discrimination parameters.</p>
</td></tr>
<tr><td><code id="calculateIIF_+3A_b">B</code></td>
<td>
<p>Vector of difficulty parameters.</p>
</td></tr>
<tr><td><code id="calculateIIF_+3A_c">C</code></td>
<td>
<p>Vector of pseudo-guessing parameters.</p>
</td></tr>
<tr><td><code id="calculateIIF_+3A_theta">theta</code></td>
<td>
<p>Vector of time intensity parameters.</p>
</td></tr>
<tr><td><code id="calculateIIF_+3A_d">D</code></td>
<td>
<p>the constant that should be used. Defaults to 1.7.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix, with columns for different <code>theta</code> and rows for different items
</p>


<h3>References</h3>

<p>van der Linden, W. J. (2005). <em>Linear models for optimal test design</em>. New York, NY: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TIF for a single item (2PL model)
calculateIIF(A = 0.8, B = 1.1, theta = 0)

# TIF for multiple items (1PL model)
calculateIIF(B = c(1.1, 0.8, 0.5), theta = 0)

# TIF for multiple theta-values (3PL model)
calculateIIF(B = -0.5, C = 0.25, theta = c(-1, 0, 1))

# TIF for multiple items and multiple ability levels (2PL model)
calculateIIF(A = c(0.7, 1.1, 0.8), B = c(1.1, 0.8, 0.5),
            theta = c(-1, 0, 1))

</code></pre>

<hr>
<h2 id='cappedMaximinObjective'>Capped Maximin Constraint.</h2><span id='topic+cappedMaximinObjective'></span>

<h3>Description</h3>

<p>Create <code>maximin</code>-constraints related to an item parameter/value. That is, the created
constraints can be used to maximize the minimal sum of the
item values (<code>itemValues</code>), while at the same time automatically setting
an ideal upper limit to the overflow. More specifically, the <code>capped minimax</code>
method described by Luo (2020) is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cappedMaximinObjective(
  nForms,
  itemValues,
  weight = 1,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemValues)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cappedMaximinObjective_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="cappedMaximinObjective_+3A_itemvalues">itemValues</code></td>
<td>
<p>Item parameter/values for which the sum per test form should be constrained.</p>
</td></tr>
<tr><td><code id="cappedMaximinObjective_+3A_weight">weight</code></td>
<td>
<p>a weight for the real-valued variable(s). Useful when multiple constraints are combined. Should only be used if the implications are well understood.</p>
</td></tr>
<tr><td><code id="cappedMaximinObjective_+3A_whichforms">whichForms</code></td>
<td>
<p>An integer vector indicating which test forms should be constrained. Defaults to all the test forms.</p>
</td></tr>
<tr><td><code id="cappedMaximinObjective_+3A_info_text">info_text</code></td>
<td>
<p>a character string of length 1, to be used in the <code>"info"</code>-attribute of the resulting <code>constraint</code>-object.</p>
</td></tr>
<tr><td><code id="cappedMaximinObjective_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"constraint"</code>.
</p>


<h3>References</h3>

<p>Xiao Luo (2020). Automated Test Assembly with Mixed-Integer Programming:
The Effects of Modeling Approaches and Solvers.
<em>Journal of Educational Measurement</em>, 57(4), 547-565.
<a href="https://doi.org/10.1111/jedm.12262">doi:10.1111/jedm.12262</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraint that minimizes the maximum difference per test form value and a
#   target value of 0
cappedMaximinObjective(nForms = 2, itemValues = rep(-2:2, 2))

</code></pre>

<hr>
<h2 id='combineConstraints'>Combine constraints</h2><span id='topic+combineConstraints'></span>

<h3>Description</h3>

<p>Combine multiple constraint-objects into one constraint object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineConstraints(..., message = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineConstraints_+3A_...">...</code></td>
<td>
<p>multiple constraint-objects or a list with multiple constraint-objects</p>
</td></tr>
<tr><td><code id="combineConstraints_+3A_message">message</code></td>
<td>
<p>A logical indicating whether a message should be given when only one constraint object is combined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of block exclusions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>combineConstraints(
 itemValuesConstraint(2, 1:10, operator = "&gt;=", targetValue = 4),
 itemValuesConstraint(2, 1:10, operator = "&lt;=", targetValue = 6)
)

</code></pre>

<hr>
<h2 id='computeTargetValues'>Compute target values based on the item pool.</h2><span id='topic+computeTargetValues'></span><span id='topic+computeTargetValues.default'></span><span id='topic+computeTargetValues.factor'></span>

<h3>Description</h3>

<p>Compute target values for item values/categories based on the number
of items in the item pool, the number of test forms to assemble and the number
of items in each test form (i.e., test length).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeTargetValues(
  itemValues,
  nForms,
  testLength = NULL,
  allowedDeviation = NULL,
  relative = FALSE
)

## Default S3 method:
computeTargetValues(
  itemValues,
  nForms,
  testLength = NULL,
  allowedDeviation = NULL,
  relative = FALSE
)

## S3 method for class 'factor'
computeTargetValues(
  itemValues,
  nForms,
  testLength = NULL,
  allowedDeviation = NULL,
  relative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeTargetValues_+3A_itemvalues">itemValues</code></td>
<td>
<p>Item parameter/values for which the sum per test form should be constrained.</p>
</td></tr>
<tr><td><code id="computeTargetValues_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="computeTargetValues_+3A_testlength">testLength</code></td>
<td>
<p>to be documented.</p>
</td></tr>
<tr><td><code id="computeTargetValues_+3A_alloweddeviation">allowedDeviation</code></td>
<td>
<p>Numeric value of length 1. How much deviance is allowed from target values?</p>
</td></tr>
<tr><td><code id="computeTargetValues_+3A_relative">relative</code></td>
<td>
<p>Is the <code>allowedDeviation</code> expressed as a proportion?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both for numerical and categorical item values, the target values are the item
pool average scaled by the ratio of items in the forms and items in the item
pool. The behavior of the function changes depending on the class of
<code>itemValues</code>.
</p>
<p>When <code>itemValues</code> is a numerical vector, an when <code>allowedDeviation</code>
is <code>NULL</code> (the default), only one target value is computed. This value
could be used in the <code>targetConstraint</code>-function. Otherwise (i.e.,
<code>allowedDeviation</code> is a numerical value), the target is computed, but a
minimal and a maximal (target)value are returned, based on the allowed
deviation. When <code>relative == TRUE</code> the allowed deviation should be
expressed as a proportion. In that case the minimal and maximal values are
a computed proportionally.
</p>
<p>When <code>itemValues</code> is a <code>factor</code>, it is assumed that the item values
are item categories, and hence only whole valued frequencies are returned.
To be more precise, a matrix with the minimal and maximal target frequencies
for every level of the factor are returned. When <code>allowedDeviation</code>
is <code>NULL</code>, the difference between the minimal and maximal value is
one (or zero). As a consequence, dummy-item values are best specified as a
factor (see examples).
</p>


<h3>Value</h3>

<p>a vector or a matrix with target values (see details)
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>computeTargetValues(default)</code>: compute target values
</p>
</li>
<li> <p><code>computeTargetValues(factor)</code>: compute target frequencies for item categories
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Assume an item pool with 50 items with random item information values (iif) for
## a given ability value.
set.seed(50)
itemInformations &lt;- runif(50, 0.5, 3)

## The target value for the test information value (i.e., sum of the item
## informations) when three test forms of 10 items are assembled is:
computeTargetValues(itemInformations, nForms = 3, testLength = 10)

## The minimum and maximum test iformation values for an allowed deviation of
## 10 percent are:
computeTargetValues(itemInformations, nForms = 3, allowedDeviation = .10,
   relative = TRUE, testLength = 10)


## items_vera$MC is dummy variable indication which items in the pool are multiple choise
str(items_vera$MC)

## when used as a numerical vector, the dummy is not treated as a categorical
## indicator, but rather as a numerical value.
computeTargetValues(items_vera$MC, nForms = 14)
computeTargetValues(items_vera$MC, nForms = 14, allowedDeviation = 1)

## Therefore, it is best to convert dummy variables into a factor, so that
## automatically freqyencies are returned
MC_factor &lt;- factor(items_vera$MC, labels = c("not MC", "MC"))
computeTargetValues(MC_factor, nForms = 14)
computeTargetValues(MC_factor, nForms = 3)

## The computed minimum and maximum frequencies can be used to create contstraints.
MC_ranges &lt;- computeTargetValues(MC_factor, nForms = 3)
itemCategoryRangeConstraint(3, MC_factor, range = MC_ranges)

## When desired, the automatically computed range can be adjusted by hand. This
##  can be of use when only a limited set of the categories should be constrained.
##  For instance, when only the multiple-choice items should be constrained, and
##  the non-multiple-choice items should not be constrained, the minimum and
##  maximum value can be set to a very small and a very high value, respectively.
##  Or to other sensible values.
MC_ranges["not MC", ] &lt;- c(0, 40)
MC_ranges
itemCategoryRangeConstraint(3, MC_factor, range = MC_ranges)

</code></pre>

<hr>
<h2 id='depletePoolConstraint'>Use complete item pool.</h2><span id='topic+depletePoolConstraint'></span>

<h3>Description</h3>

<p>Creates constraints that assure that every item in the item pool is used
(at least) once. Essentially a wrapper around <code>itemUsageConstraint</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depletePoolConstraint(nForms, nItems = NULL, itemIDs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depletePoolConstraint_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="depletePoolConstraint_+3A_nitems">nItems</code></td>
<td>
<p>Number of items in the item pool [optional to create <code>itemIDs</code> automatically].</p>
</td></tr>
<tr><td><code id="depletePoolConstraint_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>depletePoolConstraint(2, itemIDs = 1:10)

</code></pre>

<hr>
<h2 id='dummiesToFactor'>Convert dummy variables to factor.</h2><span id='topic+dummiesToFactor'></span>

<h3>Description</h3>

<p>Convert multiple dummy variables into a single factor variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummiesToFactor(dat, dummies, facVar, nameEmptyCategory = "_none_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummiesToFactor_+3A_dat">dat</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="dummiesToFactor_+3A_dummies">dummies</code></td>
<td>
<p>Character vector containing the names of the dummy variables in the <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="dummiesToFactor_+3A_facvar">facVar</code></td>
<td>
<p>Name of the factor variable, that should be created.</p>
</td></tr>
<tr><td><code id="dummiesToFactor_+3A_nameemptycategory">nameEmptyCategory</code></td>
<td>
<p>a character of length 1 that defines the name of cases
for which no dummy is equal to one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The content of a single factor variable can alternatively be stored in multiple dichotomous dummy variables coded with <code>0</code>/<code>1</code> or <code>NA</code>/<code>1</code>. <code>1</code> always has to refer to &quot;this category applies&quot;. The function requires factor levels to be exclusive (i.e. only one factor level applies per row.).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the newly created factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data set
tdat &lt;- data.frame(ID = 1:3, d1=c(1, 0, 0), d2 = c(0, 1, 0), d3 = c(0, 0, 1))

dummiesToFactor(tdat, dummies = c("d1", "d2", "d3"), facVar = "newFac")

</code></pre>

<hr>
<h2 id='getMean3PLN'>Calculate Cumulants Lognormal Response Time Distribution</h2><span id='topic+getMean3PLN'></span><span id='topic+getMean2PLN'></span><span id='topic+getVar3PLN'></span><span id='topic+getVar2PLN'></span>

<h3>Description</h3>

<p>Calculate the first and second cumulants (i.e., mean and variance) of item
response time distributions given item parameters of the three-parameter
log-normal model (3PLN) for response times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMean3PLN(lambda, phi = rep(1, length(lambda)), zeta, sdEpsi)

getMean2PLN(lambda, zeta, sdEpsi)

getVar3PLN(lambda, phi = rep(1, length(lambda)), zeta, sdEpsi)

getVar2PLN(lambda, zeta, sdEpsi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMean3PLN_+3A_lambda">lambda</code></td>
<td>
<p>Vector of time intensity parameters.</p>
</td></tr>
<tr><td><code id="getMean3PLN_+3A_phi">phi</code></td>
<td>
<p>[optional] Vector of speed sensitivity parameters.</p>
</td></tr>
<tr><td><code id="getMean3PLN_+3A_zeta">zeta</code></td>
<td>
<p>Vector of person speed parameters.</p>
</td></tr>
<tr><td><code id="getMean3PLN_+3A_sdepsi">sdEpsi</code></td>
<td>
<p>Vector of item specific residual variances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the first and second cumulant of the two-parameter log-normal (2PLN)
model for response times according to van der Linden (2006) or the 3PLN according
to Klein Entink et al. (2009). If the speed sensitivity parameter <code>phi</code>
in the 3PLN equals <code>1</code>, the model reduces to the 2PLN, yet with a
different parameterization for the item specific residual variance <code>sdEpsi</code>
compared to van der Linden (2006).
</p>
<p>The cumulants are computed for one or more speed parameters, and for one or more
sets of item parameters.
</p>
<p>The calculation is based on Fenton (1960). For the model by van der Linden (2006), the calculation was
first introduced by van der Linden (2011).
</p>


<h3>Value</h3>

<p>a matrix with either the mean or the variance of the response time distributions,
with columns for different <code>zeta</code> and rows for different items
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getMean3PLN()</code>: Calculate mean 3PLN
</p>
</li>
<li> <p><code>getMean2PLN()</code>: Calculate mean 2PLN
</p>
</li>
<li> <p><code>getVar3PLN()</code>: Calculate variance 3PLN
</p>
</li>
<li> <p><code>getVar2PLN()</code>: Calculate variance 2PLN
</p>
</li></ul>


<h3>References</h3>

<p>Fenton, L. (1960). The sum of log-normal probability distributions in scatter transmission systems. <em>IRE
Transactions on Communication Systems</em>, 8, 57-67.
</p>
<p>Klein Entink, R. H., Fox, J.-P., &amp; van der Linden, W. J. (2009). A multivariate
multilevel approach to the modeling of accuracy and speed of test
takers. <em>Psychometrika</em>, 74(1), 21-48.
</p>
<p>van der Linden, W. J. (2006). A lognormal model for response times on test
items. <em>Journal of Educational and Behavioral Statistics, 31(2),
181-204</em>.
</p>
<p>van der Linden, W. J. (2011). Test design and speededness. <em>Journal of
Educational Measurement</em>, 48(1), 44-60.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># expected RT for a single item (van der Linden model)
getMean2PLN(lambda = 3.8, zeta = 0, sdEpsi = 0.3)
getVar2PLN(lambda = 3.8, zeta = 0, sdEpsi = 0.3)

# expected RT for multiple items (van der Linden model)
getMean2PLN(lambda = c(4.1, 3.8, 3.5), zeta = 0,
                   sdEpsi = c(0.3, 0.4, 0.2))
getVar2PLN(lambda = c(4.1, 3.8, 3.5), zeta = 0,
                   sdEpsi = c(0.3, 0.4, 0.2))

# expected RT for multiple items and multiple spped levels (Klein Entink model)
getMean3PLN(lambda = c(3.7, 4.1, 3.8), phi = c(1.1, 0.8, 0.5),
                    zeta = c(-1, 0, 1), sdEpsi = c(0.3, 0.4, 0.2))
getVar3PLN(lambda = c(3.7, 4.1, 3.8), phi = c(1.1, 0.8, 0.5),
                    zeta = c(-1, 0, 1), sdEpsi = c(0.3, 0.4, 0.2))

</code></pre>

<hr>
<h2 id='inspectSolution'>Inspect a <code>useSolver</code> output</h2><span id='topic+inspectSolution'></span>

<h3>Description</h3>

<p>Process a <code>useSolver</code> output of a successfully solved optimization problem to a list so it becomes humanly readable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspectSolution(
  solverOut,
  items,
  idCol,
  colNames = names(items),
  colSums = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspectSolution_+3A_solverout">solverOut</code></td>
<td>
<p>Object created by <code>useSolver</code> function.</p>
</td></tr>
<tr><td><code id="inspectSolution_+3A_items">items</code></td>
<td>
<p>Original <code>data.frame</code> containing information on item level.</p>
</td></tr>
<tr><td><code id="inspectSolution_+3A_idcol">idCol</code></td>
<td>
<p>Column name in <code>items</code> containing item IDs. These will be used for matching to the solver output.</p>
</td></tr>
<tr><td><code id="inspectSolution_+3A_colnames">colNames</code></td>
<td>
<p>Which columns should be used from the <code>items</code> <code>data.frame</code>?</p>
</td></tr>
<tr><td><code id="inspectSolution_+3A_colsums">colSums</code></td>
<td>
<p>Should column sums be calculated in the output? Only works if all columns are numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function merges the initial item pool information in <code>items</code> to the solver output in <code>solverOut</code>.
Relevant columns can be selected via <code>colNames</code>. Column sums within test forms are calculated if possible and
if <code>colSum</code> is set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code>list</code> with assembled blocks as entries. Rows are the individual items. A final row is added, containing
the sums of each column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example item pool
items &lt;- data.frame(ID = 1:10,
itemValues = c(-4, -4, -2, -2, -1, -1, 20, 20, 0, 0))

## Test Assembly
usage &lt;- itemUsageConstraint(nForms = 2, operator = "=",
                             targetValue = 1, itemIDs = items$ID)
perForm &lt;- itemsPerFormConstraint(nForms = 2, operator = "=",
                                  targetValue = 5, itemIDs = items$ID)
target &lt;- minimaxObjective(nForms = 2,
                               itemValues = items$itemValues,
                               targetValue = 0, itemIDs = items$ID)
sol &lt;- useSolver(allConstraints = list(usage, perForm, target),
                                  solver = "lpSolve")

## Inspect Solution
out &lt;- inspectSolution(sol, items = items, idCol = 1, colNames = "itemValues")

</code></pre>

<hr>
<h2 id='itemCategoryConstraint'>Create item category constraints.</h2><span id='topic+itemCategoryConstraint'></span>

<h3>Description</h3>

<p>Create constraints related to item categories/groupings (as
represented by <code>itemCategories</code>). That is, the created
constraints assure that the number of items of each category per test form is either
(a) smaller or equal than (<code>operator = "&lt;="</code>), (b) equal to
(<code>operator = "="</code>), or (c) greater than or equal to (<code>operator = "&gt;="</code>)
the corresponding <code>targetValues</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemCategoryConstraint(
  nForms,
  itemCategories,
  operator = c("&lt;=", "=", "&gt;="),
  targetValues,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemCategories)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemCategoryConstraint_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="itemCategoryConstraint_+3A_itemcategories">itemCategories</code></td>
<td>
<p>a factor representing the categories/grouping of the items</p>
</td></tr>
<tr><td><code id="itemCategoryConstraint_+3A_operator">operator</code></td>
<td>
<p>A character indicating which operator should be used in the
constraints, with three possible values: <code>"&lt;="</code>, <code>"="</code>,
or <code>"&gt;="</code>. See details for more information.</p>
</td></tr>
<tr><td><code id="itemCategoryConstraint_+3A_targetvalues">targetValues</code></td>
<td>
<p>an integer vector representing the target number per category.
The order of the target values should correspond with the order of the levels
of the factor in <code>itemCategory</code>.</p>
</td></tr>
<tr><td><code id="itemCategoryConstraint_+3A_whichforms">whichForms</code></td>
<td>
<p>An integer vector indicating which test forms should be constrained. Defaults to all the test forms.</p>
</td></tr>
<tr><td><code id="itemCategoryConstraint_+3A_info_text">info_text</code></td>
<td>
<p>a character string of length 1, to be used in the <code>"info"</code>-attribute of the resulting <code>constraint</code>-object.</p>
</td></tr>
<tr><td><code id="itemCategoryConstraint_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A object of class <code>"constraint"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## constraints to make sure that there are at least 3 items of each item type
## in each test form
nItems &lt;- 30
item_type &lt;- factor(sample(1:3, size = nItems, replace = TRUE))
itemCategoryConstraint(2, item_type, "&gt;=", targetValues = c(1, 3, 2))

</code></pre>

<hr>
<h2 id='itemCategoryRangeConstraint'>Create item category constraints with minimum and maximum.</h2><span id='topic+itemCategoryRangeConstraint'></span><span id='topic+itemCategoryMinConstraint'></span><span id='topic+itemCategoryMaxConstraint'></span><span id='topic+itemCategoryDeviationConstraint'></span>

<h3>Description</h3>

<p><code>itemCategoriesRange</code>, <code>itemCategoriesMin</code>, and <code>itemCategoriesMax</code>
create constraints related to item categories/groupings (as
represented by <code>itemCategories</code>). That is, the created
constraints assure that the number of items of each category per test form is either
smaller or equal than the specified <code>max</code>, greater than or equal to <code>min</code>
or both <code>range</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemCategoryRangeConstraint(
  nForms,
  itemCategories,
  range,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemCategories)
)

itemCategoryMinConstraint(
  nForms,
  itemCategories,
  min,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemCategories)
)

itemCategoryMaxConstraint(
  nForms,
  itemCategories,
  max,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemCategories)
)

itemCategoryDeviationConstraint(
  nForms,
  itemCategories,
  targetValues,
  allowedDeviation,
  relative = FALSE,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemCategories)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemCategoryRangeConstraint_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="itemCategoryRangeConstraint_+3A_itemcategories">itemCategories</code></td>
<td>
<p>a factor representing the categories/grouping of the items</p>
</td></tr>
<tr><td><code id="itemCategoryRangeConstraint_+3A_range">range</code></td>
<td>
<p>a matrix with two columns representing the the minimal and the
maximum frequency of the items from each level/category <code>itemCategories</code></p>
</td></tr>
<tr><td><code id="itemCategoryRangeConstraint_+3A_whichforms">whichForms</code></td>
<td>
<p>An integer vector indicating which test forms should be constrained. Defaults to all the test forms.</p>
</td></tr>
<tr><td><code id="itemCategoryRangeConstraint_+3A_info_text">info_text</code></td>
<td>
<p>a character string of length 1, to be used in the <code>"info"</code>-attribute of the resulting <code>constraint</code>-object.</p>
</td></tr>
<tr><td><code id="itemCategoryRangeConstraint_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
<tr><td><code id="itemCategoryRangeConstraint_+3A_min">min</code></td>
<td>
<p>the minimal sum of the <code>itemValues</code> per test form</p>
</td></tr>
<tr><td><code id="itemCategoryRangeConstraint_+3A_max">max</code></td>
<td>
<p>the minimal sum of the <code>itemValues</code> per test form</p>
</td></tr>
<tr><td><code id="itemCategoryRangeConstraint_+3A_targetvalues">targetValues</code></td>
<td>
<p>an integer vector representing the target number per category.
The order of the target values should correspond with the order of the levels
of the factor in <code>itemCategory</code>.</p>
</td></tr>
<tr><td><code id="itemCategoryRangeConstraint_+3A_alloweddeviation">allowedDeviation</code></td>
<td>
<p>the maximum allowed deviation from the <code>targetValue</code></p>
</td></tr>
<tr><td><code id="itemCategoryRangeConstraint_+3A_relative">relative</code></td>
<td>
<p>a logical expressing whether or not the <code>allowedDeviation</code>
should be interpreted as a proportion of the <code>targetValue</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>itemCategoriesDeviation</code> also constrains the minimal and the maximal value
of the number of items of each category per test form, but based on chosen
<code>targetValues</code>, and maximal allowed deviations (i.e., <code>allowedDeviation</code>)
from those <code>targetValues</code>.
</p>


<h3>Value</h3>

<p>A sparse matrix.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>itemCategoryMinConstraint()</code>: constrain minimum value
</p>
</li>
<li> <p><code>itemCategoryMaxConstraint()</code>: constrain maximum value
</p>
</li>
<li> <p><code>itemCategoryDeviationConstraint()</code>: constrain the distance form the <code>targetValues</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## constraints to make sure that there are at least 2 and maximally 4
##  items of each item type in each test form
nItems &lt;- 30
item_type &lt;- factor(sample(1:3, size = nItems, replace = TRUE))
itemCategoryRangeConstraint(2, item_type, range = cbind(min = rep(2, 3), max = rep(4, 3)))

## or alternatively
itemCategoryDeviationConstraint(2, item_type,
targetValues = rep(3, 3),
allowedDeviation = rep(4, 3))

</code></pre>

<hr>
<h2 id='itemExclusionConstraint'>Create item inclusion or exclusion constraints.</h2><span id='topic+itemExclusionConstraint'></span><span id='topic+itemInclusionConstraint'></span>

<h3>Description</h3>

<p>Create constraints that prohibit that item pairs occur in the same test forms (exclusions) or
force item pairs to be in the same test forms (inclusions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemExclusionConstraint(
  nForms,
  itemTuples,
  itemIDs,
  whichForms = seq_len(nForms),
  info_text = NULL
)

itemInclusionConstraint(
  nForms,
  itemTuples,
  itemIDs,
  whichForms = seq_len(nForms),
  info_text = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemExclusionConstraint_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="itemExclusionConstraint_+3A_itemtuples">itemTuples</code></td>
<td>
<p><code>data.frame</code> with two columns, containing tuples with item IDs which should be in test forms inclusively or exclusively.</p>
</td></tr>
<tr><td><code id="itemExclusionConstraint_+3A_itemids">itemIDs</code></td>
<td>
<p>Character vector of item IDs in correct ordering.</p>
</td></tr>
<tr><td><code id="itemExclusionConstraint_+3A_whichforms">whichForms</code></td>
<td>
<p>An integer vector indicating which test forms should be constrained. Defaults to all the test forms.</p>
</td></tr>
<tr><td><code id="itemExclusionConstraint_+3A_info_text">info_text</code></td>
<td>
<p>a character string of length 1, to be used in the <code>"info"</code>-attribute of the resulting <code>constraint</code>-object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Item tuples can, for example, be created by the function <code><a href="#topic+itemTuples">itemTuples</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"constraint"</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>itemExclusionConstraint()</code>: item pair exclusion constraints
</p>
</li>
<li> <p><code>itemInclusionConstraint()</code>: item pair inclusion constraints
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple Exclusion Example
# item-IDs
IDs &lt;- c("item1", "item2", "item3", "item4")

# exclusion tuples: Item 1 can not be in the test form as item 2 and 3
exTuples &lt;- data.frame(v1 = c("item1", "item1"), v2 = c("item2", "item3"),
                       stringsAsFactors = FALSE)
# inclusion tuples: Items 2 and 3 have to be in the same test form
inTuples &lt;- data.frame(v1 = c("item2"), v2 = c("item3"),
                       stringsAsFactors = FALSE)

# create constraints
itemExclusionConstraint(nForms = 2, itemTuples = exTuples, itemIDs = IDs)
itemInclusionConstraint(nForms = 2, itemTuples = inTuples, itemIDs = IDs)


########
## Full workflow for exclusions using itemTuples
# Example data.frame
items &lt;- data.frame(ID = c("item1", "item2", "item3", "item4"),
                     infoCol = c("item2, item3", NA, NA, NA))

# Create tuples
exTuples2 &lt;- itemTuples(items = items, idCol = "ID", infoCol = "infoCol",
                    sepPattern = ", ")

## Create constraints
itemExclusionConstraint(nForms = 2, itemTuples = exTuples2, itemIDs = IDs)

</code></pre>

<hr>
<h2 id='items_diao'>Small simulated item pool example.</h2><span id='topic+items_diao'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> containing 165 items calibrated using a 3PL model. This item pool is analogous to one of the item pools used
in Diao &amp; van der Linden (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>items_diao
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> .
</p>

<dl>
<dt>item</dt><dd><p>Item identifier.</p>
</dd>
<dt>a</dt><dd><p>Discrimination parameter.</p>
</dd>
<dt>b</dt><dd><p>Difficulty parameter.</p>
</dd>
<dt>c</dt><dd><p>Pseudo-guessing parameter.</p>
</dd>
<dt>category</dt><dd><p>Content category.</p>
</dd>
</dl>



<h3>References</h3>

<p>Diao, Q. &amp; van der Linden, W.J. (2011). Automated test assembly using lp_solve version 5.5 in R. <em>Applied Psychological Measurement, 35 (5)</em>, 398-409.
</p>

<hr>
<h2 id='items_lsa'>Simulated item pool example.</h2><span id='topic+items_lsa'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> containing 209 calibrated items with different categorical and metric properties, comparable to an item pool from a large-scale
assessment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>items_lsa
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> .
</p>

<dl>
<dt>testlet</dt><dd><p>Testlet identifier (items in the same testlet share a common stimulus.</p>
</dd>
<dt>item</dt><dd><p>Item identifier.</p>
</dd>
<dt>level</dt><dd><p>Competence level.</p>
</dd>
<dt>format</dt><dd><p>Item format.</p>
</dd>
<dt>frequency</dt><dd><p>Solution frequency.</p>
</dd>
<dt>infit</dt><dd><p>Item infit.</p>
</dd>
<dt>time</dt><dd><p>Average response time in seconds.</p>
</dd>
<dt>anchor</dt><dd><p>Is the item an anchor item?</p>
</dd>
</dl>


<hr>
<h2 id='items_mini'>Small simulated item pool example.</h2><span id='topic+items_mini'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> containing 30 items with different categorical and metric properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>items_mini
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> .
</p>

<dl>
<dt>item</dt><dd><p>Item identifier.</p>
</dd>
<dt>format</dt><dd><p>Item format (e.g., multiple choice, open answer, order item).</p>
</dd>
<dt>time</dt><dd><p>Average response time in seconds.</p>
</dd>
<dt>difficulty</dt><dd><p>IRT difficulty parameter.</p>
</dd>
</dl>


<hr>
<h2 id='items_pilot'>Small simulated item pool example.</h2><span id='topic+items_pilot'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> containing 100 not yet calibrated items with different categorical and metric properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>items_pilot
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> .
</p>

<dl>
<dt>item</dt><dd><p>Item identifier.</p>
</dd>
<dt>diffCategory</dt><dd><p>Item difficulty (five categories).</p>
</dd>
<dt>format</dt><dd><p>Item format (multiple choice, constructed multiple choice, or open answer).</p>
</dd>
<dt>domain</dt><dd><p>Item domain (listening, reading, or writing).</p>
</dd>
<dt>time</dt><dd><p>Average response times in seconds.</p>
</dd>
<dt>exclusions</dt><dd><p>Items which can not be in the same test form.</p>
</dd>
</dl>


<hr>
<h2 id='items_vera'>Small artificial item pool example.</h2><span id='topic+items_vera'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> containing 80 items with different categorical and metric properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>items_vera
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> .
</p>

<dl>
<dt>item</dt><dd><p>Item identifier.</p>
</dd>
<dt>exclusions</dt><dd><p>Items which can not be in the same test form.</p>
</dd>
<dt>time</dt><dd><p>Average response times in minutes. <code>2.5</code> equals 2 minutes and 30 seconds, for example.</p>
</dd>
<dt>subitems</dt><dd><p>Number of sub items.</p>
</dd>
<dt>MC, CMC, short_answer, open</dt><dd><p>Answer formats.</p>
</dd>
<dt>diff_1, diff_2, diff_3, diff_4, diff5</dt><dd><p>Difficulty categories.</p>
</dd>
</dl>


<hr>
<h2 id='itemsPerFormConstraint'>Create number of items per test form constraints.</h2><span id='topic+itemsPerFormConstraint'></span>

<h3>Description</h3>

<p>Creates constraints related to the number of items in each test form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemsPerFormConstraint(
  nForms,
  nItems = NULL,
  operator = c("&lt;=", "=", "&gt;="),
  targetValue,
  whichForms = seq_len(nForms),
  itemIDs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemsPerFormConstraint_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="itemsPerFormConstraint_+3A_nitems">nItems</code></td>
<td>
<p>Number of items in the item pool [optional to create <code>itemIDs</code> automatically].</p>
</td></tr>
<tr><td><code id="itemsPerFormConstraint_+3A_operator">operator</code></td>
<td>
<p>A character indicating which operator should be used in the
constraints, with three possible values: <code>"&lt;="</code>, <code>"="</code>,
or <code>"&gt;="</code>. See details for more information.</p>
</td></tr>
<tr><td><code id="itemsPerFormConstraint_+3A_targetvalue">targetValue</code></td>
<td>
<p>The target value to be used in the constraints. That is,
the number of items per form.</p>
</td></tr>
<tr><td><code id="itemsPerFormConstraint_+3A_whichforms">whichForms</code></td>
<td>
<p>An integer vector indicating which test forms should be constrained. Defaults to all the test forms.</p>
</td></tr>
<tr><td><code id="itemsPerFormConstraint_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of items per test form is constrained to be either
(a) smaller or equal than (<code>operator = "&lt;="</code>), (b) equal to
(<code>operator = "="</code>), or (c) greater or equal than
(<code>operator = "&gt;="</code>) the chosen <code>value</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"constraint"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Constrain the test forms to have exactly five items
itemsPerFormConstraint(3, operator = "=", targetValue = 5,
                       itemIDs = 1:20)

</code></pre>

<hr>
<h2 id='itemTuples'>Create item tuples.</h2><span id='topic+itemTuples'></span>

<h3>Description</h3>

<p>If item inclusions or exclusions are stored as a character vector, <code>itemTuples</code> separates this vector and creates item pairs ('tuples').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemTuples(items, idCol = "ID", infoCol, sepPattern = ", ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemTuples_+3A_items">items</code></td>
<td>
<p>A <code>data.frame</code> with information on an item pool.</p>
</td></tr>
<tr><td><code id="itemTuples_+3A_idcol">idCol</code></td>
<td>
<p>character or integer indicating the item ID column in <code>items</code>.</p>
</td></tr>
<tr><td><code id="itemTuples_+3A_infocol">infoCol</code></td>
<td>
<p>character or integer indicating the column in <code>items</code> which contains information on the tuples.</p>
</td></tr>
<tr><td><code id="itemTuples_+3A_seppattern">sepPattern</code></td>
<td>
<p>String which should be used for separating item IDs in the <code>infoCol</code> column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tuples can be used by <code><a href="#topic+itemExclusionConstraint">itemExclusionConstraint</a></code> to set up exclusion constraints
and by <code><a href="#topic+itemInclusionConstraint">itemInclusionConstraint</a></code> to set up inclusion constraints. Note that a
separator pattern has to be used consistently throughout the column (e.g. <code>", "</code>).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with two columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data.frame
items &lt;- data.frame(ID = c("item1", "item2", "item3", "item4"),
                     exclusions = c("item2, item3", NA, NA, NA))

# Create tuples
itemTuples(items = items, idCol = "ID", infoCol = 2,
                    sepPattern = ", ")


</code></pre>

<hr>
<h2 id='itemUsageConstraint'>Create item usage constraints.</h2><span id='topic+itemUsageConstraint'></span>

<h3>Description</h3>

<p>Creates constraints related to item usage. That is, the number of times an item
is selected is constrained to be either (a) smaller or equal than
(<code>operator = "&lt;="</code>), (b) equal to (<code>operator = "="</code>),
or (c) greater or equal than (<code>operator = "&gt;="</code>) the chosen <code>value</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemUsageConstraint(
  nForms,
  nItems = NULL,
  formValues = rep(1, nForms),
  operator = c("&lt;=", "=", "&gt;="),
  targetValue = 1,
  whichItems = NULL,
  info_text = NULL,
  itemIDs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemUsageConstraint_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="itemUsageConstraint_+3A_nitems">nItems</code></td>
<td>
<p>Number of items in the item pool [optional to create <code>itemIDs</code> automatically].</p>
</td></tr>
<tr><td><code id="itemUsageConstraint_+3A_formvalues">formValues</code></td>
<td>
<p>vector with values or weights for each form. Defaults to 1 for each form.</p>
</td></tr>
<tr><td><code id="itemUsageConstraint_+3A_operator">operator</code></td>
<td>
<p>A character indicating which operator should be used in the
constraints, with three possible values: <code>"&lt;="</code>, <code>"="</code>,
or <code>"&gt;="</code>. See details for more information.</p>
</td></tr>
<tr><td><code id="itemUsageConstraint_+3A_targetvalue">targetValue</code></td>
<td>
<p>The value to be used in the constraints</p>
</td></tr>
<tr><td><code id="itemUsageConstraint_+3A_whichitems">whichItems</code></td>
<td>
<p>A vector indicating which items should be constrained. Defaults to all the items.</p>
</td></tr>
<tr><td><code id="itemUsageConstraint_+3A_info_text">info_text</code></td>
<td>
<p>a character string of length 1, to be used in the <code>"info"</code>-attribute of the resulting <code>constraint</code>-object.</p>
</td></tr>
<tr><td><code id="itemUsageConstraint_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>operator = "&lt;="</code> and <code>value = 1</code> (the default), each item can
be selected maximally once, which corresponds with assuring that there is no
item overlap between the forms. When <code>operator = "="</code> and <code>value = 1</code>,
each item is used exactly once, which corresponds to no item-overlap and
complete item pool depletion.
</p>
<p>If certain items are required in the resulting test form(s), as for example anchor items,
<code>whichItems</code> can be used to constrain the usage of these items to be exactly 1.
<code>whichItems</code> can either be a numeric vector with item numbers or a character vector
with item identifiers corresponding to <code>itemIDs</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"constraint"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create no-item overlap constraints with item pool depletion
##  for 2 test forms with an item pool of 20 items
itemUsageConstraint(2, operator = "=", targetValue = 1,
                    itemIDs = 1:20)

## force certain items to be in the test, others not
usage1 &lt;- itemUsageConstraint(2, operator = "&lt;=", targetValue = 1,
                    itemIDs = paste0("item", 1:20))
usage2 &lt;- itemUsageConstraint(2, operator = "=", targetValue = 1,
                    itemIDs = paste0("item", 1:20),
                    whichItems = c("item5", "item8", "item10"))

</code></pre>

<hr>
<h2 id='itemValuesConstraint'>Constrain the sum of item values per form.</h2><span id='topic+itemValuesConstraint'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><p> Create constraints related to an item parameter/value. That is, the created
constraints assure that the sum of the item values (<code>itemValues</code>) per test form is either
(a) smaller than or equal to (<code>operator = "&lt;="</code>), (b) equal to
(<code>operator = "="</code>), or (c) greater than or equal to (<code>operator = "&gt;="</code>)
the chosen <code>targetValue</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemValuesConstraint(
  nForms,
  itemValues,
  operator = c("&lt;=", "=", "&gt;="),
  targetValue,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemValues)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemValuesConstraint_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="itemValuesConstraint_+3A_itemvalues">itemValues</code></td>
<td>
<p>Item parameter/values for which the sum per test form should be constrained.</p>
</td></tr>
<tr><td><code id="itemValuesConstraint_+3A_operator">operator</code></td>
<td>
<p>A character indicating which operator should be used in the
constraints, with three possible values: <code>"&lt;="</code>, <code>"="</code>,
or <code>"&gt;="</code>. See details for more information.</p>
</td></tr>
<tr><td><code id="itemValuesConstraint_+3A_targetvalue">targetValue</code></td>
<td>
<p>the target test form value.</p>
</td></tr>
<tr><td><code id="itemValuesConstraint_+3A_whichforms">whichForms</code></td>
<td>
<p>An integer vector indicating which test forms should be constrained. Defaults to all the test forms.</p>
</td></tr>
<tr><td><code id="itemValuesConstraint_+3A_info_text">info_text</code></td>
<td>
<p>a character string of length 1, to be used in the <code>"info"</code>-attribute of the resulting <code>constraint</code>-object.</p>
</td></tr>
<tr><td><code id="itemValuesConstraint_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>operator</code> is <code>"&lt;="</code>, the constraint can be mathematically formulated as:
\[\sum_{i=1}^{I} v_i \times x_{if} \leq t , \; \; \; \code{for} \:  f \in G,\]
where \(I\) refers to the number of items in the item pool, \(v_i\) is the
<code>itemValue</code> for item \(i\) and \(t\) is the <code>targetValue</code>. Further, \(G\)
corresponds to <code>whichForms</code>, so that the above inequality constraint
is repeated for every test form \(f\) in \(G\). In addition, let \(\boldsymbol{x}\)
be a vector of binary decision variables with length \(I \times F\), where \(F\)
is <code>nForms</code>. The binary decision variables \(x_{if}\) are defined as:
</p>

<table>
<tr>
 <td style="text-align: left;">
\(\;\;\;\;\;\;\;\;\) </td><td style="text-align: left;"> \(x_{if} = 1\),\(\;\;\;\;\)  </td><td style="text-align: left;"> if item \(i\) is assigned to form \(f\), and  </td>
</tr>
<tr>
 <td style="text-align: left;">
\(\;\;\;\;\;\;\;\;\) </td><td style="text-align: left;"> \(x_{if} = 0\),\(\;\;\;\;\)  </td><td style="text-align: left;"> otherwise.
</td>
</tr>

</table>



<h3>Value</h3>

<p>An object of class <code>"constraint"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## constraints to make sure that the sum of the item values (1:10) is between
## 4 and 6
combineConstraints(
  itemValuesConstraint(2, 1:10, operator = "&gt;=", targetValue = 4),
  itemValuesConstraint(2, 1:10, operator = "&lt;=", targetValue = 6)
)

</code></pre>

<hr>
<h2 id='itemValuesRangeConstraint'>Create single value constraints with minimum and maximum.</h2><span id='topic+itemValuesRangeConstraint'></span><span id='topic+itemValuesMinConstraint'></span><span id='topic+itemValuesMaxConstraint'></span><span id='topic+itemValuesDeviationConstraint'></span>

<h3>Description</h3>

<p><code>itemValuesRangeConstraint</code>, <code>itemValuesMinConstraint</code>, and <code>itemValuesMaxConstraint</code>
create constraints related to an item parameter/value. That is, the created
constraints assure that the sum of the <code>itemValues</code> is smaller than or equal
to <code>max</code>, greater than or equal to <code>min</code>, or both <code>range</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemValuesRangeConstraint(
  nForms,
  itemValues,
  range,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemValues)
)

itemValuesMinConstraint(
  nForms,
  itemValues,
  min,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemValues)
)

itemValuesMaxConstraint(
  nForms,
  itemValues,
  max,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemValues)
)

itemValuesDeviationConstraint(
  nForms,
  itemValues,
  targetValue,
  allowedDeviation,
  relative = FALSE,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemValues)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemValuesRangeConstraint_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="itemValuesRangeConstraint_+3A_itemvalues">itemValues</code></td>
<td>
<p>Item parameter/values for which the sum per test form should be constrained.</p>
</td></tr>
<tr><td><code id="itemValuesRangeConstraint_+3A_range">range</code></td>
<td>
<p>a vector with two values, the the minimal and the maximum sum of
the <code>itemValues</code> per test form, respectively</p>
</td></tr>
<tr><td><code id="itemValuesRangeConstraint_+3A_whichforms">whichForms</code></td>
<td>
<p>An integer vector indicating which test forms should be constrained. Defaults to all the test forms.</p>
</td></tr>
<tr><td><code id="itemValuesRangeConstraint_+3A_info_text">info_text</code></td>
<td>
<p>a character string of length 1, to be used in the <code>"info"</code>-attribute of the resulting <code>constraint</code>-object.</p>
</td></tr>
<tr><td><code id="itemValuesRangeConstraint_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
<tr><td><code id="itemValuesRangeConstraint_+3A_min">min</code></td>
<td>
<p>the minimal sum of the <code>itemValues</code> per test form</p>
</td></tr>
<tr><td><code id="itemValuesRangeConstraint_+3A_max">max</code></td>
<td>
<p>the minimal sum of the <code>itemValues</code> per test form</p>
</td></tr>
<tr><td><code id="itemValuesRangeConstraint_+3A_targetvalue">targetValue</code></td>
<td>
<p>the target test form value.</p>
</td></tr>
<tr><td><code id="itemValuesRangeConstraint_+3A_alloweddeviation">allowedDeviation</code></td>
<td>
<p>the maximum allowed deviation from the <code>targetValue</code></p>
</td></tr>
<tr><td><code id="itemValuesRangeConstraint_+3A_relative">relative</code></td>
<td>
<p>a logical expressing whether or not the <code>allowedDeviation</code>
should be interpreted as a proportion of the <code>targetValue</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>itemValuesDeviationConstraint</code> also constrains the minimal and the maximal value
of the sum of the <code>itemValues</code>, but based on a chosen
and a maximal allowed deviation (i.e., <code>allowedDeviation</code>) from that <code>targetValue</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"constraint"</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>itemValuesMinConstraint()</code>: constrain minimum value
</p>
</li>
<li> <p><code>itemValuesMaxConstraint()</code>: constrain maximum value
</p>
</li>
<li> <p><code>itemValuesDeviationConstraint()</code>: constrain the distance form the <code>targetValue</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## constraints to make sure that the sum of the item values (1:10) is between
## 4 and 6
itemValuesRangeConstraint(2, 1:10, range(min = 4, max = 6))

## or alternatively
itemValuesDeviationConstraint(2, 1:10, targetValue = 5,
allowedDeviation = 1)

</code></pre>

<hr>
<h2 id='matrixExclusionTuples'>Create item exclusion tuples from matrix.</h2><span id='topic+matrixExclusionTuples'></span>

<h3>Description</h3>

<p>If item exclusions are stored as a matrix, <code>matrixExclusionTuples</code> transforms this format into item pairs ('tuples').
Information on exclusions has to be coded as <code>1</code> (items are exclusive) and <code>0</code> (items are not exclusive).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixExclusionTuples(exclMatrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixExclusionTuples_+3A_exclmatrix">exclMatrix</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> with information on item exclusiveness.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exclusion tuples can be used by <code><a href="#topic+itemExclusionConstraint">itemExclusionConstraint</a></code> to set up exclusion constraints.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with two columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data.frame
exclDF &lt;- data.frame(c(0, 1, 0, 0),
                     c(1, 0, 0, 1),
                     c(0, 0, 0, 0),
                     c(0, 1, 0, 0))
rownames(exclDF) &lt;- colnames(exclDF) &lt;- paste0("item_", 1:4)

# Create tuples
matrixExclusionTuples(exclDF)


</code></pre>

<hr>
<h2 id='maximinObjective'>Maximin Constraint.</h2><span id='topic+maximinObjective'></span>

<h3>Description</h3>

<p>Create <code>maximin</code>-constraints related to an item parameter/value. That is, the created
constraints can be used to maximize the minimal sum of the
item values (<code>itemValues</code>), while at the same time setting an upper limit to the
overflow by means of a maximally allowed deviation <code>allowedDeviation</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximinObjective(
  nForms,
  itemValues,
  allowedDeviation,
  weight = 1,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemValues)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximinObjective_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="maximinObjective_+3A_itemvalues">itemValues</code></td>
<td>
<p>Item parameter/values for which the sum per test form should be constrained.</p>
</td></tr>
<tr><td><code id="maximinObjective_+3A_alloweddeviation">allowedDeviation</code></td>
<td>
<p>the maximum allowed deviation between the sum of the target values.</p>
</td></tr>
<tr><td><code id="maximinObjective_+3A_weight">weight</code></td>
<td>
<p>a weight for the real-valued variable(s). Useful when multiple constraints are combined. Should only be used if the implications are well understood.</p>
</td></tr>
<tr><td><code id="maximinObjective_+3A_whichforms">whichForms</code></td>
<td>
<p>An integer vector indicating which test forms should be constrained. Defaults to all the test forms.</p>
</td></tr>
<tr><td><code id="maximinObjective_+3A_info_text">info_text</code></td>
<td>
<p>a character string of length 1, to be used in the <code>"info"</code>-attribute of the resulting <code>constraint</code>-object.</p>
</td></tr>
<tr><td><code id="maximinObjective_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"constraint"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraint that minimizes the maximum difference per test form value and a
#   target value of 0
maximinObjective(nForms = 2, itemValues = rep(-2:2, 2),
                 allowedDeviation = 1)

</code></pre>

<hr>
<h2 id='maxObjective'>Max Constraint.</h2><span id='topic+maxObjective'></span>

<h3>Description</h3>

<p>Create <code>max</code>-constraints related to an item parameter/value. That is, the created
constraints can be used to maximize the sum of the
item values (<code>itemValues</code>) of the test form.
Note that this constraint can only be used when only one test form has to be assembled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxObjective(
  nForms,
  itemValues,
  weight = 1,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemValues)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxObjective_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="maxObjective_+3A_itemvalues">itemValues</code></td>
<td>
<p>Item parameter/values for which the sum per test form should be constrained.</p>
</td></tr>
<tr><td><code id="maxObjective_+3A_weight">weight</code></td>
<td>
<p>a weight for the real-valued variable(s). Useful when multiple constraints are combined. Should only be used if the implications are well understood.</p>
</td></tr>
<tr><td><code id="maxObjective_+3A_whichforms">whichForms</code></td>
<td>
<p>An integer vector indicating which test forms should be constrained. Defaults to all the test forms.</p>
</td></tr>
<tr><td><code id="maxObjective_+3A_info_text">info_text</code></td>
<td>
<p>a character string of length 1, to be used in the <code>"info"</code>-attribute of the resulting <code>constraint</code>-object.</p>
</td></tr>
<tr><td><code id="maxObjective_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"constraint"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraint that maximizes the sum of the itemValues
maxObjective(nForms = 1, itemValues = rep(-2:2, 2))

</code></pre>

<hr>
<h2 id='minimaxObjective'>Minimax Constraint.</h2><span id='topic+minimaxObjective'></span>

<h3>Description</h3>

<p>Create <code>minimax</code>-constraints related to an item parameter/value. That is, the created
constraints can be used to minimize the maximum distance between the sum of the
item values (<code>itemValues</code>) per test form and the chosen <code>targetValue</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimaxObjective(
  nForms,
  itemValues,
  targetValue,
  weight = 1,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemValues)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimaxObjective_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="minimaxObjective_+3A_itemvalues">itemValues</code></td>
<td>
<p>Item parameter/values for which the sum per test form should be constrained.</p>
</td></tr>
<tr><td><code id="minimaxObjective_+3A_targetvalue">targetValue</code></td>
<td>
<p>the target test form value.</p>
</td></tr>
<tr><td><code id="minimaxObjective_+3A_weight">weight</code></td>
<td>
<p>a weight for the real-valued variable(s). Useful when multiple constraints are combined. Should only be used if the implications are well understood.</p>
</td></tr>
<tr><td><code id="minimaxObjective_+3A_whichforms">whichForms</code></td>
<td>
<p>An integer vector indicating which test forms should be constrained. Defaults to all the test forms.</p>
</td></tr>
<tr><td><code id="minimaxObjective_+3A_info_text">info_text</code></td>
<td>
<p>a character string of length 1, to be used in the <code>"info"</code>-attribute of the resulting <code>constraint</code>-object.</p>
</td></tr>
<tr><td><code id="minimaxObjective_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"constraint"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraint that minimizes the maximum difference per test form value and a
#   target value of 0
minimaxObjective(nForms = 2,
                 itemValues = rep(-2:2, 2),
                 targetValue = 0)

</code></pre>

<hr>
<h2 id='minObjective'>Min Constraint.</h2><span id='topic+minObjective'></span>

<h3>Description</h3>

<p>Create <code>min</code>-constraints related to an item parameter/value. That is, the created
constraints can be used to minimize the sum of the
item values (<code>itemValues</code>) of the test form.
Note that this constraint can only be used when only one test form has to be assembled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minObjective(
  nForms,
  itemValues,
  weight = 1,
  whichForms = seq_len(nForms),
  info_text = NULL,
  itemIDs = names(itemValues)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minObjective_+3A_nforms">nForms</code></td>
<td>
<p>Number of forms to be created.</p>
</td></tr>
<tr><td><code id="minObjective_+3A_itemvalues">itemValues</code></td>
<td>
<p>Item parameter/values for which the sum per test form should be constrained.</p>
</td></tr>
<tr><td><code id="minObjective_+3A_weight">weight</code></td>
<td>
<p>a weight for the real-valued variable(s). Useful when multiple constraints are combined. Should only be used if the implications are well understood.</p>
</td></tr>
<tr><td><code id="minObjective_+3A_whichforms">whichForms</code></td>
<td>
<p>An integer vector indicating which test forms should be constrained. Defaults to all the test forms.</p>
</td></tr>
<tr><td><code id="minObjective_+3A_info_text">info_text</code></td>
<td>
<p>a character string of length 1, to be used in the <code>"info"</code>-attribute of the resulting <code>constraint</code>-object.</p>
</td></tr>
<tr><td><code id="minObjective_+3A_itemids">itemIDs</code></td>
<td>
<p>a character vector of item IDs in correct ordering, or NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"constraint"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraint that maximizes the sum of the itemValues
maxObjective(nForms = 1, itemValues = rep(-2:2, 2))

</code></pre>

<hr>
<h2 id='stemInclusionTuples'>Create item inclusion tuples from item stem.</h2><span id='topic+stemInclusionTuples'></span>

<h3>Description</h3>

<p>If item-stimulus hierarchies are stored in a single stimulus column,
<code>stemInclusionTuples</code> transforms this format into item pairs ('tuples').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stemInclusionTuples(items, idCol = "ID", stemCol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stemInclusionTuples_+3A_items">items</code></td>
<td>
<p>A <code>data.frame</code> with information on an item pool.</p>
</td></tr>
<tr><td><code id="stemInclusionTuples_+3A_idcol">idCol</code></td>
<td>
<p>character or integer indicating the item ID column in <code>items</code>.</p>
</td></tr>
<tr><td><code id="stemInclusionTuples_+3A_stemcol">stemCol</code></td>
<td>
<p>A column in <code>items</code> containing the item stems or stimulus names, shared among items which should be in the same test form.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inclusion tuples can be used by <code><a href="#topic+itemInclusionConstraint">itemInclusionConstraint</a></code> to set up inclusion constraints.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with two columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data.frame
inclDF &lt;- data.frame(ID = paste0("item_", 1:6),
          stem = c(rep("stim_1", 3), "stim_3", "stim_4", "stim_3"),
          stringsAsFactors = FALSE)

# Create tuples
stemInclusionTuples(inclDF, idCol = "ID", stemCol = "stem")


</code></pre>

<hr>
<h2 id='useSolver'>Use a solver for a list of constraints.</h2><span id='topic+useSolver'></span>

<h3>Description</h3>

<p>Use a mathematical programming solver to solve a list for constrains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>useSolver(
  allConstraints,
  solver = c("GLPK", "lpSolve", "Gurobi", "Symphony"),
  timeLimit = Inf,
  formNames = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="useSolver_+3A_allconstraints">allConstraints</code></td>
<td>
<p>List of constraints.</p>
</td></tr>
<tr><td><code id="useSolver_+3A_solver">solver</code></td>
<td>
<p>A character string indicating the solver to use.</p>
</td></tr>
<tr><td><code id="useSolver_+3A_timelimit">timeLimit</code></td>
<td>
<p>The maximal runtime in seconds.</p>
</td></tr>
<tr><td><code id="useSolver_+3A_formnames">formNames</code></td>
<td>
<p>A character vector with names to give to the forms.</p>
</td></tr>
<tr><td><code id="useSolver_+3A_...">...</code></td>
<td>
<p>Additional arguments for the solver.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper around the functions of different solvers (<code>gurobi::gurobi(),
lpSolve::lp(), ...</code> for a list of constraints set up via <code>eatATA</code>.
<code>Rglpk</code> is used per default.
</p>
<p>Additional arguments can be passed through
<code>...</code> and vary from solver to solver (see their respective help pages,
<code><a href="lpSolve.html#topic+lp">lp</a></code> or <code><a href="Rglpk.html#topic+Rglpk_solve_LP">Rglpk_solve_LP</a></code>); for example
time limits can not be set for <code>lpSolve</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<dl>
<dt><code>solution_found</code></dt><dd><p>Was a solution found?</p>
</dd>
<dt><code>solution</code></dt><dd><p>Numeric vector containing the found solution.</p>
</dd>
<dt><code>solution_status</code></dt><dd><p>Was the solution optimal?</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>nForms &lt;- 2
nItems &lt;- 4

# create constraits
target &lt;- minimaxObjective(nForms = nForms, c(1, 0.5, 1.5, 2),
                       targetValue = 2, itemIDs = 1:nItems)
noItemOverlap &lt;- itemUsageConstraint(nForms, operator = "=", itemIDs = 1:nItems)
testLength &lt;- itemsPerFormConstraint(nForms = nForms,
                           operator = "&lt;=", targetValue = 2, itemIDs = 1:nItems)

# use a solver
result &lt;- useSolver(list(target, noItemOverlap, testLength),
  itemIDs = paste0("Item_", 1:4),
  solver = "GLPK")



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
