<!DOCTYPE html><html><head><title>Help for package GPareto</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GPareto}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checkPredict'><p>Prevention of numerical instability for a new observation</p></a></li>
<li><a href='#CPF'><p>Conditional Pareto Front simulations</p></a></li>
<li><a href='#crit_EHI'><p>Expected Hypervolume Improvement with m objectives</p></a></li>
<li><a href='#crit_EMI'><p>Expected Maximin Improvement with m objectives</p></a></li>
<li><a href='#crit_optimizer'><p>Maximization of multiobjective infill criterion</p></a></li>
<li><a href='#crit_qEHI'><p>Batch Expected Hypervolume Improvement with m objectives</p></a></li>
<li><a href='#crit_SMS'><p>Analytical expression of the SMS-EGO criterion with m&gt;1 objectives</p></a></li>
<li><a href='#crit_SUR'><p>Analytical expression of the SUR criterion for two or three objectives.</p></a></li>
<li><a href='#easyGParetoptim'><p>EGO algorithm for multiobjective optimization</p></a></li>
<li><a href='#fastfun'><p>Fast-to-evaluate function wrapper</p></a></li>
<li><a href='#fastfun-class'><p>Class for fast to compute objective.</p></a></li>
<li><a href='#getDesign'><p>Get design corresponding to an objective target</p></a></li>
<li><a href='#GPareto-package'><p>Package GPareto</p></a></li>
<li><a href='#GParetoptim'><p>Sequential multi-objective Expected Improvement maximization and model re-estimation,</p>
with a number of iterations fixed in advance by the user</a></li>
<li><a href='#integration_design_optim'><p>Function to build integration points (for the SUR criterion)</p></a></li>
<li><a href='#nonDomSet'><p>Non-dominated points with respect to a reference</p></a></li>
<li><a href='#ParetoSetDensity'><p>Estimation of Pareto set density</p></a></li>
<li><a href='#plot_uncertainty'><p>Plot uncertainty</p></a></li>
<li><a href='#plotGPareto'><p>Plot multi-objective optimization results and post-processing</p></a></li>
<li><a href='#plotParetoEmp'><p>Pareto front visualization</p></a></li>
<li><a href='#plotParetoGrid'><p>Visualisation of Pareto front and set</p></a></li>
<li><a href='#plotSymDevFun'><p>Display the Symmetric Deviation Function</p></a></li>
<li><a href='#plotSymDifRNP'><p>Symmetrical difference of RNP sets</p></a></li>
<li><a href='#predict_kms'><p>Predict function for list of <code>km</code> models.</p></a></li>
<li><a href='#ZDT1'><p>Test functions of x</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gaussian Processes for Pareto Front Estimation and Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Mickael Binois, Victor Picheny</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mickael Binois &lt;mickael.binois@inria.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Gaussian process regression models, a.k.a. Kriging models, are
    applied to global multi-objective optimization of black-box functions.
    Multi-objective Expected Improvement and Step-wise Uncertainty Reduction
    sequential infill criteria are available. A quantification of uncertainty
    on Pareto fronts is provided using conditional simulations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>DiceKriging, emoa</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.15), methods, rgenoud, pbivnorm, pso,
randtoolbox, KrigInv, MASS, DiceDesign, ks, rgl</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, DiceOptim</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mbinois/GPareto">https://github.com/mbinois/GPareto</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mbinois/GPareto/issues">https://github.com/mbinois/GPareto/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-26 15:28:08 UTC; mbinois</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-26 16:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='checkPredict'>Prevention of numerical instability for a new observation</h2><span id='topic+checkPredict'></span>

<h3>Description</h3>

<p>Check that the new point is not too close to already known observations to avoid numerical issues.
Closeness can be estimated with several distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPredict(x, model, threshold = 1e-04, distance = "euclidean", type = "UK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkPredict_+3A_x">x</code></td>
<td>
<p>a vector representing the input to check, alternatively a matrix with one point per row,</p>
</td></tr>
<tr><td><code id="checkPredict_+3A_model">model</code></td>
<td>
<p>list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>, one for each objective functions,</p>
</td></tr>
<tr><td><code id="checkPredict_+3A_threshold">threshold</code></td>
<td>
<p>optional value for the minimal distance to an existing observation, default to <code>1e-4</code>,</p>
</td></tr>
<tr><td><code id="checkPredict_+3A_distance">distance</code></td>
<td>
<p>selection of the distance between new observations, between &quot;<code>euclidean</code>&quot; (default), &quot;<code>none</code>&quot;,
&quot;<code>covdist</code>&quot; and &quot;<code>covratio</code>&quot;, see details,</p>
</td></tr>
<tr><td><code id="checkPredict_+3A_type">type</code></td>
<td>
<p>&quot;<code>SK</code>&quot; or &quot;<code>UK</code>&quot; (default), depending whether uncertainty related to trend estimation has to be taken into account.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the distance between <code>x</code> and the closest observations in <code>model</code> is below
<code>threshold</code>, <code>x</code> should not be evaluated to avoid numerical instabilities.
The distance can simply be the Euclidean distance or the canonical distance associated with the kriging predictive covariance k: 
</p>
<p style="text-align: center;"><code class="reqn">d(x,y) = \sqrt{k(x,x) - 2k(x,y) + k(y,y)}.</code>
</p>
 
<p>The last solution is the ratio between the prediction variance at <code>x</code> and the variance of the process.
<code>none</code> can be used, e.g., if points have been selected already.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if the point should not be tested.
</p>

<hr>
<h2 id='CPF'>Conditional Pareto Front simulations</h2><span id='topic+CPF'></span>

<h3>Description</h3>

<p>Compute (on a regular grid) the empirical attainment function from conditional simulations 
of Gaussian processes corresponding to two objectives. This is used to estimate the Vorob'ev
expectation of the attained set and the Vorob'ev deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPF(
  fun1sims,
  fun2sims,
  response,
  paretoFront = NULL,
  f1lim = NULL,
  f2lim = NULL,
  refPoint = NULL,
  n.grid = 100,
  compute.VorobExp = TRUE,
  compute.VorobDev = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CPF_+3A_fun1sims">fun1sims</code></td>
<td>
<p>numeric matrix containing the conditional simulations of the first output (one sample in each row),</p>
</td></tr>
<tr><td><code id="CPF_+3A_fun2sims">fun2sims</code></td>
<td>
<p>numeric matrix containing the conditional simulations of the second output (one sample in each row),</p>
</td></tr>
<tr><td><code id="CPF_+3A_response">response</code></td>
<td>
<p>a matrix containing the value of the two objective functions, one
output per row,</p>
</td></tr>
<tr><td><code id="CPF_+3A_paretofront">paretoFront</code></td>
<td>
<p>optional matrix corresponding to the Pareto front of the observations. It is 
estimated from <code>response</code> if not provided,</p>
</td></tr>
<tr><td><code id="CPF_+3A_f1lim">f1lim</code></td>
<td>
<p>optional vector (see details),</p>
</td></tr>
<tr><td><code id="CPF_+3A_f2lim">f2lim</code></td>
<td>
<p>optional vector (see details),</p>
</td></tr>
<tr><td><code id="CPF_+3A_refpoint">refPoint</code></td>
<td>
<p>optional vector (see details),</p>
</td></tr>
<tr><td><code id="CPF_+3A_n.grid">n.grid</code></td>
<td>
<p>integer determining the grid resolution,</p>
</td></tr>
<tr><td><code id="CPF_+3A_compute.vorobexp">compute.VorobExp</code></td>
<td>
<p>optional boolean indicating whether the Vorob'ev Expectation
should be computed. Default is <code>TRUE</code>,</p>
</td></tr>
<tr><td><code id="CPF_+3A_compute.vorobdev">compute.VorobDev</code></td>
<td>
<p>optional boolean indicating whether the Vorob'ev deviation
should be computed. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Works with two objectives. The user can provide locations of grid lines for
computation of the attainement function with vectors <code>f1lim</code> and <code>f2lim</code>, in the form of regularly spaced points. 
It is possible to provide only <code>refPoint</code> as a reference for hypervolume computations.
When missing, values are determined from the axis-wise extrema of the simulations.
</p>


<h3>Value</h3>

<p>A list which is given the S3 class &quot;<code>CPF</code>&quot;.
</p>

<ul>
<li> <p><code>x, y</code>: locations of grid lines at which the values of the attainment
are computed,
</p>
</li>
<li> <p><code>values</code>: numeric matrix containing the values of the attainment on the grid,
</p>
</li>
<li> <p><code>PF</code>: matrix corresponding to the Pareto front of the observations,
</p>
</li>
<li> <p><code>responses</code>: matrix containing the value of the two objective functions, one
objective per column,
</p>
</li>
<li> <p><code>fun1sims, fun2sims</code>: conditional simulations of the first/second output,
</p>
</li>
<li> <p><code>VE</code>: Vorob'ev expectation, computed if <code>compute.VorobExp = TRUE</code> (default),
</p>
</li>
<li> <p><code>beta_star</code>: Vorob'ev threshold, computed if <code>compute.VorobExp = TRUE</code> (default),
</p>
</li>
<li> <p><code>VD</code>: Vorov'ev deviation, computed if <code>compute.VorobDev = TRUE</code> (default),
</p>
</li></ul>



<h3>References</h3>

<p>M. Binois, D. Ginsbourger and O. Roustant (2015), Quantifying Uncertainty on Pareto Fronts with Gaussian process conditional simulations, 
<em>European Journal of Operational Research</em>, 243(2), 386-394. <br /> <br />
C. Chevalier (2013), <em>Fast uncertainty reduction strategies relying on Gaussian process models</em>, University of Bern, PhD thesis. <br /> <br />
I. Molchanov (2005), <em>Theory of random sets</em>, Springer.
</p>


<h3>See Also</h3>

<p>Methods <code>coef</code>, <code>summary</code> and <code>plot</code> can be used to get the coefficients from a <code>CPF</code> object, 
to obtain a summary or to display the attainment function (with the Vorob'ev expectation if <code>compute.VorobExp</code> is <code>TRUE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DiceDesign)
set.seed(42)

nvar &lt;- 2

fname &lt;- "P1" # Test function

# Initial design
nappr &lt;- 10
design.grid &lt;- maximinESE_LHS(lhsDesign(nappr, nvar, seed = 42)$design)$design
response.grid &lt;- t(apply(design.grid, 1, fname))

# kriging models: matern5_2 covariance structure, linear trend, no nugget effect
mf1 &lt;- km(~., design = design.grid, response = response.grid[,1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[,2])

# Conditional simulations generation with random sampling points 
nsim &lt;- 40
npointssim &lt;- 150 # increase for better results
Simu_f1 &lt;- matrix(0, nrow = nsim, ncol = npointssim)
Simu_f2 &lt;- matrix(0, nrow = nsim, ncol = npointssim)
design.sim &lt;- array(0, dim = c(npointssim, nvar, nsim))

for(i in 1:nsim){
  design.sim[,,i] &lt;- matrix(runif(nvar*npointssim), nrow = npointssim, ncol = nvar)
  Simu_f1[i,] &lt;- simulate(mf1, nsim = 1, newdata = design.sim[,,i], cond = TRUE,
                          checkNames = FALSE, nugget.sim = 10^-8)
  Simu_f2[i,] &lt;- simulate(mf2, nsim = 1, newdata = design.sim[,,i], cond = TRUE, 
                          checkNames = FALSE, nugget.sim = 10^-8)
}

# Attainment and Voreb'ev expectation + deviation estimation
CPF1 &lt;- CPF(Simu_f1, Simu_f2, response.grid)

# Details about the Vorob'ev threshold  and Vorob'ev deviation
summary(CPF1)

# Graphics
plot(CPF1)

</code></pre>

<hr>
<h2 id='crit_EHI'>Expected Hypervolume Improvement with m objectives</h2><span id='topic+crit_EHI'></span>

<h3>Description</h3>

<p>Multi-objective Expected Hypervolume Improvement with respect to the
current Pareto front. With two objectives the analytical formula is used, while 
Sample Average Approximation (SAA) is used with more objectives.
To avoid numerical instabilities, the new point is penalized if it is too close to an existing observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crit_EHI(
  x,
  model,
  paretoFront = NULL,
  critcontrol = list(nb.samp = 50, seed = 42),
  type = "UK"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crit_EHI_+3A_x">x</code></td>
<td>
<p>a vector representing the input for which one wishes to calculate <code>EHI</code>, alternatively a matrix with one point per row,</p>
</td></tr>
<tr><td><code id="crit_EHI_+3A_model">model</code></td>
<td>
<p>list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>, one for each objective functions,</p>
</td></tr>
<tr><td><code id="crit_EHI_+3A_paretofront">paretoFront</code></td>
<td>
<p>(optional) matrix corresponding to the Pareto front of size <code>[n.pareto x n.obj]</code>, or any reference set of observations,</p>
</td></tr>
<tr><td><code id="crit_EHI_+3A_critcontrol">critcontrol</code></td>
<td>
<p>optional list with arguments:
</p>

<ul>
<li> <p><code>nb.samp</code> number of random samples from the posterior distribution (with more than two objectives),
default to <code>50</code>, increasing gives more reliable results at the cost of longer computation time;
</p>
</li>
<li> <p><code>seed</code> seed used for the random samples (with more than two objectives);
</p>
</li>
<li> <p><code>refPoint</code> reference point for Hypervolume Expected Improvement;
</p>
</li>
<li> <p><code>extendper</code> if no reference point <code>refPoint</code> is provided,
for each objective it is fixed to the maximum over the Pareto front plus extendper times the range, 
Default value to <code>0.2</code>, corresponding to <code>1.1</code> for a scaled objective with a Pareto front in <code>[0,1]^n.obj</code>.
</p>
</li></ul>
 
<p>Options for the <code><a href="#topic+checkPredict">checkPredict</a></code> function: <code>threshold</code> (<code>1e-4</code>) and <code>distance</code> (<code>covdist</code>) are used to avoid numerical issues occuring when adding points too close to the existing ones.</p>
</td></tr>
<tr><td><code id="crit_EHI_+3A_type">type</code></td>
<td>
<p>&quot;<code>SK</code>&quot; or &quot;<code>UK</code>&quot; (by default), depending whether uncertainty related to trend estimation 
has to be taken into account.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of the analytical formula with two objectives is adapted from the Matlab source code by Michael Emmerich and Andre Deutz, LIACS, 
Leiden University, 2010 available here :
<a href="http://liacs.leidenuniv.nl/~csmoda/code/HV_based_expected_improvement.zip">http://liacs.leidenuniv.nl/~csmoda/code/HV_based_expected_improvement.zip</a>.
</p>


<h3>Value</h3>

<p>The Expected Hypervolume Improvement at <code>x</code>.
</p>


<h3>References</h3>

<p>J. D. Svenson (2011), <em>Computer Experiments: Multiobjective Optimization and Sensitivity Analysis</em>, Ohio State University, PhD thesis.  <br /> <br />
M. T. Emmerich, A. H. Deutz, J. W. Klinkenberg (2011), Hypervolume-based expected improvement: Monotonicity properties and exact computation,
<em>Evolutionary Computation (CEC)</em>, 2147-2154. <br /> <br />
</p>


<h3>See Also</h3>

<p><code><a href="DiceOptim.html#topic+EI">EI</a></code> from package DiceOptim, <code><a href="#topic+crit_EMI">crit_EMI</a></code>, <code><a href="#topic+crit_SUR">crit_SUR</a></code>, <code><a href="#topic+crit_SMS">crit_SMS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---------------------------------------------------------------------------
# Expected Hypervolume Improvement surface associated with the "P1" problem at a 15 points design
#---------------------------------------------------------------------------
set.seed(25468)
library(DiceDesign)

n_var &lt;- 2 
f_name &lt;- "P1" 
n.grid &lt;- 26
test.grid &lt;- expand.grid(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid))
n_appr &lt;- 15 
design.grid &lt;- round(maximinESE_LHS(lhsDesign(n_appr, n_var, seed = 42)$design)$design, 1)
response.grid &lt;- t(apply(design.grid, 1, f_name))
Front_Pareto &lt;- t(nondominated_points(t(response.grid)))
mf1 &lt;- km(~., design = design.grid, response = response.grid[,1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[,2])

EHI_grid &lt;- crit_EHI(x = as.matrix(test.grid), model = list(mf1, mf2),
         critcontrol = list(refPoint = c(300,0)))

filled.contour(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid), nlevels = 50,
               matrix(EHI_grid, n.grid), main = "Expected Hypervolume Improvement",
               xlab = expression(x[1]), ylab = expression(x[2]), color = terrain.colors, 
               plot.axes = {axis(1); axis(2);
                            points(design.grid[,1], design.grid[,2], pch = 21, bg = "white")
                            }
              )
</code></pre>

<hr>
<h2 id='crit_EMI'>Expected Maximin Improvement with m objectives</h2><span id='topic+crit_EMI'></span>

<h3>Description</h3>

<p>Expected Maximin Improvement with respect to the current Pareto front with Sample Average Approximation.
The semi-analytical formula is used in the bi-objective scale if the Pareto front is in [-2,2]^2,
for numerical stability reasons. 
To avoid numerical instabilities, the new point is penalized if it is too close to an existing observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crit_EMI(
  x,
  model,
  paretoFront = NULL,
  critcontrol = list(nb.samp = 50, seed = 42),
  type = "UK"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crit_EMI_+3A_x">x</code></td>
<td>
<p>a vector representing the input for which one wishes to calculate <code>EMI</code>,</p>
</td></tr>
<tr><td><code id="crit_EMI_+3A_model">model</code></td>
<td>
<p>list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>, one for each objective functions,</p>
</td></tr>
<tr><td><code id="crit_EMI_+3A_paretofront">paretoFront</code></td>
<td>
<p>(optional) matrix corresponding to the Pareto front of size <code>[n.pareto x n.obj]</code>, or any reference set of observations,</p>
</td></tr>
<tr><td><code id="crit_EMI_+3A_critcontrol">critcontrol</code></td>
<td>
<p>optional list with arguments (for more than 2 objectives only): 
</p>

<ul>
<li> <p><code>nb.samp</code> number of random samples from the posterior distribution,
default to <code>50</code>, increasing gives more reliable results at the cost of longer computation time;
</p>
</li>
<li>  <p><code>seed</code> seed used for the random samples.
</p>
</li></ul>

<p>Options for the <code><a href="#topic+checkPredict">checkPredict</a></code> function: <code>threshold</code> (<code>1e-4</code>) and <code>distance</code> (<code>covdist</code>) are used to avoid numerical issues occuring when adding points too close to the existing ones.</p>
</td></tr>
<tr><td><code id="crit_EMI_+3A_type">type</code></td>
<td>
<p>&quot;<code>SK</code>&quot; or &quot;<code>UK</code>&quot; (by default), depending whether uncertainty related to trend estimation 
has to be taken into account.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommanded to scale objectives, e.g. to <code>[0,1]</code>. 
If the Pareto front does not belong to [-2,2]^2, then SAA is used.
</p>


<h3>Value</h3>

<p>The Expected Maximin Improvement at <code>x</code>.
</p>


<h3>References</h3>

<p>J. D. Svenson &amp; T. J. Santner (2010), Multiobjective Optimization of Expensive Black-Box
Functions via Expected Maximin Improvement, Technical Report.<br />
</p>
<p>J. D. Svenson (2011), <em>Computer Experiments: Multiobjective Optimization and Sensitivity Analysis</em>, Ohio State University, PhD thesis.
</p>


<h3>See Also</h3>

<p><code><a href="DiceOptim.html#topic+EI">EI</a></code> from package DiceOptim, <code><a href="#topic+crit_EHI">crit_EHI</a></code>, <code><a href="#topic+crit_SUR">crit_SUR</a></code>, <code><a href="#topic+crit_SMS">crit_SMS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---------------------------------------------------------------------------
# Expected Maximin Improvement surface associated with the "P1" problem at a 15 points design
#---------------------------------------------------------------------------
set.seed(25468)
library(DiceDesign)

n_var &lt;- 2 
f_name &lt;- "P1" 
n.grid &lt;- 21
test.grid &lt;- expand.grid(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid))
n_appr &lt;- 15 
design.grid &lt;- round(maximinESE_LHS(lhsDesign(n_appr, n_var, seed = 42)$design)$design, 1)
response.grid &lt;- t(apply(design.grid, 1, f_name))
Front_Pareto &lt;- t(nondominated_points(t(response.grid)))
mf1 &lt;- km(~., design = design.grid, response = response.grid[,1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[,2])

EMI_grid &lt;- apply(test.grid, 1, crit_EMI, model = list(mf1, mf2), paretoFront = Front_Pareto,
                     critcontrol = list(nb_samp = 20))

filled.contour(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid), nlevels = 50,
               matrix(EMI_grid, nrow = n.grid), main = "Expected Maximin Improvement",
               xlab = expression(x[1]), ylab = expression(x[2]), color = terrain.colors,
               plot.axes = {axis(1); axis(2);
                            points(design.grid[,1], design.grid[,2], pch = 21, bg = "white")
                            }
              )
</code></pre>

<hr>
<h2 id='crit_optimizer'>Maximization of multiobjective infill criterion</h2><span id='topic+crit_optimizer'></span>

<h3>Description</h3>

<p>Given a list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code> and a set of tuning
parameters (<code>lower, upper and critcontrol</code>), <code>crit_optimizer</code> performs
the maximization of an infill criterion and delivers
the next point to be visited in a multi-objective EGO-like procedure. <br /> <br />
The latter maximization relies either on a genetic algorithm using derivatives,
<code><a href="rgenoud.html#topic+genoud">genoud</a></code>, particle swarm algorithm <code><a href="pso.html#topic+pso-package">pso-package</a></code>,
exhaustive search at pre-specified points or on a user defined method. 
It is important to remark that the information
needed about the objective function reduces here to the vector of response values
embedded in the models (no call to the objective functions or simulators (except with <code>cheapfn</code>)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crit_optimizer(
  crit = "SMS",
  model,
  lower,
  upper,
  cheapfn = NULL,
  type = "UK",
  paretoFront = NULL,
  critcontrol = NULL,
  optimcontrol = NULL,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crit_optimizer_+3A_crit">crit</code></td>
<td>
<p>sampling criterion. Four choices are available : &quot;<code>SMS</code>&quot;, &quot;<code>EHI</code>&quot;, &quot;<code>EMI</code>&quot; and &quot;<code>SUR</code>&quot;,</p>
</td></tr>
<tr><td><code id="crit_optimizer_+3A_model">model</code></td>
<td>
<p>list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>, one for each objective functions,</p>
</td></tr>
<tr><td><code id="crit_optimizer_+3A_lower">lower</code></td>
<td>
<p>vector of lower bounds for the variables to be optimized over,</p>
</td></tr>
<tr><td><code id="crit_optimizer_+3A_upper">upper</code></td>
<td>
<p>vector of upper bounds for the variables to be optimized over,</p>
</td></tr>
<tr><td><code id="crit_optimizer_+3A_cheapfn">cheapfn</code></td>
<td>
<p>optional additional fast-to-evaluate objective function (handled next with class <code><a href="#topic+fastfun">fastfun</a></code>), which does not need a kriging model,</p>
</td></tr>
<tr><td><code id="crit_optimizer_+3A_type">type</code></td>
<td>
<p>&quot;<code>SK</code>&quot; or &quot;<code>UK</code>&quot; (default), depending whether uncertainty related to trend estimation has to be taken into account.</p>
</td></tr>
<tr><td><code id="crit_optimizer_+3A_paretofront">paretoFront</code></td>
<td>
<p>(optional) matrix corresponding to the Pareto front of size <code>[n.pareto x n.obj]</code>, or any reference set of observations,</p>
</td></tr>
<tr><td><code id="crit_optimizer_+3A_critcontrol">critcontrol</code></td>
<td>
<p>optional list of control parameters for criterion <code>crit</code>, see details.
Options for the <code><a href="#topic+checkPredict">checkPredict</a></code> function: <code>threshold</code> (<code>1e-4</code>) and <code>distance</code> (<code>covdist</code>) are used to avoid numerical issues 
occuring when adding points too close to the existing ones.</p>
</td></tr>
<tr><td><code id="crit_optimizer_+3A_optimcontrol">optimcontrol</code></td>
<td>
<p>optional list of control parameters for optimization of the selected infill criterion. 
&quot;<code>method</code>&quot; set the optimization method; one can 
choose between &quot;<code>discrete</code>&quot;, &quot;<code>pso</code>&quot; and &quot;<code>genoud</code>&quot; or a user defined method name (passed to <code><a href="base.html#topic+match.fun">match.fun</a></code>). 
For each method, further parameters can be set.<br /> 
For &quot;<code>discrete</code>&quot;, one has to provide the argument &quot;<code>candidate.points</code>&quot;. <br />
For &quot;<code>pso</code>&quot;, one can control the maximum number of iterations &quot;<code>maxit</code>&quot; (<code>400</code>) and the population size &quot;<code>s</code>&quot;
(default :  <code>max(20, floor(10+2*sqrt(dim)))</code> (see <code><a href="pso.html#topic+psoptim">psoptim</a></code>). <br />
For &quot;<code>genoud</code>&quot;, one can control, among others, &quot;<code>pop.size</code>&quot; (default :  <code>[N = 3*2^dim</code> for <code>dim &lt; 6</code> and  <code>N = 32*dim</code> otherwise]),
&quot;<code>max.generations</code>&quot; (<code>12</code>), &quot;<code>wait.generations</code>&quot; (<code>2</code>), &quot;<code>BFGSburnin</code>&quot; (<code>2</code>), <code>BFGSmaxit</code> (<code>N</code>) and 
<code>solution.tolerance</code> (<code>1e-21</code>)
of function &quot;<code>genoud</code>&quot; (see <code><a href="rgenoud.html#topic+genoud">genoud</a></code>). Numbers into brackets are the default values.<br />
For a user defined method, it must have arguments like the default <code><a href="stats.html#topic+optim">optim</a></code> method, i.e. <code>par</code>, <code>fn</code>, <code>lower</code>, <code>upper</code>, <code>...</code> 
and possibly <code>control</code>, 
and return a list with <code>par</code> and <code>value</code>.
A trace <code>trace</code> argument is available, it can be set to <code>0</code> to suppress all messages, to <code>1</code> (default) for displaying the optimization progresses,
and <code>&gt;1</code> for the highest level of details.</p>
</td></tr>
<tr><td><code id="crit_optimizer_+3A_ncores">ncores</code></td>
<td>
<p>number of CPU available (&gt; 1 makes mean parallel <code>TRUE</code>). Only used with <code>discrete</code> optimization for now.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extension of the function <code><a href="DiceOptim.html#topic+max_EI">max_EI</a></code> for multi-objective optimization.<br />
Available infill criteria with <code>crit</code> are : <br />
</p>

<ul>
<li><p> Expected Hypervolume Improvement (<code>EHI</code>) <code><a href="#topic+crit_EHI">crit_EHI</a></code>,
</p>
</li>
<li><p> SMS criterion (<code>SMS</code>) <code><a href="#topic+crit_SMS">crit_SMS</a></code>,
</p>
</li>
<li><p> Expected Maximin Improvement (<code>EMI</code>) <code><a href="#topic+crit_EMI">crit_EMI</a></code>,
</p>
</li>
<li><p> Stepwise Uncertainty Reduction of the excursion volume (<code>SUR</code>) <code><a href="#topic+crit_SUR">crit_SUR</a></code>
</p>
</li></ul>

<p>Depending on the selected criterion, parameters such as a reference point for <code>SMS</code> and <code>EHI</code> or arguments for 
<code><a href="#topic+integration_design_optim">integration_design_optim</a></code> with <code>SUR</code> can be given with <code>critcontrol</code>.
Also options for <code><a href="#topic+checkPredict">checkPredict</a></code> are available.
More precisions are given in the corresponding help pages.
</p>


<h3>Value</h3>

<p>A list with components: 
</p>

<ul>
<li> <p><code>par</code>: The best set of parameters found,
</p>
</li>
<li> <p><code>value</code>: The value of expected improvement at <code>par</code>.
</p>
</li></ul>



<h3>References</h3>

<p>W.R. Jr. Mebane and J.S. Sekhon (2011), Genetic optimization using derivatives: The rgenoud package for R, 
<em>Journal of Statistical Software</em>, 42(11), 1-26 <a href="https://doi.org/10.18637/jss.v042.i11">doi:10.18637/jss.v042.i11</a> <br />
</p>
<p>D.R. Jones, M. Schonlau, and W.J. Welch (1998), Efficient global optimization of expensive black-box functions, 
<em>Journal of Global Optimization</em>, 13, 455-492.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#---------------------------------------------------------------------------
# EHI surface associated with the "P1" problem at a 15 points design
#---------------------------------------------------------------------------

set.seed(25468)
library(DiceDesign)

d &lt;- 2
n.obj &lt;- 2 
fname &lt;- "P1" 
n.grid &lt;- 51
test.grid &lt;- expand.grid(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid))
nappr &lt;- 15 
design.grid &lt;- round(maximinESE_LHS(lhsDesign(nappr, d, seed = 42)$design)$design, 1)
response.grid &lt;- t(apply(design.grid, 1, fname))
paretoFront &lt;- t(nondominated_points(t(response.grid)))
mf1 &lt;- km(~., design = design.grid, response = response.grid[,1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[,2])
model &lt;- list(mf1, mf2)

EHI_grid &lt;- apply(test.grid, 1, crit_EHI, model = list(mf1, mf2),
                  critcontrol = list(refPoint = c(300, 0)))

lower &lt;- rep(0, d)
upper &lt;- rep(1, d)     

omEGO &lt;- crit_optimizer(crit = "EHI", model = model,  lower = lower, upper = upper, 
                 optimcontrol = list(method = "genoud", pop.size = 200, BFGSburnin = 2),
                 critcontrol = list(refPoint = c(300, 0)))
                 
print(omEGO)
 
filled.contour(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid), nlevels = 50,
               matrix(EHI_grid, nrow = n.grid), main = "Expected Hypervolume Improvement", 
               xlab = expression(x[1]), ylab = expression(x[2]), color = terrain.colors,
               plot.axes = {axis(1); axis(2);
                            points(design.grid[, 1], design.grid[, 2], pch = 21, bg = "white");
                            points(omEGO$par, col = "red", pch = 4)
                            }
              )
              
#---------------------------------------------------------------------------
# SMS surface associated with the "P1" problem at a 15 points design
#---------------------------------------------------------------------------


SMS_grid &lt;- apply(test.grid, 1, crit_SMS, model = model,
                  critcontrol = list(refPoint = c(300, 0)))

lower &lt;- rep(0, d)
upper &lt;- rep(1, d)     

omEGO2 &lt;- crit_optimizer(crit = "SMS", model = model,  lower = lower, upper = upper, 
                 optimcontrol = list(method="genoud", pop.size = 200, BFGSburnin = 2),
                 critcontrol = list(refPoint = c(300, 0)))
                 
print(omEGO2)
 
filled.contour(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid), nlevels = 50,
               matrix(pmax(0,SMS_grid), nrow = n.grid), main = "SMS Criterion (&gt;0)",
               xlab = expression(x[1]), ylab = expression(x[2]), color = terrain.colors,
               plot.axes = {axis(1); axis(2);
                            points(design.grid[, 1], design.grid[, 2], pch = 21, bg = "white");
                            points(omEGO2$par, col = "red", pch = 4)
                            }
              )
#---------------------------------------------------------------------------
# Maximin Improvement surface associated with the "P1" problem at a 15 points design
#---------------------------------------------------------------------------


EMI_grid &lt;- apply(test.grid, 1, crit_EMI, model = model,
                  critcontrol = list(nb_samp = 20, type ="EMI"))

lower &lt;- rep(0, d)
upper &lt;- rep(1, d)     

omEGO3 &lt;- crit_optimizer(crit = "EMI", model = model,  lower = lower, upper = upper, 
                 optimcontrol = list(method = "genoud", pop.size = 200, BFGSburnin = 2))
                 
print(omEGO3)
 
filled.contour(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid), nlevels = 50,
               matrix(EMI_grid, nrow = n.grid), main = "Expected Maximin Improvement",
               xlab = expression(x[1]), ylab = expression(x[2]), color = terrain.colors, 
               plot.axes = {axis(1);axis(2);
                            points(design.grid[, 1], design.grid[, 2], pch = 21, bg = "white");
                            points(omEGO3$par, col = "red", pch = 4)
                            }
              )
#---------------------------------------------------------------------------
# crit_SUR surface associated with the "P1" problem at a 15 points design
#---------------------------------------------------------------------------
library(KrigInv)

integration.param &lt;- integration_design_optim(lower = c(0, 0), upper = c(1, 1), model = model)
integration.points &lt;- as.matrix(integration.param$integration.points)
integration.weights &lt;- integration.param$integration.weights

precalc.data &lt;- list()
mn.X &lt;- sn.X &lt;- matrix(0, n.obj, nrow(integration.points))

for (i in 1:n.obj){
  p.tst.all &lt;- predict(model[[i]], newdata = integration.points, type = "UK",
                       checkNames = FALSE)
  mn.X[i,] &lt;- p.tst.all$mean
  sn.X[i,]   &lt;- p.tst.all$sd
  precalc.data[[i]] &lt;- precomputeUpdateData(model[[i]], integration.points)
}
critcontrol &lt;- list(integration.points = integration.points,
                    integration.weights = integration.weights,
                    mn.X = mn.X, sn.X = sn.X, precalc.data = precalc.data)
EEV_grid &lt;- apply(test.grid, 1, crit_SUR, model=model, paretoFront = paretoFront,
                  critcontrol = critcontrol)
lower &lt;- rep(0, d)
upper &lt;- rep(1, d)
                  
omEGO4 &lt;- crit_optimizer(crit = "SUR", model = model,  lower = lower, upper = upper, 
                 optimcontrol = list(method = "genoud", pop.size = 200, BFGSburnin = 2))
print(omEGO4)

filled.contour(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid),
               matrix(pmax(0,EEV_grid), n.grid), main = "EEV criterion", nlevels = 50,
               xlab = expression(x[1]), ylab = expression(x[2]), color = terrain.colors,
               plot.axes = {axis(1); axis(2);
                            points(design.grid[,1], design.grid[,2], pch = 21, bg = "white")
                            points(omEGO4$par, col = "red", pch = 4)
                            }
              )

# example using user defined optimizer, here L-BFGS-B from base optim
userOptim &lt;- function(par, fn, lower, upper, control, ...){
  return(optim(par = par, fn = fn, method = "L-BFGS-B", lower = lower, upper = upper,
         control = control, ...))
}
omEGO4bis &lt;- crit_optimizer(crit = "SUR", model = model,  lower = lower, upper = upper, 
                 optimcontrol = list(method = "userOptim"))
print(omEGO4bis)


#---------------------------------------------------------------------------
# crit_SMS surface with problem "P1" with 15 design points, using cheapfn
#---------------------------------------------------------------------------

# Optimization with fastfun: SMS with discrete search
# Separation of the problem P1 in two objectives: 
# the first one to be kriged, the second one with fastobj

# Definition of the fastfun
f2 &lt;-   function(x){
  return(P1(x)[2])
}
 
SMS_grid_cheap &lt;- apply(test.grid, 1, crit_SMS, model = list(mf1, fastfun(f2, design.grid)),
                        paretoFront = paretoFront, critcontrol = list(refPoint = c(300, 0)))


optimcontrol &lt;- list(method = "pso")
model2 &lt;- list(mf1)
omEGO5 &lt;- crit_optimizer(crit = "SMS", model = model2,  lower = lower, upper = upper,
                         cheapfn = f2, critcontrol = list(refPoint = c(300, 0)),
                         optimcontrol = list(method = "genoud", pop.size = 200, BFGSburnin = 2))
print(omEGO5)

filled.contour(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid), 
               matrix(pmax(0, SMS_grid_cheap), nrow = n.grid), nlevels = 50,
               main = "SMS criterion with cheap 2nd objective (&gt;0)", xlab = expression(x[1]),
               ylab = expression(x[2]), color = terrain.colors,
               plot.axes = {axis(1); axis(2);
                            points(design.grid[,1], design.grid[,2], pch = 21, bg = "white")
                            points(omEGO5$par, col = "red", pch = 4)
                            }
              )

## End(Not run)
</code></pre>

<hr>
<h2 id='crit_qEHI'>Batch Expected Hypervolume Improvement with m objectives</h2><span id='topic+crit_qEHI'></span>

<h3>Description</h3>

<p>Parallel Multi-objective Expected Hypervolume Improvement with respect to the
current Pareto front, via Sample Average Approximation (SAA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crit_qEHI(
  x,
  model,
  paretoFront = NULL,
  critcontrol = list(nb.samp = 50, seed = 42),
  type = "UK"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crit_qEHI_+3A_x">x</code></td>
<td>
<p>a matrix representing the inputs (one per row) for which one wishes to calculate <code>EHI</code>,</p>
</td></tr>
<tr><td><code id="crit_qEHI_+3A_model">model</code></td>
<td>
<p>list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>, one for each objective functions,</p>
</td></tr>
<tr><td><code id="crit_qEHI_+3A_paretofront">paretoFront</code></td>
<td>
<p>(optional) matrix corresponding to the Pareto front of size <code>[n.pareto x n.obj]</code>, or any reference set of observations,</p>
</td></tr>
<tr><td><code id="crit_qEHI_+3A_critcontrol">critcontrol</code></td>
<td>
<p>optional list with arguments:
</p>

<ul>
<li> <p><code>nb.samp</code> number of random samples from the posterior distribution (with more than two objectives),
default to <code>50</code>, increasing gives more reliable results at the cost of longer computation time;
</p>
</li>
<li> <p><code>seed</code> seed used for the random samples (with more than two objectives);
</p>
</li>
<li> <p><code>refPoint</code> reference point for Hypervolume Expected Improvement;
</p>
</li>
<li> <p><code>extendper</code> if no reference point <code>refPoint</code> is provided,
for each objective it is fixed to the maximum over the Pareto front plus extendper times the range, 
Default value to <code>0.2</code>, corresponding to <code>1.1</code> for a scaled objective with a Pareto front in <code>[0,1]^n.obj</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="crit_qEHI_+3A_type">type</code></td>
<td>
<p>&quot;<code>SK</code>&quot; or &quot;<code>UK</code>&quot; (by default), depending whether uncertainty related to trend estimation 
has to be taken into account.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The batch EHI is computed by simulated <code>nb.samp</code> conditional simulation of the objectives on the candidate points,
before averaging the corresponding hypervolume improvement of each set of m simulations.
</p>


<h3>Value</h3>

<p>The Expected Hypervolume Improvement at <code>x</code>.
</p>


<h3>References</h3>

<p>J. D. Svenson (2011), <em>Computer Experiments: Multiobjective Optimization and Sensitivity Analysis</em>, Ohio State University, PhD thesis.  <br /> <br />
</p>


<h3>See Also</h3>

<p><code><a href="DiceOptim.html#topic+EI">EI</a></code> from package DiceOptim, <code><a href="#topic+crit_EMI">crit_EMI</a></code>, <code><a href="#topic+crit_SUR">crit_SUR</a></code>, <code><a href="#topic+crit_SMS">crit_SMS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---------------------------------------------------------------------------
# Expected Hypervolume Improvement surface associated with the "P1" problem at a 15 points design
#---------------------------------------------------------------------------
set.seed(25468)
library(DiceDesign)

n_var &lt;- 2 
f_name &lt;- "P1" 
n.grid &lt;- 26
test.grid &lt;- expand.grid(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid))
test.grid &lt;- as.matrix(test.grid)
n_appr &lt;- 15
design.grid &lt;- round(maximinESE_LHS(lhsDesign(n_appr, n_var, seed = 42)$design)$design, 1)
response.grid &lt;- t(apply(design.grid, 1, f_name))
Front_Pareto &lt;- t(nondominated_points(t(response.grid)))
mf1 &lt;- km(~., design = design.grid, response = response.grid[,1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[,2])

refPoint &lt;- c(300, 0)
EHI_grid &lt;- crit_EHI(x = test.grid, model = list(mf1, mf2),
         critcontrol = list(refPoint = refPoint))

## Create potential batches
q &lt;- 3
ncb &lt;- 500
Xbcands &lt;- array(NA, dim = c(ncb, q, n_var))
for(i in 1:ncb) Xbcands[i,,] &lt;- test.grid[sample(1:nrow(test.grid), q, prob = pmax(0,EHI_grid)),]

qEHI_grid &lt;- apply(Xbcands, 1, crit_qEHI, model = list(mf1, mf2),
  critcontrol = list(refPoint = refPoint))
  
Xq &lt;- Xbcands[which.max(qEHI_grid),,]

## For further optimization (gradient may not be reliable)
# sol &lt;- optim(as.vector(Xq), function(x, ...) crit_qEHI(matrix(x, q), ...),
#   model = list(mf1, mf2), lower = c(0,0), upper = c(1,1), method = "L-BFGS-B",
#   control = list(fnscale = -1), critcontrol = list(refPoint = refPoint, nb.samp = 10000))
# sol &lt;- psoptim(as.vector(Xq), function(x, ...) crit_qEHI(matrix(x, q), ...),
#  model = list(mf1, mf2), lower = c(0,0), upper = c(1,1), 
#  critcontrol = list(refPoint = refPoint, nb.samp = 100),
#  control = list(fnscale = -1))

# Plot EHI surface and selected designs for parallel evaluation
filled.contour(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid), nlevels = 50,
               matrix(EHI_grid, n.grid), 
               main = "Expected Hypervolume Improvement surface and best 3-EHI designs",
               xlab = expression(x[1]), ylab = expression(x[2]), color = terrain.colors, 
               plot.axes = {axis(1); axis(2);
                            points(design.grid[,1], design.grid[,2], pch = 21, bg = "white")
                            points(Xq, pch = 20, col = 2)
#                            points(matrix(sol$par, q), col = 4)
                            }
              )
</code></pre>

<hr>
<h2 id='crit_SMS'>Analytical expression of the SMS-EGO criterion with m&gt;1 objectives</h2><span id='topic+crit_SMS'></span>

<h3>Description</h3>

<p>Computes a slightly modified infill Criterion of the SMS-EGO. 
To avoid numerical instabilities, an additional penalty is added to the new point if it is too close to an existing observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crit_SMS(x, model, paretoFront = NULL, critcontrol = NULL, type = "UK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crit_SMS_+3A_x">x</code></td>
<td>
<p>a vector representing the input for which one wishes to calculate the criterion,</p>
</td></tr>
<tr><td><code id="crit_SMS_+3A_model">model</code></td>
<td>
<p>a list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code> (one for each objective),</p>
</td></tr>
<tr><td><code id="crit_SMS_+3A_paretofront">paretoFront</code></td>
<td>
<p>(optional) matrix corresponding to the Pareto front of size <code>[n.pareto x n.obj]</code>, or any reference set of observations,</p>
</td></tr>
<tr><td><code id="crit_SMS_+3A_critcontrol">critcontrol</code></td>
<td>
<p>list with arguments: 
</p>

<ul>
<li> <p><code>currentHV</code> current hypervolume;
</p>
</li>
<li> <p><code>refPoint</code> reference point for hypervolume computations;
</p>
</li>
<li> <p><code>extendper</code> if no reference point <code>refPoint</code> is provided,
for each objective it is fixed to the maximum over the Pareto front plus extendper times the range. 
Default value to <code>0.2</code>, corresponding to <code>1.1</code> for a scaled objective with a Pareto front in <code>[0,1]^n.obj</code>;
</p>
</li>
<li> <p><code>epsilon</code> optional value to use in additive epsilon dominance;
</p>
</li>
<li> <p><code>gain</code> optional gain factor for sigma.
</p>
</li></ul>

<p>Options for the <code><a href="#topic+checkPredict">checkPredict</a></code> function: <code>threshold</code> (<code>1e-4</code>) and <code>distance</code> (<code>covdist</code>) are used to avoid numerical issues occuring when adding points too close to the existing ones.</p>
</td></tr>
<tr><td><code id="crit_SMS_+3A_type">type</code></td>
<td>
<p>&quot;<code>SK</code>&quot; or &quot;<code>UK</code>&quot; (by default), depending whether uncertainty related to trend 
estimation has to be taken into account.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the criterion.
</p>


<h3>References</h3>

<p>W. Ponweiser, T. Wagner, D. Biermann, M. Vincze (2008), Multiobjective Optimization on a Limited Budget of Evaluations Using Model-Assisted S-Metric Selection,
<em>Parallel Problem Solving from Nature</em>, pp. 784-794. Springer, Berlin. <br /> <br />
T. Wagner, M. Emmerich, A. Deutz, W. Ponweiser (2010), On expected-improvement criteria for model-based multi-objective optimization.   
<em>Parallel Problem Solving from Nature</em>, pp. 718-727. Springer, Berlin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crit_EHI">crit_EHI</a></code>, <code><a href="#topic+crit_SUR">crit_SUR</a></code>, <code><a href="#topic+crit_EMI">crit_EMI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---------------------------------------------------------------------------
# SMS-EGO surface associated with the "P1" problem at a 15 points design
#---------------------------------------------------------------------------
set.seed(25468)
library(DiceDesign)

n_var &lt;- 2 
f_name &lt;- "P1" 
n.grid &lt;- 26
test.grid &lt;- expand.grid(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid))
n_appr &lt;- 15 
design.grid &lt;- round(maximinESE_LHS(lhsDesign(n_appr, n_var, seed = 42)$design)$design, 1)
response.grid &lt;- t(apply(design.grid, 1, f_name))
PF &lt;- t(nondominated_points(t(response.grid)))
mf1 &lt;- km(~., design = design.grid, response = response.grid[,1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[,2])

model &lt;- list(mf1, mf2)
critcontrol &lt;- list(refPoint = c(300, 0), currentHV = dominated_hypervolume(t(PF), c(300, 0)))
SMSEGO_grid &lt;- apply(test.grid, 1, crit_SMS, model = model,
                     paretoFront = PF, critcontrol = critcontrol)

filled.contour(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid),
               matrix(pmax(0, SMSEGO_grid), nrow = n.grid), nlevels = 50,
               main = "SMS-EGO criterion (positive part)", xlab = expression(x[1]),
               ylab = expression(x[2]), color = terrain.colors,
               plot.axes = {axis(1); axis(2);
                            points(design.grid[,1],design.grid[,2], pch = 21, bg = "white")
                            }
              )
</code></pre>

<hr>
<h2 id='crit_SUR'>Analytical expression of the SUR criterion for two or three objectives.</h2><span id='topic+crit_SUR'></span>

<h3>Description</h3>

<p>Computes the SUR criterion (Expected Excursion Volume Reduction) at point <code>x</code> for 2 or 3 objectives.
To avoid numerical instabilities, the new point is penalized if it is too close to an existing observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crit_SUR(x, model, paretoFront = NULL, critcontrol = NULL, type = "UK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crit_SUR_+3A_x">x</code></td>
<td>
<p>a vector representing the input for which one wishes to calculate the criterion,</p>
</td></tr>
<tr><td><code id="crit_SUR_+3A_model">model</code></td>
<td>
<p>a list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code> (one for each objective),</p>
</td></tr>
<tr><td><code id="crit_SUR_+3A_paretofront">paretoFront</code></td>
<td>
<p>(optional) matrix corresponding to the Pareto front of size <code>[n.pareto x n.obj]</code>, or any reference set of observations,</p>
</td></tr>
<tr><td><code id="crit_SUR_+3A_critcontrol">critcontrol</code></td>
<td>
<p>list with two possible options.<br />
</p>
<p>A) One can use the four following arguments:
</p>

<ul>
<li> <p><code>integration.points</code>, matrix of integration points of size <code>[n.integ.pts x d]</code>;
</p>
</li>
<li> <p><code>integration.weights</code>, vector of integration weights of length n.integ.pts;
</p>
</li>
<li> <p><code>mn.X</code> and <code>sn.X</code>, matrices of kriging means and sd, each of size <code>[n.obj x n.integ.pts]</code>; 
</p>
</li>
<li> <p><code>precalc.data</code>, list of precalculated data (based on kriging models at integration points) for faster computation. 
</p>
</li></ul>

<p>B) Alternatively, one can define arguments passed to <code><a href="#topic+integration_design_optim">integration_design_optim</a></code>:
<code>SURcontrol</code> (optional), <code>lower</code>, <code>upper</code>, <code>min.prob</code> (optional). This is slower since arguments of
A), used in the function, are then recomputed each time (note that this is not the case when called from <code><a href="#topic+GParetoptim">GParetoptim</a></code> and <code><a href="#topic+crit_optimizer">crit_optimizer</a></code>).<br /> <br />
Options for the <code><a href="#topic+checkPredict">checkPredict</a></code> function: <code>threshold</code> (<code>1e-4)</code> and <code>distance</code> (<code>covdist</code>) are used to avoid numerical issues occuring when adding points too close to the existing ones.</p>
</td></tr>
<tr><td><code id="crit_SUR_+3A_type">type</code></td>
<td>
<p>&quot;<code>SK</code>&quot; or &quot;<code>UK</code>&quot; (default), depending whether uncertainty related to trend estimation has to be taken into account.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the criterion.
</p>


<h3>References</h3>

<p>V. Picheny (2014), Multiobjective optimization using Gaussian process emulators via stepwise uncertainty reduction, 
<em>Statistics and Computing</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crit_EHI">crit_EHI</a></code>, <code><a href="#topic+crit_SMS">crit_SMS</a></code>,  <code><a href="#topic+crit_EMI">crit_EMI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---------------------------------------------------------------------------
# crit_SUR surface associated with the "P1" problem at a 15 points design
#---------------------------------------------------------------------------
set.seed(25468)
library(DiceDesign)
library(KrigInv)

n_var &lt;- 2 
n.obj &lt;- 2 
f_name &lt;- "P1" 
n.grid &lt;- 14
test.grid &lt;- expand.grid(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid))
n_appr &lt;- 15 
design.grid &lt;- round(maximinESE_LHS(lhsDesign(n_appr, n_var, seed = 42)$design)$design, 1)
response.grid &lt;- t(apply(design.grid, 1, f_name))
paretoFront &lt;- t(nondominated_points(t(response.grid)))
mf1 &lt;- km(~., design = design.grid, response = response.grid[,1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[,2])

model &lt;- list(mf1, mf2)


integration.param &lt;- integration_design_optim(lower = c(0, 0), upper = c(1, 1), model = model)
integration.points &lt;- as.matrix(integration.param$integration.points)
integration.weights &lt;- integration.param$integration.weights

precalc.data &lt;- list()
mn.X &lt;- sn.X &lt;- matrix(0, nrow = n.obj, ncol = nrow(integration.points))

for (i in 1:n.obj){
  p.tst.all &lt;- predict(model[[i]], newdata = integration.points, type = "UK", checkNames = FALSE)
  mn.X[i,] &lt;- p.tst.all$mean
  sn.X[i,]   &lt;- p.tst.all$sd
  precalc.data[[i]] &lt;- precomputeUpdateData(model[[i]], integration.points)
}

critcontrol &lt;- list(integration.points = integration.points,
                    integration.weights = integration.weights,
                    mn.X = mn.X, sn.X = sn.X, precalc.data = precalc.data)
## Alternatively: critcontrol &lt;- list(lower = rep(0, n_var), upper = rep(1,n_var))
                
EEV_grid &lt;- apply(test.grid, 1, crit_SUR, model = model, paretoFront = paretoFront,
                  critcontrol = critcontrol)
                  

filled.contour(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid),
               matrix(pmax(0,EEV_grid), nrow = n.grid), main = "EEV criterion",
               xlab = expression(x[1]), ylab = expression(x[2]), color = terrain.colors,
               plot.axes = {axis(1); axis(2);
                            points(design.grid[,1], design.grid[,2], pch = 21, bg = "white")
                            }
              )         
</code></pre>

<hr>
<h2 id='easyGParetoptim'>EGO algorithm for multiobjective optimization</h2><span id='topic+easyGParetoptim'></span>

<h3>Description</h3>

<p>User-friendly wrapper of the function <code><a href="#topic+GParetoptim">GParetoptim</a></code>.
Generates initial DOEs and kriging models (objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>), 
and executes <code>nsteps</code> iterations of multiobjective EGO methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>easyGParetoptim(
  fn,
  ...,
  cheapfn = NULL,
  budget,
  lower,
  upper,
  par = NULL,
  value = NULL,
  noise.var = NULL,
  control = list(method = "SMS", trace = 1, inneroptim = "pso", maxit = 100, seed = 42),
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="easyGParetoptim_+3A_fn">fn</code></td>
<td>
<p>the multi-objective function to be minimized (vectorial output), found by a call to <code><a href="base.html#topic+match.fun">match.fun</a></code>, see details,</p>
</td></tr>
<tr><td><code id="easyGParetoptim_+3A_...">...</code></td>
<td>
<p>additional parameters to be given to the objective <code>fn</code>.</p>
</td></tr>
<tr><td><code id="easyGParetoptim_+3A_cheapfn">cheapfn</code></td>
<td>
<p>optional additional fast-to-evaluate objective function (handled next with class <code><a href="#topic+fastfun">fastfun</a></code>), 
which does not need a kriging model, handled by a call to <code><a href="base.html#topic+match.fun">match.fun</a></code>,</p>
</td></tr>
<tr><td><code id="easyGParetoptim_+3A_budget">budget</code></td>
<td>
<p>total number of calls to the objective function,</p>
</td></tr>
<tr><td><code id="easyGParetoptim_+3A_lower">lower</code></td>
<td>
<p>vector of lower bounds for the variables to be optimized over,</p>
</td></tr>
<tr><td><code id="easyGParetoptim_+3A_upper">upper</code></td>
<td>
<p>vector of upper bounds for the variables to be optimized over,</p>
</td></tr>
<tr><td><code id="easyGParetoptim_+3A_par">par</code></td>
<td>
<p>initial design of experiments. If not provided, <code>par</code> is taken as a maximin LHD with budget/3 points,</p>
</td></tr>
<tr><td><code id="easyGParetoptim_+3A_value">value</code></td>
<td>
<p>initial set of objective observations <code class="reqn">fn(par)</code>. Computed if not provided.
Not that <code>value</code> may NOT contain any <code>cheapfn</code> value,</p>
</td></tr>
<tr><td><code id="easyGParetoptim_+3A_noise.var">noise.var</code></td>
<td>
<p>optional noise variance, for noisy objectives <code>fn</code>. If not NULL, either a scalar (constant noise, identical for all objectives), 
a vector (constant noise, different for each objective) or a function (type closure) with vectorial output (variable noise, different for each objective). 
Alternatively, set <code>noise.var="given_by_fn"</code>, see details.</p>
</td></tr>
<tr><td><code id="easyGParetoptim_+3A_control">control</code></td>
<td>
<p>an optional list of control parameters. See &quot;Details&quot;,</p>
</td></tr>
<tr><td><code id="easyGParetoptim_+3A_ncores">ncores</code></td>
<td>
<p>number of CPU available (&gt; 1 makes mean parallel <code>TRUE</code>). Only used with <code>discrete</code> optimization for now.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not require specific knowledge on kriging models (objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>).<br />
</p>
<p>The problem considered is of the form: <code class="reqn">min f(x) = f_1(x), ..., f_p(x)</code>. 
The <code>control</code> argument is a list that can supply any of the following optional components: <br />
</p>

<ul>
<li> <p><code>method</code>: choice of multiobjective improvement function: &quot;<code>SMS</code>&quot;, &quot;<code>EHI</code>&quot;, &quot;<code>EMI</code>&quot; or &quot;<code>SUR</code>&quot; 
(see <code><a href="#topic+crit_SMS">crit_SMS</a></code>, <code><a href="#topic+crit_EHI">crit_EHI</a></code>, <code><a href="#topic+crit_EMI">crit_EMI</a></code>, <code><a href="#topic+crit_SUR">crit_SUR</a></code>),
</p>
</li>
<li> <p><code>trace</code>: if positive, tracing information on the progress of the optimization is produced (<code>1</code> (default) for general progress,
<code>&gt;1</code> for more details, e.g., warnings from <code><a href="rgenoud.html#topic+genoud">genoud</a></code>),
</p>
</li>
<li> <p><code>inneroptim</code>: choice of the inner optimization algorithm: &quot;<code>genoud</code>&quot;, &quot;<code>pso</code>&quot; or &quot;<code>random</code>&quot;
(see <code><a href="rgenoud.html#topic+genoud">genoud</a></code> and <code><a href="pso.html#topic+psoptim">psoptim</a></code>),
</p>
</li>
<li> <p><code>maxit</code>: maximum number of iterations of the inner loop,
</p>
</li>
<li> <p><code>seed</code>: to fix the random variable generator,
</p>
</li>
<li> <p><code>refPoint</code>: reference point for hypervolume computations (for &quot;<code>SMS</code>&quot; and &quot;<code>EHI</code>&quot; methods),
</p>
</li>
<li> <p><code>extendper</code>: if no reference point <code>refPoint</code> is provided,
for each objective it is fixed to the maximum over the Pareto front plus extendper times the range. 
Default value to <code>0.2</code>, corresponding to <code>1.1</code> for a scaled objective with a Pareto front in <code>[0,1]^n.obj</code>.
</p>
</li></ul>

<p>If <code>noise.var="given_by_fn"</code>, <code>fn</code> must return a list of two vectors, the first being the objective functions and the second 
the corresponding noise variances. See examples in <code><a href="#topic+GParetoptim">GParetoptim</a></code>.
</p>
<p>For additional details or other possible arguments, see <code><a href="#topic+GParetoptim">GParetoptim</a></code>.<br />
</p>
<p>Display of results and various post-processings are available with <code><a href="#topic+plotGPareto">plotGPareto</a></code>.
</p>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li> <p><code>par</code>: all the non-dominated points found,
</p>
</li>
<li> <p><code>value</code>: the matrix of objective values at the points given in <code>par</code>,
</p>
</li>
<li> <p><code>history</code>: a list containing all the points visited by the algorithm (<code>X</code>) and their corresponding objectives (<code>y</code>),
</p>
</li>
<li> <p><code>model</code>: a list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>, corresponding to the last kriging models fitted.
</p>
</li></ul>

<p>Note that in the case of noisy problems, <code>value</code> and <code>history$y.denoised</code> are denoised values. The original observations are available in the slot
<code>history$y</code>.
</p>


<h3>Author(s)</h3>

<p>Victor Picheny (INRA, Castanet-Tolosan, France)
</p>
<p>Mickael Binois (Mines Saint-Etienne/Renault, France)
</p>


<h3>References</h3>

<p>M. T. Emmerich, A. H. Deutz, J. W. Klinkenberg (2011), Hypervolume-based expected improvement: Monotonicity properties and exact computation,
<em>Evolutionary Computation (CEC)</em>, 2147-2154. <br /> <br />
V. Picheny (2015), Multiobjective optimization using Gaussian process emulators via stepwise uncertainty reduction, 
<em>Statistics and Computing</em>, 25(6), 1265-1280. <br /> <br />
T. Wagner, M. Emmerich, A. Deutz, W. Ponweiser (2010), On expected-improvement criteria for model-based multi-objective optimization.   
<em>Parallel Problem Solving from Nature</em>, 718-727, Springer, Berlin. <br /> <br />
J. D. Svenson (2011), <em>Computer Experiments: Multiobjective Optimization and Sensitivity Analysis</em>, Ohio State university, PhD thesis. <br /> <br />
M. Binois, V. Picheny (2019), GPareto: An R Package for Gaussian-Process-Based Multi-Objective Optimization and Analysis,
<em>Journal of Statistical Software</em>, 89(8), 1-30, <a href="https://doi.org/10.18637/jss.v089.i08">doi:10.18637/jss.v089.i08</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---------------------------------------------------------------------------
# 2D objective function, 4 cases
#---------------------------------------------------------------------------
## Not run: 
set.seed(25468)
n_var &lt;- 2 
fname &lt;- ZDT3
lower &lt;- rep(0, n_var)
upper &lt;- rep(1, n_var)

#---------------------------------------------------------------------------
# 1- Expected Hypervolume Improvement optimization, using pso
#---------------------------------------------------------------------------
res &lt;- easyGParetoptim(fn=fname, lower=lower, upper=upper, budget=15, 
                   control=list(method="EHI", inneroptim="pso", maxit=20))
par(mfrow=c(1,2))
plotGPareto(res)
title("Pareto Front")
plot(res$history$X, main="Pareto set", col = "red", pch = 20)
points(res$par, col="blue", pch = 17)

#---------------------------------------------------------------------------
# 2- SMS Improvement optimization using random search, with initial DOE given
#---------------------------------------------------------------------------
library(DiceDesign)
design.init   &lt;- maximinESE_LHS(lhsDesign(10, n_var, seed = 42)$design)$design
response.init &lt;- t(apply(design.init, 1, fname))
res &lt;- easyGParetoptim(fn=fname, par=design.init, value=response.init, lower=lower, upper=upper, 
                       budget=15, control=list(method="SMS", inneroptim="random", maxit=100))
par(mfrow=c(1,2))
plotGPareto(res)
title("Pareto Front")
plot(res$history$X, main="Pareto set", col = "red", pch = 20)
points(res$par, col="blue", pch = 17)

#---------------------------------------------------------------------------
# 3- Stepwise Uncertainty Reduction optimization, with one fast objective function
#---------------------------------------------------------------------------
fname &lt;- camelback
cheapfn &lt;- function(x) {
if (is.null(dim(x))) return(-sum(x))
else return(-rowSums(x))
}
res &lt;- easyGParetoptim(fn=fname, cheapfn=cheapfn, lower=lower, upper=upper, budget=15, 
                   control=list(method="SUR", inneroptim="pso", maxit=20))
par(mfrow=c(1,2))
plotGPareto(res)
title("Pareto Front")
plot(res$history$X, main="Pareto set", col = "red", pch = 20)
points(res$par, col="blue", pch = 17)

#---------------------------------------------------------------------------
# 4- Expected Hypervolume Improvement optimization, using pso, noisy fn
#---------------------------------------------------------------------------
noise.var &lt;- c(0.1, 0.2)
funnoise &lt;- function(x) {ZDT3(x) + sqrt(noise.var)*rnorm(n=2)}
res &lt;- easyGParetoptim(fn=funnoise, lower=lower, upper=upper, budget=30, noise.var=noise.var,
                       control=list(method="EHI", inneroptim="pso", maxit=20))
par(mfrow=c(1,2))
plotGPareto(res)
title("Pareto Front")
plot(res$history$X, main="Pareto set", col = "red", pch = 20)
points(res$par, col="blue", pch = 17)

#---------------------------------------------------------------------------
# 5- Stepwise Uncertainty Reduction optimization, functional noise
#---------------------------------------------------------------------------
funnoise &lt;- function(x) {ZDT3(x) + sqrt(abs(0.1*x))*rnorm(n=2)}
noise.var &lt;- function(x) return(abs(0.1*x))

res &lt;- easyGParetoptim(fn=funnoise, lower=lower, upper=upper, budget=30, noise.var=noise.var,
                     control=list(method="SUR", inneroptim="pso", maxit=20))
par(mfrow=c(1,2))
plotGPareto(res)
title("Pareto Front")
plot(res$history$X, main="Pareto set", col = "red", pch = 20)
points(res$par, col="blue", pch = 17)

## End(Not run)
</code></pre>

<hr>
<h2 id='fastfun'>Fast-to-evaluate function wrapper</h2><span id='topic+fastfun'></span>

<h3>Description</h3>

<p>Modification of an R function to be used with methods <code>predict</code> and <code>update</code> (similar to a <code><a href="DiceKriging.html#topic+km">km</a></code> object). 
It creates an S4 object which contains the values corresponding to evaluations of other costly observations.
It is useful when an objective can be evaluated fast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastfun(fn, design, response = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastfun_+3A_fn">fn</code></td>
<td>
<p>the evaluator function, found by a call to <code><a href="base.html#topic+match.fun">match.fun</a></code>,</p>
</td></tr>
<tr><td><code id="fastfun_+3A_design">design</code></td>
<td>
<p>a data frame representing the design of experiments.
The ith row contains the values of the d input variables corresponding to the ith evaluation.</p>
</td></tr>
<tr><td><code id="fastfun_+3A_response">response</code></td>
<td>
<p>optional vector (or 1-column matrix or data frame) containing the values of the 1-dimensional output given by the objective function at the design points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class  <code><a href="#topic+fastfun-class">fastfun-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################################################
## Example with a fast to evaluate objective
########################################################
## Not run: 
set.seed(25468)
library(DiceDesign)

d &lt;- 2 

fname &lt;- P1
n.grid &lt;- 21
nappr &lt;- 11 
design.grid &lt;- maximinESE_LHS(lhsDesign(nappr, d, seed = 42)$design)$design
response.grid &lt;- t(apply(design.grid, 1, fname))
Front_Pareto &lt;- t(nondominated_points(t(response.grid)))

mf1 &lt;- km(~., design = design.grid, response = response.grid[,1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[,2])
model &lt;- list(mf1, mf2)

nsteps &lt;- 5 
lower &lt;- rep(0, d)
upper &lt;- rep(1, d)

# Optimization reference: SMS with discrete search
optimcontrol &lt;- list(method = "pso")
omEGO1 &lt;- GParetoptim(model = model, fn = fname, crit = "SMS", nsteps = nsteps,
                     lower = lower, upper = upper, optimcontrol = optimcontrol)
print(omEGO1$par)
print(omEGO1$values)
plot(response.grid, xlim = c(0,300), ylim = c(-40,0), pch = 17, col = "blue")
points(omEGO1$values, pch = 20, col ="green") 

# Optimization with fastfun: SMS with discrete search
# Separation of the problem P1 in two objectives: 
# the first one to be kriged, the second one with fastobj
f1 &lt;-   function(x){
  if(is.null(dim(x))) x &lt;- matrix(x, nrow = 1) 
  b1 &lt;- 15*x[,1] - 5
  b2 &lt;- 15*x[,2]
  return(  (b2 - 5.1*(b1/(2*pi))^2 + 5/pi*b1 - 6)^2 +10*((1 - 1/(8*pi))*cos(b1) + 1))
}

f2 &lt;-   function(x){
  if(is.null(dim(x))) x &lt;- matrix(x, nrow = 1) 
  b1&lt;-15*x[,1] - 5
  b2&lt;-15*x[,2]
  return(-sqrt((10.5 - b1)*(b1 + 5.5)*(b2 + 0.5))
         - 1/30*(b2 - 5.1*(b1/(2*pi))^2 - 6)^2
         - 1/3*((1 - 1/(8*pi))*cos(b1) + 1)) 
}

optimcontrol &lt;- list(method = "pso")
model2 &lt;- list(mf1)
omEGO2 &lt;- GParetoptim(model = model2, fn = f1, cheapfn = f2, crit = "SMS", nsteps = nsteps,
                     lower = lower, upper = upper, optimcontrol = optimcontrol)
print(omEGO2$par)
print(omEGO2$values)

points(omEGO2$values, col = "red", pch = 15)

## End(Not run)
</code></pre>

<hr>
<h2 id='fastfun-class'>Class for fast to compute objective.</h2><span id='topic+fastfun-class'></span><span id='topic+predict+2Cfastfun-method'></span><span id='topic+update+2Cfastfun-method'></span><span id='topic+simulate+2Cfastfun-method'></span>

<h3>Description</h3>

<p>Class for fast to compute objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fastfun'
predict(object, newdata, ...)

## S4 method for signature 'fastfun'
update(object, newX, newy, ...)

## S4 method for signature 'fastfun'
simulate(object, nsim, seed, newdata, cond, nugget.sim, checkNames, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastfun-class_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+fastfun">fastfun</a></code> object</p>
</td></tr>
<tr><td><code id="fastfun-class_+3A_newdata">newdata</code></td>
<td>
<p>an optional vector, matrix or data frame containing the points where to perform predictions.
Default is <code>NULL</code>: simulation is performed at design points specified in <code>object</code>.</p>
</td></tr>
<tr><td><code id="fastfun-class_+3A_...">...</code></td>
<td>
<p>further arguments (not used)</p>
</td></tr>
<tr><td><code id="fastfun-class_+3A_newx">newX</code></td>
<td>
<p>Matrix of the new location for the design</p>
</td></tr>
<tr><td><code id="fastfun-class_+3A_newy">newy</code></td>
<td>
<p>Matrix of the responses at <code>newX</code></p>
</td></tr>
<tr><td><code id="fastfun-class_+3A_nsim">nsim</code></td>
<td>
<p>an optional number specifying the number of response vectors to simulate. Default is 1.</p>
</td></tr>
<tr><td><code id="fastfun-class_+3A_seed">seed</code></td>
<td>
<p>usual seed argument of method simulate. Not used.</p>
</td></tr>
<tr><td><code id="fastfun-class_+3A_cond">cond</code></td>
<td>
<p>an optional boolean indicating the type of simulations. Not used.</p>
</td></tr>
<tr><td><code id="fastfun-class_+3A_nugget.sim">nugget.sim</code></td>
<td>
<p>an optional number corresponding to a numerical nugget effect. Not used.</p>
</td></tr>
<tr><td><code id="fastfun-class_+3A_checknames">checkNames</code></td>
<td>
<p>an optional boolean. Not used.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>predict(fastfun)</code>: Predict(by evaluating <code>fun</code>) the result at a new observation.
</p>
</li>
<li> <p><code>update(fastfun)</code>: Update the <code>X</code> and <code>y</code> slots with a new design and observation.
</p>
</li>
<li> <p><code>simulate(fastfun)</code>: Simulate responses values (for compatibility with methods using [DiceKriging::simulate()])
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>d</code></dt><dd><p>spatial dimension,</p>
</dd>
<dt><code>n</code></dt><dd><p>observations number,</p>
</dd>
<dt><code>X</code></dt><dd><p>the design of experiments, size <code>n x d</code>,</p>
</dd>
<dt><code>y</code></dt><dd><p>the observations, size <code>n x 1</code>,</p>
</dd>
<dt><code>fun</code></dt><dd><p>the evaluator function.</p>
</dd>
</dl>


<h3>Objects from the Class </h3>

<p>To create a <code>fastfun</code> object, use <code><a href="#topic+fastfun">fastfun</a></code>. See also this function for more details and examples.
</p>

<hr>
<h2 id='getDesign'>Get design corresponding to an objective target</h2><span id='topic+getDesign'></span>

<h3>Description</h3>

<p>Find the design that maximizes the probability of dominating a target given by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDesign(model, target, lower, upper, optimcontrol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDesign_+3A_model">model</code></td>
<td>
<p>list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>, one for each objective functions,</p>
</td></tr>
<tr><td><code id="getDesign_+3A_target">target</code></td>
<td>
<p>vector corresponding to the desired output in the objective space,</p>
</td></tr>
<tr><td><code id="getDesign_+3A_lower">lower</code></td>
<td>
<p>vector of lower bounds for the variables to be optimized over,</p>
</td></tr>
<tr><td><code id="getDesign_+3A_upper">upper</code></td>
<td>
<p>vector of upper bounds for the variables to be optimized over,</p>
</td></tr>
<tr><td><code id="getDesign_+3A_optimcontrol">optimcontrol</code></td>
<td>
<p>optional list of control parameters for optimization of the selected infill criterion. 
&quot;<code>method</code>&quot; set the optimization method; one can 
choose between &quot;<code>discrete</code>&quot;, &quot;<code>pso</code>&quot; and &quot;<code>genoud</code>&quot;. For each method, further parameters can be set.<br /> 
For &quot;<code>discrete</code>&quot;, one has to provide the argument &quot;<code>candidate.points</code>&quot;. <br />
For &quot;<code>pso</code>&quot;, one can control the maximum number of iterations &quot;<code>maxit</code>&quot; (<code>400</code>) and the population size &quot;<code>s</code>&quot;
(default :  <code>max(20, floor(10+2*sqrt(length(dim))))</code> (see <code><a href="pso.html#topic+psoptim">psoptim</a></code>). <br />
For &quot;<code>genoud</code>&quot;, one can control, among others, &quot;<code>pop.size</code>&quot; (default :  <code>[N = 3*2^dim</code> for <code>dim &lt; 6</code> and  <code>N = 32*dim</code> otherwise]),
&quot;<code>max.generations</code>&quot; (<code>12</code>), &quot;<code>wait.generations</code>&quot; (<code>2</code>), &quot;<code>BFGSburnin</code>&quot; (<code>2</code>), <code>BFGSmaxit</code> (<code>N</code>) and <code>solution.tolerance</code> (<code>1e-21</code>)
of function &quot;<code>genoud</code>&quot; (see <code><a href="rgenoud.html#topic+genoud">genoud</a></code>). Numbers into brackets are the default values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li> <p><code>par</code>: best design found,
</p>
</li>
<li> <p><code>value</code>: probabilitity that the design dominates the target,
</p>
</li>
<li> <p><code>mean</code>: kriging mean of the objectives at the design,
</p>
</li>
<li> <p><code>sd</code>: prediction standard deviation at the design.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#---------------------------------------------------------------------------
# Example of interactive optimization
#---------------------------------------------------------------------------

set.seed(25468)
library(DiceDesign)

d &lt;- 2
n.obj &lt;- 2 
fun &lt;- "P1" 
n.grid &lt;- 51
test.grid &lt;- expand.grid(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid))
nappr &lt;- 20 
design.grid &lt;- round(maximinESE_LHS(lhsDesign(nappr, d, seed = 42)$design)$design, 1)
response.grid &lt;- t(apply(design.grid, 1, fun))
paretoFront &lt;- t(nondominated_points(t(response.grid)))
mf1 &lt;- km(~., design = design.grid, response = response.grid[,1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[,2])
model &lt;- list(mf1, mf2)
lower &lt;- rep(0, d); upper &lt;- rep(1, d)

sol &lt;- GParetoptim(model, fun, crit = "SUR", nsteps = 5, lower = lower, upper = upper) 

plotGPareto(sol)

target1 &lt;- c(15, -25)
points(x = target1[1], y = target1[2], col = "black", pch = 13)

nDesign &lt;- getDesign(sol$lastmodel, target = target1, lower = rep(0, d), upper = rep(1, d))
points(t(nDesign$mean), col = "green", pch = 20)

target2 &lt;- c(48, -27)
points(x = target2[1], y = target2[2], col = "black", pch = 13)
nDesign2 &lt;- getDesign(sol$lastmodel, target = target2, lower = rep(0, d), upper = rep(1, d))
points(t(nDesign2$mean), col = "darkgreen", pch = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='GPareto-package'>Package GPareto</h2><span id='topic+GPareto-package'></span><span id='topic+GPareto'></span>

<h3>Description</h3>

<p>Multi-objective optimization and quantification of uncertainty on Pareto fronts, using Gaussian process models.
</p>


<h3>Details</h3>

<p>Important functions: <br />
<code><a href="#topic+GParetoptim">GParetoptim</a></code> <br />
<code><a href="#topic+easyGParetoptim">easyGParetoptim</a></code> <br />
<code><a href="#topic+crit_optimizer">crit_optimizer</a></code> <br />
<code><a href="#topic+plotGPareto">plotGPareto</a></code><br />
<code><a href="#topic+CPF">CPF</a></code>
</p>


<h3>Note</h3>

<p>Part of this work has been conducted within the frame of the ReDice Consortium,
gathering industrial (CEA, EDF, IFPEN, IRSN, Renault) and academic 
(Ecole des Mines de Saint-Etienne, INRIA, and the University of Bern) partners around
advanced methods for Computer Experiments. (http://redice.emse.fr/).<br />
</p>
<p>The authors would like to thank Yves Deville for his precious advices in R programming and packaging, 
as well as Olivier Roustant and David Ginsbourger for testing and suggestions of improvements for this package.
We would also like to thank Tobias Wagner for providing his Matlab codes for the SMS-EGO strategy.
</p>


<h3>Author(s)</h3>

<p>Mickael Binois, Victor Picheny
</p>


<h3>References</h3>

<p>M. Binois, D. Ginsbourger and O. Roustant (2015), Quantifying Uncertainty on Pareto Fronts with Gaussian process conditional simulations, 
<em>European Journal of Operational Research</em>, 243(2), 386-394. <br /> <br />
O. Roustant, D. Ginsbourger and Yves Deville (2012), DiceKriging, DiceOptim:
Two R Packages for the Analysis of Computer Experiments by Kriging-Based Metamodeling and Optimization,
<em>Journal of Statistical Software</em>, 51(1), 1-55, <a href="https://doi.org/10.18637/jss.v051.i01">doi:10.18637/jss.v051.i01</a>. <br /> <br />
M. T. Emmerich, A. H. Deutz, J. W. Klinkenberg (2011), Hypervolume-based expected improvement: Monotonicity properties and exact computation,
<em>Evolutionary Computation (CEC)</em>, 2147-2154. <br /> <br />
V. Picheny (2015), Multiobjective optimization using Gaussian process emulators via stepwise uncertainty reduction, 
<em>Statistics and Computing</em>, 25(6), 1265-1280. <br /> <br />
T. Wagner, M. Emmerich, A. Deutz, W. Ponweiser (2010), On expected-improvement criteria for model-based multi-objective optimization,   
<em>Parallel Problem Solving from Nature</em>, 718-727, Springer, Berlin. <br /> <br />
J. D. Svenson (2011), <em>Computer Experiments: Multiobjective Optimization and Sensitivity Analysis</em>, Ohio State University, PhD thesis. <br /> <br />
C. Chevalier (2013), <em>Fast uncertainty reduction strategies relying on Gaussian process models</em>, University of Bern, PhD thesis. <br /> <br />
M. Binois, V. Picheny (2019), GPareto: An R Package for Gaussian-Process-Based Multi-Objective Optimization and Analysis,
<em>Journal of Statistical Software</em>, 89(8), 1-30, <a href="https://doi.org/10.18637/jss.v089.i08">doi:10.18637/jss.v089.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="DiceKriging.html#topic+DiceKriging-package">DiceKriging-package</a></code>, <code><a href="DiceOptim.html#topic+DiceOptim-package">DiceOptim-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#------------------------------------------------------------
# Example 1 : Surrogate-based multi-objective Optimization with postprocessing
#------------------------------------------------------------
set.seed(25468)

d &lt;- 2 
fname &lt;- P2

plotParetoGrid(P2) # For comparison

# Optimization
budget &lt;- 25 
lower &lt;- rep(0, d) 
upper &lt;- rep(1, d)
     
omEGO &lt;- easyGParetoptim(fn = fname, budget = budget, lower = lower, upper = upper)

# Postprocessing
plotGPareto(omEGO, add= FALSE, UQ_PF = TRUE, UQ_PS = TRUE, UQ_dens = TRUE)


## End(Not run)
#------------------------------------------------------------
# Example 2 : Surrogate-based multi-objective Optimization including a cheap function
#------------------------------------------------------------
set.seed(42)
library(DiceDesign)

d &lt;- 2 

fname &lt;- P1
n.grid &lt;- 19
test.grid &lt;- expand.grid(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid))
nappr &lt;- 15 
design.grid &lt;- maximinESE_LHS(lhsDesign(nappr, d, seed = 42)$design)$design
response.grid &lt;- t(apply(design.grid, 1, fname))

mf1 &lt;- km(~., design = design.grid, response = response.grid[,1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[,2])
model &lt;- list(mf1, mf2)

nsteps &lt;- 1 
lower &lt;- rep(0, d)
upper &lt;- rep(1, d)

# Optimization with fastfun: hypervolume with discrete search

optimcontrol &lt;- list(method = "discrete", candidate.points = test.grid)
omEGO2 &lt;- GParetoptim(model = model, fn = fname, cheapfn = branin, crit = "SMS",
                      nsteps = nsteps, lower = lower, upper = upper,
                      optimcontrol = optimcontrol)
print(omEGO2$par)
print(omEGO2$values)

## Not run:  
plotGPareto(omEGO2)

#------------------------------------------------------------
# Example 3 : Surrogate-based multi-objective Optimization (4 objectives)
#------------------------------------------------------------
set.seed(42)
library(DiceDesign)

d &lt;- 5 

fname &lt;- DTLZ3
nappr &lt;- 25
design.grid &lt;- maximinESE_LHS(lhsDesign(nappr, d, seed = 42)$design)$design
response.grid &lt;- t(apply(design.grid, 1, fname, nobj = 4))
mf1 &lt;- km(~., design = design.grid, response = response.grid[,1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[,2])
mf3 &lt;- km(~., design = design.grid, response = response.grid[,3])
mf4 &lt;- km(~., design = design.grid, response = response.grid[,4])

# Optimization
nsteps &lt;- 5 
lower &lt;- rep(0, d) 
upper &lt;- rep(1, d)     
omEGO3 &lt;- GParetoptim(model = list(mf1, mf2, mf3, mf4), fn = fname, crit = "EMI",
                      nsteps = nsteps, lower = lower, upper = upper, nobj = 4)
print(omEGO3$par)
print(omEGO3$values)
plotGPareto(omEGO3)

#------------------------------------------------------------
# Example 4 : quantification of uncertainty on Pareto front
#------------------------------------------------------------
library(DiceDesign)
set.seed(42)

nvar &lt;- 2

# Test function P1
fname &lt;- "P1"

# Initial design
nappr &lt;- 10
design.grid &lt;- maximinESE_LHS(lhsDesign(nappr, nvar, seed = 42)$design)$design
response.grid &lt;- t(apply(design.grid, 1, fname))

PF &lt;- t(nondominated_points(t(response.grid)))

# kriging models : matern5_2 covariance structure, linear trend, no nugget effect
mf1 &lt;- km(~., design = design.grid, response = response.grid[,1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[,2])

# Conditional simulations generation with random sampling points 
nsim &lt;- 100 # increase for better results
npointssim &lt;- 1000 # increase for better results
Simu_f1 &lt;- matrix(0, nrow = nsim, ncol = npointssim)
Simu_f2 &lt;- matrix(0, nrow = nsim, ncol = npointssim)
design.sim &lt;- array(0, dim = c(npointssim, nvar, nsim))

for(i in 1:nsim){
  design.sim[,,i] &lt;- matrix(runif(nvar*npointssim), nrow = npointssim, ncol = nvar)
  Simu_f1[i,] &lt;- simulate(mf1, nsim = 1, newdata = design.sim[,,i], cond = TRUE,
                         checkNames = FALSE, nugget.sim = 10^-8)
  Simu_f2[i,] &lt;- simulate(mf2, nsim = 1, newdata = design.sim[,,i], cond = TRUE,
                         checkNames = FALSE, nugget.sim = 10^-8)
}

# Computation of the attainment function and Vorob'ev Expectation
CPF1 &lt;- CPF(Simu_f1, Simu_f2, response.grid, paretoFront = PF)

summary(CPF1)

plot(CPF1)

# Display of the symmetric deviation function
plotSymDevFun(CPF1)

## End(Not run)
</code></pre>

<hr>
<h2 id='GParetoptim'>Sequential multi-objective Expected Improvement maximization and model re-estimation,
with a number of iterations fixed in advance by the user</h2><span id='topic+GParetoptim'></span>

<h3>Description</h3>

<p>Executes <code>nsteps</code> iterations of multi-objective EGO methods to objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>.
At each step, kriging models are re-estimated (including covariance parameters re-estimation)
based on the initial design points plus the points visited during all previous iterations;
then a new point is obtained by maximizing one of the four multi-objective Expected Improvement criteria available. 
Handles noiseless and noisy objective functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GParetoptim(
  model,
  fn,
  ...,
  cheapfn = NULL,
  crit = "SMS",
  nsteps,
  lower,
  upper,
  type = "UK",
  cov.reestim = TRUE,
  critcontrol = NULL,
  noise.var = NULL,
  reinterpolation = NULL,
  optimcontrol = list(method = "genoud", trace = 1),
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GParetoptim_+3A_model">model</code></td>
<td>
<p>list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>, one for each objective functions,</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_fn">fn</code></td>
<td>
<p>the multi-objective function to be minimized (vectorial output), found by a call to <code><a href="base.html#topic+match.fun">match.fun</a></code>,</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_...">...</code></td>
<td>
<p>additional parameters to be given to the objective <code>fn</code>.</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_cheapfn">cheapfn</code></td>
<td>
<p>optional additional fast-to-evaluate objective function (handled next with class <code><a href="#topic+fastfun">fastfun</a></code>), which does not need a kriging model, 
handled by a call to <code><a href="base.html#topic+match.fun">match.fun</a></code>,</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_crit">crit</code></td>
<td>
<p>choice of multi-objective improvement function: &quot;<code>SMS</code>&quot;, &quot;<code>EHI</code>&quot;, &quot;<code>EMI</code>&quot; or &quot;<code>SUR</code>&quot;,
see details below,</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_nsteps">nsteps</code></td>
<td>
<p>an integer representing the desired number of iterations,</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_lower">lower</code></td>
<td>
<p>vector of lower bounds for the variables to be optimized over,</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_upper">upper</code></td>
<td>
<p>vector of upper bounds for the variables to be optimized over,</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_type">type</code></td>
<td>
<p>&quot;<code>SK</code>&quot; or &quot;<code>UK</code>&quot; (by default), depending whether uncertainty related to trend estimation has to be taken into account,
see <code><a href="DiceKriging.html#topic+km">km</a></code></p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_cov.reestim">cov.reestim</code></td>
<td>
<p>optional boolean specifying if the kriging hyperparameters should be re-estimated at each iteration,</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_critcontrol">critcontrol</code></td>
<td>
<p>optional list of parameters for criterion <code>crit</code>, see details,</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_noise.var">noise.var</code></td>
<td>
<p>noise variance (of the objective functions). Either <code>NULL</code> (noiseless objectives), a scalar (constant noise, identical for all objectives), 
a vector (constant noise, different for each objective) or 
a function (type closure) with vectorial output (variable noise, different for each objective). Alternatively, set <code>noise.var="given_by_fn"</code>, see details. 
If not provided but km models are based on noisy observations, <code>noise.var</code> is taken as the average of <code>model@noise.var</code>.</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_reinterpolation">reinterpolation</code></td>
<td>
<p>Boolean: for noisy problems, indicates whether a reinterpolation model is used, see details,</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_optimcontrol">optimcontrol</code></td>
<td>
<p>an optional list of control parameters for optimization of the selected infill criterion:
&quot;<code>method</code>&quot; can be set to &quot;<code>discrete</code>&quot;, &quot;<code>pso</code>&quot;, &quot;<code>genoud</code>&quot; or a user defined method name (passed to <code><a href="base.html#topic+match.fun">match.fun</a></code>). For &quot;<code>discrete</code>&quot;, 
a matrix <code>candidate.points</code> must be given.
For &quot;<code>pso</code>&quot; and &quot;<code>genoud</code>&quot;, specific parameters to the chosen method can also be specified  (see <code><a href="rgenoud.html#topic+genoud">genoud</a></code> and <code><a href="pso.html#topic+psoptim">psoptim</a></code>).
A user defined method must have arguments like the default <code><a href="stats.html#topic+optim">optim</a></code> method, i.e. <code>par</code>, <code>fn</code>, <code>lower</code>, <code>upper</code>, 
<code>...</code> and eventually <code>control</code>.<br />
A trace <code>trace</code> argument is available, it can be set to <code>0</code> to suppress all messages, to <code>1</code> (default) for displaying the optimization progresses,
and <code>&gt;1</code> for the highest level of details.</p>
</td></tr>
<tr><td><code id="GParetoptim_+3A_ncores">ncores</code></td>
<td>
<p>number of CPU available (&gt; 1 makes mean parallel <code>TRUE</code>). Only used with <code>discrete</code> optimization for now.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extension of the function <code><a href="DiceOptim.html#topic+EGO.nsteps">EGO.nsteps</a></code> for multi-objective optimization.<br />
Available infill criteria with <code>crit</code> are: <br />
</p>

<ul>
<li><p> Expected Hypervolume Improvement (<code>EHI</code>) <code><a href="#topic+crit_EHI">crit_EHI</a></code>,
</p>
</li>
<li><p> SMS criterion (<code>SMS</code>) <code><a href="#topic+crit_SMS">crit_SMS</a></code>,
</p>
</li>
<li><p> Expected Maximin Improvement (<code>EMI</code>) <code><a href="#topic+crit_EMI">crit_EMI</a></code>,
</p>
</li>
<li><p> Stepwise Uncertainty Reduction of the excursion volume (<code>SUR</code>) <code><a href="#topic+crit_SUR">crit_SUR</a></code>.
</p>
</li></ul>

<p>Depending on the selected criterion, parameters such as reference point for <code>SMS</code> and <code>EHI</code> or arguments for <code><a href="#topic+integration_design_optim">integration_design_optim</a></code> 
with <code>SUR</code> can be given with <code>critcontrol</code>.
Also options for <code><a href="#topic+checkPredict">checkPredict</a></code> are available.
More precisions are given in the corresponding help pages.<br />
</p>
<p>The <code>reinterpolation=TRUE</code> setting can be used to handle noisy objective functions. It works with all criteria and is the recommended option. 
If <code>reinterpolation=FALSE</code> and <code>noise.var!=NULL</code>, the criteria are used based on a &quot;denoised&quot; Pareto front.
</p>
<p>If <code>noise.var="given_by_fn"</code>, <code>fn</code> must return a list of two vectors, the first being the objective functions and the second 
the corresponding noise variances (see examples).
</p>
<p>Display of results and various post-processings are available with <code><a href="#topic+plotGPareto">plotGPareto</a></code>.
</p>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li> <p><code>par</code>: a data frame representing the additional points visited during the algorithm,
</p>
</li>
<li> <p><code>values</code>: a data frame representing the response values at the points given in <code>par</code>,
</p>
</li>
<li> <p><code>nsteps</code>: an integer representing the desired number of iterations (given in argument),
</p>
</li>
<li> <p><code>lastmodel</code>: a list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code> corresponding to the last kriging models fitted.
</p>
</li>
<li> <p><code>observations.denoised</code>:  if <code>noise.var!=NULL</code>, a matrix representing the mean values of the <code><a href="DiceKriging.html#topic+km">km</a></code> models at observation points.
If a problem occurs during either model updates or criterion maximization, the last working model and corresponding values are returned.
</p>
</li></ul>



<h3>References</h3>

<p>M. T. Emmerich, A. H. Deutz, J. W. Klinkenberg (2011), Hypervolume-based expected improvement: Monotonicity properties and exact computation,
<em>Evolutionary Computation (CEC)</em>, 2147-2154. <br /> <br />
V. Picheny (2014), Multiobjective optimization using Gaussian process emulators via stepwise uncertainty reduction, 
<em>Statistics and Computing</em>, 25(6), 1265-1280<br /> <br />
T. Wagner, M. Emmerich, A. Deutz, W. Ponweiser (2010), On expected-improvement criteria for model-based multi-objective optimization.   
<em>Parallel Problem Solving from Nature</em>, 718-727, Springer, Berlin. <br /> <br />
J. D. Svenson (2011), <em>Computer Experiments: Multiobjective Optimization and Sensitivity Analysis</em>, Ohio State university, PhD thesis. 
V. Picheny and D. Ginsbourger (2013), <em>Noisy kriging-based optimization methods: A unified implementation within the DiceOptim package</em>, 
<em>Computational Statistics &amp; Data Analysis</em>, 71: 1035-1053.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(25468)
library(DiceDesign)

################################################
# NOISELESS PROBLEMS
################################################
d &lt;- 2 
fname &lt;- ZDT3
n.grid &lt;- 21
test.grid &lt;- expand.grid(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid))
nappr &lt;- 15 
design.grid &lt;- maximinESE_LHS(lhsDesign(nappr, d, seed = 42)$design)$design
response.grid &lt;- t(apply(design.grid, 1, fname))
Front_Pareto &lt;- t(nondominated_points(t(response.grid)))

mf1 &lt;- km(~1, design = design.grid, response = response.grid[, 1], lower=c(.1,.1))
mf2 &lt;- km(~., design = design.grid, response = response.grid[, 2], lower=c(.1,.1))
model &lt;- list(mf1, mf2)

nsteps &lt;- 2
lower &lt;- rep(0, d)
upper &lt;- rep(1, d)

# Optimization 1: EHI with pso
optimcontrol &lt;- list(method = "pso", maxit = 20)
critcontrol &lt;- list(refPoint = c(1, 10))
omEGO1 &lt;- GParetoptim(model = model, fn = fname, crit = "EHI", nsteps = nsteps,
                     lower = lower, upper = upper, critcontrol = critcontrol,
                     optimcontrol = optimcontrol)
print(omEGO1$par)
print(omEGO1$values)

## Not run: 
nsteps &lt;- 10
# Optimization 2: SMS with discrete search
optimcontrol &lt;- list(method = "discrete", candidate.points = test.grid)
critcontrol &lt;- list(refPoint = c(1, 10))
omEGO2 &lt;- GParetoptim(model = model, fn = fname, crit = "SMS", nsteps = nsteps,
                     lower = lower, upper = upper, critcontrol = critcontrol,
                     optimcontrol = optimcontrol)
print(omEGO2$par)
print(omEGO2$values)

# Optimization 3: SUR with genoud
optimcontrol &lt;- list(method = "genoud", pop.size = 20, max.generations = 10)
critcontrol &lt;- list(distrib = "SUR", n.points = 100)
omEGO3 &lt;- GParetoptim(model = model, fn = fname, crit = "SUR", nsteps = nsteps,
                     lower = lower, upper = upper, critcontrol = critcontrol,
                     optimcontrol = optimcontrol)
print(omEGO3$par)
print(omEGO3$values)

# Optimization 4: EMI with pso
optimcontrol &lt;- list(method = "pso", maxit = 20)
critcontrol &lt;- list(nbsamp = 200)
omEGO4 &lt;- GParetoptim(model = model, fn = fname, crit = "EMI", nsteps = nsteps,
                     lower = lower, upper = upper, optimcontrol = optimcontrol)
print(omEGO4$par)
print(omEGO4$values)

# graphics
sol.grid &lt;- apply(expand.grid(seq(0, 1, length.out = 100),
                              seq(0, 1, length.out = 100)), 1, fname)
plot(t(sol.grid), pch = 20, col = rgb(0, 0, 0, 0.05), xlim = c(0, 1),
     ylim = c(-2, 10), xlab = expression(f[1]), ylab = expression(f[2]))
plotGPareto(res = omEGO1, add = TRUE,
            control = list(pch = 20, col = "blue", PF.pch = 17,
                           PF.points.col = "blue", PF.line.col = "blue"))
text(omEGO1$values[,1], omEGO1$values[,2], labels = 1:nsteps, pos = 3, col = "blue")
plotGPareto(res = omEGO2, add = TRUE,
            control = list(pch = 20, col = "green", PF.pch = 17,
                           PF.points.col = "green", PF.line.col = "green"))
text(omEGO2$values[,1], omEGO2$values[,2], labels = 1:nsteps, pos = 3, col = "green")
plotGPareto(res = omEGO3, add = TRUE,
            control = list(pch = 20, col = "red", PF.pch = 17,
                           PF.points.col = "red", PF.line.col = "red"))
text(omEGO3$values[,1], omEGO3$values[,2], labels = 1:nsteps, pos = 3, col = "red") 
plotGPareto(res = omEGO4, add = TRUE,
            control = list(pch = 20, col = "orange", PF.pch = 17,
                           PF.points.col = "orange", PF.line.col = "orange"))
text(omEGO4$values[,1], omEGO4$values[,2], labels = 1:nsteps, pos = 3, col = "orange")
points(response.grid[,1], response.grid[,2], col = "black", pch = 20)
legend("topright", c("EHI", "SMS", "SUR", "EMI"), col = c("blue", "green", "red", "orange"),
 pch = rep(17,4))
 
 
# Post-processing
plotGPareto(res = omEGO1, UQ_PF = TRUE, UQ_PS = TRUE, UQ_dens = TRUE)

################################################
# NOISY PROBLEMS
################################################
set.seed(25468)
library(DiceDesign)
d &lt;- 2 
nsteps &lt;- 3
lower &lt;- rep(0, d)
upper &lt;- rep(1, d)
optimcontrol &lt;- list(method = "pso", maxit = 20)
critcontrol &lt;- list(refPoint = c(1, 10))

n.grid &lt;- 21
test.grid &lt;- expand.grid(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid))
n.init &lt;- 30
design &lt;- maximinESE_LHS(lhsDesign(n.init, d, seed = 42)$design)$design

fit.models &lt;- function(u) km(~., design = design, response = response[, u],
                             noise.var=design.noise.var[,u])

# Test 1: EHI, constant noise.var
noise.var &lt;- c(0.1, 0.2)
funnoise1 &lt;- function(x) {ZDT3(x) + sqrt(noise.var)*rnorm(n=d)}
response &lt;- t(apply(design, 1, funnoise1))
design.noise.var &lt;- matrix(rep(noise.var, n.init), ncol=d, byrow=TRUE)
model &lt;- lapply(1:d, fit.models)

omEGO1 &lt;- GParetoptim(model = model, fn = funnoise1, crit = "EHI", nsteps = nsteps,
                      lower = lower, upper = upper, critcontrol = critcontrol,
                      reinterpolation=TRUE, noise.var=noise.var, optimcontrol = optimcontrol)
plotGPareto(omEGO1)

# Test 2: EMI, noise.var given by fn
funnoise2 &lt;- function(x) {list(ZDT3(x) + sqrt(0.05 + abs(0.1*x))*rnorm(n=d), 0.05 + abs(0.1*x))}
temp &lt;- funnoise2(design)
response &lt;- temp[[1]]
design.noise.var &lt;- temp[[2]]
model &lt;- lapply(1:d, fit.models)

omEGO2 &lt;- GParetoptim(model = model, fn = funnoise2, crit = "EMI", nsteps = nsteps,
                      lower = lower, upper = upper, critcontrol = critcontrol,
                      reinterpolation=TRUE, noise.var="given_by_fn", optimcontrol = optimcontrol)
plotGPareto(omEGO2)

# Test 3: SMS, functional noise.var
funnoise3 &lt;- function(x) {ZDT3(x) + sqrt(0.025 + abs(0.05*x))*rnorm(n=d)}
noise.var &lt;- function(x) return(0.025 + abs(0.05*x))
response &lt;- t(apply(design, 1, funnoise3))
design.noise.var &lt;- t(apply(design, 1, noise.var))
model &lt;- lapply(1:d, fit.models)

omEGO3 &lt;- GParetoptim(model = model, fn = funnoise3, crit = "SMS", nsteps = nsteps,
                           lower = lower, upper = upper, critcontrol = critcontrol,
                           reinterpolation=TRUE, noise.var=noise.var, optimcontrol = optimcontrol)
plotGPareto(omEGO3)

# Test 4: SUR, fastfun, constant noise.var
noise.var &lt;- 0.1
funnoise4 &lt;- function(x) {ZDT3(x)[1] + sqrt(noise.var)*rnorm(1)}
cheapfn &lt;- function(x) ZDT3(x)[2]
response &lt;- apply(design, 1, funnoise4)
design.noise.var &lt;- rep(noise.var, n.init)
model &lt;- list(km(~., design = design, response = response, noise.var=design.noise.var))

omEGO4 &lt;- GParetoptim(model = model, fn = funnoise4, cheapfn = cheapfn, crit = "SUR", 
                      nsteps = nsteps, lower = lower, upper = upper, critcontrol = critcontrol,
                      reinterpolation=TRUE, noise.var=noise.var, optimcontrol = optimcontrol)
 plotGPareto(omEGO4)
                            
 # Test 5: EMI, fastfun, noise.var given by fn
 funnoise5 &lt;- function(x) {
   if (is.null(dim(x))) x &lt;- matrix(x, nrow=1)
   list(apply(x, 1, ZDT3)[1,] + sqrt(abs(0.05*x[,1]))*rnorm(nrow(x)), abs(0.05*x[,1]))
 }
 
 cheapfn &lt;- function(x) {
   if (is.null(dim(x))) x &lt;- matrix(x, nrow=1)
   apply(x, 1, ZDT3)[2,]
 }
 
 temp &lt;- funnoise5(design)
 response &lt;- temp[[1]]
 design.noise.var &lt;- temp[[2]]
 model &lt;- list(km(~., design = design, response = response, noise.var=design.noise.var))
 
 omEGO5 &lt;- GParetoptim(model = model, fn = funnoise5, cheapfn = cheapfn, crit = "EMI", 
                       nsteps = nsteps, lower = lower, upper = upper, critcontrol = critcontrol,
                       reinterpolation=TRUE, noise.var="given_by_fn", optimcontrol = optimcontrol)
 plotGPareto(omEGO5)               
 
 # Test 6: EHI, fastfun, functional noise.var
 noise.var &lt;- 0.1
 funnoise6 &lt;- function(x) {ZDT3(x)[1] + sqrt(abs(0.1*x[1]))*rnorm(1)}
 noise.var &lt;- function(x) return(abs(0.1*x[1]))
 cheapfn &lt;- function(x) ZDT3(x)[2]
 response &lt;- apply(design, 1, funnoise6)
 design.noise.var &lt;- t(apply(design, 1, noise.var))
 model &lt;- list(km(~., design = design, response = response, noise.var=design.noise.var))
 
 omEGO6 &lt;- GParetoptim(model = model, fn = funnoise6, cheapfn = cheapfn, crit = "EMI", 
                       nsteps = nsteps, lower = lower, upper = upper, critcontrol = critcontrol,
                       reinterpolation=TRUE, noise.var=noise.var, optimcontrol = optimcontrol)
 plotGPareto(omEGO6)    

## End(Not run)
</code></pre>

<hr>
<h2 id='integration_design_optim'>Function to build integration points (for the SUR criterion)</h2><span id='topic+integration_design_optim'></span>

<h3>Description</h3>

<p>Modification of the function  <code><a href="KrigInv.html#topic+integration_design">integration_design</a></code> from the package <code><a href="KrigInv.html#topic+KrigInv-package">KrigInv-package</a></code> to 
be usable for SUR-based optimization. Handles two or three objectives.
Available important sampling schemes: none so far.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integration_design_optim(
  SURcontrol = NULL,
  d = NULL,
  lower,
  upper,
  model = NULL,
  min.prob = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integration_design_optim_+3A_surcontrol">SURcontrol</code></td>
<td>
<p>Optional list specifying the procedure to build the integration points and weights. 
Many options are possible; see 'Details'.</p>
</td></tr>
<tr><td><code id="integration_design_optim_+3A_d">d</code></td>
<td>
<p>The dimension of the input set. If not provided <code>d</code> is set equal to the length of <code>lower</code>.</p>
</td></tr>
<tr><td><code id="integration_design_optim_+3A_lower">lower</code></td>
<td>
<p>Vector containing the lower bounds of the design space.</p>
</td></tr>
<tr><td><code id="integration_design_optim_+3A_upper">upper</code></td>
<td>
<p>Vector containing the upper bounds of the design space.</p>
</td></tr>
<tr><td><code id="integration_design_optim_+3A_model">model</code></td>
<td>
<p>A list of kriging models of <code>km</code> class.</p>
</td></tr>
<tr><td><code id="integration_design_optim_+3A_min.prob">min.prob</code></td>
<td>
<p>This argument applies only when importance sampling distributions are chosen. 
For numerical reasons we give a minimum probability for a point to
belong to the importance sample. This avoids probabilities equal to zero and importance sampling
weights equal to infinity. In an importance sample of <code>M</code> points, the maximum weight becomes 
<code>1/min.prob * 1/M</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>SURcontrol</code> argument is a list with possible entries <code>integration.points</code>, <code>integration.weights</code>, <code>n.points</code>,
<code>n.candidates</code>, <code>distrib</code>, <code>init.distrib</code> and <code>init.distrib.spec</code>. It can be used 
in one of the three following ways:
</p>

<ul>
<li><p> A) If nothing is specified, <code>100 * d</code> points are chosen using the Sobol sequence;
</p>
</li>
<li><p> B) One can directly set the field <code>integration.points</code> (<code>p * d</code> matrix) for prespecified integration points. 
In this case these integration points and the corresponding vector <code>integration.weights</code> will be used 
for all the iterations of the algorithm;
</p>
</li>
<li><p> C) If the field <code>integration.points</code> is not set then the integration points are renewed at each iteration. 
In that case one can control the number of integration points <code>n.points</code> (default: <code>100*d</code>) and a specific 
distribution <code>distrib</code>. Possible values for distrib are: &quot;<code>sobol</code>&quot;, &quot;<code>MC</code>&quot; and &quot;<code>SUR</code>&quot;
(default: &quot;<code>sobol</code>&quot;):
</p>

<ul>
<li><p> C.1) The choice &quot;<code>sobol</code>&quot; corresponds to integration points chosen with the Sobol sequence in dimension <code>d</code> (uniform weight);
</p>
</li>
<li><p> C.2) The choice &quot;<code>MC</code>&quot; corresponds to points chosen randomly, uniformly on the domain;
</p>
</li>
<li><p> C.3) The choice &quot;<code>SUR</code>&quot; corresponds to importance sampling distributions (unequal weights). <br />
When important sampling procedures are chosen, <code>n.points</code> points are chosen using importance sampling among a discrete 
set of <code>n.candidates</code> points (default: <code>n.points*10</code>) which are distributed according to a distribution <code>init.distrib</code> 
(default: &quot;<code>sobol</code>&quot;). Possible values for <code>init.distrib</code> are the space filling distributions &quot;<code>sobol</code>&quot; and &quot;<code>MC</code>&quot; 
or an user defined distribution &quot;<code>spec</code>&quot;. The &quot;<code>sobol</code>&quot; and &quot;<code>MC</code>&quot; choices correspond to quasi random and random points 
in the domain. If the &quot;<code>spec</code>&quot; value is chosen the user must fill in manually the field <code>init.distrib.spec</code> to specify 
himself a <code>n.candidates * d</code> matrix of points in dimension <code>d</code>.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li> <p><code>integration.points</code>, <code>p x d</code> matrix of p points used for the numerical calculation of integrals,
</p>
</li>
<li> <p><code>integration.weights</code>, a vector of size <code>p</code> corresponding to the weight of each point. If all the points are equally 
weighted, <code>integration.weights</code> is set to <code>NULL</code>.
</p>
</li></ul>



<h3>References</h3>

<p>V. Picheny (2014), Multiobjective optimization using Gaussian process emulators via stepwise uncertainty reduction, 
<em>Statistics and Computing</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GParetoptim">GParetoptim</a></code> <code><a href="#topic+crit_SUR">crit_SUR</a></code> <code><a href="KrigInv.html#topic+integration_design">integration_design</a></code>
</p>

<hr>
<h2 id='nonDomSet'>Non-dominated points with respect to a reference</h2><span id='topic+nonDomSet'></span>

<h3>Description</h3>

<p>Determines which elements in a set are dominated by reference points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonDomSet(points, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonDomSet_+3A_points">points</code></td>
<td>
<p>matrix (one point per row) that are compared to a reference <code>ref</code> (i.e., not between themselves)</p>
</td></tr>
<tr><td><code id="nonDomSet_+3A_ref">ref</code></td>
<td>
<p>matrix (one point per row) of reference (faster if they are already Pareto optimal)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
d &lt;- 6
n &lt;- 1000
n2 &lt;- 1000

test &lt;- matrix(runif(d * n), n)
ref &lt;- matrix(runif(d * n), n)
indPF &lt;- which(!is_dominated(t(ref)))

system.time(res &lt;- nonDomSet(test, ref[indPF,,drop = FALSE]))

res2 &lt;- rep(NA, n2)
library(emoa)
t0 &lt;- Sys.time()
for(i in 1:n2){
  res2[i] &lt;- !is_dominated(t(rbind(test[i,, drop = FALSE], ref[indPF,])))[1]
}
print(Sys.time() - t0)

all(res == res2)

## End(Not run)
</code></pre>

<hr>
<h2 id='ParetoSetDensity'>Estimation of Pareto set density</h2><span id='topic+ParetoSetDensity'></span>

<h3>Description</h3>

<p>Estimation of the density of Pareto optimal points in the variable space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ParetoSetDensity(
  model,
  lower,
  upper,
  CPS = NULL,
  nsim = 50,
  simpoints = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ParetoSetDensity_+3A_model">model</code></td>
<td>
<p>list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>, one for each objective functions,</p>
</td></tr>
<tr><td><code id="ParetoSetDensity_+3A_lower">lower</code></td>
<td>
<p>vector of lower bounds for the variables,</p>
</td></tr>
<tr><td><code id="ParetoSetDensity_+3A_upper">upper</code></td>
<td>
<p>vector of upper bounds for the variables,</p>
</td></tr>
<tr><td><code id="ParetoSetDensity_+3A_cps">CPS</code></td>
<td>
<p>optional matrix containing points from Conditional Pareto Set Simulations 
(in the variable space), see details</p>
</td></tr>
<tr><td><code id="ParetoSetDensity_+3A_nsim">nsim</code></td>
<td>
<p>optional number of conditional simulations to perform if <code>CPS</code> is not provided,</p>
</td></tr>
<tr><td><code id="ParetoSetDensity_+3A_simpoints">simpoints</code></td>
<td>
<p>(optional) If <code>CPS</code> is <code>NULL</code>, either a number of simulation points,
or a matrix where conditional simulations are to be performed. In the first case, 
then simulation points are taken as a maximin LHS design using <code><a href="DiceDesign.html#topic+lhsDesign">lhsDesign</a></code>.</p>
</td></tr>
<tr><td><code id="ParetoSetDensity_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="ks.html#topic+kde">kde</a></code>. 
In particular, if the input dimension is greater than three, 
a matrix <code>eval.points</code> can be given (else it is taken as the simulation points).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the density of Pareto optimal points in the variable space
given by the surrogate models. Based on conditional simulations of the objectives at simulation points,
Conditional Pareto Set (CPS) simulations are obtained, out of which a density is fitted. 
</p>
<p>This function relies on the <code><a href="ks.html#topic+ks-package">ks-package</a></code> package for the kernel density estimation.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="ks.html#topic+kde">kde</a></code> accounting for the 
estimated density of Pareto optimal points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
#---------------------------------------------------------------------------
# Example of estimation of the density of Pareto optimal points
#---------------------------------------------------------------------------
set.seed(42)
n_var &lt;- 2 
fname &lt;- P1
lower &lt;- rep(0, n_var)
upper &lt;- rep(1, n_var)

res1 &lt;- easyGParetoptim(fn = fname, lower = lower, upper = upper, budget = 15, 
control=list(method = "EHI", inneroptim = "pso", maxit = 20))

estDens &lt;- ParetoSetDensity(res1$model, lower = lower, upper = upper)

# graphics
par(mfrow = c(1,2))
plot(estDens, display = "persp", xlab = "X1", ylab = "X2")
plot(estDens, display = "filled.contour2", main = "Estimated density of Pareto optimal point")
points(res1$model[[1]]@X[,1], res1$model[[2]]@X[,2], col="blue")
points(estDens$x[, 1], estDens$x[, 2], pch = 20, col = rgb(0, 0, 0, 0.15))
par(mfrow = c(1,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_uncertainty'>Plot uncertainty</h2><span id='topic+plot_uncertainty'></span>

<h3>Description</h3>

<p>Displays the probability of non-domination in the variable space. In dimension larger than two, projections in 2D subspaces are displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_uncertainty(
  model,
  paretoFront = NULL,
  type = "pn",
  lower,
  upper,
  resolution = 51,
  option = "mean",
  nintegpoints = 400
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_uncertainty_+3A_model">model</code></td>
<td>
<p>list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code>, one for each objective functions,</p>
</td></tr>
<tr><td><code id="plot_uncertainty_+3A_paretofront">paretoFront</code></td>
<td>
<p>(optional) matrix corresponding to the Pareto front of size <code>[n.pareto x n.obj]</code>,</p>
</td></tr>
<tr><td><code id="plot_uncertainty_+3A_type">type</code></td>
<td>
<p>type of uncertainty, for now only the probability of improvement over the Pareto front,</p>
</td></tr>
<tr><td><code id="plot_uncertainty_+3A_lower">lower</code></td>
<td>
<p>vector of lower bounds for the variables,</p>
</td></tr>
<tr><td><code id="plot_uncertainty_+3A_upper">upper</code></td>
<td>
<p>vector of upper bounds for the variables,</p>
</td></tr>
<tr><td><code id="plot_uncertainty_+3A_resolution">resolution</code></td>
<td>
<p>grid size (the total number of points is <code>resolution^d</code>),</p>
</td></tr>
<tr><td><code id="plot_uncertainty_+3A_option">option</code></td>
<td>
<p>optional argument (string) for n &gt; 2 variables to define the projection type. The 3 possible values are &quot;mean&quot; (default), &quot;max&quot; and &quot;min&quot;,</p>
</td></tr>
<tr><td><code id="plot_uncertainty_+3A_nintegpoints">nintegpoints</code></td>
<td>
<p>number of integration points for computation of mean, max and min values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function inspired by the function <code><a href="KrigInv.html#topic+print_uncertainty">print_uncertainty</a></code> and 
<code><a href="KrigInv.html#topic+print_uncertainty_nd">print_uncertainty_nd</a></code> from the package <code><a href="KrigInv.html#topic+KrigInv-package">KrigInv-package</a></code>.
Non-dominated observations are represented with green diamonds, dominated ones by yellow triangles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
#---------------------------------------------------------------------------
# 2D, bi-objective function
#---------------------------------------------------------------------------
set.seed(25468)
n_var &lt;- 2 
fname &lt;- P1
lower &lt;- rep(0, n_var)
upper &lt;- rep(1, n_var)
res1 &lt;- easyGParetoptim(fn=fname, lower=lower, upper=upper, budget=15, 
control=list(method="EHI", inneroptim="pso", maxit=20))

plot_uncertainty(res1$model, lower = lower, upper = upper)

#---------------------------------------------------------------------------
# 4D, bi-objective function
#---------------------------------------------------------------------------
set.seed(25468)
n_var &lt;- 4
fname &lt;- DTLZ2
lower &lt;- rep(0, n_var)
upper &lt;- rep(1, n_var)
res &lt;- easyGParetoptim(fn=fname, lower=lower, upper=upper, budget = 40, 
control=list(method="EHI", inneroptim="pso", maxit=40))

plot_uncertainty(res$model, lower = lower, upper = upper, resolution = 31)

## End(Not run) 
</code></pre>

<hr>
<h2 id='plotGPareto'>Plot multi-objective optimization results and post-processing</h2><span id='topic+plotGPareto'></span>

<h3>Description</h3>

<p>Display results of multi-objective optimization returned by either <code><a href="#topic+GParetoptim">GParetoptim</a></code> or <code><a href="#topic+easyGParetoptim">easyGParetoptim</a></code>,
possibly completed with various post-processings of uncertainty quantification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGPareto(
  res,
  add = FALSE,
  UQ_PF = FALSE,
  UQ_PS = FALSE,
  UQ_dens = FALSE,
  lower = NULL,
  upper = NULL,
  control = list(pch = 20, col = "red", PF.line.col = "cyan", PF.pch = 17, PF.points.col
    = "blue", VE.line.col = "cyan", nsim = 100, npsim = 1500, gridtype = "runif",
    displaytype = "persp", printVD = TRUE, use.rgl = TRUE, bounds = NULL, meshsize3d =
    50, theta = -25, phi = 10, add_denoised_PF = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGPareto_+3A_res">res</code></td>
<td>
<p>list returned by <code><a href="#topic+GParetoptim">GParetoptim</a></code> or <code><a href="#topic+easyGParetoptim">easyGParetoptim</a></code>,</p>
</td></tr>
<tr><td><code id="plotGPareto_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code> adds the first graphical output to an already existing plot; 
if <code>FALSE</code>, (default) starts a new plot,</p>
</td></tr>
<tr><td><code id="plotGPareto_+3A_uq_pf">UQ_PF</code></td>
<td>
<p>logical; for 2 objectives, if <code>TRUE</code> perform a quantification of uncertainty on
the Pareto front to display the symmetric deviation function with <code><a href="#topic+plotSymDevFun">plotSymDevFun</a></code> (cannot be added to existing graph),</p>
</td></tr>
<tr><td><code id="plotGPareto_+3A_uq_ps">UQ_PS</code></td>
<td>
<p>logical; if <code>TRUE</code> call <code><a href="#topic+plot_uncertainty">plot_uncertainty</a></code> representing the probability of non-domination in the variable space,</p>
</td></tr>
<tr><td><code id="plotGPareto_+3A_uq_dens">UQ_dens</code></td>
<td>
<p>logical; for 2D problems, if <code>TRUE</code> call <code><a href="#topic+ParetoSetDensity">ParetoSetDensity</a></code> to estimate and display the density of Pareto optimal points in the variable space,</p>
</td></tr>
<tr><td><code id="plotGPareto_+3A_lower">lower</code></td>
<td>
<p>optional vector of lower bounds for the variables. 
Necessary if <code>UQ_PF</code> and/or <code>UQ_PS</code> are <code>TRUE</code> (if not provided, variables are supposed to vary between 0 and 1),</p>
</td></tr>
<tr><td><code id="plotGPareto_+3A_upper">upper</code></td>
<td>
<p>optional vector of upper bounds for the variables. 
Necessary if <code>UQ_PF</code> and/or <code>UQ_PS</code> are <code>TRUE</code> (if not provided, variables are supposed to vary between 0 and 1),</p>
</td></tr>
<tr><td><code id="plotGPareto_+3A_control">control</code></td>
<td>
<p>optional list, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>plotGPareto</code> displays the Pareto front delimiting the non-dominated area with 2 objectives,
by a perspective view with 3 objectives and using parallel coordinates with more objectives.<br /> 
</p>
<p>Setting one or several of UQ_PF, UQ_PS and UQ_dens allows to run and display post-processing tools that assess
the precision and confidence of the optimization run, either in the objective (<code>UQ_PF</code>) or the variable spaces 
(<code>UQ_PS</code>, <code>UQ_dens</code>). Note that these options are computationally intensive.
</p>
<p>Various parameters can be used for the display of results and/or passed to subsequent function:
</p>

<ul>
<li> <p><code>col</code>, <code>pch</code> correspond the color and plotting character for observations,
</p>
</li>
<li> <p><code>PF.line.col</code>, <code>PF.pch</code>, <code>PF.points.col</code> define the color of the line denoting the current Pareto front,
the plotting character and color of non-dominated observations, respectively,
</p>
</li>
<li> <p><code>nsim</code>, <code>npsim</code> and <code>gridtype</code> define the number of conditional simulations performed with [DiceKriging::simulate()]
along with the number of simulation points (in case <code>UQ_PF</code> and/or <code>UQ_dens</code> are <code>TRUE</code>),
</p>
</li>
<li> <p><code>gridtype</code> to define how simulation points are selected; 
alternatives are '<code>runif</code>' (default) for uniformly sampled points,
'<code>LHS</code>' for a Latin Hypercube design using <code><a href="DiceDesign.html#topic+lhsDesign">lhsDesign</a></code> and 
'<code>grid2d</code>' for a two dimensional grid,
</p>
</li>
<li> <p><code>f1lim</code>, <code>f2lim</code> can be passed to <code><a href="#topic+CPF">CPF</a></code>,
</p>
</li>
<li> <p><code>resolution</code>, <code>option</code>, <code>nintegpoints</code> are to be passed to <code><a href="#topic+plot_uncertainty">plot_uncertainty</a></code>
</p>
</li>
<li> <p><code>displaytype</code> type of display for <code>UQ_dens</code>, see <code><a href="ks.html#topic+plot.kde">plot.kde</a></code>,
</p>
</li>
<li> <p><code>printVD</code> logical, if <code>TRUE</code> and <code>UQ_PF</code> is <code>TRUE</code> as well, print the value of the Vorob'ev deviation,
</p>
</li>
<li> <p><code>use.rgl</code> if <code>TRUE</code>, use rgl for 3D plots, else <code><a href="graphics.html#topic+persp">persp</a></code> is used,
</p>
</li>
<li> <p><code>bounds</code> if <code>use.rgl</code> is <code>TRUE</code>, optional <code>2*nobj</code> matrix of boundaries, see <code><a href="#topic+plotParetoEmp">plotParetoEmp</a></code>
</p>
</li>
<li> <p><code>meshsize3d</code> mesh size of the perspective view for 3-objective problems,
</p>
</li>
<li> <p><code>theta</code>, <code>phi</code> angles for perspective view of 3-objective problems,
</p>
</li>
<li> <p><code>add_denoised_PF</code> if <code>TRUE</code>, in the noisy case, add the Pareto front from the estimated mean of the observations.
</p>
</li></ul>



<h3>References</h3>

<p>M. Binois, D. Ginsbourger and O. Roustant (2015), Quantifying Uncertainty on Pareto Fronts with Gaussian process conditional simulations, 
<em>European Journal of Operational Research</em>, 243(2), 386-394. <br /> <br />
A. Inselberg (2009), <em>Parallel coordinates</em>, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#---------------------------------------------------------------------------
# 2D objective function
#---------------------------------------------------------------------------
set.seed(25468)
n_var &lt;- 2 
fname &lt;- P1
lower &lt;- rep(0, n_var)
upper &lt;- rep(1, n_var)
res &lt;- easyGParetoptim(fn=fname, lower=lower, upper=upper, budget=15, 
control=list(method="EHI", inneroptim="pso", maxit=20))

## Pareto front only
plotGPareto(res)

## With post-processing
plotGPareto(res, UQ_PF = TRUE, UQ_PS = TRUE, UQ_dens = TRUE)

## With noise
noise.var &lt;- c(10, 2)
funnoise &lt;- function(x) {P1(x) + sqrt(noise.var)*rnorm(n=2)}
res2 &lt;- easyGParetoptim(fn=funnoise, lower=lower, upper=upper, budget=15, noise.var=noise.var,
                       control=list(method="EHI", inneroptim="pso", maxit=20))
                       
plotGPareto(res2, control=list(add_denoised_PF=FALSE)) # noisy observations only
plotGPareto(res2)

#---------------------------------------------------------------------------
# 3D objective function
#---------------------------------------------------------------------------
set.seed(1)
n_var &lt;- 3 
fname &lt;- DTLZ1
lower &lt;- rep(0, n_var)
upper &lt;- rep(1, n_var)
res3 &lt;- easyGParetoptim(fn=fname, lower=lower, upper=upper, budget=50, 
control=list(method="EHI", inneroptim="pso", maxit=20))

## Pareto front only
plotGPareto(res3)

## With noise
noise.var &lt;- c(10, 2, 5)
funnoise &lt;- function(x) {fname(x) + sqrt(noise.var)*rnorm(n=3)}
res4 &lt;- easyGParetoptim(fn=funnoise, lower=lower, upper=upper, budget=100, noise.var=noise.var,
                       control=list(method="EHI", inneroptim="pso", maxit=20))
                       
plotGPareto(res4, control=list(add_denoised_PF=FALSE)) # noisy observations only
plotGPareto(res4)   

## End(Not run)
</code></pre>

<hr>
<h2 id='plotParetoEmp'>Pareto front visualization</h2><span id='topic+plotParetoEmp'></span>

<h3>Description</h3>

<p>Plot the Pareto front with step functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotParetoEmp(
  nondominatedPoints,
  add = TRUE,
  max = FALSE,
  bounds = NULL,
  alpha = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotParetoEmp_+3A_nondominatedpoints">nondominatedPoints</code></td>
<td>
<p>points considered to plot the Pareto front with segments, matrix with one point per row,</p>
</td></tr>
<tr><td><code id="plotParetoEmp_+3A_add">add</code></td>
<td>
<p>optional boolean indicating whether a new graphic should be drawn,</p>
</td></tr>
<tr><td><code id="plotParetoEmp_+3A_max">max</code></td>
<td>
<p>optional boolean indicating whether to display a Pareto front in a maximization context,</p>
</td></tr>
<tr><td><code id="plotParetoEmp_+3A_bounds">bounds</code></td>
<td>
<p>for 3D, optional 2*nobj matrix of boundaries</p>
</td></tr>
<tr><td><code id="plotParetoEmp_+3A_alpha">alpha</code></td>
<td>
<p>for 3D, optional value in [0,1] for transparency</p>
</td></tr>
<tr><td><code id="plotParetoEmp_+3A_...">...</code></td>
<td>
<p>additional values to be passed to the <code><a href="graphics.html#topic+lines">lines</a></code> function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#------------------------------------------------------------
# Simple example
#------------------------------------------------------------

x &lt;- c(0.2, 0.4, 0.6, 0.8)
y &lt;- c(0.8, 0.7, 0.5, 0.1)

plot(x, y, col = "green", pch = 20) 

plotParetoEmp(cbind(x, y), col = "green")
## Alternative
plotParetoEmp(cbind(x, y), col = "red", add = FALSE)

## With maximization
plotParetoEmp(cbind(x, y), col = "blue", max = TRUE)

## 3D plots
library(rgl)
set.seed(5)
X &lt;- matrix(runif(60), ncol=3)
Xnd &lt;- t(nondominated_points(t(X)))
plot3d(X)
plot3d(Xnd, col="red", size=8, add=TRUE)
plot3d(x=min(Xnd[,1]), y=min(Xnd[,2]), z=min(Xnd[,3]), col="green", size=8, add=TRUE)
X.range &lt;- diff(apply(X,2,range))
bounds &lt;- rbind(apply(X,2,min)-0.1*X.range,apply(X,2,max)+0.1*X.range)
plotParetoEmp(nondominatedPoints = Xnd, add=TRUE, bounds=bounds, alpha=0.5)

</code></pre>

<hr>
<h2 id='plotParetoGrid'>Visualisation of Pareto front and set</h2><span id='topic+plotParetoGrid'></span>

<h3>Description</h3>

<p>Plot the Pareto front and set for 2 variables 2 objectives test problems with evaluations on a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotParetoGrid(fname = "ZDT1", xlim = c(0, 1), ylim = c(0, 1), n.grid = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotParetoGrid_+3A_fname">fname</code></td>
<td>
<p>name of the function considered,</p>
</td></tr>
<tr><td><code id="plotParetoGrid_+3A_xlim">xlim</code>, <code id="plotParetoGrid_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, giving the <code>x</code> and <code>y</code> coordinates ranges, default is <code>[0,1] x [0,1]</code>,</p>
</td></tr>
<tr><td><code id="plotParetoGrid_+3A_n.grid">n.grid</code></td>
<td>
<p>number of divisions of the grid in each dimension.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#------------------------------------------------------------
# Examples with test functions
#------------------------------------------------------------

plotParetoGrid("ZDT3", n.grid = 21)

plotParetoGrid("P1", n.grid = 21)

plotParetoGrid("MOP2", xlim = c(0, 1), ylim = c(0, 1), n.grid = 21) 
</code></pre>

<hr>
<h2 id='plotSymDevFun'>Display the Symmetric Deviation Function</h2><span id='topic+plotSymDevFun'></span>

<h3>Description</h3>

<p>Display the Symmetric Deviation Function for an object of class CPF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSymDevFun(CPF, n.grid = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSymDevFun_+3A_cpf">CPF</code></td>
<td>
<p>CPF object, see <code><a href="#topic+CPF">CPF</a></code>,</p>
</td></tr>
<tr><td><code id="plotSymDevFun_+3A_n.grid">n.grid</code></td>
<td>
<p>number of divisions of the grid in each dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Display observations in red and the corresponding Pareto front by a step-line. 
The blue line is the estimation of the location of the Pareto front of the kriging models, named Vorob'ev expectation. 
In grayscale is the intensity of the deviation (symmetrical difference) from the Vorob'ev expectation for couples of conditional simulations.
</p>


<h3>References</h3>

<p>M. Binois, D. Ginsbourger and O. Roustant (2015), Quantifying Uncertainty on Pareto Fronts with Gaussian process conditional simulations, 
<em>European Journal of Operational Research</em>, 243(2), 386-394. <br /> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DiceDesign)
set.seed(42)

nvar &lt;- 2

# Test function
fname = "P1"

# Initial design
nappr &lt;- 10
design.grid &lt;- maximinESE_LHS(lhsDesign(nappr, nvar, seed = 42)$design)$design
response.grid &lt;- t(apply(design.grid, 1, fname))

ParetoFront &lt;- t(nondominated_points(t(response.grid)))

# kriging models : matern5_2 covariance structure, linear trend, no nugget effect
mf1 &lt;- km(~., design = design.grid, response = response.grid[, 1])
mf2 &lt;- km(~., design = design.grid, response = response.grid[, 2])

# Conditional simulations generation with random sampling points 
nsim &lt;- 10 # increase for better results
npointssim &lt;- 80 # increase for better results
Simu_f1 = matrix(0, nrow = nsim, ncol = npointssim)
Simu_f2 = matrix(0, nrow = nsim, ncol = npointssim)
design.sim = array(0,dim = c(npointssim, nvar, nsim))

for(i in 1:nsim){
  design.sim[,, i] &lt;- matrix(runif(nvar*npointssim), npointssim, nvar)
  Simu_f1[i,] = simulate(mf1, nsim = 1, newdata = design.sim[,, i], cond = TRUE,
                         checkNames = FALSE, nugget.sim = 10^-8)
  Simu_f2[i,] = simulate(mf2, nsim = 1, newdata = design.sim[,, i], cond=TRUE, 
                         checkNames = FALSE, nugget.sim = 10^-8)
}

# Attainment, Voreb'ev expectation and deviation estimation
CPF1 &lt;- CPF(Simu_f1, Simu_f2, response.grid, ParetoFront)

# Symmetric deviation function
plotSymDevFun(CPF1)

</code></pre>

<hr>
<h2 id='plotSymDifRNP'>Symmetrical difference of RNP sets</h2><span id='topic+plotSymDifRNP'></span>

<h3>Description</h3>

<p>Plot the symmetrical difference between two 
Random Non-Dominated Point (RNP) sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSymDifRNP(set1, set2, xlim, ylim, fill = "black", add = "FALSE", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSymDifRNP_+3A_set1">set1</code>, <code id="plotSymDifRNP_+3A_set2">set2</code></td>
<td>
<p>RNP sets considered,</p>
</td></tr>
<tr><td><code id="plotSymDifRNP_+3A_xlim">xlim</code>, <code id="plotSymDifRNP_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, giving the <code>x</code> and <code>y</code> coordinates ranges for plotting,</p>
</td></tr>
<tr><td><code id="plotSymDifRNP_+3A_fill">fill</code></td>
<td>
<p>optional color of the symmetric difference area,</p>
</td></tr>
<tr><td><code id="plotSymDifRNP_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code> add to an already existing plot; if <code>FALSE</code> (default) start a new plot taking <code>xlim, ylim</code> as limits.</p>
</td></tr>
<tr><td><code id="plotSymDifRNP_+3A_...">...</code></td>
<td>
<p>additional parameters for the <code><a href="graphics.html#topic+plot.default">plot.default</a></code> and <code><a href="graphics.html#topic+polygon">polygon</a></code> graphic functions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#------------------------------------------------------------
# Simple example
#------------------------------------------------------------
set1 &lt;- rbind(c(0.2, 0.35, 0.5, 0.8),
              c(0.8, 0.6, 0.55, 0.3))

set2 &lt;- rbind(c(0.3, 0.4),
              c(0.7, 0.4))

plotSymDifRNP(set1, set2, xlim = c(0, 1), ylim = c(0, 1), fill = "grey")
points(t(set1), col = "red", pch = 20)
points(t(set2), col = "blue", pch = 20)
</code></pre>

<hr>
<h2 id='predict_kms'>Predict function for list of <code><a href="DiceKriging.html#topic+km">km</a></code> models.</h2><span id='topic+predict_kms'></span>

<h3>Description</h3>

<p>Predict function for list of <code><a href="DiceKriging.html#topic+km">km</a></code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_kms(
  model,
  newdata,
  type,
  se.compute = TRUE,
  cov.compute = FALSE,
  light.return = TRUE,
  bias.correct = FALSE,
  checkNames = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_kms_+3A_model">model</code></td>
<td>
<p>list of <code><a href="DiceKriging.html#topic+km">km</a></code> models</p>
</td></tr>
<tr><td><code id="predict_kms_+3A_newdata">newdata</code>, <code id="predict_kms_+3A_type">type</code>, <code id="predict_kms_+3A_se.compute">se.compute</code>, <code id="predict_kms_+3A_cov.compute">cov.compute</code>, <code id="predict_kms_+3A_light.return">light.return</code>, <code id="predict_kms_+3A_bias.correct">bias.correct</code>, <code id="predict_kms_+3A_checknames">checkNames</code>, <code id="predict_kms_+3A_...">...</code></td>
<td>
<p>see <code><a href="DiceKriging.html#topic+predict.km">predict.km</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>So far only <code>light.return = TRUE</code> handled. For the cov field, a list of cov matrices is returned.
</p>

<hr>
<h2 id='ZDT1'>Test functions of x</h2><span id='topic+ZDT1'></span><span id='topic+ZDT2'></span><span id='topic+ZDT3'></span><span id='topic+ZDT4'></span><span id='topic+ZDT6'></span><span id='topic+P1'></span><span id='topic+P2'></span><span id='topic+MOP2'></span><span id='topic+MOP3'></span><span id='topic+DTLZ1'></span><span id='topic+DTLZ2'></span><span id='topic+DTLZ3'></span><span id='topic+DTLZ7'></span><span id='topic+OKA1'></span>

<h3>Description</h3>

<p>Multi-objective test functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZDT1(x)

ZDT2(x)

ZDT3(x)

ZDT4(x)

ZDT6(x)

P1(x)

P2(x)

MOP2(x)

MOP3(x)

DTLZ1(x, nobj = 3)

DTLZ2(x, nobj = 3)

DTLZ3(x, nobj = 3)

DTLZ7(x, nobj = 3)

OKA1(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZDT1_+3A_x">x</code></td>
<td>
<p>matrix specifying the location where the function is to be evaluated, one point per row,</p>
</td></tr>
<tr><td><code id="ZDT1_+3A_nobj">nobj</code></td>
<td>
<p>optional argument to select the number of objective for the DTLZ test functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are coming from different benchmarks:
the <code>ZDT</code> test problems from an article of E. Zitzler et al., <code>P1</code> from the thesis of J. Parr and <code>P2</code>
from an article of Poloni et al. . <code>MOP2</code> and <code>MOP3</code> are from Van Veldhuizen and <code>DTLZ</code> functions are from Deb et al. . <br /> <br />
</p>
<p>Domains (sometimes rescaled to <code>[0,1]</code>):
</p>

<ul>
<li> <p><code>ZDT1-6</code>: <code>[0,1]^d</code> 
</p>
</li>
<li> <p><code>P1</code>, <code>P2</code>: <code>[0,1]^2</code> 
</p>
</li>
<li> <p><code>MOP2</code>: <code>[0,1]^d</code>
</p>
</li>
<li> <p><code>MOP3</code>: <code>[-3,3]</code>, tri-objective, 2 variables
</p>
</li>
<li> <p><code>DTLZ1-3,7</code>: <code>[0,1]^d</code>, m-objective problems, with at least <code>d&gt;m</code> variables.
</p>
</li>
<li> <p><code>OKA1</code>: [0,1]^2, initially <code>[6 sin(pi/12), 6 sin(pi/12) + 2pi cos(pi/12)] x [-2pi sin(pi/12), 6 cos(pi/12)], bi-objective</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Matrix of values corresponding to the objective functions, the number of colums is the number of objectives.
</p>


<h3>References</h3>

<p>J. M. Parr (2012), <em>Improvement Criteria for Constraint Handling and Multiobjective Optimization</em>, University of Southampton, PhD thesis. 
</p>
<p>C. Poloni, A. Giurgevich, L. Onesti, V. Pediroda (2000), Hybridization of a multi-objective genetic algorithm, a neural network and a classical optimizer for a complex design problem in fluid dynamics, <em>Computer Methods in Applied Mechanics and Engineering</em>, 186(2), 403-420.
</p>
<p>E. Zitzler, K. Deb, and L. Thiele (2000), Comparison of multiobjective evolutionary
algorithms: Empirical results, <em>Evol. Comput.</em>, 8(2), 173-195.
</p>
<p>K. Deb, L. Thiele, M. Laumanns and E. Zitzler (2002), Scalable Test Problems for Evolutionary Multiobjective Optimization, 
<em>IEEE Transactions on Evolutionary Computation</em>, 6(2), 182-197.
</p>
<p>D. A. Van Veldhuizen, G. B. Lamont (1999), Multiobjective evolutionary algorithm test suites, <em>In Proceedings of the 1999 ACM symposium on Applied computing</em>, 351-357.
</p>
<p>T. Okabe, J. Yaochu, M. Olhofer, B. Sendhoff (2004), On test functions for evolutionary multi-objective optimization, 
<em>International Conference on Parallel Problem Solving from Nature</em>, Springer, Berlin, Heidelberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ----------------------------------
# 2-objectives test problems
# ---------------------------------- 

plotParetoGrid("ZDT1", n.grid = 21)

plotParetoGrid("ZDT2", n.grid = 21)

plotParetoGrid("ZDT3", n.grid = 21)

plotParetoGrid("ZDT4", n.grid = 21)

plotParetoGrid("ZDT6", n.grid = 21)

plotParetoGrid("P1", n.grid = 21)

plotParetoGrid("P2", n.grid = 21)

plotParetoGrid("MOP2", n.grid = 21)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
