<!DOCTYPE html><html><head><title>Help for package dualtrees</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dualtrees}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A'><p>Bias correction matrices</p></a></li>
<li><a href='#blossom'><p>Two meteorologists in front of cherry blossoms</p></a></li>
<li><a href='#boundaries'><p>Various boundary conditions for the 2D wavelet transform.</p></a></li>
<li><a href='#cen_xy'><p>xy &lt;-&gt; cen</p></a></li>
<li><a href='#cen2uv'><p>centre to vector</p></a></li>
<li><a href='#dt2cen'><p>centre of the DT-spectrum</p></a></li>
<li><a href='#dtmean'><p>spatial mean spectrum</p></a></li>
<li><a href='#dualtree-transform'><p>The 2D forward and inverse dualtree complex wavelet transform</p></a></li>
<li><a href='#filterbanks'><p>filterbanks for the dtcwt</p></a></li>
<li><a href='#fld2dt'><p>transform a field into an array of spectral energies</p></a></li>
<li><a href='#get_en'><p>get energy from the dualtree transform</p></a></li>
<li><a href='#smooth_borders'><p>smoother borders</p></a></li>
<li><a href='#uvplot'><p>plot centre as vectors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Decimated and Undecimated 2D Complex Dual-Tree Wavelet Transform</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Buschow &lt;s6sebusc@uni-bonn.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the decimated two-dimensional complex dual-tree wavelet transform as described in Kingsbury (1999) &lt;<a href="https://doi.org/10.1098%2Frsta.1999.0447">doi:10.1098/rsta.1999.0447</a>&gt; and Selesnick et al. (2005) &lt;<a href="https://doi.org/10.1109%2FMSP.2005.1550194">doi:10.1109/MSP.2005.1550194</a>&gt;. Also includes the undecimated version and spectral bias correction described in Nelson et al. (2018) &lt;<a href="https://doi.org/10.1007%2Fs11222-017-9784-0">doi:10.1007/s11222-017-9784-0</a>&gt;. The code is partly based on the 'dtcwt' Python library.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-04 09:43:31 UTC; s6sebusc</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Buschow <a href="https://orcid.org/0000-0003-4750-361X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Nick Kingsbury [ctb],
  Rich Wareham [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-04 15:10:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='A'>Bias correction matrices</h2><span id='topic+A'></span><span id='topic+A_b_bp'></span><span id='topic+A_b'></span>

<h3>Description</h3>

<p>Matrices needed in order to eliminate the effect of &quot;spectral leakage&quot; for the local dtcwt-spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A_b_bp

A_b
</code></pre>


<h3>Format</h3>

<p>A list with entries N1024, N512, N256, N128, N64, N32, each containing the bias correction matrix of appropriate size.</p>


<h3>Details</h3>

<p>As descibed in Nelson et al. (2018), the squared coefficients of the undecimated dtcwt (the local wavelet spectrum) can be used to obtain an estimate of local correlations in space. This estimator has a bias which mostly consists of an over-emphasis on the largest scales. It can be removed by multiplying each local spectrum with a matrix which depends only on the choice of wavelet and the dimensions of the field.
</p>


<h3>Source</h3>

<p>Calculated by brute force.
</p>


<h3>References</h3>

<p>Nelson, J. D. B., A. J. Gibberd, C. Nafornita, and N. Kingsbury (2018) &lt;doi:10.1007/s11222-017-9784-0&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image( A_b_bp$N512 )
</code></pre>

<hr>
<h2 id='blossom'>Two meteorologists in front of cherry blossoms</h2><span id='topic+blossom'></span>

<h3>Description</h3>

<p>A photograph of two meteorologists in front of the famous Japanese cherry trees in Bonn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blossom
</code></pre>


<h3>Format</h3>

<p>A 256x256 matrix of gray-scale values</p>


<h3>Source</h3>

<p>Armin Blanke, used with permission.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image(blossom, col=gray.colors(128,0,1))
</code></pre>

<hr>
<h2 id='boundaries'>Various boundary conditions for the 2D wavelet transform.</h2><span id='topic+boundaries'></span><span id='topic+pad'></span><span id='topic+put_in_mirror'></span><span id='topic+period_bc'></span>

<h3>Description</h3>

<p>Extend a matrix to the desired size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad(x, N, Ny = N, value = min(x, na.rm = TRUE))

put_in_mirror(x, N, Ny = N)

period_bc(x, N, Ny = N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundaries_+3A_x">x</code></td>
<td>
<p>a real matrix</p>
</td></tr>
<tr><td><code id="boundaries_+3A_n">N</code></td>
<td>
<p>the number of rows of the desired output</p>
</td></tr>
<tr><td><code id="boundaries_+3A_ny">Ny</code></td>
<td>
<p>the number of columns of the desired output, defaults to N</p>
</td></tr>
<tr><td><code id="boundaries_+3A_value">value</code></td>
<td>
<p>the value with which the picture is padded by <code>pad</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pad</code> pads the fields with a constant value on all sides, be careful what you pick here. <code>put_in_mirror</code> reflects the input at all edges (with repeated end samples), <code>period_bc</code> simply repeats the input periodically. In any case, you can retrieve the initial area via <code>bc$res[ bc$px, bc$py ]</code>.
</p>


<h3>Value</h3>

<p>a list containing the extended matrix (<code>$res</code>) and the positions of the original matrix within the extended one (<code>$px</code> and <code>$py</code>).
</p>


<h3>Note</h3>

<p>N and Ny must be at least as big as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bc &lt;- put_in_mirror( blossom, N=300 )
plot( bc )
print( range( bc$res[ bc$px, bc$py ] - blossom ) )
</code></pre>

<hr>
<h2 id='cen_xy'>xy &lt;-&gt; cen</h2><span id='topic+cen_xy'></span><span id='topic+cen2xy'></span><span id='topic+xy2cen'></span>

<h3>Description</h3>

<p>Translate the centre of mass back and forth between polar and cartesian coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cen2xy(cen)

xy2cen(xy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cen_xy_+3A_cen">cen</code></td>
<td>
<p>the centre of mass of a wavelet spectrum (rho, phi, z), output of <code>dt2cen</code></p>
</td></tr>
<tr><td><code id="cen_xy_+3A_xy">xy</code></td>
<td>
<p>the centre of mass in cartesian coordinates (x, y, z), output of cen2xy</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions allow you to translate back and forth between the two coordinate systems. <code>dt2cen</code> represents the sepctrum's centre in cylinder coordinates because that is more intuitive than the x-y-z position within the hexagonal geometry. If you want to compare two spectra, it makes more sense to consider their distance in terms of x1-x2, y1-y2 since the difference in angle is only meaningful for reasonably large radii.
</p>


<h3>Note</h3>

<p><code>cen2xy</code> is not the same thing as <code>cen2uv</code> !
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dt2cen">dt2cen</a></code>, <code><a href="#topic+cen2uv">cen2uv</a></code>
</p>

<hr>
<h2 id='cen2uv'>centre to vector</h2><span id='topic+cen2uv'></span>

<h3>Description</h3>

<p>transforms the angle and radius component of the spectral centre into vector components for visualization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cen2uv(cen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cen2uv_+3A_cen">cen</code></td>
<td>
<p>an <code>nx x ny x 3</code> array, the output of <code>dt2cen</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting vector field represents the degree of anisotropy and the dominant direction, averaged over all scales.
</p>


<h3>Value</h3>

<p>an <code>nx x ny x 2</code> array, the two matrices representing the u- and v-component of the vector field.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dt2cen">dt2cen</a></code>, <code><a href="#topic+uvplot">uvplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- fld2dt(blossom)
ce &lt;- dt2cen(dt)
uv &lt;- cen2uv(ce)
uvplot( uv, z=blossom )
</code></pre>

<hr>
<h2 id='dt2cen'>centre of the DT-spectrum</h2><span id='topic+dt2cen'></span>

<h3>Description</h3>

<p>calculate the centre of mass of the local spectra in hexagonal geometry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt2cen(dt, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt2cen_+3A_dt">dt</code></td>
<td>
<p>a <code>J x nx x ny x 6</code> array of spectral energies, the output of <code>fld2dt</code></p>
</td></tr>
<tr><td><code id="dt2cen_+3A_mask">mask</code></td>
<td>
<p>a <code> nx x ny </code> array of logical values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of the <code>J x 6</code> spectral values is assigned a coordinate in 3D space with <code>x(d,j)=cos(60*(d-1))</code>, <code>y(d,j)=sin(60*(d-1))</code>, <code>z(d,j)=j</code>, where <code>j</code> denotes the scale and <code>d</code> the direction. Then the centre of mass in this space is calculated, the spectral values being the masses at each vertex. The x- and y-cooridnate are then transformed into a radius <code>rho=sqrt(x^2+y^2)</code> and an angle <code>phi=15+0.5*atan2(y,x)</code>. <code>rho</code> measures the degree of anisotropy at each pixel, <code>phi</code> the orientation of edges in the image, and the third coordinate, <code>z</code>, the central scale. If a <code>mask</code> is provided, values where <code>mask==TRUE</code> are set to <code>NA</code>.
</p>


<h3>Value</h3>

<p>a <code>nx x ny x 3</code> array where the third dimension denotes degree of anisotropy, angle and central scale, respectively.
</p>


<h3>Note</h3>

<p>Since the centre of mass is not defined for negative mass, any values below zero are removed at this point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- fld2dt(blossom)
ce &lt;- dt2cen(dt)
image( ce[,,3], col=gray.colors(32, 0, 1) )
</code></pre>

<hr>
<h2 id='dtmean'>spatial mean spectrum</h2><span id='topic+dtmean'></span>

<h3>Description</h3>

<p>average the output of fld2dt or dtcwt over space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtmean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtmean_+3A_x">x</code></td>
<td>
<p>either a J x nx x ny x 6 array of energies (output of dtcwt) or a list of complex wavelet coefficients (the output of <code>dtcwt(...,dec=FALSE)</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a J x 6 matrix of spatially averaged energies
</p>


<h3>Note</h3>

<p>In the undecimated case, the coefficients are not averaged but summed up and then scaled by the area of the first level. This yields a comparable scale as the undecimated case.
</p>

<hr>
<h2 id='dualtree-transform'>The 2D forward and inverse dualtree complex wavelet transform</h2><span id='topic+dualtree-transform'></span><span id='topic+dtcwt'></span><span id='topic+idtcwt'></span>

<h3>Description</h3>

<p>These functions perform the dualtree complex wavelet analysis and synthesis, either with or without decimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtcwt(fld, fb1 = near_sym_b, fb2 = qshift_b, J = NULL, dec = TRUE,
  verbose = FALSE)

idtcwt(pyr, fb1 = near_sym_b, fb2 = qshift_b, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dualtree-transform_+3A_fld">fld</code></td>
<td>
<p>real matrix representing the field to be transformed</p>
</td></tr>
<tr><td><code id="dualtree-transform_+3A_fb1">fb1</code></td>
<td>
<p>A list of filter coefficients for the first level. Currently only <code>near_sym_b</code> and <code>near_sym_b_bp</code> are implemented</p>
</td></tr>
<tr><td><code id="dualtree-transform_+3A_fb2">fb2</code></td>
<td>
<p>A list of filter coefficients for all following levels. Currently only <code>qshift_b</code> and <code>qshift_b_bp</code> are implemented</p>
</td></tr>
<tr><td><code id="dualtree-transform_+3A_j">J</code></td>
<td>
<p>number of levels for the decomposition. Defaults to <code>log2( min(Nx,Ny) )</code> in the decimated case and <code>log2( min(Nx,Ny) ) - 3</code> otherwise</p>
</td></tr>
<tr><td><code id="dualtree-transform_+3A_dec">dec</code></td>
<td>
<p>whether or not the decimated transform is desired</p>
</td></tr>
<tr><td><code id="dualtree-transform_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, the function tells you which level it is working on</p>
</td></tr>
<tr><td><code id="dualtree-transform_+3A_pyr">pyr</code></td>
<td>
<p>a list containing arrays of complex coefficients for each level of the decomposition, produced by <code>dtcwt( ..., dec=TRUE )</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the 2D complex dualtree wavelet transform as described by Selesnick et al. (2005). It consists of four discerete wavelet transform trees, generated from two filter banks a and b by applying one set of filters to the rows and another (or the same) one to the columns. The 12 resulting coefficients are combined into six complex values representing six directions (15°, 45°, 75°, 105°, 135°, 165°). 
In the decimated case (dec=TRUE), each convolution is followed by a downsampling by two, meaining that the size of the six coefficient fields is cut in half at each level. The decimated transform can be reversed to recover the original image. For the <code>near_sym_b</code> and <code>qshift_b</code> filter banks, this reconstrcution should be basically perfect. In the case of the the <code>b_bp</code> filters, non-negligible artifacts appear near +-45° edges.
</p>


<h3>Value</h3>

<p>if dec=TRUE a list of complex coefficient fields, otherwise a complex <code>J x Nx x Ny x 6</code> array.
</p>


<h3>Note</h3>

<p>At present, the inverse transform only works if the input image had dimensions <code>2^N x 2^N</code>. You can use <code><a href="#topic+boundaries">boundaries</a></code> to achieve that.
</p>


<h3>Author(s)</h3>

<p>Nick Kingsbury (canonical MATLAB implementation), Rich Wareham (open source Python implementation, <a href="https://github.com/rjw57/dtcwt">https://github.com/rjw57/dtcwt</a>), Sebastian Buschow (R port).
</p>


<h3>References</h3>

<p>Kingsbury, Nick (1999) &lt;doi:10.1098/rsta.1999.0447&gt;.
Selesnick, I.W., R.G. Baraniuk, and N.C. Kingsbury (2005) &lt;doi:10.1109/MSP.2005.1550194&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterbanks">filterbanks</a></code>, <code><a href="#topic+fld2dt">fld2dt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par( no.readonly=TRUE )
# forward transform
dt &lt;- dtcwt( blossom )
par( mfrow=c(2,3), mar=rep(2,4) )
for( j in 1:6 ){
    image( blossom, col=grey.colors(32,0,1) )
    contour( Mod( dt[[3]][ ,,j ] )**2, add=TRUE, col="green" )
} 
par( oldpar ) 

# exmaple for the inverse transform
blossom_i &lt;- idtcwt( dt )
image( blossom - blossom_i )

# example for a non-square case
boy &lt;- blossom[50:120, 50:150]
bc  &lt;- put_in_mirror(boy, 128)
dt  &lt;- dtcwt(bc$res)
idt &lt;- idtcwt(dt)[ bc$px, bc$py ]
</code></pre>

<hr>
<h2 id='filterbanks'>filterbanks for the dtcwt</h2><span id='topic+filterbanks'></span><span id='topic+qshift_b'></span><span id='topic+qshift_b_bp'></span><span id='topic+near_sym_b'></span><span id='topic+near_sym_b_bp'></span>

<h3>Description</h3>

<p>Some of the filters implemented in the python package dtcwt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qshift_b

qshift_b_bp

near_sym_b

near_sym_b_bp
</code></pre>


<h3>Format</h3>

<p>A list of high- and low-pass filters for analysis and synthesis</p>


<h3>Details</h3>

<p>The near-sym filterbanks are biorthogonal wavelets used for the first level, they have 13 and 19 taps. The qshift filterbanks, each with 14 taps, are suitable for all higher levels of the dtcwt. The a- and b-filters form an approximate Hilbert-pair. The naming convention follows the python-package: </p>

<table>
<tr>
 <td style="text-align: left;"> h: </td><td style="text-align: left;"> analysis</td>
</tr>
<tr>
 <td style="text-align: left;"> g:</td><td style="text-align: left;"> synthesis</td>
</tr>
<tr>
 <td style="text-align: left;"> 0:</td><td style="text-align: left;"> low-pass</td>
</tr>
<tr>
 <td style="text-align: left;"> 1:</td><td style="text-align: left;"> high-pass</td>
</tr>
<tr>
 <td style="text-align: left;"> a,b: </td><td style="text-align: left;"> shifted filters</td>
</tr>

</table>

<p>The <code>b_bp</code>-versions of the filterbanks contain a second high-pass for the diagonal directions, denoted by 2. They allow for better directional selectivity but prohibit perfect reconstruction.
</p>


<h3>Source</h3>

<p>'dtcwt' python package (<a href="https://github.com/rjw57/dtcwt">https://github.com/rjw57/dtcwt</a>)
</p>


<h3>References</h3>

<p>Selesnick, I.W., R.G. Baraniuk, and N.C. Kingsbury (2005) &lt;doi:10.1109/MSP.2005.1550194&gt;
</p>
<p>Kingsbury, N. (2006) &lt;https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7071567&amp;isnumber=7065146&gt;
</p>

<hr>
<h2 id='fld2dt'>transform a field into an array of spectral energies</h2><span id='topic+fld2dt'></span>

<h3>Description</h3>

<p>Handles the transformation itself, boundary conditions and bias correction and returns the unbiased local wavelet spectrum at each grid-point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fld2dt(fld, Nx = NULL, Ny = NULL, J = NULL, correct = TRUE,
  rsm = 0, verbose = FALSE, boundaries = "pad",
  fb1 = near_sym_b_bp, fb2 = qshift_b_bp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fld2dt_+3A_fld">fld</code></td>
<td>
<p>a real matrix</p>
</td></tr>
<tr><td><code id="fld2dt_+3A_nx">Nx</code></td>
<td>
<p>size to which the field is padded in x-direction</p>
</td></tr>
<tr><td><code id="fld2dt_+3A_ny">Ny</code></td>
<td>
<p>size to which the field is padded in y-direction</p>
</td></tr>
<tr><td><code id="fld2dt_+3A_j">J</code></td>
<td>
<p>number of levels for the decomposition</p>
</td></tr>
<tr><td><code id="fld2dt_+3A_correct">correct</code></td>
<td>
<p>logical, whether or not to apply the bias correction</p>
</td></tr>
<tr><td><code id="fld2dt_+3A_rsm">rsm</code></td>
<td>
<p>number of pixels to be linearly smoothed along each edge before applying the boundary conditions (see <code><a href="#topic+smooth_borders">smooth_borders</a></code>).</p>
</td></tr>
<tr><td><code id="fld2dt_+3A_verbose">verbose</code></td>
<td>
<p>whether or not you want the transform to talk to you</p>
</td></tr>
<tr><td><code id="fld2dt_+3A_boundaries">boundaries</code></td>
<td>
<p>how to handle the boundary conditions, either &quot;pad&quot;, &quot;mirror&quot; or &quot;periodic&quot;</p>
</td></tr>
<tr><td><code id="fld2dt_+3A_fb1">fb1</code></td>
<td>
<p>filter bank for level 1</p>
</td></tr>
<tr><td><code id="fld2dt_+3A_fb2">fb2</code></td>
<td>
<p>filter bank for all further levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input is blown up to <code>Nx x Ny</code> and transformed by <code>dtcwt(..., dec=FALSE)</code>. Then the original domain is cut out, the coefficients are squared and the bias is corrected (for details on the bias, see <code><a href="#topic+A">A</a></code>).
</p>


<h3>Value</h3>

<p>an array of size <code>J x nx x ny x 6</code> where <code>dim(fld)=c(nx,ny)</code>
</p>


<h3>References</h3>

<p>Nelson, J. D. B., A. J. Gibberd, C. Nafornita, and N. Kingsbury (2018) &lt;doi:10.1007/s11222-017-9784-0&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+A">A</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par( no.readonly=TRUE )
dt &lt;- fld2dt( blossom )
par( mfrow=c(2,2), mar=rep(2,4) )
for( j in 1:4 ){
    image( blossom, col=gray.colors(128, 0,1), xaxt="n", yaxt="n" )
    for(d in  1:6) contour( dt[j,,,d], levels=quantile(dt[,,,], .995), 
                            col=d+1, add=TRUE, lwd=2, drawlabels=FALSE )
    title( main=paste0("j=",j) )
} 
x0  &lt;- seq( .1,.5,,6 )
y0  &lt;- rep( 0.01,6 )
a   &lt;- .075
phi &lt;- seq( 15,,30,6 )*pi/180
x1  &lt;- x0 + a*cos( phi )
y1  &lt;- y0 + a*sin( phi )
rect( min(x0,x1)-.05, min(y0,y1)-.05, 
      max(x0,x1)+.05, max(y0,y1), col="black", border=NA )
arrows( x0, y0, x1, y1, length=.05, col=2:7, lwd=2, code=3 )
par( oldpar )
</code></pre>

<hr>
<h2 id='get_en'>get energy from the dualtree transform</h2><span id='topic+get_en'></span>

<h3>Description</h3>

<p>square the wavelet coefficients and apply the bias correction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_en(dt, correct = "none", N = ncol(dt))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_en_+3A_dt">dt</code></td>
<td>
<p>array of <code> J x nx x ny x 6 </code> complex wavelet coefficients, output of <code>dtcwt(..., dec=FALSE)</code></p>
</td></tr>
<tr><td><code id="get_en_+3A_correct">correct</code></td>
<td>
<p>type of correction, either <code>"b"</code> or <code>"b_bp"</code>, any other value results in no correction at all.</p>
</td></tr>
<tr><td><code id="get_en_+3A_n">N</code></td>
<td>
<p>the smallest whole power of two larger than or equal to the dimensions of the input image, usually just <code>ncol(dt)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bias correction matrix should correspond to the filter bank used in the transform, for details on the matrices see <code><a href="#topic+A">A</a></code>.
</p>


<h3>Value</h3>

<p>an array of the same dimensions as <code>dt</code>
</p>


<h3>References</h3>

<p>Nelson, J. D. B., A. J. Gibberd, C. Nafornita, and N. Kingsbury (2018) &lt;doi:10.1007/s11222-017-9784-0&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+A">A</a></code>
</p>

<hr>
<h2 id='smooth_borders'>smoother borders</h2><span id='topic+smooth_borders'></span>

<h3>Description</h3>

<p>let a field decrease linearly towards its edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_borders(x, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_borders_+3A_x">x</code></td>
<td>
<p>a real matrix</p>
</td></tr>
<tr><td><code id="smooth_borders_+3A_r">r</code></td>
<td>
<p>a positive integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values within the field are linearly reduced from their original value to the field minimum, starting <code>r</code> pixels away from the edge. This enforces truely periodic boundaries and removes sharp edges.
</p>


<h3>Value</h3>

<p>a matrix of the same dimensions as x
</p>


<h3>Note</h3>

<p>r must not be larger than <code>min( dim(x) )/2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image( smooth_borders(blossom, r=64), col=gray.colors(128,0,1) )
</code></pre>

<hr>
<h2 id='uvplot'>plot centre as vectors</h2><span id='topic+uvplot'></span>

<h3>Description</h3>

<p>display the radial and angular component of the spectrum's centre as arrows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uvplot(uv, z = NULL, x = NULL, y = NULL, col = "green",
  zcol = grDevices::gray.colors(32, 0, 1), n = 42, f = 1,
  length = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uvplot_+3A_uv">uv</code></td>
<td>
<p>an array of dimension <code> nx x ny x 2 </code>, containing the u- and v-component, result of <code>cen2uv</code></p>
</td></tr>
<tr><td><code id="uvplot_+3A_z">z</code></td>
<td>
<p>image to show in the background, defaults to <code>sqrt(x^2+y^2)</code></p>
</td></tr>
<tr><td><code id="uvplot_+3A_x">x</code>, <code id="uvplot_+3A_y">y</code></td>
<td>
<p>optional x- and y-coordinates for the plot, must match the dimensions of <code>z</code></p>
</td></tr>
<tr><td><code id="uvplot_+3A_col">col</code></td>
<td>
<p>color of the arrows</p>
</td></tr>
<tr><td><code id="uvplot_+3A_zcol">zcol</code></td>
<td>
<p>color scale for the image</p>
</td></tr>
<tr><td><code id="uvplot_+3A_n">n</code></td>
<td>
<p>number of arrows in one direction</p>
</td></tr>
<tr><td><code id="uvplot_+3A_f">f</code></td>
<td>
<p>factor by which to enlarge the arrows</p>
</td></tr>
<tr><td><code id="uvplot_+3A_length">length</code></td>
<td>
<p>length of the arrowhead in inches</p>
</td></tr>
<tr><td><code id="uvplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>image</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pivot of the arrows is at the location to which the u- and v-component belong. No arrowhead is displayed since the egdges detcted by the cdtwt have an orientation but no sign. The default size of the arrows is such that a 'velocity' of 1 corresponds to 5% of the shorter image side.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cen2uv">cen2uv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uv &lt;- cen2uv( dt2cen( fld2dt( blossom ) ) )
uvplot( uv, z=blossom )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
