<!DOCTYPE html><html lang="en-GB"><head><title>Help for package metR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#metR'><p>metR: Tools for Easier Analysis of Meteorological Fields</p></a></li>
<li><a href='#Anomaly'><p>Anomalies</p></a></li>
<li><a href='#as.discretised_scale'><p>Create discretised versions of continuous scales</p></a></li>
<li><a href='#as.path'><p>Interpolates between locations</p></a></li>
<li><a href='#ConvertLongitude'><p>Converts between longitude conventions</p></a></li>
<li><a href='#coriolis'><p>Effects of the Earth's rotation</p></a></li>
<li><a href='#cut.eof'><p>Remove some principal components.</p></a></li>
<li><a href='#denormalise'><p>Denormalise eof matrices</p></a></li>
<li><a href='#Derivate'><p>Derivate a discrete variable using finite differences</p></a></li>
<li><a href='#EOF'><p>Empirical Orthogonal Function</p></a></li>
<li><a href='#EPflux'><p>Computes Eliassen-Palm fluxes.</p></a></li>
<li><a href='#FitLm'><p>Fast estimates of linear regression</p></a></li>
<li><a href='#geom_arrow'><p>Arrows</p></a></li>
<li><a href='#geom_contour_fill'><p>Filled 2d contours of a 3d surface</p></a></li>
<li><a href='#geom_contour_tanaka'><p>Illuminated contours</p></a></li>
<li><a href='#geom_contour2'><p>2d contours of a 3d surface</p></a></li>
<li><a href='#geom_label_contour'><p>Label contours</p></a></li>
<li><a href='#geom_relief'><p>Relief Shading</p></a></li>
<li><a href='#geom_streamline'><p>Streamlines</p></a></li>
<li><a href='#geopotential'><p>Geopotential height</p></a></li>
<li><a href='#GeostrophicWind'><p>Calculate geostrophic winds</p></a></li>
<li><a href='#GetSMNData'><p>Get Meteorological data</p>
This function is defunct.</a></li>
<li><a href='#GetTopography'><p>Get topographic data</p></a></li>
<li><a href='#guide_colourstrip'><p>Discretized continuous colour guide</p></a></li>
<li><a href='#Impute2D'><p>Impute missing values by linear or constant interpolation</p></a></li>
<li><a href='#ImputeEOF'><p>Impute missing values</p></a></li>
<li><a href='#Interpolate'><p>Bilinear interpolation</p></a></li>
<li><a href='#is.cross'><p>Cross pattern</p></a></li>
<li><a href='#JumpBy'><p>Skip observations</p></a></li>
<li><a href='#label_placers'><p>Functions to place contour labels</p></a></li>
<li><a href='#logic'><p>Extended logical operators</p></a></li>
<li><a href='#Mag'><p>Magnitude and angle of a vector</p></a></li>
<li><a href='#MakeBreaks'><p>Functions for making breaks</p></a></li>
<li><a href='#map_labels'><p>Label longitude and latitude</p></a></li>
<li><a href='#MaskLand'><p>Mask</p></a></li>
<li><a href='#Percentile'><p>Percentiles</p></a></li>
<li><a href='#ReadNetCDF'><p>Read NetCDF files.</p></a></li>
<li><a href='#reverselog_trans'><p>Reverse log transform</p></a></li>
<li><a href='#scale_divergent'><p>Divergent colour scales</p></a></li>
<li><a href='#scale_label_colour_continuous'><p>Scales for contour label aesthetics</p></a></li>
<li><a href='#scale_longitude'><p>Helpful scales for maps</p></a></li>
<li><a href='#scale_mag'><p>Scale for vector magnitudes</p></a></li>
<li><a href='#scale_stroke.colour_continuous'><p>Scale for stroke.colour</p></a></li>
<li><a href='#season'><p>Assign seasons to months</p></a></li>
<li><a href='#Smooth2D'><p>Smooths a 2D field</p></a></li>
<li><a href='#spherical'><p>Transform between spherical coordinates and physical coordinates</p></a></li>
<li><a href='#standard_atmosphere'><p>Standard atmosphere</p></a></li>
<li><a href='#stat_na'><p>Filter only NA values.</p></a></li>
<li><a href='#stat_subset'><p>Subset values</p></a></li>
<li><a href='#surface'><p>Surface height</p></a></li>
<li><a href='#temperature'><p>Air temperature</p></a></li>
<li><a href='#thermodynamics'><p>Thermodynamics</p></a></li>
<li><a href='#Trajectory'><p>Compute trajectories</p></a></li>
<li><a href='#WaveFlux'><p>Calculate wave-activity flux</p></a></li>
<li><a href='#waves'><p>Fourier transform functions</p></a></li>
<li><a href='#WrapCircular'><p>Wrap periodic data to any range</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Easier Analysis of Meteorological Fields</td>
</tr>
<tr>
<td>Version:</td>
<td>0.18.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Many useful functions and extensions for dealing
    with meteorological data in the tidy data framework. Extends 'ggplot2'
    for better plotting of scalar and vector fields and provides commonly
    used analysis methods in the atmospheric sciences.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://eliocamp.github.io/metR/">https://eliocamp.github.io/metR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eliocamp/metR/issues">https://github.com/eliocamp/metR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, data.table, digest, Formula, formula.tools, ggplot2
(&ge; 3.5.0), grid, gtable, memoise, plyr, scales, sf, stringr,
purrr, isoband, lubridate</td>
</tr>
<tr>
<td>Suggests:</td>
<td>maps, covr, irlba, knitr, ncdf4, pkgdown, reshape2, markdown,
testthat (&ge; 2.1.0), viridis, PCICt, gridExtra, vdiffr, proj4,
kriging, terra, here, gsignal, rnaturalearth</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-24 06:16:41 UTC; user1</td>
</tr>
<tr>
<td>Author:</td>
<td>Elio Campitelli <a href="https://orcid.org/0000-0002-7742-9230"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elio Campitelli &lt;eliocampitelli@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-24 08:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='metR'>metR: Tools for Easier Analysis of Meteorological Fields</h2><span id='topic+metR-package'></span><span id='topic+metR'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Many useful functions and extensions for dealing with meteorological data in the tidy data framework. Extends 'ggplot2' for better plotting of scalar and vector fields and provides commonly used analysis methods in the atmospheric sciences.
</p>


<h3>Overview</h3>

<p>Conceptually it's divided into <em>visualization tools</em> and <em>data tools</em>.
The former are geoms, stats and scales that help with plotting using
'ggplot2', such as <a href="#topic+stat_contour_fill">stat_contour_fill</a> or <a href="#topic+scale_y_level">scale_y_level</a>, while the
later are functions for common data processing tools in the atmospheric
sciences, such as <a href="#topic+Derivate">Derivate</a> or <a href="#topic+EOF">EOF</a>; these are implemented to work in the
'data.table' paradigm, but also work with regular data frames.
</p>
<p>To get started, check the vignettes:
</p>

<ul>
<li><p> Visualization Tools: <code>vignette("Visualization-tools", package = "metR")</code>
</p>
</li>
<li><p> Working with Data: <code>vignette("Working-with-data", package = "metR")    </code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Elio Campitelli <a href="mailto:eliocampitelli@gmail.com">eliocampitelli@gmail.com</a> (<a href="https://orcid.org/0000-0002-7742-9230">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://eliocamp.github.io/metR/">https://eliocamp.github.io/metR/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/eliocamp/metR/issues">https://github.com/eliocamp/metR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Anomaly'>Anomalies</h2><span id='topic+Anomaly'></span>

<h3>Description</h3>

<p>Saves keystrokes for computing anomalies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Anomaly(x, baseline = seq_along(x), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Anomaly_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="Anomaly_+3A_baseline">baseline</code></td>
<td>
<p>logical or numerical vector used for subsetting x before
computing the mean</p>
</td></tr>
<tr><td><code id="Anomaly_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="base.html#topic+mean">mean</a></code> such as <code>na.rm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as x with each value's distance to the
mean.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+JumpBy">JumpBy</a>()</code>,
<code><a href="#topic+Mag">Mag</a>()</code>,
<code><a href="#topic+Percentile">Percentile</a>()</code>,
<code><a href="#topic+logic">logic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Zonal temperature anomaly
library(data.table)
temperature[, .(lon = lon, air.z = Anomaly(air)), by = .(lat, lev)]

</code></pre>

<hr>
<h2 id='as.discretised_scale'>Create discretised versions of continuous scales</h2><span id='topic+as.discretised_scale'></span><span id='topic+scale_fill_discretised'></span><span id='topic+scale_fill_divergent_discretised'></span><span id='topic+discretised_scale'></span><span id='topic+ScaleDiscretised'></span>

<h3>Description</h3>

<p>This scale allows ggplot to understand data that has been discretised with
some procedure akin to <code>cut</code> and access the underlying continuous values.
For a scale that does the opposite (take continuous data and treat them as
discrete) see <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.discretised_scale(scale_function)

scale_fill_discretised(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = ggplot2::guide_colorsteps(even.steps = FALSE, show.limits = TRUE),
  aesthetics = "fill"
)

scale_fill_divergent_discretised(
  ...,
  low = scales::muted("blue"),
  mid = "white",
  high = scales::muted("red"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  guide = ggplot2::guide_colorsteps(even.steps = FALSE, show.limits = TRUE)
)

discretised_scale(
  aesthetics,
  scale_name,
  palette,
  name = ggplot2::waiver(),
  breaks = ggplot2::waiver(),
  labels = ggplot2::waiver(),
  limits = NULL,
  trans = scales::identity_trans(),
  na.value = NA,
  drop = FALSE,
  guide = ggplot2::guide_colorsteps(even.steps = FALSE),
  position = "left",
  rescaler = scales::rescale,
  oob = scales::censor,
  super = ScaleDiscretised
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.discretised_scale_+3A_scale_function">scale_function</code></td>
<td>
<p>a scale function (e.g. <code>scale_fill_divergent</code>)</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+continuous_scale">continuous_scale</a></code>
</p>

<dl>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a numeric vector with
values between 0 and 1 returns the corresponding output values
(e.g., <code><a href="scales.html#topic+pal_area">scales::pal_area()</a></code>).</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Note that for position scales, limits are provided after scale expansion.
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</dd>
<dt><code>rescaler</code></dt><dd><p>A function used to scale the input values to the
range [0, 1]. This is always <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>, except for
diverging and n colour gradients (i.e., <code><a href="ggplot2.html#topic+scale_colour_gradient2">scale_colour_gradient2()</a></code>,
<code><a href="ggplot2.html#topic+scale_colour_gradientn">scale_colour_gradientn()</a></code>). The <code>rescaler</code> is ignored by position
scales, which always use <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>. Also accepts rlang
<a href="rlang.html#topic+as_function">lambda</a> function notation.</p>
</dd>
<dt><code>oob</code></dt><dd><p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</dd>
<dt><code>trans</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_low">low</code>, <code id="as.discretised_scale_+3A_high">high</code></td>
<td>
<p>Colours for low and high ends of the gradient.</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_space">space</code></td>
<td>
<p>colour space in which to calculate gradient. Must be &quot;Lab&quot; -
other values are deprecated.</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_guide">guide</code></td>
<td>
<p>Type of legend. Use <code>"colourbar"</code> for continuous
colour bar, or <code>"legend"</code> for discrete colour legend.</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful, for
example, to apply colour settings to the <code>colour</code> and <code>fill</code> aesthetics at the
same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_mid">mid</code></td>
<td>
<p>colour for mid point</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_midpoint">midpoint</code></td>
<td>
<p>The midpoint (in data value) of the diverging scale.
Defaults to 0.</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_scale_name">scale_name</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_palette">palette</code></td>
<td>
<p>A palette function that when called with a numeric vector with
values between 0 and 1 returns the corresponding output values
(e.g., <code><a href="scales.html#topic+pal_area">scales::pal_area()</a></code>).</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Note that for position scales, limits are provided after scale expansion.
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_trans">trans</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The default, TRUE, uses the
levels that appear in the data; FALSE uses all the levels in the factor.</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_position">position</code></td>
<td>
<p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_rescaler">rescaler</code></td>
<td>
<p>A function used to scale the input values to the
range [0, 1]. This is always <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>, except for
diverging and n colour gradients (i.e., <code><a href="ggplot2.html#topic+scale_colour_gradient2">scale_colour_gradient2()</a></code>,
<code><a href="ggplot2.html#topic+scale_colour_gradientn">scale_colour_gradientn()</a></code>). The <code>rescaler</code> is ignored by position
scales, which always use <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>. Also accepts rlang
<a href="rlang.html#topic+as_function">lambda</a> function notation.</p>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_oob">oob</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="as.discretised_scale_+3A_super">super</code></td>
<td>
<p>The super class to use for the constructed scale</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This scale makes it very easy to synchronise the breaks of filled contours
and the breaks shown no the colour guide. Bear in mind that when using
<code><a href="#topic+geom_contour_fill">geom_contour_fill()</a></code>, the default fill aesthetic (<code>level_mid</code>) is <strong>not</strong>
discretised. To use this scale with that geom, you need to set
<code>aes(fill = after_stat(level))</code>.
</p>


<h3>Value</h3>

<p>A function with the same arguments as <code>scale_function</code> that works with discretised
values.
</p>


<h3>See Also</h3>

<p>scale_fill_discretised
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
scale_fill_brewer_discretised &lt;- as.discretised_scale(scale_fill_distiller)



library(ggplot2)

# Using the `level` compute aesthetic from `geom_contour_fill()`
# (or ggplot2::geom_contour_filled()), the default scale is discrete.
# This means that you cannot map colours to the underlying numbers.
v &lt;- ggplot(faithfuld, aes(waiting, eruptions, z = density))
v + geom_contour_fill(aes(fill = after_stat(level)))

v + geom_contour_fill(aes(fill = after_stat(level))) +
  scale_fill_discretised()

# The scale can be customised the same as any continuous colour scale
v + geom_contour_fill(aes(fill = after_stat(level))) +
  scale_fill_discretised(low = "#a62100", high = "#fff394")

# Setting limits explicitly will truncate the scale
# (if any limit is inside the range of the breaks but doesn't
# coincide with any range, it will be rounded with a warning)
v + geom_contour_fill(aes(fill = after_stat(level))) +
  scale_fill_discretised(low = "#a62100", high = "#fff394",
                         limits = c(0.01, 0.028))

# Or extend it.
v + geom_contour_fill(aes(fill = after_stat(level))) +
  scale_fill_discretised(low = "#a62100", high = "#fff394",
                         limits = c(0, 0.07))

v + geom_contour_fill(aes(fill = after_stat(level))) +
  scale_fill_divergent_discretised(midpoint = 0.02)

# Existing continous scales can be "retrofitted" by changing the `super`
# and `guide` arguments.
v + geom_contour_fill(aes(fill = after_stat(level))) +
    scale_fill_distiller(super = ScaleDiscretised)

# Unequal breaks will, by default, map to unequal spacing in the guide
v + geom_contour_fill(aes(fill = after_stat(level)), breaks = c(0, 0.005, 0.01, 0.02, 0.04)) +
  scale_fill_discretised()

# You can change that by the `even.steps` argument on ggplot2::guide_colorsteps()
v + geom_contour_fill(aes(fill = after_stat(level)), breaks = c(0, 0.005, 0.01, 0.02, 0.04)) +
  scale_fill_discretised(guide = guide_colorsteps(even.steps = TRUE, show.limits = TRUE))


</code></pre>

<hr>
<h2 id='as.path'>Interpolates between locations</h2><span id='topic+as.path'></span>

<h3>Description</h3>

<p>This is a helper function to quickly make an interpolated list of locations
between a number of locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.path(x, y, n = 10, path = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.path_+3A_x">x</code>, <code id="as.path_+3A_y">y</code></td>
<td>
<p>numeric vectors of x and y locations. If one of them is of length 1,
if will be recycled.</p>
</td></tr>
<tr><td><code id="as.path_+3A_n">n</code></td>
<td>
<p>number of points to interpolate to</p>
</td></tr>
<tr><td><code id="as.path_+3A_path">path</code></td>
<td>
<p>either <code>TRUE</code> of a character vector with the name of the path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mostly useful when combined with <a href="#topic+Interpolate">Interpolate</a>
</p>


<h3>Value</h3>

<p>A list of components <code>x</code> and <code>y</code> with the list of locations and the <code>path</code>
arguments
</p>


<h3>See Also</h3>

<p>Interpolate
</p>

<hr>
<h2 id='ConvertLongitude'>Converts between longitude conventions</h2><span id='topic+ConvertLongitude'></span>

<h3>Description</h3>

<p>Converts longitude from [0, 360) to [-180, 180) and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvertLongitude(lon, group = NULL, from = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConvertLongitude_+3A_lon">lon</code></td>
<td>
<p>numeric vector of longitude</p>
</td></tr>
<tr><td><code id="ConvertLongitude_+3A_group">group</code></td>
<td>
<p>optional vector of groups (the same length as longitude)
that will be split on the edges (see examples)</p>
</td></tr>
<tr><td><code id="ConvertLongitude_+3A_from">from</code></td>
<td>
<p>optionally explicitly say from which convention to convert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>group</code> is missing, a numeric vector the same length of lon.
Else, a list with vectors <code>lon</code> and <code>group</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(data.table)

data(geopotential)

ggplot(geopotential[date == date[1]], aes(lon, lat, z = gh)) +
    geom_contour(color = "black") +
    geom_contour(aes(x = ConvertLongitude(lon)))

map &lt;- setDT(map_data("world"))
map[, c("lon", "group2") := ConvertLongitude(long, group, from = 180)]

ggplot(map, aes(lon, lat, group = group2)) +
    geom_path()

</code></pre>

<hr>
<h2 id='coriolis'>Effects of the Earth's rotation</h2><span id='topic+coriolis'></span><span id='topic+f'></span><span id='topic+coriolis.dy'></span><span id='topic+f.dy'></span>

<h3>Description</h3>

<p>Coriolis and beta parameters by latitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coriolis(lat)

f(lat)

coriolis.dy(lat, a = 6371000)

f.dy(lat, a = 6371000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coriolis_+3A_lat">lat</code></td>
<td>
<p>latitude in degrees</p>
</td></tr>
<tr><td><code id="coriolis_+3A_a">a</code></td>
<td>
<p>radius of the earth</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions use the correct sidereal day (24hs 56mins 4.091s) instead of
the incorrect solar day (24hs) for 0.3\
pedantry.
</p>

<hr>
<h2 id='cut.eof'>Remove some principal components.</h2><span id='topic+cut.eof'></span>

<h3>Description</h3>

<p>Returns an <code>eof</code> object with just the n principal components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eof'
cut(x, n, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cut.eof_+3A_x">x</code></td>
<td>
<p>an <code>eof</code> object</p>
</td></tr>
<tr><td><code id="cut.eof_+3A_n">n</code></td>
<td>
<p>which eofs to keep</p>
</td></tr>
<tr><td><code id="cut.eof_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='denormalise'>Denormalise eof matrices</h2><span id='topic+denormalise'></span><span id='topic+denormalize'></span>

<h3>Description</h3>

<p>The matrices returned by <code><a href="#topic+EOF">EOF()</a></code> are normalized. This function multiplies the left or right
matrix by the diagonal matrix to return it to proper units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denormalise(eof, which = c("left", "right"))

denormalize(eof, which = c("left", "right"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denormalise_+3A_eof">eof</code></td>
<td>
<p>an <code>eof</code> object.</p>
</td></tr>
<tr><td><code id="denormalise_+3A_which">which</code></td>
<td>
<p>which side of the eof decomposition to denormalise</p>
</td></tr>
</table>

<hr>
<h2 id='Derivate'>Derivate a discrete variable using finite differences</h2><span id='topic+Derivate'></span><span id='topic+Laplacian'></span><span id='topic+Divergence'></span><span id='topic+Vorticity'></span>

<h3>Description</h3>

<p>Derivate a discrete variable using finite differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Derivate(
  formula,
  order = 1,
  cyclical = FALSE,
  fill = FALSE,
  data = NULL,
  sphere = FALSE,
  a = 6371000,
  equispaced = TRUE
)

Laplacian(
  formula,
  cyclical = FALSE,
  fill = FALSE,
  data = NULL,
  sphere = FALSE,
  a = 6371000,
  equispaced = TRUE
)

Divergence(
  formula,
  cyclical = FALSE,
  fill = FALSE,
  data = NULL,
  sphere = FALSE,
  a = 6371000,
  equispaced = TRUE
)

Vorticity(
  formula,
  cyclical = FALSE,
  fill = FALSE,
  data = NULL,
  sphere = FALSE,
  a = 6371000,
  equispaced = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Derivate_+3A_formula">formula</code></td>
<td>
<p>a formula indicating dependent and independent variables</p>
</td></tr>
<tr><td><code id="Derivate_+3A_order">order</code></td>
<td>
<p>order of the derivative</p>
</td></tr>
<tr><td><code id="Derivate_+3A_cyclical">cyclical</code></td>
<td>
<p>logical vector of boundary condition for each independent variable</p>
</td></tr>
<tr><td><code id="Derivate_+3A_fill">fill</code></td>
<td>
<p>logical indicating whether to fill values at the boundaries
with forward and backwards differencing</p>
</td></tr>
<tr><td><code id="Derivate_+3A_data">data</code></td>
<td>
<p>optional data.frame containing the variables</p>
</td></tr>
<tr><td><code id="Derivate_+3A_sphere">sphere</code></td>
<td>
<p>logical indicating whether to use spherical coordinates
(see details)</p>
</td></tr>
<tr><td><code id="Derivate_+3A_a">a</code></td>
<td>
<p>radius to use in spherical coordinates (defaults to Earth's radius)</p>
</td></tr>
<tr><td><code id="Derivate_+3A_equispaced">equispaced</code></td>
<td>
<p>logical indicating whether points are equispaced or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element of the return vector is an estimation of
<code class="reqn">\frac{\partial^n x}{\partial y^{n}}</code> by
centred finite differences.
</p>
<p>If <code>sphere = TRUE</code>, then the first two independent variables are
assumed to be longitude and latitude (<strong>in that order</strong>) in degrees. Then, a
correction is applied to the derivative so that they are in the same units as
<code>a</code>.
</p>
<p>Using <code>fill = TRUE</code> will degrade the solution near the edges of a non-cyclical
boundary. Use with caution.
</p>
<p><code>Laplacian()</code>, <code>Divergence()</code> and <code>Vorticity()</code> are convenient wrappers that
call <code>Derivate()</code> and make the appropriate sums. For <code>Divergence()</code> and
<code>Vorticity()</code>, <code>formula</code> must be of the form <code>vx + vy ~ x + y</code>
(<strong>in that order</strong>).
</p>


<h3>Value</h3>

<p>If there is one independent variable and one dependent variable, a numeric
vector of the same length as the dependent variable.
If there are two or more independent variables or two or more dependent variables,
a list containing the directional derivatives of each dependent variables.
</p>


<h3>See Also</h3>

<p>Other meteorology functions: 
<code><a href="#topic+EOF">EOF</a>()</code>,
<code><a href="#topic+GeostrophicWind">GeostrophicWind</a>()</code>,
<code><a href="#topic+WaveFlux">WaveFlux</a>()</code>,
<code><a href="#topic+thermodynamics">thermodynamics</a></code>,
<code><a href="#topic+waves">waves</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(2)
theta &lt;- seq(0, 360, length.out = 20)*pi/180
theta &lt;- theta[-1]
x &lt;- cos(theta)
dx_analytical &lt;- -sin(theta)
dx_finitediff &lt;- Derivate(x ~ theta, cyclical = TRUE)[[1]]

plot(theta, dx_analytical, type = "l")
points(theta, dx_finitediff, col = "red")

# Curvature (Laplacian)
# Note the different boundary conditions for each dimension
variable &lt;- expand.grid(lon = seq(0, 360, by = 3)[-1],
                        lat = seq(-90, 90, by = 3))
variable$z &lt;- with(variable, cos(lat*pi/180*3) + sin(lon*pi/180*2))
variable &lt;- cbind(
     variable,
     as.data.frame(Derivate(z ~ lon + lat, data = variable,
                          cyclical = c(TRUE, FALSE), order = 2)))
library(ggplot2)
ggplot(variable, aes(lon, lat)) +
    geom_contour(aes(z = z)) +
    geom_contour(aes(z = z.ddlon + z.ddlat), color = "red")

# The same as
ggplot(variable, aes(lon, lat)) +
    geom_contour(aes(z = z)) +
    geom_contour(aes(z = Laplacian(z ~ lon + lat, cyclical = c(TRUE, FALSE))),
                 color = "red")

</code></pre>

<hr>
<h2 id='EOF'>Empirical Orthogonal Function</h2><span id='topic+EOF'></span>

<h3>Description</h3>

<p>Computes Singular Value Decomposition (also known as Principal Components
Analysis or Empirical Orthogonal Functions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EOF(
  formula,
  n = 1,
  data = NULL,
  B = 0,
  probs = c(lower = 0.025, mid = 0.5, upper = 0.975),
  rotate = NULL,
  suffix = "PC",
  fill = NULL,
  engine = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EOF_+3A_formula">formula</code></td>
<td>
<p>a formula to build the matrix that will be used in the SVD
decomposition (see Details)</p>
</td></tr>
<tr><td><code id="EOF_+3A_n">n</code></td>
<td>
<p>which singular values to return (if <code>NULL</code>, returns all)</p>
</td></tr>
<tr><td><code id="EOF_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="EOF_+3A_b">B</code></td>
<td>
<p>number of bootstrap samples used to estimate confidence intervals.
Ignored if &lt;= 1.</p>
</td></tr>
<tr><td><code id="EOF_+3A_probs">probs</code></td>
<td>
<p>the probabilities of the lower and upper values of estimated
confidence intervals. If named, it's names will be used as column names.</p>
</td></tr>
<tr><td><code id="EOF_+3A_rotate">rotate</code></td>
<td>
<p>a function to apply to the loadings to rotate them. E.g. for
varimax rotation use <code>stats::varimax</code>.</p>
</td></tr>
<tr><td><code id="EOF_+3A_suffix">suffix</code></td>
<td>
<p>character to name the principal components</p>
</td></tr>
<tr><td><code id="EOF_+3A_fill">fill</code></td>
<td>
<p>value to infill implicit missing values or <code>NULL</code> if the
data is dense.</p>
</td></tr>
<tr><td><code id="EOF_+3A_engine">engine</code></td>
<td>
<p>function to use to compute SVD. If <code>NULL</code> it uses <a href="irlba.html#topic+irlba">irlba::irlba</a>
(if installed) if the largest singular value to compute is lower than half the maximum
possible value, otherwise it uses <a href="base.html#topic+svd">base::svd</a>. If the user provides a function,
it needs to be a drop-in replacement for <a href="base.html#topic+svd">base::svd</a> (the same arguments and
output format).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Singular values can be computed over matrices so <code>formula</code> denotes how
to build a matrix from the data. It is a formula of the form VAR ~ LEFT | RIGHT
(see <a href="Formula.html#topic+Formula">Formula::Formula</a>) in which VAR is the variable whose values will
populate the matrix, and LEFT represent the variables used to make the rows
and RIGHT, the columns of the matrix. Think it like &quot;VAR <em>as a function</em> of
LEFT <em>and</em> RIGHT&quot;. The variable combination used in this formula <em>must</em> identify
an unique value in a cell.
</p>
<p>So, for example, <code>v ~ x + y | t</code> would mean that there is one value of <code>v</code> for
each combination of <code>x</code>, <code>y</code> and <code>t</code>, and that there will be one row for
each combination of <code>x</code> and <code>y</code> and one row for each <code>t</code>.
</p>
<p>In the result, the left and right vectors have dimensions of the LEFT and RIGHT
part of the <code>formula</code>, respectively.
</p>
<p>It is much faster to compute only some singular vectors, so is advisable not
to set n to <code>NULL</code>. If the irlba package is installed, EOF uses
<a href="irlba.html#topic+irlba">irlba::irlba</a> instead of <a href="base.html#topic+svd">base::svd</a> since it's much faster.
</p>
<p>The bootstrapping procedure follows Fisher et.al. (2016) and returns the
standard deviation of each singular value.
</p>


<h3>Value</h3>

<p>An <code>eof</code> object which is just a named list of <code>data.table</code>s
</p>

<dl>
<dt>left</dt><dd><p>data.table with left singular vectors</p>
</dd>
<dt>right</dt><dd><p>data.table with right singular vectors</p>
</dd>
<dt>sdev</dt><dd><p>data.table with singular values, their explained variance,
and, optionally, quantiles estimated via bootstrap</p>
</dd>
</dl>

<p>There are some methods implemented
</p>

<ul>
<li> <p><a href="base.html#topic+summary">summary</a>
</p>
</li>
<li> <p><a href="stats.html#topic+screeplot">screeplot</a> and the equivalent <a href="ggplot2.html#topic+autoplot">ggplot2::autoplot</a>
</p>
</li>
<li> <p><a href="#topic+cut.eof">cut.eof</a>
</p>
</li>
<li> <p><a href="stats.html#topic+predict">predict</a>
</p>
</li></ul>



<h3>References</h3>

<p>Fisher, A., Caffo, B., Schwartz, B., &amp; Zipunnikov, V. (2016). Fast, Exact Bootstrap Principal Component Analysis for p &gt; 1 million. Journal of the American Statistical Association, 111(514), 846–860. <a href="https://doi.org/10.1080/01621459.2015.1062383">doi:10.1080/01621459.2015.1062383</a>
</p>


<h3>See Also</h3>

<p>Other meteorology functions: 
<code><a href="#topic+Derivate">Derivate</a>()</code>,
<code><a href="#topic+GeostrophicWind">GeostrophicWind</a>()</code>,
<code><a href="#topic+WaveFlux">WaveFlux</a>()</code>,
<code><a href="#topic+thermodynamics">thermodynamics</a></code>,
<code><a href="#topic+waves">waves</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The Antarctic Oscillation is computed from the
# monthly geopotential height anomalies weighted by latitude.
library(data.table)
data(geopotential)
geopotential &lt;- copy(geopotential)
geopotential[, gh.t.w := Anomaly(gh)*sqrt(cos(lat*pi/180)),
      by = .(lon, lat, month(date))]

eof &lt;- EOF(gh.t.w ~ lat + lon | date, 1:5, data = geopotential,
           B = 100, probs = c(low = 0.1, hig = 0.9))

# Inspect the explained variance of each component
summary(eof)
screeplot(eof)

# Keep only the 1st.
aao &lt;- cut(eof, 1)

# AAO field
library(ggplot2)
ggplot(aao$left, aes(lon, lat, z = gh.t.w)) +
    geom_contour(aes(color = after_stat(level))) +
    coord_polar()

# AAO signal
ggplot(aao$right, aes(date, gh.t.w)) +
    geom_line()

# standard deviation, % of explained variance and
# confidence intervals.
aao$sdev

# Reconstructed fields based only on the two first
# principal components
field &lt;- predict(eof, 1:2)

# Compare it to the real field.
ggplot(field[date == date[1]], aes(lon, lat)) +
    geom_contour_fill(aes(z = gh.t.w), data = geopotential[date == date[1]]) +
    geom_contour2(aes(z = gh.t.w, linetype = factor(-sign(stat(level))))) +
    scale_fill_divergent()


</code></pre>

<hr>
<h2 id='EPflux'>Computes Eliassen-Palm fluxes.</h2><span id='topic+EPflux'></span>

<h3>Description</h3>

<p>Computes Eliassen-Palm fluxes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EPflux(lon, lat, lev, t, u, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EPflux_+3A_lon">lon</code></td>
<td>
<p>longitudes in degrees.</p>
</td></tr>
<tr><td><code id="EPflux_+3A_lat">lat</code></td>
<td>
<p>latitudes in degrees.</p>
</td></tr>
<tr><td><code id="EPflux_+3A_lev">lev</code></td>
<td>
<p>pressure levels.</p>
</td></tr>
<tr><td><code id="EPflux_+3A_t">t</code></td>
<td>
<p>temperature in Kelvin.</p>
</td></tr>
<tr><td><code id="EPflux_+3A_u">u</code></td>
<td>
<p>zonal wind in m/s.</p>
</td></tr>
<tr><td><code id="EPflux_+3A_v">v</code></td>
<td>
<p>meridional wind in m/s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with columns <code>Flon</code>, <code>Flat</code> and <code>Flev</code> giving the zonal, meridional
and vertical components of the EP Fluxes at each longitude, latitude and level.
</p>


<h3>References</h3>

<p>Plumb, R. A. (1985). On the Three-Dimensional Propagation of Stationary Waves. Journal of the Atmospheric Sciences, 42(3), 217–229. <a href="https://doi.org/10.1175/1520-0469%281985%29042%3C0217%3AOTTDPO%3E2.0.CO%3B2">doi:10.1175/1520-0469(1985)042&lt;0217:OTTDPO&gt;2.0.CO;2</a>
Cohen, J., Barlow, M., Kushner, P. J., &amp; Saito, K. (2007). Stratosphere–Troposphere Coupling and Links with Eurasian Land Surface Variability. Journal of Climate, 20(21), 5335–5343. <a href="https://doi.org/10.1175/2007JCLI1725.1">doi:10.1175/2007JCLI1725.1</a>
</p>

<hr>
<h2 id='FitLm'>Fast estimates of linear regression</h2><span id='topic+FitLm'></span><span id='topic+ResidLm'></span><span id='topic+Detrend'></span>

<h3>Description</h3>

<p>Computes a linear regression with <a href="stats.html#topic+lmfit">stats::.lm.fit</a> and returns the estimate
and, optionally, standard error for each regressor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitLm(y, ..., intercept = TRUE, weights = NULL, se = FALSE, r2 = se)

ResidLm(y, ..., intercept = TRUE, weights = NULL)

Detrend(y, time = seq_along(y))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FitLm_+3A_y">y</code></td>
<td>
<p>numeric vector of observations to model</p>
</td></tr>
<tr><td><code id="FitLm_+3A_...">...</code></td>
<td>
<p>numeric vectors of variables used in the modelling</p>
</td></tr>
<tr><td><code id="FitLm_+3A_intercept">intercept</code></td>
<td>
<p>logical indicating whether to automatically add the intercept</p>
</td></tr>
<tr><td><code id="FitLm_+3A_weights">weights</code></td>
<td>
<p>numerical vector of weights (which doesn't need to be normalised)</p>
</td></tr>
<tr><td><code id="FitLm_+3A_se">se</code></td>
<td>
<p>logical indicating whether to compute the standard error</p>
</td></tr>
<tr><td><code id="FitLm_+3A_r2">r2</code></td>
<td>
<p>logical indicating whether to compute r squared</p>
</td></tr>
<tr><td><code id="FitLm_+3A_time">time</code></td>
<td>
<p>time vector to use for detrending. Only necessary in the case of
irregularly sampled timeseries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FitLm returns a list with elements
</p>

<dl>
<dt>term</dt><dd><p>the name of the regressor</p>
</dd>
<dt>estimate</dt><dd><p>estimate of the regression</p>
</dd>
<dt>std.error</dt><dd><p>standard error</p>
</dd>
<dt>df</dt><dd><p>degrees of freedom</p>
</dd>
<dt>r.squared</dt><dd><p>Percent of variance explained by the model (repeated in each term)</p>
</dd>
<dt>adj.r.squared</dt><dd><p> r.squared' adjusted based on the degrees of freedom)</p>
</dd>
</dl>

<p>ResidLm and Detrend returns a vector of the same length
</p>
<p>If there's no complete cases in the regression, <code>NA</code>s are returned with no
warning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Linear trend with "signficant" areas shaded with points
library(data.table)
library(ggplot2)
system.time({
  regr &lt;- geopotential[, FitLm(gh, date, se = TRUE), by = .(lon, lat)]
})

ggplot(regr[term != "(Intercept)"], aes(lon, lat)) +
    geom_contour(aes(z = estimate, color = after_stat(level))) +
    stat_subset(aes(subset = abs(estimate) &gt; 2*std.error), size = 0.05)

# Using stats::lm() is much slower and with no names.
## Not run: 
system.time({
  regr &lt;- geopotential[, coef(lm(gh ~ date))[2], by = .(lon, lat)]
})

## End(Not run)

</code></pre>

<hr>
<h2 id='geom_arrow'>Arrows</h2><span id='topic+geom_arrow'></span><span id='topic+geom_vector'></span><span id='topic+GeomArrow'></span><span id='topic+StatArrow'></span>

<h3>Description</h3>

<p>Parametrization of <a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment</a> either by location and displacement
or by magnitude and angle with default arrows. <code>geom_arrow()</code> is the same as
<code>geom_vector()</code> but defaults to preserving the direction under coordinate
transformation and different plot ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_arrow(
  mapping = NULL,
  data = NULL,
  stat = "arrow",
  position = "identity",
  ...,
  start = 0,
  direction = c("ccw", "cw"),
  pivot = 0.5,
  preserve.dir = TRUE,
  min.mag = 0,
  skip = 0,
  skip.x = skip,
  skip.y = skip,
  arrow.angle = 15,
  arrow.length = 0.5,
  arrow.ends = "last",
  arrow.type = "closed",
  arrow = grid::arrow(arrow.angle, grid::unit(arrow.length, "lines"), ends = arrow.ends,
    type = arrow.type),
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_vector(
  mapping = NULL,
  data = NULL,
  stat = "arrow",
  position = "identity",
  ...,
  start = 0,
  direction = c("ccw", "cw"),
  pivot = 0.5,
  preserve.dir = FALSE,
  min.mag = 0,
  skip = 0,
  skip.x = skip,
  skip.y = skip,
  arrow.angle = 15,
  arrow.length = 0.5,
  arrow.ends = "last",
  arrow.type = "closed",
  arrow = grid::arrow(arrow.angle, grid::unit(arrow.length, "lines"), ends = arrow.ends,
    type = arrow.type),
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_arrow_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_arrow_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_arrow_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_arrow_+3A_start">start</code></td>
<td>
<p>starting angle for rotation in degrees</p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_direction">direction</code></td>
<td>
<p>direction of rotation (counter-clockwise or clockwise)</p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_pivot">pivot</code></td>
<td>
<p>numeric indicating where to pivot the arrow where 0 means at the
beginning and 1 means at the end.</p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_preserve.dir">preserve.dir</code></td>
<td>
<p>logical indicating whether to preserve direction or not</p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_min.mag">min.mag</code></td>
<td>
<p>minimum magnitude for plotting vectors</p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_skip">skip</code>, <code id="geom_arrow_+3A_skip.x">skip.x</code>, <code id="geom_arrow_+3A_skip.y">skip.y</code></td>
<td>
<p>numeric specifying number of gridpoints not to draw
in the x and y direction</p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_arrow.length">arrow.length</code>, <code id="geom_arrow_+3A_arrow.angle">arrow.angle</code>, <code id="geom_arrow_+3A_arrow.ends">arrow.ends</code>, <code id="geom_arrow_+3A_arrow.type">arrow.type</code></td>
<td>
<p>parameters passed to
<a href="grid.html#topic+arrow">grid::arrow</a></p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_arrow_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Direction and start allows to work with different standards. For the
meteorological standard, for example, use <code>star = -90</code> and <code>direction = "cw"</code>.
</p>


<h3>Aesthetics</h3>

<p><code>geom_vector</code> understands the following aesthetics (required aesthetics are in bold)
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> either <strong>mag</strong> and <strong>angle</strong>, or <strong>dx</strong> and <strong>dy</strong>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li>
<li> <p><code>lineend</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
library(ggplot2)

data(seals)
# If the velocity components are in the same units as the axis,
# geom_vector() (or geom_arrow(preserve.dir = TRUE)) might be a better option
ggplot(seals, aes(long, lat)) +
    geom_arrow(aes(dx = delta_long, dy = delta_lat), skip = 1, color = "red") +
    geom_vector(aes(dx = delta_long, dy = delta_lat), skip = 1) +
    scale_mag()

data(geopotential)
geopotential &lt;- copy(geopotential)[date == date[1]]
geopotential[, gh.z := Anomaly(gh), by = .(lat)]
geopotential[, c("u", "v") := GeostrophicWind(gh.z, lon, lat)]

(g &lt;- ggplot(geopotential, aes(lon, lat)) +
    geom_arrow(aes(dx = dlon(u, lat), dy = dlat(v)), skip.x = 3, skip.y = 2,
               color = "red") +
    geom_vector(aes(dx = dlon(u, lat), dy = dlat(v)), skip.x = 3, skip.y = 2) +
    scale_mag( guide = "none"))

# A dramatic illustration of the difference between arrow and vector
g + coord_polar()

# When plotting winds in a lat-lon grid, a good way to have both
# the correct direction and an interpretable magnitude is to define
# the angle by the longitud and latitude displacement and the magnitude
# by the wind velocity. That way arrows are always parallel to streamlines
# and their magnitude are in the correct units.
ggplot(geopotential, aes(lon, lat)) +
    geom_contour(aes(z = gh.z)) +
    geom_vector(aes(angle = atan2(dlat(v), dlon(u, lat))*180/pi,
                   mag = Mag(v, u)), skip = 1, pivot = 0.5) +
    scale_mag()

# Sverdrup transport
library(data.table)
b &lt;- 10
d &lt;- 10
grid &lt;- as.data.table(expand.grid(x = seq(1, d, by = 0.5),
                                  y = seq(1, b, by = 0.5)))
grid[, My := -sin(pi*y/b)*pi/b]
grid[, Mx := -pi^2/b^2*cos(pi*y/b)*(d - x)]

ggplot(grid, aes(x, y)) +
    geom_arrow(aes(dx = Mx, dy = My))

# Due to limitations in ggplot2 (see: https://github.com/tidyverse/ggplot2/issues/4291),
# if you define the vector with the dx and dy aesthetics, you need
# to explicitly add scale_mag() in order to show the arrow legend.

ggplot(grid, aes(x, y)) +
    geom_arrow(aes(dx = Mx, dy = My)) +
    scale_mag()

# Alternative, use Mag and Angle.
ggplot(grid, aes(x, y)) +
    geom_arrow(aes(mag = Mag(Mx, My), angle = Angle(Mx, My)))

</code></pre>

<hr>
<h2 id='geom_contour_fill'>Filled 2d contours of a 3d surface</h2><span id='topic+geom_contour_fill'></span><span id='topic+stat_contour_fill'></span><span id='topic+StatContourFill'></span>

<h3>Description</h3>

<p>While ggplot2's <code><a href="ggplot2.html#topic+geom_contour">geom_contour</a></code> can plot nice contours, it
doesn't work with the polygon geom. This stat makes some small manipulation
of the data to ensure that all contours are closed and also computes a new
aesthetic <code>int.level</code>, which differs from <code>level</code> (computed by
<a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour</a>) in that represents
the value of the <code>z</code> aesthetic <em>inside</em> the contour instead of at the edge.
It also computes breaks globally instead of per panel, so that faceted plots
have all the same binwidth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_contour_fill(
  mapping = NULL,
  data = NULL,
  stat = "ContourFill",
  position = "identity",
  ...,
  breaks = MakeBreaks(),
  bins = NULL,
  binwidth = NULL,
  proj = NULL,
  proj.latlon = TRUE,
  clip = NULL,
  kriging = FALSE,
  global.breaks = TRUE,
  na.fill = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_contour_fill(
  mapping = NULL,
  data = NULL,
  geom = "polygon",
  position = "identity",
  ...,
  breaks = MakeBreaks(),
  bins = NULL,
  binwidth = NULL,
  global.breaks = TRUE,
  proj = NULL,
  proj.latlon = TRUE,
  clip = NULL,
  kriging = FALSE,
  na.fill = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_contour_fill_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_breaks">breaks</code></td>
<td>
<p>numeric vector of breaks</p>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_bins">bins</code></td>
<td>
<p>Number of evenly spaced breaks.</p>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_binwidth">binwidth</code></td>
<td>
<p>Distance between breaks.</p>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_proj">proj</code></td>
<td>
<p>The projection to which to project the contours to.
It can be either a projection string or a function to apply to the whole
contour dataset.</p>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_proj.latlon">proj.latlon</code></td>
<td>
<p>Logical indicating if the projection step should project
from a cartographic projection to a lon/lat grid or the other way around.</p>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_clip">clip</code></td>
<td>
<p>A simple features object to be used as a clip. Contours are only
drawn in the interior of this polygon.</p>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_kriging">kriging</code></td>
<td>
<p>Whether to perform ordinary kriging before contouring.
Use this if you want to use contours with irregularly spaced data.
If <code>FALSE</code>, no kriging is performed. If <code>TRUE</code>, kriging will be performed with
40 points. If a numeric, kriging will be performed with <code>kriging</code> points.</p>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_global.breaks">global.breaks</code></td>
<td>
<p>Logical indicating whether <code>breaks</code> should be computed for the whole
data or for each grouping.</p>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_na.fill">na.fill</code></td>
<td>
<p>How to fill missing values.
</p>

<ul>
<li> <p><code>FALSE</code> for letting the computation fail with no interpolation
</p>
</li>
<li> <p><code>TRUE</code> for imputing missing values with <a href="#topic+Impute2D">Impute2D</a>
</p>
</li>
<li><p> A numeric value for constant imputation
</p>
</li>
<li><p> A function that takes a vector and returns a numeric (e.g. <code>mean</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_contour_fill_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data for this layer.
When using a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function to construct a layer, the <code>geom</code> argument
can be used to override the default coupling between stats and geoms. The
<code>geom</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Geom</code> ggproto subclass, for example <code>GeomPoint</code>.
</p>
</li>
<li><p> A string naming the geom. To give the geom as a string, strip the
function name of the <code>geom_</code> prefix. For example, to use <code>geom_point()</code>,
give the geom as <code>"point"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the geom, see the
<a href="ggplot2.html#topic+layer_geoms">layer geom</a> documentation.
</p>
</li></ul>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_contour_fill</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>group</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li>
<li> <p><code>weight</code>
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>level</dt><dd><p>An ordered factor that represents bin ranges.</p>
</dd>
<dt>level_d</dt><dd><p>Same as <code>level</code>, but automatically uses <code><a href="#topic+scale_fill_discretised">scale_fill_discretised()</a></code></p>
</dd>
<dt>level_low,level_high,level_mid</dt><dd><p>Lower and upper bin boundaries for each band, as well the mid point between the boundaries.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ggplot2)
surface &lt;- reshape2::melt(volcano)
ggplot(surface, aes(Var1, Var2, z = value)) +
  geom_contour_fill() +
  geom_contour(color = "black", size = 0.1)

ggplot(surface, aes(Var1, Var2, z = value)) +
  geom_contour_fill(aes(fill = after_stat(level)))

ggplot(surface, aes(Var1, Var2, z = value)) +
  geom_contour_fill(aes(fill = after_stat(level_d)))

</code></pre>

<hr>
<h2 id='geom_contour_tanaka'>Illuminated contours</h2><span id='topic+geom_contour_tanaka'></span><span id='topic+GeomContourTanaka'></span>

<h3>Description</h3>

<p>Illuminated contours (aka Tanaka contours) use varying brightness and width to
create an illusion of relief. This can help distinguishing between concave and
convex areas (local minimums and maximums), specially in black and white plots
or to make photocopy safe plots with divergent colour palettes, or to render
a more aesthetically pleasing representation of topography.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_contour_tanaka(
  mapping = NULL,
  data = NULL,
  stat = "Contour2",
  position = "identity",
  ...,
  breaks = NULL,
  bins = NULL,
  binwidth = NULL,
  sun.angle = 60,
  light = "white",
  dark = "gray20",
  range = c(0.01, 0.5),
  smooth = 0,
  proj = NULL,
  proj.latlon = TRUE,
  clip = NULL,
  kriging = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_contour_tanaka_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> A numeric vector of breaks
</p>
</li>
<li><p> A function that takes the range of the data and binwidth as input
and returns breaks as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_bins">bins</code></td>
<td>
<p>Number of evenly spaced breaks.</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_binwidth">binwidth</code></td>
<td>
<p>Distance between breaks.</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_sun.angle">sun.angle</code></td>
<td>
<p>angle of the sun in degrees counterclockwise from 12 o' clock</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_light">light</code>, <code id="geom_contour_tanaka_+3A_dark">dark</code></td>
<td>
<p>valid colour representing the light and dark shading</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_range">range</code></td>
<td>
<p>numeric vector of length 2 with the minimum and maximum size of lines</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_smooth">smooth</code></td>
<td>
<p>numeric indicating the degree of smoothing of illumination and size.
Larger</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_proj">proj</code></td>
<td>
<p>The projection to which to project the contours to.
It can be either a projection string or a function to apply to the whole
contour dataset.</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_proj.latlon">proj.latlon</code></td>
<td>
<p>Logical indicating if the projection step should project
from a cartographic projection to a lon/lat grid or the other way around.</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_clip">clip</code></td>
<td>
<p>A simple features object to be used as a clip. Contours are only
drawn in the interior of this polygon.</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_kriging">kriging</code></td>
<td>
<p>Whether to perform ordinary kriging before contouring.
Use this if you want to use contours with irregularly spaced data.
If <code>FALSE</code>, no kriging is performed. If <code>TRUE</code>, kriging will be performed with
40 points. If a numeric, kriging will be performed with <code>kriging</code> points.</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_contour_tanaka_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_contour_tanaka</code> understands the following aesthetics (required aesthetics are in bold)
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>z</strong>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

library(ggplot2)
library(data.table)
# A fresh look at the boring old volcano dataset
ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +
    geom_contour_fill(aes(z = value)) +
    geom_contour_tanaka(aes(z = value)) +
    theme_void()

# If the transition between segments feels too abrupt,
# smooth it a bit with smooth
ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +
    geom_contour_fill(aes(z = value)) +
    geom_contour_tanaka(aes(z = value), smooth = 1) +
    theme_void()

data(geopotential)
geo &lt;- geopotential[date == unique(date)[4]]
geo[, gh.z := Anomaly(gh), by = lat]

# In a monochrome contour map, it's impossible to know which areas are
# local maximums or minimums.
ggplot(geo, aes(lon, lat)) +
    geom_contour2(aes(z = gh.z), color = "black", xwrap = c(0, 360))

# With tanaka contours, they are obvious.
ggplot(geo, aes(lon, lat)) +
    geom_contour_tanaka(aes(z = gh.z), dark = "black",
                        xwrap = c(0, 360)) +
    scale_fill_divergent()

# A good divergent color palette has the same luminosity for positive
# and negative values.But that means that printed in grayscale (Desaturated),
# they are indistinguishable.
(g &lt;- ggplot(geo, aes(lon, lat)) +
    geom_contour_fill(aes(z = gh.z), xwrap = c(0, 360)) +
    scale_fill_gradientn(colours = c("#767676", "white", "#484848"),
                         values = c(0, 0.415, 1)))

# Tanaka contours can solve this issue.
g + geom_contour_tanaka(aes(z = gh.z))

</code></pre>

<hr>
<h2 id='geom_contour2'>2d contours of a 3d surface</h2><span id='topic+geom_contour2'></span><span id='topic+GeomContour2'></span><span id='topic+stat_contour2'></span><span id='topic+StatContour2'></span>

<h3>Description</h3>

<p>Similar to <a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour</a> but it can label contour lines,
accepts accepts a function as the <code>breaks</code> argument and and computes
breaks globally instead of per panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_contour2(
  mapping = NULL,
  data = NULL,
  stat = "contour2",
  position = "identity",
  ...,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  breaks = MakeBreaks(),
  bins = NULL,
  binwidth = NULL,
  global.breaks = TRUE,
  na.rm = FALSE,
  na.fill = FALSE,
  skip = 1,
  margin = grid::unit(c(1, 1, 1, 1), "pt"),
  label.placer = label_placer_flattest(),
  show.legend = NA,
  inherit.aes = TRUE
)

stat_contour2(
  mapping = NULL,
  data = NULL,
  geom = "contour2",
  position = "identity",
  ...,
  breaks = MakeBreaks(),
  bins = NULL,
  binwidth = NULL,
  proj = NULL,
  proj.latlon = TRUE,
  clip = NULL,
  kriging = FALSE,
  global.breaks = TRUE,
  na.rm = FALSE,
  na.fill = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_contour2_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour2_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour2_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour2_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> A numeric vector of breaks
</p>
</li>
<li><p> A function that takes the range of the data and binwidth as input
and returns breaks as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour2_+3A_bins">bins</code></td>
<td>
<p>Number of evenly spaced breaks.</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_binwidth">binwidth</code></td>
<td>
<p>Distance between breaks.</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_global.breaks">global.breaks</code></td>
<td>
<p>Logical indicating whether <code>breaks</code> should be computed for the whole
data or for each grouping.</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_na.fill">na.fill</code></td>
<td>
<p>How to fill missing values.
</p>

<ul>
<li> <p><code>FALSE</code> for letting the computation fail with no interpolation
</p>
</li>
<li> <p><code>TRUE</code> for imputing missing values with <a href="#topic+Impute2D">Impute2D</a>
</p>
</li>
<li><p> A numeric value for constant imputation
</p>
</li>
<li><p> A function that takes a vector and returns a numeric (e.g. <code>mean</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour2_+3A_skip">skip</code></td>
<td>
<p>number of contours to skip for labelling
(e.g. <code>skip = 1</code> will skip 1 contour line between labels).</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_margin">margin</code></td>
<td>
<p>the margin around labels around which contour lines
are clipped to avoid overlapping.</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_label.placer">label.placer</code></td>
<td>
<p>a label placer function. See <code><a href="#topic+label_placer_flattest">label_placer_flattest()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data for this layer.
When using a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function to construct a layer, the <code>geom</code> argument
can be used to override the default coupling between stats and geoms. The
<code>geom</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Geom</code> ggproto subclass, for example <code>GeomPoint</code>.
</p>
</li>
<li><p> A string naming the geom. To give the geom as a string, strip the
function name of the <code>geom_</code> prefix. For example, to use <code>geom_point()</code>,
give the geom as <code>"point"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the geom, see the
<a href="ggplot2.html#topic+layer_geoms">layer geom</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_contour2_+3A_proj">proj</code></td>
<td>
<p>The projection to which to project the contours to.
It can be either a projection string or a function to apply to the whole
contour dataset.</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_proj.latlon">proj.latlon</code></td>
<td>
<p>Logical indicating if the projection step should project
from a cartographic projection to a lon/lat grid or the other way around.</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_clip">clip</code></td>
<td>
<p>A simple features object to be used as a clip. Contours are only
drawn in the interior of this polygon.</p>
</td></tr>
<tr><td><code id="geom_contour2_+3A_kriging">kriging</code></td>
<td>
<p>Whether to perform ordinary kriging before contouring.
Use this if you want to use contours with irregularly spaced data.
If <code>FALSE</code>, no kriging is performed. If <code>TRUE</code>, kriging will be performed with
40 points. If a numeric, kriging will be performed with <code>kriging</code> points.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_contour2</code> understands the following aesthetics (required aesthetics are in bold):
</p>
<p>Aesthetics related to contour lines:
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>z</strong>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>group</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li>
<li> <p><code>weight</code>
</p>
</li></ul>

<p>Aesthetics related to labels:
</p>

<ul>
<li> <p><code>label</code>
</p>
</li>
<li> <p><code>label_colour</code>
</p>
</li>
<li> <p><code>label_alpha</code>
</p>
</li>
<li> <p><code>label_size</code>
</p>
</li>
<li> <p><code>family</code>
</p>
</li>
<li> <p><code>fontface</code>
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>level</dt><dd><p>height of contour</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>
<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ggplot2)

# Breaks can be a function.
ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +
    geom_contour2(aes(z = value, color = after_stat(level)),
                  breaks = AnchorBreaks(130, binwidth = 10))

# Add labels by supplying the label aes.
ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +
    geom_contour2(aes(z = value, label = after_stat(level)))

ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +
    geom_contour2(aes(z = value, label = after_stat(level)),
                  skip = 0)

# Use label.placer to control where contours are labelled.
ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +
    geom_contour2(aes(z = value, label = after_stat(level)),
                      label.placer = label_placer_n(n = 2))

# Use the rot_adjuster argument of the placer function to
# control the angle. For example, to fix it to some angle:
ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +
    geom_contour2(aes(z = value, label = after_stat(level)),
                  skip = 0,
                  label.placer = label_placer_flattest(rot_adjuster = 0))

</code></pre>

<hr>
<h2 id='geom_label_contour'>Label contours</h2><span id='topic+geom_label_contour'></span><span id='topic+GeomLabelContour'></span><span id='topic+geom_text_contour'></span><span id='topic+GeomTextContour'></span><span id='topic+StatTextContour'></span>

<h3>Description</h3>

<p>Draws labels on contours built with <a href="ggplot2.html#topic+geom_contour">ggplot2::stat_contour</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_label_contour(
  mapping = NULL,
  data = NULL,
  stat = "text_contour",
  position = "identity",
  ...,
  min.size = 5,
  skip = 1,
  label.placer = label_placer_flattest(),
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  label.padding = grid::unit(0.25, "lines"),
  label.r = grid::unit(0.15, "lines"),
  label.size = 0.25,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_text_contour(
  mapping = NULL,
  data = NULL,
  stat = "text_contour",
  position = "identity",
  ...,
  min.size = 5,
  skip = 1,
  rotate = TRUE,
  label.placer = label_placer_flattest(),
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  stroke = 0,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_label_contour_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer.
Cannot be jointy specified with <code>nudge_x</code> or <code>nudge_y</code>. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
</p>
</li>
<li><p> A string nameing the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_min.size">min.size</code></td>
<td>
<p>minimum number of points for a contour to be labelled.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_skip">skip</code></td>
<td>
<p>number of contours to skip</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_label.placer">label.placer</code></td>
<td>
<p>a label placer function. See <code><a href="#topic+label_placer_flattest">label_placer_flattest()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_nudge_x">nudge_x</code>, <code id="geom_label_contour_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.
Cannot be jointly specified with <code>position</code>.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_label.padding">label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_label.r">label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_label.size">label.size</code></td>
<td>
<p>Size of label border, in mm.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_rotate">rotate</code></td>
<td>
<p>logical indicating whether to rotate text following the contour.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_stroke">stroke</code></td>
<td>
<p>numerical indicating width of stroke relative to the size of
the text. Ignored if less than zero.</p>
</td></tr>
<tr><td><code id="geom_label_contour_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Is best used with a previous call to <a href="ggplot2.html#topic+geom_contour">ggplot2::stat_contour</a> with the same
parameters (e.g. the same <code>binwidth</code>, <code>breaks</code>, or <code>bins</code>).
Note that while <code>geom_text_contour()</code> can angle itself to follow the contour,
this is not the case with <code>geom_label_contour()</code>.
</p>


<h3>Aesthetics</h3>

<p><code>geom_text_contour</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>label</strong>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>angle</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>stroke.color</code>
</p>
</li>
<li> <p><code>family</code>
</p>
</li>
<li> <p><code>fontface</code>
</p>
</li>
<li> <p><code>group</code>
</p>
</li>
<li> <p><code>hjust</code>
</p>
</li>
<li> <p><code>lineheight</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li>
<li> <p><code>vjust</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
v &lt;- reshape2::melt(volcano)
g &lt;- ggplot(v, aes(Var1, Var2)) +
       geom_contour(aes(z = value))
g + geom_text_contour(aes(z = value))

g + geom_text_contour(aes(z = value), stroke = 0.2)

g + geom_text_contour(aes(z = value), stroke = 0.2, stroke.colour = "red")

g + geom_text_contour(aes(z = value, stroke.colour = after_stat(level)), stroke = 0.2) +
    scale_colour_gradient(aesthetics = "stroke.colour", guide = "none")

g + geom_text_contour(aes(z = value), rotate = FALSE)

g + geom_text_contour(aes(z = value),
                      label.placer = label_placer_random())

g + geom_text_contour(aes(z = value),
                      label.placer = label_placer_n(3))

g + geom_text_contour(aes(z = value),
                      label.placer = label_placer_flattest())

g + geom_text_contour(aes(z = value),
                      label.placer = label_placer_flattest(ref_angle = 90))

</code></pre>

<hr>
<h2 id='geom_relief'>Relief Shading</h2><span id='topic+geom_relief'></span><span id='topic+GeomRelief'></span><span id='topic+geom_shadow'></span><span id='topic+GeomShadow'></span>

<h3>Description</h3>

<p><code>geom_relief()</code> simulates shading caused by relief. Can be useful when
plotting topographic data because relief shading might give a more intuitive
impression of the shape of the terrain than contour lines or mapping height
to colour. <code>geom_shadow()</code> projects shadows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_relief(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  sun.angle = 60,
  raster = TRUE,
  interpolate = TRUE,
  shadow = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_shadow(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  sun.angle = 60,
  range = c(0, 1),
  skip = 0,
  raster = TRUE,
  interpolate = TRUE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_relief_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_relief_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_relief_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_relief_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_relief_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_relief_+3A_sun.angle">sun.angle</code></td>
<td>
<p>angle from which the sun is shining, in degrees
counterclockwise from 12 o' clock</p>
</td></tr>
<tr><td><code id="geom_relief_+3A_raster">raster</code></td>
<td>
<p>if <code>TRUE</code> (the default), uses <a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster</a>,
if <code>FALSE</code>, uses <a href="ggplot2.html#topic+geom_tile">ggplot2::geom_tile</a>.</p>
</td></tr>
<tr><td><code id="geom_relief_+3A_interpolate">interpolate</code></td>
<td>
<p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code>
(the default) don't interpolate.</p>
</td></tr>
<tr><td><code id="geom_relief_+3A_shadow">shadow</code></td>
<td>
<p>if TRUE, adds also a layer of <code>geom_shadow()</code></p>
</td></tr>
<tr><td><code id="geom_relief_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_relief_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_relief_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_relief_+3A_range">range</code></td>
<td>
<p>transparency range for shadows</p>
</td></tr>
<tr><td><code id="geom_relief_+3A_skip">skip</code></td>
<td>
<p>data points to skip when casting shadows</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>light</code> and <code>dark</code> must be valid colours determining the light and dark shading
(defaults to &quot;white&quot; and &quot;gray20&quot;, respectively).
</p>


<h3>Aesthetics</h3>

<p><code>geom_relief()</code> and <code>geom_shadow()</code> understands the following aesthetics (required aesthetics are in bold)
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>z</strong>
</p>
</li>
<li> <p><code>light</code>
</p>
</li>
<li> <p><code>dark</code>
</p>
</li>
<li> <p><code>sun.angle</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ggplot2)
ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +
      geom_relief(aes(z = value))

## End(Not run)
</code></pre>

<hr>
<h2 id='geom_streamline'>Streamlines</h2><span id='topic+geom_streamline'></span><span id='topic+stat_streamline'></span><span id='topic+StatStreamline'></span><span id='topic+GeomStreamline'></span>

<h3>Description</h3>

<p>Streamlines are paths that are always tangential to a vector field. In the
case of a steady field, it's identical to the path of a massless particle that
moves with the &quot;flow&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_streamline(
  mapping = NULL,
  data = NULL,
  stat = "streamline",
  position = "identity",
  ...,
  L = 5,
  min.L = 0,
  res = 1,
  S = NULL,
  dt = NULL,
  xwrap = NULL,
  ywrap = NULL,
  skip = 1,
  skip.x = skip,
  skip.y = skip,
  n = NULL,
  nx = n,
  ny = n,
  jitter = 1,
  jitter.x = jitter,
  jitter.y = jitter,
  arrow.angle = 6,
  arrow.length = 0.5,
  arrow.ends = "last",
  arrow.type = "closed",
  arrow = grid::arrow(arrow.angle, grid::unit(arrow.length, "lines"), ends = arrow.ends,
    type = arrow.type),
  lineend = "butt",
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_streamline(
  mapping = NULL,
  data = NULL,
  geom = "streamline",
  position = "identity",
  ...,
  L = 5,
  min.L = 0,
  res = 1,
  S = NULL,
  dt = NULL,
  xwrap = NULL,
  ywrap = NULL,
  skip = 1,
  skip.x = skip,
  skip.y = skip,
  n = NULL,
  nx = n,
  ny = n,
  jitter = 1,
  jitter.x = jitter,
  jitter.y = jitter,
  arrow.angle = 6,
  arrow.length = 0.5,
  arrow.ends = "last",
  arrow.type = "closed",
  arrow = grid::arrow(arrow.angle, grid::unit(arrow.length, "lines"), ends = arrow.ends,
    type = arrow.type),
  lineend = "butt",
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_streamline_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_streamline_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_streamline_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_streamline_+3A_l">L</code></td>
<td>
<p>typical length of a streamline in x and y units</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_min.l">min.L</code></td>
<td>
<p>minimum length of segments to show</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_res">res</code></td>
<td>
<p>resolution parameter (higher numbers increases the resolution)</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_s">S</code></td>
<td>
<p>optional numeric number of timesteps for integration</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_dt">dt</code></td>
<td>
<p>optional numeric size &quot;timestep&quot; for integration</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_xwrap">xwrap</code>, <code id="geom_streamline_+3A_ywrap">ywrap</code></td>
<td>
<p>vector of length two used to wrap the circular dimension.</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_skip">skip</code>, <code id="geom_streamline_+3A_skip.x">skip.x</code>, <code id="geom_streamline_+3A_skip.y">skip.y</code></td>
<td>
<p>numeric specifying number of gridpoints not to draw
in the x and y direction</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_n">n</code>, <code id="geom_streamline_+3A_nx">nx</code>, <code id="geom_streamline_+3A_ny">ny</code></td>
<td>
<p>optional numeric indicating the number of points to draw in the
x and y direction (replaces <code>skip</code> if not <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_jitter">jitter</code>, <code id="geom_streamline_+3A_jitter.x">jitter.x</code>, <code id="geom_streamline_+3A_jitter.y">jitter.y</code></td>
<td>
<p>amount of jitter of the starting points</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_arrow.length">arrow.length</code>, <code id="geom_streamline_+3A_arrow.angle">arrow.angle</code>, <code id="geom_streamline_+3A_arrow.ends">arrow.ends</code>, <code id="geom_streamline_+3A_arrow.type">arrow.type</code></td>
<td>
<p>parameters passed to
<a href="grid.html#topic+arrow">grid::arrow</a></p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_streamline_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data for this layer.
When using a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function to construct a layer, the <code>geom</code> argument
can be used to override the default coupling between stats and geoms. The
<code>geom</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Geom</code> ggproto subclass, for example <code>GeomPoint</code>.
</p>
</li>
<li><p> A string naming the geom. To give the geom as a string, strip the
function name of the <code>geom_</code> prefix. For example, to use <code>geom_point()</code>,
give the geom as <code>"point"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the geom, see the
<a href="ggplot2.html#topic+layer_geoms">layer geom</a> documentation.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Streamlines are computed by simple integration with a forward Euler method.
By default, <code>stat_streamline()</code> computes <code>dt</code> and <code>S</code> from <code>L</code>, <code>res</code>,
the resolution of the grid and the mean magnitude of the field. <code>S</code> is
then defined as the number of steps necessary to make a streamline of length
<code>L</code> under an uniform mean field and <code>dt</code> is chosen so that each step is no
larger than the resolution of the data (divided by the <code>res</code> parameter). Be
aware that this rule of thumb might fail in field with very skewed distribution
of magnitudes.
</p>
<p>Alternatively, <code>L</code> and/or <code>res</code> are ignored if <code>S</code> and/or <code>dt</code> are specified
explicitly. This not only makes it possible to fine-tune the result but also
divorces the integration parameters from the properties of the data and makes
it possible to compare streamlines between different fields.
</p>
<p>The starting grid is a semi regular grid defined, either by the resolution of the
field and the <code>skip.x</code> and <code>skip.y</code> parameters o the <code>nx</code> and <code>ny</code> parameters,
jittered by an amount proportional to the resolution of the data and the
<code>jitter.x</code> and <code>jitter.y</code> parameters.
</p>
<p>It might be important that the units of the vector field are compatible to the units
of the x and y dimensions. For example, passing <code>dx</code> and <code>dy</code> in m/s on a
longitude-latitude grid will might misleading results (see <a href="#topic+spherical">spherical</a>).
</p>
<p>Missing values are not permitted and the field must be defined on a
regular grid, for now.
</p>


<h3>Aesthetics</h3>

<p><code>stat_streamline</code> understands the following aesthetics (required aesthetics are in bold)
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>dx</strong>
</p>
</li>
<li> <p><strong>dy</strong>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>step</dt><dd><p>step in the simulation</p>
</dd>
<dt>dx</dt><dd><p>dx at each location of the streamline</p>
</dd>
<dt>dy</dt><dd><p>dy at each location of the streamline</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(data.table)
library(ggplot2)
data(geopotential)

geopotential &lt;- copy(geopotential)[date == date[1]]
geopotential[, gh.z := Anomaly(gh), by = .(lat)]
geopotential[, c("u", "v") := GeostrophicWind(gh.z, lon, lat)]

(g &lt;- ggplot(geopotential, aes(lon, lat)) +
    geom_contour2(aes(z = gh.z), xwrap = c(0, 360)) +
    geom_streamline(aes(dx = dlon(u, lat), dy = dlat(v)), L = 60,
                    xwrap = c(0, 360)))

# The circular parameter is particularly important for polar coordinates
g + coord_polar()

# If u and v are not converted into degrees/second, the resulting
# streamlines have problems, specially near the pole.
ggplot(geopotential, aes(lon, lat)) +
    geom_contour(aes(z = gh.z)) +
    geom_streamline(aes(dx = u, dy = v), L = 50)

# The step variable can be mapped to size or alpha to
# get cute "drops". It's important to note that after_stat(dx) (the calculated variable)
# is NOT the same as dx (from the data).
ggplot(geopotential, aes(lon, lat)) +
    geom_streamline(aes(dx = dlon(u, lat), dy = dlat(v), alpha = after_stat(step),
                        color = sqrt(after_stat(dx^2) + after_stat(dy^2)),
                        size = after_stat(step)),
                        L = 40, xwrap = c(0, 360), res = 2, arrow = NULL,
                        lineend = "round") +
    scale_size(range = c(0, 0.6))

# Using topographic information to simulate "rivers" from slope
topo &lt;- GetTopography(295, -55+360, -30, -42, res = 1/20)  # needs internet!
topo[, c("dx", "dy") := Derivate(h ~ lon + lat)]
topo[h &lt;= 0, c("dx", "dy") := 0]

# See how in this example the integration step is too coarse in the
# western montanous region where the slope is much higher than in the
# flatlands of La Pampa at in the east.
ggplot(topo, aes(lon, lat)) +
    geom_relief(aes(z = h), interpolate = TRUE, data = topo[h &gt;= 0]) +
    geom_contour(aes(z = h), breaks = 0, color = "black") +
    geom_streamline(aes(dx = -dx, dy = -dy), L = 10, skip = 3, arrow = NULL,
                    color = "#4658BD") +
    coord_quickmap()
 
## End(Not run)

</code></pre>

<hr>
<h2 id='geopotential'>Geopotential height</h2><span id='topic+geopotential'></span>

<h3>Description</h3>

<p>Monthly geopotential field at 700hPa south of 20°S from January 1990 to
December 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geopotential
</code></pre>


<h3>Format</h3>

<p>A data.table with 53224 rows and 5 variables.
</p>

<dl>
<dt>lon</dt><dd><p>longitude in degrees</p>
</dd>
<dt>lat</dt><dd><p>latitude in degrees</p>
</dd>
<dt>lev</dt><dd><p>level in hPa</p>
</dd>
<dt>gh</dt><dd><p>geopotential height in meters</p>
</dd>
<dt>date</dt><dd><p>date</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://psl.noaa.gov/data/gridded/data.ncep.reanalysis.derived.pressure.html">https://psl.noaa.gov/data/gridded/data.ncep.reanalysis.derived.pressure.html</a>
</p>

<hr>
<h2 id='GeostrophicWind'>Calculate geostrophic winds</h2><span id='topic+GeostrophicWind'></span>

<h3>Description</h3>

<p>Geostrophic wind from a geopotential height field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeostrophicWind(gh, lon, lat, cyclical = "guess", g = 9.81, a = 6371000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GeostrophicWind_+3A_gh">gh</code></td>
<td>
<p>geopotential height</p>
</td></tr>
<tr><td><code id="GeostrophicWind_+3A_lon">lon</code></td>
<td>
<p>longitude in degrees</p>
</td></tr>
<tr><td><code id="GeostrophicWind_+3A_lat">lat</code></td>
<td>
<p>latitude in degrees</p>
</td></tr>
<tr><td><code id="GeostrophicWind_+3A_cyclical">cyclical</code></td>
<td>
<p>boundary condition for longitude (see details)</p>
</td></tr>
<tr><td><code id="GeostrophicWind_+3A_g">g</code></td>
<td>
<p>acceleration of gravity</p>
</td></tr>
<tr><td><code id="GeostrophicWind_+3A_a">a</code></td>
<td>
<p>Earth's radius</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>cyclical = "guess"</code> (the default) the function will try to guess if <code>lon</code>
covers the whole globe and set cyclical conditions accordingly. For more
predictable results, set the boundary condition explicitly.
</p>


<h3>Value</h3>

<p>A named list with vectors for the zonal and meridional component of geostrophic
wind.
</p>


<h3>See Also</h3>

<p>Other meteorology functions: 
<code><a href="#topic+Derivate">Derivate</a>()</code>,
<code><a href="#topic+EOF">EOF</a>()</code>,
<code><a href="#topic+WaveFlux">WaveFlux</a>()</code>,
<code><a href="#topic+thermodynamics">thermodynamics</a></code>,
<code><a href="#topic+waves">waves</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geopotential)
geopotential &lt;- data.table::copy(geopotential)
geopotential[date == date[1], c("u", "v") := GeostrophicWind(gh, lon, lat)]
library(ggplot2)
ggplot(geopotential[date == date[1]], aes(lon, lat)) +
    geom_contour(aes(z = gh)) +
    geom_vector(aes(dx = u, dy = v), skip = 2) +
    scale_mag()

</code></pre>

<hr>
<h2 id='GetSMNData'>Get Meteorological data
This function is defunct.</h2><span id='topic+GetSMNData'></span>

<h3>Description</h3>

<p>Get Meteorological data
This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSMNData(
  date,
  type = c("hourly", "daily", "radiation"),
  bar = FALSE,
  cache = TRUE,
  file.dir = tempdir()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetSMNData_+3A_date">date</code></td>
<td>
<p>date vector of dates to fetch data</p>
</td></tr>
<tr><td><code id="GetSMNData_+3A_type">type</code></td>
<td>
<p>type of data to retrieve</p>
</td></tr>
<tr><td><code id="GetSMNData_+3A_bar">bar</code></td>
<td>
<p>logical object indicating whether to show a progress bar</p>
</td></tr>
<tr><td><code id="GetSMNData_+3A_cache">cache</code></td>
<td>
<p>logical indicating if the results should be saved on disk</p>
</td></tr>
<tr><td><code id="GetSMNData_+3A_file.dir">file.dir</code></td>
<td>
<p>optional directory where to save and/or retrieve data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='GetTopography'>Get topographic data</h2><span id='topic+GetTopography'></span>

<h3>Description</h3>

<p>Retrieves topographic data from ETOPO1 Global Relief Model (see references).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetTopography(
  lon.west,
  lon.east,
  lat.north,
  lat.south,
  resolution = 3.5,
  cache = TRUE,
  file.dir = tempdir(),
  verbose = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetTopography_+3A_lon.west">lon.west</code>, <code id="GetTopography_+3A_lon.east">lon.east</code>, <code id="GetTopography_+3A_lat.north">lat.north</code>, <code id="GetTopography_+3A_lat.south">lat.south</code></td>
<td>
<p>latitudes and longitudes of the
bounding box in degrees</p>
</td></tr>
<tr><td><code id="GetTopography_+3A_resolution">resolution</code></td>
<td>
<p>numeric vector indicating the desired resolution (in degrees)
in the lon and lat directions (maximum resolution is 1 minute)</p>
</td></tr>
<tr><td><code id="GetTopography_+3A_cache">cache</code></td>
<td>
<p>logical indicating if the results should be saved on disk</p>
</td></tr>
<tr><td><code id="GetTopography_+3A_file.dir">file.dir</code></td>
<td>
<p>optional directory where to save and/or retrieve data</p>
</td></tr>
<tr><td><code id="GetTopography_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether to print progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Very large requests can take long and can be denied by the NOAA server.
If the function fails, try with a smaller bounding box or coarser resolution.
</p>
<p>Longitude coordinates must be between 0 and 360.
</p>


<h3>Value</h3>

<p>A data table with height (in meters) for each longitude and latitude.
</p>


<h3>References</h3>

<p>Source: Amante, C. and B.W. Eakins, 2009. ETOPO1 1 Arc-Minute Global Relief Model: Procedures, Data Sources and Analysis. NOAA Technical Memorandum NESDIS NGDC-24. National Geophysical Data Center, NOAA.  <a href="https://doi.org/10.7289/V5C8276M">doi:10.7289/V5C8276M</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
topo &lt;- GetTopography(280, 330, 0, -60, resolution = 0.5)
library(ggplot2)
ggplot(topo, aes(lon, lat)) +
    geom_raster(aes(fill = h)) +
    geom_contour(aes(z = h), breaks = 0, color = "black", size = 0.3) +
    scale_fill_gradient2(low = "steelblue", high = "goldenrod2", mid = "olivedrab") +
    coord_quickmap()

## End(Not run)
</code></pre>

<hr>
<h2 id='guide_colourstrip'>Discretized continuous colour guide</h2><span id='topic+guide_colourstrip'></span><span id='topic+guide_train.colorstrip'></span><span id='topic+guide_geom.colorstrip'></span><span id='topic+guide_colorstrip'></span><span id='topic+guide_gengrob.colorstrip'></span>

<h3>Description</h3>

<p>A version of <a href="ggplot2.html#topic+guide_colourbar">ggplot2::guide_colourbar</a> that displays discretized values and,
by default, puts labels in between values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_colourstrip(
  title = ggplot2::waiver(),
  title.position = NULL,
  title.theme = NULL,
  title.hjust = NULL,
  title.vjust = NULL,
  label = TRUE,
  label.position = NULL,
  label.theme = NULL,
  label.hjust = NULL,
  label.vjust = NULL,
  barwidth = NULL,
  barheight = NULL,
  ticks = FALSE,
  draw.ulim = TRUE,
  draw.llim = TRUE,
  inside = FALSE,
  direction = NULL,
  default.unit = "line",
  reverse = FALSE,
  order = 0,
  available_aes = c("colour", "color", "fill"),
  ...
)

guide_colorstrip(
  title = ggplot2::waiver(),
  title.position = NULL,
  title.theme = NULL,
  title.hjust = NULL,
  title.vjust = NULL,
  label = TRUE,
  label.position = NULL,
  label.theme = NULL,
  label.hjust = NULL,
  label.vjust = NULL,
  barwidth = NULL,
  barheight = NULL,
  ticks = FALSE,
  draw.ulim = TRUE,
  draw.llim = TRUE,
  inside = FALSE,
  direction = NULL,
  default.unit = "line",
  reverse = FALSE,
  order = 0,
  available_aes = c("colour", "color", "fill"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guide_colourstrip_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="ggplot2.html#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="ggplot2.html#topic+labs">labs()</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_colourstrip_+3A_draw.ulim">draw.ulim</code></td>
<td>
<p>A logical specifying if the upper limit tick marks should
be visible.</p>
</td></tr>
<tr><td><code id="guide_colourstrip_+3A_draw.llim">draw.llim</code></td>
<td>
<p>A logical specifying if the lower limit tick marks should
be visible.</p>
</td></tr>
<tr><td><code id="guide_colourstrip_+3A_inside">inside</code></td>
<td>
<p>logical indicating where to position labels (see examples).</p>
</td></tr>
<tr><td><code id="guide_colourstrip_+3A_direction">direction</code></td>
<td>
<p>A character string indicating the direction of the guide.
One of &quot;horizontal&quot; or &quot;vertical.&quot;</p>
</td></tr>
<tr><td><code id="guide_colourstrip_+3A_reverse">reverse</code></td>
<td>
<p>logical. If <code>TRUE</code> the colourbar is reversed. By default,
the highest value is on the top and the lowest value is on the bottom</p>
</td></tr>
<tr><td><code id="guide_colourstrip_+3A_order">order</code></td>
<td>
<p>positive integer less than 99 that specifies the order of
this guide among multiple guides. This controls the order in which
multiple guides are displayed, not the contents of the guide itself.
If 0 (default), the order is determined by a secret algorithm.</p>
</td></tr>
<tr><td><code id="guide_colourstrip_+3A_available_aes">available_aes</code></td>
<td>
<p>A vector of character strings listing the aesthetics
for which a colourbar can be drawn.</p>
</td></tr>
<tr><td><code id="guide_colourstrip_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="guide_colourstrip_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="ggplot2.html#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default behaviour works fell for geom_contour_fill in which the colours
represent the value between contour surfaces.
</p>
<p>'inside = TRUE&ldquo; works better for geom_tile where the colour represents
the value of the data and is very similar to <a href="ggplot2.html#topic+guide_legend">ggplot2::guide_legend</a>.
</p>


<h3>Value</h3>

<p>A guide object.
</p>


<h3>See Also</h3>

<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In this example the lowest colour represents an area of the data with values
# between 80 and 100.
library(ggplot2)
binwidth &lt;- 20
data(volcano)
ggplot(reshape2::melt(volcano), aes(Var1, Var2, z = value)) +
    geom_contour_fill(binwidth = binwidth) +
    scale_fill_continuous(guide = guide_colourstrip(),
                         breaks = MakeBreaks(binwidth))

# Difference between guide_legend() and guide_colorbar2(inside = T)
df &lt;- reshape2::melt(outer(1:4, 1:4), varnames = c("X1", "X2"))
g &lt;- ggplot(df, aes(X1, X2)) +
        geom_tile(aes(fill = value)) +
        theme(legend.position = "bottom")

# Tick labels are to the side
g + scale_fill_continuous(guide = guide_legend())
# Tick labels are at the bottom
g + scale_fill_continuous(guide = guide_colourstrip(inside = TRUE))

</code></pre>

<hr>
<h2 id='Impute2D'>Impute missing values by linear or constant interpolation</h2><span id='topic+Impute2D'></span>

<h3>Description</h3>

<p>Provides methods for (soft) imputation of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Impute2D(formula, data = NULL, method = "interpolate")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Impute2D_+3A_formula">formula</code></td>
<td>
<p>a formula indicating dependent and independent variables (see Details)</p>
</td></tr>
<tr><td><code id="Impute2D_+3A_data">data</code></td>
<td>
<p>optional data.frame with the data</p>
</td></tr>
<tr><td><code id="Impute2D_+3A_method">method</code></td>
<td>
<p>&quot;interpolate&quot; for interpolation, a numeric for constant imputation
or a function that takes a vector and returns a number (like <a href="base.html#topic+mean">mean</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is &quot;soft&quot; imputation because the imputed values are not supposed to be
representative of the missing data but just filling for algorithms that need
complete data (in particular, contouring). The method used if
<code>method = "interpolate"</code> is to do simple linear interpolation in both the x and y
direction and then average the result.
</p>
<p>This is the imputation method used by <code><a href="#topic+geom_contour_fill">geom_contour_fill()</a></code>.
</p>

<hr>
<h2 id='ImputeEOF'>Impute missing values</h2><span id='topic+ImputeEOF'></span>

<h3>Description</h3>

<p>Imputes missing values via Data Interpolating Empirical Orthogonal Functions
(DINEOF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImputeEOF(
  formula,
  max.eof = NULL,
  data = NULL,
  min.eof = 1,
  tol = 0.01,
  max.iter = 10000,
  validation = NULL,
  verbose = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ImputeEOF_+3A_formula">formula</code></td>
<td>
<p>a formula to build the matrix that will be used in the SVD
decomposition (see Details)</p>
</td></tr>
<tr><td><code id="ImputeEOF_+3A_max.eof">max.eof</code>, <code id="ImputeEOF_+3A_min.eof">min.eof</code></td>
<td>
<p>maximum and minimum number of singular values used for
imputation</p>
</td></tr>
<tr><td><code id="ImputeEOF_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="ImputeEOF_+3A_tol">tol</code></td>
<td>
<p>tolerance used for determining convergence</p>
</td></tr>
<tr><td><code id="ImputeEOF_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum iterations allowed for the algorithm</p>
</td></tr>
<tr><td><code id="ImputeEOF_+3A_validation">validation</code></td>
<td>
<p>number of points to use in cross-validation (defaults to the
maximum of 30 or 10% of the non NA points)</p>
</td></tr>
<tr><td><code id="ImputeEOF_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether to print progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Singular values can be computed over matrices so <code>formula</code> denotes how
to build a matrix from the data. It is a formula of the form VAR ~ LEFT | RIGHT
(see <a href="Formula.html#topic+Formula">Formula::Formula</a>) in which VAR is the variable whose values will
populate the matrix, and LEFT represent the variables used to make the rows
and RIGHT, the columns of the matrix.
Think it like &quot;VAR <em>as a function</em> of LEFT <em>and</em> RIGHT&quot;.
</p>
<p>Alternatively, if <code>value.var</code> is not <code>NULL</code>, it's possible to use the
(probably) more familiar <a href="data.table.html#topic+dcast.data.table">data.table::dcast</a> formula interface. In that case,
<code>data</code> must be provided.
</p>
<p>If <code>data</code> is a matrix, the <code>formula</code> argument is ignored and the function
returns a matrix.
</p>


<h3>Value</h3>

<p>A vector of imputed values with attributes <code>eof</code>, which is the number of
singular values used in the final imputation; and <code>rmse</code>, which is the Root
Mean Square Error estimated from cross-validation.
</p>


<h3>References</h3>

<p>Beckers, J.-M., Barth, A., and Alvera-Azcárate, A.: DINEOF reconstruction of clouded images including error maps – application to the Sea-Surface Temperature around Corsican Island, Ocean Sci., 2, 183-199, <a href="https://doi.org/10.5194/os-2-183-2006">doi:10.5194/os-2-183-2006</a>, 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data(geopotential)
geopotential &lt;- copy(geopotential)
geopotential[, gh.t := Anomaly(gh), by = .(lat, lon, month(date))]

# Add gaps to field
geopotential[, gh.gap := gh.t]
set.seed(42)
geopotential[sample(1:.N, .N*0.3), gh.gap := NA]

max.eof &lt;- 5    # change to a higher value
geopotential[, gh.impute := ImputeEOF(gh.gap ~ lat + lon | date, max.eof,
                                      verbose = TRUE, max.iter = 2000)]

library(ggplot2)
ggplot(geopotential[date == date[1]], aes(lon, lat)) +
    geom_contour(aes(z = gh.t), color = "black") +
    geom_contour(aes(z = gh.impute))

# Scatterplot with a sample.
na.sample &lt;- geopotential[is.na(gh.gap)][sample(1:.N, .N*0.1)]
ggplot(na.sample, aes(gh.t, gh.impute)) +
    geom_point()

# Estimated RMSE
attr(geopotential$gh.impute, "rmse")
# Real RMSE
geopotential[is.na(gh.gap), sqrt(mean((gh.t - gh.impute)^2))]


</code></pre>

<hr>
<h2 id='Interpolate'>Bilinear interpolation</h2><span id='topic+Interpolate'></span>

<h3>Description</h3>

<p>Interpolates values using bilinear interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Interpolate(formula, x.out, y.out, data = NULL, grid = TRUE, path = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Interpolate_+3A_formula">formula</code></td>
<td>
<p>a formula indicating dependent and independent variables (see Details)</p>
</td></tr>
<tr><td><code id="Interpolate_+3A_x.out">x.out</code>, <code id="Interpolate_+3A_y.out">y.out</code></td>
<td>
<p>x and y values where to interpolate (see Details)</p>
</td></tr>
<tr><td><code id="Interpolate_+3A_data">data</code></td>
<td>
<p>optional data.frame with the data</p>
</td></tr>
<tr><td><code id="Interpolate_+3A_grid">grid</code></td>
<td>
<p>logical indicating if x.out and y.out define a regular grid.</p>
</td></tr>
<tr><td><code id="Interpolate_+3A_path">path</code></td>
<td>
<p>a logical or character indicating if the x.out and y.out define a
path. If character, it will be the name of the column returning the order of
said path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>formula</code> must be of the form VAR1 | VAR2 ~ X + Y where VAR1, VAR2, etc...
are the names of the variables to interpolate and X and Y the names of the
x and y values, respectively. It is also possible to pass only values of x,
in which case, regular linear interpolation is performed and y.out, if exists,
is ignored with a warning.
</p>
<p>If <code>grid = TRUE</code>, <code>x.out</code> and <code>y.out</code> must define the values of a regular
grid. If <code>grid = FALSE</code>, they define the locations where to interpolate.
Both <code>grid</code> and <code>path</code> cannot be set to <code>TRUE</code> and the value of <code>path</code> takes
precedence.
</p>
<p><code>x.out</code> can be a list, in which case, the first two elements will be interpreted
as the x and y values where to interpolate and it can also have a <code>path</code> element
that will be used in place of the <code>path</code> argument. This helps when creating a
path with <a href="#topic+as.path">as.path</a> (see Examples)
</p>


<h3>Value</h3>

<p>A data.frame with interpolated values and locations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data(geopotential)
geopotential &lt;- geopotential[date == date[1]]
# new grid
x.out &lt;- seq(0, 360, by = 10)
y.out &lt;- seq(-90, 0, by = 10)

# Interpolate values to a new grid
interpolated &lt;- geopotential[, Interpolate(gh ~ lon + lat, x.out, y.out)]

# Add values to an existing grid
geopotential[, gh.new := Interpolate(gh ~ lon + lat, lon, lat,
                                     data = interpolated, grid = FALSE)$gh]

# Interpolate multiple values
geopotential[, c("u", "v") := GeostrophicWind(gh, lon, lat)]
interpolated &lt;- geopotential[, Interpolate(u | v ~ lon + lat, x.out, y.out)]

# Interpolate values following a path
lats &lt;- c(-34, -54, -30)   # start and end latitudes
lons &lt;- c(302, 290, 180)   # start and end longituded
path &lt;- geopotential[, Interpolate(gh ~ lon + lat, as.path(lons, lats))]

</code></pre>

<hr>
<h2 id='is.cross'>Cross pattern</h2><span id='topic+is.cross'></span><span id='topic+cross'></span>

<h3>Description</h3>

<p>Reduces the density of a regular grid using a cross pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.cross(x, y, skip = 0)

cross(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.cross_+3A_x">x</code>, <code id="is.cross_+3A_y">y</code></td>
<td>
<p>x and y points that define a regular grid.</p>
</td></tr>
<tr><td><code id="is.cross_+3A_skip">skip</code></td>
<td>
<p>how many points to skip. Greater value reduces the final point density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.cross</code> returns a logical vector indicating whether each point belongs to the
reduced grid or not.
<code>cross</code> returns a list of x and y components of the reduced density grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic usage
grid &lt;- expand.grid(x = 1:10, y = 1:10)
cross &lt;- is.cross(grid$x, grid$y, skip = 2)

with(grid, plot(x, y))
with(grid, points(x[cross], y[cross], col = "red"))

# Its intended use is to highlight areas with geom_subset()
# with reduced densnity. This "hatches" areas with temperature
# over 270K
library(ggplot2)
ggplot(temperature[lev == 500], aes(lon, lat)) +
  geom_raster(aes(fill = air)) +
  stat_subset(aes(subset = air &gt; 270 &amp; is.cross(lon, lat)),
              geom = "point", size = 0.1)

</code></pre>

<hr>
<h2 id='JumpBy'>Skip observations</h2><span id='topic+JumpBy'></span>

<h3>Description</h3>

<p>Skip observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JumpBy(x, by, start = 1, fill = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JumpBy_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="JumpBy_+3A_by">by</code></td>
<td>
<p>numeric interval between elements to keep</p>
</td></tr>
<tr><td><code id="JumpBy_+3A_start">start</code></td>
<td>
<p>index to start from</p>
</td></tr>
<tr><td><code id="JumpBy_+3A_fill">fill</code></td>
<td>
<p>how observations are skipped</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mostly useful for labelling only every <code>by</code>th element.
</p>


<h3>Value</h3>

<p>A vector of the same class as x and, if <code>fill</code> is not <code>null</code>,
the same length.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Anomaly">Anomaly</a>()</code>,
<code><a href="#topic+Mag">Mag</a>()</code>,
<code><a href="#topic+Percentile">Percentile</a>()</code>,
<code><a href="#topic+logic">logic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:50
JumpBy(x, 2)   # only odd numbers
JumpBy(x, 2, start = 2)   # only even numbers
JumpBy(x, 2, fill = NA)   # even numbers replaced by NA
JumpBy(x, 2, fill = 6)   # even numbers replaced by 6

</code></pre>

<hr>
<h2 id='label_placers'>Functions to place contour labels</h2><span id='topic+label_placers'></span><span id='topic+label_placer_fraction'></span><span id='topic+label_placement_fraction'></span><span id='topic+label_placer_n'></span><span id='topic+label_placement_n'></span><span id='topic+label_placer_random'></span><span id='topic+label_placement_random'></span><span id='topic+label_placer_all'></span><span id='topic+label_placement_all'></span><span id='topic+label_placer_flattest'></span><span id='topic+label_placement_flattest'></span><span id='topic+label_placer_minmax'></span><span id='topic+label_placement_minmax'></span>

<h3>Description</h3>

<p>These functions compute the position of contour labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_placer_fraction(
  frac = 0.5,
  rot_adjuster = isoband::angle_halfcircle_bottom()
)

label_placement_fraction(
  frac = 0.5,
  rot_adjuster = isoband::angle_halfcircle_bottom()
)

label_placer_n(n = 2, rot_adjuster = isoband::angle_halfcircle_bottom())

label_placement_n(n = 2, rot_adjuster = isoband::angle_halfcircle_bottom())

label_placer_random(
  seed = 42,
  n = 1,
  rot_adjuster = isoband::angle_halfcircle_bottom()
)

label_placement_random(
  seed = 42,
  n = 1,
  rot_adjuster = isoband::angle_halfcircle_bottom()
)

label_placer_all(rot_adjuster = isoband::angle_halfcircle_bottom())

label_placement_all(rot_adjuster = isoband::angle_halfcircle_bottom())

label_placer_flattest(
  ref_angle = 0,
  rot_adjuster = isoband::angle_halfcircle_bottom()
)

label_placement_flattest(
  ref_angle = 0,
  rot_adjuster = isoband::angle_halfcircle_bottom()
)

label_placer_minmax(
  direction = c("vertical", "horizontal"),
  rot_adjuster = isoband::angle_halfcircle_bottom()
)

label_placement_minmax(
  direction = c("vertical", "horizontal"),
  rot_adjuster = isoband::angle_halfcircle_bottom()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_placers_+3A_frac">frac</code></td>
<td>
<p>A numeric vector with values between 0 and 1 representing
where in the contour to put labels (i.e. <code>frac = 0.5</code> puts labels
at the midpoint).</p>
</td></tr>
<tr><td><code id="label_placers_+3A_rot_adjuster">rot_adjuster</code></td>
<td>
<p>A function that standardizes the rotation angles of the labels.
See e.g. <a href="isoband.html#topic+angle_halfcircle_bottom">isoband::angle_halfcircle_bottom</a>.</p>
</td></tr>
<tr><td><code id="label_placers_+3A_n">n</code></td>
<td>
<p>Number of labels to put.</p>
</td></tr>
<tr><td><code id="label_placers_+3A_seed">seed</code></td>
<td>
<p>Seed to use for randomly choosing where to put labels.</p>
</td></tr>
<tr><td><code id="label_placers_+3A_ref_angle">ref_angle</code></td>
<td>
<p>Angle (in degrees counter-clockwise from East) to try
to approximate labels.</p>
</td></tr>
<tr><td><code id="label_placers_+3A_direction">direction</code></td>
<td>
<p>Direction in which to compute the maximum and minimum.</p>
</td></tr>
</table>

<hr>
<h2 id='logic'>Extended logical operators</h2><span id='topic+logic'></span><span id='topic++25~+25'></span><span id='topic+Similar'></span>

<h3>Description</h3>

<p>Extended binary operators for easy subsetting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %~% target

Similar(x, target, tol = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logic_+3A_x">x</code>, <code id="logic_+3A_target">target</code></td>
<td>
<p>numeric vectors</p>
</td></tr>
<tr><td><code id="logic_+3A_tol">tol</code></td>
<td>
<p>tolerance for similarity</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>%~%</code> can be thought as a &quot;similar&quot; operator. It's a fuzzy version of
<code><a href="base.html#topic++25in+25">%in%</a></code> in that returns <code>TRUE</code> for the element of <code>x</code>
which is the (first) closest to any element of <code>target</code>.
</p>
<p><code>Similar</code> is a functional version of <code>%~%</code> that also has a
<code>tol</code> parameter that indicates the maximum allowed tolerance.
</p>


<h3>Value</h3>

<p>A logical vector of the same length of x.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Anomaly">Anomaly</a>()</code>,
<code><a href="#topic+JumpBy">JumpBy</a>()</code>,
<code><a href="#topic+Mag">Mag</a>()</code>,
<code><a href="#topic+Percentile">Percentile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(198)
x &lt;- rnorm(100)
x[x %~% c(0.3, 0.5, 1)]

# Practical use case: vertical cross-section at
# approximately 36W between 50S and 50N.
cross.lon &lt;- -34 + 360
library(ggplot2)
library(data.table)
ggplot(temperature[lon %~% cross.lon &amp; lat %between% c(-50, 50)],
       aes(lat, lev)) +
    geom_contour(aes(z = air))

</code></pre>

<hr>
<h2 id='Mag'>Magnitude and angle of a vector</h2><span id='topic+Mag'></span><span id='topic+Angle'></span>

<h3>Description</h3>

<p>Computes the magnitude of a vector of any dimension. Or angle (in degrees)
in 2 dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mag(...)

Angle(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mag_+3A_...">...</code></td>
<td>
<p>numeric vectors of coordinates or list of coordinates</p>
</td></tr>
<tr><td><code id="Mag_+3A_x">x</code>, <code id="Mag_+3A_y">y</code></td>
<td>
<p>x and y directions of the vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helpful to save keystrokes and gain readability when computing wind
(or any other vector quantity) magnitude.
</p>


<h3>Value</h3>

<p><code>Mag</code>: A numeric vector the same length as each element of ...
that is <code class="reqn">\sqrt(x^2 + y^2 + ...)</code>.
<code>Angle</code>: A numeric vector of the same length as x and y that is
<code>atan2(y, x)*180/pi</code>.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Anomaly">Anomaly</a>()</code>,
<code><a href="#topic+JumpBy">JumpBy</a>()</code>,
<code><a href="#topic+Percentile">Percentile</a>()</code>,
<code><a href="#topic+logic">logic</a></code>
</p>
<p>Other utilities: 
<code><a href="#topic+Anomaly">Anomaly</a>()</code>,
<code><a href="#topic+JumpBy">JumpBy</a>()</code>,
<code><a href="#topic+Percentile">Percentile</a>()</code>,
<code><a href="#topic+logic">logic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Mag(10, 10)
Angle(10, 10)
Mag(10, 10, 10, 10)
Mag(list(10, 10, 10, 10))

# There's no vector recicling!
## Not run: 
Mag(1, 1:2)

## End(Not run)

</code></pre>

<hr>
<h2 id='MakeBreaks'>Functions for making breaks</h2><span id='topic+MakeBreaks'></span><span id='topic+AnchorBreaks'></span>

<h3>Description</h3>

<p>Functions that return functions suitable to use as the <code>breaks</code> argument in
ggplot2's continuous scales and in <a href="#topic+geom_contour_fill">geom_contour_fill</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeBreaks(binwidth = NULL, bins = 10, exclude = NULL)

AnchorBreaks(anchor = 0, binwidth = NULL, exclude = NULL, bins = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakeBreaks_+3A_binwidth">binwidth</code></td>
<td>
<p>width of breaks</p>
</td></tr>
<tr><td><code id="MakeBreaks_+3A_bins">bins</code></td>
<td>
<p>number of bins, used if <code>binwidth = NULL</code></p>
</td></tr>
<tr><td><code id="MakeBreaks_+3A_exclude">exclude</code></td>
<td>
<p>a vector of breaks to exclude</p>
</td></tr>
<tr><td><code id="MakeBreaks_+3A_anchor">anchor</code></td>
<td>
<p>anchor value</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MakeBreaks</code> is essentially an export of the default way
<a href="ggplot2.html#topic+geom_contour">ggplot2::stat_contour</a> makes breaks.
</p>
<p><code>AnchorBreaks</code> makes breaks starting from an <code>anchor</code> value and covering
the range of the data according to <code>binwidth</code>.
</p>


<h3>Value</h3>

<p>A function that takes a range as argument and a binwidth as an optional argument
and returns a sequence of equally spaced intervals covering the range.
</p>


<h3>See Also</h3>

<p>Other ggplot2 helpers: 
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my_breaks &lt;- MakeBreaks(10)
my_breaks(c(1, 100))
my_breaks(c(1, 100), 20)    # optional new binwidth argument ignored

MakeBreaks()(c(1, 100), 20)  # but is not ignored if initial binwidth is NULL

# One to one mapping between contours and breaks
library(ggplot2)
binwidth &lt;- 20
ggplot(reshape2::melt(volcano), aes(Var1, Var2, z = value)) +
    geom_contour(aes(color = after_stat(level)), binwidth = binwidth) +
    scale_color_continuous(breaks = MakeBreaks(binwidth))

#Two ways of getting the same contours. Better use the second one.
ggplot(reshape2::melt(volcano), aes(Var1, Var2, z = value)) +
    geom_contour2(aes(color = after_stat(level)), breaks = AnchorBreaks(132),
                  binwidth = binwidth) +
    geom_contour2(aes(color = after_stat(level)), breaks = AnchorBreaks(132, binwidth)) +
    scale_color_continuous(breaks = AnchorBreaks(132, binwidth))

</code></pre>

<hr>
<h2 id='map_labels'>Label longitude and latitude</h2><span id='topic+map_labels'></span><span id='topic+LonLabel'></span><span id='topic+LatLabel'></span>

<h3>Description</h3>

<p>Provide easy functions for adding suffixes to longitude and latitude for labelling
maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LonLabel(lon, east = "°E", west = "°W", zero = "°")

LatLabel(lat, north = "°N", south = "°S", zero = "°")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_labels_+3A_lon">lon</code></td>
<td>
<p>longitude in degrees</p>
</td></tr>
<tr><td><code id="map_labels_+3A_east">east</code>, <code id="map_labels_+3A_west">west</code>, <code id="map_labels_+3A_north">north</code>, <code id="map_labels_+3A_south">south</code>, <code id="map_labels_+3A_zero">zero</code></td>
<td>
<p>text to append for each quadrant</p>
</td></tr>
<tr><td><code id="map_labels_+3A_lat">lat</code></td>
<td>
<p>latitude in degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default values are for Spanish.
</p>


<h3>See Also</h3>

<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
LonLabel(0:360)

</code></pre>

<hr>
<h2 id='MaskLand'>Mask</h2><span id='topic+MaskLand'></span>

<h3>Description</h3>

<p>Creates a  mask
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaskLand(lon, lat, mask = "world", wrap = c(0, 360))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaskLand_+3A_lon">lon</code></td>
<td>
<p>a vector of longitudes in degrees in 0-360 format</p>
</td></tr>
<tr><td><code id="MaskLand_+3A_lat">lat</code></td>
<td>
<p>a vector of latitudes in degrees</p>
</td></tr>
<tr><td><code id="MaskLand_+3A_mask">mask</code></td>
<td>
<p>the name of the dataset (that will be load with
<code><a href="maps.html#topic+map">map</a></code>) for creating the mask</p>
</td></tr>
<tr><td><code id="MaskLand_+3A_wrap">wrap</code></td>
<td>
<p>the longitude range to be used for a global mask</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as lat and lon where <code>TRUE</code> means
that the point is inside one of the polygons making up the map. For a global
map (the default), this means that the point is over land.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Make a sea-land mask
mask &lt;- temperature[lev == 1000, .(lon = lon, lat = lat, land = MaskLand(lon, lat))]
temperature &lt;- temperature[mask, on = c("lon", "lat")]
library(ggplot2)

ggplot(mask, aes(lon, lat)) +
   geom_raster(aes(fill = land))

# Take the temperature difference between land and ocean
diftemp &lt;- temperature[,
          .(tempdif = mean(air[land == TRUE]) - mean(air[land == FALSE])),
           by = .(lat, lev)]

ggplot(diftemp, aes(lat, lev)) +
    geom_contour(aes(z = tempdif, color = after_stat(level))) +
    scale_y_level() +
    scale_x_latitude() +
    scale_color_divergent()


</code></pre>

<hr>
<h2 id='Percentile'>Percentiles</h2><span id='topic+Percentile'></span>

<h3>Description</h3>

<p>Computes percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Percentile(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Percentile_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as x with the percentile of each value
of x.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Anomaly">Anomaly</a>()</code>,
<code><a href="#topic+JumpBy">JumpBy</a>()</code>,
<code><a href="#topic+Mag">Mag</a>()</code>,
<code><a href="#topic+logic">logic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
p &lt;- Percentile(x)

</code></pre>

<hr>
<h2 id='ReadNetCDF'>Read NetCDF files.</h2><span id='topic+ReadNetCDF'></span><span id='topic+GlanceNetCDF'></span>

<h3>Description</h3>

<p>Using the <code><a href="ncdf4.html#topic+ncdf4-package">ncdf4-package</a></code> package, it reads a NetCDF file. The advantage
over using <code><a href="ncdf4.html#topic+ncvar_get">ncvar_get</a></code> is that the output is a tidy data.table
with proper dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadNetCDF(
  file,
  vars = NULL,
  out = c("data.frame", "vector", "array"),
  subset = NULL,
  key = FALSE
)

GlanceNetCDF(file, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadNetCDF_+3A_file">file</code></td>
<td>
<p>source to read from. Must be one of:
</p>

<ul>
<li><p> A string representing a local file with read access.
</p>
</li>
<li><p> A string representing a URL readable by <code><a href="ncdf4.html#topic+nc_open">ncdf4::nc_open()</a></code>.
(this includes DAP urls).
</p>
</li>
<li><p> A netcdf object returned by <code><a href="ncdf4.html#topic+nc_open">ncdf4::nc_open()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadNetCDF_+3A_vars">vars</code></td>
<td>
<p>one of:
</p>

<ul>
<li> <p><code>NULL</code>: reads all variables.
</p>
</li>
<li><p> a character vector with the name of the variables to read.
</p>
</li>
<li><p> a function that takes a vector with all the variables and returns either
a character vector with the name of variables to read or a numeric/logical
vector that indicates a subset of variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadNetCDF_+3A_out">out</code></td>
<td>
<p>character indicating the type of output desired</p>
</td></tr>
<tr><td><code id="ReadNetCDF_+3A_subset">subset</code></td>
<td>
<p>a list of subsetting objects. See below.</p>
</td></tr>
<tr><td><code id="ReadNetCDF_+3A_key">key</code></td>
<td>
<p>if <code>TRUE</code>, returns a data.table keyed by the dimensions of the data.</p>
</td></tr>
<tr><td><code id="ReadNetCDF_+3A_...">...</code></td>
<td>
<p>in <code><a href="#topic+GlanceNetCDF">GlanceNetCDF()</a></code>, ignored. Is there for convenience so that a call to <code><a href="#topic+ReadNetCDF">ReadNetCDF()</a></code> can
be also valid for <code><a href="#topic+GlanceNetCDF">GlanceNetCDF()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return format is specified by <code>out</code>. It can be a data table in which each
column is a variable and each row, an observation; an array with named
dimensions; or a vector. Since it's possible to return multiple arrays or
vectors (one for each variable), for consistency the return type is always a
list. Either of these two options are much faster than the
first since the most time consuming part is the melting of the array
returned by <a href="ncdf4.html#topic+ncvar_get">ncdf4::ncvar_get</a>. <code>out = "vector"</code> is particularly useful for
adding new variables to an existing data frame with the same dimensions.
</p>
<p>When not all variables specified in <code>vars</code> have the same number of dimensions,
the shorter variables will be recycled. E.g. if reading a 3D pressure field
and a 2D surface temperature field, the latter will be turned into a 3D field
with the same values in each missing dimension.
</p>
<p><code>GlanceNetCDF()</code> returns a list of variables and dimensions included in the
file with a nice printing method.
</p>


<h3>Subsetting</h3>

<p>In the most basic form, <code>subset</code> will be a named list whose names must match
the dimensions specified in the NetCDF file and each element must be a vector
whose range defines
a contiguous subset of data. You don't need to provide and exact range that
matches the actual gridpoints of the file; the closest gridpoint will be selected.
Furthermore, you can use <code>NA</code> to refer to the existing minimum or maximum.
</p>
<p>So, if you want to get Southern Hemisphere data from the from a file that defines
latitude as <code>lat</code>, then you can use:
</p>
<pre>
subset = list(lat = -90:0)
</pre>
<p>To use dimension indices instead of values, wrap the expression in <code><a href="base.html#topic+AsIs">base::I()</a></code>.
For example to read the first 10 timesteps of a file:
</p>
<pre>
subset = list(time = I(1, 10))
</pre>
<p>Negative indices are interpreted as starting from the end.
So to read the last 10 timesteps of a file:
</p>
<pre>
subset = list(time = I(-10, 0))
</pre>
<p>More complex subsetting operations are supported. If you want to read non-contiguous
chunks of data, you can specify each chunk into a list inside <code>subset</code>. For example
this subset
</p>
<pre>
subset = list(list(lat = -90:-70, lon = 0:60),
              list(lat = 70:90, lon = 300:360))
</pre>
<p>will return two contiguous chunks: one on the South-West corner and one on the
North-East corner. Alternatively, if you want to get the four corners that
are combination of those two conditions,
</p>
<pre>
subset = list(lat = list(-90:-70, 70:90),
              lon = list(0:60, 300:360))
</pre>
<p>Both operations can be mixed together. So for example this
</p>
<pre>
subset = list(list(lat = -90:-70,
                   lon = 0:60),
              time = list(c("2000-01-01", "2000-12-31"),
                          c("2010-01-01", "2010-12-31")))
</pre>
<p>returns one spatial chunk for each of two temporal chunks.
</p>
<p>The general idea is that named elements define 'global' subsets ranges that will be
applied to every other subset, while each unnamed element define one contiguous chunk.
In the above example, <code>time</code> defines two temporal ranges that every subset of data will
have.
</p>
<p>The above example, then, is equivalent to
</p>
<pre>
subset = list(list(lat = -90:-70,
                   lon = 0:60,
                   time = c("2000-01-01", "2000-12-31")),
              list(lat = -90:-70,
                   lon = 0:60,
                   time = c("2010-01-01", "2010-12-31")))
</pre>
<p>but demands much less typing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("extdata", "temperature.nc", package = "metR")
# Get a list of variables.
variables &lt;- GlanceNetCDF(file)
print(variables)

# The object returned by GlanceNetCDF is a list with lots
# of information
str(variables)

# Read only the first one, with name "var".
field &lt;- ReadNetCDF(file, vars = c(var = names(variables$vars[1])))
# Add a new variable.
# ¡Make sure it's on the same exact grid!
field[, var2 := ReadNetCDF(file, out = "vector")]

## Not run: 
# Using a DAP url
url &lt;- "http://iridl.ldeo.columbia.edu/SOURCES/.Models/.SubX/.GMAO/.GEOS_V2p1/.hindcast/.ua/dods"
field &lt;- ReadNetCDF(url, subset = list(M = 1,
                                       P = 10,
                                       S = "1999-01-01"))

# In this case, opening the netcdf file takes a non-neglible
# amount of time. So if you want to iterate over many dimensions,
# then it's more efficient to open the file first and then read it.

ncfile &lt;- ncdf4::nc_open(url)
field &lt;- ReadNetCDF(ncfile, subset = list(M = 1,
                                       P = 10,
                                       S = "1999-01-01"))


# Using a function in `vars` to read all variables that
# start with "radar_".
ReadNetCDF(radar_file, vars = function(x) startsWith(x, "radar_"))


## End(Not run)
</code></pre>

<hr>
<h2 id='reverselog_trans'>Reverse log transform</h2><span id='topic+reverselog_trans'></span>

<h3>Description</h3>

<p>Reverse log transformation. Useful when plotting and one axis is in pressure
levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverselog_trans(base = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverselog_trans_+3A_base">base</code></td>
<td>
<p>Base of the logarithm</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Adiabatic temperature profile
gamma &lt;- 0.286
t &lt;- data.frame(p = c(1000, 950, 850, 700, 500, 300, 200, 100))
t$t &lt;- 300*(t$p/1000)^gamma

library(ggplot2)
ggplot(t, aes(p, t)) +
   geom_line() +
   coord_flip() +
   scale_x_continuous(trans = "reverselog")

</code></pre>

<hr>
<h2 id='scale_divergent'>Divergent colour scales</h2><span id='topic+scale_divergent'></span><span id='topic+scale_colour_divergent'></span><span id='topic+scale_color_divergent'></span><span id='topic+scale_fill_divergent'></span>

<h3>Description</h3>

<p>Wrapper around ggplot's <code><a href="ggplot2.html#topic+scale_colour_gradient2">scale_colour_gradient2</a></code> with
inverted defaults of <code>high</code> and <code>low</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_divergent(
  ...,
  low = scales::muted("blue"),
  mid = "white",
  high = scales::muted("red"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar"
)

scale_color_divergent(
  ...,
  low = scales::muted("blue"),
  mid = "white",
  high = scales::muted("red"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar"
)

scale_fill_divergent(
  ...,
  low = scales::muted("blue"),
  mid = "white",
  high = scales::muted("red"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_divergent_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+continuous_scale">continuous_scale</a></code>
</p>

<dl>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a numeric vector with
values between 0 and 1 returns the corresponding output values
(e.g., <code><a href="scales.html#topic+pal_area">scales::pal_area()</a></code>).</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Note that for position scales, limits are provided after scale expansion.
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</dd>
<dt><code>rescaler</code></dt><dd><p>A function used to scale the input values to the
range [0, 1]. This is always <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>, except for
diverging and n colour gradients (i.e., <code><a href="ggplot2.html#topic+scale_colour_gradient2">scale_colour_gradient2()</a></code>,
<code><a href="ggplot2.html#topic+scale_colour_gradientn">scale_colour_gradientn()</a></code>). The <code>rescaler</code> is ignored by position
scales, which always use <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>. Also accepts rlang
<a href="rlang.html#topic+as_function">lambda</a> function notation.</p>
</dd>
<dt><code>oob</code></dt><dd><p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</dd>
<dt><code>trans</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_divergent_+3A_low">low</code>, <code id="scale_divergent_+3A_high">high</code></td>
<td>
<p>Colours for low and high ends of the gradient.</p>
</td></tr>
<tr><td><code id="scale_divergent_+3A_mid">mid</code></td>
<td>
<p>colour for mid point</p>
</td></tr>
<tr><td><code id="scale_divergent_+3A_midpoint">midpoint</code></td>
<td>
<p>The midpoint (in data value) of the diverging scale.
Defaults to 0.</p>
</td></tr>
<tr><td><code id="scale_divergent_+3A_space">space</code></td>
<td>
<p>colour space in which to calculate gradient. Must be &quot;Lab&quot; -
other values are deprecated.</p>
</td></tr>
<tr><td><code id="scale_divergent_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
<tr><td><code id="scale_divergent_+3A_guide">guide</code></td>
<td>
<p>Type of legend. Use <code>"colourbar"</code> for continuous
colour bar, or <code>"legend"</code> for discrete colour legend.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot(reshape2::melt(volcano), aes(Var1, Var2, z = value)) +
  geom_contour(aes(color = after_stat(level))) +
  scale_colour_divergent(midpoint = 130)

</code></pre>

<hr>
<h2 id='scale_label_colour_continuous'>Scales for contour label aesthetics</h2><span id='topic+scale_label_colour_continuous'></span><span id='topic+scale_label_alpha_continuous'></span><span id='topic+scale_label_size_continuous'></span>

<h3>Description</h3>

<p>Scales for contour label aesthetics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_label_colour_continuous(
  ...,
  aesthetics = c("label_colour"),
  guide = ggplot2::guide_colorbar(available_aes = "label_colour")
)

scale_label_alpha_continuous(
  ...,
  range = c(0.1, 1),
  aesthetics = c("label_alpha")
)

scale_label_size_continuous(
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  transform = "identity",
  guide = "legend"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_label_colour_continuous_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+continuous_scale">continuous_scale</a></code>
</p>

<dl>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>oob</code></dt><dd><p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</dd>
<dt><code>na.value</code></dt><dd><p>Missing values will be replaced with this value.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_label_colour_continuous_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful,
for example, to apply colour settings to the colour and fill aesthetics at
the same time, via aesthetics = c(&quot;colour&quot;, &quot;fill&quot;).</p>
</td></tr>
<tr><td><code id="scale_label_colour_continuous_+3A_guide">guide</code></td>
<td>
<p>Type of legend. Use &quot;colourbar&quot; for continuous colour bar,
or &quot;legend&quot; for discrete colour legend.</p>
</td></tr>
<tr><td><code id="scale_label_colour_continuous_+3A_range">range</code></td>
<td>
<p>Output range of alpha values. Must lie between 0 and 1.</p>
</td></tr>
<tr><td><code id="scale_label_colour_continuous_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Note that for position scales, limits are provided after scale expansion.
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_label_colour_continuous_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_label_colour_continuous_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_label_colour_continuous_+3A_transform">transform</code></td>
<td>
<p>For continuous scales, the name of a transformation object
or the object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;date&quot;, &quot;exp&quot;, &quot;hms&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;modulus&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;pseudo_log&quot;, &quot;reciprocal&quot;,
&quot;reverse&quot;, &quot;sqrt&quot; and &quot;time&quot;.
</p>
<p>A transformation object bundles together a transform, its inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code style="white-space: pre;">&#8288;transform_&lt;name&gt;&#8288;</code>. If
transformations require arguments, you can call them from the scales
package, e.g. <code><a href="scales.html#topic+transform_boxcox">scales::transform_boxcox(p = 2)</a></code>.
You can create your own transformation with <code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='scale_longitude'>Helpful scales for maps</h2><span id='topic+scale_longitude'></span><span id='topic+scale_x_longitude'></span><span id='topic+scale_latitude'></span><span id='topic+scale_y_longitude'></span><span id='topic+scale_x_latitude'></span><span id='topic+scale_y_latitude'></span><span id='topic+scale_x_level'></span><span id='topic+scale_y_level'></span>

<h3>Description</h3>

<p>These functions are simple wrappers around
<code><a href="ggplot2.html#topic+scale_x_continuous">scale_x_continuous</a></code> and
<code><a href="ggplot2.html#topic+scale_y_continuous">scale_y_continuous</a></code> with
helpful defaults for plotting longitude, latitude and pressure levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_longitude(
  name = "",
  ticks = 30,
  breaks = seq(-180, 360, by = ticks),
  expand = c(0, 0),
  labels = LonLabel,
  ...
)

scale_y_longitude(
  name = "",
  ticks = 60,
  breaks = seq(-180, 360, by = ticks),
  expand = c(0, 0),
  labels = LonLabel,
  ...
)

scale_x_latitude(
  name = "",
  ticks = 30,
  breaks = seq(-90, 90, by = ticks),
  expand = c(0, 0),
  labels = LatLabel,
  ...
)

scale_y_latitude(
  name = "",
  ticks = 30,
  breaks = seq(-90, 90, by = ticks),
  expand = c(0, 0),
  labels = LatLabel,
  ...
)

scale_x_level(name = "", expand = c(0, 0), trans = "reverselog", ...)

scale_y_level(name = "", expand = c(0, 0), trans = "reverselog", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_longitude_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_longitude_+3A_ticks">ticks</code></td>
<td>
<p>spacing between breaks</p>
</td></tr>
<tr><td><code id="scale_longitude_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Note that for position scales, limits are provided after scale expansion.
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_longitude_+3A_expand">expand</code></td>
<td>
<p>For position scales, a vector of range expansion
constants used to add some padding around the data to ensure
that they are placed some distance away from the axes.
Use the convenience function <code><a href="ggplot2.html#topic+expansion">ggplot2::expansion()</a></code> to generate
the values for the expand argument.</p>
</td></tr>
<tr><td><code id="scale_longitude_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_longitude_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code style="white-space: pre;">&#8288;scale_(x|y)_continuous()&#8288;</code></p>
</td></tr>
<tr><td><code id="scale_longitude_+3A_trans">trans</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geopotential)
library(ggplot2)
ggplot(geopotential[date == date[1]], aes(lon, lat, z = gh)) +
    geom_contour() +
    scale_x_longitude() +
    scale_y_latitude()

data(temperature)
ggplot(temperature[lon == lon[1] &amp; lat == lat[1]], aes(air, lev)) +
    geom_path() +
    scale_y_level()

</code></pre>

<hr>
<h2 id='scale_mag'>Scale for vector magnitudes</h2><span id='topic+scale_mag'></span><span id='topic+scale_mag_continuous'></span>

<h3>Description</h3>

<p>Allows to control the size of the arrows in <a href="#topic+geom_arrow">geom_arrow</a>.
Highly experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_mag(
  name = ggplot2::waiver(),
  n.breaks = 1,
  breaks = ggplot2::waiver(),
  oob = no_censor,
  ...
)

scale_mag_continuous(
  name = ggplot2::waiver(),
  n.breaks = 1,
  breaks = ggplot2::waiver(),
  oob = no_censor,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_mag_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_mag_+3A_n.breaks">n.breaks</code></td>
<td>
<p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</td></tr>
<tr><td><code id="scale_mag_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Note that for position scales, limits are provided after scale expansion.
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_mag_+3A_oob">oob</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_mag_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code style="white-space: pre;">&#8288;scale_(x|y)_continuous()&#8288;</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
g &lt;- ggplot(seals, aes(long, lat)) +
    geom_vector(aes(dx = delta_long, dy = delta_lat), skip = 2)

g + scale_mag("Seals velocity")

g + scale_mag("Seals velocity", limits = c(0, 1))

</code></pre>

<hr>
<h2 id='scale_stroke.colour_continuous'>Scale for stroke.colour</h2><span id='topic+scale_stroke.colour_continuous'></span>

<h3>Description</h3>

<p>Scale for stroke.colour
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_stroke.colour_continuous_+3A_...">...</code></td>
<td>
<p>parameters sent to <a href="ggplot2.html#topic+scale_colour_continuous">ggplot2::scale_color_continuous</a></p>
</td></tr>
</table>

<hr>
<h2 id='season'>Assign seasons to months</h2><span id='topic+season'></span><span id='topic+AssignSeason'></span><span id='topic+seasonally'></span><span id='topic+is.full_season'></span>

<h3>Description</h3>

<p>Assign seasons to months
</p>


<h3>Usage</h3>

<pre><code class='language-R'>season(x, lang = c("en", "es"))

seasonally(x)

is.full_season(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="season_+3A_x">x</code></td>
<td>
<p>A vector of dates (alternative a numeric vector of months, for <code>season()</code>)</p>
</td></tr>
<tr><td><code id="season_+3A_lang">lang</code></td>
<td>
<p>Language to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>season()</code> returns a factor vector of the same length as <code>x</code> with the trimester of each
month.
<code>seasonaly()</code> returns a date vector of the same length as <code>x</code> with the date &quot;rounded&quot; up to the centre
month of each season.
<code>is.full_season()</code> returns a logical vector of the same length as <code>x</code> that is true only if the
3 months of each season for each year (December counts for the following year) are present in the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>season(1, lang = "en")
season(as.Date("2017-01-01"))

seasonally(as.Date(c("2017-12-01", "2018-01-01", "2018-02-01")))

is.full_season(as.Date(c("2017-12-01", "2018-01-01", "2018-02-01", "2018-03-01")))

</code></pre>

<hr>
<h2 id='Smooth2D'>Smooths a 2D field</h2><span id='topic+Smooth2D'></span><span id='topic+smooth_dct'></span><span id='topic+smooth_svd'></span>

<h3>Description</h3>

<p>Smooth a 2D field using a user-supplied method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Smooth2D(x, y, value, method = smooth_svd(0.01))

smooth_dct(kx = 0.5, ky = kx)

smooth_svd(variance_lost = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Smooth2D_+3A_x">x</code>, <code id="Smooth2D_+3A_y">y</code></td>
<td>
<p>Vector of x and y coordinates</p>
</td></tr>
<tr><td><code id="Smooth2D_+3A_value">value</code></td>
<td>
<p>Vector of values</p>
</td></tr>
<tr><td><code id="Smooth2D_+3A_method">method</code></td>
<td>
<p>The method to use smooth. Must be a function that takes a matrix
and returns the smoothed matrix. Build-in methods are <code>smooth_svd()</code> and <code>smooth_dct()</code>.</p>
</td></tr>
<tr><td><code id="Smooth2D_+3A_kx">kx</code>, <code id="Smooth2D_+3A_ky">ky</code></td>
<td>
<p>Proportion of components to keep in the x and
y direction respectively. Lower values increase the smoothness.</p>
</td></tr>
<tr><td><code id="Smooth2D_+3A_variance_lost">variance_lost</code></td>
<td>
<p>Maximum percentage of variance lost after smoothing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>smooth_svd()</code> computes the SVD of the field and reconstructs it keeping only
the leading values that ensures a maximum variance lost.
<code>smooth_dct()</code> computes the Discrete Cosine Transform of the field and sets
a proportion of the components to zero.
</p>


<h3>Value</h3>

<p>A vector of the same length as value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
# Creates a noisy version of the volcano dataset and applies the smooth
volcano &lt;- reshape2::melt(datasets::volcano, value.name = "original")
volcano$noisy &lt;- with(volcano, original + 1.5*rnorm(length(original)))

volcano$smooth_svd &lt;- with(volcano, Smooth2D(Var2, Var1, noisy, method = smooth_svd(0.005)))
volcano$smooth_dct &lt;- with(volcano, Smooth2D(Var2, Var1, noisy, method = smooth_dct(kx = 0.4)))

volcano &lt;- reshape2::melt(volcano, id.vars = c("Var1", "Var2"))

ggplot(volcano, aes(Var1, Var2)) +
  geom_contour(aes(z = value, color = after_stat(level))) +
  scale_color_viridis_c() +
  coord_equal() +
  facet_wrap(~variable, ncol = 2)
</code></pre>

<hr>
<h2 id='spherical'>Transform between spherical coordinates and physical coordinates</h2><span id='topic+spherical'></span><span id='topic+dlon'></span><span id='topic+dlat'></span><span id='topic+dx'></span><span id='topic+dy'></span>

<h3>Description</h3>

<p>Transform a longitude or latitude interval into the equivalent in meters depending
on latitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlon(dx, lat, a = 6731000)

dlat(dy, a = 6731000)

dx(dlon, lat, a = 6731000)

dy(dlat, a = 6731000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spherical_+3A_dx">dx</code>, <code id="spherical_+3A_dy">dy</code></td>
<td>
<p>interval in meters</p>
</td></tr>
<tr><td><code id="spherical_+3A_lat">lat</code></td>
<td>
<p>latitude, in degrees</p>
</td></tr>
<tr><td><code id="spherical_+3A_a">a</code></td>
<td>
<p>radius of the Earth</p>
</td></tr>
<tr><td><code id="spherical_+3A_dlon">dlon</code>, <code id="spherical_+3A_dlat">dlat</code></td>
<td>
<p>interval in degrees</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
data(geopotential)
geopotential &lt;- geopotential[date == date[1]]

# Geostrophic wind
geopotential[, c("u", "v") := GeostrophicWind(gh, lon, lat)]  # in meters/second
geopotential[, c("dlon", "dlat") := .(dlon(u, lat), dlat(v))] # in degrees/second
geopotential[, c("u2", "v2") := .(dx(dlon, lat), dy(dlat))]   # again in degrees/second

</code></pre>

<hr>
<h2 id='standard_atmosphere'>Standard atmosphere</h2><span id='topic+standard_atmosphere'></span><span id='topic+sa_pressure'></span><span id='topic+sa_height'></span><span id='topic+sa_temperature'></span><span id='topic+sa_height_trans'></span><span id='topic+sa_pressure_trans'></span><span id='topic+sa_height_breaks'></span><span id='topic+sa_height_axis'></span><span id='topic+sa_pressure_axis'></span>

<h3>Description</h3>

<p>Utilities to use the International Standard Atmosphere. It uses the
International Standard Atmosphere up to the tropopause (11 km by definition)
and then extends up to the 500 km using the ARDC Model Atmosphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sa_pressure(height)

sa_height(pressure)

sa_temperature(height)

sa_height_trans(pressure_in = "hPa", height_in = "km")

sa_pressure_trans(height_in = "km", pressure_in = "hPa")

sa_height_breaks(n = 6, pressure_in = "hPa", height_in = "km", ...)

sa_height_axis(
  name = ggplot2::waiver(),
  breaks = sa_height_breaks(pressure_in = pressure_in, height_in = height_in),
  labels = ggplot2::waiver(),
  guide = ggplot2::waiver(),
  pressure_in = "hPa",
  height_in = "km"
)

sa_pressure_axis(
  name = ggplot2::waiver(),
  breaks = scales::log_breaks(n = 6),
  labels = scales::number_format(drop0trailing = TRUE, big.mark = "", trim = FALSE),
  guide = ggplot2::waiver(),
  height_in = "km",
  pressure_in = "hPa"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standard_atmosphere_+3A_height">height</code></td>
<td>
<p>height in meter</p>
</td></tr>
<tr><td><code id="standard_atmosphere_+3A_pressure">pressure</code></td>
<td>
<p>pressure in pascals</p>
</td></tr>
<tr><td><code id="standard_atmosphere_+3A_height_in">height_in</code>, <code id="standard_atmosphere_+3A_pressure_in">pressure_in</code></td>
<td>
<p>units of height and pressure, respectively.
Possible values are &quot;km&quot;, &quot;m&quot; for height and &quot;hPa&quot; and &quot;Pa&quot; for pressure.
Alternatively, it can be a numeric constant that multiplied to convert the
unit to meters and Pascals respectively. (E.g. if height is in feet,
use <code>height_in = 0.3048</code>.)</p>
</td></tr>
<tr><td><code id="standard_atmosphere_+3A_n">n</code></td>
<td>
<p>desiderd number of breaks.</p>
</td></tr>
<tr><td><code id="standard_atmosphere_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <a href="scales.html#topic+breaks_extended">scales::breaks_extended</a>.</p>
</td></tr>
<tr><td><code id="standard_atmosphere_+3A_name">name</code>, <code id="standard_atmosphere_+3A_breaks">breaks</code>, <code id="standard_atmosphere_+3A_labels">labels</code>, <code id="standard_atmosphere_+3A_guide">guide</code></td>
<td>
<p>arguments passed to <code><a href="ggplot2.html#topic+sec_axis">ggplot2::sec_axis()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sa_pressure()</code>, <code>sa_height()</code>, <code>sa_temperature()</code> return, respectively,
pressure (in pascals), height (in meters) and temperature (in Kelvin).
</p>
<p><code>sa_height_trans()</code> and <code>sa_pressure_trans()</code> are two transformation functions
to be used as the <code>trans</code> argument in ggplot2 scales (e.g. <code style="white-space: pre;">&#8288;scale_y_continuous(trans = "sa_height"&#8288;</code>).
</p>
<p><code>sa_height_axis()</code>  and <code>sa_pressure_axis()</code> return a secondary axis that transforms to
height or pressure respectively to be used as ggplot2 secondary axis
(e.g. <code>scale_y_continuous(sec.axis = sa_height_axis())</code>).
</p>
<p>For convenience, and unlike the &quot;primitive&quot; functions, both the transformation
functions and the axis functions input and output in hectopascals and kilometres
by default.
</p>


<h3>References</h3>

<p>Standard atmosphere—Glossary of Meteorology. (n.d.).
Retrieved 22 February 2021, from <a href="https://glossary.ametsoc.org/wiki/Standard_atmosphere">https://glossary.ametsoc.org/wiki/Standard_atmosphere</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>height &lt;- seq(0, 100*1000, by = 1*200)

# Temperature profile that defines the standard atmosphere (in degrees Celsius)
plot(sa_temperature(height) - 273.15, height, type = "l")

# Pressure profile
plot(sa_pressure(height), height, type = "l")

# Use with ggplot2
library(ggplot2)
data &lt;- data.frame(height = height/1000,               # height in kilometers
                   pressure = sa_pressure(height)/100) # pressures in hectopascals

# With the sa_*_axis functions, you can label the approximate height
# when using isobaric coordinates#'
ggplot(data, aes(height, pressure)) +
  geom_path() +
  scale_y_continuous(sec.axis = sa_height_axis("height"))

# Or the approximate pressure when using physical height
ggplot(data, aes(pressure, height)) +
  geom_path() +
  scale_y_continuous(sec.axis = sa_pressure_axis("level"))

# When working with isobaric coordinates,using a linear scale exagerates
# the thickness of the lower levels
ggplot(temperature[lat == 0], aes(lon, lev)) +
   geom_contour_fill(aes(z = air)) +
   scale_y_reverse()

# Using the standard atmospehre height transormation, the result
# is an approximate linear scale in height
ggplot(temperature[lat == 0], aes(lon, lev)) +
   geom_contour_fill(aes(z = air)) +
   scale_y_continuous(trans = "sa_height", expand = c(0, 0))

# The result is very similar to using a reverse log transform, which is the
# current behaviour of scale_y_level(). This transformation slightly
# overextends the higher levels.
ggplot(temperature[lat == 0], aes(lon, lev)) +
   geom_contour_fill(aes(z = air)) +
   scale_y_level()

</code></pre>

<hr>
<h2 id='stat_na'>Filter only NA values.</h2><span id='topic+stat_na'></span><span id='topic+StatNa'></span>

<h3>Description</h3>

<p>Useful for indicating or masking missing data. This stat subsets data where
one variable is <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_na(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_na_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_na_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_na_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data for this layer.
When using a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function to construct a layer, the <code>geom</code> argument
can be used to override the default coupling between stats and geoms. The
<code>geom</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Geom</code> ggproto subclass, for example <code>GeomPoint</code>.
</p>
</li>
<li><p> A string naming the geom. To give the geom as a string, strip the
function name of the <code>geom_</code> prefix. For example, to use <code>geom_point()</code>,
give the geom as <code>"point"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the geom, see the
<a href="ggplot2.html#topic+layer_geoms">layer geom</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_na_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_na_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_na_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_na_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>stat_na</code> understands the following aesthetics (required aesthetics are in bold)
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>na</strong>
</p>
</li>
<li> <p><code>width</code>
</p>
</li>
<li> <p><code>height</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+stat_subset">stat_subset</a> for a more general way of filtering data.
</p>
<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(data.table)
surface &lt;- reshape2::melt(volcano)
surface &lt;- within(surface, value[Var1 %between% c(20, 30) &amp; Var2 %between% c(20, 30)] &lt;- NA)
surface[sample(1:nrow(surface), 100, replace = FALSE), 3] &lt;- NA

ggplot(surface, aes(Var1, Var2, z = value)) +
    geom_contour_fill(na.fill = TRUE) +
    stat_na(aes(na = value), geom = "tile")

</code></pre>

<hr>
<h2 id='stat_subset'>Subset values</h2><span id='topic+stat_subset'></span><span id='topic+StatSubset'></span>

<h3>Description</h3>

<p>Removes values where <code>subset</code> evaluates to <code>FALSE</code>. Useful for showing only
statistical significant values, or an interesting subset of the data without
manually subsetting the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_subset(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_subset_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_subset_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_subset_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data for this layer.
When using a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function to construct a layer, the <code>geom</code> argument
can be used to override the default coupling between stats and geoms. The
<code>geom</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Geom</code> ggproto subclass, for example <code>GeomPoint</code>.
</p>
</li>
<li><p> A string naming the geom. To give the geom as a string, strip the
function name of the <code>geom_</code> prefix. For example, to use <code>geom_point()</code>,
give the geom as <code>"point"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the geom, see the
<a href="ggplot2.html#topic+layer_geoms">layer geom</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_subset_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_subset_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_subset_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_subset_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>stat_subset</code> understands the following aesthetics (required aesthetics are in bold)
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>subset</strong>
</p>
</li>
<li> <p><code>width</code>
</p>
</li>
<li> <p><code>height</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+stat_na">stat_na</a> for a more specialized stat for filtering <code>NA</code> values.
</p>
<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+WrapCircular">WrapCircular</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
ggplot(reshape2::melt(volcano), aes(Var1, Var2)) +
    geom_contour(aes(z = value)) +
    stat_subset(aes(subset = value &gt;= 150 &amp; value &lt;= 160),
                shape = 3, color = "red")

</code></pre>

<hr>
<h2 id='surface'>Surface height</h2><span id='topic+surface'></span>

<h3>Description</h3>

<p>Surface height of central Argentina on a lambert grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surface
</code></pre>


<h3>Format</h3>

<p>A data.table with 53224 rows and 5 variables.
</p>

<dl>
<dt>lon</dt><dd><p>longitude in degrees</p>
</dd>
<dt>lat</dt><dd><p>latitude in degrees</p>
</dd>
<dt>height</dt><dd><p>height in meters</p>
</dd>
<dt>x</dt><dd><p>x coordinates of projection</p>
</dd>
<dt>y</dt><dd><p>y coordinates of projection</p>
</dd>
</dl>


<hr>
<h2 id='temperature'>Air temperature</h2><span id='topic+temperature'></span>

<h3>Description</h3>

<p>A global air temperature field for 2017-07-09.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temperature
</code></pre>


<h3>Format</h3>

<p>A data.table with 10512 rows and 3 variables:
</p>

<dl>
<dt>lon</dt><dd><p>longitude in degrees from 0 to 360</p>
</dd>
<dt>lat</dt><dd><p>latitude in degrees</p>
</dd>
<dt>lev</dt><dd><p>pressure level in hPa)</p>
</dd>
<dt>air</dt><dd><p>air temperature in Kelvin</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://psl.noaa.gov/data/gridded/data.ncep.reanalysis.derived.pressure.html">https://psl.noaa.gov/data/gridded/data.ncep.reanalysis.derived.pressure.html</a>
</p>

<hr>
<h2 id='thermodynamics'>Thermodynamics</h2><span id='topic+thermodynamics'></span><span id='topic+IdealGas'></span><span id='topic+Adiabat'></span><span id='topic+VirtualTemperature'></span><span id='topic+MixingRatio'></span><span id='topic+ClausiusClapeyron'></span><span id='topic+DewPoint'></span>

<h3>Description</h3>

<p>Functions related to common atmospheric thermodynamic relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IdealGas(p, t, rho, R = 287.058)

Adiabat(p, t, theta, p0 = 1e+05, kappa = 2/7)

VirtualTemperature(p, t, e, tv, epsilon = 0.622)

MixingRatio(p, e, w, epsilon = 0.622)

ClausiusClapeyron(t, es)

DewPoint(p, ws, td, epsilon = 0.622)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thermodynamics_+3A_p">p</code></td>
<td>
<p>pressure</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_t">t</code></td>
<td>
<p>temperature</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_rho">rho</code></td>
<td>
<p>density</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_r">R</code></td>
<td>
<p>gas constant for air</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_theta">theta</code></td>
<td>
<p>potential temperature</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_p0">p0</code></td>
<td>
<p>reference pressure</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_kappa">kappa</code></td>
<td>
<p>ratio of dry air constant and specific heat capacity at constant pressure</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_e">e</code></td>
<td>
<p>vapour partial pressure</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_tv">tv</code></td>
<td>
<p>virtual temperature</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_epsilon">epsilon</code></td>
<td>
<p>ratio of dry air constant and vapour constant</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_w">w</code></td>
<td>
<p>mixing ratio</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_es">es</code></td>
<td>
<p>saturation vapour partial pressure</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_ws">ws</code></td>
<td>
<p>saturation mixing ratio</p>
</td></tr>
<tr><td><code id="thermodynamics_+3A_td">td</code></td>
<td>
<p>dewpoint</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>IdealGas</code> computes pressure, temperature or density of air according to the
ideal gas law <code class="reqn">P=\rho R T</code>.
</p>
<p><code>Adiabat</code> computes pressure, temperature or potential temperature according to
the adiabatic relationship <code class="reqn">\theta = T (P0/P)^\kappa</code>.
</p>
<p><code>VirtualTemperature</code> computes pressure, temperature, vapour partial pressure or
virtual temperature according to the virtual temperature definition
<code class="reqn">T(1 - e/P(1 - \epsilon))^{-1}</code>.
</p>
<p><code>MixingRatio</code> computes pressure, vapour partial temperature, or mixing ratio
according to <code class="reqn">w = \epsilon e/(P - e)</code>.
</p>
<p><code>ClausiusClapeyron</code> computes saturation pressure or temperature according
to the August-Roche-Magnus formula <code class="reqn">es = a exp{bT/(T + c)}</code> with temperature
in Kelvin and saturation pressure in Pa.
</p>
<p><code>DewPoint</code> computes pressure, saturation mixing ration or dew point
from the relationship <code class="reqn">ws =  \epsilon es(Td)/(p - es(Td))</code>. Note that the
computation of dew point is approximated.
</p>
<p>Is important to take note of the units in which each variable is provided.
With the default values, pressure should be passed in Pascals, temperature and
potential temperature in Kelvins, and density in <code class="reqn">kg/m^3</code>.
<code>ClausiusClayperon</code> and <code>DewPoint</code> require and return values in those units.
</p>
<p>The defaults value of the <code>R</code> and <code>kappa</code> parameters are correct for dry air,
for the case of moist air, use the virtual temperature instead of the actual
temperature.
</p>


<h3>Value</h3>

<p>Each function returns the value of the missing state variable.
</p>


<h3>References</h3>

<p>http://www.atmo.arizona.edu/students/courselinks/fall11/atmo551a/ATMO_451a_551a_files/WaterVapor.pdf
</p>


<h3>See Also</h3>

<p>Other meteorology functions: 
<code><a href="#topic+Derivate">Derivate</a>()</code>,
<code><a href="#topic+EOF">EOF</a>()</code>,
<code><a href="#topic+GeostrophicWind">GeostrophicWind</a>()</code>,
<code><a href="#topic+WaveFlux">WaveFlux</a>()</code>,
<code><a href="#topic+waves">waves</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>IdealGas(1013*100, 20 + 273.15)
IdealGas(1013*100, rho = 1.15) - 273.15

(theta &lt;- Adiabat(70000, 20 + 273.15))
Adiabat(70000, theta = theta) - 273.15

# Relative humidity from T and Td
t &lt;- 25 + 273.15
td &lt;- 20 + 273.15
p &lt;- 1000000
(rh &lt;- ClausiusClapeyron(td)/ClausiusClapeyron(t))

# Mixing ratio
ws &lt;- MixingRatio(p, ClausiusClapeyron(t))
w &lt;- ws*rh
DewPoint(p, w) - 273.15    # Recover Td

</code></pre>

<hr>
<h2 id='Trajectory'>Compute trajectories</h2><span id='topic+Trajectory'></span>

<h3>Description</h3>

<p>Computes trajectories of particles in a time-varying velocity field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Trajectory(formula, x0, y0, cyclical = FALSE, data = NULL, res = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Trajectory_+3A_formula">formula</code></td>
<td>
<p>a formula indicating dependent and independent variables
in the form of dx + dy ~ x + y + t.</p>
</td></tr>
<tr><td><code id="Trajectory_+3A_x0">x0</code>, <code id="Trajectory_+3A_y0">y0</code></td>
<td>
<p>starting coordinates of the particles.</p>
</td></tr>
<tr><td><code id="Trajectory_+3A_cyclical">cyclical</code></td>
<td>
<p>logical vector of boundary condition for x and y.</p>
</td></tr>
<tr><td><code id="Trajectory_+3A_data">data</code></td>
<td>
<p>optional data.frame containing the variables.</p>
</td></tr>
<tr><td><code id="Trajectory_+3A_res">res</code></td>
<td>
<p>resolution parameter (higher numbers increases the resolution)</p>
</td></tr>
</table>

<hr>
<h2 id='WaveFlux'>Calculate wave-activity flux</h2><span id='topic+WaveFlux'></span>

<h3>Description</h3>

<p>Calculate wave-activity flux
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WaveFlux(gh, u, v, lon, lat, lev, g = 9.81, a = 6371000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WaveFlux_+3A_gh">gh</code></td>
<td>
<p>geopotential height</p>
</td></tr>
<tr><td><code id="WaveFlux_+3A_u">u</code></td>
<td>
<p>mean zonal velocity</p>
</td></tr>
<tr><td><code id="WaveFlux_+3A_v">v</code></td>
<td>
<p>mean meridional velocity</p>
</td></tr>
<tr><td><code id="WaveFlux_+3A_lon">lon</code></td>
<td>
<p>longitude (in degrees)</p>
</td></tr>
<tr><td><code id="WaveFlux_+3A_lat">lat</code></td>
<td>
<p>latitude (in degrees)</p>
</td></tr>
<tr><td><code id="WaveFlux_+3A_lev">lev</code></td>
<td>
<p>pressure level (in hPa)</p>
</td></tr>
<tr><td><code id="WaveFlux_+3A_g">g</code></td>
<td>
<p>acceleration of gravity</p>
</td></tr>
<tr><td><code id="WaveFlux_+3A_a">a</code></td>
<td>
<p>Earth's radius</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates Plum-like wave activity fluxes
</p>


<h3>Value</h3>

<p>A list with elements: longitude, latitude, and the two horizontal components
of the wave activity flux.
</p>


<h3>References</h3>

<p>Takaya, K. and H. Nakamura, 2001: A Formulation of a Phase-Independent Wave-Activity Flux for Stationary and Migratory Quasigeostrophic Eddies on a Zonally Varying Basic Flow. J. Atmos. Sci., 58, 608–627, <a href="https://doi.org/10.1175/1520-0469%282001%29058%3C0608%3AAFOAPI%3E2.0.CO%3B2">doi:10.1175/1520-0469(2001)058&lt;0608:AFOAPI&gt;2.0.CO;2</a> <br />
Adapted from <a href="https://github.com/marisolosman/Reunion_Clima/blob/master/WAF/Calculo_WAF.ipynb">https://github.com/marisolosman/Reunion_Clima/blob/master/WAF/Calculo_WAF.ipynb</a>
</p>


<h3>See Also</h3>

<p>Other meteorology functions: 
<code><a href="#topic+Derivate">Derivate</a>()</code>,
<code><a href="#topic+EOF">EOF</a>()</code>,
<code><a href="#topic+GeostrophicWind">GeostrophicWind</a>()</code>,
<code><a href="#topic+thermodynamics">thermodynamics</a></code>,
<code><a href="#topic+waves">waves</a></code>
</p>

<hr>
<h2 id='waves'>Fourier transform functions</h2><span id='topic+waves'></span><span id='topic+FitWave'></span><span id='topic+BuildWave'></span><span id='topic+FilterWave'></span><span id='topic+WaveEnvelope'></span>

<h3>Description</h3>

<p>Use <code><a href="stats.html#topic+fft">fft()</a></code> to fit, filter and reconstruct signals in the frequency domain, as
well as to compute the wave envelope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitWave(y, k = 1)

BuildWave(
  x,
  amplitude,
  phase,
  k,
  wave = list(amplitude = amplitude, phase = phase, k = k),
  sum = TRUE
)

FilterWave(y, k, action = sign(k[k != 0][1]))

WaveEnvelope(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="waves_+3A_y">y</code></td>
<td>
<p>numeric vector to transform</p>
</td></tr>
<tr><td><code id="waves_+3A_k">k</code></td>
<td>
<p>numeric vector of wave numbers</p>
</td></tr>
<tr><td><code id="waves_+3A_x">x</code></td>
<td>
<p>numeric vector of locations (in radians)</p>
</td></tr>
<tr><td><code id="waves_+3A_amplitude">amplitude</code></td>
<td>
<p>numeric vector of amplitudes</p>
</td></tr>
<tr><td><code id="waves_+3A_phase">phase</code></td>
<td>
<p>numeric vector of phases</p>
</td></tr>
<tr><td><code id="waves_+3A_wave">wave</code></td>
<td>
<p>optional list output from <code>FitWave</code></p>
</td></tr>
<tr><td><code id="waves_+3A_sum">sum</code></td>
<td>
<p>whether to perform the sum or not (see Details)</p>
</td></tr>
<tr><td><code id="waves_+3A_action">action</code></td>
<td>
<p>integer to disambiguate action for k = 0 (see Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FitWave</code> performs a fourier transform of the input vector
and returns a list of parameters for each wave number kept.
The  amplitude (A), phase (<code class="reqn">\phi</code>) and wave number (k) satisfy:
</p>
<p style="text-align: center;"><code class="reqn">y = \sum A cos((x - \phi)k)</code>
</p>

<p>The phase is calculated so that it lies between 0 and <code class="reqn">2\pi/k</code> so it
represents the location (in radians) of the first maximum of each wave number.
For the case of k = 0 (the mean), phase is arbitrarily set to 0.
</p>
<p><code>BuildWave</code> is <code>FitWave</code>'s inverse. It reconstructs the original data for
selected wavenumbers. If <code>sum</code> is <code>TRUE</code> (the default) it performs the above
mentioned sum and returns a single vector. If is <code>FALSE</code>, then it returns a list
of k vectors consisting of the reconstructed signal of each wavenumber.
</p>
<p><code>FilterWave</code> filters or removes wavenumbers specified in <code>k</code>. If <code>k</code> is positive,
then the result is the reconstructed signal of <code>y</code> only for wavenumbers
specified in <code>k</code>, if it's negative, is the signal of <code>y</code> minus the wavenumbers
specified in <code>k</code>. The argument <code>action</code> must be be manually set to <code>-1</code> or <code>+1</code>
if <code>k=0</code>.
</p>
<p><code>WaveEnvelope</code> computes the wave envelope of <code>y</code> following Zimin (2003). To compute
the envelope of only a restricted band, first filter it with <code>FilterWave</code>.
</p>


<h3>Value</h3>

<p><code>FitWaves</code> returns a a named list with components
</p>

<dl>
<dt>k</dt><dd><p>wavenumbers</p>
</dd>
<dt>amplitude</dt><dd><p>amplitude of each wavenumber</p>
</dd>
<dt>phase</dt><dd><p>phase of each wavenumber in radians</p>
</dd>
<dt>r2</dt><dd><p>explained variance of each wavenumber</p>
</dd>
</dl>

<p><code>BuildWave</code> returns a vector of the same length of x with the reconstructed
vector if <code>sum</code> is <code>TRUE</code> or, instead, a list with components
</p>

<dl>
<dt>k</dt><dd><p>wavenumbers</p>
</dd>
<dt>x</dt><dd><p>the vector of locations</p>
</dd>
<dt>y</dt><dd><p>the reconstructed signal of each wavenumber</p>
</dd>
</dl>

<p><code>FilterWave</code> and <code>WaveEnvelope</code> return a vector of the same length as <code>y</code>
'
</p>


<h3>References</h3>

<p>Zimin, A.V., I. Szunyogh, D.J. Patil, B.R. Hunt, and E. Ott, 2003: Extracting Envelopes of Rossby Wave Packets. Mon. Wea. Rev., 131, 1011–1017, <a href="https://doi.org/10.1175/1520-0493%282003%29131%3C1011%3AEEORWP%3E2.0.CO%3B2">doi:10.1175/1520-0493(2003)131&lt;1011:EEORWP&gt;2.0.CO;2</a>
</p>


<h3>See Also</h3>

<p>Other meteorology functions: 
<code><a href="#topic+Derivate">Derivate</a>()</code>,
<code><a href="#topic+EOF">EOF</a>()</code>,
<code><a href="#topic+GeostrophicWind">GeostrophicWind</a>()</code>,
<code><a href="#topic+WaveFlux">WaveFlux</a>()</code>,
<code><a href="#topic+thermodynamics">thermodynamics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Build a wave with specific wavenumber profile
waves &lt;- list(k = 1:10,
              amplitude = rnorm(10)^2,
              phase = runif(10, 0, 2*pi/(1:10)))
x &lt;- BuildWave(seq(0, 2*pi, length.out = 60)[-1], wave = waves)

# Just fancy FFT
FitWave(x, k = 1:10)

# Extract only specific wave components
plot(FilterWave(x,  1), type = "l")
plot(FilterWave(x,  2), type = "l")
plot(FilterWave(x,  1:4), type = "l")

# Remove components from the signal
plot(FilterWave(x,  -4:-1), type = "l")

# The sum of the two above is the original signal (minus floating point errors)
all.equal(x, FilterWave(x,  1:4) + FilterWave(x,  -4:-1))

# The Wave envelopes shows where the signal is the most "wavy".
plot(x, type = "l", col = "grey")
lines(WaveEnvelope(x), add = TRUE)

# Examples with real data
data(geopotential)
library(data.table)
# January mean of geopotential height
jan &lt;- geopotential[month(date) == 1, .(gh = mean(gh)), by = .(lon, lat)]

# Stationary waves for each latitude
jan.waves &lt;- jan[, FitWave(gh, 1:4), by = .(lat)]
library(ggplot2)
ggplot(jan.waves, aes(lat, amplitude, color = factor(k))) +
    geom_line()

# Build field of wavenumber 1
jan[, gh.1 := BuildWave(lon*pi/180, wave = FitWave(gh, 1)), by = .(lat)]
ggplot(jan, aes(lon, lat)) +
    geom_contour(aes(z = gh.1, color = after_stat(level))) +
    coord_polar()

# Build fields of wavenumber 1 and 2
waves &lt;- jan[, BuildWave(lon*pi/180, wave = FitWave(gh, 1:2), sum = FALSE), by = .(lat)]
waves[, lon := x*180/pi]
ggplot(waves, aes(lon, lat)) +
    geom_contour(aes(z = y, color = after_stat(level))) +
    facet_wrap(~k) +
    coord_polar()

# Field with waves 0 to 2 filtered
jan[, gh.no12 := gh - BuildWave(lon*pi/180, wave = FitWave(gh, 0:2)), by = .(lat)]
ggplot(jan, aes(lon, lat)) +
    geom_contour(aes(z = gh.no12, color = after_stat(level))) +
    coord_polar()

# Much faster
jan[, gh.no12 := FilterWave(gh, -2:0), by = .(lat)]
ggplot(jan, aes(lon, lat)) +
    geom_contour(aes(z = gh.no12, color = after_stat(level))) +
    coord_polar()

# Using positive numbers returns the field
jan[, gh.only12 := FilterWave(gh, 2:1), by = .(lat)]
ggplot(jan, aes(lon, lat)) +
    geom_contour(aes(z = gh.only12, color = after_stat(level))) +
    coord_polar()

# Compute the envelope of the geopotential
jan[, envelope := WaveEnvelope(gh.no12), by = .(lat)]
ggplot(jan[lat == -60], aes(lon, gh.no12)) +
    geom_line() +
    geom_line(aes(y = envelope), color = "red")

</code></pre>

<hr>
<h2 id='WrapCircular'>Wrap periodic data to any range</h2><span id='topic+WrapCircular'></span><span id='topic+RepeatCircular'></span>

<h3>Description</h3>

<p>Periodic data can be defined only in one period and be extended to any arbitrary
range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WrapCircular(x, circular = "lon", wrap = c(0, 360))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WrapCircular_+3A_x">x</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="WrapCircular_+3A_circular">circular</code></td>
<td>
<p>the name of the circular dimension</p>
</td></tr>
<tr><td><code id="WrapCircular_+3A_wrap">wrap</code></td>
<td>
<p>the wrap for the data to be extended to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>See Also</h3>

<p>geom_contour2
</p>
<p>Other ggplot2 helpers: 
<code><a href="#topic+MakeBreaks">MakeBreaks</a>()</code>,
<code><a href="#topic+geom_arrow">geom_arrow</a>()</code>,
<code><a href="#topic+geom_contour2">geom_contour2</a>()</code>,
<code><a href="#topic+geom_contour_fill">geom_contour_fill</a>()</code>,
<code><a href="#topic+geom_label_contour">geom_label_contour</a>()</code>,
<code><a href="#topic+geom_relief">geom_relief</a>()</code>,
<code><a href="#topic+geom_streamline">geom_streamline</a>()</code>,
<code><a href="#topic+guide_colourstrip">guide_colourstrip</a>()</code>,
<code><a href="#topic+map_labels">map_labels</a></code>,
<code><a href="#topic+reverselog_trans">reverselog_trans</a>()</code>,
<code><a href="#topic+scale_divergent">scale_divergent</a></code>,
<code><a href="#topic+scale_longitude">scale_longitude</a></code>,
<code><a href="#topic+stat_na">stat_na</a>()</code>,
<code><a href="#topic+stat_subset">stat_subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ggplot2)
library(data.table)
data(geopotential)
g &lt;- ggplot(geopotential[date == date[1]], aes(lon, lat)) +
    geom_contour(aes(z = gh)) +
    coord_polar() +
    ylim(c(-90, -10))

# This plot has problems in lon = 0
g

# But using WrapCircular solves it.
g %+% WrapCircular(geopotential[date == date[1]], "lon", c(0, 360))

# Aditionally data can be just repeatet to the right and
# left
ggplot(WrapCircular(geopotential[date == date[1]], wrap = c(-180, 360 + 180)),
       aes(lon, lat)) +
    geom_contour(aes(z = gh))

# The same behaviour is now implemented directly in geom_contour2
# and geom_contour_fill
ggplot(geopotential[date == date[1]], aes(lon, lat)) +
    geom_contour2(aes(z = gh), xwrap = c(-180, 360 + 180))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
