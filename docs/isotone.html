<!DOCTYPE html><html><head><title>Help for package isotone</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {isotone}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#activeSet'><p>Active Set Methods for Isotone Optimization</p></a></li>
<li><a href='#aSolver'><p>Asymmetric Least Squares</p></a></li>
<li><a href='#dSolver'><p>Absolute Value Norm</p></a></li>
<li><a href='#eSolver'><p>L1 approximation</p></a></li>
<li><a href='#fSolver'><p>User-Specified Loss Function</p></a></li>
<li><a href='#gpava'><p>Generalized Pooled-Adjacent-Violators Algorithm (PAVA)</p></a></li>
<li><a href='#hSolver'><p>Huber Loss Function</p></a></li>
<li><a href='#iSolver'><p>SILF Loss</p></a></li>
<li><a href='#lfSolver'><p>General Least Squares Loss Function</p></a></li>
<li><a href='#lsSolver'><p>Least Squares Loss Function</p></a></li>
<li><a href='#mendota'><p>Number of freezing days at Lake Mendota</p></a></li>
<li><a href='#mregnn'><p>Regression with Linear Inequality Restrictions on Predicted Values</p></a></li>
<li><a href='#mSolver'><p>Chebyshev norm</p></a></li>
<li><a href='#oSolver'><p>Lp norm</p></a></li>
<li><a href='#pituitary'><p>Size of pituitary fissue</p></a></li>
<li><a href='#posturo'><p>Repeated posturographic measures</p></a></li>
<li><a href='#pSolver'><p>Quantile Regression</p></a></li>
<li><a href='#sSolver'><p>Negative Poisson Log-Likelihood</p></a></li>
<li><a href='#weighted.fractile'><p>Weighted Median</p></a></li>
<li><a href='#weighted.median'><p>Weighted Median</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Active Set and Generalized PAVA for Isotone Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Mair [aut, cre],
  Jan De Leeuw [aut],
  Kurt Hornik [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Mair &lt;mair@fas.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains two main functions: one for
        solving general isotone regression problems using the
        pool-adjacent-violators algorithm (PAVA); another one provides
        a framework for active set methods for isotone optimization
        problems with arbitrary order restrictions. Various types of
        loss functions are prespecified.</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, nnls</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/psychor/">https://r-forge.r-project.org/projects/psychor/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-21 22:39:38 UTC; patrick</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-22 07:33:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='activeSet'>Active Set Methods for Isotone Optimization</h2><span id='topic+activeSet'></span><span id='topic+print.activeset'></span><span id='topic+summary.activeset'></span>

<h3>Description</h3>

<p>Isotone optimization can be formulated as a convex programming problem with simple linear constraints.
This functions offers active set strategies for a collection of isotone optimization problems pre-specified in the 
package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activeSet(isomat, mySolver = "LS", x0 = NULL, ups = 1e-12, check = TRUE, 
maxiter = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="activeSet_+3A_isomat">isomat</code></td>
<td>
<p>Matrix with 2 columns that contains isotonicity conditions, i.e. for row i it holds that fitted value i column 1 &lt;= fitted value i column 2 (see examples)</p>
</td></tr>
<tr><td><code id="activeSet_+3A_mysolver">mySolver</code></td>
<td>
<p>Various functions are pre-defined (see details). Either to funtction name or the corresponding string equivalent can be used. For user-specified functions <code>fSolver</code> with additional 
arguments can be used (see details as well).</p>
</td></tr>
<tr><td><code id="activeSet_+3A_x0">x0</code></td>
<td>
<p>Feasible starting solution. If <code>NULL</code> the null-vector is used internally.</p>
</td></tr>
<tr><td><code id="activeSet_+3A_ups">ups</code></td>
<td>
<p>Upper boundary</p>
</td></tr>
<tr><td><code id="activeSet_+3A_check">check</code></td>
<td>
<p>If TRUE, KKT feasibility checks for isotonicity of the solution are performed</p>
</td></tr>
<tr><td><code id="activeSet_+3A_maxiter">maxiter</code></td>
<td>
<p>Iteration limit</p>
</td></tr>
<tr><td><code id="activeSet_+3A_...">...</code></td>
<td>
<p>Additional arguments for the various solvers (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following solvers are specified. Note that <code>y</code> as the vector of observed values and <code>weights</code> as the vector of weights need to provided through <code>...</code> for each solver (except for <code>fSolver()</code> and <code>sSolver()</code>). Some solvers need additional arguments as described in the corresponding solver help files. More technical details can be found in the package vignette.    
</p>
<p>The pre-specified solvers are the following (we always give the corresponding string equivalent in brackets): 
<code>lsSolver()</code> (<code>"LS"</code>) for least squares with diagonal weights, <code>aSolver()</code> (<code>"asyLS"</code>) for asymmetric least squares, <code>dSolver()</code> (<code>"L1"</code>) for the least absolute value, <code>eSolver()</code> (<code>"L1eps"</code>) minimizes l1-approximation. <code>hSolver()</code> (<code>"huber"</code>) for Huber loss function, <code>iSolver()</code> (<code>"SILF"</code>) for SILF loss (support vector regression), <code>lfSolver()</code> (<code>"GLS"</code>) for general least squares with non-diagonal weights, <code>mSolver()</code> (<code>"chebyshev"</code>) for Chebyshev L-inf norm, <code>oSolver()</code> (<code>"Lp"</code>) for L-p power norm, <code>pSolver()</code> (<code>"quantile"</code>) for quantile loss function, and finally <code>sSolver()</code> (<code>"poisson"</code>) for Poisson likelihood. 
</p>
<p><code>fSolver()</code> for user-specified arbitrary differentiable functions. The arguments <code>fobj</code> (target function ) and <code>gobj</code> (first derivative) must be provided plus any additional arguments used in the definition of <code>fobj</code>. 
</p>


<h3>Value</h3>

<p>Generates an object of class <code>activeset</code>.
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Vector containing the observed values</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>fval</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>constr.vals</code></td>
<td>
<p>Vector with the values of isotonicity constraints</p>
</td></tr>
<tr><td><code>Alambda</code></td>
<td>
<p>Constraint matrix multiplied by lambda (should be equal to gradient)</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>Gradient</p>
</td></tr>
<tr><td><code>isocheck</code></td>
<td>
<p>List containing the KKT checks for stationarity, primal feasibility, dual feasibility, and complementary slackness (&gt;= 0 means feasible)</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan de Leeuw, Kurt Hornik, Patrick Mair</p>


<h3>References</h3>

<p>de Leeuw, J., Hornik, K., Mair, P. (2009). Isotone optimization in R: Active Set methods and pool-adjacent-violators algorithm. 
Journal of Statistical Software, 32(5), 1-24.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpava">gpava</a></code>, <code><a href="#topic+lsSolver">lsSolver</a></code>, <code><a href="#topic+dSolver">dSolver</a></code>, <code><a href="#topic+mSolver">mSolver</a></code>, <code><a href="#topic+fSolver">fSolver</a></code>,
<code><a href="#topic+pSolver">pSolver</a></code>, <code><a href="#topic+lfSolver">lfSolver</a></code>, <code><a href="#topic+oSolver">oSolver</a></code>, <code><a href="#topic+aSolver">aSolver</a></code>, <code><a href="#topic+eSolver">eSolver</a></code>,
<code><a href="#topic+sSolver">sSolver</a></code>, <code><a href="#topic+hSolver">hSolver</a></code>, <code><a href="#topic+iSolver">iSolver</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Data specification
set.seed(12345)
y &lt;- rnorm(9)               ##normal distributed response values
w1 &lt;- rep(1,9)              ##unit weights
Atot &lt;- cbind(1:8, 2:9)     ##Matrix defining isotonicity (total order)
Atot


## Least squares solver (pre-specified and user-specified)
fit.ls1 &lt;- activeSet(Atot, "LS", y = y, weights = w1)
fit.ls1
summary(fit.ls1)
fit.ls2 &lt;- activeSet(Atot, fSolver, fobj = function(x) sum(w1*(x-y)^2), 
gobj = function(x) 2*drop(w1*(x-y)), y = y, weights = w1)

## LS vs. GLS solver (needs weight matrix)
set.seed(12345)
wvec &lt;- 1:9
wmat &lt;- crossprod(matrix(rnorm(81),9,9))/9  
fit.wls &lt;- activeSet(Atot, "LS", y = y, weights = wvec)
fit.gls &lt;- activeSet(Atot, "GLS", y = y, weights = wmat)


## Quantile regression
fit.qua &lt;- activeSet(Atot, "quantile", y = y, weights = wvec, aw = 0.3, bw = 0.7)


## Mean absolute value norm
fit.abs &lt;- activeSet(Atot, "L1", y = y, weights = w1)

## Lp norm
fit.pow &lt;- activeSet(Atot, "Lp", y = y, weights = w1, p = 1.2)

## Chebyshev norm
fit.che &lt;- activeSet(Atot, "chebyshev", y = y, weights = w1)

## Efron's asymmetric LS
fit.asy &lt;- activeSet(Atot, "asyLS", y = y, weights = w1, aw = 2, bw = 1)

## Huber and SILF loss
fit.hub &lt;- activeSet(Atot, "huber", y = y, weights = w1, eps = 1)
fit.svm &lt;- activeSet(Atot, "SILF", y = y, weights = w1, beta = 0.8, eps = 0.2)


## Negative Poisson log-likelihood
set.seed(12345)
yp &lt;- rpois(9,5)
x0 &lt;- 1:9
fit.poi &lt;- activeSet(Atot, "poisson", x0 = x0, y = yp)

## LS on tree ordering
Atree &lt;- matrix(c(1,1,2,2,2,3,3,8,2,3,4,5,6,7,8,9),8,2)
Atree
fit.tree &lt;- activeSet(Atree, "LS", y = y, weights = w1)


## LS on loop ordering
Aloop &lt;- matrix(c(1,2,3,3,4,5,6,6,7,8,3,3,4,5,6,6,7,8,9,9),10,2)
Aloop
fit.loop &lt;- activeSet(Aloop, "LS", y = y, weights = w1)


## LS on block ordering
Ablock &lt;- cbind(c(rep(1,3),rep(2,3),rep(3,3),rep(4,3),rep(5,3),rep(6,3)),c(rep(c(4,5,6),3),
rep(c(7,8,9),3)))
Ablock
fit.block &lt;- activeSet(Ablock, "LS", y = y, weights = w1)

## Isotone LS regression using gpava and active set (same results)
pava.fitted &lt;- gpava(y = y)$x
aset.fitted &lt;- activeSet(Atot, "LS", weights = w1, y = y)$x
mse &lt;- mean((pava.fitted - aset.fitted)^2)
mse
</code></pre>

<hr>
<h2 id='aSolver'>Asymmetric Least Squares</h2><span id='topic+aSolver'></span>

<h3>Description</h3>

<p>Minimizes Efron's asymmetric least squares regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aSolver(z, a, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aSolver_+3A_z">z</code></td>
<td>
<p>Vector containing observed response</p>
</td></tr>
<tr><td><code id="aSolver_+3A_a">a</code></td>
<td>
<p>Matrix with active constraints</p>
</td></tr>
<tr><td><code id="aSolver_+3A_extra">extra</code></td>
<td>
<p>List with element <code>y</code> containing the observed response vector, <code>weights</code> 
with optional observation weights, weight <code>aw</code> for y &gt; x, and weight <code>bw</code> for y &lt;= x</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally in <code>activeSet</code> by setting <code>mySolver = aSolver</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>lbd</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>Gradient at point x</p>
</td></tr>
</table>


<h3>References</h3>

<p>Efron, B. (1991). Regression percentiles using asymmetric squared error loss. Statistica Sinica, 1, 93-125.</p>


<h3>See Also</h3>

<p><code><a href="#topic+activeSet">activeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Fitting isotone regression using active set
set.seed(12345)
y &lt;- rnorm(9)              ##response values
w &lt;- rep(1,9)              ##unit weights
btota &lt;- cbind(1:8, 2:9)   ##Matrix defining isotonicity (total order)
fit.asy &lt;- activeSet(btota, aSolver, weights = w, y = y, aw = 0.3, bw = 0.5)

</code></pre>

<hr>
<h2 id='dSolver'>Absolute Value Norm</h2><span id='topic+dSolver'></span>

<h3>Description</h3>

<p>Solver for the least absolute value norm with optional weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dSolver(z, a, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dSolver_+3A_z">z</code></td>
<td>
<p>Vector containing observed response</p>
</td></tr>
<tr><td><code id="dSolver_+3A_a">a</code></td>
<td>
<p>Matrix with active constraints</p>
</td></tr>
<tr><td><code id="dSolver_+3A_extra">extra</code></td>
<td>
<p>List with element <code>y</code> containing the observed response vector and <code>weights</code> 
with optional observation weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally in <code>activeSet</code> by setting <code>mySolver = dSolver</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>lbd</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>Gradient at point x</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+activeSet">activeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Fitting weighted absolute norm problem
set.seed(12345)
y &lt;- rnorm(9)              ##response values
w &lt;- rep(1,9)              ##unit weights
btota &lt;- cbind(1:8, 2:9)   ##Matrix defining isotonicity (total order)
fit.abs &lt;- activeSet(btota, dSolver, weights = w, y = y)

</code></pre>

<hr>
<h2 id='eSolver'>L1 approximation</h2><span id='topic+eSolver'></span>

<h3>Description</h3>

<p>Solves an L1 approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eSolver(z, a, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eSolver_+3A_z">z</code></td>
<td>
<p>Vector containing observed response</p>
</td></tr>
<tr><td><code id="eSolver_+3A_a">a</code></td>
<td>
<p>Matrix with active constraints</p>
</td></tr>
<tr><td><code id="eSolver_+3A_extra">extra</code></td>
<td>
<p>List with element <code>y</code> containing the observed response vector and <code>weights</code> 
with optional observation weights, <code>eps</code> for the error term</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally in <code>activeSet</code> by setting <code>mySolver = eSolver</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>lbd</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>Gradient at point x</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+activeSet">activeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Fitting isotone regression using active set
set.seed(12345)
y &lt;- rnorm(9)              ##response values
w &lt;- rep(1,9)              ##unit weights
eps = 0.01                 ##error term
btota &lt;- cbind(1:8, 2:9)   ##Matrix defining isotonicity (total order)
fit.approx &lt;- activeSet(btota, eSolver, weights = w, y = y, eps = eps)

</code></pre>

<hr>
<h2 id='fSolver'>User-Specified Loss Function</h2><span id='topic+fSolver'></span>

<h3>Description</h3>

<p>Specification of a differentiable convex loss function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fSolver(z, a, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fSolver_+3A_z">z</code></td>
<td>
<p>Vector containing observed response</p>
</td></tr>
<tr><td><code id="fSolver_+3A_a">a</code></td>
<td>
<p>Matrix with active constraints</p>
</td></tr>
<tr><td><code id="fSolver_+3A_extra">extra</code></td>
<td>
<p>List with element <code>fobj</code> containing the target function and <code>gobj</code> with the 
first derivative</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally in <code>activeSet</code> by setting <code>mySolver = fSolver</code>. It uses
<code>optim()</code> with <code>"BFGS"</code> for optimization.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>lbd</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>Gradient at point x</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+activeSet">activeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Fitting isotone regression using active set (L2-norm user-specified)
set.seed(12345)
y &lt;- rnorm(9)              ##response values
w &lt;- rep(1,9)              ##unit weights
btota &lt;- cbind(1:8, 2:9)   ##Matrix defining isotonicity (total order)
fit.convex &lt;- activeSet(btota, fSolver, fobj = function(x) sum(w*(x-y)^2), 
gobj = function(x) 2*drop(w*(x-y)), y = y, weights = w)
</code></pre>

<hr>
<h2 id='gpava'>Generalized Pooled-Adjacent-Violators Algorithm (PAVA)</h2><span id='topic+gpava'></span><span id='topic+print.pava'></span><span id='topic+plot.pava'></span>

<h3>Description</h3>

<p>Pooled-adjacent-violators algorithm for general isotone regression problems. It allows for general convex target function, 
multiple measurements, and different approaches for handling ties.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpava(z, y, weights = NULL, solver = weighted.mean, ties = "primary", p = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpava_+3A_z">z</code></td>
<td>
<p>Vector of abscissae values</p>
</td></tr>
<tr><td><code id="gpava_+3A_y">y</code></td>
<td>
<p>Vector or list of vectors of responses</p>
</td></tr>
<tr><td><code id="gpava_+3A_weights">weights</code></td>
<td>
<p>Vector of list of vectors of observation weights</p>
</td></tr>
<tr><td><code id="gpava_+3A_solver">solver</code></td>
<td>
<p>Either <code>weighted.mean</code>, <code>weighted.median</code>, <code>weighted.fractile</code>, or 
a user-specified function (see below)</p>
</td></tr>
<tr><td><code id="gpava_+3A_ties">ties</code></td>
<td>
<p>Treatment of ties, either &quot;primary&quot;, &quot;secondary&quot;, or &quot;tertiary&quot;</p>
</td></tr>
<tr><td><code id="gpava_+3A_p">p</code></td>
<td>
<p>Fractile value between 0 and 1 if <code>weighted.fractile</code> is used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Pool Adjacent Violators Algorithm framework for minimizing problems
like 
</p>
<p style="text-align: center;"><code class="reqn">\sum_i \sum_{J_i} w_{ij} f(y_{ij}, m_i)</code>
</p>

<p>under the constraint <code class="reqn">m_1 \le ... \le m_n</code> with <code class="reqn">f</code> a convex function in m. Note that this formulation allows for repeated data in each block
(i.e. each list element of <code>y</code>, and hence is more general than the usual pava/isoreg ones.  
</p>
<p>A solver for the unconstrained <code class="reqn">\sum_k w_k f(y_k, m) -&gt; min!</code> can be specified. 
Typical cases are <code class="reqn">f(y, m) = |y - m|^p</code> for <code class="reqn">p = 2</code> (solved by weighted mean) and <code class="reqn">p = 1</code> (solved by weighted median), respectively. 
</p>
<p>Using the <code>weighted.fractile</code> solver corresponds to the classical minimization procedure in quantile regression. 
</p>
<p>The user can also specify his own function <code>foo(y, w)</code> with responses and weights as arguments. It 
should return a single numerical value. 
</p>


<h3>Value</h3>

<p>Generates an object of class <code>gpava</code>.
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Fitted values</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Observed response</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>Observed predictors</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>Weights</p>
</td></tr>
<tr><td><code>solver</code></td>
<td>
<p>Convex function</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Fractile value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kurt Hornik, Jan de Leeuw, Patrick Mair</p>


<h3>References</h3>

<p>de Leeuw, J., Hornik, K., Mair, P. (2009). Isotone Optimization in R: Pool-Adjacent-Violators 
Algorithm (PAVA) and Active Set Methods. Journal of Statistical Software,  32(5), 1-24. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pituitary)
##different tie approaches
gpava(pituitary[,1],pituitary[,2], ties = "primary")
gpava(pituitary[,1],pituitary[,2], ties = "secondary")
gpava(pituitary[,1],pituitary[,2], ties = "tertiary")

##different target functions
gpava(pituitary[,1],pituitary[,2], solver = weighted.mean)
gpava(pituitary[,1],pituitary[,2], solver = weighted.median)
gpava(pituitary[,1],pituitary[,2], solver = weighted.fractile, p = 0.25)


##repeated measures
data(posturo)
res &lt;- gpava(posturo[,1],posturo[,2:4], ties = "secondary")
plot(res)

</code></pre>

<hr>
<h2 id='hSolver'>Huber Loss Function</h2><span id='topic+hSolver'></span>

<h3>Description</h3>

<p>Solver for Huber's robust loss function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hSolver(z, a, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hSolver_+3A_z">z</code></td>
<td>
<p>Vector containing observed response</p>
</td></tr>
<tr><td><code id="hSolver_+3A_a">a</code></td>
<td>
<p>Matrix with active constraints</p>
</td></tr>
<tr><td><code id="hSolver_+3A_extra">extra</code></td>
<td>
<p>List with element <code>y</code> containing the observed response vector and <code>weights</code> 
with optional observation weights, and <code>eps</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally in <code>activeSet</code> by setting <code>mySolver = hSolver</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>lbd</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>Gradient at point x</p>
</td></tr>
</table>


<h3>References</h3>

<p>Huber, P. (1982). Robust Statistics. Chichester: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+activeSet">activeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Fitting isotone regression using active set
set.seed(12345)
y &lt;- rnorm(9)              ##response values
w &lt;- rep(1,9)              ##unit weights
eps &lt;- 0.01
btota &lt;- cbind(1:8, 2:9)   ##Matrix defining isotonicity (total order)
fit.huber &lt;- activeSet(btota, hSolver, weights = w, y = y, eps = eps)

</code></pre>

<hr>
<h2 id='iSolver'>SILF Loss</h2><span id='topic+iSolver'></span>

<h3>Description</h3>

<p>Minimizes soft insensitive loss function (SILF) for support vector regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iSolver(z, a, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iSolver_+3A_z">z</code></td>
<td>
<p>Vector containing observed response</p>
</td></tr>
<tr><td><code id="iSolver_+3A_a">a</code></td>
<td>
<p>Matrix with active constraints</p>
</td></tr>
<tr><td><code id="iSolver_+3A_extra">extra</code></td>
<td>
<p>List with element <code>y</code> containing the observed response vector, <code>weights</code> 
with optional observation weights, <code>beta</code> between 0 and 1, and <code>eps</code> &gt; 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally in <code>activeSet</code> by setting <code>mySolver = iSolver</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>lbd</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>Gradient at point x</p>
</td></tr>
</table>


<h3>References</h3>

<p>Efron, B. (1991). Regression percentiles using asymmetric squared error loss. Statistica Sinica, 1, 93-125.</p>


<h3>See Also</h3>

<p><code><a href="#topic+activeSet">activeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Fitting isotone regression using active set
set.seed(12345)
y &lt;- rnorm(9)              ##response values
w &lt;- rep(1,9)              ##unit weights
eps &lt;- 2
beta &lt;- 0.4

btota &lt;- cbind(1:8, 2:9)   ##Matrix defining isotonicity (total order)
fit.silf &lt;- activeSet(btota, iSolver, weights = w, y = y, beta = beta, eps = eps)

</code></pre>

<hr>
<h2 id='lfSolver'>General Least Squares Loss Function</h2><span id='topic+lfSolver'></span>

<h3>Description</h3>

<p>Solver for the general least squares monotone regression problem of the form
(y-x)'W(y-x). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfSolver(z, a, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfSolver_+3A_z">z</code></td>
<td>
<p>Vector containing observed response</p>
</td></tr>
<tr><td><code id="lfSolver_+3A_a">a</code></td>
<td>
<p>Matrix with active constraints</p>
</td></tr>
<tr><td><code id="lfSolver_+3A_extra">extra</code></td>
<td>
<p>List with element <code>y</code> containing the observed response vector and <code>weights</code> 
as weight matrix W which is not necessarily positive definite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally in <code>activeSet</code> by setting <code>mySolver = lfSolver</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>lbd</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>Gradient at point x</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+activeSet">activeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Fitting isotone regression 
set.seed(12345)
y &lt;- rnorm(9)              ##response values
w &lt;- diag(rep(1,9))        ##unit weight matrix
btota &lt;- cbind(1:8, 2:9)   ##Matrix defining isotonicity (total order)
#fit.lf &lt;- activeSet(btota, lfSolver, weights = w, y = y)

</code></pre>

<hr>
<h2 id='lsSolver'>Least Squares Loss Function</h2><span id='topic+lsSolver'></span>

<h3>Description</h3>

<p>Solver for the least squares monotone regression problem with optional weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsSolver(z, a, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsSolver_+3A_z">z</code></td>
<td>
<p>Vector containing observed response</p>
</td></tr>
<tr><td><code id="lsSolver_+3A_a">a</code></td>
<td>
<p>Matrix with active constraints</p>
</td></tr>
<tr><td><code id="lsSolver_+3A_extra">extra</code></td>
<td>
<p>List with element <code>y</code> containing the observed response vector and <code>weights</code> 
with optional observation weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally in <code>activeSet</code> by setting <code>mySolver = lsSolver</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>lbd</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>Gradient at point x</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+activeSet">activeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Fitting isotone regression using active set
set.seed(12345)
y &lt;- rnorm(9)              ##response values
w &lt;- rep(1,9)              ##unit weights
btota &lt;- cbind(1:8, 2:9)   ##Matrix defining isotonicity (total order)
fit.ls &lt;- activeSet(btota, lsSolver, weights = w, y = y)

</code></pre>

<hr>
<h2 id='mendota'>Number of freezing days at Lake Mendota</h2><span id='topic+mendota'></span>

<h3>Description</h3>

<p>This dataset shows the number of freezing days at Lake Mendota measured from November, 23, in the year 1854. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mendota)</code></pre>


<h3>Format</h3>

<p>A data frame with 12 subjects.
</p>


<h3>References</h3>

<p>Bhattacharyya, G. K., &amp; Klotz, J. H. (1966). The bivariate trend of Lake Mendota. Technical Report No. 98, Department of Statistics, University of Wisconsin.
</p>
<p>Barlow, R. E., Bartholomew, D. J., Bremner, J. M., &amp; Brunk, H. D. (1972). Statistical inference under order restrictions: The theory and application of isotonic regression. Chichester: Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mendota)
</code></pre>

<hr>
<h2 id='mregnn'>Regression with Linear Inequality Restrictions on Predicted Values</h2><span id='topic+mregnn'></span><span id='topic+mregnnM'></span><span id='topic+mregnnP'></span>

<h3>Description</h3>

<p>The package contains three functions for fitting regressions with inequality restrictions:
<code>mregnn</code> is the most general one, allowing basically for any partial orders, <code>mregnnM</code> poses a monotone restriction on the fitted values, <code>mregnnP</code> restricts the predicted values to be positive. Monre details can be found below. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mregnn(x, y, a)
mregnnM(x, y)
mregnnP(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mregnn_+3A_x">x</code></td>
<td>
<p>Can be a spline basis.</p>
</td></tr>
<tr><td><code id="mregnn_+3A_y">y</code></td>
<td>
<p>Response.</p>
</td></tr>
<tr><td><code id="mregnn_+3A_a">a</code></td>
<td>
<p>Matrix containing order restrictions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions solve the problem 
</p>
<p style="text-align: center;"><code class="reqn">
f(b) = \frac{1}{2}(y - Xb)'(y - Xb)
</code>
</p>

<p>over all <code class="reqn">b</code> for which <code class="reqn">A'Xb \geq 0</code>. <code class="reqn">A</code> can be used require the transformation to be non-negative, or increasing, or satisfying any partial order. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>xb</code></td>
<td>
<p>Predicted values.</p>
</td></tr>
<tr><td><code>lb</code></td>
<td>
<p>Solution of the dual problem.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
</table>


<h3>References</h3>

<p>de Leeuw, J. (2015). Regression with Linear Inequality Restrictions on Predicted Values. <a href="http://rpubs.com/deleeuw/78897">http://rpubs.com/deleeuw/78897</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compute the best fitting quadratic polynomial (in black) 
## and monotone quadratic polynomial (in blue)
set.seed(12345)
x &lt;- outer(1:10,1:3,"^")
x &lt;- apply(x,2,function(x)
x - mean(x))
x &lt;- apply (x,2,function(x)
x / sqrt (sum(x ^ 2)))
y &lt;- rowSums(x) + rnorm(10)
plot(x[,1], y, lwd = 3, col = "RED", xlab = "x", ylab = "P(x)")
o &lt;- mregnnM(x,y)
lines(x[,1], o$xb, col = "BLUE", lwd = 2)
xb &lt;- drop(x %*% qr.solve(x,y))
lines(x[,1],xb,col="BLACK", lwd = 2)

## same monotone model through basic mregnn()
difmat &lt;- function (n) {
  m1 &lt;- ifelse(outer(1:(n - 1),1:n,"-") == -1, 1, 0)
  m2 &lt;- ifelse(outer(1:(n - 1),1:n,"-") == 0,-1, 0)
  return (m1 + m2)
}
a &lt;- difmat(nrow(x))      ## order restriction
o2 &lt;- mregnn(x, y, a)
</code></pre>

<hr>
<h2 id='mSolver'>Chebyshev norm</h2><span id='topic+mSolver'></span>

<h3>Description</h3>

<p>Solver for the Chebyshev norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mSolver(z, a, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mSolver_+3A_z">z</code></td>
<td>
<p>Vector containing observed response</p>
</td></tr>
<tr><td><code id="mSolver_+3A_a">a</code></td>
<td>
<p>Matrix with active constraints</p>
</td></tr>
<tr><td><code id="mSolver_+3A_extra">extra</code></td>
<td>
<p>List with element <code>y</code> containing the observed response vector and <code>weights</code> 
with optional observation weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally in <code>activeSet</code> by setting <code>mySolver = mSolver</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>lbd</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>Gradient at point x</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+activeSet">activeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Fitting isotone regression using active set
set.seed(12345)
y &lt;- rnorm(9)              ##response values
w &lt;- rep(1,9)              ##unit weights
btota &lt;- cbind(1:8, 2:9)   ##Matrix defining isotonicity (total order)
fit.cheby &lt;- activeSet(btota, mSolver, weights = w, y = y)

</code></pre>

<hr>
<h2 id='oSolver'>Lp norm</h2><span id='topic+oSolver'></span>

<h3>Description</h3>

<p>Solver for Lp-norm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>oSolver(z, a, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oSolver_+3A_z">z</code></td>
<td>
<p>Vector containing observed response</p>
</td></tr>
<tr><td><code id="oSolver_+3A_a">a</code></td>
<td>
<p>Matrix with active constraints</p>
</td></tr>
<tr><td><code id="oSolver_+3A_extra">extra</code></td>
<td>
<p>List with element <code>y</code> containing the observed response vector, <code>weights</code> 
as an optional weight vector, and <code>p</code> as the exponent for the Lp-norm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally in <code>activeSet</code> by setting <code>mySolver = oSolver</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>lbd</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>Gradient at point x</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+activeSet">activeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Fitting isotone regression 
set.seed(12345)
y &lt;- rnorm(9)               ##normal distributed response values
w1 &lt;- rep(1,9)              ##unit weights
Atot &lt;- cbind(1:8, 2:9)     ##Matrix defining isotonicity (total order)
fit.pow &lt;- activeSet(Atot, oSolver, y = y, weights = w1, p = 1.2)

</code></pre>

<hr>
<h2 id='pituitary'>Size of pituitary fissue</h2><span id='topic+pituitary'></span>

<h3>Description</h3>

<p>The University of Carolina conducted a study in which the size (in mm) of the pituitary fissure was measured on girls between an age of 8 and 14.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pituitary)</code></pre>


<h3>Format</h3>

<p>A data frame with 11 subjects.
</p>


<h3>References</h3>

<p>Pothoff, R. F., &amp; Roy, S. N. (1964). A generalized multivariate analysis of variance model useful especially for growth curve problems. Biometrika, 51, 313-326.
</p>
<p>Robertson, T., Wright, F. T., &amp; Dykstra, R. L. (1988). Order restricted statistical inference. New York, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pituitary)
</code></pre>

<hr>
<h2 id='posturo'>Repeated posturographic measures</h2><span id='topic+posturo'></span>

<h3>Description</h3>

<p>This dataset represents a subset from the posturographic data collected in Leitner et al. (sensory organisation test SOT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(posturo)</code></pre>


<h3>Format</h3>

<p>A data frame with 50 subjects, age as predictor and 3 repeated SOT measures as responses.
</p>


<h3>References</h3>

<p>Leitner, C., Mair, P., Paul, B., Wick, F., Mittermaier, C., Sycha, T., &amp; Ebenbichler, G. (2009). Reliability of posturographic measurements in the assessment of impaired sensorimotor function in chronic low back pain. Journal of Electromyography and Kinesiology, 19(3), 380-390.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(posturo)
</code></pre>

<hr>
<h2 id='pSolver'>Quantile Regression</h2><span id='topic+pSolver'></span>

<h3>Description</h3>

<p>Solver for the general p-quantile monotone regression problem with optional weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pSolver(z, a, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pSolver_+3A_z">z</code></td>
<td>
<p>Vector containing observed response</p>
</td></tr>
<tr><td><code id="pSolver_+3A_a">a</code></td>
<td>
<p>Matrix with active constraints</p>
</td></tr>
<tr><td><code id="pSolver_+3A_extra">extra</code></td>
<td>
<p>List with element <code>y</code> containing the observed response vector, <code>weights</code> 
with optional observation weights, <code>aw</code> and <code>bw</code> as quantile weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally in <code>activeSet</code> by setting <code>mySolver = pSolver</code>. Note
that if <code>aw</code> = <code>bw</code>, we get the weighted median and therefore we solved the weighted absolute norm.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>lbd</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>Gradient at point x</p>
</td></tr>
</table>


<h3>References</h3>

<p>Koenker, R. (2005). Quantile regression. Cambridge, MA: Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+activeSet">activeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Fitting quantile regression
set.seed(12345)
y &lt;- rnorm(9)              ##response values
w &lt;- rep(1,9)              ##unit weights
btota &lt;- cbind(1:8, 2:9)   ##Matrix defining isotonicity (total order)
fit.p &lt;- activeSet(btota, pSolver, weights = w, y = y, aw = 0.3, bw = 0.7)

</code></pre>

<hr>
<h2 id='sSolver'>Negative Poisson Log-Likelihood</h2><span id='topic+sSolver'></span>

<h3>Description</h3>

<p>Solver for the negative Poisson log-likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sSolver(z, a, extra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sSolver_+3A_z">z</code></td>
<td>
<p>Vector containing observed response</p>
</td></tr>
<tr><td><code id="sSolver_+3A_a">a</code></td>
<td>
<p>Matrix with active constraints</p>
</td></tr>
<tr><td><code id="sSolver_+3A_extra">extra</code></td>
<td>
<p>List with element <code>y</code> containing the observed response vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally in <code>activeSet</code> by setting <code>mySolver = sSolver</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Vector containing the fitted values</p>
</td></tr>
<tr><td><code>lbd</code></td>
<td>
<p>Vector with Lagrange multipliers</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Value of the target function</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>Gradient at point x</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+activeSet">activeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Minimizing Poisson log-liklihood
set.seed(12345)
yp &lt;- rpois(9,5)
Atot &lt;- cbind(1:8, 2:9)     ##Matrix defining isotonicity (total order)
x0 &lt;- 1:9                   ##starting values
fit.poi &lt;- activeSet(Atot, sSolver, x0 = x0, y = yp)
</code></pre>

<hr>
<h2 id='weighted.fractile'>Weighted Median</h2><span id='topic+weighted.fractile'></span>

<h3>Description</h3>

<p>Computes the weighted fractile of a numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.fractile(y, w, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.fractile_+3A_y">y</code></td>
<td>
<p>A numeric vector containing the values whose fractile is to be computed</p>
</td></tr>
<tr><td><code id="weighted.fractile_+3A_w">w</code></td>
<td>
<p>A vector of length <code>y</code> giving the weights to use for each element of <code>y</code></p>
</td></tr>
<tr><td><code id="weighted.fractile_+3A_p">p</code></td>
<td>
<p>Fractile specification; value between 0 and 1</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>, <code><a href="#topic+weighted.median">weighted.median</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- 1:9
w &lt;- c(rep(1,5), rep(2,4))
res &lt;- weighted.fractile(y, w, p = 0.33)
</code></pre>

<hr>
<h2 id='weighted.median'>Weighted Median</h2><span id='topic+weighted.median'></span>

<h3>Description</h3>

<p>Computes a weighted median of a numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.median(y, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.median_+3A_y">y</code></td>
<td>
<p>A numeric vector containing the values whose median is to be computed</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_w">w</code></td>
<td>
<p>A vector of length <code>y</code> giving the weights to use for each element of <code>y</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>, <code><a href="#topic+weighted.fractile">weighted.fractile</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- 1:9
w &lt;- c(rep(1,5), rep(2,4))
res &lt;- weighted.median(y, w)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
