<!DOCTYPE html><html><head><title>Help for package FunCC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FunCC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#find_best_delta'><p>Functional Cheng and Church Algorithm varying the delta value</p></a></li>
<li><a href='#funcc_biclust'><p>Functional Cheng and Church algorithm</p></a></li>
<li><a href='#funcc_show_bicluster_coverage'><p>plotting coverage of each bi-cluster</p></a></li>
<li><a href='#funcc_show_bicluster_dimension'><p>plotting dimensions of each bi-cluster</p></a></li>
<li><a href='#funcc_show_bicluster_hscore'><p>plotting hscore of each bi-cluster on bicluster dimension</p></a></li>
<li><a href='#funcc_show_block_matrix'><p>Plotting co-clustering results of funCC on the data matrix</p></a></li>
<li><a href='#funcc_show_results'><p>Plotting co-clustering results of funCC</p></a></li>
<li><a href='#funCCdata'><p>Simulated data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functional Cheng and Church Bi-Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Agostino Torti [aut, cre], Marta Galvani [aut, cre], Alessandra Menafoglio [aut], Simone Vantini[aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Agostino Torti &lt;agostino.torti@polimi.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The FunCC algorithm allows to apply the FunCC algorithm to simultaneously cluster the rows and the columns of a data matrix whose inputs are functions. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>narray, biclust, reshape, RColorBrewer, ggplot2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-29 10:05:29 UTC; martagalvani</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-08 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='find_best_delta'>Functional Cheng and Church Algorithm varying the delta value</h2><span id='topic+find_best_delta'></span>

<h3>Description</h3>

<p>The find_best_delta function evaluate the results of FunCC algorithm in terms of total H-score value, the number of obtained bi-clusters and the number of not assigned elements when varying the delta value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_best_delta(
  fun_mat,
  delta_min,
  delta_max,
  num_delta = 10,
  template.type = "mean",
  theta = 1.5,
  number = 100,
  alpha = 0,
  beta = 0,
  const_alpha = FALSE,
  const_beta = FALSE,
  shift.alignement = FALSE,
  shift.max = 0.1,
  max.iter.align = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_best_delta_+3A_fun_mat">fun_mat</code></td>
<td>
<p>The data array (n x m x T) where each entry corresponds to the measure of one observation i, i=1,...,n, for a functional variable m, m=1,...,p, at point t, t=1,...,T</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_delta_min">delta_min</code></td>
<td>
<p>scalar: Manimum value of the maximum of accepted score, should be a real value &gt; 0</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_delta_max">delta_max</code></td>
<td>
<p>scalar: Maximum value of the maximum of accepted score, should be a real value &gt; 0</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_num_delta">num_delta</code></td>
<td>
<p>integer: number of delta to be evaluated between delta_min and delta_max</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_template.type">template.type</code></td>
<td>
<p>character: type of template required. If template.type='mean' the template is evaluated as the average function, if template.type='medoid' the template is evaluated as the medoid function.</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_theta">theta</code></td>
<td>
<p>scalar: Scaling factor should be a real value &gt; 1</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_number">number</code></td>
<td>
<p>integer: Maximum number of iterations</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_alpha">alpha</code></td>
<td>
<p>binary: if alpha=1 row shift is allowed, if alpha=0 row shift is avoided</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_beta">beta</code></td>
<td>
<p>binary: if beta=1 row shift is allowed, if beta=0 row shift is avoided</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_const_alpha">const_alpha</code></td>
<td>
<p>logicol: indicates if row shift is contrained as constant</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_const_beta">const_beta</code></td>
<td>
<p>logicol: indicates if col shift is contrained as constant</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_shift.alignement">shift.alignement</code></td>
<td>
<p>logicol: If shift.alignement=True the shift aligment is performed, if shift.alignement=False no alignment is performed</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_shift.max">shift.max</code></td>
<td>
<p>scalar: shift.max controls the maximal allowed shift, at each iteration, in the alignment procedure with respect to the range of curve domains. t.max must be such that 0&lt;shift.max&lt;1</p>
</td></tr>
<tr><td><code id="find_best_delta_+3A_max.iter.align">max.iter.align</code></td>
<td>
<p>integer: maximum number of iteration in the alignment procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing for each evaluated delta: Htot_sum (the sum of totale H-score), num_clust (the number of found Bi-clusters), not_assigned (the number of not assigned elements)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
data("funCCdata")
find_best_delta(funCCdata,delta_min=0.1,delta_max=20,num_delta=20,alpha=1,beta=0,const_alpha=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='funcc_biclust'>Functional Cheng and Church algorithm</h2><span id='topic+funcc_biclust'></span>

<h3>Description</h3>

<p>The funCC algorithm allows to simultaneously cluster the rows and the columns of a data matrix where each entry of the matrix is a function or a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funcc_biclust(
  fun_mat,
  delta,
  theta = 1,
  template.type = "mean",
  number = 100,
  alpha = 0,
  beta = 0,
  const_alpha = FALSE,
  const_beta = FALSE,
  shift.alignement = FALSE,
  shift.max = 0.1,
  max.iter.align = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funcc_biclust_+3A_fun_mat">fun_mat</code></td>
<td>
<p>The data array (n x m x T) where each entry corresponds to the measure of one observation i, i=1,...,n, for a functional variable m, m=1,...,p, at point t, t=1,...,T</p>
</td></tr>
<tr><td><code id="funcc_biclust_+3A_delta">delta</code></td>
<td>
<p>scalar: Maximum of accepted score, should be a real value &gt; 0</p>
</td></tr>
<tr><td><code id="funcc_biclust_+3A_theta">theta</code></td>
<td>
<p>scalar: Scaling factor should be a real value &gt; 1</p>
</td></tr>
<tr><td><code id="funcc_biclust_+3A_template.type">template.type</code></td>
<td>
<p>character: type of template required. If template.type='mean' the template is evaluated as the average function, if template.type='medoid' the template is evaluated as the medoid function.</p>
</td></tr>
<tr><td><code id="funcc_biclust_+3A_number">number</code></td>
<td>
<p>integer: Maximum number of iteration</p>
</td></tr>
<tr><td><code id="funcc_biclust_+3A_alpha">alpha</code></td>
<td>
<p>binary: if alpha=1 row shift is allowed, if alpha=0 row shift is avoided</p>
</td></tr>
<tr><td><code id="funcc_biclust_+3A_beta">beta</code></td>
<td>
<p>binary: if beta=1 row shift is allowed, if beta=0 row shift is avoided</p>
</td></tr>
<tr><td><code id="funcc_biclust_+3A_const_alpha">const_alpha</code></td>
<td>
<p>logicol: Indicates if row shift is contrained as constant.</p>
</td></tr>
<tr><td><code id="funcc_biclust_+3A_const_beta">const_beta</code></td>
<td>
<p>logicol: Indicates if col shift is contrained as constant.</p>
</td></tr>
<tr><td><code id="funcc_biclust_+3A_shift.alignement">shift.alignement</code></td>
<td>
<p>logicol: If shift.alignement=True the shift aligment is performed, if shift.alignement=False no alignment is performed</p>
</td></tr>
<tr><td><code id="funcc_biclust_+3A_shift.max">shift.max</code></td>
<td>
<p>scalar: shift.max controls the maximal allowed shift, at each iteration, in the alignment procedure with respect to the range of curve domains. t.max must be such that 0&lt;shift.max&lt;1</p>
</td></tr>
<tr><td><code id="funcc_biclust_+3A_max.iter.align">max.iter.align</code></td>
<td>
<p>integer: maximum number of iteration in the alignment procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two elements containing respectively the Biclustresults and a dataframe containing the parameters setting of the algorithm
@examples  
data(&quot;funCCdata&quot;)
res &lt;- funcc_biclust(funCCdata,delta=10,theta=1,alpha=1,beta=0,const_alpha=TRUE)
res
</p>

<hr>
<h2 id='funcc_show_bicluster_coverage'>plotting coverage of each bi-cluster</h2><span id='topic+funcc_show_bicluster_coverage'></span>

<h3>Description</h3>

<p>funcc_show_bicluster_coverage graphically shows the coverage of each bi-cluster in terms of percentage of included functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funcc_show_bicluster_coverage(
  fun_mat,
  res_input,
  not_assigned = TRUE,
  max_coverage = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funcc_show_bicluster_coverage_+3A_fun_mat">fun_mat</code></td>
<td>
<p>The data array (n x m x T) where each entry corresponds to the measure of one observation i, i=1,...,n, for a functional variable m, m=1,...,p, at point t, t=1,...,T</p>
</td></tr>
<tr><td><code id="funcc_show_bicluster_coverage_+3A_res_input">res_input</code></td>
<td>
<p>An object produced by the funcc_biclust function</p>
</td></tr>
<tr><td><code id="funcc_show_bicluster_coverage_+3A_not_assigned">not_assigned</code></td>
<td>
<p>logicol: if true also the cluster of not assigned elements is included</p>
</td></tr>
<tr><td><code id="funcc_show_bicluster_coverage_+3A_max_coverage">max_coverage</code></td>
<td>
<p>scalar: percentage of maximum cumulative coverage to be shown</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a figure representing for each bi-cluster the coverage in terms of percentage of included functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data("funCCdata")
res &lt;- funcc_biclust(funCCdata,delta=10,theta=1,alpha=1,beta=0,const_alpha=TRUE)
funcc_show_bicluster_coverage(funCCdata,res)
</code></pre>

<hr>
<h2 id='funcc_show_bicluster_dimension'>plotting dimensions of each bi-cluster</h2><span id='topic+funcc_show_bicluster_dimension'></span>

<h3>Description</h3>

<p>funcc_show_bicluster_dimension graphically shows the dimensions of each bi-cluster (i.e. number of rows and columns)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funcc_show_bicluster_dimension(fun_mat, res_input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funcc_show_bicluster_dimension_+3A_fun_mat">fun_mat</code></td>
<td>
<p>The data array (n x m x T) where each entry corresponds to the measure of one observation i, i=1,...,n, for a functional variable m, m=1,...,p, at point t, t=1,...,T</p>
</td></tr>
<tr><td><code id="funcc_show_bicluster_dimension_+3A_res_input">res_input</code></td>
<td>
<p>An object produced by the funcc_biclust function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a figure representing the dimensions of each bi-cluster (i.e. number of rows and columns)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data("funCCdata")
res &lt;- funcc_biclust(funCCdata,delta=10,theta=1,alpha=1,beta=0,const_alpha=TRUE)
funcc_show_bicluster_dimension(funCCdata,res)

</code></pre>

<hr>
<h2 id='funcc_show_bicluster_hscore'>plotting hscore of each bi-cluster on bicluster dimension</h2><span id='topic+funcc_show_bicluster_hscore'></span>

<h3>Description</h3>

<p>funcc_show_bicluster_hscore graphically shows the hscore vs the dimension (i.e. number of rows and columns) of each bi-cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funcc_show_bicluster_hscore(fun_mat, res_input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funcc_show_bicluster_hscore_+3A_fun_mat">fun_mat</code></td>
<td>
<p>The data array (n x m x T) where each entry corresponds to the measure of one observation i, i=1,...,n, for a functional variable m, m=1,...,p, at point t, t=1,...,T</p>
</td></tr>
<tr><td><code id="funcc_show_bicluster_hscore_+3A_res_input">res_input</code></td>
<td>
<p>An object produced by the funcc_biclust function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a figure representing the dimensions of each bi-cluster (i.e. number of rows and columns)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data("funCCdata")
res &lt;- funcc_biclust(funCCdata,delta=10,theta=1,alpha=1,beta=0,const_alpha=TRUE)
funcc_show_bicluster_hscore(funCCdata,res)

</code></pre>

<hr>
<h2 id='funcc_show_block_matrix'>Plotting co-clustering results of funCC on the data matrix</h2><span id='topic+funcc_show_block_matrix'></span>

<h3>Description</h3>

<p>funcc_show_block_matrix graphically shows the bi-clusters positions in the original data matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funcc_show_block_matrix(fun_mat, res_input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funcc_show_block_matrix_+3A_fun_mat">fun_mat</code></td>
<td>
<p>The data array (n x m x T) where each entry corresponds to the measure of one observation i, i=1,...,n, for a functional variable m, m=1,...,p, at point t, t=1,...,T</p>
</td></tr>
<tr><td><code id="funcc_show_block_matrix_+3A_res_input">res_input</code></td>
<td>
<p>An object produced by the funcc_biclust function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a figure representing the bi-clusters positions in the original data matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data("funCCdata")
res &lt;- funcc_biclust(funCCdata,delta=10,theta=1,alpha=1,beta=0,const_alpha=TRUE)
funcc_show_block_matrix(funCCdata,res)
</code></pre>

<hr>
<h2 id='funcc_show_results'>Plotting co-clustering results of funCC</h2><span id='topic+funcc_show_results'></span>

<h3>Description</h3>

<p>funcc_show_results graphically shows the results of the bi-clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funcc_show_results(
  fun_mat,
  res_input,
  only.mean = FALSE,
  aligned = FALSE,
  warping = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funcc_show_results_+3A_fun_mat">fun_mat</code></td>
<td>
<p>The data array (n x m x T) where each entry corresponds to the measure of one observation i, i=1,...,n, for a functional variable m, m=1,...,p, at point t, t=1,...,T</p>
</td></tr>
<tr><td><code id="funcc_show_results_+3A_res_input">res_input</code></td>
<td>
<p>An object produced by the funcc_biclust function</p>
</td></tr>
<tr><td><code id="funcc_show_results_+3A_only.mean">only.mean</code></td>
<td>
<p>logicol: if True only the template functions for each bi-cluster is displayed</p>
</td></tr>
<tr><td><code id="funcc_show_results_+3A_aligned">aligned</code></td>
<td>
<p>logicol: if True the alignemd functions are displayed</p>
</td></tr>
<tr><td><code id="funcc_show_results_+3A_warping">warping</code></td>
<td>
<p>logicol: if True also a figure representing the warping functions are displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a figure representing each bi-cluster in terms of functions contained in it or templates
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data("funCCdata")
res &lt;- funcc_biclust(funCCdata,delta=10,theta=1,alpha=1,beta=0,const_alpha=TRUE)
funcc_show_results(funCCdata,res)
</code></pre>

<hr>
<h2 id='funCCdata'>Simulated data</h2><span id='topic+funCCdata'></span>

<h3>Description</h3>

<p>funCC.data is a functional dataset displaying block structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(funCCdata)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>array</code> of dimension 30 x 7 x 240.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(funCCdata)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
