<!DOCTYPE html><html><head><title>Help for package CVXR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CVXR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CVXR-package'><p>CVXR: Disciplined Convex Optimization in R</p></a></li>
<li><a href='#-+2CExpression+2Cmissing-method'><p>The NegExpression class.</p></a></li>
<li><a href='#.build_matrix_0'><p>Get the <code>sparse</code> flag field for the LinOp object</p></a></li>
<li><a href='#.build_matrix_1'><p>Get the <code>sparse</code> flag field for the LinOp object</p></a></li>
<li><a href='#.decomp_quad'><p>Compute a Matrix Decomposition.</p></a></li>
<li><a href='#.LinOp__args_push_back'><p>Perform a push back operation on the <code>args</code> field of LinOp</p></a></li>
<li><a href='#.LinOp__get_dense_data'><p>Get the field <code>dense_data</code> for the LinOp object</p></a></li>
<li><a href='#.LinOp__get_id'><p>Get the id field of the LinOp Object</p></a></li>
<li><a href='#.LinOp__get_size'><p>Get the field <code>size</code> for the LinOp object</p></a></li>
<li><a href='#.LinOp__get_slice'><p>Get the slice field of the LinOp Object</p></a></li>
<li><a href='#.LinOp__get_sparse'><p>Get the <code>sparse</code> flag field for the LinOp object</p></a></li>
<li><a href='#.LinOp__get_sparse_data'><p>Get the field named <code>sparse_data</code> from the LinOp object</p></a></li>
<li><a href='#.LinOp__get_type'><p>Get the field named <code>type</code> for the LinOp object</p></a></li>
<li><a href='#.LinOp__new'><p>Create a new LinOp object.</p></a></li>
<li><a href='#.LinOp__set_dense_data'><p>Set the field <code>dense_data</code> of the LinOp object</p></a></li>
<li><a href='#.LinOp__set_size'><p>Set the field <code>size</code> of the LinOp object</p></a></li>
<li><a href='#.LinOp__set_slice'><p>Set the slice field of the LinOp Object</p></a></li>
<li><a href='#.LinOp__set_sparse'><p>Set the flag <code>sparse</code> of the LinOp object</p></a></li>
<li><a href='#.LinOp__set_sparse_data'><p>Set the field named <code>sparse_data</code> of the LinOp object</p></a></li>
<li><a href='#.LinOp__set_type'><p>Set the field named <code>type</code> for the LinOp object</p></a></li>
<li><a href='#.LinOp__size_push_back'><p>Perform a push back operation on the <code>size</code> field of LinOp</p></a></li>
<li><a href='#.LinOp__slice_push_back'><p>Perform a push back operation on the <code>slice</code> field of LinOp</p></a></li>
<li><a href='#.LinOp_at_index'><p>Return the LinOp element at index i (0-based)</p></a></li>
<li><a href='#.LinOpVector__new'><p>Create a new LinOpVector object.</p></a></li>
<li><a href='#.LinOpVector__push_back'><p>Perform a push back operation on the <code>args</code> field of LinOp</p></a></li>
<li><a href='#.p_norm'><p>Internal method for calculating the p-norm</p></a></li>
<li><a href='#.ProblemData__get_const_to_row'><p>Get the const_to_row field of the ProblemData Object</p></a></li>
<li><a href='#.ProblemData__get_const_vec'><p>Get the const_vec field from the ProblemData Object</p></a></li>
<li><a href='#.ProblemData__get_I'><p>Get the I field of the ProblemData Object</p></a></li>
<li><a href='#.ProblemData__get_id_to_col'><p>Get the id_to_col field of the ProblemData Object</p></a></li>
<li><a href='#.ProblemData__get_J'><p>Get the J field of the ProblemData Object</p></a></li>
<li><a href='#.ProblemData__get_V'><p>Get the V field of the ProblemData Object</p></a></li>
<li><a href='#.ProblemData__new'><p>Create a new ProblemData object.</p></a></li>
<li><a href='#.ProblemData__set_const_to_row'><p>Set the const_to_row map of the ProblemData Object</p></a></li>
<li><a href='#.ProblemData__set_const_vec'><p>Set the const_vec field in the ProblemData Object</p></a></li>
<li><a href='#.ProblemData__set_I'><p>Set the I field in the ProblemData Object</p></a></li>
<li><a href='#.ProblemData__set_id_to_col'><p>Set the id_to_col field of the ProblemData Object</p></a></li>
<li><a href='#.ProblemData__set_J'><p>Set the J field in the ProblemData Object</p></a></li>
<li><a href='#.ProblemData__set_V'><p>Set the V field in the ProblemData Object</p></a></li>
<li><a href='#+5B+2CExpression+2Cindex+2Cmissing+2CANY-method'><p>The SpecialIndex class.</p></a></li>
<li><a href='#+5B+2CExpression+2Cmissing+2Cmissing+2CANY-method'><p>The Index class.</p></a></li>
<li><a href='#+2A+2CExpression+2CExpression-method'><p>Elementwise multiplication operator</p></a></li>
<li><a href='#+2F+2CExpression+2CExpression-method'><p>The DivExpression class.</p></a></li>
<li><a href='#+26lt+3B+3D+2CExpression+2CExpression-method'><p>The IneqConstraint class</p></a></li>
<li><a href='#+25+2A+25+2CExpression+2CExpression-method'><p>The MulExpression class.</p></a></li>
<li><a href='#+25+26gt+3B+26gt+3B+25'><p>The PSDConstraint class.</p></a></li>
<li><a href='#+5E+2CExpression+2Cnumeric-method'><p>Elementwise Power</p></a></li>
<li><a href='#+2B+2CExpression+2Cmissing-method'><p>The AddExpression class.</p></a></li>
<li><a href='#+3D+3D+2CExpression+2CExpression-method'><p>The EqConstraint class</p></a></li>
<li><a href='#Abs-class'><p>The Abs class.</p></a></li>
<li><a href='#abs+2CExpression-method'><p>Absolute Value</p></a></li>
<li><a href='#accepts'><p>Reduction Acceptance</p></a></li>
<li><a href='#AffAtom-class'><p>The AffAtom class.</p></a></li>
<li><a href='#are_args_affine'><p>Are the arguments affine?</p></a></li>
<li><a href='#Atom-class'><p>The Atom class.</p></a></li>
<li><a href='#AxisAtom-class'><p>The AxisAtom class.</p></a></li>
<li><a href='#BinaryOperator-class'><p>The BinaryOperator class.</p></a></li>
<li><a href='#bmat'><p>Block Matrix</p></a></li>
<li><a href='#CallbackParam-class'><p>The CallbackParam class.</p></a></li>
<li><a href='#Canonical-class'><p>The Canonical class.</p></a></li>
<li><a href='#Canonicalization-class'><p>The Canonicalization class.</p></a></li>
<li><a href='#canonicalize'><p>Canonicalize</p></a></li>
<li><a href='#CBC_CONIC-class'><p>An interface to the CBC solver</p></a></li>
<li><a href='#cdiac'><p>Global Monthly and Annual Temperature Anomalies (degrees C), 1850-2015</p>
(Relative to the 1961-1990 Mean) (May 2016)</a></li>
<li><a href='#Chain-class'><p>The Chain class.</p></a></li>
<li><a href='#complex-atoms'><p>Complex Numbers</p></a></li>
<li><a href='#complex-methods'><p>Complex Properties</p></a></li>
<li><a href='#Complex2Real-class'><p>Lifts complex numbers to a real representation.</p></a></li>
<li><a href='#Complex2Real.abs_canon'><p>Complex canonicalizer for the absolute value atom</p></a></li>
<li><a href='#Complex2Real.add'><p>Helper function to sum arguments.</p></a></li>
<li><a href='#Complex2Real.at_least_2D'><p>Upcast 0D and 1D to 2D.</p></a></li>
<li><a href='#Complex2Real.binary_canon'><p>Complex canonicalizer for the binary atom</p></a></li>
<li><a href='#Complex2Real.canonicalize_expr'><p>Canonicalizes a Complex Expression</p></a></li>
<li><a href='#Complex2Real.canonicalize_tree'><p>Recursively Canonicalizes a Complex Expression.</p></a></li>
<li><a href='#Complex2Real.conj_canon'><p>Complex canonicalizer for the conjugate atom</p></a></li>
<li><a href='#Complex2Real.constant_canon'><p>Complex canonicalizer for the constant atom</p></a></li>
<li><a href='#Complex2Real.hermitian_canon'><p>Complex canonicalizer for the hermitian atom</p></a></li>
<li><a href='#Complex2Real.imag_canon'><p>Complex canonicalizer for the imaginary atom</p></a></li>
<li><a href='#Complex2Real.join'><p>Helper function to combine arguments.</p></a></li>
<li><a href='#Complex2Real.lambda_sum_largest_canon'><p>Complex canonicalizer for the largest sum atom</p></a></li>
<li><a href='#Complex2Real.matrix_frac_canon'><p>Complex canonicalizer for the matrix fraction atom</p></a></li>
<li><a href='#Complex2Real.nonpos_canon'><p>Complex canonicalizer for the non-positive atom</p></a></li>
<li><a href='#Complex2Real.norm_nuc_canon'><p>Complex canonicalizer for the nuclear norm atom</p></a></li>
<li><a href='#Complex2Real.param_canon'><p>Complex canonicalizer for the parameter matrix atom</p></a></li>
<li><a href='#Complex2Real.pnorm_canon'><p>Complex canonicalizer for the p norm atom</p></a></li>
<li><a href='#Complex2Real.psd_canon'><p>Complex canonicalizer for the positive semidefinite atom</p></a></li>
<li><a href='#Complex2Real.quad_canon'><p>Complex canonicalizer for the quadratic atom</p></a></li>
<li><a href='#Complex2Real.quad_over_lin_canon'><p>Complex canonicalizer for the quadratic over linear term atom</p></a></li>
<li><a href='#Complex2Real.real_canon'><p>Complex canonicalizer for the real atom</p></a></li>
<li><a href='#Complex2Real.separable_canon'><p>Complex canonicalizer for the separable atom</p></a></li>
<li><a href='#Complex2Real.soc_canon'><p>Complex canonicalizer for the SOC atom</p></a></li>
<li><a href='#Complex2Real.variable_canon'><p>Complex canonicalizer for the variable atom</p></a></li>
<li><a href='#Complex2Real.zero_canon'><p>Complex canonicalizer for the zero atom</p></a></li>
<li><a href='#cone-methods'><p>Second-Order Cone Methods</p></a></li>
<li><a href='#ConeDims-class'><p>Summary of cone dimensions present in constraints.</p></a></li>
<li><a href='#ConeMatrixStuffing-class'><p>Construct Matrices for Linear Cone Problems</p></a></li>
<li><a href='#ConicSolver-class'><p>The ConicSolver class.</p></a></li>
<li><a href='#ConicSolver.get_coeff_offset'><p>Return the coefficient and offset in <code class="reqn">Ax + b</code>.</p></a></li>
<li><a href='#ConicSolver.get_spacing_matrix'><p>Returns a sparse matrix that spaces out an expression.</p></a></li>
<li><a href='#Conjugate-class'><p>The Conjugate class.</p></a></li>
<li><a href='#Constant-class'><p>The Constant class.</p></a></li>
<li><a href='#ConstantSolver-class'><p>The ConstantSolver class.</p></a></li>
<li><a href='#constr_value'><p>Is Constraint Violated?</p></a></li>
<li><a href='#Constraint-class'><p>The Constraint class.</p></a></li>
<li><a href='#construct_intermediate_chain+2CProblem+2Clist-method'><p>Builds a chain that rewrites a problem into an intermediate representation suitable for numeric reductions.</p></a></li>
<li><a href='#construct_solving_chain'><p>Build a reduction chain from a problem to an installed solver.</p></a></li>
<li><a href='#conv'><p>Discrete Convolution</p></a></li>
<li><a href='#Conv-class'><p>The Conv class.</p></a></li>
<li><a href='#CPLEX_CONIC-class'><p>An interface for the CPLEX solver</p></a></li>
<li><a href='#CPLEX_QP-class'><p>An interface for the CPLEX solver.</p></a></li>
<li><a href='#cummax_axis'><p>Cumulative Maximum</p></a></li>
<li><a href='#CumMax-class'><p>The CumMax class.</p></a></li>
<li><a href='#cumsum_axis'><p>Cumulative Sum</p></a></li>
<li><a href='#CumSum-class'><p>The CumSum class.</p></a></li>
<li><a href='#curvature'><p>Curvature of Expression</p></a></li>
<li><a href='#curvature-atom'><p>Curvature of an Atom</p></a></li>
<li><a href='#curvature-comp'><p>Curvature of Composition</p></a></li>
<li><a href='#curvature-methods'><p>Curvature Properties</p></a></li>
<li><a href='#CvxAttr2Constr-class'><p>The CvxAttr2Constr class.</p></a></li>
<li><a href='#CVXOPT-class'><p>An interface for the CVXOPT solver.</p></a></li>
<li><a href='#cvxr_norm'><p>Matrix Norm (Alternative)</p></a></li>
<li><a href='#Dcp2Cone-class'><p>Reduce DCP Problem to Conic Form</p></a></li>
<li><a href='#Dcp2Cone.entr_canon'><p>Dcp2Cone canonicalizer for the entropy atom</p></a></li>
<li><a href='#Dcp2Cone.exp_canon'><p>Dcp2Cone canonicalizer for the exponential atom</p></a></li>
<li><a href='#Dcp2Cone.geo_mean_canon'><p>Dcp2Cone canonicalizer for the geometric mean atom</p></a></li>
<li><a href='#Dcp2Cone.huber_canon'><p>Dcp2Cone canonicalizer for the huber atom</p></a></li>
<li><a href='#Dcp2Cone.indicator_canon'><p>Dcp2Cone canonicalizer for the indicator atom</p></a></li>
<li><a href='#Dcp2Cone.kl_div_canon'><p>Dcp2Cone canonicalizer for the KL Divergence atom</p></a></li>
<li><a href='#Dcp2Cone.lambda_max_canon'><p>Dcp2Cone canonicalizer for the lambda maximization atom</p></a></li>
<li><a href='#Dcp2Cone.lambda_sum_largest_canon'><p>Dcp2Cone canonicalizer for the largest lambda sum atom</p></a></li>
<li><a href='#Dcp2Cone.log_canon'><p>Dcp2Cone canonicalizer for the log atom</p></a></li>
<li><a href='#Dcp2Cone.log_det_canon'><p>Dcp2Cone canonicalizer for the log determinant atom</p></a></li>
<li><a href='#Dcp2Cone.log_sum_exp_canon'><p>Dcp2Cone canonicalizer for the log sum of the exp atom</p></a></li>
<li><a href='#Dcp2Cone.log1p_canon'><p>Dcp2Cone canonicalizer for the log 1p atom</p></a></li>
<li><a href='#Dcp2Cone.logistic_canon'><p>Dcp2Cone canonicalizer for the logistic function atom</p></a></li>
<li><a href='#Dcp2Cone.matrix_frac_canon'><p>Dcp2Cone canonicalizer for the matrix fraction atom</p></a></li>
<li><a href='#Dcp2Cone.normNuc_canon'><p>Dcp2Cone canonicalizer for the nuclear norm atom</p></a></li>
<li><a href='#Dcp2Cone.pnorm_canon'><p>Dcp2Cone canonicalizer for the p norm atom</p></a></li>
<li><a href='#Dcp2Cone.power_canon'><p>Dcp2Cone canonicalizer for the power atom</p></a></li>
<li><a href='#Dcp2Cone.quad_form_canon'><p>Dcp2Cone canonicalizer for the quadratic form atom</p></a></li>
<li><a href='#Dcp2Cone.quad_over_lin_canon'><p>Dcp2Cone canonicalizer for the quadratic over linear term atom</p></a></li>
<li><a href='#Dcp2Cone.sigma_max_canon'><p>Dcp2Cone canonicalizer for the sigma max atom</p></a></li>
<li><a href='#Dgp2Dcp-class'><p>Reduce DGP problems to DCP problems.</p></a></li>
<li><a href='#Dgp2Dcp.add_canon'><p>Dgp2Dcp canonicalizer for the addition atom</p></a></li>
<li><a href='#Dgp2Dcp.constant_canon'><p>Dgp2Dcp canonicalizer for the constant atom</p></a></li>
<li><a href='#Dgp2Dcp.div_canon'><p>Dgp2Dcp canonicalizer for the division atom</p></a></li>
<li><a href='#Dgp2Dcp.exp_canon'><p>Dgp2Dcp canonicalizer for the exp atom</p></a></li>
<li><a href='#Dgp2Dcp.eye_minus_inv_canon'><p>Dgp2Dcp canonicalizer for the <code class="reqn">(I - X)^{-1}</code> atom</p></a></li>
<li><a href='#Dgp2Dcp.geo_mean_canon'><p>Dgp2Dcp canonicalizer for the geometric mean atom</p></a></li>
<li><a href='#Dgp2Dcp.log_canon'><p>Dgp2Dcp canonicalizer for the log atom</p></a></li>
<li><a href='#Dgp2Dcp.mul_canon'><p>Dgp2Dcp canonicalizer for the multiplication atom</p></a></li>
<li><a href='#Dgp2Dcp.mulexpression_canon'><p>Dgp2Dcp canonicalizer for the multiplication expression atom</p></a></li>
<li><a href='#Dgp2Dcp.nonpos_constr_canon'><p>Dgp2Dcp canonicalizer for the non-positive constraint atom</p></a></li>
<li><a href='#Dgp2Dcp.norm_inf_canon'><p>Dgp2Dcp canonicalizer for the infinite norm atom</p></a></li>
<li><a href='#Dgp2Dcp.norm1_canon'><p>Dgp2Dcp canonicalizer for the 1 norm atom</p></a></li>
<li><a href='#Dgp2Dcp.one_minus_pos_canon'><p>Dgp2Dcp canonicalizer for the 1-x atom</p></a></li>
<li><a href='#Dgp2Dcp.parameter_canon'><p>Dgp2Dcp canonicalizer for the parameter atom</p></a></li>
<li><a href='#Dgp2Dcp.pf_eigenvalue_canon'><p>Dgp2Dcp canonicalizer for the spectral radius atom</p></a></li>
<li><a href='#Dgp2Dcp.pnorm_canon'><p>Dgp2Dcp canonicalizer for the p norm atom</p></a></li>
<li><a href='#Dgp2Dcp.power_canon'><p>Dgp2Dcp canonicalizer for the power atom</p></a></li>
<li><a href='#Dgp2Dcp.prod_canon'><p>Dgp2Dcp canonicalizer for the product atom</p></a></li>
<li><a href='#Dgp2Dcp.quad_form_canon'><p>Dgp2Dcp canonicalizer for the quadratic form atom</p></a></li>
<li><a href='#Dgp2Dcp.quad_over_lin_canon'><p>Dgp2Dcp canonicalizer for the quadratic over linear term atom</p></a></li>
<li><a href='#Dgp2Dcp.sum_canon'><p>Dgp2Dcp canonicalizer for the sum atom</p></a></li>
<li><a href='#Dgp2Dcp.trace_canon'><p>Dgp2Dcp canonicalizer for the trace atom</p></a></li>
<li><a href='#Dgp2Dcp.zero_constr_canon'><p>Dgp2Dcp canonicalizer for the zero constraint atom</p></a></li>
<li><a href='#DgpCanonMethods-class'><p>DGP canonical methods class.</p></a></li>
<li><a href='#Diag'><p>Turns an expression into a DiagVec object</p></a></li>
<li><a href='#diag+2CExpression-method'><p>Matrix Diagonal</p></a></li>
<li><a href='#DiagMat-class'><p>The DiagMat class.</p></a></li>
<li><a href='#DiagVec-class'><p>The DiagVec class.</p></a></li>
<li><a href='#Diff'><p>Takes the k-th order differences</p></a></li>
<li><a href='#diff+2CExpression-method'><p>Lagged and Iterated Differences</p></a></li>
<li><a href='#DiffPos'><p>The DiffPos atom.</p></a></li>
<li><a href='#dim_from_args'><p>Atom Dimensions</p></a></li>
<li><a href='#domain'><p>Domain</p></a></li>
<li><a href='#dspop'><p>Direct Standardization: Population</p></a></li>
<li><a href='#dssamp'><p>Direct Standardization: Sample</p></a></li>
<li><a href='#dual_value-methods'><p>Get and Set Dual Value</p></a></li>
<li><a href='#ECOS_BB-class'><p>An interface for the ECOS BB solver.</p></a></li>
<li><a href='#ECOS-class'><p>An interface for the ECOS solver</p></a></li>
<li><a href='#ECOS.dims_to_solver_dict'><p>Utility method for formatting a ConeDims instance into a dictionary</p>
that can be supplied to ECOS.</a></li>
<li><a href='#Elementwise-class'><p>The Elementwise class.</p></a></li>
<li><a href='#EliminatePwl-class'><p>The EliminatePwl class.</p></a></li>
<li><a href='#EliminatePwl.abs_canon'><p>EliminatePwl canonicalizer for the absolute atom</p></a></li>
<li><a href='#EliminatePwl.cummax_canon'><p>EliminatePwl canonicalizer for the cumulative max atom</p></a></li>
<li><a href='#EliminatePwl.cumsum_canon'><p>EliminatePwl canonicalizer for the cumulative sum atom</p></a></li>
<li><a href='#EliminatePwl.max_elemwise_canon'><p>EliminatePwl canonicalizer for the elementwise maximum atom</p></a></li>
<li><a href='#EliminatePwl.max_entries_canon'><p>EliminatePwl canonicalizer for the max entries atom</p></a></li>
<li><a href='#EliminatePwl.min_elemwise_canon'><p>EliminatePwl canonicalizer for the elementwise minimum atom</p></a></li>
<li><a href='#EliminatePwl.min_entries_canon'><p>EliminatePwl canonicalizer for the minimum entries atom</p></a></li>
<li><a href='#EliminatePwl.norm_inf_canon'><p>EliminatePwl canonicalizer for the infinite norm atom</p></a></li>
<li><a href='#EliminatePwl.norm1_canon'><p>EliminatePwl canonicalizer for the 1 norm atom</p></a></li>
<li><a href='#EliminatePwl.sum_largest_canon'><p>EliminatePwl canonicalizer for the largest sum atom</p></a></li>
<li><a href='#entr'><p>Entropy Function</p></a></li>
<li><a href='#Entr-class'><p>The Entr class.</p></a></li>
<li><a href='#EvalParams-class'><p>The EvalParams class.</p></a></li>
<li><a href='#Exp-class'><p>The Exp class.</p></a></li>
<li><a href='#exp+2CExpression-method'><p>Natural Exponential</p></a></li>
<li><a href='#ExpCone-class'><p>The ExpCone class.</p></a></li>
<li><a href='#Expression-class'><p>The Expression class.</p></a></li>
<li><a href='#expression-parts'><p>Parts of an Expression Leaf</p></a></li>
<li><a href='#extract_dual_value'><p>Gets a specified value of a dual variable.</p></a></li>
<li><a href='#extract_mip_idx'><p>Coalesces bool, int indices for variables.</p></a></li>
<li><a href='#eye_minus_inv'><p>Unity Resolvent</p></a></li>
<li><a href='#EyeMinusInv-class'><p>The EyeMinusInv class.</p></a></li>
<li><a href='#FlipObjective-class'><p>The FlipObjective class.</p></a></li>
<li><a href='#format_constr'><p>Format Constraints</p></a></li>
<li><a href='#geo_mean'><p>Geometric Mean</p></a></li>
<li><a href='#GeoMean-class'><p>The GeoMean class.</p></a></li>
<li><a href='#get_data'><p>Get Expression Data</p></a></li>
<li><a href='#get_dual_values'><p>Gets the values of the dual variables.</p></a></li>
<li><a href='#get_id'><p>Get ID</p></a></li>
<li><a href='#get_np'><p>Get numpy handle</p></a></li>
<li><a href='#get_problem_data'><p>Get Problem Data</p></a></li>
<li><a href='#get_sp'><p>Get scipy handle</p></a></li>
<li><a href='#GLPK_MI-class'><p>An interface for the GLPK MI solver.</p></a></li>
<li><a href='#GLPK-class'><p>An interface for the GLPK solver.</p></a></li>
<li><a href='#grad'><p>Sub/Super-Gradient</p></a></li>
<li><a href='#graph_implementation'><p>Graph Implementation</p></a></li>
<li><a href='#group_constraints'><p>Organize the constraints into a dictionary keyed by constraint names.</p></a></li>
<li><a href='#GUROBI_CONIC-class'><p>An interface for the GUROBI conic solver.</p></a></li>
<li><a href='#GUROBI_QP-class'><p>An interface for the GUROBI_QP solver.</p></a></li>
<li><a href='#harmonic_mean'><p>Harmonic Mean</p></a></li>
<li><a href='#HarmonicMean'><p>The HarmonicMean atom.</p></a></li>
<li><a href='#hstack'><p>Horizontal Concatenation</p></a></li>
<li><a href='#HStack-class'><p>The HStack class.</p></a></li>
<li><a href='#huber'><p>Huber Function</p></a></li>
<li><a href='#Huber-class'><p>The Huber class.</p></a></li>
<li><a href='#id'><p>Identification Number</p></a></li>
<li><a href='#Imag-class'><p>The Imag class.</p></a></li>
<li><a href='#import_solver'><p>Import Solver</p></a></li>
<li><a href='#installed_solvers'><p>List installed solvers</p></a></li>
<li><a href='#inv_pos'><p>Reciprocal Function</p></a></li>
<li><a href='#InverseData-class'><p>The InverseData class.</p></a></li>
<li><a href='#invert'><p>Return Original Solution</p></a></li>
<li><a href='#is_dcp'><p>DCP Compliance</p></a></li>
<li><a href='#is_dgp'><p>DGP Compliance</p></a></li>
<li><a href='#is_mixed_integer'><p>Is Problem Mixed Integer?</p></a></li>
<li><a href='#is_qp'><p>Is Problem a QP?</p></a></li>
<li><a href='#is_stuffed_cone_constraint'><p>Is the constraint a stuffed cone constraint?</p></a></li>
<li><a href='#is_stuffed_cone_objective'><p>Is the objective a stuffed cone objective?</p></a></li>
<li><a href='#is_stuffed_qp_objective'><p>Is the QP objective stuffed?</p></a></li>
<li><a href='#kl_div'><p>Kullback-Leibler Divergence</p></a></li>
<li><a href='#KLDiv-class'><p>The KLDiv class.</p></a></li>
<li><a href='#Kron-class'><p>The Kron class.</p></a></li>
<li><a href='#kronecker+2CExpression+2CANY-method'><p>Kronecker Product</p></a></li>
<li><a href='#lambda_max'><p>Maximum Eigenvalue</p></a></li>
<li><a href='#lambda_min'><p>Minimum Eigenvalue</p></a></li>
<li><a href='#lambda_sum_largest'><p>Sum of Largest Eigenvalues</p></a></li>
<li><a href='#lambda_sum_smallest'><p>Sum of Smallest Eigenvalues</p></a></li>
<li><a href='#LambdaMax-class'><p>The LambdaMax class.</p></a></li>
<li><a href='#LambdaMin'><p>The LambdaMin atom.</p></a></li>
<li><a href='#LambdaSumLargest-class'><p>The LambdaSumLargest class.</p></a></li>
<li><a href='#LambdaSumSmallest'><p>The LambdaSumSmallest atom.</p></a></li>
<li><a href='#leaf-attr'><p>Attributes of an Expression Leaf</p></a></li>
<li><a href='#Leaf-class'><p>The Leaf class.</p></a></li>
<li><a href='#linearize'><p>Affine Approximation to an Expression</p></a></li>
<li><a href='#ListORConstr-class'><p>A Class Union of List and Constraint</p></a></li>
<li><a href='#log_det'><p>Log-Determinant</p></a></li>
<li><a href='#log_log_curvature'><p>Log-Log Curvature of Expression</p></a></li>
<li><a href='#log_log_curvature-atom'><p>Log-Log Curvature of an Atom</p></a></li>
<li><a href='#log_log_curvature-methods'><p>Log-Log Curvature Properties</p></a></li>
<li><a href='#log_sum_exp'><p>Log-Sum-Exponential</p></a></li>
<li><a href='#Log-class'><p>The Log class.</p></a></li>
<li><a href='#log+2CExpression-method'><p>Logarithms</p></a></li>
<li><a href='#Log1p-class'><p>The Log1p class.</p></a></li>
<li><a href='#LogDet-class'><p>The LogDet class.</p></a></li>
<li><a href='#logistic'><p>Logistic Function</p></a></li>
<li><a href='#Logistic-class'><p>The Logistic class.</p></a></li>
<li><a href='#LogSumExp-class'><p>The LogSumExp class.</p></a></li>
<li><a href='#matrix_frac'><p>Matrix Fraction</p></a></li>
<li><a href='#matrix_prop-methods'><p>Matrix Properties</p></a></li>
<li><a href='#matrix_trace'><p>Matrix Trace</p></a></li>
<li><a href='#MatrixFrac-class'><p>The MatrixFrac class.</p></a></li>
<li><a href='#MatrixStuffing-class'><p>The MatrixStuffing class.</p></a></li>
<li><a href='#max_elemwise'><p>Elementwise Maximum</p></a></li>
<li><a href='#max_entries'><p>Maximum</p></a></li>
<li><a href='#MaxElemwise-class'><p>The MaxElemwise class.</p></a></li>
<li><a href='#MaxEntries-class'><p>The MaxEntries class.</p></a></li>
<li><a href='#Maximize-class'><p>The Maximize class.</p></a></li>
<li><a href='#mean.Expression'><p>Arithmetic Mean</p></a></li>
<li><a href='#min_elemwise'><p>Elementwise Minimum</p></a></li>
<li><a href='#min_entries'><p>Minimum</p></a></li>
<li><a href='#MinElemwise-class'><p>The MinElemwise class.</p></a></li>
<li><a href='#MinEntries-class'><p>The MinEntries class.</p></a></li>
<li><a href='#Minimize-class'><p>The Minimize class.</p></a></li>
<li><a href='#mip_capable'><p>Solver Capabilities</p></a></li>
<li><a href='#mixed_norm'><p>Mixed Norm</p></a></li>
<li><a href='#MixedNorm'><p>The MixedNorm atom.</p></a></li>
<li><a href='#MOSEK-class'><p>An interface for the MOSEK solver.</p></a></li>
<li><a href='#MOSEK.parse_dual_vars'><p>Parses MOSEK dual variables into corresponding CVXR constraints and dual values</p></a></li>
<li><a href='#MOSEK.recover_dual_variables'><p>Recovers MOSEK solutions dual variables</p></a></li>
<li><a href='#multiply'><p>Elementwise Multiplication</p></a></li>
<li><a href='#Multiply-class'><p>The Multiply class.</p></a></li>
<li><a href='#name'><p>Variable, Parameter, or Expression Name</p></a></li>
<li><a href='#neg'><p>Elementwise Negative</p></a></li>
<li><a href='#Neg'><p>An alias for -MinElemwise(x, 0)</p></a></li>
<li><a href='#NonlinearConstraint-class'><p>The NonlinearConstraint class.</p></a></li>
<li><a href='#NonPosConstraint-class'><p>The NonPosConstraint class</p></a></li>
<li><a href='#Norm'><p>The Norm atom.</p></a></li>
<li><a href='#norm_inf'><p>Infinity-Norm</p></a></li>
<li><a href='#norm_nuc'><p>Nuclear Norm</p></a></li>
<li><a href='#norm+2CExpression+2Ccharacter-method'><p>Matrix Norm</p></a></li>
<li><a href='#norm1'><p>1-Norm</p></a></li>
<li><a href='#Norm1-class'><p>The Norm1 class.</p></a></li>
<li><a href='#norm2'><p>Euclidean Norm</p></a></li>
<li><a href='#Norm2'><p>The Norm2 atom.</p></a></li>
<li><a href='#NormInf-class'><p>The NormInf class.</p></a></li>
<li><a href='#NormNuc-class'><p>The NormNuc class.</p></a></li>
<li><a href='#Objective-arith'><p>Arithmetic Operations on Objectives</p></a></li>
<li><a href='#Objective-class'><p>The Objective class.</p></a></li>
<li><a href='#one_minus_pos'><p>Difference on Restricted Domain</p></a></li>
<li><a href='#OneMinusPos-class'><p>The OneMinusPos class.</p></a></li>
<li><a href='#OSQP-class'><p>An interface for the OSQP solver.</p></a></li>
<li><a href='#p_norm'><p>P-Norm</p></a></li>
<li><a href='#Parameter-class'><p>The Parameter class.</p></a></li>
<li><a href='#perform'><p>Perform Reduction</p></a></li>
<li><a href='#pf_eigenvalue'><p>Perron-Frobenius Eigenvalue</p></a></li>
<li><a href='#PfEigenvalue-class'><p>The PfEigenvalue class.</p></a></li>
<li><a href='#Pnorm-class'><p>The Pnorm class.</p></a></li>
<li><a href='#pos'><p>Elementwise Positive</p></a></li>
<li><a href='#Pos'><p>An alias for MaxElemwise(x, 0)</p></a></li>
<li><a href='#Power-class'><p>The Power class.</p></a></li>
<li><a href='#Problem-arith'><p>Arithmetic Operations on Problems</p></a></li>
<li><a href='#Problem-class'><p>The Problem class.</p></a></li>
<li><a href='#problem-parts'><p>Parts of a Problem</p></a></li>
<li><a href='#prod_entries'><p>Product of Entries</p></a></li>
<li><a href='#ProdEntries-class'><p>The ProdEntries class.</p></a></li>
<li><a href='#project-methods'><p>Project Value</p></a></li>
<li><a href='#Promote-class'><p>The Promote class.</p></a></li>
<li><a href='#psd_coeff_offset'><p>Given a problem returns a PSD constraint</p></a></li>
<li><a href='#PSDWrap-class'><p>The PSDWrap class.</p></a></li>
<li><a href='#psolve'><p>Solve a DCP Problem</p></a></li>
<li><a href='#Qp2SymbolicQp-class'><p>The Qp2SymbolicQp class.</p></a></li>
<li><a href='#QpMatrixStuffing-class'><p>The QpMatrixStuffing class.</p></a></li>
<li><a href='#QpSolver-class'><p>A QP solver interface.</p></a></li>
<li><a href='#quad_form'><p>Quadratic Form</p></a></li>
<li><a href='#quad_over_lin'><p>Quadratic over Linear</p></a></li>
<li><a href='#QuadForm-class'><p>The QuadForm class.</p></a></li>
<li><a href='#QuadOverLin-class'><p>The QuadOverLin class.</p></a></li>
<li><a href='#Rdict-class'><p>The Rdict class.</p></a></li>
<li><a href='#Rdictdefault-class'><p>The Rdictdefault class.</p></a></li>
<li><a href='#Real-class'><p>The Real class.</p></a></li>
<li><a href='#reduce'><p>Reduce a Problem</p></a></li>
<li><a href='#Reduction-class'><p>The Reduction class.</p></a></li>
<li><a href='#ReductionSolver-class'><p>The ReductionSolver class.</p></a></li>
<li><a href='#resetOptions'><p>Reset Options</p></a></li>
<li><a href='#reshape_expr'><p>Reshape an Expression</p></a></li>
<li><a href='#Reshape-class'><p>The Reshape class.</p></a></li>
<li><a href='#residual-methods'><p>Constraint Residual</p></a></li>
<li><a href='#retrieve'><p>Retrieve Solution</p></a></li>
<li><a href='#scaled_lower_tri'><p>Utility methods for special handling of semidefinite constraints.</p></a></li>
<li><a href='#scalene'><p>Scalene Function</p></a></li>
<li><a href='#SCS-class'><p>An interface for the SCS solver</p></a></li>
<li><a href='#SCS.dims_to_solver_dict'><p>Utility method for formatting a ConeDims instance into a dictionary</p>
that can be supplied to SCS.</a></li>
<li><a href='#SCS.extract_dual_value'><p>Extracts the dual value for constraint starting at offset.</p></a></li>
<li><a href='#setIdCounter'><p>Set ID Counter</p></a></li>
<li><a href='#sigma_max'><p>Maximum Singular Value</p></a></li>
<li><a href='#SigmaMax-class'><p>The SigmaMax class.</p></a></li>
<li><a href='#sign_from_args'><p>Atom Sign</p></a></li>
<li><a href='#sign-methods'><p>Sign Properties</p></a></li>
<li><a href='#sign+2CExpression-method'><p>Sign of Expression</p></a></li>
<li><a href='#size'><p>Size of Expression</p></a></li>
<li><a href='#size-methods'><p>Size Properties</p></a></li>
<li><a href='#SizeMetrics-class'><p>The SizeMetrics class.</p></a></li>
<li><a href='#SOC-class'><p>The SOC class.</p></a></li>
<li><a href='#SOCAxis-class'><p>The SOCAxis class.</p></a></li>
<li><a href='#Solution-class'><p>The Solution class.</p></a></li>
<li><a href='#SolverStats-class'><p>The SolverStats class.</p></a></li>
<li><a href='#SolvingChain-class'><p>The SolvingChain class.</p></a></li>
<li><a href='#sqrt+2CExpression-method'><p>Square Root</p></a></li>
<li><a href='#square+2CExpression-method'><p>Square</p></a></li>
<li><a href='#sum_entries'><p>Sum of Entries</p></a></li>
<li><a href='#sum_largest'><p>Sum of Largest Values</p></a></li>
<li><a href='#sum_smallest'><p>Sum of Smallest Values</p></a></li>
<li><a href='#sum_squares'><p>Sum of Squares</p></a></li>
<li><a href='#SumEntries-class'><p>The SumEntries class.</p></a></li>
<li><a href='#SumLargest-class'><p>The SumLargest class.</p></a></li>
<li><a href='#SumSmallest'><p>The SumSmallest atom.</p></a></li>
<li><a href='#SumSquares'><p>The SumSquares atom.</p></a></li>
<li><a href='#SymbolicQuadForm-class'><p>The SymbolicQuadForm class.</p></a></li>
<li><a href='#t.Expression'><p>Matrix Transpose</p></a></li>
<li><a href='#to_numeric'><p>Numeric Value of Atom</p></a></li>
<li><a href='#TotalVariation'><p>The TotalVariation atom.</p></a></li>
<li><a href='#Trace-class'><p>The Trace class.</p></a></li>
<li><a href='#Transpose-class'><p>The Transpose class.</p></a></li>
<li><a href='#tri_to_full'><p>Expands lower triangular to full matrix.</p></a></li>
<li><a href='#tv'><p>Total Variation</p></a></li>
<li><a href='#UnaryOperator-class'><p>The UnaryOperator class.</p></a></li>
<li><a href='#unpack_results'><p>Parse output from a solver and updates problem state</p></a></li>
<li><a href='#upper_tri'><p>Upper Triangle of a Matrix</p></a></li>
<li><a href='#UpperTri-class'><p>The UpperTri class.</p></a></li>
<li><a href='#validate_args'><p>Validate Arguments</p></a></li>
<li><a href='#validate_val'><p>Validate Value</p></a></li>
<li><a href='#value-methods'><p>Get or Set Value</p></a></li>
<li><a href='#Variable-class'><p>The Variable class.</p></a></li>
<li><a href='#vec'><p>Vectorization of a Matrix</p></a></li>
<li><a href='#vectorized_lower_tri_to_mat'><p>Turns symmetric 2D array into a lower triangular matrix</p></a></li>
<li><a href='#vstack'><p>Vertical Concatenation</p></a></li>
<li><a href='#VStack-class'><p>The VStack class.</p></a></li>
<li><a href='#Wrap-class'><p>The Wrap class.</p></a></li>
<li><a href='#ZeroConstraint-class'><p>The ZeroConstraint class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Disciplined Convex Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-12</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cvxr.rbind.io">https://cvxr.rbind.io</a>, <a href="https://www.cvxgrp.org/CVXR/">https://www.cvxgrp.org/CVXR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cvxgrp/CVXR/issues">https://github.com/cvxgrp/CVXR/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>An object-oriented modeling language for disciplined
    convex programming (DCP) as described in Fu, Narasimhan, and Boyd
    (2020, &lt;<a href="https://doi.org/10.18637%2Fjss.v094.i14">doi:10.18637/jss.v094.i14</a>&gt;). It allows the user to
    formulate convex optimization problems in a natural way following
    mathematical convention and DCP rules. The system analyzes the
    problem, verifies its convexity, converts it into a canonical
    form, and hands it off to an appropriate solver to obtain the
    solution. Interfaces to solvers on CRAN and elsewhere are
    provided, both commercial and open source.</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://bnaras.github.io/drat">https://bnaras.github.io/drat</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, R6, Matrix, Rcpp (&ge; 0.12.12), bit64, gmp, Rmpfr,
ECOSolveR (&ge; 0.5.4), scs (&ge; 3.0), stats, osqp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, nnls, slam, covr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a> | file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'CVXR.R' 'data.R' 'globals.R' 'generics.R' 'interface.R'
'canonical.R' 'expressions.R' 'constant.R' 'variable.R'
'lin_ops.R' 'atoms.R' 'affine.R' 'problem.R' 'constraints.R'
'elementwise.R' 'coeff_extractor.R' 'reductions.R'
'reduction_solvers.R' 'complex2real.R' 'conic_solvers.R'
'eliminate_pwl.R' 'dcp2cone.R' 'dgp2dcp.R' 'qp2quad_form.R'
'qp_solvers.R' 'utilities.R' 'solver_utilities.R'
'transforms.R' 'exports.R' 'rcppUtils.R' 'R6List.R'
'ProblemData-R6.R' 'LinOp-R6.R' 'LinOpVector-R6.R'
'RcppExports.R' 'CVXcanon-R6.R' 'Deque.R' 'canonInterface.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Enhances:</td>
<td>Rcplex, gurobi, rcbc, cccp, Rmosek, Rglpk</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-01 06:11:15 UTC; naras</td>
</tr>
<tr>
<td>Author:</td>
<td>Anqi Fu [aut, cre],
  Balasubramanian Narasimhan [aut],
  David W Kang [aut],
  Steven Diamond [aut],
  John Miller [aut],
  Stephen Boyd [ctb],
  Paul Kunsberg Rosenfield [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anqi Fu &lt;anqif@alumni.stanford.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 00:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CVXR-package'>CVXR: Disciplined Convex Optimization in R</h2><span id='topic+CVXR-package'></span><span id='topic+CVXR'></span>

<h3>Description</h3>

<p>CVXR is an R package that provides an object-oriented modeling
language for convex optimization, similar to CVX, CVXPY, YALMIP,
and Convex.jl. This domain specific language (DSL) allows the user
to formulate convex optimization problems in a natural mathematical
syntax rather than the restrictive standard form required by most
solvers. The user specifies an objective and set of constraints by
combining constants, variables, and parameters using a library of
functions with known mathematical properties. CVXR then applies
signed disciplined convex programming (DCP) to verify the problem's
convexity. Once verified, the problem is converted into standard
conic form using graph implementations and passed to a cone solver
such as ECOS or SCS.
</p>


<h3>Author(s)</h3>

<p>Anqi Fu, Balasubramanian Narasimhan, John Miller, Steven Diamond, Stephen Boyd
</p>
<p>Maintainer: Anqi Fu&lt;anqif@stanford.edu&gt;
</p>

<hr>
<h2 id='-+2CExpression+2Cmissing-method'>The NegExpression class.</h2><span id='topic+-+2CExpression+2Cmissing-method'></span><span id='topic+-+2CExpression+2CExpression-method'></span><span id='topic+-+2CExpression+2CConstVal-method'></span><span id='topic+-+2CConstVal+2CExpression-method'></span><span id='topic+NegExpression-class'></span><span id='topic+.NegExpression'></span><span id='topic+NegExpression'></span><span id='topic+dim_from_args+2CNegExpression-method'></span><span id='topic+sign_from_args+2CNegExpression-method'></span><span id='topic+is_incr+2CNegExpression-method'></span><span id='topic+is_decr+2CNegExpression-method'></span><span id='topic+is_symmetric+2CNegExpression-method'></span><span id='topic+is_hermitian+2CNegExpression-method'></span><span id='topic+graph_implementation+2CNegExpression-method'></span>

<h3>Description</h3>

<p>This class represents the negation of an affine expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression,missing'
e1 - e2

## S4 method for signature 'Expression,Expression'
e1 - e2

## S4 method for signature 'Expression,ConstVal'
e1 - e2

## S4 method for signature 'ConstVal,Expression'
e1 - e2

## S4 method for signature 'NegExpression'
dim_from_args(object)

## S4 method for signature 'NegExpression'
sign_from_args(object)

## S4 method for signature 'NegExpression'
is_incr(object, idx)

## S4 method for signature 'NegExpression'
is_decr(object, idx)

## S4 method for signature 'NegExpression'
is_symmetric(object)

## S4 method for signature 'NegExpression'
is_hermitian(object)

## S4 method for signature 'NegExpression'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="-+2B2CExpression+2B2Cmissing-method_+3A_e1">e1</code>, <code id="-+2B2CExpression+2B2Cmissing-method_+3A_e2">e2</code></td>
<td>
<p>The <a href="#topic+Expression-class">Expression</a> objects or numeric constants to subtract.</p>
</td></tr>
<tr><td><code id="-+2B2CExpression+2B2Cmissing-method_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+NegExpression-class">NegExpression</a> object.</p>
</td></tr>
<tr><td><code id="-+2B2CExpression+2B2Cmissing-method_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="-+2B2CExpression+2B2Cmissing-method_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="-+2B2CExpression+2B2Cmissing-method_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="-+2B2CExpression+2B2Cmissing-method_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>dim_from_args(NegExpression)</code>: The (row, col) dimensions of the expression.
</p>
</li>
<li> <p><code>sign_from_args(NegExpression)</code>: The (is positive, is negative) sign of the expression.
</p>
</li>
<li> <p><code>is_incr(NegExpression)</code>: The expression is not weakly increasing in any argument.
</p>
</li>
<li> <p><code>is_decr(NegExpression)</code>: The expression is weakly decreasing in every argument.
</p>
</li>
<li> <p><code>is_symmetric(NegExpression)</code>: Is the expression symmetric?
</p>
</li>
<li> <p><code>is_hermitian(NegExpression)</code>: Is the expression Hermitian?
</p>
</li>
<li> <p><code>graph_implementation(NegExpression)</code>: The graph implementation of the expression.
</p>
</li></ul>

<hr>
<h2 id='.build_matrix_0'>Get the <code>sparse</code> flag field for the LinOp object</h2><span id='topic+.build_matrix_0'></span>

<h3>Description</h3>

<p>Get the <code>sparse</code> flag field for the LinOp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.build_matrix_0(xp, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".build_matrix_0_+3A_xp">xp</code></td>
<td>
<p>the LinOpVector Object XPtr</p>
</td></tr>
<tr><td><code id=".build_matrix_0_+3A_v">v</code></td>
<td>
<p>the <code>id_to_col</code> named int vector in R with integer names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a XPtr to ProblemData Object
</p>

<hr>
<h2 id='.build_matrix_1'>Get the <code>sparse</code> flag field for the LinOp object</h2><span id='topic+.build_matrix_1'></span>

<h3>Description</h3>

<p>Get the <code>sparse</code> flag field for the LinOp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.build_matrix_1(xp, v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".build_matrix_1_+3A_xp">xp</code></td>
<td>
<p>the LinOpVector Object XPtr</p>
</td></tr>
<tr><td><code id=".build_matrix_1_+3A_v1">v1</code></td>
<td>
<p>the <code>id_to_col</code> named int vector in R with integer names</p>
</td></tr>
<tr><td><code id=".build_matrix_1_+3A_v2">v2</code></td>
<td>
<p>the <code>constr_offsets</code> vector of offsets (an int vector in R)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a XPtr to ProblemData Object
</p>

<hr>
<h2 id='.decomp_quad'>Compute a Matrix Decomposition.</h2><span id='topic+.decomp_quad'></span>

<h3>Description</h3>

<p>Compute sgn, scale, M such that <code class="reqn">P = sgn * scale * dot(M, t(M))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.decomp_quad(P, cond = NA, rcond = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".decomp_quad_+3A_p">P</code></td>
<td>
<p>A real symmetric positive or negative (semi)definite input matrix</p>
</td></tr>
<tr><td><code id=".decomp_quad_+3A_cond">cond</code></td>
<td>
<p>Cutoff for small eigenvalues. Singular values smaller than rcond * largest_eigenvalue are considered negligible.</p>
</td></tr>
<tr><td><code id=".decomp_quad_+3A_rcond">rcond</code></td>
<td>
<p>Cutoff for small eigenvalues. Singular values smaller than rcond * largest_eigenvalue are considered negligible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of induced matrix 2-norm of P and a rectangular matrix such that P = scale * (dot(M1, t(M1)) - dot(M2, t(M2)))
</p>

<hr>
<h2 id='.LinOp__args_push_back'>Perform a push back operation on the <code>args</code> field of LinOp</h2><span id='topic+.LinOp__args_push_back'></span>

<h3>Description</h3>

<p>Perform a push back operation on the <code>args</code> field of LinOp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__args_push_back(xp, yp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__args_push_back_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
<tr><td><code id=".LinOp__args_push_back_+3A_yp">yp</code></td>
<td>
<p>the LinOp Object XPtr to push</p>
</td></tr>
</table>

<hr>
<h2 id='.LinOp__get_dense_data'>Get the field <code>dense_data</code> for the LinOp object</h2><span id='topic+.LinOp__get_dense_data'></span>

<h3>Description</h3>

<p>Get the field <code>dense_data</code> for the LinOp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__get_dense_data(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__get_dense_data_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a MatrixXd object
</p>

<hr>
<h2 id='.LinOp__get_id'>Get the id field of the LinOp Object</h2><span id='topic+.LinOp__get_id'></span>

<h3>Description</h3>

<p>Get the id field of the LinOp Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__get_id(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__get_id_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the id field of the LinOp Object
</p>

<hr>
<h2 id='.LinOp__get_size'>Get the field <code>size</code> for the LinOp object</h2><span id='topic+.LinOp__get_size'></span>

<h3>Description</h3>

<p>Get the field <code>size</code> for the LinOp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__get_size(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__get_size_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>

<hr>
<h2 id='.LinOp__get_slice'>Get the slice field of the LinOp Object</h2><span id='topic+.LinOp__get_slice'></span>

<h3>Description</h3>

<p>Get the slice field of the LinOp Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__get_slice(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__get_slice_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the slice field of the LinOp Object
</p>

<hr>
<h2 id='.LinOp__get_sparse'>Get the <code>sparse</code> flag field for the LinOp object</h2><span id='topic+.LinOp__get_sparse'></span>

<h3>Description</h3>

<p>Get the <code>sparse</code> flag field for the LinOp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__get_sparse(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__get_sparse_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE
</p>

<hr>
<h2 id='.LinOp__get_sparse_data'>Get the field named <code>sparse_data</code> from the LinOp object</h2><span id='topic+.LinOp__get_sparse_data'></span>

<h3>Description</h3>

<p>Get the field named <code>sparse_data</code> from the LinOp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__get_sparse_data(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__get_sparse_data_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a> object
</p>

<hr>
<h2 id='.LinOp__get_type'>Get the field named <code>type</code> for the LinOp object</h2><span id='topic+.LinOp__get_type'></span>

<h3>Description</h3>

<p>Get the field named <code>type</code> for the LinOp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__get_type(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__get_type_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer value for type
</p>

<hr>
<h2 id='.LinOp__new'>Create a new LinOp object.</h2><span id='topic+.LinOp__new'></span>

<h3>Description</h3>

<p>Create a new LinOp object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__new()
</code></pre>


<h3>Value</h3>

<p>an external ptr (Rcpp::XPtr) to a LinOp object instance.
</p>

<hr>
<h2 id='.LinOp__set_dense_data'>Set the field <code>dense_data</code> of the LinOp object</h2><span id='topic+.LinOp__set_dense_data'></span>

<h3>Description</h3>

<p>Set the field <code>dense_data</code> of the LinOp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__set_dense_data(xp, denseMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__set_dense_data_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
<tr><td><code id=".LinOp__set_dense_data_+3A_densemat">denseMat</code></td>
<td>
<p>a standard matrix object in R</p>
</td></tr>
</table>

<hr>
<h2 id='.LinOp__set_size'>Set the field <code>size</code> of the LinOp object</h2><span id='topic+.LinOp__set_size'></span>

<h3>Description</h3>

<p>Set the field <code>size</code> of the LinOp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__set_size(xp, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__set_size_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
<tr><td><code id=".LinOp__set_size_+3A_value">value</code></td>
<td>
<p>an integer vector object in R</p>
</td></tr>
</table>

<hr>
<h2 id='.LinOp__set_slice'>Set the slice field of the LinOp Object</h2><span id='topic+.LinOp__set_slice'></span>

<h3>Description</h3>

<p>Set the slice field of the LinOp Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__set_slice(xp, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__set_slice_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
<tr><td><code id=".LinOp__set_slice_+3A_value">value</code></td>
<td>
<p>a list of integer vectors, e.g. <code>list(1:10, 2L, 11:15)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the slice field of the LinOp Object
</p>

<hr>
<h2 id='.LinOp__set_sparse'>Set the flag <code>sparse</code> of the LinOp object</h2><span id='topic+.LinOp__set_sparse'></span>

<h3>Description</h3>

<p>Set the flag <code>sparse</code> of the LinOp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__set_sparse(xp, sparseSEXP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__set_sparse_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
<tr><td><code id=".LinOp__set_sparse_+3A_sparsesexp">sparseSEXP</code></td>
<td>
<p>an R boolean</p>
</td></tr>
</table>

<hr>
<h2 id='.LinOp__set_sparse_data'>Set the field named <code>sparse_data</code> of the LinOp object</h2><span id='topic+.LinOp__set_sparse_data'></span>

<h3>Description</h3>

<p>Set the field named <code>sparse_data</code> of the LinOp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__set_sparse_data(xp, sparseMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__set_sparse_data_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
<tr><td><code id=".LinOp__set_sparse_data_+3A_sparsemat">sparseMat</code></td>
<td>
<p>a <a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a> object</p>
</td></tr>
</table>

<hr>
<h2 id='.LinOp__set_type'>Set the field named <code>type</code> for the LinOp object</h2><span id='topic+.LinOp__set_type'></span>

<h3>Description</h3>

<p>Set the field named <code>type</code> for the LinOp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__set_type(xp, typeValue)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__set_type_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
<tr><td><code id=".LinOp__set_type_+3A_typevalue">typeValue</code></td>
<td>
<p>an integer value</p>
</td></tr>
</table>

<hr>
<h2 id='.LinOp__size_push_back'>Perform a push back operation on the <code>size</code> field of LinOp</h2><span id='topic+.LinOp__size_push_back'></span>

<h3>Description</h3>

<p>Perform a push back operation on the <code>size</code> field of LinOp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__size_push_back(xp, intVal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__size_push_back_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
<tr><td><code id=".LinOp__size_push_back_+3A_intval">intVal</code></td>
<td>
<p>the integer value to push back</p>
</td></tr>
</table>

<hr>
<h2 id='.LinOp__slice_push_back'>Perform a push back operation on the <code>slice</code> field of LinOp</h2><span id='topic+.LinOp__slice_push_back'></span>

<h3>Description</h3>

<p>Perform a push back operation on the <code>slice</code> field of LinOp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp__slice_push_back(xp, intVec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp__slice_push_back_+3A_xp">xp</code></td>
<td>
<p>the LinOp Object XPtr</p>
</td></tr>
<tr><td><code id=".LinOp__slice_push_back_+3A_intvec">intVec</code></td>
<td>
<p>an integer vector to push back</p>
</td></tr>
</table>

<hr>
<h2 id='.LinOp_at_index'>Return the LinOp element at index i (0-based)</h2><span id='topic+.LinOp_at_index'></span>

<h3>Description</h3>

<p>Return the LinOp element at index i (0-based)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOp_at_index(lvec, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOp_at_index_+3A_lvec">lvec</code></td>
<td>
<p>the LinOpVector Object XPtr</p>
</td></tr>
<tr><td><code id=".LinOp_at_index_+3A_i">i</code></td>
<td>
<p>the index</p>
</td></tr>
</table>

<hr>
<h2 id='.LinOpVector__new'>Create a new LinOpVector object.</h2><span id='topic+.LinOpVector__new'></span>

<h3>Description</h3>

<p>Create a new LinOpVector object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOpVector__new()
</code></pre>


<h3>Value</h3>

<p>an external ptr (Rcpp::XPtr) to a LinOp object instance.
</p>

<hr>
<h2 id='.LinOpVector__push_back'>Perform a push back operation on the <code>args</code> field of LinOp</h2><span id='topic+.LinOpVector__push_back'></span>

<h3>Description</h3>

<p>Perform a push back operation on the <code>args</code> field of LinOp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.LinOpVector__push_back(xp, yp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".LinOpVector__push_back_+3A_xp">xp</code></td>
<td>
<p>the LinOpVector Object XPtr</p>
</td></tr>
<tr><td><code id=".LinOpVector__push_back_+3A_yp">yp</code></td>
<td>
<p>the LinOp Object XPtr to push</p>
</td></tr>
</table>

<hr>
<h2 id='.p_norm'>Internal method for calculating the p-norm</h2><span id='topic+.p_norm'></span>

<h3>Description</h3>

<p>Internal method for calculating the p-norm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.p_norm(x, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".p_norm_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id=".p_norm_+3A_p">p</code></td>
<td>
<p>A number grater than or equal to 1, or equal to positive infinity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the specified norm of matrix x
</p>

<hr>
<h2 id='.ProblemData__get_const_to_row'>Get the const_to_row field of the ProblemData Object</h2><span id='topic+.ProblemData__get_const_to_row'></span>

<h3>Description</h3>

<p>Get the const_to_row field of the ProblemData Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__get_const_to_row(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ProblemData__get_const_to_row_+3A_xp">xp</code></td>
<td>
<p>the ProblemData Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the const_to_row field as a named integer vector where the names are integers converted to characters
</p>

<hr>
<h2 id='.ProblemData__get_const_vec'>Get the const_vec field from the ProblemData Object</h2><span id='topic+.ProblemData__get_const_vec'></span>

<h3>Description</h3>

<p>Get the const_vec field from the ProblemData Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__get_const_vec(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ProblemData__get_const_vec_+3A_xp">xp</code></td>
<td>
<p>the ProblemData Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of the field const_vec from the ProblemData Object
</p>

<hr>
<h2 id='.ProblemData__get_I'>Get the I field of the ProblemData Object</h2><span id='topic+.ProblemData__get_I'></span>

<h3>Description</h3>

<p>Get the I field of the ProblemData Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__get_I(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ProblemData__get_I_+3A_xp">xp</code></td>
<td>
<p>the ProblemData Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector of the field I from the ProblemData Object
</p>

<hr>
<h2 id='.ProblemData__get_id_to_col'>Get the id_to_col field of the ProblemData Object</h2><span id='topic+.ProblemData__get_id_to_col'></span>

<h3>Description</h3>

<p>Get the id_to_col field of the ProblemData Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__get_id_to_col(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ProblemData__get_id_to_col_+3A_xp">xp</code></td>
<td>
<p>the ProblemData Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the id_to_col field as a named integer vector where the names are integers converted to characters
</p>

<hr>
<h2 id='.ProblemData__get_J'>Get the J field of the ProblemData Object</h2><span id='topic+.ProblemData__get_J'></span>

<h3>Description</h3>

<p>Get the J field of the ProblemData Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__get_J(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ProblemData__get_J_+3A_xp">xp</code></td>
<td>
<p>the ProblemData Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector of the field J from the ProblemData Object
</p>

<hr>
<h2 id='.ProblemData__get_V'>Get the V field of the ProblemData Object</h2><span id='topic+.ProblemData__get_V'></span>

<h3>Description</h3>

<p>Get the V field of the ProblemData Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__get_V(xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ProblemData__get_V_+3A_xp">xp</code></td>
<td>
<p>the ProblemData Object XPtr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of doubles (the field V) from the ProblemData Object
</p>

<hr>
<h2 id='.ProblemData__new'>Create a new ProblemData object.</h2><span id='topic+.ProblemData__new'></span>

<h3>Description</h3>

<p>Create a new ProblemData object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__new()
</code></pre>


<h3>Value</h3>

<p>an external ptr (Rcpp::XPtr) to a ProblemData object instance.
</p>

<hr>
<h2 id='.ProblemData__set_const_to_row'>Set the const_to_row map of the ProblemData Object</h2><span id='topic+.ProblemData__set_const_to_row'></span>

<h3>Description</h3>

<p>Set the const_to_row map of the ProblemData Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__set_const_to_row(xp, iv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ProblemData__set_const_to_row_+3A_xp">xp</code></td>
<td>
<p>the ProblemData Object XPtr</p>
</td></tr>
<tr><td><code id=".ProblemData__set_const_to_row_+3A_iv">iv</code></td>
<td>
<p>a named integer vector with names being integers converted to characters</p>
</td></tr>
</table>

<hr>
<h2 id='.ProblemData__set_const_vec'>Set the const_vec field in the ProblemData Object</h2><span id='topic+.ProblemData__set_const_vec'></span>

<h3>Description</h3>

<p>Set the const_vec field in the ProblemData Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__set_const_vec(xp, cvp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ProblemData__set_const_vec_+3A_xp">xp</code></td>
<td>
<p>the ProblemData Object XPtr</p>
</td></tr>
<tr><td><code id=".ProblemData__set_const_vec_+3A_cvp">cvp</code></td>
<td>
<p>a numeric vector of values for const_vec field of the ProblemData object</p>
</td></tr>
</table>

<hr>
<h2 id='.ProblemData__set_I'>Set the I field in the ProblemData Object</h2><span id='topic+.ProblemData__set_I'></span>

<h3>Description</h3>

<p>Set the I field in the ProblemData Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__set_I(xp, ip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ProblemData__set_I_+3A_xp">xp</code></td>
<td>
<p>the ProblemData Object XPtr</p>
</td></tr>
<tr><td><code id=".ProblemData__set_I_+3A_ip">ip</code></td>
<td>
<p>an integer vector of values for field I of the ProblemData object</p>
</td></tr>
</table>

<hr>
<h2 id='.ProblemData__set_id_to_col'>Set the id_to_col field of the ProblemData Object</h2><span id='topic+.ProblemData__set_id_to_col'></span>

<h3>Description</h3>

<p>Set the id_to_col field of the ProblemData Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__set_id_to_col(xp, iv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ProblemData__set_id_to_col_+3A_xp">xp</code></td>
<td>
<p>the ProblemData Object XPtr</p>
</td></tr>
<tr><td><code id=".ProblemData__set_id_to_col_+3A_iv">iv</code></td>
<td>
<p>a named integer vector with names being integers converted to characters</p>
</td></tr>
</table>

<hr>
<h2 id='.ProblemData__set_J'>Set the J field in the ProblemData Object</h2><span id='topic+.ProblemData__set_J'></span>

<h3>Description</h3>

<p>Set the J field in the ProblemData Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__set_J(xp, jp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ProblemData__set_J_+3A_xp">xp</code></td>
<td>
<p>the ProblemData Object XPtr</p>
</td></tr>
<tr><td><code id=".ProblemData__set_J_+3A_jp">jp</code></td>
<td>
<p>an integer vector of the values for field J of the ProblemData object</p>
</td></tr>
</table>

<hr>
<h2 id='.ProblemData__set_V'>Set the V field in the ProblemData Object</h2><span id='topic+.ProblemData__set_V'></span>

<h3>Description</h3>

<p>Set the V field in the ProblemData Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ProblemData__set_V(xp, vp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ProblemData__set_V_+3A_xp">xp</code></td>
<td>
<p>the ProblemData Object XPtr</p>
</td></tr>
<tr><td><code id=".ProblemData__set_V_+3A_vp">vp</code></td>
<td>
<p>a numeric vector of values for field V</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CExpression+2Cindex+2Cmissing+2CANY-method'>The SpecialIndex class.</h2><span id='topic++5B+2CExpression+2Cindex+2Cmissing+2CANY-method'></span><span id='topic++5B+2CExpression+2Cmissing+2Cindex+2CANY-method'></span><span id='topic++5B+2CExpression+2Cindex+2Cindex+2CANY-method'></span><span id='topic++5B+2CExpression+2Cmatrix+2Cindex+2CANY-method'></span><span id='topic++5B+2CExpression+2Cindex+2Cmatrix+2CANY-method'></span><span id='topic++5B+2CExpression+2Cmatrix+2Cmatrix+2CANY-method'></span><span id='topic++5B+2CExpression+2Cmatrix+2Cmissing+2CANY-method'></span><span id='topic+SpecialIndex-class'></span><span id='topic+.SpecialIndex'></span><span id='topic+SpecialIndex'></span><span id='topic+name+2CSpecialIndex-method'></span><span id='topic+is_atom_log_log_convex+2CSpecialIndex-method'></span><span id='topic+is_atom_log_log_concave+2CSpecialIndex-method'></span><span id='topic+get_data+2CSpecialIndex-method'></span><span id='topic+.grad+2CSpecialIndex-method'></span>

<h3>Description</h3>

<p>This class represents indexing using logical indexing or a list of indices into a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression,index,missing,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'Expression,missing,index,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'Expression,index,index,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'Expression,matrix,index,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'Expression,index,matrix,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'Expression,matrix,matrix,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'Expression,matrix,missing,ANY'
x[i, j, ..., drop = TRUE]

SpecialIndex(expr, key)

## S4 method for signature 'SpecialIndex'
name(x)

## S4 method for signature 'SpecialIndex'
is_atom_log_log_convex(object)

## S4 method for signature 'SpecialIndex'
is_atom_log_log_concave(object)

## S4 method for signature 'SpecialIndex'
get_data(object)

## S4 method for signature 'SpecialIndex'
.grad(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cindex+2B2Cmissing+2B2CANY-method_+3A_x">x</code>, <code id="+2B5B+2B2CExpression+2B2Cindex+2B2Cmissing+2B2CANY-method_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Index-class">Index</a> object.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cindex+2B2Cmissing+2B2CANY-method_+3A_i">i</code>, <code id="+2B5B+2B2CExpression+2B2Cindex+2B2Cmissing+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>The row and column indices of the slice.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cindex+2B2Cmissing+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>(Unimplemented) Optional arguments.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cindex+2B2Cmissing+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>(Unimplemented) A logical value indicating whether the result should be coerced to the lowest possible dimension.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cindex+2B2Cmissing+2B2CANY-method_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cindex+2B2Cmissing+2B2CANY-method_+3A_key">key</code></td>
<td>
<p>A list containing the start index, end index, and step size of the slice.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(SpecialIndex)</code>: Returns the index in string form.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(SpecialIndex)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(SpecialIndex)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>get_data(SpecialIndex)</code>: A list containing <code>key</code>.
</p>
</li>
<li> <p><code>.grad(SpecialIndex)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</dd>
<dt><code>key</code></dt><dd><p>A list containing the start index, end index, and step size of the slice.</p>
</dd>
</dl>

<hr>
<h2 id='+5B+2CExpression+2Cmissing+2Cmissing+2CANY-method'>The Index class.</h2><span id='topic++5B+2CExpression+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+2CExpression+2Cnumeric+2Cmissing+2CANY-method'></span><span id='topic++5B+2CExpression+2Cmissing+2Cnumeric+2CANY-method'></span><span id='topic++5B+2CExpression+2Cnumeric+2Cnumeric+2CANY-method'></span><span id='topic+Index-class'></span><span id='topic+.Index'></span><span id='topic+Index'></span><span id='topic+to_numeric+2CIndex-method'></span><span id='topic+dim_from_args+2CIndex-method'></span><span id='topic+is_atom_log_log_convex+2CIndex-method'></span><span id='topic+is_atom_log_log_concave+2CIndex-method'></span><span id='topic+get_data+2CIndex-method'></span><span id='topic+graph_implementation+2CIndex-method'></span><span id='topic+to_numeric+2CSpecialIndex-method'></span><span id='topic+dim_from_args+2CSpecialIndex-method'></span>

<h3>Description</h3>

<p>This class represents indexing or slicing into a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression,missing,missing,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'Expression,numeric,missing,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'Expression,missing,numeric,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'Expression,numeric,numeric,ANY'
x[i, j, ..., drop = TRUE]

Index(expr, key)

## S4 method for signature 'Index'
to_numeric(object, values)

## S4 method for signature 'Index'
dim_from_args(object)

## S4 method for signature 'Index'
is_atom_log_log_convex(object)

## S4 method for signature 'Index'
is_atom_log_log_concave(object)

## S4 method for signature 'Index'
get_data(object)

## S4 method for signature 'Index'
graph_implementation(object, arg_objs, dim, data = NA_real_)

## S4 method for signature 'SpecialIndex'
to_numeric(object, values)

## S4 method for signature 'SpecialIndex'
dim_from_args(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_i">i</code>, <code id="+2B5B+2B2CExpression+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>The row and column indices of the slice.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>(Unimplemented) Optional arguments.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>(Unimplemented) A logical value indicating whether the result should be coerced to the lowest possible dimension.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_key">key</code></td>
<td>
<p>A list containing the start index, end index, and step size of the slice.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Index-class">Index</a> object.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CExpression+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Index)</code>: The index/slice into the given value.
</p>
</li>
<li> <p><code>dim_from_args(Index)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(Index)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(Index)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>get_data(Index)</code>: A list containing <code>key</code>.
</p>
</li>
<li> <p><code>graph_implementation(Index)</code>: The graph implementation of the atom.
</p>
</li>
<li> <p><code>to_numeric(SpecialIndex)</code>: The index/slice into the given value.
</p>
</li>
<li> <p><code>dim_from_args(SpecialIndex)</code>: The dimensions of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</dd>
<dt><code>key</code></dt><dd><p>A list containing the start index, end index, and step size of the slice.</p>
</dd>
</dl>

<hr>
<h2 id='+2A+2CExpression+2CExpression-method'>Elementwise multiplication operator</h2><span id='topic++2A+2CExpression+2CExpression-method'></span><span id='topic++2A+2CExpression+2CConstVal-method'></span><span id='topic++2A+2CConstVal+2CExpression-method'></span>

<h3>Description</h3>

<p>Elementwise multiplication operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression,Expression'
e1 * e2

## S4 method for signature 'Expression,ConstVal'
e1 * e2

## S4 method for signature 'ConstVal,Expression'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A+2B2CExpression+2B2CExpression-method_+3A_e1">e1</code>, <code id="+2B2A+2B2CExpression+2B2CExpression-method_+3A_e2">e2</code></td>
<td>
<p>The <a href="#topic+Expression-class">Expression</a> objects or numeric constants to multiply elementwise.</p>
</td></tr>
</table>

<hr>
<h2 id='+2F+2CExpression+2CExpression-method'>The DivExpression class.</h2><span id='topic++2F+2CExpression+2CExpression-method'></span><span id='topic++2F+2CExpression+2CConstVal-method'></span><span id='topic++2F+2CConstVal+2CExpression-method'></span><span id='topic+DivExpression-class'></span><span id='topic+.DivExpression'></span><span id='topic+DivExpression'></span><span id='topic+to_numeric+2CDivExpression-method'></span><span id='topic+is_quadratic+2CDivExpression-method'></span><span id='topic+is_qpwa+2CDivExpression-method'></span><span id='topic+dim_from_args+2CDivExpression-method'></span><span id='topic+is_atom_convex+2CDivExpression-method'></span><span id='topic+is_atom_concave+2CDivExpression-method'></span><span id='topic+is_atom_log_log_convex+2CDivExpression-method'></span><span id='topic+is_atom_log_log_concave+2CDivExpression-method'></span><span id='topic+is_incr+2CDivExpression-method'></span><span id='topic+is_decr+2CDivExpression-method'></span><span id='topic+graph_implementation+2CDivExpression-method'></span>

<h3>Description</h3>

<p>This class represents one expression divided by another expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression,Expression'
e1 / e2

## S4 method for signature 'Expression,ConstVal'
e1 / e2

## S4 method for signature 'ConstVal,Expression'
e1 / e2

## S4 method for signature 'DivExpression'
to_numeric(object, values)

## S4 method for signature 'DivExpression'
is_quadratic(object)

## S4 method for signature 'DivExpression'
is_qpwa(object)

## S4 method for signature 'DivExpression'
dim_from_args(object)

## S4 method for signature 'DivExpression'
is_atom_convex(object)

## S4 method for signature 'DivExpression'
is_atom_concave(object)

## S4 method for signature 'DivExpression'
is_atom_log_log_convex(object)

## S4 method for signature 'DivExpression'
is_atom_log_log_concave(object)

## S4 method for signature 'DivExpression'
is_incr(object, idx)

## S4 method for signature 'DivExpression'
is_decr(object, idx)

## S4 method for signature 'DivExpression'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2F+2B2CExpression+2B2CExpression-method_+3A_e1">e1</code>, <code id="+2B2F+2B2CExpression+2B2CExpression-method_+3A_e2">e2</code></td>
<td>
<p>The <a href="#topic+Expression-class">Expression</a> objects or numeric constants to divide. The denominator, <code>e2</code>, must be a scalar constant.</p>
</td></tr>
<tr><td><code id="+2B2F+2B2CExpression+2B2CExpression-method_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+DivExpression-class">DivExpression</a> object.</p>
</td></tr>
<tr><td><code id="+2B2F+2B2CExpression+2B2CExpression-method_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="+2B2F+2B2CExpression+2B2CExpression-method_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="+2B2F+2B2CExpression+2B2CExpression-method_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="+2B2F+2B2CExpression+2B2CExpression-method_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="+2B2F+2B2CExpression+2B2CExpression-method_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(DivExpression)</code>: Matrix division by a scalar.
</p>
</li>
<li> <p><code>is_quadratic(DivExpression)</code>: Is the left-hand expression quadratic and the right-hand expression constant?
</p>
</li>
<li> <p><code>is_qpwa(DivExpression)</code>: Is the expression quadratic of piecewise affine?
</p>
</li>
<li> <p><code>dim_from_args(DivExpression)</code>: The (row, col) dimensions of the left-hand expression.
</p>
</li>
<li> <p><code>is_atom_convex(DivExpression)</code>: Division is convex (affine) in its arguments only if the denominator is constant.
</p>
</li>
<li> <p><code>is_atom_concave(DivExpression)</code>: Division is concave (affine) in its arguments only if the denominator is constant.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(DivExpression)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(DivExpression)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(DivExpression)</code>: Is the right-hand expression positive?
</p>
</li>
<li> <p><code>is_decr(DivExpression)</code>: Is the right-hand expression negative?
</p>
</li>
<li> <p><code>graph_implementation(DivExpression)</code>: The graph implementation of the expression.
</p>
</li></ul>

<hr>
<h2 id='+26lt+3B+3D+2CExpression+2CExpression-method'>The IneqConstraint class</h2><span id='topic++3C+3D+2CExpression+2CExpression-method'></span><span id='topic++3C+3D+2CExpression+2CConstVal-method'></span><span id='topic++3C+3D+2CConstVal+2CExpression-method'></span><span id='topic++3C+2CExpression+2CExpression-method'></span><span id='topic++3C+2CExpression+2CConstVal-method'></span><span id='topic++3C+2CConstVal+2CExpression-method'></span><span id='topic++3E+3D+2CExpression+2CExpression-method'></span><span id='topic++3E+3D+2CExpression+2CConstVal-method'></span><span id='topic++3E+3D+2CConstVal+2CExpression-method'></span><span id='topic++3E+2CExpression+2CExpression-method'></span><span id='topic++3E+2CExpression+2CConstVal-method'></span><span id='topic++3E+2CConstVal+2CExpression-method'></span><span id='topic+IneqConstraint-class'></span><span id='topic+.IneqConstraint'></span><span id='topic+name+2CIneqConstraint-method'></span><span id='topic+dim+2CIneqConstraint-method'></span><span id='topic+size+2CIneqConstraint-method'></span><span id='topic+expr+2CIneqConstraint-method'></span><span id='topic+is_dcp+2CIneqConstraint-method'></span><span id='topic+is_dgp+2CIneqConstraint-method'></span><span id='topic+residual+2CIneqConstraint-method'></span>

<h3>Description</h3>

<p>The IneqConstraint class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression,Expression'
e1 &lt;= e2

## S4 method for signature 'Expression,ConstVal'
e1 &lt;= e2

## S4 method for signature 'ConstVal,Expression'
e1 &lt;= e2

## S4 method for signature 'Expression,Expression'
e1 &lt; e2

## S4 method for signature 'Expression,ConstVal'
e1 &lt; e2

## S4 method for signature 'ConstVal,Expression'
e1 &lt; e2

## S4 method for signature 'Expression,Expression'
e1 &gt;= e2

## S4 method for signature 'Expression,ConstVal'
e1 &gt;= e2

## S4 method for signature 'ConstVal,Expression'
e1 &gt;= e2

## S4 method for signature 'Expression,Expression'
e1 &gt; e2

## S4 method for signature 'Expression,ConstVal'
e1 &gt; e2

## S4 method for signature 'ConstVal,Expression'
e1 &gt; e2

## S4 method for signature 'IneqConstraint'
name(x)

## S4 method for signature 'IneqConstraint'
dim(x)

## S4 method for signature 'IneqConstraint'
size(object)

## S4 method for signature 'IneqConstraint'
expr(object)

## S4 method for signature 'IneqConstraint'
is_dcp(object)

## S4 method for signature 'IneqConstraint'
is_dgp(object)

## S4 method for signature 'IneqConstraint'
residual(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B26lt+2B3B+2B3D+2B2CExpression+2B2CExpression-method_+3A_e1">e1</code>, <code id="+2B26lt+2B3B+2B3D+2B2CExpression+2B2CExpression-method_+3A_e2">e2</code></td>
<td>
<p>The <a href="#topic+Expression-class">Expression</a> objects or numeric constants to compare.</p>
</td></tr>
<tr><td><code id="+2B26lt+2B3B+2B3D+2B2CExpression+2B2CExpression-method_+3A_x">x</code>, <code id="+2B26lt+2B3B+2B3D+2B2CExpression+2B2CExpression-method_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+IneqConstraint-class">IneqConstraint</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(IneqConstraint)</code>: The string representation of the constraint.
</p>
</li>
<li> <p><code>dim(IneqConstraint)</code>: The dimensions of the constrained expression.
</p>
</li>
<li> <p><code>size(IneqConstraint)</code>: The size of the constrained expression.
</p>
</li>
<li> <p><code>expr(IneqConstraint)</code>: The expression to constrain.
</p>
</li>
<li> <p><code>is_dcp(IneqConstraint)</code>: A non-positive constraint is DCP if its argument is convex.
</p>
</li>
<li> <p><code>is_dgp(IneqConstraint)</code>: Is the constraint DGP?
</p>
</li>
<li> <p><code>residual(IneqConstraint)</code>: The residual of the constraint.
</p>
</li></ul>

<hr>
<h2 id='+25+2A+25+2CExpression+2CExpression-method'>The MulExpression class.</h2><span id='topic++25+2A+25+2CExpression+2CExpression-method'></span><span id='topic++25+2A+25+2CExpression+2CConstVal-method'></span><span id='topic++25+2A+25+2CConstVal+2CExpression-method'></span><span id='topic+MulExpression-class'></span><span id='topic+.MulExpression'></span><span id='topic+MulExpression'></span><span id='topic+to_numeric+2CMulExpression-method'></span><span id='topic+dim_from_args+2CMulExpression-method'></span><span id='topic+is_atom_convex+2CMulExpression-method'></span><span id='topic+is_atom_concave+2CMulExpression-method'></span><span id='topic+is_atom_log_log_convex+2CMulExpression-method'></span><span id='topic+is_atom_log_log_concave+2CMulExpression-method'></span><span id='topic+is_incr+2CMulExpression-method'></span><span id='topic+is_decr+2CMulExpression-method'></span><span id='topic+.grad+2CMulExpression-method'></span><span id='topic+graph_implementation+2CMulExpression-method'></span>

<h3>Description</h3>

<p>This class represents the matrix product of two linear expressions.
See <a href="#topic+Multiply-class">Multiply</a> for the elementwise product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression,Expression'
x %*% y

## S4 method for signature 'Expression,ConstVal'
x %*% y

## S4 method for signature 'ConstVal,Expression'
x %*% y

## S4 method for signature 'MulExpression'
to_numeric(object, values)

## S4 method for signature 'MulExpression'
dim_from_args(object)

## S4 method for signature 'MulExpression'
is_atom_convex(object)

## S4 method for signature 'MulExpression'
is_atom_concave(object)

## S4 method for signature 'MulExpression'
is_atom_log_log_convex(object)

## S4 method for signature 'MulExpression'
is_atom_log_log_concave(object)

## S4 method for signature 'MulExpression'
is_incr(object, idx)

## S4 method for signature 'MulExpression'
is_decr(object, idx)

## S4 method for signature 'MulExpression'
.grad(object, values)

## S4 method for signature 'MulExpression'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B2A+2B25+2B2CExpression+2B2CExpression-method_+3A_x">x</code>, <code id="+2B25+2B2A+2B25+2B2CExpression+2B2CExpression-method_+3A_y">y</code></td>
<td>
<p>The <a href="#topic+Expression-class">Expression</a> objects or numeric constants to multiply.</p>
</td></tr>
<tr><td><code id="+2B25+2B2A+2B25+2B2CExpression+2B2CExpression-method_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+MulExpression-class">MulExpression</a> object.</p>
</td></tr>
<tr><td><code id="+2B25+2B2A+2B25+2B2CExpression+2B2CExpression-method_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="+2B25+2B2A+2B25+2B2CExpression+2B2CExpression-method_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="+2B25+2B2A+2B25+2B2CExpression+2B2CExpression-method_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="+2B25+2B2A+2B25+2B2CExpression+2B2CExpression-method_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="+2B25+2B2A+2B25+2B2CExpression+2B2CExpression-method_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(MulExpression)</code>: Matrix multiplication.
</p>
</li>
<li> <p><code>dim_from_args(MulExpression)</code>: The (row, col) dimensions of the expression.
</p>
</li>
<li> <p><code>is_atom_convex(MulExpression)</code>: Multiplication is convex (affine) in its arguments only if one of the arguments is constant.
</p>
</li>
<li> <p><code>is_atom_concave(MulExpression)</code>: If the multiplication atom is convex, then it is affine.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(MulExpression)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(MulExpression)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(MulExpression)</code>: Is the left-hand expression positive?
</p>
</li>
<li> <p><code>is_decr(MulExpression)</code>: Is the left-hand expression negative?
</p>
</li>
<li> <p><code>.grad(MulExpression)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>graph_implementation(MulExpression)</code>: The graph implementation of the expression.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+Multiply-class">Multiply</a>
</p>

<hr>
<h2 id='+25+26gt+3B+26gt+3B+25'>The PSDConstraint class.</h2><span id='topic++25+3E+3E+25'></span><span id='topic++25+3C+3C+25'></span><span id='topic++25+3E+3E+25+2CExpression+2CExpression-method'></span><span id='topic++25+3E+3E+25+2CExpression+2CConstVal-method'></span><span id='topic++25+3E+3E+25+2CConstVal+2CExpression-method'></span><span id='topic++25+3C+3C+25+2CExpression+2CExpression-method'></span><span id='topic++25+3C+3C+25+2CExpression+2CConstVal-method'></span><span id='topic++25+3C+3C+25+2CConstVal+2CExpression-method'></span><span id='topic+PSDConstraint-class'></span><span id='topic+.PSDConstraint'></span><span id='topic+PSDConstraint'></span><span id='topic+name+2CPSDConstraint-method'></span><span id='topic+is_dcp+2CPSDConstraint-method'></span><span id='topic+is_dgp+2CPSDConstraint-method'></span><span id='topic+residual+2CPSDConstraint-method'></span><span id='topic+canonicalize+2CPSDConstraint-method'></span>

<h3>Description</h3>

<p>This class represents the positive semidefinite constraint, <code class="reqn">\frac{1}{2}(X + X^T) \succeq 0</code>, i.e. <code class="reqn">z^T(X + X^T)z \geq 0</code> for all <code class="reqn">z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %&gt;&gt;% e2

e1 %&lt;&lt;% e2

## S4 method for signature 'Expression,Expression'
e1 %&gt;&gt;% e2

## S4 method for signature 'Expression,ConstVal'
e1 %&gt;&gt;% e2

## S4 method for signature 'ConstVal,Expression'
e1 %&gt;&gt;% e2

## S4 method for signature 'Expression,Expression'
e1 %&lt;&lt;% e2

## S4 method for signature 'Expression,ConstVal'
e1 %&lt;&lt;% e2

## S4 method for signature 'ConstVal,Expression'
e1 %&lt;&lt;% e2

PSDConstraint(expr, id = NA_integer_)

## S4 method for signature 'PSDConstraint'
name(x)

## S4 method for signature 'PSDConstraint'
is_dcp(object)

## S4 method for signature 'PSDConstraint'
is_dgp(object)

## S4 method for signature 'PSDConstraint'
residual(object)

## S4 method for signature 'PSDConstraint'
canonicalize(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B26gt+2B3B+2B25_+3A_e1">e1</code>, <code id="+2B25+2B26gt+2B3B+2B26gt+2B3B+2B25_+3A_e2">e2</code></td>
<td>
<p>The <a href="#topic+Expression-class">Expression</a> objects or numeric constants to compare.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B26gt+2B3B+2B25_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, numeric element, vector, or matrix representing <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B26gt+2B3B+2B25_+3A_id">id</code></td>
<td>
<p>(Optional) A numeric value representing the constraint ID.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B26gt+2B3B+2B25_+3A_x">x</code>, <code id="+2B25+2B26gt+2B3B+2B26gt+2B3B+2B25_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+PSDConstraint-class">PSDConstraint</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(PSDConstraint)</code>: The string representation of the constraint.
</p>
</li>
<li> <p><code>is_dcp(PSDConstraint)</code>: The constraint is DCP if the left-hand and right-hand expressions are affine.
</p>
</li>
<li> <p><code>is_dgp(PSDConstraint)</code>: Is the constraint DGP?
</p>
</li>
<li> <p><code>residual(PSDConstraint)</code>: A <a href="#topic+Expression-class">Expression</a> representing the residual of the constraint.
</p>
</li>
<li> <p><code>canonicalize(PSDConstraint)</code>: The graph implementation of the object. Marks the top level constraint as the <code>dual_holder</code> so the dual value will be saved to the <a href="#topic+PSDConstraint-class">PSDConstraint</a>.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a>, numeric element, vector, or matrix representing <code class="reqn">X</code>.</p>
</dd>
</dl>

<hr>
<h2 id='+5E+2CExpression+2Cnumeric-method'>Elementwise Power</h2><span id='topic++5E+2CExpression+2Cnumeric-method'></span><span id='topic+power'></span><span id='topic++5E'></span>

<h3>Description</h3>

<p>Raises each element of the input to the power <code class="reqn">p</code>.
If <code>expr</code> is a CVXR expression, then <code>expr^p</code> is equivalent to <code>power(expr,p)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression,numeric'
e1 ^ e2

power(x, p, max_denom = 1024)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5E+2B2CExpression+2B2Cnumeric-method_+3A_e1">e1</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object to exponentiate.</p>
</td></tr>
<tr><td><code id="+2B5E+2B2CExpression+2B2Cnumeric-method_+3A_e2">e2</code></td>
<td>
<p>The power of the exponential. Must be a numeric scalar.</p>
</td></tr>
<tr><td><code id="+2B5E+2B2CExpression+2B2Cnumeric-method_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="+2B5E+2B2CExpression+2B2Cnumeric-method_+3A_p">p</code></td>
<td>
<p>A scalar value indicating the exponential power.</p>
</td></tr>
<tr><td><code id="+2B5E+2B2CExpression+2B2Cnumeric-method_+3A_max_denom">max_denom</code></td>
<td>
<p>The maximum denominator considered in forming a rational approximation of <code>p</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code class="reqn">p = 0</code> and <code class="reqn">f(x) = 1</code>, this function is constant and positive.
For <code class="reqn">p = 1</code> and <code class="reqn">f(x) = x</code>, this function is affine, increasing, and the same sign as <code class="reqn">x</code>.
For <code class="reqn">p = 2,4,8,\ldots</code> and <code class="reqn">f(x) = |x|^p</code>, this function is convex, positive, with signed monotonicity.
For <code class="reqn">p &lt; 0</code> and <code class="reqn">f(x) = </code>
</p>

<dl>
<dt><code class="reqn">x^p</code></dt><dd><p> for <code class="reqn">x &gt; 0</code></p>
</dd>
<dt><code class="reqn">+\infty</code></dt><dd><p><code class="reqn">x \leq 0</code></p>
</dd>
</dl>
<p>, this function is convex, decreasing, and positive.
For <code class="reqn">0 &lt; p &lt; 1</code> and <code class="reqn">f(x) =</code>
</p>

<dl>
<dt><code class="reqn">x^p</code></dt><dd><p> for <code class="reqn">x \geq 0</code></p>
</dd>
<dt><code class="reqn">-\infty</code></dt><dd><p><code class="reqn">x &lt; 0</code></p>
</dd>
</dl>
<p>, this function is concave, increasing, and positivea.
For <code class="reqn">p &gt; 1, p \neq 2,4,8,\ldots</code> and <code class="reqn">f(x) = </code>
</p>

<dl>
<dt><code class="reqn">x^p</code></dt><dd><p> for <code class="reqn">x \geq 0</code></p>
</dd>
<dt><code class="reqn">+\infty</code></dt><dd><p><code class="reqn">x &lt; 0</code></p>
</dd>
</dl>
<p>, this function is convex, increasing, and positive.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- Variable()
prob &lt;- Problem(Minimize(power(x,1.7) + power(x,-2.3) - power(x,0.45)))
result &lt;- solve(prob)
result$value
result$getValue(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='+2B+2CExpression+2Cmissing-method'>The AddExpression class.</h2><span id='topic++2B+2CExpression+2Cmissing-method'></span><span id='topic++2B+2CExpression+2CExpression-method'></span><span id='topic++2B+2CExpression+2CConstVal-method'></span><span id='topic++2B+2CConstVal+2CExpression-method'></span><span id='topic+AddExpression-class'></span><span id='topic+.AddExpression'></span><span id='topic+AddExpression'></span><span id='topic+dim_from_args+2CAddExpression-method'></span><span id='topic+name+2CAddExpression-method'></span><span id='topic+to_numeric+2CAddExpression-method'></span><span id='topic+is_atom_log_log_convex+2CAddExpression-method'></span><span id='topic+is_atom_log_log_concave+2CAddExpression-method'></span><span id='topic+is_symmetric+2CAddExpression-method'></span><span id='topic+is_hermitian+2CAddExpression-method'></span><span id='topic+copy+2CAddExpression-method'></span><span id='topic+graph_implementation+2CAddExpression-method'></span>

<h3>Description</h3>

<p>This class represents the sum of any number of expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression,missing'
e1 + e2

## S4 method for signature 'Expression,Expression'
e1 + e2

## S4 method for signature 'Expression,ConstVal'
e1 + e2

## S4 method for signature 'ConstVal,Expression'
e1 + e2

## S4 method for signature 'AddExpression'
dim_from_args(object)

## S4 method for signature 'AddExpression'
name(x)

## S4 method for signature 'AddExpression'
to_numeric(object, values)

## S4 method for signature 'AddExpression'
is_atom_log_log_convex(object)

## S4 method for signature 'AddExpression'
is_atom_log_log_concave(object)

## S4 method for signature 'AddExpression'
is_symmetric(object)

## S4 method for signature 'AddExpression'
is_hermitian(object)

## S4 method for signature 'AddExpression'
copy(object, args = NULL, id_objects = list())

## S4 method for signature 'AddExpression'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B+2B2CExpression+2B2Cmissing-method_+3A_e1">e1</code>, <code id="+2B2B+2B2CExpression+2B2Cmissing-method_+3A_e2">e2</code></td>
<td>
<p>The <a href="#topic+Expression-class">Expression</a> objects or numeric constants to add.</p>
</td></tr>
<tr><td><code id="+2B2B+2B2CExpression+2B2Cmissing-method_+3A_x">x</code>, <code id="+2B2B+2B2CExpression+2B2Cmissing-method_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+AddExpression-class">AddExpression</a> object.</p>
</td></tr>
<tr><td><code id="+2B2B+2B2CExpression+2B2Cmissing-method_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="+2B2B+2B2CExpression+2B2Cmissing-method_+3A_args">args</code></td>
<td>
<p>An optional list of arguments to reconstruct the atom. Default is to use current args of the atom.</p>
</td></tr>
<tr><td><code id="+2B2B+2B2CExpression+2B2Cmissing-method_+3A_id_objects">id_objects</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="+2B2B+2B2CExpression+2B2Cmissing-method_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="+2B2B+2B2CExpression+2B2Cmissing-method_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="+2B2B+2B2CExpression+2B2Cmissing-method_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>dim_from_args(AddExpression)</code>: The dimensions of the expression.
</p>
</li>
<li> <p><code>name(AddExpression)</code>: The string form of the expression.
</p>
</li>
<li> <p><code>to_numeric(AddExpression)</code>: Sum all the values.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(AddExpression)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(AddExpression)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_symmetric(AddExpression)</code>: Is the atom symmetric?
</p>
</li>
<li> <p><code>is_hermitian(AddExpression)</code>: Is the atom hermitian?
</p>
</li>
<li> <p><code>copy(AddExpression)</code>: Returns a shallow copy of the AddExpression atom
</p>
</li>
<li> <p><code>graph_implementation(AddExpression)</code>: The graph implementation of the expression.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>arg_groups</code></dt><dd><p>A <code>list</code> of <a href="#topic+Expression-class">Expression</a>s and numeric data.frame, matrix, or vector objects.</p>
</dd>
</dl>

<hr>
<h2 id='+3D+3D+2CExpression+2CExpression-method'>The EqConstraint class</h2><span id='topic++3D+3D+2CExpression+2CExpression-method'></span><span id='topic++3D+3D+2CExpression+2CConstVal-method'></span><span id='topic++3D+3D+2CConstVal+2CExpression-method'></span><span id='topic+EqConstraint-class'></span><span id='topic+.EqConstraint'></span><span id='topic+name+2CEqConstraint-method'></span><span id='topic+dim+2CEqConstraint-method'></span><span id='topic+size+2CEqConstraint-method'></span><span id='topic+expr+2CEqConstraint-method'></span><span id='topic+is_dcp+2CEqConstraint-method'></span><span id='topic+is_dgp+2CEqConstraint-method'></span><span id='topic+residual+2CEqConstraint-method'></span>

<h3>Description</h3>

<p>The EqConstraint class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression,Expression'
e1 == e2

## S4 method for signature 'Expression,ConstVal'
e1 == e2

## S4 method for signature 'ConstVal,Expression'
e1 == e2

## S4 method for signature 'EqConstraint'
name(x)

## S4 method for signature 'EqConstraint'
dim(x)

## S4 method for signature 'EqConstraint'
size(object)

## S4 method for signature 'EqConstraint'
expr(object)

## S4 method for signature 'EqConstraint'
is_dcp(object)

## S4 method for signature 'EqConstraint'
is_dgp(object)

## S4 method for signature 'EqConstraint'
residual(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B3D+2B3D+2B2CExpression+2B2CExpression-method_+3A_e1">e1</code>, <code id="+2B3D+2B3D+2B2CExpression+2B2CExpression-method_+3A_e2">e2</code></td>
<td>
<p>The <a href="#topic+Expression-class">Expression</a> objects or numeric constants to compare.</p>
</td></tr>
<tr><td><code id="+2B3D+2B3D+2B2CExpression+2B2CExpression-method_+3A_x">x</code>, <code id="+2B3D+2B3D+2B2CExpression+2B2CExpression-method_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+EqConstraint-class">EqConstraint</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(EqConstraint)</code>: The string representation of the constraint.
</p>
</li>
<li> <p><code>dim(EqConstraint)</code>: The dimensions of the constrained expression.
</p>
</li>
<li> <p><code>size(EqConstraint)</code>: The size of the constrained expression.
</p>
</li>
<li> <p><code>expr(EqConstraint)</code>: The expression to constrain.
</p>
</li>
<li> <p><code>is_dcp(EqConstraint)</code>: Is the constraint DCP?
</p>
</li>
<li> <p><code>is_dgp(EqConstraint)</code>: Is the constraint DGP?
</p>
</li>
<li> <p><code>residual(EqConstraint)</code>: The residual of the constraint..
</p>
</li></ul>

<hr>
<h2 id='Abs-class'>The Abs class.</h2><span id='topic+Abs-class'></span><span id='topic+.Abs'></span><span id='topic+Abs'></span><span id='topic+to_numeric+2CAbs-method'></span><span id='topic+allow_complex+2CAbs-method'></span><span id='topic+sign_from_args+2CAbs-method'></span><span id='topic+is_atom_convex+2CAbs-method'></span><span id='topic+is_atom_concave+2CAbs-method'></span><span id='topic+is_incr+2CAbs-method'></span><span id='topic+is_decr+2CAbs-method'></span><span id='topic+is_pwl+2CAbs-method'></span>

<h3>Description</h3>

<p>This class represents the elementwise absolute value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Abs(x)

## S4 method for signature 'Abs'
to_numeric(object, values)

## S4 method for signature 'Abs'
allow_complex(object)

## S4 method for signature 'Abs'
sign_from_args(object)

## S4 method for signature 'Abs'
is_atom_convex(object)

## S4 method for signature 'Abs'
is_atom_concave(object)

## S4 method for signature 'Abs'
is_incr(object, idx)

## S4 method for signature 'Abs'
is_decr(object, idx)

## S4 method for signature 'Abs'
is_pwl(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Abs-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
<tr><td><code id="Abs-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Abs-class">Abs</a> object.</p>
</td></tr>
<tr><td><code id="Abs-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="Abs-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Abs)</code>: The elementwise absolute value of the input.
</p>
</li>
<li> <p><code>allow_complex(Abs)</code>: Does the atom handle complex numbers?
</p>
</li>
<li> <p><code>sign_from_args(Abs)</code>: The atom is positive.
</p>
</li>
<li> <p><code>is_atom_convex(Abs)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(Abs)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_incr(Abs)</code>: A logical value indicating whether the atom is weakly increasing.
</p>
</li>
<li> <p><code>is_decr(Abs)</code>: A logical value indicating whether the atom is weakly decreasing.
</p>
</li>
<li> <p><code>is_pwl(Abs)</code>: Is <code>x</code> piecewise linear?
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</dd>
</dl>

<hr>
<h2 id='abs+2CExpression-method'>Absolute Value</h2><span id='topic+abs+2CExpression-method'></span><span id='topic+abs'></span>

<h3>Description</h3>

<p>The elementwise absolute value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression'
abs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abs+2B2CExpression-method_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the absolute value of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Variable(2,2)
prob &lt;- Problem(Minimize(sum(abs(A))), list(A &lt;= -2))
result &lt;- solve(prob)
result$value
result$getValue(A)
</code></pre>

<hr>
<h2 id='accepts'>Reduction Acceptance</h2><span id='topic+accepts'></span>

<h3>Description</h3>

<p>Determine whether the reduction accepts a problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accepts(object, problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accepts_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Reduction-class">Reduction</a> object.</p>
</td></tr>
<tr><td><code id="accepts_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the reduction can be applied.
</p>

<hr>
<h2 id='AffAtom-class'>The AffAtom class.</h2><span id='topic+AffAtom-class'></span><span id='topic+AffAtom'></span><span id='topic+allow_complex+2CAffAtom-method'></span><span id='topic+sign_from_args+2CAffAtom-method'></span><span id='topic+is_imag+2CAffAtom-method'></span><span id='topic+is_complex+2CAffAtom-method'></span><span id='topic+is_atom_convex+2CAffAtom-method'></span><span id='topic+is_atom_concave+2CAffAtom-method'></span><span id='topic+is_incr+2CAffAtom-method'></span><span id='topic+is_decr+2CAffAtom-method'></span><span id='topic+is_quadratic+2CAffAtom-method'></span><span id='topic+is_qpwa+2CAffAtom-method'></span><span id='topic+is_pwl+2CAffAtom-method'></span><span id='topic+is_psd+2CAffAtom-method'></span><span id='topic+is_nsd+2CAffAtom-method'></span><span id='topic+.grad+2CAffAtom-method'></span>

<h3>Description</h3>

<p>This virtual class represents an affine atomic expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AffAtom'
allow_complex(object)

## S4 method for signature 'AffAtom'
sign_from_args(object)

## S4 method for signature 'AffAtom'
is_imag(object)

## S4 method for signature 'AffAtom'
is_complex(object)

## S4 method for signature 'AffAtom'
is_atom_convex(object)

## S4 method for signature 'AffAtom'
is_atom_concave(object)

## S4 method for signature 'AffAtom'
is_incr(object, idx)

## S4 method for signature 'AffAtom'
is_decr(object, idx)

## S4 method for signature 'AffAtom'
is_quadratic(object)

## S4 method for signature 'AffAtom'
is_qpwa(object)

## S4 method for signature 'AffAtom'
is_pwl(object)

## S4 method for signature 'AffAtom'
is_psd(object)

## S4 method for signature 'AffAtom'
is_nsd(object)

## S4 method for signature 'AffAtom'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AffAtom-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+AffAtom-class">AffAtom</a> object.</p>
</td></tr>
<tr><td><code id="AffAtom-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="AffAtom-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>allow_complex(AffAtom)</code>: Does the atom handle complex numbers?
</p>
</li>
<li> <p><code>sign_from_args(AffAtom)</code>: The sign of the atom.
</p>
</li>
<li> <p><code>is_imag(AffAtom)</code>: Is the atom imaginary?
</p>
</li>
<li> <p><code>is_complex(AffAtom)</code>: Is the atom complex valued?
</p>
</li>
<li> <p><code>is_atom_convex(AffAtom)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(AffAtom)</code>: The atom is concave.
</p>
</li>
<li> <p><code>is_incr(AffAtom)</code>: The atom is weakly increasing in every argument.
</p>
</li>
<li> <p><code>is_decr(AffAtom)</code>: The atom is not weakly decreasing in any argument.
</p>
</li>
<li> <p><code>is_quadratic(AffAtom)</code>: Is every argument quadratic?
</p>
</li>
<li> <p><code>is_qpwa(AffAtom)</code>: Is every argument quadratic of piecewise affine?
</p>
</li>
<li> <p><code>is_pwl(AffAtom)</code>: Is every argument piecewise linear?
</p>
</li>
<li> <p><code>is_psd(AffAtom)</code>: Is the atom a positive semidefinite matrix?
</p>
</li>
<li> <p><code>is_nsd(AffAtom)</code>: Is the atom a negative semidefinite matrix?
</p>
</li>
<li> <p><code>.grad(AffAtom)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>

<hr>
<h2 id='are_args_affine'>Are the arguments affine?</h2><span id='topic+are_args_affine'></span>

<h3>Description</h3>

<p>Are the arguments affine?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_args_affine(constraints)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are_args_affine_+3A_constraints">constraints</code></td>
<td>
<p>A <a href="#topic+Constraint-class">Constraint</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All the affine arguments in given constraints.
</p>

<hr>
<h2 id='Atom-class'>The Atom class.</h2><span id='topic+Atom-class'></span><span id='topic+Atom'></span><span id='topic+name+2CAtom-method'></span><span id='topic+validate_args+2CAtom-method'></span><span id='topic+dim+2CAtom-method'></span><span id='topic+nrow+2CAtom-method'></span><span id='topic+ncol+2CAtom-method'></span><span id='topic+allow_complex+2CAtom-method'></span><span id='topic+is_nonneg+2CAtom-method'></span><span id='topic+is_nonpos+2CAtom-method'></span><span id='topic+is_imag+2CAtom-method'></span><span id='topic+is_complex+2CAtom-method'></span><span id='topic+is_convex+2CAtom-method'></span><span id='topic+is_concave+2CAtom-method'></span><span id='topic+is_log_log_convex+2CAtom-method'></span><span id='topic+is_log_log_concave+2CAtom-method'></span><span id='topic+canonicalize+2CAtom-method'></span><span id='topic+graph_implementation+2CAtom-method'></span><span id='topic+value_impl+2CAtom-method'></span><span id='topic+value+2CAtom-method'></span><span id='topic+grad+2CAtom-method'></span><span id='topic+domain+2CAtom-method'></span><span id='topic+atoms+2CAtom-method'></span>

<h3>Description</h3>

<p>This virtual class represents atomic expressions in CVXR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Atom'
name(x)

## S4 method for signature 'Atom'
validate_args(object)

## S4 method for signature 'Atom'
dim(x)

## S4 method for signature 'Atom'
nrow(x)

## S4 method for signature 'Atom'
ncol(x)

## S4 method for signature 'Atom'
allow_complex(object)

## S4 method for signature 'Atom'
is_nonneg(object)

## S4 method for signature 'Atom'
is_nonpos(object)

## S4 method for signature 'Atom'
is_imag(object)

## S4 method for signature 'Atom'
is_complex(object)

## S4 method for signature 'Atom'
is_convex(object)

## S4 method for signature 'Atom'
is_concave(object)

## S4 method for signature 'Atom'
is_log_log_convex(object)

## S4 method for signature 'Atom'
is_log_log_concave(object)

## S4 method for signature 'Atom'
canonicalize(object)

## S4 method for signature 'Atom'
graph_implementation(object, arg_objs, dim, data = NA_real_)

## S4 method for signature 'Atom'
value_impl(object)

## S4 method for signature 'Atom'
value(object)

## S4 method for signature 'Atom'
grad(object)

## S4 method for signature 'Atom'
domain(object)

## S4 method for signature 'Atom'
atoms(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Atom-class_+3A_x">x</code>, <code id="Atom-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Atom-class">Atom</a> object.</p>
</td></tr>
<tr><td><code id="Atom-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="Atom-class_+3A_dim">dim</code></td>
<td>
<p>A vector with two elements representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="Atom-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(Atom)</code>: Returns the string representtation of the function call
</p>
</li>
<li> <p><code>validate_args(Atom)</code>: Raises an error if the arguments are invalid.
</p>
</li>
<li> <p><code>dim(Atom)</code>: The <code>c(row, col)</code> dimensions of the atom.
</p>
</li>
<li> <p><code>nrow(Atom)</code>: The number of rows in the atom.
</p>
</li>
<li> <p><code>ncol(Atom)</code>: The number of columns in the atom.
</p>
</li>
<li> <p><code>allow_complex(Atom)</code>: Does the atom handle complex numbers?
</p>
</li>
<li> <p><code>is_nonneg(Atom)</code>: A logical value indicating whether the atom is nonnegative.
</p>
</li>
<li> <p><code>is_nonpos(Atom)</code>: A logical value indicating whether the atom is nonpositive.
</p>
</li>
<li> <p><code>is_imag(Atom)</code>: A logical value indicating whether the atom is imaginary.
</p>
</li>
<li> <p><code>is_complex(Atom)</code>: A logical value indicating whether the atom is complex valued.
</p>
</li>
<li> <p><code>is_convex(Atom)</code>: A logical value indicating whether the atom is convex.
</p>
</li>
<li> <p><code>is_concave(Atom)</code>: A logical value indicating whether the atom is concave.
</p>
</li>
<li> <p><code>is_log_log_convex(Atom)</code>: A logical value indicating whether the atom is log-log convex.
</p>
</li>
<li> <p><code>is_log_log_concave(Atom)</code>: A logical value indicating whether the atom is log-log concave.
</p>
</li>
<li> <p><code>canonicalize(Atom)</code>: Represent the atom as an affine objective and conic constraints.
</p>
</li>
<li> <p><code>graph_implementation(Atom)</code>: The graph implementation of the atom.
</p>
</li>
<li> <p><code>value_impl(Atom)</code>: Returns the value of each of the componets in an Atom. Returns an empty matrix if it's an empty atom
</p>
</li>
<li> <p><code>value(Atom)</code>: Returns the value of the atom.
</p>
</li>
<li> <p><code>grad(Atom)</code>: The (sub/super)-gradient of the atom with respect to each variable.
</p>
</li>
<li> <p><code>domain(Atom)</code>: A list of constraints describing the closure of the region where the expression is finite.
</p>
</li>
<li> <p><code>atoms(Atom)</code>: Returns a list of the atom types present amongst this atom's arguments
</p>
</li></ul>

<hr>
<h2 id='AxisAtom-class'>The AxisAtom class.</h2><span id='topic+AxisAtom-class'></span><span id='topic+AxisAtom'></span><span id='topic+dim_from_args+2CAxisAtom-method'></span><span id='topic+get_data+2CAxisAtom-method'></span><span id='topic+validate_args+2CAxisAtom-method'></span><span id='topic+.axis_grad+2CAxisAtom-method'></span><span id='topic+.column_grad+2CAxisAtom-method'></span>

<h3>Description</h3>

<p>This virtual class represents atomic expressions that can be applied along an axis in CVXR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxisAtom'
dim_from_args(object)

## S4 method for signature 'AxisAtom'
get_data(object)

## S4 method for signature 'AxisAtom'
validate_args(object)

## S4 method for signature 'AxisAtom'
.axis_grad(object, values)

## S4 method for signature 'AxisAtom'
.column_grad(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AxisAtom-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Atom-class">Atom</a> object.</p>
</td></tr>
<tr><td><code id="AxisAtom-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="AxisAtom-class_+3A_value">value</code></td>
<td>
<p>A numeric value</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>dim_from_args(AxisAtom)</code>: The dimensions of the atom determined from its arguments.
</p>
</li>
<li> <p><code>get_data(AxisAtom)</code>: A list containing <code>axis</code> and <code>keepdims</code>.
</p>
</li>
<li> <p><code>validate_args(AxisAtom)</code>: Check that the new dimensions have the same number of entries as the old.
</p>
</li>
<li> <p><code>.axis_grad(AxisAtom)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.column_grad(AxisAtom)</code>: Gives the (sub/super)gradient of the atom w.r.t. each column variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>A numeric element, data.frame, matrix, vector, or Expression.</p>
</dd>
<dt><code>axis</code></dt><dd><p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</dd>
<dt><code>keepdims</code></dt><dd><p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</dd>
</dl>

<hr>
<h2 id='BinaryOperator-class'>The BinaryOperator class.</h2><span id='topic+BinaryOperator-class'></span><span id='topic+BinaryOperator'></span><span id='topic+name+2CBinaryOperator-method'></span><span id='topic+to_numeric+2CBinaryOperator-method'></span><span id='topic+sign_from_args+2CBinaryOperator-method'></span><span id='topic+is_imag+2CBinaryOperator-method'></span><span id='topic+is_complex+2CBinaryOperator-method'></span>

<h3>Description</h3>

<p>This base class represents expressions involving binary operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BinaryOperator'
name(x)

## S4 method for signature 'BinaryOperator'
to_numeric(object, values)

## S4 method for signature 'BinaryOperator'
sign_from_args(object)

## S4 method for signature 'BinaryOperator'
is_imag(object)

## S4 method for signature 'BinaryOperator'
is_complex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinaryOperator-class_+3A_x">x</code>, <code id="BinaryOperator-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+BinaryOperator-class">BinaryOperator</a> object.</p>
</td></tr>
<tr><td><code id="BinaryOperator-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(BinaryOperator)</code>: Returns the name of the BinaryOperator object.
</p>
</li>
<li> <p><code>to_numeric(BinaryOperator)</code>: Apply the binary operator to the values.
</p>
</li>
<li> <p><code>sign_from_args(BinaryOperator)</code>: Default to rule for multiplication.
</p>
</li>
<li> <p><code>is_imag(BinaryOperator)</code>: Is the expression imaginary?
</p>
</li>
<li> <p><code>is_complex(BinaryOperator)</code>: Is the expression complex valued?
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>lh_exp</code></dt><dd><p>The <a href="#topic+Expression-class">Expression</a> on the left-hand side of the operator.</p>
</dd>
<dt><code>rh_exp</code></dt><dd><p>The <a href="#topic+Expression-class">Expression</a> on the right-hand side of the operator.</p>
</dd>
<dt><code>op_name</code></dt><dd><p>A <code>character</code> string indicating the binary operation.</p>
</dd>
</dl>

<hr>
<h2 id='bmat'>Block Matrix</h2><span id='topic+bmat'></span>

<h3>Description</h3>

<p>Constructs a block matrix from a list of lists. Each internal list is stacked horizontally, and the internal lists are stacked vertically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmat(block_lists)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmat_+3A_block_lists">block_lists</code></td>
<td>
<p>A list of lists containing <a href="#topic+Expression-class">Expression</a> objects, matrices, or vectors, which represent the blocks of the block matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the block matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable()
expr &lt;- bmat(list(list(matrix(1, nrow = 3, ncol = 1), matrix(2, nrow = 3, ncol = 2)),
                list(matrix(3, nrow = 1, ncol = 2), x)
             ))
prob &lt;- Problem(Minimize(sum_entries(expr)), list(x &gt;= 0))
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='CallbackParam-class'>The CallbackParam class.</h2><span id='topic+CallbackParam-class'></span><span id='topic+.CallbackParam'></span><span id='topic+CallbackParam'></span><span id='topic+value+2CCallbackParam-method'></span>

<h3>Description</h3>

<p>This class represents a parameter whose value is obtained by evaluating a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CallbackParam(callback, dim = NULL, ...)

## S4 method for signature 'CallbackParam'
value(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CallbackParam-class_+3A_callback">callback</code></td>
<td>
<p>A callback function that generates the parameter value.</p>
</td></tr>
<tr><td><code id="CallbackParam-class_+3A_dim">dim</code></td>
<td>
<p>The dimensions of the parameter.</p>
</td></tr>
<tr><td><code id="CallbackParam-class_+3A_...">...</code></td>
<td>
<p>Additional attribute arguments. See <a href="#topic+Leaf-class">Leaf</a> for details.</p>
</td></tr>
<tr><td><code id="CallbackParam-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+CallbackParam-class">CallbackParam</a> object.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>callback</code></dt><dd><p>A callback function that generates the parameter value.</p>
</dd>
<dt><code>dim</code></dt><dd><p>The dimensions of the parameter.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(2)
fun &lt;- function() { value(x) }
y &lt;- CallbackParam(fun, dim(x), nonneg = TRUE)
get_data(y)
</code></pre>

<hr>
<h2 id='Canonical-class'>The Canonical class.</h2><span id='topic+Canonical-class'></span><span id='topic+expr+2CCanonical-method'></span><span id='topic+id+2CCanonical-method'></span><span id='topic+canonical_form+2CCanonical-method'></span><span id='topic+variables+2CCanonical-method'></span><span id='topic+parameters+2CCanonical-method'></span><span id='topic+constants+2CCanonical-method'></span><span id='topic+atoms+2CCanonical-method'></span><span id='topic+get_data+2CCanonical-method'></span>

<h3>Description</h3>

<p>This virtual class represents a canonical expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Canonical'
expr(object)

## S4 method for signature 'Canonical'
id(object)

## S4 method for signature 'Canonical'
canonical_form(object)

## S4 method for signature 'Canonical'
variables(object)

## S4 method for signature 'Canonical'
parameters(object)

## S4 method for signature 'Canonical'
constants(object)

## S4 method for signature 'Canonical'
atoms(object)

## S4 method for signature 'Canonical'
get_data(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Canonical-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Canonical-class">Canonical</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>expr(Canonical)</code>: The expression associated with the input.
</p>
</li>
<li> <p><code>id(Canonical)</code>: The unique ID of the canonical expression.
</p>
</li>
<li> <p><code>canonical_form(Canonical)</code>: The graph implementation of the input.
</p>
</li>
<li> <p><code>variables(Canonical)</code>: List of <a href="#topic+Variable-class">Variable</a> objects in the expression.
</p>
</li>
<li> <p><code>parameters(Canonical)</code>: List of <a href="#topic+Parameter-class">Parameter</a> objects in the expression.
</p>
</li>
<li> <p><code>constants(Canonical)</code>: List of <a href="#topic+Constant-class">Constant</a> objects in the expression.
</p>
</li>
<li> <p><code>atoms(Canonical)</code>: List of <a href="#topic+Atom-class">Atom</a> objects in the expression.
</p>
</li>
<li> <p><code>get_data(Canonical)</code>: Information needed to reconstruct the expression aside from its arguments.
</p>
</li></ul>

<hr>
<h2 id='Canonicalization-class'>The Canonicalization class.</h2><span id='topic+Canonicalization-class'></span><span id='topic+.Canonicalization'></span><span id='topic+perform+2CCanonicalization+2CProblem-method'></span><span id='topic+invert+2CCanonicalization+2CSolution+2CInverseData-method'></span><span id='topic+canonicalize_tree+2CCanonicalization-method'></span><span id='topic+canonicalize_expr+2CCanonicalization-method'></span>

<h3>Description</h3>

<p>This class represents a canonicalization reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Canonicalization,Problem'
perform(object, problem)

## S4 method for signature 'Canonicalization,Solution,InverseData'
invert(object, solution, inverse_data)

## S4 method for signature 'Canonicalization'
canonicalize_tree(object, expr)

## S4 method for signature 'Canonicalization'
canonicalize_expr(object, expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Canonicalization-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Canonicalization-class">Canonicalization</a> object.</p>
</td></tr>
<tr><td><code id="Canonicalization-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="Canonicalization-class_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> to a problem that generated the inverse data.</p>
</td></tr>
<tr><td><code id="Canonicalization-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>An <a href="#topic+InverseData-class">InverseData</a> object that contains the data encoding the original problem.</p>
</td></tr>
<tr><td><code id="Canonicalization-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
<tr><td><code id="Canonicalization-class_+3A_args">args</code></td>
<td>
<p>List of arguments to canonicalize the expression.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>perform(object = Canonicalization, problem = Problem)</code>: Recursively canonicalize the objective and every constraint.
</p>
</li>
<li> <p><code>invert(
  object = Canonicalization,
  solution = Solution,
  inverse_data = InverseData
)</code>: Performs the reduction on a problem and returns an equivalent problem.
</p>
</li>
<li> <p><code>canonicalize_tree(Canonicalization)</code>: Recursively canonicalize an Expression.
</p>
</li>
<li> <p><code>canonicalize_expr(Canonicalization)</code>: Canonicalize an expression, w.r.t. canonicalized arguments.
</p>
</li></ul>

<hr>
<h2 id='canonicalize'>Canonicalize</h2><span id='topic+canonicalize'></span><span id='topic+canonical_form'></span>

<h3>Description</h3>

<p>Computes the graph implementation of a canonical expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canonicalize(object)

canonical_form(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canonicalize_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Canonical-class">Canonical</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>list(affine expression, list(constraints))</code>.
</p>

<hr>
<h2 id='CBC_CONIC-class'>An interface to the CBC solver</h2><span id='topic+CBC_CONIC-class'></span><span id='topic+CBC_CONIC'></span><span id='topic+mip_capable+2CCBC_CONIC-method'></span><span id='topic+status_map+2CCBC_CONIC-method'></span><span id='topic+status_map_mip+2CCBC_CONIC-method'></span><span id='topic+status_map_lp+2CCBC_CONIC-method'></span><span id='topic+name+2CCBC_CONIC-method'></span><span id='topic+import_solver+2CCBC_CONIC-method'></span><span id='topic+accepts+2CCBC_CONIC+2CProblem-method'></span><span id='topic+perform+2CCBC_CONIC+2CProblem-method'></span><span id='topic+invert+2CCBC_CONIC+2Clist+2Clist-method'></span><span id='topic+solve_via_data+2CCBC_CONIC-method'></span>

<h3>Description</h3>

<p>An interface to the CBC solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CBC_CONIC()

## S4 method for signature 'CBC_CONIC'
mip_capable(solver)

## S4 method for signature 'CBC_CONIC'
status_map(solver, status)

## S4 method for signature 'CBC_CONIC'
status_map_mip(solver, status)

## S4 method for signature 'CBC_CONIC'
status_map_lp(solver, status)

## S4 method for signature 'CBC_CONIC'
name(x)

## S4 method for signature 'CBC_CONIC'
import_solver(solver)

## S4 method for signature 'CBC_CONIC,Problem'
accepts(object, problem)

## S4 method for signature 'CBC_CONIC,Problem'
perform(object, problem)

## S4 method for signature 'CBC_CONIC,list,list'
invert(object, solution, inverse_data)

## S4 method for signature 'CBC_CONIC'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CBC_CONIC-class_+3A_solver">solver</code>, <code id="CBC_CONIC-class_+3A_object">object</code>, <code id="CBC_CONIC-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+CBC_CONIC-class">CBC_CONIC</a> object.</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_status">status</code></td>
<td>
<p>A status code returned by the solver.</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_solution">solution</code></td>
<td>
<p>The raw solution returned by the solver.</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A list containing data necessary for the inversion.</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance.</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance.</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance.</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="CBC_CONIC-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(CBC_CONIC)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>status_map(CBC_CONIC)</code>: Converts status returned by the CBC solver to its respective CVXPY status.
</p>
</li>
<li> <p><code>status_map_mip(CBC_CONIC)</code>: Converts status returned by the CBC solver to its respective CVXPY status for mixed integer problems.
</p>
</li>
<li> <p><code>status_map_lp(CBC_CONIC)</code>: Converts status returned by the CBC solver to its respective CVXPY status for linear problems.
</p>
</li>
<li> <p><code>name(CBC_CONIC)</code>: Returns the name of the solver
</p>
</li>
<li> <p><code>import_solver(CBC_CONIC)</code>: Imports the solver
</p>
</li>
<li> <p><code>accepts(object = CBC_CONIC, problem = Problem)</code>: Can CBC_CONIC solve the problem?
</p>
</li>
<li> <p><code>perform(object = CBC_CONIC, problem = Problem)</code>: Returns a new problem and data for inverting the new solution.
</p>
</li>
<li> <p><code>invert(object = CBC_CONIC, solution = list, inverse_data = list)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li>
<li> <p><code>solve_via_data(CBC_CONIC)</code>: Solve a problem represented by data returned from apply.
</p>
</li></ul>

<hr>
<h2 id='cdiac'>Global Monthly and Annual Temperature Anomalies (degrees C), 1850-2015
(Relative to the 1961-1990 Mean) (May 2016)</h2><span id='topic+cdiac'></span>

<h3>Description</h3>

<p>Global Monthly and Annual Temperature Anomalies (degrees C), 1850-2015
(Relative to the 1961-1990 Mean) (May 2016)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdiac
</code></pre>


<h3>Format</h3>

<p>A data frame with 166 rows and 14 variables:
</p>

<dl>
<dt>year</dt><dd><p>Year</p>
</dd>
<dt>jan</dt><dd><p>Anomaly for month of January</p>
</dd>
<dt>feb</dt><dd><p>Anomaly for month of February</p>
</dd>
<dt>mar</dt><dd><p>Anomaly for month of March</p>
</dd>
<dt>apr</dt><dd><p>Anomaly for month of April</p>
</dd>
<dt>may</dt><dd><p>Anomaly for month of May</p>
</dd>
<dt>jun</dt><dd><p>Anomaly for month of June</p>
</dd>
<dt>jul</dt><dd><p>Anomaly for month of July</p>
</dd>
<dt>aug</dt><dd><p>Anomaly for month of August</p>
</dd>
<dt>sep</dt><dd><p>Anomaly for month of September</p>
</dd>
<dt>oct</dt><dd><p>Anomaly for month of October</p>
</dd>
<dt>nov</dt><dd><p>Anomaly for month of November</p>
</dd>
<dt>dec</dt><dd><p>Anomaly for month of December</p>
</dd>
<dt>annual</dt><dd><p>Annual anomaly for the year</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://ess-dive.lbl.gov/">https://ess-dive.lbl.gov/</a>
</p>


<h3>References</h3>

<p><a href="https://ess-dive.lbl.gov/">https://ess-dive.lbl.gov/</a>
</p>

<hr>
<h2 id='Chain-class'>The Chain class.</h2><span id='topic+Chain-class'></span><span id='topic+.Chain'></span><span id='topic+as.character+2CChain-method'></span><span id='topic+accepts+2CChain+2CProblem-method'></span><span id='topic+perform+2CChain+2CProblem-method'></span><span id='topic+invert+2CChain+2CSolutionORList+2Clist-method'></span>

<h3>Description</h3>

<p>This class represents a reduction that replaces symbolic parameters with
their constraint values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Chain'
as.character(x)

## S4 method for signature 'Chain,Problem'
accepts(object, problem)

## S4 method for signature 'Chain,Problem'
perform(object, problem)

## S4 method for signature 'Chain,SolutionORList,list'
invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Chain-class_+3A_x">x</code>, <code id="Chain-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Chain-class">Chain</a> object.</p>
</td></tr>
<tr><td><code id="Chain-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object to check.</p>
</td></tr>
<tr><td><code id="Chain-class_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> or list.</p>
</td></tr>
<tr><td><code id="Chain-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A list that contains the data encoding the original problem.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>accepts(object = Chain, problem = Problem)</code>: A problem is accepted if the sequence of reductions is valid. In particular, the i-th reduction must accept the output of the i-1th
reduction, with the first reduction (self.reductions[0]) in the sequence taking as input the supplied problem.
</p>
</li>
<li> <p><code>perform(object = Chain, problem = Problem)</code>: Applies the chain to a problem and returns an equivalent problem.
</p>
</li>
<li> <p><code>invert(object = Chain, solution = SolutionORList, inverse_data = list)</code>: Performs the reduction on a problem and returns an equivalent problem.
</p>
</li></ul>

<hr>
<h2 id='complex-atoms'>Complex Numbers</h2><span id='topic+complex-atoms'></span><span id='topic+Re+2CExpression-method'></span><span id='topic+Im+2CExpression-method'></span><span id='topic+Conj+2CExpression-method'></span>

<h3>Description</h3>

<p>Basic atoms that support complex arithmetic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression'
Re(z)

## S4 method for signature 'Expression'
Im(z)

## S4 method for signature 'Expression'
Conj(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complex-atoms_+3A_z">z</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> object that represents the real, imaginary, or complex conjugate.
</p>

<hr>
<h2 id='complex-methods'>Complex Properties</h2><span id='topic+complex-methods'></span><span id='topic+is_real'></span><span id='topic+is_imag'></span><span id='topic+is_complex'></span>

<h3>Description</h3>

<p>Determine if an expression is real, imaginary, or complex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_real(object)

is_imag(object)

is_complex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complex-methods_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>

<hr>
<h2 id='Complex2Real-class'>Lifts complex numbers to a real representation.</h2><span id='topic+Complex2Real-class'></span><span id='topic+Complex2Real'></span><span id='topic+accepts+2CComplex2Real+2CProblem-method'></span><span id='topic+perform+2CComplex2Real+2CProblem-method'></span><span id='topic+invert+2CComplex2Real+2CSolution+2CInverseData-method'></span>

<h3>Description</h3>

<p>This reduction takes in a complex problem and returns
an equivalent real problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Complex2Real,Problem'
accepts(object, problem)

## S4 method for signature 'Complex2Real,Problem'
perform(object, problem)

## S4 method for signature 'Complex2Real,Solution,InverseData'
invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Complex2Real-class">Complex2Real</a> object.</p>
</td></tr>
<tr><td><code id="Complex2Real-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="Complex2Real-class_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> object to invert.</p>
</td></tr>
<tr><td><code id="Complex2Real-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A <a href="#topic+InverseData-class">InverseData</a> object containing data necessary for the inversion.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>accepts(object = Complex2Real, problem = Problem)</code>: Checks whether or not the problem involves any complex numbers.
</p>
</li>
<li> <p><code>perform(object = Complex2Real, problem = Problem)</code>: Converts a Complex problem into a Real one.
</p>
</li>
<li> <p><code>invert(object = Complex2Real, solution = Solution, inverse_data = InverseData)</code>: Returns a solution to the original problem given the inverse data.
</p>
</li></ul>

<hr>
<h2 id='Complex2Real.abs_canon'>Complex canonicalizer for the absolute value atom</h2><span id='topic+Complex2Real.abs_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the absolute value atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.abs_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.abs_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.abs_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.abs_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.abs_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the absolute value atom of a complex expression, where the returned
variables are its real and imaginary components parsed out.
</p>

<hr>
<h2 id='Complex2Real.add'>Helper function to sum arguments.</h2><span id='topic+Complex2Real.add'></span>

<h3>Description</h3>

<p>Helper function to sum arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.add(lh_arg, rh_arg, neg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.add_+3A_lh_arg">lh_arg</code></td>
<td>
<p>The arguments for the left-hand side</p>
</td></tr>
<tr><td><code id="Complex2Real.add_+3A_rh_arg">rh_arg</code></td>
<td>
<p>The arguments for the right-hand side</p>
</td></tr>
<tr><td><code id="Complex2Real.add_+3A_neg">neg</code></td>
<td>
<p>Whether to negate the right hand side</p>
</td></tr>
</table>

<hr>
<h2 id='Complex2Real.at_least_2D'>Upcast 0D and 1D to 2D.</h2><span id='topic+Complex2Real.at_least_2D'></span>

<h3>Description</h3>

<p>Upcast 0D and 1D to 2D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.at_least_2D(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.at_least_2D_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An expression of dimension at least 2.
</p>

<hr>
<h2 id='Complex2Real.binary_canon'>Complex canonicalizer for the binary atom</h2><span id='topic+Complex2Real.binary_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the binary atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.binary_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.binary_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.binary_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.binary_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.binary_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a binary atom, where the returned
variables are the real component and the imaginary component.
</p>

<hr>
<h2 id='Complex2Real.canonicalize_expr'>Canonicalizes a Complex Expression</h2><span id='topic+Complex2Real.canonicalize_expr'></span>

<h3>Description</h3>

<p>Canonicalizes a Complex Expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.canonicalize_expr(expr, real_args, imag_args, real2imag, leaf_map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.canonicalize_expr_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
<tr><td><code id="Complex2Real.canonicalize_expr_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression.</p>
</td></tr>
<tr><td><code id="Complex2Real.canonicalize_expr_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression.</p>
</td></tr>
<tr><td><code id="Complex2Real.canonicalize_expr_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
<tr><td><code id="Complex2Real.canonicalize_expr_+3A_leaf_map">leaf_map</code></td>
<td>
<p>A map that consists of a tree representation of the overall expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the parsed out real and imaginary components of the expression at hand.
</p>

<hr>
<h2 id='Complex2Real.canonicalize_tree'>Recursively Canonicalizes a Complex Expression.</h2><span id='topic+Complex2Real.canonicalize_tree'></span>

<h3>Description</h3>

<p>Recursively Canonicalizes a Complex Expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.canonicalize_tree(expr, real2imag, leaf_map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.canonicalize_tree_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
<tr><td><code id="Complex2Real.canonicalize_tree_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
<tr><td><code id="Complex2Real.canonicalize_tree_+3A_leaf_map">leaf_map</code></td>
<td>
<p>A map that consists of a tree representation of the expression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the parsed out real and imaginary components of the
expression that was constructed by performing the canonicalization of each leaf
in the tree.
</p>

<hr>
<h2 id='Complex2Real.conj_canon'>Complex canonicalizer for the conjugate atom</h2><span id='topic+Complex2Real.conj_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the conjugate atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.conj_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.conj_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.conj_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.conj_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.conj_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a conjugate atom, where the returned
variables are the real components and negative of the imaginary component.
</p>

<hr>
<h2 id='Complex2Real.constant_canon'>Complex canonicalizer for the constant atom</h2><span id='topic+Complex2Real.constant_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the constant atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.constant_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.constant_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.constant_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.constant_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.constant_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a constant atom, where the returned
variables are the real component and the imaginary component in the <a href="#topic+Constant-class">Constant</a>
atom.
</p>

<hr>
<h2 id='Complex2Real.hermitian_canon'>Complex canonicalizer for the hermitian atom</h2><span id='topic+Complex2Real.hermitian_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the hermitian atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.hermitian_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.hermitian_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.hermitian_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.hermitian_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.hermitian_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a hermitian matrix atom, where the returned
variables are the real component and the imaginary component.
</p>

<hr>
<h2 id='Complex2Real.imag_canon'>Complex canonicalizer for the imaginary atom</h2><span id='topic+Complex2Real.imag_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the imaginary atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.imag_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.imag_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.imag_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.imag_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.imag_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of an imaginary atom, where the returned
variables are the imaginary component and NULL for the real component.
</p>

<hr>
<h2 id='Complex2Real.join'>Helper function to combine arguments.</h2><span id='topic+Complex2Real.join'></span>

<h3>Description</h3>

<p>Helper function to combine arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.join(expr, lh_arg, rh_arg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.join_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.join_+3A_lh_arg">lh_arg</code></td>
<td>
<p>The arguments for the left-hand side</p>
</td></tr>
<tr><td><code id="Complex2Real.join_+3A_rh_arg">rh_arg</code></td>
<td>
<p>The arguments for the right-hand side</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A joined expression of both left and right expressions
</p>

<hr>
<h2 id='Complex2Real.lambda_sum_largest_canon'>Complex canonicalizer for the largest sum atom</h2><span id='topic+Complex2Real.lambda_sum_largest_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the largest sum atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.lambda_sum_largest_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.lambda_sum_largest_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.lambda_sum_largest_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.lambda_sum_largest_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.lambda_sum_largest_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the largest sum atom, where the returned
variables are the real component and the imaginary component.
</p>

<hr>
<h2 id='Complex2Real.matrix_frac_canon'>Complex canonicalizer for the matrix fraction atom</h2><span id='topic+Complex2Real.matrix_frac_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the matrix fraction atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.matrix_frac_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.matrix_frac_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.matrix_frac_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.matrix_frac_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.matrix_frac_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a matrix atom, where the returned
variables are converted to real variables.
</p>

<hr>
<h2 id='Complex2Real.nonpos_canon'>Complex canonicalizer for the non-positive atom</h2><span id='topic+Complex2Real.nonpos_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the non-positive atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.nonpos_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.nonpos_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.nonpos_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.nonpos_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.nonpos_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a non positive atom, where the returned
variables are the real component and the imaginary component.
</p>

<hr>
<h2 id='Complex2Real.norm_nuc_canon'>Complex canonicalizer for the nuclear norm atom</h2><span id='topic+Complex2Real.norm_nuc_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the nuclear norm atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.norm_nuc_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.norm_nuc_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.norm_nuc_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.norm_nuc_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.norm_nuc_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a nuclear norm matrix atom, where the returned
variables are the real component and the imaginary component.
</p>

<hr>
<h2 id='Complex2Real.param_canon'>Complex canonicalizer for the parameter matrix atom</h2><span id='topic+Complex2Real.param_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the parameter matrix atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.param_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.param_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.param_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.param_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.param_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a parameter matrix atom, where the returned
variables are the real component and the imaginary component.
</p>

<hr>
<h2 id='Complex2Real.pnorm_canon'>Complex canonicalizer for the p norm atom</h2><span id='topic+Complex2Real.pnorm_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the p norm atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.pnorm_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.pnorm_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.pnorm_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.pnorm_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.pnorm_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a pnorm atom, where the returned
variables are the real component and the NULL imaginary component.
</p>

<hr>
<h2 id='Complex2Real.psd_canon'>Complex canonicalizer for the positive semidefinite atom</h2><span id='topic+Complex2Real.psd_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the positive semidefinite atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.psd_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.psd_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.psd_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.psd_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.psd_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a positive semidefinite atom, where the returned
variables are the real component and the NULL imaginary component.
</p>

<hr>
<h2 id='Complex2Real.quad_canon'>Complex canonicalizer for the quadratic atom</h2><span id='topic+Complex2Real.quad_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the quadratic atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.quad_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.quad_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.quad_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.quad_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.quad_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a quadratic atom, where the returned
variables are the real component and the imaginary component as NULL.
</p>

<hr>
<h2 id='Complex2Real.quad_over_lin_canon'>Complex canonicalizer for the quadratic over linear term atom</h2><span id='topic+Complex2Real.quad_over_lin_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the quadratic over linear term atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.quad_over_lin_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.quad_over_lin_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.quad_over_lin_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.quad_over_lin_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.quad_over_lin_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a quadratic over a linear term atom, where the returned
variables are the real component and the imaginary component.
</p>

<hr>
<h2 id='Complex2Real.real_canon'>Complex canonicalizer for the real atom</h2><span id='topic+Complex2Real.real_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the real atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.real_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.real_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.real_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.real_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.real_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a real atom, where the returned
variables are the real component and NULL for the imaginary component.
</p>

<hr>
<h2 id='Complex2Real.separable_canon'>Complex canonicalizer for the separable atom</h2><span id='topic+Complex2Real.separable_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the separable atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.separable_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.separable_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.separable_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.separable_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.separable_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a separable atom, where the returned
variables are its real and imaginary components parsed out.
</p>

<hr>
<h2 id='Complex2Real.soc_canon'>Complex canonicalizer for the SOC atom</h2><span id='topic+Complex2Real.soc_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the SOC atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.soc_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.soc_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.soc_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.soc_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.soc_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a SOC atom, where the returned
variables are the real component and the NULL imaginary component.
</p>

<hr>
<h2 id='Complex2Real.variable_canon'>Complex canonicalizer for the variable atom</h2><span id='topic+Complex2Real.variable_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the variable atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.variable_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.variable_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.variable_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.variable_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.variable_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a variable atom, where the returned
variables are the real component and the NULL imaginary component.
</p>

<hr>
<h2 id='Complex2Real.zero_canon'>Complex canonicalizer for the zero atom</h2><span id='topic+Complex2Real.zero_canon'></span>

<h3>Description</h3>

<p>Complex canonicalizer for the zero atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Complex2Real.zero_canon(expr, real_args, imag_args, real2imag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Complex2Real.zero_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Complex2Real.zero_canon_+3A_real_args">real_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the real part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.zero_canon_+3A_imag_args">imag_args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for the imaginary part of the expression</p>
</td></tr>
<tr><td><code id="Complex2Real.zero_canon_+3A_real2imag">real2imag</code></td>
<td>
<p>A list mapping the ID of the real part of a complex expression to the ID of its imaginary part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of a zero atom, where the returned
variables are the real component and the imaginary component.
</p>

<hr>
<h2 id='cone-methods'>Second-Order Cone Methods</h2><span id='topic+cone-methods'></span><span id='topic+num_cones'></span><span id='topic+cone_sizes'></span>

<h3>Description</h3>

<p>The number of elementwise cones or a list of the sizes of the elementwise cones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_cones(object)

cone_sizes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cone-methods_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+SOCAxis-class">SOCAxis</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of cones, or the size of a cone.
</p>

<hr>
<h2 id='ConeDims-class'>Summary of cone dimensions present in constraints.</h2><span id='topic+ConeDims-class'></span><span id='topic+.ConeDims'></span>

<h3>Description</h3>

<p>Constraints must be formatted as dictionary that maps from
constraint type to a list of constraints of that type.
</p>


<h3>Details</h3>

<p>Attributes
&mdash;&mdash;&mdash;-
zero : int
The dimension of the zero cone.
nonpos : int
The dimension of the non-positive cone.
exp : int
The dimension of the exponential cone.
soc : list of int
A list of the second-order cone dimensions.
psd : list of int
A list of the positive semidefinite cone dimensions, where the
dimension of the PSD cone of k by k matrices is k.
</p>

<hr>
<h2 id='ConeMatrixStuffing-class'>Construct Matrices for Linear Cone Problems</h2><span id='topic+ConeMatrixStuffing-class'></span><span id='topic+ConeMatrixStuffing'></span><span id='topic+accepts+2CConeMatrixStuffing+2CProblem-method'></span><span id='topic+stuffed_objective+2CConeMatrixStuffing+2CProblem+2CCoeffExtractor-method'></span>

<h3>Description</h3>

<p>Linear cone problems are assumed to have a linear objective and cone constraints,
which may have zero or more arguments, all of which must be affine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConeMatrixStuffing,Problem'
accepts(object, problem)

## S4 method for signature 'ConeMatrixStuffing,Problem,CoeffExtractor'
stuffed_objective(object, problem, extractor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConeMatrixStuffing-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+ConeMatrixStuffing-class">ConeMatrixStuffing</a> object.</p>
</td></tr>
<tr><td><code id="ConeMatrixStuffing-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="ConeMatrixStuffing-class_+3A_extractor">extractor</code></td>
<td>
<p>Used to extract the affine coefficients of the objective.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>minimize c^Tx
subject to cone_constr1(A_1*x + b_1, ...)
...
cone_constrK(A_K*x + b_K, ...)
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>accepts(object = ConeMatrixStuffing, problem = Problem)</code>: Is the solver accepted?
</p>
</li>
<li> <p><code>stuffed_objective(
  object = ConeMatrixStuffing,
  problem = Problem,
  extractor = CoeffExtractor
)</code>: Returns a list of the stuffed matrices
</p>
</li></ul>

<hr>
<h2 id='ConicSolver-class'>The ConicSolver class.</h2><span id='topic+ConicSolver-class'></span><span id='topic+ConicSolver'></span><span id='topic+accepts+2CConicSolver+2CProblem-method'></span><span id='topic+reduction_format_constr+2CConicSolver-method'></span><span id='topic+group_coeff_offset+2CConicSolver-method'></span><span id='topic+invert+2CConicSolver+2CSolution+2CInverseData-method'></span>

<h3>Description</h3>

<p>Conic solver class with reduction semantics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConicSolver,Problem'
accepts(object, problem)

## S4 method for signature 'ConicSolver'
reduction_format_constr(object, problem, constr, exp_cone_order)

## S4 method for signature 'ConicSolver'
group_coeff_offset(object, problem, constraints, exp_cone_order)

## S4 method for signature 'ConicSolver,Solution,InverseData'
invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConicSolver-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+ConicSolver-class">ConicSolver</a> object.</p>
</td></tr>
<tr><td><code id="ConicSolver-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="ConicSolver-class_+3A_constr">constr</code></td>
<td>
<p>A <a href="#topic+Constraint-class">Constraint</a> to format.</p>
</td></tr>
<tr><td><code id="ConicSolver-class_+3A_exp_cone_order">exp_cone_order</code></td>
<td>
<p>A list indicating how the exponential cone arguments are ordered.</p>
</td></tr>
<tr><td><code id="ConicSolver-class_+3A_constraints">constraints</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects.</p>
</td></tr>
<tr><td><code id="ConicSolver-class_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> object to invert.</p>
</td></tr>
<tr><td><code id="ConicSolver-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A <a href="#topic+InverseData-class">InverseData</a> object containing data necessary for the inversion.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>accepts(object = ConicSolver, problem = Problem)</code>: Can the problem be solved with a conic solver?
</p>
</li>
<li> <p><code>reduction_format_constr(ConicSolver)</code>: Return a list representing a cone program whose problem data tensors
will yield the coefficient &quot;A&quot; and offset &quot;b&quot; for the respective constraints:
Linear Equations: <code class="reqn">A x = b</code>,
Linear inequalities: <code class="reqn">A x \leq b</code>,
Second order cone: <code class="reqn">A x \leq_{SOC} b</code>,
Exponential cone: <code class="reqn">A x \leq_{EXP} b</code>,
Semidefinite cone: <code class="reqn">A x \leq_{SOP} b</code>.
</p>
</li>
<li> <p><code>group_coeff_offset(ConicSolver)</code>: Combine the constraints into a single matrix, offset.
</p>
</li>
<li> <p><code>invert(object = ConicSolver, solution = Solution, inverse_data = InverseData)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li></ul>

<hr>
<h2 id='ConicSolver.get_coeff_offset'>Return the coefficient and offset in <code class="reqn">Ax + b</code>.</h2><span id='topic+ConicSolver.get_coeff_offset'></span>

<h3>Description</h3>

<p>Return the coefficient and offset in <code class="reqn">Ax + b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConicSolver.get_coeff_offset(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConicSolver.get_coeff_offset_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coefficient and offset in <code class="reqn">Ax + b</code>.
</p>

<hr>
<h2 id='ConicSolver.get_spacing_matrix'>Returns a sparse matrix that spaces out an expression.</h2><span id='topic+ConicSolver.get_spacing_matrix'></span>

<h3>Description</h3>

<p>Returns a sparse matrix that spaces out an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConicSolver.get_spacing_matrix(dim, spacing, offset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConicSolver.get_spacing_matrix_+3A_dim">dim</code></td>
<td>
<p>A vector outlining the dimensions of the matrix.</p>
</td></tr>
<tr><td><code id="ConicSolver.get_spacing_matrix_+3A_spacing">spacing</code></td>
<td>
<p>An int of the number of rows between the start of each non-zero block.</p>
</td></tr>
<tr><td><code id="ConicSolver.get_spacing_matrix_+3A_offset">offset</code></td>
<td>
<p>An int of the number of zeros at the beginning of the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix that spaces out an expression
</p>

<hr>
<h2 id='Conjugate-class'>The Conjugate class.</h2><span id='topic+Conjugate-class'></span><span id='topic+.Conjugate'></span><span id='topic+Conjugate'></span><span id='topic+to_numeric+2CConjugate-method'></span><span id='topic+dim_from_args+2CConjugate-method'></span><span id='topic+is_incr+2CConjugate-method'></span><span id='topic+is_decr+2CConjugate-method'></span><span id='topic+is_symmetric+2CConjugate-method'></span><span id='topic+is_hermitian+2CConjugate-method'></span>

<h3>Description</h3>

<p>This class represents the complex conjugate of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Conjugate(expr)

## S4 method for signature 'Conjugate'
to_numeric(object, values)

## S4 method for signature 'Conjugate'
dim_from_args(object)

## S4 method for signature 'Conjugate'
is_incr(object, idx)

## S4 method for signature 'Conjugate'
is_decr(object, idx)

## S4 method for signature 'Conjugate'
is_symmetric(object)

## S4 method for signature 'Conjugate'
is_hermitian(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Conjugate-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or R numeric data.</p>
</td></tr>
<tr><td><code id="Conjugate-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Conjugate-class">Conjugate</a> object.</p>
</td></tr>
<tr><td><code id="Conjugate-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="Conjugate-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Conjugate)</code>: Elementwise complex conjugate of the constant.
</p>
</li>
<li> <p><code>dim_from_args(Conjugate)</code>: The (row, col) dimensions of the expression.
</p>
</li>
<li> <p><code>is_incr(Conjugate)</code>: Is the composition weakly increasing in argument idx?
</p>
</li>
<li> <p><code>is_decr(Conjugate)</code>: Is the composition weakly decreasing in argument idx?
</p>
</li>
<li> <p><code>is_symmetric(Conjugate)</code>: Is the expression symmetric?
</p>
</li>
<li> <p><code>is_hermitian(Conjugate)</code>: Is the expression hermitian?
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or R numeric data.</p>
</dd>
</dl>

<hr>
<h2 id='Constant-class'>The Constant class.</h2><span id='topic+Constant-class'></span><span id='topic+.Constant'></span><span id='topic+Constant'></span><span id='topic+show+2CConstant-method'></span><span id='topic+name+2CConstant-method'></span><span id='topic+constants+2CConstant-method'></span><span id='topic+value+2CConstant-method'></span><span id='topic+is_pos+2CConstant-method'></span><span id='topic+grad+2CConstant-method'></span><span id='topic+dim+2CConstant-method'></span><span id='topic+canonicalize+2CConstant-method'></span><span id='topic+is_nonneg+2CConstant-method'></span><span id='topic+is_nonpos+2CConstant-method'></span><span id='topic+is_imag+2CConstant-method'></span><span id='topic+is_complex+2CConstant-method'></span><span id='topic+is_symmetric+2CConstant-method'></span><span id='topic+is_hermitian+2CConstant-method'></span><span id='topic+is_psd+2CConstant-method'></span><span id='topic+is_nsd+2CConstant-method'></span><span id='topic+as.Constant'></span>

<h3>Description</h3>

<p>This class represents a constant.
</p>
<p>Coerce an R object or expression into the <a href="#topic+Constant-class">Constant</a> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Constant(value)

## S4 method for signature 'Constant'
show(object)

## S4 method for signature 'Constant'
name(x)

## S4 method for signature 'Constant'
constants(object)

## S4 method for signature 'Constant'
value(object)

## S4 method for signature 'Constant'
is_pos(object)

## S4 method for signature 'Constant'
grad(object)

## S4 method for signature 'Constant'
dim(x)

## S4 method for signature 'Constant'
canonicalize(object)

## S4 method for signature 'Constant'
is_nonneg(object)

## S4 method for signature 'Constant'
is_nonpos(object)

## S4 method for signature 'Constant'
is_imag(object)

## S4 method for signature 'Constant'
is_complex(object)

## S4 method for signature 'Constant'
is_symmetric(object)

## S4 method for signature 'Constant'
is_hermitian(object)

## S4 method for signature 'Constant'
is_psd(object)

## S4 method for signature 'Constant'
is_nsd(object)

as.Constant(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Constant-class_+3A_value">value</code></td>
<td>
<p>A numeric element, vector, matrix, or data.frame. Vectors are automatically cast into a matrix column.</p>
</td></tr>
<tr><td><code id="Constant-class_+3A_x">x</code>, <code id="Constant-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Constant-class">Constant</a> object.</p>
</td></tr>
<tr><td><code id="Constant-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, numeric element, vector, matrix, or data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Constant-class">Constant</a> representing the input as a constant.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(Constant)</code>: The name of the constant.
</p>
</li>
<li> <p><code>constants(Constant)</code>: Returns itself as a constant.
</p>
</li>
<li> <p><code>value(Constant)</code>: The value of the constant.
</p>
</li>
<li> <p><code>is_pos(Constant)</code>: A logical value indicating whether all elements of the constant are positive.
</p>
</li>
<li> <p><code>grad(Constant)</code>: An empty list since the gradient of a constant is zero.
</p>
</li>
<li> <p><code>dim(Constant)</code>: The <code>c(row, col)</code> dimensions of the constant.
</p>
</li>
<li> <p><code>canonicalize(Constant)</code>: The canonical form of the constant.
</p>
</li>
<li> <p><code>is_nonneg(Constant)</code>: A logical value indicating whether all elements of the constant are non-negative.
</p>
</li>
<li> <p><code>is_nonpos(Constant)</code>: A logical value indicating whether all elements of the constant are non-positive.
</p>
</li>
<li> <p><code>is_imag(Constant)</code>: A logical value indicating whether the constant is imaginary.
</p>
</li>
<li> <p><code>is_complex(Constant)</code>: A logical value indicating whether the constant is complex-valued.
</p>
</li>
<li> <p><code>is_symmetric(Constant)</code>: A logical value indicating whether the constant is symmetric.
</p>
</li>
<li> <p><code>is_hermitian(Constant)</code>: A logical value indicating whether the constant is a Hermitian matrix.
</p>
</li>
<li> <p><code>is_psd(Constant)</code>: A logical value indicating whether the constant is a positive semidefinite matrix.
</p>
</li>
<li> <p><code>is_nsd(Constant)</code>: A logical value indicating whether the constant is a negative semidefinite matrix.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>value</code></dt><dd><p>A numeric element, vector, matrix, or data.frame. Vectors are automatically cast into a matrix column.</p>
</dd>
<dt><code>sparse</code></dt><dd><p>(Internal) A logical value indicating whether the value is a sparse matrix.</p>
</dd>
<dt><code>is_pos</code></dt><dd><p>(Internal) A logical value indicating whether all elements are non-negative.</p>
</dd>
<dt><code>is_neg</code></dt><dd><p>(Internal) A logical value indicating whether all elements are non-positive.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Constant(5)
y &lt;- Constant(diag(3))
get_data(y)
value(y)
is_nonneg(y)
size(y)
as.Constant(y)
</code></pre>

<hr>
<h2 id='ConstantSolver-class'>The ConstantSolver class.</h2><span id='topic+ConstantSolver-class'></span><span id='topic+ConstantSolver'></span><span id='topic+mip_capable+2CConstantSolver-method'></span><span id='topic+accepts+2CConstantSolver+2CProblem-method'></span><span id='topic+perform+2CConstantSolver+2CProblem-method'></span><span id='topic+invert+2CConstantSolver+2CSolution+2Clist-method'></span><span id='topic+name+2CConstantSolver-method'></span><span id='topic+import_solver+2CConstantSolver-method'></span><span id='topic+is_installed+2CConstantSolver-method'></span><span id='topic+solve_via_data+2CConstantSolver-method'></span><span id='topic+reduction_solve+2CConstantSolver+2CANY-method'></span>

<h3>Description</h3>

<p>The ConstantSolver class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantSolver'
mip_capable(solver)

## S4 method for signature 'ConstantSolver,Problem'
accepts(object, problem)

## S4 method for signature 'ConstantSolver,Problem'
perform(object, problem)

## S4 method for signature 'ConstantSolver,Solution,list'
invert(object, solution, inverse_data)

## S4 method for signature 'ConstantSolver'
name(x)

## S4 method for signature 'ConstantSolver'
import_solver(solver)

## S4 method for signature 'ConstantSolver'
is_installed(solver)

## S4 method for signature 'ConstantSolver'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)

## S4 method for signature 'ConstantSolver,ANY'
reduction_solve(object, problem, warm_start, verbose, solver_opts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantSolver-class_+3A_solver">solver</code>, <code id="ConstantSolver-class_+3A_object">object</code>, <code id="ConstantSolver-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+ConstantSolver-class">ConstantSolver</a> object.</p>
</td></tr>
<tr><td><code id="ConstantSolver-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="ConstantSolver-class_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> object to invert.</p>
</td></tr>
<tr><td><code id="ConstantSolver-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A list containing data necessary for the inversion.</p>
</td></tr>
<tr><td><code id="ConstantSolver-class_+3A_data">data</code></td>
<td>
<p>Data for the solver.</p>
</td></tr>
<tr><td><code id="ConstantSolver-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="ConstantSolver-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="ConstantSolver-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance.</p>
</td></tr>
<tr><td><code id="ConstantSolver-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance.</p>
</td></tr>
<tr><td><code id="ConstantSolver-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance.</p>
</td></tr>
<tr><td><code id="ConstantSolver-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="ConstantSolver-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="ConstantSolver-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(ConstantSolver)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>accepts(object = ConstantSolver, problem = Problem)</code>: Is the solver capable of solving the problem?
</p>
</li>
<li> <p><code>perform(object = ConstantSolver, problem = Problem)</code>: Returns a list of the ConstantSolver, Problem, and an empty list.
</p>
</li>
<li> <p><code>invert(object = ConstantSolver, solution = Solution, inverse_data = list)</code>: Returns the solution.
</p>
</li>
<li> <p><code>name(ConstantSolver)</code>: Returns the name of the solver.
</p>
</li>
<li> <p><code>import_solver(ConstantSolver)</code>: Imports the solver.
</p>
</li>
<li> <p><code>is_installed(ConstantSolver)</code>: Is the solver installed?
</p>
</li>
<li> <p><code>solve_via_data(ConstantSolver)</code>: Solve a problem represented by data returned from apply.
</p>
</li>
<li> <p><code>reduction_solve(object = ConstantSolver, problem = ANY)</code>: Solve the problem and return a <a href="#topic+Solution-class">Solution</a> object.
</p>
</li></ul>

<hr>
<h2 id='constr_value'>Is Constraint Violated?</h2><span id='topic+constr_value'></span>

<h3>Description</h3>

<p>Checks whether the constraint violation is less than a tolerance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constr_value(object, tolerance = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constr_value_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Constraint-class">Constraint</a> object.</p>
</td></tr>
<tr><td><code id="constr_value_+3A_tolerance">tolerance</code></td>
<td>
<p>A numeric scalar representing the absolute tolerance to impose on the violation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the violation is less than the <code>tolerance</code>. Raises an error if the residual is <code>NA</code>.
</p>

<hr>
<h2 id='Constraint-class'>The Constraint class.</h2><span id='topic+Constraint-class'></span><span id='topic+Constraint'></span><span id='topic+as.character+2CConstraint-method'></span><span id='topic+dim+2CConstraint-method'></span><span id='topic+size+2CConstraint-method'></span><span id='topic+is_real+2CConstraint-method'></span><span id='topic+is_imag+2CConstraint-method'></span><span id='topic+is_complex+2CConstraint-method'></span><span id='topic+is_dcp+2CConstraint-method'></span><span id='topic+is_dgp+2CConstraint-method'></span><span id='topic+residual+2CConstraint-method'></span><span id='topic+violation+2CConstraint-method'></span><span id='topic+constr_value+2CConstraint-method'></span><span id='topic+get_data+2CConstraint-method'></span><span id='topic+dual_value+2CConstraint-method'></span><span id='topic+dual_value+3C-+2CConstraint-method'></span><span id='topic+size+2CZeroConstraint-method'></span>

<h3>Description</h3>

<p>This virtual class represents a mathematical constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Constraint'
as.character(x)

## S4 method for signature 'Constraint'
dim(x)

## S4 method for signature 'Constraint'
size(object)

## S4 method for signature 'Constraint'
is_real(object)

## S4 method for signature 'Constraint'
is_imag(object)

## S4 method for signature 'Constraint'
is_complex(object)

## S4 method for signature 'Constraint'
is_dcp(object)

## S4 method for signature 'Constraint'
is_dgp(object)

## S4 method for signature 'Constraint'
residual(object)

## S4 method for signature 'Constraint'
violation(object)

## S4 method for signature 'Constraint'
constr_value(object, tolerance = 1e-08)

## S4 method for signature 'Constraint'
get_data(object)

## S4 method for signature 'Constraint'
dual_value(object)

## S4 replacement method for signature 'Constraint'
dual_value(object) &lt;- value

## S4 method for signature 'ZeroConstraint'
size(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Constraint-class_+3A_x">x</code>, <code id="Constraint-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Constraint-class">Constraint</a> object.</p>
</td></tr>
<tr><td><code id="Constraint-class_+3A_tolerance">tolerance</code></td>
<td>
<p>The tolerance for checking if the constraint is violated.</p>
</td></tr>
<tr><td><code id="Constraint-class_+3A_value">value</code></td>
<td>
<p>A numeric scalar, vector, or matrix.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>dim(Constraint)</code>: The dimensions of the constrained expression.
</p>
</li>
<li> <p><code>size(Constraint)</code>: The size of the constrained expression.
</p>
</li>
<li> <p><code>is_real(Constraint)</code>: Is the constraint real?
</p>
</li>
<li> <p><code>is_imag(Constraint)</code>: Is the constraint imaginary?
</p>
</li>
<li> <p><code>is_complex(Constraint)</code>: Is the constraint complex?
</p>
</li>
<li> <p><code>is_dcp(Constraint)</code>: Is the constraint DCP?
</p>
</li>
<li> <p><code>is_dgp(Constraint)</code>: Is the constraint DGP?
</p>
</li>
<li> <p><code>residual(Constraint)</code>: The residual of a constraint
</p>
</li>
<li> <p><code>violation(Constraint)</code>: The violation of a constraint.
</p>
</li>
<li> <p><code>constr_value(Constraint)</code>: The value of a constraint.
</p>
</li>
<li> <p><code>get_data(Constraint)</code>: Information needed to reconstruct the object aside from the args.
</p>
</li>
<li> <p><code>dual_value(Constraint)</code>: The dual values of a constraint.
</p>
</li>
<li> <p><code>dual_value(Constraint) &lt;- value</code>: Replaces the dual values of a constraint..
</p>
</li>
<li> <p><code>size(ZeroConstraint)</code>: The size of the constrained expression.
</p>
</li></ul>

<hr>
<h2 id='construct_intermediate_chain+2CProblem+2Clist-method'>Builds a chain that rewrites a problem into an intermediate representation suitable for numeric reductions.</h2><span id='topic+construct_intermediate_chain+2CProblem+2Clist-method'></span>

<h3>Description</h3>

<p>Builds a chain that rewrites a problem into an intermediate representation suitable for numeric reductions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Problem,list'
construct_intermediate_chain(problem, candidates, gp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_intermediate_chain+2B2CProblem+2B2Clist-method_+3A_problem">problem</code></td>
<td>
<p>The problem for which to build a chain.</p>
</td></tr>
<tr><td><code id="construct_intermediate_chain+2B2CProblem+2B2Clist-method_+3A_candidates">candidates</code></td>
<td>
<p>A list of candidate solvers.</p>
</td></tr>
<tr><td><code id="construct_intermediate_chain+2B2CProblem+2B2Clist-method_+3A_gp">gp</code></td>
<td>
<p>A logical value indicating whether the problem is a geometric program.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Chain-class">Chain</a> object that can be used to convert the problem to an intermediate form.
</p>

<hr>
<h2 id='construct_solving_chain'>Build a reduction chain from a problem to an installed solver.</h2><span id='topic+construct_solving_chain'></span>

<h3>Description</h3>

<p>Build a reduction chain from a problem to an installed solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_solving_chain(problem, candidates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_solving_chain_+3A_problem">problem</code></td>
<td>
<p>The problem for which to build a chain.</p>
</td></tr>
<tr><td><code id="construct_solving_chain_+3A_candidates">candidates</code></td>
<td>
<p>A list of candidate solvers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+SolvingChain-class">SolvingChain</a> that can be used to solve the problem.
</p>

<hr>
<h2 id='conv'>Discrete Convolution</h2><span id='topic+conv'></span>

<h3>Description</h3>

<p>The 1-D discrete convolution of two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv(lh_exp, rh_exp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_+3A_lh_exp">lh_exp</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or vector representing the left-hand value.</p>
</td></tr>
<tr><td><code id="conv_+3A_rh_exp">rh_exp</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or vector representing the right-hand value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the convolution of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(129)
x &lt;- Variable(5)
h &lt;- matrix(stats::rnorm(2), nrow = 2, ncol = 1)
prob &lt;- Problem(Minimize(sum(conv(h, x))))
result &lt;- solve(prob)
result$value
result$getValue(x)
</code></pre>

<hr>
<h2 id='Conv-class'>The Conv class.</h2><span id='topic+Conv-class'></span><span id='topic+.Conv'></span><span id='topic+Conv'></span><span id='topic+to_numeric+2CConv-method'></span><span id='topic+validate_args+2CConv-method'></span><span id='topic+dim_from_args+2CConv-method'></span><span id='topic+sign_from_args+2CConv-method'></span><span id='topic+is_incr+2CConv-method'></span><span id='topic+is_decr+2CConv-method'></span><span id='topic+graph_implementation+2CConv-method'></span>

<h3>Description</h3>

<p>This class represents the 1-D discrete convolution of two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Conv(lh_exp, rh_exp)

## S4 method for signature 'Conv'
to_numeric(object, values)

## S4 method for signature 'Conv'
validate_args(object)

## S4 method for signature 'Conv'
dim_from_args(object)

## S4 method for signature 'Conv'
sign_from_args(object)

## S4 method for signature 'Conv'
is_incr(object, idx)

## S4 method for signature 'Conv'
is_decr(object, idx)

## S4 method for signature 'Conv'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Conv-class_+3A_lh_exp">lh_exp</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or R numeric data representing the left-hand vector.</p>
</td></tr>
<tr><td><code id="Conv-class_+3A_rh_exp">rh_exp</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or R numeric data representing the right-hand vector.</p>
</td></tr>
<tr><td><code id="Conv-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Conv-class">Conv</a> object.</p>
</td></tr>
<tr><td><code id="Conv-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="Conv-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="Conv-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="Conv-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="Conv-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Conv)</code>: The convolution of the two values.
</p>
</li>
<li> <p><code>validate_args(Conv)</code>: Check both arguments are vectors and the first is a constant.
</p>
</li>
<li> <p><code>dim_from_args(Conv)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>sign_from_args(Conv)</code>: The sign of the atom.
</p>
</li>
<li> <p><code>is_incr(Conv)</code>: Is the left-hand expression positive?
</p>
</li>
<li> <p><code>is_decr(Conv)</code>: Is the left-hand expression negative?
</p>
</li>
<li> <p><code>graph_implementation(Conv)</code>: The graph implementation of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>lh_exp</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or R numeric data representing the left-hand vector.</p>
</dd>
<dt><code>rh_exp</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or R numeric data representing the right-hand vector.</p>
</dd>
</dl>

<hr>
<h2 id='CPLEX_CONIC-class'>An interface for the CPLEX solver</h2><span id='topic+CPLEX_CONIC-class'></span><span id='topic+CPLEX_CONIC'></span><span id='topic+mip_capable+2CCPLEX_CONIC-method'></span><span id='topic+name+2CCPLEX_CONIC-method'></span><span id='topic+import_solver+2CCPLEX_CONIC-method'></span><span id='topic+accepts+2CCPLEX_CONIC+2CProblem-method'></span><span id='topic+status_map+2CCPLEX_CONIC-method'></span><span id='topic+perform+2CCPLEX_CONIC+2CProblem-method'></span><span id='topic+invert+2CCPLEX_CONIC+2Clist+2Clist-method'></span><span id='topic+solve_via_data+2CCPLEX_CONIC-method'></span>

<h3>Description</h3>

<p>An interface for the CPLEX solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPLEX_CONIC()

CPLEX_CONIC()

## S4 method for signature 'CPLEX_CONIC'
mip_capable(solver)

## S4 method for signature 'CPLEX_CONIC'
name(x)

## S4 method for signature 'CPLEX_CONIC'
import_solver(solver)

## S4 method for signature 'CPLEX_CONIC,Problem'
accepts(object, problem)

## S4 method for signature 'CPLEX_CONIC'
status_map(solver, status)

## S4 method for signature 'CPLEX_CONIC,Problem'
perform(object, problem)

## S4 method for signature 'CPLEX_CONIC,list,list'
invert(object, solution, inverse_data)

## S4 method for signature 'CPLEX_CONIC'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CPLEX_CONIC-class_+3A_solver">solver</code>, <code id="CPLEX_CONIC-class_+3A_object">object</code>, <code id="CPLEX_CONIC-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+CPLEX_CONIC-class">CPLEX_CONIC</a> object.</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_status">status</code></td>
<td>
<p>A status code returned by the solver.</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_solution">solution</code></td>
<td>
<p>The raw solution returned by the solver.</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A list containing data necessary for the inversion.</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance on the primal and dual residual.</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance on the duality gap.</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance on the duality gap.</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="CPLEX_CONIC-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(CPLEX_CONIC)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>name(CPLEX_CONIC)</code>: Returns the name of the solver.
</p>
</li>
<li> <p><code>import_solver(CPLEX_CONIC)</code>: Imports the solver.
</p>
</li>
<li> <p><code>accepts(object = CPLEX_CONIC, problem = Problem)</code>: Can CPLEX solve the problem?
</p>
</li>
<li> <p><code>status_map(CPLEX_CONIC)</code>: Converts status returned by the CPLEX solver to its respective CVXPY status.
</p>
</li>
<li> <p><code>perform(object = CPLEX_CONIC, problem = Problem)</code>: Returns a new problem and data for inverting the new solution.
</p>
</li>
<li> <p><code>invert(object = CPLEX_CONIC, solution = list, inverse_data = list)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li>
<li> <p><code>solve_via_data(CPLEX_CONIC)</code>: Solve a problem represented by data returned from apply.
</p>
</li></ul>

<hr>
<h2 id='CPLEX_QP-class'>An interface for the CPLEX solver.</h2><span id='topic+CPLEX_QP-class'></span><span id='topic+CPLEX_QP'></span><span id='topic+mip_capable+2CCPLEX_QP-method'></span><span id='topic+status_map+2CCPLEX_QP-method'></span><span id='topic+name+2CCPLEX_QP-method'></span><span id='topic+import_solver+2CCPLEX_QP-method'></span><span id='topic+invert+2CCPLEX_QP+2Clist+2CInverseData-method'></span><span id='topic+solve_via_data+2CCPLEX_QP-method'></span>

<h3>Description</h3>

<p>An interface for the CPLEX solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPLEX_QP()

## S4 method for signature 'CPLEX_QP'
mip_capable(solver)

## S4 method for signature 'CPLEX_QP'
status_map(solver, status)

## S4 method for signature 'CPLEX_QP'
name(x)

## S4 method for signature 'CPLEX_QP'
import_solver(solver)

## S4 method for signature 'CPLEX_QP,list,InverseData'
invert(object, solution, inverse_data)

## S4 method for signature 'CPLEX_QP'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CPLEX_QP-class_+3A_status">status</code></td>
<td>
<p>A status code returned by the solver.</p>
</td></tr>
<tr><td><code id="CPLEX_QP-class_+3A_x">x</code>, <code id="CPLEX_QP-class_+3A_object">object</code>, <code id="CPLEX_QP-class_+3A_solver">solver</code></td>
<td>
<p>A <a href="#topic+CPLEX_QP-class">CPLEX_QP</a> object.</p>
</td></tr>
<tr><td><code id="CPLEX_QP-class_+3A_solution">solution</code></td>
<td>
<p>The raw solution returned by the solver.</p>
</td></tr>
<tr><td><code id="CPLEX_QP-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A <a href="#topic+InverseData-class">InverseData</a> object containing data necessary for the inversion.</p>
</td></tr>
<tr><td><code id="CPLEX_QP-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="CPLEX_QP-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="CPLEX_QP-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="CPLEX_QP-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance on the primal and dual residual.</p>
</td></tr>
<tr><td><code id="CPLEX_QP-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance on the duality gap.</p>
</td></tr>
<tr><td><code id="CPLEX_QP-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance on the duality gap.</p>
</td></tr>
<tr><td><code id="CPLEX_QP-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="CPLEX_QP-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="CPLEX_QP-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(CPLEX_QP)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>status_map(CPLEX_QP)</code>: Converts status returned by the CPLEX solver to its respective CVXPY status.
</p>
</li>
<li> <p><code>name(CPLEX_QP)</code>: Returns the name of the solver.
</p>
</li>
<li> <p><code>import_solver(CPLEX_QP)</code>: Imports the solver.
</p>
</li>
<li> <p><code>invert(object = CPLEX_QP, solution = list, inverse_data = InverseData)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li>
<li> <p><code>solve_via_data(CPLEX_QP)</code>: Solve a problem represented by data returned from apply.
</p>
</li></ul>

<hr>
<h2 id='cummax_axis'>Cumulative Maximum</h2><span id='topic+cummax_axis'></span><span id='topic+cummax'></span><span id='topic+cummax+2CExpression-method'></span>

<h3>Description</h3>

<p>The cumulative maximum, <code class="reqn">\max_{i=1,\ldots,k} x_i</code> for <code class="reqn">k=1,\ldots,n</code>.
When calling <code>cummax</code>, matrices are automatically flattened into column-major order before the max is taken.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cummax_axis(expr, axis = 2)

## S4 method for signature 'Expression'
cummax(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cummax_axis_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, and <code>2</code> indicates columns. The default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="cummax_axis_+3A_x">x</code>, <code id="cummax_axis_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>val &lt;- cbind(c(1,2), c(3,4))
value(cummax(Constant(val)))
value(cummax_axis(Constant(val)))

x &lt;- Variable(2,2)
prob &lt;- Problem(Minimize(cummax(x)[4]), list(x == val))
result &lt;- solve(prob)
result$value
result$getValue(cummax(x))
</code></pre>

<hr>
<h2 id='CumMax-class'>The CumMax class.</h2><span id='topic+CumMax-class'></span><span id='topic+.CumMax'></span><span id='topic+CumMax'></span><span id='topic+to_numeric+2CCumMax-method'></span><span id='topic+.grad+2CCumMax-method'></span><span id='topic+.column_grad+2CCumMax-method'></span><span id='topic+dim_from_args+2CCumMax-method'></span><span id='topic+sign_from_args+2CCumMax-method'></span><span id='topic+get_data+2CCumMax-method'></span><span id='topic+is_atom_convex+2CCumMax-method'></span><span id='topic+is_atom_concave+2CCumMax-method'></span><span id='topic+is_incr+2CCumMax-method'></span><span id='topic+is_decr+2CCumMax-method'></span>

<h3>Description</h3>

<p>This class represents the cumulative maximum of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CumMax(expr, axis = 2)

## S4 method for signature 'CumMax'
to_numeric(object, values)

## S4 method for signature 'CumMax'
.grad(object, values)

## S4 method for signature 'CumMax'
.column_grad(object, value)

## S4 method for signature 'CumMax'
dim_from_args(object)

## S4 method for signature 'CumMax'
sign_from_args(object)

## S4 method for signature 'CumMax'
get_data(object)

## S4 method for signature 'CumMax'
is_atom_convex(object)

## S4 method for signature 'CumMax'
is_atom_concave(object)

## S4 method for signature 'CumMax'
is_incr(object, idx)

## S4 method for signature 'CumMax'
is_decr(object, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CumMax-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>.</p>
</td></tr>
<tr><td><code id="CumMax-class_+3A_axis">axis</code></td>
<td>
<p>A numeric vector indicating the axes along which to apply the function. For a 2D matrix, <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>c(1,2)</code> indicates rows and columns.</p>
</td></tr>
<tr><td><code id="CumMax-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+CumMax-class">CumMax</a> object.</p>
</td></tr>
<tr><td><code id="CumMax-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="CumMax-class_+3A_value">value</code></td>
<td>
<p>A numeric value.</p>
</td></tr>
<tr><td><code id="CumMax-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(CumMax)</code>: The cumulative maximum along the axis.
</p>
</li>
<li> <p><code>.grad(CumMax)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.column_grad(CumMax)</code>: Gives the (sub/super)gradient of the atom w.r.t. each column variable
</p>
</li>
<li> <p><code>dim_from_args(CumMax)</code>: The dimensions of the atom determined from its arguments.
</p>
</li>
<li> <p><code>sign_from_args(CumMax)</code>: The (is positive, is negative) sign of the atom.
</p>
</li>
<li> <p><code>get_data(CumMax)</code>: Returns the axis along which the cumulative max is taken.
</p>
</li>
<li> <p><code>is_atom_convex(CumMax)</code>: Is the atom convex?
</p>
</li>
<li> <p><code>is_atom_concave(CumMax)</code>: Is the atom concave?
</p>
</li>
<li> <p><code>is_incr(CumMax)</code>: Is the atom weakly increasing in the index?
</p>
</li>
<li> <p><code>is_decr(CumMax)</code>: Is the atom weakly decreasing in the index?
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a>.</p>
</dd>
<dt><code>axis</code></dt><dd><p>A numeric vector indicating the axes along which to apply the function. For a 2D matrix, <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>c(1,2)</code> indicates rows and columns.</p>
</dd>
</dl>

<hr>
<h2 id='cumsum_axis'>Cumulative Sum</h2><span id='topic+cumsum_axis'></span><span id='topic+cumsum'></span><span id='topic+cumsum+2CExpression-method'></span>

<h3>Description</h3>

<p>The cumulative sum, <code class="reqn">\sum_{i=1}^k x_i</code> for <code class="reqn">k=1,\ldots,n</code>.
When calling <code>cumsum</code>, matrices are automatically flattened into column-major order before the sum is taken.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumsum_axis(expr, axis = 2)

## S4 method for signature 'Expression'
cumsum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumsum_axis_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, and <code>2</code> indicates columns. The default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="cumsum_axis_+3A_x">x</code>, <code id="cumsum_axis_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>val &lt;- cbind(c(1,2), c(3,4))
value(cumsum(Constant(val)))
value(cumsum_axis(Constant(val)))

x &lt;- Variable(2,2)
prob &lt;- Problem(Minimize(cumsum(x)[4]), list(x == val))
result &lt;- solve(prob)
result$value
result$getValue(cumsum(x))
</code></pre>

<hr>
<h2 id='CumSum-class'>The CumSum class.</h2><span id='topic+CumSum-class'></span><span id='topic+.CumSum'></span><span id='topic+CumSum'></span><span id='topic+to_numeric+2CCumSum-method'></span><span id='topic+dim_from_args+2CCumSum-method'></span><span id='topic+get_data+2CCumSum-method'></span><span id='topic+.grad+2CCumSum-method'></span><span id='topic+graph_implementation+2CCumSum-method'></span>

<h3>Description</h3>

<p>This class represents the cumulative sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CumSum(expr, axis = 2)

## S4 method for signature 'CumSum'
to_numeric(object, values)

## S4 method for signature 'CumSum'
dim_from_args(object)

## S4 method for signature 'CumSum'
get_data(object)

## S4 method for signature 'CumSum'
.grad(object, values)

## S4 method for signature 'CumSum'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CumSum-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> to be summed.</p>
</td></tr>
<tr><td><code id="CumSum-class_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, and <code>2</code> indicates columns. The default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="CumSum-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+CumSum-class">CumSum</a> object.</p>
</td></tr>
<tr><td><code id="CumSum-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="CumSum-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="CumSum-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="CumSum-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(CumSum)</code>: The cumulative sum of the values along the specified axis.
</p>
</li>
<li> <p><code>dim_from_args(CumSum)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>get_data(CumSum)</code>: Returns the axis along which the cumulative sum is taken.
</p>
</li>
<li> <p><code>.grad(CumSum)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>graph_implementation(CumSum)</code>: The graph implementation of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> to be summed.</p>
</dd>
<dt><code>axis</code></dt><dd><p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, and <code>2</code> indicates columns. The default is <code>2</code>.</p>
</dd>
</dl>

<hr>
<h2 id='curvature'>Curvature of Expression</h2><span id='topic+curvature'></span><span id='topic+curvature+2CExpression-method'></span>

<h3>Description</h3>

<p>The curvature of an expression.
</p>
<p>The curvature of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curvature(object)

## S4 method for signature 'Expression'
curvature(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curvature_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string indicating the curvature of the expression, either &quot;CONSTANT&quot;, &quot;AFFINE&quot;, &quot;CONVEX, &quot;CONCAVE&quot;, or &quot;UNKNOWN&quot;.
</p>
<p>A string indicating the curvature of the expression, either &quot;CONSTANT&quot;, &quot;AFFINE&quot;, &quot;CONVEX&quot;, &quot;CONCAVE&quot;, or &quot;UNKNOWN&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable()
c &lt;- Constant(5)

curvature(c)
curvature(x)
curvature(x^2)
curvature(sqrt(x))
curvature(log(x^3) + sqrt(x))
</code></pre>

<hr>
<h2 id='curvature-atom'>Curvature of an Atom</h2><span id='topic+curvature-atom'></span><span id='topic+is_atom_convex'></span><span id='topic+is_atom_concave'></span><span id='topic+is_atom_affine'></span><span id='topic+is_atom_convex+2CAtom-method'></span><span id='topic+is_atom_concave+2CAtom-method'></span><span id='topic+is_atom_affine+2CAtom-method'></span><span id='topic+is_atom_log_log_convex+2CAtom-method'></span><span id='topic+is_atom_log_log_concave+2CAtom-method'></span><span id='topic+is_atom_log_log_affine+2CAtom-method'></span>

<h3>Description</h3>

<p>Determine if an atom is convex, concave, or affine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_atom_convex(object)

is_atom_concave(object)

is_atom_affine(object)

## S4 method for signature 'Atom'
is_atom_convex(object)

## S4 method for signature 'Atom'
is_atom_concave(object)

## S4 method for signature 'Atom'
is_atom_affine(object)

## S4 method for signature 'Atom'
is_atom_log_log_convex(object)

## S4 method for signature 'Atom'
is_atom_log_log_concave(object)

## S4 method for signature 'Atom'
is_atom_log_log_affine(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curvature-atom_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Atom-class">Atom</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable()

is_atom_convex(x^2)
is_atom_convex(sqrt(x))
is_atom_convex(log(x))

is_atom_concave(-abs(x))
is_atom_concave(x^2)
is_atom_concave(sqrt(x))

is_atom_affine(2*x)
is_atom_affine(x^2)
</code></pre>

<hr>
<h2 id='curvature-comp'>Curvature of Composition</h2><span id='topic+curvature-comp'></span><span id='topic+is_incr'></span><span id='topic+is_decr'></span><span id='topic+is_incr+2CAtom-method'></span><span id='topic+is_decr+2CAtom-method'></span>

<h3>Description</h3>

<p>Determine whether a composition is non-decreasing or non-increasing in an index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_incr(object, idx)

is_decr(object, idx)

## S4 method for signature 'Atom'
is_incr(object, idx)

## S4 method for signature 'Atom'
is_decr(object, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curvature-comp_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Atom-class">Atom</a> object.</p>
</td></tr>
<tr><td><code id="curvature-comp_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable()
is_incr(log(x), 1)
is_incr(x^2, 1)
is_decr(min(x), 1)
is_decr(abs(x), 1)
</code></pre>

<hr>
<h2 id='curvature-methods'>Curvature Properties</h2><span id='topic+curvature-methods'></span><span id='topic+is_constant'></span><span id='topic+is_affine'></span><span id='topic+is_convex'></span><span id='topic+is_concave'></span><span id='topic+is_quadratic'></span><span id='topic+is_pwl'></span><span id='topic+is_qpwa'></span>

<h3>Description</h3>

<p>Determine if an expression is constant, affine, convex, concave, quadratic, piecewise linear (pwl), or quadratic/piecewise affine (qpwa).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_constant(object)

is_affine(object)

is_convex(object)

is_concave(object)

is_quadratic(object)

is_pwl(object)

is_qpwa(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curvature-methods_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable()
c &lt;- Constant(5)

is_constant(c)
is_constant(x)

is_affine(c)
is_affine(x)
is_affine(x^2)

is_convex(c)
is_convex(x)
is_convex(x^2)
is_convex(sqrt(x))

is_concave(c)
is_concave(x)
is_concave(x^2)
is_concave(sqrt(x))

is_quadratic(x^2)
is_quadratic(sqrt(x))

is_pwl(c)
is_pwl(x)
is_pwl(x^2)
</code></pre>

<hr>
<h2 id='CvxAttr2Constr-class'>The CvxAttr2Constr class.</h2><span id='topic+CvxAttr2Constr-class'></span><span id='topic+CvxAttr2Constr'></span><span id='topic+perform+2CCvxAttr2Constr+2CProblem-method'></span><span id='topic+invert+2CCvxAttr2Constr+2CSolution+2Clist-method'></span>

<h3>Description</h3>

<p>This class represents a reduction that expands convex variable attributes into constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'CvxAttr2Constr,Problem'
perform(object, problem)

## S4 method for signature 'CvxAttr2Constr,Solution,list'
invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CvxAttr2Constr-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+CvxAttr2Constr-class">CvxAttr2Constr</a> object.</p>
</td></tr>
<tr><td><code id="CvxAttr2Constr-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="CvxAttr2Constr-class_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> to a problem that generated the inverse data.</p>
</td></tr>
<tr><td><code id="CvxAttr2Constr-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>The inverse data returned by an invocation to apply.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>perform(object = CvxAttr2Constr, problem = Problem)</code>: Expand convex variable attributes to constraints.
</p>
</li>
<li> <p><code>invert(object = CvxAttr2Constr, solution = Solution, inverse_data = list)</code>: Performs the reduction on a problem and returns an equivalent problem.
</p>
</li></ul>

<hr>
<h2 id='CVXOPT-class'>An interface for the CVXOPT solver.</h2><span id='topic+CVXOPT-class'></span><span id='topic+mip_capable+2CCVXOPT-method'></span><span id='topic+status_map+2CCVXOPT-method'></span><span id='topic+name+2CCVXOPT-method'></span><span id='topic+import_solver+2CCVXOPT-method'></span><span id='topic+accepts+2CCVXOPT+2CProblem-method'></span><span id='topic+perform+2CCVXOPT+2CProblem-method'></span><span id='topic+invert+2CCVXOPT+2Clist+2Clist-method'></span><span id='topic+solve_via_data+2CCVXOPT-method'></span>

<h3>Description</h3>

<p>An interface for the CVXOPT solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'CVXOPT'
mip_capable(solver)

## S4 method for signature 'CVXOPT'
status_map(solver, status)

## S4 method for signature 'CVXOPT'
name(x)

## S4 method for signature 'CVXOPT'
import_solver(solver)

## S4 method for signature 'CVXOPT,Problem'
accepts(object, problem)

## S4 method for signature 'CVXOPT,Problem'
perform(object, problem)

## S4 method for signature 'CVXOPT,list,list'
invert(object, solution, inverse_data)

## S4 method for signature 'CVXOPT'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CVXOPT-class_+3A_solver">solver</code>, <code id="CVXOPT-class_+3A_object">object</code>, <code id="CVXOPT-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+CVXOPT-class">CVXOPT</a> object.</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_status">status</code></td>
<td>
<p>A status code returned by the solver.</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_solution">solution</code></td>
<td>
<p>The raw solution returned by the solver.</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A list containing data necessary for the inversion.</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance on the primal and dual residual.</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance on the duality gap.</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance on the duality gap.</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="CVXOPT-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(CVXOPT)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>status_map(CVXOPT)</code>: Converts status returned by the CVXOPT solver to its respective CVXPY status.
</p>
</li>
<li> <p><code>name(CVXOPT)</code>: Returns the name of the solver.
</p>
</li>
<li> <p><code>import_solver(CVXOPT)</code>: Imports the solver.
</p>
</li>
<li> <p><code>accepts(object = CVXOPT, problem = Problem)</code>: Can CVXOPT solve the problem?
</p>
</li>
<li> <p><code>perform(object = CVXOPT, problem = Problem)</code>: Returns a new problem and data for inverting the new solution.
</p>
</li>
<li> <p><code>invert(object = CVXOPT, solution = list, inverse_data = list)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li>
<li> <p><code>solve_via_data(CVXOPT)</code>: Solve a problem represented by data returned from apply.
</p>
</li></ul>

<hr>
<h2 id='cvxr_norm'>Matrix Norm (Alternative)</h2><span id='topic+cvxr_norm'></span>

<h3>Description</h3>

<p>A wrapper on the different norm atoms. This is different from the standard &quot;norm&quot; method in the R base package.
If <code>p = 2</code>, <code>axis = NA</code>, and <code>x</code> is a matrix, this returns the maximium singular value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvxr_norm(x, p = 2, axis = NA_real_, keepdims = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvxr_norm_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric constant representing a vector or matrix.</p>
</td></tr>
<tr><td><code id="cvxr_norm_+3A_p">p</code></td>
<td>
<p>The type of norm. May be a number (p-norm), &quot;inf&quot; (infinity-norm), &quot;nuc&quot; (nuclear norm), or &quot;fro&quot; (Frobenius norm). The default is <code>p = 2</code>.</p>
</td></tr>
<tr><td><code id="cvxr_norm_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="cvxr_norm_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the norm.
</p>


<h3>See Also</h3>

<p><a href="#topic+norm">norm</a>
</p>

<hr>
<h2 id='Dcp2Cone-class'>Reduce DCP Problem to Conic Form</h2><span id='topic+Dcp2Cone-class'></span><span id='topic+.Dcp2Cone'></span><span id='topic+accepts+2CDcp2Cone+2CProblem-method'></span><span id='topic+perform+2CDcp2Cone+2CProblem-method'></span>

<h3>Description</h3>

<p>This reduction takes as input (minimization) DCP problems and converts them into problems
with affine objectives and conic constraints whose arguments are affine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Dcp2Cone,Problem'
accepts(object, problem)

## S4 method for signature 'Dcp2Cone,Problem'
perform(object, problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Dcp2Cone-class">Dcp2Cone</a> object.</p>
</td></tr>
<tr><td><code id="Dcp2Cone-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>accepts(object = Dcp2Cone, problem = Problem)</code>: A problem is accepted if it is a minimization and is DCP.
</p>
</li>
<li> <p><code>perform(object = Dcp2Cone, problem = Problem)</code>: Converts a DCP problem to a conic form.
</p>
</li></ul>

<hr>
<h2 id='Dcp2Cone.entr_canon'>Dcp2Cone canonicalizer for the entropy atom</h2><span id='topic+Dcp2Cone.entr_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the entropy atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.entr_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.entr_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.entr_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from an entropy atom where 
the objective function is just the variable t with an ExpCone constraint.
</p>

<hr>
<h2 id='Dcp2Cone.exp_canon'>Dcp2Cone canonicalizer for the exponential atom</h2><span id='topic+Dcp2Cone.exp_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the exponential atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.exp_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.exp_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.exp_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from an exponential atom 
where the objective function is the variable t with an ExpCone constraint.
</p>

<hr>
<h2 id='Dcp2Cone.geo_mean_canon'>Dcp2Cone canonicalizer for the geometric mean atom</h2><span id='topic+Dcp2Cone.geo_mean_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the geometric mean atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.geo_mean_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.geo_mean_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.geo_mean_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a geometric mean atom 
where the objective function is the variable t with geometric mean constraints
</p>

<hr>
<h2 id='Dcp2Cone.huber_canon'>Dcp2Cone canonicalizer for the huber atom</h2><span id='topic+Dcp2Cone.huber_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the huber atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.huber_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.huber_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.huber_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a huber atom where the objective 
function is the variable t with square and absolute constraints
</p>

<hr>
<h2 id='Dcp2Cone.indicator_canon'>Dcp2Cone canonicalizer for the indicator atom</h2><span id='topic+Dcp2Cone.indicator_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the indicator atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.indicator_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.indicator_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.indicator_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from an indicator atom and
where 0 is the objective function with the given constraints
in the function.
</p>

<hr>
<h2 id='Dcp2Cone.kl_div_canon'>Dcp2Cone canonicalizer for the KL Divergence atom</h2><span id='topic+Dcp2Cone.kl_div_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the KL Divergence atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.kl_div_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.kl_div_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.kl_div_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a KL divergence atom
where t is the objective function with the ExpCone constraints.
</p>

<hr>
<h2 id='Dcp2Cone.lambda_max_canon'>Dcp2Cone canonicalizer for the lambda maximization atom</h2><span id='topic+Dcp2Cone.lambda_max_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the lambda maximization atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.lambda_max_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.lambda_max_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.lambda_max_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a lambda maximization atom
where t is the objective function and a PSD constraint and a
constraint requiring I*t to be symmetric.
</p>

<hr>
<h2 id='Dcp2Cone.lambda_sum_largest_canon'>Dcp2Cone canonicalizer for the largest lambda sum atom</h2><span id='topic+Dcp2Cone.lambda_sum_largest_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the largest lambda sum atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.lambda_sum_largest_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.lambda_sum_largest_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.lambda_sum_largest_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a lambda sum of the k
largest elements atom where k*t + trace(Z) is the objective function.
t denotes the variable subject to constraints and Z is a PSD matrix variable
whose dimensions consist of the length of the vector at hand. The constraints
require the the diagonal matrix of the vector to be symmetric and PSD.
</p>

<hr>
<h2 id='Dcp2Cone.log_canon'>Dcp2Cone canonicalizer for the log atom</h2><span id='topic+Dcp2Cone.log_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the log atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.log_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.log_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.log_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a log atom where
t is the objective function and the constraints consist of
ExpCone constraints
</p>

<hr>
<h2 id='Dcp2Cone.log_det_canon'>Dcp2Cone canonicalizer for the log determinant atom</h2><span id='topic+Dcp2Cone.log_det_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the log determinant atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.log_det_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.log_det_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.log_det_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a log determinant atom where
the objective function is the sum of the log of the vector D
and the constraints consist of requiring the matrix Z to be
diagonal and the diagonal Z to equal D, Z to be upper triangular
and DZ; t(Z)A to be positive semidefinite, where A is a n by n
matrix.
</p>

<hr>
<h2 id='Dcp2Cone.log_sum_exp_canon'>Dcp2Cone canonicalizer for the log sum of the exp atom</h2><span id='topic+Dcp2Cone.log_sum_exp_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the log sum of the exp atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.log_sum_exp_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.log_sum_exp_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.log_sum_exp_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from the log sum
of the exp atom where the objective is the t variable
and the constraints consist of the ExpCone constraints and
requiring t to be less than a matrix of ones of the same size.
</p>

<hr>
<h2 id='Dcp2Cone.log1p_canon'>Dcp2Cone canonicalizer for the log 1p atom</h2><span id='topic+Dcp2Cone.log1p_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the log 1p atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.log1p_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.log1p_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.log1p_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a log 1p atom where
t is the objective function and the constraints consist of
ExpCone constraints + 1.
</p>

<hr>
<h2 id='Dcp2Cone.logistic_canon'>Dcp2Cone canonicalizer for the logistic function atom</h2><span id='topic+Dcp2Cone.logistic_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the logistic function atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.logistic_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.logistic_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.logistic_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from the logistic atom
where the objective function is given by t0 and the 
constraints consist of the ExpCone constraints.
</p>

<hr>
<h2 id='Dcp2Cone.matrix_frac_canon'>Dcp2Cone canonicalizer for the matrix fraction atom</h2><span id='topic+Dcp2Cone.matrix_frac_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the matrix fraction atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.matrix_frac_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.matrix_frac_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.matrix_frac_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from the matrix fraction
atom, where the objective function is the trace of Tvar, a 
m by m matrix where the constraints consist of the matrix of
the Schur complement of Tvar to consist of P, an n by n, given
matrix, X, an n by m given matrix, and Tvar.
</p>

<hr>
<h2 id='Dcp2Cone.normNuc_canon'>Dcp2Cone canonicalizer for the nuclear norm atom</h2><span id='topic+Dcp2Cone.normNuc_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the nuclear norm atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.normNuc_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.normNuc_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.normNuc_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a nuclear norm atom,
where the objective function consists of .5 times the trace of
a matrix X of size m+n by m+n where the constraint consist of
the top right corner of the matrix being the original matrix.
</p>

<hr>
<h2 id='Dcp2Cone.pnorm_canon'>Dcp2Cone canonicalizer for the p norm atom</h2><span id='topic+Dcp2Cone.pnorm_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the p norm atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.pnorm_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.pnorm_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.pnorm_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a pnorm atom, where
the objective is a variable t of dimension of the original
vector in the problem and the constraints consist of geometric
mean constraints.
</p>

<hr>
<h2 id='Dcp2Cone.power_canon'>Dcp2Cone canonicalizer for the power atom</h2><span id='topic+Dcp2Cone.power_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the power atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.power_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.power_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.power_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a power atom, where
the objective function consists of the variable t which is
of the dimension of the original vector from the power atom
and the constraints consists of geometric mean constraints.
</p>

<hr>
<h2 id='Dcp2Cone.quad_form_canon'>Dcp2Cone canonicalizer for the quadratic form atom</h2><span id='topic+Dcp2Cone.quad_form_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the quadratic form atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.quad_form_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.quad_form_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.quad_form_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a quadratic form atom,
where the objective function consists of the scaled objective function
from the quadratic over linear canonicalization and same with the
constraints.
</p>

<hr>
<h2 id='Dcp2Cone.quad_over_lin_canon'>Dcp2Cone canonicalizer for the quadratic over linear term atom</h2><span id='topic+Dcp2Cone.quad_over_lin_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the quadratic over linear term atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.quad_over_lin_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.quad_over_lin_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.quad_over_lin_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a quadratic over linear
term atom where the objective function consists of a one
dimensional variable t with SOC constraints.
</p>

<hr>
<h2 id='Dcp2Cone.sigma_max_canon'>Dcp2Cone canonicalizer for the sigma max atom</h2><span id='topic+Dcp2Cone.sigma_max_canon'></span>

<h3>Description</h3>

<p>Dcp2Cone canonicalizer for the sigma max atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dcp2Cone.sigma_max_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dcp2Cone.sigma_max_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dcp2Cone.sigma_max_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cone program constructed from a sigma max atom
where the objective function consists of the variable t
that is of the same dimension as the original expression
with specified constraints in the function.
</p>

<hr>
<h2 id='Dgp2Dcp-class'>Reduce DGP problems to DCP problems.</h2><span id='topic+Dgp2Dcp-class'></span><span id='topic+Dgp2Dcp'></span><span id='topic+accepts+2CDgp2Dcp+2CProblem-method'></span><span id='topic+perform+2CDgp2Dcp+2CProblem-method'></span><span id='topic+canonicalize_expr+2CDgp2Dcp-method'></span><span id='topic+invert+2CDgp2Dcp+2CSolution+2CInverseData-method'></span>

<h3>Description</h3>

<p>This reduction takes as input a DGP problem and returns an equivalent DCP
problem. Because every (generalized) geometric program is a DGP problem,
this reduction can be used to convert geometric programs into convex form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Dgp2Dcp,Problem'
accepts(object, problem)

## S4 method for signature 'Dgp2Dcp,Problem'
perform(object, problem)

## S4 method for signature 'Dgp2Dcp'
canonicalize_expr(object, expr, args)

## S4 method for signature 'Dgp2Dcp,Solution,InverseData'
invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Dgp2Dcp-class">Dgp2Dcp</a> object.</p>
</td></tr>
<tr><td><code id="Dgp2Dcp-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="Dgp2Dcp-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object corresponding to the DGP problem.</p>
</td></tr>
<tr><td><code id="Dgp2Dcp-class_+3A_args">args</code></td>
<td>
<p>A list of values corresponding to the DGP expression</p>
</td></tr>
<tr><td><code id="Dgp2Dcp-class_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> object to invert.</p>
</td></tr>
<tr><td><code id="Dgp2Dcp-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A <a href="#topic+InverseData-class">InverseData</a> object containing data necessary for the inversion.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>accepts(object = Dgp2Dcp, problem = Problem)</code>: Is the problem DGP?
</p>
</li>
<li> <p><code>perform(object = Dgp2Dcp, problem = Problem)</code>: Converts the DGP problem to a DCP problem.
</p>
</li>
<li> <p><code>canonicalize_expr(Dgp2Dcp)</code>: Canonicalizes each atom within an Dgp2Dcp expression.
</p>
</li>
<li> <p><code>invert(object = Dgp2Dcp, solution = Solution, inverse_data = InverseData)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li></ul>

<hr>
<h2 id='Dgp2Dcp.add_canon'>Dgp2Dcp canonicalizer for the addition atom</h2><span id='topic+Dgp2Dcp.add_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the addition atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.add_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.add_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.add_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the addition atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.constant_canon'>Dgp2Dcp canonicalizer for the constant atom</h2><span id='topic+Dgp2Dcp.constant_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the constant atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.constant_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.constant_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.constant_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the constant atom of a DGP expression,
where the returned expression is the DCP equivalent resulting
from the log of the expression.
</p>

<hr>
<h2 id='Dgp2Dcp.div_canon'>Dgp2Dcp canonicalizer for the division atom</h2><span id='topic+Dgp2Dcp.div_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the division atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.div_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.div_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.div_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the division atom of a DGP expression,
where the returned expression is the log transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.exp_canon'>Dgp2Dcp canonicalizer for the exp atom</h2><span id='topic+Dgp2Dcp.exp_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the exp atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.exp_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.exp_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.exp_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the exp atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.eye_minus_inv_canon'>Dgp2Dcp canonicalizer for the <code class="reqn">(I - X)^{-1}</code> atom</h2><span id='topic+Dgp2Dcp.eye_minus_inv_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the <code class="reqn">(I - X)^{-1}</code> atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.eye_minus_inv_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.eye_minus_inv_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.eye_minus_inv_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the <code class="reqn">(I - X)^{-1}</code> atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.geo_mean_canon'>Dgp2Dcp canonicalizer for the geometric mean atom</h2><span id='topic+Dgp2Dcp.geo_mean_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the geometric mean atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.geo_mean_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.geo_mean_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.geo_mean_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the geometric mean atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.log_canon'>Dgp2Dcp canonicalizer for the log atom</h2><span id='topic+Dgp2Dcp.log_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the log atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.log_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.log_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.log_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the log atom of a DGP expression,
where the returned expression is the log of the original expression..
</p>

<hr>
<h2 id='Dgp2Dcp.mul_canon'>Dgp2Dcp canonicalizer for the multiplication atom</h2><span id='topic+Dgp2Dcp.mul_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the multiplication atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.mul_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.mul_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.mul_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the multiplication atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.mulexpression_canon'>Dgp2Dcp canonicalizer for the multiplication expression atom</h2><span id='topic+Dgp2Dcp.mulexpression_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the multiplication expression atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.mulexpression_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.mulexpression_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.mulexpression_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the multiplication expression atom
of a DGP expression, where the returned expression is the transformed
DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.nonpos_constr_canon'>Dgp2Dcp canonicalizer for the non-positive constraint atom</h2><span id='topic+Dgp2Dcp.nonpos_constr_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the non-positive constraint atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.nonpos_constr_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.nonpos_constr_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.nonpos_constr_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the non-positive contraint atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.norm_inf_canon'>Dgp2Dcp canonicalizer for the infinite norm atom</h2><span id='topic+Dgp2Dcp.norm_inf_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the infinite norm atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.norm_inf_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.norm_inf_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.norm_inf_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the infinity norm atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.norm1_canon'>Dgp2Dcp canonicalizer for the 1 norm atom</h2><span id='topic+Dgp2Dcp.norm1_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the 1 norm atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.norm1_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.norm1_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.norm1_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the norm1 atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.one_minus_pos_canon'>Dgp2Dcp canonicalizer for the 1-x atom</h2><span id='topic+Dgp2Dcp.one_minus_pos_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the 1-x atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.one_minus_pos_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.one_minus_pos_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.one_minus_pos_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the 1-x with 0 &lt; x &lt; 1 atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.parameter_canon'>Dgp2Dcp canonicalizer for the parameter atom</h2><span id='topic+Dgp2Dcp.parameter_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the parameter atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.parameter_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.parameter_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.parameter_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the parameter atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.pf_eigenvalue_canon'>Dgp2Dcp canonicalizer for the spectral radius atom</h2><span id='topic+Dgp2Dcp.pf_eigenvalue_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the spectral radius atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.pf_eigenvalue_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.pf_eigenvalue_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.pf_eigenvalue_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the spectral radius atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.pnorm_canon'>Dgp2Dcp canonicalizer for the p norm atom</h2><span id='topic+Dgp2Dcp.pnorm_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the p norm atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.pnorm_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.pnorm_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.pnorm_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the pnorm atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.power_canon'>Dgp2Dcp canonicalizer for the power atom</h2><span id='topic+Dgp2Dcp.power_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the power atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.power_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.power_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.power_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the power atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.prod_canon'>Dgp2Dcp canonicalizer for the product atom</h2><span id='topic+Dgp2Dcp.prod_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the product atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.prod_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.prod_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.prod_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the product atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.quad_form_canon'>Dgp2Dcp canonicalizer for the quadratic form atom</h2><span id='topic+Dgp2Dcp.quad_form_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the quadratic form atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.quad_form_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.quad_form_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.quad_form_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the quadratic form atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.quad_over_lin_canon'>Dgp2Dcp canonicalizer for the quadratic over linear term atom</h2><span id='topic+Dgp2Dcp.quad_over_lin_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the quadratic over linear term atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.quad_over_lin_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.quad_over_lin_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.quad_over_lin_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the quadratic over linear atom of a
DGP expression, where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.sum_canon'>Dgp2Dcp canonicalizer for the sum atom</h2><span id='topic+Dgp2Dcp.sum_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the sum atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.sum_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.sum_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.sum_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the sum atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.trace_canon'>Dgp2Dcp canonicalizer for the trace atom</h2><span id='topic+Dgp2Dcp.trace_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the trace atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.trace_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.trace_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.trace_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the trace atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='Dgp2Dcp.zero_constr_canon'>Dgp2Dcp canonicalizer for the zero constraint atom</h2><span id='topic+Dgp2Dcp.zero_constr_canon'></span>

<h3>Description</h3>

<p>Dgp2Dcp canonicalizer for the zero constraint atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dgp2Dcp.zero_constr_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgp2Dcp.zero_constr_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="Dgp2Dcp.zero_constr_canon_+3A_args">args</code></td>
<td>
<p>A list of values for the expr variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the zero constraint atom of a DGP expression,
where the returned expression is the transformed DCP equivalent.
</p>

<hr>
<h2 id='DgpCanonMethods-class'>DGP canonical methods class.</h2><span id='topic+DgpCanonMethods-class'></span><span id='topic+.DgpCanonMethods'></span><span id='topic+names+2CDgpCanonMethods-method'></span><span id='topic++24+2CDgpCanonMethods-method'></span>

<h3>Description</h3>

<p>Canonicalization of DGPs is a stateful procedure, hence the need for a class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DgpCanonMethods'
names(x)

## S4 method for signature 'DgpCanonMethods'
x$name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DgpCanonMethods-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+DgpCanonMethods-class">DgpCanonMethods</a> object.</p>
</td></tr>
<tr><td><code id="DgpCanonMethods-class_+3A_name">name</code></td>
<td>
<p>The name of the atom or expression to canonicalize.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>names(DgpCanonMethods)</code>: Returns the name of all the canonicalization methods
</p>
</li>
<li> <p><code>$</code>: Returns either a canonicalized variable or
a corresponding Dgp2Dcp canonicalization method
</p>
</li></ul>

<hr>
<h2 id='Diag'>Turns an expression into a DiagVec object</h2><span id='topic+Diag'></span>

<h3>Description</h3>

<p>Turns an expression into a DiagVec object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Diag(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Diag_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> that represents a vector or square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the diagonal vector/matrix.
</p>

<hr>
<h2 id='diag+2CExpression-method'>Matrix Diagonal</h2><span id='topic+diag+2CExpression-method'></span><span id='topic+diag'></span>

<h3>Description</h3>

<p>Extracts the diagonal from a matrix or makes a vector into a diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression'
diag(x = 1, nrow, ncol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag+2B2CExpression-method_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or square matrix.</p>
</td></tr>
<tr><td><code id="diag+2B2CExpression-method_+3A_nrow">nrow</code>, <code id="diag+2B2CExpression-method_+3A_ncol">ncol</code></td>
<td>
<p>(Optional) Dimensions for the result when <code>x</code> is not a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the diagonal vector or matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- Variable(3,3)
obj &lt;- Maximize(C[1,3])
constraints &lt;- list(diag(C) == 1, C[1,2] == 0.6, C[2,3] == -0.3, C == Variable(3,3, PSD = TRUE))
prob &lt;- Problem(obj, constraints)
result &lt;- solve(prob)
result$value
result$getValue(C)
</code></pre>

<hr>
<h2 id='DiagMat-class'>The DiagMat class.</h2><span id='topic+DiagMat-class'></span><span id='topic+.DiagMat'></span><span id='topic+DiagMat'></span><span id='topic+to_numeric+2CDiagMat-method'></span><span id='topic+dim_from_args+2CDiagMat-method'></span><span id='topic+is_atom_log_log_convex+2CDiagMat-method'></span><span id='topic+is_atom_log_log_concave+2CDiagMat-method'></span><span id='topic+graph_implementation+2CDiagMat-method'></span>

<h3>Description</h3>

<p>This class represents the extraction of the diagonal from a square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiagMat(expr)

## S4 method for signature 'DiagMat'
to_numeric(object, values)

## S4 method for signature 'DiagMat'
dim_from_args(object)

## S4 method for signature 'DiagMat'
is_atom_log_log_convex(object)

## S4 method for signature 'DiagMat'
is_atom_log_log_concave(object)

## S4 method for signature 'DiagMat'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiagMat-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing the matrix whose diagonal we are interested in.</p>
</td></tr>
<tr><td><code id="DiagMat-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+DiagMat-class">DiagMat</a> object.</p>
</td></tr>
<tr><td><code id="DiagMat-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="DiagMat-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="DiagMat-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="DiagMat-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(DiagMat)</code>: Extract the diagonal from a square matrix constant.
</p>
</li>
<li> <p><code>dim_from_args(DiagMat)</code>: The size of the atom.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(DiagMat)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(DiagMat)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>graph_implementation(DiagMat)</code>: The graph implementation of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing the matrix whose diagonal we are interested in.</p>
</dd>
</dl>

<hr>
<h2 id='DiagVec-class'>The DiagVec class.</h2><span id='topic+DiagVec-class'></span><span id='topic+.DiagVec'></span><span id='topic+DiagVec'></span><span id='topic+to_numeric+2CDiagVec-method'></span><span id='topic+dim_from_args+2CDiagVec-method'></span><span id='topic+is_atom_log_log_convex+2CDiagVec-method'></span><span id='topic+is_atom_log_log_concave+2CDiagVec-method'></span><span id='topic+is_symmetric+2CDiagVec-method'></span><span id='topic+is_hermitian+2CDiagVec-method'></span><span id='topic+graph_implementation+2CDiagVec-method'></span>

<h3>Description</h3>

<p>This class represents the conversion of a vector into a diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiagVec(expr)

## S4 method for signature 'DiagVec'
to_numeric(object, values)

## S4 method for signature 'DiagVec'
dim_from_args(object)

## S4 method for signature 'DiagVec'
is_atom_log_log_convex(object)

## S4 method for signature 'DiagVec'
is_atom_log_log_concave(object)

## S4 method for signature 'DiagVec'
is_symmetric(object)

## S4 method for signature 'DiagVec'
is_hermitian(object)

## S4 method for signature 'DiagVec'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiagVec-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing the vector to convert.</p>
</td></tr>
<tr><td><code id="DiagVec-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+DiagVec-class">DiagVec</a> object.</p>
</td></tr>
<tr><td><code id="DiagVec-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="DiagVec-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="DiagVec-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="DiagVec-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(DiagVec)</code>: Convert the vector constant into a diagonal matrix.
</p>
</li>
<li> <p><code>dim_from_args(DiagVec)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(DiagVec)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(DiagVec)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_symmetric(DiagVec)</code>: Is the expression symmetric?
</p>
</li>
<li> <p><code>is_hermitian(DiagVec)</code>: Is the expression hermitian?
</p>
</li>
<li> <p><code>graph_implementation(DiagVec)</code>: The graph implementation of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing the vector to convert.</p>
</dd>
</dl>

<hr>
<h2 id='Diff'>Takes the k-th order differences</h2><span id='topic+Diff'></span>

<h3>Description</h3>

<p>Takes the k-th order differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Diff(x, lag = 1, k = 1, axis = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Diff_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> that represents a vector</p>
</td></tr>
<tr><td><code id="Diff_+3A_lag">lag</code></td>
<td>
<p>The degree of lag between differences</p>
</td></tr>
<tr><td><code id="Diff_+3A_k">k</code></td>
<td>
<p>The integer value of the order of differences</p>
</td></tr>
<tr><td><code id="Diff_+3A_axis">axis</code></td>
<td>
<p>The axis along which to apply the function. For a 2D matrix, <code>1</code> indicates rows and <code>2</code> indicates columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Takes in a vector of length n and returns a vector of length n-k of the kth order differences
</p>

<hr>
<h2 id='diff+2CExpression-method'>Lagged and Iterated Differences</h2><span id='topic+diff+2CExpression-method'></span><span id='topic+diff'></span>

<h3>Description</h3>

<p>The lagged and iterated differences of a vector.
If <code>x</code> is length <code>n</code>, this function returns a length <code class="reqn">n-k</code> vector of the <code class="reqn">k</code>th order difference between the lagged terms.
<code>diff(x)</code> returns the vector of differences between adjacent elements in the vector, i.e. [x[2] - x[1], x[3] - x[2], ...].
<code>diff(x,1,2)</code> is the second-order differences vector, equivalently diff(diff(x)). <code>diff(x,1,0)</code> returns the vector x unchanged.
<code>diff(x,2)</code> returns the vector of differences [x[3] - x[1], x[4] - x[2], ...], equivalent to <code>x[(1+lag):n] - x[1:(n-lag)]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression'
diff(x, lag = 1, differences = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff+2B2CExpression-method_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>.</p>
</td></tr>
<tr><td><code id="diff+2B2CExpression-method_+3A_lag">lag</code></td>
<td>
<p>An integer indicating which lag to use.</p>
</td></tr>
<tr><td><code id="diff+2B2CExpression-method_+3A_differences">differences</code></td>
<td>
<p>An integer indicating the order of the difference.</p>
</td></tr>
<tr><td><code id="diff+2B2CExpression-method_+3A_...">...</code></td>
<td>
<p>(Optional) Addition <code>axis</code> argument, specifying the dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>axis = 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the <code>k</code>th order difference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Problem data
m &lt;- 101
L &lt;- 2
h &lt;- L/(m-1)

## Form objective and constraints
x &lt;- Variable(m)
y &lt;- Variable(m)
obj &lt;- sum(y)
constr &lt;- list(x[1] == 0, y[1] == 1, x[m] == 1, y[m] == 1, diff(x)^2 + diff(y)^2 &lt;= h^2)

## Solve the catenary problem
prob &lt;- Problem(Minimize(obj), constr)
result &lt;- solve(prob)

## Plot and compare with ideal catenary
xs &lt;- result$getValue(x)
ys &lt;- result$getValue(y)
plot(c(0, 1), c(0, 1), type = 'n', xlab = "x", ylab = "y")
lines(xs, ys, col = "blue", lwd = 2)
grid()
</code></pre>

<hr>
<h2 id='DiffPos'>The DiffPos atom.</h2><span id='topic+DiffPos'></span>

<h3>Description</h3>

<p>The difference between expressions, <code class="reqn">x - y</code>, where <code class="reqn">x &gt; y &gt; 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiffPos(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiffPos_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a></p>
</td></tr>
<tr><td><code id="DiffPos_+3A_y">y</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The difference <code class="reqn">x - y</code> with domain <code class="reqn">x,y: x &gt; y &gt; 0</code>.
</p>

<hr>
<h2 id='dim_from_args'>Atom Dimensions</h2><span id='topic+dim_from_args'></span><span id='topic+dim_from_args+2CAtom-method'></span>

<h3>Description</h3>

<p>Determine the dimensions of an atom based on its arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dim_from_args(object)

## S4 method for signature 'Atom'
dim_from_args(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim_from_args_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Atom-class">Atom</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector <code>c(row, col)</code> indicating the dimensions of the atom.
</p>

<hr>
<h2 id='domain'>Domain</h2><span id='topic+domain'></span>

<h3>Description</h3>

<p>A list of constraints describing the closure of the region where the expression is finite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- Variable(name = "a")
dom &lt;- domain(p_norm(a, -0.5))
prob &lt;- Problem(Minimize(a), dom)
result &lt;- solve(prob)
result$value

b &lt;- Variable()
dom &lt;- domain(kl_div(a, b))
result &lt;- solve(Problem(Minimize(a + b), dom))
result$getValue(a)
result$getValue(b)

A &lt;- Variable(2, 2, name = "A")
dom &lt;- domain(lambda_max(A))
A0 &lt;- rbind(c(1,2), c(3,4))
result &lt;- solve(Problem(Minimize(norm2(A - A0)), dom))
result$getValue(A)

dom &lt;- domain(log_det(A + diag(rep(1,2))))
prob &lt;- Problem(Minimize(sum(diag(A))), dom)
result &lt;- solve(prob, solver = "SCS")
result$value
</code></pre>

<hr>
<h2 id='dspop'>Direct Standardization: Population</h2><span id='topic+dspop'></span>

<h3>Description</h3>

<p>Randomly generated data for direct standardization example.
Sex was drawn from a Bernoulli distribution, and age was drawn from a uniform distribution on <code class="reqn">10,\ldots,60</code>.
The response was drawn from a normal distribution with a mean that depends on sex and age, and a variance of 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dspop
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 3 variables:
</p>

<dl>
<dt>y</dt><dd><p>Response variable</p>
</dd>
<dt>sex</dt><dd><p>Sex of individual, coded male (0) and female (1)</p>
</dd>
<dt>age</dt><dd><p>Age of individual</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+dssamp">dssamp</a>
</p>

<hr>
<h2 id='dssamp'>Direct Standardization: Sample</h2><span id='topic+dssamp'></span>

<h3>Description</h3>

<p>A sample of <code><a href="#topic+dspop">dspop</a></code> for direct standardization example.
The sample is skewed such that young males are overrepresented in comparison to the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dssamp
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 3 variables:
</p>

<dl>
<dt>y</dt><dd><p>Response variable</p>
</dd>
<dt>sex</dt><dd><p>Sex of individual, coded male (0) and female (1)</p>
</dd>
<dt>age</dt><dd><p>Age of individual</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+dspop">dspop</a>
</p>

<hr>
<h2 id='dual_value-methods'>Get and Set Dual Value</h2><span id='topic+dual_value-methods'></span><span id='topic+dual_value'></span><span id='topic+dual_value+3C-'></span>

<h3>Description</h3>

<p>Get and set the value of the dual variable in a constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dual_value(object)

dual_value(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dual_value-methods_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Constraint-class">Constraint</a> object.</p>
</td></tr>
<tr><td><code id="dual_value-methods_+3A_value">value</code></td>
<td>
<p>A numeric scalar, vector, or matrix to assign to the object.</p>
</td></tr>
</table>

<hr>
<h2 id='ECOS_BB-class'>An interface for the ECOS BB solver.</h2><span id='topic+ECOS_BB-class'></span><span id='topic+ECOS_BB'></span><span id='topic+mip_capable+2CECOS_BB-method'></span><span id='topic+name+2CECOS_BB-method'></span><span id='topic+perform+2CECOS_BB+2CProblem-method'></span><span id='topic+solve_via_data+2CECOS_BB-method'></span>

<h3>Description</h3>

<p>An interface for the ECOS BB solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ECOS_BB()

## S4 method for signature 'ECOS_BB'
mip_capable(solver)

## S4 method for signature 'ECOS_BB'
name(x)

## S4 method for signature 'ECOS_BB,Problem'
perform(object, problem)

## S4 method for signature 'ECOS_BB'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ECOS_BB-class_+3A_solver">solver</code>, <code id="ECOS_BB-class_+3A_object">object</code>, <code id="ECOS_BB-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+ECOS_BB-class">ECOS_BB</a> object.</p>
</td></tr>
<tr><td><code id="ECOS_BB-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="ECOS_BB-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="ECOS_BB-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="ECOS_BB-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="ECOS_BB-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance.</p>
</td></tr>
<tr><td><code id="ECOS_BB-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance.</p>
</td></tr>
<tr><td><code id="ECOS_BB-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance.</p>
</td></tr>
<tr><td><code id="ECOS_BB-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="ECOS_BB-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="ECOS_BB-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(ECOS_BB)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>name(ECOS_BB)</code>: Returns the name of the solver.
</p>
</li>
<li> <p><code>perform(object = ECOS_BB, problem = Problem)</code>: Returns a new problem and data for inverting the new solution.
</p>
</li>
<li> <p><code>solve_via_data(ECOS_BB)</code>: Solve a problem represented by data returned from apply.
</p>
</li></ul>

<hr>
<h2 id='ECOS-class'>An interface for the ECOS solver</h2><span id='topic+ECOS-class'></span><span id='topic+ECOS'></span><span id='topic+mip_capable+2CECOS-method'></span><span id='topic+status_map+2CECOS-method'></span><span id='topic+import_solver+2CECOS-method'></span><span id='topic+name+2CECOS-method'></span><span id='topic+perform+2CECOS+2CProblem-method'></span><span id='topic+invert+2CECOS+2Clist+2Clist-method'></span>

<h3>Description</h3>

<p>An interface for the ECOS solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ECOS()

## S4 method for signature 'ECOS'
mip_capable(solver)

## S4 method for signature 'ECOS'
status_map(solver, status)

## S4 method for signature 'ECOS'
import_solver(solver)

## S4 method for signature 'ECOS'
name(x)

## S4 method for signature 'ECOS,Problem'
perform(object, problem)

## S4 method for signature 'ECOS,list,list'
invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ECOS-class_+3A_solver">solver</code>, <code id="ECOS-class_+3A_object">object</code>, <code id="ECOS-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+ECOS-class">ECOS</a> object.</p>
</td></tr>
<tr><td><code id="ECOS-class_+3A_status">status</code></td>
<td>
<p>A status code returned by the solver.</p>
</td></tr>
<tr><td><code id="ECOS-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="ECOS-class_+3A_solution">solution</code></td>
<td>
<p>The raw solution returned by the solver.</p>
</td></tr>
<tr><td><code id="ECOS-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A list containing data necessary for the inversion.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(ECOS)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>status_map(ECOS)</code>: Converts status returned by the ECOS solver to its respective CVXPY status.
</p>
</li>
<li> <p><code>import_solver(ECOS)</code>: Imports the solver
</p>
</li>
<li> <p><code>name(ECOS)</code>: Returns the name of the solver
</p>
</li>
<li> <p><code>perform(object = ECOS, problem = Problem)</code>: Returns a new problem and data for inverting the new solution.
</p>
</li>
<li> <p><code>invert(object = ECOS, solution = list, inverse_data = list)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li></ul>

<hr>
<h2 id='ECOS.dims_to_solver_dict'>Utility method for formatting a ConeDims instance into a dictionary
that can be supplied to ECOS.</h2><span id='topic+ECOS.dims_to_solver_dict'></span>

<h3>Description</h3>

<p>Utility method for formatting a ConeDims instance into a dictionary
that can be supplied to ECOS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ECOS.dims_to_solver_dict(cone_dims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ECOS.dims_to_solver_dict_+3A_cone_dims">cone_dims</code></td>
<td>
<p>A <a href="#topic+ConeDims-class">ConeDims</a> instance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dictionary of cone dimensions
</p>

<hr>
<h2 id='Elementwise-class'>The Elementwise class.</h2><span id='topic+Elementwise-class'></span><span id='topic+Elementwise'></span><span id='topic+dim_from_args+2CElementwise-method'></span><span id='topic+validate_args+2CElementwise-method'></span><span id='topic+is_symmetric+2CElementwise-method'></span>

<h3>Description</h3>

<p>This virtual class represents an elementwise atom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Elementwise'
dim_from_args(object)

## S4 method for signature 'Elementwise'
validate_args(object)

## S4 method for signature 'Elementwise'
is_symmetric(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Elementwise-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Elementwise-class">Elementwise</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>dim_from_args(Elementwise)</code>: Dimensions is the same as the sum of the arguments' dimensions.
</p>
</li>
<li> <p><code>validate_args(Elementwise)</code>: Verify that all the dimensions are the same or can be promoted.
</p>
</li>
<li> <p><code>is_symmetric(Elementwise)</code>: Is the expression symmetric?
</p>
</li></ul>

<hr>
<h2 id='EliminatePwl-class'>The EliminatePwl class.</h2><span id='topic+EliminatePwl-class'></span><span id='topic+.EliminatePwl'></span><span id='topic+accepts+2CEliminatePwl+2CProblem-method'></span>

<h3>Description</h3>

<p>This class eliminates piecewise linear atoms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EliminatePwl,Problem'
accepts(object, problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EliminatePwl-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+EliminatePwl-class">EliminatePwl</a> object.</p>
</td></tr>
<tr><td><code id="EliminatePwl-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>accepts(object = EliminatePwl, problem = Problem)</code>: Does this problem contain piecewise linear atoms?
</p>
</li></ul>

<hr>
<h2 id='EliminatePwl.abs_canon'>EliminatePwl canonicalizer for the absolute atom</h2><span id='topic+EliminatePwl.abs_canon'></span>

<h3>Description</h3>

<p>EliminatePwl canonicalizer for the absolute atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EliminatePwl.abs_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EliminatePwl.abs_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="EliminatePwl.abs_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the picewise-lienar atom
constructed from an absolute atom where the objective function 
consists of the variable that is of the same dimension as the 
original expression and the constraints consist of splitting 
the absolute value into two inequalities.
</p>

<hr>
<h2 id='EliminatePwl.cummax_canon'>EliminatePwl canonicalizer for the cumulative max atom</h2><span id='topic+EliminatePwl.cummax_canon'></span>

<h3>Description</h3>

<p>EliminatePwl canonicalizer for the cumulative max atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EliminatePwl.cummax_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EliminatePwl.cummax_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="EliminatePwl.cummax_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the piecewise-lienar atom
constructed from a cumulative max atom where the objective
function consists of the variable Y which is of the same
dimension as the original expression and the constraints
consist of row/column constraints depending on the axis
</p>

<hr>
<h2 id='EliminatePwl.cumsum_canon'>EliminatePwl canonicalizer for the cumulative sum atom</h2><span id='topic+EliminatePwl.cumsum_canon'></span>

<h3>Description</h3>

<p>EliminatePwl canonicalizer for the cumulative sum atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EliminatePwl.cumsum_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EliminatePwl.cumsum_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="EliminatePwl.cumsum_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the piecewise-lienar atom
constructed from a cumulative sum atom where the objective
is Y that is of the same dimension as the matrix of the expression
and the constraints consist of various row constraints
</p>

<hr>
<h2 id='EliminatePwl.max_elemwise_canon'>EliminatePwl canonicalizer for the elementwise maximum atom</h2><span id='topic+EliminatePwl.max_elemwise_canon'></span>

<h3>Description</h3>

<p>EliminatePwl canonicalizer for the elementwise maximum atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EliminatePwl.max_elemwise_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EliminatePwl.max_elemwise_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="EliminatePwl.max_elemwise_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the piecewise-lienar atom
constructed by a elementwise maximum atom where the
objective function is the variable t of the same dimension
as the expression and the constraints consist of a simple
inequality.
</p>

<hr>
<h2 id='EliminatePwl.max_entries_canon'>EliminatePwl canonicalizer for the max entries atom</h2><span id='topic+EliminatePwl.max_entries_canon'></span>

<h3>Description</h3>

<p>EliminatePwl canonicalizer for the max entries atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EliminatePwl.max_entries_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EliminatePwl.max_entries_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="EliminatePwl.max_entries_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the piecewise-lienar atom
constructed from the max entries atom where the objective
function consists of the variable t of the same size as
the original expression and the constraints consist of
a vector multiplied by a vector of 1's.
</p>

<hr>
<h2 id='EliminatePwl.min_elemwise_canon'>EliminatePwl canonicalizer for the elementwise minimum atom</h2><span id='topic+EliminatePwl.min_elemwise_canon'></span>

<h3>Description</h3>

<p>EliminatePwl canonicalizer for the elementwise minimum atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EliminatePwl.min_elemwise_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EliminatePwl.min_elemwise_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="EliminatePwl.min_elemwise_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the piecewise-lienar atom
constructed by a minimum elementwise atom where the
objective function is the negative of variable t
t produced by max_elemwise_canon of the same dimension
as the expression and the constraints consist of a simple
inequality.
</p>

<hr>
<h2 id='EliminatePwl.min_entries_canon'>EliminatePwl canonicalizer for the minimum entries atom</h2><span id='topic+EliminatePwl.min_entries_canon'></span>

<h3>Description</h3>

<p>EliminatePwl canonicalizer for the minimum entries atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EliminatePwl.min_entries_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EliminatePwl.min_entries_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="EliminatePwl.min_entries_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the piecewise-lienar atom
constructed by a minimum entries atom where the
objective function is the negative of variable 
t produced by max_elemwise_canon of the same dimension
as the expression and the constraints consist of a simple
inequality.
</p>

<hr>
<h2 id='EliminatePwl.norm_inf_canon'>EliminatePwl canonicalizer for the infinite norm atom</h2><span id='topic+EliminatePwl.norm_inf_canon'></span>

<h3>Description</h3>

<p>EliminatePwl canonicalizer for the infinite norm atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EliminatePwl.norm_inf_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EliminatePwl.norm_inf_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="EliminatePwl.norm_inf_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the piecewise-lienar atom
constructed by the infinite norm atom where the objective
function consists variable t of the same dimension as the
expression and the constraints consist of a vector
constructed by multiplying t to a vector of 1's
</p>

<hr>
<h2 id='EliminatePwl.norm1_canon'>EliminatePwl canonicalizer for the 1 norm atom</h2><span id='topic+EliminatePwl.norm1_canon'></span>

<h3>Description</h3>

<p>EliminatePwl canonicalizer for the 1 norm atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EliminatePwl.norm1_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EliminatePwl.norm1_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="EliminatePwl.norm1_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the piecewise-lienar atom
constructed by the norm1 atom where the objective functino
consists of the sum of the variables created by the
abs_canon function and the constraints consist of
constraints generated by abs_canon.
</p>

<hr>
<h2 id='EliminatePwl.sum_largest_canon'>EliminatePwl canonicalizer for the largest sum atom</h2><span id='topic+EliminatePwl.sum_largest_canon'></span>

<h3>Description</h3>

<p>EliminatePwl canonicalizer for the largest sum atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EliminatePwl.sum_largest_canon(expr, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EliminatePwl.sum_largest_canon_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object</p>
</td></tr>
<tr><td><code id="EliminatePwl.sum_largest_canon_+3A_args">args</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonicalization of the piecewise-lienar atom
constructed by the k largest sums atom where the objective
function consists of the sum of variables t that is of
the same dimension as the expression plus k
</p>

<hr>
<h2 id='entr'>Entropy Function</h2><span id='topic+entr'></span><span id='topic+entropy'></span>

<h3>Description</h3>

<p>The elementwise entropy function, <code class="reqn">-xlog(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entr_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the entropy of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(5)
obj &lt;- Maximize(sum(entr(x)))
prob &lt;- Problem(obj, list(sum(x) == 1))
result &lt;- solve(prob)
result$getValue(x)
</code></pre>

<hr>
<h2 id='Entr-class'>The Entr class.</h2><span id='topic+Entr-class'></span><span id='topic+.Entr'></span><span id='topic+Entr'></span><span id='topic+to_numeric+2CEntr-method'></span><span id='topic+sign_from_args+2CEntr-method'></span><span id='topic+is_atom_convex+2CEntr-method'></span><span id='topic+is_atom_concave+2CEntr-method'></span><span id='topic+is_incr+2CEntr-method'></span><span id='topic+is_decr+2CEntr-method'></span><span id='topic+.grad+2CEntr-method'></span><span id='topic+.domain+2CEntr-method'></span>

<h3>Description</h3>

<p>This class represents the elementwise operation <code class="reqn">-xlog(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Entr(x)

## S4 method for signature 'Entr'
to_numeric(object, values)

## S4 method for signature 'Entr'
sign_from_args(object)

## S4 method for signature 'Entr'
is_atom_convex(object)

## S4 method for signature 'Entr'
is_atom_concave(object)

## S4 method for signature 'Entr'
is_incr(object, idx)

## S4 method for signature 'Entr'
is_decr(object, idx)

## S4 method for signature 'Entr'
.grad(object, values)

## S4 method for signature 'Entr'
.domain(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Entr-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</td></tr>
<tr><td><code id="Entr-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Entr-class">Entr</a> object.</p>
</td></tr>
<tr><td><code id="Entr-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="Entr-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Entr)</code>: The elementwise entropy function evaluated at the value.
</p>
</li>
<li> <p><code>sign_from_args(Entr)</code>: The sign of the atom is unknown.
</p>
</li>
<li> <p><code>is_atom_convex(Entr)</code>: The atom is not convex.
</p>
</li>
<li> <p><code>is_atom_concave(Entr)</code>: The atom is concave.
</p>
</li>
<li> <p><code>is_incr(Entr)</code>: The atom is weakly increasing.
</p>
</li>
<li> <p><code>is_decr(Entr)</code>: The atom is weakly decreasing.
</p>
</li>
<li> <p><code>.grad(Entr)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.domain(Entr)</code>: Returns constraints descrbing the domain of the node
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</dd>
</dl>

<hr>
<h2 id='EvalParams-class'>The EvalParams class.</h2><span id='topic+EvalParams-class'></span><span id='topic+EvalParams'></span><span id='topic+perform+2CEvalParams+2CProblem-method'></span><span id='topic+invert+2CEvalParams+2CSolution+2Clist-method'></span>

<h3>Description</h3>

<p>This class represents a reduction that replaces symbolic parameters with
their constaint values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EvalParams,Problem'
perform(object, problem)

## S4 method for signature 'EvalParams,Solution,list'
invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EvalParams-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+EvalParams-class">EvalParams</a> object.</p>
</td></tr>
<tr><td><code id="EvalParams-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="EvalParams-class_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> to a problem that generated the inverse data.</p>
</td></tr>
<tr><td><code id="EvalParams-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>The inverse data returned by an invocation to apply.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>perform(object = EvalParams, problem = Problem)</code>: Replace parameters with constant values.
</p>
</li>
<li> <p><code>invert(object = EvalParams, solution = Solution, inverse_data = list)</code>: Returns a solution to the original problem given the inverse_data.
</p>
</li></ul>

<hr>
<h2 id='Exp-class'>The Exp class.</h2><span id='topic+Exp-class'></span><span id='topic+.Exp'></span><span id='topic+Exp'></span><span id='topic+to_numeric+2CExp-method'></span><span id='topic+sign_from_args+2CExp-method'></span><span id='topic+is_atom_convex+2CExp-method'></span><span id='topic+is_atom_concave+2CExp-method'></span><span id='topic+is_atom_log_log_convex+2CExp-method'></span><span id='topic+is_atom_log_log_concave+2CExp-method'></span><span id='topic+is_incr+2CExp-method'></span><span id='topic+is_decr+2CExp-method'></span><span id='topic+.grad+2CExp-method'></span>

<h3>Description</h3>

<p>This class represents the elementwise natural exponential <code class="reqn">e^x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Exp(x)

## S4 method for signature 'Exp'
to_numeric(object, values)

## S4 method for signature 'Exp'
sign_from_args(object)

## S4 method for signature 'Exp'
is_atom_convex(object)

## S4 method for signature 'Exp'
is_atom_concave(object)

## S4 method for signature 'Exp'
is_atom_log_log_convex(object)

## S4 method for signature 'Exp'
is_atom_log_log_concave(object)

## S4 method for signature 'Exp'
is_incr(object, idx)

## S4 method for signature 'Exp'
is_decr(object, idx)

## S4 method for signature 'Exp'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Exp-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
<tr><td><code id="Exp-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Exp-class">Exp</a> object.</p>
</td></tr>
<tr><td><code id="Exp-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="Exp-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Exp)</code>: The matrix with each element exponentiated.
</p>
</li>
<li> <p><code>sign_from_args(Exp)</code>: The atom is positive.
</p>
</li>
<li> <p><code>is_atom_convex(Exp)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(Exp)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(Exp)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(Exp)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(Exp)</code>: The atom is weakly increasing.
</p>
</li>
<li> <p><code>is_decr(Exp)</code>: The atom is not weakly decreasing.
</p>
</li>
<li> <p><code>.grad(Exp)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</dd>
</dl>

<hr>
<h2 id='exp+2CExpression-method'>Natural Exponential</h2><span id='topic+exp+2CExpression-method'></span><span id='topic+exp'></span>

<h3>Description</h3>

<p>The elementwise natural exponential.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression'
exp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp+2B2CExpression-method_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the natural exponential of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(5)
obj &lt;- Minimize(sum(exp(x)))
prob &lt;- Problem(obj, list(sum(x) == 1))
result &lt;- solve(prob)
result$getValue(x)
</code></pre>

<hr>
<h2 id='ExpCone-class'>The ExpCone class.</h2><span id='topic+ExpCone-class'></span><span id='topic+.ExpCone'></span><span id='topic+ExpCone'></span><span id='topic+as.character+2CExpCone-method'></span><span id='topic+residual+2CExpCone-method'></span><span id='topic+size+2CExpCone-method'></span><span id='topic+num_cones+2CExpCone-method'></span><span id='topic+cone_sizes+2CExpCone-method'></span><span id='topic+is_dcp+2CExpCone-method'></span><span id='topic+is_dgp+2CExpCone-method'></span><span id='topic+canonicalize+2CExpCone-method'></span>

<h3>Description</h3>

<p>This class represents a reformulated exponential cone constraint operating elementwise on <code class="reqn">a, b, c</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpCone(x, y, z, id = NA_integer_)

## S4 method for signature 'ExpCone'
as.character(x)

## S4 method for signature 'ExpCone'
residual(object)

## S4 method for signature 'ExpCone'
size(object)

## S4 method for signature 'ExpCone'
num_cones(object)

## S4 method for signature 'ExpCone'
cone_sizes(object)

## S4 method for signature 'ExpCone'
is_dcp(object)

## S4 method for signature 'ExpCone'
is_dgp(object)

## S4 method for signature 'ExpCone'
canonicalize(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpCone-class_+3A_x">x</code></td>
<td>
<p>The variable <code class="reqn">x</code> in the exponential cone.</p>
</td></tr>
<tr><td><code id="ExpCone-class_+3A_y">y</code></td>
<td>
<p>The variable <code class="reqn">y</code> in the exponential cone.</p>
</td></tr>
<tr><td><code id="ExpCone-class_+3A_z">z</code></td>
<td>
<p>The variable <code class="reqn">z</code> in the exponential cone.</p>
</td></tr>
<tr><td><code id="ExpCone-class_+3A_id">id</code></td>
<td>
<p>(Optional) A numeric value representing the constraint ID.</p>
</td></tr>
<tr><td><code id="ExpCone-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+ExpCone-class">ExpCone</a> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Original cone:
</p>
<p style="text-align: center;"><code class="reqn">
K = \{(x,y,z) | y &gt; 0, ye^{x/y} \leq z\} \cup \{(x,y,z) | x \leq 0, y = 0, z \geq 0\}
</code>
</p>

<p>Reformulated cone:
</p>
<p style="text-align: center;"><code class="reqn">
K = \{(x,y,z) | y, z &gt; 0, y\log(y) + x \leq y\log(z)\} \cup \{(x,y,z) | x \leq 0, y = 0, z \geq 0\}
</code>
</p>



<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>residual(ExpCone)</code>: The size of the <code>x</code> argument.
</p>
</li>
<li> <p><code>size(ExpCone)</code>: The number of entries in the combined cones.
</p>
</li>
<li> <p><code>num_cones(ExpCone)</code>: The number of elementwise cones.
</p>
</li>
<li> <p><code>cone_sizes(ExpCone)</code>: The dimensions of the exponential cones.
</p>
</li>
<li> <p><code>is_dcp(ExpCone)</code>: An exponential constraint is DCP if each argument is affine.
</p>
</li>
<li> <p><code>is_dgp(ExpCone)</code>: Is the constraint DGP?
</p>
</li>
<li> <p><code>canonicalize(ExpCone)</code>: Canonicalizes by converting expressions to LinOps.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>The variable <code class="reqn">x</code> in the exponential cone.</p>
</dd>
<dt><code>y</code></dt><dd><p>The variable <code class="reqn">y</code> in the exponential cone.</p>
</dd>
<dt><code>z</code></dt><dd><p>The variable <code class="reqn">z</code> in the exponential cone.</p>
</dd>
</dl>

<hr>
<h2 id='Expression-class'>The Expression class.</h2><span id='topic+Expression-class'></span><span id='topic+Expression'></span><span id='topic+value+2CExpression-method'></span><span id='topic+grad+2CExpression-method'></span><span id='topic+domain+2CExpression-method'></span><span id='topic+as.character+2CExpression-method'></span><span id='topic+name+2CExpression-method'></span><span id='topic+expr+2CExpression-method'></span><span id='topic+is_constant+2CExpression-method'></span><span id='topic+is_affine+2CExpression-method'></span><span id='topic+is_convex+2CExpression-method'></span><span id='topic+is_concave+2CExpression-method'></span><span id='topic+is_dcp+2CExpression-method'></span><span id='topic+is_log_log_constant+2CExpression-method'></span><span id='topic+is_log_log_affine+2CExpression-method'></span><span id='topic+is_log_log_convex+2CExpression-method'></span><span id='topic+is_log_log_concave+2CExpression-method'></span><span id='topic+is_dgp+2CExpression-method'></span><span id='topic+is_hermitian+2CExpression-method'></span><span id='topic+is_psd+2CExpression-method'></span><span id='topic+is_nsd+2CExpression-method'></span><span id='topic+is_quadratic+2CExpression-method'></span><span id='topic+is_symmetric+2CExpression-method'></span><span id='topic+is_pwl+2CExpression-method'></span><span id='topic+is_qpwa+2CExpression-method'></span><span id='topic+is_zero+2CExpression-method'></span><span id='topic+is_nonneg+2CExpression-method'></span><span id='topic+is_nonpos+2CExpression-method'></span><span id='topic+dim+2CExpression-method'></span><span id='topic+is_real+2CExpression-method'></span><span id='topic+is_imag+2CExpression-method'></span><span id='topic+is_complex+2CExpression-method'></span><span id='topic+size+2CExpression-method'></span><span id='topic+ndim+2CExpression-method'></span><span id='topic+flatten+2CExpression-method'></span><span id='topic+is_scalar+2CExpression-method'></span><span id='topic+is_vector+2CExpression-method'></span><span id='topic+is_matrix+2CExpression-method'></span><span id='topic+nrow+2CExpression-method'></span><span id='topic+ncol+2CExpression-method'></span>

<h3>Description</h3>

<p>This class represents a mathematical expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression'
value(object)

## S4 method for signature 'Expression'
grad(object)

## S4 method for signature 'Expression'
domain(object)

## S4 method for signature 'Expression'
as.character(x)

## S4 method for signature 'Expression'
name(x)

## S4 method for signature 'Expression'
expr(object)

## S4 method for signature 'Expression'
is_constant(object)

## S4 method for signature 'Expression'
is_affine(object)

## S4 method for signature 'Expression'
is_convex(object)

## S4 method for signature 'Expression'
is_concave(object)

## S4 method for signature 'Expression'
is_dcp(object)

## S4 method for signature 'Expression'
is_log_log_constant(object)

## S4 method for signature 'Expression'
is_log_log_affine(object)

## S4 method for signature 'Expression'
is_log_log_convex(object)

## S4 method for signature 'Expression'
is_log_log_concave(object)

## S4 method for signature 'Expression'
is_dgp(object)

## S4 method for signature 'Expression'
is_hermitian(object)

## S4 method for signature 'Expression'
is_psd(object)

## S4 method for signature 'Expression'
is_nsd(object)

## S4 method for signature 'Expression'
is_quadratic(object)

## S4 method for signature 'Expression'
is_symmetric(object)

## S4 method for signature 'Expression'
is_pwl(object)

## S4 method for signature 'Expression'
is_qpwa(object)

## S4 method for signature 'Expression'
is_zero(object)

## S4 method for signature 'Expression'
is_nonneg(object)

## S4 method for signature 'Expression'
is_nonpos(object)

## S4 method for signature 'Expression'
dim(x)

## S4 method for signature 'Expression'
is_real(object)

## S4 method for signature 'Expression'
is_imag(object)

## S4 method for signature 'Expression'
is_complex(object)

## S4 method for signature 'Expression'
size(object)

## S4 method for signature 'Expression'
ndim(object)

## S4 method for signature 'Expression'
flatten(object)

## S4 method for signature 'Expression'
is_scalar(object)

## S4 method for signature 'Expression'
is_vector(object)

## S4 method for signature 'Expression'
is_matrix(object)

## S4 method for signature 'Expression'
nrow(x)

## S4 method for signature 'Expression'
ncol(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Expression-class_+3A_x">x</code>, <code id="Expression-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>value(Expression)</code>: The value of the expression.
</p>
</li>
<li> <p><code>grad(Expression)</code>: The (sub/super)-gradient of the expression with respect to each variable.
</p>
</li>
<li> <p><code>domain(Expression)</code>: A list of constraints describing the closure of the region where the expression is finite.
</p>
</li>
<li> <p><code>as.character(Expression)</code>: The string representation of the expression.
</p>
</li>
<li> <p><code>name(Expression)</code>: The name of the expression.
</p>
</li>
<li> <p><code>expr(Expression)</code>: The expression itself.
</p>
</li>
<li> <p><code>is_constant(Expression)</code>: The expression is constant if it contains no variables or is identically zero.
</p>
</li>
<li> <p><code>is_affine(Expression)</code>: The expression is affine if it is constant or both convex and concave.
</p>
</li>
<li> <p><code>is_convex(Expression)</code>: A logical value indicating whether the expression is convex.
</p>
</li>
<li> <p><code>is_concave(Expression)</code>: A logical value indicating whether the expression is concave.
</p>
</li>
<li> <p><code>is_dcp(Expression)</code>: The expression is DCP if it is convex or concave.
</p>
</li>
<li> <p><code>is_log_log_constant(Expression)</code>: Is the expression log-log constant, i.e., elementwise positive?
</p>
</li>
<li> <p><code>is_log_log_affine(Expression)</code>: Is the expression log-log affine?
</p>
</li>
<li> <p><code>is_log_log_convex(Expression)</code>: Is the expression log-log convex?
</p>
</li>
<li> <p><code>is_log_log_concave(Expression)</code>: Is the expression log-log concave?
</p>
</li>
<li> <p><code>is_dgp(Expression)</code>: The expression is DGP if it is log-log DCP.
</p>
</li>
<li> <p><code>is_hermitian(Expression)</code>: A logical value indicating whether the expression is a Hermitian matrix.
</p>
</li>
<li> <p><code>is_psd(Expression)</code>: A logical value indicating whether the expression is a positive semidefinite matrix.
</p>
</li>
<li> <p><code>is_nsd(Expression)</code>: A logical value indicating whether the expression is a negative semidefinite matrix.
</p>
</li>
<li> <p><code>is_quadratic(Expression)</code>: A logical value indicating whether the expression is quadratic.
</p>
</li>
<li> <p><code>is_symmetric(Expression)</code>: A logical value indicating whether the expression is symmetric.
</p>
</li>
<li> <p><code>is_pwl(Expression)</code>: A logical value indicating whether the expression is piecewise linear.
</p>
</li>
<li> <p><code>is_qpwa(Expression)</code>: A logical value indicating whether the expression is quadratic of piecewise affine.
</p>
</li>
<li> <p><code>is_zero(Expression)</code>: The expression is zero if it is both nonnegative and nonpositive.
</p>
</li>
<li> <p><code>is_nonneg(Expression)</code>: A logical value indicating whether the expression is nonnegative.
</p>
</li>
<li> <p><code>is_nonpos(Expression)</code>: A logical value indicating whether the expression is nonpositive.
</p>
</li>
<li> <p><code>dim(Expression)</code>: The <code>c(row, col)</code> dimensions of the expression.
</p>
</li>
<li> <p><code>is_real(Expression)</code>: A logical value indicating whether the expression is real.
</p>
</li>
<li> <p><code>is_imag(Expression)</code>: A logical value indicating whether the expression is imaginary.
</p>
</li>
<li> <p><code>is_complex(Expression)</code>: A logical value indicating whether the expression is complex.
</p>
</li>
<li> <p><code>size(Expression)</code>: The number of entries in the expression.
</p>
</li>
<li> <p><code>ndim(Expression)</code>: The number of dimensions of the expression.
</p>
</li>
<li> <p><code>flatten(Expression)</code>: Vectorizes the expression.
</p>
</li>
<li> <p><code>is_scalar(Expression)</code>: A logical value indicating whether the expression is a scalar.
</p>
</li>
<li> <p><code>is_vector(Expression)</code>: A logical value indicating whether the expression is a row or column vector.
</p>
</li>
<li> <p><code>is_matrix(Expression)</code>: A logical value indicating whether the expression is a matrix.
</p>
</li>
<li> <p><code>nrow(Expression)</code>: Number of rows in the expression.
</p>
</li>
<li> <p><code>ncol(Expression)</code>: Number of columns in the expression.
</p>
</li></ul>

<hr>
<h2 id='expression-parts'>Parts of an Expression Leaf</h2><span id='topic+expression-parts'></span><span id='topic+variables'></span><span id='topic+parameters'></span><span id='topic+constants'></span><span id='topic+atoms'></span>

<h3>Description</h3>

<p>List the variables, parameters, constants, or atoms in a canonical expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variables(object)

parameters(object)

constants(object)

atoms(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expression-parts_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Leaf-class">Leaf</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <a href="#topic+Variable-class">Variable</a>, <a href="#topic+Parameter-class">Parameter</a>, <a href="#topic+Constant-class">Constant</a>, or <a href="#topic+Atom-class">Atom</a> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(67)
m &lt;- 50
n &lt;- 10
beta &lt;- Variable(n)
y &lt;- matrix(rnorm(m), nrow = m)
X &lt;- matrix(rnorm(m*n), nrow = m, ncol = n)
lambda &lt;- Parameter()

expr &lt;- sum_squares(y - X %*% beta) + lambda*p_norm(beta, 1)
variables(expr)
parameters(expr)
constants(expr)
lapply(constants(expr), function(c) { value(c) })
</code></pre>

<hr>
<h2 id='extract_dual_value'>Gets a specified value of a dual variable.</h2><span id='topic+extract_dual_value'></span>

<h3>Description</h3>

<p>Gets a specified value of a dual variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_dual_value(result_vec, offset, constraint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_dual_value_+3A_result_vec">result_vec</code></td>
<td>
<p>A vector containing the dual variable values.</p>
</td></tr>
<tr><td><code id="extract_dual_value_+3A_offset">offset</code></td>
<td>
<p>An offset to get correct index of dual values.</p>
</td></tr>
<tr><td><code id="extract_dual_value_+3A_constraint">constraint</code></td>
<td>
<p>A list of the constraints in the problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of a dual variable value and its offset.
</p>

<hr>
<h2 id='extract_mip_idx'>Coalesces bool, int indices for variables.</h2><span id='topic+extract_mip_idx'></span>

<h3>Description</h3>

<p>Coalesces bool, int indices for variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_mip_idx(variables)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_mip_idx_+3A_variables">variables</code></td>
<td>
<p>A list of <a href="#topic+Variable-class">Variable</a> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coalesces bool, int indices for variables. The indexing scheme assumes that the variables will be coalesced into
a single one-dimensional variable, with each variable being reshaped in Fortran order.
</p>

<hr>
<h2 id='eye_minus_inv'>Unity Resolvent</h2><span id='topic+eye_minus_inv'></span>

<h3>Description</h3>

<p>The unity resolvent of a positive matrix. For an elementwise positive matrix <code class="reqn">X</code>, this atom represents <code class="reqn">(I - X)^{-1}</code>,
and it enforces the constraint that the spectral radius of <code class="reqn">X</code> is at most 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eye_minus_inv(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eye_minus_inv_+3A_x">X</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or positive square matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This atom is log-log convex.
</p>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the unity resolvent of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Variable(2,2, pos = TRUE)
prob &lt;- Problem(Minimize(matrix_trace(A)), list(eye_minus_inv(A) &lt;=1))
result &lt;- solve(prob, gp = TRUE)
result$value
result$getValue(A)
</code></pre>

<hr>
<h2 id='EyeMinusInv-class'>The EyeMinusInv class.</h2><span id='topic+EyeMinusInv-class'></span><span id='topic+.EyeMinusInv'></span><span id='topic+EyeMinusInv'></span><span id='topic+to_numeric+2CEyeMinusInv-method'></span><span id='topic+name+2CEyeMinusInv-method'></span><span id='topic+dim_from_args+2CEyeMinusInv-method'></span><span id='topic+sign_from_args+2CEyeMinusInv-method'></span><span id='topic+is_atom_convex+2CEyeMinusInv-method'></span><span id='topic+is_atom_concave+2CEyeMinusInv-method'></span><span id='topic+is_atom_log_log_convex+2CEyeMinusInv-method'></span><span id='topic+is_atom_log_log_concave+2CEyeMinusInv-method'></span><span id='topic+is_incr+2CEyeMinusInv-method'></span><span id='topic+is_decr+2CEyeMinusInv-method'></span><span id='topic+.grad+2CEyeMinusInv-method'></span>

<h3>Description</h3>

<p>This class represents the unity resolvent of an elementwise positive matrix <code class="reqn">X</code>, i.e., <code class="reqn">(I - X)^{-1}</code>,
and it enforces the constraint that the spectral radius of <code class="reqn">X</code> is at most 1.
This atom is log-log convex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EyeMinusInv(X)

## S4 method for signature 'EyeMinusInv'
to_numeric(object, values)

## S4 method for signature 'EyeMinusInv'
name(x)

## S4 method for signature 'EyeMinusInv'
dim_from_args(object)

## S4 method for signature 'EyeMinusInv'
sign_from_args(object)

## S4 method for signature 'EyeMinusInv'
is_atom_convex(object)

## S4 method for signature 'EyeMinusInv'
is_atom_concave(object)

## S4 method for signature 'EyeMinusInv'
is_atom_log_log_convex(object)

## S4 method for signature 'EyeMinusInv'
is_atom_log_log_concave(object)

## S4 method for signature 'EyeMinusInv'
is_incr(object, idx)

## S4 method for signature 'EyeMinusInv'
is_decr(object, idx)

## S4 method for signature 'EyeMinusInv'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EyeMinusInv-class_+3A_x">X</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="EyeMinusInv-class_+3A_object">object</code>, <code id="EyeMinusInv-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+EyeMinusInv-class">EyeMinusInv</a> object.</p>
</td></tr>
<tr><td><code id="EyeMinusInv-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="EyeMinusInv-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(EyeMinusInv)</code>: The unity resolvent of the matrix.
</p>
</li>
<li> <p><code>name(EyeMinusInv)</code>: The name and arguments of the atom.
</p>
</li>
<li> <p><code>dim_from_args(EyeMinusInv)</code>: The dimensions of the atom determined from its arguments.
</p>
</li>
<li> <p><code>sign_from_args(EyeMinusInv)</code>: The (is positive, is negative) sign of the atom.
</p>
</li>
<li> <p><code>is_atom_convex(EyeMinusInv)</code>: Is the atom convex?
</p>
</li>
<li> <p><code>is_atom_concave(EyeMinusInv)</code>: Is the atom concave?
</p>
</li>
<li> <p><code>is_atom_log_log_convex(EyeMinusInv)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(EyeMinusInv)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(EyeMinusInv)</code>: Is the atom weakly increasing in the index?
</p>
</li>
<li> <p><code>is_decr(EyeMinusInv)</code>: Is the atom weakly decreasing in the index?
</p>
</li>
<li> <p><code>.grad(EyeMinusInv)</code>: Gives EyeMinusInv the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>X</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='FlipObjective-class'>The FlipObjective class.</h2><span id='topic+FlipObjective-class'></span><span id='topic+FlipObjective'></span><span id='topic+perform+2CFlipObjective+2CProblem-method'></span><span id='topic+invert+2CFlipObjective+2CSolution+2Clist-method'></span>

<h3>Description</h3>

<p>This class represents a reduction that flips a minimization objective to a
maximization and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FlipObjective,Problem'
perform(object, problem)

## S4 method for signature 'FlipObjective,Solution,list'
invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FlipObjective-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+FlipObjective-class">FlipObjective</a> object.</p>
</td></tr>
<tr><td><code id="FlipObjective-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="FlipObjective-class_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> to a problem that generated the inverse data.</p>
</td></tr>
<tr><td><code id="FlipObjective-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>The inverse data returned by an invocation to apply.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>perform(object = FlipObjective, problem = Problem)</code>: Flip a minimization objective to a maximization and vice versa.
</p>
</li>
<li> <p><code>invert(object = FlipObjective, solution = Solution, inverse_data = list)</code>: Map the solution of the flipped problem to that of the original.
</p>
</li></ul>

<hr>
<h2 id='format_constr'>Format Constraints</h2><span id='topic+format_constr'></span>

<h3>Description</h3>

<p>Format constraints for the solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_constr(object, eq_constr, leq_constr, dims, solver)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_constr_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Constraint-class">Constraint</a> object.</p>
</td></tr>
<tr><td><code id="format_constr_+3A_eq_constr">eq_constr</code></td>
<td>
<p>A list of the equality constraints in the canonical problem.</p>
</td></tr>
<tr><td><code id="format_constr_+3A_leq_constr">leq_constr</code></td>
<td>
<p>A list of the inequality constraints in the canonical problem.</p>
</td></tr>
<tr><td><code id="format_constr_+3A_dims">dims</code></td>
<td>
<p>A list with the dimensions of the conic constraints.</p>
</td></tr>
<tr><td><code id="format_constr_+3A_solver">solver</code></td>
<td>
<p>A string representing the solver to be called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing equality constraints, inequality constraints, and dimensions.
</p>

<hr>
<h2 id='geo_mean'>Geometric Mean</h2><span id='topic+geo_mean'></span>

<h3>Description</h3>

<p>The (weighted) geometric mean of vector <code class="reqn">x</code> with optional powers given by <code class="reqn">p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_mean(x, p = NA_real_, max_denom = 1024)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_mean_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or vector.</p>
</td></tr>
<tr><td><code id="geo_mean_+3A_p">p</code></td>
<td>
<p>(Optional) A vector of weights for the weighted geometric mean. Defaults to a vector of ones, giving the <strong>unweighted</strong> geometric mean <code class="reqn">x_1^{1/n} \cdots x_n^{1/n}</code>.</p>
</td></tr>
<tr><td><code id="geo_mean_+3A_max_denom">max_denom</code></td>
<td>
<p>(Optional) The maximum denominator to use in approximating <code>p/sum(p)</code> with <code>w</code>. If <code>w</code> is not an exact representation, increasing <code>max_denom</code> may offer a more accurate representation, at the cost of requiring more convex inequalities to represent the geometric mean. Defaults to 1024.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">\left(x_1^{p_1} \cdots x_n^{p_n} \right)^{\frac{1}{\mathbf{1}^Tp}}</code>
</p>

<p>The geometric mean includes an implicit constraint that <code class="reqn">x_i \geq 0</code> whenever <code class="reqn">p_i &gt; 0</code>. If <code class="reqn">p_i = 0, x_i</code> will be unconstrained.
The only exception to this rule occurs when <code class="reqn">p</code> has exactly one nonzero element, say <code class="reqn">p_i</code>, in which case <code>geo_mean(x,p)</code> is equivalent to <code class="reqn">x_i</code> (without the nonnegativity constraint).
A specific case of this is when <code class="reqn">x \in \mathbf{R}^1</code>.
</p>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the geometric mean of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(2)
cost &lt;- geo_mean(x)
prob &lt;- Problem(Maximize(cost), list(sum(x) &lt;= 1))
result &lt;- solve(prob)
result$value
result$getValue(x)

## Not run: 
  x &lt;- Variable(5)
  p &lt;- c(0.07, 0.12, 0.23, 0.19, 0.39)
  prob &lt;- Problem(Maximize(geo_mean(x,p)), list(p_norm(x) &lt;= 1))
  result &lt;- solve(prob)
  result$value
  result$getValue(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='GeoMean-class'>The GeoMean class.</h2><span id='topic+GeoMean-class'></span><span id='topic+.GeoMean'></span><span id='topic+GeoMean'></span><span id='topic+to_numeric+2CGeoMean-method'></span><span id='topic+.domain+2CGeoMean-method'></span><span id='topic+.grad+2CGeoMean-method'></span><span id='topic+name+2CGeoMean-method'></span><span id='topic+dim_from_args+2CGeoMean-method'></span><span id='topic+sign_from_args+2CGeoMean-method'></span><span id='topic+is_atom_convex+2CGeoMean-method'></span><span id='topic+is_atom_concave+2CGeoMean-method'></span><span id='topic+is_atom_log_log_convex+2CGeoMean-method'></span><span id='topic+is_atom_log_log_concave+2CGeoMean-method'></span><span id='topic+is_incr+2CGeoMean-method'></span><span id='topic+is_decr+2CGeoMean-method'></span><span id='topic+get_data+2CGeoMean-method'></span><span id='topic+copy+2CGeoMean-method'></span>

<h3>Description</h3>

<p>This class represents the (weighted) geometric mean of vector <code class="reqn">x</code> with optional powers given by <code class="reqn">p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoMean(x, p = NA_real_, max_denom = 1024)

## S4 method for signature 'GeoMean'
to_numeric(object, values)

## S4 method for signature 'GeoMean'
.domain(object)

## S4 method for signature 'GeoMean'
.grad(object, values)

## S4 method for signature 'GeoMean'
name(x)

## S4 method for signature 'GeoMean'
dim_from_args(object)

## S4 method for signature 'GeoMean'
sign_from_args(object)

## S4 method for signature 'GeoMean'
is_atom_convex(object)

## S4 method for signature 'GeoMean'
is_atom_concave(object)

## S4 method for signature 'GeoMean'
is_atom_log_log_convex(object)

## S4 method for signature 'GeoMean'
is_atom_log_log_concave(object)

## S4 method for signature 'GeoMean'
is_incr(object, idx)

## S4 method for signature 'GeoMean'
is_decr(object, idx)

## S4 method for signature 'GeoMean'
get_data(object)

## S4 method for signature 'GeoMean'
copy(object, args = NULL, id_objects = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoMean-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric vector.</p>
</td></tr>
<tr><td><code id="GeoMean-class_+3A_p">p</code></td>
<td>
<p>(Optional) A vector of weights for the weighted geometric mean. The default is a vector of ones, giving the <strong>unweighted</strong> geometric mean <code class="reqn">x_1^{1/n} \cdots x_n^{1/n}</code>.</p>
</td></tr>
<tr><td><code id="GeoMean-class_+3A_max_denom">max_denom</code></td>
<td>
<p>(Optional) The maximum denominator to use in approximating <code>p/sum(p)</code> with <code>w</code>. If <code>w</code> is not an exact representation, increasing <code>max_denom</code> may offer a more accurate representation, at the cost of requiring more convex inequalities to represent the geometric mean. Defaults to 1024.</p>
</td></tr>
<tr><td><code id="GeoMean-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+GeoMean-class">GeoMean</a> object.</p>
</td></tr>
<tr><td><code id="GeoMean-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="GeoMean-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="GeoMean-class_+3A_args">args</code></td>
<td>
<p>An optional list that contains the arguments to reconstruct the atom. Default is to use current arguments of the atom.</p>
</td></tr>
<tr><td><code id="GeoMean-class_+3A_id_objects">id_objects</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">\left(x_1^{p_1} \cdots x_n^{p_n} \right)^{\frac{1}{\mathbf{1}^Tp}}</code>
</p>

<p>The geometric mean includes an implicit constraint that <code class="reqn">x_i \geq 0</code> whenever <code class="reqn">p_i &gt; 0</code>. If <code class="reqn">p_i = 0, x_i</code> will be unconstrained.
The only exception to this rule occurs when <code class="reqn">p</code> has exactly one nonzero element, say <code class="reqn">p_i</code>, in which case <code>GeoMean(x,p)</code> is equivalent to <code class="reqn">x_i</code> (without the nonnegativity constraint).
A specific case of this is when <code class="reqn">x \in \mathbf{R}^1</code>.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(GeoMean)</code>: The (weighted) geometric mean of the elements of <code>x</code>.
</p>
</li>
<li> <p><code>.domain(GeoMean)</code>: Returns constraints describing the domain of the node
</p>
</li>
<li> <p><code>.grad(GeoMean)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>name(GeoMean)</code>: The name and arguments of the atom.
</p>
</li>
<li> <p><code>dim_from_args(GeoMean)</code>: The atom is a scalar.
</p>
</li>
<li> <p><code>sign_from_args(GeoMean)</code>: The atom is non-negative.
</p>
</li>
<li> <p><code>is_atom_convex(GeoMean)</code>: The atom is not convex.
</p>
</li>
<li> <p><code>is_atom_concave(GeoMean)</code>: The atom is concave.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(GeoMean)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(GeoMean)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(GeoMean)</code>: The atom is weakly increasing in every argument.
</p>
</li>
<li> <p><code>is_decr(GeoMean)</code>: The atom is not weakly decreasing in any argument.
</p>
</li>
<li> <p><code>get_data(GeoMean)</code>: Returns <code>list(w, dyadic completion, tree of dyads)</code>.
</p>
</li>
<li> <p><code>copy(GeoMean)</code>: Returns a shallow copy of the GeoMean atom
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric vector.</p>
</dd>
<dt><code>p</code></dt><dd><p>(Optional) A vector of weights for the weighted geometric mean. The default is a vector of ones, giving the <strong>unweighted</strong> geometric mean <code class="reqn">x_1^{1/n} \cdots x_n^{1/n}</code>.</p>
</dd>
<dt><code>max_denom</code></dt><dd><p>(Optional) The maximum denominator to use in approximating <code>p/sum(p)</code> with <code>w</code>. If <code>w</code> is not an exact representation, increasing <code>max_denom</code> may offer a more accurate representation, at the cost of requiring more convex inequalities to represent the geometric mean. Defaults to 1024.</p>
</dd>
<dt><code>w</code></dt><dd><p>(Internal) A list of <code>bigq</code> objects that represent a rational approximation of <code>p/sum(p)</code>.</p>
</dd>
<dt><code>approx_error</code></dt><dd><p>(Internal) The error in approximating <code>p/sum(p)</code> with <code>w</code>, given by <code class="reqn">\|p/\mathbf{1}^Tp - w\|_{\infty}</code>.</p>
</dd>
</dl>

<hr>
<h2 id='get_data'>Get Expression Data</h2><span id='topic+get_data'></span>

<h3>Description</h3>

<p>Get information needed to reconstruct the expression aside from its arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing data.
</p>

<hr>
<h2 id='get_dual_values'>Gets the values of the dual variables.</h2><span id='topic+get_dual_values'></span>

<h3>Description</h3>

<p>Gets the values of the dual variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dual_values(result_vec, parse_func, constraints)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dual_values_+3A_result_vec">result_vec</code></td>
<td>
<p>A vector containing the dual variable values.</p>
</td></tr>
<tr><td><code id="get_dual_values_+3A_parse_func">parse_func</code></td>
<td>
<p>Function handle for the parser.</p>
</td></tr>
<tr><td><code id="get_dual_values_+3A_constraints">constraints</code></td>
<td>
<p>A list of the constraints in the problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A map of constraint ID to dual variable value.
</p>

<hr>
<h2 id='get_id'>Get ID</h2><span id='topic+get_id'></span>

<h3>Description</h3>

<p>Get the next identifier value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_id()
</code></pre>


<h3>Value</h3>

<p>A new unique integer identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   get_id()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_np'>Get numpy handle</h2><span id='topic+get_np'></span>

<h3>Description</h3>

<p>Get the numpy handle or fail if not available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_np()
</code></pre>


<h3>Value</h3>

<p>the numpy handle
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   get_np

## End(Not run)
</code></pre>

<hr>
<h2 id='get_problem_data'>Get Problem Data</h2><span id='topic+get_problem_data'></span>

<h3>Description</h3>

<p>Get the problem data used in the call to the solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_problem_data(object, solver, gp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_problem_data_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="get_problem_data_+3A_solver">solver</code></td>
<td>
<p>A string indicating the solver that the problem data is for. Call <code>installed_solvers()</code> to see all available.</p>
</td></tr>
<tr><td><code id="get_problem_data_+3A_gp">gp</code></td>
<td>
<p>(Optional) A logical value indicating whether the problem is a geometric program.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the data for the solver, the solving chain for the problem, and the inverse data needed to invert the solution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- Variable(name = "a")
data &lt;- get_problem_data(Problem(Minimize(exp(a) + 2)), "SCS")[[1]]
data[["dims"]]
data[["c"]]
data[["A"]]

x &lt;- Variable(2, name = "x")
data &lt;- get_problem_data(Problem(Minimize(p_norm(x) + 3)), "ECOS")[[1]]
data[["dims"]]
data[["c"]]
data[["A"]]
data[["G"]]
</code></pre>

<hr>
<h2 id='get_sp'>Get scipy handle</h2><span id='topic+get_sp'></span>

<h3>Description</h3>

<p>Get the scipy handle or fail if not available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sp()
</code></pre>


<h3>Value</h3>

<p>the scipy handle
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   get_sp

## End(Not run)
</code></pre>

<hr>
<h2 id='GLPK_MI-class'>An interface for the GLPK MI solver.</h2><span id='topic+GLPK_MI-class'></span><span id='topic+GLPK_MI'></span><span id='topic+mip_capable+2CGLPK_MI-method'></span><span id='topic+status_map+2CGLPK_MI-method'></span><span id='topic+name+2CGLPK_MI-method'></span><span id='topic+solve_via_data+2CGLPK_MI-method'></span>

<h3>Description</h3>

<p>An interface for the GLPK MI solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLPK_MI()

## S4 method for signature 'GLPK_MI'
mip_capable(solver)

## S4 method for signature 'GLPK_MI'
status_map(solver, status)

## S4 method for signature 'GLPK_MI'
name(x)

## S4 method for signature 'GLPK_MI'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLPK_MI-class_+3A_solver">solver</code>, <code id="GLPK_MI-class_+3A_object">object</code>, <code id="GLPK_MI-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+GLPK_MI-class">GLPK_MI</a> object.</p>
</td></tr>
<tr><td><code id="GLPK_MI-class_+3A_status">status</code></td>
<td>
<p>A status code returned by the solver.</p>
</td></tr>
<tr><td><code id="GLPK_MI-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="GLPK_MI-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="GLPK_MI-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="GLPK_MI-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance.</p>
</td></tr>
<tr><td><code id="GLPK_MI-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance.</p>
</td></tr>
<tr><td><code id="GLPK_MI-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance.</p>
</td></tr>
<tr><td><code id="GLPK_MI-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="GLPK_MI-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="GLPK_MI-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(GLPK_MI)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>status_map(GLPK_MI)</code>: Converts status returned by the GLPK_MI solver to its respective CVXPY status.
</p>
</li>
<li> <p><code>name(GLPK_MI)</code>: Returns the name of the solver.
</p>
</li>
<li> <p><code>solve_via_data(GLPK_MI)</code>: Solve a problem represented by data returned from apply.
</p>
</li></ul>

<hr>
<h2 id='GLPK-class'>An interface for the GLPK solver.</h2><span id='topic+GLPK-class'></span><span id='topic+GLPK'></span><span id='topic+mip_capable+2CGLPK-method'></span><span id='topic+status_map+2CGLPK-method'></span><span id='topic+name+2CGLPK-method'></span><span id='topic+import_solver+2CGLPK-method'></span><span id='topic+invert+2CGLPK+2Clist+2Clist-method'></span><span id='topic+solve_via_data+2CGLPK-method'></span>

<h3>Description</h3>

<p>An interface for the GLPK solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLPK()

## S4 method for signature 'GLPK'
mip_capable(solver)

## S4 method for signature 'GLPK'
status_map(solver, status)

## S4 method for signature 'GLPK'
name(x)

## S4 method for signature 'GLPK'
import_solver(solver)

## S4 method for signature 'GLPK,list,list'
invert(object, solution, inverse_data)

## S4 method for signature 'GLPK'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLPK-class_+3A_solver">solver</code>, <code id="GLPK-class_+3A_object">object</code>, <code id="GLPK-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+GLPK-class">GLPK</a> object.</p>
</td></tr>
<tr><td><code id="GLPK-class_+3A_status">status</code></td>
<td>
<p>A status code returned by the solver.</p>
</td></tr>
<tr><td><code id="GLPK-class_+3A_solution">solution</code></td>
<td>
<p>The raw solution returned by the solver.</p>
</td></tr>
<tr><td><code id="GLPK-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A list containing data necessary for the inversion.</p>
</td></tr>
<tr><td><code id="GLPK-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="GLPK-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="GLPK-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="GLPK-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance.</p>
</td></tr>
<tr><td><code id="GLPK-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance.</p>
</td></tr>
<tr><td><code id="GLPK-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance.</p>
</td></tr>
<tr><td><code id="GLPK-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="GLPK-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="GLPK-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(GLPK)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>status_map(GLPK)</code>: Converts status returned by the GLPK solver to its respective CVXPY status.
</p>
</li>
<li> <p><code>name(GLPK)</code>: Returns the name of the solver.
</p>
</li>
<li> <p><code>import_solver(GLPK)</code>: Imports the solver.
</p>
</li>
<li> <p><code>invert(object = GLPK, solution = list, inverse_data = list)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li>
<li> <p><code>solve_via_data(GLPK)</code>: Solve a problem represented by data returned from apply.
</p>
</li></ul>

<hr>
<h2 id='grad'>Sub/Super-Gradient</h2><span id='topic+grad'></span>

<h3>Description</h3>

<p>The (sub/super)-gradient of the expression with respect to each variable.
Matrix expressions are vectorized, so the gradient is a matrix. <code>NA</code> indicates variable values are unknown or outside the domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grad_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list mapping each variable to a sparse matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(2, name = "x")
A &lt;- Variable(2, 2, name = "A")

value(x) &lt;- c(-3,4)
expr &lt;- p_norm(x, 2)
grad(expr)

value(A) &lt;- rbind(c(3,-4), c(4,3))
expr &lt;- p_norm(A, 0.5)
grad(expr)

value(A) &lt;- cbind(c(1,2), c(-1,0))
expr &lt;- abs(A)
grad(expr)
</code></pre>

<hr>
<h2 id='graph_implementation'>Graph Implementation</h2><span id='topic+graph_implementation'></span>

<h3>Description</h3>

<p>Reduces the atom to an affine expression and list of constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_implementation(object, arg_objs, dim, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_implementation_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
<tr><td><code id="graph_implementation_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="graph_implementation_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="graph_implementation_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>list(LinOp for objective, list of constraints)</code>, where LinOp is a list representing the linear operator.
</p>

<hr>
<h2 id='group_constraints'>Organize the constraints into a dictionary keyed by constraint names.</h2><span id='topic+group_constraints'></span>

<h3>Description</h3>

<p>Organize the constraints into a dictionary keyed by constraint names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_constraints(constraints)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_constraints_+3A_constraints">constraints</code></td>
<td>
<p>a list of constraints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of constraint types where constr_map[[cone_type]] maps to a list.
</p>

<hr>
<h2 id='GUROBI_CONIC-class'>An interface for the GUROBI conic solver.</h2><span id='topic+GUROBI_CONIC-class'></span><span id='topic+GUROBI_CONIC'></span><span id='topic+mip_capable+2CGUROBI_CONIC-method'></span><span id='topic+name+2CGUROBI_CONIC-method'></span><span id='topic+import_solver+2CGUROBI_CONIC-method'></span><span id='topic+status_map+2CGUROBI_CONIC-method'></span><span id='topic+accepts+2CGUROBI_CONIC+2CProblem-method'></span><span id='topic+perform+2CGUROBI_CONIC+2CProblem-method'></span><span id='topic+invert+2CGUROBI_CONIC+2Clist+2Clist-method'></span><span id='topic+solve_via_data+2CGUROBI_CONIC-method'></span>

<h3>Description</h3>

<p>An interface for the GUROBI conic solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GUROBI_CONIC()

## S4 method for signature 'GUROBI_CONIC'
mip_capable(solver)

## S4 method for signature 'GUROBI_CONIC'
name(x)

## S4 method for signature 'GUROBI_CONIC'
import_solver(solver)

## S4 method for signature 'GUROBI_CONIC'
status_map(solver, status)

## S4 method for signature 'GUROBI_CONIC,Problem'
accepts(object, problem)

## S4 method for signature 'GUROBI_CONIC,Problem'
perform(object, problem)

## S4 method for signature 'GUROBI_CONIC,list,list'
invert(object, solution, inverse_data)

## S4 method for signature 'GUROBI_CONIC'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GUROBI_CONIC-class_+3A_solver">solver</code>, <code id="GUROBI_CONIC-class_+3A_object">object</code>, <code id="GUROBI_CONIC-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+GUROBI_CONIC-class">GUROBI_CONIC</a> object.</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_status">status</code></td>
<td>
<p>A status code returned by the solver.</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_solution">solution</code></td>
<td>
<p>The raw solution returned by the solver.</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A list containing data necessary for the inversion.</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance.</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance.</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance.</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="GUROBI_CONIC-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(GUROBI_CONIC)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>name(GUROBI_CONIC)</code>: Returns the name of the solver.
</p>
</li>
<li> <p><code>import_solver(GUROBI_CONIC)</code>: Imports the solver.
</p>
</li>
<li> <p><code>status_map(GUROBI_CONIC)</code>: Converts status returned by the GUROBI solver to its respective CVXPY status.
</p>
</li>
<li> <p><code>accepts(object = GUROBI_CONIC, problem = Problem)</code>: Can GUROBI_CONIC solve the problem?
</p>
</li>
<li> <p><code>perform(object = GUROBI_CONIC, problem = Problem)</code>: Returns a new problem and data for inverting the new solution.
</p>
</li>
<li> <p><code>invert(object = GUROBI_CONIC, solution = list, inverse_data = list)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li>
<li> <p><code>solve_via_data(GUROBI_CONIC)</code>: Solve a problem represented by data returned from apply.
</p>
</li></ul>

<hr>
<h2 id='GUROBI_QP-class'>An interface for the GUROBI_QP solver.</h2><span id='topic+GUROBI_QP-class'></span><span id='topic+GUROBI_QP'></span><span id='topic+mip_capable+2CGUROBI_QP-method'></span><span id='topic+status_map+2CGUROBI_QP-method'></span><span id='topic+name+2CGUROBI_QP-method'></span><span id='topic+import_solver+2CGUROBI_QP-method'></span><span id='topic+solve_via_data+2CGUROBI_QP-method'></span><span id='topic+invert+2CGUROBI_QP+2Clist+2CInverseData-method'></span>

<h3>Description</h3>

<p>An interface for the GUROBI_QP solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GUROBI_QP()

## S4 method for signature 'GUROBI_QP'
mip_capable(solver)

## S4 method for signature 'GUROBI_QP'
status_map(solver, status)

## S4 method for signature 'GUROBI_QP'
name(x)

## S4 method for signature 'GUROBI_QP'
import_solver(solver)

## S4 method for signature 'GUROBI_QP'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)

## S4 method for signature 'GUROBI_QP,list,InverseData'
invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GUROBI_QP-class_+3A_solver">solver</code>, <code id="GUROBI_QP-class_+3A_object">object</code>, <code id="GUROBI_QP-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+GUROBI_QP-class">GUROBI_QP</a> object.</p>
</td></tr>
<tr><td><code id="GUROBI_QP-class_+3A_status">status</code></td>
<td>
<p>A status code returned by the solver.</p>
</td></tr>
<tr><td><code id="GUROBI_QP-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="GUROBI_QP-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="GUROBI_QP-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="GUROBI_QP-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance.</p>
</td></tr>
<tr><td><code id="GUROBI_QP-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance.</p>
</td></tr>
<tr><td><code id="GUROBI_QP-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance.</p>
</td></tr>
<tr><td><code id="GUROBI_QP-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="GUROBI_QP-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="GUROBI_QP-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
<tr><td><code id="GUROBI_QP-class_+3A_solution">solution</code></td>
<td>
<p>The raw solution returned by the solver.</p>
</td></tr>
<tr><td><code id="GUROBI_QP-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A <a href="#topic+InverseData-class">InverseData</a> object containing data necessary for the inversion.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(GUROBI_QP)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>status_map(GUROBI_QP)</code>: Converts status returned by the GUROBI solver to its respective CVXPY status.
</p>
</li>
<li> <p><code>name(GUROBI_QP)</code>: Returns the name of the solver.
</p>
</li>
<li> <p><code>import_solver(GUROBI_QP)</code>: Imports the solver.
</p>
</li>
<li> <p><code>solve_via_data(GUROBI_QP)</code>: Solve a problem represented by data returned from apply.
</p>
</li>
<li> <p><code>invert(object = GUROBI_QP, solution = list, inverse_data = InverseData)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li></ul>

<hr>
<h2 id='harmonic_mean'>Harmonic Mean</h2><span id='topic+harmonic_mean'></span>

<h3>Description</h3>

<p>The harmonic mean, <code class="reqn">\left(\frac{1}{n} \sum_{i=1}^n x_i^{-1}\right)^{-1}</code>. For a matrix, the function is applied over all entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonic_mean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonic_mean_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the harmonic mean of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable()
prob &lt;- Problem(Maximize(harmonic_mean(x)), list(x &gt;= 0, x &lt;= 5))
result &lt;- solve(prob)
result$value
result$getValue(x)
</code></pre>

<hr>
<h2 id='HarmonicMean'>The HarmonicMean atom.</h2><span id='topic+HarmonicMean'></span>

<h3>Description</h3>

<p>The harmonic mean of x, <code class="reqn">\frac{1}{n} \sum_{i=1}^n x_i^{-1}</code>, where n is the length of x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HarmonicMean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HarmonicMean_+3A_x">x</code></td>
<td>
<p>An expression or number whose harmonic mean is to be computed. Must have positive entries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The harmonic mean of <code>x</code>.
</p>

<hr>
<h2 id='hstack'>Horizontal Concatenation</h2><span id='topic+hstack'></span>

<h3>Description</h3>

<p>The horizontal concatenation of expressions.
This is equivalent to <code>cbind</code> when applied to objects with the same number of rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hstack(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hstack_+3A_...">...</code></td>
<td>
<p><a href="#topic+Expression-class">Expression</a> objects, vectors, or matrices. All arguments must have the same number of rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the concatenated inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(2)
y &lt;- Variable(3)
c &lt;- matrix(1, nrow = 1, ncol = 5)
prob &lt;- Problem(Minimize(c %*% t(hstack(t(x), t(y)))), list(x == c(1,2), y == c(3,4,5)))
result &lt;- solve(prob)
result$value

c &lt;- matrix(1, nrow = 1, ncol = 4)
prob &lt;- Problem(Minimize(c %*% t(hstack(t(x), t(x)))), list(x == c(1,2)))
result &lt;- solve(prob)
result$value

A &lt;- Variable(2,2)
C &lt;- Variable(3,2)
c &lt;- matrix(1, nrow = 2, ncol = 2)
prob &lt;- Problem(Minimize(sum_entries(hstack(t(A), t(C)))), list(A &gt;= 2*c, C == -2))
result &lt;- solve(prob)
result$value
result$getValue(A)

D &lt;- Variable(3,3)
expr &lt;- hstack(C, D)
obj &lt;- expr[1,2] + sum(hstack(expr, expr))
constr &lt;- list(C &gt;= 0, D &gt;= 0, D[1,1] == 2, C[1,2] == 3)
prob &lt;- Problem(Minimize(obj), constr)
result &lt;- solve(prob)
result$value
result$getValue(C)
result$getValue(D)
</code></pre>

<hr>
<h2 id='HStack-class'>The HStack class.</h2><span id='topic+HStack-class'></span><span id='topic+.HStack'></span><span id='topic+HStack'></span><span id='topic+to_numeric+2CHStack-method'></span><span id='topic+dim_from_args+2CHStack-method'></span><span id='topic+is_atom_log_log_convex+2CHStack-method'></span><span id='topic+is_atom_log_log_concave+2CHStack-method'></span><span id='topic+validate_args+2CHStack-method'></span><span id='topic+graph_implementation+2CHStack-method'></span>

<h3>Description</h3>

<p>Horizontal concatenation of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HStack(...)

## S4 method for signature 'HStack'
to_numeric(object, values)

## S4 method for signature 'HStack'
dim_from_args(object)

## S4 method for signature 'HStack'
is_atom_log_log_convex(object)

## S4 method for signature 'HStack'
is_atom_log_log_concave(object)

## S4 method for signature 'HStack'
validate_args(object)

## S4 method for signature 'HStack'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HStack-class_+3A_...">...</code></td>
<td>
<p><a href="#topic+Expression-class">Expression</a> objects or matrices. All arguments must have the same dimensions except for axis 2 (columns).</p>
</td></tr>
<tr><td><code id="HStack-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+HStack-class">HStack</a> object.</p>
</td></tr>
<tr><td><code id="HStack-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="HStack-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="HStack-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="HStack-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(HStack)</code>: Horizontally concatenate the values using <code>cbind</code>.
</p>
</li>
<li> <p><code>dim_from_args(HStack)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(HStack)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(HStack)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>validate_args(HStack)</code>: Check all arguments have the same height.
</p>
</li>
<li> <p><code>graph_implementation(HStack)</code>: The graph implementation of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>...</code></dt><dd><p><a href="#topic+Expression-class">Expression</a> objects or matrices. All arguments must have the same dimensions except for axis 2 (columns).</p>
</dd>
</dl>

<hr>
<h2 id='huber'>Huber Function</h2><span id='topic+huber'></span>

<h3>Description</h3>

<p>The elementwise Huber function, <code class="reqn">Huber(x, M) = 1</code>
</p>

<dl>
<dt><code class="reqn">2M|x|-M^2</code></dt><dd><p>for <code class="reqn">|x| \geq |M|</code></p>
</dd>
<dt><code class="reqn">|x|^2</code></dt><dd><p>for <code class="reqn">|x| \leq |M|.</code></p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>huber(x, M = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huber_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="huber_+3A_m">M</code></td>
<td>
<p>(Optional) A positive scalar value representing the threshold. Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the Huber function evaluated at the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
n &lt;- 10
m &lt;- 450
p &lt;- 0.1    # Fraction of responses with sign flipped

# Generate problem data
beta_true &lt;- 5*matrix(stats::rnorm(n), nrow = n)
X &lt;- matrix(stats::rnorm(m*n), nrow = m, ncol = n)
y_true &lt;- X %*% beta_true
eps &lt;- matrix(stats::rnorm(m), nrow = m)

# Randomly flip sign of some responses
factor &lt;- 2*rbinom(m, size = 1, prob = 1-p) - 1
y &lt;- factor * y_true + eps

# Huber regression
beta &lt;- Variable(n)
obj &lt;- sum(huber(y - X %*% beta, 1))
prob &lt;- Problem(Minimize(obj))
result &lt;- solve(prob)
result$getValue(beta)
</code></pre>

<hr>
<h2 id='Huber-class'>The Huber class.</h2><span id='topic+Huber-class'></span><span id='topic+.Huber'></span><span id='topic+Huber'></span><span id='topic+to_numeric+2CHuber-method'></span><span id='topic+sign_from_args+2CHuber-method'></span><span id='topic+is_atom_convex+2CHuber-method'></span><span id='topic+is_atom_concave+2CHuber-method'></span><span id='topic+is_incr+2CHuber-method'></span><span id='topic+is_decr+2CHuber-method'></span><span id='topic+is_quadratic+2CHuber-method'></span><span id='topic+get_data+2CHuber-method'></span><span id='topic+validate_args+2CHuber-method'></span><span id='topic+.grad+2CHuber-method'></span>

<h3>Description</h3>

<p>This class represents the elementwise Huber function, <code class="reqn">Huber(x, M = 1)</code>
</p>

<dl>
<dt><code class="reqn">2M|x|-M^2</code></dt><dd><p>for <code class="reqn">|x| \geq |M|</code></p>
</dd>
<dt><code class="reqn">|x|^2</code></dt><dd><p>for <code class="reqn">|x| \leq |M|.</code></p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>Huber(x, M = 1)

## S4 method for signature 'Huber'
to_numeric(object, values)

## S4 method for signature 'Huber'
sign_from_args(object)

## S4 method for signature 'Huber'
is_atom_convex(object)

## S4 method for signature 'Huber'
is_atom_concave(object)

## S4 method for signature 'Huber'
is_incr(object, idx)

## S4 method for signature 'Huber'
is_decr(object, idx)

## S4 method for signature 'Huber'
is_quadratic(object)

## S4 method for signature 'Huber'
get_data(object)

## S4 method for signature 'Huber'
validate_args(object)

## S4 method for signature 'Huber'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Huber-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
<tr><td><code id="Huber-class_+3A_m">M</code></td>
<td>
<p>A positive scalar value representing the threshold. Defaults to 1.</p>
</td></tr>
<tr><td><code id="Huber-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Huber-class">Huber</a> object.</p>
</td></tr>
<tr><td><code id="Huber-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="Huber-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Huber)</code>: The Huber function evaluted elementwise on the input value.
</p>
</li>
<li> <p><code>sign_from_args(Huber)</code>: The atom is positive.
</p>
</li>
<li> <p><code>is_atom_convex(Huber)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(Huber)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_incr(Huber)</code>: A logical value indicating whether the atom is weakly increasing.
</p>
</li>
<li> <p><code>is_decr(Huber)</code>: A logical value indicating whether the atom is weakly decreasing.
</p>
</li>
<li> <p><code>is_quadratic(Huber)</code>: The atom is quadratic if <code>x</code> is affine.
</p>
</li>
<li> <p><code>get_data(Huber)</code>: A list containing the parameter <code>M</code>.
</p>
</li>
<li> <p><code>validate_args(Huber)</code>: Check that <code>M</code> is a non-negative constant.
</p>
</li>
<li> <p><code>.grad(Huber)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</dd>
<dt><code>M</code></dt><dd><p>A positive scalar value representing the threshold. Defaults to 1.</p>
</dd>
</dl>

<hr>
<h2 id='id'>Identification Number</h2><span id='topic+id'></span>

<h3>Description</h3>

<p>A unique identification number used internally to keep track of variables and constraints. Should not be modified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Variable-class">Variable</a> or <a href="#topic+Constraint-class">Constraint</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A non-negative integer identifier.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_id">get_id</a></code> <code><a href="#topic+setIdCounter">setIdCounter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable()
constr &lt;- (x &gt;= 5)
id(x)
id(constr)
</code></pre>

<hr>
<h2 id='Imag-class'>The Imag class.</h2><span id='topic+Imag-class'></span><span id='topic+.Imag'></span><span id='topic+Imag'></span><span id='topic+to_numeric+2CImag-method'></span><span id='topic+dim_from_args+2CImag-method'></span><span id='topic+is_imag+2CImag-method'></span><span id='topic+is_complex+2CImag-method'></span><span id='topic+is_symmetric+2CImag-method'></span>

<h3>Description</h3>

<p>This class represents the imaginary part of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Imag(expr)

## S4 method for signature 'Imag'
to_numeric(object, values)

## S4 method for signature 'Imag'
dim_from_args(object)

## S4 method for signature 'Imag'
is_imag(object)

## S4 method for signature 'Imag'
is_complex(object)

## S4 method for signature 'Imag'
is_symmetric(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Imag-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</td></tr>
<tr><td><code id="Imag-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Imag-class">Imag</a> object.</p>
</td></tr>
<tr><td><code id="Imag-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Imag)</code>: The imaginary part of the given value.
</p>
</li>
<li> <p><code>dim_from_args(Imag)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>is_imag(Imag)</code>: Is the atom imaginary?
</p>
</li>
<li> <p><code>is_complex(Imag)</code>: Is the atom complex valued?
</p>
</li>
<li> <p><code>is_symmetric(Imag)</code>: Is the atom symmetric?
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</dd>
</dl>

<hr>
<h2 id='import_solver'>Import Solver</h2><span id='topic+import_solver'></span>

<h3>Description</h3>

<p>Import the R library that interfaces with the specified solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_solver(solver)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_solver_+3A_solver">solver</code></td>
<td>
<p>A <a href="#topic+ReductionSolver-class">ReductionSolver</a> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>import_solver(ECOS())
import_solver(SCS())
</code></pre>

<hr>
<h2 id='installed_solvers'>List installed solvers</h2><span id='topic+installed_solvers'></span><span id='topic+add_to_solver_blacklist'></span><span id='topic+remove_from_solver_blacklist'></span><span id='topic+set_solver_blacklist'></span>

<h3>Description</h3>

<p>List available solvers, taking currently blacklisted solvers into
account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>installed_solvers()

add_to_solver_blacklist(solvers)

remove_from_solver_blacklist(solvers)

set_solver_blacklist(solvers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="installed_solvers_+3A_solvers">solvers</code></td>
<td>
<p>a character vector of solver names, default <code>character(0)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The names of all the installed solvers as a character vector.
</p>
<p>The current blacklist (character vector), invisibly.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>add_to_solver_blacklist()</code>: Add to solver blacklist, useful for temporarily disabling a solver
</p>
</li>
<li> <p><code>remove_from_solver_blacklist()</code>: Remove solvers from blacklist
</p>
</li>
<li> <p><code>set_solver_blacklist()</code>: Set solver blacklist to a value
</p>
</li></ul>

<hr>
<h2 id='inv_pos'>Reciprocal Function</h2><span id='topic+inv_pos'></span>

<h3>Description</h3>

<p>The elementwise reciprocal function, <code class="reqn">\frac{1}{x}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_pos(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_pos_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the reciprocal of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Variable(2,2)
val &lt;- cbind(c(1,2), c(3,4))
prob &lt;- Problem(Minimize(inv_pos(A)[1,2]), list(A == val))
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='InverseData-class'>The InverseData class.</h2><span id='topic+InverseData-class'></span><span id='topic+.InverseData'></span>

<h3>Description</h3>

<p>This class represents the data encoding an optimization problem.
</p>

<hr>
<h2 id='invert'>Return Original Solution</h2><span id='topic+invert'></span>

<h3>Description</h3>

<p>Returns a solution to the original problem given the inverse data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Reduction-class">Reduction</a> object.</p>
</td></tr>
<tr><td><code id="invert_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> to a problem that generated <code>inverse_data</code>.</p>
</td></tr>
<tr><td><code id="invert_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A <a href="#topic+InverseData-class">InverseData</a> object encoding the original problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Solution-class">Solution</a> to the original problem.
</p>

<hr>
<h2 id='is_dcp'>DCP Compliance</h2><span id='topic+is_dcp'></span>

<h3>Description</h3>

<p>Determine if a problem or expression complies with the disciplined convex programming rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_dcp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_dcp_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> or <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the problem or expression is DCP compliant, i.e. no unknown curvatures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable()
prob &lt;- Problem(Minimize(x^2), list(x &gt;= 5))
is_dcp(prob)
solve(prob)
</code></pre>

<hr>
<h2 id='is_dgp'>DGP Compliance</h2><span id='topic+is_dgp'></span>

<h3>Description</h3>

<p>Determine if a problem or expression complies with the disciplined geometric programming rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_dgp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_dgp_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> or <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the problem or expression is DCP compliant, i.e. no unknown curvatures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(pos = TRUE)
y &lt;- Variable(pos = TRUE)
prob &lt;- Problem(Minimize(x*y), list(x &gt;= 5, y &gt;= 5))
is_dgp(prob)
solve(prob, gp = TRUE)
</code></pre>

<hr>
<h2 id='is_mixed_integer'>Is Problem Mixed Integer?</h2><span id='topic+is_mixed_integer'></span>

<h3>Description</h3>

<p>Determine if a problem is a mixed-integer program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mixed_integer(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_mixed_integer_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the problem is a mixed-integer program
</p>

<hr>
<h2 id='is_qp'>Is Problem a QP?</h2><span id='topic+is_qp'></span>

<h3>Description</h3>

<p>Determine if a problem is a quadratic program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_qp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_qp_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the problem is a quadratic program.
</p>

<hr>
<h2 id='is_stuffed_cone_constraint'>Is the constraint a stuffed cone constraint?</h2><span id='topic+is_stuffed_cone_constraint'></span>

<h3>Description</h3>

<p>Is the constraint a stuffed cone constraint?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_stuffed_cone_constraint(constraint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_stuffed_cone_constraint_+3A_constraint">constraint</code></td>
<td>
<p>A <a href="#topic+Constraint-class">Constraint</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Is the constraint a stuffed-cone constraint?
</p>

<hr>
<h2 id='is_stuffed_cone_objective'>Is the objective a stuffed cone objective?</h2><span id='topic+is_stuffed_cone_objective'></span>

<h3>Description</h3>

<p>Is the objective a stuffed cone objective?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_stuffed_cone_objective(objective)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_stuffed_cone_objective_+3A_objective">objective</code></td>
<td>
<p>An <a href="#topic+Objective-class">Objective</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Is the objective a stuffed-cone objective?
</p>

<hr>
<h2 id='is_stuffed_qp_objective'>Is the QP objective stuffed?</h2><span id='topic+is_stuffed_qp_objective'></span>

<h3>Description</h3>

<p>Is the QP objective stuffed?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_stuffed_qp_objective(objective)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_stuffed_qp_objective_+3A_objective">objective</code></td>
<td>
<p>A <a href="#topic+Minimize-class">Minimize</a> or <a href="#topic+Maximize-class">Maximize</a> object representing the optimization objective.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Is the objective a stuffed QP?
</p>

<hr>
<h2 id='kl_div'>Kullback-Leibler Divergence</h2><span id='topic+kl_div'></span>

<h3>Description</h3>

<p>The elementwise Kullback-Leibler divergence, <code class="reqn">x\log(x/y) - x + y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kl_div(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kl_div_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="kl_div_+3A_y">y</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the KL-divergence of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
alpha &lt;- seq(10, n-1+10)/n
beta &lt;- seq(10, n-1+10)/n
P_tot &lt;- 0.5
W_tot &lt;- 1.0

P &lt;- Variable(n)
W &lt;- Variable(n)
R &lt;- kl_div(alpha*W, alpha*(W + beta*P)) - alpha*beta*P
obj &lt;- sum(R)
constr &lt;- list(P &gt;= 0, W &gt;= 0, sum(P) == P_tot, sum(W) == W_tot)
prob &lt;- Problem(Minimize(obj), constr)
result &lt;- solve(prob)

result$value
result$getValue(P)
result$getValue(W)
</code></pre>

<hr>
<h2 id='KLDiv-class'>The KLDiv class.</h2><span id='topic+KLDiv-class'></span><span id='topic+.KLDiv'></span><span id='topic+KLDiv'></span><span id='topic+to_numeric+2CKLDiv-method'></span><span id='topic+sign_from_args+2CKLDiv-method'></span><span id='topic+is_atom_convex+2CKLDiv-method'></span><span id='topic+is_atom_concave+2CKLDiv-method'></span><span id='topic+is_incr+2CKLDiv-method'></span><span id='topic+is_decr+2CKLDiv-method'></span><span id='topic+.grad+2CKLDiv-method'></span><span id='topic+.domain+2CKLDiv-method'></span>

<h3>Description</h3>

<p>The elementwise KL-divergence <code class="reqn">x\log(x/y) - x + y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KLDiv(x, y)

## S4 method for signature 'KLDiv'
to_numeric(object, values)

## S4 method for signature 'KLDiv'
sign_from_args(object)

## S4 method for signature 'KLDiv'
is_atom_convex(object)

## S4 method for signature 'KLDiv'
is_atom_concave(object)

## S4 method for signature 'KLDiv'
is_incr(object, idx)

## S4 method for signature 'KLDiv'
is_decr(object, idx)

## S4 method for signature 'KLDiv'
.grad(object, values)

## S4 method for signature 'KLDiv'
.domain(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KLDiv-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</td></tr>
<tr><td><code id="KLDiv-class_+3A_y">y</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</td></tr>
<tr><td><code id="KLDiv-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+KLDiv-class">KLDiv</a> object.</p>
</td></tr>
<tr><td><code id="KLDiv-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="KLDiv-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(KLDiv)</code>: The KL-divergence evaluted elementwise on the input value.
</p>
</li>
<li> <p><code>sign_from_args(KLDiv)</code>: The atom is positive.
</p>
</li>
<li> <p><code>is_atom_convex(KLDiv)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(KLDiv)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_incr(KLDiv)</code>: The atom is not monotonic in any argument.
</p>
</li>
<li> <p><code>is_decr(KLDiv)</code>: The atom is not monotonic in any argument.
</p>
</li>
<li> <p><code>.grad(KLDiv)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.domain(KLDiv)</code>: Returns constraints describng the domain of the node
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</dd>
<dt><code>y</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</dd>
</dl>

<hr>
<h2 id='Kron-class'>The Kron class.</h2><span id='topic+Kron-class'></span><span id='topic+.Kron'></span><span id='topic+Kron'></span><span id='topic+to_numeric+2CKron-method'></span><span id='topic+validate_args+2CKron-method'></span><span id='topic+dim_from_args+2CKron-method'></span><span id='topic+sign_from_args+2CKron-method'></span><span id='topic+is_incr+2CKron-method'></span><span id='topic+is_decr+2CKron-method'></span><span id='topic+graph_implementation+2CKron-method'></span>

<h3>Description</h3>

<p>This class represents the kronecker product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kron(lh_exp, rh_exp)

## S4 method for signature 'Kron'
to_numeric(object, values)

## S4 method for signature 'Kron'
validate_args(object)

## S4 method for signature 'Kron'
dim_from_args(object)

## S4 method for signature 'Kron'
sign_from_args(object)

## S4 method for signature 'Kron'
is_incr(object, idx)

## S4 method for signature 'Kron'
is_decr(object, idx)

## S4 method for signature 'Kron'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kron-class_+3A_lh_exp">lh_exp</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric constant representing the left-hand matrix.</p>
</td></tr>
<tr><td><code id="Kron-class_+3A_rh_exp">rh_exp</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric constant representing the right-hand matrix.</p>
</td></tr>
<tr><td><code id="Kron-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Kron-class">Kron</a> object.</p>
</td></tr>
<tr><td><code id="Kron-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="Kron-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="Kron-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="Kron-class_+3A_dim">dim</code></td>
<td>
<p>A vector with two elements representing the size of the resulting expression.</p>
</td></tr>
<tr><td><code id="Kron-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Kron)</code>: The kronecker product of the two values.
</p>
</li>
<li> <p><code>validate_args(Kron)</code>: Check both arguments are vectors and the first is a constant.
</p>
</li>
<li> <p><code>dim_from_args(Kron)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>sign_from_args(Kron)</code>: The sign of the atom.
</p>
</li>
<li> <p><code>is_incr(Kron)</code>: Is the left-hand expression positive?
</p>
</li>
<li> <p><code>is_decr(Kron)</code>: Is the right-hand expression negative?
</p>
</li>
<li> <p><code>graph_implementation(Kron)</code>: The graph implementation of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>lh_exp</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric constant representing the left-hand matrix.</p>
</dd>
<dt><code>rh_exp</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric constant representing the right-hand matrix.</p>
</dd>
</dl>

<hr>
<h2 id='kronecker+2CExpression+2CANY-method'>Kronecker Product</h2><span id='topic+kronecker+2CExpression+2CANY-method'></span><span id='topic+kronecker'></span><span id='topic++25x+25'></span><span id='topic+kronecker+2CANY+2CExpression-method'></span>

<h3>Description</h3>

<p>The generalized kronecker product of two matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression,ANY'
kronecker(X, Y, FUN = "*", make.dimnames = FALSE, ...)

## S4 method for signature 'ANY,Expression'
kronecker(X, Y, FUN = "*", make.dimnames = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kronecker+2B2CExpression+2B2CANY-method_+3A_x">X</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
<tr><td><code id="kronecker+2B2CExpression+2B2CANY-method_+3A_y">Y</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
<tr><td><code id="kronecker+2B2CExpression+2B2CANY-method_+3A_fun">FUN</code></td>
<td>
<p>Hardwired to &quot;*&quot; for the kronecker product.</p>
</td></tr>
<tr><td><code id="kronecker+2B2CExpression+2B2CANY-method_+3A_make.dimnames">make.dimnames</code></td>
<td>
<p>(Unimplemented) Dimension names are not supported in <a href="#topic+Expression-class">Expression</a> objects.</p>
</td></tr>
<tr><td><code id="kronecker+2B2CExpression+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>(Unimplemented) Optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> that represents the kronecker product.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- cbind(c(1,2), c(3,4))
Y &lt;- Variable(2,2)
val &lt;- cbind(c(5,6), c(7,8))

obj &lt;- X %x% Y
prob &lt;- Problem(Minimize(kronecker(X,Y)[1,1]), list(Y == val))
result &lt;- solve(prob)
result$value
result$getValue(kronecker(X,Y))
</code></pre>

<hr>
<h2 id='lambda_max'>Maximum Eigenvalue</h2><span id='topic+lambda_max'></span>

<h3>Description</h3>

<p>The maximum eigenvalue of a matrix, <code class="reqn">\lambda_{\max}(A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_max(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_max_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the maximum eigenvalue of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Variable(2,2)
prob &lt;- Problem(Minimize(lambda_max(A)), list(A &gt;= 2))
result &lt;- solve(prob)
result$value
result$getValue(A)

obj &lt;- Maximize(A[2,1] - A[1,2])
prob &lt;- Problem(obj, list(lambda_max(A) &lt;= 100, A[1,1] == 2, A[2,2] == 2, A[2,1] == 2))
result &lt;- solve(prob)
result$value
result$getValue(A)
</code></pre>

<hr>
<h2 id='lambda_min'>Minimum Eigenvalue</h2><span id='topic+lambda_min'></span>

<h3>Description</h3>

<p>The minimum eigenvalue of a matrix, <code class="reqn">\lambda_{\min}(A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_min(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_min_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the minimum eigenvalue of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Variable(2,2)
val &lt;- cbind(c(5,7), c(7,-3))
prob &lt;- Problem(Maximize(lambda_min(A)), list(A == val))
result &lt;- solve(prob)
result$value
result$getValue(A)
</code></pre>

<hr>
<h2 id='lambda_sum_largest'>Sum of Largest Eigenvalues</h2><span id='topic+lambda_sum_largest'></span>

<h3>Description</h3>

<p>The sum of the largest <code class="reqn">k</code> eigenvalues of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_sum_largest(A, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_sum_largest_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
<tr><td><code id="lambda_sum_largest_+3A_k">k</code></td>
<td>
<p>The number of eigenvalues to sum over.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the sum of the largest <code>k</code> eigenvalues of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- Variable(3,3)
val &lt;- cbind(c(1,2,3), c(2,4,5), c(3,5,6))
prob &lt;- Problem(Minimize(lambda_sum_largest(C,2)), list(C == val))
result &lt;- solve(prob)
result$value
result$getValue(C)
</code></pre>

<hr>
<h2 id='lambda_sum_smallest'>Sum of Smallest Eigenvalues</h2><span id='topic+lambda_sum_smallest'></span>

<h3>Description</h3>

<p>The sum of the smallest <code class="reqn">k</code> eigenvalues of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_sum_smallest(A, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_sum_smallest_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
<tr><td><code id="lambda_sum_smallest_+3A_k">k</code></td>
<td>
<p>The number of eigenvalues to sum over.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the sum of the smallest <code>k</code> eigenvalues of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- Variable(3,3)
val &lt;- cbind(c(1,2,3), c(2,4,5), c(3,5,6))
prob &lt;- Problem(Maximize(lambda_sum_smallest(C,2)), list(C == val))
result &lt;- solve(prob)
result$value
result$getValue(C)
</code></pre>

<hr>
<h2 id='LambdaMax-class'>The LambdaMax class.</h2><span id='topic+LambdaMax-class'></span><span id='topic+.LambdaMax'></span><span id='topic+LambdaMax'></span><span id='topic+to_numeric+2CLambdaMax-method'></span><span id='topic+.domain+2CLambdaMax-method'></span><span id='topic+.grad+2CLambdaMax-method'></span><span id='topic+validate_args+2CLambdaMax-method'></span><span id='topic+dim_from_args+2CLambdaMax-method'></span><span id='topic+sign_from_args+2CLambdaMax-method'></span><span id='topic+is_atom_convex+2CLambdaMax-method'></span><span id='topic+is_atom_concave+2CLambdaMax-method'></span><span id='topic+is_incr+2CLambdaMax-method'></span><span id='topic+is_decr+2CLambdaMax-method'></span>

<h3>Description</h3>

<p>The maximum eigenvalue of a matrix, <code class="reqn">\lambda_{\max}(A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LambdaMax(A)

## S4 method for signature 'LambdaMax'
to_numeric(object, values)

## S4 method for signature 'LambdaMax'
.domain(object)

## S4 method for signature 'LambdaMax'
.grad(object, values)

## S4 method for signature 'LambdaMax'
validate_args(object)

## S4 method for signature 'LambdaMax'
dim_from_args(object)

## S4 method for signature 'LambdaMax'
sign_from_args(object)

## S4 method for signature 'LambdaMax'
is_atom_convex(object)

## S4 method for signature 'LambdaMax'
is_atom_concave(object)

## S4 method for signature 'LambdaMax'
is_incr(object, idx)

## S4 method for signature 'LambdaMax'
is_decr(object, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LambdaMax-class_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="LambdaMax-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+LambdaMax-class">LambdaMax</a> object.</p>
</td></tr>
<tr><td><code id="LambdaMax-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="LambdaMax-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(LambdaMax)</code>: The largest eigenvalue of <code>A</code>. Requires that <code>A</code> be symmetric.
</p>
</li>
<li> <p><code>.domain(LambdaMax)</code>: Returns the constraints describing the domain of the atom.
</p>
</li>
<li> <p><code>.grad(LambdaMax)</code>: Gives the (sub/super)gradient of the atom with respect to each argument. Matrix expressions are vectorized, so the gradient is a matrix.
</p>
</li>
<li> <p><code>validate_args(LambdaMax)</code>: Check that <code>A</code> is square.
</p>
</li>
<li> <p><code>dim_from_args(LambdaMax)</code>: The atom is a scalar.
</p>
</li>
<li> <p><code>sign_from_args(LambdaMax)</code>: The sign of the atom is unknown.
</p>
</li>
<li> <p><code>is_atom_convex(LambdaMax)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(LambdaMax)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_incr(LambdaMax)</code>: The atom is not monotonic in any argument.
</p>
</li>
<li> <p><code>is_decr(LambdaMax)</code>: The atom is not monotonic in any argument.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>A</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='LambdaMin'>The LambdaMin atom.</h2><span id='topic+LambdaMin'></span>

<h3>Description</h3>

<p>The minimum eigenvalue of a matrix, <code class="reqn">\lambda_{\min}(A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LambdaMin(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LambdaMin_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the minimum eigenvalue of a matrix.
</p>

<hr>
<h2 id='LambdaSumLargest-class'>The LambdaSumLargest class.</h2><span id='topic+LambdaSumLargest-class'></span><span id='topic+.LambdaSumLargest'></span><span id='topic+LambdaSumLargest'></span><span id='topic+allow_complex+2CLambdaSumLargest-method'></span><span id='topic+to_numeric+2CLambdaSumLargest-method'></span><span id='topic+validate_args+2CLambdaSumLargest-method'></span><span id='topic+get_data+2CLambdaSumLargest-method'></span><span id='topic+.grad+2CLambdaSumLargest-method'></span>

<h3>Description</h3>

<p>This class represents the sum of the <code>k</code> largest eigenvalues of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LambdaSumLargest(A, k)

## S4 method for signature 'LambdaSumLargest'
allow_complex(object)

## S4 method for signature 'LambdaSumLargest'
to_numeric(object, values)

## S4 method for signature 'LambdaSumLargest'
validate_args(object)

## S4 method for signature 'LambdaSumLargest'
get_data(object)

## S4 method for signature 'LambdaSumLargest'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LambdaSumLargest-class_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="LambdaSumLargest-class_+3A_k">k</code></td>
<td>
<p>A positive integer.</p>
</td></tr>
<tr><td><code id="LambdaSumLargest-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+LambdaSumLargest-class">LambdaSumLargest</a> object.</p>
</td></tr>
<tr><td><code id="LambdaSumLargest-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>allow_complex(LambdaSumLargest)</code>: Does the atom handle complex numbers?
</p>
</li>
<li> <p><code>to_numeric(LambdaSumLargest)</code>: Returns the largest eigenvalue of <code>A</code>, which must be symmetric.
</p>
</li>
<li> <p><code>validate_args(LambdaSumLargest)</code>: Verify that the argument <code>A</code> is square.
</p>
</li>
<li> <p><code>get_data(LambdaSumLargest)</code>: Returns the parameter <code>k</code>.
</p>
</li>
<li> <p><code>.grad(LambdaSumLargest)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>k</code></dt><dd><p>A positive integer.</p>
</dd>
</dl>

<hr>
<h2 id='LambdaSumSmallest'>The LambdaSumSmallest atom.</h2><span id='topic+LambdaSumSmallest'></span>

<h3>Description</h3>

<p>This class represents the sum of the <code>k</code> smallest eigenvalues of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LambdaSumSmallest(A, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LambdaSumSmallest_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="LambdaSumSmallest_+3A_k">k</code></td>
<td>
<p>A positive integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the sum of the k smallest eigenvalues of a matrix.
</p>

<hr>
<h2 id='leaf-attr'>Attributes of an Expression Leaf</h2><span id='topic+leaf-attr'></span><span id='topic+is_pos'></span><span id='topic+is_neg'></span>

<h3>Description</h3>

<p>Determine if an expression is positive or negative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_pos(object)

is_neg(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaf-attr_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Leaf-class">Leaf</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>

<hr>
<h2 id='Leaf-class'>The Leaf class.</h2><span id='topic+Leaf-class'></span><span id='topic+Leaf'></span><span id='topic+get_data+2CLeaf-method'></span><span id='topic+dim+2CLeaf-method'></span><span id='topic+variables+2CLeaf-method'></span><span id='topic+parameters+2CLeaf-method'></span><span id='topic+constants+2CLeaf-method'></span><span id='topic+atoms+2CLeaf-method'></span><span id='topic+is_convex+2CLeaf-method'></span><span id='topic+is_concave+2CLeaf-method'></span><span id='topic+is_log_log_convex+2CLeaf-method'></span><span id='topic+is_log_log_concave+2CLeaf-method'></span><span id='topic+is_nonneg+2CLeaf-method'></span><span id='topic+is_nonpos+2CLeaf-method'></span><span id='topic+is_pos+2CLeaf-method'></span><span id='topic+is_neg+2CLeaf-method'></span><span id='topic+is_hermitian+2CLeaf-method'></span><span id='topic+is_symmetric+2CLeaf-method'></span><span id='topic+is_imag+2CLeaf-method'></span><span id='topic+is_complex+2CLeaf-method'></span><span id='topic+domain+2CLeaf-method'></span><span id='topic+project+2CLeaf-method'></span><span id='topic+project_and_assign+2CLeaf-method'></span><span id='topic+value+2CLeaf-method'></span><span id='topic+value+3C-+2CLeaf-method'></span><span id='topic+validate_val+2CLeaf-method'></span><span id='topic+is_psd+2CLeaf-method'></span><span id='topic+is_nsd+2CLeaf-method'></span><span id='topic+is_quadratic+2CLeaf-method'></span><span id='topic+is_pwl+2CLeaf-method'></span>

<h3>Description</h3>

<p>This class represents a leaf node, i.e. a Variable, Constant, or Parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Leaf'
get_data(object)

## S4 method for signature 'Leaf'
dim(x)

## S4 method for signature 'Leaf'
variables(object)

## S4 method for signature 'Leaf'
parameters(object)

## S4 method for signature 'Leaf'
constants(object)

## S4 method for signature 'Leaf'
atoms(object)

## S4 method for signature 'Leaf'
is_convex(object)

## S4 method for signature 'Leaf'
is_concave(object)

## S4 method for signature 'Leaf'
is_log_log_convex(object)

## S4 method for signature 'Leaf'
is_log_log_concave(object)

## S4 method for signature 'Leaf'
is_nonneg(object)

## S4 method for signature 'Leaf'
is_nonpos(object)

## S4 method for signature 'Leaf'
is_pos(object)

## S4 method for signature 'Leaf'
is_neg(object)

## S4 method for signature 'Leaf'
is_hermitian(object)

## S4 method for signature 'Leaf'
is_symmetric(object)

## S4 method for signature 'Leaf'
is_imag(object)

## S4 method for signature 'Leaf'
is_complex(object)

## S4 method for signature 'Leaf'
domain(object)

## S4 method for signature 'Leaf'
project(object, value)

## S4 method for signature 'Leaf'
project_and_assign(object, value)

## S4 method for signature 'Leaf'
value(object)

## S4 replacement method for signature 'Leaf'
value(object) &lt;- value

## S4 method for signature 'Leaf'
validate_val(object, val)

## S4 method for signature 'Leaf'
is_psd(object)

## S4 method for signature 'Leaf'
is_nsd(object)

## S4 method for signature 'Leaf'
is_quadratic(object)

## S4 method for signature 'Leaf'
is_pwl(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Leaf-class_+3A_object">object</code>, <code id="Leaf-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Leaf-class">Leaf</a> object.</p>
</td></tr>
<tr><td><code id="Leaf-class_+3A_value">value</code></td>
<td>
<p>A numeric scalar, vector, or matrix.</p>
</td></tr>
<tr><td><code id="Leaf-class_+3A_val">val</code></td>
<td>
<p>The assigned value.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>get_data(Leaf)</code>: Leaves are not copied.
</p>
</li>
<li> <p><code>dim(Leaf)</code>: The dimensions of the leaf node.
</p>
</li>
<li> <p><code>variables(Leaf)</code>: List of <a href="#topic+Variable-class">Variable</a> objects in the leaf node.
</p>
</li>
<li> <p><code>parameters(Leaf)</code>: List of <a href="#topic+Parameter-class">Parameter</a> objects in the leaf node.
</p>
</li>
<li> <p><code>constants(Leaf)</code>: List of <a href="#topic+Constant-class">Constant</a> objects in the leaf node.
</p>
</li>
<li> <p><code>atoms(Leaf)</code>: List of <a href="#topic+Atom-class">Atom</a> objects in the leaf node.
</p>
</li>
<li> <p><code>is_convex(Leaf)</code>: A logical value indicating whether the leaf node is convex.
</p>
</li>
<li> <p><code>is_concave(Leaf)</code>: A logical value indicating whether the leaf node is concave.
</p>
</li>
<li> <p><code>is_log_log_convex(Leaf)</code>: Is the expression log-log convex?
</p>
</li>
<li> <p><code>is_log_log_concave(Leaf)</code>: Is the expression log-log concave?
</p>
</li>
<li> <p><code>is_nonneg(Leaf)</code>: A logical value indicating whether the leaf node is nonnegative.
</p>
</li>
<li> <p><code>is_nonpos(Leaf)</code>: A logical value indicating whether the leaf node is nonpositive.
</p>
</li>
<li> <p><code>is_pos(Leaf)</code>: Is the expression positive?
</p>
</li>
<li> <p><code>is_neg(Leaf)</code>: Is the expression negative?
</p>
</li>
<li> <p><code>is_hermitian(Leaf)</code>: A logical value indicating whether the leaf node is hermitian.
</p>
</li>
<li> <p><code>is_symmetric(Leaf)</code>: A logical value indicating whether the leaf node is symmetric.
</p>
</li>
<li> <p><code>is_imag(Leaf)</code>: A logical value indicating whether the leaf node is imaginary.
</p>
</li>
<li> <p><code>is_complex(Leaf)</code>: A logical value indicating whether the leaf node is complex.
</p>
</li>
<li> <p><code>domain(Leaf)</code>: A list of constraints describing the closure of the region where the leaf node is finite. Default is the full domain.
</p>
</li>
<li> <p><code>project(Leaf)</code>: Project value onto the attribute set of the leaf.
</p>
</li>
<li> <p><code>project_and_assign(Leaf)</code>: Project and assign a value to the leaf.
</p>
</li>
<li> <p><code>value(Leaf)</code>: Get the value of the leaf.
</p>
</li>
<li> <p><code>value(Leaf) &lt;- value</code>: Set the value of the leaf.
</p>
</li>
<li> <p><code>validate_val(Leaf)</code>: Check that <code>val</code> satisfies symbolic attributes of leaf.
</p>
</li>
<li> <p><code>is_psd(Leaf)</code>: A logical value indicating whether the leaf node is a positive semidefinite matrix.
</p>
</li>
<li> <p><code>is_nsd(Leaf)</code>: A logical value indicating whether the leaf node is a negative semidefinite matrix.
</p>
</li>
<li> <p><code>is_quadratic(Leaf)</code>: Leaf nodes are always quadratic.
</p>
</li>
<li> <p><code>is_pwl(Leaf)</code>: Leaf nodes are always piecewise linear.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>id</code></dt><dd><p>(Internal) A unique integer identification number used internally.</p>
</dd>
<dt><code>dim</code></dt><dd><p>The dimensions of the leaf.</p>
</dd>
<dt><code>value</code></dt><dd><p>The numeric value of the leaf.</p>
</dd>
<dt><code>nonneg</code></dt><dd><p>Is the leaf nonnegative?</p>
</dd>
<dt><code>nonpos</code></dt><dd><p>Is the leaf nonpositive?</p>
</dd>
<dt><code>complex</code></dt><dd><p>Is the leaf a complex number?</p>
</dd>
<dt><code>imag</code></dt><dd><p>Is the leaf imaginary?</p>
</dd>
<dt><code>symmetric</code></dt><dd><p>Is the leaf a symmetric matrix?</p>
</dd>
<dt><code>diag</code></dt><dd><p>Is the leaf a diagonal matrix?</p>
</dd>
<dt><code>PSD</code></dt><dd><p>Is the leaf positive semidefinite?</p>
</dd>
<dt><code>NSD</code></dt><dd><p>Is the leaf negative semidefinite?</p>
</dd>
<dt><code>hermitian</code></dt><dd><p>Is the leaf hermitian?</p>
</dd>
<dt><code>boolean</code></dt><dd><p>Is the leaf boolean? Is the variable boolean? May be <code>TRUE</code> = entire leaf is boolean, <code>FALSE</code> = entire leaf is not boolean, or a vector of
indices which should be constrained as boolean, where each index is a vector of length exactly equal to the length of <code>dim</code>.</p>
</dd>
<dt><code>integer</code></dt><dd><p>Is the leaf integer? The semantics are the same as the <code>boolean</code> argument.</p>
</dd>
<dt><code>sparsity</code></dt><dd><p>A matrix representing the fixed sparsity pattern of the leaf.</p>
</dd>
<dt><code>pos</code></dt><dd><p>Is the leaf strictly positive?</p>
</dd>
<dt><code>neg</code></dt><dd><p>Is the leaf strictly negative?</p>
</dd>
</dl>

<hr>
<h2 id='linearize'>Affine Approximation to an Expression</h2><span id='topic+linearize'></span>

<h3>Description</h3>

<p>Gives an elementwise lower (upper) bound for convex (concave) expressions that is tight
at the current variable/parameter values. No guarantees for non-DCP expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearize(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearize_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> to linearize.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If f and g are convex, the objective f-g can be (heuristically) minimized using the
implementation below of the convex-concave method:
</p>
<p><code>for(iters in 1:N)
   solve(Problem(Minimize(f - linearize(g))))</code>
</p>


<h3>Value</h3>

<p>An affine expression or <code>NA</code> if cannot be linearized.
</p>

<hr>
<h2 id='ListORConstr-class'>A Class Union of List and Constraint</h2><span id='topic+ListORConstr-class'></span><span id='topic+id+2CListORConstr-method'></span>

<h3>Description</h3>

<p>A Class Union of List and Constraint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ListORConstr'
id(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ListORConstr-class_+3A_object">object</code></td>
<td>
<p>A list or <a href="#topic+Constraint-class">Constraint</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>id(ListORConstr)</code>: Returns the ID associated with the list or constraint.
</p>
</li></ul>

<hr>
<h2 id='log_det'>Log-Determinant</h2><span id='topic+log_det'></span>

<h3>Description</h3>

<p>The natural logarithm of the determinant of a matrix, <code class="reqn">\log\det(A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_det(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_det_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the log-determinant of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- t(data.frame(c(0.55, 0.25, -0.2, -0.25, -0.0, 0.4),
                  c(0.0, 0.35, 0.2, -0.1, -0.3, -0.2)))
n &lt;- nrow(x)
m &lt;- ncol(x)

A &lt;- Variable(n,n)
b &lt;- Variable(n)
obj &lt;- Maximize(log_det(A))
constr &lt;- lapply(1:m, function(i) { p_norm(A %*% as.matrix(x[,i]) + b) &lt;= 1 })
prob &lt;- Problem(obj, constr)
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='log_log_curvature'>Log-Log Curvature of Expression</h2><span id='topic+log_log_curvature'></span><span id='topic+log_log_curvature+2CExpression-method'></span>

<h3>Description</h3>

<p>The log-log curvature of an expression.
</p>
<p>The log-log curvature of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_log_curvature(object)

## S4 method for signature 'Expression'
log_log_curvature(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_log_curvature_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string indicating the log-log curvature of the expression, either &quot;LOG_LOG_CONSTANT&quot;, &quot;LOG_LOG_AFFINE&quot;, &quot;LOG_LOG_CONVEX, &quot;LOG_LOG_CONCAVE&quot;, or &quot;UNKNOWN&quot;.
</p>
<p>A string indicating the log-log curvature of the expression, either &quot;LOG_LOG_CONSTANT&quot;, &quot;LOG_LOG_AFFINE&quot;, &quot;LOG_LOG_CONVEX&quot;, &quot;LOG_LOG_CONCAVE&quot;, or &quot;UNKNOWN&quot;.
</p>

<hr>
<h2 id='log_log_curvature-atom'>Log-Log Curvature of an Atom</h2><span id='topic+log_log_curvature-atom'></span><span id='topic+is_atom_log_log_convex'></span><span id='topic+is_atom_log_log_concave'></span><span id='topic+is_atom_log_log_affine'></span>

<h3>Description</h3>

<p>Determine if an atom is log-log convex, concave, or affine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_atom_log_log_convex(object)

is_atom_log_log_concave(object)

is_atom_log_log_affine(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_log_curvature-atom_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Atom-class">Atom</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>

<hr>
<h2 id='log_log_curvature-methods'>Log-Log Curvature Properties</h2><span id='topic+log_log_curvature-methods'></span><span id='topic+is_log_log_constant'></span><span id='topic+is_log_log_affine'></span><span id='topic+is_log_log_convex'></span><span id='topic+is_log_log_concave'></span>

<h3>Description</h3>

<p>Determine if an expression is log-log constant, log-log affine, log-log convex, or log-log concave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_log_log_constant(object)

is_log_log_affine(object)

is_log_log_convex(object)

is_log_log_concave(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_log_curvature-methods_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>

<hr>
<h2 id='log_sum_exp'>Log-Sum-Exponential</h2><span id='topic+log_sum_exp'></span>

<h3>Description</h3>

<p>The natural logarithm of the sum of the elementwise exponential, <code class="reqn">\log\sum_{i=1}^n e^{x_i}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_sum_exp(x, axis = NA_real_, keepdims = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_sum_exp_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="log_sum_exp_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="log_sum_exp_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the log-sum-exponential of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Variable(2,2)
val &lt;- cbind(c(5,7), c(0,-3))
prob &lt;- Problem(Minimize(log_sum_exp(A)), list(A == val))
result &lt;- solve(prob)
result$getValue(A)
</code></pre>

<hr>
<h2 id='Log-class'>The Log class.</h2><span id='topic+Log-class'></span><span id='topic+.Log'></span><span id='topic+Log'></span><span id='topic+to_numeric+2CLog-method'></span><span id='topic+sign_from_args+2CLog-method'></span><span id='topic+is_atom_convex+2CLog-method'></span><span id='topic+is_atom_concave+2CLog-method'></span><span id='topic+is_atom_log_log_convex+2CLog-method'></span><span id='topic+is_atom_log_log_concave+2CLog-method'></span><span id='topic+is_incr+2CLog-method'></span><span id='topic+is_decr+2CLog-method'></span><span id='topic+.grad+2CLog-method'></span><span id='topic+.domain+2CLog-method'></span>

<h3>Description</h3>

<p>This class represents the elementwise natural logarithm <code class="reqn">\log(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Log(x)

## S4 method for signature 'Log'
to_numeric(object, values)

## S4 method for signature 'Log'
sign_from_args(object)

## S4 method for signature 'Log'
is_atom_convex(object)

## S4 method for signature 'Log'
is_atom_concave(object)

## S4 method for signature 'Log'
is_atom_log_log_convex(object)

## S4 method for signature 'Log'
is_atom_log_log_concave(object)

## S4 method for signature 'Log'
is_incr(object, idx)

## S4 method for signature 'Log'
is_decr(object, idx)

## S4 method for signature 'Log'
.grad(object, values)

## S4 method for signature 'Log'
.domain(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Log-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</td></tr>
<tr><td><code id="Log-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Log-class">Log</a> object.</p>
</td></tr>
<tr><td><code id="Log-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="Log-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Log)</code>: The elementwise natural logarithm of the input value.
</p>
</li>
<li> <p><code>sign_from_args(Log)</code>: The sign of the atom is unknown.
</p>
</li>
<li> <p><code>is_atom_convex(Log)</code>: The atom is not convex.
</p>
</li>
<li> <p><code>is_atom_concave(Log)</code>: The atom is concave.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(Log)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(Log)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(Log)</code>: The atom is weakly increasing.
</p>
</li>
<li> <p><code>is_decr(Log)</code>: The atom is not weakly decreasing.
</p>
</li>
<li> <p><code>.grad(Log)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.domain(Log)</code>: Returns constraints describng the domain of the node
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</dd>
</dl>

<hr>
<h2 id='log+2CExpression-method'>Logarithms</h2><span id='topic+log+2CExpression-method'></span><span id='topic+log'></span><span id='topic+log10'></span><span id='topic+log2'></span><span id='topic+log1p'></span><span id='topic+log10+2CExpression-method'></span><span id='topic+log2+2CExpression-method'></span><span id='topic+log1p+2CExpression-method'></span>

<h3>Description</h3>

<p>The elementwise logarithm.
<code>log</code> computes the logarithm, by default the natural logarithm, <code>log10</code> computes the common (i.e., base 10) logarithm, and <code>log2</code> computes the binary (i.e., base 2) logarithms. The general form <code>log(x, base)</code> computes logarithms with base <code>base</code>.
<code>log1p</code> computes elementwise the function <code class="reqn">\log(1+x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression'
log(x, base = base::exp(1))

## S4 method for signature 'Expression'
log10(x)

## S4 method for signature 'Expression'
log2(x)

## S4 method for signature 'Expression'
log1p(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log+2B2CExpression-method_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>.</p>
</td></tr>
<tr><td><code id="log+2B2CExpression-method_+3A_base">base</code></td>
<td>
<p>(Optional) A positive number that is the base with respect to which the logarithm is computed. Defaults to <code class="reqn">e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the exponentiated input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Log in objective
x &lt;- Variable(2)
obj &lt;- Maximize(sum(log(x)))
constr &lt;- list(x &lt;= matrix(c(1, exp(1))))
prob &lt;- Problem(obj, constr)
result &lt;- solve(prob)
result$value
result$getValue(x)

# Log in constraint
obj &lt;- Minimize(sum(x))
constr &lt;- list(log2(x) &gt;= 0, x &lt;= matrix(c(1,1)))
prob &lt;- Problem(obj, constr)
result &lt;- solve(prob)
result$value
result$getValue(x)

# Index into log
obj &lt;- Maximize(log10(x)[2])
constr &lt;- list(x &lt;= matrix(c(1, exp(1))))
prob &lt;- Problem(obj, constr)
result &lt;- solve(prob)
result$value

# Scalar log
obj &lt;- Maximize(log1p(x[2]))
constr &lt;- list(x &lt;= matrix(c(1, exp(1))))
prob &lt;- Problem(obj, constr)
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='Log1p-class'>The Log1p class.</h2><span id='topic+Log1p-class'></span><span id='topic+.Log1p'></span><span id='topic+Log1p'></span><span id='topic+to_numeric+2CLog1p-method'></span><span id='topic+sign_from_args+2CLog1p-method'></span><span id='topic+.grad+2CLog1p-method'></span><span id='topic+.domain+2CLog1p-method'></span>

<h3>Description</h3>

<p>This class represents the elementwise operation <code class="reqn">\log(1 + x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Log1p(x)

## S4 method for signature 'Log1p'
to_numeric(object, values)

## S4 method for signature 'Log1p'
sign_from_args(object)

## S4 method for signature 'Log1p'
.grad(object, values)

## S4 method for signature 'Log1p'
.domain(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Log1p-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</td></tr>
<tr><td><code id="Log1p-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Log1p-class">Log1p</a> object.</p>
</td></tr>
<tr><td><code id="Log1p-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Log1p)</code>: The elementwise natural logarithm of one plus the input value.
</p>
</li>
<li> <p><code>sign_from_args(Log1p)</code>: The sign of the atom.
</p>
</li>
<li> <p><code>.grad(Log1p)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.domain(Log1p)</code>: Returns constraints describng the domain of the node
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</dd>
</dl>

<hr>
<h2 id='LogDet-class'>The LogDet class.</h2><span id='topic+LogDet-class'></span><span id='topic+.LogDet'></span><span id='topic+LogDet'></span><span id='topic+to_numeric+2CLogDet-method'></span><span id='topic+validate_args+2CLogDet-method'></span><span id='topic+dim_from_args+2CLogDet-method'></span><span id='topic+sign_from_args+2CLogDet-method'></span><span id='topic+is_atom_convex+2CLogDet-method'></span><span id='topic+is_atom_concave+2CLogDet-method'></span><span id='topic+is_incr+2CLogDet-method'></span><span id='topic+is_decr+2CLogDet-method'></span><span id='topic+.grad+2CLogDet-method'></span><span id='topic+.domain+2CLogDet-method'></span>

<h3>Description</h3>

<p>The natural logarithm of the determinant of a matrix, <code class="reqn">\log\det(A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogDet(A)

## S4 method for signature 'LogDet'
to_numeric(object, values)

## S4 method for signature 'LogDet'
validate_args(object)

## S4 method for signature 'LogDet'
dim_from_args(object)

## S4 method for signature 'LogDet'
sign_from_args(object)

## S4 method for signature 'LogDet'
is_atom_convex(object)

## S4 method for signature 'LogDet'
is_atom_concave(object)

## S4 method for signature 'LogDet'
is_incr(object, idx)

## S4 method for signature 'LogDet'
is_decr(object, idx)

## S4 method for signature 'LogDet'
.grad(object, values)

## S4 method for signature 'LogDet'
.domain(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogDet-class_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="LogDet-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+LogDet-class">LogDet</a> object.</p>
</td></tr>
<tr><td><code id="LogDet-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="LogDet-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(LogDet)</code>: The log-determinant of SDP matrix <code>A</code>. This is the sum of logs of the eigenvalues and is equivalent to the nuclear norm of the matrix logarithm of <code>A</code>.
</p>
</li>
<li> <p><code>validate_args(LogDet)</code>: Check that <code>A</code> is square.
</p>
</li>
<li> <p><code>dim_from_args(LogDet)</code>: The atom is a scalar.
</p>
</li>
<li> <p><code>sign_from_args(LogDet)</code>: The atom is non-negative.
</p>
</li>
<li> <p><code>is_atom_convex(LogDet)</code>: The atom is not convex.
</p>
</li>
<li> <p><code>is_atom_concave(LogDet)</code>: The atom is concave.
</p>
</li>
<li> <p><code>is_incr(LogDet)</code>: The atom is not monotonic in any argument.
</p>
</li>
<li> <p><code>is_decr(LogDet)</code>: The atom is not monotonic in any argument.
</p>
</li>
<li> <p><code>.grad(LogDet)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.domain(LogDet)</code>: Returns constraints describing the domain of the node
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>A</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='logistic'>Logistic Function</h2><span id='topic+logistic'></span>

<h3>Description</h3>

<p>The elementwise logistic function, <code class="reqn">\log(1 + e^x)</code>.
This is a special case of log(sum(exp)) that evaluates to a vector rather than to a scalar, which is useful for logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the logistic function evaluated at the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(92)
n &lt;- 20
m &lt;- 1000
sigma &lt;- 45

beta_true &lt;- stats::rnorm(n)
idxs &lt;- sample(n, size = 0.8*n, replace = FALSE)
beta_true[idxs] &lt;- 0
X &lt;- matrix(stats::rnorm(m*n, 0, 5), nrow = m, ncol = n)
y &lt;- sign(X %*% beta_true + stats::rnorm(m, 0, sigma))

beta &lt;- Variable(n)
X_sign &lt;- apply(X, 2, function(x) { ifelse(y &lt;= 0, -1, 1) * x })
obj &lt;- -sum(logistic(-X[y &lt;= 0,] %*% beta)) - sum(logistic(X[y == 1,] %*% beta))
prob &lt;- Problem(Maximize(obj))
result &lt;- solve(prob)

log_odds &lt;- result$getValue(X %*% beta)
beta_res &lt;- result$getValue(beta)
y_probs &lt;- 1/(1 + exp(-X %*% beta_res))
log(y_probs/(1 - y_probs))
</code></pre>

<hr>
<h2 id='Logistic-class'>The Logistic class.</h2><span id='topic+Logistic-class'></span><span id='topic+.Logistic'></span><span id='topic+Logistic'></span><span id='topic+to_numeric+2CLogistic-method'></span><span id='topic+sign_from_args+2CLogistic-method'></span><span id='topic+is_atom_convex+2CLogistic-method'></span><span id='topic+is_atom_concave+2CLogistic-method'></span><span id='topic+is_incr+2CLogistic-method'></span><span id='topic+is_decr+2CLogistic-method'></span><span id='topic+.grad+2CLogistic-method'></span>

<h3>Description</h3>

<p>This class represents the elementwise operation <code class="reqn">\log(1 + e^x)</code>.
This is a special case of log(sum(exp)) that evaluates to a vector rather than to a scalar,
which is useful for logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Logistic(x)

## S4 method for signature 'Logistic'
to_numeric(object, values)

## S4 method for signature 'Logistic'
sign_from_args(object)

## S4 method for signature 'Logistic'
is_atom_convex(object)

## S4 method for signature 'Logistic'
is_atom_concave(object)

## S4 method for signature 'Logistic'
is_incr(object, idx)

## S4 method for signature 'Logistic'
is_decr(object, idx)

## S4 method for signature 'Logistic'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Logistic-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</td></tr>
<tr><td><code id="Logistic-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Logistic-class">Logistic</a> object.</p>
</td></tr>
<tr><td><code id="Logistic-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="Logistic-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Logistic)</code>: Evaluates <code>e^x</code> elementwise, adds one, and takes the natural logarithm.
</p>
</li>
<li> <p><code>sign_from_args(Logistic)</code>: The atom is positive.
</p>
</li>
<li> <p><code>is_atom_convex(Logistic)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(Logistic)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_incr(Logistic)</code>: The atom is weakly increasing.
</p>
</li>
<li> <p><code>is_decr(Logistic)</code>: The atom is not weakly decreasing.
</p>
</li>
<li> <p><code>.grad(Logistic)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</dd>
</dl>

<hr>
<h2 id='LogSumExp-class'>The LogSumExp class.</h2><span id='topic+LogSumExp-class'></span><span id='topic+.LogSumExp'></span><span id='topic+LogSumExp'></span><span id='topic+to_numeric+2CLogSumExp-method'></span><span id='topic+.grad+2CLogSumExp-method'></span><span id='topic+.column_grad+2CLogSumExp-method'></span><span id='topic+sign_from_args+2CLogSumExp-method'></span><span id='topic+is_atom_convex+2CLogSumExp-method'></span><span id='topic+is_atom_concave+2CLogSumExp-method'></span><span id='topic+is_incr+2CLogSumExp-method'></span><span id='topic+is_decr+2CLogSumExp-method'></span>

<h3>Description</h3>

<p>The natural logarithm of the sum of the elementwise exponential, <code class="reqn">\log\sum_{i=1}^n e^{x_i}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogSumExp(x, axis = NA_real_, keepdims = FALSE)

## S4 method for signature 'LogSumExp'
to_numeric(object, values)

## S4 method for signature 'LogSumExp'
.grad(object, values)

## S4 method for signature 'LogSumExp'
.column_grad(object, value)

## S4 method for signature 'LogSumExp'
sign_from_args(object)

## S4 method for signature 'LogSumExp'
is_atom_convex(object)

## S4 method for signature 'LogSumExp'
is_atom_concave(object)

## S4 method for signature 'LogSumExp'
is_incr(object, idx)

## S4 method for signature 'LogSumExp'
is_decr(object, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogSumExp-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</td></tr>
<tr><td><code id="LogSumExp-class_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="LogSumExp-class_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="LogSumExp-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+LogSumExp-class">LogSumExp</a> object.</p>
</td></tr>
<tr><td><code id="LogSumExp-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values.</p>
</td></tr>
<tr><td><code id="LogSumExp-class_+3A_value">value</code></td>
<td>
<p>A numeric value.</p>
</td></tr>
<tr><td><code id="LogSumExp-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(LogSumExp)</code>: Evaluates <code class="reqn">e^x</code> elementwise, sums, and takes the natural log.
</p>
</li>
<li> <p><code>.grad(LogSumExp)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.column_grad(LogSumExp)</code>: Gives the (sub/super)gradient of the atom w.r.t. each column variable.
</p>
</li>
<li> <p><code>sign_from_args(LogSumExp)</code>: Returns sign (is positive, is negative) of the atom.
</p>
</li>
<li> <p><code>is_atom_convex(LogSumExp)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(LogSumExp)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_incr(LogSumExp)</code>: The atom is weakly increasing in the index.
</p>
</li>
<li> <p><code>is_decr(LogSumExp)</code>: The atom is not weakly decreasing in the index.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</dd>
<dt><code>axis</code></dt><dd><p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</dd>
<dt><code>keepdims</code></dt><dd><p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</dd>
</dl>

<hr>
<h2 id='matrix_frac'>Matrix Fraction</h2><span id='topic+matrix_frac'></span>

<h3>Description</h3>

<p><code class="reqn">tr(X^T P^{-1} X)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_frac(X, P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_frac_+3A_x">X</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix. Must have the same number of rows as <code>P</code>.</p>
</td></tr>
<tr><td><code id="matrix_frac_+3A_p">P</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix. Must be an invertible square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the matrix fraction evaluated at the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(192)
m &lt;- 100
n &lt;- 80
r &lt;- 70

A &lt;- matrix(stats::rnorm(m*n), nrow = m, ncol = n)
b &lt;- matrix(stats::rnorm(m), nrow = m, ncol = 1)
G &lt;- matrix(stats::rnorm(r*n), nrow = r, ncol = n)
h &lt;- matrix(stats::rnorm(r), nrow = r, ncol = 1)

# ||Ax-b||^2 = x^T (A^T A) x - 2(A^T b)^T x + ||b||^2
P &lt;- t(A) %*% A
q &lt;- -2 * t(A) %*% b
r &lt;- t(b) %*% b
Pinv &lt;- base::solve(P)

x &lt;- Variable(n)
obj &lt;- matrix_frac(x, Pinv) + t(q) %*% x + r
constr &lt;- list(G %*% x == h)
prob &lt;- Problem(Minimize(obj), constr)
result &lt;- solve(prob)
result$value

## End(Not run)
</code></pre>

<hr>
<h2 id='matrix_prop-methods'>Matrix Properties</h2><span id='topic+matrix_prop-methods'></span><span id='topic+is_psd'></span><span id='topic+is_nsd'></span><span id='topic+is_hermitian'></span><span id='topic+is_symmetric'></span>

<h3>Description</h3>

<p>Determine if an expression is positive semidefinite, negative semidefinite, hermitian, and/or symmetric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_psd(object)

is_nsd(object)

is_hermitian(object)

is_symmetric(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_prop-methods_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>

<hr>
<h2 id='matrix_trace'>Matrix Trace</h2><span id='topic+matrix_trace'></span><span id='topic+trace'></span><span id='topic+tr'></span>

<h3>Description</h3>

<p>The sum of the diagonal entries in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_trace(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_trace_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the trace of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- Variable(3,3)
val &lt;- cbind(3:5, 6:8, 9:11)
prob &lt;- Problem(Maximize(matrix_trace(C)), list(C == val))
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='MatrixFrac-class'>The MatrixFrac class.</h2><span id='topic+MatrixFrac-class'></span><span id='topic+.MatrixFrac'></span><span id='topic+MatrixFrac'></span><span id='topic+allow_complex+2CMatrixFrac-method'></span><span id='topic+to_numeric+2CMatrixFrac-method'></span><span id='topic+validate_args+2CMatrixFrac-method'></span><span id='topic+dim_from_args+2CMatrixFrac-method'></span><span id='topic+sign_from_args+2CMatrixFrac-method'></span><span id='topic+is_atom_convex+2CMatrixFrac-method'></span><span id='topic+is_atom_concave+2CMatrixFrac-method'></span><span id='topic+is_incr+2CMatrixFrac-method'></span><span id='topic+is_decr+2CMatrixFrac-method'></span><span id='topic+is_quadratic+2CMatrixFrac-method'></span><span id='topic+is_qpwa+2CMatrixFrac-method'></span><span id='topic+.domain+2CMatrixFrac-method'></span><span id='topic+.grad+2CMatrixFrac-method'></span>

<h3>Description</h3>

<p>The matrix fraction function <code class="reqn">tr(X^T P^{-1} X)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatrixFrac(X, P)

## S4 method for signature 'MatrixFrac'
allow_complex(object)

## S4 method for signature 'MatrixFrac'
to_numeric(object, values)

## S4 method for signature 'MatrixFrac'
validate_args(object)

## S4 method for signature 'MatrixFrac'
dim_from_args(object)

## S4 method for signature 'MatrixFrac'
sign_from_args(object)

## S4 method for signature 'MatrixFrac'
is_atom_convex(object)

## S4 method for signature 'MatrixFrac'
is_atom_concave(object)

## S4 method for signature 'MatrixFrac'
is_incr(object, idx)

## S4 method for signature 'MatrixFrac'
is_decr(object, idx)

## S4 method for signature 'MatrixFrac'
is_quadratic(object)

## S4 method for signature 'MatrixFrac'
is_qpwa(object)

## S4 method for signature 'MatrixFrac'
.domain(object)

## S4 method for signature 'MatrixFrac'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatrixFrac-class_+3A_x">X</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="MatrixFrac-class_+3A_p">P</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="MatrixFrac-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+MatrixFrac-class">MatrixFrac</a> object.</p>
</td></tr>
<tr><td><code id="MatrixFrac-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="MatrixFrac-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>allow_complex(MatrixFrac)</code>: Does the atom handle complex numbers?
</p>
</li>
<li> <p><code>to_numeric(MatrixFrac)</code>: The trace of <code class="reqn">X^TP^{-1}X</code>.
</p>
</li>
<li> <p><code>validate_args(MatrixFrac)</code>: Check that the dimensions of <code>x</code> and <code>P</code> match.
</p>
</li>
<li> <p><code>dim_from_args(MatrixFrac)</code>: The atom is a scalar.
</p>
</li>
<li> <p><code>sign_from_args(MatrixFrac)</code>: The atom is positive.
</p>
</li>
<li> <p><code>is_atom_convex(MatrixFrac)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(MatrixFrac)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_incr(MatrixFrac)</code>: The atom is not monotonic in any argument.
</p>
</li>
<li> <p><code>is_decr(MatrixFrac)</code>: The atom is not monotonic in any argument.
</p>
</li>
<li> <p><code>is_quadratic(MatrixFrac)</code>: True if x is affine and P is constant.
</p>
</li>
<li> <p><code>is_qpwa(MatrixFrac)</code>: True if x is piecewise linear and P is constant.
</p>
</li>
<li> <p><code>.domain(MatrixFrac)</code>: Returns constraints describing the domain of the node
</p>
</li>
<li> <p><code>.grad(MatrixFrac)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>X</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
<dt><code>P</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='MatrixStuffing-class'>The MatrixStuffing class.</h2><span id='topic+MatrixStuffing-class'></span><span id='topic+MatrixStuffing'></span><span id='topic+perform+2CMatrixStuffing+2CProblem-method'></span><span id='topic+invert+2CMatrixStuffing+2CSolution+2CInverseData-method'></span>

<h3>Description</h3>

<p>The MatrixStuffing class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MatrixStuffing,Problem'
perform(object, problem)

## S4 method for signature 'MatrixStuffing,Solution,InverseData'
invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatrixStuffing-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+MatrixStuffing-class">MatrixStuffing</a> object.</p>
</td></tr>
<tr><td><code id="MatrixStuffing-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object to stuff; the arguments of every constraint must be affine.</p>
</td></tr>
<tr><td><code id="MatrixStuffing-class_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> to a problem that generated the inverse data.</p>
</td></tr>
<tr><td><code id="MatrixStuffing-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>The data encoding the original problem.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>perform(object = MatrixStuffing, problem = Problem)</code>: Returns a stuffed problem. The returned problem is a minimization problem in which every
constraint in the problem has affine arguments that are expressed in the form A 
</p>
</li>
<li> <p><code>invert(
  object = MatrixStuffing,
  solution = Solution,
  inverse_data = InverseData
)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li></ul>

<hr>
<h2 id='max_elemwise'>Elementwise Maximum</h2><span id='topic+max_elemwise'></span>

<h3>Description</h3>

<p>The elementwise maximum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_elemwise(arg1, arg2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_elemwise_+3A_arg1">arg1</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="max_elemwise_+3A_arg2">arg2</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="max_elemwise_+3A_...">...</code></td>
<td>
<p>Additional <a href="#topic+Expression-class">Expression</a> objects, vectors, or matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the elementwise maximum of the inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c &lt;- matrix(c(1,-1))
prob &lt;- Problem(Minimize(max_elemwise(t(c), 2, 2 + t(c))[2]))
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='max_entries'>Maximum</h2><span id='topic+max_entries'></span><span id='topic+max'></span><span id='topic+max.Expression'></span>

<h3>Description</h3>

<p>The maximum of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_entries(x, axis = NA_real_, keepdims = FALSE)

## S3 method for class 'Expression'
max(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_entries_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="max_entries_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="max_entries_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="max_entries_+3A_...">...</code></td>
<td>
<p>Numeric scalar, vector, matrix, or <a href="#topic+Expression-class">Expression</a> objects.</p>
</td></tr>
<tr><td><code id="max_entries_+3A_na.rm">na.rm</code></td>
<td>
<p>(Unimplemented) A logical value indicating whether missing values should be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the maximum of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(2)
val &lt;- matrix(c(-5,-10))
prob &lt;- Problem(Minimize(max_entries(x)), list(x == val))
result &lt;- solve(prob)
result$value

A &lt;- Variable(2,2)
val &lt;- rbind(c(-5,2), c(-3,1))
prob &lt;- Problem(Minimize(max_entries(A, axis = 1)[2,1]), list(A == val))
result &lt;- solve(prob)
result$value
x &lt;- Variable(2)
val &lt;- matrix(c(-5,-10))
prob &lt;- Problem(Minimize(max_entries(x)), list(x == val))
result &lt;- solve(prob)
result$value

A &lt;- Variable(2,2)
val &lt;- rbind(c(-5,2), c(-3,1))
prob &lt;- Problem(Minimize(max_entries(A, axis = 1)[2,1]), list(A == val))
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='MaxElemwise-class'>The MaxElemwise class.</h2><span id='topic+MaxElemwise-class'></span><span id='topic+.MaxElemwise'></span><span id='topic+MaxElemwise'></span><span id='topic+to_numeric+2CMaxElemwise-method'></span><span id='topic+sign_from_args+2CMaxElemwise-method'></span><span id='topic+is_atom_convex+2CMaxElemwise-method'></span><span id='topic+is_atom_concave+2CMaxElemwise-method'></span><span id='topic+is_atom_log_log_convex+2CMaxElemwise-method'></span><span id='topic+is_atom_log_log_concave+2CMaxElemwise-method'></span><span id='topic+is_incr+2CMaxElemwise-method'></span><span id='topic+is_decr+2CMaxElemwise-method'></span><span id='topic+is_pwl+2CMaxElemwise-method'></span><span id='topic+.grad+2CMaxElemwise-method'></span>

<h3>Description</h3>

<p>This class represents the elementwise maximum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxElemwise(arg1, arg2, ...)

## S4 method for signature 'MaxElemwise'
to_numeric(object, values)

## S4 method for signature 'MaxElemwise'
sign_from_args(object)

## S4 method for signature 'MaxElemwise'
is_atom_convex(object)

## S4 method for signature 'MaxElemwise'
is_atom_concave(object)

## S4 method for signature 'MaxElemwise'
is_atom_log_log_convex(object)

## S4 method for signature 'MaxElemwise'
is_atom_log_log_concave(object)

## S4 method for signature 'MaxElemwise'
is_incr(object, idx)

## S4 method for signature 'MaxElemwise'
is_decr(object, idx)

## S4 method for signature 'MaxElemwise'
is_pwl(object)

## S4 method for signature 'MaxElemwise'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MaxElemwise-class_+3A_arg1">arg1</code></td>
<td>
<p>The first <a href="#topic+Expression-class">Expression</a> in the maximum operation.</p>
</td></tr>
<tr><td><code id="MaxElemwise-class_+3A_arg2">arg2</code></td>
<td>
<p>The second <a href="#topic+Expression-class">Expression</a> in the maximum operation.</p>
</td></tr>
<tr><td><code id="MaxElemwise-class_+3A_...">...</code></td>
<td>
<p>Additional <a href="#topic+Expression-class">Expression</a> objects in the maximum operation.</p>
</td></tr>
<tr><td><code id="MaxElemwise-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+MaxElemwise-class">MaxElemwise</a> object.</p>
</td></tr>
<tr><td><code id="MaxElemwise-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="MaxElemwise-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(MaxElemwise)</code>: The elementwise maximum.
</p>
</li>
<li> <p><code>sign_from_args(MaxElemwise)</code>: The sign of the atom.
</p>
</li>
<li> <p><code>is_atom_convex(MaxElemwise)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(MaxElemwise)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(MaxElemwise)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(MaxElemwise)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(MaxElemwise)</code>: The atom is weakly increasing.
</p>
</li>
<li> <p><code>is_decr(MaxElemwise)</code>: The atom is not weakly decreasing.
</p>
</li>
<li> <p><code>is_pwl(MaxElemwise)</code>: Are all the arguments piecewise linear?
</p>
</li>
<li> <p><code>.grad(MaxElemwise)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>arg1</code></dt><dd><p>The first <a href="#topic+Expression-class">Expression</a> in the maximum operation.</p>
</dd>
<dt><code>arg2</code></dt><dd><p>The second <a href="#topic+Expression-class">Expression</a> in the maximum operation.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional <a href="#topic+Expression-class">Expression</a> objects in the maximum operation.</p>
</dd>
</dl>

<hr>
<h2 id='MaxEntries-class'>The MaxEntries class.</h2><span id='topic+MaxEntries-class'></span><span id='topic+.MaxEntries'></span><span id='topic+MaxEntries'></span><span id='topic+to_numeric+2CMaxEntries-method'></span><span id='topic+sign_from_args+2CMaxEntries-method'></span><span id='topic+is_atom_convex+2CMaxEntries-method'></span><span id='topic+is_atom_concave+2CMaxEntries-method'></span><span id='topic+is_atom_log_log_convex+2CMaxEntries-method'></span><span id='topic+is_atom_log_log_concave+2CMaxEntries-method'></span><span id='topic+is_incr+2CMaxEntries-method'></span><span id='topic+is_decr+2CMaxEntries-method'></span><span id='topic+is_pwl+2CMaxEntries-method'></span><span id='topic+.grad+2CMaxEntries-method'></span><span id='topic+.column_grad+2CMaxEntries-method'></span>

<h3>Description</h3>

<p>The maximum of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxEntries(x, axis = NA_real_, keepdims = FALSE)

## S4 method for signature 'MaxEntries'
to_numeric(object, values)

## S4 method for signature 'MaxEntries'
sign_from_args(object)

## S4 method for signature 'MaxEntries'
is_atom_convex(object)

## S4 method for signature 'MaxEntries'
is_atom_concave(object)

## S4 method for signature 'MaxEntries'
is_atom_log_log_convex(object)

## S4 method for signature 'MaxEntries'
is_atom_log_log_concave(object)

## S4 method for signature 'MaxEntries'
is_incr(object, idx)

## S4 method for signature 'MaxEntries'
is_decr(object, idx)

## S4 method for signature 'MaxEntries'
is_pwl(object)

## S4 method for signature 'MaxEntries'
.grad(object, values)

## S4 method for signature 'MaxEntries'
.column_grad(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MaxEntries-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</td></tr>
<tr><td><code id="MaxEntries-class_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="MaxEntries-class_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MaxEntries-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+MaxEntries-class">MaxEntries</a> object.</p>
</td></tr>
<tr><td><code id="MaxEntries-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="MaxEntries-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="MaxEntries-class_+3A_value">value</code></td>
<td>
<p>A numeric value</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(MaxEntries)</code>: The largest entry in <code>x</code>.
</p>
</li>
<li> <p><code>sign_from_args(MaxEntries)</code>: The sign of the atom.
</p>
</li>
<li> <p><code>is_atom_convex(MaxEntries)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(MaxEntries)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(MaxEntries)</code>: Is the atom log-log convex.
</p>
</li>
<li> <p><code>is_atom_log_log_concave(MaxEntries)</code>: Is the atom log-log concave.
</p>
</li>
<li> <p><code>is_incr(MaxEntries)</code>: The atom is weakly increasing in every argument.
</p>
</li>
<li> <p><code>is_decr(MaxEntries)</code>: The atom is not weakly decreasing in any argument.
</p>
</li>
<li> <p><code>is_pwl(MaxEntries)</code>: Is <code>x</code> piecewise linear?
</p>
</li>
<li> <p><code>.grad(MaxEntries)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.column_grad(MaxEntries)</code>: Gives the (sub/super)gradient of the atom w.r.t. each column variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</dd>
<dt><code>axis</code></dt><dd><p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</dd>
<dt><code>keepdims</code></dt><dd><p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</dd>
</dl>

<hr>
<h2 id='Maximize-class'>The Maximize class.</h2><span id='topic+Maximize-class'></span><span id='topic+.Maximize'></span><span id='topic+Maximize'></span><span id='topic+canonicalize+2CMaximize-method'></span><span id='topic+is_dcp+2CMaximize-method'></span><span id='topic+is_dgp+2CMaximize-method'></span>

<h3>Description</h3>

<p>This class represents an optimization objective for maximization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Maximize(expr)

## S4 method for signature 'Maximize'
canonicalize(object)

## S4 method for signature 'Maximize'
is_dcp(object)

## S4 method for signature 'Maximize'
is_dgp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Maximize-class_+3A_expr">expr</code></td>
<td>
<p>A scalar <a href="#topic+Expression-class">Expression</a> to maximize.</p>
</td></tr>
<tr><td><code id="Maximize-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Maximize-class">Maximize</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>canonicalize(Maximize)</code>: Negates the target expression's objective.
</p>
</li>
<li> <p><code>is_dcp(Maximize)</code>: A logical value indicating whether the objective is concave.
</p>
</li>
<li> <p><code>is_dgp(Maximize)</code>: A logical value indicating whether the objective is log-log concave.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>A scalar <a href="#topic+Expression-class">Expression</a> to maximize.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(3)
alpha &lt;- c(0.8,1.0,1.2)
obj &lt;- sum(log(alpha + x))
constr &lt;- list(x &gt;= 0, sum(x) == 1)
prob &lt;- Problem(Maximize(obj), constr)
result &lt;- solve(prob)
result$value
result$getValue(x)
</code></pre>

<hr>
<h2 id='mean.Expression'>Arithmetic Mean</h2><span id='topic+mean.Expression'></span><span id='topic+mean'></span>

<h3>Description</h3>

<p>The arithmetic mean of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Expression'
mean(x, trim = 0, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.Expression_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
<tr><td><code id="mean.Expression_+3A_trim">trim</code></td>
<td>
<p>(Unimplemented) The fraction (0 to 0.5) of observations to be trimmed from each end of <code class="reqn">x</code> before the mean is computed.</p>
</td></tr>
<tr><td><code id="mean.Expression_+3A_na.rm">na.rm</code></td>
<td>
<p>(Unimplemented) A logical value indicating whether missing values should be removed.</p>
</td></tr>
<tr><td><code id="mean.Expression_+3A_...">...</code></td>
<td>
<p>(Unimplemented) Optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the mean of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Variable(2,2)
val &lt;- cbind(c(-5,2), c(-3,1))
prob &lt;- Problem(Minimize(mean(A)), list(A == val))
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='min_elemwise'>Elementwise Minimum</h2><span id='topic+min_elemwise'></span>

<h3>Description</h3>

<p>The elementwise minimum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_elemwise(arg1, arg2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_elemwise_+3A_arg1">arg1</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="min_elemwise_+3A_arg2">arg2</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="min_elemwise_+3A_...">...</code></td>
<td>
<p>Additional <a href="#topic+Expression-class">Expression</a> objects, vectors, or matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the elementwise minimum of the inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- cbind(c(-5,2), c(-3,-1))
b &lt;- cbind(c(5,4), c(-1,2))
prob &lt;- Problem(Minimize(min_elemwise(a, 0, b)[1,2]))
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='min_entries'>Minimum</h2><span id='topic+min_entries'></span><span id='topic+min'></span><span id='topic+min.Expression'></span>

<h3>Description</h3>

<p>The minimum of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_entries(x, axis = NA_real_, keepdims = FALSE)

## S3 method for class 'Expression'
min(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_entries_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="min_entries_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="min_entries_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="min_entries_+3A_...">...</code></td>
<td>
<p>Numeric scalar, vector, matrix, or <a href="#topic+Expression-class">Expression</a> objects.</p>
</td></tr>
<tr><td><code id="min_entries_+3A_na.rm">na.rm</code></td>
<td>
<p>(Unimplemented) A logical value indicating whether missing values should be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the minimum of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Variable(2,2)
val &lt;- cbind(c(-5,2), c(-3,1))
prob &lt;- Problem(Maximize(min_entries(A)), list(A == val))
result &lt;- solve(prob)
result$value
A &lt;- Variable(2,2)
val &lt;- cbind(c(-5,2), c(-3,1))
prob &lt;- Problem(Maximize(min_entries(A)), list(A == val))
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='MinElemwise-class'>The MinElemwise class.</h2><span id='topic+MinElemwise-class'></span><span id='topic+.MinElemwise'></span><span id='topic+MinElemwise'></span><span id='topic+to_numeric+2CMinElemwise-method'></span><span id='topic+sign_from_args+2CMinElemwise-method'></span><span id='topic+is_atom_convex+2CMinElemwise-method'></span><span id='topic+is_atom_concave+2CMinElemwise-method'></span><span id='topic+is_atom_log_log_convex+2CMinElemwise-method'></span><span id='topic+is_atom_log_log_concave+2CMinElemwise-method'></span><span id='topic+is_incr+2CMinElemwise-method'></span><span id='topic+is_decr+2CMinElemwise-method'></span><span id='topic+is_pwl+2CMinElemwise-method'></span><span id='topic+.grad+2CMinElemwise-method'></span>

<h3>Description</h3>

<p>This class represents the elementwise minimum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinElemwise(arg1, arg2, ...)

## S4 method for signature 'MinElemwise'
to_numeric(object, values)

## S4 method for signature 'MinElemwise'
sign_from_args(object)

## S4 method for signature 'MinElemwise'
is_atom_convex(object)

## S4 method for signature 'MinElemwise'
is_atom_concave(object)

## S4 method for signature 'MinElemwise'
is_atom_log_log_convex(object)

## S4 method for signature 'MinElemwise'
is_atom_log_log_concave(object)

## S4 method for signature 'MinElemwise'
is_incr(object, idx)

## S4 method for signature 'MinElemwise'
is_decr(object, idx)

## S4 method for signature 'MinElemwise'
is_pwl(object)

## S4 method for signature 'MinElemwise'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MinElemwise-class_+3A_arg1">arg1</code></td>
<td>
<p>The first <a href="#topic+Expression-class">Expression</a> in the minimum operation.</p>
</td></tr>
<tr><td><code id="MinElemwise-class_+3A_arg2">arg2</code></td>
<td>
<p>The second <a href="#topic+Expression-class">Expression</a> in the minimum operation.</p>
</td></tr>
<tr><td><code id="MinElemwise-class_+3A_...">...</code></td>
<td>
<p>Additional <a href="#topic+Expression-class">Expression</a> objects in the minimum operation.</p>
</td></tr>
<tr><td><code id="MinElemwise-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+MinElemwise-class">MinElemwise</a> object.</p>
</td></tr>
<tr><td><code id="MinElemwise-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="MinElemwise-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(MinElemwise)</code>: The elementwise minimum.
</p>
</li>
<li> <p><code>sign_from_args(MinElemwise)</code>: The sign of the atom.
</p>
</li>
<li> <p><code>is_atom_convex(MinElemwise)</code>: The atom is not convex.
</p>
</li>
<li> <p><code>is_atom_concave(MinElemwise)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(MinElemwise)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(MinElemwise)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(MinElemwise)</code>: The atom is weakly increasing.
</p>
</li>
<li> <p><code>is_decr(MinElemwise)</code>: The atom is not weakly decreasing.
</p>
</li>
<li> <p><code>is_pwl(MinElemwise)</code>: Are all the arguments piecewise linear?
</p>
</li>
<li> <p><code>.grad(MinElemwise)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>arg1</code></dt><dd><p>The first <a href="#topic+Expression-class">Expression</a> in the minimum operation.</p>
</dd>
<dt><code>arg2</code></dt><dd><p>The second <a href="#topic+Expression-class">Expression</a> in the minimum operation.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional <a href="#topic+Expression-class">Expression</a> objects in the minimum operation.</p>
</dd>
</dl>

<hr>
<h2 id='MinEntries-class'>The MinEntries class.</h2><span id='topic+MinEntries-class'></span><span id='topic+.MinEntries'></span><span id='topic+MinEntries'></span><span id='topic+to_numeric+2CMinEntries-method'></span><span id='topic+sign_from_args+2CMinEntries-method'></span><span id='topic+is_atom_convex+2CMinEntries-method'></span><span id='topic+is_atom_concave+2CMinEntries-method'></span><span id='topic+is_atom_log_log_convex+2CMinEntries-method'></span><span id='topic+is_atom_log_log_concave+2CMinEntries-method'></span><span id='topic+is_incr+2CMinEntries-method'></span><span id='topic+is_decr+2CMinEntries-method'></span><span id='topic+is_pwl+2CMinEntries-method'></span><span id='topic+.grad+2CMinEntries-method'></span><span id='topic+.column_grad+2CMinEntries-method'></span>

<h3>Description</h3>

<p>The minimum of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinEntries(x, axis = NA_real_, keepdims = FALSE)

## S4 method for signature 'MinEntries'
to_numeric(object, values)

## S4 method for signature 'MinEntries'
sign_from_args(object)

## S4 method for signature 'MinEntries'
is_atom_convex(object)

## S4 method for signature 'MinEntries'
is_atom_concave(object)

## S4 method for signature 'MinEntries'
is_atom_log_log_convex(object)

## S4 method for signature 'MinEntries'
is_atom_log_log_concave(object)

## S4 method for signature 'MinEntries'
is_incr(object, idx)

## S4 method for signature 'MinEntries'
is_decr(object, idx)

## S4 method for signature 'MinEntries'
is_pwl(object)

## S4 method for signature 'MinEntries'
.grad(object, values)

## S4 method for signature 'MinEntries'
.column_grad(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MinEntries-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</td></tr>
<tr><td><code id="MinEntries-class_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="MinEntries-class_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MinEntries-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+MinEntries-class">MinEntries</a> object.</p>
</td></tr>
<tr><td><code id="MinEntries-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="MinEntries-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="MinEntries-class_+3A_value">value</code></td>
<td>
<p>A numeric value</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(MinEntries)</code>: The largest entry in <code>x</code>.
</p>
</li>
<li> <p><code>sign_from_args(MinEntries)</code>: The sign of the atom.
</p>
</li>
<li> <p><code>is_atom_convex(MinEntries)</code>: The atom is not convex.
</p>
</li>
<li> <p><code>is_atom_concave(MinEntries)</code>: The atom is concave.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(MinEntries)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(MinEntries)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(MinEntries)</code>: The atom is weakly increasing in every argument.
</p>
</li>
<li> <p><code>is_decr(MinEntries)</code>: The atom is not weakly decreasing in any argument.
</p>
</li>
<li> <p><code>is_pwl(MinEntries)</code>: Is <code>x</code> piecewise linear?
</p>
</li>
<li> <p><code>.grad(MinEntries)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.column_grad(MinEntries)</code>: Gives the (sub/super)gradient of the atom w.r.t. each column variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</dd>
<dt><code>axis</code></dt><dd><p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</dd>
<dt><code>keepdims</code></dt><dd><p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</dd>
</dl>

<hr>
<h2 id='Minimize-class'>The Minimize class.</h2><span id='topic+Minimize-class'></span><span id='topic+.Minimize'></span><span id='topic+Minimize'></span><span id='topic+canonicalize+2CMinimize-method'></span><span id='topic+is_dcp+2CMinimize-method'></span><span id='topic+is_dgp+2CMinimize-method'></span>

<h3>Description</h3>

<p>This class represents an optimization objective for minimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Minimize(expr)

## S4 method for signature 'Minimize'
canonicalize(object)

## S4 method for signature 'Minimize'
is_dcp(object)

## S4 method for signature 'Minimize'
is_dgp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Minimize-class_+3A_expr">expr</code></td>
<td>
<p>A scalar <a href="#topic+Expression-class">Expression</a> to minimize.</p>
</td></tr>
<tr><td><code id="Minimize-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Minimize-class">Minimize</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>canonicalize(Minimize)</code>: Pass on the target expression's objective and constraints.
</p>
</li>
<li> <p><code>is_dcp(Minimize)</code>: A logical value indicating whether the objective is convex.
</p>
</li>
<li> <p><code>is_dgp(Minimize)</code>: A logical value indicating whether the objective is log-log convex.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>A scalar <a href="#topic+Expression-class">Expression</a> to minimize.</p>
</dd>
</dl>

<hr>
<h2 id='mip_capable'>Solver Capabilities</h2><span id='topic+mip_capable'></span>

<h3>Description</h3>

<p>Determine if a solver is capable of solving a mixed-integer program (MIP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mip_capable(solver)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mip_capable_+3A_solver">solver</code></td>
<td>
<p>A <a href="#topic+ReductionSolver-class">ReductionSolver</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mip_capable(ECOS())
</code></pre>

<hr>
<h2 id='mixed_norm'>Mixed Norm</h2><span id='topic+mixed_norm'></span>

<h3>Description</h3>

<p><code class="reqn">l_{p,q}(x) = \left(\sum_{i=1}^n (\sum_{j=1}^m |x_{i,j}|)^{q/p}\right)^{1/q}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixed_norm(X, p = 2, q = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixed_norm_+3A_x">X</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="mixed_norm_+3A_p">p</code></td>
<td>
<p>The type of inner norm.</p>
</td></tr>
<tr><td><code id="mixed_norm_+3A_q">q</code></td>
<td>
<p>The type of outer norm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the <code class="reqn">l_{p,q}</code> norm of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Variable(2,2)
val &lt;- cbind(c(3,3), c(4,4))
prob &lt;- Problem(Minimize(mixed_norm(A,2,1)), list(A == val))
result &lt;- solve(prob)
result$value
result$getValue(A)

val &lt;- cbind(c(1,4), c(5,6))
prob &lt;- Problem(Minimize(mixed_norm(A,1,Inf)), list(A == val))
result &lt;- solve(prob)
result$value
result$getValue(A)
</code></pre>

<hr>
<h2 id='MixedNorm'>The MixedNorm atom.</h2><span id='topic+MixedNorm'></span>

<h3>Description</h3>

<p>The <code class="reqn">l_{p,q}</code> norm of X, <code class="reqn">(\sum_k (\sum_l ||X_{k,l}||^p)^{q/p})^{1/q}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixedNorm(X, p = 2, q = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixedNorm_+3A_x">X</code></td>
<td>
<p>The matrix to take the <code class="reqn">l_{p,q}</code> norm of</p>
</td></tr>
<tr><td><code id="MixedNorm_+3A_p">p</code></td>
<td>
<p>The type of inner norm</p>
</td></tr>
<tr><td><code id="MixedNorm_+3A_q">q</code></td>
<td>
<p>The type of outer norm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the mixed norm of X with specified parameters p and q
</p>

<hr>
<h2 id='MOSEK-class'>An interface for the MOSEK solver.</h2><span id='topic+MOSEK-class'></span><span id='topic+MOSEK'></span><span id='topic+mip_capable+2CMOSEK-method'></span><span id='topic+import_solver+2CMOSEK-method'></span><span id='topic+name+2CMOSEK-method'></span><span id='topic+accepts+2CMOSEK+2CProblem-method'></span><span id='topic+block_format+2CMOSEK-method'></span><span id='topic+perform+2CMOSEK+2CProblem-method'></span><span id='topic+solve_via_data+2CMOSEK-method'></span><span id='topic+invert+2CMOSEK+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>An interface for the MOSEK solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MOSEK()

## S4 method for signature 'MOSEK'
mip_capable(solver)

## S4 method for signature 'MOSEK'
import_solver(solver)

## S4 method for signature 'MOSEK'
name(x)

## S4 method for signature 'MOSEK,Problem'
accepts(object, problem)

## S4 method for signature 'MOSEK'
block_format(object, problem, constraints, exp_cone_order = NA)

## S4 method for signature 'MOSEK,Problem'
perform(object, problem)

## S4 method for signature 'MOSEK'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)

## S4 method for signature 'MOSEK,ANY,ANY'
invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MOSEK-class_+3A_solver">solver</code>, <code id="MOSEK-class_+3A_object">object</code>, <code id="MOSEK-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+MOSEK-class">MOSEK</a> object.</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_constraints">constraints</code></td>
<td>
<p>A list of <a href="#topic+Constraint-class">Constraint</a> objects for which coefficient
andd offset data (&quot;G&quot;, &quot;h&quot; respectively) is needed</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_exp_cone_order">exp_cone_order</code></td>
<td>
<p>A parameter that is only used when a <a href="#topic+Constraint-class">Constraint</a> object
describes membership in the exponential cone.</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance.</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance.</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance.</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_solution">solution</code></td>
<td>
<p>The raw solution returned by the solver.</p>
</td></tr>
<tr><td><code id="MOSEK-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A list containing data necessary for the inversion.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(MOSEK)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>import_solver(MOSEK)</code>: Imports the solver.
</p>
</li>
<li> <p><code>name(MOSEK)</code>: Returns the name of the solver.
</p>
</li>
<li> <p><code>accepts(object = MOSEK, problem = Problem)</code>: Can MOSEK solve the problem?
</p>
</li>
<li> <p><code>block_format(MOSEK)</code>: Returns a large matrix &quot;coeff&quot; and a vector of constants &quot;offset&quot; such
that every <a href="#topic+Constraint-class">Constraint</a> in &quot;constraints&quot; holds at z in R^n iff
&quot;coeff&quot; * z &lt;=_K offset&quot;, where K is a product of cones supported by MOSEK
and CVXR (zero cone, nonnegative orthant, second order cone, exponential cone). The
nature of K is inferred later by accessing the data in &quot;lengths&quot; and &quot;ids&quot;.
</p>
</li>
<li> <p><code>perform(object = MOSEK, problem = Problem)</code>: Returns a new problem and data for inverting the new solution.
</p>
</li>
<li> <p><code>solve_via_data(MOSEK)</code>: Solve a problem represented by data returned from apply.
</p>
</li>
<li> <p><code>invert(object = MOSEK, solution = ANY, inverse_data = ANY)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li></ul>

<hr>
<h2 id='MOSEK.parse_dual_vars'>Parses MOSEK dual variables into corresponding CVXR constraints and dual values</h2><span id='topic+MOSEK.parse_dual_vars'></span>

<h3>Description</h3>

<p>Parses MOSEK dual variables into corresponding CVXR constraints and dual values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MOSEK.parse_dual_vars(dual_var, constr_id_to_constr_dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MOSEK.parse_dual_vars_+3A_dual_var">dual_var</code></td>
<td>
<p>List of the dual variables returned by the MOSEK solution.</p>
</td></tr>
<tr><td><code id="MOSEK.parse_dual_vars_+3A_constr_id_to_constr_dim">constr_id_to_constr_dim</code></td>
<td>
<p>A list that contains the mapping of entry &quot;id&quot;
that is the index of the CVXR <a href="#topic+Constraint-class">Constraint</a> object to which the
next &quot;dim&quot; entries of the dual variable belong.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the mapping of the CVXR <a href="#topic+Constraint-class">Constraint</a> object
indices with the corresponding dual values.
</p>

<hr>
<h2 id='MOSEK.recover_dual_variables'>Recovers MOSEK solutions dual variables</h2><span id='topic+MOSEK.recover_dual_variables'></span>

<h3>Description</h3>

<p>Recovers MOSEK solutions dual variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MOSEK.recover_dual_variables(sol, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MOSEK.recover_dual_variables_+3A_sol">sol</code></td>
<td>
<p>List of the solutions returned by the MOSEK solver.</p>
</td></tr>
<tr><td><code id="MOSEK.recover_dual_variables_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A list of the data returned by the perform function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the mapping of CVXR's <a href="#topic+Constraint-class">Constraint</a>
object's id to its corresponding dual variables in the current solution.
</p>

<hr>
<h2 id='multiply'>Elementwise Multiplication</h2><span id='topic+multiply'></span><span id='topic++2A'></span>

<h3>Description</h3>

<p>The elementwise product of two expressions. The first expression must be constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiply(lh_exp, rh_exp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiply_+3A_lh_exp">lh_exp</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix representing the left-hand value.</p>
</td></tr>
<tr><td><code id="multiply_+3A_rh_exp">rh_exp</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix representing the right-hand value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the elementwise product of the inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Variable(2,2)
c &lt;- cbind(c(1,-1), c(2,-2))
expr &lt;- multiply(c, A)
obj &lt;- Minimize(norm_inf(expr))
prob &lt;- Problem(obj, list(A == 5))
result &lt;- solve(prob)
result$value
result$getValue(expr)
</code></pre>

<hr>
<h2 id='Multiply-class'>The Multiply class.</h2><span id='topic+Multiply-class'></span><span id='topic+.Multiply'></span><span id='topic+Multiply'></span><span id='topic+to_numeric+2CMultiply-method'></span><span id='topic+dim_from_args+2CMultiply-method'></span><span id='topic+is_atom_log_log_convex+2CMultiply-method'></span><span id='topic+is_atom_log_log_concave+2CMultiply-method'></span><span id='topic+is_psd+2CMultiply-method'></span><span id='topic+is_nsd+2CMultiply-method'></span><span id='topic+graph_implementation+2CMultiply-method'></span>

<h3>Description</h3>

<p>This class represents the elementwise product of two expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Multiply(lh_exp, rh_exp)

## S4 method for signature 'Multiply'
to_numeric(object, values)

## S4 method for signature 'Multiply'
dim_from_args(object)

## S4 method for signature 'Multiply'
is_atom_log_log_convex(object)

## S4 method for signature 'Multiply'
is_atom_log_log_concave(object)

## S4 method for signature 'Multiply'
is_psd(object)

## S4 method for signature 'Multiply'
is_nsd(object)

## S4 method for signature 'Multiply'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Multiply-class_+3A_lh_exp">lh_exp</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or R numeric data.</p>
</td></tr>
<tr><td><code id="Multiply-class_+3A_rh_exp">rh_exp</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or R numeric data.</p>
</td></tr>
<tr><td><code id="Multiply-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Multiply-class">Multiply</a> object.</p>
</td></tr>
<tr><td><code id="Multiply-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="Multiply-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="Multiply-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="Multiply-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Multiply)</code>: Multiplies the values elementwise.
</p>
</li>
<li> <p><code>dim_from_args(Multiply)</code>: The sum of the argument dimensions - 1.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(Multiply)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(Multiply)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_psd(Multiply)</code>: Is the expression a positive semidefinite matrix?
</p>
</li>
<li> <p><code>is_nsd(Multiply)</code>: Is the expression a negative semidefinite matrix?
</p>
</li>
<li> <p><code>graph_implementation(Multiply)</code>: The graph implementation of the expression.
</p>
</li></ul>

<hr>
<h2 id='name'>Variable, Parameter, or Expression Name</h2><span id='topic+name'></span>

<h3>Description</h3>

<p>The string representation of a variable, parameter, or expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Variable-class">Variable</a>, <a href="#topic+Parameter-class">Parameter</a>, or <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <a href="#topic+Variable-class">Variable</a> or <a href="#topic+Parameter-class">Parameter</a> objects, the value in the name slot. For <a href="#topic+Expression-class">Expression</a> objects, a string indicating the nested atoms and their respective arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable()
y &lt;- Variable(3, name = "yVar")

name(x)
name(y)
</code></pre>

<hr>
<h2 id='neg'>Elementwise Negative</h2><span id='topic+neg'></span>

<h3>Description</h3>

<p>The elementwise absolute negative portion of an expression, <code class="reqn">-\min(x_i,0)</code>. This is equivalent to <code>-min_elemwise(x,0)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neg_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the negative portion of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(2)
val &lt;- matrix(c(-3,3))
prob &lt;- Problem(Minimize(neg(x)[1]), list(x == val))
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='Neg'>An alias for -MinElemwise(x, 0)</h2><span id='topic+Neg'></span>

<h3>Description</h3>

<p>An alias for -MinElemwise(x, 0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Neg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Neg_+3A_x">x</code></td>
<td>
<p>An R numeric value or <a href="#topic+Expression-class">Expression</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An alias for -MinElemwise(x, 0)
</p>

<hr>
<h2 id='NonlinearConstraint-class'>The NonlinearConstraint class.</h2><span id='topic+NonlinearConstraint-class'></span><span id='topic+.NonlinearConstraint'></span><span id='topic+NonlinearConstraint'></span>

<h3>Description</h3>

<p>This class represents a nonlinear inequality constraint, <code class="reqn">f(x) \leq 0</code> where <code class="reqn">f</code> is twice-differentiable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NonlinearConstraint(f, vars_, id = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NonlinearConstraint-class_+3A_f">f</code></td>
<td>
<p>A nonlinear function.</p>
</td></tr>
<tr><td><code id="NonlinearConstraint-class_+3A_vars_">vars_</code></td>
<td>
<p>A list of variables involved in the function.</p>
</td></tr>
<tr><td><code id="NonlinearConstraint-class_+3A_id">id</code></td>
<td>
<p>(Optional) An integer representing the unique ID of the contraint.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>f</code></dt><dd><p>A nonlinear function.</p>
</dd>
<dt><code>vars_</code></dt><dd><p>A list of variables involved in the function.</p>
</dd>
<dt><code>.x_dim</code></dt><dd><p>(Internal) The dimensions of a column vector with number of elements equal to the total elements in all the variables.</p>
</dd>
</dl>

<hr>
<h2 id='NonPosConstraint-class'>The NonPosConstraint class</h2><span id='topic+NonPosConstraint-class'></span><span id='topic+.NonPosConstraint'></span><span id='topic+name+2CNonPosConstraint-method'></span><span id='topic+is_dcp+2CNonPosConstraint-method'></span><span id='topic+is_dgp+2CNonPosConstraint-method'></span><span id='topic+canonicalize+2CNonPosConstraint-method'></span><span id='topic+residual+2CNonPosConstraint-method'></span>

<h3>Description</h3>

<p>The NonPosConstraint class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NonPosConstraint'
name(x)

## S4 method for signature 'NonPosConstraint'
is_dcp(object)

## S4 method for signature 'NonPosConstraint'
is_dgp(object)

## S4 method for signature 'NonPosConstraint'
canonicalize(object)

## S4 method for signature 'NonPosConstraint'
residual(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NonPosConstraint-class_+3A_x">x</code>, <code id="NonPosConstraint-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+NonPosConstraint-class">NonPosConstraint</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(NonPosConstraint)</code>: The string representation of the constraint.
</p>
</li>
<li> <p><code>is_dcp(NonPosConstraint)</code>: Is the constraint DCP?
</p>
</li>
<li> <p><code>is_dgp(NonPosConstraint)</code>: Is the constraint DGP?
</p>
</li>
<li> <p><code>canonicalize(NonPosConstraint)</code>: The graph implementation of the object.
</p>
</li>
<li> <p><code>residual(NonPosConstraint)</code>: The residual of the constraint.
</p>
</li></ul>

<hr>
<h2 id='Norm'>The Norm atom.</h2><span id='topic+Norm'></span>

<h3>Description</h3>

<p>Wrapper around the different norm atoms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Norm(x, p = 2, axis = NA_real_, keepdims = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Norm_+3A_x">x</code></td>
<td>
<p>The matrix to take the norm of</p>
</td></tr>
<tr><td><code id="Norm_+3A_p">p</code></td>
<td>
<p>The type of norm. Valid options include any positive integer, 'fro' (for frobenius),
'nuc' (sum of singular values), np.inf or 'inf' (infinity norm).</p>
</td></tr>
<tr><td><code id="Norm_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="Norm_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the specified norm of x.
</p>

<hr>
<h2 id='norm_inf'>Infinity-Norm</h2><span id='topic+norm_inf'></span>

<h3>Description</h3>

<p><code class="reqn">\|x\|_{\infty} = \max_{i=1,\ldots,n} |x_i|</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_inf(x, axis = NA_real_, keepdims = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_inf_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="norm_inf_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="norm_inf_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the infinity-norm of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- Variable()
b &lt;- Variable()
c &lt;- Variable()

prob &lt;- Problem(Minimize(norm_inf(a)), list(a &gt;= 2))
result &lt;- solve(prob)
result$value
result$getValue(a)

prob &lt;- Problem(Minimize(3*norm_inf(a + 2*b) + c), list(a &gt;= 2, b &lt;= -1, c == 3))
result &lt;- solve(prob)
result$value
result$getValue(a + 2*b)
result$getValue(c)

prob &lt;- Problem(Maximize(-norm_inf(a)), list(a &lt;= -2))
result &lt;- solve(prob)
result$value
result$getValue(a)

x &lt;- Variable(2)
z &lt;- Variable(2)
prob &lt;- Problem(Minimize(norm_inf(x - z) + 5), list(x &gt;= c(2,3), z &lt;= c(-1,-4)))
result &lt;- solve(prob)
result$value
result$getValue(x[1] - z[1])
</code></pre>

<hr>
<h2 id='norm_nuc'>Nuclear Norm</h2><span id='topic+norm_nuc'></span>

<h3>Description</h3>

<p>The nuclear norm, i.e. sum of the singular values of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_nuc(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_nuc_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the nuclear norm of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- Variable(3,3)
val &lt;- cbind(3:5, 6:8, 9:11)
prob &lt;- Problem(Minimize(norm_nuc(C)), list(C == val))
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='norm+2CExpression+2Ccharacter-method'>Matrix Norm</h2><span id='topic+norm+2CExpression+2Ccharacter-method'></span><span id='topic+norm'></span>

<h3>Description</h3>

<p>The matrix norm, which can be the 1-norm (&quot;1&quot;), infinity-norm (&quot;I&quot;), Frobenius norm (&quot;F&quot;), maximum modulus of all the entries (&quot;M&quot;), or the spectral norm (&quot;2&quot;), as determined by the value of type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression,character'
norm(x, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm+2B2CExpression+2B2Ccharacter-method_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>.</p>
</td></tr>
<tr><td><code id="norm+2B2CExpression+2B2Ccharacter-method_+3A_type">type</code></td>
<td>
<p>A character indicating the type of norm desired.
</p>

<ul>
<li><p> &quot;O&quot;, &quot;o&quot; or &quot;1&quot; specifies the 1-norm (maximum absolute column sum).
</p>
</li>
<li><p> &quot;I&quot; or &quot;i&quot; specifies the infinity-norm (maximum absolute row sum).
</p>
</li>
<li><p> &quot;F&quot; or &quot;f&quot; specifies the Frobenius norm (Euclidean norm of the vectorized <code>x</code>).
</p>
</li>
<li><p> &quot;M&quot; or &quot;m&quot; specifies the maximum modulus of all the elements in <code>x</code>.
</p>
</li>
<li><p> &quot;2&quot; specifies the spectral norm, which is the largest singular value of <code>x</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the norm of the input.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+p_norm">p_norm</a></code> function calculates the vector p-norm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- Variable(3,2)
val &lt;- Constant(rbind(c(1,2), c(3,4), c(5,6)))
prob &lt;- Problem(Minimize(norm(C, "F")), list(C == val))
result &lt;- solve(prob, solver = "SCS")
result$value
</code></pre>

<hr>
<h2 id='norm1'>1-Norm</h2><span id='topic+norm1'></span>

<h3>Description</h3>

<p><code class="reqn">\|x\|_1 = \sum_{i=1}^n |x_i|</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm1(x, axis = NA_real_, keepdims = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm1_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="norm1_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="norm1_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the 1-norm of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- Variable()
prob &lt;- Problem(Minimize(norm1(a)), list(a &lt;= -2))
result &lt;- solve(prob)
result$value
result$getValue(a)

prob &lt;- Problem(Maximize(-norm1(a)), list(a &lt;= -2))
result &lt;- solve(prob)
result$value
result$getValue(a)

x &lt;- Variable(2)
z &lt;- Variable(2)
prob &lt;- Problem(Minimize(norm1(x - z) + 5), list(x &gt;= c(2,3), z &lt;= c(-1,-4)))
result &lt;- solve(prob)
result$value
result$getValue(x[1] - z[1])
</code></pre>

<hr>
<h2 id='Norm1-class'>The Norm1 class.</h2><span id='topic+Norm1-class'></span><span id='topic+.Norm1'></span><span id='topic+Norm1'></span><span id='topic+name+2CNorm1-method'></span><span id='topic+to_numeric+2CNorm1-method'></span><span id='topic+allow_complex+2CNorm1-method'></span><span id='topic+sign_from_args+2CNorm1-method'></span><span id='topic+is_atom_convex+2CNorm1-method'></span><span id='topic+is_atom_concave+2CNorm1-method'></span><span id='topic+is_incr+2CNorm1-method'></span><span id='topic+is_decr+2CNorm1-method'></span><span id='topic+is_pwl+2CNorm1-method'></span><span id='topic+get_data+2CNorm1-method'></span><span id='topic+.domain+2CNorm1-method'></span><span id='topic+.grad+2CNorm1-method'></span><span id='topic+.column_grad+2CNorm1-method'></span>

<h3>Description</h3>

<p>This class represents the 1-norm of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Norm1(x, axis = NA_real_, keepdims = FALSE)

## S4 method for signature 'Norm1'
name(x)

## S4 method for signature 'Norm1'
to_numeric(object, values)

## S4 method for signature 'Norm1'
allow_complex(object)

## S4 method for signature 'Norm1'
sign_from_args(object)

## S4 method for signature 'Norm1'
is_atom_convex(object)

## S4 method for signature 'Norm1'
is_atom_concave(object)

## S4 method for signature 'Norm1'
is_incr(object, idx)

## S4 method for signature 'Norm1'
is_decr(object, idx)

## S4 method for signature 'Norm1'
is_pwl(object)

## S4 method for signature 'Norm1'
get_data(object)

## S4 method for signature 'Norm1'
.domain(object)

## S4 method for signature 'Norm1'
.grad(object, values)

## S4 method for signature 'Norm1'
.column_grad(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Norm1-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
<tr><td><code id="Norm1-class_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="Norm1-class_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Norm1-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Norm1-class">Norm1</a> object.</p>
</td></tr>
<tr><td><code id="Norm1-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="Norm1-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="Norm1-class_+3A_value">value</code></td>
<td>
<p>A numeric value</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(Norm1)</code>: The name and arguments of the atom.
</p>
</li>
<li> <p><code>to_numeric(Norm1)</code>: Returns the 1-norm of x along the given axis.
</p>
</li>
<li> <p><code>allow_complex(Norm1)</code>: Does the atom handle complex numbers?
</p>
</li>
<li> <p><code>sign_from_args(Norm1)</code>: The atom is always positive.
</p>
</li>
<li> <p><code>is_atom_convex(Norm1)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(Norm1)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_incr(Norm1)</code>: Is the composition weakly increasing in argument <code>idx</code>?
</p>
</li>
<li> <p><code>is_decr(Norm1)</code>: Is the composition weakly decreasing in argument <code>idx</code>?
</p>
</li>
<li> <p><code>is_pwl(Norm1)</code>: Is the atom piecewise linear?
</p>
</li>
<li> <p><code>get_data(Norm1)</code>: Returns the axis.
</p>
</li>
<li> <p><code>.domain(Norm1)</code>: Returns constraints describing the domain of the node
</p>
</li>
<li> <p><code>.grad(Norm1)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.column_grad(Norm1)</code>: Gives the (sub/super)gradient of the atom w.r.t. each column variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</dd>
</dl>

<hr>
<h2 id='norm2'>Euclidean Norm</h2><span id='topic+norm2'></span>

<h3>Description</h3>

<p><code class="reqn">\|x\|_2 = \left(\sum_{i=1}^n x_i^2\right)^{1/2}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm2(x, axis = NA_real_, keepdims = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm2_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="norm2_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="norm2_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the Euclidean norm of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- Variable()
prob &lt;- Problem(Minimize(norm2(a)), list(a &lt;= -2))
result &lt;- solve(prob)
result$value
result$getValue(a)

prob &lt;- Problem(Maximize(-norm2(a)), list(a &lt;= -2))
result &lt;- solve(prob)
result$value
result$getValue(a)

x &lt;- Variable(2)
z &lt;- Variable(2)
prob &lt;- Problem(Minimize(norm2(x - z) + 5), list(x &gt;= c(2,3), z &lt;= c(-1,-4)))
result &lt;- solve(prob)
result$value
result$getValue(x)
result$getValue(z)

prob &lt;- Problem(Minimize(norm2(t(x - z)) + 5), list(x &gt;= c(2,3), z &lt;= c(-1,-4)))
result &lt;- solve(prob)
result$value
result$getValue(x)
result$getValue(z)
</code></pre>

<hr>
<h2 id='Norm2'>The Norm2 atom.</h2><span id='topic+Norm2'></span>

<h3>Description</h3>

<p>The 2-norm of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Norm2(x, axis = NA_real_, keepdims = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Norm2_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
<tr><td><code id="Norm2_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="Norm2_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the 2-norm of x.
</p>

<hr>
<h2 id='NormInf-class'>The NormInf class.</h2><span id='topic+NormInf-class'></span><span id='topic+.NormInf'></span><span id='topic+NormInf'></span><span id='topic+name+2CNormInf-method'></span><span id='topic+to_numeric+2CNormInf-method'></span><span id='topic+allow_complex+2CNormInf-method'></span><span id='topic+sign_from_args+2CNormInf-method'></span><span id='topic+is_atom_convex+2CNormInf-method'></span><span id='topic+is_atom_concave+2CNormInf-method'></span><span id='topic+is_atom_log_log_convex+2CNormInf-method'></span><span id='topic+is_atom_log_log_concave+2CNormInf-method'></span><span id='topic+is_incr+2CNormInf-method'></span><span id='topic+is_decr+2CNormInf-method'></span><span id='topic+is_pwl+2CNormInf-method'></span><span id='topic+get_data+2CNormInf-method'></span><span id='topic+.domain+2CNormInf-method'></span><span id='topic+.grad+2CNormInf-method'></span><span id='topic+.column_grad+2CNormInf-method'></span>

<h3>Description</h3>

<p>This class represents the infinity-norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NormInf'
name(x)

## S4 method for signature 'NormInf'
to_numeric(object, values)

## S4 method for signature 'NormInf'
allow_complex(object)

## S4 method for signature 'NormInf'
sign_from_args(object)

## S4 method for signature 'NormInf'
is_atom_convex(object)

## S4 method for signature 'NormInf'
is_atom_concave(object)

## S4 method for signature 'NormInf'
is_atom_log_log_convex(object)

## S4 method for signature 'NormInf'
is_atom_log_log_concave(object)

## S4 method for signature 'NormInf'
is_incr(object, idx)

## S4 method for signature 'NormInf'
is_decr(object, idx)

## S4 method for signature 'NormInf'
is_pwl(object)

## S4 method for signature 'NormInf'
get_data(object)

## S4 method for signature 'NormInf'
.domain(object)

## S4 method for signature 'NormInf'
.grad(object, values)

## S4 method for signature 'NormInf'
.column_grad(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormInf-class_+3A_x">x</code>, <code id="NormInf-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+NormInf-class">NormInf</a> object.</p>
</td></tr>
<tr><td><code id="NormInf-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="NormInf-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="NormInf-class_+3A_value">value</code></td>
<td>
<p>A numeric value</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(NormInf)</code>: The name and arguments of the atom.
</p>
</li>
<li> <p><code>to_numeric(NormInf)</code>: Returns the infinity norm of <code>x</code>.
</p>
</li>
<li> <p><code>allow_complex(NormInf)</code>: Does the atom handle complex numbers?
</p>
</li>
<li> <p><code>sign_from_args(NormInf)</code>: The atom is always positive.
</p>
</li>
<li> <p><code>is_atom_convex(NormInf)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(NormInf)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(NormInf)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(NormInf)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(NormInf)</code>: Is the composition weakly increasing in argument <code>idx</code>?
</p>
</li>
<li> <p><code>is_decr(NormInf)</code>: Is the composition weakly decreasing in argument <code>idx</code>?
</p>
</li>
<li> <p><code>is_pwl(NormInf)</code>: Is the atom piecewise linear?
</p>
</li>
<li> <p><code>get_data(NormInf)</code>: Returns the axis.
</p>
</li>
<li> <p><code>.domain(NormInf)</code>: Returns constraints describing the domain of the node
</p>
</li>
<li> <p><code>.grad(NormInf)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.column_grad(NormInf)</code>: Gives the (sub/super)gradient of the atom w.r.t. each column variable
</p>
</li></ul>

<hr>
<h2 id='NormNuc-class'>The NormNuc class.</h2><span id='topic+NormNuc-class'></span><span id='topic+.NormNuc'></span><span id='topic+NormNuc'></span><span id='topic+to_numeric+2CNormNuc-method'></span><span id='topic+allow_complex+2CNormNuc-method'></span><span id='topic+dim_from_args+2CNormNuc-method'></span><span id='topic+sign_from_args+2CNormNuc-method'></span><span id='topic+is_atom_convex+2CNormNuc-method'></span><span id='topic+is_atom_concave+2CNormNuc-method'></span><span id='topic+is_incr+2CNormNuc-method'></span><span id='topic+is_decr+2CNormNuc-method'></span><span id='topic+.grad+2CNormNuc-method'></span>

<h3>Description</h3>

<p>The nuclear norm, i.e. sum of the singular values of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormNuc(A)

## S4 method for signature 'NormNuc'
to_numeric(object, values)

## S4 method for signature 'NormNuc'
allow_complex(object)

## S4 method for signature 'NormNuc'
dim_from_args(object)

## S4 method for signature 'NormNuc'
sign_from_args(object)

## S4 method for signature 'NormNuc'
is_atom_convex(object)

## S4 method for signature 'NormNuc'
is_atom_concave(object)

## S4 method for signature 'NormNuc'
is_incr(object, idx)

## S4 method for signature 'NormNuc'
is_decr(object, idx)

## S4 method for signature 'NormNuc'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormNuc-class_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="NormNuc-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+NormNuc-class">NormNuc</a> object.</p>
</td></tr>
<tr><td><code id="NormNuc-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="NormNuc-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(NormNuc)</code>: The nuclear norm (i.e., the sum of the singular values) of <code>A</code>.
</p>
</li>
<li> <p><code>allow_complex(NormNuc)</code>: Does the atom handle complex numbers?
</p>
</li>
<li> <p><code>dim_from_args(NormNuc)</code>: The atom is a scalar.
</p>
</li>
<li> <p><code>sign_from_args(NormNuc)</code>: The atom is positive.
</p>
</li>
<li> <p><code>is_atom_convex(NormNuc)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(NormNuc)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_incr(NormNuc)</code>: The atom is not monotonic in any argument.
</p>
</li>
<li> <p><code>is_decr(NormNuc)</code>: The atom is not monotonic in any argument.
</p>
</li>
<li> <p><code>.grad(NormNuc)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>A</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='Objective-arith'>Arithmetic Operations on Objectives</h2><span id='topic+Objective-arith'></span><span id='topic++2B+2CObjective+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2CObjective-method'></span><span id='topic+-+2CMinimize+2Cmissing-method'></span><span id='topic++2B+2CMinimize+2CMinimize-method'></span><span id='topic++2B+2CMinimize+2CMaximize-method'></span><span id='topic+-+2CObjective+2CMinimize-method'></span><span id='topic+-+2CObjective+2CMaximize-method'></span><span id='topic+-+2CMinimize+2CObjective-method'></span><span id='topic+-+2CMaximize+2CObjective-method'></span><span id='topic+-+2CObjective+2Cnumeric-method'></span><span id='topic+-+2Cnumeric+2CObjective-method'></span><span id='topic++2A+2CMinimize+2Cnumeric-method'></span><span id='topic++2A+2CMaximize+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2CMinimize-method'></span><span id='topic++2A+2Cnumeric+2CMaximize-method'></span><span id='topic++2F+2CObjective+2Cnumeric-method'></span><span id='topic+-+2CMaximize+2Cmissing-method'></span><span id='topic++2B+2CMaximize+2CMaximize-method'></span><span id='topic++2B+2CMaximize+2CMinimize-method'></span>

<h3>Description</h3>

<p>Add, subtract, multiply, or divide optimization objectives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Objective,numeric'
e1 + e2

## S4 method for signature 'numeric,Objective'
e1 + e2

## S4 method for signature 'Minimize,missing'
e1 - e2

## S4 method for signature 'Minimize,Minimize'
e1 + e2

## S4 method for signature 'Minimize,Maximize'
e1 + e2

## S4 method for signature 'Objective,Minimize'
e1 - e2

## S4 method for signature 'Objective,Maximize'
e1 - e2

## S4 method for signature 'Minimize,Objective'
e1 - e2

## S4 method for signature 'Maximize,Objective'
e1 - e2

## S4 method for signature 'Objective,numeric'
e1 - e2

## S4 method for signature 'numeric,Objective'
e1 - e2

## S4 method for signature 'Minimize,numeric'
e1 * e2

## S4 method for signature 'Maximize,numeric'
e1 * e2

## S4 method for signature 'numeric,Minimize'
e1 * e2

## S4 method for signature 'numeric,Maximize'
e1 * e2

## S4 method for signature 'Objective,numeric'
e1 / e2

## S4 method for signature 'Maximize,missing'
e1 - e2

## S4 method for signature 'Maximize,Maximize'
e1 + e2

## S4 method for signature 'Maximize,Minimize'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Objective-arith_+3A_e1">e1</code></td>
<td>
<p>The left-hand <a href="#topic+Minimize-class">Minimize</a>, <a href="#topic+Maximize-class">Maximize</a>, or numeric value.</p>
</td></tr>
<tr><td><code id="Objective-arith_+3A_e2">e2</code></td>
<td>
<p>The right-hand <a href="#topic+Minimize-class">Minimize</a>, <a href="#topic+Maximize-class">Maximize</a>, or numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Minimize-class">Minimize</a> or <a href="#topic+Maximize-class">Maximize</a> object.
</p>

<hr>
<h2 id='Objective-class'>The Objective class.</h2><span id='topic+Objective-class'></span><span id='topic+.Objective'></span><span id='topic+Objective'></span><span id='topic+value+2CObjective-method'></span><span id='topic+is_quadratic+2CObjective-method'></span><span id='topic+is_qpwa+2CObjective-method'></span>

<h3>Description</h3>

<p>This class represents an optimization objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Objective(expr)

## S4 method for signature 'Objective'
value(object)

## S4 method for signature 'Objective'
is_quadratic(object)

## S4 method for signature 'Objective'
is_qpwa(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Objective-class_+3A_expr">expr</code></td>
<td>
<p>A scalar <a href="#topic+Expression-class">Expression</a> to optimize.</p>
</td></tr>
<tr><td><code id="Objective-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Objective-class">Objective</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>value(Objective)</code>: The value of the objective expression.
</p>
</li>
<li> <p><code>is_quadratic(Objective)</code>: Is the objective a quadratic function?
</p>
</li>
<li> <p><code>is_qpwa(Objective)</code>: Is the objective a quadratic of piecewise affine function?
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>A scalar <a href="#topic+Expression-class">Expression</a> to optimize.</p>
</dd>
</dl>

<hr>
<h2 id='one_minus_pos'>Difference on Restricted Domain</h2><span id='topic+one_minus_pos'></span>

<h3>Description</h3>

<p>The difference <code class="reqn">1 - x</code> with domain <code class="reqn">\{x : 0 &lt; x &lt; 1\}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_minus_pos(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_minus_pos_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This atom is log-log concave.
</p>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing one minus the input restricted to <code class="reqn">(0,1)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(pos = TRUE)
y &lt;- Variable(pos = TRUE)
prob &lt;- Problem(Maximize(one_minus_pos(x*y)), list(x &lt;= 2 * y^2, y &gt;= .2))
result &lt;- solve(prob, gp = TRUE)
result$value
result$getValue(x)
result$getValue(y)

</code></pre>

<hr>
<h2 id='OneMinusPos-class'>The OneMinusPos class.</h2><span id='topic+OneMinusPos-class'></span><span id='topic+.OneMinusPos'></span><span id='topic+OneMinusPos'></span><span id='topic+name+2COneMinusPos-method'></span><span id='topic+to_numeric+2COneMinusPos-method'></span><span id='topic+dim_from_args+2COneMinusPos-method'></span><span id='topic+sign_from_args+2COneMinusPos-method'></span><span id='topic+is_atom_convex+2COneMinusPos-method'></span><span id='topic+is_atom_concave+2COneMinusPos-method'></span><span id='topic+is_atom_log_log_convex+2COneMinusPos-method'></span><span id='topic+is_atom_log_log_concave+2COneMinusPos-method'></span><span id='topic+is_incr+2COneMinusPos-method'></span><span id='topic+is_decr+2COneMinusPos-method'></span><span id='topic+.grad+2COneMinusPos-method'></span>

<h3>Description</h3>

<p>This class represents the difference <code class="reqn">1 - x</code> with domain <code class="reqn">\{x : 0 &lt; x &lt; 1</code>}
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OneMinusPos(x)

## S4 method for signature 'OneMinusPos'
name(x)

## S4 method for signature 'OneMinusPos'
to_numeric(object, values)

## S4 method for signature 'OneMinusPos'
dim_from_args(object)

## S4 method for signature 'OneMinusPos'
sign_from_args(object)

## S4 method for signature 'OneMinusPos'
is_atom_convex(object)

## S4 method for signature 'OneMinusPos'
is_atom_concave(object)

## S4 method for signature 'OneMinusPos'
is_atom_log_log_convex(object)

## S4 method for signature 'OneMinusPos'
is_atom_log_log_concave(object)

## S4 method for signature 'OneMinusPos'
is_incr(object, idx)

## S4 method for signature 'OneMinusPos'
is_decr(object, idx)

## S4 method for signature 'OneMinusPos'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OneMinusPos-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="OneMinusPos-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+OneMinusPos-class">OneMinusPos</a> object.</p>
</td></tr>
<tr><td><code id="OneMinusPos-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="OneMinusPos-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(OneMinusPos)</code>: The name and arguments of the atom.
</p>
</li>
<li> <p><code>to_numeric(OneMinusPos)</code>: Returns one minus the value.
</p>
</li>
<li> <p><code>dim_from_args(OneMinusPos)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>sign_from_args(OneMinusPos)</code>: Returns the sign (is positive, is negative) of the atom.
</p>
</li>
<li> <p><code>is_atom_convex(OneMinusPos)</code>: Is the atom convex?
</p>
</li>
<li> <p><code>is_atom_concave(OneMinusPos)</code>: Is the atom concave?
</p>
</li>
<li> <p><code>is_atom_log_log_convex(OneMinusPos)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(OneMinusPos)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(OneMinusPos)</code>: Is the atom weakly increasing in the argument <code>idx</code>?
</p>
</li>
<li> <p><code>is_decr(OneMinusPos)</code>: Is the atom weakly decreasing in the argument <code>idx</code>?
</p>
</li>
<li> <p><code>.grad(OneMinusPos)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='OSQP-class'>An interface for the OSQP solver.</h2><span id='topic+OSQP-class'></span><span id='topic+OSQP'></span><span id='topic+status_map+2COSQP-method'></span><span id='topic+name+2COSQP-method'></span><span id='topic+import_solver+2COSQP-method'></span><span id='topic+invert+2COSQP+2Clist+2CInverseData-method'></span><span id='topic+solve_via_data+2COSQP-method'></span>

<h3>Description</h3>

<p>An interface for the OSQP solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSQP()

## S4 method for signature 'OSQP'
status_map(solver, status)

## S4 method for signature 'OSQP'
name(x)

## S4 method for signature 'OSQP'
import_solver(solver)

## S4 method for signature 'OSQP,list,InverseData'
invert(object, solution, inverse_data)

## S4 method for signature 'OSQP'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OSQP-class_+3A_solver">solver</code>, <code id="OSQP-class_+3A_object">object</code>, <code id="OSQP-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+OSQP-class">OSQP</a> object.</p>
</td></tr>
<tr><td><code id="OSQP-class_+3A_status">status</code></td>
<td>
<p>A status code returned by the solver.</p>
</td></tr>
<tr><td><code id="OSQP-class_+3A_solution">solution</code></td>
<td>
<p>The raw solution returned by the solver.</p>
</td></tr>
<tr><td><code id="OSQP-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A <a href="#topic+InverseData-class">InverseData</a> object containing data necessary for the inversion.</p>
</td></tr>
<tr><td><code id="OSQP-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="OSQP-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="OSQP-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="OSQP-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance.</p>
</td></tr>
<tr><td><code id="OSQP-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance.</p>
</td></tr>
<tr><td><code id="OSQP-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance.</p>
</td></tr>
<tr><td><code id="OSQP-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="OSQP-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="OSQP-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>status_map(OSQP)</code>: Converts status returned by the OSQP solver to its respective CVXPY status.
</p>
</li>
<li> <p><code>name(OSQP)</code>: Returns the name of the solver.
</p>
</li>
<li> <p><code>import_solver(OSQP)</code>: Imports the solver.
</p>
</li>
<li> <p><code>invert(object = OSQP, solution = list, inverse_data = InverseData)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li>
<li> <p><code>solve_via_data(OSQP)</code>: Solve a problem represented by data returned from apply.
</p>
</li></ul>

<hr>
<h2 id='p_norm'>P-Norm</h2><span id='topic+p_norm'></span>

<h3>Description</h3>

<p>The vector p-norm. If given a matrix variable, <code>p_norm</code> will treat it as a vector and compute the p-norm of the concatenated columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_norm(x, p = 2, axis = NA_real_, keepdims = FALSE, max_denom = 1024)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_norm_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="p_norm_+3A_p">p</code></td>
<td>
<p>A number greater than or equal to 1, or equal to positive infinity.</p>
</td></tr>
<tr><td><code id="p_norm_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="p_norm_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="p_norm_+3A_max_denom">max_denom</code></td>
<td>
<p>(Optional) The maximum denominator considered in forming a rational approximation for <code class="reqn">p</code>. The default is 1024.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code class="reqn">p \geq 1</code>, the p-norm is given by </p>
<p style="text-align: center;"><code class="reqn">\|x\|_p = \left(\sum_{i=1}^n |x_i|^p\right)^{1/p}</code>
</p>
<p> with domain <code class="reqn">x \in \mathbf{R}^n</code>.
For <code class="reqn">p &lt; 1, p \neq 0</code>, the p-norm is given by </p>
<p style="text-align: center;"><code class="reqn">\|x\|_p = \left(\sum_{i=1}^n x_i^p\right)^{1/p}</code>
</p>
<p> with domain <code class="reqn">x \in \mathbf{R}^n_+</code>.
</p>

<ul>
<li><p> Note that the &quot;p-norm&quot; is actually a <strong>norm</strong> only when <code class="reqn">p \geq 1</code> or <code class="reqn">p = +\infty</code>. For these cases, it is convex.
</p>
</li>
<li><p> The expression is undefined when <code class="reqn">p = 0</code>.
</p>
</li>
<li><p> Otherwise, when <code class="reqn">p &lt; 1</code>, the expression is concave, but not a true norm.
</p>
</li></ul>



<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the p-norm of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(3)
prob &lt;- Problem(Minimize(p_norm(x,2)))
result &lt;- solve(prob)
result$value
result$getValue(x)

prob &lt;- Problem(Minimize(p_norm(x,Inf)))
result &lt;- solve(prob)
result$value
result$getValue(x)

## Not run: 
  a &lt;- c(1.0, 2, 3)
  prob &lt;- Problem(Minimize(p_norm(x,1.6)), list(t(x) %*% a &gt;= 1))
  result &lt;- solve(prob)
  result$value
  result$getValue(x)

  prob &lt;- Problem(Minimize(sum(abs(x - a))), list(p_norm(x,-1) &gt;= 0))
  result &lt;- solve(prob)
  result$value
  result$getValue(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='Parameter-class'>The Parameter class.</h2><span id='topic+Parameter-class'></span><span id='topic+.Parameter'></span><span id='topic+Parameter'></span><span id='topic+get_data+2CParameter-method'></span><span id='topic+name+2CParameter-method'></span><span id='topic+value+2CParameter-method'></span><span id='topic+value+3C-+2CParameter-method'></span><span id='topic+grad+2CParameter-method'></span><span id='topic+parameters+2CParameter-method'></span><span id='topic+canonicalize+2CParameter-method'></span>

<h3>Description</h3>

<p>This class represents a parameter, either scalar or a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Parameter(
  rows = NULL,
  cols = NULL,
  name = NA_character_,
  value = NA_real_,
  ...
)

## S4 method for signature 'Parameter'
get_data(object)

## S4 method for signature 'Parameter'
name(x)

## S4 method for signature 'Parameter'
value(object)

## S4 replacement method for signature 'Parameter'
value(object) &lt;- value

## S4 method for signature 'Parameter'
grad(object)

## S4 method for signature 'Parameter'
parameters(object)

## S4 method for signature 'Parameter'
canonicalize(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Parameter-class_+3A_rows">rows</code></td>
<td>
<p>The number of rows in the parameter.</p>
</td></tr>
<tr><td><code id="Parameter-class_+3A_cols">cols</code></td>
<td>
<p>The number of columns in the parameter.</p>
</td></tr>
<tr><td><code id="Parameter-class_+3A_name">name</code></td>
<td>
<p>(Optional) A character string representing the name of the parameter.</p>
</td></tr>
<tr><td><code id="Parameter-class_+3A_value">value</code></td>
<td>
<p>(Optional) A numeric element, vector, matrix, or data.frame. Defaults to <code>NA</code> and may be changed with <code>value&lt;-</code> later.</p>
</td></tr>
<tr><td><code id="Parameter-class_+3A_...">...</code></td>
<td>
<p>Additional attribute arguments. See <a href="#topic+Leaf-class">Leaf</a> for details.</p>
</td></tr>
<tr><td><code id="Parameter-class_+3A_object">object</code>, <code id="Parameter-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Parameter-class">Parameter</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>get_data(Parameter)</code>: Returns <code>list(dim, name, value, attributes)</code>.
</p>
</li>
<li> <p><code>name(Parameter)</code>: The name of the parameter.
</p>
</li>
<li> <p><code>value(Parameter)</code>: The value of the parameter.
</p>
</li>
<li> <p><code>value(Parameter) &lt;- value</code>: Set the value of the parameter.
</p>
</li>
<li> <p><code>grad(Parameter)</code>: An empty list since the gradient of a parameter is zero.
</p>
</li>
<li> <p><code>parameters(Parameter)</code>: Returns itself as a parameter.
</p>
</li>
<li> <p><code>canonicalize(Parameter)</code>: The canonical form of the parameter.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>rows</code></dt><dd><p>The number of rows in the parameter.</p>
</dd>
<dt><code>cols</code></dt><dd><p>The number of columns in the parameter.</p>
</dd>
<dt><code>name</code></dt><dd><p>(Optional) A character string representing the name of the parameter.</p>
</dd>
<dt><code>value</code></dt><dd><p>(Optional) A numeric element, vector, matrix, or data.frame. Defaults to <code>NA</code> and may be changed with <code>value&lt;-</code> later.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Parameter(3, name = "x0", nonpos = TRUE) ## 3-vec negative
is_nonneg(x)
is_nonpos(x)
size(x)
</code></pre>

<hr>
<h2 id='perform'>Perform Reduction</h2><span id='topic+perform'></span>

<h3>Description</h3>

<p>Performs the reduction on a problem and returns an equivalent problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perform(object, problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perform_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Reduction-class">Reduction</a> object.</p>
</td></tr>
<tr><td><code id="perform_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> on which the reduction will be performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>

<dl>
<dt>&quot;problem&quot;</dt><dd><p>A <a href="#topic+Problem-class">Problem</a> or list representing the equivalent problem.</p>
</dd>
<dt>&quot;inverse_data&quot;</dt><dd><p>A <a href="#topic+InverseData-class">InverseData</a> or list containing the data needed to invert this particular reduction.</p>
</dd>
</dl>


<hr>
<h2 id='pf_eigenvalue'>Perron-Frobenius Eigenvalue</h2><span id='topic+pf_eigenvalue'></span>

<h3>Description</h3>

<p>The Perron-Frobenius eigenvalue of a positive matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pf_eigenvalue(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pf_eigenvalue_+3A_x">X</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or positive square matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an elementwise positive matrix <code class="reqn">X</code>, this atom represents its spectral radius, i.e., the magnitude of its largest eigenvalue.
Because <code class="reqn">X</code> is positive, the spectral radius equals its largest eigenvalue, which is guaranteed to be positive.
</p>
<p>This atom is log-log convex.
</p>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the largest eigenvalue of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 3
X &lt;- Variable(n, n, pos=TRUE)
objective_fn &lt;- pf_eigenvalue(X)
constraints &lt;- list( X[1,1]== 1.0,
                     X[1,3] == 1.9,
                     X[2,2] == .8,
                     X[3,1] == 3.2,
                     X[3,2] == 5.9,
                     X[1, 2] * X[2, 1] * X[2,3] * X[3,3] == 1)
problem &lt;- Problem(Minimize(objective_fn), constraints)
result &lt;- solve(problem, gp=TRUE)
result$value
result$getValue(X)

</code></pre>

<hr>
<h2 id='PfEigenvalue-class'>The PfEigenvalue class.</h2><span id='topic+PfEigenvalue-class'></span><span id='topic+.PfEigenvalue'></span><span id='topic+PfEigenvalue'></span><span id='topic+name+2CPfEigenvalue-method'></span><span id='topic+to_numeric+2CPfEigenvalue-method'></span><span id='topic+dim_from_args+2CPfEigenvalue-method'></span><span id='topic+sign_from_args+2CPfEigenvalue-method'></span><span id='topic+is_atom_convex+2CPfEigenvalue-method'></span><span id='topic+is_atom_concave+2CPfEigenvalue-method'></span><span id='topic+is_atom_log_log_convex+2CPfEigenvalue-method'></span><span id='topic+is_atom_log_log_concave+2CPfEigenvalue-method'></span><span id='topic+is_incr+2CPfEigenvalue-method'></span><span id='topic+is_decr+2CPfEigenvalue-method'></span><span id='topic+.grad+2CPfEigenvalue-method'></span>

<h3>Description</h3>

<p>This class represents the Perron-Frobenius eigenvalue of a positive matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PfEigenvalue(X)

## S4 method for signature 'PfEigenvalue'
name(x)

## S4 method for signature 'PfEigenvalue'
to_numeric(object, values)

## S4 method for signature 'PfEigenvalue'
dim_from_args(object)

## S4 method for signature 'PfEigenvalue'
sign_from_args(object)

## S4 method for signature 'PfEigenvalue'
is_atom_convex(object)

## S4 method for signature 'PfEigenvalue'
is_atom_concave(object)

## S4 method for signature 'PfEigenvalue'
is_atom_log_log_convex(object)

## S4 method for signature 'PfEigenvalue'
is_atom_log_log_concave(object)

## S4 method for signature 'PfEigenvalue'
is_incr(object, idx)

## S4 method for signature 'PfEigenvalue'
is_decr(object, idx)

## S4 method for signature 'PfEigenvalue'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PfEigenvalue-class_+3A_x">X</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="PfEigenvalue-class_+3A_x">x</code>, <code id="PfEigenvalue-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+PfEigenvalue-class">PfEigenvalue</a> object.</p>
</td></tr>
<tr><td><code id="PfEigenvalue-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="PfEigenvalue-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(PfEigenvalue)</code>: The name and arguments of the atom.
</p>
</li>
<li> <p><code>to_numeric(PfEigenvalue)</code>: Returns the Perron-Frobenius eigenvalue of <code>X</code>.
</p>
</li>
<li> <p><code>dim_from_args(PfEigenvalue)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>sign_from_args(PfEigenvalue)</code>: Returns the sign (is positive, is negative) of the atom.
</p>
</li>
<li> <p><code>is_atom_convex(PfEigenvalue)</code>: Is the atom convex?
</p>
</li>
<li> <p><code>is_atom_concave(PfEigenvalue)</code>: Is the atom concave?
</p>
</li>
<li> <p><code>is_atom_log_log_convex(PfEigenvalue)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(PfEigenvalue)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(PfEigenvalue)</code>: Is the atom weakly increasing in the argument <code>idx</code>?
</p>
</li>
<li> <p><code>is_decr(PfEigenvalue)</code>: Is the atom weakly decreasing in the argument <code>idx</code>?
</p>
</li>
<li> <p><code>.grad(PfEigenvalue)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>X</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='Pnorm-class'>The Pnorm class.</h2><span id='topic+Pnorm-class'></span><span id='topic+.Pnorm'></span><span id='topic+Pnorm'></span><span id='topic+allow_complex+2CPnorm-method'></span><span id='topic+to_numeric+2CPnorm-method'></span><span id='topic+validate_args+2CPnorm-method'></span><span id='topic+sign_from_args+2CPnorm-method'></span><span id='topic+is_atom_convex+2CPnorm-method'></span><span id='topic+is_atom_concave+2CPnorm-method'></span><span id='topic+is_atom_log_log_convex+2CPnorm-method'></span><span id='topic+is_atom_log_log_concave+2CPnorm-method'></span><span id='topic+is_incr+2CPnorm-method'></span><span id='topic+is_decr+2CPnorm-method'></span><span id='topic+is_pwl+2CPnorm-method'></span><span id='topic+get_data+2CPnorm-method'></span><span id='topic+name+2CPnorm-method'></span><span id='topic+.domain+2CPnorm-method'></span><span id='topic+.grad+2CPnorm-method'></span><span id='topic+.column_grad+2CPnorm-method'></span>

<h3>Description</h3>

<p>This class represents the vector p-norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pnorm(x, p = 2, axis = NA_real_, keepdims = FALSE, max_denom = 1024)

## S4 method for signature 'Pnorm'
allow_complex(object)

## S4 method for signature 'Pnorm'
to_numeric(object, values)

## S4 method for signature 'Pnorm'
validate_args(object)

## S4 method for signature 'Pnorm'
sign_from_args(object)

## S4 method for signature 'Pnorm'
is_atom_convex(object)

## S4 method for signature 'Pnorm'
is_atom_concave(object)

## S4 method for signature 'Pnorm'
is_atom_log_log_convex(object)

## S4 method for signature 'Pnorm'
is_atom_log_log_concave(object)

## S4 method for signature 'Pnorm'
is_incr(object, idx)

## S4 method for signature 'Pnorm'
is_decr(object, idx)

## S4 method for signature 'Pnorm'
is_pwl(object)

## S4 method for signature 'Pnorm'
get_data(object)

## S4 method for signature 'Pnorm'
name(x)

## S4 method for signature 'Pnorm'
.domain(object)

## S4 method for signature 'Pnorm'
.grad(object, values)

## S4 method for signature 'Pnorm'
.column_grad(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pnorm-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</td></tr>
<tr><td><code id="Pnorm-class_+3A_p">p</code></td>
<td>
<p>A number greater than or equal to 1, or equal to positive infinity.</p>
</td></tr>
<tr><td><code id="Pnorm-class_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="Pnorm-class_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Pnorm-class_+3A_max_denom">max_denom</code></td>
<td>
<p>(Optional) The maximum denominator considered in forming a rational approximation for <code class="reqn">p</code>. The default is 1024.</p>
</td></tr>
<tr><td><code id="Pnorm-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Pnorm-class">Pnorm</a> object.</p>
</td></tr>
<tr><td><code id="Pnorm-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="Pnorm-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="Pnorm-class_+3A_value">value</code></td>
<td>
<p>A numeric value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If given a matrix variable, <code>Pnorm</code> will treat it as a vector and compute the p-norm of the concatenated columns.
</p>
<p>For <code class="reqn">p \geq 1</code>, the p-norm is given by </p>
<p style="text-align: center;"><code class="reqn">\|x\|_p = \left(\sum_{i=1}^n |x_i|^p\right)^{1/p}</code>
</p>
<p> with domain <code class="reqn">x \in \mathbf{R}^n</code>.
For <code class="reqn">p &lt; 1, p\neq 0</code>, the p-norm is given by </p>
<p style="text-align: center;"><code class="reqn">\|x\|_p = \left(\sum_{i=1}^n x_i^p\right)^{1/p}</code>
</p>
<p> with domain <code class="reqn">x \in \mathbf{R}^n_+</code>.
</p>

<ul>
<li><p> Note that the &quot;p-norm&quot; is actually a <strong>norm</strong> only when <code class="reqn">p \geq 1</code> or <code class="reqn">p = +\infty</code>. For these cases, it is convex.
</p>
</li>
<li><p> The expression is undefined when <code class="reqn">p = 0</code>.
</p>
</li>
<li><p> Otherwise, when <code class="reqn">p &lt; 1</code>, the expression is concave, but not a true norm.
</p>
</li></ul>



<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>allow_complex(Pnorm)</code>: Does the atom handle complex numbers?
</p>
</li>
<li> <p><code>to_numeric(Pnorm)</code>: The p-norm of <code>x</code>.
</p>
</li>
<li> <p><code>validate_args(Pnorm)</code>: Check that the arguments are valid.
</p>
</li>
<li> <p><code>sign_from_args(Pnorm)</code>: The atom is positive.
</p>
</li>
<li> <p><code>is_atom_convex(Pnorm)</code>: The atom is convex if <code class="reqn">p \geq 1</code>.
</p>
</li>
<li> <p><code>is_atom_concave(Pnorm)</code>: The atom is concave if <code class="reqn">p &lt; 1</code>.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(Pnorm)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(Pnorm)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(Pnorm)</code>: The atom is weakly increasing if <code class="reqn">p &lt; 1</code> or <code class="reqn">p &gt; 1</code> and <code>x</code> is positive.
</p>
</li>
<li> <p><code>is_decr(Pnorm)</code>: The atom is weakly decreasing if <code class="reqn">p &gt; 1</code> and <code>x</code> is negative.
</p>
</li>
<li> <p><code>is_pwl(Pnorm)</code>: The atom is not piecewise linear unless <code class="reqn">p = 1</code> or <code class="reqn">p = \infty</code>.
</p>
</li>
<li> <p><code>get_data(Pnorm)</code>: Returns <code>list(p, axis)</code>.
</p>
</li>
<li> <p><code>name(Pnorm)</code>: The name and arguments of the atom.
</p>
</li>
<li> <p><code>.domain(Pnorm)</code>: Returns constraints describing the domain of the node
</p>
</li>
<li> <p><code>.grad(Pnorm)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.column_grad(Pnorm)</code>: Gives the (sub/super)gradient of the atom w.r.t. each column variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</dd>
<dt><code>p</code></dt><dd><p>A number greater than or equal to 1, or equal to positive infinity.</p>
</dd>
<dt><code>max_denom</code></dt><dd><p>The maximum denominator considered in forming a rational approximation for <code class="reqn">p</code>.</p>
</dd>
<dt><code>axis</code></dt><dd><p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</dd>
<dt><code>keepdims</code></dt><dd><p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</dd>
<dt><code>.approx_error</code></dt><dd><p>(Internal) The absolute difference between <code class="reqn">p</code> and its rational approximation.</p>
</dd>
<dt><code>.original_p</code></dt><dd><p>(Internal) The original input <code class="reqn">p</code>.</p>
</dd>
</dl>

<hr>
<h2 id='pos'>Elementwise Positive</h2><span id='topic+pos'></span>

<h3>Description</h3>

<p>The elementwise positive portion of an expression, <code class="reqn">\max(x_i,0)</code>. This is equivalent to <code>max_elemwise(x,0)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pos(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pos_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the positive portion of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(2)
val &lt;- matrix(c(-3,2))
prob &lt;- Problem(Minimize(pos(x)[1]), list(x == val))
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='Pos'>An alias for MaxElemwise(x, 0)</h2><span id='topic+Pos'></span>

<h3>Description</h3>

<p>An alias for MaxElemwise(x, 0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pos(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pos_+3A_x">x</code></td>
<td>
<p>An R numeric value or <a href="#topic+Expression-class">Expression</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An alias for MaxElemwise(x, 0)
</p>

<hr>
<h2 id='Power-class'>The Power class.</h2><span id='topic+Power-class'></span><span id='topic+.Power'></span><span id='topic+Power'></span><span id='topic+to_numeric+2CPower-method'></span><span id='topic+sign_from_args+2CPower-method'></span><span id='topic+is_atom_convex+2CPower-method'></span><span id='topic+is_atom_concave+2CPower-method'></span><span id='topic+is_atom_log_log_convex+2CPower-method'></span><span id='topic+is_atom_log_log_concave+2CPower-method'></span><span id='topic+is_constant+2CPower-method'></span><span id='topic+is_incr+2CPower-method'></span><span id='topic+is_decr+2CPower-method'></span><span id='topic+is_quadratic+2CPower-method'></span><span id='topic+is_qpwa+2CPower-method'></span><span id='topic+.grad+2CPower-method'></span><span id='topic+.domain+2CPower-method'></span><span id='topic+get_data+2CPower-method'></span><span id='topic+copy+2CPower-method'></span><span id='topic+name+2CPower-method'></span>

<h3>Description</h3>

<p>This class represents the elementwise power function <code class="reqn">f(x) = x^p</code>.
If <code>expr</code> is a CVXR expression, then <code>expr^p</code> is equivalent to <code>Power(expr, p)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Power(x, p, max_denom = 1024)

## S4 method for signature 'Power'
to_numeric(object, values)

## S4 method for signature 'Power'
sign_from_args(object)

## S4 method for signature 'Power'
is_atom_convex(object)

## S4 method for signature 'Power'
is_atom_concave(object)

## S4 method for signature 'Power'
is_atom_log_log_convex(object)

## S4 method for signature 'Power'
is_atom_log_log_concave(object)

## S4 method for signature 'Power'
is_constant(object)

## S4 method for signature 'Power'
is_incr(object, idx)

## S4 method for signature 'Power'
is_decr(object, idx)

## S4 method for signature 'Power'
is_quadratic(object)

## S4 method for signature 'Power'
is_qpwa(object)

## S4 method for signature 'Power'
.grad(object, values)

## S4 method for signature 'Power'
.domain(object)

## S4 method for signature 'Power'
get_data(object)

## S4 method for signature 'Power'
copy(object, args = NULL, id_objects = list())

## S4 method for signature 'Power'
name(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Power-class_+3A_x">x</code></td>
<td>
<p>The <a href="#topic+Expression-class">Expression</a> to be raised to a power.</p>
</td></tr>
<tr><td><code id="Power-class_+3A_p">p</code></td>
<td>
<p>A numeric value indicating the scalar power.</p>
</td></tr>
<tr><td><code id="Power-class_+3A_max_denom">max_denom</code></td>
<td>
<p>The maximum denominator considered in forming a rational approximation of <code>p</code>.</p>
</td></tr>
<tr><td><code id="Power-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Power-class">Power</a> object.</p>
</td></tr>
<tr><td><code id="Power-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="Power-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="Power-class_+3A_args">args</code></td>
<td>
<p>A list of arguments to reconstruct the atom. If args=NULL, use the current args of the atom</p>
</td></tr>
<tr><td><code id="Power-class_+3A_id_objects">id_objects</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code class="reqn">p = 0</code>, <code class="reqn">f(x) = 1</code>, constant, positive.
</p>
<p>For <code class="reqn">p = 1</code>, <code class="reqn">f(x) = x</code>, affine, increasing, same sign as <code class="reqn">x</code>.
</p>
<p>For <code class="reqn">p = 2,4,8,...</code>, <code class="reqn">f(x) = |x|^p</code>, convex, signed monotonicity, positive.
</p>
<p>For <code class="reqn">p &lt; 0</code> and <code class="reqn">f(x) = </code>
</p>

<dl>
<dt><code class="reqn">x^p</code></dt><dd><p> for <code class="reqn">x &gt; 0</code></p>
</dd>
<dt><code class="reqn">+\infty</code></dt><dd><p><code class="reqn">x \leq 0</code></p>
</dd>
</dl>
<p>, this function is convex, decreasing, and positive.
</p>
<p>For <code class="reqn">0 &lt; p &lt; 1</code> and <code class="reqn">f(x) =</code>
</p>

<dl>
<dt><code class="reqn">x^p</code></dt><dd><p> for <code class="reqn">x \geq 0</code></p>
</dd>
<dt><code class="reqn">-\infty</code></dt><dd><p><code class="reqn">x &lt; 0</code></p>
</dd>
</dl>
<p>, this function is concave, increasing, and positive.
</p>
<p>For <code class="reqn">p &gt; 1, p \neq 2,4,8,\ldots</code> and <code class="reqn">f(x) = </code>
</p>

<dl>
<dt><code class="reqn">x^p</code></dt><dd><p> for <code class="reqn">x \geq 0</code></p>
</dd>
<dt><code class="reqn">+\infty</code></dt><dd><p><code class="reqn">x &lt; 0</code></p>
</dd>
</dl>
<p>, this function is convex, increasing, and positive.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Power)</code>: Throw an error if the power is negative and cannot be handled.
</p>
</li>
<li> <p><code>sign_from_args(Power)</code>: The sign of the atom.
</p>
</li>
<li> <p><code>is_atom_convex(Power)</code>: Is <code class="reqn">p \leq 0</code> or <code class="reqn">p \geq 1</code>?
</p>
</li>
<li> <p><code>is_atom_concave(Power)</code>: Is <code class="reqn">p \geq 0</code> or <code class="reqn">p \leq 1</code>?
</p>
</li>
<li> <p><code>is_atom_log_log_convex(Power)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(Power)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_constant(Power)</code>: A logical value indicating whether the atom is constant.
</p>
</li>
<li> <p><code>is_incr(Power)</code>: A logical value indicating whether the atom is weakly increasing.
</p>
</li>
<li> <p><code>is_decr(Power)</code>: A logical value indicating whether the atom is weakly decreasing.
</p>
</li>
<li> <p><code>is_quadratic(Power)</code>: A logical value indicating whether the atom is quadratic.
</p>
</li>
<li> <p><code>is_qpwa(Power)</code>: A logical value indicating whether the atom is quadratic of piecewise affine.
</p>
</li>
<li> <p><code>.grad(Power)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li>
<li> <p><code>.domain(Power)</code>: Returns constraints describng the domain of the node
</p>
</li>
<li> <p><code>get_data(Power)</code>: A list containing the output of <code>pow_low, pow_mid</code>, or <code>pow_high</code> depending on the input power.
</p>
</li>
<li> <p><code>copy(Power)</code>: Returns a shallow  copy of the power atom
</p>
</li>
<li> <p><code>name(Power)</code>: Returns the expression in string form.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>The <a href="#topic+Expression-class">Expression</a> to be raised to a power.</p>
</dd>
<dt><code>p</code></dt><dd><p>A numeric value indicating the scalar power.</p>
</dd>
<dt><code>max_denom</code></dt><dd><p>The maximum denominator considered in forming a rational approximation of <code>p</code>.</p>
</dd>
</dl>

<hr>
<h2 id='Problem-arith'>Arithmetic Operations on Problems</h2><span id='topic+Problem-arith'></span><span id='topic++2B+2CProblem+2Cmissing-method'></span><span id='topic+-+2CProblem+2Cmissing-method'></span><span id='topic++2B+2CProblem+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2CProblem-method'></span><span id='topic++2B+2CProblem+2CProblem-method'></span><span id='topic+-+2CProblem+2Cnumeric-method'></span><span id='topic+-+2Cnumeric+2CProblem-method'></span><span id='topic+-+2CProblem+2CProblem-method'></span><span id='topic++2A+2CProblem+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2CProblem-method'></span><span id='topic++2F+2CProblem+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Add, subtract, multiply, or divide DCP optimization problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Problem,missing'
e1 + e2

## S4 method for signature 'Problem,missing'
e1 - e2

## S4 method for signature 'Problem,numeric'
e1 + e2

## S4 method for signature 'numeric,Problem'
e1 + e2

## S4 method for signature 'Problem,Problem'
e1 + e2

## S4 method for signature 'Problem,numeric'
e1 - e2

## S4 method for signature 'numeric,Problem'
e1 - e2

## S4 method for signature 'Problem,Problem'
e1 - e2

## S4 method for signature 'Problem,numeric'
e1 * e2

## S4 method for signature 'numeric,Problem'
e1 * e2

## S4 method for signature 'Problem,numeric'
e1 / e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Problem-arith_+3A_e1">e1</code></td>
<td>
<p>The left-hand <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="Problem-arith_+3A_e2">e2</code></td>
<td>
<p>The right-hand <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Problem-class">Problem</a> object.
</p>

<hr>
<h2 id='Problem-class'>The Problem class.</h2><span id='topic+Problem-class'></span><span id='topic+.Problem'></span><span id='topic+Problem'></span><span id='topic+objective+2CProblem-method'></span><span id='topic+objective+3C-+2CProblem-method'></span><span id='topic+constraints+2CProblem-method'></span><span id='topic+constraints+3C-+2CProblem-method'></span><span id='topic+value+2CProblem-method'></span><span id='topic+value+3C-+2CProblem-method'></span><span id='topic+status+2CProblem-method'></span><span id='topic+is_dcp+2CProblem-method'></span><span id='topic+is_dgp+2CProblem-method'></span><span id='topic+is_qp+2CProblem-method'></span><span id='topic+canonicalize+2CProblem-method'></span><span id='topic+is_mixed_integer+2CProblem-method'></span><span id='topic+variables+2CProblem-method'></span><span id='topic+parameters+2CProblem-method'></span><span id='topic+constants+2CProblem-method'></span><span id='topic+atoms+2CProblem-method'></span><span id='topic+size_metrics+2CProblem-method'></span><span id='topic+solver_stats+2CProblem-method'></span><span id='topic+solver_stats+3C-+2CProblem-method'></span><span id='topic+get_problem_data+2CProblem+2Ccharacter+2Clogical-method'></span><span id='topic+get_problem_data+2CProblem+2Ccharacter+2Cmissing-method'></span><span id='topic+unpack_results+2CProblem-method'></span>

<h3>Description</h3>

<p>This class represents a convex optimization problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Problem(objective, constraints = list())

## S4 method for signature 'Problem'
objective(object)

## S4 replacement method for signature 'Problem'
objective(object) &lt;- value

## S4 method for signature 'Problem'
constraints(object)

## S4 replacement method for signature 'Problem'
constraints(object) &lt;- value

## S4 method for signature 'Problem'
value(object)

## S4 replacement method for signature 'Problem'
value(object) &lt;- value

## S4 method for signature 'Problem'
status(object)

## S4 method for signature 'Problem'
is_dcp(object)

## S4 method for signature 'Problem'
is_dgp(object)

## S4 method for signature 'Problem'
is_qp(object)

## S4 method for signature 'Problem'
canonicalize(object)

## S4 method for signature 'Problem'
is_mixed_integer(object)

## S4 method for signature 'Problem'
variables(object)

## S4 method for signature 'Problem'
parameters(object)

## S4 method for signature 'Problem'
constants(object)

## S4 method for signature 'Problem'
atoms(object)

## S4 method for signature 'Problem'
size_metrics(object)

## S4 method for signature 'Problem'
solver_stats(object)

## S4 replacement method for signature 'Problem'
solver_stats(object) &lt;- value

## S4 method for signature 'Problem,character,logical'
get_problem_data(object, solver, gp)

## S4 method for signature 'Problem,character,missing'
get_problem_data(object, solver, gp)

## S4 method for signature 'Problem'
unpack_results(object, solution, chain, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Problem-class_+3A_objective">objective</code></td>
<td>
<p>A <a href="#topic+Minimize-class">Minimize</a> or <a href="#topic+Maximize-class">Maximize</a> object representing the optimization objective.</p>
</td></tr>
<tr><td><code id="Problem-class_+3A_constraints">constraints</code></td>
<td>
<p>(Optional) A list of <a href="#topic+Constraint-class">Constraint</a> objects representing constraints on the optimization variables.</p>
</td></tr>
<tr><td><code id="Problem-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> class.</p>
</td></tr>
<tr><td><code id="Problem-class_+3A_value">value</code></td>
<td>
<p>A <a href="#topic+Minimize-class">Minimize</a> or <a href="#topic+Maximize-class">Maximize</a> object (objective), list of <a href="#topic+Constraint-class">Constraint</a> objects (constraints), or numeric scalar (value).</p>
</td></tr>
<tr><td><code id="Problem-class_+3A_solver">solver</code></td>
<td>
<p>A string indicating the solver that the problem data is for. Call <code>installed_solvers()</code> to see all available.</p>
</td></tr>
<tr><td><code id="Problem-class_+3A_gp">gp</code></td>
<td>
<p>Is the problem a geometric problem?</p>
</td></tr>
<tr><td><code id="Problem-class_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> object.</p>
</td></tr>
<tr><td><code id="Problem-class_+3A_chain">chain</code></td>
<td>
<p>The corresponding solving <a href="#topic+Chain-class">Chain</a>.</p>
</td></tr>
<tr><td><code id="Problem-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A <a href="#topic+InverseData-class">InverseData</a> object or list containing data necessary for the inversion.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>objective(Problem)</code>: The objective of the problem.
</p>
</li>
<li> <p><code>objective(Problem) &lt;- value</code>: Set the value of the problem objective.
</p>
</li>
<li> <p><code>constraints(Problem)</code>: A list of the constraints of the problem.
</p>
</li>
<li> <p><code>constraints(Problem) &lt;- value</code>: Set the value of the problem constraints.
</p>
</li>
<li> <p><code>value(Problem)</code>: The value from the last time the problem was solved (or NA if not solved).
</p>
</li>
<li> <p><code>value(Problem) &lt;- value</code>: Set the value of the optimal objective.
</p>
</li>
<li> <p><code>status(Problem)</code>: The status from the last time the problem was solved.
</p>
</li>
<li> <p><code>is_dcp(Problem)</code>: A logical value indicating whether the problem statisfies DCP rules.
</p>
</li>
<li> <p><code>is_dgp(Problem)</code>: A logical value indicating whether the problem statisfies DGP rules.
</p>
</li>
<li> <p><code>is_qp(Problem)</code>: A logical value indicating whether the problem is a quadratic program.
</p>
</li>
<li> <p><code>canonicalize(Problem)</code>: The graph implementation of the problem.
</p>
</li>
<li> <p><code>is_mixed_integer(Problem)</code>: logical value indicating whether the problem is a mixed integer program.
</p>
</li>
<li> <p><code>variables(Problem)</code>: List of <a href="#topic+Variable-class">Variable</a> objects in the problem.
</p>
</li>
<li> <p><code>parameters(Problem)</code>: List of <a href="#topic+Parameter-class">Parameter</a> objects in the problem.
</p>
</li>
<li> <p><code>constants(Problem)</code>: List of <a href="#topic+Constant-class">Constant</a> objects in the problem.
</p>
</li>
<li> <p><code>atoms(Problem)</code>: List of <a href="#topic+Atom-class">Atom</a> objects in the problem.
</p>
</li>
<li> <p><code>size_metrics(Problem)</code>: Information about the size of the problem.
</p>
</li>
<li> <p><code>solver_stats(Problem)</code>: Additional information returned by the solver.
</p>
</li>
<li> <p><code>solver_stats(Problem) &lt;- value</code>: Set the additional information returned by the solver in the problem.
</p>
</li>
<li> <p><code>get_problem_data(object = Problem, solver = character, gp = logical)</code>: Get the problem data passed to the specified solver.
</p>
</li>
<li> <p><code>get_problem_data(object = Problem, solver = character, gp = missing)</code>: Get the problem data passed to the specified solver.
</p>
</li>
<li> <p><code>unpack_results(Problem)</code>: Parses the output from a solver and updates the problem state, including the status,
objective value, and values of the primal and dual variables.
Assumes the results are from the given solver.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>objective</code></dt><dd><p>A <a href="#topic+Minimize-class">Minimize</a> or <a href="#topic+Maximize-class">Maximize</a> object representing the optimization objective.</p>
</dd>
<dt><code>constraints</code></dt><dd><p>(Optional) A list of constraints on the optimization variables.</p>
</dd>
<dt><code>value</code></dt><dd><p>(Internal) Used internally to hold the value of the optimization objective at the solution.</p>
</dd>
<dt><code>status</code></dt><dd><p>(Internal) Used internally to hold the status of the problem solution.</p>
</dd>
<dt><code>.cached_data</code></dt><dd><p>(Internal) Used internally to hold cached matrix data.</p>
</dd>
<dt><code>.separable_problems</code></dt><dd><p>(Internal) Used internally to hold separable problem data.</p>
</dd>
<dt><code>.size_metrics</code></dt><dd><p>(Internal) Used internally to hold size metrics.</p>
</dd>
<dt><code>.solver_stats</code></dt><dd><p>(Internal) Used internally to hold solver statistics.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(2)
p &lt;- Problem(Minimize(p_norm(x, 2)), list(x &gt;= 0))
is_dcp(p)
x &lt;- Variable(2)
A &lt;- matrix(c(1,-1,-1, 1), nrow = 2)
p &lt;- Problem(Minimize(quad_form(x, A)), list(x &gt;= 0))
is_qp(p)
</code></pre>

<hr>
<h2 id='problem-parts'>Parts of a Problem</h2><span id='topic+problem-parts'></span><span id='topic+objective'></span><span id='topic+objective+3C-'></span><span id='topic+constraints'></span><span id='topic+constraints+3C-'></span><span id='topic+size_metrics'></span>

<h3>Description</h3>

<p>Get and set the objective, constraints, or size metrics (get only) of a problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objective(object)

objective(object) &lt;- value

constraints(object)

constraints(object) &lt;- value

size_metrics(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="problem-parts_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="problem-parts_+3A_value">value</code></td>
<td>
<p>The value to assign to the slot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For getter functions, the requested slot of the object.
x &lt;- Variable()
prob &lt;- Problem(Minimize(x^2), list(x &gt;= 5))
objective(prob)
constraints(prob)
size_metrics(prob)
</p>
<p>objective(prob) &lt;- Maximize(sqrt(x))
constraints(prob) &lt;- list(x &lt;= 10)
objective(prob)
constraints(prob)
</p>

<hr>
<h2 id='prod_entries'>Product of Entries</h2><span id='topic+prod_entries'></span><span id='topic+prod'></span><span id='topic+prod.Expression'></span>

<h3>Description</h3>

<p>The product of entries in a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prod_entries(..., axis = NA_real_, keepdims = FALSE)

## S3 method for class 'Expression'
prod(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prod_entries_+3A_...">...</code></td>
<td>
<p>Numeric scalar, vector, matrix, or <a href="#topic+Expression-class">Expression</a> objects.</p>
</td></tr>
<tr><td><code id="prod_entries_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="prod_entries_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="prod_entries_+3A_na.rm">na.rm</code></td>
<td>
<p>(Unimplemented) A logical value indicating whether missing values should be removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This atom is log-log affine, but it is neither convex nor concave.
</p>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the product of the entries of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 2
X &lt;- Variable(n, n, pos=TRUE)
obj &lt;- sum(X)
constraints &lt;- list(prod_entries(X) == 4)
prob &lt;- Problem(Minimize(obj), constraints)
result &lt;- solve(prob, gp=TRUE)
result$value
result$getValue(X)

n &lt;- 2
X &lt;- Variable(n, n, pos=TRUE)
obj &lt;- sum(X)
constraints &lt;- list(prod(X) == 4)
prob &lt;- Problem(Minimize(obj), constraints)
result &lt;- solve(prob, gp=TRUE)
result$value
</code></pre>

<hr>
<h2 id='ProdEntries-class'>The ProdEntries class.</h2><span id='topic+ProdEntries-class'></span><span id='topic+.ProdEntries'></span><span id='topic+ProdEntries'></span><span id='topic+to_numeric+2CProdEntries-method'></span><span id='topic+sign_from_args+2CProdEntries-method'></span><span id='topic+is_atom_convex+2CProdEntries-method'></span><span id='topic+is_atom_concave+2CProdEntries-method'></span><span id='topic+is_atom_log_log_convex+2CProdEntries-method'></span><span id='topic+is_atom_log_log_concave+2CProdEntries-method'></span><span id='topic+is_incr+2CProdEntries-method'></span><span id='topic+is_decr+2CProdEntries-method'></span><span id='topic+.column_grad+2CProdEntries-method'></span><span id='topic+.grad+2CProdEntries-method'></span>

<h3>Description</h3>

<p>The product of the entries in an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProdEntries(..., axis = NA_real_, keepdims = FALSE)

## S4 method for signature 'ProdEntries'
to_numeric(object, values)

## S4 method for signature 'ProdEntries'
sign_from_args(object)

## S4 method for signature 'ProdEntries'
is_atom_convex(object)

## S4 method for signature 'ProdEntries'
is_atom_concave(object)

## S4 method for signature 'ProdEntries'
is_atom_log_log_convex(object)

## S4 method for signature 'ProdEntries'
is_atom_log_log_concave(object)

## S4 method for signature 'ProdEntries'
is_incr(object, idx)

## S4 method for signature 'ProdEntries'
is_decr(object, idx)

## S4 method for signature 'ProdEntries'
.column_grad(object, value)

## S4 method for signature 'ProdEntries'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProdEntries-class_+3A_...">...</code></td>
<td>
<p><a href="#topic+Expression-class">Expression</a> objects, vectors, or matrices.</p>
</td></tr>
<tr><td><code id="ProdEntries-class_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="ProdEntries-class_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ProdEntries-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+ProdEntries-class">ProdEntries</a> object.</p>
</td></tr>
<tr><td><code id="ProdEntries-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="ProdEntries-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="ProdEntries-class_+3A_value">value</code></td>
<td>
<p>A numeric value.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(ProdEntries)</code>: The product of all the entries.
</p>
</li>
<li> <p><code>sign_from_args(ProdEntries)</code>: Returns the sign (is positive, is negative) of the atom.
</p>
</li>
<li> <p><code>is_atom_convex(ProdEntries)</code>: Is the atom convex?
</p>
</li>
<li> <p><code>is_atom_concave(ProdEntries)</code>: Is the atom concave?
</p>
</li>
<li> <p><code>is_atom_log_log_convex(ProdEntries)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(ProdEntries)</code>: is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(ProdEntries)</code>: Is the atom weakly increasing in the argument <code>idx</code>?
</p>
</li>
<li> <p><code>is_decr(ProdEntries)</code>: Is the atom weakly decreasing in the argument <code>idx</code>?
</p>
</li>
<li> <p><code>.column_grad(ProdEntries)</code>: Gives the (sub/super)gradient of the atom w.r.t. each column variable
</p>
</li>
<li> <p><code>.grad(ProdEntries)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</dd>
<dt><code>axis</code></dt><dd><p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</dd>
</dl>

<hr>
<h2 id='project-methods'>Project Value</h2><span id='topic+project-methods'></span><span id='topic+project'></span><span id='topic+project_and_assign'></span>

<h3>Description</h3>

<p>Project a value onto the attribute set of a <a href="#topic+Leaf-class">Leaf</a>.
A sensible idiom is <code>value(leaf) = project(leaf, val)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(object, value)

project_and_assign(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project-methods_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Leaf-class">Leaf</a> object.</p>
</td></tr>
<tr><td><code id="project-methods_+3A_value">value</code></td>
<td>
<p>The assigned value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value rounded to the attribute type.
</p>

<hr>
<h2 id='Promote-class'>The Promote class.</h2><span id='topic+Promote-class'></span><span id='topic+.Promote'></span><span id='topic+Promote'></span><span id='topic+to_numeric+2CPromote-method'></span><span id='topic+is_symmetric+2CPromote-method'></span><span id='topic+dim_from_args+2CPromote-method'></span><span id='topic+is_atom_log_log_convex+2CPromote-method'></span><span id='topic+is_atom_log_log_concave+2CPromote-method'></span><span id='topic+get_data+2CPromote-method'></span><span id='topic+graph_implementation+2CPromote-method'></span>

<h3>Description</h3>

<p>This class represents the promotion of a scalar expression into a vector/matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Promote(expr, promoted_dim)

## S4 method for signature 'Promote'
to_numeric(object, values)

## S4 method for signature 'Promote'
is_symmetric(object)

## S4 method for signature 'Promote'
dim_from_args(object)

## S4 method for signature 'Promote'
is_atom_log_log_convex(object)

## S4 method for signature 'Promote'
is_atom_log_log_concave(object)

## S4 method for signature 'Promote'
get_data(object)

## S4 method for signature 'Promote'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Promote-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</td></tr>
<tr><td><code id="Promote-class_+3A_promoted_dim">promoted_dim</code></td>
<td>
<p>The desired dimensions.</p>
</td></tr>
<tr><td><code id="Promote-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Promote-class">Promote</a> object.</p>
</td></tr>
<tr><td><code id="Promote-class_+3A_values">values</code></td>
<td>
<p>A list containing the value to promote.</p>
</td></tr>
<tr><td><code id="Promote-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="Promote-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="Promote-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Promote)</code>: Promotes the value to the new dimensions.
</p>
</li>
<li> <p><code>is_symmetric(Promote)</code>: Is the expression symmetric?
</p>
</li>
<li> <p><code>dim_from_args(Promote)</code>: Returns the (row, col) dimensions of the expression.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(Promote)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(Promote)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>get_data(Promote)</code>: Returns information needed to reconstruct the expression besides the args.
</p>
</li>
<li> <p><code>graph_implementation(Promote)</code>: The graph implementation of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</dd>
<dt><code>promoted_dim</code></dt><dd><p>The desired dimensions.</p>
</dd>
</dl>

<hr>
<h2 id='psd_coeff_offset'>Given a problem returns a PSD constraint</h2><span id='topic+psd_coeff_offset'></span>

<h3>Description</h3>

<p>Given a problem returns a PSD constraint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psd_coeff_offset(problem, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psd_coeff_offset_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="psd_coeff_offset_+3A_c">c</code></td>
<td>
<p>A vector of coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an array G and vector h such that the given constraint is
equivalent to <code class="reqn">G*z \leq_{PSD} h</code>.
</p>

<hr>
<h2 id='PSDWrap-class'>The PSDWrap class.</h2><span id='topic+PSDWrap-class'></span><span id='topic+.PSDWrap'></span><span id='topic+PSDWrap'></span><span id='topic+is_psd+2CPSDWrap-method'></span>

<h3>Description</h3>

<p>A no-op wrapper to assert the input argument is positive semidefinite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSDWrap(arg)

## S4 method for signature 'PSDWrap'
is_psd(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSDWrap-class_+3A_arg">arg</code></td>
<td>
<p>A <a href="#topic+Expression-class">Expression</a> object or matrix.</p>
</td></tr>
<tr><td><code id="PSDWrap-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+PSDWrap-class">PSDWrap</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>is_psd(PSDWrap)</code>: Is the atom positive semidefinite?
</p>
</li></ul>

<hr>
<h2 id='psolve'>Solve a DCP Problem</h2><span id='topic+psolve'></span><span id='topic+solve'></span><span id='topic+psolve+2CProblem-method'></span><span id='topic+solve+2CProblem+2CANY-method'></span>

<h3>Description</h3>

<p>Solve a DCP compliant optimization problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psolve(
  object,
  solver = NA,
  ignore_dcp = FALSE,
  warm_start = FALSE,
  verbose = FALSE,
  parallel = FALSE,
  gp = FALSE,
  feastol = NULL,
  reltol = NULL,
  abstol = NULL,
  num_iter = NULL,
  ...
)

## S4 method for signature 'Problem'
psolve(
  object,
  solver = NA,
  ignore_dcp = FALSE,
  warm_start = FALSE,
  verbose = FALSE,
  parallel = FALSE,
  gp = FALSE,
  feastol = NULL,
  reltol = NULL,
  abstol = NULL,
  num_iter = NULL,
  ...
)

## S4 method for signature 'Problem,ANY'
solve(a, b = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psolve_+3A_object">object</code>, <code id="psolve_+3A_a">a</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="psolve_+3A_solver">solver</code>, <code id="psolve_+3A_b">b</code></td>
<td>
<p>(Optional) A string indicating the solver to use. Defaults to &quot;ECOS&quot;.</p>
</td></tr>
<tr><td><code id="psolve_+3A_ignore_dcp">ignore_dcp</code></td>
<td>
<p>(Optional) A logical value indicating whether to override the DCP check for a problem.</p>
</td></tr>
<tr><td><code id="psolve_+3A_warm_start">warm_start</code></td>
<td>
<p>(Optional) A logical value indicating whether the previous solver result should be used to warm start.</p>
</td></tr>
<tr><td><code id="psolve_+3A_verbose">verbose</code></td>
<td>
<p>(Optional) A logical value indicating whether to print additional solver output.</p>
</td></tr>
<tr><td><code id="psolve_+3A_parallel">parallel</code></td>
<td>
<p>(Optional) A logical value indicating whether to solve in parallel if the problem is separable.</p>
</td></tr>
<tr><td><code id="psolve_+3A_gp">gp</code></td>
<td>
<p>(Optional) A logical value indicating whether the problem is a geometric program. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="psolve_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance on the primal and dual residual.</p>
</td></tr>
<tr><td><code id="psolve_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance on the duality gap.</p>
</td></tr>
<tr><td><code id="psolve_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance on the duality gap.</p>
</td></tr>
<tr><td><code id="psolve_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="psolve_+3A_...">...</code></td>
<td>
<p>Additional options that will be passed to the specific solver. In general, these options will override any default settings imposed by CVXR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the solution to the problem:
</p>

<dl>
<dt><code>status</code></dt><dd><p>The status of the solution. Can be &quot;optimal&quot;, &quot;optimal_inaccurate&quot;, &quot;infeasible&quot;, &quot;infeasible_inaccurate&quot;, &quot;unbounded&quot;, &quot;unbounded_inaccurate&quot;, or &quot;solver_error&quot;.</p>
</dd>
<dt><code>value</code></dt><dd><p>The optimal value of the objective function.</p>
</dd>
<dt><code>solver</code></dt><dd><p>The name of the solver.</p>
</dd>
<dt><code>solve_time</code></dt><dd><p>The time (in seconds) it took for the solver to solve the problem.</p>
</dd>
<dt><code>setup_time</code></dt><dd><p>The time (in seconds) it took for the solver to set up the problem.</p>
</dd>
<dt><code>num_iters</code></dt><dd><p>The number of iterations the solver had to go through to find a solution.</p>
</dd>
<dt><code>getValue</code></dt><dd><p>A function that takes a <a href="#topic+Variable-class">Variable</a> object and retrieves its primal value.</p>
</dd>
<dt><code>getDualValue</code></dt><dd><p>A function that takes a <a href="#topic+Constraint-class">Constraint</a> object and retrieves its dual value(s).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- Variable(name = "a")
prob &lt;- Problem(Minimize(norm_inf(a)), list(a &gt;= 2))
result &lt;- psolve(prob, solver = "ECOS", verbose = TRUE)
result$status
result$value
result$getValue(a)
result$getDualValue(constraints(prob)[[1]])
</code></pre>

<hr>
<h2 id='Qp2SymbolicQp-class'>The Qp2SymbolicQp class.</h2><span id='topic+Qp2SymbolicQp-class'></span><span id='topic+.Qp2SymbolicQp'></span>

<h3>Description</h3>

<p>This class reduces a quadratic problem to a problem that consists of affine
expressions and symbolic quadratic forms.
</p>

<hr>
<h2 id='QpMatrixStuffing-class'>The QpMatrixStuffing class.</h2><span id='topic+QpMatrixStuffing-class'></span><span id='topic+QpMatrixStuffing'></span>

<h3>Description</h3>

<p>This class fills in numeric values for the problem instance and
outputs a DCP-compliant minimization problem with an objective
of the form
</p>


<h3>Details</h3>

<p>QuadForm(x, p) + t(q) 
</p>
<p>and Zero/NonPos constraints, both of which exclusively carry
affine arguments
</p>

<hr>
<h2 id='QpSolver-class'>A QP solver interface.</h2><span id='topic+QpSolver-class'></span><span id='topic+accepts+2CQpSolver+2CProblem-method'></span><span id='topic+perform+2CQpSolver+2CProblem-method'></span>

<h3>Description</h3>

<p>A QP solver interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QpSolver,Problem'
accepts(object, problem)

## S4 method for signature 'QpSolver,Problem'
perform(object, problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QpSolver-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+QpSolver-class">QpSolver</a> object.</p>
</td></tr>
<tr><td><code id="QpSolver-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>accepts(object = QpSolver, problem = Problem)</code>: Is this a QP problem?
</p>
</li>
<li> <p><code>perform(object = QpSolver, problem = Problem)</code>: Constructs a QP problem data stored in a list
</p>
</li></ul>

<hr>
<h2 id='quad_form'>Quadratic Form</h2><span id='topic+quad_form'></span>

<h3>Description</h3>

<p>The quadratic form, <code class="reqn">x^TPx</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quad_form(x, P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quad_form_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or vector.</p>
</td></tr>
<tr><td><code id="quad_form_+3A_p">P</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the quadratic form evaluated at the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(2)
P &lt;- rbind(c(4,0), c(0,9))
prob &lt;- Problem(Minimize(quad_form(x,P)), list(x &gt;= 1))
result &lt;- solve(prob)
result$value
result$getValue(x)

A &lt;- Variable(2,2)
c &lt;- c(1,2)
prob &lt;- Problem(Minimize(quad_form(c,A)), list(A &gt;= 1))
result &lt;- solve(prob)
result$value
result$getValue(A)
</code></pre>

<hr>
<h2 id='quad_over_lin'>Quadratic over Linear</h2><span id='topic+quad_over_lin'></span>

<h3>Description</h3>

<p><code class="reqn">\sum_{i,j} X_{i,j}^2/y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quad_over_lin(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quad_over_lin_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="quad_over_lin_+3A_y">y</code></td>
<td>
<p>A scalar <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the quadratic over linear function value evaluated at the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(3,2)
y &lt;- Variable()
val &lt;- cbind(c(-1,2,-2), c(-1,2,-2))
prob &lt;- Problem(Minimize(quad_over_lin(x,y)), list(x == val, y &lt;= 2))
result &lt;- solve(prob)
result$value
result$getValue(x)
result$getValue(y)
</code></pre>

<hr>
<h2 id='QuadForm-class'>The QuadForm class.</h2><span id='topic+QuadForm-class'></span><span id='topic+.QuadForm'></span><span id='topic+QuadForm'></span><span id='topic+name+2CQuadForm-method'></span><span id='topic+allow_complex+2CQuadForm-method'></span><span id='topic+to_numeric+2CQuadForm-method'></span><span id='topic+validate_args+2CQuadForm-method'></span><span id='topic+sign_from_args+2CQuadForm-method'></span><span id='topic+dim_from_args+2CQuadForm-method'></span><span id='topic+is_atom_convex+2CQuadForm-method'></span><span id='topic+is_atom_concave+2CQuadForm-method'></span><span id='topic+is_atom_log_log_convex+2CQuadForm-method'></span><span id='topic+is_atom_log_log_concave+2CQuadForm-method'></span><span id='topic+is_incr+2CQuadForm-method'></span><span id='topic+is_decr+2CQuadForm-method'></span><span id='topic+is_quadratic+2CQuadForm-method'></span><span id='topic+is_pwl+2CQuadForm-method'></span><span id='topic+.grad+2CQuadForm-method'></span>

<h3>Description</h3>

<p>This class represents the quadratic form <code class="reqn">x^T P x</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuadForm(x, P)

## S4 method for signature 'QuadForm'
name(x)

## S4 method for signature 'QuadForm'
allow_complex(object)

## S4 method for signature 'QuadForm'
to_numeric(object, values)

## S4 method for signature 'QuadForm'
validate_args(object)

## S4 method for signature 'QuadForm'
sign_from_args(object)

## S4 method for signature 'QuadForm'
dim_from_args(object)

## S4 method for signature 'QuadForm'
is_atom_convex(object)

## S4 method for signature 'QuadForm'
is_atom_concave(object)

## S4 method for signature 'QuadForm'
is_atom_log_log_convex(object)

## S4 method for signature 'QuadForm'
is_atom_log_log_concave(object)

## S4 method for signature 'QuadForm'
is_incr(object, idx)

## S4 method for signature 'QuadForm'
is_decr(object, idx)

## S4 method for signature 'QuadForm'
is_quadratic(object)

## S4 method for signature 'QuadForm'
is_pwl(object)

## S4 method for signature 'QuadForm'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QuadForm-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric vector.</p>
</td></tr>
<tr><td><code id="QuadForm-class_+3A_p">P</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, numeric matrix, or vector.</p>
</td></tr>
<tr><td><code id="QuadForm-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+QuadForm-class">QuadForm</a> object.</p>
</td></tr>
<tr><td><code id="QuadForm-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="QuadForm-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(QuadForm)</code>: The name and arguments of the atom.
</p>
</li>
<li> <p><code>allow_complex(QuadForm)</code>: Does the atom handle complex numbers?
</p>
</li>
<li> <p><code>to_numeric(QuadForm)</code>: Returns the quadratic form.
</p>
</li>
<li> <p><code>validate_args(QuadForm)</code>: Checks the dimensions of the arguments.
</p>
</li>
<li> <p><code>sign_from_args(QuadForm)</code>: Returns the sign (is positive, is negative) of the atom.
</p>
</li>
<li> <p><code>dim_from_args(QuadForm)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>is_atom_convex(QuadForm)</code>: Is the atom convex?
</p>
</li>
<li> <p><code>is_atom_concave(QuadForm)</code>: Is the atom concave?
</p>
</li>
<li> <p><code>is_atom_log_log_convex(QuadForm)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(QuadForm)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(QuadForm)</code>: Is the atom weakly increasing in the argument <code>idx</code>?
</p>
</li>
<li> <p><code>is_decr(QuadForm)</code>: Is the atom weakly decreasing in the argument <code>idx</code>?
</p>
</li>
<li> <p><code>is_quadratic(QuadForm)</code>: Is the atom quadratic?
</p>
</li>
<li> <p><code>is_pwl(QuadForm)</code>: Is the atom piecewise linear?
</p>
</li>
<li> <p><code>.grad(QuadForm)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric vector.</p>
</dd>
<dt><code>P</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a>, numeric matrix, or vector.</p>
</dd>
</dl>

<hr>
<h2 id='QuadOverLin-class'>The QuadOverLin class.</h2><span id='topic+QuadOverLin-class'></span><span id='topic+.QuadOverLin'></span><span id='topic+QuadOverLin'></span><span id='topic+allow_complex+2CQuadOverLin-method'></span><span id='topic+to_numeric+2CQuadOverLin-method'></span><span id='topic+validate_args+2CQuadOverLin-method'></span><span id='topic+dim_from_args+2CQuadOverLin-method'></span><span id='topic+sign_from_args+2CQuadOverLin-method'></span><span id='topic+is_atom_convex+2CQuadOverLin-method'></span><span id='topic+is_atom_concave+2CQuadOverLin-method'></span><span id='topic+is_atom_log_log_convex+2CQuadOverLin-method'></span><span id='topic+is_atom_log_log_concave+2CQuadOverLin-method'></span><span id='topic+is_incr+2CQuadOverLin-method'></span><span id='topic+is_decr+2CQuadOverLin-method'></span><span id='topic+is_quadratic+2CQuadOverLin-method'></span><span id='topic+is_qpwa+2CQuadOverLin-method'></span><span id='topic+.domain+2CQuadOverLin-method'></span><span id='topic+.grad+2CQuadOverLin-method'></span>

<h3>Description</h3>

<p>This class represents the sum of squared entries in X divided by a scalar y, <code class="reqn">\sum_{i,j} X_{i,j}^2/y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuadOverLin(x, y)

## S4 method for signature 'QuadOverLin'
allow_complex(object)

## S4 method for signature 'QuadOverLin'
to_numeric(object, values)

## S4 method for signature 'QuadOverLin'
validate_args(object)

## S4 method for signature 'QuadOverLin'
dim_from_args(object)

## S4 method for signature 'QuadOverLin'
sign_from_args(object)

## S4 method for signature 'QuadOverLin'
is_atom_convex(object)

## S4 method for signature 'QuadOverLin'
is_atom_concave(object)

## S4 method for signature 'QuadOverLin'
is_atom_log_log_convex(object)

## S4 method for signature 'QuadOverLin'
is_atom_log_log_concave(object)

## S4 method for signature 'QuadOverLin'
is_incr(object, idx)

## S4 method for signature 'QuadOverLin'
is_decr(object, idx)

## S4 method for signature 'QuadOverLin'
is_quadratic(object)

## S4 method for signature 'QuadOverLin'
is_qpwa(object)

## S4 method for signature 'QuadOverLin'
.domain(object)

## S4 method for signature 'QuadOverLin'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QuadOverLin-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="QuadOverLin-class_+3A_y">y</code></td>
<td>
<p>A scalar <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</td></tr>
<tr><td><code id="QuadOverLin-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+QuadOverLin-class">QuadOverLin</a> object.</p>
</td></tr>
<tr><td><code id="QuadOverLin-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="QuadOverLin-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>allow_complex(QuadOverLin)</code>: Does the atom handle complex numbers?
</p>
</li>
<li> <p><code>to_numeric(QuadOverLin)</code>: The sum of the entries of <code>x</code> squared over <code>y</code>.
</p>
</li>
<li> <p><code>validate_args(QuadOverLin)</code>: Check the dimensions of the arguments.
</p>
</li>
<li> <p><code>dim_from_args(QuadOverLin)</code>: The atom is a scalar.
</p>
</li>
<li> <p><code>sign_from_args(QuadOverLin)</code>: The atom is positive.
</p>
</li>
<li> <p><code>is_atom_convex(QuadOverLin)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(QuadOverLin)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(QuadOverLin)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(QuadOverLin)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>is_incr(QuadOverLin)</code>: A logical value indicating whether the atom is weakly increasing in argument <code>idx</code>.
</p>
</li>
<li> <p><code>is_decr(QuadOverLin)</code>: A logical value indicating whether the atom is weakly decreasing in argument <code>idx</code>.
</p>
</li>
<li> <p><code>is_quadratic(QuadOverLin)</code>: Quadratic if <code>x</code> is affine and <code>y</code> is constant.
</p>
</li>
<li> <p><code>is_qpwa(QuadOverLin)</code>: Quadratic of piecewise affine if <code>x</code> is piecewise linear and <code>y</code> is constant.
</p>
</li>
<li> <p><code>.domain(QuadOverLin)</code>: Returns constraints describing the domain of the node
</p>
</li>
<li> <p><code>.grad(QuadOverLin)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
<dt><code>y</code></dt><dd><p>A scalar <a href="#topic+Expression-class">Expression</a> or numeric constant.</p>
</dd>
</dl>

<hr>
<h2 id='Rdict-class'>The Rdict class.</h2><span id='topic+Rdict-class'></span><span id='topic+Rdict'></span><span id='topic++24+2CRdict-method'></span><span id='topic+length+2CRdict-method'></span><span id='topic+is.element+2CANY+2CRdict-method'></span><span id='topic++5B+2CRdict+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CRdict+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>A simple, internal dictionary composed of a list of keys and a list of values. These keys/values can be any type, including nested lists, S4 objects, etc.
Incredibly inefficient hack, but necessary for the geometric mean atom, since it requires mixed numeric/gmp objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rdict(keys = list(), values = list())

## S4 method for signature 'Rdict'
x$name

## S4 method for signature 'Rdict'
length(x)

## S4 method for signature 'ANY,Rdict'
is.element(el, set)

## S4 method for signature 'Rdict,ANY,ANY,ANY'
x[i, j, ..., drop = TRUE]

## S4 replacement method for signature 'Rdict,ANY,ANY,ANY'
x[i, j, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rdict-class_+3A_keys">keys</code></td>
<td>
<p>A list of keys.</p>
</td></tr>
<tr><td><code id="Rdict-class_+3A_values">values</code></td>
<td>
<p>A list of values corresponding to the keys.</p>
</td></tr>
<tr><td><code id="Rdict-class_+3A_x">x</code>, <code id="Rdict-class_+3A_set">set</code></td>
<td>
<p>A <a href="#topic+Rdict-class">Rdict</a> object.</p>
</td></tr>
<tr><td><code id="Rdict-class_+3A_name">name</code></td>
<td>
<p>Either &quot;keys&quot; for a list of keys, &quot;values&quot; for a list of values, or &quot;items&quot; for a list of lists where each nested list is a (key, value) pair.</p>
</td></tr>
<tr><td><code id="Rdict-class_+3A_el">el</code></td>
<td>
<p>The element to search the dictionary of values for.</p>
</td></tr>
<tr><td><code id="Rdict-class_+3A_i">i</code></td>
<td>
<p>A key into the dictionary.</p>
</td></tr>
<tr><td><code id="Rdict-class_+3A_j">j</code>, <code id="Rdict-class_+3A_drop">drop</code>, <code id="Rdict-class_+3A_...">...</code></td>
<td>
<p>Unused arguments.</p>
</td></tr>
<tr><td><code id="Rdict-class_+3A_value">value</code></td>
<td>
<p>The value to assign to key <code>i</code>.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>keys</code></dt><dd><p>A list of keys.</p>
</dd>
<dt><code>values</code></dt><dd><p>A list of values corresponding to the keys.</p>
</dd>
</dl>

<hr>
<h2 id='Rdictdefault-class'>The Rdictdefault class.</h2><span id='topic+Rdictdefault-class'></span><span id='topic+Rdictdefault'></span><span id='topic++5B+2CRdictdefault+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>This is a subclass of <a href="#topic+Rdict-class">Rdict</a> that contains an additional slot for a default function, which assigns a value to an input key.
Only partially implemented, but working well enough for the geometric mean. Will be combined with <a href="#topic+Rdict-class">Rdict</a> later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rdictdefault(keys = list(), values = list(), default)

## S4 method for signature 'Rdictdefault,ANY,ANY,ANY'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rdictdefault-class_+3A_keys">keys</code></td>
<td>
<p>A list of keys.</p>
</td></tr>
<tr><td><code id="Rdictdefault-class_+3A_values">values</code></td>
<td>
<p>A list of values corresponding to the keys.</p>
</td></tr>
<tr><td><code id="Rdictdefault-class_+3A_default">default</code></td>
<td>
<p>A function that takes as input a key and outputs a value to assign to that key.</p>
</td></tr>
<tr><td><code id="Rdictdefault-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Rdictdefault-class">Rdictdefault</a> object.</p>
</td></tr>
<tr><td><code id="Rdictdefault-class_+3A_i">i</code></td>
<td>
<p>A key into the dictionary.</p>
</td></tr>
<tr><td><code id="Rdictdefault-class_+3A_j">j</code>, <code id="Rdictdefault-class_+3A_drop">drop</code>, <code id="Rdictdefault-class_+3A_...">...</code></td>
<td>
<p>Unused arguments.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>keys</code></dt><dd><p>A list of keys.</p>
</dd>
<dt><code>values</code></dt><dd><p>A list of values corresponding to the keys.</p>
</dd>
<dt><code>default</code></dt><dd><p>A function that takes as input a key and outputs a value to assign to that key.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+Rdict-class">Rdict</a>
</p>

<hr>
<h2 id='Real-class'>The Real class.</h2><span id='topic+Real-class'></span><span id='topic+.Real'></span><span id='topic+Real'></span><span id='topic+to_numeric+2CReal-method'></span><span id='topic+dim_from_args+2CReal-method'></span><span id='topic+is_imag+2CReal-method'></span><span id='topic+is_complex+2CReal-method'></span><span id='topic+is_symmetric+2CReal-method'></span>

<h3>Description</h3>

<p>This class represents the real part of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Real(expr)

## S4 method for signature 'Real'
to_numeric(object, values)

## S4 method for signature 'Real'
dim_from_args(object)

## S4 method for signature 'Real'
is_imag(object)

## S4 method for signature 'Real'
is_complex(object)

## S4 method for signature 'Real'
is_symmetric(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Real-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</td></tr>
<tr><td><code id="Real-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Real-class">Real</a> object.</p>
</td></tr>
<tr><td><code id="Real-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Real)</code>: The imaginary part of the given value.
</p>
</li>
<li> <p><code>dim_from_args(Real)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>is_imag(Real)</code>: Is the atom imaginary?
</p>
</li>
<li> <p><code>is_complex(Real)</code>: Is the atom complex valued?
</p>
</li>
<li> <p><code>is_symmetric(Real)</code>: Is the atom symmetric?
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</dd>
</dl>

<hr>
<h2 id='reduce'>Reduce a Problem</h2><span id='topic+reduce'></span>

<h3>Description</h3>

<p>Reduces the owned problem to an equivalent problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Reduction-class">Reduction</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An equivalent problem, encoded either as a <a href="#topic+Problem-class">Problem</a> object or a list.
</p>

<hr>
<h2 id='Reduction-class'>The Reduction class.</h2><span id='topic+Reduction-class'></span><span id='topic+accepts+2CReduction+2CProblem-method'></span><span id='topic+reduce+2CReduction-method'></span><span id='topic+retrieve+2CReduction+2CSolution-method'></span><span id='topic+perform+2CReduction+2CProblem-method'></span><span id='topic+invert+2CReduction+2CSolution+2Clist-method'></span>

<h3>Description</h3>

<p>This virtual class represents a reduction, an actor that transforms a problem
into an equivalent problem. By equivalent, we mean that there exists a mapping
between solutions of either problem: if we reduce a problem <code class="reqn">A</code> to another
problem <code class="reqn">B</code> and then proceed to find a solution to <code class="reqn">B</code>, we can convert
it to a solution of <code class="reqn">A</code> with at most a moderate amount of effort.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Reduction,Problem'
accepts(object, problem)

## S4 method for signature 'Reduction'
reduce(object)

## S4 method for signature 'Reduction,Solution'
retrieve(object, solution)

## S4 method for signature 'Reduction,Problem'
perform(object, problem)

## S4 method for signature 'Reduction,Solution,list'
invert(object, solution, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Reduction-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Reduction-class">Reduction</a> object.</p>
</td></tr>
<tr><td><code id="Reduction-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="Reduction-class_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> to a problem that generated the inverse data.</p>
</td></tr>
<tr><td><code id="Reduction-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>The data encoding the original problem.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every reduction supports three methods: accepts, perform, and invert. The accepts
method of a particular reduction codifies the types of problems that it is applicable
to, the perform method takes a problem and reduces it to a (new) equivalent form,
and the invert method maps solutions from reduced-to problems to their problems
of provenance.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>accepts(object = Reduction, problem = Problem)</code>: States whether the reduction accepts a problem.
</p>
</li>
<li> <p><code>reduce(Reduction)</code>: Reduces the owned problem to an equivalent problem.
</p>
</li>
<li> <p><code>retrieve(object = Reduction, solution = Solution)</code>: Retrieves a solution to the owned problem.
</p>
</li>
<li> <p><code>perform(object = Reduction, problem = Problem)</code>: Performs the reduction on a problem and returns an equivalent problem.
</p>
</li>
<li> <p><code>invert(object = Reduction, solution = Solution, inverse_data = list)</code>: Returns a solution to the original problem given the inverse data.
</p>
</li></ul>

<hr>
<h2 id='ReductionSolver-class'>The ReductionSolver class.</h2><span id='topic+ReductionSolver-class'></span><span id='topic+mip_capable+2CReductionSolver-method'></span><span id='topic+name+2CReductionSolver-method'></span><span id='topic+import_solver+2CReductionSolver-method'></span><span id='topic+is_installed+2CReductionSolver-method'></span><span id='topic+solve_via_data+2CReductionSolver-method'></span><span id='topic+reduction_solve+2CReductionSolver+2CANY-method'></span><span id='topic+solve_via_data+2CECOS-method'></span>

<h3>Description</h3>

<p>The ReductionSolver class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ReductionSolver'
mip_capable(solver)

## S4 method for signature 'ReductionSolver'
name(x)

## S4 method for signature 'ReductionSolver'
import_solver(solver)

## S4 method for signature 'ReductionSolver'
is_installed(solver)

## S4 method for signature 'ReductionSolver'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)

## S4 method for signature 'ReductionSolver,ANY'
reduction_solve(
  object,
  problem,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts
)

## S4 method for signature 'ECOS'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReductionSolver-class_+3A_solver">solver</code>, <code id="ReductionSolver-class_+3A_object">object</code>, <code id="ReductionSolver-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+ReductionSolver-class">ReductionSolver</a> object.</p>
</td></tr>
<tr><td><code id="ReductionSolver-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="ReductionSolver-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="ReductionSolver-class_+3A_verbose">verbose</code></td>
<td>
<p>An integer number indicating level of solver verbosity.</p>
</td></tr>
<tr><td><code id="ReductionSolver-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance on the primal and dual residual.</p>
</td></tr>
<tr><td><code id="ReductionSolver-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance on the duality gap.</p>
</td></tr>
<tr><td><code id="ReductionSolver-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance on the duality gap.</p>
</td></tr>
<tr><td><code id="ReductionSolver-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="ReductionSolver-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="ReductionSolver-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
<tr><td><code id="ReductionSolver-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(ReductionSolver)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>name(ReductionSolver)</code>: Returns the name of the solver
</p>
</li>
<li> <p><code>import_solver(ReductionSolver)</code>: Imports the solver
</p>
</li>
<li> <p><code>is_installed(ReductionSolver)</code>: Is the solver installed?
</p>
</li>
<li> <p><code>solve_via_data(ReductionSolver)</code>: Solve a problem represented by data returned from apply.
</p>
</li>
<li> <p><code>reduction_solve(object = ReductionSolver, problem = ANY)</code>: Solve a problem represented by data returned from apply.
</p>
</li>
<li> <p><code>solve_via_data(ECOS)</code>: Solve a problem represented by data returned from apply.
</p>
</li></ul>

<hr>
<h2 id='resetOptions'>Reset Options</h2><span id='topic+resetOptions'></span>

<h3>Description</h3>

<p>Reset the global package variable <code>.CVXR.options</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetOptions()
</code></pre>


<h3>Value</h3>

<p>The default value of CVXR package global <code>.CVXR.options</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  resetOptions()

## End(Not run)
</code></pre>

<hr>
<h2 id='reshape_expr'>Reshape an Expression</h2><span id='topic+reshape_expr'></span><span id='topic+reshape'></span>

<h3>Description</h3>

<p>This function vectorizes an expression, then unvectorizes it into a new shape. Entries are stored in column-major order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshape_expr(expr, new_dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshape_expr_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="reshape_expr_+3A_new_dim">new_dim</code></td>
<td>
<p>The new dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the reshaped input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(4)
mat &lt;- cbind(c(1,-1), c(2,-2))
vec &lt;- matrix(1:4)
expr &lt;- reshape_expr(x,c(2,2))
obj &lt;- Minimize(sum(mat %*% expr))
prob &lt;- Problem(obj, list(x == vec))
result &lt;- solve(prob)
result$value

A &lt;- Variable(2,2)
c &lt;- 1:4
expr &lt;- reshape_expr(A,c(4,1))
obj &lt;- Minimize(t(expr) %*% c)
constraints &lt;- list(A == cbind(c(-1,-2), c(3,4)))
prob &lt;- Problem(obj, constraints)
result &lt;- solve(prob)
result$value
result$getValue(expr)
result$getValue(reshape_expr(expr,c(2,2)))

C &lt;- Variable(3,2)
expr &lt;- reshape_expr(C,c(2,3))
mat &lt;- rbind(c(1,-1), c(2,-2))
C_mat &lt;- rbind(c(1,4), c(2,5), c(3,6))
obj &lt;- Minimize(sum(mat %*% expr))
prob &lt;- Problem(obj, list(C == C_mat))
result &lt;- solve(prob)
result$value
result$getValue(expr)

a &lt;- Variable()
c &lt;- cbind(c(1,-1), c(2,-2))
expr &lt;- reshape_expr(c * a,c(1,4))
obj &lt;- Minimize(expr %*% (1:4))
prob &lt;- Problem(obj, list(a == 2))
result &lt;- solve(prob)
result$value
result$getValue(expr)

expr &lt;- reshape_expr(c * a,c(4,1))
obj &lt;- Minimize(t(expr) %*% (1:4))
prob &lt;- Problem(obj, list(a == 2))
result &lt;- solve(prob)
result$value
result$getValue(expr)
</code></pre>

<hr>
<h2 id='Reshape-class'>The Reshape class.</h2><span id='topic+Reshape-class'></span><span id='topic+.Reshape'></span><span id='topic+Reshape'></span><span id='topic+to_numeric+2CReshape-method'></span><span id='topic+validate_args+2CReshape-method'></span><span id='topic+dim_from_args+2CReshape-method'></span><span id='topic+is_atom_log_log_convex+2CReshape-method'></span><span id='topic+is_atom_log_log_concave+2CReshape-method'></span><span id='topic+get_data+2CReshape-method'></span><span id='topic+graph_implementation+2CReshape-method'></span>

<h3>Description</h3>

<p>This class represents the reshaping of an expression. The operator vectorizes the expression,
then unvectorizes it into the new dimensions. Entries are stored in column-major order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Reshape(expr, new_dim)

## S4 method for signature 'Reshape'
to_numeric(object, values)

## S4 method for signature 'Reshape'
validate_args(object)

## S4 method for signature 'Reshape'
dim_from_args(object)

## S4 method for signature 'Reshape'
is_atom_log_log_convex(object)

## S4 method for signature 'Reshape'
is_atom_log_log_concave(object)

## S4 method for signature 'Reshape'
get_data(object)

## S4 method for signature 'Reshape'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Reshape-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="Reshape-class_+3A_new_dim">new_dim</code></td>
<td>
<p>The new dimensions.</p>
</td></tr>
<tr><td><code id="Reshape-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Reshape-class">Reshape</a> object.</p>
</td></tr>
<tr><td><code id="Reshape-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="Reshape-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="Reshape-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="Reshape-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Reshape)</code>: Reshape the value into the specified dimensions.
</p>
</li>
<li> <p><code>validate_args(Reshape)</code>: Check the new shape has the same number of entries as the old.
</p>
</li>
<li> <p><code>dim_from_args(Reshape)</code>: The <code>c(rows, cols)</code> dimensions of the new expression.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(Reshape)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(Reshape)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>get_data(Reshape)</code>: Returns a list containing the new shape.
</p>
</li>
<li> <p><code>graph_implementation(Reshape)</code>: The graph implementation of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
<dt><code>new_dim</code></dt><dd><p>The new dimensions.</p>
</dd>
</dl>

<hr>
<h2 id='residual-methods'>Constraint Residual</h2><span id='topic+residual-methods'></span><span id='topic+residual'></span><span id='topic+violation'></span>

<h3>Description</h3>

<p>The residual expression of a constraint, i.e. the amount by which it is violated, and the value of that violation.
For instance, if our constraint is <code class="reqn">g(x) \leq 0</code>, the residual is <code class="reqn">max(g(x), 0)</code> applied elementwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residual(object)

violation(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residual-methods_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Constraint-class">Constraint</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Expression-class">Expression</a> representing the residual, or the value of this expression.
</p>

<hr>
<h2 id='retrieve'>Retrieve Solution</h2><span id='topic+retrieve'></span>

<h3>Description</h3>

<p>Retrieves a solution to the owned problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieve(object, solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retrieve_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Reduction-class">Reduction</a> object.</p>
</td></tr>
<tr><td><code id="retrieve_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Solution-class">Solution</a> to the problem emitted by <code><a href="#topic+reduce">reduce</a></code>.
</p>

<hr>
<h2 id='scaled_lower_tri'>Utility methods for special handling of semidefinite constraints.</h2><span id='topic+scaled_lower_tri'></span>

<h3>Description</h3>

<p>Utility methods for special handling of semidefinite constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaled_lower_tri(matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaled_lower_tri_+3A_matrix">matrix</code></td>
<td>
<p>The matrix to get the lower triangular matrix for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The lower triangular part of the matrix, stacked in column-major order
</p>

<hr>
<h2 id='scalene'>Scalene Function</h2><span id='topic+scalene'></span>

<h3>Description</h3>

<p>The elementwise weighted sum of the positive and negative portions of an expression, <code class="reqn">\alpha\max(x_i,0) - \beta\min(x_i,0)</code>.
This is equivalent to <code>alpha*pos(x) + beta*neg(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalene(x, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalene_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="scalene_+3A_alpha">alpha</code></td>
<td>
<p>The weight on the positive portion of <code>x</code>.</p>
</td></tr>
<tr><td><code id="scalene_+3A_beta">beta</code></td>
<td>
<p>The weight on othe negative portion of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the scalene function evaluated at the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
A &lt;- Variable(2,2)
val &lt;- cbind(c(-5,2), c(-3,1))
prob &lt;- Problem(Minimize(scalene(A,2,3)[1,1]), list(A == val))
result &lt;- solve(prob)
result$value
result$getValue(scalene(A, 0.7, 0.3))

## End(Not run)
</code></pre>

<hr>
<h2 id='SCS-class'>An interface for the SCS solver</h2><span id='topic+SCS-class'></span><span id='topic+SCS'></span><span id='topic+mip_capable+2CSCS-method'></span><span id='topic+status_map+2CSCS-method'></span><span id='topic+name+2CSCS-method'></span><span id='topic+import_solver+2CSCS-method'></span><span id='topic+reduction_format_constr+2CSCS-method'></span><span id='topic+perform+2CSCS+2CProblem-method'></span><span id='topic+invert+2CSCS+2Clist+2Clist-method'></span><span id='topic+solve_via_data+2CSCS-method'></span>

<h3>Description</h3>

<p>An interface for the SCS solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCS()

## S4 method for signature 'SCS'
mip_capable(solver)

## S4 method for signature 'SCS'
status_map(solver, status)

## S4 method for signature 'SCS'
name(x)

## S4 method for signature 'SCS'
import_solver(solver)

## S4 method for signature 'SCS'
reduction_format_constr(object, problem, constr, exp_cone_order)

## S4 method for signature 'SCS,Problem'
perform(object, problem)

## S4 method for signature 'SCS,list,list'
invert(object, solution, inverse_data)

## S4 method for signature 'SCS'
solve_via_data(
  object,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts,
  solver_cache
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCS-class_+3A_solver">solver</code>, <code id="SCS-class_+3A_object">object</code>, <code id="SCS-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+SCS-class">SCS</a> object.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_status">status</code></td>
<td>
<p>A status code returned by the solver.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_constr">constr</code></td>
<td>
<p>A <a href="#topic+Constraint-class">Constraint</a> to format.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_exp_cone_order">exp_cone_order</code></td>
<td>
<p>A list indicating how the exponential cone arguments are ordered.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_solution">solution</code></td>
<td>
<p>The raw solution returned by the solver.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A list containing data necessary for the inversion.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_data">data</code></td>
<td>
<p>Data generated via an apply call.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance on the primal and dual residual.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance on the duality gap.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance on the duality gap.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="SCS-class_+3A_solver_cache">solver_cache</code></td>
<td>
<p>Cache for the solver.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>mip_capable(SCS)</code>: Can the solver handle mixed-integer programs?
</p>
</li>
<li> <p><code>status_map(SCS)</code>: Converts status returned by SCS solver to its respective CVXPY status.
</p>
</li>
<li> <p><code>name(SCS)</code>: Returns the name of the solver
</p>
</li>
<li> <p><code>import_solver(SCS)</code>: Imports the solver
</p>
</li>
<li> <p><code>reduction_format_constr(SCS)</code>: Return a linear operator to multiply by PSD constraint coefficients.
</p>
</li>
<li> <p><code>perform(object = SCS, problem = Problem)</code>: Returns a new problem and data for inverting the new solution
</p>
</li>
<li> <p><code>invert(object = SCS, solution = list, inverse_data = list)</code>: Returns the solution to the original problem given the inverse_data.
</p>
</li>
<li> <p><code>solve_via_data(SCS)</code>: Solve a problem represented by data returned from apply.
</p>
</li></ul>

<hr>
<h2 id='SCS.dims_to_solver_dict'>Utility method for formatting a ConeDims instance into a dictionary
that can be supplied to SCS.</h2><span id='topic+SCS.dims_to_solver_dict'></span>

<h3>Description</h3>

<p>Utility method for formatting a ConeDims instance into a dictionary
that can be supplied to SCS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCS.dims_to_solver_dict(cone_dims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCS.dims_to_solver_dict_+3A_cone_dims">cone_dims</code></td>
<td>
<p>A <a href="#topic+ConeDims-class">ConeDims</a> instance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dimensions of the cones.
</p>

<hr>
<h2 id='SCS.extract_dual_value'>Extracts the dual value for constraint starting at offset.</h2><span id='topic+SCS.extract_dual_value'></span>

<h3>Description</h3>

<p>Special cases PSD constraints, as per the SCS specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCS.extract_dual_value(result_vec, offset, constraint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCS.extract_dual_value_+3A_result_vec">result_vec</code></td>
<td>
<p>The vector to extract dual values from.</p>
</td></tr>
<tr><td><code id="SCS.extract_dual_value_+3A_offset">offset</code></td>
<td>
<p>The starting point of the vector to extract from.</p>
</td></tr>
<tr><td><code id="SCS.extract_dual_value_+3A_constraint">constraint</code></td>
<td>
<p>A <a href="#topic+Constraint-class">Constraint</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dual values for the corresponding PSD constraints
</p>

<hr>
<h2 id='setIdCounter'>Set ID Counter</h2><span id='topic+setIdCounter'></span>

<h3>Description</h3>

<p>Set the CVXR variable/constraint identification number counter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setIdCounter(value = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setIdCounter_+3A_value">value</code></td>
<td>
<p>The value to assign as ID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the changed value of the package global <code>.CVXR.options</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  setIdCounter(value = 0L)

## End(Not run)
</code></pre>

<hr>
<h2 id='sigma_max'>Maximum Singular Value</h2><span id='topic+sigma_max'></span>

<h3>Description</h3>

<p>The maximum singular value of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma_max(A = A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma_max_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the maximum singular value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- Variable(3,2)
val &lt;- rbind(c(1,2), c(3,4), c(5,6))
obj &lt;- sigma_max(C)
constr &lt;- list(C == val)
prob &lt;- Problem(Minimize(obj), constr)
result &lt;- solve(prob, solver = "SCS")
result$value
result$getValue(C)
</code></pre>

<hr>
<h2 id='SigmaMax-class'>The SigmaMax class.</h2><span id='topic+SigmaMax-class'></span><span id='topic+.SigmaMax'></span><span id='topic+SigmaMax'></span><span id='topic+to_numeric+2CSigmaMax-method'></span><span id='topic+allow_complex+2CSigmaMax-method'></span><span id='topic+dim_from_args+2CSigmaMax-method'></span><span id='topic+sign_from_args+2CSigmaMax-method'></span><span id='topic+is_atom_convex+2CSigmaMax-method'></span><span id='topic+is_atom_concave+2CSigmaMax-method'></span><span id='topic+is_incr+2CSigmaMax-method'></span><span id='topic+is_decr+2CSigmaMax-method'></span><span id='topic+.grad+2CSigmaMax-method'></span>

<h3>Description</h3>

<p>The maximum singular value of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SigmaMax(A = A)

## S4 method for signature 'SigmaMax'
to_numeric(object, values)

## S4 method for signature 'SigmaMax'
allow_complex(object)

## S4 method for signature 'SigmaMax'
dim_from_args(object)

## S4 method for signature 'SigmaMax'
sign_from_args(object)

## S4 method for signature 'SigmaMax'
is_atom_convex(object)

## S4 method for signature 'SigmaMax'
is_atom_concave(object)

## S4 method for signature 'SigmaMax'
is_incr(object, idx)

## S4 method for signature 'SigmaMax'
is_decr(object, idx)

## S4 method for signature 'SigmaMax'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SigmaMax-class_+3A_a">A</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
<tr><td><code id="SigmaMax-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+SigmaMax-class">SigmaMax</a> object.</p>
</td></tr>
<tr><td><code id="SigmaMax-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="SigmaMax-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(SigmaMax)</code>: The largest singular value of <code>A</code>.
</p>
</li>
<li> <p><code>allow_complex(SigmaMax)</code>: Does the atom handle complex numbers?
</p>
</li>
<li> <p><code>dim_from_args(SigmaMax)</code>: The atom is a scalar.
</p>
</li>
<li> <p><code>sign_from_args(SigmaMax)</code>: The atom is positive.
</p>
</li>
<li> <p><code>is_atom_convex(SigmaMax)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(SigmaMax)</code>: The atom is concave.
</p>
</li>
<li> <p><code>is_incr(SigmaMax)</code>: The atom is not monotonic in any argument.
</p>
</li>
<li> <p><code>is_decr(SigmaMax)</code>: The atom is not monotonic in any argument.
</p>
</li>
<li> <p><code>.grad(SigmaMax)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>A</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='sign_from_args'>Atom Sign</h2><span id='topic+sign_from_args'></span><span id='topic+sign_from_args+2CAtom-method'></span>

<h3>Description</h3>

<p>Determine the sign of an atom based on its arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sign_from_args(object)

## S4 method for signature 'Atom'
sign_from_args(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sign_from_args_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Atom-class">Atom</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector <code>c(is positive, is negative)</code> indicating the sign of the atom.
</p>

<hr>
<h2 id='sign-methods'>Sign Properties</h2><span id='topic+sign-methods'></span><span id='topic+is_zero'></span><span id='topic+is_nonneg'></span><span id='topic+is_nonpos'></span>

<h3>Description</h3>

<p>Determine if an expression is positive, negative, or zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_zero(object)

is_nonneg(object)

is_nonpos(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sign-methods_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pos &lt;- Constant(1)
neg &lt;- Constant(-1)
zero &lt;- Constant(0)
unknown &lt;- Variable()

is_zero(pos)
is_zero(-zero)
is_zero(unknown)
is_zero(pos + neg)

is_nonneg(pos + zero)
is_nonneg(pos * neg)
is_nonneg(pos - neg)
is_nonneg(unknown)

is_nonpos(-pos)
is_nonpos(pos + neg)
is_nonpos(neg * zero)
is_nonpos(neg - pos)
</code></pre>

<hr>
<h2 id='sign+2CExpression-method'>Sign of Expression</h2><span id='topic+sign+2CExpression-method'></span>

<h3>Description</h3>

<p>The sign of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression'
sign(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sign+2B2CExpression-method_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string indicating the sign of the expression, either &quot;ZERO&quot;, &quot;NONNEGATIVE&quot;, &quot;NONPOSITIVE&quot;, or &quot;UNKNOWN&quot;.
</p>

<hr>
<h2 id='size'>Size of Expression</h2><span id='topic+size'></span><span id='topic+size+2CListORExpr-method'></span>

<h3>Description</h3>

<p>The size of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size(object)

## S4 method for signature 'ListORExpr'
size(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with two elements <code>c(row, col)</code> representing the dimensions of the expression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable()
y &lt;- Variable(3)
z &lt;- Variable(3,2)

size(x)
size(y)
size(z)
size(x + y)
size(z - x)
</code></pre>

<hr>
<h2 id='size-methods'>Size Properties</h2><span id='topic+size-methods'></span><span id='topic+is_scalar'></span><span id='topic+is_vector'></span><span id='topic+is_matrix'></span>

<h3>Description</h3>

<p>Determine if an expression is a scalar, vector, or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_scalar(object)

is_vector(object)

is_matrix(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size-methods_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable()
y &lt;- Variable(3)
z &lt;- Variable(3,2)

is_scalar(x)
is_scalar(y)
is_scalar(x + y)

is_vector(x)
is_vector(y)
is_vector(2*z)

is_matrix(x)
is_matrix(y)
is_matrix(z)
is_matrix(z - x)
</code></pre>

<hr>
<h2 id='SizeMetrics-class'>The SizeMetrics class.</h2><span id='topic+SizeMetrics-class'></span><span id='topic+.SizeMetrics'></span><span id='topic+SizeMetrics'></span>

<h3>Description</h3>

<p>This class contains various metrics regarding the problem size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SizeMetrics(problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SizeMetrics-class_+3A_problem">problem</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>num_scalar_variables</code></dt><dd><p>The number of scalar variables in the problem.</p>
</dd>
<dt><code>num_scalar_data</code></dt><dd><p>The number of constants used across all matrices and vectors in the problem. Some constants are not apparent when the problem is constructed. For example, the <code>sum_squares</code> expression is a wrapper for a <code>quad_over_lin</code> expression with a constant <code>1</code> in the denominator.</p>
</dd>
<dt><code>num_scalar_eq_constr</code></dt><dd><p>The number of scalar equality constraints in the problem.</p>
</dd>
<dt><code>num_scalar_leq_constr</code></dt><dd><p>The number of scalar inequality constraints in the problem.</p>
</dd>
<dt><code>max_data_dimension</code></dt><dd><p>The longest dimension of any data block constraint or parameter.</p>
</dd>
<dt><code>max_big_small_squared</code></dt><dd><p>The maximum value of (big)(small)^2 over all data blocks of the problem, where (big) is the larger dimension and (small) is the smaller dimension for each data block.</p>
</dd>
</dl>

<hr>
<h2 id='SOC-class'>The SOC class.</h2><span id='topic+SOC-class'></span><span id='topic+.SOC'></span><span id='topic+SOC'></span><span id='topic+as.character+2CSOC-method'></span><span id='topic+residual+2CSOC-method'></span><span id='topic+get_data+2CSOC-method'></span><span id='topic+format_constr+2CSOC-method'></span><span id='topic+num_cones+2CSOC-method'></span><span id='topic+size+2CSOC-method'></span><span id='topic+cone_sizes+2CSOC-method'></span><span id='topic+is_dcp+2CSOC-method'></span><span id='topic+is_dgp+2CSOC-method'></span><span id='topic+canonicalize+2CSOC-method'></span>

<h3>Description</h3>

<p>This class represents a second-order cone constraint, i.e. <code class="reqn">\|x\|_2 \leq t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SOC(t, X, axis = 2, id = NA_integer_)

## S4 method for signature 'SOC'
as.character(x)

## S4 method for signature 'SOC'
residual(object)

## S4 method for signature 'SOC'
get_data(object)

## S4 method for signature 'SOC'
format_constr(object, eq_constr, leq_constr, dims, solver)

## S4 method for signature 'SOC'
num_cones(object)

## S4 method for signature 'SOC'
size(object)

## S4 method for signature 'SOC'
cone_sizes(object)

## S4 method for signature 'SOC'
is_dcp(object)

## S4 method for signature 'SOC'
is_dgp(object)

## S4 method for signature 'SOC'
canonicalize(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SOC-class_+3A_t">t</code></td>
<td>
<p>The scalar part of the second-order constraint.</p>
</td></tr>
<tr><td><code id="SOC-class_+3A_x">X</code></td>
<td>
<p>A matrix whose rows/columns are each a cone.</p>
</td></tr>
<tr><td><code id="SOC-class_+3A_axis">axis</code></td>
<td>
<p>The dimension along which to slice: <code>1</code> indicates rows, and <code>2</code> indicates columns. The default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="SOC-class_+3A_id">id</code></td>
<td>
<p>(Optional) A numeric value representing the constraint ID.</p>
</td></tr>
<tr><td><code id="SOC-class_+3A_x">x</code>, <code id="SOC-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+SOC-class">SOC</a> object.</p>
</td></tr>
<tr><td><code id="SOC-class_+3A_eq_constr">eq_constr</code></td>
<td>
<p>A list of the equality constraints in the canonical problem.</p>
</td></tr>
<tr><td><code id="SOC-class_+3A_leq_constr">leq_constr</code></td>
<td>
<p>A list of the inequality constraints in the canonical problem.</p>
</td></tr>
<tr><td><code id="SOC-class_+3A_dims">dims</code></td>
<td>
<p>A list with the dimensions of the conic constraints.</p>
</td></tr>
<tr><td><code id="SOC-class_+3A_solver">solver</code></td>
<td>
<p>A string representing the solver to be called.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>residual(SOC)</code>: The residual of the second-order constraint.
</p>
</li>
<li> <p><code>get_data(SOC)</code>: Information needed to reconstruct the object aside from the args.
</p>
</li>
<li> <p><code>format_constr(SOC)</code>: Format SOC constraints as inequalities for the solver.
</p>
</li>
<li> <p><code>num_cones(SOC)</code>: The number of elementwise cones.
</p>
</li>
<li> <p><code>size(SOC)</code>: The number of entries in the combined cones.
</p>
</li>
<li> <p><code>cone_sizes(SOC)</code>: The dimensions of the second-order cones.
</p>
</li>
<li> <p><code>is_dcp(SOC)</code>: An SOC constraint is DCP if each of its arguments is affine.
</p>
</li>
<li> <p><code>is_dgp(SOC)</code>: Is the constraint DGP?
</p>
</li>
<li> <p><code>canonicalize(SOC)</code>: The canonicalization of the constraint.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>t</code></dt><dd><p>The scalar part of the second-order constraint.</p>
</dd>
<dt><code>X</code></dt><dd><p>A matrix whose rows/columns are each a cone.</p>
</dd>
<dt><code>axis</code></dt><dd><p>The dimension along which to slice: <code>1</code> indicates rows, and <code>2</code> indicates columns. The default is <code>2</code>.</p>
</dd>
</dl>

<hr>
<h2 id='SOCAxis-class'>The SOCAxis class.</h2><span id='topic+SOCAxis-class'></span><span id='topic+.SOCAxis'></span><span id='topic+SOCAxis'></span><span id='topic+as.character+2CSOCAxis-method'></span><span id='topic+format_constr+2CSOCAxis-method'></span><span id='topic+num_cones+2CSOCAxis-method'></span><span id='topic+cone_sizes+2CSOCAxis-method'></span><span id='topic+size+2CSOCAxis-method'></span>

<h3>Description</h3>

<p>This class represents a second-order cone constraint for each row/column.
It Assumes <code class="reqn">t</code> is a vector the same length as <code class="reqn">X</code>'s rows (columns) for axis == 1 (2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SOCAxis(t, X, axis, id = NA_integer_)

## S4 method for signature 'SOCAxis'
as.character(x)

## S4 method for signature 'SOCAxis'
format_constr(object, eq_constr, leq_constr, dims, solver)

## S4 method for signature 'SOCAxis'
num_cones(object)

## S4 method for signature 'SOCAxis'
cone_sizes(object)

## S4 method for signature 'SOCAxis'
size(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SOCAxis-class_+3A_t">t</code></td>
<td>
<p>The scalar part of the second-order constraint.</p>
</td></tr>
<tr><td><code id="SOCAxis-class_+3A_x">X</code></td>
<td>
<p>A matrix whose rows/columns are each a cone.</p>
</td></tr>
<tr><td><code id="SOCAxis-class_+3A_axis">axis</code></td>
<td>
<p>The dimension across which to take the slice: <code>1</code> indicates rows, and <code>2</code> indicates columns.</p>
</td></tr>
<tr><td><code id="SOCAxis-class_+3A_id">id</code></td>
<td>
<p>(Optional) A numeric value representing the constraint ID.</p>
</td></tr>
<tr><td><code id="SOCAxis-class_+3A_x">x</code>, <code id="SOCAxis-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+SOCAxis-class">SOCAxis</a> object.</p>
</td></tr>
<tr><td><code id="SOCAxis-class_+3A_eq_constr">eq_constr</code></td>
<td>
<p>A list of the equality constraints in the canonical problem.</p>
</td></tr>
<tr><td><code id="SOCAxis-class_+3A_leq_constr">leq_constr</code></td>
<td>
<p>A list of the inequality constraints in the canonical problem.</p>
</td></tr>
<tr><td><code id="SOCAxis-class_+3A_dims">dims</code></td>
<td>
<p>A list with the dimensions of the conic constraints.</p>
</td></tr>
<tr><td><code id="SOCAxis-class_+3A_solver">solver</code></td>
<td>
<p>A string representing the solver to be called.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>format_constr(SOCAxis)</code>: Format SOC constraints as inequalities for the solver.
</p>
</li>
<li> <p><code>num_cones(SOCAxis)</code>: The number of elementwise cones.
</p>
</li>
<li> <p><code>cone_sizes(SOCAxis)</code>: The dimensions of a single cone.
</p>
</li>
<li> <p><code>size(SOCAxis)</code>: The dimensions of the (elementwise) second-order cones.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>t</code></dt><dd><p>The scalar part of the second-order constraint.</p>
</dd>
<dt><code>x_elems</code></dt><dd><p>A list containing <code>X</code>, a matrix whose rows/columns are each a cone.</p>
</dd>
<dt><code>axis</code></dt><dd><p>The dimension across which to take the slice: <code>1</code> indicates rows, and <code>2</code> indicates columns.</p>
</dd>
</dl>

<hr>
<h2 id='Solution-class'>The Solution class.</h2><span id='topic+Solution-class'></span><span id='topic+.Solution'></span><span id='topic+as.character+2CSolution-method'></span>

<h3>Description</h3>

<p>This class represents a solution to an optimization problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Solution'
as.character(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Solution-class_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> object.</p>
</td></tr>
</table>

<hr>
<h2 id='SolverStats-class'>The SolverStats class.</h2><span id='topic+SolverStats-class'></span><span id='topic+.SolverStats'></span><span id='topic+SolverStats'></span>

<h3>Description</h3>

<p>This class contains the miscellaneous information that is returned by a solver after solving, but that is not captured directly by the <a href="#topic+Problem-class">Problem</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SolverStats(results_dict = list(), solver_name = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SolverStats-class_+3A_results_dict">results_dict</code></td>
<td>
<p>A list containing the results returned by the solver.</p>
</td></tr>
<tr><td><code id="SolverStats-class_+3A_solver_name">solver_name</code></td>
<td>
<p>The name of the solver.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>

<dl>
<dt><code>solver_name</code></dt><dd><p>The name of the solver.</p>
</dd>
<dt><code>solve_time</code></dt><dd><p>The time (in seconds) it took for the solver to solve the problem.</p>
</dd>
<dt><code>setup_time</code></dt><dd><p>The time (in seconds) it took for the solver to set up the problem.</p>
</dd>
<dt><code>num_iters</code></dt><dd><p>The number of iterations the solver had to go through to find a solution.</p>
</dd>
</dl>



<h3>Slots</h3>


<dl>
<dt><code>solver_name</code></dt><dd><p>The name of the solver.</p>
</dd>
<dt><code>solve_time</code></dt><dd><p>The time (in seconds) it took for the solver to solve the problem.</p>
</dd>
<dt><code>setup_time</code></dt><dd><p>The time (in seconds) it took for the solver to set up the problem.</p>
</dd>
<dt><code>num_iters</code></dt><dd><p>The number of iterations the solver had to go through to find a solution.</p>
</dd>
</dl>

<hr>
<h2 id='SolvingChain-class'>The SolvingChain class.</h2><span id='topic+SolvingChain-class'></span><span id='topic+.SolvingChain'></span><span id='topic+prepend+2CSolvingChain+2CChain-method'></span><span id='topic+reduction_solve+2CSolvingChain+2CProblem-method'></span><span id='topic+reduction_solve_via_data+2CSolvingChain-method'></span>

<h3>Description</h3>

<p>This class represents a reduction chain that ends with a solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SolvingChain,Chain'
prepend(object, chain)

## S4 method for signature 'SolvingChain,Problem'
reduction_solve(
  object,
  problem,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts
)

## S4 method for signature 'SolvingChain'
reduction_solve_via_data(
  object,
  problem,
  data,
  warm_start,
  verbose,
  feastol,
  reltol,
  abstol,
  num_iter,
  solver_opts
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SolvingChain-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+SolvingChain-class">SolvingChain</a> object.</p>
</td></tr>
<tr><td><code id="SolvingChain-class_+3A_chain">chain</code></td>
<td>
<p>A <a href="#topic+Chain-class">Chain</a> to prepend.</p>
</td></tr>
<tr><td><code id="SolvingChain-class_+3A_problem">problem</code></td>
<td>
<p>The problem to solve.</p>
</td></tr>
<tr><td><code id="SolvingChain-class_+3A_warm_start">warm_start</code></td>
<td>
<p>A boolean of whether to warm start the solver.</p>
</td></tr>
<tr><td><code id="SolvingChain-class_+3A_verbose">verbose</code></td>
<td>
<p>A boolean of whether to enable solver verbosity.</p>
</td></tr>
<tr><td><code id="SolvingChain-class_+3A_feastol">feastol</code></td>
<td>
<p>The feasible tolerance.</p>
</td></tr>
<tr><td><code id="SolvingChain-class_+3A_reltol">reltol</code></td>
<td>
<p>The relative tolerance.</p>
</td></tr>
<tr><td><code id="SolvingChain-class_+3A_abstol">abstol</code></td>
<td>
<p>The absolute tolerance.</p>
</td></tr>
<tr><td><code id="SolvingChain-class_+3A_num_iter">num_iter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="SolvingChain-class_+3A_solver_opts">solver_opts</code></td>
<td>
<p>A list of Solver specific options</p>
</td></tr>
<tr><td><code id="SolvingChain-class_+3A_data">data</code></td>
<td>
<p>Data for the solver.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>prepend(object = SolvingChain, chain = Chain)</code>: Create and return a new SolvingChain by concatenating chain with this instance.
</p>
</li>
<li> <p><code>reduction_solve(object = SolvingChain, problem = Problem)</code>: Applies each reduction in the chain to the problem, solves it,
and then inverts the chain to return a solution of the supplied problem.
</p>
</li>
<li> <p><code>reduction_solve_via_data(SolvingChain)</code>: Solves the problem using the data output by the an apply invocation.
</p>
</li></ul>

<hr>
<h2 id='sqrt+2CExpression-method'>Square Root</h2><span id='topic+sqrt+2CExpression-method'></span><span id='topic+sqrt'></span>

<h3>Description</h3>

<p>The elementwise square root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression'
sqrt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqrt+2B2CExpression-method_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the square root of the input.
A &lt;- Variable(2,2)
val &lt;- cbind(c(2,4), c(16,1))
prob &lt;- Problem(Maximize(sqrt(A)[1,2]), list(A == val))
result &lt;- solve(prob)
result$value
</p>

<hr>
<h2 id='square+2CExpression-method'>Square</h2><span id='topic+square+2CExpression-method'></span><span id='topic+square'></span>

<h3>Description</h3>

<p>The elementwise square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Expression'
square(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="square+2B2CExpression-method_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the square of the input.
A &lt;- Variable(2,2)
val &lt;- cbind(c(2,4), c(16,1))
prob &lt;- Problem(Minimize(square(A)[1,2]), list(A == val))
result &lt;- solve(prob)
result$value
</p>

<hr>
<h2 id='sum_entries'>Sum of Entries</h2><span id='topic+sum_entries'></span><span id='topic+sum'></span><span id='topic+sum.Expression'></span>

<h3>Description</h3>

<p>The sum of entries in a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_entries(expr, axis = NA_real_, keepdims = FALSE)

## S3 method for class 'Expression'
sum(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_entries_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="sum_entries_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sum_entries_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sum_entries_+3A_...">...</code></td>
<td>
<p>Numeric scalar, vector, matrix, or <a href="#topic+Expression-class">Expression</a> objects.</p>
</td></tr>
<tr><td><code id="sum_entries_+3A_na.rm">na.rm</code></td>
<td>
<p>(Unimplemented) A logical value indicating whether missing values should be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the sum of the entries of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(2)
prob &lt;- Problem(Minimize(sum_entries(x)), list(t(x) &gt;= matrix(c(1,2), nrow = 1, ncol = 2)))
result &lt;- solve(prob)
result$value
result$getValue(x)

C &lt;- Variable(3,2)
prob &lt;- Problem(Maximize(sum_entries(C)), list(C[2:3,] &lt;= 2, C[1,] == 1))
result &lt;- solve(prob)
result$value
result$getValue(C)
x &lt;- Variable(2)
prob &lt;- Problem(Minimize(sum_entries(x)), list(t(x) &gt;= matrix(c(1,2), nrow = 1, ncol = 2)))
result &lt;- solve(prob)
result$value
result$getValue(x)

C &lt;- Variable(3,2)
prob &lt;- Problem(Maximize(sum_entries(C)), list(C[2:3,] &lt;= 2, C[1,] == 1))
result &lt;- solve(prob)
result$value
result$getValue(C)
</code></pre>

<hr>
<h2 id='sum_largest'>Sum of Largest Values</h2><span id='topic+sum_largest'></span>

<h3>Description</h3>

<p>The sum of the largest <code class="reqn">k</code> values of a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_largest(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_largest_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="sum_largest_+3A_k">k</code></td>
<td>
<p>The number of largest values to sum over.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the sum of the largest <code>k</code> values of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(122)
m &lt;- 300
n &lt;- 9
X &lt;- matrix(stats::rnorm(m*n), nrow = m, ncol = n)
X &lt;- cbind(rep(1,m), X)
b &lt;- c(0, 0.8, 0, 1, 0.2, 0, 0.4, 1, 0, 0.7)
y &lt;- X %*% b + stats::rnorm(m)

beta &lt;- Variable(n+1)
obj &lt;- sum_largest((y - X %*% beta)^2, 100)
prob &lt;- Problem(Minimize(obj))
result &lt;- solve(prob)
result$getValue(beta)
</code></pre>

<hr>
<h2 id='sum_smallest'>Sum of Smallest Values</h2><span id='topic+sum_smallest'></span>

<h3>Description</h3>

<p>The sum of the smallest k values of a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_smallest(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_smallest_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="sum_smallest_+3A_k">k</code></td>
<td>
<p>The number of smallest values to sum over.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the sum of the smallest k values of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1323)
m &lt;- 300
n &lt;- 9
X &lt;- matrix(stats::rnorm(m*n), nrow = m, ncol = n)
X &lt;- cbind(rep(1,m), X)
b &lt;- c(0, 0.8, 0, 1, 0.2, 0, 0.4, 1, 0, 0.7)
factor &lt;- 2*rbinom(m, size = 1, prob = 0.8) - 1
y &lt;- factor * (X %*% b) + stats::rnorm(m)

beta &lt;- Variable(n+1)
obj &lt;- sum_smallest(y - X %*% beta, 200)
prob &lt;- Problem(Maximize(obj), list(0 &lt;= beta, beta &lt;= 1))
result &lt;- solve(prob)
result$getValue(beta)
</code></pre>

<hr>
<h2 id='sum_squares'>Sum of Squares</h2><span id='topic+sum_squares'></span>

<h3>Description</h3>

<p>The sum of the squared entries in a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_squares(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_squares_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the sum of squares of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(212)
m &lt;- 30
n &lt;- 20
A &lt;- matrix(stats::rnorm(m*n), nrow = m, ncol = n)
b &lt;- matrix(stats::rnorm(m), nrow = m, ncol = 1)

x &lt;- Variable(n)
obj &lt;- Minimize(sum_squares(A %*% x - b))
constr &lt;- list(0 &lt;= x, x &lt;= 1)
prob &lt;- Problem(obj, constr)
result &lt;- solve(prob)

result$value
result$getValue(x)
result$getDualValue(constr[[1]])
</code></pre>

<hr>
<h2 id='SumEntries-class'>The SumEntries class.</h2><span id='topic+SumEntries-class'></span><span id='topic+.SumEntries'></span><span id='topic+SumEntries'></span><span id='topic+to_numeric+2CSumEntries-method'></span><span id='topic+is_atom_log_log_convex+2CSumEntries-method'></span><span id='topic+is_atom_log_log_concave+2CSumEntries-method'></span><span id='topic+graph_implementation+2CSumEntries-method'></span>

<h3>Description</h3>

<p>This class represents the sum of all entries in a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SumEntries(expr, axis = NA_real_, keepdims = FALSE)

## S4 method for signature 'SumEntries'
to_numeric(object, values)

## S4 method for signature 'SumEntries'
is_atom_log_log_convex(object)

## S4 method for signature 'SumEntries'
is_atom_log_log_concave(object)

## S4 method for signature 'SumEntries'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SumEntries-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</td></tr>
<tr><td><code id="SumEntries-class_+3A_axis">axis</code></td>
<td>
<p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="SumEntries-class_+3A_keepdims">keepdims</code></td>
<td>
<p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="SumEntries-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+SumEntries-class">SumEntries</a> object.</p>
</td></tr>
<tr><td><code id="SumEntries-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="SumEntries-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="SumEntries-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="SumEntries-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(SumEntries)</code>: Sum the entries along the specified axis.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(SumEntries)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(SumEntries)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>graph_implementation(SumEntries)</code>: The graph implementation of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing a vector or matrix.</p>
</dd>
<dt><code>axis</code></dt><dd><p>(Optional) The dimension across which to apply the function: <code>1</code> indicates rows, <code>2</code> indicates columns, and <code>NA</code> indicates rows and columns. The default is <code>NA</code>.</p>
</dd>
<dt><code>keepdims</code></dt><dd><p>(Optional) Should dimensions be maintained when applying the atom along an axis? If <code>FALSE</code>, result will be collapsed into an <code class="reqn">n x 1</code> column vector. The default is <code>FALSE</code>.</p>
</dd>
</dl>

<hr>
<h2 id='SumLargest-class'>The SumLargest class.</h2><span id='topic+SumLargest-class'></span><span id='topic+.SumLargest'></span><span id='topic+SumLargest'></span><span id='topic+to_numeric+2CSumLargest-method'></span><span id='topic+validate_args+2CSumLargest-method'></span><span id='topic+dim_from_args+2CSumLargest-method'></span><span id='topic+sign_from_args+2CSumLargest-method'></span><span id='topic+is_atom_convex+2CSumLargest-method'></span><span id='topic+is_atom_concave+2CSumLargest-method'></span><span id='topic+is_incr+2CSumLargest-method'></span><span id='topic+is_decr+2CSumLargest-method'></span><span id='topic+get_data+2CSumLargest-method'></span><span id='topic+.grad+2CSumLargest-method'></span>

<h3>Description</h3>

<p>The sum of the largest k values of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SumLargest(x, k)

## S4 method for signature 'SumLargest'
to_numeric(object, values)

## S4 method for signature 'SumLargest'
validate_args(object)

## S4 method for signature 'SumLargest'
dim_from_args(object)

## S4 method for signature 'SumLargest'
sign_from_args(object)

## S4 method for signature 'SumLargest'
is_atom_convex(object)

## S4 method for signature 'SumLargest'
is_atom_concave(object)

## S4 method for signature 'SumLargest'
is_incr(object, idx)

## S4 method for signature 'SumLargest'
is_decr(object, idx)

## S4 method for signature 'SumLargest'
get_data(object)

## S4 method for signature 'SumLargest'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SumLargest-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="SumLargest-class_+3A_k">k</code></td>
<td>
<p>The number of largest values to sum over.</p>
</td></tr>
<tr><td><code id="SumLargest-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+SumLargest-class">SumLargest</a> object.</p>
</td></tr>
<tr><td><code id="SumLargest-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
<tr><td><code id="SumLargest-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(SumLargest)</code>: The sum of the <code>k</code> largest entries of the vector or matrix.
</p>
</li>
<li> <p><code>validate_args(SumLargest)</code>: Check that <code>k</code> is a positive integer.
</p>
</li>
<li> <p><code>dim_from_args(SumLargest)</code>: The atom is a scalar.
</p>
</li>
<li> <p><code>sign_from_args(SumLargest)</code>: The sign of the atom.
</p>
</li>
<li> <p><code>is_atom_convex(SumLargest)</code>: The atom is convex.
</p>
</li>
<li> <p><code>is_atom_concave(SumLargest)</code>: The atom is not concave.
</p>
</li>
<li> <p><code>is_incr(SumLargest)</code>: The atom is weakly increasing in every argument.
</p>
</li>
<li> <p><code>is_decr(SumLargest)</code>: The atom is not weakly decreasing in any argument.
</p>
</li>
<li> <p><code>get_data(SumLargest)</code>: A list containing <code>k</code>.
</p>
</li>
<li> <p><code>.grad(SumLargest)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
<dt><code>k</code></dt><dd><p>The number of largest values to sum over.</p>
</dd>
</dl>

<hr>
<h2 id='SumSmallest'>The SumSmallest atom.</h2><span id='topic+SumSmallest'></span>

<h3>Description</h3>

<p>The sum of the smallest k values of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SumSmallest(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SumSmallest_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="SumSmallest_+3A_k">k</code></td>
<td>
<p>The number of smallest values to sum over.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of the smlalest k values
</p>

<hr>
<h2 id='SumSquares'>The SumSquares atom.</h2><span id='topic+SumSquares'></span>

<h3>Description</h3>

<p>The sum of the squares of the entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SumSquares(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SumSquares_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of the squares of the entries in the expression.
</p>

<hr>
<h2 id='SymbolicQuadForm-class'>The SymbolicQuadForm class.</h2><span id='topic+SymbolicQuadForm-class'></span><span id='topic+.SymbolicQuadForm'></span><span id='topic+SymbolicQuadForm'></span><span id='topic+dim_from_args+2CSymbolicQuadForm-method'></span><span id='topic+sign_from_args+2CSymbolicQuadForm-method'></span><span id='topic+get_data+2CSymbolicQuadForm-method'></span><span id='topic+is_atom_convex+2CSymbolicQuadForm-method'></span><span id='topic+is_atom_concave+2CSymbolicQuadForm-method'></span><span id='topic+is_incr+2CSymbolicQuadForm-method'></span><span id='topic+is_decr+2CSymbolicQuadForm-method'></span><span id='topic+is_quadratic+2CSymbolicQuadForm-method'></span><span id='topic+.grad+2CSymbolicQuadForm-method'></span>

<h3>Description</h3>

<p>The SymbolicQuadForm class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SymbolicQuadForm(x, P, expr)

## S4 method for signature 'SymbolicQuadForm'
dim_from_args(object)

## S4 method for signature 'SymbolicQuadForm'
sign_from_args(object)

## S4 method for signature 'SymbolicQuadForm'
get_data(object)

## S4 method for signature 'SymbolicQuadForm'
is_atom_convex(object)

## S4 method for signature 'SymbolicQuadForm'
is_atom_concave(object)

## S4 method for signature 'SymbolicQuadForm'
is_incr(object, idx)

## S4 method for signature 'SymbolicQuadForm'
is_decr(object, idx)

## S4 method for signature 'SymbolicQuadForm'
is_quadratic(object)

## S4 method for signature 'SymbolicQuadForm'
.grad(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SymbolicQuadForm-class_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric vector.</p>
</td></tr>
<tr><td><code id="SymbolicQuadForm-class_+3A_p">P</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, numeric matrix, or vector.</p>
</td></tr>
<tr><td><code id="SymbolicQuadForm-class_+3A_expr">expr</code></td>
<td>
<p>The original <a href="#topic+Expression-class">Expression</a>.</p>
</td></tr>
<tr><td><code id="SymbolicQuadForm-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+SymbolicQuadForm-class">SymbolicQuadForm</a> object.</p>
</td></tr>
<tr><td><code id="SymbolicQuadForm-class_+3A_idx">idx</code></td>
<td>
<p>An index into the atom.</p>
</td></tr>
<tr><td><code id="SymbolicQuadForm-class_+3A_values">values</code></td>
<td>
<p>A list of numeric values for the arguments</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>dim_from_args(SymbolicQuadForm)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>sign_from_args(SymbolicQuadForm)</code>: The sign (is positive, is negative) of the atom.
</p>
</li>
<li> <p><code>get_data(SymbolicQuadForm)</code>: The original expression.
</p>
</li>
<li> <p><code>is_atom_convex(SymbolicQuadForm)</code>: Is the original expression convex?
</p>
</li>
<li> <p><code>is_atom_concave(SymbolicQuadForm)</code>: Is the original expression concave?
</p>
</li>
<li> <p><code>is_incr(SymbolicQuadForm)</code>: Is the original expression weakly increasing in argument <code>idx</code>?
</p>
</li>
<li> <p><code>is_decr(SymbolicQuadForm)</code>: Is the original expression weakly decreasing in argument <code>idx</code>?
</p>
</li>
<li> <p><code>is_quadratic(SymbolicQuadForm)</code>: The atom is quadratic.
</p>
</li>
<li> <p><code>.grad(SymbolicQuadForm)</code>: Gives the (sub/super)gradient of the atom w.r.t. each variable
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric vector.</p>
</dd>
<dt><code>P</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a>, numeric matrix, or vector.</p>
</dd>
<dt><code>original_expression</code></dt><dd><p>The original <a href="#topic+Expression-class">Expression</a>.</p>
</dd>
</dl>

<hr>
<h2 id='t.Expression'>Matrix Transpose</h2><span id='topic+t.Expression'></span><span id='topic+t'></span><span id='topic+t+2CExpression-method'></span>

<h3>Description</h3>

<p>The transpose of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Expression'
t(x)

## S4 method for signature 'Expression'
t(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t.Expression_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the transposed matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(3, 4)
t(x)
</code></pre>

<hr>
<h2 id='to_numeric'>Numeric Value of Atom</h2><span id='topic+to_numeric'></span>

<h3>Description</h3>

<p>Returns the numeric value of the atom evaluated on the specified arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_numeric(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_numeric_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Atom-class">Atom</a> object.</p>
</td></tr>
<tr><td><code id="to_numeric_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar, vector, or matrix.
</p>

<hr>
<h2 id='TotalVariation'>The TotalVariation atom.</h2><span id='topic+TotalVariation'></span>

<h3>Description</h3>

<p>The total variation of a vector, matrix, or list of matrices.
Uses L1 norm of discrete gradients for vectors and L2 norm of discrete gradients for matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TotalVariation(value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TotalVariation_+3A_value">value</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing the value to take the total variation of.</p>
</td></tr>
<tr><td><code id="TotalVariation_+3A_...">...</code></td>
<td>
<p>Additional matrices extending the third dimension of value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An expression representing the total variation.
</p>

<hr>
<h2 id='Trace-class'>The Trace class.</h2><span id='topic+Trace-class'></span><span id='topic+.Trace'></span><span id='topic+Trace'></span><span id='topic+to_numeric+2CTrace-method'></span><span id='topic+validate_args+2CTrace-method'></span><span id='topic+dim_from_args+2CTrace-method'></span><span id='topic+is_atom_log_log_convex+2CTrace-method'></span><span id='topic+is_atom_log_log_concave+2CTrace-method'></span><span id='topic+graph_implementation+2CTrace-method'></span>

<h3>Description</h3>

<p>This class represents the sum of the diagonal entries in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Trace(expr)

## S4 method for signature 'Trace'
to_numeric(object, values)

## S4 method for signature 'Trace'
validate_args(object)

## S4 method for signature 'Trace'
dim_from_args(object)

## S4 method for signature 'Trace'
is_atom_log_log_convex(object)

## S4 method for signature 'Trace'
is_atom_log_log_concave(object)

## S4 method for signature 'Trace'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Trace-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> representing a matrix.</p>
</td></tr>
<tr><td><code id="Trace-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Trace-class">Trace</a> object.</p>
</td></tr>
<tr><td><code id="Trace-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="Trace-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="Trace-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="Trace-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Trace)</code>: Sum the diagonal entries.
</p>
</li>
<li> <p><code>validate_args(Trace)</code>: Check the argument is a square matrix.
</p>
</li>
<li> <p><code>dim_from_args(Trace)</code>: The atom is a scalar.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(Trace)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(Trace)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>graph_implementation(Trace)</code>: The graph implementation of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> representing a matrix.</p>
</dd>
</dl>

<hr>
<h2 id='Transpose-class'>The Transpose class.</h2><span id='topic+Transpose-class'></span><span id='topic+.Transpose'></span><span id='topic+Transpose'></span><span id='topic+to_numeric+2CTranspose-method'></span><span id='topic+is_symmetric+2CTranspose-method'></span><span id='topic+is_hermitian+2CTranspose-method'></span><span id='topic+dim_from_args+2CTranspose-method'></span><span id='topic+is_atom_log_log_convex+2CTranspose-method'></span><span id='topic+is_atom_log_log_concave+2CTranspose-method'></span><span id='topic+get_data+2CTranspose-method'></span><span id='topic+graph_implementation+2CTranspose-method'></span>

<h3>Description</h3>

<p>This class represents the matrix transpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Transpose'
to_numeric(object, values)

## S4 method for signature 'Transpose'
is_symmetric(object)

## S4 method for signature 'Transpose'
is_hermitian(object)

## S4 method for signature 'Transpose'
dim_from_args(object)

## S4 method for signature 'Transpose'
is_atom_log_log_convex(object)

## S4 method for signature 'Transpose'
is_atom_log_log_concave(object)

## S4 method for signature 'Transpose'
get_data(object)

## S4 method for signature 'Transpose'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Transpose-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Transpose-class">Transpose</a> object.</p>
</td></tr>
<tr><td><code id="Transpose-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="Transpose-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="Transpose-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="Transpose-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Transpose)</code>: The transpose of the given value.
</p>
</li>
<li> <p><code>is_symmetric(Transpose)</code>: Is the expression symmetric?
</p>
</li>
<li> <p><code>is_hermitian(Transpose)</code>: Is the expression hermitian?
</p>
</li>
<li> <p><code>dim_from_args(Transpose)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(Transpose)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(Transpose)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>get_data(Transpose)</code>: Returns the axes for transposition.
</p>
</li>
<li> <p><code>graph_implementation(Transpose)</code>: The graph implementation of the atom.
</p>
</li></ul>

<hr>
<h2 id='tri_to_full'>Expands lower triangular to full matrix.</h2><span id='topic+tri_to_full'></span>

<h3>Description</h3>

<p>Expands lower triangular to full matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri_to_full(lower_tri, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri_to_full_+3A_lower_tri">lower_tri</code></td>
<td>
<p>A matrix representing the lower triangular part of the matrix,
stacked in column-major order</p>
</td></tr>
<tr><td><code id="tri_to_full_+3A_n">n</code></td>
<td>
<p>The number of rows (columns) in the full square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that is the scaled expansion of the lower triangular matrix.
</p>

<hr>
<h2 id='tv'>Total Variation</h2><span id='topic+tv'></span><span id='topic+total_variation'></span>

<h3>Description</h3>

<p>The total variation of a vector, matrix, or list of matrices. Uses L1 norm of discrete gradients for vectors and L2 norm of discrete gradients for matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv(value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv_+3A_value">value</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a>, vector, or matrix.</p>
</td></tr>
<tr><td><code id="tv_+3A_...">...</code></td>
<td>
<p>(Optional) <a href="#topic+Expression-class">Expression</a> objects or numeric constants that extend the third dimension of value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the total variation of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rows &lt;- 10
cols &lt;- 10
Uorig &lt;- matrix(sample(0:255, size = rows * cols, replace = TRUE), nrow = rows, ncol = cols)

# Known is 1 if the pixel is known, 0 if the pixel was corrupted
Known &lt;- matrix(0, nrow = rows, ncol = cols)
for(i in 1:rows) {
   for(j in 1:cols) {
      if(stats::runif(1) &gt; 0.7)
         Known[i,j] &lt;- 1
   }
}
Ucorr &lt;- Known %*% Uorig

# Recover the original image using total variation in-painting
U &lt;- Variable(rows, cols)
obj &lt;- Minimize(tv(U))
constraints &lt;- list(Known * U == Known * Ucorr)
prob &lt;- Problem(obj, constraints)
result &lt;- solve(prob, solver = "SCS")
result$getValue(U)
</code></pre>

<hr>
<h2 id='UnaryOperator-class'>The UnaryOperator class.</h2><span id='topic+UnaryOperator-class'></span><span id='topic+UnaryOperator'></span><span id='topic+name+2CUnaryOperator-method'></span><span id='topic+to_numeric+2CUnaryOperator-method'></span>

<h3>Description</h3>

<p>This base class represents expressions involving unary operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'UnaryOperator'
name(x)

## S4 method for signature 'UnaryOperator'
to_numeric(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnaryOperator-class_+3A_x">x</code>, <code id="UnaryOperator-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+UnaryOperator-class">UnaryOperator</a> object.</p>
</td></tr>
<tr><td><code id="UnaryOperator-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(UnaryOperator)</code>: Returns the expression in string form.
</p>
</li>
<li> <p><code>to_numeric(UnaryOperator)</code>: Applies the unary operator to the value.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>The <a href="#topic+Expression-class">Expression</a> that is being operated upon.</p>
</dd>
<dt><code>op_name</code></dt><dd><p>A <code>character</code> string indicating the unary operation.</p>
</dd>
</dl>

<hr>
<h2 id='unpack_results'>Parse output from a solver and updates problem state</h2><span id='topic+unpack_results'></span>

<h3>Description</h3>

<p>Updates problem status, problem value, and primal and dual variable values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_results(object, solution, chain, inverse_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_results_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="unpack_results_+3A_solution">solution</code></td>
<td>
<p>A <a href="#topic+Solution-class">Solution</a> object.</p>
</td></tr>
<tr><td><code id="unpack_results_+3A_chain">chain</code></td>
<td>
<p>The corresponding solving <a href="#topic+Chain-class">Chain</a>.</p>
</td></tr>
<tr><td><code id="unpack_results_+3A_inverse_data">inverse_data</code></td>
<td>
<p>A <a href="#topic+InverseData-class">InverseData</a> object or list containing data necessary for the inversion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the solution to the problem:
</p>

<dl>
<dt><code>status</code></dt><dd><p>The status of the solution. Can be &quot;optimal&quot;, &quot;optimal_inaccurate&quot;, &quot;infeasible&quot;, &quot;infeasible_inaccurate&quot;, &quot;unbounded&quot;, &quot;unbounded_inaccurate&quot;, or &quot;solver_error&quot;.</p>
</dd>
<dt><code>value</code></dt><dd><p>The optimal value of the objective function.</p>
</dd>
<dt><code>solver</code></dt><dd><p>The name of the solver.</p>
</dd>
<dt><code>solve_time</code></dt><dd><p>The time (in seconds) it took for the solver to solve the problem.</p>
</dd>
<dt><code>setup_time</code></dt><dd><p>The time (in seconds) it took for the solver to set up the problem.</p>
</dd>
<dt><code>num_iters</code></dt><dd><p>The number of iterations the solver had to go through to find a solution.</p>
</dd>
<dt><code>getValue</code></dt><dd><p>A function that takes a <a href="#topic+Variable-class">Variable</a> object and retrieves its primal value.</p>
</dd>
<dt><code>getDualValue</code></dt><dd><p>A function that takes a <a href="#topic+Constraint-class">Constraint</a> object and retrieves its dual value(s).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- Variable(2)
obj &lt;- Minimize(x[1] + cvxr_norm(x, 1))
constraints &lt;- list(x &gt;= 2)
prob1 &lt;- Problem(obj, constraints)
# Solve with ECOS.
ecos_data &lt;- get_problem_data(prob1, "ECOS")
# Call ECOS solver interface directly
ecos_output &lt;- ECOSolveR::ECOS_csolve(
                           c = ecos_data[["c"]],
                           G = ecos_data[["G"]],
                           h = ecos_data[["h"]],
                           dims = ecos_data[["dims"]],
                           A = ecos_data[["A"]],
                           b = ecos_data[["b"]]
                         )
# Unpack raw solver output.
res1 &lt;- unpack_results(prob1, "ECOS", ecos_output)
# Without DCP validation (so be sure of your math), above is equivalent to:
# res1 &lt;- solve(prob1, solver = "ECOS")
X &lt;- Variable(2,2, PSD = TRUE)
Fmat &lt;- rbind(c(1,0), c(0,-1))
obj &lt;- Minimize(sum_squares(X - Fmat))
prob2 &lt;- Problem(obj)
scs_data &lt;- get_problem_data(prob2, "SCS")
scs_output &lt;- scs::scs(
                      A = scs_data[['A']],
                      b = scs_data[['b']],
                      obj = scs_data[['c']],
                      cone = scs_data[['dims']]
                  )
res2 &lt;- unpack_results(prob2, "SCS", scs_output)
# Without DCP validation (so be sure of your math), above is equivalent to:
# res2 &lt;- solve(prob2, solver = "SCS")

## End(Not run)
</code></pre>

<hr>
<h2 id='upper_tri'>Upper Triangle of a Matrix</h2><span id='topic+upper_tri'></span>

<h3>Description</h3>

<p>The vectorized strictly upper triangular entries of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upper_tri(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upper_tri_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the upper triangle of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- Variable(3,3)
val &lt;- cbind(3:5, 6:8, 9:11)
prob &lt;- Problem(Maximize(upper_tri(C)[3,1]), list(C == val))
result &lt;- solve(prob)
result$value
result$getValue(upper_tri(C))
</code></pre>

<hr>
<h2 id='UpperTri-class'>The UpperTri class.</h2><span id='topic+UpperTri-class'></span><span id='topic+.UpperTri'></span><span id='topic+UpperTri'></span><span id='topic+to_numeric+2CUpperTri-method'></span><span id='topic+validate_args+2CUpperTri-method'></span><span id='topic+dim_from_args+2CUpperTri-method'></span><span id='topic+is_atom_log_log_convex+2CUpperTri-method'></span><span id='topic+is_atom_log_log_concave+2CUpperTri-method'></span><span id='topic+graph_implementation+2CUpperTri-method'></span>

<h3>Description</h3>

<p>The vectorized strictly upper triagonal entries of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpperTri(expr)

## S4 method for signature 'UpperTri'
to_numeric(object, values)

## S4 method for signature 'UpperTri'
validate_args(object)

## S4 method for signature 'UpperTri'
dim_from_args(object)

## S4 method for signature 'UpperTri'
is_atom_log_log_convex(object)

## S4 method for signature 'UpperTri'
is_atom_log_log_concave(object)

## S4 method for signature 'UpperTri'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UpperTri-class_+3A_expr">expr</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</td></tr>
<tr><td><code id="UpperTri-class_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+UpperTri-class">UpperTri</a> object.</p>
</td></tr>
<tr><td><code id="UpperTri-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="UpperTri-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="UpperTri-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="UpperTri-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(UpperTri)</code>: Vectorize the upper triagonal entries.
</p>
</li>
<li> <p><code>validate_args(UpperTri)</code>: Check the argument is a square matrix.
</p>
</li>
<li> <p><code>dim_from_args(UpperTri)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(UpperTri)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(UpperTri)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>graph_implementation(UpperTri)</code>: The graph implementation of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>expr</code></dt><dd><p>An <a href="#topic+Expression-class">Expression</a> or numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='validate_args'>Validate Arguments</h2><span id='topic+validate_args'></span>

<h3>Description</h3>

<p>Validate an atom's arguments, returning an error if any are invalid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_args(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_args_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+Atom-class">Atom</a> object.</p>
</td></tr>
</table>

<hr>
<h2 id='validate_val'>Validate Value</h2><span id='topic+validate_val'></span>

<h3>Description</h3>

<p>Check that the value satisfies a <a href="#topic+Leaf-class">Leaf</a>'s symbolic attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_val(object, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_val_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Leaf-class">Leaf</a> object.</p>
</td></tr>
<tr><td><code id="validate_val_+3A_val">val</code></td>
<td>
<p>The assigned value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value converted to proper matrix type.
</p>

<hr>
<h2 id='value-methods'>Get or Set Value</h2><span id='topic+value-methods'></span><span id='topic+value'></span><span id='topic+value+3C-'></span>

<h3>Description</h3>

<p>Get or set the value of a variable, parameter, expression, or problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value(object)

value(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="value-methods_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Variable-class">Variable</a>, <a href="#topic+Parameter-class">Parameter</a>, <a href="#topic+Expression-class">Expression</a>, or <a href="#topic+Problem-class">Problem</a> object.</p>
</td></tr>
<tr><td><code id="value-methods_+3A_value">value</code></td>
<td>
<p>A numeric scalar, vector, or matrix to assign to the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric value of the variable, parameter, or expression. If any part of the mathematical object is unknown, return <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- Parameter()
value(lambda)

value(lambda) &lt;- 5
value(lambda)
</code></pre>

<hr>
<h2 id='Variable-class'>The Variable class.</h2><span id='topic+Variable-class'></span><span id='topic+.Variable'></span><span id='topic+Variable'></span><span id='topic+as.character+2CVariable-method'></span><span id='topic+name+2CVariable-method'></span><span id='topic+value+2CVariable-method'></span><span id='topic+grad+2CVariable-method'></span><span id='topic+variables+2CVariable-method'></span><span id='topic+canonicalize+2CVariable-method'></span>

<h3>Description</h3>

<p>This class represents an optimization variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Variable(rows = NULL, cols = NULL, name = NA_character_, ...)

## S4 method for signature 'Variable'
as.character(x)

## S4 method for signature 'Variable'
name(x)

## S4 method for signature 'Variable'
value(object)

## S4 method for signature 'Variable'
grad(object)

## S4 method for signature 'Variable'
variables(object)

## S4 method for signature 'Variable'
canonicalize(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Variable-class_+3A_rows">rows</code></td>
<td>
<p>The number of rows in the variable.</p>
</td></tr>
<tr><td><code id="Variable-class_+3A_cols">cols</code></td>
<td>
<p>The number of columns in the variable.</p>
</td></tr>
<tr><td><code id="Variable-class_+3A_name">name</code></td>
<td>
<p>(Optional) A character string representing the name of the variable.</p>
</td></tr>
<tr><td><code id="Variable-class_+3A_...">...</code></td>
<td>
<p>(Optional) Additional attribute arguments. See <a href="#topic+Leaf-class">Leaf</a> for details.</p>
</td></tr>
<tr><td><code id="Variable-class_+3A_x">x</code>, <code id="Variable-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Variable-class">Variable</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(Variable)</code>: The name of the variable.
</p>
</li>
<li> <p><code>value(Variable)</code>: Get the value of the variable.
</p>
</li>
<li> <p><code>grad(Variable)</code>: The sub/super-gradient of the variable represented as a sparse matrix.
</p>
</li>
<li> <p><code>variables(Variable)</code>: Returns itself as a variable.
</p>
</li>
<li> <p><code>canonicalize(Variable)</code>: The canonical form of the variable.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>dim</code></dt><dd><p>The dimensions of the variable.</p>
</dd>
<dt><code>name</code></dt><dd><p>(Optional) A character string representing the name of the variable.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(3, name = "x0") ## 3-int variable
y &lt;- Variable(3, 3, name = "y0") # Matrix variable
as.character(y)
id(y)
is_nonneg(x)
is_nonpos(x)
size(y)
name(y)
value(y) &lt;- matrix(1:9, nrow = 3)
value(y)
grad(y)
variables(y)
canonicalize(y)
</code></pre>

<hr>
<h2 id='vec'>Vectorization of a Matrix</h2><span id='topic+vec'></span>

<h3>Description</h3>

<p>Flattens a matrix into a vector in column-major order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_+3A_x">X</code></td>
<td>
<p>An <a href="#topic+Expression-class">Expression</a> or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the vectorized matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Variable(2,2)
c &lt;- 1:4
expr &lt;- vec(A)
obj &lt;- Minimize(t(expr) %*% c)
constraints &lt;- list(A == cbind(c(-1,-2), c(3,4)))
prob &lt;- Problem(obj, constraints)
result &lt;- solve(prob)
result$value
result$getValue(expr)
</code></pre>

<hr>
<h2 id='vectorized_lower_tri_to_mat'>Turns symmetric 2D array into a lower triangular matrix</h2><span id='topic+vectorized_lower_tri_to_mat'></span>

<h3>Description</h3>

<p>Turns symmetric 2D array into a lower triangular matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectorized_lower_tri_to_mat(v, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vectorized_lower_tri_to_mat_+3A_v">v</code></td>
<td>
<p>A list of length (dim * (dim + 1) / 2).</p>
</td></tr>
<tr><td><code id="vectorized_lower_tri_to_mat_+3A_dim">dim</code></td>
<td>
<p>The number of rows (equivalently, columns) in the output array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the symmetric 2D array defined by taking &quot;v&quot; to specify its
lower triangular matrix.
</p>

<hr>
<h2 id='vstack'>Vertical Concatenation</h2><span id='topic+vstack'></span>

<h3>Description</h3>

<p>The vertical concatenation of expressions. This is equivalent to <code>rbind</code> when applied to objects with the same number of columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vstack(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vstack_+3A_...">...</code></td>
<td>
<p><a href="#topic+Expression-class">Expression</a> objects, vectors, or matrices. All arguments must have the same number of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Expression-class">Expression</a> representing the concatenated inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Variable(2)
y &lt;- Variable(3)
c &lt;- matrix(1, nrow = 1, ncol = 5)
prob &lt;- Problem(Minimize(c %*% vstack(x, y)), list(x == c(1,2), y == c(3,4,5)))
result &lt;- solve(prob)
result$value

c &lt;- matrix(1, nrow = 1, ncol = 4)
prob &lt;- Problem(Minimize(c %*% vstack(x, x)), list(x == c(1,2)))
result &lt;- solve(prob)
result$value

A &lt;- Variable(2,2)
C &lt;- Variable(3,2)
c &lt;- matrix(1, nrow = 2, ncol = 2)
prob &lt;- Problem(Minimize(sum(vstack(A, C))), list(A &gt;= 2*c, C == -2))
result &lt;- solve(prob)
result$value

B &lt;- Variable(2,2)
c &lt;- matrix(1, nrow = 1, ncol = 2)
prob &lt;- Problem(Minimize(sum(vstack(c %*% A, c %*% B))), list(A &gt;= 2, B == -2))
result &lt;- solve(prob)
result$value
</code></pre>

<hr>
<h2 id='VStack-class'>The VStack class.</h2><span id='topic+VStack-class'></span><span id='topic+.VStack'></span><span id='topic+VStack'></span><span id='topic+to_numeric+2CVStack-method'></span><span id='topic+validate_args+2CVStack-method'></span><span id='topic+dim_from_args+2CVStack-method'></span><span id='topic+is_atom_log_log_convex+2CVStack-method'></span><span id='topic+is_atom_log_log_concave+2CVStack-method'></span><span id='topic+graph_implementation+2CVStack-method'></span>

<h3>Description</h3>

<p>Vertical concatenation of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VStack(...)

## S4 method for signature 'VStack'
to_numeric(object, values)

## S4 method for signature 'VStack'
validate_args(object)

## S4 method for signature 'VStack'
dim_from_args(object)

## S4 method for signature 'VStack'
is_atom_log_log_convex(object)

## S4 method for signature 'VStack'
is_atom_log_log_concave(object)

## S4 method for signature 'VStack'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VStack-class_+3A_...">...</code></td>
<td>
<p><a href="#topic+Expression-class">Expression</a> objects or matrices. All arguments must have the same number of columns.</p>
</td></tr>
<tr><td><code id="VStack-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+VStack-class">VStack</a> object.</p>
</td></tr>
<tr><td><code id="VStack-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="VStack-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="VStack-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="VStack-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(VStack)</code>: Vertically concatenate the values using <code>rbind</code>.
</p>
</li>
<li> <p><code>validate_args(VStack)</code>: Check all arguments have the same width.
</p>
</li>
<li> <p><code>dim_from_args(VStack)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(VStack)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(VStack)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>graph_implementation(VStack)</code>: The graph implementation of the atom.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>...</code></dt><dd><p><a href="#topic+Expression-class">Expression</a> objects or matrices. All arguments must have the same number of columns.</p>
</dd>
</dl>

<hr>
<h2 id='Wrap-class'>The Wrap class.</h2><span id='topic+Wrap-class'></span><span id='topic+Wrap'></span><span id='topic+to_numeric+2CWrap-method'></span><span id='topic+dim_from_args+2CWrap-method'></span><span id='topic+is_atom_log_log_convex+2CWrap-method'></span><span id='topic+is_atom_log_log_concave+2CWrap-method'></span><span id='topic+graph_implementation+2CWrap-method'></span>

<h3>Description</h3>

<p>This virtual class represents a no-op wrapper to assert properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Wrap'
to_numeric(object, values)

## S4 method for signature 'Wrap'
dim_from_args(object)

## S4 method for signature 'Wrap'
is_atom_log_log_convex(object)

## S4 method for signature 'Wrap'
is_atom_log_log_concave(object)

## S4 method for signature 'Wrap'
graph_implementation(object, arg_objs, dim, data = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wrap-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+Wrap-class">Wrap</a> object.</p>
</td></tr>
<tr><td><code id="Wrap-class_+3A_values">values</code></td>
<td>
<p>A list of arguments to the atom.</p>
</td></tr>
<tr><td><code id="Wrap-class_+3A_arg_objs">arg_objs</code></td>
<td>
<p>A list of linear expressions for each argument.</p>
</td></tr>
<tr><td><code id="Wrap-class_+3A_dim">dim</code></td>
<td>
<p>A vector representing the dimensions of the resulting expression.</p>
</td></tr>
<tr><td><code id="Wrap-class_+3A_data">data</code></td>
<td>
<p>A list of additional data required by the atom.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>to_numeric(Wrap)</code>: Returns the input value.
</p>
</li>
<li> <p><code>dim_from_args(Wrap)</code>: The dimensions of the atom.
</p>
</li>
<li> <p><code>is_atom_log_log_convex(Wrap)</code>: Is the atom log-log convex?
</p>
</li>
<li> <p><code>is_atom_log_log_concave(Wrap)</code>: Is the atom log-log concave?
</p>
</li>
<li> <p><code>graph_implementation(Wrap)</code>: The graph implementation of the atom.
</p>
</li></ul>

<hr>
<h2 id='ZeroConstraint-class'>The ZeroConstraint class</h2><span id='topic+ZeroConstraint-class'></span><span id='topic+.ZeroConstraint'></span><span id='topic+name+2CZeroConstraint-method'></span><span id='topic+dim+2CZeroConstraint-method'></span><span id='topic+is_dcp+2CZeroConstraint-method'></span><span id='topic+is_dgp+2CZeroConstraint-method'></span><span id='topic+residual+2CZeroConstraint-method'></span><span id='topic+canonicalize+2CZeroConstraint-method'></span>

<h3>Description</h3>

<p>The ZeroConstraint class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ZeroConstraint'
name(x)

## S4 method for signature 'ZeroConstraint'
dim(x)

## S4 method for signature 'ZeroConstraint'
is_dcp(object)

## S4 method for signature 'ZeroConstraint'
is_dgp(object)

## S4 method for signature 'ZeroConstraint'
residual(object)

## S4 method for signature 'ZeroConstraint'
canonicalize(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZeroConstraint-class_+3A_x">x</code>, <code id="ZeroConstraint-class_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+ZeroConstraint-class">ZeroConstraint</a> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>name(ZeroConstraint)</code>: The string representation of the constraint.
</p>
</li>
<li> <p><code>dim(ZeroConstraint)</code>: The dimensions of the constrained expression.
</p>
</li>
<li> <p><code>is_dcp(ZeroConstraint)</code>: Is the constraint DCP?
</p>
</li>
<li> <p><code>is_dgp(ZeroConstraint)</code>: Is the constraint DGP?
</p>
</li>
<li> <p><code>residual(ZeroConstraint)</code>: The residual of a constraint
</p>
</li>
<li> <p><code>canonicalize(ZeroConstraint)</code>: The graph implementation of the object.
</p>
</li></ul>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
