<!DOCTYPE html><html><head><title>Help for package rvest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rvest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rvest-package'><p>rvest: Easily Harvest (Scrape) Web Pages</p></a></li>
<li><a href='#google_form'><p>Make link to google form given id</p></a></li>
<li><a href='#html_attr'><p>Get element attributes</p></a></li>
<li><a href='#html_children'><p>Get element children</p></a></li>
<li><a href='#html_element'><p>Select elements from an HTML document</p></a></li>
<li><a href='#html_encoding_guess'><p>Guess faulty character encoding</p></a></li>
<li><a href='#html_form'><p>Parse forms and set values</p></a></li>
<li><a href='#html_name'><p>Get element name</p></a></li>
<li><a href='#html_table'><p>Parse an html table into a data frame</p></a></li>
<li><a href='#html_text'><p>Get element text</p></a></li>
<li><a href='#LiveHTML'><p>Interact with a live web page</p></a></li>
<li><a href='#minimal_html'><p>Create an HTML document from inline HTML</p></a></li>
<li><a href='#read_html'><p>Static web scraping (with xml2)</p></a></li>
<li><a href='#read_html_live'><p>Live web scraping (with chromote)</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rename'><p>Functions renamed in rvest 1.0.0</p></a></li>
<li><a href='#repair_encoding'><p>Repair faulty encoding</p></a></li>
<li><a href='#session'><p>Simulate a session in web browser</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Easily Harvest (Scrape) Web Pages</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Wrappers around the 'xml2' and 'httr' packages to make it
    easy to download, then manipulate, HTML and XML.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rvest.tidyverse.org/">https://rvest.tidyverse.org/</a>, <a href="https://github.com/tidyverse/rvest">https://github.com/tidyverse/rvest</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/rvest/issues">https://github.com/tidyverse/rvest/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, glue, httr (&ge; 0.5), lifecycle (&ge; 1.0.3), magrittr,
rlang (&ge; 1.1.0), selectr, tibble, xml2 (&ge; 1.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>chromote, covr, knitr, R6, readr, repurrrsive, rmarkdown,
spelling, stringi (&ge; 0.3.1), testthat (&ge; 3.0.2), webfakes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 17:13:26 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-12 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rvest-package'>rvest: Easily Harvest (Scrape) Web Pages</h2><span id='topic+rvest'></span><span id='topic+rvest-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Wrappers around the 'xml2' and 'httr' packages to make it easy to download, then manipulate, HTML and XML.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://rvest.tidyverse.org/">https://rvest.tidyverse.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/rvest">https://github.com/tidyverse/rvest</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/rvest/issues">https://github.com/tidyverse/rvest/issues</a>
</p>
</li></ul>


<hr>
<h2 id='google_form'>Make link to google form given id</h2><span id='topic+google_form'></span>

<h3>Description</h3>

<p>Make link to google form given id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>google_form(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="google_form_+3A_x">x</code></td>
<td>
<p>Unique identifier for form</p>
</td></tr>
</table>

<hr>
<h2 id='html_attr'>Get element attributes</h2><span id='topic+html_attr'></span><span id='topic+html_attrs'></span>

<h3>Description</h3>

<p><code>html_attr()</code> gets a single attribute; <code>html_attrs()</code> gets all attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_attr(x, name, default = NA_character_)

html_attrs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_attr_+3A_x">x</code></td>
<td>
<p>A document (from <code><a href="#topic+read_html">read_html()</a></code>), node set (from <code><a href="#topic+html_elements">html_elements()</a></code>),
node (from <code><a href="#topic+html_element">html_element()</a></code>), or session (from <code><a href="#topic+session">session()</a></code>).</p>
</td></tr>
<tr><td><code id="html_attr_+3A_name">name</code></td>
<td>
<p>Name of attribute to retrieve.</p>
</td></tr>
<tr><td><code id="html_attr_+3A_default">default</code></td>
<td>
<p>A string used as a default value when the attribute does
not exist in every element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector (for <code>html_attr()</code>) or list (<code>html_attrs()</code>)
the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>html &lt;- minimal_html('&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://a.com" class="important"&gt;a&lt;/a&gt;&lt;/li&gt;
  &lt;li class="active"&gt;&lt;a href="https://c.com"&gt;b&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://c.com"&gt;b&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;')

html %&gt;% html_elements("a") %&gt;% html_attrs()

html %&gt;% html_elements("a") %&gt;% html_attr("href")
html %&gt;% html_elements("li") %&gt;% html_attr("class")
html %&gt;% html_elements("li") %&gt;% html_attr("class", default = "inactive")
</code></pre>

<hr>
<h2 id='html_children'>Get element children</h2><span id='topic+html_children'></span>

<h3>Description</h3>

<p>Get element children
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_children(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_children_+3A_x">x</code></td>
<td>
<p>A document (from <code><a href="#topic+read_html">read_html()</a></code>), node set (from <code><a href="#topic+html_elements">html_elements()</a></code>),
node (from <code><a href="#topic+html_element">html_element()</a></code>), or session (from <code><a href="#topic+session">session()</a></code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>html &lt;- minimal_html("&lt;ul&gt;&lt;li&gt;1&lt;li&gt;2&lt;li&gt;3&lt;/ul&gt;")
ul &lt;- html_elements(html, "ul")
html_children(ul)

html &lt;- minimal_html("&lt;p&gt;Hello &lt;b&gt;Hadley&lt;/b&gt;&lt;i&gt;!&lt;/i&gt;")
p &lt;- html_elements(html, "p")
html_children(p)
</code></pre>

<hr>
<h2 id='html_element'>Select elements from an HTML document</h2><span id='topic+html_element'></span><span id='topic+html_elements'></span>

<h3>Description</h3>

<p><code>html_element()</code> and <code>html_elements()</code> find HTML element using CSS selectors
or XPath expressions. CSS selectors are particularly useful in conjunction
with <a href="https://selectorgadget.com/">https://selectorgadget.com/</a>, which makes it very easy to discover the
selector you need.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_element(x, css, xpath)

html_elements(x, css, xpath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_element_+3A_x">x</code></td>
<td>
<p>Either a document, a node set or a single node.</p>
</td></tr>
<tr><td><code id="html_element_+3A_css">css</code>, <code id="html_element_+3A_xpath">xpath</code></td>
<td>
<p>Elements to select. Supply one of <code>css</code> or <code>xpath</code>
depending on whether you want to use a CSS selector or XPath 1.0
expression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>html_element()</code> returns a nodeset the same length as the input.
<code>html_elements()</code> flattens the output so there's no direct way to map
the output to the input.
</p>


<h3>CSS selector support</h3>

<p>CSS selectors are translated to XPath selectors by the <span class="pkg">selectr</span>
package, which is a port of the python <span class="pkg">cssselect</span> library,
<a href="https://pythonhosted.org/cssselect/">https://pythonhosted.org/cssselect/</a>.
</p>
<p>It implements the majority of CSS3 selectors, as described in
<a href="https://www.w3.org/TR/2011/REC-css3-selectors-20110929/">https://www.w3.org/TR/2011/REC-css3-selectors-20110929/</a>. The
exceptions are listed below:
</p>

<ul>
<li><p> Pseudo selectors that require interactivity are ignored:
<code style="white-space: pre;">&#8288;:hover&#8288;</code>, <code style="white-space: pre;">&#8288;:active&#8288;</code>, <code style="white-space: pre;">&#8288;:focus&#8288;</code>, <code style="white-space: pre;">&#8288;:target&#8288;</code>, <code style="white-space: pre;">&#8288;:visited&#8288;</code>.
</p>
</li>
<li><p> The following pseudo classes don't work with the wild card element, *:
<code style="white-space: pre;">&#8288;*:first-of-type&#8288;</code>, <code style="white-space: pre;">&#8288;*:last-of-type&#8288;</code>, <code style="white-space: pre;">&#8288;*:nth-of-type&#8288;</code>,
<code style="white-space: pre;">&#8288;*:nth-last-of-type&#8288;</code>, <code style="white-space: pre;">&#8288;*:only-of-type&#8288;</code>
</p>
</li>
<li><p> It supports <code style="white-space: pre;">&#8288;:contains(text)&#8288;</code>
</p>
</li>
<li><p> You can use !=, <code style="white-space: pre;">&#8288;[foo!=bar]&#8288;</code> is the same as <code style="white-space: pre;">&#8288;:not([foo=bar])&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;:not()&#8288;</code> accepts a sequence of simple selectors, not just a single
simple selector.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>html &lt;- minimal_html("
  &lt;h1&gt;This is a heading&lt;/h1&gt;
  &lt;p id='first'&gt;This is a paragraph&lt;/p&gt;
  &lt;p class='important'&gt;This is an important paragraph&lt;/p&gt;
")

html %&gt;% html_element("h1")
html %&gt;% html_elements("p")
html %&gt;% html_elements(".important")
html %&gt;% html_elements("#first")

# html_element() vs html_elements() --------------------------------------
html &lt;- minimal_html("
  &lt;ul&gt;
    &lt;li&gt;&lt;b&gt;C-3PO&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class='weight'&gt;167 kg&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;b&gt;R2-D2&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt; that weighs &lt;span class='weight'&gt;96 kg&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;b&gt;Yoda&lt;/b&gt; weighs &lt;span class='weight'&gt;66 kg&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;b&gt;R4-P17&lt;/b&gt; is a &lt;i&gt;droid&lt;/i&gt;&lt;/li&gt;
  &lt;/ul&gt;
")
li &lt;- html %&gt;% html_elements("li")

# When applied to a node set, html_elements() returns all matching elements
# beneath any of the inputs, flattening results into a new node set.
li %&gt;% html_elements("i")

# When applied to a node set, html_element() always returns a vector the
# same length as the input, using a "missing" element where needed.
li %&gt;% html_element("i")
# and html_text() and html_attr() will return NA
li %&gt;% html_element("i") %&gt;% html_text2()
li %&gt;% html_element("span") %&gt;% html_attr("class")
</code></pre>

<hr>
<h2 id='html_encoding_guess'>Guess faulty character encoding</h2><span id='topic+html_encoding_guess'></span><span id='topic+guess_encoding'></span>

<h3>Description</h3>

<p><code>html_encoding_guess()</code> helps you handle web pages that declare an incorrect
encoding. Use <code>html_encoding_guess()</code> to generate a list of possible
encodings, then try each out by using <code>encoding</code> argument of <code>read_html()</code>.
<code>html_encoding_guess()</code> replaces the deprecated <code>guess_encoding()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_encoding_guess(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_encoding_guess_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># A file with bad encoding included in the package
path &lt;- system.file("html-ex", "bad-encoding.html", package = "rvest")
x &lt;- read_html(path)
x %&gt;% html_elements("p") %&gt;% html_text()

html_encoding_guess(x)
# Two valid encodings, only one of which is correct
read_html(path, encoding = "ISO-8859-1") %&gt;% html_elements("p") %&gt;% html_text()
read_html(path, encoding = "ISO-8859-2") %&gt;% html_elements("p") %&gt;% html_text()
</code></pre>

<hr>
<h2 id='html_form'>Parse forms and set values</h2><span id='topic+html_form'></span><span id='topic+html_form_set'></span><span id='topic+html_form_submit'></span>

<h3>Description</h3>

<p>Use <code>html_form()</code> to extract a form, set values with <code>html_form_set()</code>,
and submit it with <code>html_form_submit()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_form(x, base_url = NULL)

html_form_set(form, ...)

html_form_submit(form, submit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_form_+3A_x">x</code></td>
<td>
<p>A document (from <code><a href="#topic+read_html">read_html()</a></code>), node set (from <code><a href="#topic+html_elements">html_elements()</a></code>),
node (from <code><a href="#topic+html_element">html_element()</a></code>), or session (from <code><a href="#topic+session">session()</a></code>).</p>
</td></tr>
<tr><td><code id="html_form_+3A_base_url">base_url</code></td>
<td>
<p>Base url of underlying HTML document. The default, <code>NULL</code>,
uses the url of the HTML document underlying <code>x</code>.</p>
</td></tr>
<tr><td><code id="html_form_+3A_form">form</code></td>
<td>
<p>A form</p>
</td></tr>
<tr><td><code id="html_form_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Name-value pairs giving
fields to modify.
</p>
<p>Provide a character vector to set multiple checkboxes in a set or
select multiple values from a multi-select.</p>
</td></tr>
<tr><td><code id="html_form_+3A_submit">submit</code></td>
<td>
<p>Which button should be used to submit the form?
</p>

<ul>
<li> <p><code>NULL</code>, the default, uses the first button.
</p>
</li>
<li><p> A string selects a button by its name.
</p>
</li>
<li><p> A number selects a button using its relative position.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>html_form()</code> returns as S3 object with class <code>rvest_form</code> when applied
to a single element. It returns a list of <code>rvest_form</code> objects when
applied to multiple elements or a document.
</p>
</li>
<li> <p><code>html_form_set()</code> returns an <code>rvest_form</code> object.
</p>
</li>
<li> <p><code>html_form_submit()</code> submits the form, returning an httr response which
can be parsed with <code><a href="#topic+read_html">read_html()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>HTML 4.01 form specification:
<a href="https://www.w3.org/TR/html401/interact/forms.html">https://www.w3.org/TR/html401/interact/forms.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>html &lt;- read_html("http://www.google.com")
search &lt;- html_form(html)[[1]]

search &lt;- search %&gt;% html_form_set(q = "My little pony", hl = "fr")

# Or if you have a list of values, use !!!
vals &lt;- list(q = "web scraping", hl = "en")
search &lt;- search %&gt;% html_form_set(!!!vals)

# To submit and get result:
## Not run: 
resp &lt;- html_form_submit(search)
read_html(resp)

## End(Not run)
</code></pre>

<hr>
<h2 id='html_name'>Get element name</h2><span id='topic+html_name'></span>

<h3>Description</h3>

<p>Get element name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_name(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_name_+3A_x">x</code></td>
<td>
<p>A document (from <code><a href="#topic+read_html">read_html()</a></code>), node set (from <code><a href="#topic+html_elements">html_elements()</a></code>),
node (from <code><a href="#topic+html_element">html_element()</a></code>), or session (from <code><a href="#topic+session">session()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>url &lt;- "https://rvest.tidyverse.org/articles/starwars.html"
html &lt;- read_html(url)

html %&gt;%
  html_element("div") %&gt;%
  html_children() %&gt;%
  html_name()
</code></pre>

<hr>
<h2 id='html_table'>Parse an html table into a data frame</h2><span id='topic+html_table'></span>

<h3>Description</h3>

<p>The algorithm mimics what a browser does, but repeats the values of merged
cells in every cell that cover.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_table(
  x,
  header = NA,
  trim = TRUE,
  fill = deprecated(),
  dec = ".",
  na.strings = "NA",
  convert = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_table_+3A_x">x</code></td>
<td>
<p>A document (from <code><a href="#topic+read_html">read_html()</a></code>), node set (from <code><a href="#topic+html_elements">html_elements()</a></code>),
node (from <code><a href="#topic+html_element">html_element()</a></code>), or session (from <code><a href="#topic+session">session()</a></code>).</p>
</td></tr>
<tr><td><code id="html_table_+3A_header">header</code></td>
<td>
<p>Use first row as header? If <code>NA</code>, will use first row
if it consists of <code style="white-space: pre;">&#8288;&lt;th&gt;&#8288;</code> tags.
</p>
<p>If <code>TRUE</code>, column names are left exactly as they are in the source
document, which may require post-processing to generate a valid data
frame.</p>
</td></tr>
<tr><td><code id="html_table_+3A_trim">trim</code></td>
<td>
<p>Remove leading and trailing whitespace within each cell?</p>
</td></tr>
<tr><td><code id="html_table_+3A_fill">fill</code></td>
<td>
<p>Deprecated - missing cells in tables are now always
automatically filled with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="html_table_+3A_dec">dec</code></td>
<td>
<p>The character used as decimal place marker.</p>
</td></tr>
<tr><td><code id="html_table_+3A_na.strings">na.strings</code></td>
<td>
<p>Character vector of values that will be converted to <code>NA</code>
if <code>convert</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="html_table_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, will run <code><a href="utils.html#topic+type.convert">type.convert()</a></code> to interpret texts as
integer, double, or <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When applied to a single element, <code>html_table()</code> returns a single tibble.
When applied to multiple elements or a document, <code>html_table()</code> returns
a list of tibbles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample1 &lt;- minimal_html("&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;Col A&lt;/th&gt;&lt;th&gt;Col B&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;x&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;y&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;z&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;")
sample1 %&gt;%
  html_element("table") %&gt;%
  html_table()

# Values in merged cells will be duplicated
sample2 &lt;- minimal_html("&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;A&lt;/th&gt;&lt;th&gt;B&lt;/th&gt;&lt;th&gt;C&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td colspan='2'&gt;4&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td colspan='2'&gt;7&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;")
sample2 %&gt;%
  html_element("table") %&gt;%
  html_table()

# If a row is missing cells, they'll be filled with NAs
sample3 &lt;- minimal_html("&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;A&lt;/th&gt;&lt;th&gt;B&lt;/th&gt;&lt;th&gt;C&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td colspan='2'&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td colspan='2'&gt;3&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;")
sample3 %&gt;%
  html_element("table") %&gt;%
  html_table()
</code></pre>

<hr>
<h2 id='html_text'>Get element text</h2><span id='topic+html_text'></span><span id='topic+html_text2'></span>

<h3>Description</h3>

<p>There are two ways to retrieve text from a element: <code>html_text()</code> and
<code>html_text2()</code>. <code>html_text()</code> is a thin wrapper around <code><a href="xml2.html#topic+xml_text">xml2::xml_text()</a></code>
which returns just the raw underlying text. <code>html_text2()</code> simulates how
text looks in a browser, using an approach inspired by JavaScript's
<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText">innerText()</a>.
Roughly speaking, it converts <code style="white-space: pre;">&#8288;&lt;br /&gt;&#8288;</code> to <code>"\n"</code>, adds blank lines
around <code style="white-space: pre;">&#8288;&lt;p&gt;&#8288;</code> tags, and lightly formats tabular data.
</p>
<p><code>html_text2()</code> is usually what you want, but it is much slower than
<code>html_text()</code> so for simple applications where performance is important
you may want to use <code>html_text()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_text(x, trim = FALSE)

html_text2(x, preserve_nbsp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_text_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
<tr><td><code id="html_text_+3A_trim">trim</code></td>
<td>
<p>If <code>TRUE</code> will trim leading and trailing spaces.</p>
</td></tr>
<tr><td><code id="html_text_+3A_preserve_nbsp">preserve_nbsp</code></td>
<td>
<p>Should non-breaking spaces be preserved? By default,
<code>html_text2()</code> converts to ordinary spaces to ease further computation.
When <code>preserve_nbsp</code> is <code>TRUE</code>, <code style="white-space: pre;">&#8288;&amp;nbsp;&#8288;</code> will appear in strings as
<code>"\ua0"</code>. This often causes confusion because it prints the same way as
<code>" "</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To understand the difference between html_text() and html_text2()
# take the following html:

html &lt;- minimal_html(
  "&lt;p&gt;This is a paragraph.
    This another sentence.&lt;br&gt;This should start on a new line"
)

# html_text() returns the raw underlying text, which includes whitespace
# that would be ignored by a browser, and ignores the &lt;br&gt;
html %&gt;% html_element("p") %&gt;% html_text() %&gt;% writeLines()

# html_text2() simulates what a browser would display. Non-significant
# whitespace is collapsed, and &lt;br&gt; is turned into a line break
html %&gt;% html_element("p") %&gt;% html_text2() %&gt;% writeLines()

# By default, html_text2() also converts non-breaking spaces to regular
# spaces:
html &lt;- minimal_html("&lt;p&gt;x&amp;nbsp;y&lt;/p&gt;")
x1 &lt;- html %&gt;% html_element("p") %&gt;% html_text()
x2 &lt;- html %&gt;% html_element("p") %&gt;% html_text2()

# When printed, non-breaking spaces look exactly like regular spaces
x1
x2
# But aren't actually the same:
x1 == x2
# Which you can confirm by looking at their underlying binary
# representaion:
charToRaw(x1)
charToRaw(x2)
</code></pre>

<hr>
<h2 id='LiveHTML'>Interact with a live web page</h2><span id='topic+LiveHTML'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>You construct an LiveHTML object with <code><a href="#topic+read_html_live">read_html_live()</a></code> and then interact,
like you're a human, using the methods described below. When debugging a
scraping script it is particularly useful to use <code style="white-space: pre;">&#8288;$view()&#8288;</code>, which will open
a live preview of the site, and you can actually see each of the operations
performed on the real site.
</p>
<p>rvest provides relatively simple methods for scrolling, typing, and
clicking. For richer interaction, you probably want to use a package
that exposes a more powerful user interface, like
<a href="https://ashbythorpe.github.io/selenider/">selendir</a>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>session</code></dt><dd><p>Underlying chromote session object. For expert use only.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LiveHTML-new"><code>LiveHTML$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LiveHTML-print"><code>LiveHTML$print()</code></a>
</p>
</li>
<li> <p><a href="#method-LiveHTML-view"><code>LiveHTML$view()</code></a>
</p>
</li>
<li> <p><a href="#method-LiveHTML-html_elements"><code>LiveHTML$html_elements()</code></a>
</p>
</li>
<li> <p><a href="#method-LiveHTML-click"><code>LiveHTML$click()</code></a>
</p>
</li>
<li> <p><a href="#method-LiveHTML-get_scroll_position"><code>LiveHTML$get_scroll_position()</code></a>
</p>
</li>
<li> <p><a href="#method-LiveHTML-scroll_into_view"><code>LiveHTML$scroll_into_view()</code></a>
</p>
</li>
<li> <p><a href="#method-LiveHTML-scroll_to"><code>LiveHTML$scroll_to()</code></a>
</p>
</li>
<li> <p><a href="#method-LiveHTML-scroll_by"><code>LiveHTML$scroll_by()</code></a>
</p>
</li>
<li> <p><a href="#method-LiveHTML-type"><code>LiveHTML$type()</code></a>
</p>
</li>
<li> <p><a href="#method-LiveHTML-press"><code>LiveHTML$press()</code></a>
</p>
</li>
<li> <p><a href="#method-LiveHTML-clone"><code>LiveHTML$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-LiveHTML-new"></a>



<h4>Method <code>new()</code></h4>

<p>initialize the object
</p>


<h5>Usage</h5>

<div class="r"><pre>LiveHTML$new(url)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>URL to page.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LiveHTML-print"></a>



<h4>Method <code>print()</code></h4>

<p>Called when <code>print()</code>ed
</p>


<h5>Usage</h5>

<div class="r"><pre>LiveHTML$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LiveHTML-view"></a>



<h4>Method <code>view()</code></h4>

<p>Display a live view of the site
</p>


<h5>Usage</h5>

<div class="r"><pre>LiveHTML$view()</pre></div>


<hr>
<a id="method-LiveHTML-html_elements"></a>



<h4>Method <code>html_elements()</code></h4>

<p>Extract HTML elements from the current page.
</p>


<h5>Usage</h5>

<div class="r"><pre>LiveHTML$html_elements(css, xpath)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>css, xpath</code></dt><dd><p>CSS selector or xpath expression.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LiveHTML-click"></a>



<h4>Method <code>click()</code></h4>

<p>Simulate a click on an HTML element.
</p>


<h5>Usage</h5>

<div class="r"><pre>LiveHTML$click(css, n_clicks = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>css</code></dt><dd><p>CSS selector or xpath expression.</p>
</dd>
<dt><code>n_clicks</code></dt><dd><p>Number of clicks</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LiveHTML-get_scroll_position"></a>



<h4>Method <code>get_scroll_position()</code></h4>

<p>Get the current scroll position.
</p>


<h5>Usage</h5>

<div class="r"><pre>LiveHTML$get_scroll_position()</pre></div>


<hr>
<a id="method-LiveHTML-scroll_into_view"></a>



<h4>Method <code>scroll_into_view()</code></h4>

<p>Scroll selected element into view.
</p>


<h5>Usage</h5>

<div class="r"><pre>LiveHTML$scroll_into_view(css)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>css</code></dt><dd><p>CSS selector or xpath expression.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LiveHTML-scroll_to"></a>



<h4>Method <code>scroll_to()</code></h4>

<p>Scroll to specified location
</p>


<h5>Usage</h5>

<div class="r"><pre>LiveHTML$scroll_to(top = 0, left = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>top, left</code></dt><dd><p>Number of pixels from top/left respectively.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LiveHTML-scroll_by"></a>



<h4>Method <code>scroll_by()</code></h4>

<p>Scroll by the specified amount
</p>


<h5>Usage</h5>

<div class="r"><pre>LiveHTML$scroll_by(top = 0, left = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>top, left</code></dt><dd><p>Number of pixels to scroll up/down and left/right
respectively.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LiveHTML-type"></a>



<h4>Method <code>type()</code></h4>

<p>Type text in the selected element
</p>


<h5>Usage</h5>

<div class="r"><pre>LiveHTML$type(css, text)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>css</code></dt><dd><p>CSS selector or xpath expression.</p>
</dd>
<dt><code>text</code></dt><dd><p>A single string containing the text to type.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LiveHTML-press"></a>



<h4>Method <code>press()</code></h4>

<p>Simulate pressing a single key (including special keys).
</p>


<h5>Usage</h5>

<div class="r"><pre>LiveHTML$press(css, key_code, modifiers = character())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>css</code></dt><dd><p>CSS selector or xpath expression. Set to <code>NULL</code></p>
</dd>
<dt><code>key_code</code></dt><dd><p>Name of key. You can see a complete list of known
keys at <a href="https://pptr.dev/api/puppeteer.keyinput/">https://pptr.dev/api/puppeteer.keyinput/</a>.</p>
</dd>
<dt><code>modifiers</code></dt><dd><p>A character vector of modifiers. Must be one or more
of <code style="white-space: pre;">&#8288;"Shift&#8288;</code>, <code>"Control"</code>, <code>"Alt"</code>, or <code>"Meta"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LiveHTML-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LiveHTML$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To retrieve data for this paginated site, we need to repeatedly push
# the "Load More" button
sess &lt;- read_html_live("https://www.bodybuilding.com/exercises/finder")
sess$view()

sess %&gt;% html_elements(".ExResult-row") %&gt;% length()
sess$click(".ExLoadMore-btn")
sess %&gt;% html_elements(".ExResult-row") %&gt;% length()
sess$click(".ExLoadMore-btn")
sess %&gt;% html_elements(".ExResult-row") %&gt;% length()

## End(Not run)
</code></pre>

<hr>
<h2 id='minimal_html'>Create an HTML document from inline HTML</h2><span id='topic+minimal_html'></span>

<h3>Description</h3>

<p>Create an HTML document from inline HTML
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimal_html(html, title = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimal_html_+3A_html">html</code></td>
<td>
<p>HTML contents of page.</p>
</td></tr>
<tr><td><code id="minimal_html_+3A_title">title</code></td>
<td>
<p>Page title (required by HTML spec).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>minimal_html("&lt;p&gt;test&lt;/p&gt;")
</code></pre>

<hr>
<h2 id='read_html'>Static web scraping (with xml2)</h2><span id='topic+read_html'></span>

<h3>Description</h3>

<p><code><a href="#topic+read_html">read_html()</a></code> works by performing a HTTP request then parsing the HTML
received using the xml2 package. This is &quot;static&quot; scraping because it
operates only on the raw HTML file. While this works for most sites,
in some cases you will need to use <code><a href="#topic+read_html_live">read_html_live()</a></code> if the parts of
the page you want to scrape are dynamically generated with javascript.
</p>
<p>Generally, we recommend using <code>read_html()</code> if it works, as it will be
faster and more robust, as it has fewer external dependencies (i.e. it
doesn't rely on the Chrome web browser installed on your computer.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_html(x, encoding = "", ..., options = c("RECOVER", "NOERROR", "NOBLANKS"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_html_+3A_x">x</code></td>
<td>
<p>Usually a string representing a URL. See <code><a href="xml2.html#topic+read_xml">xml2::read_html()</a></code> for
other options.</p>
</td></tr>
<tr><td><code id="read_html_+3A_encoding">encoding</code></td>
<td>
<p>Specify a default encoding for the document. Unless
otherwise specified XML documents are assumed to be in UTF-8 or
UTF-16. If the document is not UTF-8/16, and lacks an explicit
encoding directive, this allows you to supply a default.</p>
</td></tr>
<tr><td><code id="read_html_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="read_html_+3A_options">options</code></td>
<td>
<p>Set parsing options for the libxml2 parser. Zero or more of
</p>

<dl>
<dt>RECOVER</dt><dd><p>recover on errors</p>
</dd>
<dt>NOENT</dt><dd><p>substitute entities</p>
</dd>
<dt>DTDLOAD</dt><dd><p>load the external subset</p>
</dd>
<dt>DTDATTR</dt><dd><p>default DTD attributes</p>
</dd>
<dt>DTDVALID</dt><dd><p>validate with the DTD</p>
</dd>
<dt>NOERROR</dt><dd><p>suppress error reports</p>
</dd>
<dt>NOWARNING</dt><dd><p>suppress warning reports</p>
</dd>
<dt>PEDANTIC</dt><dd><p>pedantic error reporting</p>
</dd>
<dt>NOBLANKS</dt><dd><p>remove blank nodes</p>
</dd>
<dt>SAX1</dt><dd><p>use the SAX1 interface internally</p>
</dd>
<dt>XINCLUDE</dt><dd><p>Implement XInclude substitition</p>
</dd>
<dt>NONET</dt><dd><p>Forbid network access</p>
</dd>
<dt>NODICT</dt><dd><p>Do not reuse the context dictionary</p>
</dd>
<dt>NSCLEAN</dt><dd><p>remove redundant namespaces declarations</p>
</dd>
<dt>NOCDATA</dt><dd><p>merge CDATA as text nodes</p>
</dd>
<dt>NOXINCNODE</dt><dd><p>do not generate XINCLUDE START/END nodes</p>
</dd>
<dt>COMPACT</dt><dd><p>compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)</p>
</dd>
<dt>OLD10</dt><dd><p>parse using XML-1.0 before update 5</p>
</dd>
<dt>NOBASEFIX</dt><dd><p>do not fixup XINCLUDE xml:base uris</p>
</dd>
<dt>HUGE</dt><dd><p>relax any hardcoded limit from the parser</p>
</dd>
<dt>OLDSAX</dt><dd><p>parse using SAX2 interface before 2.7.0</p>
</dd>
<dt>IGNORE_ENC</dt><dd><p>ignore internal document encoding hint</p>
</dd>
<dt>BIG_LINES</dt><dd><p>Store big lines numbers in text PSVI field</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Start by reading a HTML page with read_html():
starwars &lt;- read_html("https://rvest.tidyverse.org/articles/starwars.html")

# Then find elements that match a css selector or XPath expression
# using html_elements(). In this example, each &lt;section&gt; corresponds
# to a different film
films &lt;- starwars %&gt;% html_elements("section")
films

# Then use html_element() to extract one element per film. Here
# we the title is given by the text inside &lt;h2&gt;
title &lt;- films %&gt;%
  html_element("h2") %&gt;%
  html_text2()
title

# Or use html_attr() to get data out of attributes. html_attr() always
# returns a string so we convert it to an integer using a readr function
episode &lt;- films %&gt;%
  html_element("h2") %&gt;%
  html_attr("data-id") %&gt;%
  readr::parse_integer()
episode
</code></pre>

<hr>
<h2 id='read_html_live'>Live web scraping (with chromote)</h2><span id='topic+read_html_live'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code><a href="#topic+read_html">read_html()</a></code> operates on the HTML source code downloaded from the server.
This works for most websites but can fail if the site uses javascript to
generate the HTML. <code>read_html_live()</code> provides an alternative interface
that runs a live web browser (Chrome) in the background. This allows you to
access elements of the HTML page that are generated dynamically by javascript
and to interact with the live page by clicking on buttons or typing in
forms.
</p>
<p>Behind the scenes, this function uses the
<a href="https://rstudio.github.io/chromote/">chromote</a> package, which requires that
you have a copy of <a href="https://www.google.com/chrome/">Google Chrome</a> installed
on your machine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_html_live(url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_html_live_+3A_url">url</code></td>
<td>
<p>Website url to read from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read_html_live()</code> returns an R6 <a href="#topic+LiveHTML">LiveHTML</a> object. You can interact
with this object using the usual rvest functions, or call its methods,
like <code style="white-space: pre;">&#8288;$click()&#8288;</code>, <code style="white-space: pre;">&#8288;$scroll_to()&#8288;</code>, and <code style="white-space: pre;">&#8288;$type()&#8288;</code> to interact with the live
page like a human would.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# When we retrieve the raw HTML for this site, it doesn't contain the
# data we're interested in:
static &lt;- read_html("https://www.forbes.com/top-colleges/")
static %&gt;% html_elements(".TopColleges2023_tableRow__BYOSU")

# Instead, we need to run the site in a real web browser, causing it to
# download a JSON file and then dynamically generate the html:

sess &lt;- read_html_live("https://www.forbes.com/top-colleges/")
sess$view()
rows &lt;- sess %&gt;% html_elements(".TopColleges2023_tableRow__BYOSU")
rows %&gt;% html_element(".TopColleges2023_organizationName__J1lEV") %&gt;% html_text()
rows %&gt;% html_element(".grant-aid") %&gt;% html_text()

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+url_absolute'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>xml2</dt><dd><p><code><a href="xml2.html#topic+url_absolute">url_absolute</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rename'>Functions renamed in rvest 1.0.0</h2><span id='topic+set_values'></span><span id='topic+submit_form'></span><span id='topic+xml_tag'></span><span id='topic+xml_node'></span><span id='topic+xml_nodes'></span><span id='topic+html_nodes'></span><span id='topic+html_node'></span><span id='topic+back'></span><span id='topic+forward'></span><span id='topic+jump_to'></span><span id='topic+follow_link'></span><span id='topic+html_session'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>rvest 1.0.0 renamed a number of functions to ensure that every function
has a common prefix, matching tidyverse conventions that emerged since
rvest was first created.
</p>

<ul>
<li> <p><code>set_values()</code> -&gt; <code>html_form_set()</code>
</p>
</li>
<li> <p><code>submit_form()</code> -&gt; <code>session_submit()</code>
</p>
</li>
<li> <p><code>xml_tag()</code> -&gt; <code>html_name()</code>
</p>
</li>
<li> <p><code>xml_node()</code> &amp; <code>html_node()</code> -&gt; <code>html_element()</code>
</p>
</li>
<li> <p><code>xml_nodes()</code> &amp; <code>html_nodes()</code> -&gt; <code>html_elements()</code>
</p>
</li></ul>

<p>(<code>html_node()</code> and <code>html_nodes()</code> are only superseded because they're
so widely used.)
</p>
<p>Additionally all session related functions gained a common prefix:
</p>

<ul>
<li> <p><code>html_session()</code> -&gt; <code>session()</code>
</p>
</li>
<li> <p><code>forward()</code> -&gt; <code>session_forward()</code>
</p>
</li>
<li> <p><code>back()</code> -&gt; <code>session_back()</code>
</p>
</li>
<li> <p><code>jump_to()</code> -&gt; <code>session_jump_to()</code>
</p>
</li>
<li> <p><code>follow_link()</code> -&gt; <code>session_follow_link()</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>set_values(form, ...)

submit_form(session, form, submit = NULL, ...)

xml_tag(x)

xml_node(...)

xml_nodes(...)

html_nodes(...)

html_node(...)

back(x)

forward(x)

jump_to(x, url, ...)

follow_link(x, ...)

html_session(url, ...)
</code></pre>

<hr>
<h2 id='repair_encoding'>Repair faulty encoding</h2><span id='topic+repair_encoding'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function has been deprecated because it doesn't work. Instead
re-read the HTML file with correct <code>encoding</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repair_encoding(x, from = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repair_encoding_+3A_from">from</code></td>
<td>
<p>The encoding that the string is actually in. If <code>NULL</code>,
<code>guess_encoding</code> will be used.</p>
</td></tr>
</table>

<hr>
<h2 id='session'>Simulate a session in web browser</h2><span id='topic+session'></span><span id='topic+is.session'></span><span id='topic+session_jump_to'></span><span id='topic+session_follow_link'></span><span id='topic+session_back'></span><span id='topic+session_forward'></span><span id='topic+session_history'></span><span id='topic+session_submit'></span>

<h3>Description</h3>

<p>This set of functions allows you to simulate a user interacting with a
website, using forms and navigating from page to page.
</p>

<ul>
<li><p> Create a session with <code>session(url)</code>
</p>
</li>
<li><p> Navigate to a specified url with <code>session_jump_to()</code>, or follow a link on the
page with <code>session_follow_link()</code>.
</p>
</li>
<li><p> Submit an <a href="#topic+html_form">html_form</a> with <code>session_submit()</code>.
</p>
</li>
<li><p> View the history with <code>session_history()</code> and navigate back and forward
with <code>session_back()</code> and <code>session_forward()</code>.
</p>
</li>
<li><p> Extract page contents with <code><a href="#topic+html_element">html_element()</a></code> and <code><a href="#topic+html_elements">html_elements()</a></code>, or get the
complete HTML document with <code><a href="#topic+read_html">read_html()</a></code>.
</p>
</li>
<li><p> Inspect the HTTP response with <code><a href="httr.html#topic+cookies">httr::cookies()</a></code>, <code><a href="httr.html#topic+headers">httr::headers()</a></code>,
and <code><a href="httr.html#topic+status_code">httr::status_code()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>session(url, ...)

is.session(x)

session_jump_to(x, url, ...)

session_follow_link(x, i, css, xpath, ...)

session_back(x)

session_forward(x)

session_history(x)

session_submit(x, form, submit = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="session_+3A_url">url</code></td>
<td>
<p>A URL, either relative or absolute, to navigate to.</p>
</td></tr>
<tr><td><code id="session_+3A_...">...</code></td>
<td>
<p>Any additional httr config to use throughout the session.</p>
</td></tr>
<tr><td><code id="session_+3A_x">x</code></td>
<td>
<p>A session.</p>
</td></tr>
<tr><td><code id="session_+3A_i">i</code></td>
<td>
<p>A integer to select the ith link or a string to match the
first link containing that text (case sensitive).</p>
</td></tr>
<tr><td><code id="session_+3A_css">css</code>, <code id="session_+3A_xpath">xpath</code></td>
<td>
<p>Elements to select. Supply one of <code>css</code> or <code>xpath</code>
depending on whether you want to use a CSS selector or XPath 1.0
expression.</p>
</td></tr>
<tr><td><code id="session_+3A_form">form</code></td>
<td>
<p>An <a href="#topic+html_form">html_form</a> to submit</p>
</td></tr>
<tr><td><code id="session_+3A_submit">submit</code></td>
<td>
<p>Which button should be used to submit the form?
</p>

<ul>
<li> <p><code>NULL</code>, the default, uses the first button.
</p>
</li>
<li><p> A string selects a button by its name.
</p>
</li>
<li><p> A number selects a button using its relative position.
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- session("http://hadley.nz")
s %&gt;%
  session_jump_to("hadley-wickham.jpg") %&gt;%
  session_jump_to("/") %&gt;%
  session_history()

s %&gt;%
  session_jump_to("hadley-wickham.jpg") %&gt;%
  session_back() %&gt;%
  session_history()


s %&gt;%
  session_follow_link(css = "p a") %&gt;%
  html_elements("p")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
