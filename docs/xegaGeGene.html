<!DOCTYPE html><html lang="en"><head><title>Help for package xegaGeGene</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xegaGeGene}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ChoiceVector'><p>Choice vector of a grammar.</p></a></li>
<li><a href='#CodonChoiceBiases'><p>Biases in Rule Choice.</p></a></li>
<li><a href='#CodonChoiceBiasesDeprecated'><p>Biases in Rule Choice (Deprecated)</p></a></li>
<li><a href='#CodonPrecision'><p>Compute codon precision with the choice bias of rules below a threshold.</p></a></li>
<li><a href='#CodonPrecisionWithThreshold'><p>Precision of a codon which has a choice bias below a probability threshold.</p></a></li>
<li><a href='#lFxegaGeGene'><p>The local function list lFxegaGeGene.</p></a></li>
<li><a href='#MinCodonPrecision'><p>Minimal precision of codon.</p></a></li>
<li><a href='#mLCMG'><p>Compute the mLCM of the vector of the number of production rules</p>
in a production table.</a></li>
<li><a href='#mLCMGCodonPrecision'><p>mLCMG precision of codon.</p></a></li>
<li><a href='#tLCM'><p>Computes the largest least common multiple of all prime factors</p>
of the integers in the interval <code>1:m</code> for k-bit integers.</a></li>
<li><a href='#xegaGeDecodeGene'><p>Decode a gene for a context free grammar.</p></a></li>
<li><a href='#xegaGeGene'><p>Package xegaGeGene.</p></a></li>
<li><a href='#xegaGeGeneMapFactory'><p>Configure the gene map function of a genetic algorithm for grammar evolution.</p></a></li>
<li><a href='#xegaGeGeneMapmLCM'><p>Map the bit strings of a binary gene to integer parameters in the interval</p>
<code>1</code> to <code>numbers::mLCM(x) &lt; 2^k</code>.</a></li>
<li><a href='#xegaGeGeneMapMod'><p>Map the bit strings of a binary gene to parameters in the interval</p>
<code>1:2^k</code>.</a></li>
<li><a href='#xegaGeInitGene'><p>Initialize a binary gene</p></a></li>
<li><a href='#xegaGePrecisionFactory'><p>Configure the function for computing the codon precision for grammar evolution.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Grammatical Evolution</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Grammatical evolution  (see O'Neil, M. and 
        Ryan, C.  (2003,ISBN:1-4020-7444-1)) uses decoders to 
        convert linear (binary or integer genes) into programs.  
        In addition, automatic determination of codon precision 
        with a limited rule choice bias is provided.
        For a recent survey of grammatical evolution, 
        see Ryan, C., O'Neill, M., and Collins, J. J. (2018)
        &lt;<a href="https://doi.org/10.1007%2F978-3-319-78717-6">doi:10.1007/978-3-319-78717-6</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://github.com/ageyerschulz/xegaGeGene&amp;gt;">https://github.com/ageyerschulz/xegaGeGene&gt;</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>numbers, xegaSelectGene, xegaBNF, xegaDerivationTrees</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-16 15:59:35 UTC; dj2333</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Geyer-Schulz
    <a href="https://orcid.org/0009-0000-5237-3579"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Geyer-Schulz &lt;Andreas.Geyer-Schulz@kit.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-17 21:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ChoiceVector'>Choice vector of a grammar.</h2><span id='topic+ChoiceVector'></span>

<h3>Description</h3>

<p>Choice vector of a grammar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChoiceVector(LHS)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ChoiceVector_+3A_lhs">LHS</code></td>
<td>
<p>Vector of Integers. 
The left-hand side <code>G$LHS</code> of a grammar object <code>G</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of the number of choices for non-terminal symbols.
</p>


<h3>See Also</h3>

<p>Other Utility: 
<code><a href="#topic+mLCMG">mLCMG</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NT&lt;-sample(5, 50, replace=TRUE)
ChoiceVector(NT)
</code></pre>

<hr>
<h2 id='CodonChoiceBiases'>Biases in Rule Choice.</h2><span id='topic+CodonChoiceBiases'></span>

<h3>Description</h3>

<p>Measures the biases in rule choice for each non-terminal.
Statistics computed:
</p>

<ul>
<li><p> dP: Difference in probability  
between random choice with equal 
probability and modulo rule with a codon 
<code>precision</code>.
</p>
</li>
<li><p> dH: Difference in entropy  
between random choice with equal 
probability and modulo rule with a codon 
<code>precision</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>CodonChoiceBiases(cv, precision)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CodonChoiceBiases_+3A_cv">cv</code></td>
<td>
<p>Choice vector of grammar.</p>
</td></tr>
<tr><td><code id="CodonChoiceBiases_+3A_precision">precision</code></td>
<td>
<p>Number of bits of codon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the following columns
</p>

<ul>
<li> <p><code>$precision</code>: Number of bits.
</p>
</li>
<li> <p><code>$cv</code>:   i-th element of choice vector.
</p>
</li>
<li> <p><code>$dp</code>:   Deviation from choice with equal probability for <code>$precision</code>.
</p>
</li>
<li> <p><code>$dH</code>:   Entropy difference between choice with equal probability 
and biased choice for <code>$precision</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Diagnostics: 
<code><a href="#topic+CodonChoiceBiasesDeprecated">CodonChoiceBiasesDeprecated</a>()</code>,
<code><a href="#topic+CodonPrecision">CodonPrecision</a>()</code>,
<code><a href="#topic+tLCM">tLCM</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> CodonChoiceBiases(c(1, 2, 3, 5), 3)
 CodonChoiceBiases(c(1, 2, 3, 5), 5)
</code></pre>

<hr>
<h2 id='CodonChoiceBiasesDeprecated'>Biases in Rule Choice (Deprecated)</h2><span id='topic+CodonChoiceBiasesDeprecated'></span>

<h3>Description</h3>

<p>See <code>CodonChoiceBiases</code>. 
The use of the outer product leads to memory problems for 
<code>precision&gt;31</code> and becomes slow for <code>precision&gt;24</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CodonChoiceBiasesDeprecated(cv, precision)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CodonChoiceBiasesDeprecated_+3A_cv">cv</code></td>
<td>
<p>Choice vector of grammar.</p>
</td></tr>
<tr><td><code id="CodonChoiceBiasesDeprecated_+3A_precision">precision</code></td>
<td>
<p>Number of bits of codon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the following columns
</p>

<ul>
<li> <p><code>$precision</code>: Number of bits.
</p>
</li>
<li> <p><code>$cv</code>:   i-th element of choice vector.
</p>
</li>
<li> <p><code>$dp</code>:   Deviation from choice with equal probability for <code>$precision</code>.
</p>
</li>
<li> <p><code>$dH</code>:   Entropy difference between choice with equal probability 
and biased choice for <code>$precision</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Diagnostics: 
<code><a href="#topic+CodonChoiceBiases">CodonChoiceBiases</a>()</code>,
<code><a href="#topic+CodonPrecision">CodonPrecision</a>()</code>,
<code><a href="#topic+tLCM">tLCM</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> CodonChoiceBiasesDeprecated(c(1, 2, 3, 5), 3)
 CodonChoiceBiasesDeprecated(c(1, 2, 3, 5), 5)
</code></pre>

<hr>
<h2 id='CodonPrecision'>Compute codon precision with the choice bias of rules below a threshold.</h2><span id='topic+CodonPrecision'></span>

<h3>Description</h3>

<p>For automatic determination of the least codon precision for grammar evolution 
with an upper threshold on the choice bias of for the substitution of all
non-terminal symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CodonPrecision(cv, pCrit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CodonPrecision_+3A_cv">cv</code></td>
<td>
<p>Choice vector of a context-free grammar.</p>
</td></tr>
<tr><td><code id="CodonPrecision_+3A_pcrit">pCrit</code></td>
<td>
<p>Threhold for choice bias.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Precision of codon.
</p>


<h3>See Also</h3>

<p>Other Diagnostics: 
<code><a href="#topic+CodonChoiceBiasesDeprecated">CodonChoiceBiasesDeprecated</a>()</code>,
<code><a href="#topic+CodonChoiceBiases">CodonChoiceBiases</a>()</code>,
<code><a href="#topic+tLCM">tLCM</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> CodonPrecision(c(1, 2, 3, 5), 0.1)
 CodonPrecision(c(1, 2, 3, 5), 0.01)

</code></pre>

<hr>
<h2 id='CodonPrecisionWithThreshold'>Precision of a codon which has a choice bias below a probability threshold.</h2><span id='topic+CodonPrecisionWithThreshold'></span>

<h3>Description</h3>

<p>The choice bias is the sum of the absolute values of the 
difference between a k equally probable choices and the 
probability distribution of the modulo choice rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CodonPrecisionWithThreshold(LHS, pCrit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CodonPrecisionWithThreshold_+3A_lhs">LHS</code></td>
<td>
<p>The left-hand side of a grammar object <code>G</code>.</p>
</td></tr>
<tr><td><code id="CodonPrecisionWithThreshold_+3A_pcrit">pCrit</code></td>
<td>
<p>Threshold for the choice bias for single non-terminal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision of a codon which guarantees that the choice bias 
for all nonterminals is below a probability threshold of
<code>PCrit</code>.
</p>


<h3>See Also</h3>

<p>Other Precision: 
<code><a href="#topic+MinCodonPrecision">MinCodonPrecision</a>()</code>,
<code><a href="#topic+mLCMGCodonPrecision">mLCMGCodonPrecision</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NT&lt;-sample(5, 50, replace=TRUE)
CodonPrecisionWithThreshold(NT, 0.1)
CodonPrecisionWithThreshold(NT, 0.01)
</code></pre>

<hr>
<h2 id='lFxegaGeGene'>The local function list lFxegaGeGene.</h2><span id='topic+lFxegaGeGene'></span>

<h3>Description</h3>

<p>The local function list lFxegaGeGene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lFxegaGeGene
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 23.
</p>

<hr>
<h2 id='MinCodonPrecision'>Minimal precision of codon.</h2><span id='topic+MinCodonPrecision'></span>

<h3>Description</h3>

<p>The minimal precision of the codon needed for generating a working 
decoder for a context-free grammar <code>G</code>. However, the decoder 
has some choice bias which reduces the efficiency of grammar evolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinCodonPrecision(LHS, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MinCodonPrecision_+3A_lhs">LHS</code></td>
<td>
<p>Vector of Integers. The left-hand side of a grammar object <code>G</code>.</p>
</td></tr>
<tr><td><code id="MinCodonPrecision_+3A_...">...</code></td>
<td>
<p>Unused. Needed for common abstract interface of 
precision functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer.  The Precision of a codon whose upper bound is the least power of 2 
above the maximum number of rules for a non-terminal of a grammar.
</p>


<h3>See Also</h3>

<p>Other Precision: 
<code><a href="#topic+CodonPrecisionWithThreshold">CodonPrecisionWithThreshold</a>()</code>,
<code><a href="#topic+mLCMGCodonPrecision">mLCMGCodonPrecision</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NT&lt;-sample(5, 50, replace=TRUE)
MinCodonPrecision(NT)
</code></pre>

<hr>
<h2 id='mLCMG'>Compute the mLCM of the vector of the number of production rules
in a production table.</h2><span id='topic+mLCMG'></span>

<h3>Description</h3>

<p>Compute the least common multiple of the prime factors 
of the vector of the number of rules applicable for each 
non-terminal symbol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mLCMG(LHS)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mLCMG_+3A_lhs">LHS</code></td>
<td>
<p>Vector of integers. The left-hand side of a grammar object <code>G</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For removing the bias of the modulo rule in 
grammatical evolution, see Keijzer, M., O'Neill, M., 
Ryan, C. and Cattolico, M. (2002). 
This version works for integer genes coded in the 
domain <code>1:mlCM</code> without bias in choosing a rule.
See Keijzer et al. (2002).
However, if the mLCM and <code>2^k</code> are relative prime, it is impossible 
to find an unbiased binary coding.
The choice bias is considerable lower than for <code>MinCodonPrecision()</code>.
</p>


<h3>Value</h3>

<p>Integer. The least common multiple of the vector of the available 
rules for each non-terminal.
</p>


<h3>References</h3>

<p>Keijzer, M., O'Neill, M., Ryan, C. and Cattolico, M. (2002)
Grammatical Evolution Rules: The Mod and the Bucket Rule,
pp. 123-130. 
In: Foster, J. A., Lutton, E., Miller, J., Ryan, C. and 
Tettamanzi, A. (Eds.): Genetic Programming.
Lecture Notes in Computer Science, Vol.2278, 
Springer, Heidelberg. 
&lt;doi:10.1007/3-540-45984-7_12&gt;
</p>


<h3>See Also</h3>

<p>Other Utility: 
<code><a href="#topic+ChoiceVector">ChoiceVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xegaBNF)
g&lt;-compileBNF(booleanGrammar())
mLCMG(g$PT$LHS)
</code></pre>

<hr>
<h2 id='mLCMGCodonPrecision'>mLCMG precision of codon.</h2><span id='topic+mLCMGCodonPrecision'></span>

<h3>Description</h3>

<p>mLCMG precision of codon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mLCMGCodonPrecision(LHS, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mLCMGCodonPrecision_+3A_lhs">LHS</code></td>
<td>
<p>Vector of Integers. The left-hand side of a grammar object <code>G</code>.</p>
</td></tr>
<tr><td><code id="mLCMGCodonPrecision_+3A_...">...</code></td>
<td>
<p>Unused. Needed for common abstract interface of 
precision functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer. The precision of a codon whose upper bound is larger than 
least common multiple of the prime factors of the 
vector of the available rules 
for each non-terminal of a grammar.
</p>


<h3>See Also</h3>

<p>Other Precision: 
<code><a href="#topic+CodonPrecisionWithThreshold">CodonPrecisionWithThreshold</a>()</code>,
<code><a href="#topic+MinCodonPrecision">MinCodonPrecision</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NT&lt;-sample(5, 50, replace=TRUE)
mLCMGCodonPrecision(NT)
</code></pre>

<hr>
<h2 id='tLCM'>Computes the largest least common multiple of all prime factors 
of the integers in the interval <code>1:m</code> for k-bit integers.</h2><span id='topic+tLCM'></span>

<h3>Description</h3>

<p>For 64 bit numbers, numerically stable up to <code>m==42</code>.
The modulo rule in grammatical evolution assigns to the choices 
of substitutions for a non-terminal slightly (biased) probabilities.
For an integer coding, the least common multiple of all rule choices 
from no choice (1) to the maximal number of substitutions of a non-terminal
removes this bias completely. However, whenever the prime factors of the 
least common multiple contain a prime different from <code>2</code>, 
the bias cannot be removed completely for a binary gene coding. 
However, each additional bit used for coding approximately halves the bias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tLCM(k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tLCM_+3A_k">k</code></td>
<td>
<p>Number of bits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This could be done with the help of 
the function mLCM of the R-package <code>numbers</code>. 
We implement this by enumerating the vector of prime factors  
in <code>1:42</code>.
</p>


<h3>Value</h3>

<p>A list of three elements:
</p>

<ul>
<li> <p><code>$k</code>: The number of bits.
</p>
</li>
<li> <p><code>$m</code>: Maximal number of substitutions for a non-terminal symbol
in a grammar. 
</p>
</li>
<li> <p><code>$mLCM</code>: Least common multiple of the prime factors of
all rule choices from 1 to <code>$m</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Diagnostics: 
<code><a href="#topic+CodonChoiceBiasesDeprecated">CodonChoiceBiasesDeprecated</a>()</code>,
<code><a href="#topic+CodonChoiceBiases">CodonChoiceBiases</a>()</code>,
<code><a href="#topic+CodonPrecision">CodonPrecision</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  tLCM(8)
  tLCM(16)
  tLCM(32)
</code></pre>

<hr>
<h2 id='xegaGeDecodeGene'>Decode a gene for a context free grammar.</h2><span id='topic+xegaGeDecodeGene'></span>

<h3>Description</h3>

<p><code>xegaGeDecodeGene()</code> decodes a binary gene with 
a context-free grammar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGeDecodeGene(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xegaGeDecodeGene_+3A_gene">gene</code></td>
<td>
<p>Binary gene.</p>
</td></tr>
<tr><td><code id="xegaGeDecodeGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The codons (k-bit sequences) of the binary gene are determining
the choices of non-terminal symbols of a depth-first left-to-right
tree traversal. Decoding works in 2 steps:
</p>

<ol>
<li><p> From the binary gene and a grammar a potentially 
incomplete derivation tree is built.
</p>
</li>
<li><p> The leaves of the derivation tree are extracted.
</p>
</li></ol>

<p>It is not guaranteed that a complete derivation trees is returned.
</p>


<h3>Value</h3>

<p>Decoded gene.
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+xegaGeGeneMapMod">xegaGeGeneMapMod</a>()</code>,
<code><a href="#topic+xegaGeGeneMapmLCM">xegaGeGeneMapmLCM</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lFxegaGeGene$GeneMap&lt;-xegaGeGeneMapFactory("Mod")
gene&lt;-xegaGeInitGene(lFxegaGeGene)
xegaGeDecodeGene(gene, lFxegaGeGene)

</code></pre>

<hr>
<h2 id='xegaGeGene'>Package xegaGeGene.</h2><span id='topic+xegaGeGene'></span>

<h3>Description</h3>

<p>The <code>xegaGeGene</code> package 
provides functions implementing
grammatical evolution with binary coded genes:
</p>


<h3>Details</h3>


<ul>
<li><p> Gene initialization.
</p>
</li>
<li><p> Gene maps for the mod and (approximately) for the bucket rule.
</p>
</li>
<li><p> Grammar-based decoders for binary coded genes.
</p>
</li>
<li><p> Analysis of the interaction of  codon precision 
with the rule choice bias for a given grammar.
</p>
</li>
<li><p> Automatic determination of codon precision 
with a limited rule choice bias.
</p>
</li></ul>



<h3>Gene Initialization</h3>

<p>The number of bits of a gene are specified by <code>lF$BitsOnGene()</code>.
</p>
<p>The number of bits of a codon are specified 
by <code>lF$CodonPrecision()</code>.
</p>


<h3>Binary Gene Representation</h3>

<p>A binary gene is a named list:
</p>

<ul>
<li><p> $gene1      the gene must be a binary vector.
</p>
</li>
<li><p> $fit        the fitness value of the gene
(for EvalGeneDet and EvalGeneU) or
the mean fitness (for stochastic functions
evaluated with EvalGeneStoch).
</p>
</li>
<li><p> $evaluated  has the gene been evaluated?
</p>
</li>
<li><p> $evalFail   has the evaluation of the gene failed?
</p>
</li>
<li><p> $var        the cumulative variance of the fitness 
of all evaluations of a gene.
(For stochastic functions)
</p>
</li>
<li><p> $sigma      the standard deviation of the fitness of 
all evaluations of a gene.
(For stochastic functions)
</p>
</li>
<li><p> $obs        the number evaluations of a gene.
(For stochastic functions)
</p>
</li></ul>



<h3>Abstract Interface of Problem Environment</h3>

<p>A problem environment <code>penv</code> must provide:
</p>

<ul>
<li> <p><code>$f(parameters, gene, lF)</code>: 
Function with a real parameter vector as first argument 
which returns a gene 
with evaluated fitness.
</p>
</li>
<li><p> $genelength(): The number of bits of the binary coded
real parameter vector. Used in <code>InitGene</code>.
</p>
</li>
<li><p> $bitlength(): A vector specifying the number of bits 
used for coding each real parameter.
If <code>penv$bitlength()[1]</code> is <code>20</code>, 
then <code>parameters[1]</code> is coded by 20 bits.
Used in <code>GeneMap</code>.
</p>
</li>
<li><p> $lb(): The lower bound vector of each parameter.
Used in <code>GeneMap</code>.
</p>
</li>
<li><p> $ub(): The upper bound vector of each parameter.
Used in <code>GeneMap</code>.
</p>
</li></ul>



<h3>The Architecture of the xegaX-Packages</h3>

<p>The xegaX-packages are a family of R-packages which implement 
eXtended Evolutionary and Genetic Algorithms (xega).  
The architecture has 3 layers, 
namely the user interface layer,
the population layer, and the gene layer: 
</p>

<ul>
<li>
<p>The user interface layer (package <code>xega</code>) 
provides a function call interface and configuration support
for several algorithms: genetic algorithms (sga), 
permutation-based genetic algorithms (sgPerm), 
derivation free algorithms as e.g. differential evolution (sgde), 
grammar-based genetic programming (sgp) and grammatical evolution
(sge). 
</p>
</li>
<li>
<p>The population layer (package <code>xegaPopulation</code>) contains
population related functionality as well as support for 
population statistics dependent adaptive mechanisms and parallelization.
</p>
</li>
<li> 
<p>The gene layer is split in a representation independent and 
a representation dependent part:
</p>

<ol>
<li> 
<p>The representation indendent part (package <code>xegaSelectGene</code>)
is responsible for variants of selection operators, evaluation 
strategies for genes, as well as profiling and timing capabilities.        
</p>
</li>
<li> 
<p>The representation dependent part consists of the following packages: 
</p>

<ul>
<li> <p><code>xegaGaGene</code> for binary coded genetic algorithms.
</p>
</li>
<li> <p><code>xegaPermGene</code> for permutation-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaDfGene</code> for derivation free algorithms as e.g. 
differential evolution.
</p>
</li>
<li> <p><code>xegaGpGene</code> for grammar-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaGeGene</code> for grammatical evolution algorithms.
</p>
</li></ul>

<p>The packages <code>xegaDerivationTrees</code> and <code>xegaBNF</code> support
the last two packages:
<code>xegaBNF</code> essentially provides a grammar compiler and 
<code>xegaDerivationTrees</code> an abstract data type for derivation trees.
</p>
</li></ol>
</li></ul>



<h3>Copyright</h3>

<p>(c) 2024 Andreas Geyer-Schulz
</p>


<h3>License</h3>

<p>MIT
</p>


<h3>URL</h3>

<p>https://github.com/ageyerschulz/xegaGeGene
</p>


<h3>Installation</h3>

<p>From CRAN by <code>install.packages('xegaGeGene')</code>
</p>


<h3>Author(s)</h3>

<p>Andreas Geyer-Schulz
</p>


<h3>References</h3>

<p>Ryan, Conor and Collins, J. J. AND Neill, Michael O. (1998)
Grammatical evolution: Evolving programs for an arbitrary language.
In: 	Banzhaf, Wolfgang and Poli, Riccardo, Schoenauer, Marc and 
Fogarty, Terence C. (1998):
Genetic Programming. First European Workshop, EuroGP' 98 
Paris, France, April 14-15, 1998 Proceedings,
Lecture Notes in Computer Science, 1391, Springer, Heidelberg.
&lt;doi:10.1007/BFb0055930&gt;
</p>
<p>O'Neil, Michael AND Ryan, Conor (2003)
Grammatical Evolution: 
Evolutionary Automatic Programming in an Arbitrary Language.
Kluwer, Dordrecht.
&lt;ISBN:1-4020-7444-1&gt;
</p>
<p>Ryan, Conor and O'Neill, Michael and Collins, J. J. (2018)
Handbook of Grammatical Evolution.
Springer International Publishing, Cham.
&lt;doi:10.1007/978-3-319-78717-6&gt;
</p>

<hr>
<h2 id='xegaGeGeneMapFactory'>Configure the gene map function of a genetic algorithm for grammar evolution.</h2><span id='topic+xegaGeGeneMapFactory'></span>

<h3>Description</h3>

<p><code>xegaGeGeneMapFactory()</code> implements the selection
of one of the GeneMap functions in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error), if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;Mod&quot; returns <code>GeneMapMod()</code>. (Default).
</p>
</li>
<li><p> &quot;Bucket&quot; returns <code>GeneMapmLCM()</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaGeGeneMapFactory(method = "Mod")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xegaGeGeneMapFactory_+3A_method">method</code></td>
<td>
<p>String specifying the GeneMap function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gene map function for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+xegaGePrecisionFactory">xegaGePrecisionFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XGene&lt;-xegaGeGeneMapFactory("Mod")
gene&lt;-xegaGeInitGene(lFxegaGeGene)
XGene(gene$gene1, lFxegaGeGene)
</code></pre>

<hr>
<h2 id='xegaGeGeneMapmLCM'>Map the bit strings of a binary gene to integer parameters in the interval
<code>1</code> to <code>numbers::mLCM(x) &lt; 2^k</code>.</h2><span id='topic+xegaGeGeneMapmLCM'></span>

<h3>Description</h3>

<p><code>xegaGeGeneMapmLCM()</code> 
maps the bit strings of a binary string 
to integers in the interval <code>1</code> to 
<code>lF$CodonPrecision()</code>. 
Bit vectors are mapped into equispaced numbers in the interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGeGeneMapmLCM(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xegaGeGeneMapmLCM_+3A_gene">gene</code></td>
<td>
<p>Binary gene (the genotype).</p>
</td></tr>
<tr><td><code id="xegaGeGeneMapmLCM_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the interval of <code>1</code> to <code>numbers::mLCM(1:m)</code>
provides a the least common multiple of all prime factors 
of the numbers in the interval <code>1:m</code>.
This corresponds to the bucket rule of Keijzer et al. (2002).
For 16-bit precision, the highest number of rules
for the same non-terminal symbols is 12.
For 8-bit precision,this reduces to 6.
With 64-bit integer arithmetic, the bucket rule works up to 
42 rules starting with the same non-terminal.
</p>


<h3>Value</h3>

<p>Integer vector.
</p>


<h3>References</h3>

<p>Keijzer, M., O'Neill, M., Ryan, C. and Cattolico, M. (2002)
Grammatical Evolution Rules: The Mod and the Bucket Rule,
pp. 123-130. 
In: Foster, J. A., Lutton, E., Miller, J., Ryan, C. and 
Tettamanzi, A. (Eds.): Genetic Programming.
Lecture Notes in Computer Science, Vol.2278, 
Springer, Heidelberg. 
&lt;doi:10.1007/3-540-45984-7_12&gt;
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+xegaGeDecodeGene">xegaGeDecodeGene</a>()</code>,
<code><a href="#topic+xegaGeGeneMapMod">xegaGeGeneMapMod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene&lt;-xegaGeInitGene(lFxegaGeGene)
xegaGeGeneMapmLCM(gene$gene1, lFxegaGeGene)

</code></pre>

<hr>
<h2 id='xegaGeGeneMapMod'>Map the bit strings of a binary gene to parameters in the interval
<code>1:2^k</code>.</h2><span id='topic+xegaGeGeneMapMod'></span>

<h3>Description</h3>

<p><code>xegaGeGeneMapMod()</code> maps the bit strings of a binary string 
to integers in the interval <code>1</code> to 
<code>lF$CodonPrecision()</code>. 
Bit vectors are mapped into equispaced numbers in the interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGeGeneMapMod(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xegaGeGeneMapMod_+3A_gene">gene</code></td>
<td>
<p>Binary gene (the genotype).</p>
</td></tr>
<tr><td><code id="xegaGeGeneMapMod_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The modulo rule of grammatical evolution produces (slightly)
biased choices of rules with this mapping. The bias goes to 
zero as <code>lF$CodonPrecision()</code> <code>&gt;&gt;</code> number of rules 
to choose from.
</p>


<h3>Value</h3>

<p>Integer vector.
</p>


<h3>References</h3>

<p>Keijzer, M., O'Neill, M., Ryan, C. and Cattolico, M. (2002)
Grammatical Evolution Rules: The Mod and the Bucket Rule,
pp. 123-130. 
In: Foster, J. A., Lutton, E., Miller, J., Ryan, C. and 
Tettamanzi, A. (Eds.): Genetic Programming.
Lecture Notes in Computer Science, Vol.2278, 
Springer, Heidelberg. 
&lt;doi:10.1007/3-540-45984-7_12&gt;
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+xegaGeDecodeGene">xegaGeDecodeGene</a>()</code>,
<code><a href="#topic+xegaGeGeneMapmLCM">xegaGeGeneMapmLCM</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene&lt;-xegaGeInitGene(lFxegaGeGene)
xegaGeGeneMapMod(gene$gene1, lFxegaGeGene)

</code></pre>

<hr>
<h2 id='xegaGeInitGene'>Initialize a binary gene</h2><span id='topic+xegaGeInitGene'></span>

<h3>Description</h3>

<p><code>xegaGeInitGene()</code> generates a random binary gene 
with a given length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGeInitGene(lF)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xegaGeInitGene_+3A_lf">lF</code></td>
<td>
<p>the local configuration of the genetic algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the binary representation of 
package <code>xega</code>, <em>gene</em> is a list with 
</p>

<ol>
<li> <p><code>$evaluated</code> Boolean: TRUE if the fitness is known.
</p>
</li>
<li> <p><code>$fit</code>       The fitness of the genotype of 
<code>$gene1</code>         
</p>
</li>
<li> <p><code>$gene1</code>     a bit string (the genetopye).
</p>
</li></ol>

<p>This representation makes several code optimizations
and generalizations easier.
</p>


<h3>Value</h3>

<p>a binary gene (a named list):
</p>

<ul>
<li> <p><code>$evaluated</code>: FALSE. See package <code>xegaEvalGene</code>
</p>
</li>
<li> <p><code>$evalFail</code>:  FALSE. Set by the error handler(s)
in package <code>xegaEvalGene</code> 
in the case of failure.
</p>
</li>
<li> <p><code>$fit</code>:       Fitness vector.
</p>
</li>
<li> <p><code>$gene1</code>:     Binary gene.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>xegaGeInitGene(lFxegaGeGene)

</code></pre>

<hr>
<h2 id='xegaGePrecisionFactory'>Configure the function for computing the codon precision for grammar evolution.</h2><span id='topic+xegaGePrecisionFactory'></span>

<h3>Description</h3>

<p><code>xegaGePrecisionFactory()</code> implements the selection
of one of the functions for computing the codon precision in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error), if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;Min&quot; returns <code>MinCodonPrecision</code>.
Shortest coding, but some choice bias.
</p>
</li>
<li><p> &quot;LCM&quot; returns <code>mLCMGCodonPrecision</code>. (Default)
</p>
</li>
<li><p> &quot;MaxPBias&quot; returns <code>CodonPrecisionWithThreshold</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaGePrecisionFactory(method = "LCM")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xegaGePrecisionFactory_+3A_method">method</code></td>
<td>
<p>String specifying the GeneMap function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Precision of codon function.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+xegaGeGeneMapFactory">xegaGeGeneMapFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CodonPrecision&lt;-xegaGePrecisionFactory("Min")
NT&lt;-sample(5, 50, replace=TRUE)
CodonPrecision(NT)
CodonPrecision&lt;-xegaGePrecisionFactory("MaxPBias")
CodonPrecision(NT, 0.1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
