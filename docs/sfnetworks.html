<!DOCTYPE html><html lang="en"><head><title>Help for package sfnetworks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sfnetworks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sfnetworks-package'><p>sfnetworks: Tidy Geospatial Networks</p></a></li>
<li><a href='#as_sfnetwork'><p>Convert a foreign object to a sfnetwork</p></a></li>
<li><a href='#as_tibble'><p>Extract the active element of a sfnetwork as spatial tibble</p></a></li>
<li><a href='#as.linnet'><p>Convert a sfnetwork into a linnet</p></a></li>
<li><a href='#autoplot'><p>Plot sfnetwork geometries with ggplot2</p></a></li>
<li><a href='#is.sfnetwork'><p>Check if an object is a sfnetwork</p></a></li>
<li><a href='#node_coordinates'><p>Query node coordinates</p></a></li>
<li><a href='#plot.sfnetwork'><p>Plot sfnetwork geometries</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#roxel'><p>Road network of Münster Roxel</p></a></li>
<li><a href='#s2'><p>s2 methods for sfnetworks</p></a></li>
<li><a href='#sf'><p>sf methods for sfnetworks</p></a></li>
<li><a href='#sf_attr'><p>Query sf attributes from the active element of a sfnetwork</p></a></li>
<li><a href='#sfnetwork'><p>Create a sfnetwork</p></a></li>
<li><a href='#spatial_edge_measures'><p>Query spatial edge measures</p></a></li>
<li><a href='#spatial_edge_predicates'><p>Query edges with spatial predicates</p></a></li>
<li><a href='#spatial_morphers'><p>Spatial morphers for sfnetworks</p></a></li>
<li><a href='#spatial_node_predicates'><p>Query nodes with spatial predicates</p></a></li>
<li><a href='#st_network_bbox'><p>Get the bounding box of a spatial network</p></a></li>
<li><a href='#st_network_blend'><p>Blend geospatial points into a spatial network</p></a></li>
<li><a href='#st_network_cost'><p>Compute a cost matrix of a spatial network</p></a></li>
<li><a href='#st_network_join'><p>Join two spatial networks based on equality of node geometries</p></a></li>
<li><a href='#st_network_paths'><p>Paths between points in geographical space</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tidy Geospatial Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lucas van der Meer &lt;luukvandermeer@live.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a tidy approach to spatial network
    analysis, in the form of classes and functions that enable a seamless
    interaction between the network analysis package 'tidygraph' and the
    spatial analysis package 'sf'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://luukvdmeer.github.io/sfnetworks/">https://luukvdmeer.github.io/sfnetworks/</a>,
<a href="https://github.com/luukvdmeer/sfnetworks">https://github.com/luukvdmeer/sfnetworks</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/luukvdmeer/sfnetworks/issues/">https://github.com/luukvdmeer/sfnetworks/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>crayon, dplyr, graphics, igraph, lwgeom, rlang, sf, sfheaders,
tibble, tidygraph, units, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dbscan, fansi, ggplot2 (&ge; 3.0.0), knitr, purrr, rmarkdown,
s2 (&ge; 1.0.1), spatstat.geom, spatstat.linnet, testthat, TSP</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-06 15:03:30 UTC; rstudio</td>
</tr>
<tr>
<td>Author:</td>
<td>Lucas van der Meer
    <a href="https://orcid.org/0000-0001-6336-8628"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Lorena Abad <a href="https://orcid.org/0000-0003-0554-734X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Andrea Gilardi <a href="https://orcid.org/0000-0002-9424-7439"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Robin Lovelace <a href="https://orcid.org/0000-0001-5679-6536"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-06 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sfnetworks-package'>sfnetworks: Tidy Geospatial Networks</h2><span id='topic+sfnetworks'></span><span id='topic+sfnetworks-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides a tidy approach to spatial network analysis, in the form of classes and functions that enable a seamless interaction between the network analysis package 'tidygraph' and the spatial analysis package 'sf'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lucas van der Meer <a href="mailto:luukvandermeer@live.nl">luukvandermeer@live.nl</a> (<a href="https://orcid.org/0000-0001-6336-8628">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Lorena Abad <a href="mailto:lore.abad6@gmail.com">lore.abad6@gmail.com</a> (<a href="https://orcid.org/0000-0003-0554-734X">ORCID</a>)
</p>
</li>
<li><p> Andrea Gilardi <a href="mailto:andrea.gilardi@unimib.it">andrea.gilardi@unimib.it</a> (<a href="https://orcid.org/0000-0002-9424-7439">ORCID</a>)
</p>
</li>
<li><p> Robin Lovelace <a href="mailto:r.lovelace@leeds.ac.uk">r.lovelace@leeds.ac.uk</a> (<a href="https://orcid.org/0000-0001-5679-6536">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://luukvdmeer.github.io/sfnetworks/">https://luukvdmeer.github.io/sfnetworks/</a>
</p>
</li>
<li> <p><a href="https://github.com/luukvdmeer/sfnetworks">https://github.com/luukvdmeer/sfnetworks</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/luukvdmeer/sfnetworks/issues/">https://github.com/luukvdmeer/sfnetworks/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='as_sfnetwork'>Convert a foreign object to a sfnetwork</h2><span id='topic+as_sfnetwork'></span><span id='topic+as_sfnetwork.default'></span><span id='topic+as_sfnetwork.sf'></span><span id='topic+as_sfnetwork.linnet'></span><span id='topic+as_sfnetwork.psp'></span><span id='topic+as_sfnetwork.sfc'></span><span id='topic+as_sfnetwork.sfNetwork'></span><span id='topic+as_sfnetwork.sfnetwork'></span><span id='topic+as_sfnetwork.tbl_graph'></span>

<h3>Description</h3>

<p>Convert a given object into an object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.
If an object can be read by <code><a href="tidygraph.html#topic+as_tbl_graph">as_tbl_graph</a></code> and the
nodes can be read by <code><a href="sf.html#topic+st_as_sf">st_as_sf</a></code>, it is automatically
supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sfnetwork(x, ...)

## Default S3 method:
as_sfnetwork(x, ...)

## S3 method for class 'sf'
as_sfnetwork(x, ...)

## S3 method for class 'linnet'
as_sfnetwork(x, ...)

## S3 method for class 'psp'
as_sfnetwork(x, ...)

## S3 method for class 'sfc'
as_sfnetwork(x, ...)

## S3 method for class 'sfNetwork'
as_sfnetwork(x, ...)

## S3 method for class 'sfnetwork'
as_sfnetwork(x, ...)

## S3 method for class 'tbl_graph'
as_sfnetwork(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_sfnetwork_+3A_x">x</code></td>
<td>
<p>Object to be converted into an <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="as_sfnetwork_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the <code><a href="#topic+sfnetwork">sfnetwork</a></code> construction
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as_sfnetwork(sf)</code>: Only sf objects with either exclusively geometries
of type <code>LINESTRING</code> or exclusively geometries of type <code>POINT</code> are
supported. For lines, is assumed that the given features form the edges.
Nodes are created at the endpoints of the lines. Endpoints which are shared
between multiple edges become a single node. For points, it is assumed that
the given features geometries form the nodes. They will be connected by
edges sequentially. Hence, point 1 to point 2, point 2 to point 3, etc.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># From an sf object.
library(sf, quietly = TRUE)

# With LINESTRING geometries.
as_sfnetwork(roxel)

oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1), mfrow = c(1,2))
plot(st_geometry(roxel))
plot(as_sfnetwork(roxel))
par(oldpar)

# With POINT geometries.
p1 = st_point(c(7, 51))
p2 = st_point(c(7, 52))
p3 = st_point(c(8, 52))
points = st_as_sf(st_sfc(p1, p2, p3))
as_sfnetwork(points)

oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1), mfrow = c(1,2))
plot(st_geometry(points))
plot(as_sfnetwork(points))
par(oldpar)

# From a linnet object.
if (require(spatstat.geom, quietly = TRUE)) {
  as_sfnetwork(simplenet)
}

# From a psp object.
if (require(spatstat.geom, quietly = TRUE)) {
  set.seed(42)
  test_psp = psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  as_sfnetwork(test_psp)
}

</code></pre>

<hr>
<h2 id='as_tibble'>Extract the active element of a sfnetwork as spatial tibble</h2><span id='topic+as_tibble'></span><span id='topic+as_tibble.sfnetwork'></span>

<h3>Description</h3>

<p>The sfnetwork method for <code><a href="tibble.html#topic+as_tibble">as_tibble</a></code> is conceptually
different. Whenever a geometry list column is present, it will by default
return what we call a 'spatial tibble'. With that we mean an object of
class <code>c('sf', 'tbl_df')</code> instead of an object of class
<code>'tbl_df'</code>. This little conceptual trick is essential for how
tidyverse functions handle <code><a href="#topic+sfnetwork">sfnetwork</a></code> objects, i.e. always
using the corresponding <code><a href="sf.html#topic+sf">sf</a></code> method if present. When using
<code><a href="tibble.html#topic+as_tibble">as_tibble</a></code> on <code><a href="#topic+sfnetwork">sfnetwork</a></code> objects directly
as a user, you can disable this behaviour by setting <code>spatial = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfnetwork'
as_tibble(x, active = NULL, spatial = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_tibble_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="as_tibble_+3A_active">active</code></td>
<td>
<p>Which network element (i.e. nodes or edges) to activate before
extracting. If <code>NULL</code>, it will be set to the current active element of
the given network. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="as_tibble_+3A_spatial">spatial</code></td>
<td>
<p>Should the extracted tibble be a 'spatial tibble', i.e. an
object of class <code>c('sf', 'tbl_df')</code>, if it contains a geometry list
column. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="as_tibble_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="tibble.html#topic+as_tibble">as_tibble</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The active element of the network as an object of class
<code><a href="tibble.html#topic+tibble">tibble</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble, quietly = TRUE)

net = as_sfnetwork(roxel)

# Extract the active network element as a spatial tibble.
as_tibble(net)

# Extract any network element as a spatial tibble.
as_tibble(net, "edges")

# Extract the active network element as a regular tibble.
as_tibble(net, spatial = FALSE)

</code></pre>

<hr>
<h2 id='as.linnet'>Convert a sfnetwork into a linnet</h2><span id='topic+as.linnet'></span><span id='topic+as.linnet.sfnetwork'></span>

<h3>Description</h3>

<p>A method to convert an object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code> into
<code><a href="spatstat.linnet.html#topic+linnet">linnet</a></code> format and enhance the
interoperability between <code>sfnetworks</code> and <code>spatstat</code>. Use
this method without the .sfnetwork suffix and after loading the
<code>spatstat</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.linnet.sfnetwork(X, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.linnet_+3A_x">X</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code> with a projected CRS.</p>
</td></tr>
<tr><td><code id="as.linnet_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="spatstat.linnet.html#topic+linnet">linnet</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="spatstat.linnet.html#topic+linnet">linnet</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_sfnetwork">as_sfnetwork</a></code> to convert objects of class
<code><a href="spatstat.linnet.html#topic+linnet">linnet</a></code> into objects of class
<code><a href="#topic+sfnetwork">sfnetwork</a></code>.
</p>

<hr>
<h2 id='autoplot'>Plot sfnetwork geometries with ggplot2</h2><span id='topic+autoplot'></span><span id='topic+autoplot.sfnetwork'></span>

<h3>Description</h3>

<p>Plot the geometries of an object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>
automatically as a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object. Use this method
without the .sfnetwork suffix and after loading the <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot.sfnetwork(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="ggplot2.html#topic+autoplot">autoplot</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.
</p>

<hr>
<h2 id='is.sfnetwork'>Check if an object is a sfnetwork</h2><span id='topic+is.sfnetwork'></span>

<h3>Description</h3>

<p>Check if an object is a sfnetwork
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.sfnetwork(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.sfnetwork_+3A_x">x</code></td>
<td>
<p>Object to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the given object is an object of class
<code><a href="#topic+sfnetwork">sfnetwork</a></code>, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidygraph, quietly = TRUE, warn.conflicts = FALSE)

net = as_sfnetwork(roxel)
is.sfnetwork(net)
is.sfnetwork(as_tbl_graph(net))

</code></pre>

<hr>
<h2 id='node_coordinates'>Query node coordinates</h2><span id='topic+node_coordinates'></span><span id='topic+node_X'></span><span id='topic+node_Y'></span><span id='topic+node_Z'></span><span id='topic+node_M'></span>

<h3>Description</h3>

<p>These functions allow to query specific coordinate values from the
geometries of the nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_X()

node_Y()

node_Z()

node_M()
</code></pre>


<h3>Details</h3>

<p>Just as with all query functions in tidygraph, these functions
are meant to be called inside tidygraph verbs such as
<code><a href="tidygraph.html#topic+mutate">mutate</a></code> or <code><a href="tidygraph.html#topic+filter">filter</a></code>, where
the network that is currently being worked on is known and thus not needed
as an argument to the function. If you want to use an algorithm outside of
the tidygraph framework you can use <code><a href="tidygraph.html#topic+with_graph">with_graph</a></code> to
set the context temporarily while the algorithm is being evaluated.
</p>


<h3>Value</h3>

<p>A numeric vector of the same length as the number of nodes in the
network.
</p>


<h3>Note</h3>

<p>If a requested coordinate value is not available for a node, <code>NA</code>
will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf, quietly = TRUE)
library(tidygraph, quietly = TRUE)

# Create a network.
net = as_sfnetwork(roxel)

# Use query function in a filter call.
filtered = net %&gt;%
  activate("nodes") %&gt;%
  filter(node_X() &gt; 7.54)

oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1))
plot(net, col = "grey")
plot(filtered, col = "red", add = TRUE)
par(oldpar)

# Use query function in a mutate call.
net %&gt;%
  activate("nodes") %&gt;%
  mutate(X = node_X(), Y = node_Y())

</code></pre>

<hr>
<h2 id='plot.sfnetwork'>Plot sfnetwork geometries</h2><span id='topic+plot.sfnetwork'></span>

<h3>Description</h3>

<p>Plot the geometries of an object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfnetwork'
plot(x, draw_lines = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sfnetwork_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="plot.sfnetwork_+3A_draw_lines">draw_lines</code></td>
<td>
<p>If the edges of the network are spatially implicit, should
straight lines be drawn between connected nodes? Defaults to <code>TRUE</code>.
Ignored when the edges of the network are spatially explicit.</p>
</td></tr>
<tr><td><code id="plot.sfnetwork_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="sf.html#topic+plot">plot.sf</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a basic plotting functionality. For more advanced plotting,
it is recommended to extract the nodes and edges from the network, and plot
them separately with one of the many available spatial plotting functions
as can be found in <code>sf</code>, <code>tmap</code>, <code>ggplot2</code>, <code>ggspatial</code>,
and others.
</p>


<h3>Value</h3>

<p>This is a plot method and therefore has no visible return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1), mfrow = c(1,1))
net = as_sfnetwork(roxel)
plot(net)

# When lines are spatially implicit.
par(mar = c(1,1,1,1), mfrow = c(1,2))
net = as_sfnetwork(roxel, edges_as_lines = FALSE)
plot(net)
plot(net, draw_lines = FALSE)

# Changing default settings.
par(mar = c(1,1,1,1), mfrow = c(1,1))
plot(net, col = 'blue', pch = 18, lwd = 1, cex = 2)

# Add grid and axis
par(mar = c(2.5,2.5,1,1))
plot(net, graticule = TRUE, axes = TRUE)

par(oldpar)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+activate'></span><span id='topic+active'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>tidygraph</dt><dd><p><code><a href="tidygraph.html#topic+reexports">%&gt;%</a></code>, <code><a href="tidygraph.html#topic+activate">activate</a></code>, <code><a href="tidygraph.html#topic+activate">active</a></code></p>
</dd>
</dl>

<hr>
<h2 id='roxel'>Road network of Münster Roxel</h2><span id='topic+roxel'></span>

<h3>Description</h3>

<p>A dataset containing the road network (roads, bikelanes, footpaths, etc.) of
Roxel, a neighborhood in the city of Münster, Germany. The data are taken
from OpenStreetMap, querying by key = 'highway'. The topology is cleaned with
the v.clean tool in GRASS GIS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roxel
</code></pre>


<h3>Format</h3>

<p>An object of class <code><a href="sf.html#topic+sf">sf</a></code> with <code>LINESTRING</code>
geometries, containing 851 features and three columns:
</p>

<dl>
<dt>name</dt><dd><p>the name of the road, if it exists</p>
</dd>
<dt>type</dt><dd><p>the type of the road, e.g. cycleway</p>
</dd>
<dt>geometry</dt><dd><p>the geometry list column</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.openstreetmap.org">https://www.openstreetmap.org</a>
</p>

<hr>
<h2 id='s2'>s2 methods for sfnetworks</h2><span id='topic+s2'></span><span id='topic+as_s2_geography.sfnetwork'></span>

<h3>Description</h3>

<p>s2 methods for sfnetworks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_s2_geography.sfnetwork(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s2_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="s2_+3A_...">...</code></td>
<td>
<p>Arguments passed on the corresponding <code>s2</code> function.</p>
</td></tr>
</table>

<hr>
<h2 id='sf'>sf methods for sfnetworks</h2><span id='topic+sf'></span><span id='topic+st_as_sf.sfnetwork'></span><span id='topic+st_as_s2.sfnetwork'></span><span id='topic+st_geometry.sfnetwork'></span><span id='topic+st_geometry+3C-.sfnetwork'></span><span id='topic+st_drop_geometry.sfnetwork'></span><span id='topic+st_bbox.sfnetwork'></span><span id='topic+st_coordinates.sfnetwork'></span><span id='topic+st_is.sfnetwork'></span><span id='topic+st_is_valid.sfnetwork'></span><span id='topic+st_crs.sfnetwork'></span><span id='topic+st_crs+3C-.sfnetwork'></span><span id='topic+st_precision.sfnetwork'></span><span id='topic+st_set_precision.sfnetwork'></span><span id='topic+st_shift_longitude.sfnetwork'></span><span id='topic+st_transform.sfnetwork'></span><span id='topic+st_wrap_dateline.sfnetwork'></span><span id='topic+st_normalize.sfnetwork'></span><span id='topic+st_zm.sfnetwork'></span><span id='topic+st_m_range.sfnetwork'></span><span id='topic+st_z_range.sfnetwork'></span><span id='topic+st_agr.sfnetwork'></span><span id='topic+st_agr+3C-.sfnetwork'></span><span id='topic+st_reverse.sfnetwork'></span><span id='topic+st_simplify.sfnetwork'></span><span id='topic+st_join.sfnetwork'></span><span id='topic+st_join.morphed_sfnetwork'></span><span id='topic+st_filter.sfnetwork'></span><span id='topic+st_filter.morphed_sfnetwork'></span><span id='topic+st_crop.sfnetwork'></span><span id='topic+st_crop.morphed_sfnetwork'></span><span id='topic+st_difference.sfnetwork'></span><span id='topic+st_difference.morphed_sfnetwork'></span><span id='topic+st_intersection.sfnetwork'></span><span id='topic+st_intersection.morphed_sfnetwork'></span><span id='topic+st_intersects.sfnetwork'></span><span id='topic+st_sample.sfnetwork'></span><span id='topic+st_nearest_points.sfnetwork'></span><span id='topic+st_area.sfnetwork'></span>

<h3>Description</h3>

<p><code><a href="sf.html#topic+sf">sf</a></code> methods for <code><a href="#topic+sfnetwork">sfnetwork</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfnetwork'
st_as_sf(x, active = NULL, ...)

## S3 method for class 'sfnetwork'
st_as_s2(x, active = NULL, ...)

## S3 method for class 'sfnetwork'
st_geometry(obj, active = NULL, ...)

## S3 replacement method for class 'sfnetwork'
st_geometry(x) &lt;- value

## S3 method for class 'sfnetwork'
st_drop_geometry(x, ...)

## S3 method for class 'sfnetwork'
st_bbox(obj, active = NULL, ...)

## S3 method for class 'sfnetwork'
st_coordinates(x, active = NULL, ...)

## S3 method for class 'sfnetwork'
st_is(x, ...)

## S3 method for class 'sfnetwork'
st_is_valid(x, ...)

## S3 method for class 'sfnetwork'
st_crs(x, ...)

## S3 replacement method for class 'sfnetwork'
st_crs(x) &lt;- value

## S3 method for class 'sfnetwork'
st_precision(x)

## S3 method for class 'sfnetwork'
st_set_precision(x, precision)

## S3 method for class 'sfnetwork'
st_shift_longitude(x, ...)

## S3 method for class 'sfnetwork'
st_transform(x, ...)

## S3 method for class 'sfnetwork'
st_wrap_dateline(x, ...)

## S3 method for class 'sfnetwork'
st_normalize(x, ...)

## S3 method for class 'sfnetwork'
st_zm(x, ...)

## S3 method for class 'sfnetwork'
st_m_range(obj, active = NULL, ...)

## S3 method for class 'sfnetwork'
st_z_range(obj, active = NULL, ...)

## S3 method for class 'sfnetwork'
st_agr(x, active = NULL, ...)

## S3 replacement method for class 'sfnetwork'
st_agr(x) &lt;- value

## S3 method for class 'sfnetwork'
st_reverse(x, ...)

## S3 method for class 'sfnetwork'
st_simplify(x, ...)

## S3 method for class 'sfnetwork'
st_join(x, y, ...)

## S3 method for class 'morphed_sfnetwork'
st_join(x, y, ...)

## S3 method for class 'sfnetwork'
st_filter(x, y, ...)

## S3 method for class 'morphed_sfnetwork'
st_filter(x, y, ...)

## S3 method for class 'sfnetwork'
st_crop(x, y, ...)

## S3 method for class 'morphed_sfnetwork'
st_crop(x, y, ...)

## S3 method for class 'sfnetwork'
st_difference(x, y, ...)

## S3 method for class 'morphed_sfnetwork'
st_difference(x, y, ...)

## S3 method for class 'sfnetwork'
st_intersection(x, y, ...)

## S3 method for class 'morphed_sfnetwork'
st_intersection(x, y, ...)

## S3 method for class 'sfnetwork'
st_intersects(x, y, ...)

## S3 method for class 'sfnetwork'
st_sample(x, ...)

## S3 method for class 'sfnetwork'
st_nearest_points(x, y, ...)

## S3 method for class 'sfnetwork'
st_area(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="sf_+3A_active">active</code></td>
<td>
<p>Which network element (i.e. nodes or edges) to activate before
extracting. If <code>NULL</code>, it will be set to the current active element of
the given network. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sf_+3A_...">...</code></td>
<td>
<p>Arguments passed on the corresponding <code>sf</code> function.</p>
</td></tr>
<tr><td><code id="sf_+3A_obj">obj</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="sf_+3A_value">value</code></td>
<td>
<p>The value to be assigned. See the documentation of the
corresponding sf function for details.</p>
</td></tr>
<tr><td><code id="sf_+3A_precision">precision</code></td>
<td>
<p>The precision to be assigned. See
<code><a href="sf.html#topic+st_precision">st_precision</a></code> for details.</p>
</td></tr>
<tr><td><code id="sf_+3A_y">y</code></td>
<td>
<p>An object of class <code><a href="sf.html#topic+sf">sf</a></code>, or directly convertible to
it using <code><a href="sf.html#topic+st_as_sf">st_as_sf</a></code>. In some cases, it can also be an object
of <code><a href="sf.html#topic+st">sfg</a></code> or <code><a href="sf.html#topic+st_bbox">bbox</a></code>. Always look
at the documentation of the corresponding <code>sf</code> function for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code><a href="sf.html#topic+sf">sf</a></code> documentation.
</p>


<h3>Value</h3>

<p>The <code>sfnetwork</code> method for <code><a href="sf.html#topic+st_as_sf">st_as_sf</a></code> returns
the active element of the network as object of class <code><a href="sf.html#topic+sf">sf</a></code>.
The <code>sfnetwork</code> and <code>morphed_sfnetwork</code> methods for
<code><a href="sf.html#topic+st_join">st_join</a></code>, <code><a href="sf.html#topic+st_filter">st_filter</a></code>,
<code><a href="sf.html#topic+st_intersection">st_intersection</a></code>, <code><a href="sf.html#topic+st_difference">st_difference</a></code>,
<code><a href="sf.html#topic+st_crop">st_crop</a></code> and the setter functions
return an object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>
and <code>morphed_sfnetwork</code> respectively. All other
methods return the same type of objects as their corresponding sf function.
See the <code><a href="sf.html#topic+sf">sf</a></code> documentation for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf, quietly = TRUE)

net = as_sfnetwork(roxel)

# Extract the active network element.
st_as_sf(net)

# Extract any network element.
st_as_sf(net, "edges")

# Get geometry of the active network element.
st_geometry(net)

# Get geometry of any network element.
st_geometry(net, "edges")

# Get bbox of the active network element.
st_bbox(net)

# Get CRS of the network.
st_crs(net)

# Get agr factor of the active network element.
st_agr(net)

# Get agr factor of any network element.
st_agr(net, "edges")

# Spatial join applied to the active network element.
net = st_transform(net, 3035)
codes = st_as_sf(st_make_grid(net, n = c(2, 2)))
codes$post_code = as.character(seq(1000, 1000 + nrow(codes) * 10 - 10, 10))

joined = st_join(net, codes, join = st_intersects)
joined

oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1), mfrow = c(1,2))
plot(net, col = "grey")
plot(codes, col = NA, border = "red", lty = 4, lwd = 4, add = TRUE)
text(st_coordinates(st_centroid(st_geometry(codes))), codes$post_code)
plot(st_geometry(joined, "edges"))
plot(st_as_sf(joined, "nodes"), pch = 20, add = TRUE)
par(oldpar)
# Spatial filter applied to the active network element.
p1 = st_point(c(4151358, 3208045))
p2 = st_point(c(4151340, 3207520))
p3 = st_point(c(4151756, 3207506))
p4 = st_point(c(4151774, 3208031))

poly = st_multipoint(c(p1, p2, p3, p4)) %&gt;%
  st_cast('POLYGON') %&gt;%
  st_sfc(crs = 3035) %&gt;%
  st_as_sf()

filtered = st_filter(net, poly, .pred = st_intersects)

oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1), mfrow = c(1,2))
plot(net, col = "grey")
plot(poly, border = "red", lty = 4, lwd = 4, add = TRUE)
plot(filtered)
par(oldpar)
</code></pre>

<hr>
<h2 id='sf_attr'>Query sf attributes from the active element of a sfnetwork</h2><span id='topic+sf_attr'></span>

<h3>Description</h3>

<p>Query sf attributes from the active element of a sfnetwork
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_attr(x, name, active = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_attr_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="sf_attr_+3A_name">name</code></td>
<td>
<p>Name of the attribute to query. Either <code>'sf_column'</code> or
<code>'agr'</code>.</p>
</td></tr>
<tr><td><code id="sf_attr_+3A_active">active</code></td>
<td>
<p>Which network element (i.e. nodes or edges) to activate before
extracting. If <code>NULL</code>, it will be set to the current active element of
the given network. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>sf attributes include <code>sf_column</code> (the name of the sf column)
and <code>agr</code> (the attribute-geometry-relationships).
</p>


<h3>Value</h3>

<p>The value of the attribute matched, or <code>NULL</code> if no exact
match is found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net = as_sfnetwork(roxel)
sf_attr(net, "agr", active = "edges")
sf_attr(net, "sf_column", active = "nodes")

</code></pre>

<hr>
<h2 id='sfnetwork'>Create a sfnetwork</h2><span id='topic+sfnetwork'></span>

<h3>Description</h3>

<p><code>sfnetwork</code> is a tidy data structure for geospatial networks. It
extends the <code><a href="tidygraph.html#topic+tbl_graph">tbl_graph</a></code> data structure for
relational data into the domain of geospatial networks, with nodes and
edges embedded in geographical space, and offers smooth integration with
<code><a href="sf.html#topic+sf">sf</a></code> for spatial data analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfnetwork(
  nodes,
  edges = NULL,
  directed = TRUE,
  node_key = "name",
  edges_as_lines = NULL,
  length_as_weight = FALSE,
  force = FALSE,
  message = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfnetwork_+3A_nodes">nodes</code></td>
<td>
<p>The nodes of the network. Should be an object of class
<code><a href="sf.html#topic+sf">sf</a></code>, or directly convertible to it using
<code><a href="sf.html#topic+st_as_sf">st_as_sf</a></code>. All features should have an associated geometry
of type <code>POINT</code>.</p>
</td></tr>
<tr><td><code id="sfnetwork_+3A_edges">edges</code></td>
<td>
<p>The edges of the network. May be an object of class
<code><a href="sf.html#topic+sf">sf</a></code>, with all features having an associated geometry of
type <code>LINESTRING</code>. It may also be a regular <code><a href="base.html#topic+data.frame">data.frame</a></code> or
<code><a href="tibble.html#topic+tbl_df">tbl_df</a></code> object. In any case, the nodes at the ends of
each edge must either be encoded in a <code>to</code> and <code>from</code> column, as
integers or characters. Integers should refer to the position of a node in
the nodes table, while characters should refer to the name of a node encoded
in the column referred to in the <code>node_key</code> argument. Setting edges to
<code>NULL</code> will create a network without edges.</p>
</td></tr>
<tr><td><code id="sfnetwork_+3A_directed">directed</code></td>
<td>
<p>Should the constructed network be directed? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sfnetwork_+3A_node_key">node_key</code></td>
<td>
<p>The name of the column in the nodes table that character
represented <code>to</code> and <code>from</code> columns should be matched against. If
<code>NA</code>, the first column is always chosen. This setting has no effect if
<code>to</code> and <code>from</code> are given as integers. Defaults to <code>'name'</code>.</p>
</td></tr>
<tr><td><code id="sfnetwork_+3A_edges_as_lines">edges_as_lines</code></td>
<td>
<p>Should the edges be spatially explicit, i.e. have
<code>LINESTRING</code> geometries stored in a geometry list column? If
<code>NULL</code>, this will be automatically defined, by setting the argument to
<code>TRUE</code> when the edges are given as an object of class
<code><a href="sf.html#topic+sf">sf</a></code>, and <code>FALSE</code> otherwise. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sfnetwork_+3A_length_as_weight">length_as_weight</code></td>
<td>
<p>Should the length of the edges be stored in a column
named <code>weight</code>? If set to <code>TRUE</code>, this will calculate the length
of the linestring geometry of the edge in the case of spatially explicit
edges, and the straight-line distance between the source and target node in
the case of spatially implicit edges. If there is already a column named
<code>weight</code>, it will be overwritten. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sfnetwork_+3A_force">force</code></td>
<td>
<p>Should network validity checks be skipped? Defaults to
<code>FALSE</code>, meaning that network validity checks are executed when
constructing the network. These checks guarantee a valid spatial network
structure. For the nodes, this means that they all should have <code>POINT</code>
geometries. In the case of spatially explicit edges, it is also checked that
all edges have <code>LINESTRING</code> geometries, nodes and edges have the same
CRS and boundary points of edges match their corresponding node coordinates.
These checks are important, but also time consuming. If you are already sure
your input data meet the requirements, the checks are unnecessary and can be
turned off to improve performance.</p>
</td></tr>
<tr><td><code id="sfnetwork_+3A_message">message</code></td>
<td>
<p>Should informational messages (those messages that are
neither warnings nor errors) be printed when constructing the network?
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sfnetwork_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="sf.html#topic+st_as_sf">st_as_sf</a></code>, if nodes need
to be converted into an <code><a href="sf.html#topic+sf">sf</a></code> object during construction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sfnetwork</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf, quietly = TRUE)

## Create sfnetwork from sf objects
p1 = st_point(c(7, 51))
p2 = st_point(c(7, 52))
p3 = st_point(c(8, 52))
nodes = st_as_sf(st_sfc(p1, p2, p3, crs = 4326))

e1 = st_cast(st_union(p1, p2), "LINESTRING")
e2 = st_cast(st_union(p1, p3), "LINESTRING")
e3 = st_cast(st_union(p3, p2), "LINESTRING")
edges = st_as_sf(st_sfc(e1, e2, e3, crs = 4326))
edges$from = c(1, 1, 3)
edges$to = c(2, 3, 2)

# Default.
sfnetwork(nodes, edges)

# Undirected network.
sfnetwork(nodes, edges, directed = FALSE)

# Using character encoded from and to columns.
nodes$name = c("city", "village", "farm")
edges$from = c("city", "city", "farm")
edges$to = c("village", "farm", "village")
sfnetwork(nodes, edges, node_key = "name")

# Spatially implicit edges.
sfnetwork(nodes, edges, edges_as_lines = FALSE)

# Store edge lenghts in a weight column.
sfnetwork(nodes, edges, length_as_weight = TRUE)

# Adjust the number of features printed by active and inactive components
oldoptions = options(sfn_max_print_active = 1, sfn_max_print_inactive = 2)
sfnetwork(nodes, edges)
options(oldoptions)

</code></pre>

<hr>
<h2 id='spatial_edge_measures'>Query spatial edge measures</h2><span id='topic+spatial_edge_measures'></span><span id='topic+edge_azimuth'></span><span id='topic+edge_circuity'></span><span id='topic+edge_length'></span><span id='topic+edge_displacement'></span>

<h3>Description</h3>

<p>These functions are a collection of specific spatial edge measures, that
form a spatial extension to edge measures in
<code><a href="tidygraph.html#topic+tidygraph-package">tidygraph</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_azimuth(degrees = FALSE)

edge_circuity(Inf_as_NaN = FALSE)

edge_length()

edge_displacement()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial_edge_measures_+3A_degrees">degrees</code></td>
<td>
<p>Should the angle be returned in degrees instead of radians?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="spatial_edge_measures_+3A_inf_as_nan">Inf_as_NaN</code></td>
<td>
<p>Should the circuity values of loop edges be stored as
<code>NaN</code> instead of <code>Inf</code>? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just as with all query functions in tidygraph, spatial edge
measures are meant to be called inside tidygraph verbs such as
<code><a href="tidygraph.html#topic+mutate">mutate</a></code> or <code><a href="tidygraph.html#topic+filter">filter</a></code>, where
the network that is currently being worked on is known and thus not needed
as an argument to the function. If you want to use an algorithm outside of
the tidygraph framework you can use <code><a href="tidygraph.html#topic+with_graph">with_graph</a></code> to
set the context temporarily while the algorithm is being evaluated.
</p>


<h3>Value</h3>

<p>A numeric vector of the same length as the number of edges in the
graph.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>edge_azimuth()</code>: The angle in radians between a straight
line from the edge startpoint pointing north, and the straight line from
the edge startpoint and the edge endpoint. Calculated with
<code><a href="lwgeom.html#topic+st_geod_azimuth">st_geod_azimuth</a></code>. Requires a geographic CRS.
</p>
</li>
<li> <p><code>edge_circuity()</code>: The ratio of the length of an edge
linestring geometry versus the straight-line distance between its boundary
nodes, as described in Giacomin &amp;
Levinson, 2015. DOI: 10.1068/b130131p.
</p>
</li>
<li> <p><code>edge_length()</code>: The length of an edge linestring geometry
as calculated by <code><a href="sf.html#topic+st_length">st_length</a></code>.
</p>
</li>
<li> <p><code>edge_displacement()</code>: The straight-line distance between the two
boundary nodes of an edge, as calculated by <code><a href="sf.html#topic+st_distance">st_distance</a></code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf, quietly = TRUE)
library(tidygraph, quietly = TRUE)

net = as_sfnetwork(roxel)

net %&gt;%
  activate("edges") %&gt;%
  mutate(azimuth = edge_azimuth())

net %&gt;%
  activate("edges") %&gt;%
  mutate(azimuth = edge_azimuth(degrees = TRUE))

net %&gt;%
  activate("edges") %&gt;%
  mutate(circuity = edge_circuity())

net %&gt;%
  activate("edges") %&gt;%
  mutate(length = edge_length())

net %&gt;%
  activate("edges") %&gt;%
  mutate(displacement = edge_displacement())

</code></pre>

<hr>
<h2 id='spatial_edge_predicates'>Query edges with spatial predicates</h2><span id='topic+spatial_edge_predicates'></span><span id='topic+edge_intersects'></span><span id='topic+edge_is_disjoint'></span><span id='topic+edge_touches'></span><span id='topic+edge_crosses'></span><span id='topic+edge_is_within'></span><span id='topic+edge_contains'></span><span id='topic+edge_contains_properly'></span><span id='topic+edge_overlaps'></span><span id='topic+edge_equals'></span><span id='topic+edge_covers'></span><span id='topic+edge_is_covered_by'></span><span id='topic+edge_is_within_distance'></span>

<h3>Description</h3>

<p>These functions allow to interpret spatial relations between edges and
other geospatial features directly inside <code><a href="tidygraph.html#topic+filter">filter</a></code>
and <code><a href="tidygraph.html#topic+mutate">mutate</a></code> calls. All functions return a logical
vector of the same length as the number of edges in the network. Element i
in that vector is <code>TRUE</code> whenever <code>any(predicate(x[i], y[j]))</code> is
<code>TRUE</code>. Hence, in the case of using <code>edge_intersects</code>, element i
in the returned vector is <code>TRUE</code> when edge i intersects with any of
the features given in y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_intersects(y, ...)

edge_is_disjoint(y, ...)

edge_touches(y, ...)

edge_crosses(y, ...)

edge_is_within(y, ...)

edge_contains(y, ...)

edge_contains_properly(y, ...)

edge_overlaps(y, ...)

edge_equals(y, ...)

edge_covers(y, ...)

edge_is_covered_by(y, ...)

edge_is_within_distance(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial_edge_predicates_+3A_y">y</code></td>
<td>
<p>The geospatial features to test the edges against, either as an
object of class <code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sf.html#topic+sfc">sfc</a></code>.</p>
</td></tr>
<tr><td><code id="spatial_edge_predicates_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the corresponding spatial predicate
function of sf. See <code><a href="sf.html#topic+geos_binary_pred">geos_binary_pred</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="sf.html#topic+geos_binary_pred">geos_binary_pred</a></code> for details on each spatial
predicate. Just as with all query functions in tidygraph, these functions
are meant to be called inside tidygraph verbs such as
<code><a href="tidygraph.html#topic+mutate">mutate</a></code> or <code><a href="tidygraph.html#topic+filter">filter</a></code>, where
the network that is currently being worked on is known and thus not needed
as an argument to the function. If you want to use an algorithm outside of
the tidygraph framework you can use <code><a href="tidygraph.html#topic+with_graph">with_graph</a></code> to
set the context temporarily while the algorithm is being evaluated.
</p>


<h3>Value</h3>

<p>A logical vector of the same length as the number of edges in the
network.
</p>


<h3>Note</h3>

<p>Note that <code>edge_is_within_distance</code> is a wrapper around the
<code>st_is_within_distance</code> predicate from sf. Hence, it is based on
'as-the-crow-flies' distance, and not on distances over the network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf, quietly = TRUE)
library(tidygraph, quietly = TRUE)

# Create a network.
net = as_sfnetwork(roxel) %&gt;%
  st_transform(3035)

# Create a geometry to test against.
p1 = st_point(c(4151358, 3208045))
p2 = st_point(c(4151340, 3207520))
p3 = st_point(c(4151756, 3207506))
p4 = st_point(c(4151774, 3208031))

poly = st_multipoint(c(p1, p2, p3, p4)) %&gt;%
  st_cast('POLYGON') %&gt;%
  st_sfc(crs = 3035)

# Use predicate query function in a filter call.
intersects = net %&gt;%
  activate(edges) %&gt;%
  filter(edge_intersects(poly))

oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1))
plot(st_geometry(net, "edges"))
plot(st_geometry(intersects, "edges"), col = "red", lwd = 2, add = TRUE)
par(oldpar)

# Use predicate query function in a mutate call.
net %&gt;%
  activate(edges) %&gt;%
  mutate(disjoint = edge_is_disjoint(poly)) %&gt;%
  select(disjoint)

</code></pre>

<hr>
<h2 id='spatial_morphers'>Spatial morphers for sfnetworks</h2><span id='topic+spatial_morphers'></span><span id='topic+to_spatial_contracted'></span><span id='topic+to_spatial_directed'></span><span id='topic+to_spatial_explicit'></span><span id='topic+to_spatial_neighborhood'></span><span id='topic+to_spatial_shortest_paths'></span><span id='topic+to_spatial_simple'></span><span id='topic+to_spatial_smooth'></span><span id='topic+to_spatial_subdivision'></span><span id='topic+to_spatial_subset'></span><span id='topic+to_spatial_transformed'></span>

<h3>Description</h3>

<p>Spatial morphers form spatial add-ons to the set of
<code><a href="tidygraph.html#topic+morphers">morphers</a></code> provided by <code>tidygraph</code>. These
functions are not meant to be called directly. They should either be passed
into <code><a href="tidygraph.html#topic+morph">morph</a></code> to create a temporary alternative
representation of the input network. Such an alternative representation is a
list of one or more network objects. Single elements of that list can be
extracted directly as a new network by passing the morpher to
<code><a href="tidygraph.html#topic+convert">convert</a></code> instead, to make the changes lasting rather
than temporary. Alternatively, if the morphed state contains multiple
elements, all of them can be extracted together inside a
<code><a href="tibble.html#topic+tbl_df">tbl_df</a></code> by passing the morpher to
<code><a href="tidygraph.html#topic+crystallise">crystallise</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_spatial_contracted(
  x,
  ...,
  simplify = FALSE,
  summarise_attributes = "ignore",
  store_original_data = FALSE
)

to_spatial_directed(x)

to_spatial_explicit(x, ...)

to_spatial_neighborhood(x, node, threshold, weights = NULL, from = TRUE, ...)

to_spatial_shortest_paths(x, ...)

to_spatial_simple(
  x,
  remove_multiple = TRUE,
  remove_loops = TRUE,
  summarise_attributes = "first",
  store_original_data = FALSE
)

to_spatial_smooth(
  x,
  protect = NULL,
  summarise_attributes = "ignore",
  require_equal = FALSE,
  store_original_data = FALSE
)

to_spatial_subdivision(x)

to_spatial_subset(x, ..., subset_by = NULL)

to_spatial_transformed(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial_morphers_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to other functions. See the description
of each morpher for details.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_simplify">simplify</code></td>
<td>
<p>Should the network be simplified after contraction? This
means that multiple edges and loop edges will be removed. Multiple edges
are introduced by contraction when there are several connections between
the same groups of nodes. Loop edges are introduced by contraction when
there are connections within a group. Note however that setting this to
<code>TRUE</code> also removes multiple edges and loop edges that already
existed before contraction. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_summarise_attributes">summarise_attributes</code></td>
<td>
<p>Whenever multiple features (i.e. nodes and/or
edges) are merged into a single feature during morphing, how should their
attributes be combined? Several options are possible, see
<code><a href="igraph.html#topic+igraph-attribute-combination">igraph-attribute-combination</a></code> for details.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_store_original_data">store_original_data</code></td>
<td>
<p>Whenever multiple features (i.e. nodes and/or
edges) are merged into a single feature during morphing, should the data of
the original features be stored as an attribute of the new feature, in a
column named <code>.orig_data</code>. This is in line with the design principles
of <code>tidygraph</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_node">node</code></td>
<td>
<p>The geospatial point for which the neighborhood will be
calculated. Can be an integer, referring to the index of the node for which
the neighborhood will be calculated. Can also be an object of class
<code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sf.html#topic+sfc">sfc</a></code>, containing a single feature.
In that case, this point will be snapped to its nearest node before
calculating the neighborhood. When multiple indices or features are given,
only the first one is taken.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_threshold">threshold</code></td>
<td>
<p>The threshold distance to be used. Only nodes within the
threshold distance from the reference node will be included in the
neighborhood. Should be a numeric value in the same units as the weight
values used for distance calculation.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_weights">weights</code></td>
<td>
<p>The edge weights used to calculate distances on the network.
Can be a numeric vector giving edge weights, or a column name referring to
an attribute column in the edges table containing those weights. If set to
<code>NULL</code>, the values of a column named <code>weight</code> in the edges table
will be used automatically, as long as this column is present. If not, the
geographic edge lengths will be calculated internally and used as weights.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_from">from</code></td>
<td>
<p>Should distances be calculated from the reference node towards
the other nodes? Defaults to <code>TRUE</code>. If set to <code>FALSE</code>, distances
will be calculated from the other nodes towards the reference node instead.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_remove_multiple">remove_multiple</code></td>
<td>
<p>Should multiple edges be merged into one. Defaults
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_remove_loops">remove_loops</code></td>
<td>
<p>Should loop edges be removed. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_protect">protect</code></td>
<td>
<p>Nodes to be protected from being removed, no matter if they
are a pseudo node or not. Can be given as a numeric vector containing node
indices or a character vector containing node names. Can also be a set of
geospatial features as object of class <code><a href="sf.html#topic+sf">sf</a></code> or
<code><a href="sf.html#topic+sfc">sfc</a></code>. In that case, for each of these features its nearest
node in the network will be protected. Defaults to <code>NULL</code>, meaning that
none of the nodes is protected.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_require_equal">require_equal</code></td>
<td>
<p>Should nodes only be removed when the attribute values
of their incident edges are equal? Defaults to <code>FALSE</code>. If <code>TRUE</code>,
only pseudo nodes that have incident edges with equal attribute values are
removed. May also be given as a vector of attribute names. In that case only
those attributes are checked for equality. Equality tests are evaluated
using the <code>==</code> operator.</p>
</td></tr>
<tr><td><code id="spatial_morphers_+3A_subset_by">subset_by</code></td>
<td>
<p>Whether to create subgraphs based on nodes or edges.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It also possible to create your own morphers. See the documentation
of <code><a href="tidygraph.html#topic+morph">morph</a></code> for the requirements for custom morphers.
</p>


<h3>Value</h3>

<p>Either a <code>morphed_sfnetwork</code>, which is a list of one or more
<code><a href="#topic+sfnetwork">sfnetwork</a></code> objects, or a <code>morphed_tbl_graph</code>, which is a
list of one or more <code><a href="tidygraph.html#topic+tbl_graph">tbl_graph</a></code> objects. See the
description of each morpher for details.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>to_spatial_contracted()</code>: Combine groups of nodes into a single node per
group. <code>...</code> is forwarded to <code><a href="dplyr.html#topic+group_by">group_by</a></code> to
create the groups. The centroid of the group of nodes will be used as
geometry of the contracted node. If edge are spatially explicit, edge
geometries are updated accordingly such that the valid spatial network
structure is preserved. Returns a <code>morphed_sfnetwork</code> containing a
single element of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.
</p>
</li>
<li> <p><code>to_spatial_directed()</code>: Make a network directed in the direction given
by the linestring geometries of the edges. Differs from
<code><a href="tidygraph.html#topic+to_directed">to_directed</a></code>, which makes a network directed based
on the node indices given in the <code>from</code> and <code>to</code> columns. In
undirected networks these indices may not correspond with the endpoints of
the linestring geometries. Returns a <code>morphed_sfnetwork</code> containing a
single element of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>. This morpher requires edges
to be spatially explicit. If not, use <code><a href="tidygraph.html#topic+to_directed">to_directed</a></code>.
</p>
</li>
<li> <p><code>to_spatial_explicit()</code>: Create linestring geometries between source
and target nodes of edges. If the edges data can be directly converted to
an object of class <code><a href="sf.html#topic+sf">sf</a></code> using <code><a href="sf.html#topic+st_as_sf">st_as_sf</a></code>,
extra arguments can be provided as <code>...</code> and will be forwarded to
<code><a href="sf.html#topic+st_as_sf">st_as_sf</a></code> internally. Otherwise, straight lines will be
drawn between the source and target node of each edge. Returns a
<code>morphed_sfnetwork</code> containing a single element of class
<code><a href="#topic+sfnetwork">sfnetwork</a></code>.
</p>
</li>
<li> <p><code>to_spatial_neighborhood()</code>: Limit a network to the spatial neighborhood of
a specific node. <code>...</code> is forwarded to
<code><a href="tidygraph.html#topic+node_distance_from">node_distance_from</a></code> (if <code>from</code> is <code>TRUE</code>)
or <code><a href="tidygraph.html#topic+node_distance_to">node_distance_to</a></code> (if <code>from</code> is
<code>FALSE</code>). Returns a <code>morphed_sfnetwork</code> containing a single
element of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.
</p>
</li>
<li> <p><code>to_spatial_shortest_paths()</code>: Limit a network to those nodes and edges that
are part of the shortest path between two nodes. <code>...</code> is evaluated in
the same manner as <code><a href="#topic+st_network_paths">st_network_paths</a></code> with
<code>type = 'shortest'</code>. Returns a <code>morphed_sfnetwork</code> that may
contain multiple elements of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>, depending on
the number of requested paths. When unmorphing only the first instance of
both the node and edge data will be used, as the the same node and/or edge
can be present in multiple paths.
</p>
</li>
<li> <p><code>to_spatial_simple()</code>: Remove loop edges and/or merges multiple edges
into a single edge. Multiple edges are edges that have the same source and
target nodes (in directed networks) or edges that are incident to the same
nodes (in undirected networks). When merging them into a single edge, the
geometry of the first edge is preserved. The order of the edges can be
influenced by calling <code><a href="dplyr.html#topic+arrange">arrange</a></code> before simplifying.
Returns a <code>morphed_sfnetwork</code> containing a single element of class
<code><a href="#topic+sfnetwork">sfnetwork</a></code>.
</p>
</li>
<li> <p><code>to_spatial_smooth()</code>: Construct a smoothed version of the network by
iteratively removing pseudo nodes, while preserving the connectivity of the
network. In the case of directed networks, pseudo nodes are those nodes that
have only one incoming and one outgoing edge. In undirected networks, pseudo
nodes are those nodes that have two incident edges. Equality of attribute
values among the two edges can be defined as an additional requirement by
setting the <code>require_equal</code> parameter. Connectivity of the
network is preserved by concatenating the incident edges of each removed
pseudo node. Returns a <code>morphed_sfnetwork</code> containing a single element
of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.
</p>
</li>
<li> <p><code>to_spatial_subdivision()</code>: Construct a subdivision of the network by
subdividing edges at each interior point that is equal to any
other interior or boundary point in the edges table. Interior points in this
sense are those points that are included in their linestring geometry
feature but are not endpoints of it, while boundary points are the endpoints
of the linestrings. The network is reconstructed after subdivision such that
edges are connected at the points of subdivision. Returns a
<code>morphed_sfnetwork</code> containing a single element of class
<code><a href="#topic+sfnetwork">sfnetwork</a></code>. This morpher requires edges to be spatially
explicit and nodes to be spatially unique (i.e. not more than one node at
the same spatial location).
</p>
</li>
<li> <p><code>to_spatial_subset()</code>: Subset the network by applying a spatial
filter, i.e. a filter on the geometry column based on a spatial predicate.
<code>...</code> is evaluated in the same manner as <code><a href="sf.html#topic+st_filter">st_filter</a></code>.
Returns a <code>morphed_sfnetwork</code> containing a single element of class
<code><a href="#topic+sfnetwork">sfnetwork</a></code>. For filters on an attribute column, use
<code><a href="tidygraph.html#topic+to_subgraph">to_subgraph</a></code>.
</p>
</li>
<li> <p><code>to_spatial_transformed()</code>: Transform the geospatial coordinates of the
network into a different coordinate reference system. <code>...</code> is
evaluated in the same manner as <code><a href="sf.html#topic+st_transform">st_transform</a></code>.
Returns a <code>morphed_sfnetwork</code> containing a single element of class
<code><a href="#topic+sfnetwork">sfnetwork</a></code>.
</p>
</li></ul>


<h3>See Also</h3>

<p>The vignette on
<a href="https://luukvdmeer.github.io/sfnetworks/articles/sfn05_morphers.html">spatial morphers</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf, quietly = TRUE)
library(tidygraph, quietly = TRUE)

net = as_sfnetwork(roxel, directed = FALSE) %&gt;%
  st_transform(3035)

# Temporary changes with morph and unmorph.
net %&gt;%
 activate("edges") %&gt;%
 mutate(weight = edge_length()) %&gt;%
 morph(to_spatial_shortest_paths, from = 1, to = 10) %&gt;%
 mutate(in_paths = TRUE) %&gt;%
 unmorph()

# Lasting changes with convert.
net %&gt;%
 activate("edges") %&gt;%
 mutate(weight = edge_length()) %&gt;%
 convert(to_spatial_shortest_paths, from = 1, to = 10)

</code></pre>

<hr>
<h2 id='spatial_node_predicates'>Query nodes with spatial predicates</h2><span id='topic+spatial_node_predicates'></span><span id='topic+node_intersects'></span><span id='topic+node_is_disjoint'></span><span id='topic+node_touches'></span><span id='topic+node_is_within'></span><span id='topic+node_equals'></span><span id='topic+node_is_covered_by'></span><span id='topic+node_is_within_distance'></span>

<h3>Description</h3>

<p>These functions allow to interpret spatial relations between nodes and
other geospatial features directly inside <code><a href="tidygraph.html#topic+filter">filter</a></code>
and <code><a href="tidygraph.html#topic+mutate">mutate</a></code> calls. All functions return a logical
vector of the same length as the number of nodes in the network. Element i
in that vector is <code>TRUE</code> whenever <code>any(predicate(x[i], y[j]))</code> is
<code>TRUE</code>. Hence, in the case of using <code>node_intersects</code>, element i
in the returned vector is <code>TRUE</code> when node i intersects with any of
the features given in y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_intersects(y, ...)

node_is_disjoint(y, ...)

node_touches(y, ...)

node_is_within(y, ...)

node_equals(y, ...)

node_is_covered_by(y, ...)

node_is_within_distance(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial_node_predicates_+3A_y">y</code></td>
<td>
<p>The geospatial features to test the nodes against, either as an
object of class <code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sf.html#topic+sfc">sfc</a></code>.</p>
</td></tr>
<tr><td><code id="spatial_node_predicates_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the corresponding spatial predicate
function of sf. See <code><a href="sf.html#topic+geos_binary_pred">geos_binary_pred</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="sf.html#topic+geos_binary_pred">geos_binary_pred</a></code> for details on each spatial
predicate. Just as with all query functions in tidygraph, these functions
are meant to be called inside tidygraph verbs such as
<code><a href="tidygraph.html#topic+mutate">mutate</a></code> or <code><a href="tidygraph.html#topic+filter">filter</a></code>, where
the network that is currently being worked on is known and thus not needed
as an argument to the function. If you want to use an algorithm outside of
the tidygraph framework you can use <code><a href="tidygraph.html#topic+with_graph">with_graph</a></code> to
set the context temporarily while the algorithm is being evaluated.
</p>


<h3>Value</h3>

<p>A logical vector of the same length as the number of nodes in the
network.
</p>


<h3>Note</h3>

<p>Note that <code>node_is_within_distance</code> is a wrapper around the
<code>st_is_within_distance</code> predicate from sf. Hence, it is based on
'as-the-crow-flies' distance, and not on distances over the network. For
distances over the network, use <code><a href="tidygraph.html#topic+node_distance_to">node_distance_to</a></code>
with edge lengths as weights argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf, quietly = TRUE)
library(tidygraph, quietly = TRUE)

# Create a network.
net = as_sfnetwork(roxel) %&gt;%
  st_transform(3035)

# Create a geometry to test against.
p1 = st_point(c(4151358, 3208045))
p2 = st_point(c(4151340, 3207520))
p3 = st_point(c(4151756, 3207506))
p4 = st_point(c(4151774, 3208031))

poly = st_multipoint(c(p1, p2, p3, p4)) %&gt;%
  st_cast('POLYGON') %&gt;%
  st_sfc(crs = 3035)

# Use predicate query function in a filter call.
within = net %&gt;%
  activate("nodes") %&gt;%
  filter(node_is_within(poly))

disjoint = net %&gt;%
  activate("nodes") %&gt;%
  filter(node_is_disjoint(poly))
oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1))
plot(net)
plot(within, col = "red", add = TRUE)
plot(disjoint, col = "blue", add = TRUE)
par(oldpar)

# Use predicate query function in a mutate call.
net %&gt;%
  activate("nodes") %&gt;%
  mutate(within = node_is_within(poly)) %&gt;%
  select(within)

</code></pre>

<hr>
<h2 id='st_network_bbox'>Get the bounding box of a spatial network</h2><span id='topic+st_network_bbox'></span>

<h3>Description</h3>

<p>A spatial network specific bounding box extractor, returning the combined
bounding box of the nodes and edges in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_network_bbox(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_network_bbox_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="st_network_bbox_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="sf.html#topic+st_bbox">st_bbox</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="sf.html#topic+st_bbox">st_bbox</a></code> for details.
</p>


<h3>Value</h3>

<p>The bounding box of the network as an object of class
<code><a href="sf.html#topic+st_bbox">bbox</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)

# Create a network.
node1 = st_point(c(8, 51))
node2 = st_point(c(7, 51.5))
node3 = st_point(c(8, 52))
node4 = st_point(c(9, 51))
edge1 = st_sfc(st_linestring(c(node1, node2, node3)))

nodes = st_as_sf(c(st_sfc(node1), st_sfc(node3), st_sfc(node4)))
edges = st_as_sf(edge1)
edges$from = 1
edges$to = 2

net = sfnetwork(nodes, edges)

# Create bounding boxes for nodes, edges and the whole network.
node_bbox = st_bbox(activate(net, "nodes"))
node_bbox
edge_bbox = st_bbox(activate(net, "edges"))
edge_bbox
net_bbox = st_network_bbox(net)
net_bbox

# Plot.
oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1), mfrow = c(1,2))
plot(net, lwd = 2, cex = 4, main = "Element bounding boxes")
plot(st_as_sfc(node_bbox), border = "red", lty = 2, lwd = 4, add = TRUE)
plot(st_as_sfc(edge_bbox), border = "blue", lty = 2, lwd = 4, add = TRUE)
plot(net, lwd = 2, cex = 4, main = "Network bounding box")
plot(st_as_sfc(net_bbox), border = "red", lty = 2, lwd = 4, add = TRUE)
par(oldpar)

</code></pre>

<hr>
<h2 id='st_network_blend'>Blend geospatial points into a spatial network</h2><span id='topic+st_network_blend'></span>

<h3>Description</h3>

<p>Blending a point into a network is the combined process of first snapping
the given point to its nearest point on its nearest edge in the network,
subsequently splitting that edge at the location of the snapped point, and
finally adding the snapped point as node to the network. If the location
of the snapped point is already a node in the network, the attributes of the
point (if any) will be joined to that node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_network_blend(x, y, tolerance = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_network_blend_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="st_network_blend_+3A_y">y</code></td>
<td>
<p>The spatial features to be blended, either as object of class
<code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sf.html#topic+sfc">sfc</a></code>, with <code>POINT</code> geometries.</p>
</td></tr>
<tr><td><code id="st_network_blend_+3A_tolerance">tolerance</code></td>
<td>
<p>The tolerance distance to be used. Only features that are
at least as close to the network as the tolerance distance will be blended.
Should be a non-negative number preferably given as an object of class
<code><a href="units.html#topic+units">units</a></code>. Otherwise, it will be assumed that the unit is
meters. If set to <code>Inf</code> all features will be blended. Defaults to
<code>Inf</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two important details to be aware of. Firstly: when the
snap locations of multiple points are equal, only the first of these points
is blended into the network. By arranging <code>y</code> before blending you can
influence which (type of) point is given priority in such cases.
Secondly: when the snap location of a point intersects with multiple edges,
it is only blended into the first of these edges. You might want to run the
<code><a href="#topic+to_spatial_subdivision">to_spatial_subdivision</a></code> morpher after blending, such that
intersecting but unconnected edges get connected.
</p>


<h3>Value</h3>

<p>The blended network as an object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.
</p>


<h3>Note</h3>

<p>Due to internal rounding of rational numbers, it may occur that the
intersection point between a line and a point is not evaluated as
actually intersecting that line by the designated algorithm. Instead, the
intersection point lies a tiny-bit away from the edge. Therefore, it is
recommended to set the tolerance to a very small number (for example 1e-5)
even if you only want to blend points that intersect the line.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf, quietly = TRUE)

# Create a network and a set of points to blend.
n11 = st_point(c(0,0))
n12 = st_point(c(1,1))
e1 = st_sfc(st_linestring(c(n11, n12)), crs = 3857)

n21 = n12
n22 = st_point(c(0,2))
e2 = st_sfc(st_linestring(c(n21, n22)), crs = 3857)

n31 = n22
n32 = st_point(c(-1,1))
e3 = st_sfc(st_linestring(c(n31, n32)), crs = 3857)

net = as_sfnetwork(c(e1,e2,e3))

pts = net %&gt;%
  st_bbox() %&gt;%
  st_as_sfc() %&gt;%
  st_sample(10, type = "random") %&gt;%
  st_set_crs(3857) %&gt;%
  st_cast('POINT')

# Blend points into the network.
# --&gt; By default tolerance is set to Inf
# --&gt; Meaning that all points get blended
b1 = st_network_blend(net, pts)
b1

# Blend points with a tolerance.
tol = units::set_units(0.2, "m")
b2 = st_network_blend(net, pts, tolerance = tol)
b2

## Plot results.
# Initial network and points.
oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1), mfrow = c(1,3))
plot(net, cex = 2, main = "Network + set of points")
plot(pts, cex = 2, col = "red", pch = 20, add = TRUE)

# Blend with no tolerance
plot(b1, cex = 2, main = "Blend with tolerance = Inf")
plot(pts, cex = 2, col = "red", pch = 20, add = TRUE)

# Blend with tolerance.
within = st_is_within_distance(pts, st_geometry(net, "edges"), tol)
pts_within = pts[lengths(within) &gt; 0]
plot(b2, cex = 2, main = "Blend with tolerance = 0.2 m")
plot(pts, cex = 2, col = "grey", pch = 20, add = TRUE)
plot(pts_within, cex = 2, col = "red", pch = 20, add = TRUE)
par(oldpar)

</code></pre>

<hr>
<h2 id='st_network_cost'>Compute a cost matrix of a spatial network</h2><span id='topic+st_network_cost'></span>

<h3>Description</h3>

<p>Wrapper around <code><a href="igraph.html#topic+distances">distances</a></code> to calculate costs of
pairwise shortest paths between points in a spatial network. It allows to
provide any set of geospatial point as <code>from</code> and <code>to</code> arguments.
If such a geospatial point is not equal to a node in the network, it will
be snapped to its nearest node before calculating costs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_network_cost(
  x,
  from = igraph::V(x),
  to = igraph::V(x),
  weights = NULL,
  direction = "out",
  Inf_as_NaN = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_network_cost_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="st_network_cost_+3A_from">from</code></td>
<td>
<p>The (set of) geospatial point(s) from which the shortest paths
will be calculated. Can be an object of  class <code><a href="sf.html#topic+sf">sf</a></code> or
<code><a href="sf.html#topic+sfc">sfc</a></code>.
Alternatively it can be a numeric vector containing the indices of the nodes
from which the shortest paths will be calculated, or a character vector
containing the names of the nodes from which the shortest paths will be
calculated. By default, all nodes in the network are included.</p>
</td></tr>
<tr><td><code id="st_network_cost_+3A_to">to</code></td>
<td>
<p>The (set of) geospatial point(s) to which the shortest paths will
be calculated. Can be an object of class <code><a href="sf.html#topic+sf">sf</a></code> or
<code><a href="sf.html#topic+sfc">sfc</a></code>.
Alternatively it can be a numeric vector containing the indices of the nodes
to which the shortest paths will be calculated, or a character vector
containing the names of the nodes to which the shortest paths will be
calculated. Duplicated values will be removed before calculating the cost
matrix. By default, all nodes in the network are included.</p>
</td></tr>
<tr><td><code id="st_network_cost_+3A_weights">weights</code></td>
<td>
<p>The edge weights to be used in the shortest path calculation.
Can be a numeric vector giving edge weights, or a column name referring to
an attribute column in the edges table containing those weights. If set to
<code>NULL</code>, the values of a column named <code>weight</code> in the edges table
will be used automatically, as long as this column is present. If not, the
geographic edge lengths will be calculated internally and used as weights.
If set to <code>NA</code>, no weights are used, even if the edges have a
<code>weight</code> column.</p>
</td></tr>
<tr><td><code id="st_network_cost_+3A_direction">direction</code></td>
<td>
<p>The direction of travel. Defaults to <code>'out'</code>, meaning
that the direction given by the network is followed and costs are calculated
from the points given as argument <code>from</code>. May be set to <code>'in'</code>,
meaning that the opposite direction is followed an costs are calculated
towards the points given as argument <code>from</code>. May also be set to
<code>'all'</code>, meaning that the network is considered to be undirected. This
argument is ignored for undirected networks.</p>
</td></tr>
<tr><td><code id="st_network_cost_+3A_inf_as_nan">Inf_as_NaN</code></td>
<td>
<p>Should the cost values of unconnected nodes be stored as
<code>NaN</code> instead of <code>Inf</code>? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="st_network_cost_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="igraph.html#topic+distances">distances</a></code>. Argument
<code>mode</code> is ignored. Use <code>direction</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spatial features provided to the <code>from</code> and/or
<code>to</code> argument don't necessarily have to be points. Internally, the
nearest node to each feature is found by calling
<code><a href="sf.html#topic+st_nearest_feature">st_nearest_feature</a></code>, so any feature with a geometry type
that is accepted by that function can be provided as <code>from</code> and/or
<code>to</code> argument.
</p>
<p>When directly providing integer node indices or character node names to the
<code>from</code> and/or <code>to</code> argument, keep the following in mind. A node
index should correspond to a row-number of the nodes table of the network.
A node name should correspond to a value of a column in the nodes table
named <code>name</code>. This column should contain character values without
duplicates.
</p>
<p>For more details on the wrapped function from <code><a href="igraph.html#topic+igraph">igraph</a></code>
see the <code><a href="igraph.html#topic+distances">distances</a></code> documentation page.
</p>


<h3>Value</h3>

<p>An n times m numeric matrix where n is the length of the <code>from</code>
argument, and m is the length of the <code>to</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+st_network_paths">st_network_paths</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf, quietly = TRUE)
library(tidygraph, quietly = TRUE)

# Create a network with edge lengths as weights.
# These weights will be used automatically in shortest paths calculation.
net = as_sfnetwork(roxel, directed = FALSE) %&gt;%
  st_transform(3035) %&gt;%
  activate("edges") %&gt;%
  mutate(weight = edge_length())

# Providing node indices.
st_network_cost(net, from = c(495, 121), to = c(495, 121))

# Providing nodes as spatial points.
# Points that don't equal a node will be snapped to their nearest node.
p1 = st_geometry(net, "nodes")[495] + st_sfc(st_point(c(50, -50)))
st_crs(p1) = st_crs(net)
p2 = st_geometry(net, "nodes")[121] + st_sfc(st_point(c(-10, 100)))
st_crs(p2) = st_crs(net)

st_network_cost(net, from = c(p1, p2), to = c(p1, p2))

# Using another column for weights.
net %&gt;%
  activate("edges") %&gt;%
  mutate(foo = runif(n(), min = 0, max = 1)) %&gt;%
  st_network_cost(c(p1, p2), c(p1, p2), weights = "foo")

# Not providing any from or to points includes all nodes by default.
with_graph(net, graph_order()) # Our network has 701 nodes.
cost_matrix = st_network_cost(net)
dim(cost_matrix)

</code></pre>

<hr>
<h2 id='st_network_join'>Join two spatial networks based on equality of node geometries</h2><span id='topic+st_network_join'></span>

<h3>Description</h3>

<p>A spatial network specific join function which makes a spatial full join on
the geometries of the nodes data, based on the <code><a href="sf.html#topic+st_equals">st_equals</a></code>
spatial predicate. Edge data are combined using a
<code><a href="dplyr.html#topic+bind_rows">bind_rows</a></code> semantic, meaning that data are matched by
column name and values are filled with <code>NA</code> if missing in either of
the networks. The <code>from</code> and <code>to</code> columns in the edge data are
updated such that they match the new node indices of the resulting network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_network_join(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_network_join_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="st_network_join_+3A_y">y</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>, or directly convertible
to it using <code><a href="#topic+as_sfnetwork">as_sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="st_network_join_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="tidygraph.html#topic+graph_join">graph_join</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The joined networks as an object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf, quietly = TRUE)

node1 = st_point(c(0, 0))
node2 = st_point(c(1, 0))
node3 = st_point(c(1,1))
node4 = st_point(c(0,1))
edge1 = st_sfc(st_linestring(c(node1, node2)))
edge2 = st_sfc(st_linestring(c(node2, node3)))
edge3 = st_sfc(st_linestring(c(node3, node4)))

net1 = as_sfnetwork(c(edge1, edge2))
net2 = as_sfnetwork(c(edge2, edge3))

joined = st_network_join(net1, net2)
joined

## Plot results.
oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1), mfrow = c(1,2))
plot(net1, pch = 15, cex = 2, lwd = 4)
plot(net2, col = "red", pch = 18, cex = 2, lty = 3, lwd = 4, add = TRUE)
plot(joined, cex = 2, lwd = 4)
par(oldpar)

</code></pre>

<hr>
<h2 id='st_network_paths'>Paths between points in geographical space</h2><span id='topic+st_network_paths'></span>

<h3>Description</h3>

<p>Combined wrapper around <code><a href="igraph.html#topic+shortest_paths">shortest_paths</a></code>,
<code><a href="igraph.html#topic+all_shortest_paths">all_shortest_paths</a></code> and
<code><a href="igraph.html#topic+all_simple_paths">all_simple_paths</a></code> from <code><a href="igraph.html#topic+igraph">igraph</a></code>,
allowing to provide any geospatial point as <code>from</code> argument and any
set of geospatial points as <code>to</code> argument. If such a geospatial point
is not equal to a node in the network, it will be snapped to its nearest
node before calculating the shortest or simple paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_network_paths(
  x,
  from,
  to = igraph::V(x),
  weights = NULL,
  type = "shortest",
  use_names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_network_paths_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+sfnetwork">sfnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="st_network_paths_+3A_from">from</code></td>
<td>
<p>The geospatial point from which the paths will be
calculated. Can be an object an object of class <code><a href="sf.html#topic+sf">sf</a></code> or
<code><a href="sf.html#topic+sfc">sfc</a></code>, containing a single feature. When multiple features
are given, only the first one is used.
Alternatively, it can be an integer, referring to the index of the
node from which the paths will be calculated, or a character,
referring to the name of the node from which the paths will be
calculated.</p>
</td></tr>
<tr><td><code id="st_network_paths_+3A_to">to</code></td>
<td>
<p>The (set of) geospatial point(s) to which the paths will be
calculated. Can be an object of  class <code><a href="sf.html#topic+sf">sf</a></code> or
<code><a href="sf.html#topic+sfc">sfc</a></code>.
Alternatively it can be a numeric vector containing the indices of the nodes
to which the paths will be calculated, or a character vector
containing the names of the nodes to which the paths will be
calculated. By default, all nodes in the network are included.</p>
</td></tr>
<tr><td><code id="st_network_paths_+3A_weights">weights</code></td>
<td>
<p>The edge weights to be used in the shortest path calculation.
Can be a numeric vector giving edge weights, or a column name referring to
an attribute column in the edges table containing those weights. If set to
<code>NULL</code>, the values of a column named <code>weight</code> in the edges table
will be used automatically, as long as this column is present. If not, the
geographic edge lengths will be calculated internally and used as weights.
If set to <code>NA</code>, no weights are used, even if the edges have a
<code>weight</code> column. Ignored when <code>type = 'all_simple'</code>.</p>
</td></tr>
<tr><td><code id="st_network_paths_+3A_type">type</code></td>
<td>
<p>Character defining which type of path calculation should be
performed. If set to <code>'shortest'</code> paths are calculated using
<code><a href="igraph.html#topic+shortest_paths">shortest_paths</a></code>, if set to
<code>'all_shortest'</code> paths are calculated using
<code><a href="igraph.html#topic+all_shortest_paths">all_shortest_paths</a></code>, if set to
<code>'all_simple'</code> paths are calculated using
<code><a href="igraph.html#topic+all_simple_paths">all_simple_paths</a></code>. Defaults to <code>'shortest'</code>.</p>
</td></tr>
<tr><td><code id="st_network_paths_+3A_use_names">use_names</code></td>
<td>
<p>If a column named <code>name</code> is present in the nodes
table, should these names be used to encode the nodes in a path, instead of
the node indices? Defaults to <code>TRUE</code>. Ignored when the nodes table does
not have a column named <code>name</code>.</p>
</td></tr>
<tr><td><code id="st_network_paths_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the corresponding
<code><a href="igraph.html#topic+shortest_paths">igraph</a></code> or
<code><a href="igraph.html#topic+all_simple_paths">igraph</a></code> function. Arguments
<code>predecessors</code> and <code>inbound.edges</code> are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spatial features provided to the <code>from</code> and/or
<code>to</code> argument don't necessarily have to be points. Internally, the
nearest node to each feature is found by calling
<code><a href="sf.html#topic+st_nearest_feature">st_nearest_feature</a></code>, so any feature with a geometry type
that is accepted by that function can be provided as <code>from</code> and/or
<code>to</code> argument.
</p>
<p>When directly providing integer node indices or character node names to the
<code>from</code> and/or <code>to</code> argument, keep the following in mind. A node
index should correspond to a row-number of the nodes table of the network.
A node name should correspond to a value of a column in the nodes table
named <code>name</code>. This column should contain character values without
duplicates.
</p>
<p>For more details on the wrapped functions from <code><a href="igraph.html#topic+igraph">igraph</a></code>
see the <code><a href="igraph.html#topic+shortest_paths">shortest_paths</a></code> or
<code><a href="igraph.html#topic+all_simple_paths">all_simple_paths</a></code> documentation pages.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="tibble.html#topic+tbl_df">tbl_df</a></code> with one row per
returned path. Depending on the setting of the <code>type</code> argument,
columns can be <code>node_paths</code> (a list column with for each path the
ordered indices of nodes present in that path) and <code>edge_paths</code>
(a list column with for each path the ordered indices of edges present in
that path). <code>'all_shortest'</code> and <code>'all_simple'</code> return only
<code>node_paths</code>, while <code>'shortest'</code> returns both.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+st_network_cost">st_network_cost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf, quietly = TRUE)
library(tidygraph, quietly = TRUE)

# Create a network with edge lengths as weights.
# These weights will be used automatically in shortest paths calculation.
net = as_sfnetwork(roxel, directed = FALSE) %&gt;%
  st_transform(3035) %&gt;%
  activate("edges") %&gt;%
  mutate(weight = edge_length())

# Providing node indices.
paths = st_network_paths(net, from = 495, to = 121)
paths

node_path = paths %&gt;%
  slice(1) %&gt;%
  pull(node_paths) %&gt;%
  unlist()
node_path

oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1))
plot(net, col = "grey")
plot(slice(activate(net, "nodes"), node_path), col = "red", add = TRUE)
par(oldpar)

# Providing nodes as spatial points.
# Points that don't equal a node will be snapped to their nearest node.
p1 = st_geometry(net, "nodes")[495] + st_sfc(st_point(c(50, -50)))
st_crs(p1) = st_crs(net)
p2 = st_geometry(net, "nodes")[121] + st_sfc(st_point(c(-10, 100)))
st_crs(p2) = st_crs(net)

paths = st_network_paths(net, from = p1, to = p2)
paths

node_path = paths %&gt;%
  slice(1) %&gt;%
  pull(node_paths) %&gt;%
  unlist()
node_path

oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1))
plot(net, col = "grey")
plot(c(p1, p2), col = "black", pch = 8, add = TRUE)
plot(slice(activate(net, "nodes"), node_path), col = "red", add = TRUE)
par(oldpar)

# Using another column for weights.
net %&gt;%
  activate("edges") %&gt;%
  mutate(foo = runif(n(), min = 0, max = 1)) %&gt;%
  st_network_paths(p1, p2, weights = "foo")

# Obtaining all simple paths between two nodes.
# Beware, this function can take long when:
# --&gt; Providing a lot of 'to' nodes.
# --&gt; The network is large and dense.
net = as_sfnetwork(roxel, directed = TRUE)
st_network_paths(net, from = 1, to = 12, type = "all_simple")

# Obtaining all shortest paths between two nodes.
# Not using edge weights.
# Hence, a shortest path is the paths with the least number of edges.
st_network_paths(net, from = 5, to = 1, weights = NA, type = "all_shortest")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
