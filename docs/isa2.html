<!DOCTYPE html><html><head><title>Help for package isa2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {isa2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#isa2-package'><p>The isa package</p></a></li>
<li><a href='#generate.seeds'><p>Generate seed vectors for the Iterative Signature Algorithm</p></a></li>
<li><a href='#isa'><p>Iterative Signature Algorithm</p></a></li>
<li><a href='#isa.biclust'><p>Convert ISA modules to a Biclust class, as defined by the</p>
biclust package</a></li>
<li><a href='#isa.in.silico'><p>Generate in-silico input data for biclustering algorithms</p></a></li>
<li><a href='#isa.iterate'><p>The Iterative Signature Algorithm</p></a></li>
<li><a href='#isa.normalize'><p>Normalize input data for use with ISA</p></a></li>
<li><a href='#isa.option'><p>Options for the isa package</p></a></li>
<li><a href='#isa.sweep'><p>Create a hierarchical structure of ISA biclusters</p></a></li>
<li><a href='#isa.unique'><p>Filter out biclusters that are very similar to each other</p></a></li>
<li><a href='#plotModules'><p>Image plots of biclusters</p></a></li>
<li><a href='#ppa'><p>The Ping-Pong Algorithm</p></a></li>
<li><a href='#ppa.in.silico'><p>Generate in-silico input data for testing the PPA algorithm</p></a></li>
<li><a href='#ppa.iterate'><p>The Ping-Pong Algorithm</p></a></li>
<li><a href='#ppa.normalize'><p>Normalize input data for use with the PPA</p></a></li>
<li><a href='#ppa.unique'><p>Filter co-modules that are very similar to each other</p></a></li>
<li><a href='#robustness'><p>Robustness of ISA biclusters and PPA co-modules</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3.6</td>
</tr>
<tr>
<td>Title:</td>
<td>The Iterative Signature Algorithm</td>
</tr>
<tr>
<td>Author:</td>
<td>Gabor Csardi &lt;csardi.gabor@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gabor Csardi &lt;csardi.gabor@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The ISA is a biclustering algorithm that finds modules 
  in an input matrix. A module or bicluster is a block of the
  reordered input matrix.</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, lattice, stats, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph (&ge; 0.5.5), biclust</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-21 21:09:53 UTC; gaborcsardi</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gaborcsardi/ISA">https://github.com/gaborcsardi/ISA</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gaborcsardi/ISA/issues">https://github.com/gaborcsardi/ISA/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-21 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='isa2-package'>The isa package</h2><span id='topic+isa2-package'></span>

<h3>Description</h3>

<p>The Iterative Signature Algorithm</p>


<h3>Introduction</h3>

<p>The Iterative Signature Algorithm (ISA) is a biclustering
algorithm. Biclustering algorithms classify simultaneously the rows
and columns of an input matrix into biclusters, or as we will call
them here, modules.
</p>


<h3>For the impatient</h3>

<p>The easiest way to run ISA is to call the <code><a href="#topic+isa">isa</a></code> function
with your input matrix as the single argument. This does all steps of
a typical ISA work flow, with the default parameters.
</p>


<h3>ISA biclusters</h3>

<p>An ISA module is pair; a subset of the rows of the input matrix and a
subset of its columns. In other words, a bicluster is a block of the
reordered input matrix, where reordering means a permutation of both
the rows and columns. (Another bicluster might be block of the same
permuted input matrix or one after a different permutation.)
</p>
<p>The criteria of a good bicluster is that 1) its rows are significantly
different than the other rows, when we consider only the positions
defined by the columns of the same bicluster, and (symmetrically) 2)
its columns are significantly different than the other columns, when
we consider only the positions defined by the rows of the same
bicluster.
</p>
<p>In other words, the rows of the bicluster are correlated, but only on
the columns defined by the same bicluster; and the opposite is also
true, the columns of the bicluster are correlated, but only on the
rows defined by the same bicluster.
</p>
<p>ISA biclusters are soft, two biclusters may overlap in their 
rows, columns or even both. It is also possible that some rows and/or
columns of the input matrix are not found to be part of any ISA
biclusters. Depending on the stringency parameters, it might even
happen that ISA does not find any biclusters.  
</p>


<h3>ISA row and column scores</h3>

<p>ISA biclusters are not only soft, but every row and column in a given
bicluster has a score, a number between minus one and one. The further
this number is from zero, then stronger is the association of the
given row or column to the bicluster.
</p>


<h3>How ISA works</h3>

<p>ISA works in an iterative way. For an <code class="reqn">E (m\times n)</code>
input matrix it starts from seed vector <code class="reqn">r_0</code>, which is
typically a sparse 0/1 vector of length <code class="reqn">m</code>. This defines a set of
rows in <code class="reqn">E</code>. Then <code class="reqn">E'</code> is multiplied by <code class="reqn">r_0</code> and the
result is thresholded. (Please see also &lsquo;Normalization&rsquo; below.)
</p>
<p>The thresholding is an important step of the ISA, without thresholding
ISA would be equivalent to a (not too effective) numerical singular
value decomposition (SVD). Currently thresholding is done by
calculating the mean and standard deviation of the vector and keeping
only elements that are further than a given number of standard
deviations from the mean. Based on the <code>direction</code> parameter,
this means 1) keeping values that are significantly higher than the
mean (<code>direction="up"</code>), significantly lower
(<code>direction="down"</code>) or both
(<code>direction="updown"</code>).
</p>
<p>The thresholded vector <code class="reqn">c_0</code> is the (column)
&lsquo;signature&rsquo; of <code class="reqn">r_0</code>. Then the (row) signature of
<code class="reqn">c_0</code> is calculated, <code class="reqn">E</code> is multiplied by
<code class="reqn">c_0</code> and then thresholded to get <code class="reqn">r_1</code>. 
</p>
<p>This iteration is performed until it converges, i.e. <code class="reqn">r_i</code>
and <code class="reqn">r_{i-1}</code> are &ldquo;close&rdquo;, and <code class="reqn">c_i</code> and
<code class="reqn">c_{i-1}</code> are also close. The convergence criteria,
i.e. what &ldquo;close&rdquo; means is by default defined by high Pearson
correlation.
</p>
<p>It is very possible that the ISA finds the same modules more than once;
two or more seeds might converge to the same module. The function
<code><a href="#topic+isa.unique">isa.unique</a></code> eliminates every module from the result of 
<code><a href="#topic+isa.iterate">isa.iterate</a></code> that is very similar (in terms of
Pearson correlation) to the one that was already found before it.
</p>


<h3>Parameters</h3>

<p>The two main parameters of ISA are the two thresholds (one for the
rows and one for the columns). They basically define the stringency of
the modules. If the row threshold is high, then the modules will have
very similar rows. If it is mild, then modules will be bigger, with
less similar rows than in the first case.
</p>


<h3>Random seeding and smart seeding</h3>

<p>By default (i.e. if the <code><a href="#topic+isa">isa</a></code> function is used) the ISA is
performed from random sparse starting seeds, generated by
<code><a href="#topic+generate.seeds">generate.seeds</a></code>. This way the algorithm is 
completely unsupervised, but also stochastic: it might give different
results for different runs.
</p>
<p>It is possible to use non-random seeds as well, if you have some
knowledge about the data or are interested in a particular subset of
rows/columns, then you can feed in your seeds into the
<code><a href="#topic+isa.iterate">isa.iterate</a></code> function directly. In this case the
algorithm is deterministic, for the same seed you will always get the
same results.
</p>


<h3>Normalization</h3>

<p>On in silico data we observed that ISA has the best performance if the
input matrix is normalized (see <code><a href="#topic+isa.normalize">isa.normalize</a></code>). The
normalization produces two matrices: <code class="reqn">E_r</code> and
<code class="reqn">E_c</code>. <code class="reqn">E_r</code> is calculated by transposing <code class="reqn">E</code> and
centering and scaling its rows (see <code><a href="base.html#topic+scale">scale</a></code>). <code class="reqn">E_c</code> is
calculated by centering and scaling the rows of <code class="reqn">E</code>. <code class="reqn">E_r</code> is
used to calculate the column signature of rows and <code class="reqn">E_c</code> is used
to calculate the signature of the columns.
</p>
<p>It is possible to use another normalization, then the user is
requested to supply the normalized input data in a named list,
including the two matrices of appropriate
dimensions. &lsquo;<code>Er</code>&rsquo; will be used for calculating the
signature of the rows, &lsquo;<code>Ec</code>&rsquo; the signature of the
columns. If you want to use the same matrix in both steps, then supply
it twice, the first one transposed.
</p>


<h3>Robustness</h3>

<p>As ISA is an unsupervised algorithm, it may very well find some
modules, even if you feed in noise as an input matrix. To avoid these
spurious modules we defined a robustness measure, a single number for
a modules that gives how well the rows and the columns are
correlated.
</p>
<p>It recommended that the user uses <code><a href="#topic+isa.filter.robust">isa.filter.robust</a></code> to
run ISA on the scrambled input matrix with the same threshold
parameters and then drop every module, which has a robustness score
lower than the highest robustness score among modules found in the
scrambled data.
</p>


<h3>A typical ISA work flow</h3>

<p>Please see the manual page and the source code of <code><a href="#topic+isa">isa</a></code>
for a typical ISA work flow. (You can obtain the source code by typing
&lsquo;<code>isa</code>&rsquo; (without the apostrophes) into your R prompt and
pressing ENTER.)
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a></p>


<h3>References</h3>

<p>Bergmann S, Ihmels J, Barkai N: Iterative signature algorithm for the
analysis of large-scale gene expression data <em>Phys Rev E Stat
Nonlin Soft Matter Phys.</em> 2003 Mar;67(3 Pt 1):031902. Epub 2003 Mar 11.
</p>
<p>Ihmels J, Friedlander G, Bergmann S, Sarig O, Ziv Y, Barkai N:
Revealing modular organization in the yeast transcriptional network
<em>Nat Genet.</em> 2002 Aug;31(4):370-7. Epub 2002 Jul 22
</p>
<p>Ihmels J, Bergmann S, Barkai N:
Defining transcription modules using large-scale gene expression data
<em>Bioinformatics</em> 2004 Sep 1;20(13):1993-2003. Epub 2004 Mar 25.
</p>


<h3>See Also</h3>

<p>The vignette in the package and <code><a href="#topic+isa">isa</a></code> for running ISA.
</p>

<hr>
<h2 id='generate.seeds'>Generate seed vectors for the Iterative Signature Algorithm</h2><span id='topic+generate.seeds'></span>

<h3>Description</h3>

<p>Generate random input seeds for the ISA.</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.seeds (length, count = 100, method = c("uni"), sparsity=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.seeds_+3A_length">length</code></td>
<td>
<p>The length of the seeds, should be the number of rows in
your input data for row seeds and the number of columns for column
seeds.</p>
</td></tr>
<tr><td><code id="generate.seeds_+3A_count">count</code></td>
<td>
<p>The number of seeds to gnerate.</p>
</td></tr>
<tr><td><code id="generate.seeds_+3A_method">method</code></td>
<td>
<p>The method for generating the seeds. Currently only
<code>"uni"</code> is supported, that picks the 1 elements in each seed
uniformly randomly.</p>
</td></tr>
<tr><td><code id="generate.seeds_+3A_sparsity">sparsity</code></td>
<td>
<p>A numeric scalar, an integer number giving the number
of non-zero values in each seed vector. It will be recycled to have
the same length as the number of seeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can generate a 0/1 matrix whose columns are the seeds of
the ISA. The result can be use as the <code>row.seeds</code> (or
<code>col.seeds</code>) argument of the <code><a href="#topic+isa.iterate">isa.iterate</a></code> function.
</p>


<h3>Value</h3>

<p>A numeric matrix with 0/1 values.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Bergmann S, Ihmels J, Barkai N: Iterative signature algorithm for the
analysis of large-scale gene expression data <em>Phys Rev E Stat
Nonlin Soft Matter Phys.</em> 2003 Mar;67(3 Pt 1):031902. Epub 2003 Mar 11.
</p>
<p>Ihmels J, Friedlander G, Bergmann S, Sarig O, Ziv Y, Barkai N:
Revealing modular organization in the yeast transcriptional network
<em>Nat Genet.</em> 2002 Aug;31(4):370-7. Epub 2002 Jul 22
</p>
<p>Ihmels J, Bergmann S, Barkai N:
Defining transcription modules using large-scale gene expression data
<em>Bioinformatics</em> 2004 Sep 1;20(13):1993-2003. Epub 2004 Mar 25.
</p>


<h3>See Also</h3>

 <p><a href="#topic+isa2-package">isa2-package</a> for a short introduction on the Iterative
Signature Algorithm. See <code><a href="#topic+isa">isa</a></code> for an easy way of running
ISA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Just to get always the same result
set.seed(24)

## Create some random seeds with different sparseness
data &lt;- isa.in.silico()
sparsity &lt;- rep( c(1,5,25,125), length=100)
row.seeds &lt;- generate.seeds(length=nrow(data[[1]]), count=100,
                            sparsity=sparsity)

## Do ISA with the seeds
normed.data &lt;- isa.normalize(data[[1]])
isaresult &lt;- isa.iterate(normed.data, thr.row=1, thr.col=1,
                         row.seeds=row.seeds)

## Add the sparsity to the seed data
isaresult$seeddata$sparsity &lt;- sparsity

## Check which ones leed to higher robustness scores
rob &lt;- robustness(normed.data, isaresult$rows, isaresult$columns)
tapply(rob, sparsity, mean)
## About the same

## How many unique modules did we find for the different sparsity
isaresult.unique &lt;- isa.unique(normed.data, isaresult)
tapply(seq_len(ncol(isaresult.unique$rows)),
       isaresult.unique$seeddata$sparsity, length)
## We usually find more modules with sparser seeds
</code></pre>

<hr>
<h2 id='isa'>Iterative Signature Algorithm</h2><span id='topic+isa'></span><span id='topic+isa+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Run ISA with the default parameters</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
isa(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isa_+3A_data">data</code></td>
<td>
<p>The input. It must be a numeric matrix. It may contain
<code>NA</code> and/or <code>NaN</code> values, but then the algorithm might be a
bit slower, as R matrix multiplication might be slower for these
matrices, depending on your platform.</p>
</td></tr>
<tr><td><code id="isa_+3A_...">...</code></td>
<td>
<p>Additional arguments, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please read the <a href="#topic+isa2-package">isa2-package</a> manual page for an introduction on
ISA.
</p>
<p>This function can be called as
</p>
<pre>
    isa(data, thr.row=seq(1,3,by=0.5),
        thr.col=seq(1,3,by=0.5), no.seeds=100,
        direction=c("updown", "updown"))
      </pre>
<p>where the arguments are:
</p>

<dl>
<dt>data</dt><dd><p>The input. It must be a numeric matrix. It may contain
<code>NA</code> and/or <code>NaN</code> values, but then the algorithm might be a
bit slower, as R matrix multiplication might be slower for these
matrices, depending on your platform.</p>
</dd>
<dt>thr.row</dt><dd><p>Numeric vector.
The row threshold parameters for which the ISA will be
run. We use all possible combinations of <code>thr.row</code> and
<code>thr.col</code>.</p>
</dd>
<dt>thr.col</dt><dd><p>Numeric vector.
The column threshold parameters for which the ISA will be run. We
use all possible combinations of <code>thr.row</code> and <code>thr.col</code>.
</p>
</dd>
<dt>no.seeds</dt><dd><p>Integer scalar, the number of seeds to use.</p>
</dd>
<dt>direction</dt><dd><p>Character vector of length two, one for the rows, one
for the columns. It specifies whether we are interested in
rows/columns that are higher (&lsquo;<code>up</code>&rsquo;) than average,
lower than average (&lsquo;<code>down</code>&rsquo;), or both
(&lsquo;<code>updown</code>&rsquo;).</p>
</dd>
</dl>

<p>The <code>isa</code> function provides an easy to use interface to the
ISA. It runs all steps of a typical ISA work flow with their default
parameters. 
</p>
<p>This involves:
</p>

<ol>
<li><p> Normalizing the data by calling <code><a href="#topic+isa.normalize">isa.normalize</a></code>.
</p>
</li>
<li><p> Generating random input seeds via
<code><a href="#topic+generate.seeds">generate.seeds</a></code>.
</p>
</li>
<li><p> Running ISA with all combinations of given row and column
thresholds, (by default 1, 1.5, 2, 2.5, 3); by calling
<code><a href="#topic+isa.iterate">isa.iterate</a></code>. 
</p>
</li>
<li><p> Merging similar modules, separately for each threshold
combination, by calling <code><a href="#topic+isa.unique">isa.unique</a></code>.
</p>
</li>
<li><p> Filtering the modules separately for each threshold combination,
by calling <code><a href="#topic+isa.filter.robust">isa.filter.robust</a></code>.
</p>
</li>
<li><p> Putting all modules from the runs with different thresholds into
a single object.
</p>
</li>
<li><p> Merging similar modules, across all threshold combinations, if
two modules are similar, then the larger one, the one with the
milder thresholds is kept.
</p>
</li></ol>

<p>Please see the manual pages of these functions for the details or if
you want to change their default parameters.
</p>


<h3>Value</h3>

<p>A named list is returned with the following elements:
</p>
<table>
<tr><td><code>rows</code></td>
<td>
<p>The row components in the biclusters, a numeric
matrix. Every column in it corresponds to a bicluster, if an
element (the score of the row) is non-zero, that means that the row
is included in the bicluster, otherwise it is not. Scores are
between -1 and 1. If the scores of two rows have the same (nonzero)
sign, that means that the two corresponding rows &ldquo;behave&rdquo; the
same way. If they have opposite sign, that means that they behave
the opposite way.
</p>
<p>If the corresponding seed has not converged during the allowed
number of iterations, then that column of <code>rows</code> contains
<code>NA</code> values.</p>
</td></tr>
<tr><td><code>columns</code></td>
<td>
<p>The column components of the biclusters, in the same
format as the rows.
</p>
<p>If the corresponding seed has not converged during the allowed
number of iterations, then that column of <code>columns</code> contains
<code>NA</code> values.</p>
</td></tr>
<tr><td><code>seeddata</code></td>
<td>
<p>A data frame containing information about the
biclusters. There is one row for each bicluster. The data frame has
the following columns:
</p>

<dl>
<dt><code>iterations</code></dt><dd><p>The number of iterations needed to
converge to the bicluster.</p>
</dd>
<dt><code>oscillation</code></dt><dd><p>The oscillation period for oscillating
biclusters. It is zero for non-oscillating ones.</p>
</dd>
<dt><code>thr.row</code></dt><dd><p>The row threshold that was used for find the
bicluster.</p>
</dd>
<dt><code>thr.col</code></dt><dd><p>The column threshold that was used for finding the
bicluster.</p>
</dd>
<dt><code>freq</code></dt><dd><p>The number of times the bicluster was found.</p>
</dd>
<dt><code>rob</code></dt><dd><p>The robustness score of the bicluster, see
<code><a href="#topic+robustness">robustness</a></code> for details.</p>
</dd>
<dt><code>rob.limit</code></dt><dd><p>The robustness limit that was used to filter the
module. See <code><a href="#topic+isa.filter.robust">isa.filter.robust</a></code> for details.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>rundata</code></td>
<td>
<p>A named list with information about the ISA runs. It
has the following entries:
</p>

<dl>
<dt><code>direction</code></dt><dd><p>Character vector of length two.
Specifies which side(s) of the score distribution
were kept in each ISA step. See the <code>direction</code> argument
of <code><a href="#topic+isa.iterate">isa.iterate</a></code> for details.</p>
</dd>
<dt><code>convergence</code></dt><dd><p>Character scalar. The convergence criteria for
the iteration. See the <code>convergence</code> argument of
<code><a href="#topic+isa.iterate">isa.iterate</a></code> for details.</p>
</dd>
<dt><code>eps</code></dt><dd><p>Numeric scalar. The threshold for convergence, if the
&lsquo;eps&rsquo; convergence criteria was used.</p>
</dd>
<dt><code>cor.limit</code></dt><dd><p>Numeric scalar. The threshold for convergence, if
the &lsquo;cor&rsquo; convergence criteria was used.</p>
</dd>
<dt><code>corx</code></dt><dd><p>Numeric scalar, the shift in number of
iterations, to check convergence. See the <code>convergence</code>
argument of <code><a href="#topic+isa.iterate">isa.iterate</a></code> for details.</p>
</dd>
<dt><code>maxiter</code></dt><dd><p>Numeric scalar. The maximum number of iterations
that were allowed for an input seed.</p>
</dd>
<dt><code>N</code></dt><dd><p>Numeric scalar. The total number of seeds that were used
for all the thresholds.</p>
</dd>
<dt><code>prenormalize</code></dt><dd><p>Logical scalar. Whether the data was
pre-normalized.</p>
</dd> 
<dt><code>hasNA</code></dt><dd><p>Logical scalar. Whether the (normalized) data had
<code>NA</code> or <code>NaN</code> values.</p>
</dd>
<dt><code>unique</code></dt><dd><p>Logical scalar. Whether the similar biclusters were
merged by calling <code><a href="#topic+isa.unique">isa.unique</a></code>.</p>
</dd>
<dt><code>oscillation</code></dt><dd><p>Logical scalar. Whether the algorithm looked
for oscillating modules as well.</p>
</dd> 
<dt><code>rob.perms</code></dt><dd><p>Numeric scalar, the number of permutations that
were used to calculate the baseline robustness for
filtering. See the <code>perms</code> argument of the
<code><a href="#topic+isa.filter.robust">isa.filter.robust</a></code> function for details.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Bergmann S, Ihmels J, Barkai N: Iterative signature algorithm for the
analysis of large-scale gene expression data <em>Phys Rev E Stat
Nonlin Soft Matter Phys.</em> 2003 Mar;67(3 Pt 1):031902. Epub 2003 Mar 11.
</p>
<p>Ihmels J, Friedlander G, Bergmann S, Sarig O, Ziv Y, Barkai N:
Revealing modular organization in the yeast transcriptional network
<em>Nat Genet.</em> 2002 Aug;31(4):370-7. Epub 2002 Jul 22
</p>
<p>Ihmels J, Bergmann S, Barkai N:
Defining transcription modules using large-scale gene expression data
<em>Bioinformatics</em> 2004 Sep 1;20(13):1993-2003. Epub 2004 Mar 25.
</p>


<h3>See Also</h3>

 <p><a href="#topic+isa2-package">isa2-package</a> for a short introduction on the Iterative
Signature Algorithm. See the functions mentioned above if you want to
change the default ISA parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## We generate some noisy in-silico data with modules and try to find
## them with the ISA. This might take one or two minutes.
data &lt;- isa.in.silico(noise=0.1)
isa.result &lt;- isa(data[[1]])

## Find the best bicluster for each block in the input
best &lt;- apply(cor(isa.result$rows, data[[2]]), 2, which.max)

## Check correlation
sapply(seq_along(best),
       function(x) cor(isa.result$rows[,best[x]], data[[2]][,x]))

## The same for the columns
sapply(seq_along(best),
       function(x) cor(isa.result$columns[,best[x]], data[[3]][,x]))

## Plot the data and the modules found
if (interactive()) {
  layout(rbind(1:2,3:4))
  image(data[[1]], main="In-silico data")
  sapply(best, function(b) image(outer(isa.result$rows[,b],
                                       isa.result$columns[,b]),
                                 main=paste("Module", b)))  
}

## End(Not run)
</code></pre>

<hr>
<h2 id='isa.biclust'>Convert ISA modules to a Biclust class, as defined by the
biclust package</h2><span id='topic+isa.biclust'></span>

<h3>Description</h3>

<p>This function converts the object with ISA modules to a <code>Biclust</code>
object, so all the functions in the <code>biclust</code> package can be used
on it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isa.biclust(modules)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isa.biclust_+3A_modules">modules</code></td>
<td>
<p>The ISA modules, as returned by the <code>isa</code> or some
other function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>biclust</code> is an R package that implements many biclustering
algorithms in a unified framework. This function converts a set of ISA
biclusters to a <code>Biclust</code> object, this class is used to store all
biclustering results by the <code>biclust</code> package.
</p>
<p>The <code>Biclust</code> class only supports binary biclusters, so the ISA
modules are binarized during the conversion.
</p>


<h3>Value</h3>

<p>A <code>Biclust</code> object.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## You need the biclust package for this
## Not run: 
if (require(biclust)) {
  set.seed(1)
  data &lt;- isa.in.silico()
  modules &lt;- isa(data[[1]])
  bc &lt;- isa.biclust(modules)

  ## A heatmap
  drawHeatmap(data[[1]], bc, 1)

  ## A "bubble" plot
  bubbleplot(data[[1]], bc)

  ## Compare values inside and outside the bicluster
  plotclust(bc, data[[1]])

  ## Plot profiles of bicluster elements
  parallelCoordinates(data[[1]], bc, number=1)

  ## Coherence measures vs. ISA robustness
  cV &lt;- sapply(seq(bc@Number), function(x)
     constantVariance(data[[1]], bc, x, dimension="both"))
  aV &lt;- sapply(seq(bc@Number), function(x)
     additiveVariance(data[[1]], bc, x, dimension="both"))
  mV &lt;- sapply(seq(bc@Number), function(x)
     multiplicativeVariance(data[[1]], bc, x, dimension="both"))
  sV &lt;- sapply(seq(bc@Number), function(x)
     signVariance(data[[1]], bc, x, dimension="both"))

  rob &lt;- robustness(isa.normalize(data[[1]]), modules$rows,
     modules$columns)

  cor( cbind(cV, aV, mV, sV, rob) )
}

## End(Not run)
</code></pre>

<hr>
<h2 id='isa.in.silico'>Generate in-silico input data for biclustering algorithms</h2><span id='topic+isa.in.silico'></span>

<h3>Description</h3>

<p>This function generates a test data set for ISA, containing
modules of prescribed number, size, signal level, internal noise and
background noise. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isa.in.silico (num.rows = 300, num.cols = 50, num.fact = 3,
     mod.row.size = round(0.5 * num.rows/num.fact), 
     mod.col.size = round(0.5 * num.cols/num.fact), noise = 0.1,                 
     mod.signal = rep(1, num.fact), mod.noise = rep(0, num.fact),                
     overlap.row = 0, overlap.col = overlap.row)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isa.in.silico_+3A_num.rows">num.rows</code></td>
<td>
<p>The number of rows in the data matrix.</p>
</td></tr>
<tr><td><code id="isa.in.silico_+3A_num.cols">num.cols</code></td>
<td>
<p>The number of columns in the data matrix.</p>
</td></tr>
<tr><td><code id="isa.in.silico_+3A_num.fact">num.fact</code></td>
<td>
<p>The number of modules to put into the data.</p>
</td></tr>
<tr><td><code id="isa.in.silico_+3A_mod.row.size">mod.row.size</code></td>
<td>
<p>The size of the modules, the number of rows per
module. It can be a scalar or a vector and it is recycled.</p>
</td></tr>
<tr><td><code id="isa.in.silico_+3A_mod.col.size">mod.col.size</code></td>
<td>
<p>The size of the modules, the number of columns per
module. It can be a scalar or a vector and it is recycled.</p>
</td></tr>
<tr><td><code id="isa.in.silico_+3A_noise">noise</code></td>
<td>
<p>The level of the background noise to be added to the data
matrix. It gives the standard deviation of the normal distribution
from which the noise is generated.</p>
</td></tr>
<tr><td><code id="isa.in.silico_+3A_mod.signal">mod.signal</code></td>
<td>
<p>The signal level of the modules.</p>
</td></tr>
<tr><td><code id="isa.in.silico_+3A_mod.noise">mod.noise</code></td>
<td>
<p>The noise levels of the different modules. Normally
distributed noise with standard deviation <code>mod.noise</code> is added
to the data. This is in addition to the background noise.</p>
</td></tr>
<tr><td><code id="isa.in.silico_+3A_overlap.row">overlap.row</code></td>
<td>
<p>The overlap of the modules, for the rows.
Zero means no overlap, one means one overlapping row, etc.</p>
</td></tr> 
<tr><td><code id="isa.in.silico_+3A_overlap.col">overlap.col</code></td>
<td>
<p>The overlap of the modules, for the columns.
Zero means no overlap, one means one overlapping column, etc.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>isa.in.silico</code> creates an artificial data set to test the ISA or
any other biclustering algorithm. It creates a data matrix with a
checkerboard matrix. In other words, potentially overlapping blocks
are planted into a noisy background matrix.
</p>
<p>These blocks may have different signal and noise levels and they might
also overlap. See the parameters above.
</p>


<h3>Value</h3>

<p>A list with three matrices. The first matrix is the in silico data,
the second contains the rows of the correct modules, the third the
columns.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Bergmann S, Ihmels J, Barkai N: Iterative signature algorithm for the
analysis of large-scale gene expression data <em>Phys Rev E Stat
Nonlin Soft Matter Phys.</em> 2003 Mar;67(3 Pt 1):031902. Epub 2003 Mar 11.
</p>
<p>Ihmels J, Friedlander G, Bergmann S, Sarig O, Ziv Y, Barkai N:
Revealing modular organization in the yeast transcriptional network
<em>Nat Genet.</em> 2002 Aug;31(4):370-7. Epub 2002 Jul 22
</p>
<p>Ihmels J, Bergmann S, Barkai N:
Defining transcription modules using large-scale gene expression data
<em>Bioinformatics</em> 2004 Sep 1;20(13):1993-2003. Epub 2004 Mar 25.
</p>


<h3>See Also</h3>

 <p><a href="#topic+isa2-package">isa2-package</a> for a short introduction on the Iterative
Signature Algorithm. See <code><a href="#topic+isa">isa</a></code> for an easy way of running
ISA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define a function for plotting if we are interactive
if (interactive()) { layout( rbind(1:2,3:4) ) }
myimage &lt;- function(mat) {
  if (interactive()) { par(mar=c(1,2,2,1)); image(mat[[1]]) }
}

## Create a simple checkerboard without overlap and noise
silico1 &lt;- isa.in.silico(100, 100, 10, mod.row.size=10, mod.col.size=10,
                         noise=0)
myimage(silico1)

## The same, but with some overlap and noise
silico2 &lt;- isa.in.silico(100, 100, 10, mod.row.size=10, mod.col.size=10,
                         noise=0.1, overlap.row=3)
myimage(silico2)

## Modules with different noise levels
silico3 &lt;- isa.in.silico(100, 100, 5, mod.row.size=10, mod.col.size=10,
                         noise=0.01, mod.noise=seq(0.1,by=0.1,length=5))
myimage(silico3)

## Modules with different signal levels
silico4 &lt;- isa.in.silico(100, 100, 5, mod.row.size=10, mod.col.size=10,
                         noise=0.01, mod.signal=seq(1,5,length=5))
myimage(silico4)
</code></pre>

<hr>
<h2 id='isa.iterate'>The Iterative Signature Algorithm</h2><span id='topic+isa.iterate'></span><span id='topic+isa.iterate+2Clist-method'></span>

<h3>Description</h3>

<p>Perform ISA on the (normalized) input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
isa.iterate(normed.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isa.iterate_+3A_normed.data">normed.data</code></td>
<td>
<p>The normalized data. A list of two matrices,
usually coming from <code><a href="#topic+isa.normalize">isa.normalize</a></code>.</p>
</td></tr>
<tr><td><code id="isa.iterate_+3A_...">...</code></td>
<td>
<p>Additional arguments, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>isa.iterate</code> performs the ISA iteration on the specified input
seeds. It can be called as 
</p>
<pre>
    isa.iterate(normed.data, row.seeds, col.seeds,
                thr.row, thr.col = thr.row,
		direction = c("updown", "updown"),
		convergence = c("corx", "cor", "eps"),
		cor.limit = 0.99, eps = 1e-04, corx=3,
		oscillation = FALSE, maxiter = 100)
	      </pre>
<p>where the arguments are:
</p>

<dl>
<dt>normed.data</dt><dd><p>The normalized data. A list of two matrices,
usually coming from <code><a href="#topic+isa.normalize">isa.normalize</a></code>.</p>
</dd>
<dt>row.seeds</dt><dd><p>The row seed vectors to start the ISA runs
from. Every column is a seed vector. (If this argument and
<code>col.seeds</code> are both present, then both of them are used.)</p>
</dd>
<dt>col.seeds</dt><dd><p>The column seed vectors to start the ISA runs from,
every column is a seed vector. (If this argument and
<code>row.seeds</code> are both present, then both of them are used.)</p>
</dd>
<dt>thr.row</dt><dd><p>Numeric scalar or vector giving the threshold parameter
for the rows. Higher values indicate a more stringent threshold and
the result biclusters will contain less rows on average. The
threshold is measured by the number of standard deviations from the
mean, over the values of the row vector. If it is a vector then it
must contain an entry for each seed.</p>
</dd>
<dt>thr.col</dt><dd><p>Numeric scalar or vector giving the threshold parameter
for the columns. The analogue of <code>thr.row</code>.</p>
</dd>
<dt>direction</dt><dd><p>Character vector of length two, one for the rows, one
for the columns. It specifies whether we are interested in
rows/columns that are higher (&lsquo;<code>up</code>&rsquo;) than average,
lower than average (&lsquo;<code>down</code>&rsquo;), or both
(&lsquo;<code>updown</code>&rsquo;).</p>
</dd>
<dt>convergence</dt><dd><p>Character scalar, the convergence criteria for the
ISA iteration. If it is &lsquo;<code>cor</code>&rsquo;, then convergence is
measured based on high Pearson correlation (see the <code>cor.limit</code>
argument below) of the subsequent row and
column vectors. If it is &lsquo;<code>eps</code>&rsquo;, then all entries of
the subsequent row and column vectors must be close to each other,
see the <code>eps</code> argument below.
</p>
<p>&lsquo;<code>corx</code>&rsquo; is similar to &lsquo;<code>cor</code>&rsquo;, but the
current row/column vectors are compared to the ones <code>corx</code>
steps ago, instead of the ones in the previous step. See the
<code>corx</code> argument below, that gives the size of the shift.
</p>
</dd>
<dt>cor.limit</dt><dd><p>The correlation limit for convergence if the
&lsquo;<code>cor</code>&rsquo; method is used.</p>
</dd>
<dt>eps</dt><dd><p>Limit for convergence if the &lsquo;<code>eps</code>&rsquo; method is
used.</p>
</dd>
<dt>corx</dt><dd><p>The number of iterations to use as a shift, for checking
convergence with the &lsquo;<code>corx</code>&rsquo; method.</p>
</dd>
<dt>oscillation</dt><dd><p>Logical scalar, whether to look for oscillating
seeds. Usually there are not too many oscillating seeds, so it is
safe to leave this on <code>FALSE</code>.</p>
</dd>
<dt>maxiter</dt><dd><p>The maximum number of iterations allowed.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A named list with many components. Please see the manual page of
<code><a href="#topic+isa">isa</a></code> for a complete description.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Bergmann S, Ihmels J, Barkai N: Iterative signature algorithm for the
analysis of large-scale gene expression data <em>Phys Rev E Stat
Nonlin Soft Matter Phys.</em> 2003 Mar;67(3 Pt 1):031902. Epub 2003 Mar 11.
</p>
<p>Ihmels J, Friedlander G, Bergmann S, Sarig O, Ziv Y, Barkai N:
Revealing modular organization in the yeast transcriptional network
<em>Nat Genet.</em> 2002 Aug;31(4):370-7. Epub 2002 Jul 22
</p>
<p>Ihmels J, Bergmann S, Barkai N:
Defining transcription modules using large-scale gene expression data
<em>Bioinformatics</em> 2004 Sep 1;20(13):1993-2003. Epub 2004 Mar 25.
</p>


<h3>See Also</h3>

 <p><a href="#topic+isa2-package">isa2-package</a> for a short introduction on the Iterative
Signature Algorithm. See <code><a href="#topic+isa">isa</a></code> for an easy way of running
ISA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A basic ISA work flow for a single threshold combination
## In-silico data
set.seed(1)
insili &lt;- isa.in.silico()

## Random seeds
seeds &lt;- generate.seeds(length=nrow(insili[[1]]), count=100)

## Normalize input matrix
nm &lt;- isa.normalize(insili[[1]])

## Do ISA
isares &lt;- isa.iterate(nm, row.seeds=seeds, thr.row=2, thr.col=1)

## Eliminate duplicates
isares &lt;- isa.unique(nm, isares)

## Filter out not robust ones
isares &lt;- isa.filter.robust(insili[[1]], nm, isares)

## Print the sizes of the modules
cbind( colSums(isares$rows!=0), colSums(isares$columns!=0) )

## Plot the original data and the modules found
if (interactive()) {
  layout(rbind(1:2))
  image(insili[[1]], main="In silico data")
  image(outer(isares$rows[,1],isares$columns[,1])+
        outer(isares$rows[,2],isares$columns[,2])+
        outer(isares$rows[,3],isares$columns[,3]), main="ISA modules")
}
</code></pre>

<hr>
<h2 id='isa.normalize'>Normalize input data for use with ISA</h2><span id='topic+isa.normalize'></span><span id='topic+isa.normalize+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Normalize a matrix and create a form that can be effectively used for
ISA runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
isa.normalize(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isa.normalize_+3A_data">data</code></td>
<td>
<p>A numeric matrix, the input data. It might contains
<code>NA</code> and/or <code>NaN</code> values.</p>
</td></tr>
<tr><td><code id="isa.normalize_+3A_...">...</code></td>
<td>
<p>Additional arguments, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be called as
</p>
<pre>
    isa.normalize(data, prenormalize = FALSE)    
  </pre>
<p>where the arguments are:
</p>

<dl>
<dt>data</dt><dd><p>A numeric matrix, the input data. It might contains
<code>NA</code> and/or <code>NaN</code> values.</p>
</dd>
<dt>prenormalize</dt><dd><p>Logical scalar, see details below.</p>
</dd>
</dl>

<p>It was observed that the ISA works better if the input matrix is
scaled and its rows have mean zero and standard deviation one.
</p>
<p>An ISA step consists of two sub-steps, and this implies two different
normalizations, in the first the rows, in the second the columns of
the input matrix will be scaled.
</p>
<p>If the <code>prenormalize</code> argument is set to <code>TRUE</code>, then
row-wise scaling is calculated on the column-wise scaled matrix and
not on the input matrix directly.
</p>


<h3>Value</h3>

<p>A list of two normalized matrices, the first one is transposed.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Bergmann S, Ihmels J, Barkai N: Iterative signature algorithm for the
analysis of large-scale gene expression data <em>Phys Rev E Stat
Nonlin Soft Matter Phys.</em> 2003 Mar;67(3 Pt 1):031902. Epub 2003 Mar 11.
</p>
<p>Ihmels J, Friedlander G, Bergmann S, Sarig O, Ziv Y, Barkai N:
Revealing modular organization in the yeast transcriptional network
<em>Nat Genet.</em> 2002 Aug;31(4):370-7. Epub 2002 Jul 22
</p>
<p>Ihmels J, Bergmann S, Barkai N:
Defining transcription modules using large-scale gene expression data
<em>Bioinformatics</em> 2004 Sep 1;20(13):1993-2003. Epub 2004 Mar 25.
</p>


<h3>See Also</h3>

 <p><a href="#topic+isa2-package">isa2-package</a> for a short introduction on the Iterative
Signature Algorithm. See <code><a href="#topic+isa">isa</a></code> for an easy way of running
ISA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## In-silico data
set.seed(1)
insili &lt;- isa.in.silico()
nm &lt;- isa.normalize(insili[[1]])

## Check it
max(abs(rowSums(nm[[1]])))
max(abs(rowSums(nm[[2]])))

max(abs(apply(t(nm[[1]]), 2, sd) - 1))
max(abs(apply(t(nm[[2]]), 2, sd) - 1))

## Plot them
if (interactive()) {
  layout(rbind(1:2,3:4))
  image(insili[[1]], main="Original data")
  image(t(nm[[1]]), main="Row normalized")
  image(nm[[2]], main="Column normalized")
}

</code></pre>

<hr>
<h2 id='isa.option'>Options for the isa package</h2><span id='topic+isa.option'></span>

<h3>Description</h3>

<p>This function can be used to set various options that affect many
functions in the isa package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isa.option(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isa.option_+3A_...">...</code></td>
<td>
<p>A single option query, or option assignments, these must
be named, too. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>isa.option</code> function can be used in three forms. First,
calling it without any arguments returns a named list of the current
values of all isa options.
</p>
<p>Second, calling it with a character scalar as the single argument, it
returns the value of the specified option.
</p>
<p>Third, calling it with a named argument (or more named arguments) set
the specified options to the given values.
</p>
<p>Here is a list of all the currently supported options:
</p>

<dl>
<dt><code>verbose</code></dt><dd><p>Logical scalar. Whether to report what the isa
functions are currently doing. Defaults to <code>FALSE</code>.</p>
</dd>
<dt><code>status.function</code></dt><dd><p>A function object, it serves as a
callback for printing status messages.</p>
</dd>
</dl>



<h3>Value</h3>

<p>In the first form, <code>isa.option</code> returns a named list with the
current values of all options.
</p>
<p>In the second form, it returns the value of the specified option.
</p>
<p>In the third form, it returns a named list with the current values of
all options, invisibly.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Make isa functions verbose
isa.option(verbose=TRUE)

## Query the value of 'verbose'
isa.option("verbose")

## Query all options
isa.option()
</code></pre>

<hr>
<h2 id='isa.sweep'>Create a hierarchical structure of ISA biclusters</h2><span id='topic+isa.sweep'></span><span id='topic+isa.sweep+2Cmatrix-method'></span><span id='topic+sweep.graph'></span><span id='topic+sweep.graph+2Clist-method'></span>

<h3>Description</h3>

<p>Relate the biclusters found in many ISA runs on the same input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
isa.sweep(data, ...)
## S4 method for signature 'list'
sweep.graph(sweep.result, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isa.sweep_+3A_data">data</code></td>
<td>
<p>The input matrix.</p>
</td></tr>
<tr><td><code id="isa.sweep_+3A_...">...</code></td>
<td>
<p>Additional arguments, see details
below. <code>sweep.graph</code> has no additional arguments currently.</p>
</td></tr>
<tr><td><code id="isa.sweep_+3A_sweep.result">sweep.result</code></td>
<td>
<p>An ISA result with hierarchy information in the
seed data, typically calculated by the <code>isa.sweep</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>isa.sweep</code> can be called as
</p>
<pre>
    isa.sweep(data, normed.data, isaresult,
              method = c("cor"), neg.cor = TRUE,  
	      cor.limit = 0.9)
	    </pre>
<p>where the arguments are:	    
</p>

<dl>
<dt>data</dt><dd><p>The input matrix.</p>
</dd>
<dt>normed.data</dt><dd><p>The normalized input matrix, usually the output of
the <code><a href="#topic+isa.normalize">isa.normalize</a></code> function.</p>
</dd>
<dt>isaresult</dt><dd><p>An object containing the biclusters, the result of
<code><a href="#topic+isa">isa</a></code> or <code><a href="#topic+isa.iterate">isa.iterate</a></code>.</p>
</dd>
<dt>method</dt><dd><p>Character scalar giving the method to determine which
seed converged which bicluster. Right now only &lsquo;<code>cor</code>&rsquo;
is supported, this is based on Pearson correlation.</p>
</dd>
<dt>neg.cor</dt><dd><p>Logical scalar, whether to consider negative
correlation as convergence.</p>
</dd>
<dt>cor.limit</dt><dd><p>Numeric scalar giving the minimum correlation for
convergence.</p>
</dd>
</dl>

<p>Many ISA runs with different thresholds typically create a bunch of
biclusters and it is useful to visualize how these are related.
</p>
<p>From a set of biclusters for which of the <code>thr.row</code> and
<code>thr.col</code> parameters was the same, but the other was not,
<code>isa.sweep</code> creates a hierarchy of modules.
</p>
<p>The hierarchy is a directed graph of modules in which every node has
an out degree at most one. An edge pointing from module <code class="reqn">m</code> to
module <code class="reqn">n</code> means that module <code class="reqn">n</code> is &ldquo;part of&rdquo; module
<code class="reqn">m</code>; in the sense that an ISA iteration started from module
<code class="reqn">n</code> converges to module <code class="reqn">m</code> at the (milder) thresholds of
module <code class="reqn">m</code>.
</p>
<p>The information about the module relationships is stored in a column
of the seed data.
</p>
<p><code>sweep.graph</code> takes the output of <code>isa.sweep</code> and creates a
graph object of it. For this the &lsquo;igraph&rsquo; package is required
to be installed on the system.
</p>


<h3>Value</h3>

<p><code>isa.sweep</code> returns a named list with the same components as in
the input (<code>isaresult</code>), but the &lsquo;<code>father</code>&rsquo; and the
&lsquo;<code>level</code>&rsquo; columns are
added to the &lsquo;<code>seeddata</code>&rsquo; member. <code>father</code> contains
the edges of the sweep graph: if bicluster <code class="reqn">m</code> is the father of
bicluster <code class="reqn">n</code> that means that bicluster <code class="reqn">n</code> converges to
bicluster <code class="reqn">m</code> at the same threshold parameters that were used to
find biclusters <code class="reqn">m</code>.
</p>
<p><code>level</code> is a simple numbering of the different thresholds for
which the sweep tree was built. I.e. the most strict threshold is
level one, the second most is level two, etc.  
</p>
<p><code>sweep.graph</code> returns and igraph graph with a lot of attributes:
</p>
<table>
<tr><td><code>1</code></td>
<td>
<p>The <code>layout</code> graph attribute contains a two-column matrix
with the coordinates for an optimal tree-like layout to plot the
graph.</p>
</td></tr>
<tr><td><code>2</code></td>
<td>
<p>The <code>width</code> and <code>height</code> graph attributes contain the
optimal width and height of the plot, in inches.</p>
</td></tr>
<tr><td><code>3</code></td>
<td>
<p>The <code>thr</code> vertex attribute contains the ISA threshold that
varies along the sweeping.</p>
</td></tr>
<tr><td><code>4</code></td>
<td>
<p>The <code>id</code> vertex attribute contains the id of the module, these
correspond to the indices in the result matrix.</p>
</td></tr>
<tr><td><code>5</code></td>
<td>
<p>The <code>rows</code> and <code>cols</code> vertex attributes contain the
number of rows and columns in the module.</p>
</td></tr>
<tr><td><code>6</code></td>
<td>
<p>The <code>shape</code>, <code>size</code>, <code>size2</code>, <code>label</code> vertex
attributes and the <code>arrow.size</code> edge attribute contain various
graphical parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Bergmann S, Ihmels J, Barkai N: Iterative signature algorithm for the
analysis of large-scale gene expression data <em>Phys Rev E Stat
Nonlin Soft Matter Phys.</em> 2003 Mar;67(3 Pt 1):031902. Epub 2003 Mar 11.
</p>
<p>Ihmels J, Friedlander G, Bergmann S, Sarig O, Ziv Y, Barkai N:
Revealing modular organization in the yeast transcriptional network
<em>Nat Genet.</em> 2002 Aug;31(4):370-7. Epub 2002 Jul 22
</p>
<p>Ihmels J, Bergmann S, Barkai N:
Defining transcription modules using large-scale gene expression data
<em>Bioinformatics</em> 2004 Sep 1;20(13):1993-2003. Epub 2004 Mar 25.
</p>


<h3>See Also</h3>

 <p><a href="#topic+isa2-package">isa2-package</a> for a short introduction on the Iterative
Signature Algorithm. See <code><a href="#topic+isa">isa</a></code> for an easy way of running
ISA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## In-silico data
set.seed(1)
insili &lt;- isa.in.silico()

## Do ISA with a bunch of row thresholds while keeping the column
## threshold fixed. This is quite an artificial example...
isares &lt;- isa(insili[[1]], thr.row=c(0.5,1,2), thr.col=0)

## Create a nice tree from the modules, we need the normed data for this
nm &lt;- isa.normalize(insili[[1]])
isa.tree &lt;- isa.sweep(insili[[1]], nm, isares)
network &lt;- sweep.graph(isa.tree)

## Plot the network of modules, only if the igraph package is
## installed
if (interactive() &amp;&amp; require(igraph) &amp;&amp;
    compareVersion(packageDescription("igraph")$Version, "0.6")&gt;=0) {
  lab &lt;- paste(sep="", seq_len(ncol(isa.tree$rows)), ": ",
               colSums(isa.tree$rows!=0), ",",
               colSums(isa.tree$columns!=0))
  par(mar=c(1,1,1,1))
  roots &lt;- tapply(topological.sort(network, mode="out"),
                  clusters(network)$membership, function(x) x[1])
  rootlevel &lt;- isa.tree$seeddata$level-1
  coords &lt;- layout.reingold.tilford(network, root=roots,
                                    rootlevel=rootlevel[roots+1])
  plot(network, layout=coords,
       vertex.shape="rectangle", vertex.color="green",
       vertex.label=lab, vertex.size=30, vertex.size2=10)
}

## Plot the modules themselves as well
if (interactive()) {
  plotModules(isa.tree)
}

## Yet another plot, the scores for the rows within the modules
if (interactive()) {
  layout(matrix( 1:15, ncol=3 ))
  for (i in seq(ncol(isa.tree$rows))) {
    par(mar=c(2,2,1,1))
    plot(isa.tree$rows[,i], axes=FALSE, ylim=c(-1,1))
    axis(1); axis(2)
    text(nrow(isa.tree$rows), 1, adj=c(1,1), paste(sep="", "#", i), cex=2)
  }
}
    
</code></pre>

<hr>
<h2 id='isa.unique'>Filter out biclusters that are very similar to each other</h2><span id='topic+isa.unique'></span><span id='topic+isa.unique+2Clist+2Clist-method'></span>

<h3>Description</h3>

<p>From a potentially non-unique set of ISA biclusters, create a unique
set by removing all biclusters that are similar to others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list,list'
 isa.unique(normed.data, isaresult, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isa.unique_+3A_normed.data">normed.data</code></td>
<td>
<p>The normalized input data, a list of two matrices,
usually the output of <code><a href="#topic+isa.normalize">isa.normalize</a></code>.</p>
</td></tr>
<tr><td><code id="isa.unique_+3A_isaresult">isaresult</code></td>
<td>
<p>The result of an ISA run, a set of biclusters.</p>
</td></tr>
<tr><td><code id="isa.unique_+3A_...">...</code></td>
<td>
<p>Additional arguments, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can we called as
</p>
<pre>
    isa.unique(normed.data, isaresult, method = c("cor"),
               ignore.div = TRUE, cor.limit = 0.9,
	       neg.cor = TRUE, drop.zero = TRUE)
	     </pre>
<p>where the arguments are:
</p>

<dl>
<dt>normed.data</dt><dd><p>The normalized input data, a list of two matrices,
usually the output of <code><a href="#topic+isa.normalize">isa.normalize</a></code>.</p>
</dd>
<dt>isaresult</dt><dd><p>The result of an ISA run, a set of biclusters.</p>
</dd>
<dt>method</dt><dd><p>Character scalar giving the method to be used to
determine if two biclusters are similar. Right now only
&lsquo;<code>cor</code>&rsquo; is implemented, this keeps both biclusters if
their Pearson correlation is less than <code>cor.limit</code>, both for
their row and column scores. See also the <code>neg.cor</code> argument.</p>
</dd>
<dt>ignore.div</dt><dd><p>Logical scalar, if <code>TRUE</code>, then the divergent
biclusters will be removed.</p>
</dd>
<dt>cor.limit</dt><dd><p>Numeric scalar, giving the correlation limit for the
&lsquo;<code>cor</code>&rsquo; method.</p>
</dd>
<dt>neg.cor</dt><dd><p>Logical scalar, if <code>TRUE</code>, then the
&lsquo;<code>cor</code>&rsquo; method considers the absolute value of the
correlation.</p>
</dd>
<dt>drop.zero</dt><dd><p>Logical scalar, whether to drop biclusters that have
all zero scores.</p>
</dd>
</dl>

<p>Because of the nature of the ISA algorithm, the set of biclusters
created by <code><a href="#topic+isa.iterate">isa.iterate</a></code> is not unique; many input seeds
may converge to the same biclusters, even if the input seeds are not
random.
</p>
<p><code>isa.unique</code> filters a set of biclusters and removed the ones
that are very similar to ones that were already found for another
seed.
</p>


<h3>Value</h3>

<p>A named list, the filtered <code>isaresult</code>. See the return value of
<code><a href="#topic+isa.iterate">isa.iterate</a></code> for the details.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Bergmann S, Ihmels J, Barkai N: Iterative signature algorithm for the
analysis of large-scale gene expression data <em>Phys Rev E Stat
Nonlin Soft Matter Phys.</em> 2003 Mar;67(3 Pt 1):031902. Epub 2003 Mar 11.
</p>
<p>Ihmels J, Friedlander G, Bergmann S, Sarig O, Ziv Y, Barkai N:
Revealing modular organization in the yeast transcriptional network
<em>Nat Genet.</em> 2002 Aug;31(4):370-7. Epub 2002 Jul 22
</p>
<p>Ihmels J, Bergmann S, Barkai N:
Defining transcription modules using large-scale gene expression data
<em>Bioinformatics</em> 2004 Sep 1;20(13):1993-2003. Epub 2004 Mar 25.
</p>


<h3>See Also</h3>

 <p><a href="#topic+isa2-package">isa2-package</a> for a short introduction on the Iterative
Signature Algorithm. See <code><a href="#topic+isa">isa</a></code> for an easy way of running
ISA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an ISA module set
set.seed(1)
insili &lt;- isa.in.silico(noise=0.01)

## Random seeds
seeds &lt;- generate.seeds(length=nrow(insili[[1]]), count=20)

## Normalize input matrix
nm &lt;- isa.normalize(insili[[1]])

## Do ISA
isares &lt;- isa.iterate(nm, row.seeds=seeds, thr.row=2, thr.col=1)

## Check correlation among modules
cc &lt;- cor(isares$rows)
if (interactive()) { hist(cc[lower.tri(cc)],10) }

## Some of them are quite high, how many?
undiag &lt;- function(x) { diag(x) &lt;- 0; x }
sum(undiag(cc) &gt; 0.99, na.rm=TRUE)

## Eliminate duplicated modules
isares.unique &lt;- isa.unique(nm, isares)

## How many modules left?
ncol(isares.unique$rows)

## Double check
cc2 &lt;- cor(isares.unique$rows)
if (interactive()) { hist(cc2[lower.tri(cc2)],10) }

## High correlation?
sum(undiag(cc2) &gt; 0.99, na.rm=TRUE)

</code></pre>

<hr>
<h2 id='plotModules'>Image plots of biclusters</h2><span id='topic+images'></span><span id='topic+plotModules'></span><span id='topic+plotModules+2Clist-method'></span>

<h3>Description</h3>

<p>Make several image plots, one for each bicluster, and
optionally one for the original data as well.</p>


<h3>Usage</h3>

<pre><code class='language-R'>images(matrices, names=NULL, ...)
## S4 method for signature 'list'
 plotModules(modules, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotModules_+3A_matrices">matrices</code></td>
<td>
<p>A list of matrices to plot. Please note that this
argument is <em>always</em> interpreted as a list, even if want to
plot a single matrix, put it into a list.</p>
</td></tr>
<tr><td><code id="plotModules_+3A_names">names</code></td>
<td>
<p>Character vector, the labels to show above the image
plots. If you give the <code>data</code> argument to <code>plotModules</code>,
then the first label corresponds to that.</p>
</td></tr>
<tr><td><code id="plotModules_+3A_...">...</code></td>
<td>
<p>Additional arguments, for <code>images</code> these are passed
to <code><a href="lattice.html#topic+levelplot">levelplot</a></code>, for <code>plotModules</code> see the
details below.</p>
</td></tr> 
<tr><td><code id="plotModules_+3A_modules">modules</code></td>
<td>
<p>The object with the ISA modules, as returned by the
<code><a href="#topic+isa">isa</a></code> function or other such functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>images</code> creates image plots for a series of matrices, using
<code><a href="lattice.html#topic+levelplot">levelplot</a></code> from the <code>lattice</code> package.
</p>
<p><code>plotModules</code> calls <code>images</code> from the
to create image plots for a set of modules. It can be called as
</p>
<pre>
    plotModules(modules, to.plot=seq_len(ncol(modules$rows)),
                data, binary=TRUE, names=NULL, xlab="", ylab="",
		\dots)
	      </pre>
<p>where the arguments are:
</p>

<dl>
<dt>modules</dt><dd><p>The object with the ISA modules, as returned by the
<code><a href="#topic+isa">isa</a></code> function or other such functions.</p>
</dd>
<dt>to.plot</dt><dd><p>Numeric vector, the modules to plot, the numbers
correspond to the columns in <code>modules$rows</code> and
<code>modules$columns</code>. By default all modules will be plot.</p>
</dd>
<dt>data</dt><dd><p>An optional data matrix to plot. Most often this is the
original data. If given, its dimension must much the dimensions in
the <code>modules</code> object. If given, then this matrix is plotted
first, before the modules.</p>
</dd>
<dt>binary</dt><dd><p>Logical scalar, whether to binarize the biclusters
before plotting or use the actual ISA scores. By default the
biclusters are binarized.</p>
</dd>
<dt>names</dt><dd><p>Character vector, the labels to show above the image
plots. If you give the <code>data</code> argument to <code>plotModules</code>,
then the first label corresponds to that.</p>
</dd>
<dt>xlab</dt><dd><p>Character scalar, the label to put on the horizontal
axis.</p>
</dd>
<dt>ylab</dt><dd><p>Character scalar, the label to put on the vertical axis.</p>
</dd>
<dt>...</dt><dd><p>Further arguments are passed to
<code><a href="lattice.html#topic+levelplot">levelplot</a></code>.</p>
</dd>
</dl>

<p>Note, that if you want to export these plots to a file, then a
bitmap-based format might be more appropriate. For larger matrices
vector formats tend to generate huge file because of the many dots.
</p>


<h3>Value</h3>

<p>Since these function use the <code>lattice</code> package, they return an
object of class <code>trellis</code>. You will need to <code>print</code> this
object to create the actual plots.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a></p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+image">image</a></code> and the other version: <code>image</code>
from the <code>Matrix</code> package, for alternatives to create image
plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The following should plot the input matrix and the four modules
## found by ISA
set.seed(1)   # to get same plot every time
data &lt;- isa.in.silico(100, 100, num.fact=4)
modules &lt;- isa(data[[1]], thr.row=2, thr.col=2)
plotModules(modules, data=data[[1]], binary=FALSE,
            names=c("Input matrix",
                    paste("Module", seq_len(ncol(modules$rows)))))
</code></pre>

<hr>
<h2 id='ppa'>The Ping-Pong Algorithm</h2><span id='topic+ppa'></span><span id='topic+ppa+2Clist-method'></span>

<h3>Description</h3>

<p>Run the PPA with the default parameters</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
ppa(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppa_+3A_data">data</code></td>
<td>
<p>The input, a list of two numeric matrices, with the same
number of columns. They may contain <code>NA</code> and/or <code>NaN</code>
values, but then the algorithm might get slower, as R matrix
multiplication is slower sometimes slower for these matrices,
depending on your platform.</p>
</td></tr>
<tr><td><code id="ppa_+3A_...">...</code></td>
<td>
<p>Additional arguments, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please read the <a href="#topic+isa2-package">isa2-package</a> manual page for and introductino
on ISA and PPA.
</p>
<p>This function can be called as
</p>
<pre>
    ppa(data, thr.row1 = seq(1, 3, by = 0.5),
        thr.row2 = seq(1, 3, by = 0.5),
        thr.col = seq(1, 3, by = 0.5),
        no.seeds = 100, direction = "updown")
      </pre>
<p>where the arguments are:
</p>

<dl>
<dt>data</dt><dd><p>The input, a list of two numeric matrices, with the same
number of columns. They may contain <code>NA</code> and/or <code>NaN</code>
values, but then the algorithm might get slower, as R matrix
multiplication is slower sometimes slower for these matrices,
depending on your platform.</p>
</dd>
<dt>thr.row1</dt><dd><p>Numeric scalar or vector giving the threshold
parameter for the rows of the first matrix. Higher values indicate
a more stringent threshold and the result comodules will contain
less rows for the first matrix on average. The threshold is
measured by the number of standard deviations from the 
mean, over the values of the first row vector. If it is a vector
then it must contain an entry for each seed.</p>
</dd>
<dt>thr.row2</dt><dd><p>Numeric scalar or vector, the threshold parameter(s)
for the rows of the second matrix. See <code>thr.row1</code> for
details.</p>
</dd>
<dt>thr.col</dt><dd><p>Numeric scalar or vector giving the threshold
parameter for the columns of both matrices. The analogue of
<code>thr.row1</code>.</p>
</dd>
<dt>no.seeds</dt><dd><p>Integer scalar, the number of random seeds to use.</p>
</dd>
<dt>direction</dt><dd><p>Character vector of length four, one for each matrix
multiplication performed during a PPA iteration. 
It specifies whether we are interested in
rows/columns that are higher (&lsquo;<code>up</code>&rsquo;) than average,
lower than average (&lsquo;<code>down</code>&rsquo;), or both
(&lsquo;<code>updown</code>&rsquo;). The first and the second entry both
corresponds to the common column dimension of the two matrices, so
they should be equal, otherwise a warning is given.</p>
</dd>
</dl>

<p>The <code>ppa</code> function provides and easy interface to the PPA. It
runs all sptes of a typical PPA work flow, with their default
paramers.
</p>
<p>This involves:
</p>

<ol>
<li><p> Normalizing the input matrices by calling
<code><a href="#topic+ppa.normalize">ppa.normalize</a></code>.
</p>
</li>
<li><p> Generating random input seeds via
<code><a href="#topic+generate.seeds">generate.seeds</a></code>.
</p>
</li>
<li><p> Running the PPA with all combinations of the given row1, row2
and column thresholds (by default 1, 1.5, 2, 2.5, 3); by calling
<code><a href="#topic+ppa.iterate">ppa.iterate</a></code>.
</p>
</li>
<li><p> Merging similar co-modules, separately for each threshold
combination, by calling <code><a href="#topic+ppa.unique">ppa.unique</a></code>.
</p>
</li>
<li><p> Filtering the co-modules separately for each threshold
combination, by calling <code><a href="#topic+ppa.filter.robust">ppa.filter.robust</a></code>.
</p>
</li>
<li><p> Putting all co-modules from the run with different thresholds,
into a single object.
</p>
</li>
<li><p> Merging similar co-modules, again, but now across all
threshold combinations. If two co-modules are similar, then the
larger one, the one with milder thresholds is kept.
</p>
</li></ol>

<p>Please see the manual pages of these functions for the details.
</p>


<h3>Value</h3>

<p>A named list is returned with the following elements:
</p>
<table>
<tr><td><code>rows1</code></td>
<td>
<p>The first components of the co-modules, corresponding to
the rows of the first input matrix. Every column corresponds to a
co-module, if an element (the score of the row) is non-zero, that
means that that component is included in the co-module, otherwise it
is not. Scores are between -1 and 1. If two scores have
the same non-zero sign, then the corresponding first matrix rows are
collelated. If they have an opposite sign, then they are
anti-correlated.
</p>
<p>If an input seed did not converge within the allowed number of
iterations, then that column of <code>rows1</code> contains <code>NA</code>
values. The <code>ppa</code> function does not produce such columns,
because it always drops the non-convergent seeds via a call to
<code><a href="#topic+ppa.unique">ppa.unique</a></code>. The result of the
<code><a href="#topic+ppa.iterate">ppa.iterate</a></code> function might contain such columns,
though.</p>
</td></tr>  
<tr><td><code>rows2</code></td>
<td>
<p>This is the same as <code>rows1</code>, but for the second
input matrix.</p>
</td></tr>
<tr><td><code>columns</code></td>
<td>
<p>The same as <code>rows1</code> and <code>rows2</code>, but for the
columns of both input matrices.</p>
</td></tr>
<tr><td><code>seeddata</code></td>
<td>
<p>A data frame containing information about the
co-modules. There is one row for each co-module. The data frame has
the following columns:
</p>

<dl>
<dt><code>iterations</code></dt><dd><p>The number of iterations needed for
convergence.</p>
</dd>
<dt><code>oscillation</code></dt><dd><p>The oscillation cycle of this is
oscillating co-module. Zero otherwise.</p>
</dd>
<dt><code>thr.row1</code></dt><dd><p>The threshold used for the rows of the
first matrix.</p>
</dd>
<dt><code>thr.row2</code></dt><dd><p>The threshold used for the rows of the
second matrix.</p>
</dd>
<dt><code>thr.col</code></dt><dd><p>The threshold used for the common column
dimension.</p>
</dd>
<dt><code>freq</code></dt><dd><p>Numeric scalar, the number of times the same
(or a very similar) co-module was found.</p>
</dd>
<dt><code>rob</code></dt><dd><p>The robustness score of the module.</p>
</dd>
<dt><code>rob.limit</code></dt><dd><p>The robustness limit that was used to
filter the module. See <code><a href="#topic+ppa.filter.robust">ppa.filter.robust</a></code> for
details.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>rundata</code></td>
<td>

<p>A named list with information about the PPA run. It has the
following entries:
</p>

<dl>
<dt><code>direction</code></dt><dd><p>Character vector of length four, the
<code>direction</code> argument of the <code><a href="#topic+ppa.iterate">ppa.iterate</a></code>
call.</p>
</dd>
<dt><code>convergence</code></dt><dd><p>Character scalar, the convergence
criteria that was used, see the <code><a href="#topic+ppa.iterate">ppa.iterate</a></code>
function for details.</p>
</dd>
<dt><code>cor.limit</code></dt><dd><p>Numeric scalar, the correlation
threshold, that was used if the convergence criteria was
&lsquo;<code>cor</code>&rsquo;.</p>
</dd>
<dt><code>maxiter</code></dt><dd><p>The maximum number of PPA iterations.</p>
</dd>
<dt><code>N</code></dt><dd><p>The total number of input seeds that were used to
find the co-modules.</p>
</dd>
<dt><code>prenormalize</code></dt><dd><p>Logical scalar, whether the input
matrices were pre-normalized, see <code><a href="#topic+ppa.normalize">ppa.normalize</a></code>
for details.</p>
</dd>
<dt><code>hasNA</code></dt><dd><p>Logical vector of length two. Whether the two
input matrices contained any <code>NA</code> or <code>NaN</code> values.</p>
</dd>
<dt><code>unique</code></dt><dd><p>Logical scalar, whether the co-modules are
unique, i.e. whether <code><a href="#topic+ppa.unique">ppa.unique</a></code> was called.</p>
</dd>
<dt><code>oscillation</code></dt><dd><p>Logical scalar, whether the
<code><a href="#topic+ppa.iterate">ppa.iterate</a></code> run looked for oscillating modules.</p>
</dd>
<dt><code>rob.perms</code></dt><dd><p>The number of data permutations that was
performed during the robustness filtering, see
<code><a href="#topic+ppa.filter.robust">ppa.filter.robust</a></code> for details.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Kutalik Z, Bergmann S, Beckmann, J: A modular approach for integrative
analysis of large-scale gene-expression and drug-response data
<em>Nat Biotechnol</em> 2008 May; 26(5) 531-9.
</p>


<h3>See Also</h3>

 <p><a href="#topic+isa2-package">isa2-package</a> for a short introduction to the ISA and
the Ping-Pong algorithms. See the functions mentioned above if you
want to change the default ISA parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## WE do not run this, it takes relatively long
## Not run: 
data &lt;- ppa.in.silico(noise=0.1)
ppa.result &lt;- ppa(data[1:2], direction="up")

## Find the best bicluster for each block in the input
## (based on the rows of the first input matrix)
best &lt;- apply(cor(ppa.result$rows1, data[[3]]), 2, which.max)

## Check correlation
sapply(seq_along(best),
       function(x) cor(ppa.result$rows1[,best[x]], data[[3]][,x]))

## The same for the rows of the second matrix
sapply(seq_along(best),
       function(x) cor(ppa.result$rows2[,best[x]], data[[4]][,x]))

## The same for the columns
sapply(seq_along(best),
       function(x) cor(ppa.result$columns[,best[x]], data[[5]][,x]))

## Plot the data and the modules found
if (interactive()) {
  layout(rbind(1:2,c(3,6),c(4,7), c(5,8)))
  image(data[[1]], main="In-silico data, first matrix")
  image(data[[2]], main="In-silico data, second matrix")
  sapply(best[1:3], function(b) image(outer(ppa.result$rows1[,b],
                                       ppa.result$columns[,b]),
                                 main=paste("Module", b)))  
  sapply(best[1:3], function(b) image(outer(ppa.result$rows2[,b],
                                       ppa.result$columns[,b]),
                                 main=paste("Module", b)))  
}

## End(Not run)
</code></pre>

<hr>
<h2 id='ppa.in.silico'>Generate in-silico input data for testing the PPA algorithm</h2><span id='topic+ppa.in.silico'></span>

<h3>Description</h3>

<p>This function generates an artificial test data set for the
PPA algorithm: two matrices, with common column dimension, containing
co-modules of prescribed number, size, signal level, noise level and
background noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppa.in.silico (num.rows1 = 300, num.rows2 = 200, num.cols = 50,
    num.fact = 3, mod.row1.size = round(0.5 * num.rows1/num.fact),
    mod.row2.size = round(0.5 * num.rows2/num.fact),
    mod.col.size = round(0.5 * num.cols/num.fact), 
    noise = 0.1, mod.signal = rep(1, num.fact),
    mod.noise = rep(0, num.fact), overlap.row1 = 0,
    overlap.row2 = overlap.row1, overlap.col = overlap.row1) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppa.in.silico_+3A_num.rows1">num.rows1</code></td>
<td>
<p>The number of rows in the first data matrix.</p>
</td></tr>
<tr><td><code id="ppa.in.silico_+3A_num.rows2">num.rows2</code></td>
<td>
<p>The number of rows in the second data matrix.</p>
</td></tr>
<tr><td><code id="ppa.in.silico_+3A_num.cols">num.cols</code></td>
<td>
<p>The number of columns in both matrices.</p>
</td></tr>
<tr><td><code id="ppa.in.silico_+3A_num.fact">num.fact</code></td>
<td>
<p>The number of co-modules to put in the data.</p>
</td></tr>
<tr><td><code id="ppa.in.silico_+3A_mod.row1.size">mod.row1.size</code></td>
<td>
<p>The size of the co-modules, the number of rows
from the first data matrix. It can be a scalar or a vector, and it
is recycled.</p>
</td></tr>
<tr><td><code id="ppa.in.silico_+3A_mod.row2.size">mod.row2.size</code></td>
<td>
<p>The size of the co-modules, the number of rows
from the second data matrix. It can be a scalar or a vector, and it
is recycled.</p>
</td></tr>
<tr><td><code id="ppa.in.silico_+3A_mod.col.size">mod.col.size</code></td>
<td>
<p>The size of the co-modules, the number of columns
(from both matrices). It can be a scalar or a vector, and it
is recycled.</p>
</td></tr>
<tr><td><code id="ppa.in.silico_+3A_noise">noise</code></td>
<td>
<p>The level of the background noise to be added to the data
matrices. It gives the standard deviation of the normal distribution
from which the noise is generated.</p>
</td></tr>
<tr><td><code id="ppa.in.silico_+3A_mod.signal">mod.signal</code></td>
<td>
<p>The signal level of the co-modules.</p>
</td></tr> 
<tr><td><code id="ppa.in.silico_+3A_mod.noise">mod.noise</code></td>
<td>
<p>The noise levels of the different co-modules. Normally
distributed noise with standard deviation <code>mod.noise</code> is added
to the data. This is in addition to the background noise.</p>
</td></tr>
<tr><td><code id="ppa.in.silico_+3A_overlap.row1">overlap.row1</code></td>
<td>
<p>The overlap of the modules, for the rows of the
first matrix. Zero means no overlap, one means one overlapping row,
etc.</p>
</td></tr>
<tr><td><code id="ppa.in.silico_+3A_overlap.row2">overlap.row2</code></td>
<td>
<p>The same as <code>overlap.row1</code>, but for the rows
of the second matrix.</p>
</td></tr>
<tr><td><code id="ppa.in.silico_+3A_overlap.col">overlap.col</code></td>
<td>
<p>The same as <code>overlap.row1</code>, but for the
columns of both matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ppa.in.silico</code> creates an artificial data set to test the PPA
(or potentially other) algorithm. It creates two data matrices with an
overlapping dimension and a checkerboard-like structure. The fields of
the checkerboard are the co-modules, and they may have different
signal and noise levels, and they may also overlap.  
</p>


<h3>Value</h3>

<p>A list with five matrices. The first two are the two data matrices,
they have the same number of columns. The last three matrices contain
the correct modules, for the rows of the first matrix, the rows of the
second matrix, and finally for the common column dimension.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Kutalik Z, Bergmann S, Beckmann, J: A modular approach for integrative
analysis of large-scale gene-expression and drug-response data
<em>Nat Biotechnol</em> 2008 May; 26(5) 531-9.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ppa">ppa</a></code> for an easy way of running the PPA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define a function for plotting if we are interactive
if (interactive()) { layout(cbind(1:2,3:4,5:6,7:8)) }
myimage &lt;- function(mat) {
  if (interactive()) {
    par(mar=c(3,2,1,1)); image(mat[[1]])
    par(mar=c(3,2,1,1)); image(mat[[2]])
  }
}

## Co-modules without overlap and noise
silico1 &lt;- ppa.in.silico(100, 100, 100, 10, mod.row1.size=10,
                         mod.row2.size=10, mod.col.size=10, noise=0)
myimage(silico1)

## The same, but with overlap and noise
silico2 &lt;- ppa.in.silico(100, 100, 100, 10, mod.row1.size=10,
                         mod.row2.size=10, mod.col.size=10, noise=0.1,
                         overlap.row1=3)
myimage(silico2)

## Co-modules with different noise levels
silico3 &lt;- ppa.in.silico(100, 100, 100, 5, mod.row1.size=10,
                         mod.row2.size=10, mod.col.size=10, noise=0.01,
                         mod.noise=seq(0.1,by=0.1,length=5))
myimage(silico3)

## Co-modules withe different signal levels
silico4 &lt;- ppa.in.silico(100, 100, 100, 5, mod.row1.size=10,
                         mod.row2.size=10, mod.col.size=10, noise=0.01,
                         mod.signal=seq(1,5,length=5))
myimage(silico4)
</code></pre>

<hr>
<h2 id='ppa.iterate'>The Ping-Pong Algorithm</h2><span id='topic+ppa.iterate'></span><span id='topic+ppa.iterate+2Clist-method'></span>

<h3>Description</h3>

<p>Perform PPA on two (normalized) input matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
ppa.iterate(normed.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppa.iterate_+3A_normed.data">normed.data</code></td>
<td>
<p>The normalized input matrices. A list of four
matrices, usually coming from the <code><a href="#topic+ppa.normalize">ppa.normalize</a></code>
function.</p>
</td></tr>
<tr><td><code id="ppa.iterate_+3A_...">...</code></td>
<td>
<p>Additional arguments, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ppa.iterate</code> performs the PPA iteration on the specified input
matrices using given input seeds. It can be called
as </p>
<pre>
    ppa.iterate(normed.data, row1.seeds, col1.seeds,
                row2.seeds, col2.seeds,
                thr.row1, thr.col=thr.row1, thr.row2=thr.row1,
		direction="updown",
		convegence=c("cor"), cor.limit=0.9,
		oscillation=FALSE, maxiter=100)
	      </pre>
<p>where the arguments are:
</p>

<dl>
<dt>normed.data</dt><dd><p>The normalized data, a list of four matrices with
the appropriate size. They are usually coming from the output of
the <code><a href="#topic+ppa.normalize">ppa.normalize</a></code> function.</p>
</dd>
<dt>row1.seeds</dt><dd><p>The row seed vectors for the first matrix. At
least one of the four possible seed vectors must be present and
they will be concatenated, after doing the suitable
half-iterations.</p>
</dd>
<dt>col1.seeds</dt><dd><p>The column seed vectors for the first matrix. At
least one of the four possible seed vectors must be present and
they will be concatenated, after doing the suitable
half-iterations.</p>
</dd>
<dt>row2.seeds</dt><dd><p>The row seed vectors for the second matrix. At
least one of the four possible seed vectors must be present and
they will be concatenated, after doing the suitable
half-iterations.</p>
</dd>
<dt>col2.seeds</dt><dd><p>The column seed vectors for the second matrix. At
least one of the four possible seed vectors must be present and
they will be concatenated, after doing the suitable
half-iterations.</p>
</dd>
<dt>thr.row1</dt><dd><p>Numeric scalar or vector giving the threshold
parameter for the rows of the first matrix. Higher values indicate
a more stringent threshold and the result comodules will contain
less rows for the first matrix on average. The threshold is
measured by the number of standard deviations from the 
mean, over the values of the first row vector. If it is a vector
then it must contain an entry for each seed.</p>
</dd>
<dt>thr.col</dt><dd><p>Numeric scalar or vector giving the threshold
parameter for the columns of both matrices. The analogue of
<code>thr.row1</code>.</p>
</dd>
<dt>thr.row2</dt><dd><p>Numeric scalar or vector, the threshold parameter(s)
for the rows of the second matrix. See <code>thr.row1</code> for
details.</p>
</dd>
<dt>direction</dt><dd><p>Character vector of length four, one for each matrix
multiplication performed during a PPA iteration. 
It specifies whether we are interested in
rows/columns that are higher (&lsquo;<code>up</code>&rsquo;) than average,
lower than average (&lsquo;<code>down</code>&rsquo;), or both
(&lsquo;<code>updown</code>&rsquo;). The first and the second entry both
corresponds to the common column dimension of the two matrices, so
they should be equal, otherwise a warning is given.</p>
</dd>
<dt>convergence</dt><dd><p>Character scalar, the convergence criteria for the
PPA iteration. If it is &lsquo;<code>cor</code>&rsquo;, then convergence is
measured based on high Pearson correlation (see the <code>cor.limit</code>
argument below) of the subsequent row and column
vectors. Currently this is the only option implemented.</p>
</dd>
<dt>cor.limit</dt><dd><p>The correlation limit for convergence if the
&lsquo;<code>cor</code>&rsquo; method is used.</p>
</dd>
<dt>oscillation</dt><dd><p>Logical scalar, whether to look for oscillating
seeds. Usually there are not too many oscillating seeds, so it is
safe to leave this on <code>FALSE</code>.</p>
</dd>
<dt>maxiter</dt><dd><p>The maximum number of iterations allowed.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A named list with many components. Please see the manual page of
<code>link{isa}</code> for a complete description.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Kutalik Z, Bergmann S, Beckmann, J: A modular approach for integrative
analysis of large-scale gene-expression and drug-response data
<em>Nat Biotechnol</em> 2008 May; 26(5) 531-9.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ppa">ppa</a></code> for an easy way of running the PPA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A basic PPA workflow with a single threshold combination
## In-silico data
set.seed(1)
insili &lt;- ppa.in.silico()

## Random seeds
seeds &lt;- generate.seeds(length=nrow(insili[[1]]), count=100)

## Normalize input matrices
nm &lt;- ppa.normalize(insili[1:2])

## Do PPA
ppares &lt;- ppa.iterate(nm, row1.seeds=seeds, thr.row1=1, direction="up")

## Eliminate duplicates
ppares &lt;- ppa.unique(nm, ppares)

## Fitler out not robust ones
ppares &lt;- ppa.filter.robust(insili[1:2], nm, ppares)

## Print the sizes of the co-modules
cbind(colSums(ppares$rows1 != 0), colSums(ppares$rows1 != 0),
      colSums(ppares$columns != 0))

## Plot the original data and the first three modules found
if (interactive()) {
  layout(rbind(1:2,3:4))
  image(insili[[1]], main="In silico data 1")
  image(outer(ppares$rows1[,1],ppares$columns[,1])+
        outer(ppares$rows1[,2],ppares$columns[,2])+
        outer(ppares$rows1[,3],ppares$columns[,3]), main="PPA co-modules 2")
  image(insili[[2]], main="In silico data 2")
  image(outer(ppares$rows2[,1],ppares$columns[,1])+
        outer(ppares$rows2[,2],ppares$columns[,2])+
        outer(ppares$rows2[,3],ppares$columns[,3]), main="PPA co-modules 2")
}

</code></pre>

<hr>
<h2 id='ppa.normalize'>Normalize input data for use with the PPA</h2><span id='topic+ppa.normalize'></span><span id='topic+ppa.normalize+2Clist-method'></span>

<h3>Description</h3>

<p>Normalize the two input matrices and store them in a form that can be
used effectively to perform the Ping-Pong Algorithm</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
ppa.normalize(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppa.normalize_+3A_data">data</code></td>
<td>
<p>A list of two numeric matrices, with matching number of
columns. They might contain <code>Na</code> and/or <code>NaN</code> values.</p>
</td></tr>
<tr><td><code id="ppa.normalize_+3A_...">...</code></td>
<td>
<p>Additional arguments, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be called as
</p>
<pre>
    isa.normalize(data, prenormalize = FALSE)
  </pre>
<p>where the arguments are:
</p>

<dl>
<dt>data</dt><dd><p>A list of two numeric matrices, with matching number of
columns. They might contain <code>Na</code> and/or <code>NaN</code> values.</p>
</dd>
<dt>prenormalize</dt><dd><p>Logical scalar, see details below.</p>
</dd>
</dl>

<p>It was observed that the PPA works best if the input matrices are
scaled to have mean zero and standard deviation one.
</p>
<p>A PPA step consist of four matrix-multiplications and this requires
four different matrices, each of the two input matrices scaled
row-wise and column-wise.
</p>
<p>If the <code>prenormalized</code> argument is set to <code>TRUE</code>, then
row-wise scaling is calculated on the column-wise scaled matrices and
not on the raw input.
</p>


<h3>Value</h3>

<p>A list of four matrices, the first two corresponds to the first input
matrix, the second two to the second matrix.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Kutalik Z, Bergmann S, Beckmann, J: A modular approach for integrative
analysis of large-scale gene-expression and drug-response data
<em>Nat Biotechnol</em> 2008 May; 26(5) 531-9.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ppa">ppa</a></code> for an easy way of running the PPA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## In-silico data
set.seed(1)
insili &lt;- ppa.in.silico()
nm &lt;- ppa.normalize(insili[1:2])

## Check it
max(abs(rowSums(nm[[1]])))
max(abs(rowSums(nm[[2]])))
max(abs(rowSums(nm[[3]])))
max(abs(rowSums(nm[[4]])))

max(abs(rowSums(nm[[1]])))
max(abs(rowSums(nm[[2]])))
max(abs(rowSums(nm[[3]])))
max(abs(rowSums(nm[[4]])))

## Plot them
if (interactive()) {
  layout(rbind(1:3,4:6))
  image(insili[[1]], main="Original data 1")
  image(t(nm[[1]]), main="Row normalized 1")
  image(nm[[2]], main="Column normalized 1")

  image(insili[[2]], main="Original data 2")
  image(t(nm[[3]]), main="Row normalized 2")
  image(nm[[4]], main="Column normalized 2")
}

</code></pre>

<hr>
<h2 id='ppa.unique'>Filter co-modules that are very similar to each other</h2><span id='topic+ppa.unique'></span><span id='topic+ppa.unique+2Clist+2Clist-method'></span>

<h3>Description</h3>

<p>From a potentially non-unique set of PPA co-modules, create a unique
set by removing all co-modules that are similar to others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list,list'
 ppa.unique(normed.data, pparesult, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppa.unique_+3A_normed.data">normed.data</code></td>
<td>
<p>The normalized input data, a list of four matrices,
usually the output of the <code><a href="#topic+ppa.normalize">ppa.normalize</a></code> function.</p>
</td></tr>
<tr><td><code id="ppa.unique_+3A_pparesult">pparesult</code></td>
<td>
<p>The result of a PPA run, a set of co-modules.</p>
</td></tr>
<tr><td><code id="ppa.unique_+3A_...">...</code></td>
<td>
<p>Additional arguments, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be called as
</p>
<pre>
    ppa.unique(normed.data, pparesult, method = c("cor"),
               ignore.div = TRUE, cor.limit = 0.9,
	       neg.cor = TRUE, drop.zero = TRUE)
  </pre>
<p>where the arguments are:
</p>

<dl>
<dt>normed.data</dt><dd><p>The normalized input data, a list of four
matrices, usually the output of <code><a href="#topic+ppa.normalize">ppa.normalize</a></code>.</p>
</dd>
<dt>pparesult</dt><dd><p>The results of a PPA run, a set of co-modules.</p>
</dd>
<dt>method</dt><dd><p>Character scalar giving the method to be used to
determine if two co-modules are similar. Right now only
&lsquo;<code>cor</code>&rsquo; is implemented, this keeps both co-modules if
their Pearson correlation is less than <code>cor.limit</code>, for
their row1, row2 and column scores. See also the <code>neg.cor</code>
argument.</p>
</dd>
<dt>ignore.div</dt><dd><p>Logical scalar, if <code>TRUE</code>, then the divergent
co-modules will be removed.</p>
</dd>
<dt>cor.limit</dt><dd><p>Numeric scalar, giving the correlation limit for the
&lsquo;<code>cor</code>&rsquo; method.</p>
</dd>
<dt>neg.cor</dt><dd><p>Logical scalar, if <code>TRUE</code>, then the
&lsquo;<code>cor</code>&rsquo; method considers the absolute value of the
correlation.</p>
</dd>
<dt>drop.zero</dt><dd><p>Logical scalar, whether to drop co-modules that have
all zero scores.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A named list, the filtered <code>pparesult</code>. See the return value of
<code><a href="#topic+ppa.iterate">ppa.iterate</a></code> for the details.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Kutalik Z, Bergmann S, Beckmann, J: A modular approach for integrative
analysis of large-scale gene-expression and drug-response data
<em>Nat Biotechnol</em> 2008 May; 26(5) 531-9.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ppa">ppa</a></code> for an easy way of running the PPA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an PPA module set
set.seed(1)
insili &lt;- ppa.in.silico(noise=0.01)

## Random seeds
seeds &lt;- generate.seeds(length=nrow(insili[[1]]), count=20)

## Normalize input matrix
nm &lt;- ppa.normalize(insili[1:2])

## Do PPA
ppares &lt;- ppa.iterate(nm, row1.seeds=seeds,
                      thr.row1=2, thr.row2=2, thr.col=1)

## Check correlation among modules
cc &lt;- cor(ppares$rows1)
if (interactive()) { hist(cc[lower.tri(cc)],10) }

## Some of them are quite high, how many?
undiag &lt;- function(x) { diag(x) &lt;- 0; x }
sum(undiag(cc) &gt; 0.99, na.rm=TRUE)

## Eliminate duplicated modules
ppares.unique &lt;- ppa.unique(nm, ppares)

## How many modules left?
ncol(ppares.unique$rows1)

## Double check
cc2 &lt;- cor(ppares.unique$rows1)
if (interactive()) { hist(cc2[lower.tri(cc2)],10) }

## High correlation?
sum(undiag(cc2) &gt; 0.99, na.rm=TRUE)

</code></pre>

<hr>
<h2 id='robustness'>Robustness of ISA biclusters and PPA co-modules</h2><span id='topic+robustness'></span><span id='topic+isa.filter.robust'></span><span id='topic+ppa.filter.robust'></span><span id='topic+robustness+2Clist-method'></span><span id='topic+isa.filter.robust+2Cmatrix-method'></span><span id='topic+ppa.filter.robust+2Clist-method'></span>

<h3>Description</h3>

<p>Robustness of ISA biclusters and PPA co-modules. The more robust
biclusters/co-modules are more significant in the sense that it is
less likely to see them in random data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
robustness(normed.data, ...)
## S4 method for signature 'matrix'
isa.filter.robust(data, ...)
## S4 method for signature 'list'
ppa.filter.robust(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robustness_+3A_normed.data">normed.data</code></td>
<td>
<p>The normalized input data, usually calculated with
<code><a href="#topic+isa.normalize">isa.normalize</a></code>.</p>
</td></tr>
<tr><td><code id="robustness_+3A_data">data</code></td>
<td>
<p>The original, not normalized input data, a matrix for
<code>isa.filter.robust</code>, a list of two matrices for
<code>ppa.filter.robust</code>.</p>
</td></tr>
<tr><td><code id="robustness_+3A_...">...</code></td>
<td>
<p>Additional arguments, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>robustness</code> can be called as
</p>
<pre>
    robustness(normed.data, row.scores, col.scores)
  </pre>
<p><code>isa.filter.robust</code> can be called as
</p>
<pre>
    isa.filter.robust(data, normed.data, isares,
                      perms = 1, row.seeds, col.seeds)
  </pre>
<p>and <code>ppa.filter.robust</code> can be called as
</p>
<pre>
    ppa.filter.robust(data, normed.data, ppares,
                      perms = 1, row1.seeds, col1.seeds,
		      row2.seeds, col2.seeds)
  </pre>
<p>These arguments are:
</p>

<dl>
<dt>normed.data</dt><dd><p>The normalized input data, usually calculated with
<code><a href="#topic+isa.normalize">isa.normalize</a></code> (for ISA) or
<code><a href="#topic+ppa.normalize">ppa.normalize</a></code> (for PPA).</p>
</dd>
<dt>row.scores</dt><dd><p>The scores of the row components of the
biclusters. Usually the <code>rows</code> member of the result list, as
returned by <code><a href="#topic+isa">isa</a></code>, or <code><a href="#topic+isa.iterate">isa.iterate</a></code> or some
other ISA function.</p>
</dd>
<dt>col.scores</dt><dd><p>The scores of the columns of the biclusters, usually
the <code>columns</code> member of the result list from
<code><a href="#topic+isa">isa</a></code>.</p>
</dd>
<dt>data</dt><dd><p>The original, not normalized input data.</p>
</dd>
<dt>isares</dt><dd><p>The result of ISA, coming from <code><a href="#topic+isa">isa</a></code> or
<code><a href="#topic+isa.iterate">isa.iterate</a></code> or any other function that return the same
format.</p>
</dd>
<dt>perms</dt><dd><p>The number of permutations to perform on the input data.</p>
</dd>
<dt>row.seeds</dt><dd><p>Optionally the row seeds for the ISA run on the
scrambled data. If this and <code>col.seeds</code> are both omitted the
same number of random seeds are used as for <code>isaresult</code>.</p>
</dd>
<dt>col.seeds</dt><dd><p>Optionally the column seed to use for the ISA on the
scrambled input matrix. If both this and <code>row.seeds</code> are
omitted, then the same number of random (row) seeds will be used as
for <code>isares</code>.</p>
</dd>
<dt>ppares</dt><dd><p>The result of a PPA run, the output of the
<code><a href="#topic+ppa.iterate">ppa.iterate</a></code> or the <code><a href="#topic+ppa.unique">ppa.unique</a></code>
function (or any other function that returns the same format).</p>
</dd>
<dt>row1.seeds</dt><dd><p>Optionally, the seeds based of the rows of the
first input matrix, can be given here. Otherwise random seeds are
used, the same number as it was used to find the original
co-modules.</p>
</dd>
<dt>col1.seeds</dt><dd><p>Optionally, the seeds based of the columns of the
first input matrix, can be given here. Otherwise random seeds are
used, the same number as it was used to find the original
co-modules.</p>
</dd>
<dt>row2.seeds</dt><dd><p>Optionally, the seeds based of the rows of the
second input matrix, can be given here. Otherwise random seeds are
used, the same number as it was used to find the original
co-modules.</p>
</dd>
<dt>col2.seeds</dt><dd><p>Optionally, the seeds based of the columns of the
second input matrix, can be given here. Otherwise random seeds are
used, the same number as it was used to find the original
co-modules.</p>
</dd>
</dl>

<p>Even if you generate a matrix with uniform random noise in it, if you
calculate ISA on it, you will get some biclusters, except maybe if you
use very strict threshold parameters. These biclusters contain rows
and columns that are correlated just by chance. The same is true for
PPA.
</p>
<p>To circumvent this, you can use the so-called robustness measure of
the biclusters/co-modules. The robustness of a bicluster is the
function of its rows, columns and the input data, and it is a real
number, usually positive. It is roughly equivalent to the principal
singular value of the submatrix (of the reordered input matrix)
defined by the bicluster.
</p>
<p><code>robustness</code> calculates the robustness score of a set of
biclusters/co-modules, usually coming from one or more ISA/PPA
iterations.
</p>
<p><code>isa.filter.robust</code> provides filtering based on the robustness
measure. It reshuffles the input matrix and calculates ISA on it, with
the parameters that were used to find the biclusters under
evaluation. It then calculates the robustness for the modules that
were found in the scrambled matrix (if there is any) and removes any
modules from the data set that have a lower robustness score than at
least one module in the scrambled data.
</p>
<p>You can think of <code>isa.filter.robust</code> as a permutation test, but
the input data is shuffled only once (at least by default), because of
the relatively high computational demands of the ISA.
</p>
<p><code>ppa.filter.robust</code> does essentially the same, but for PPA
co-modules.
</p>


<h3>Value</h3>

<p><code>robustness</code> returns a numeric vector, the robustness score of
each bicluster.
</p>
<p><code>isa.filter.robust</code> returns a named list, the filtered
<code>isares</code>, see the return value of <code><a href="#topic+isa.iterate">isa.iterate</a></code> for
the structure of the list.
</p>
<p><code>ppa.filter.robust</code> resturns a named list, the filtered
<code>ppares</code>, see the return value of <code><a href="#topic+ppa.iterate">ppa.iterate</a></code> for
the structure of the list.
</p>


<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:Gabor.Csardi@unil.ch">Gabor.Csardi@unil.ch</a> </p>


<h3>References</h3>

<p>Bergmann S, Ihmels J, Barkai N: Iterative signature algorithm for the
analysis of large-scale gene expression data <em>Phys Rev E Stat
Nonlin Soft Matter Phys.</em> 2003 Mar;67(3 Pt 1):031902. Epub 2003 Mar 11.
</p>
<p>Ihmels J, Friedlander G, Bergmann S, Sarig O, Ziv Y, Barkai N:
Revealing modular organization in the yeast transcriptional network
<em>Nat Genet.</em> 2002 Aug;31(4):370-7. Epub 2002 Jul 22
</p>
<p>Ihmels J, Bergmann S, Barkai N:
Defining transcription modules using large-scale gene expression data
<em>Bioinformatics</em> 2004 Sep 1;20(13):1993-2003. Epub 2004 Mar 25.
</p>
<p>Kutalik Z, Bergmann S, Beckmann, J: A modular approach for integrative
analysis of large-scale gene-expression and drug-response data
<em>Nat Biotechnol</em> 2008 May; 26(5) 531-9.
</p>


<h3>See Also</h3>

 <p><a href="#topic+isa2-package">isa2-package</a> for a short introduction on the Iterative
Signature Algorithm. See <code><a href="#topic+isa">isa</a></code> for an easy way of running
ISA, <code><a href="#topic+ppa">ppa</a></code> for an easy way of running the PPA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A basic ISA work flow for a single threshold combination
## In-silico data
set.seed(1)
insili &lt;- isa.in.silico()

## Random seeds
seeds &lt;- generate.seeds(length=nrow(insili[[1]]), count=100)

## Normalize input matrix
nm &lt;- isa.normalize(insili[[1]])

## Do ISA
isares &lt;- isa.iterate(nm, row.seeds=seeds, thr.row=2, thr.col=1)

## Eliminate duplicates
isares &lt;- isa.unique(nm, isares)

## Calculate robustness
rob &lt;- robustness(nm, isares$rows, isares$columns)
rob

## There are three robust ones and a lot of less robust ones
## Plot the three robust ones and three others
if (interactive()) {
  toplot1 &lt;- rev(order(rob))[1:3]
  toplot2 &lt;- sample(seq_along(rob)[-toplot1], 3)
  layout( rbind(1:3,4:6) )
  for (i in c(toplot1, toplot2)) {
    image(outer(isares$rows[,i], isares$column[,i]),
          main=round(rob[i],2))
  }
}

## Filter out not robust ones
isares2 &lt;- isa.filter.robust(insili[[1]], nm, isares)

## Probably there are only three of them left
ncol(isares2$rows)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
