<!DOCTYPE html><html lang="en"><head><title>Help for package TMTI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TMTI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjust_LocalTest'><p>Adjust all p-values using a Closed Testing Procedure and a</p>
user-defined local test which satisfies the quadratic shortcut given in Mogensen and Markussen (2021)</a></li>
<li><a href='#adjust_TMTI'><p>Adjust all p-values using a Closed Testing Procedeure and the</p>
TMTI family of tests.</a></li>
<li><a href='#CTP_LocalTest'><p>A Closed Testing Procedure for any local test satisfying the conditions of Mogensen and Markussen (2021) using an O(n^2) shortcut.</p></a></li>
<li><a href='#CTP_TMTI'><p>A Closed Testing Procedure for the TMTI using an O(n^2) shortcut</p></a></li>
<li><a href='#FullCTP_C'><p>Leading NA</p></a></li>
<li><a href='#FWER_set_C'><p>Leading NA</p></a></li>
<li><a href='#gamma_bootstrapper'><p>Function to bootstrap the Cumulative Distribution Functions (CDFs) of the TMTI statistics.</p></a></li>
<li><a href='#gamma_bootstrapper_Ttest'><p>Compute a list of TMTI CDFs for one- and two-sample test scenarios</p></a></li>
<li><a href='#kFWER_LocalTest'><p>kFWER_LocalTest. Computes the largest rejection set possible with kFWER control.</p></a></li>
<li><a href='#kFWER_set_C'><p>Leading NA</p></a></li>
<li><a href='#kFWER_TMTI'><p>kFWER_TMTI. Computes the largest rejection set possible with kFWER control.</p></a></li>
<li><a href='#MakeY_C'><p>Leading NA</p></a></li>
<li><a href='#MakeZ_C'><p>Leading NA</p></a></li>
<li><a href='#MakeZ_C_nsmall'><p>Leading NA</p></a></li>
<li><a href='#rtTMTI_CDF'><p>Computes the analytical version of the rtMTI_infty CDF. When m&gt;100, this should</p>
not be used.</a></li>
<li><a href='#TestSet_C'><p>Leading NA</p></a></li>
<li><a href='#TestSet_LocalTest'><p>Test a subset of hypotheses in its closure using a user-specified local test</p></a></li>
<li><a href='#TestSet_TMTI'><p>Test a subset of hypotheses in its closure using the TMTI</p></a></li>
<li><a href='#TMTI'><p>Computes the TMTI test for a joint hypothesis given input p-values.</p></a></li>
<li><a href='#TMTI_CDF'><p>Computes the analytical version of the TMTI_infty CDF. When m&gt;100, this should</p>
not be used.</a></li>
<li><a href='#TopDown_C'><p>Leading NA</p></a></li>
<li><a href='#TopDown_C_binary'><p>Leading NA</p></a></li>
<li><a href='#TopDown_C_binary_subset'><p>Leading NA</p></a></li>
<li><a href='#TopDown_LocalTest'><p>TopDown LocalTest algorithm for estimating a 1-alpha confidence set for the number</p>
of false hypotheses among a set.</a></li>
<li><a href='#TopDown_TMTI'><p>TopDown TMTI algorithm for estimating a 1-alpha confidence set for the number</p>
of false hypotheses among a set.</a></li>
<li><a href='#tTMTI_CDF'><p>Computes the analytical version of the tTMTI_infty CDF. When m&gt;100, this should</p>
not be used.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Too Many, Too Improbable (TMTI) Test Procedures</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Phillip B. Mogensen [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Phillip B. Mogensen &lt;pbm@math.ku.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for computing joint tests, controlling the Familywise Error Rate (FWER) and getting lower bounds on the number of false hypotheses in a set. The methods implemented here are described in Mogensen and Markussen (2021) &lt;<a href="https://doi.org/10.48550%2FarXiv.2108.04731">doi:10.48550/arXiv.2108.04731</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-25 22:12:23 UTC; phillipbredahl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-29 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjust_LocalTest'>Adjust all p-values using a Closed Testing Procedure and a
user-defined local test which satisfies the quadratic shortcut given in Mogensen and Markussen (2021)</h2><span id='topic+adjust_LocalTest'></span>

<h3>Description</h3>

<p>Adjust all p-values using a Closed Testing Procedure and a
user-defined local test which satisfies the quadratic shortcut given in Mogensen and Markussen (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_LocalTest(
  LocalTest,
  pvals,
  alpha = 0.05,
  is.sorted = FALSE,
  EarlyStop = FALSE,
  verbose = FALSE,
  mc.cores = 1L,
  chunksize = 4 * mc.cores,
  direction = "increasing",
  parallel.direction = "breadth",
  AdjustAll = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust_LocalTest_+3A_localtest">LocalTest</code></td>
<td>
<p>A function specifying a local test.</p>
</td></tr>
<tr><td><code id="adjust_LocalTest_+3A_pvals">pvals</code></td>
<td>
<p>vector of p-values.</p>
</td></tr>
<tr><td><code id="adjust_LocalTest_+3A_alpha">alpha</code></td>
<td>
<p>significance level. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="adjust_LocalTest_+3A_is.sorted">is.sorted</code></td>
<td>
<p>Logical, indicating whether the supplied p-values are already
sorted. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="adjust_LocalTest_+3A_earlystop">EarlyStop</code></td>
<td>
<p>Logical; set to TRUE to stop as soon as a hypothesis can be
accepted at level alpha. This speeds up the procedure, but now only provides
upper bounds on the adjusted p-values that are below alpha.</p>
</td></tr>
<tr><td><code id="adjust_LocalTest_+3A_verbose">verbose</code></td>
<td>
<p>Logical; set to TRUE to print progress. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="adjust_LocalTest_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to parallelize onto.</p>
</td></tr>
<tr><td><code id="adjust_LocalTest_+3A_chunksize">chunksize</code></td>
<td>
<p>Integer indicating the size of chunks to parallelize. E.g.,
if setting chunksize = mc.cores, each time a parallel computation is set up,
each worker will perform only a single task. If mc.cores &gt; chunksize, some
threads will be inactive.</p>
</td></tr>
<tr><td><code id="adjust_LocalTest_+3A_direction">direction</code></td>
<td>
<p>String that is equal to either &quot;increasing&quot;/&quot;i&quot;, &quot;decreasing&quot;/&quot;d&quot; or &quot;binary&quot;/&quot;b&quot;.
Determines the search direction. When set to&quot;increasing&quot;, the function computes the exact adjusted p-value
for all those hypotheses that can be rejected (while controlling the FWER),
but is potentially slower than &quot;decreasing&quot;. &quot;decreasing&quot;identifies all hypotheses that can
be rejected with FWER control, but does not compute the actual adjusted p-values.
&quot;binary&quot; performs a binary search for the number of hypotheses
that can be rejected with FWER control.  Defaults to &quot;increasing&quot;. Note that
'binary' does not work with parallel.direction == 'breadth'.</p>
</td></tr>
<tr><td><code id="adjust_LocalTest_+3A_parallel.direction">parallel.direction</code></td>
<td>
<p>A string that is either &quot;breadth&quot; or &quot;depth&quot;
(or abbreviated to &quot;b&quot; or &quot;d), indicating in which direction to parallelize.
Breadth-first parallelization uses a more efficient C++ implementation to
adjust each p-value, but depth-first parallelization potentially finishes
faster if using early stopping (EarlyStop = TRUE) and very few hypotheses
can be rejected.</p>
</td></tr>
<tr><td><code id="adjust_LocalTest_+3A_adjustall">AdjustAll</code></td>
<td>
<p>Logical, indicating whether to adjust all p-values (TRUE)
or only those that are marginally significant (FALSE). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="adjust_LocalTest_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame containing adjusted p-values and their respective indices.
If direction == 'decreasing' or 'binary', an integer describing the number of
hypotheses that can be rejected with FWER control is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sort(runif(100)) # Simulate and sort p-values
p[1:10] = p[1:10]**3 # Make the bottom 10 smaller, such that they correspond to false hypotheses
adjust_LocalTest(
  LocalTest = function(x) {
    min(c(1, length(x) * min(x)))
  },
  p, alpha = 0.05, is.sorted = TRUE
)
</code></pre>

<hr>
<h2 id='adjust_TMTI'>Adjust all p-values using a Closed Testing Procedeure and the
TMTI family of tests.</h2><span id='topic+adjust_TMTI'></span>

<h3>Description</h3>

<p>Adjust all p-values using a Closed Testing Procedeure and the
TMTI family of tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_TMTI(
  pvals,
  alpha = 0.05,
  B = 1000,
  gammaList = NULL,
  tau = NULL,
  K = NULL,
  is.sorted = FALSE,
  EarlyStop = FALSE,
  verbose = FALSE,
  mc.cores = 1L,
  chunksize = 4 * mc.cores,
  direction = "increasing",
  parallel.direction = "breadth",
  AdjustAll = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust_TMTI_+3A_pvals">pvals</code></td>
<td>
<p>vector of p-values.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_alpha">alpha</code></td>
<td>
<p>significance level. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replications. Only relevant if length(pvals) &gt; 100
and no gammaList is supplied.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_gammalist">gammaList</code></td>
<td>
<p>A list of functions. These functions should be the CDFs of
the chosen TMTI test for different m.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_tau">tau</code></td>
<td>
<p>Number between 0 and 1 or NULL, describing the truncation level.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_k">K</code></td>
<td>
<p>Integer between &gt;1 and m describing the truncation index.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_is.sorted">is.sorted</code></td>
<td>
<p>Logical, indicating whether the supplied p-values are already
sorted. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_earlystop">EarlyStop</code></td>
<td>
<p>Logical; set to TRUE to stop as soon as a hypothesis can be
accepted at level alpha. This speeds up the procedure, but now only provides
upper bounds on the adjusted p-values that are below alpha.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_verbose">verbose</code></td>
<td>
<p>Logical; set to TRUE to print progress. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to parallelize onto.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_chunksize">chunksize</code></td>
<td>
<p>Integer indicating the size of chunks to parallelize. E.g.,
if setting chunksize = mc.cores, each time a parallel computation is set up,
each worker will perform only a single task. If mc.cores &gt; chunksize, some
threads will be inactive.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_direction">direction</code></td>
<td>
<p>String that is equal to either &quot;increasing&quot;/&quot;i&quot;, &quot;decreasing&quot;/&quot;d&quot; or &quot;binary&quot;/&quot;b&quot;.
Determines the search direction. When set to&quot;increasing&quot;, the function computes the exact adjusted p-value
for all those hypotheses that can be rejected (while controlling the FWER),
but is potentially slower than &quot;decreasing&quot;. &quot;decreasing&quot;identifies all hypotheses that can
be rejected with FWER control, but does not compute the actual adjusted p-values.
&quot;binary&quot; performs a binary search for the number of hypotheses
that can be rejected with FWER control.  Defaults to &quot;increasing&quot;. Note that
'binary' does not work with parallel.direction == 'breadth'.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_parallel.direction">parallel.direction</code></td>
<td>
<p>A string that is either &quot;breadth&quot; or &quot;depth&quot;
(or abbreviated to &quot;b&quot; or &quot;d), indicating in which direction to parallelize.
Breadth-first parallelization uses a more efficient C++ implementation to
adjust each p-value, but depth-first parallelization potentially finishes
faster if using early stopping (EarlyStop = TRUE) and very few hypotheses
can be rejected.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_adjustall">AdjustAll</code></td>
<td>
<p>Logical, indicating whether to adjust all p-values (TRUE)
or only those that are marginally significant (FALSE). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="adjust_TMTI_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame containing adjusted p-values and their respective indices.
If direction == 'decreasing' or 'binary', an integer describing the number of
hypotheses that can be rejected with FWER control is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sort(runif(100)) # Simulate and sort p-values
p[1:10] = p[1:10]**3 # Make the bottom 10 smaller, such that they correspond to false hypotheses
adjust_TMTI(p, alpha = 0.05, is.sorted = TRUE)
</code></pre>

<hr>
<h2 id='CTP_LocalTest'>A Closed Testing Procedure for any local test satisfying the conditions of Mogensen and Markussen (2021) using an O(n^2) shortcut.</h2><span id='topic+CTP_LocalTest'></span><span id='topic+localTest_CTP'></span>

<h3>Description</h3>

<p>A Closed Testing Procedure for any local test satisfying the conditions of Mogensen and Markussen (2021) using an O(n^2) shortcut.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTP_LocalTest(
  LocalTest,
  pvals,
  alpha = 0.05,
  is.sorted = FALSE,
  EarlyStop = FALSE,
  ...
)

localTest_CTP(localTest, pvals, alpha = 0.05, is.sorted = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTP_LocalTest_+3A_localtest">LocalTest</code></td>
<td>
<p>A function which defines the choice of local test to use.</p>
</td></tr>
<tr><td><code id="CTP_LocalTest_+3A_pvals">pvals</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="CTP_LocalTest_+3A_alpha">alpha</code></td>
<td>
<p>Level to perform each intersection test at. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="CTP_LocalTest_+3A_is.sorted">is.sorted</code></td>
<td>
<p>Logical, indicating whether the supplied p-values are already
is.sorted. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="CTP_LocalTest_+3A_earlystop">EarlyStop</code></td>
<td>
<p>Logical indicating whether to exit as soon as a non-significant
p-value is found. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="CTP_LocalTest_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="CTP_LocalTest_+3A_localtest">localTest</code></td>
<td>
<p>A function specifying a local test (deprecated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing adjusted p-values and the original index of
the p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate some p-values
## The first 10 are from false hypotheses, the next 10 are from true
pvals = c(
  rbeta(10, 1, 20), ## Mean value of .05
  runif(10)
)
## Perform the CTP using a local Bonferroni test
CTP_LocalTest(function(x) {
  min(c(length(x) * min(x), 1))
}, pvals)

</code></pre>

<hr>
<h2 id='CTP_TMTI'>A Closed Testing Procedure for the TMTI using an O(n^2) shortcut</h2><span id='topic+CTP_TMTI'></span><span id='topic+TMTI_CTP'></span>

<h3>Description</h3>

<p>A Closed Testing Procedure for the TMTI using an O(n^2) shortcut
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTP_TMTI(
  pvals,
  alpha = 0.05,
  B = 1000,
  gammaList = NULL,
  tau = NULL,
  K = NULL,
  is.sorted = FALSE,
  EarlyStop = FALSE,
  ...
)

TMTI_CTP(
  pvals,
  alpha = 0.05,
  B = 1000,
  gammaList = NULL,
  tau = NULL,
  K = NULL,
  is.sorted = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTP_TMTI_+3A_pvals">pvals</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="CTP_TMTI_+3A_alpha">alpha</code></td>
<td>
<p>Level to perform each intersection test at. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="CTP_TMTI_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replications if gamma needs to be approximated.
Not used if specifying a list of functions using the gammaList argument
or if length(pvals) &lt;= 100. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="CTP_TMTI_+3A_gammalist">gammaList</code></td>
<td>
<p>A list of pre-specified gamma functions. If NULL, gamma
functions will be approximated via bootstrap, assuming independence. Defaults
to NULL.</p>
</td></tr>
<tr><td><code id="CTP_TMTI_+3A_tau">tau</code></td>
<td>
<p>Numerical (in (0,1)); threshold to use in tTMTI. If set to NULL,
then either TMTI (default) or rtTMTI is used.</p>
</td></tr>
<tr><td><code id="CTP_TMTI_+3A_k">K</code></td>
<td>
<p>Integer; Number of smallest p-values to use in rtTMTI. If se to NULL,
then either TMTI (default) or tTMTI is used.</p>
</td></tr>
<tr><td><code id="CTP_TMTI_+3A_is.sorted">is.sorted</code></td>
<td>
<p>Logical, indicating the p-values are pre-sorted. Defaults
to FALSE.</p>
</td></tr>
<tr><td><code id="CTP_TMTI_+3A_earlystop">EarlyStop</code></td>
<td>
<p>Logical indicating whether to exit as soon as a non-significant
p-value is found. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="CTP_TMTI_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing adjusted p-values and the original index of
the p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate some p-values
## The first 10 are from false hypotheses, the next 10 are from true
pvals = c(
  rbeta(10, 1, 20), ## Mean value of .05
  runif(10)
)
CTP_TMTI(pvals)

</code></pre>

<hr>
<h2 id='FullCTP_C'>Leading NA</h2><span id='topic+FullCTP_C'></span>

<h3>Description</h3>

<p>Tests a user-specified subset in a CTP, using a user-supplied local test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FullCTP_C(LocalTest, f, pvals, EarlyStop, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FullCTP_C_+3A_localtest">LocalTest</code></td>
<td>
<p>A function that returns a double in (0, 1).</p>
</td></tr>
<tr><td><code id="FullCTP_C_+3A_f">f</code></td>
<td>
<p>A function that iterates LocalTest over the relevant test tree.
In practice, this is called as TestSet_C.</p>
</td></tr>
<tr><td><code id="FullCTP_C_+3A_pvals">pvals</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="FullCTP_C_+3A_earlystop">EarlyStop</code></td>
<td>
<p>Logical indicating whether to exit as soon as a non-significant
p-value is found.</p>
</td></tr>
<tr><td><code id="FullCTP_C_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. This is only used if EarlyStop = TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='FWER_set_C'>Leading NA</h2><span id='topic+FWER_set_C'></span>

<h3>Description</h3>

<p>Computes a the number of hypotheses that can be rejected with FWER control by
using a binary search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FWER_set_C(LocalTest, pvals, alpha, low, high, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FWER_set_C_+3A_localtest">LocalTest</code></td>
<td>
<p>A function that returns a double in (0, 1).</p>
</td></tr>
<tr><td><code id="FWER_set_C_+3A_pvals">pvals</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="FWER_set_C_+3A_alpha">alpha</code></td>
<td>
<p>A double indicating the significance level</p>
</td></tr>
<tr><td><code id="FWER_set_C_+3A_low">low</code></td>
<td>
<p>integer denoting the starting point for the search. Should start at zero.</p>
</td></tr>
<tr><td><code id="FWER_set_C_+3A_high">high</code></td>
<td>
<p>integer denoting the end point of the search. Should end at pvals.size() - 1.</p>
</td></tr>
<tr><td><code id="FWER_set_C_+3A_verbose">verbose</code></td>
<td>
<p>boolean, indicating whether to print progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of hypotheses that can be rejected with kFWER control at a user
specific k.
</p>

<hr>
<h2 id='gamma_bootstrapper'>Function to bootstrap the Cumulative Distribution Functions (CDFs) of the TMTI statistics.</h2><span id='topic+gamma_bootstrapper'></span>

<h3>Description</h3>

<p>Function to bootstrap the Cumulative Distribution Functions (CDFs) of the TMTI statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_bootstrapper(m, n = Inf, B = 1000, mc.cores = 1L, tau = NULL, K = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamma_bootstrapper_+3A_m">m</code></td>
<td>
<p>Number of tests.</p>
</td></tr>
<tr><td><code id="gamma_bootstrapper_+3A_n">n</code></td>
<td>
<p>Number (or Inf) indicating what kind of minimum to consider.
Defaults to Inf, corresponding to the global minimum.</p>
</td></tr>
<tr><td><code id="gamma_bootstrapper_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates. Rule of thumb is to use at least
10 * m.</p>
</td></tr>
<tr><td><code id="gamma_bootstrapper_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Integer denoting the number of cores to use when using
parallelization, Defaults to 1, corresponding to single-threaded computations.</p>
</td></tr>
<tr><td><code id="gamma_bootstrapper_+3A_tau">tau</code></td>
<td>
<p>Numerical (in (0,1)); threshold to use in tTMTI. If set to NULL,
then either TMTI (default) or rtTMTI is used.</p>
</td></tr>
<tr><td><code id="gamma_bootstrapper_+3A_k">K</code></td>
<td>
<p>Integer; Number of smallest p-values to use in rtTMTI. If se to NULL,
then either TMTI (default) or tTMTI is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An approximation of the function <code class="reqn">\gamma^m(x)</code> under the
assumption that all p-values are independent and exactly uniform.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get an approximation of gamma
gamma_function = gamma_bootstrapper(10)
## Evaluate it in a number, say .2
gamma_function(.2)
</code></pre>

<hr>
<h2 id='gamma_bootstrapper_Ttest'>Compute a list of TMTI CDFs for one- and two-sample test scenarios</h2><span id='topic+gamma_bootstrapper_Ttest'></span>

<h3>Description</h3>

<p>Compute a list of TMTI CDFs for one- and two-sample test scenarios
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_bootstrapper_Ttest(
  Y,
  X = NULL,
  n = Inf,
  B = 1000,
  mc.cores = 1L,
  tau = NULL,
  K = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamma_bootstrapper_Ttest_+3A_y">Y</code></td>
<td>
<p>A d*m matrix of m response variables with d observations. Can
contain missing values in places.</p>
</td></tr>
<tr><td><code id="gamma_bootstrapper_Ttest_+3A_x">X</code></td>
<td>
<p>Null if one-sample, a vector with only two unique values if
two-sample.</p>
</td></tr>
<tr><td><code id="gamma_bootstrapper_Ttest_+3A_n">n</code></td>
<td>
<p>Number (or Inf) indicating what kind of minimum to consider.
Defaults to Inf, corresponding to the global minimum.</p>
</td></tr>
<tr><td><code id="gamma_bootstrapper_Ttest_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates. Rule of thumb is to use at least
10 * m.</p>
</td></tr>
<tr><td><code id="gamma_bootstrapper_Ttest_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Integer denoting the number of cores to use when using
parallelization, Defaults to 1, corresponding to single-threaded computations.</p>
</td></tr>
<tr><td><code id="gamma_bootstrapper_Ttest_+3A_tau">tau</code></td>
<td>
<p>Numerical (in (0,1)); threshold to use in tTMTI. If set to NULL,
then either TMTI (default) or rtTMTI is used.</p>
</td></tr>
<tr><td><code id="gamma_bootstrapper_Ttest_+3A_k">K</code></td>
<td>
<p>Integer; Number of smallest p-values to use in rtTMTI. If se to NULL,
then either TMTI (default) or tTMTI is used.</p>
</td></tr>
<tr><td><code id="gamma_bootstrapper_Ttest_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating whether or not to print progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of bootstrapped TMTI CDFs that can be used directly in the
CTP_TMTI function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d = 100
m = 3

X = sample(LETTERS[1:2], d, replace = TRUE)
Y = matrix(rnorm(d * m), nrow = d, ncol = m)
pvalues = apply(Y, 2, function(y) t.test(y ~ X)$p.value)

gammaFunctions = gamma_bootstrapper_Ttest(Y, X) # Produces a list of CDFs
CTP_TMTI(pvalues, gammaList = gammaFunctions) # Adjusted p-values using the bootstrapped CDFs

</code></pre>

<hr>
<h2 id='kFWER_LocalTest'>kFWER_LocalTest. Computes the largest rejection set possible with kFWER control.</h2><span id='topic+kFWER_LocalTest'></span>

<h3>Description</h3>

<p>kFWER_LocalTest. Computes the largest rejection set possible with kFWER control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kFWER_LocalTest(LocalTest, pvals, k, alpha = 0.05, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kFWER_LocalTest_+3A_localtest">LocalTest</code></td>
<td>
<p>A function that returns a p-value for a joint hypothesis test.</p>
</td></tr>
<tr><td><code id="kFWER_LocalTest_+3A_pvals">pvals</code></td>
<td>
<p>A vector p-values.</p>
</td></tr>
<tr><td><code id="kFWER_LocalTest_+3A_k">k</code></td>
<td>
<p>An integer denoting the desired k at which to control the kFWER.</p>
</td></tr>
<tr><td><code id="kFWER_LocalTest_+3A_alpha">alpha</code></td>
<td>
<p>Significance level.</p>
</td></tr>
<tr><td><code id="kFWER_LocalTest_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating whether or not to print progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of marginal hypotheses that can be rejected with kFWER control.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nfalse = 50
m = 100
pvals = c (
  sort(runif(nfalse, 0, 0.05 / m)),
  sort(runif(m - nfalse, 0.1, 1))
)
kFWER_LocalTest (
  LocalTest = function (x) min(x) * length(x),
  pvals = pvals,
  k = 5,
  alpha = 0.05,
  verbose = FALSE
)
</code></pre>

<hr>
<h2 id='kFWER_set_C'>Leading NA</h2><span id='topic+kFWER_set_C'></span>

<h3>Description</h3>

<p>Computes a confidence set for the number of false hypotheses among a subset of
using a binary search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kFWER_set_C(LocalTest, pvals, k, alpha, low, high, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kFWER_set_C_+3A_localtest">LocalTest</code></td>
<td>
<p>A function that returns a double in (0, 1).</p>
</td></tr>
<tr><td><code id="kFWER_set_C_+3A_pvals">pvals</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="kFWER_set_C_+3A_k">k</code></td>
<td>
<p>integer denoting the k to control the kFWER at.</p>
</td></tr>
<tr><td><code id="kFWER_set_C_+3A_alpha">alpha</code></td>
<td>
<p>A double indicating the significance level</p>
</td></tr>
<tr><td><code id="kFWER_set_C_+3A_low">low</code></td>
<td>
<p>integer denoting the starting point for the search. Should start at zero.</p>
</td></tr>
<tr><td><code id="kFWER_set_C_+3A_high">high</code></td>
<td>
<p>integer denoting the end point of the search. Should end at pvals.size() - 1.</p>
</td></tr>
<tr><td><code id="kFWER_set_C_+3A_verbose">verbose</code></td>
<td>
<p>boolean, indicating whether to print progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of hypotheses that can be rejected with kFWER control at a user
specific k.
</p>

<hr>
<h2 id='kFWER_TMTI'>kFWER_TMTI. Computes the largest rejection set possible with kFWER control.</h2><span id='topic+kFWER_TMTI'></span>

<h3>Description</h3>

<p>kFWER_TMTI. Computes the largest rejection set possible with kFWER control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kFWER_TMTI(
  pvals,
  k,
  alpha = 0.05,
  B = 1000,
  gammaList = NULL,
  tau = NULL,
  K = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kFWER_TMTI_+3A_pvals">pvals</code></td>
<td>
<p>A vector p-values.</p>
</td></tr>
<tr><td><code id="kFWER_TMTI_+3A_k">k</code></td>
<td>
<p>An integer denoting the desired k at which to control the kFWER.</p>
</td></tr>
<tr><td><code id="kFWER_TMTI_+3A_alpha">alpha</code></td>
<td>
<p>Significance level.</p>
</td></tr>
<tr><td><code id="kFWER_TMTI_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replications if gamma needs to be approximated.
Not used if specifying a list of functions using the gammaList argument
or if length(pvals) &lt;= 100. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="kFWER_TMTI_+3A_gammalist">gammaList</code></td>
<td>
<p>A list of pre-specified gamma functions. If NULL, gamma
functions will be approximated via bootstrap, assuming independence. Defaults
to NULL.</p>
</td></tr>
<tr><td><code id="kFWER_TMTI_+3A_tau">tau</code></td>
<td>
<p>Numerical (in (0,1)); threshold to use in tTMTI. If set to NULL,
then either TMTI (default) or rtTMTI is used.</p>
</td></tr>
<tr><td><code id="kFWER_TMTI_+3A_k">K</code></td>
<td>
<p>Integer; Number of smallest p-values to use in rtTMTI. If se to NULL,
then either TMTI (default) or tTMTI is used.</p>
</td></tr>
<tr><td><code id="kFWER_TMTI_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating whether or not to print progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of marginal hypotheses that can be rejected with kFWER control.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nfalse = 50
m = 100
pvals = c (
  sort(runif(nfalse, 0, 0.05 / m)),
  sort(runif(m - nfalse, 0.1, 1))
)
kFWER_TMTI (
  pvals = pvals,
  k = 5,
  alpha = 0.05,
  verbose = FALSE
)
</code></pre>

<hr>
<h2 id='MakeY_C'>Leading NA</h2><span id='topic+MakeY_C'></span>

<h3>Description</h3>

<p>Returns the transformed p-values (Y) from pre-sorted p-values and
pre-truncated p-values. If not truncation is used, set m_full = m
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeY_C(pvals, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakeY_C_+3A_pvals">pvals</code></td>
<td>
<p>A NumericVector containing the truncated sorted p-values. It
is important that this vector: 1) contains only the truncated p-values (i.e,
those that fall below the truncation point) and 2) is sorted.</p>
</td></tr>
<tr><td><code id="MakeY_C_+3A_m">m</code></td>
<td>
<p>The total (i.e., non-truncated) number of p-values.</p>
</td></tr>
</table>

<hr>
<h2 id='MakeZ_C'>Leading NA</h2><span id='topic+MakeZ_C'></span>

<h3>Description</h3>

<p>Returns the TMTI_infinity statistic from pre-sorted,
pre-truncated vector of p-values. If no truncation is used, set m_full = m
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeZ_C(pvals, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakeZ_C_+3A_pvals">pvals</code></td>
<td>
<p>A NumericVector containing the truncated sorted p-values. It
is important that this vector: 1) contains only the truncated p-values (i.e,
those that fall below the truncation point) and 2) is sorted.</p>
</td></tr>
<tr><td><code id="MakeZ_C_+3A_m">m</code></td>
<td>
<p>The total (i.e., non-truncated) number of p-values.</p>
</td></tr>
</table>

<hr>
<h2 id='MakeZ_C_nsmall'>Leading NA</h2><span id='topic+MakeZ_C_nsmall'></span>

<h3>Description</h3>

<p>Returns the transformed p-values (Y) from pre-sorted p-values and
pre-truncated p-values when n &lt; m - 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeZ_C_nsmall(pvals, n, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakeZ_C_nsmall_+3A_pvals">pvals</code></td>
<td>
<p>A NumericVector containing the truncated sorted p-values. It
is important that this vector: 1) contains only the truncated p-values (i.e,
those that fall below the truncation point) and 2) is sorted.</p>
</td></tr>
<tr><td><code id="MakeZ_C_nsmall_+3A_n">n</code></td>
<td>
<p>A positive number (or Inf) indicating which type of local minimum
to consider. Defaults to Infm, corresponding to the global minimum.</p>
</td></tr>
<tr><td><code id="MakeZ_C_nsmall_+3A_m">m</code></td>
<td>
<p>The total (i.e., non-truncated) number of p-values.</p>
</td></tr>
</table>

<hr>
<h2 id='rtTMTI_CDF'>Computes the analytical version of the rtMTI_infty CDF. When m&gt;100, this should
not be used.</h2><span id='topic+rtTMTI_CDF'></span>

<h3>Description</h3>

<p>Computes the analytical version of the rtMTI_infty CDF. When m&gt;100, this should
not be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtTMTI_CDF(x, m, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rtTMTI_CDF_+3A_x">x</code></td>
<td>
<p>Point in which to evaluate the CDF.</p>
</td></tr>
<tr><td><code id="rtTMTI_CDF_+3A_m">m</code></td>
<td>
<p>Number of independent tests to combine.</p>
</td></tr>
<tr><td><code id="rtTMTI_CDF_+3A_k">K</code></td>
<td>
<p>Integer; the truncation point to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The probability that the test statistic is at most x assuming
independence under the global null hypothesis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rtTMTI_CDF(0.05, 100, 10)
</code></pre>

<hr>
<h2 id='TestSet_C'>Leading NA</h2><span id='topic+TestSet_C'></span>

<h3>Description</h3>

<p>Tests a user-specified subset in a CTP, using a user-supplied local test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestSet_C(
  LocalTest,
  pSub,
  pRest,
  alpha,
  is_subset_sequence,
  EarlyStop,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TestSet_C_+3A_localtest">LocalTest</code></td>
<td>
<p>A function that returns a double in (0, 1).</p>
</td></tr>
<tr><td><code id="TestSet_C_+3A_psub">pSub</code></td>
<td>
<p>A vector with the p-values of the set to be tested.</p>
</td></tr>
<tr><td><code id="TestSet_C_+3A_prest">pRest</code></td>
<td>
<p>A vector containing the remaining p-values.</p>
</td></tr>
<tr><td><code id="TestSet_C_+3A_alpha">alpha</code></td>
<td>
<p>Double indicating the significance level.</p>
</td></tr>
<tr><td><code id="TestSet_C_+3A_is_subset_sequence">is_subset_sequence</code></td>
<td>
<p>Logical indicating whether the supplied subset of
p_values corresponds to the pSub.size() smallest overall p-values.</p>
</td></tr>
<tr><td><code id="TestSet_C_+3A_earlystop">EarlyStop</code></td>
<td>
<p>Logical indicating whether to exit as soon as a non-significant
p-value is found.</p>
</td></tr>
<tr><td><code id="TestSet_C_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to print progress.</p>
</td></tr>
</table>

<hr>
<h2 id='TestSet_LocalTest'>Test a subset of hypotheses in its closure using a user-specified local test</h2><span id='topic+TestSet_LocalTest'></span><span id='topic+TestSet_localTest'></span>

<h3>Description</h3>

<p>Test a subset of hypotheses in its closure using a user-specified local test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestSet_LocalTest(
  LocalTest,
  pvals,
  subset,
  alpha = 0.05,
  EarlyStop = FALSE,
  verbose = FALSE,
  mc.cores = 1L,
  chunksize = 4 * mc.cores,
  is.sorted = FALSE,
  ...
)

TestSet_localTest(
  localTest,
  pvals,
  subset,
  alpha = 0.05,
  EarlyStop = FALSE,
  verbose = FALSE,
  mc.cores = 1L,
  chunksize = 4 * mc.cores,
  is.sorted = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TestSet_LocalTest_+3A_localtest">LocalTest</code></td>
<td>
<p>Function which defines a combination test.</p>
</td></tr>
<tr><td><code id="TestSet_LocalTest_+3A_pvals">pvals</code></td>
<td>
<p>Numeric vector of p-values.</p>
</td></tr>
<tr><td><code id="TestSet_LocalTest_+3A_subset">subset</code></td>
<td>
<p>Numeric vector; the subset to be tested.</p>
</td></tr>
<tr><td><code id="TestSet_LocalTest_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; the level to test at, if stopping early. Defaults
to 0.05.</p>
</td></tr>
<tr><td><code id="TestSet_LocalTest_+3A_earlystop">EarlyStop</code></td>
<td>
<p>Logical; set to TRUE to stop as soon as a hypothesis can be
accepted at level alpha. This speeds up the procedure, but now only provides
lower bounds on the p-values for the global test.</p>
</td></tr>
<tr><td><code id="TestSet_LocalTest_+3A_verbose">verbose</code></td>
<td>
<p>Logical; set to TRUE to print progress.</p>
</td></tr>
<tr><td><code id="TestSet_LocalTest_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to parallelize onto.</p>
</td></tr>
<tr><td><code id="TestSet_LocalTest_+3A_chunksize">chunksize</code></td>
<td>
<p>Integer indicating the size of chunks to parallelize. E.g.,
if setting chunksize = mc.cores, each time a parallel computation is set up,
each worker will perform only a single task. If mc.cores &gt; chunksize, some
threads will be inactive.</p>
</td></tr>
<tr><td><code id="TestSet_LocalTest_+3A_is.sorted">is.sorted</code></td>
<td>
<p>Logical, indicating whether the supplied p-values are already
is.sorted. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="TestSet_LocalTest_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="TestSet_LocalTest_+3A_localtest">localTest</code></td>
<td>
<p>A function specifying a local test (deprecated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjusted p-value for the test of the hypothesis that there are
no false hypotheses among the selected subset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate p-values; 10 from false hypotheses, 10 from true
pvals = sort(c(
  rbeta(10, 1, 20), # Mean value of .1
  runif(10)
))
## Test whether the highest 10 contain any false hypotheses using a Bonferroni test
TestSet_LocalTest(function(x) {
  min(c(1, length(x) * min(x)))
}, pvals, subset = 11:20)
</code></pre>

<hr>
<h2 id='TestSet_TMTI'>Test a subset of hypotheses in its closure using the TMTI</h2><span id='topic+TestSet_TMTI'></span>

<h3>Description</h3>

<p>Test a subset of hypotheses in its closure using the TMTI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestSet_TMTI(
  pvals,
  subset,
  alpha = 0.05,
  tau = NULL,
  K = NULL,
  EarlyStop = FALSE,
  verbose = FALSE,
  gammaList = NULL,
  mc.cores = 1L,
  chunksize = 4 * mc.cores,
  is.sorted = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TestSet_TMTI_+3A_pvals">pvals</code></td>
<td>
<p>Numeric vector of p-values.</p>
</td></tr>
<tr><td><code id="TestSet_TMTI_+3A_subset">subset</code></td>
<td>
<p>Numeric vector; the subset to be tested.</p>
</td></tr>
<tr><td><code id="TestSet_TMTI_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; the level to test at, if stopping early. Defaults
to 0.05.</p>
</td></tr>
<tr><td><code id="TestSet_TMTI_+3A_tau">tau</code></td>
<td>
<p>Numeric; the treshold to use if using rTMTI. Set to NULL for TMTI
or rtTMTI. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="TestSet_TMTI_+3A_k">K</code></td>
<td>
<p>Integer; The number of p-values to use if using rtTMTI. Set to NULL
for TMTI or tTMTI. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="TestSet_TMTI_+3A_earlystop">EarlyStop</code></td>
<td>
<p>Logical; set to TRUE to stop as soon as a hypothesis can be
accepted at level alpha. This speeds up the procedure, but now only provides
lower bounds on the p-values for the global test.</p>
</td></tr>
<tr><td><code id="TestSet_TMTI_+3A_verbose">verbose</code></td>
<td>
<p>Logical; set to TRUE to print progress.</p>
</td></tr>
<tr><td><code id="TestSet_TMTI_+3A_gammalist">gammaList</code></td>
<td>
<p>List of functions. Must be such that the ith element
is the gamma function for sets of size i. Set to NULL to bootstrap the
functions assuming independence. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="TestSet_TMTI_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to parallelize onto.</p>
</td></tr>
<tr><td><code id="TestSet_TMTI_+3A_chunksize">chunksize</code></td>
<td>
<p>Integer indicating the size of chunks to parallelize. E.g.,
if setting chunksize = mc.cores, each time a parallel computation is set up,
each worker will perform only a single task. If mc.cores &gt; chunksize, some
threads will be inactive.</p>
</td></tr>
<tr><td><code id="TestSet_TMTI_+3A_is.sorted">is.sorted</code></td>
<td>
<p>Logical, indicating the p-values are pre-sorted. Defaults
to FALSE.</p>
</td></tr>
<tr><td><code id="TestSet_TMTI_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjusted p-value for the test of the hypothesis that there are
no false hypotheses among the selected subset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate p-values; 10 from false hypotheses, 10 from true
pvals = sort(c(
  rbeta(10, 1, 20), # Mean value of .1
  runif(10)
))
## Test whether the highest 10 contain any false hypotheses
TestSet_TMTI(pvals, subset = 11:20)
</code></pre>

<hr>
<h2 id='TMTI'>Computes the TMTI test for a joint hypothesis given input p-values.</h2><span id='topic+TMTI'></span>

<h3>Description</h3>

<p>A package to compute TMTI tests, perform closed testing
procedures with quadratic shortcuts and to generate confidence sets for the
number of false hypotheses among m tested hypotheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TMTI(
  pvals,
  n = Inf,
  tau = NULL,
  K = NULL,
  gamma = NULL,
  B = 1000,
  m_max = 100,
  is.sorted = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TMTI_+3A_pvals">pvals</code></td>
<td>
<p>A vector of pvalues.</p>
</td></tr>
<tr><td><code id="TMTI_+3A_n">n</code></td>
<td>
<p>A positive number (or Inf) indicating which type of local minimum
to consider. Defaults to Inf, corresponding to the global minimum.</p>
</td></tr>
<tr><td><code id="TMTI_+3A_tau">tau</code></td>
<td>
<p>Number between 0 and 1 or NULL, describing the truncation level.</p>
</td></tr>
<tr><td><code id="TMTI_+3A_k">K</code></td>
<td>
<p>Integer between &gt;1 and m describing the truncation index.</p>
</td></tr>
<tr><td><code id="TMTI_+3A_gamma">gamma</code></td>
<td>
<p>Function; function to be used as the gamma approximation. If NULL, then
the gamma function will be bootstrapped assuming independence. Defaults
to NULL.</p>
</td></tr>
<tr><td><code id="TMTI_+3A_b">B</code></td>
<td>
<p>Numeric; number of bootstrap replicates to be used when estimating
the gamma function. If a gamma is supplied, this argument is ignored.
Defaults to 1e3.</p>
</td></tr>
<tr><td><code id="TMTI_+3A_m_max">m_max</code></td>
<td>
<p>Integer; the highest number of test for which the analytical
computation of the TMTI CDF is used. When m is above m_max it will be
bootstrapped or user supplied instead.</p>
</td></tr>
<tr><td><code id="TMTI_+3A_is.sorted">is.sorted</code></td>
<td>
<p>Logical, indicating whether the supplied p-values are already
is.sorted. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="TMTI_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A p-value from the TMTI test
</p>


<h3>Author(s)</h3>

<p>Phillip B. Mogensen &lt;pbm@math.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate some p-values
## The first 10 are from false hypotheses, the next 10 are from true
pvals = c(
  rbeta(10, 1, 20), ## Mean value of .05
  runif(10)
)
TMTI(pvals)
</code></pre>

<hr>
<h2 id='TMTI_CDF'>Computes the analytical version of the TMTI_infty CDF. When m&gt;100, this should
not be used.</h2><span id='topic+TMTI_CDF'></span>

<h3>Description</h3>

<p>Computes the analytical version of the TMTI_infty CDF. When m&gt;100, this should
not be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TMTI_CDF(x, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TMTI_CDF_+3A_x">x</code></td>
<td>
<p>Point in which to evaluate the CDF.</p>
</td></tr>
<tr><td><code id="TMTI_CDF_+3A_m">m</code></td>
<td>
<p>Number of independent tests to combine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The probability that the test statistic is at most x assuming
independence under the global null hypothesis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TMTI_CDF(0.05, 100)
</code></pre>

<hr>
<h2 id='TopDown_C'>Leading NA</h2><span id='topic+TopDown_C'></span>

<h3>Description</h3>

<p>Computes a confidence set for the number of false hypotheses among all hypotheses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TopDown_C(LocalTest, pvals, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TopDown_C_+3A_localtest">LocalTest</code></td>
<td>
<p>A function that returns a double in (0, 1).</p>
</td></tr>
<tr><td><code id="TopDown_C_+3A_pvals">pvals</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="TopDown_C_+3A_alpha">alpha</code></td>
<td>
<p>A double indicating the significance level</p>
</td></tr>
</table>

<hr>
<h2 id='TopDown_C_binary'>Leading NA</h2><span id='topic+TopDown_C_binary'></span>

<h3>Description</h3>

<p>Computes a confidence set for the number of false hypotheses among all hypotheses
using a binary search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TopDown_C_binary(LocalTest, pvals, alpha, low, high, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TopDown_C_binary_+3A_localtest">LocalTest</code></td>
<td>
<p>A function that returns a double in (0, 1).</p>
</td></tr>
<tr><td><code id="TopDown_C_binary_+3A_pvals">pvals</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="TopDown_C_binary_+3A_alpha">alpha</code></td>
<td>
<p>A double indicating the significance level</p>
</td></tr>
<tr><td><code id="TopDown_C_binary_+3A_low">low</code></td>
<td>
<p>integer denoting the starting point for the search. Should start at zero.</p>
</td></tr>
<tr><td><code id="TopDown_C_binary_+3A_high">high</code></td>
<td>
<p>integer denoting the end point of the search. Should end at pvals.size() - 1.</p>
</td></tr>
<tr><td><code id="TopDown_C_binary_+3A_verbose">verbose</code></td>
<td>
<p>boolean, indicating whether to print progress.</p>
</td></tr>
</table>

<hr>
<h2 id='TopDown_C_binary_subset'>Leading NA</h2><span id='topic+TopDown_C_binary_subset'></span>

<h3>Description</h3>

<p>Computes a confidence set for the number of false hypotheses among a subset of
using a binary search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TopDown_C_binary_subset(LocalTest, pSub, pRest, alpha, low, high, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TopDown_C_binary_subset_+3A_localtest">LocalTest</code></td>
<td>
<p>A function that returns a double in (0, 1).</p>
</td></tr>
<tr><td><code id="TopDown_C_binary_subset_+3A_psub">pSub</code></td>
<td>
<p>A vector of p-values from the subset of interest.</p>
</td></tr>
<tr><td><code id="TopDown_C_binary_subset_+3A_prest">pRest</code></td>
<td>
<p>A vector of the remaining p-values.</p>
</td></tr>
<tr><td><code id="TopDown_C_binary_subset_+3A_alpha">alpha</code></td>
<td>
<p>A double indicating the significance level</p>
</td></tr>
<tr><td><code id="TopDown_C_binary_subset_+3A_low">low</code></td>
<td>
<p>integer denoting the starting point for the search. Should start at zero.</p>
</td></tr>
<tr><td><code id="TopDown_C_binary_subset_+3A_high">high</code></td>
<td>
<p>integer denoting the end point of the search. Should end at pvals.size() - 1.</p>
</td></tr>
<tr><td><code id="TopDown_C_binary_subset_+3A_verbose">verbose</code></td>
<td>
<p>boolean, indicating whether to print progress.</p>
</td></tr>
</table>

<hr>
<h2 id='TopDown_LocalTest'>TopDown LocalTest algorithm for estimating a 1-alpha confidence set for the number
of false hypotheses among a set.</h2><span id='topic+TopDown_LocalTest'></span><span id='topic+TopDown_localTest'></span>

<h3>Description</h3>

<p>TopDown LocalTest algorithm for estimating a 1-alpha confidence set for the number
of false hypotheses among a set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TopDown_LocalTest(
  LocalTest,
  pvals,
  subset = NULL,
  alpha = 0.05,
  verbose = FALSE,
  mc.cores = 1L,
  chunksize = 4 * mc.cores,
  direction = "binary",
  ...
)

TopDown_localTest(
  localTest,
  pvals,
  subset = NULL,
  alpha = 0.05,
  verbose = TRUE,
  mc.cores = 1L,
  chunksize = 4 * mc.cores,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TopDown_LocalTest_+3A_localtest">LocalTest</code></td>
<td>
<p>A function specifying a local test.</p>
</td></tr>
<tr><td><code id="TopDown_LocalTest_+3A_pvals">pvals</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="TopDown_LocalTest_+3A_subset">subset</code></td>
<td>
<p>Numeric vector specifying a subset a p-values to estimate a
confidence set for the number of false hypotheses for. Defaults to NULL
corresponding to estimating a confidence set for the number of false
hypotheses in the entire set.</p>
</td></tr>
<tr><td><code id="TopDown_LocalTest_+3A_alpha">alpha</code></td>
<td>
<p>Level in [0,1] at which to generate confidence set. Defaults
to 0.05.</p>
</td></tr>
<tr><td><code id="TopDown_LocalTest_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating whether or not to write out the progress.
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="TopDown_LocalTest_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Integer specifying the number of cores to parallelize onto.</p>
</td></tr>
<tr><td><code id="TopDown_LocalTest_+3A_chunksize">chunksize</code></td>
<td>
<p>Integer indicating the size of chunks to parallelize. E.g.,
if setting chunksize = mc.cores, each time a parallel computation is set up,
each worker will perform only a single task. If mc.cores &gt; chunksize, some
threads will be inactive.</p>
</td></tr>
<tr><td><code id="TopDown_LocalTest_+3A_direction">direction</code></td>
<td>
<p>A string indicating whether to perform a binary search ('binary'/'b')
or decreasing ('decreasing'/'d') search. Defaults to 'binary', which has better
computational complexity.</p>
</td></tr>
<tr><td><code id="TopDown_LocalTest_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
<tr><td><code id="TopDown_LocalTest_+3A_localtest">localTest</code></td>
<td>
<p>A function specifying a local test (deprecated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 1-alpha bound lower for the number of false hypotheses among the
specified subset of the supplied p-values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate some p-values
## The first 10 are from false hypotheses, the next 10 are from true
pvals = c(
  rbeta(10, 1, 20), ## Mean value of .05
  runif(10)
)
## Estimate the confidence set using a local Bonferroni test
TopDown_LocalTest(function(x) {
  min(c(1, length(x) * min(x)))
}, pvals)

</code></pre>

<hr>
<h2 id='TopDown_TMTI'>TopDown TMTI algorithm for estimating a 1-alpha confidence set for the number
of false hypotheses among a set.</h2><span id='topic+TopDown_TMTI'></span>

<h3>Description</h3>

<p>TopDown TMTI algorithm for estimating a 1-alpha confidence set for the number
of false hypotheses among a set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TopDown_TMTI(
  pvals,
  subset = NULL,
  alpha = 0.05,
  gammaList = NULL,
  verbose = TRUE,
  tau = NULL,
  K = NULL,
  is.sorted = FALSE,
  mc.cores = 1L,
  chunksize = 4 * mc.cores,
  direction = "binary",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TopDown_TMTI_+3A_pvals">pvals</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="TopDown_TMTI_+3A_subset">subset</code></td>
<td>
<p>Numeric vector specifying a subset a p-values to estimate a
confidence set for the number of false hypotheses for. Defaults to NULL
corresponding to estimating a confidence set for the number of false
hypotheses in the entire set.</p>
</td></tr>
<tr><td><code id="TopDown_TMTI_+3A_alpha">alpha</code></td>
<td>
<p>Level in [0,1] at which to generate confidence set. Defaults
to 0.05.</p>
</td></tr>
<tr><td><code id="TopDown_TMTI_+3A_gammalist">gammaList</code></td>
<td>
<p>List of pre-specified gamma functions. If NULL, the
functions will be approximated by bootstrap assuming independence. Defaults
to NULL.</p>
</td></tr>
<tr><td><code id="TopDown_TMTI_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating whether or not to write out the progress.
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="TopDown_TMTI_+3A_tau">tau</code></td>
<td>
<p>Numerical (in (0,1)); threshold to use in tTMTI. If set to NULL,
then either TMTI (default) or rtTMTI is used.</p>
</td></tr>
<tr><td><code id="TopDown_TMTI_+3A_k">K</code></td>
<td>
<p>Integer; Number of smallest p-values to use in rtTMTI. If se to NULL,
then either TMTI (default) or tTMTI is used.</p>
</td></tr>
<tr><td><code id="TopDown_TMTI_+3A_is.sorted">is.sorted</code></td>
<td>
<p>Logical, indicating whether the supplied p-values are already
is.sorted. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="TopDown_TMTI_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to parallelize onto.</p>
</td></tr>
<tr><td><code id="TopDown_TMTI_+3A_chunksize">chunksize</code></td>
<td>
<p>Integer indicating the size of chunks to parallelize. E.g.,
if setting chunksize = mc.cores, each time a parallel computation is set up,
each worker will perform only a single task. If mc.cores &gt; chunksize, some
threads will be inactive.</p>
</td></tr>
<tr><td><code id="TopDown_TMTI_+3A_direction">direction</code></td>
<td>
<p>A string indicating whether to perform a binary search ('binary'/'b')
or decreasing ('decreasing'/'d') search. Defaults to 'binary', which has better
computational complexity.</p>
</td></tr>
<tr><td><code id="TopDown_TMTI_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 1-alpha lower bound for the number of false hypotheses among the
set of supplied p-values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate some p-values
## The first 10 are from false hypotheses, the next 10 are from true
pvals = c(
  rbeta(10, 1, 20), ## Mean value of .05
  runif(10)
)
TopDown_TMTI(pvals)

</code></pre>

<hr>
<h2 id='tTMTI_CDF'>Computes the analytical version of the tTMTI_infty CDF. When m&gt;100, this should
not be used.</h2><span id='topic+tTMTI_CDF'></span>

<h3>Description</h3>

<p>Computes the analytical version of the tTMTI_infty CDF. When m&gt;100, this should
not be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tTMTI_CDF(x, m, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tTMTI_CDF_+3A_x">x</code></td>
<td>
<p>Point in which to evaluate the CDF.</p>
</td></tr>
<tr><td><code id="tTMTI_CDF_+3A_m">m</code></td>
<td>
<p>Number of independent tests to combine.</p>
</td></tr>
<tr><td><code id="tTMTI_CDF_+3A_tau">tau</code></td>
<td>
<p>The truncation point of the tTMTI procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The probability that the test statistic is at most x assuming
independence under the global null hypothesis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tTMTI_CDF(0.05, 100, 0.05)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
