<!DOCTYPE html><html><head><title>Help for package itertools2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {itertools2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#consume'><p>Consumes the first n elements of an iterator</p></a></li>
<li><a href='#dotproduct'><p>Computes the dot product of two iterable objects</p></a></li>
<li><a href='#ichain'><p>Iterator that chains multiple arguments together into a single iterator</p></a></li>
<li><a href='#ichunk'><p>Iterator that returns elements in fixed-length chunks</p></a></li>
<li><a href='#icompress'><p>Iterator that filters elements where corresponding selector is false.</p></a></li>
<li><a href='#icount'><p>Iterator of neverending numeric sequence with initial value and step size</p></a></li>
<li><a href='#icycle'><p>Iterator that cycles indefinitely through an iterable object</p></a></li>
<li><a href='#idropwhile'><p>Iterator that drops elements until the predicate function returns FALSE</p></a></li>
<li><a href='#ienumerate'><p>Iterator that returns the elements of an object along with their indices</p></a></li>
<li><a href='#ifilter'><p>Iterator that filters elements not satisfying a predicate function</p></a></li>
<li><a href='#ilength'><p>Consumes an iterator and computes its length</p></a></li>
<li><a href='#imap'><p>Iterator that applies a given function to several iterables concurrently.</p></a></li>
<li><a href='#ipad'><p>Iterator that returns an object followed indefinitely by a fill value</p></a></li>
<li><a href='#ipairwise'><p>Iterator that returns elements of an object in pairs</p></a></li>
<li><a href='#iproduct'><p>Iterator that returns the Cartesian product of the arguments.</p></a></li>
<li><a href='#irep'><p>Iterator that replicates elements of an iterable object</p></a></li>
<li><a href='#irepeat'><p>Iterator that returns an object indefinitely</p></a></li>
<li><a href='#iroundrobin'><p>Iterator that traverses each given iterable in a roundrobin order</p></a></li>
<li><a href='#is_iterator'><p>Helper function that determines whether is an iterator object</p></a></li>
<li><a href='#iseq'><p>Iterators for sequence generation</p></a></li>
<li><a href='#islice'><p>Iterator that returns selected elements from an iterable.</p></a></li>
<li><a href='#istarmap'><p>Iterator that applies a given function to the elements of an iterable.</p></a></li>
<li><a href='#itabulate'><p>Iterator that maps a function to a sequence of numeric values</p></a></li>
<li><a href='#itakewhile'><p>Iterator that returns elements while a predicate function returns TRUE</p></a></li>
<li><a href='#itee'><p>Returns a list of n independent iterators from a single iterable object</p></a></li>
<li><a href='#iter_deepcopy'><p>Performs a deep copy of an iterator</p></a></li>
<li><a href='#iter_length'><p>Helper function that determines the length of an iterator object</p></a></li>
<li><a href='#itertools2'><p>itertools2: Functions creating iterators for efficient looping</p></a></li>
<li><a href='#iunique'><p>Iterator that extracts the unique elements from an iterable object</p></a></li>
<li><a href='#iunique_justseen'><p>Iterator that extracts the just-seen unique elements from an iterable object</p></a></li>
<li><a href='#izip'><p>Iterator that iterates through several iterables concurrently.</p></a></li>
<li><a href='#izip_longest'><p>Iterator that iterates through several iterables concurrently.</p></a></li>
<li><a href='#nth'><p>Returns the nth item of an iterator</p></a></li>
<li><a href='#quantify'><p>Count the number of times an iterable object is TRUE</p></a></li>
<li><a href='#stop_iteration'><p>Helper function that determines whether an object inherits from a</p>
StopIteration exception</a></li>
<li><a href='#take'><p>Return the first n elements of an iterable object as a list</p></a></li>
<li><a href='#try_nextElem'><p>Calls iterators::nextElem(). If error, returns default value.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>itertools2: Functions creating iterators for efficient looping</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2014-08-08</td>
</tr>
<tr>
<td>Author:</td>
<td>John A. Ramey &lt;johnramey@gmail.com&gt;,
    Kayla Schaefer &lt;kschaefer.tx@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John A. Ramey &lt;johnramey@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A port of Python's excellent itertools module to R for efficient
    looping.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>iterators (&ge; 1.0.7)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 0.8.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ramhiser/itertools2">https://github.com/ramhiser/itertools2</a>, <a href="http://ramhiser.com">http://ramhiser.com</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2014-08-08 12:47:29 UTC; ramhiser</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2014-08-08 15:16:57</td>
</tr>
</table>
<hr>
<h2 id='consume'>Consumes the first n elements of an iterator</h2><span id='topic+consume'></span>

<h3>Description</h3>

<p>Advances the iterator n-steps ahead without returning anything.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consume(iterator, n = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consume_+3A_iterator">iterator</code></td>
<td>
<p>an iterator object</p>
</td></tr>
<tr><td><code id="consume_+3A_n">n</code></td>
<td>
<p>The number of elements to consume.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>n</code> is 0, the iterator is consumed entirely. Similarly, if <code>n</code>
is larger than the length of the iterator, the iterator is consumed entirely.
</p>


<h3>Value</h3>

<p>Nothing, i.e., <code>invisible(NULL)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iterators::iter(1:10)
# Skips the first 5 elements
consume(it, n=5)
# Returns 6
iterators::nextElem(it)

it2 &lt;- iterators::iter(letters)
# Skips the first 4 elements
consume(it2, 4)
# Returns 'e'
iterators::nextElem(it2)
</code></pre>

<hr>
<h2 id='dotproduct'>Computes the dot product of two iterable objects</h2><span id='topic+dotproduct'></span>

<h3>Description</h3>

<p>Returns the dot product of two numeric iterables of equal length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotproduct(vec1, vec2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dotproduct_+3A_vec1">vec1</code></td>
<td>
<p>the first</p>
</td></tr>
<tr><td><code id="dotproduct_+3A_vec2">vec2</code></td>
<td>
<p>the second iterable object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dot product of the iterators
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iterators::iter(1:3)
it2 &lt;- iterators::iter(4:6)
dotproduct(it, it2) # 32

it &lt;- iterators::iter(1:4)
it2 &lt;- iterators::iter(7:10)
dotproduct(1:4, 7:10) # 90
</code></pre>

<hr>
<h2 id='ichain'>Iterator that chains multiple arguments together into a single iterator</h2><span id='topic+ichain'></span>

<h3>Description</h3>

<p>Generates an iterator that returns elements from the first argument until it
is exhausted. Then generates an iterator from the next argument and returns
elements from it. This process continues until all arguments are exhausted
Chaining is useful for treating consecutive sequences as a single sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ichain(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ichain_+3A_...">...</code></td>
<td>
<p>multiple arguments to iterate through in sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iterator that iterates through each argument in sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- ichain(1:3, 4:5, 6)
as.list(it)

it2 &lt;- ichain(1:3, levels(iris$Species))
as.list(it2)
</code></pre>

<hr>
<h2 id='ichunk'>Iterator that returns elements in fixed-length chunks</h2><span id='topic+ichunk'></span>

<h3>Description</h3>

<p>Constructs an iterator that returns elements of an iterable <code>object</code> in
fixed-length chunks. If the length of the iterator is not divisible by
<code>chunk_size</code>, the remainder of the last block is filled with the value
specified in <code>fill</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ichunk(object, chunk_size = 1, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ichunk_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="ichunk_+3A_chunk_size">chunk_size</code></td>
<td>
<p>the number of elements returned per chunk</p>
</td></tr>
<tr><td><code id="ichunk_+3A_fill">fill</code></td>
<td>
<p>the value with which to fill the last chunk if the length of the
iterator is not divisble by <code>chunk_size</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function corresponds to Python's <code>grouper</code> function. We chose the
name <code>ichunk</code> because it more explicitly defines the function's purpose.
</p>


<h3>Value</h3>

<p>each call to <code>nextElem</code> results in a list of length
<code>chunk_size</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- ichunk(iterators::iter(1:5), chunk_size=2)
# List: list(1, 2, 3)
iterators::nextElem(it)
# List: list(4, 5, NA)
iterators::nextElem(it)

it2 &lt;- ichunk(levels(iris$Species), chunk_size=4, "weeee")
# Returns: list("setosa", "versicolor", "virginica", "weeee")
iterators::nextElem(it2)
</code></pre>

<hr>
<h2 id='icompress'>Iterator that filters elements where corresponding selector is false.</h2><span id='topic+icompress'></span>

<h3>Description</h3>

<p>Constructs an iterator that filters elements from iterable returning only
those for which the corresponding element from <code>selectors</code> is
<code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icompress(object, selectors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icompress_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="icompress_+3A_selectors">selectors</code></td>
<td>
<p>an iterable that determines whether the corresponding
element in <code>object</code> is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iterator stops when either <code>object</code> or <code>selectors</code> has been
exhausted.
</p>


<h3>Value</h3>

<p>iterator object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filters out odd numbers and retains only even numbers
n &lt;- 10
selectors &lt;- rep(c(FALSE, TRUE), n)
it &lt;- icompress(seq_len(n), selectors)
as.list(it)

# Similar idea here but anonymous function is used to filter out even
# numbers
n &lt;- 10
it2 &lt;- icompress(seq_len(10), rep(c(TRUE, FALSE), n))
as.list(it2)

it3 &lt;- icompress(letters, letters %in% c('a', 'e', 'i', 'o', 'u'))
as.list(it3)
</code></pre>

<hr>
<h2 id='icount'>Iterator of neverending numeric sequence with initial value and step size</h2><span id='topic+icount'></span>

<h3>Description</h3>

<p>Constructs an iterator that generates a neverending sequence of evenly spaced
values starting with <code>icount</code>. The step size is given by <code>step</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icount(start = 0, step = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icount_+3A_start">start</code></td>
<td>
<p>sequence's initial value</p>
</td></tr>
<tr><td><code id="icount_+3A_step">step</code></td>
<td>
<p>sequence's step size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: Use a negative <code>step</code> size to generate decreasing sequences.
</p>
<p>Often used as an argument to <code><a href="#topic+imap">imap</a></code> to
generate consecutive data points.
</p>


<h3>Value</h3>

<p>sequence's iterator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- icount()
iterators::nextElem(it)
iterators::nextElem(it)
iterators::nextElem(it)

it2 &lt;- icount(start=5.5, step=1.5)
iterators::nextElem(it2)
iterators::nextElem(it2)
iterators::nextElem(it2)
</code></pre>

<hr>
<h2 id='icycle'>Iterator that cycles indefinitely through an iterable object</h2><span id='topic+icycle'></span>

<h3>Description</h3>

<p>Constructs an iterator that returns an iterable object in sequence over and
over again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icycle(object, times = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icycle_+3A_object">object</code></td>
<td>
<p>object to cycle indefinitely.</p>
</td></tr>
<tr><td><code id="icycle_+3A_times">times</code></td>
<td>
<p>the number of times <code>object</code> is returned. If <code>NULL</code>
(default), <code>object</code> is returned indefinitely.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs indefinitely unless the <code>times</code> argument is specified.
</p>


<h3>Value</h3>

<p>iterator that returns <code>object</code> in sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- icycle(1:3)
iterators::nextElem(it) # 1
iterators::nextElem(it) # 2
iterators::nextElem(it) # 3
iterators::nextElem(it) # 1
iterators::nextElem(it) # 2
iterators::nextElem(it) # 3
iterators::nextElem(it) # 1

it2 &lt;- icycle(1:3, times=2)
as.list(it2)

# Can return the results from a function.
it3 &lt;- icycle(function() rnorm(1))
iterators::nextElem(it)
iterators::nextElem(it)
iterators::nextElem(it)
iterators::nextElem(it)
</code></pre>

<hr>
<h2 id='idropwhile'>Iterator that drops elements until the predicate function returns FALSE</h2><span id='topic+idropwhile'></span>

<h3>Description</h3>

<p>Constructs an iterator that drops elements from the iterable <code>object</code> as
long as the <code>predicate</code> function is true; afterwards, every element of
<code>iterable</code> object is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idropwhile(predicate, object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idropwhile_+3A_predicate">predicate</code></td>
<td>
<p>a function that determines whether an element is <code>TRUE</code>
or <code>FALSE</code>. The function is assumed to take only one argument.</p>
</td></tr>
<tr><td><code id="idropwhile_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because the iterator does not return any elements until the <code>predicate</code>
first becomes false, there may have a lengthy start-up time before elements
are returned.
</p>


<h3>Value</h3>

<p>iterator object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filters out numbers exceeding 3
not_too_large &lt;- function(x) {
  x &lt;= 3
}
it &lt;- idropwhile(not_too_large, 1:8)
as.list(it)

# Same approach but uses an anonymous function
it2 &lt;- idropwhile(function(x) x &lt;= 10, seq(2, 20, by=2))
as.list(it2)
</code></pre>

<hr>
<h2 id='ienumerate'>Iterator that returns the elements of an object along with their indices</h2><span id='topic+ienum'></span><span id='topic+ienumerate'></span>

<h3>Description</h3>

<p>Constructs an iterator that returns the elements of an object along with each
element's indices. Enumeration is useful when looping through an
<code>object</code> and a counter is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ienumerate(object)

ienum(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ienumerate_+3A_object">object</code></td>
<td>
<p>object to return indefinitely.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to follow the convention used in Python's
<code>enumerate</code> function where the primary difference is that a list is
returned instead of Python's <code>tuple</code> construct.
</p>
<p>Each call to <code><a href="iterators.html#topic+nextElem">nextElem</a></code> returns a list with two
elements:
</p>

<dl>
<dt>index:</dt><dd><p>a counter</p>
</dd>
<dt>value:</dt><dd><p>the current value of <code>object</code></p>
</dd>
</dl>

<p><code>ienum</code> is an alias to <code>ienumerate</code> to save a few keystrokes.
</p>


<h3>Value</h3>

<p>iterator that returns the values of <code>object</code> along with the
index of the object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
it &lt;- ienumerate(rnorm(5))
as.list(it)

# Iterates through the columns of the iris data.frame
it2 &lt;- ienum(iris)
iterators::nextElem(it2)
iterators::nextElem(it2)
iterators::nextElem(it2)
iterators::nextElem(it2)
iterators::nextElem(it2)
</code></pre>

<hr>
<h2 id='ifilter'>Iterator that filters elements not satisfying a predicate function</h2><span id='topic+ifilter'></span><span id='topic+ifilterfalse'></span>

<h3>Description</h3>

<p>Constructs an iterator that filters elements from iterable returning only
those for which the predicate is <code>TRUE</code>.
</p>
<p>Constructs an iterator that filters elements from iterable returning only
those for which the predicate is <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifilter(predicate, iterable)

ifilterfalse(predicate, iterable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifilter_+3A_predicate">predicate</code></td>
<td>
<p>a function that determines whether an element is <code>TRUE</code>
or <code>FALSE</code>. The function is assumed to take only one argument.</p>
</td></tr>
<tr><td><code id="ifilter_+3A_iterable">iterable</code></td>
<td>
<p>an iterable object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iterator object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filters out odd numbers and retains only even numbers
is_even &lt;- function(x) {
  x %% 2 == 0
}
it &lt;- ifilter(is_even, 1:10)
as.list(it)

# Similar idea here but anonymous function is used to filter out even
# numbers
it2 &lt;- ifilter(function(x) x %% 2 == 1, 1:10)
iterators::nextElem(it2) # 1
iterators::nextElem(it2) # 3
iterators::nextElem(it2) # 5
iterators::nextElem(it2) # 7
iterators::nextElem(it2) # 9

is_vowel &lt;- function(x) {
  x %in% c('a', 'e', 'i', 'o', 'u')
}
it3 &lt;- ifilter(is_vowel, letters)
as.list(it3)
# Filters out even numbers and retains only odd numbers
is_even &lt;- function(x) {
  x %% 2 == 0
}
it &lt;- ifilterfalse(is_even, 1:10)
as.list(it)

# Similar idea here but anonymous function is used to filter out odd
# numbers
it2 &lt;- ifilter(function(x) x %% 2 == 1, 1:10)
as.list(it2)

is_vowel &lt;- function(x) {
  x %in% c('a', 'e', 'i', 'o', 'u')
}
it3 &lt;- ifilterfalse(is_vowel, letters)
iterators::nextElem(it3) # b
iterators::nextElem(it3) # c
iterators::nextElem(it3) # d
iterators::nextElem(it3) # f
iterators::nextElem(it3) # g
# iterators::nextElem(it) continues through the rest of the consonants
</code></pre>

<hr>
<h2 id='ilength'>Consumes an iterator and computes its length</h2><span id='topic+ilength'></span>

<h3>Description</h3>

<p>Counts the number of elements in an iterator. NOTE: The iterator is consumed
in the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ilength(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ilength_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of elements in the iterator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ilength(1:5) == length(1:5)

it &lt;- iterators::iter(1:5)
ilength(it) == length(1:5)

it2 &lt;- ichain(1:3, 4:5, 6)
ilength(it2)

it3 &lt;- ichain(1:3, levels(iris$Species))
ilength(it3)
</code></pre>

<hr>
<h2 id='imap'>Iterator that applies a given function to several iterables concurrently.</h2><span id='topic+imap'></span>

<h3>Description</h3>

<p>Constructs an iterator that computes the given function <code>f</code> using the
arguments from each of the iterables given in <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imap(f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imap_+3A_f">f</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="imap_+3A_...">...</code></td>
<td>
<p>multiple arguments to iterate through in sequence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iterator returned is exhausted when the shortest iterable in <code>...</code>
is exhausted. Note that <code>imap</code> does not recycle arguments as
<code><a href="base.html#topic+Map">Map</a></code> does.
</p>
<p>The primary difference between <code>istarmap</code> and
<code><a href="#topic+imap">imap</a></code> is that the former expects an iterable object
whose elements are already grouped together, while the latter case groups the
arguments together before applying the given function. The choice is a matter
of style and convenience.
</p>


<h3>Value</h3>

<p>iterator that returns the values of <code>object</code> along with the
index of the object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pow &lt;- function(x, y) {
  x^y
}
it &lt;- imap(pow, c(2, 3, 10), c(5, 2, 3))
as.list(it)

# Similar to the above, but because the second vector is exhausted after two
# calls to `nextElem`, the iterator is exhausted.
it2 &lt;- imap(pow, c(2, 3, 10), c(5, 2))
as.list(it2)

# Another similar example but with lists instead of vectors
it3 &lt;- imap(pow, list(2, 3, 10), list(5, 2, 3))
iterators::nextElem(it3) # 32
iterators::nextElem(it3) # 9
iterators::nextElem(it3) # 1000
</code></pre>

<hr>
<h2 id='ipad'>Iterator that returns an object followed indefinitely by a fill value</h2><span id='topic+ipad'></span>

<h3>Description</h3>

<p>Constructs an iterator that returns an iterable <code>object</code> before padding
the iterator with the given <code>fill</code> value indefinitely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipad(object, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipad_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="ipad_+3A_fill">fill</code></td>
<td>
<p>the value to pad the indefinite iterator after the initial
<code>object</code> is consumed. Default: <code>NA</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>iterator that returns <code>object</code> followed indefinitely by the
<code>fill</code> value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iterators::iter(1:9)
it_ipad &lt;- ipad(it)
as.list(islice(it_ipad, end=9)) # Same as as.list(1:9)

it2 &lt;- iterators::iter(1:9)
it2_ipad &lt;- ipad(it2)
as.list(islice(it2_ipad, end=10)) # Same as as.list(c(1:9, NA))

it3 &lt;- iterators::iter(1:9)
it3_ipad &lt;- ipad(it3, fill=TRUE)
as.list(islice(it3_ipad, end=10)) # Same as as.list(c(1:9, TRUE))
</code></pre>

<hr>
<h2 id='ipairwise'>Iterator that returns elements of an object in pairs</h2><span id='topic+ipairwise'></span>

<h3>Description</h3>

<p>Constructs an iterator of an iterable <code>object</code> that returns its elements
in pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipairwise(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipairwise_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an iterator that returns pairwise elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- ipairwise(iterators::iter(letters[1:4]))
iterators::nextElem(it) # list("a", "b")
iterators::nextElem(it) # list("b", "c")
iterators::nextElem(it) # list("c", "d")

it2 &lt;- ipairwise(1:5)
iterators::nextElem(it2) # list(1, 2)
iterators::nextElem(it2) # list(2, 3)
iterators::nextElem(it2) # list(3, 4)
iterators::nextElem(it2) # list(4, 5)
</code></pre>

<hr>
<h2 id='iproduct'>Iterator that returns the Cartesian product of the arguments.</h2><span id='topic+iproduct'></span>

<h3>Description</h3>

<p>Constructs an iterator that is the Cartesian product of each of the arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iproduct(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iproduct_+3A_...">...</code></td>
<td>
<p>multiple arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although they share the same end goal, <code>iproduct</code> can yield drastic
memory savings compared to <code><a href="base.html#topic+expand.grid">expand.grid</a></code>.
</p>


<h3>Value</h3>

<p>iterator that iterates through each element from the Cartesian
product
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iproduct(x=1:3, y=4:5)
iterators::nextElem(it) # list(x=1, y=4)
iterators::nextElem(it) # list(x=1, y=5)
iterators::nextElem(it) # list(x=2, y=4)
iterators::nextElem(it) # list(x=2, y=5)
iterators::nextElem(it) # list(x=3, y=4)
iterators::nextElem(it) # list(x=3, y=5)

# iproduct is a replacement for base::expand.grid()
# Large data.frames are not created unless the iterator is manually consumed
a &lt;- 1:2
b &lt;- 3:4
c &lt;- 5:6
it2 &lt;- iproduct(a=a, b=b, c=c)
df_iproduct &lt;- do.call(rbind, as.list(it2))
df_iproduct &lt;- data.frame(df_iproduct)

# Compare df_iproduct with the results from base::expand.grid()
base::expand.grid(a=a, b=b, c=c)
</code></pre>

<hr>
<h2 id='irep'>Iterator that replicates elements of an iterable object</h2><span id='topic+irep'></span><span id='topic+irep_len'></span>

<h3>Description</h3>

<p>Constructs an iterator that replicates the values of an <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irep(object, times = 1, length.out = NULL, each = NULL)

irep_len(object, length.out = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irep_+3A_object">object</code></td>
<td>
<p>object to return indefinitely.</p>
</td></tr>
<tr><td><code id="irep_+3A_times">times</code></td>
<td>
<p>the number of times to repeat each element in <code>object</code></p>
</td></tr>
<tr><td><code id="irep_+3A_length.out">length.out</code></td>
<td>
<p>non-negative integer. The desired length of the iterator</p>
</td></tr>
<tr><td><code id="irep_+3A_each">each</code></td>
<td>
<p>non-negative integer. Each element is repeated <code>each</code> times</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended an iterable version of the standard
<code><a href="base.html#topic+rep">rep</a></code> function. However, as exception, the recycling
behavior of <code><a href="base.html#topic+rep">rep</a></code> is intentionally not implemented.
</p>


<h3>Value</h3>

<p>iterator that returns <code>object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- irep(1:3, 2)
unlist(as.list(it)) == rep(1:3, 2)

it2 &lt;- irep(1:3, each=2)
unlist(as.list(it2)) == rep(1:3, each=2)

it3 &lt;- irep(1:3, each=2, length.out=4)
as.list(it3)
</code></pre>

<hr>
<h2 id='irepeat'>Iterator that returns an object indefinitely</h2><span id='topic+irepeat'></span>

<h3>Description</h3>

<p>Constructs an iterator that returns an object over and over again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irepeat(object, times = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irepeat_+3A_object">object</code></td>
<td>
<p>object to return indefinitely.</p>
</td></tr>
<tr><td><code id="irepeat_+3A_times">times</code></td>
<td>
<p>the number of times <code>object</code> is returned. If <code>NULL</code>
(default), <code>object</code> is returned indefinitely.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs indefinitely unless the <code>times</code> argument is specified. Used as
argument to <code><a href="#topic+imap">imap</a></code> for invariant function
parameters. Also used with <code><a href="#topic+izip">izip</a></code> to create constant
fields in a tuple record.
</p>


<h3>Value</h3>

<p>iterator that returns <code>object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- irepeat(42)
iterators::nextElem(it)
iterators::nextElem(it)
iterators::nextElem(it)
# Further calls to iterators::nextElem(it) will repeat 42

it2 &lt;- irepeat(42, times=4)
iterators::nextElem(it2)
iterators::nextElem(it2)
iterators::nextElem(it2)
iterators::nextElem(it2)

# The object can be a data.frame, matrix, etc
it3 &lt;- irepeat(iris, times=4)
iterators::nextElem(it3)
iterators::nextElem(it3)
iterators::nextElem(it3)
iterators::nextElem(it3)
</code></pre>

<hr>
<h2 id='iroundrobin'>Iterator that traverses each given iterable in a roundrobin order</h2><span id='topic+iroundrobin'></span>

<h3>Description</h3>

<p>Constructs an iterator that traverses each given iterable in a roundrobin
order. That is, the iterables are traversed in an alternating fashion such
that the each element is drawn from the next iterable. If an iterable has no
more available elements, it is skipped, and the next element is taken from
the next iterable having available elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iroundrobin(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iroundrobin_+3A_...">...</code></td>
<td>
<p>multiple arguments to iterate through in roundrobin sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iterator that alternates through each argument in roundrobin sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iterators::iter(c("A", "B", "C"))
it2 &lt;- iterators::iter("D")
it3 &lt;- iterators::iter(c("E", "F"))
as.list(iroundrobin(it, it2, it3)) # A D E B F C

it_rr &lt;- iroundrobin(1:3, 4:5, 7:10)
as.list(it_rr) # 1 4 7 2 5 8 3 9 10
</code></pre>

<hr>
<h2 id='is_iterator'>Helper function that determines whether is an iterator object</h2><span id='topic+is_iterator'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if the <code>object</code> is an object of class <code>iter</code>,
and <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_iterator(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_iterator_+3A_object">object</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value indicating whether <code>object</code> is of class
<code>iter</code>
</p>

<hr>
<h2 id='iseq'>Iterators for sequence generation</h2><span id='topic+iseq'></span><span id='topic+iseq_along'></span><span id='topic+iseq_len'></span>

<h3>Description</h3>

<p>Constructs iterators that generate regular sequences that follow the
<code><a href="base.html#topic+seq">seq</a></code> family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iseq(from = 1, to = 1, by = (to - from)/(length_out - 1),
  length_out = NULL, along_with = NULL)

iseq_len(length_out = NULL)

iseq_along(along_with = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iseq_+3A_from">from</code></td>
<td>
<p>the starting value of the sequence</p>
</td></tr>
<tr><td><code id="iseq_+3A_to">to</code></td>
<td>
<p>the end value of the sequence</p>
</td></tr>
<tr><td><code id="iseq_+3A_by">by</code></td>
<td>
<p>increment of the sequence.</p>
</td></tr>
<tr><td><code id="iseq_+3A_length_out">length_out</code></td>
<td>
<p>desired length of the sequence. A non-negative number,
which for <code>seq</code> will be rounded up if fractional.</p>
</td></tr>
<tr><td><code id="iseq_+3A_along_with">along_with</code></td>
<td>
<p>the length of the sequence will match the length of this
argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>iseq</code> function generates a sequence of values beginning with
<code>from</code> and ending with <code>to</code>. The sequence of values between are
determined by the <code>by</code>, <code>length_out</code>, and <code>along_with</code>
arguments. The <code>by</code> argument determines the step size of the sequence,
whereas <code>length_out</code> and <code>along_with</code> determine the length of the
sequence. If <code>by</code> is not given, then it is determined by either
<code>length_out</code> or <code>along_with</code>. By default, neither are given, in
which case <code>by</code> is set to 1 or -1, depending on whether <code>to &gt;
from</code>.
</p>
<p><code>seq_along</code> and <code>seq_len</code> return an iterator, which generates a
sequence of integers, beginning with 1 and proceeding to an ending value
</p>


<h3>Value</h3>

<p>sequence's iterator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iseq(from=2, to=5)
unlist(as.list(it)) == 2:5

it2 &lt;- iseq_len(4)
unlist(as.list(it2)) == 1:4

it3 &lt;- iseq_along(iris)
unlist(as.list(it3)) == 1:length(iris)
</code></pre>

<hr>
<h2 id='islice'>Iterator that returns selected elements from an iterable.</h2><span id='topic+islice'></span>

<h3>Description</h3>

<p>Constructs an iterator that returns elements from an iterable following the
given sequence with starting value <code>start</code> and ending value <code>end</code>.
The sequence's step size is given by <code>step</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>islice(object, start = 1, end = NULL, step = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="islice_+3A_object">object</code></td>
<td>
<p>iterable object through which this function iterates</p>
</td></tr>
<tr><td><code id="islice_+3A_start">start</code></td>
<td>
<p>the index of the first element to return from <code>object</code></p>
</td></tr>
<tr><td><code id="islice_+3A_end">end</code></td>
<td>
<p>the index of the last element to return from <code>object</code></p>
</td></tr>
<tr><td><code id="islice_+3A_step">step</code></td>
<td>
<p>the step size of the sequence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iterable given in <code>object</code> is traversed beginning with element
having index specified in <code>start</code>. If <code>start</code> is greater than 1,
then elements from the <code>object</code> are skipped until <code>start</code> is
reached. By default, elements are returned consecutively. However, if the
<code>step</code> size is greater than 1, elements in <code>object</code> are skipped.
</p>
<p>If <code>stop</code> is <code>NULL</code> (default), the iteration continues until the
iterator is exhausted unless <code>end</code> is specified. In this case,
<code>end</code> specifies the sequence position to stop iteration.
</p>


<h3>Value</h3>

<p>iterator that returns <code>object</code> in sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- islice(1:5, start=2)
iterators::nextElem(it) # 2
iterators::nextElem(it) # 3
iterators::nextElem(it) # 4
iterators::nextElem(it) # 5

it2 &lt;- islice(1:10, start=2, end=5)
unlist(as.list(it2)) == 2:5

it3 &lt;- islice(1:10, start=2, end=9, step=2)
unlist(as.list(it3)) == c(2, 4, 6, 8)
</code></pre>

<hr>
<h2 id='istarmap'>Iterator that applies a given function to the elements of an iterable.</h2><span id='topic+istar'></span><span id='topic+istarmap'></span>

<h3>Description</h3>

<p>Constructs an iterator that applies the function <code>f</code> concurrently to the
elements within the list <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>istarmap(f, x)

istar(f, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="istarmap_+3A_f">f</code></td>
<td>
<p>a function to apply to the elements of <code>x</code></p>
</td></tr>
<tr><td><code id="istarmap_+3A_x">x</code></td>
<td>
<p>an iterable object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iterator returned is exhausted when the shortest element in <code>x</code>
is exhausted. Note that <code>istarmap</code> does not recycle arguments as
<code><a href="base.html#topic+Map">Map</a></code> does.
</p>
<p>The primary difference between <code>istarmap</code> and
<code><a href="#topic+imap">imap</a></code> is that the former expects an iterable object
whose elements are already grouped together, while the latter case groups the
arguments together before applying the given function. The choice is a matter
of style and convenience.
</p>


<h3>Value</h3>

<p>iterator that returns the values of <code>object</code> along with the
index of the object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pow &lt;- function(x, y) {
  x^y
}
it &lt;- istarmap(pow, list(c(2, 3, 10), c(5, 2, 3)))
unlist(as.list(it)) == c(32, 9, 1000)

# Similar to the above, but because the second vector is exhausted after two
# calls to `nextElem`, the iterator is exhausted.
it2 &lt;- istarmap(pow, list(c(2, 3, 10), c(5, 2)))
unlist(as.list(it2)) == c(32, 9)

# Another similar example but with lists instead of vectors
it3 &lt;- istarmap(pow, list(list(2, 3, 10), list(5, 2, 3)))
as.list(it3)

# Computes sum of each row in the iris data set
# Numerically equivalent to base::rowSums()
tolerance &lt;- sqrt(.Machine$double.eps)
iris_x &lt;- iris[, -5]
it4 &lt;- istarmap(sum, iris_x)
unlist(as.list(it4)) - rowSums(iris_x) &lt; tolerance
</code></pre>

<hr>
<h2 id='itabulate'>Iterator that maps a function to a sequence of numeric values</h2><span id='topic+itabulate'></span>

<h3>Description</h3>

<p>Constructs an iterator that maps a given function over an indefinite sequence
of numeric values. The input the function <code>f</code> is expected to accept a
single numeric argument. The sequence of arguments passed to <code>f</code> begin
with <code>start</code> and are incremented by <code>step</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itabulate(f, start = 1, step = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itabulate_+3A_f">f</code></td>
<td>
<p>the function to apply</p>
</td></tr>
<tr><td><code id="itabulate_+3A_start">start</code></td>
<td>
<p>sequence's initial value</p>
</td></tr>
<tr><td><code id="itabulate_+3A_step">step</code></td>
<td>
<p>sequence's step size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an iterator that returns the mapped values from the sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- itabulate(f=function(x) x + 1)
take(it, 4) # 2 3 4 5

it2 &lt;- itabulate(f=function(x) x^2, start=-3)
take(it2, 6) # 9 4 1 0 1 4

it3 &lt;- itabulate(abs, start=-5, step=2)
take(it3, 6) # 5 3 1 1 3 5

it4 &lt;- itabulate(exp, start=6, step=-2)
take(it4, 4) # exp(c(6, 4, 2, 0))
</code></pre>

<hr>
<h2 id='itakewhile'>Iterator that returns elements while a predicate function returns TRUE</h2><span id='topic+itakewhile'></span>

<h3>Description</h3>

<p>Constructs an iterator that returns elements from an iterable <code>object</code>
as long as the given <code>predicate</code> function returns <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itakewhile(predicate, object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itakewhile_+3A_predicate">predicate</code></td>
<td>
<p>a function that determines whether an element is <code>TRUE</code>
or <code>FALSE</code>. The function is assumed to take only one argument.</p>
</td></tr>
<tr><td><code id="itakewhile_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iterator object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filters out numbers exceeding 5
not_too_large &lt;- function(x) {
  x &lt;= 5
}
it &lt;- itakewhile(not_too_large, 1:100)
unlist(as.list(it)) == 1:5

# Same approach but uses an anonymous function
it2 &lt;- itakewhile(function(x) x &lt;= 10, seq(2, 100, by=2))
unlist(as.list(it2)) == c(2, 4, 6, 8, 10)
</code></pre>

<hr>
<h2 id='itee'>Returns a list of n independent iterators from a single iterable object</h2><span id='topic+itee'></span>

<h3>Description</h3>

<p>Constructs a list of <code>n</code> iterators, each of which iterates through an
iterable <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itee(object, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itee_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="itee_+3A_n">n</code></td>
<td>
<p>the number of iterables to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>object</code> is an iterator (i.e., inherits from class <code>iter</code>),
<code>n</code> deep copies of <code>object</code> are returned. Otherwise, <code>object</code>
is passed to <code><a href="iterators.html#topic+iter">iter</a></code> <code>n</code> times.
</p>


<h3>Value</h3>

<p>a list of <code>n</code> iterators
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates a list of three iterators.
# Each iterator iterates through 1:5 independently.
iter_list &lt;- itee(1:5, n=3)

# Consumes the first iterator
unlist(as.list(iter_list[[1]])) == 1:5

# We can iterate through the remaining two iterators in any order.
iterators::nextElem(iter_list[[2]]) # 1
iterators::nextElem(iter_list[[2]]) # 2

iterators::nextElem(iter_list[[3]]) # 1
iterators::nextElem(iter_list[[3]]) # 2

iterators::nextElem(iter_list[[2]]) # 3
iterators::nextElem(iter_list[[2]]) # 4
iterators::nextElem(iter_list[[2]]) # 5

iterators::nextElem(iter_list[[3]]) # 3
iterators::nextElem(iter_list[[3]]) # 4
iterators::nextElem(iter_list[[3]]) # 5
</code></pre>

<hr>
<h2 id='iter_deepcopy'>Performs a deep copy of an iterator</h2><span id='topic+iter_deepcopy'></span>

<h3>Description</h3>

<p>This function is useful when an iterator needs to be copied with a new
<code>state</code> environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iter_deepcopy(iterator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iter_deepcopy_+3A_iterator">iterator</code></td>
<td>
<p>an iterator object that inherits from class 'iter'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new iterator with its own state
</p>

<hr>
<h2 id='iter_length'>Helper function that determines the length of an iterator object</h2><span id='topic+iter_length'></span>

<h3>Description</h3>

<p>Returns the length of an iterator object. In the case that the iterator's
length is <code>NULL</code>, a value of 1 is returned by default. This value can be
set using the <code>default</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iter_length(object, default = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iter_length_+3A_object">object</code></td>
<td>
<p>an iterator object</p>
</td></tr>
<tr><td><code id="iter_length_+3A_default">default</code></td>
<td>
<p>the value returned when an iterator has <code>NULL</code> length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>

<hr>
<h2 id='itertools2'>itertools2: Functions creating iterators for efficient looping</h2><span id='topic+itertools2'></span><span id='topic+itertools2-package'></span><span id='topic+package-itertools2'></span>

<h3>Description</h3>

<p>The R package <code>itertools2</code> is a port of Python's excellent itertools
module <a href="https://docs.python.org/2/library/itertools.html">https://docs.python.org/2/library/itertools.html</a> to R for
efficient looping and is a replacement for the existing itertools R package
<a href="https://r-forge.r-project.org/projects/itertools/">https://r-forge.r-project.org/projects/itertools/</a>.
</p>

<hr>
<h2 id='iunique'>Iterator that extracts the unique elements from an iterable object</h2><span id='topic+iunique'></span>

<h3>Description</h3>

<p>Constructs an iterator that extracts each unique element in turn from an
iterable <code>object</code>. Order of the elements is maintained. This function is
an iterator analogue to <code><a href="base.html#topic+sort">sort</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iunique(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iunique_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: In order to determine whether an element is unique, a list of previous
unique elements is stored. In doing so, the list can potentially become large
if there are a large number of unique elements.
</p>


<h3>Value</h3>

<p>an iterator that returns the unique elements from <code>object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- ichain(rep(1, 4), rep(2, 5), 4:7, 2)
as.list(iunique(it)) # 1 2 4 5 6 7

it2 &lt;- iterators::iter(c('a', 'a', "A", "V"))
as.list(iunique(it2)) # a A V

x &lt;- as.character(gl(5, 10))
it_unique &lt;- iunique(x)
as.list(it_unique) # 1 2 3 4 5
</code></pre>

<hr>
<h2 id='iunique_justseen'>Iterator that extracts the just-seen unique elements from an iterable object</h2><span id='topic+iunique_justseen'></span>

<h3>Description</h3>

<p>Constructs an iterator that extracts each unique element in turn from an
iterable <code>object</code>. Order of the elements is maintained. Only the element
just seen is remembered for determining uniqueness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iunique_justseen(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iunique_justseen_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an iterator that returns the just-seen unique elements from
<code>object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- ichain(rep(1,4), rep(2, 5), 4:7, 2)
it_iunique &lt;- iunique_justseen(it)
as.list(it_iunique) # 1 2 4 5 6 7 2

it2 &lt;- iterators::iter(c('a', 'a', "A", 'a', 'a', "V"))
it2_iunique &lt;- iunique_justseen(it2)
as.list(it2_iunique) # a A a V
</code></pre>

<hr>
<h2 id='izip'>Iterator that iterates through several iterables concurrently.</h2><span id='topic+izip'></span>

<h3>Description</h3>

<p>The resulting iterator aggregates elements from each of the iterables into a
list from each iteration. Used for lock-step iteration over several iterables
at a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>izip(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="izip_+3A_...">...</code></td>
<td>
<p>multiple arguments to iterate through in sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iterator that iterates through each argument in sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- izip(x=1:3, y=4:6, z=7:9)
iterators::nextElem(it) # list(x=1, y=4, z=7)
iterators::nextElem(it) # list(x=2, y=5, z=8)
iterators::nextElem(it) # list(x=3, y=6, z=9)

# Sums the zip'd elements. 1 + 4 + 7, and so on.
it2 &lt;- izip(1:3, 4:6, 7:9)
sum_zip &lt;- sapply(it2, function(x) sum(unlist(x)))
sum_zip == c(12, 15, 18)

it3 &lt;- izip(a=1:3, b=4:42, class=levels(iris$Species))
iterators::nextElem(it3) # list(a=1, b=4, class="setosa")
iterators::nextElem(it3) # list(a=2, b=5, class="versicolor")
iterators::nextElem(it3) # list(a=3, b=6, class="virginica")
</code></pre>

<hr>
<h2 id='izip_longest'>Iterator that iterates through several iterables concurrently.</h2><span id='topic+izip_longest'></span>

<h3>Description</h3>

<p>The resulting iterator aggregates elements from each of the iterables into a
list from each iteration. Used for lock-step iteration over several iterables
at a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>izip_longest(..., fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="izip_longest_+3A_...">...</code></td>
<td>
<p>multiple arguments to iterate through in sequence</p>
</td></tr>
<tr><td><code id="izip_longest_+3A_fill">fill</code></td>
<td>
<p>the value used to replace missing values when the iterables in
<code>...</code> are of uneven length</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although similar to <code><a href="#topic+izip">izip</a></code>, missing values are
replaced with <code>fill</code> if the iterables are of uneven length, and
Iteration continues until the longest iterable is exhausted.
</p>


<h3>Value</h3>

<p>iterator that iterates through each argument in sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- izip_longest(x=1:3, y=4:6, z=7:9)
iterators::nextElem(it) # list(x=1, y=4, z=7)
iterators::nextElem(it) # list(x=2, y=5, z=8)
iterators::nextElem(it) # list(x=3, y=6, z=9)

it2 &lt;- izip_longest(1:3, 4:8)
iterators::nextElem(it2) # list(1, 4)
iterators::nextElem(it2) # list(2, 5)
iterators::nextElem(it2) # list(3, 6)
iterators::nextElem(it2) # list(NA, 7)
iterators::nextElem(it2) # list(NA, 8)

it3 &lt;- izip_longest(1:2, 4:7, levels(iris$Species), fill="w00t")
iterators::nextElem(it3) # list(1, 4, "setosa")
iterators::nextElem(it3) # list(2, 5, "versicolor")
iterators::nextElem(it3) # list("w00t", 6, "virginica")
iterators::nextElem(it3) # list("w00t", 7, "w00t")
</code></pre>

<hr>
<h2 id='nth'>Returns the nth item of an iterator</h2><span id='topic+nth'></span>

<h3>Description</h3>

<p>Returns the <code>n</code>th item of an <code>iterator</code> after advancing the
iterator <code>n</code> steps ahead. If the <code>iterator</code> is entirely consumed,
the <code>default</code> value is returned instead. That is, if either <code>n &gt;
length(iterator)</code> or <code>n</code> is 0, then the <code>iterator</code> is consumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nth(iterator, n, default = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nth_+3A_iterator">iterator</code></td>
<td>
<p>an iterator object</p>
</td></tr>
<tr><td><code id="nth_+3A_n">n</code></td>
<td>
<p>The location of the desired element to return</p>
</td></tr>
<tr><td><code id="nth_+3A_default">default</code></td>
<td>
<p>The value to return if iterable is consumed, default is NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The nth element of the iterable or the default value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iterators::iter(1:10)
# Returns 5
nth(it, 5)

it2 &lt;- iterators::iter(letters)
# Returns 'e'
nth(it2, 5)

it3 &lt;- iterators::iter(letters)
# Returns default value of NA
nth(it3, 42)

it4 &lt;- iterators::iter(letters)
# Returns default value of "foo"
nth(it4, 42, default="foo")
</code></pre>

<hr>
<h2 id='quantify'>Count the number of times an iterable object is TRUE</h2><span id='topic+quantify'></span>

<h3>Description</h3>

<p>Returns the number of elements from an iterable object evaluate to
<code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantify(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantify_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of <code>TRUE</code> elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iterators::iter(c(TRUE, FALSE, TRUE))
quantify(it) # 2

set.seed(42)
x &lt;- sample(c(TRUE, FALSE), size=10, replace=TRUE)
quantify(x) # Equivalent to sum(x)
</code></pre>

<hr>
<h2 id='stop_iteration'>Helper function that determines whether an object inherits from a
StopIteration exception</h2><span id='topic+stop_iteration'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if the <code>object</code> resulted from a StopIteration
exception when <code><a href="iterators.html#topic+nextElem">nextElem</a></code> is called, and <code>FALSE</code>
otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_iteration(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_iteration_+3A_object">object</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>object</code> resulted from a StopIteration
exception. Otherwise, <code>FALSE</code>.
</p>

<hr>
<h2 id='take'>Return the first n elements of an iterable object as a list</h2><span id='topic+take'></span>

<h3>Description</h3>

<p>Returns the first <code>n</code> elements of an iterable <code>object</code> as a list.
If <code>n</code> is larger than the number of elements in <code>object</code>, the
entire iterator is consumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>take(object, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="take_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="take_+3A_n">n</code></td>
<td>
<p>the number of elements to return in the list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the first <code>n</code> items of the iterable <code>object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>take(iterators::iter(1:10), 3) # 1 2 3

take(iterators::iter(1:5), 10) # 1 2 3 4 5
</code></pre>

<hr>
<h2 id='try_nextElem'>Calls iterators::nextElem(). If error, returns default value.</h2><span id='topic+try_nextElem'></span>

<h3>Description</h3>

<p>Returns the next element of <code>object</code>. In the case a StopIteration
exception is thrown, the <code>default</code> value is returned instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_nextElem(object, default = NA, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_nextElem_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="try_nextElem_+3A_default">default</code></td>
<td>
<p>default value returned if a StopIteration exception is thrown</p>
</td></tr>
<tr><td><code id="try_nextElem_+3A_silent">silent</code></td>
<td>
<p>Should any errors be suppressed without explicitly notifying
the user? Default. Yes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the next element of <code>object</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
