<!DOCTYPE html><html lang="en"><head><title>Help for package pttstability</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pttstability}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#colfun0'><p>default colonization function</p></a></li>
<li><a href='#dat'><p>Microcosm experimental data</p></a></li>
<li><a href='#density_fun0'><p>Default density function for prior</p></a></li>
<li><a href='#detfun0'><p>default deterministic function</p></a></li>
<li><a href='#detfun0_sin'><p>deterministic function with time-varying carrying capacity</p></a></li>
<li><a href='#EDMfun0'><p>EDM deterministic function</p></a></li>
<li><a href='#getcm'><p>Get rates</p></a></li>
<li><a href='#ilogit'><p>Inverse logit</p></a></li>
<li><a href='#indexsort'><p>Sort output of particle filter</p></a></li>
<li><a href='#inv_fun0'><p>Default inverse transormation function</p></a></li>
<li><a href='#likelihood_EDM_piecewise'><p>calculate likelihood for piecewise data</p></a></li>
<li><a href='#likelihood0'><p>Default likelihood function</p></a></li>
<li><a href='#logit'><p>Logit</p></a></li>
<li><a href='#logitnormal_imode'><p>Get inverse logit-normal mode</p></a></li>
<li><a href='#lognormal_imode'><p>Get inverse log-normal mode</p></a></li>
<li><a href='#makeblock'><p>Make an embedding block from timeseries data</p></a></li>
<li><a href='#makedynamics_general'><p>Simulate general time series</p></a></li>
<li><a href='#obsfun0'><p>default observation noise function</p></a></li>
<li><a href='#parseparam0'><p>Parse parameters</p></a></li>
<li><a href='#particleFilterLL'><p>particle filter</p></a></li>
<li><a href='#particleFilterLL_piecewise'><p>run particle filter across piecewise data</p></a></li>
<li><a href='#process_scof'><p>Process S-mapping coefficients</p></a></li>
<li><a href='#procfun_ct'><p>continuous-time process noise function</p></a></li>
<li><a href='#procfun0'><p>default process noise function</p></a></li>
<li><a href='#pttstability'><p>pttstability: Methods for Measuring Stability in Systems Without Static Equilibria</p></a></li>
<li><a href='#S_map_Sugihara1994'><p>Apply S-mapping algorithm from Sugihara 1994</p></a></li>
<li><a href='#sampler_fun0'><p>Default sampler function for prior</p></a></li>
<li><a href='#sdproc_abstract'><p>calculate estimated total variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Particle-Takens Stability</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Includes a collection of functions presented in "Measuring stability in ecological systems without static equilibria" by Clark et al. (2022) &lt;<a href="https://doi.org/10.1002%2Fecs2.4328">doi:10.1002/ecs2.4328</a>&gt; in Ecosphere.
	These can be used to estimate the parameters of a stochastic state space model (i.e. a model where
	a time series is observed with error). The goal of this package is to estimate the variability
	around a deterministic process, both in terms of observation error - i.e. variability due to
	imperfect observations that does not influence system state - and in terms of process noise - i.e.
	stochastic variation in the actual state of the process. Unlike classical methods for estimating
	variability, this package does not necessarily assume that the deterministic state is fixed (i.e.
	a fixed-point equilibrium), meaning that variability around a dynamic trajectory can be estimated
	(e.g. stochastic fluctuations during predator-prey dynamics).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BayesianTools</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'bayesfun.R' 'data.R' 'fake_data.R' 'logit_funs.R'
'particlefilter.R' 'pttstability_man.R' 'smapping_functions.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam Clark <a href="https://orcid.org/0000-0002-8843-3278"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam Clark &lt;adam.tclark@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 14:41:38 UTC; aclark</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='colfun0'>default colonization function</h2><span id='topic+colfun0'></span>

<h3>Description</h3>

<p>Simulates colonization events - events occur as a binomial random process with probability ilogit(p), and populations are seeded with abundance exp(A).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colfun0(co, xt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colfun0_+3A_co">co</code></td>
<td>
<p>a numeric vector of length two (p, A), specifying the logit-transformed colonization probability when abundance is zero, and the log-transformed abundance observed immediately after a colonization event</p>
</td></tr>
<tr><td><code id="colfun0_+3A_xt">xt</code></td>
<td>
<p>a number or numeric vector of abundances at time t, before colonization has occurred</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric, including number or numeric vector of length xt, with predicted abundances after colonization has occurred
</p>

<hr>
<h2 id='dat'>Microcosm experimental data</h2><span id='topic+dat'></span>

<h3>Description</h3>

<p>A dataset containing the abundances of Chlamydomonas terricola growing
in a multi-species community. Includes 17 time steps covering 463 days in two
treatments: LSA ('low' temperature, 'stable' oscillations, and 'absence' of predators)
and LVA ('low' temperature, 'variable' oscillations, and 'absence' of predators).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat
</code></pre>


<h3>Format</h3>

<p>A data frame with 271 rows and 4 variables:
</p>

<dl>
<dt>treatment</dt><dd><p>Experimental treatment</p>
</dd>
<dt>number</dt><dd><p>Replicate number</p>
</dd>
<dt>time</dt><dd><p>Day of experiment</p>
</dd>
<dt>Chlamydomonas.terricola</dt><dd><p>Species abundance</p>
</dd>
</dl>



<h3>Source</h3>

<p>Burgmer &amp; Hillebrand 2011, Oikos 120:922-933.
</p>

<hr>
<h2 id='density_fun0'>Default density function for prior</h2><span id='topic+density_fun0'></span>

<h3>Description</h3>

<p>Default density function, following the syntax for priors in the BayesianTools package. Uses
flat priors for all paramters, within the given interval. Density function integrates to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_fun0(param, minv, maxv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="density_fun0_+3A_param">param</code></td>
<td>
<p>a vector model parameters</p>
</td></tr>
<tr><td><code id="density_fun0_+3A_minv">minv</code></td>
<td>
<p>a vector of minimum values for the interval</p>
</td></tr>
<tr><td><code id="density_fun0_+3A_maxv">maxv</code></td>
<td>
<p>a vector of maximum values for the interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns log likelihood of parameters given priors.
</p>

<hr>
<h2 id='detfun0'>default deterministic function</h2><span id='topic+detfun0'></span>

<h3>Description</h3>

<p>Simulates deterministic component of Ricker model, of the form xt+1 = xt exp(exp(sdet[1])*(1-xt/exp(sdet[2])))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detfun0(sdet, xt, time = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detfun0_+3A_sdet">sdet</code></td>
<td>
<p>a numeric vector of length two, specifying growth rate and carrying capacity</p>
</td></tr>
<tr><td><code id="detfun0_+3A_xt">xt</code></td>
<td>
<p>a number or numeric vector of abundances at time t</p>
</td></tr>
<tr><td><code id="detfun0_+3A_time">time</code></td>
<td>
<p>the timestep - defaults to NULL (i.e. not used)</p>
</td></tr>
<tr><td><code id="detfun0_+3A_...">...</code></td>
<td>
<p>additional arguments, for compatability with other usages of the function - values are not used in this implementation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number or numeric vector of length xt, with predicted abundances at time t+1
</p>

<hr>
<h2 id='detfun0_sin'>deterministic function with time-varying carrying capacity</h2><span id='topic+detfun0_sin'></span>

<h3>Description</h3>

<p>Simulates deterministic component of Ricker model, of the form xt+1 = xt exp(exp(sdet[1])*(1-xt/K))
where K varies with time as (sin(time/2)+exp(sdet[2])+0.5)*(2/3). Function is calibrated such that
for exp(sdet[2]) = 1, mean(K) = 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detfun0_sin(sdet, xt, time = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detfun0_sin_+3A_sdet">sdet</code></td>
<td>
<p>a numeric vector of length two, specifying growth rate and carrying capacity</p>
</td></tr>
<tr><td><code id="detfun0_sin_+3A_xt">xt</code></td>
<td>
<p>a number or numeric vector of abundances at time t</p>
</td></tr>
<tr><td><code id="detfun0_sin_+3A_time">time</code></td>
<td>
<p>the timestep - defaults to NULL (i.e. not used)</p>
</td></tr>
<tr><td><code id="detfun0_sin_+3A_...">...</code></td>
<td>
<p>additional arguments, for compatability with other usages of the function - values are not used in this implementation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number or numeric vector of length xt, with predicted abundances at time t+1
</p>

<hr>
<h2 id='EDMfun0'>EDM deterministic function</h2><span id='topic+EDMfun0'></span>

<h3>Description</h3>

<p>Estimates future states of xt based on based behaviour
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EDMfun0(smp_cf, yp, x, minest = 0, maxest = NULL, time)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EDMfun0_+3A_smp_cf">smp_cf</code></td>
<td>
<p>a matrix of s-map coefficients. Columns correspond to intercept and time lags, rows to observations. Final column corresponds to intercept term.</p>
</td></tr>
<tr><td><code id="EDMfun0_+3A_yp">yp</code></td>
<td>
<p>a matrix of covariates to be multiplied by the smp_cf (typically time lags). Should have one fewer column than smp_cf.</p>
</td></tr>
<tr><td><code id="EDMfun0_+3A_x">x</code></td>
<td>
<p>observation at time-1, to be used to make the prediction.</p>
</td></tr>
<tr><td><code id="EDMfun0_+3A_minest">minest</code></td>
<td>
<p>minimum value to return for prediction - defaults to 0.</p>
</td></tr>
<tr><td><code id="EDMfun0_+3A_maxest">maxest</code></td>
<td>
<p>maximum value to return for prediction - defaults to NULL (no maximum)</p>
</td></tr>
<tr><td><code id="EDMfun0_+3A_time">time</code></td>
<td>
<p>the time step (i.e. position in smp_cf) for the desired prediction. Prediction will be made based on observation in preceding time point (i.e. time-1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number or numeric vector of length xt, with predicted abundances at time t+1
</p>


<h3>Source</h3>

<p>Adapted from Ye, Sugihara, et al. (2015), PNAS 112:E1569-E1576.
</p>

<hr>
<h2 id='getcm'>Get rates</h2><span id='topic+getcm'></span>

<h3>Description</h3>

<p>Calculates colonization rate, mortality rate, and expected mean occupancy time based on a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getcm(dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getcm_+3A_dat">dat</code></td>
<td>
<p>a numeric vector, including the timeseries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including colonization and mortality probability per time step (pc and pm, respectively), and pocc, the expected fraction of time that the species will be present
</p>

<hr>
<h2 id='ilogit'>Inverse logit</h2><span id='topic+ilogit'></span>

<h3>Description</h3>

<p>Returns the inverse logit transformation of x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ilogit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ilogit_+3A_x">x</code></td>
<td>
<p>a number, vector, matrix, etc. to be transformed from (-inf, inf) to (0 1) by the inverse logit transform</p>
</td></tr>
<tr><td><code id="ilogit_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to plogis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>transformed result
</p>

<hr>
<h2 id='indexsort'>Sort output of particle filter</h2><span id='topic+indexsort'></span>

<h3>Description</h3>

<p>Sorts outputs of particle filter based on index - returns a sorted list of particles, based on the
sampling trajectory through time. This is a somewhat more accurate estiamte of the true posterior than
are the stepwise samples provided by the filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexsort(fulltracemat, fulltraceindex, nsmp = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indexsort_+3A_fulltracemat">fulltracemat</code></td>
<td>
<p>full output of particles from the particleFilterLL function</p>
</td></tr>
<tr><td><code id="indexsort_+3A_fulltraceindex">fulltraceindex</code></td>
<td>
<p>full output of particle indices from the particleFilterLL function</p>
</td></tr>
<tr><td><code id="indexsort_+3A_nsmp">nsmp</code></td>
<td>
<p>number of particle paths to sample - defaults to NULL, which samples all paths</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an index-sorted matrix - each column shows the trajectory of a single particle
</p>

<hr>
<h2 id='inv_fun0'>Default inverse transormation function</h2><span id='topic+inv_fun0'></span>

<h3>Description</h3>

<p>Takes in a matrix, where each column represents a parameter. Returns parameters in untransformed space.
If length = 2, then in the order (obs1, proc1).
If 3, then in the order (obs1, proc1, proc2).
If 4, then in the order (obs1, obs2, proc1, proc2).
If 6, then in the order (obs1, proc1, pcol1, pcol2, det1, det2)
If 7, then in the order (obs1, proc1, proc2, pcol1, pcol2, det1, det2)
If 8, then in the order (obs1, obs2, proc1, proc2, pcol1, pcol2, det1, det2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_fun0(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv_fun0_+3A_x">x</code></td>
<td>
<p>an nxm matrix with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns back-transformed values of parameters
</p>

<hr>
<h2 id='likelihood_EDM_piecewise'>calculate likelihood for piecewise data</h2><span id='topic+likelihood_EDM_piecewise'></span>

<h3>Description</h3>

<p>Calculates likelihoods across several segments of data - e.g. multiple plots from a single experiment.
See documentation for particleFilterLL_piecewise for examples of use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood_EDM_piecewise(
  param,
  y,
  libuse_y,
  smap_coefs,
  Euse,
  tuse,
  N,
  colpar = c(logit(1e-06), log(0.1))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="likelihood_EDM_piecewise_+3A_param">param</code></td>
<td>
<p>parameters to be passed to likelihood0 function</p>
</td></tr>
<tr><td><code id="likelihood_EDM_piecewise_+3A_y">y</code></td>
<td>
<p>the time series to be analyzed</p>
</td></tr>
<tr><td><code id="likelihood_EDM_piecewise_+3A_libuse_y">libuse_y</code></td>
<td>
<p>a matrix with two columns, specifying the start end end positions of segments within vector y</p>
</td></tr>
<tr><td><code id="likelihood_EDM_piecewise_+3A_smap_coefs">smap_coefs</code></td>
<td>
<p>a matrix of s-mapping coefficients</p>
</td></tr>
<tr><td><code id="likelihood_EDM_piecewise_+3A_euse">Euse</code></td>
<td>
<p>embedding dimension for the s-mapping analysis</p>
</td></tr>
<tr><td><code id="likelihood_EDM_piecewise_+3A_tuse">tuse</code></td>
<td>
<p>theta for s-mapping analysis</p>
</td></tr>
<tr><td><code id="likelihood_EDM_piecewise_+3A_n">N</code></td>
<td>
<p>number of particles</p>
</td></tr>
<tr><td><code id="likelihood_EDM_piecewise_+3A_colpar">colpar</code></td>
<td>
<p>parameters to be passed to the colfun0 - defaults to c(logit(1e-6), log(0.1))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summed log likelihood across all segments
</p>

<hr>
<h2 id='likelihood0'>Default likelihood function</h2><span id='topic+likelihood0'></span>

<h3>Description</h3>

<p>Calculates likelihood of vector y given parameter values in param, based on the particleFilterLL function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood0(
  param,
  y = y,
  parseparam = parseparam0,
  N = 1000,
  detfun = detfun0,
  edmdat = NULL,
  obsfun = obsfun0,
  procfun = procfun0,
  neff = FALSE,
  lowerbound = (-999)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="likelihood0_+3A_param">param</code></td>
<td>
<p>An unformatted vector of parameters, to be passed to parseparam function.</p>
</td></tr>
<tr><td><code id="likelihood0_+3A_y">y</code></td>
<td>
<p>A numeric vector of observed values, from which the likelihood of parameters and functions will be determined.</p>
</td></tr>
<tr><td><code id="likelihood0_+3A_parseparam">parseparam</code></td>
<td>
<p>A function for transforming the vector param into a form that can be read by particleFilterLL. See particleFilterLL for details.</p>
</td></tr>
<tr><td><code id="likelihood0_+3A_n">N</code></td>
<td>
<p>Number of particles to simulate. Defaults to 1e3.</p>
</td></tr>
<tr><td><code id="likelihood0_+3A_detfun">detfun</code></td>
<td>
<p>A function that simulates deterministic dynamics, which takes in arguments sdet (parameters for deterministic model, taken from pars$proc), and xt, observed abundances at time t.
Returns estimated abundances at time t+1 based on deterministic function (either a parametric function or an EDM function). Defaults to detfun0.</p>
</td></tr>
<tr><td><code id="likelihood0_+3A_edmdat">edmdat</code></td>
<td>
<p>A list including arguments to be passed to S_map_Sugihara1994 - see S_map_Sugihara1994 help file for details. Alternatively, the user can provide a matrix of pre-computed S-map coefficients, in element &quot;smp_cf&quot;.
Default for edmdat is NULL, which implies that EDM will not be applied - instead, a detfun and pars$det must be included.</p>
</td></tr>
<tr><td><code id="likelihood0_+3A_obsfun">obsfun</code></td>
<td>
<p>The observation error function to be used: defaults to obsfun0</p>
</td></tr>
<tr><td><code id="likelihood0_+3A_procfun">procfun</code></td>
<td>
<p>The process noise function to be used: defaults to procfun0</p>
</td></tr>
<tr><td><code id="likelihood0_+3A_neff">neff</code></td>
<td>
<p>Should effective sample size be used to scale likelihood? Defaults to FALSE. TRUE uses automatic sample size, based on correlations in y. Otherwise, can be any positive number.</p>
</td></tr>
<tr><td><code id="likelihood0_+3A_lowerbound">lowerbound</code></td>
<td>
<p>Lower bound for log likelihood. Filter will be re-run if the value falls below this threshold. NOTE - this option may induce a bias
in the resulting likelihood (and subsequent parameter) estimates. Should only be set if the lower limit is indicative of filter failure (e.g. if all particles)
are degenerate. Defaults to (-Inf) - i.e. no lower limit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log likelihood generated by particleFilterLL function
</p>

<hr>
<h2 id='logit'>Logit</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Returns the logit transformation of x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>a number, vector, matrix, etc. to be transformed from (0, 1) to (-inf inf) by the logit transform</p>
</td></tr>
<tr><td><code id="logit_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to plogis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>transformed result - impossible values are replaced with NA, without warnings
</p>

<hr>
<h2 id='logitnormal_imode'>Get inverse logit-normal mode</h2><span id='topic+logitnormal_imode'></span>

<h3>Description</h3>

<p>Returns a mean for a logit normal such that the mode will be centered around mu
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logitnormal_imode(mu, sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logitnormal_imode_+3A_mu">mu</code></td>
<td>
<p>the value around which the mode should be centered (in logit space)</p>
</td></tr>
<tr><td><code id="logitnormal_imode_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of the logit distribution (in logit space)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the proposed mean for the distribution
</p>

<hr>
<h2 id='lognormal_imode'>Get inverse log-normal mode</h2><span id='topic+lognormal_imode'></span>

<h3>Description</h3>

<p>Returns a mean for a lognormal such that the mode will be centered around mu
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lognormal_imode(mu, sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lognormal_imode_+3A_mu">mu</code></td>
<td>
<p>the value around which the mode should be centered (in log space)</p>
</td></tr>
<tr><td><code id="lognormal_imode_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of the lognormal distribution (in log space)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the proposed mean for the distribution
</p>

<hr>
<h2 id='makeblock'>Make an embedding block from timeseries data</h2><span id='topic+makeblock'></span>

<h3>Description</h3>

<p>Returns a matrix X, where columns are time-delayed embeddings of Y, with number of embeddings
specified by embedding dimension E.
See help file for the S_map_Sugihara1994 function for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeblock(Y, E, lib = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeblock_+3A_y">Y</code></td>
<td>
<p>a timeseries vector from which to build the embedding.</p>
</td></tr>
<tr><td><code id="makeblock_+3A_e">E</code></td>
<td>
<p>a positive integer, specifying the embedding dimension</p>
</td></tr>
<tr><td><code id="makeblock_+3A_lib">lib</code></td>
<td>
<p>an optional matrix of library positions, for specifying cases where
Y is a composite timeseries made up of multiple separate observations (e.g. spatial replicates).
Matrix should have two columns, with the first row in each column specifying the start of the
timeseries section, and the second column specifying the end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of time-delayed embeddings
</p>

<hr>
<h2 id='makedynamics_general'>Simulate general time series</h2><span id='topic+makedynamics_general'></span>

<h3>Description</h3>

<p>Simulates a time series following a user-defined deterministic function, observation function, process noise function, and colonization function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makedynamics_general(
  n = 1000,
  n0 = 0.1,
  pdet = c(log(3), log(1)),
  proc = c(log(1)),
  obs = c(log(1)),
  pcol = c(logit(0.2), log(1)),
  detfun = detfun0,
  procfun = procfun0,
  obsfun = obsfun0,
  colfun = colfun0,
  doplot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makedynamics_general_+3A_n">n</code></td>
<td>
<p>number of timesteps to simulate</p>
</td></tr>
<tr><td><code id="makedynamics_general_+3A_n0">n0</code></td>
<td>
<p>starting population size</p>
</td></tr>
<tr><td><code id="makedynamics_general_+3A_pdet">pdet</code></td>
<td>
<p>a numeric vector of parameters for the deterministic function</p>
</td></tr>
<tr><td><code id="makedynamics_general_+3A_proc">proc</code></td>
<td>
<p>a numeric vector of parameters for the process noise function</p>
</td></tr>
<tr><td><code id="makedynamics_general_+3A_obs">obs</code></td>
<td>
<p>a numeric vector of parameters for the observation error function</p>
</td></tr>
<tr><td><code id="makedynamics_general_+3A_pcol">pcol</code></td>
<td>
<p>a numeric vector of parameters for the colonization function</p>
</td></tr>
<tr><td><code id="makedynamics_general_+3A_detfun">detfun</code></td>
<td>
<p>A function that simulates deterministic dynamics, which takes in arguments sdet (parameters for deterministic model, taken from pars$proc), and xt, observed abundances at time t. Returns estimated abundances at time t+1 based on deterministic function (either a parametric function or an EDM function). Defaults to detfun0.</p>
</td></tr>
<tr><td><code id="makedynamics_general_+3A_procfun">procfun</code></td>
<td>
<p>A function that simulates process noise, which takes in arguments sp (parameters for process noise function, taken from pars$proc) and xt (abundances prior to process noise). Returns abundances after process noise has occurred. Defaults to procfun0.</p>
</td></tr>
<tr><td><code id="makedynamics_general_+3A_obsfun">obsfun</code></td>
<td>
<p>An observation function, which takes in up to five variables, including so (a vector of parameter values, inherited from pars$obs), yt (a number, showing observed abundance at time t), xt (predicted abundances), binary value &quot;inverse&quot;, and number &quot;N&quot;. If inverse = TRUE,
then function should simulate N draws from the observation function, centered around value yt. If inverse = FALSE, then function should return log probability denisty of observed value yt given predicted values in xt. Defaults to obsfun0.</p>
</td></tr>
<tr><td><code id="makedynamics_general_+3A_colfun">colfun</code></td>
<td>
<p>A function simulating colonization events, that takes in two arguments: co, a vector of parameter values taken from pars$pcol, and xt, a number or numeric vector of abundances at time t, before colonization has occurred. Returns predicted abundances after colonization has occurred. Defaults to colful0.</p>
</td></tr>
<tr><td><code id="makedynamics_general_+3A_doplot">doplot</code></td>
<td>
<p>a logical specifying wether output should be plotted - defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An n-by-3 dataframe of states, including obs (observed values), truth (true values), and noproc (values without process noise)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #run function
 datout&lt;-makedynamics_general(n=2e4, proc = c(-2,log(1.2)))

 #show regression of variance vs. mean for binned data
 datout_ps&lt;-datout[datout$true&gt;0 &amp; datout$noproc&gt;0,]
 #bins
 sq&lt;-seq(0, quantile(datout$true, 0.95), length=50)
 ctd&lt;-cut(datout_ps$noproc, sq)
 #calculate mean and variance by bin
 tdat&lt;-data.frame(mu=(sq[-1]+sq[-length(sq)])/2,
      var=tapply((datout_ps$true-datout_ps$noproc)^2, ctd, mean))
 #plot result
 plot(log(tdat$mu), log(tdat$var), xlab="mu", ylab="var")
 #show regression
 summary(mod&lt;-lm(log(var)~log(mu), tdat)); abline(mod, col=2)
</code></pre>

<hr>
<h2 id='obsfun0'>default observation noise function</h2><span id='topic+obsfun0'></span>

<h3>Description</h3>

<p>Two options: If inverse=FALSE, calculates the log probability density of observation yt based on true state xt and observation error.
Otherwise, simulates N random observations of yt.
Observation error follows a Gaussian distribution truncated at zero, using a Tobit distribution.
Note that probability density is calculated based on a Tobit distribution, with lower boundary zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsfun0(
  so,
  yt,
  xt = NULL,
  inverse = FALSE,
  N = NULL,
  minsd = 0.01,
  time = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obsfun0_+3A_so">so</code></td>
<td>
<p>a numeric vector of length one, specifying either log-transformed standard deviation of the observation error as a fraction of the observation,
or two log-transformed parameters of the form sd=exp(B0)+exp(B1)*x.</p>
</td></tr>
<tr><td><code id="obsfun0_+3A_yt">yt</code></td>
<td>
<p>a number, representing a potential observed value of xt</p>
</td></tr>
<tr><td><code id="obsfun0_+3A_xt">xt</code></td>
<td>
<p>a number or numeric vector of &quot;true&quot; (or simulated) abundances at time t, from which the likelihood of yt will be calculated - defaults to NULL for inverse=TRUE</p>
</td></tr>
<tr><td><code id="obsfun0_+3A_inverse">inverse</code></td>
<td>
<p>a logical specifying whether inverse (i.e. random number generator) function should be implemented - defaults to FALSE</p>
</td></tr>
<tr><td><code id="obsfun0_+3A_n">N</code></td>
<td>
<p>number of draws from the random number generator, if inverse=TRUE - defaults to NULL</p>
</td></tr>
<tr><td><code id="obsfun0_+3A_minsd">minsd</code></td>
<td>
<p>minimum observation error allowed (e.g. if observation = 0), to prevent log likelihoods of -infinity - defaults to 0.01</p>
</td></tr>
<tr><td><code id="obsfun0_+3A_time">time</code></td>
<td>
<p>the timestep - defaults to NULL (i.e. not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If inverse=FALSE, returns a list including LL, a number or numeric vector of length xt, with predicted log likelihoods of observation yt,
and wts, a number or vector with weights corresponding to the relative likelihood of each observation (after accounting for variable continuous vs. discrete probability distributions).
If inverse = FALSE, returns N random draws from the observation function.
</p>

<hr>
<h2 id='parseparam0'>Parse parameters</h2><span id='topic+parseparam0'></span>

<h3>Description</h3>

<p>Takes in a vector of 3 or 6 parameters, and puts them into a list of the format expected by the particleFilterLL function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseparam0(
  param,
  colparam = c(logit(0.2), log(0.1)),
  detparam = c(log(1.2), log(1))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parseparam0_+3A_param">param</code></td>
<td>
<p>List of paramters, of length 2, 3, 4, 6, 7, or 8.
If 2, then in the order (obs1, proc1).
If 3, then in the order (obs1, proc1, proc2).
If 4, then in the order (obs1, obs2, proc1, proc2).
If 6, then in the order (obs1, proc1, pcol1, pcol2, det1, det2)
If 7, then in the order (obs1, proc1, proc2, pcol1, pcol2, det1, det2)
If 8, then in the order (obs1, obs2, proc1, proc2, pcol1, pcol2, det1, det2)
Note that if param is of length 2 or 3, then detparam  and colparam must be supplied. See obsfun0, procfun0, and detfun0 for more details.</p>
</td></tr>
<tr><td><code id="parseparam0_+3A_colparam">colparam</code></td>
<td>
<p>Optional vector of length two, including parameters for the colonization function.</p>
</td></tr>
<tr><td><code id="parseparam0_+3A_detparam">detparam</code></td>
<td>
<p>Optional vector of length two, including paramters for the deterministic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a formatted list of parameters
</p>

<hr>
<h2 id='particleFilterLL'>particle filter</h2><span id='topic+particleFilterLL'></span>

<h3>Description</h3>

<p>General function for caluclating the log-likeihood of a stochastic discrete-time model,
based on a noisy observation of time-series y. Returns estimates of true values of y, as well as for process noise, observation error, colonization rates, and extinction rates.
Function is adapted from the R code of Knape and Valpine (2012), Ecology 93:256-263.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>particleFilterLL(
  y,
  pars,
  N = 1000,
  detfun = detfun0,
  procfun = procfun0,
  obsfun = obsfun0,
  colfun = colfun0,
  edmdat = NULL,
  dotraceback = FALSE,
  fulltraceback = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="particleFilterLL_+3A_y">y</code></td>
<td>
<p>A numeric vector of observed values, from which the likelihood of parameters and functions will be determined.</p>
</td></tr>
<tr><td><code id="particleFilterLL_+3A_pars">pars</code></td>
<td>
<p>A list of parameter values. Must include elements obs (observation error parameters), proc (process noise parameters), and pcol (colonization parameters), which are passed on the their respecive functions, described below. If edmdat=NULL, then element det (deterministic process parameters) must be included.</p>
</td></tr>
<tr><td><code id="particleFilterLL_+3A_n">N</code></td>
<td>
<p>Number of particles to simulate. Defaults to 1e3.</p>
</td></tr>
<tr><td><code id="particleFilterLL_+3A_detfun">detfun</code></td>
<td>
<p>A function that simulates deterministic dynamics, which takes in arguments sdet (parameters for deterministic model, taken from pars$proc), and xt, observed abundances at time t. Returns estimated abundances at time t+1 based on deterministic function (either a parametric function or an EDM function). Defaults to detfun0.</p>
</td></tr>
<tr><td><code id="particleFilterLL_+3A_procfun">procfun</code></td>
<td>
<p>A function that simulates process noise, which takes in arguments sp (parameters for process noise function, taken from pars$proc) and xt (abundances prior to process noise). Returns abundances after process noise has occurred. Defaults to procfun0.</p>
</td></tr>
<tr><td><code id="particleFilterLL_+3A_obsfun">obsfun</code></td>
<td>
<p>An observation function, which takes in up to five variables, including so (a vector of parameter values, inherited from pars$obs), yt (a number, showing observed abundance at time t), xt (predicted abundances), binary value &quot;inverse&quot;, and number &quot;N&quot;. If inverse = TRUE,
then function should simulate N draws from the observation function, centered around value yt. If inverse = FALSE, then function should return log probability denisty of observed value yt given predicted values in xt. Defaults to obsfun0.</p>
</td></tr>
<tr><td><code id="particleFilterLL_+3A_colfun">colfun</code></td>
<td>
<p>A function simulating colonization events, that takes in two arguments: co, a vector of parameter values taken from pars$pcol, and xt, a number or numeric vector of abundances at time t, before colonization has occurred. Returns predicted abundances after colonization has occurred. Defaults to colful0.</p>
</td></tr>
<tr><td><code id="particleFilterLL_+3A_edmdat">edmdat</code></td>
<td>
<p>A list including arguments to be passed to the S_map_Sugihara1994 function - see S_map_Sugihara1994 help file for details. Alternatively, the user can provide a matrix of pre-computed S-map coefficients, in element &quot;smp_cf&quot;.
Default for edmdat is NULL, which implies that EDM will not be applied - instead, a detfun and pars$det must be included.</p>
</td></tr>
<tr><td><code id="particleFilterLL_+3A_dotraceback">dotraceback</code></td>
<td>
<p>A logical, indicating whether estimated values and demographic rates should be reported - defaults to FALSE</p>
</td></tr>
<tr><td><code id="particleFilterLL_+3A_fulltraceback">fulltraceback</code></td>
<td>
<p>A logical, indicating whether full matrix of particles for all time steps should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>LL (total log likelihood), LLlst (log likelihood for each time step), Nest (mean estimated state), Nsd (standard deviation of estimated state), Nest_noproc (mean estimated state at time t+1 without process error), Nsd_noproc (standard deviation of estimated state at time t+1 without process error),
fulltracemat (full traceback of particle paths), fulltracemat_noproc (full traceback of particle paths at time t+1 without process noise), and fulltraceindex (index positions for the particle traces over time)
</p>


<h3>Source</h3>

<p>Adapted from Knape and Valpine (2012), Ecology 93:256-263.
</p>

<hr>
<h2 id='particleFilterLL_piecewise'>run particle filter across piecewise data</h2><span id='topic+particleFilterLL_piecewise'></span>

<h3>Description</h3>

<p>Calculates likelihoods across several segments of data - e.g. multiple plots from a single experiment.
Requires several implicitely defined variables to run:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>particleFilterLL_piecewise(
  param,
  N,
  y,
  libuse_y,
  smap_coefs,
  Euse,
  tuse,
  colpar = c(logit(1e-06), log(0.1)),
  nsmp = 1,
  lowerbound = -999,
  maxNuse = 512000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="particleFilterLL_piecewise_+3A_param">param</code></td>
<td>
<p>parameters to be passed to parseparam0 function</p>
</td></tr>
<tr><td><code id="particleFilterLL_piecewise_+3A_n">N</code></td>
<td>
<p>number of particles</p>
</td></tr>
<tr><td><code id="particleFilterLL_piecewise_+3A_y">y</code></td>
<td>
<p>the time series to be analyzed</p>
</td></tr>
<tr><td><code id="particleFilterLL_piecewise_+3A_libuse_y">libuse_y</code></td>
<td>
<p>a matrix with two columns, specifying the start end end positions of segments within vector y</p>
</td></tr>
<tr><td><code id="particleFilterLL_piecewise_+3A_smap_coefs">smap_coefs</code></td>
<td>
<p>a matrix of s-mapping coefficients</p>
</td></tr>
<tr><td><code id="particleFilterLL_piecewise_+3A_euse">Euse</code></td>
<td>
<p>embedding dimension for the s-mapping analysis</p>
</td></tr>
<tr><td><code id="particleFilterLL_piecewise_+3A_tuse">tuse</code></td>
<td>
<p>theta for s-mapping analysis</p>
</td></tr>
<tr><td><code id="particleFilterLL_piecewise_+3A_colpar">colpar</code></td>
<td>
<p>parameters to be passed to the colfun0 - defaults to c(logit(1e-6), log(0.1))</p>
</td></tr>
<tr><td><code id="particleFilterLL_piecewise_+3A_nsmp">nsmp</code></td>
<td>
<p>number of sample particle trajectories to return - defaults to 1</p>
</td></tr>
<tr><td><code id="particleFilterLL_piecewise_+3A_lowerbound">lowerbound</code></td>
<td>
<p>minimum accepted likelihood - used to automatically select number of particles. Defaults to -999</p>
</td></tr>
<tr><td><code id="particleFilterLL_piecewise_+3A_maxnuse">maxNuse</code></td>
<td>
<p>maximum number of particles to simulate - defaults to 512000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>results from particle filter - including mean estimates (Nest) and standard deviations (Nsd), across particles,
and sample particle trajectories with (Nsmp) and without (Nsmp_noproc) process noise
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(dat)
# sort by index
dat = dat[order(dat$treatment, dat$number, dat$time),]


# make list of starting and ending positions for each replicate in the dat list
libmat&lt;-NULL
trtmat&lt;-data.frame(trt=as.character(sort(unique(dat$treatment))))
datnum&lt;-1:nrow(dat)

for(i in 1:nrow(trtmat)) {
  ps1&lt;-which(dat$treatment==trtmat$trt[i])
  replst&lt;-sort(unique(dat$number[ps1]))

  for(j in 1:length(replst)) {
    ps2&lt;-which(dat$number[ps1]==replst[j])
    libmat&lt;-rbind(libmat, data.frame(trt=trtmat$trt[i], rep=replst[j],
      start=min(datnum[ps1][ps2]), end=max(datnum[ps1][ps2])))
  }
}

## run particle filter
# select treatment to analyse: enter either "LSA" or "LSP"
trtuse&lt;-"HSP"
# extract library positions for treatment
libuse&lt;-as.matrix(libmat[libmat$trt==trtuse,c("start", "end")])
# save abundance data to variable y
yps&lt;-which(dat$treatment==trtuse)
y&lt;-dat[,"Chlamydomonas.terricola"][yps]
libuse_y&lt;-libuse-min(libuse)+1 # translate positions in dat to positions in y vector
y&lt;-y/sd(y) # standardize to mean of one
timesteps&lt;-dat$time[yps]

# get S-mapping parameters
sout&lt;-data.frame(E = 2:4, theta = NA, RMSE = NA)
for(i in 1:nrow(sout)) {
  optout = optimize(f = function(x) {S_map_Sugihara1994(Y = y, E = sout$E[i],
      theta = x, lib = libuse_y)$RMSE}, interval = c(0,10))
  sout$theta[i] = optout$minimum
  sout$RMSE[i] = optout$objective
}
tuse&lt;-sout$theta[which.min(sout$RMSE)] # find theta (nonlinerity) parameter
euse&lt;-sout$E[which.min(sout$RMSE)] # find embedding dimension
spred&lt;-S_map_Sugihara1994(Y = y, E = euse, theta = tuse, lib = libuse_y)

# set priors (log-transformed Beta_obs, Beta_proc1, and Beta_proc2)
minvUSE_edm&lt;-c(log(0.001), log(0.001))  # lower limits
maxvUSE_edm&lt;-c(log(2), log(2)) # upper limits


## Not run: 
  ## Run filter
  # Commented-out code: Install BayesianTools package if needed
  #install.packages("BayesianTools")
  set.seed(2343)
  require(BayesianTools)
  density_fun_USE_edm&lt;-function(param) density_fun0(param = param,
    minv = minvUSE_edm, maxv=maxvUSE_edm)
  sampler_fun_USE_edm&lt;-function(x) sampler_fun0(n = 1, minv = minvUSE_edm, maxv=maxvUSE_edm)
  prior_edm &lt;- createPrior(density = density_fun_USE_edm, sampler = sampler_fun_USE_edm,
                         lower = minvUSE_edm, upper = maxvUSE_edm)
  niter&lt;-5e3 # number of steps for the MCMC sampler
  N&lt;-2e3 # number of particles
  smap_coefs&lt;-process_scof(spred$C) # coefficients from s-mapping routine

  # likelihood and bayesian set-ups for EDM functions
  likelihood_EDM_piecewise_use&lt;-function(x) {
    # default values for filter - see likelihood_EDM_piecewise documentation for details
    # note that colpar are set near zero because we expect no colonisation into a closed microcosm.
    likelihood_EDM_piecewise(param=x, y, libuse_y, smap_coefs, euse, tuse, N,
                             colpar = c(logit(1e-06), log(0.1)))
  }

  bayesianSetup_EDM &lt;- createBayesianSetup(likelihood = likelihood_EDM_piecewise_use,
     prior = prior_edm)

  # run MCMC optimization (will take ~ 5 min)
  out_EDM &lt;- runMCMC(bayesianSetup = bayesianSetup_EDM,
     settings = list(iterations=niter, consoleUpdates=20))
  burnin&lt;-floor(niter/5) # burnin period
  plot(out_EDM, start=burnin) # plot MCMC chains
  gelmanDiagnostics(out_EDM, start=burnin) # calculate Gelman statistic
  summary(out_EDM, start=burnin) # coefficient summary

  ## extract abundance estimate from particle filter
  # use final estimate from MCMC chain
  smp_EDM&lt;-(getSample(out_EDM, start=floor(niter/5)))
  tmp&lt;-particleFilterLL_piecewise(param = smp_EDM[nrow(smp_EDM),], N=N, y = y, libuse_y = libuse_y,
                                  smap_coefs = smap_coefs, Euse = euse, tuse = tuse)
  # mean estimated abundance
  simout&lt;-tmp$Nest
  # sd estimated abundance
  sdout&lt;-tmp$Nsd
  # sample from true particle trajectory
  simout_smp&lt;-tmp$Nsmp
  # sample from true particle trajectory pre-process noise
  simout_smp_noproc&lt;-tmp$Nsmp_noproc

  plot(timesteps, simout, xlab="Time", ylab="Abundance")
  abline(h=0, lty=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='process_scof'>Process S-mapping coefficients</h2><span id='topic+process_scof'></span>

<h3>Description</h3>

<p>Processes s-mapping coefficients from S_map_Sugihara1994 into a matrix of form C1, C2, C3, ... C0, where C0 is the intercept,
C1 is the current time step t, C2 is timestep t-1, C3 is timestep t-2, and so on.
Rows correspond to the time step used to produce the prediction, e.g. row 4 is used to calculate
predicted value for time step 5. This is the format expected by the EDMfun0 function.
See help file for the S_map_Sugihara1994 function for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_scof(smap_coefs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_scof_+3A_smap_coefs">smap_coefs</code></td>
<td>
<p>a matrix of s-map coefficients, taken from the S_map_Sugihara1994 function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of s-mapping coefficients
</p>

<hr>
<h2 id='procfun_ct'>continuous-time process noise function</h2><span id='topic+procfun_ct'></span>

<h3>Description</h3>

<p>Simulates effects of process noise following a Gaussian perturbation.
Note that process noise only influences positive abundances (i.e. process noise cannot contribute to colonization)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procfun_ct(sp, xt, waiting_time = 1, time = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="procfun_ct_+3A_sp">sp</code></td>
<td>
<p>a numeric vector of length two or three, where terms 1-2 specify either the log-transformed standard deviation of the process noise function,
or an intercept and slope for calculating variance of process noise based on a power function of x, of the form var=exp(B0)*x^exp(B1)
The final term in the vector represents the recovery rate - i.e. the continuous time rate at which abundances recover from perturbation</p>
</td></tr>
<tr><td><code id="procfun_ct_+3A_xt">xt</code></td>
<td>
<p>a number or numeric vector of abundances at time t, before process noise has occurred</p>
</td></tr>
<tr><td><code id="procfun_ct_+3A_waiting_time">waiting_time</code></td>
<td>
<p>average time between disturbance events: defaults to 1</p>
</td></tr>
<tr><td><code id="procfun_ct_+3A_time">time</code></td>
<td>
<p>the timestep - defaults to NULL (i.e. not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number or numeric vector of length xt, with predicted abundances after process noise has occurred
</p>

<hr>
<h2 id='procfun0'>default process noise function</h2><span id='topic+procfun0'></span>

<h3>Description</h3>

<p>Simulates effects of process noise following a Gaussian perturbation.
Note that process noise only influences positive abundances (i.e. process noise cannot contribute to colonization)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procfun0(sp, xt, inverse = FALSE, time = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="procfun0_+3A_sp">sp</code></td>
<td>
<p>a numeric vector of length one or two, specifying either the log-transformed standard deviation of the process noise function,
or an intercept and slope for calculating variance of process noise based on a power function of x, of the form var=exp(B0)*x^exp(B1)</p>
</td></tr>
<tr><td><code id="procfun0_+3A_xt">xt</code></td>
<td>
<p>a number or numeric vector of abundances at time t, before process noise has occurred</p>
</td></tr>
<tr><td><code id="procfun0_+3A_inverse">inverse</code></td>
<td>
<p>a logical specifying whether the inverse (i.e. probability of drawing a value of zero given xt and sp) should be calcualted</p>
</td></tr>
<tr><td><code id="procfun0_+3A_time">time</code></td>
<td>
<p>the timestep - defaults to NULL (i.e. not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number or numeric vector of length xt, with predicted abundances after process noise has occurred
</p>

<hr>
<h2 id='pttstability'>pttstability: Methods for Measuring Stability in Systems Without Static Equilibria</h2><span id='topic+pttstability'></span>

<h3>Description</h3>

<p>The pttstability (&quot;ParTicle-Takens Stability&quot;) package is a collection of functions
that can be used to estimate the parameters of a stochastic state space model (i.e.
a model where a time series is observed with error).
</p>


<h3>Applications</h3>

<p>The goal of this package is to estimate the variability around a deterministic process, both in terms of
observation error - i.e. variability due to imperfect observations that does not influence system state -
and in terms of process noise - i.e. stochastic variation in the actual state of the process.
Unlike classical methods for estmiating variability, this package does not necesarilly assume that
the deterministic state is fixed (i.e. a fixed-point equilibrium), meaning that variability around a
dynamic trajectory can be estimated (e.g. stochastic fluctuations during predator-prey dynamics).
</p>
<p>By combining information about both the estimated deterministic state of the system and the estimated
effects of process noise, this package can be used to compute a dynamic analog of various stability metrics
- e.g. coefficient of variation (CV) or invariability. Estimated extinction rates and colonization rates
can also be estimated.
</p>


<h3>Contents</h3>

<p>This package builds on three existing toolkits. First, it applies an updated version of the
&quot;particleFilterLL&quot; particle filter function of Knape and Valpine (2012) to calculate likelihoods of
observed time series given modeled dynamics.
Second, it applies empirical dynamic modeling (EDM) methods to estimate deterministic
dynamics even in cases where the underlying equations governing system behavior are not known.
These models are based on Takens delay-embedding theorem, from which this package takes its name.
Finally, it (optionally) uses the MCMC fitting methods from the BayesianTools package to estimate paramter values for
the observation error, process noise, and (optionally) deterministic functions underlying observed dynamics.
</p>
<p>The default observation error and process noise functions in this package (obsfun0 and procfun0)
take advantage of the Taylor Power law to separate noise components for relatively short time series.
Observation error is assumed to scale with the observed state as sd_obs(x) = x*exp(obs),
Process noise is either a constant (i.e. sd_proc(x) = exp(proc)), or, if two variables are given,
process noise scales as a power function of the observed value as sd_proc(x) = sqrt(exp(proc1)*x^exp(proc2))
</p>
<p>Note that although we include default functions in this package, users are able (and encouraged!) to write
their own (including for observation error, process noise, deterministic dynamics, priors, and likelihoods).
</p>


<h3>Source</h3>

<p>Adam T. Clark, Lina K. Mhlbauer, Helmut Hillebrand, and Canan Karako. (2022). Measuring Stability in Ecological Systems Without Static Equilibria. Ecosphere 13(12):e4328.
</p>
<p>Knape, J., and Valpine, P. (2012). Fitting complex population models by combining particle filters with Markov chain Monte Carlo. Ecology 93:256-263.
</p>
<p>Ye, H., Sugihara, G., et al. (2015). Equation-free ecosystem forecasting. PNAS 112:E1569-E1576.
</p>
<p>Ye, H., et al. (2019). rEDM: Applications of Empirical Dynamic Modeling from Time Series. R package version 0.7.2.
</p>
<p>Hartig, F., et al. (2019). BayesianTools: General-Purpose MCMC and SMC Samplers and Tools for Bayesian Statistics. R package version 0.1.6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Set seed
set.seed(5826)

## Simulate data
pars_true&lt;-list(obs=log(0.15),
            proc=c(log(0.1)),
            pcol=c(logit(0.2), log(0.1)),
            det=c(log(1.2),log(1)))
#parameters for the filter
pars_filter&lt;-pars_true

#generate random parameter values
datout&lt;-makedynamics_general(n = 100, n0 = exp(pars_true$det[2]),
                             pdet=pars_true$det, proc = pars_true$proc,
                             obs = pars_true$obs, pcol = pars_true$pcol,
                             detfun = detfun0_sin, procfun = procfun0,
                             obsfun=obsfun0, colfun=colfun0)
y&lt;-datout$obs
plot(y, type = "l", xlab="time", ylab="observed abundance")

#get parameters for S-mapping
sout&lt;-data.frame(E = 2:4, theta = NA, RMSE = NA)
for(i in 1:nrow(sout)) {
  optout = optimize(f = function(x) {S_map_Sugihara1994(Y = y, E = sout$E[i],
    theta = x)$RMSE}, interval = c(0,10))
  sout$theta[i] = optout$minimum
  sout$RMSE[i] = optout$objective
}
tuse&lt;-sout$theta[which.min(sout$RMSE)] # find theta (nonlinerity) parameter
Euse&lt;-sout$E[which.min(sout$RMSE)] # find embedding dimension
spred&lt;-S_map_Sugihara1994(Y = y, E = Euse, theta = tuse) # fit S-mapping for best paramter set
plot(spred$Y, spred$Y_hat); abline(a=0, b=1, lty=2) # observed vs. predicted

## Run filter with "correct" parameter values
N = 1e3 # number of particles
#based on detful0
filterout_det&lt;-particleFilterLL(y, pars=pars_filter, N,
                                detfun = detfun0_sin, procfun = procfun0,
                                dotraceback = TRUE, fulltraceback = TRUE)
#based on EDM
filterout_edm&lt;-particleFilterLL(y, pars=pars_filter, N, detfun = EDMfun0,
                                edmdat = list(E=Euse, theta=tuse),
                                procfun = procfun0, dotraceback = TRUE,
                                fulltraceback = TRUE)

#plot filter output
op = par(mar=c(4,4,2,2), mfrow=c(3,1))
#plot 30 of the 1000 particles to show general trend
# correct deterministic function
matplot(1:length(y), filterout_det$fulltracemat[,1:30],
        col=adjustcolor(1,alpha.f = 0.5), lty=3,
        type="l", xlab="time", ylab="abund", main="detfun0")
lines(1:length(y), y, col=2, lwd=1.5) #observations
lines(1:length(y), datout$true, col="blue", lwd=1.5, lty=2) #true values
lines(1:length(y), filterout_det$Nest, col=3, lwd=1.5) #mean filter estimate

# EDM function
matplot(1:length(y), filterout_edm$fulltracemat[,1:30],
        col=adjustcolor(1,alpha.f = 0.5), lty=3,
        type="l", xlab="time", ylab="abund", main="EDM")
lines(1:length(y), y, col=2, lwd=1.5)
lines(1:length(y), datout$true, col="blue", lwd=1.5, lty=2)
lines(1:length(y), filterout_edm$Nest, col=3, lwd=1.5)

plot(filterout_det$Nest, datout$true, xlim=range(c(filterout_det$Nest,
     filterout_edm$Nest)),
     xlab="predicted", ylab="true value", col=4)
points(filterout_edm$Nest, datout$true, col=2)
points(y, datout$true, col=3)
abline(a=0, b=1, lty=2)
legend("topleft", c("detfun0", "EDM", "obs"), pch=1, col=c(4,2,3), bty="n")

#note improvement in fit, for both filters
cor(datout$true, datout$obs)^2 #observations
cor(datout$true, filterout_det$Nest)^2 #deterministic filter
cor(datout$true, filterout_edm$Nest)^2 #EDM filter
par(op) # reset plotting parameters

## Not run: 
# Commented-out code: Install BayesianTools if needed
#install.packages("BayesianTools")
require(BayesianTools)
## Run optimizers
#create priors
minvUSE&lt;-c(-4, -4) #minimum interval for obs and proc
maxvUSE&lt;-c(0, 0) #maximum interval for obs and proc

minvUSE_edm&lt;-c(-4, -4) #minimum interval for obs and proc
maxvUSE_edm&lt;-c(0, 0) #maximum interval for obs and proc

#density, sampler, and prior functions for deterministic function
density_fun_USE&lt;-function(param) density_fun0(param = param, minv = minvUSE,
                         maxv=maxvUSE)
sampler_fun_USE&lt;-function(x) sampler_fun0(n = 1, minv = minvUSE,
                         maxv=maxvUSE)
prior_USE &lt;- createPrior(density = density_fun_USE,
                         sampler = sampler_fun_USE,
                         lower = minvUSE, upper = maxvUSE)

#density, sampler, and prior functions for EDM function
density_fun_USE_edm&lt;-function(param) density_fun0(param = param,
                         minv = minvUSE_edm, maxv=maxvUSE_edm)
sampler_fun_USE_edm&lt;-function(x) sampler_fun0(n = 1, minv = minvUSE_edm,
                         maxv=maxvUSE_edm)
prior_edm &lt;- createPrior(density = density_fun_USE_edm,
                         sampler = sampler_fun_USE_edm,
                         lower = minvUSE_edm, upper = maxvUSE_edm)
## Run filter
niter&lt;-5000 #number of steps for the MCMC sampler
N&lt;-1e3 #number of particles
Euse&lt;-Euse #number of embedding dimensions

#likelihood and bayesian set-ups for deterministic functions
likelihood_detfun0&lt;-function(x) likelihood0(param=x, y=y,
                         parseparam = parseparam0, detfun = detfun0_sin,
                         procfun = procfun0, N = N)
bayesianSetup_detfun0 &lt;- createBayesianSetup(likelihood = likelihood_detfun0,
                         prior = prior_USE)

#likelihood and bayesian set-ups for EDM functions
likelihood_EDM&lt;-function(x) {
  likelihood0(param = x, y=y, parseparam = parseparam0, procfun = procfun0,
              detfun = EDMfun0, edmdat = list(E=Euse, theta=tuse), N = N)
}

bayesianSetup_EDM &lt;- createBayesianSetup(likelihood = likelihood_EDM,
                         prior = prior_edm)
#run MCMC optimization
out_detfun0 &lt;- runMCMC(bayesianSetup = bayesianSetup_detfun0,
                   settings = list(iterations=niter, consoleUpdates=20))
out_EDM &lt;- runMCMC(bayesianSetup = bayesianSetup_EDM,
                   settings = list(iterations=niter, consoleUpdates=20))

#plot results, with a 1000-step burn-in
plot(out_detfun0, start = 1000, thin = 2)
plot(out_EDM, start = 1000, thin = 2)

## extract and plot parameter distributions
smp_detfun0&lt;-getSample(out_detfun0, start = 1000, thin = 2)
smp_EDM&lt;-getSample(out_EDM, start=1000, thin = 2)

op = par(mfrow=c(2,2))
hist(exp(smp_detfun0[,1]), xlim=c(exp(minvUSE[1]), exp(maxvUSE[1])),
                    main="det. function", xlab="obs", breaks = 20)
abline(v=exp(pars_true$obs), col=2) # true value
abline(v=c(exp(minvUSE[1]), exp(maxvUSE[1])), col=1, lty=2)# Priors

hist(exp(smp_detfun0[,2]), xlim=c(exp(minvUSE[2]), exp(maxvUSE[2])),
                    main="det. function", xlab="proc", breaks = 20)
abline(v=exp(pars_true$proc), col=2) # true value
abline(v=c(exp(minvUSE[2]), exp(maxvUSE[2])), col=1, lty=2)# Priors

hist(exp(smp_EDM[,1]), xlim=c(exp(minvUSE_edm[1]), exp(maxvUSE_edm[1])),
                    main="EDM function", xlab="obs", breaks = 20)
abline(v=exp(pars_true$obs), col=2) # true value
abline(v=c(exp(minvUSE_edm[1]), exp(maxvUSE_edm[1])), col=1, lty=2)# Priors

hist(exp(smp_EDM[,2]), xlim=c(exp(minvUSE_edm[2]), exp(maxvUSE_edm[2])),
                    main="EDM function", xlab="proc", breaks = 20)
abline(v=exp(pars_true$proc), col=2) # true value
abline(v=c(exp(minvUSE_edm[2]), exp(maxvUSE_edm[2])), col=1, lty=2)# Priors
# note slight over-estimate of process noise due to EDM error
par(op) # reset plotting parameters

## End(Not run)
</code></pre>

<hr>
<h2 id='S_map_Sugihara1994'>Apply S-mapping algorithm from Sugihara 1994</h2><span id='topic+S_map_Sugihara1994'></span>

<h3>Description</h3>

<p>Carries out an S-mapping analysis, following the algorithm outlined in Sugihara (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S_map_Sugihara1994(Y, E, theta, X = NULL, lib = NULL, trimNA = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="S_map_Sugihara1994_+3A_y">Y</code></td>
<td>
<p>a timeseries vector from which to build the embedding.</p>
</td></tr>
<tr><td><code id="S_map_Sugihara1994_+3A_e">E</code></td>
<td>
<p>a positive integer, specifying the embedding dimension</p>
</td></tr>
<tr><td><code id="S_map_Sugihara1994_+3A_theta">theta</code></td>
<td>
<p>a positive numeric scalar, specifying the nonlinearity parameter for the analysis. A value of 0 indicates
a fully linear analysis; higher numbers indicate greater nonlinearity.</p>
</td></tr>
<tr><td><code id="S_map_Sugihara1994_+3A_x">X</code></td>
<td>
<p>an optional matrix of time-delayed embeddings to use for the analysis</p>
</td></tr>
<tr><td><code id="S_map_Sugihara1994_+3A_lib">lib</code></td>
<td>
<p>an optional matrix of library positions, for specifying cases where
Y is a composite timeseries made up of multiple separate observations (e.g. spatial replicates).
Matrix should have two columns, with the first row in each column specifying the start of the
timeseries section, and the second column specifying the end.</p>
</td></tr>
<tr><td><code id="S_map_Sugihara1994_+3A_trimna">trimNA</code></td>
<td>
<p>a logical specifying whether NA values should be removed from Y and X - defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list, including the timeseries used for S-mapping (Y), the delay embedding matrix used for S-mapping (X),
a vector of predictions (Y_hat), a matrix of S-mapping coefficients (C), the standard errors for the S-mapping
coefficients (C_SE), and goodness of fit metrics R-squared (R2) and root mean square error (RMSE).
</p>


<h3>Source</h3>

<p>Sugihara, G. (1994). Nonlinear forecasting for the classification of natural time-series. Philos. Trans. R. Soc. -Math. Phys. Eng. Sci., 348, 477495.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an example timeseries
n = 100
set.seed(1234)
datout&lt;-makedynamics_general(n = n+2,
                             pdet=log(c(0.8,1)),
                             proc = -2.5,
                             detfun = detfun0_sin)
plot(datout$true, type = "l") # plot timeseries
Y = datout$true # extract true values

# run s-mapping
sout = S_map_Sugihara1994(Y = Y, E = 2, theta = 0.5)
s_coef = process_scof(sout$C) # process coefficients from the S-mapping output

# find best E/theta
fitout = data.frame(E = 1:5, theta = NA, RMSE = NA)

for(i in 1:nrow(fitout)) {
   E = fitout$E[i]
   Ytmp = Y[-c(1:E)]
   optout = optimize(f = function(x) {S_map_Sugihara1994(Ytmp, E, x)$RMSE}, interval = c(0,10))
  
  fitout$theta[i] = optout$minimum # get best theta for given E
  fitout$RMSE[i] = optout$objective # get error
}
ps = which.min(fitout$RMSE)

E = fitout$E[ps] # get best E
theta = fitout$theta[ps] # get best theta
X = makeblock(Y, E) # get X for analysis
Y = Y[-c(1:E)] # trim NA values (corresponding to positions in X)
X = X[(E+1):nrow(X),] # trim NA values
sout = S_map_Sugihara1994(Y = Y, E = E,
  theta = theta, X = X) # run S-mapping for best paramter combination
sout$R2 # look at R-squared

# check fit
plot(sout$Y_hat, Y)
abline(a=0, b=1, lty=2)
</code></pre>

<hr>
<h2 id='sampler_fun0'>Default sampler function for prior</h2><span id='topic+sampler_fun0'></span>

<h3>Description</h3>

<p>Draws samples from a flat prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler_fun0(n = 1, minv, maxv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampler_fun0_+3A_n">n</code></td>
<td>
<p>number of random draws to take from the priors</p>
</td></tr>
<tr><td><code id="sampler_fun0_+3A_minv">minv</code></td>
<td>
<p>Vector of minimum values to return for each parameter</p>
</td></tr>
<tr><td><code id="sampler_fun0_+3A_maxv">maxv</code></td>
<td>
<p>Vector of maximum values to return for each parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns random draws from the priors
</p>

<hr>
<h2 id='sdproc_abstract'>calculate estimated total variance</h2><span id='topic+sdproc_abstract'></span>

<h3>Description</h3>

<p>Function for estimating stochastic variation in linar process x as a function of relative growth rate and disturbance regime standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdproc_abstract(sd_proc, rgr, waiting_time = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdproc_abstract_+3A_sd_proc">sd_proc</code></td>
<td>
<p>standard deviation of the (Gaussian) disturbance process</p>
</td></tr>
<tr><td><code id="sdproc_abstract_+3A_rgr">rgr</code></td>
<td>
<p>relative growth rate of the linear process</p>
</td></tr>
<tr><td><code id="sdproc_abstract_+3A_waiting_time">waiting_time</code></td>
<td>
<p>average waiting time between (random exponentially distributed through time) disturbance events</p>
</td></tr>
</table>


<h3>Value</h3>

<p>standard deviation of stochastic variability in x
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
