<!DOCTYPE html><html><head><title>Help for package hdnom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hdnom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_nomogram'><p>Construct nomogram ojects for high-dimensional Cox models</p></a></li>
<li><a href='#calibrate'><p>Calibrate high-dimensional Cox models</p></a></li>
<li><a href='#calibrate_external'><p>Externally calibrate high-dimensional Cox models</p></a></li>
<li><a href='#calibrate_external_surv_prob_true'><p>Compute Kaplan-Meier estimated survival probabilities for external calibration</p></a></li>
<li><a href='#calibrate_surv_prob_true'><p>Compute Kaplan-Meier estimated survival probabilities for calibration</p></a></li>
<li><a href='#compare_by_calibrate'><p>Compare high-dimensional Cox models by model calibration</p></a></li>
<li><a href='#compare_by_validate'><p>Compare high-dimensional Cox models by model validation</p></a></li>
<li><a href='#fit_aenet'><p>Model selection for high-dimensional Cox models with adaptive elastic-net penalty</p></a></li>
<li><a href='#fit_alasso'><p>Model selection for high-dimensional Cox models with adaptive lasso penalty</p></a></li>
<li><a href='#fit_enet'><p>Model selection for high-dimensional Cox models with elastic-net penalty</p></a></li>
<li><a href='#fit_flasso'><p>Model selection for high-dimensional Cox models with fused lasso penalty</p></a></li>
<li><a href='#fit_lasso'><p>Model selection for high-dimensional Cox models with lasso penalty</p></a></li>
<li><a href='#fit_mcp'><p>Model selection for high-dimensional Cox models with MCP penalty</p></a></li>
<li><a href='#fit_mnet'><p>Model selection for high-dimensional Cox models with Mnet penalty</p></a></li>
<li><a href='#fit_scad'><p>Model selection for high-dimensional Cox models with SCAD penalty</p></a></li>
<li><a href='#fit_snet'><p>Model selection for high-dimensional Cox models with Snet penalty</p></a></li>
<li><a href='#glmnet_basesurv'><p>Breslow baseline hazard estimator for glmnet objects</p></a></li>
<li><a href='#glmnet_calibrate_external_surv_prob_pred'><p>Compute glmnet predicted survival probabilities for external calibration</p></a></li>
<li><a href='#glmnet_calibrate_surv_prob_pred'><p>Compute glmnet predicted survival probabilities for calibration</p></a></li>
<li><a href='#glmnet_survcurve'><p>Survival curve prediction for glmnet objects</p></a></li>
<li><a href='#glmnet_tune_alpha'><p>Automatic alpha tuning function by k-fold cross-validation</p></a></li>
<li><a href='#glmnet_validate_external_tauc'><p>Compute external validation measures for glmnet objects</p></a></li>
<li><a href='#glmnet_validate_tauc'><p>Compute validation measures for glmnet objects</p></a></li>
<li><a href='#hdnom-package'><p>hdnom: Benchmarking and Visualization Toolkit for Penalized Cox Models</p></a></li>
<li><a href='#infer_variable_type'><p>Extract information of selected variables from high-dimensional Cox models</p></a></li>
<li><a href='#kmplot'><p>Kaplan-Meier plot with number at risk table for internal calibration and</p>
external calibration results</a></li>
<li><a href='#kmplot_raw'><p>Kaplan-Meier Plot with Number at Risk Table</p></a></li>
<li><a href='#logrank_test'><p>Log-rank test for internal calibration and external calibration results</p></a></li>
<li><a href='#ncvreg_basesurv'><p>Breslow baseline hazard estimator for ncvreg objects</p></a></li>
<li><a href='#ncvreg_calibrate_external_surv_prob_pred'><p>Compute ncvreg predicted survival probabilities for external calibration</p></a></li>
<li><a href='#ncvreg_calibrate_surv_prob_pred'><p>Compute ncvreg predicted survival probabilities for calibration</p></a></li>
<li><a href='#ncvreg_survcurve'><p>Survival curve prediction for ncvreg objects</p></a></li>
<li><a href='#ncvreg_tune_gamma'><p>Automatic MCP/SCAD gamma tuning function by k-fold cross-validation</p></a></li>
<li><a href='#ncvreg_tune_gamma_alpha'><p>Automatic Mnet/Snet gamma and alpha tuning function by k-fold cross-validation</p></a></li>
<li><a href='#ncvreg_validate_external_tauc'><p>Compute external validation measures for ncvreg model objects</p></a></li>
<li><a href='#ncvreg_validate_tauc'><p>Compute validation measures for ncvreg model objects</p></a></li>
<li><a href='#palette_aaas'><p>Color Palette for AAAS Journals</p></a></li>
<li><a href='#palette_jco'><p>Color Palette for Journal of Clinical Oncology (JCO)</p></a></li>
<li><a href='#palette_lancet'><p>Color Palette for Lancet Journals</p></a></li>
<li><a href='#palette_npg'><p>Color Palette for NPG Journals</p></a></li>
<li><a href='#penalized_basesurv'><p>Breslow baseline hazard estimator for penfit objects</p></a></li>
<li><a href='#penalized_calibrate_external_surv_prob_pred'><p>Compute penfit predicted survival probabilities for external calibration</p></a></li>
<li><a href='#penalized_calibrate_surv_prob_pred'><p>Compute penfit predicted survival probabilities for calibration</p></a></li>
<li><a href='#penalized_survcurve'><p>Survival curve prediction for penfit objects</p></a></li>
<li><a href='#penalized_tune_lambda'><p>Automatic lambda tuning function for fused lasso by k-fold cross-validation</p></a></li>
<li><a href='#penalized_validate_external_tauc'><p>Compute external validation measures for penfit model objects</p></a></li>
<li><a href='#penalized_validate_tauc'><p>Compute validation measures for penfit model objects</p></a></li>
<li><a href='#plot.hdnom.calibrate'><p>Plot calibration results</p></a></li>
<li><a href='#plot.hdnom.calibrate.external'><p>Plot external calibration results</p></a></li>
<li><a href='#plot.hdnom.compare.calibrate'><p>Plot model comparison by calibration results</p></a></li>
<li><a href='#plot.hdnom.compare.validate'><p>Plot model comparison by validation results</p></a></li>
<li><a href='#plot.hdnom.nomogram'><p>Plot nomogram objects</p></a></li>
<li><a href='#plot.hdnom.validate'><p>Plot optimism-corrected time-dependent discrimination curves for validation</p></a></li>
<li><a href='#plot.hdnom.validate.external'><p>Plot time-dependent discrimination curves for external validation</p></a></li>
<li><a href='#predict.hdnom.model'><p>Make predictions from high-dimensional Cox models</p></a></li>
<li><a href='#print.hdnom.calibrate'><p>Print calibration results</p></a></li>
<li><a href='#print.hdnom.calibrate.external'><p>Print external calibration results</p></a></li>
<li><a href='#print.hdnom.compare.calibrate'><p>Print model comparison by calibration results</p></a></li>
<li><a href='#print.hdnom.compare.validate'><p>Print model comparison by validation results</p></a></li>
<li><a href='#print.hdnom.model'><p>Print high-dimensional Cox model objects</p></a></li>
<li><a href='#print.hdnom.nomogram'><p>Print nomograms objects</p></a></li>
<li><a href='#print.hdnom.validate'><p>Print validation results</p></a></li>
<li><a href='#print.hdnom.validate.external'><p>Print external validation results</p></a></li>
<li><a href='#smart'><p>Imputed SMART study data</p></a></li>
<li><a href='#smarto'><p>Original SMART study data</p></a></li>
<li><a href='#summary.hdnom.calibrate'><p>Summary of calibration results</p></a></li>
<li><a href='#summary.hdnom.calibrate.external'><p>Summary of external calibration results</p></a></li>
<li><a href='#summary.hdnom.compare.calibrate'><p>Summary of model comparison by calibration results</p></a></li>
<li><a href='#summary.hdnom.compare.validate'><p>Summary of model comparison by validation results</p></a></li>
<li><a href='#summary.hdnom.validate'><p>Summary of validation results</p></a></li>
<li><a href='#summary.hdnom.validate.external'><p>Summary of external validation results</p></a></li>
<li><a href='#theme_hdnom'><p>Plot theme (ggplot2) for hdnom</p></a></li>
<li><a href='#validate'><p>Validate high-dimensional Cox models with time-dependent AUC</p></a></li>
<li><a href='#validate_external'><p>Externally validate high-dimensional Cox models with time-dependent AUC</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Benchmarking and Visualization Toolkit for Penalized Cox Models</td>
</tr>
<tr>
<td>Version:</td>
<td>6.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates nomogram visualizations for penalized Cox regression
    models, with the support of reproducible survival model building,
    validation, calibration, and comparison for high-dimensional data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nanx.me/hdnom/">https://nanx.me/hdnom/</a>, <a href="https://github.com/nanxstats/hdnom">https://github.com/nanxstats/hdnom</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nanxstats/hdnom/issues">https://github.com/nanxstats/hdnom/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreach, ggplot2, glmnet, gridExtra, ncvreg, penalized,
survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel, knitr, ragg, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-03 02:27:09 UTC; nanx</td>
</tr>
<tr>
<td>Author:</td>
<td>Nan Xiao <a href="https://orcid.org/0000-0002-0250-5673"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Qing-Song Xu [aut],
  Miao-Zhu Li [aut],
  Frank Harrell [ctb] (rms author),
  Sergej Potapov [ctb] (survAUC author),
  Werner Adler [ctb] (survAUC author),
  Matthias Schmid [ctb] (survAUC author)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nan Xiao &lt;me@nanx.me&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-03 03:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_nomogram'>Construct nomogram ojects for high-dimensional Cox models</h2><span id='topic+as_nomogram'></span>

<h3>Description</h3>

<p>Construct nomograms ojects for high-dimensional Cox models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_nomogram(
  object,
  x,
  time,
  event,
  pred.at = NULL,
  fun.at = NULL,
  funlabel = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_nomogram_+3A_object">object</code></td>
<td>
<p>Model object fitted by 'hdnom::fit_*()' functions.</p>
</td></tr>
<tr><td><code id="as_nomogram_+3A_x">x</code></td>
<td>
<p>Matrix of training data used for fitting the model.</p>
</td></tr>
<tr><td><code id="as_nomogram_+3A_time">time</code></td>
<td>
<p>Survival time. Must be of the same length with
the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="as_nomogram_+3A_event">event</code></td>
<td>
<p>Status indicator, normally 0 = alive, 1 = dead.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="as_nomogram_+3A_pred.at">pred.at</code></td>
<td>
<p>Time point at which to plot nomogram prediction axis.</p>
</td></tr>
<tr><td><code id="as_nomogram_+3A_fun.at">fun.at</code></td>
<td>
<p>Function values to label on axis.</p>
</td></tr>
<tr><td><code id="as_nomogram_+3A_funlabel">funlabel</code></td>
<td>
<p>Label for <code>fun</code> axis.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The nomogram visualizes the model under the automatically
selected &quot;optimal&quot; hyperparameters (e.g. lambda, alpha, gamma).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(smart)
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

fit &lt;- fit_lasso(x, y, nfolds = 5, rule = "lambda.1se", seed = 11)

nom &lt;- as_nomogram(
  fit, x, time, event, pred.at = 365 * 2,
  funlabel = "2-Year Overall Survival Probability"
)

print(nom)
plot(nom)
</code></pre>

<hr>
<h2 id='calibrate'>Calibrate high-dimensional Cox models</h2><span id='topic+calibrate'></span>

<h3>Description</h3>

<p>Calibrate high-dimensional Cox models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate(
  x,
  time,
  event,
  model.type = c("lasso", "alasso", "flasso", "enet", "aenet", "mcp", "mnet", "scad",
    "snet"),
  alpha,
  lambda,
  pen.factor = NULL,
  gamma,
  lambda1,
  lambda2,
  method = c("fitting", "bootstrap", "cv", "repeated.cv"),
  boot.times = NULL,
  nfolds = NULL,
  rep.times = NULL,
  pred.at,
  ngroup = 5,
  seed = 1001,
  trace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate_+3A_x">x</code></td>
<td>
<p>Matrix of training data used for fitting the model;
on which to run the calibration.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_time">time</code></td>
<td>
<p>Survival time.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_event">event</code></td>
<td>
<p>Status indicator, normally 0 = alive, 1 = dead.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_model.type">model.type</code></td>
<td>
<p>Model type to calibrate. Could be one of <code>"lasso"</code>,
<code>"alasso"</code>, <code>"flasso"</code>, <code>"enet"</code>, <code>"aenet"</code>,
<code>"mcp"</code>, <code>"mnet"</code>, <code>"scad"</code>, or <code>"snet"</code>.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_alpha">alpha</code></td>
<td>
<p>Value of the elastic-net mixing parameter alpha for
<code>enet</code>, <code>aenet</code>, <code>mnet</code>, and <code>snet</code> models.
For <code>lasso</code>, <code>alasso</code>, <code>mcp</code>, and <code>scad</code> models,
please set <code>alpha = 1</code>.
<code>alpha=1</code>: lasso (l1) penalty; <code>alpha=0</code>: ridge (l2) penalty.
Note that for <code>mnet</code> and <code>snet</code> models,
<code>alpha</code> can be set to very close to 0 but not 0 exactly.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_lambda">lambda</code></td>
<td>
<p>Value of the penalty parameter lambda to use in the
model fits on the resampled data. From the Cox model you have built.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_pen.factor">pen.factor</code></td>
<td>
<p>Penalty factors to apply to each coefficient.
From the built <em>adaptive lasso</em> or <em>adaptive elastic-net</em> model.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_gamma">gamma</code></td>
<td>
<p>Value of the model parameter gamma for
MCP/SCAD/Mnet/Snet models.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_lambda1">lambda1</code></td>
<td>
<p>Value of the penalty parameter lambda1 for fused lasso model.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_lambda2">lambda2</code></td>
<td>
<p>Value of the penalty parameter lambda2 for fused lasso model.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_method">method</code></td>
<td>
<p>Calibration method.
Options including <code>"fitting"</code>, <code>"bootstrap"</code>, <code>"cv"</code>,
and <code>"repeated.cv"</code>.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_boot.times">boot.times</code></td>
<td>
<p>Number of repetitions for bootstrap.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds for cross-validation and
repeated cross-validation.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_rep.times">rep.times</code></td>
<td>
<p>Number of repeated times for repeated cross-validation.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_pred.at">pred.at</code></td>
<td>
<p>Time point at which calibration should take place.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_ngroup">ngroup</code></td>
<td>
<p>Number of groups to be formed for calibration.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_seed">seed</code></td>
<td>
<p>A random seed for resampling.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_trace">trace</code></td>
<td>
<p>Logical. Output the calibration progress or not.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

# Fit Cox model with lasso penalty
fit &lt;- fit_lasso(x, y, nfolds = 5, rule = "lambda.1se", seed = 11)

# Model calibration by fitting the original data directly
cal.fitting &lt;- calibrate(
  x, time, event,
  model.type = "lasso",
  alpha = 1, lambda = fit$lambda,
  method = "fitting",
  pred.at = 365 * 9, ngroup = 5,
  seed = 1010
)

# Model calibration by 5-fold cross-validation
cal.cv &lt;- calibrate(
  x, time, event,
  model.type = "lasso",
  alpha = 1, lambda = fit$lambda,
  method = "cv", nfolds = 5,
  pred.at = 365 * 9, ngroup = 5,
  seed = 1010
)

print(cal.fitting)
summary(cal.fitting)
plot(cal.fitting)

print(cal.cv)
summary(cal.cv)
plot(cal.cv)

# # Test fused lasso, SCAD, and Mnet models
# data(smart)
# x = as.matrix(smart[, -c(1, 2)])[1:500, ]
# time = smart$TEVENT[1:500]
# event = smart$EVENT[1:500]
# y = survival::Surv(time, event)
#
# set.seed(1010)
# cal.fitting = calibrate(
#   x, time, event, model.type = "flasso",
#   lambda1 = 5, lambda2 = 2,
#   method = "fitting",
#   pred.at = 365 * 9, ngroup = 5,
#   seed = 1010)
#
# cal.boot = calibrate(
#   x, time, event, model.type = "scad",
#   gamma = 3.7, alpha = 1, lambda = 0.03,
#   method = "bootstrap", boot.times = 10,
#   pred.at = 365 * 9, ngroup = 5,
#   seed = 1010)
#
# cal.cv = calibrate(
#   x, time, event, model.type = "mnet",
#   gamma = 3, alpha = 0.3, lambda = 0.03,
#   method = "cv", nfolds = 5,
#   pred.at = 365 * 9, ngroup = 5,
#   seed = 1010)
#
# cal.repcv = calibrate(
#   x, time, event, model.type = "flasso",
#   lambda1 = 5, lambda2 = 2,
#   method = "repeated.cv", nfolds = 5, rep.times = 3,
#   pred.at = 365 * 9, ngroup = 5,
#   seed = 1010)
#
# print(cal.fitting)
# summary(cal.fitting)
# plot(cal.fitting)
#
# print(cal.boot)
# summary(cal.boot)
# plot(cal.boot)
#
# print(cal.cv)
# summary(cal.cv)
# plot(cal.cv)
#
# print(cal.repcv)
# summary(cal.repcv)
# plot(cal.repcv)
</code></pre>

<hr>
<h2 id='calibrate_external'>Externally calibrate high-dimensional Cox models</h2><span id='topic+calibrate_external'></span>

<h3>Description</h3>

<p>Externally calibrate high-dimensional Cox models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate_external(
  object,
  x,
  time,
  event,
  x_new,
  time_new,
  event_new,
  pred.at,
  ngroup = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate_external_+3A_object">object</code></td>
<td>
<p>Model object fitted by <code>hdnom::fit_*()</code>.</p>
</td></tr>
<tr><td><code id="calibrate_external_+3A_x">x</code></td>
<td>
<p>Matrix of training data used for fitting the model.</p>
</td></tr>
<tr><td><code id="calibrate_external_+3A_time">time</code></td>
<td>
<p>Survival time of the training data.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="calibrate_external_+3A_event">event</code></td>
<td>
<p>Status indicator of the training data,
normally 0 = alive, 1 = dead.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="calibrate_external_+3A_x_new">x_new</code></td>
<td>
<p>Matrix of predictors for the external validation data.</p>
</td></tr>
<tr><td><code id="calibrate_external_+3A_time_new">time_new</code></td>
<td>
<p>Survival time of the external validation data.
Must be of the same length with the number of rows as <code>x_new</code>.</p>
</td></tr>
<tr><td><code id="calibrate_external_+3A_event_new">event_new</code></td>
<td>
<p>Status indicator of the external validation data,
normally 0 = alive, 1 = dead.
Must be of the same length with the number of rows as <code>x_new</code>.</p>
</td></tr>
<tr><td><code id="calibrate_external_+3A_pred.at">pred.at</code></td>
<td>
<p>Time point at which external calibration should take place.</p>
</td></tr>
<tr><td><code id="calibrate_external_+3A_ngroup">ngroup</code></td>
<td>
<p>Number of groups to be formed for external calibration.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library("survival")

# Load imputed SMART data
data(smart)
# Use the first 1000 samples as training data
# (the data used for internal validation)
x &lt;- as.matrix(smart[, -c(1, 2)])[1:1000, ]
time &lt;- smart$TEVENT[1:1000]
event &lt;- smart$EVENT[1:1000]

# Take the next 1000 samples as external calibration data
# In practice, usually use data collected in other studies
x_new &lt;- as.matrix(smart[, -c(1, 2)])[1001:2000, ]
time_new &lt;- smart$TEVENT[1001:2000]
event_new &lt;- smart$EVENT[1001:2000]

# Fit Cox model with lasso penalty
fit &lt;- fit_lasso(
  x, Surv(time, event),
  nfolds = 5, rule = "lambda.1se", seed = 11
)

# External calibration
cal.ext &lt;- calibrate_external(
  fit, x, time, event,
  x_new, time_new, event_new,
  pred.at = 365 * 5, ngroup = 5
)

print(cal.ext)
summary(cal.ext)
plot(cal.ext, xlim = c(0.6, 1), ylim = c(0.6, 1))
# # Test fused lasso, MCP, and Snet models
# data(smart)
# # Use first 500 samples as training data
# # (the data used for internal validation)
# x &lt;- as.matrix(smart[, -c(1, 2)])[1:500, ]
# time &lt;- smart$TEVENT[1:500]
# event &lt;- smart$EVENT[1:500]
#
# # Take 1000 samples as external validation data.
# # In practice, usually use data collected in other studies.
# x_new &lt;- as.matrix(smart[, -c(1, 2)])[1001:2000, ]
# time_new &lt;- smart$TEVENT[1001:2000]
# event_new &lt;- smart$EVENT[1001:2000]
#
# flassofit &lt;- fit_flasso(x, survival::Surv(time, event), nfolds = 5, seed = 11)
# scadfit &lt;- fit_mcp(x, survival::Surv(time, event), nfolds = 5, seed = 11)
# mnetfit &lt;- fit_snet(x, survival::Surv(time, event), nfolds = 5, seed = 11)
#
# cal.ext1 &lt;- calibrate_external(
#   flassofit, x, time, event,
#   x_new, time_new, event_new,
#   pred.at = 365 * 5, ngroup = 5)
#
# cal.ext2 &lt;- calibrate_external(
#   scadfit, x, time, event,
#   x_new, time_new, event_new,
#   pred.at = 365 * 5, ngroup = 5)
#
# cal.ext3 &lt;- calibrate_external(
#   mnetfit, x, time, event,
#   x_new, time_new, event_new,
#   pred.at = 365 * 5, ngroup = 5)
#
# print(cal.ext1)
# summary(cal.ext1)
# plot(cal.ext1)
#
# print(cal.ext2)
# summary(cal.ext2)
# plot(cal.ext2)
#
# print(cal.ext3)
# summary(cal.ext3)
# plot(cal.ext3)
</code></pre>

<hr>
<h2 id='calibrate_external_surv_prob_true'>Compute Kaplan-Meier estimated survival probabilities for external calibration</h2><span id='topic+calibrate_external_surv_prob_true'></span>

<h3>Description</h3>

<p>Compute Kaplan-Meier estimated survival probabilities for external calibration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate_external_surv_prob_true(
  pred_prob,
  grp,
  time_new,
  event_new,
  pred.at,
  ngroup
)
</code></pre>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='calibrate_surv_prob_true'>Compute Kaplan-Meier estimated survival probabilities for calibration</h2><span id='topic+calibrate_surv_prob_true'></span>

<h3>Description</h3>

<p>Compute Kaplan-Meier estimated survival probabilities for calibration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate_surv_prob_true(pred_prob, grp, time, event, pred.at, ngroup)
</code></pre>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='compare_by_calibrate'>Compare high-dimensional Cox models by model calibration</h2><span id='topic+compare_by_calibrate'></span>

<h3>Description</h3>

<p>Compare high-dimensional Cox models by model calibration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_by_calibrate(
  x,
  time,
  event,
  model.type = c("lasso", "alasso", "flasso", "enet", "aenet", "mcp", "mnet", "scad",
    "snet"),
  method = c("fitting", "bootstrap", "cv", "repeated.cv"),
  boot.times = NULL,
  nfolds = NULL,
  rep.times = NULL,
  pred.at,
  ngroup = 5,
  seed = 1001,
  trace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_by_calibrate_+3A_x">x</code></td>
<td>
<p>Matrix of training data used for fitting the model;
on which to run the calibration.</p>
</td></tr>
<tr><td><code id="compare_by_calibrate_+3A_time">time</code></td>
<td>
<p>Survival time.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="compare_by_calibrate_+3A_event">event</code></td>
<td>
<p>Status indicator, normally 0 = alive, 1 = dead.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="compare_by_calibrate_+3A_model.type">model.type</code></td>
<td>
<p>Model types to compare. Could be at least two of
<code>"lasso"</code>, <code>"alasso"</code>, <code>"flasso"</code>, <code>"enet"</code>,
<code>"aenet"</code>, <code>"mcp"</code>, <code>"mnet"</code>, <code>"scad"</code>,
or <code>"snet"</code>.</p>
</td></tr>
<tr><td><code id="compare_by_calibrate_+3A_method">method</code></td>
<td>
<p>Calibration method.
Could be <code>"bootstrap"</code>, <code>"cv"</code>, or <code>"repeated.cv"</code>.</p>
</td></tr>
<tr><td><code id="compare_by_calibrate_+3A_boot.times">boot.times</code></td>
<td>
<p>Number of repetitions for bootstrap.</p>
</td></tr>
<tr><td><code id="compare_by_calibrate_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds for cross-validation and
repeated cross-validation.</p>
</td></tr>
<tr><td><code id="compare_by_calibrate_+3A_rep.times">rep.times</code></td>
<td>
<p>Number of repeated times for repeated cross-validation.</p>
</td></tr>
<tr><td><code id="compare_by_calibrate_+3A_pred.at">pred.at</code></td>
<td>
<p>Time point at which calibration should take place.</p>
</td></tr>
<tr><td><code id="compare_by_calibrate_+3A_ngroup">ngroup</code></td>
<td>
<p>Number of groups to be formed for calibration.</p>
</td></tr>
<tr><td><code id="compare_by_calibrate_+3A_seed">seed</code></td>
<td>
<p>A random seed for cross-validation fold division.</p>
</td></tr>
<tr><td><code id="compare_by_calibrate_+3A_trace">trace</code></td>
<td>
<p>Logical. Output the calibration progress or not.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(smart)
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT

# Compare lasso and adaptive lasso by 5-fold cross-validation
cmp.cal.cv &lt;- compare_by_calibrate(
  x, time, event,
  model.type = c("lasso", "alasso"),
  method = "fitting",
  pred.at = 365 * 9, ngroup = 5, seed = 1001
)

print(cmp.cal.cv)
summary(cmp.cal.cv)
plot(cmp.cal.cv)
</code></pre>

<hr>
<h2 id='compare_by_validate'>Compare high-dimensional Cox models by model validation</h2><span id='topic+compare_by_validate'></span>

<h3>Description</h3>

<p>Compare high-dimensional Cox models by model validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_by_validate(
  x,
  time,
  event,
  model.type = c("lasso", "alasso", "flasso", "enet", "aenet", "mcp", "mnet", "scad",
    "snet"),
  method = c("bootstrap", "cv", "repeated.cv"),
  boot.times = NULL,
  nfolds = NULL,
  rep.times = NULL,
  tauc.type = c("CD", "SZ", "UNO"),
  tauc.time,
  seed = 1001,
  trace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_by_validate_+3A_x">x</code></td>
<td>
<p>Matrix of training data used for fitting the model;
on which to run the validation.</p>
</td></tr>
<tr><td><code id="compare_by_validate_+3A_time">time</code></td>
<td>
<p>Survival time.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="compare_by_validate_+3A_event">event</code></td>
<td>
<p>Status indicator, normally 0 = alive, 1 = dead.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="compare_by_validate_+3A_model.type">model.type</code></td>
<td>
<p>Model types to compare. Could be at least two
of <code>"lasso"</code>, <code>"alasso"</code>, <code>"flasso"</code>, <code>"enet"</code>,
<code>"aenet"</code>, <code>"mcp"</code>, <code>"mnet"</code>, <code>"scad"</code>,
or <code>"snet"</code>.</p>
</td></tr>
<tr><td><code id="compare_by_validate_+3A_method">method</code></td>
<td>
<p>Validation method.
Could be <code>"bootstrap"</code>, <code>"cv"</code>, or <code>"repeated.cv"</code>.</p>
</td></tr>
<tr><td><code id="compare_by_validate_+3A_boot.times">boot.times</code></td>
<td>
<p>Number of repetitions for bootstrap.</p>
</td></tr>
<tr><td><code id="compare_by_validate_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds for cross-validation and
repeated cross-validation.</p>
</td></tr>
<tr><td><code id="compare_by_validate_+3A_rep.times">rep.times</code></td>
<td>
<p>Number of repeated times for repeated cross-validation.</p>
</td></tr>
<tr><td><code id="compare_by_validate_+3A_tauc.type">tauc.type</code></td>
<td>
<p>Type of time-dependent AUC.
Including <code>"CD"</code> proposed by Chambless and Diao (2006).,
<code>"SZ"</code> proposed by Song and Zhou (2008).,
<code>"UNO"</code> proposed by Uno et al. (2007).</p>
</td></tr>
<tr><td><code id="compare_by_validate_+3A_tauc.time">tauc.time</code></td>
<td>
<p>Numeric vector. Time points at which to evaluate
the time-dependent AUC.</p>
</td></tr>
<tr><td><code id="compare_by_validate_+3A_seed">seed</code></td>
<td>
<p>A random seed for cross-validation fold division.</p>
</td></tr>
<tr><td><code id="compare_by_validate_+3A_trace">trace</code></td>
<td>
<p>Logical. Output the validation progress or not.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chambless, L. E. and G. Diao (2006).
Estimation of time-dependent area under the ROC curve for long-term
risk prediction.
<em>Statistics in Medicine</em> 25, 3474&ndash;3486.
</p>
<p>Song, X. and X.-H. Zhou (2008).
A semiparametric approach for the covariate specific ROC curve with
survival outcome.
<em>Statistica Sinica</em> 18, 947&ndash;965.
</p>
<p>Uno, H., T. Cai, L. Tian, and L. J. Wei (2007).
Evaluating prediction rules for t-year survivors with censored
regression models.
<em>Journal of the American Statistical Association</em> 102, 527&ndash;537.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(smart)
x &lt;- as.matrix(smart[, -c(1, 2)])[1:1000, ]
time &lt;- smart$TEVENT[1:1000]
event &lt;- smart$EVENT[1:1000]

# Compare lasso and adaptive lasso by 5-fold cross-validation
cmp.val.cv &lt;- compare_by_validate(
  x, time, event,
  model.type = c("lasso", "alasso"),
  method = "cv", nfolds = 5, tauc.type = "UNO",
  tauc.time = seq(0.25, 2, 0.25) * 365, seed = 1001
)

print(cmp.val.cv)
summary(cmp.val.cv)
plot(cmp.val.cv)
plot(cmp.val.cv, interval = TRUE)
</code></pre>

<hr>
<h2 id='fit_aenet'>Model selection for high-dimensional Cox models with adaptive elastic-net penalty</h2><span id='topic+fit_aenet'></span>

<h3>Description</h3>

<p>Automatic model selection for high-dimensional Cox models
with adaptive elastic-net penalty, evaluated by penalized partial-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_aenet(
  x,
  y,
  nfolds = 5L,
  alphas = seq(0.05, 0.95, 0.05),
  rule = c("lambda.min", "lambda.1se"),
  seed = c(1001, 1002),
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_aenet_+3A_x">x</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="fit_aenet_+3A_y">y</code></td>
<td>
<p>Response matrix made with <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_aenet_+3A_nfolds">nfolds</code></td>
<td>
<p>Fold numbers of cross-validation.</p>
</td></tr>
<tr><td><code id="fit_aenet_+3A_alphas">alphas</code></td>
<td>
<p>Alphas to tune in <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>.</p>
</td></tr>
<tr><td><code id="fit_aenet_+3A_rule">rule</code></td>
<td>
<p>Model selection criterion, <code>"lambda.min"</code> or
<code>"lambda.1se"</code>. See <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>
for details.</p>
</td></tr>
<tr><td><code id="fit_aenet_+3A_seed">seed</code></td>
<td>
<p>Two random seeds for cross-validation fold division
in two estimation steps.</p>
</td></tr>
<tr><td><code id="fit_aenet_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Enable parallel parameter tuning or not,
default is <code>FALSE</code>. To enable parallel tuning, load the
<code>doParallel</code> package and run <code>registerDoParallel()</code>
with the number of CPU cores before calling this function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

# To enable parallel parameter tuning, first run:
# library("doParallel")
# registerDoParallel(detectCores())
# then set fit_aenet(..., parallel = TRUE).

fit &lt;- fit_aenet(
  x, y,
  nfolds = 3, alphas = c(0.3, 0.7),
  rule = "lambda.1se", seed = c(5, 7)
)

nom &lt;- as_nomogram(
  fit, x, time, event,
  pred.at = 365 * 2,
  funlabel = "2-Year Overall Survival Probability"
)

plot(nom)
</code></pre>

<hr>
<h2 id='fit_alasso'>Model selection for high-dimensional Cox models with adaptive lasso penalty</h2><span id='topic+fit_alasso'></span>

<h3>Description</h3>

<p>Automatic model selection for high-dimensional Cox models
with adaptive lasso penalty, evaluated by penalized partial-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_alasso(
  x,
  y,
  nfolds = 5L,
  rule = c("lambda.min", "lambda.1se"),
  seed = c(1001, 1002)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_alasso_+3A_x">x</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="fit_alasso_+3A_y">y</code></td>
<td>
<p>Response matrix made by <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_alasso_+3A_nfolds">nfolds</code></td>
<td>
<p>Fold numbers of cross-validation.</p>
</td></tr>
<tr><td><code id="fit_alasso_+3A_rule">rule</code></td>
<td>
<p>Model selection criterion, <code>"lambda.min"</code> or
<code>"lambda.1se"</code>. See <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>
for details.</p>
</td></tr>
<tr><td><code id="fit_alasso_+3A_seed">seed</code></td>
<td>
<p>Two random seeds for cross-validation fold division
in two estimation steps.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

fit &lt;- fit_alasso(x, y, nfolds = 3, rule = "lambda.1se", seed = c(7, 11))

nom &lt;- as_nomogram(
  fit, x, time, event,
  pred.at = 365 * 2,
  funlabel = "2-Year Overall Survival Probability"
)

plot(nom)
</code></pre>

<hr>
<h2 id='fit_enet'>Model selection for high-dimensional Cox models with elastic-net penalty</h2><span id='topic+fit_enet'></span>

<h3>Description</h3>

<p>Automatic model selection for high-dimensional Cox models
with elastic-net penalty, evaluated by penalized partial-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_enet(
  x,
  y,
  nfolds = 5L,
  alphas = seq(0.05, 0.95, 0.05),
  rule = c("lambda.min", "lambda.1se"),
  seed = 1001,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_enet_+3A_x">x</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="fit_enet_+3A_y">y</code></td>
<td>
<p>Response matrix made by <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_enet_+3A_nfolds">nfolds</code></td>
<td>
<p>Fold numbers of cross-validation.</p>
</td></tr>
<tr><td><code id="fit_enet_+3A_alphas">alphas</code></td>
<td>
<p>Alphas to tune in <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>.</p>
</td></tr>
<tr><td><code id="fit_enet_+3A_rule">rule</code></td>
<td>
<p>Model selection criterion, <code>"lambda.min"</code> or
<code>"lambda.1se"</code>. See <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>
for details.</p>
</td></tr>
<tr><td><code id="fit_enet_+3A_seed">seed</code></td>
<td>
<p>A random seed for cross-validation fold division.</p>
</td></tr>
<tr><td><code id="fit_enet_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Enable parallel parameter tuning or not,
default is <code>FALSE</code>. To enable parallel tuning, load the
<code>doParallel</code> package and run <code>registerDoParallel()</code>
with the number of CPU cores before calling this function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

# To enable parallel parameter tuning, first run:
# library("doParallel")
# registerDoParallel(detectCores())
# then set fit_enet(..., parallel = TRUE).

fit &lt;- fit_enet(
  x, y,
  nfolds = 3, alphas = c(0.3, 0.7),
  rule = "lambda.1se", seed = 11
)

nom &lt;- as_nomogram(
  fit, x, time, event,
  pred.at = 365 * 2,
  funlabel = "2-Year Overall Survival Probability"
)

plot(nom)
</code></pre>

<hr>
<h2 id='fit_flasso'>Model selection for high-dimensional Cox models with fused lasso penalty</h2><span id='topic+fit_flasso'></span>

<h3>Description</h3>

<p>Automatic model selection for high-dimensional Cox models
with fused lasso penalty, evaluated by cross-validated likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_flasso(
  x,
  y,
  nfolds = 5L,
  lambda1 = c(0.001, 0.05, 0.5, 1, 5),
  lambda2 = c(0.001, 0.01, 0.5),
  maxiter = 25,
  epsilon = 0.001,
  seed = 1001,
  trace = FALSE,
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_flasso_+3A_x">x</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="fit_flasso_+3A_y">y</code></td>
<td>
<p>Response matrix made by <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_flasso_+3A_nfolds">nfolds</code></td>
<td>
<p>Fold numbers of cross-validation.</p>
</td></tr>
<tr><td><code id="fit_flasso_+3A_lambda1">lambda1</code></td>
<td>
<p>Vector of lambda1 candidates.
Default is <code>0.001, 0.05, 0.5, 1, 5</code>.</p>
</td></tr>
<tr><td><code id="fit_flasso_+3A_lambda2">lambda2</code></td>
<td>
<p>Vector of lambda2 candidates.
Default is <code>0.001, 0.01, 0.5</code>.</p>
</td></tr>
<tr><td><code id="fit_flasso_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations allowed.
Default is <code>25</code>.</p>
</td></tr>
<tr><td><code id="fit_flasso_+3A_epsilon">epsilon</code></td>
<td>
<p>The convergence criterion.
Default is <code>1e-3</code>.</p>
</td></tr>
<tr><td><code id="fit_flasso_+3A_seed">seed</code></td>
<td>
<p>A random seed for cross-validation fold division.</p>
</td></tr>
<tr><td><code id="fit_flasso_+3A_trace">trace</code></td>
<td>
<p>Output the cross-validation parameter tuning
progress or not. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_flasso_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Enable parallel parameter tuning or not,
default is <code>FALSE</code>. To enable parallel tuning, load the
<code>doParallel</code> package and run <code>registerDoParallel()</code>
with the number of CPU cores before calling this function.</p>
</td></tr>
<tr><td><code id="fit_flasso_+3A_...">...</code></td>
<td>
<p>other parameters to <code><a href="penalized.html#topic+cvl">cvl</a></code>
and <code><a href="penalized.html#topic+penalized">penalized</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The cross-validation procedure used in this function is the
<em>approximated cross-validation</em> provided by the <code>penalized</code>
package. Be careful dealing with the results since they might be more
optimistic than a traditional CV procedure. This cross-validation
method is more suitable for datasets with larger number of observations,
and a higher number of cross-validation folds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])[1:120, ]
time &lt;- smart$TEVENT[1:120]
event &lt;- smart$EVENT[1:120]
y &lt;- survival::Surv(time, event)

fit &lt;- fit_flasso(
  x, y,
  lambda1 = c(1, 10), lambda2 = c(0.01),
  nfolds = 3, seed = 11
)

nom &lt;- as_nomogram(
  fit, x, time, event,
  pred.at = 365 * 2,
  funlabel = "2-Year Overall Survival Probability"
)

plot(nom)
</code></pre>

<hr>
<h2 id='fit_lasso'>Model selection for high-dimensional Cox models with lasso penalty</h2><span id='topic+fit_lasso'></span>

<h3>Description</h3>

<p>Automatic model selection for high-dimensional Cox models
with lasso penalty, evaluated by penalized partial-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_lasso(x, y, nfolds = 5L, rule = c("lambda.min", "lambda.1se"), seed = 1001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_lasso_+3A_x">x</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="fit_lasso_+3A_y">y</code></td>
<td>
<p>Response matrix made by <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_lasso_+3A_nfolds">nfolds</code></td>
<td>
<p>Fold numbers of cross-validation.</p>
</td></tr>
<tr><td><code id="fit_lasso_+3A_rule">rule</code></td>
<td>
<p>Model selection criterion, <code>"lambda.min"</code> or
<code>"lambda.1se"</code>. See <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>
for details.</p>
</td></tr>
<tr><td><code id="fit_lasso_+3A_seed">seed</code></td>
<td>
<p>A random seed for cross-validation fold division.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

fit &lt;- fit_lasso(x, y, nfolds = 5, rule = "lambda.1se", seed = 11)

nom &lt;- as_nomogram(
  fit, x, time, event,
  pred.at = 365 * 2,
  funlabel = "2-Year Overall Survival Probability"
)

plot(nom)
</code></pre>

<hr>
<h2 id='fit_mcp'>Model selection for high-dimensional Cox models with MCP penalty</h2><span id='topic+fit_mcp'></span>

<h3>Description</h3>

<p>Automatic model selection for high-dimensional Cox models
with MCP penalty, evaluated by penalized partial-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mcp(
  x,
  y,
  nfolds = 5L,
  gammas = c(1.01, 1.7, 3, 100),
  eps = 1e-04,
  max.iter = 10000L,
  seed = 1001,
  trace = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mcp_+3A_x">x</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="fit_mcp_+3A_y">y</code></td>
<td>
<p>Response matrix made by <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_mcp_+3A_nfolds">nfolds</code></td>
<td>
<p>Fold numbers of cross-validation.</p>
</td></tr>
<tr><td><code id="fit_mcp_+3A_gammas">gammas</code></td>
<td>
<p>Gammas to tune in <code><a href="ncvreg.html#topic+cv.ncvsurv">cv.ncvsurv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_mcp_+3A_eps">eps</code></td>
<td>
<p>Convergence threshhold.</p>
</td></tr>
<tr><td><code id="fit_mcp_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="fit_mcp_+3A_seed">seed</code></td>
<td>
<p>A random seed for cross-validation fold division.</p>
</td></tr>
<tr><td><code id="fit_mcp_+3A_trace">trace</code></td>
<td>
<p>Output the cross-validation parameter tuning
progress or not. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_mcp_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Enable parallel parameter tuning or not,
default is <code>FALSE</code>. To enable parallel tuning, load the
<code>doParallel</code> package and run <code>registerDoParallel()</code>
with the number of CPU cores before calling this function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

fit &lt;- fit_mcp(x, y, nfolds = 3, gammas = c(2.1, 3), seed = 1001)

nom &lt;- as_nomogram(
  fit, x, time, event,
  pred.at = 365 * 2,
  funlabel = "2-Year Overall Survival Probability"
)

plot(nom)

</code></pre>

<hr>
<h2 id='fit_mnet'>Model selection for high-dimensional Cox models with Mnet penalty</h2><span id='topic+fit_mnet'></span>

<h3>Description</h3>

<p>Automatic model selection for high-dimensional Cox models
with Mnet penalty, evaluated by penalized partial-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mnet(
  x,
  y,
  nfolds = 5L,
  gammas = c(1.01, 1.7, 3, 100),
  alphas = seq(0.05, 0.95, 0.05),
  eps = 1e-04,
  max.iter = 10000L,
  seed = 1001,
  trace = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mnet_+3A_x">x</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="fit_mnet_+3A_y">y</code></td>
<td>
<p>Response matrix made by <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_mnet_+3A_nfolds">nfolds</code></td>
<td>
<p>Fold numbers of cross-validation.</p>
</td></tr>
<tr><td><code id="fit_mnet_+3A_gammas">gammas</code></td>
<td>
<p>Gammas to tune in <code><a href="ncvreg.html#topic+cv.ncvsurv">cv.ncvsurv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_mnet_+3A_alphas">alphas</code></td>
<td>
<p>Alphas to tune in <code><a href="ncvreg.html#topic+cv.ncvsurv">cv.ncvsurv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_mnet_+3A_eps">eps</code></td>
<td>
<p>Convergence threshhold.</p>
</td></tr>
<tr><td><code id="fit_mnet_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="fit_mnet_+3A_seed">seed</code></td>
<td>
<p>A random seed for cross-validation fold division.</p>
</td></tr>
<tr><td><code id="fit_mnet_+3A_trace">trace</code></td>
<td>
<p>Output the cross-validation parameter tuning
progress or not. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_mnet_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Enable parallel parameter tuning or not,
default is <code>FALSE</code>. To enable parallel tuning, load the
<code>doParallel</code> package and run <code>registerDoParallel()</code>
with the number of CPU cores before calling this function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

fit &lt;- fit_mnet(
  x, y,
  nfolds = 3,
  gammas = 3, alphas = c(0.3, 0.6, 0.9),
  max.iter = 15000, seed = 1010
)

nom &lt;- as_nomogram(
  fit, x, time, event,
  pred.at = 365 * 2,
  funlabel = "2-Year Overall Survival Probability"
)

plot(nom)

</code></pre>

<hr>
<h2 id='fit_scad'>Model selection for high-dimensional Cox models with SCAD penalty</h2><span id='topic+fit_scad'></span>

<h3>Description</h3>

<p>Automatic model selection for high-dimensional Cox models
with SCAD penalty, evaluated by penalized partial-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_scad(
  x,
  y,
  nfolds = 5L,
  gammas = c(2.01, 2.3, 3.7, 200),
  eps = 1e-04,
  max.iter = 10000L,
  seed = 1001,
  trace = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_scad_+3A_x">x</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="fit_scad_+3A_y">y</code></td>
<td>
<p>Response matrix made by <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_scad_+3A_nfolds">nfolds</code></td>
<td>
<p>Fold numbers of cross-validation.</p>
</td></tr>
<tr><td><code id="fit_scad_+3A_gammas">gammas</code></td>
<td>
<p>Gammas to tune in <code><a href="ncvreg.html#topic+cv.ncvsurv">cv.ncvsurv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_scad_+3A_eps">eps</code></td>
<td>
<p>Convergence threshhold.</p>
</td></tr>
<tr><td><code id="fit_scad_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="fit_scad_+3A_seed">seed</code></td>
<td>
<p>A random seed for cross-validation fold division.</p>
</td></tr>
<tr><td><code id="fit_scad_+3A_trace">trace</code></td>
<td>
<p>Output the cross-validation parameter tuning
progress or not. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_scad_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Enable parallel parameter tuning or not,
default is <code>FALSE</code>. To enable parallel tuning, load the
<code>doParallel</code> package and run <code>registerDoParallel()</code>
with the number of CPU cores before calling this function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

fit &lt;- fit_scad(
  x, y,
  nfolds = 3, gammas = c(3.7, 5),
  max.iter = 15000, seed = 1010
)

nom &lt;- as_nomogram(
  fit, x, time, event,
  pred.at = 365 * 2,
  funlabel = "2-Year Overall Survival Probability"
)

plot(nom)

</code></pre>

<hr>
<h2 id='fit_snet'>Model selection for high-dimensional Cox models with Snet penalty</h2><span id='topic+fit_snet'></span>

<h3>Description</h3>

<p>Automatic model selection for high-dimensional Cox models
with Snet penalty, evaluated by penalized partial-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_snet(
  x,
  y,
  nfolds = 5L,
  gammas = c(2.01, 2.3, 3.7, 200),
  alphas = seq(0.05, 0.95, 0.05),
  eps = 1e-04,
  max.iter = 10000L,
  seed = 1001,
  trace = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_snet_+3A_x">x</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="fit_snet_+3A_y">y</code></td>
<td>
<p>Response matrix made by <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_snet_+3A_nfolds">nfolds</code></td>
<td>
<p>Fold numbers of cross-validation.</p>
</td></tr>
<tr><td><code id="fit_snet_+3A_gammas">gammas</code></td>
<td>
<p>Gammas to tune in <code><a href="ncvreg.html#topic+cv.ncvsurv">cv.ncvsurv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_snet_+3A_alphas">alphas</code></td>
<td>
<p>Alphas to tune in <code><a href="ncvreg.html#topic+cv.ncvsurv">cv.ncvsurv</a></code>.</p>
</td></tr>
<tr><td><code id="fit_snet_+3A_eps">eps</code></td>
<td>
<p>Convergence threshhold.</p>
</td></tr>
<tr><td><code id="fit_snet_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="fit_snet_+3A_seed">seed</code></td>
<td>
<p>A random seed for cross-validation fold division.</p>
</td></tr>
<tr><td><code id="fit_snet_+3A_trace">trace</code></td>
<td>
<p>Output the cross-validation parameter tuning
progress or not. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_snet_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Enable parallel parameter tuning or not,
default is <code>FALSE</code>. To enable parallel tuning, load the
<code>doParallel</code> package and run <code>registerDoParallel()</code>
with the number of CPU cores before calling this function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

fit &lt;- fit_snet(
  x, y,
  nfolds = 3,
  gammas = 3.7, alphas = c(0.3, 0.8),
  max.iter = 15000, seed = 1010
)

nom &lt;- as_nomogram(
  fit, x, time, event,
  pred.at = 365 * 2,
  funlabel = "2-Year Overall Survival Probability"
)

plot(nom)

</code></pre>

<hr>
<h2 id='glmnet_basesurv'>Breslow baseline hazard estimator for glmnet objects</h2><span id='topic+glmnet_basesurv'></span>

<h3>Description</h3>

<p>Derived from <code>peperr:::basesurv</code> and <code>gbm::basehaz.gbm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnet_basesurv(time, event, lp, times.eval = NULL, centered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmnet_basesurv_+3A_time">time</code></td>
<td>
<p>Survival time</p>
</td></tr>
<tr><td><code id="glmnet_basesurv_+3A_event">event</code></td>
<td>
<p>Status indicator</p>
</td></tr>
<tr><td><code id="glmnet_basesurv_+3A_lp">lp</code></td>
<td>
<p>Linear predictors</p>
</td></tr>
<tr><td><code id="glmnet_basesurv_+3A_times.eval">times.eval</code></td>
<td>
<p>Survival time to evaluate</p>
</td></tr>
<tr><td><code id="glmnet_basesurv_+3A_centered">centered</code></td>
<td>
<p>Should we center the survival curve?
See <code><a href="survival.html#topic+basehaz">basehaz</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing cumulative base hazard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='glmnet_calibrate_external_surv_prob_pred'>Compute glmnet predicted survival probabilities for external calibration</h2><span id='topic+glmnet_calibrate_external_surv_prob_pred'></span>

<h3>Description</h3>

<p>Compute glmnet predicted survival probabilities for external calibration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnet_calibrate_external_surv_prob_pred(object, x_tr, x_te, y_tr, pred.at)
</code></pre>


<h3>Value</h3>

<p>list containing predicted survival probability
</p>

<hr>
<h2 id='glmnet_calibrate_surv_prob_pred'>Compute glmnet predicted survival probabilities for calibration</h2><span id='topic+glmnet_calibrate_surv_prob_pred'></span>

<h3>Description</h3>

<p>Compute glmnet predicted survival probabilities for calibration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnet_calibrate_surv_prob_pred(
  x_tr,
  x_te,
  y_tr,
  alpha,
  lambda,
  pen.factor,
  pred.at
)
</code></pre>


<h3>Value</h3>

<p>list containing predicted survival probability
</p>

<hr>
<h2 id='glmnet_survcurve'>Survival curve prediction for glmnet objects</h2><span id='topic+glmnet_survcurve'></span>

<h3>Description</h3>

<p>Derived from c060::predictProb.coxnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnet_survcurve(object, time, event, x, survtime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmnet_survcurve_+3A_object">object</code></td>
<td>
<p><code>glmnet</code> model object</p>
</td></tr>
<tr><td><code id="glmnet_survcurve_+3A_time">time</code></td>
<td>
<p>Survival time</p>
</td></tr>
<tr><td><code id="glmnet_survcurve_+3A_event">event</code></td>
<td>
<p>Status indicator</p>
</td></tr>
<tr><td><code id="glmnet_survcurve_+3A_x">x</code></td>
<td>
<p>Predictor matrix</p>
</td></tr>
<tr><td><code id="glmnet_survcurve_+3A_survtime">survtime</code></td>
<td>
<p>Survival time to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing predicted survival probabilities and
linear predictors for all samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='glmnet_tune_alpha'>Automatic alpha tuning function by k-fold cross-validation</h2><span id='topic+glmnet_tune_alpha'></span>

<h3>Description</h3>

<p>Automatic alpha tuning function by k-fold cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnet_tune_alpha(..., alphas, seed, parallel)
</code></pre>


<h3>Value</h3>

<p>best model object and best alpha
</p>

<hr>
<h2 id='glmnet_validate_external_tauc'>Compute external validation measures for glmnet objects</h2><span id='topic+glmnet_validate_external_tauc'></span>

<h3>Description</h3>

<p>Compute external validation measures for glmnet objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnet_validate_external_tauc(
  object,
  x_tr,
  x_te,
  y_tr,
  y_te,
  tauc.type,
  tauc.time
)
</code></pre>


<h3>Value</h3>

<p>time-dependent AUC (tAUC) value
</p>

<hr>
<h2 id='glmnet_validate_tauc'>Compute validation measures for glmnet objects</h2><span id='topic+glmnet_validate_tauc'></span>

<h3>Description</h3>

<p>Compute validation measures for glmnet objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnet_validate_tauc(
  x_tr,
  x_te,
  y_tr,
  y_te,
  alpha,
  lambda,
  pen.factor,
  tauc.type,
  tauc.time
)
</code></pre>


<h3>Value</h3>

<p>time-dependent AUC (tAUC) value
</p>

<hr>
<h2 id='hdnom-package'>hdnom: Benchmarking and Visualization Toolkit for Penalized Cox Models</h2><span id='topic+hdnom'></span><span id='topic+hdnom-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Creates nomogram visualizations for penalized Cox regression models, with the support of reproducible survival model building, validation, calibration, and comparison for high-dimensional data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nan Xiao <a href="mailto:me@nanx.me">me@nanx.me</a> (<a href="https://orcid.org/0000-0002-0250-5673">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Qing-Song Xu <a href="mailto:qsxu@csu.edu.cn">qsxu@csu.edu.cn</a>
</p>
</li>
<li><p> Miao-Zhu Li <a href="mailto:miaozhu.li@duke.edu">miaozhu.li@duke.edu</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Frank Harrell <a href="mailto:f.harrell@vanderbilt.edu">f.harrell@vanderbilt.edu</a> (rms author) [contributor]
</p>
</li>
<li><p> Sergej Potapov (survAUC author) [contributor]
</p>
</li>
<li><p> Werner Adler (survAUC author) [contributor]
</p>
</li>
<li><p> Matthias Schmid (survAUC author) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://nanx.me/hdnom/">https://nanx.me/hdnom/</a>
</p>
</li>
<li> <p><a href="https://github.com/nanxstats/hdnom">https://github.com/nanxstats/hdnom</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/nanxstats/hdnom/issues">https://github.com/nanxstats/hdnom/issues</a>
</p>
</li></ul>


<hr>
<h2 id='infer_variable_type'>Extract information of selected variables from high-dimensional Cox models</h2><span id='topic+infer_variable_type'></span>

<h3>Description</h3>

<p>Extract the names and type of selected variables from fitted
high-dimensional Cox models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_variable_type(object, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_variable_type_+3A_object">object</code></td>
<td>
<p>Model object.</p>
</td></tr>
<tr><td><code id="infer_variable_type_+3A_x">x</code></td>
<td>
<p>Data matrix used to fit the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the index, name, type and range of the
selected variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

fit &lt;- fit_lasso(x, y, nfolds = 5, rule = "lambda.1se", seed = 11)
infer_variable_type(fit, x)
</code></pre>

<hr>
<h2 id='kmplot'>Kaplan-Meier plot with number at risk table for internal calibration and
external calibration results</h2><span id='topic+kmplot'></span>

<h3>Description</h3>

<p>Kaplan-Meier plot with number at risk table for internal calibration and
external calibration results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmplot(
  object,
  group.name = NULL,
  time.at = NULL,
  col.pal = c("JCO", "Lancet", "NPG", "AAAS")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmplot_+3A_object">object</code></td>
<td>
<p>An object returned by <code><a href="#topic+calibrate">calibrate</a></code> or
<code><a href="#topic+calibrate_external">calibrate_external</a></code>.</p>
</td></tr>
<tr><td><code id="kmplot_+3A_group.name">group.name</code></td>
<td>
<p>Risk group labels. Default is
Group 1, Group 2, ..., Group k.</p>
</td></tr>
<tr><td><code id="kmplot_+3A_time.at">time.at</code></td>
<td>
<p>Time points to evaluate the number at risk.</p>
</td></tr>
<tr><td><code id="kmplot_+3A_col.pal">col.pal</code></td>
<td>
<p>Color palette to use. Possible values are
<code>"JCO"</code>, <code>"Lancet"</code>, <code>"NPG"</code>, and <code>"AAAS"</code>.
Default is <code>"JCO"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("smart")
# Use the first 1000 samples as training data
# (the data used for internal validation)
x &lt;- as.matrix(smart[, -c(1, 2)])[1:1000, ]
time &lt;- smart$TEVENT[1:1000]
event &lt;- smart$EVENT[1:1000]

# Take the next 1000 samples as external calibration data
# In practice, usually use data collected in other studies
x_new &lt;- as.matrix(smart[, -c(1, 2)])[1001:2000, ]
time_new &lt;- smart$TEVENT[1001:2000]
event_new &lt;- smart$EVENT[1001:2000]

# Fit Cox model with lasso penalty
fit &lt;- fit_lasso(x, survival::Surv(time, event), nfolds = 5, rule = "lambda.1se", seed = 11)

# Internal calibration
cal.int &lt;- calibrate(
  x, time, event,
  model.type = "lasso",
  alpha = 1, lambda = fit$lambda,
  method = "cv", nfolds = 5,
  pred.at = 365 * 9, ngroup = 3
)

kmplot(
  cal.int,
  group.name = c("High risk", "Medium risk", "Low risk"),
  time.at = 1:6 * 365
)

# External calibration
cal.ext &lt;- calibrate_external(
  fit, x, time, event,
  x_new, time_new, event_new,
  pred.at = 365 * 5, ngroup = 3
)

kmplot(
  cal.ext,
  group.name = c("High risk", "Medium risk", "Low risk"),
  time.at = 1:6 * 365
)
</code></pre>

<hr>
<h2 id='kmplot_raw'>Kaplan-Meier Plot with Number at Risk Table</h2><span id='topic+kmplot_raw'></span>

<h3>Description</h3>

<p>Kaplan-Meier Plot with Number at Risk Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmplot_raw(
  fit,
  group.name = NULL,
  time.at = NULL,
  surv.df = NULL,
  col.pal = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmplot_raw_+3A_fit">fit</code></td>
<td>
<p>a <code><a href="survival.html#topic+survfit">survfit</a></code> object</p>
</td></tr>
<tr><td><code id="kmplot_raw_+3A_group.name">group.name</code></td>
<td>
<p>Group labels. Default is Group 1, Group 2, ... Group k.</p>
</td></tr>
<tr><td><code id="kmplot_raw_+3A_time.at">time.at</code></td>
<td>
<p>Time points to evaluate the number at risk.</p>
</td></tr>
<tr><td><code id="kmplot_raw_+3A_surv.df">surv.df</code></td>
<td>
<p>Data frame containing survival time, event and risk group
for log-rank test.</p>
</td></tr>
<tr><td><code id="kmplot_raw_+3A_col.pal">col.pal</code></td>
<td>
<p>color palette to use</p>
</td></tr>
</table>

<hr>
<h2 id='logrank_test'>Log-rank test for internal calibration and external calibration results</h2><span id='topic+logrank_test'></span>

<h3>Description</h3>

<p>Log-rank test for internal calibration and external calibration results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logrank_test(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logrank_test_+3A_object">object</code></td>
<td>
<p>An object returned by <code><a href="#topic+calibrate">calibrate</a></code> or
<code><a href="#topic+calibrate_external">calibrate_external</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("smart")
# Use the first 1000 samples as training data
# (the data used for internal validation)
x &lt;- as.matrix(smart[, -c(1, 2)])[1:1000, ]
time &lt;- smart$TEVENT[1:1000]
event &lt;- smart$EVENT[1:1000]

# Take the next 1000 samples as external calibration data
# In practice, usually use data collected in other studies
x_new &lt;- as.matrix(smart[, -c(1, 2)])[1001:2000, ]
time_new &lt;- smart$TEVENT[1001:2000]
event_new &lt;- smart$EVENT[1001:2000]

# Fit Cox model with lasso penalty
fit &lt;- fit_lasso(
  x, survival::Surv(time, event),
  nfolds = 5, rule = "lambda.1se", seed = 11
)

# Internal calibration
cal.int &lt;- calibrate(
  x, time, event,
  model.type = "lasso",
  alpha = 1, lambda = fit$lambda,
  method = "cv", nfolds = 5,
  pred.at = 365 * 9, ngroup = 3
)

logrank_test(cal.int)

# External calibration
cal.ext &lt;- calibrate_external(
  fit, x, time, event,
  x_new, time_new, event_new,
  pred.at = 365 * 5, ngroup = 3
)

logrank_test(cal.ext)
</code></pre>

<hr>
<h2 id='ncvreg_basesurv'>Breslow baseline hazard estimator for ncvreg objects</h2><span id='topic+ncvreg_basesurv'></span>

<h3>Description</h3>

<p>Derived from <code>peperr:::basesurv</code> and <code>gbm::basehaz.gbm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncvreg_basesurv(time, event, lp, times.eval = NULL, centered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncvreg_basesurv_+3A_time">time</code></td>
<td>
<p>Survival time</p>
</td></tr>
<tr><td><code id="ncvreg_basesurv_+3A_event">event</code></td>
<td>
<p>Status indicator</p>
</td></tr>
<tr><td><code id="ncvreg_basesurv_+3A_lp">lp</code></td>
<td>
<p>Linear predictors</p>
</td></tr>
<tr><td><code id="ncvreg_basesurv_+3A_times.eval">times.eval</code></td>
<td>
<p>Survival time to evaluate</p>
</td></tr>
<tr><td><code id="ncvreg_basesurv_+3A_centered">centered</code></td>
<td>
<p>Should we center the survival curve?
See <code><a href="survival.html#topic+basehaz">basehaz</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing cumulative base hazard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='ncvreg_calibrate_external_surv_prob_pred'>Compute ncvreg predicted survival probabilities for external calibration</h2><span id='topic+ncvreg_calibrate_external_surv_prob_pred'></span>

<h3>Description</h3>

<p>Compute ncvreg predicted survival probabilities for external calibration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncvreg_calibrate_external_surv_prob_pred(object, x_tr, x_te, y_tr, pred.at)
</code></pre>


<h3>Value</h3>

<p>list containing predicted survival probability
</p>

<hr>
<h2 id='ncvreg_calibrate_surv_prob_pred'>Compute ncvreg predicted survival probabilities for calibration</h2><span id='topic+ncvreg_calibrate_surv_prob_pred'></span>

<h3>Description</h3>

<p>Compute ncvreg predicted survival probabilities for calibration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncvreg_calibrate_surv_prob_pred(
  x_tr,
  x_te,
  y_tr,
  model.type,
  alpha,
  lambda,
  gamma,
  pred.at
)
</code></pre>


<h3>Value</h3>

<p>list containing predicted survival probability
</p>

<hr>
<h2 id='ncvreg_survcurve'>Survival curve prediction for ncvreg objects</h2><span id='topic+ncvreg_survcurve'></span>

<h3>Description</h3>

<p>Derived from c060::predictProb.coxnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncvreg_survcurve(object, time, event, x, survtime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncvreg_survcurve_+3A_object">object</code></td>
<td>
<p><code>ncvreg</code> model object</p>
</td></tr>
<tr><td><code id="ncvreg_survcurve_+3A_time">time</code></td>
<td>
<p>Survival time</p>
</td></tr>
<tr><td><code id="ncvreg_survcurve_+3A_event">event</code></td>
<td>
<p>Status indicator</p>
</td></tr>
<tr><td><code id="ncvreg_survcurve_+3A_x">x</code></td>
<td>
<p>Predictor matrix</p>
</td></tr>
<tr><td><code id="ncvreg_survcurve_+3A_survtime">survtime</code></td>
<td>
<p>Survival time to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing predicted survival probabilities and
linear predictors for all samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='ncvreg_tune_gamma'>Automatic MCP/SCAD gamma tuning function by k-fold cross-validation</h2><span id='topic+ncvreg_tune_gamma'></span>

<h3>Description</h3>

<p>Automatic MCP/SCAD gamma tuning function by k-fold cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncvreg_tune_gamma(..., gammas, eps, max.iter, seed, parallel)
</code></pre>


<h3>Value</h3>

<p>best model object and best gamma
</p>

<hr>
<h2 id='ncvreg_tune_gamma_alpha'>Automatic Mnet/Snet gamma and alpha tuning function by k-fold cross-validation</h2><span id='topic+ncvreg_tune_gamma_alpha'></span>

<h3>Description</h3>

<p>Automatic Mnet/Snet gamma and alpha tuning function by k-fold cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncvreg_tune_gamma_alpha(..., gammas, alphas, eps, max.iter, seed, parallel)
</code></pre>


<h3>Value</h3>

<p>best model object, best gamma, and best alpha
</p>

<hr>
<h2 id='ncvreg_validate_external_tauc'>Compute external validation measures for ncvreg model objects</h2><span id='topic+ncvreg_validate_external_tauc'></span>

<h3>Description</h3>

<p>Compute external validation measures for ncvreg model objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncvreg_validate_external_tauc(
  object,
  x_tr,
  x_te,
  y_tr,
  y_te,
  tauc.type,
  tauc.time
)
</code></pre>


<h3>Value</h3>

<p>time-dependent AUC (tAUC) value
</p>

<hr>
<h2 id='ncvreg_validate_tauc'>Compute validation measures for ncvreg model objects</h2><span id='topic+ncvreg_validate_tauc'></span>

<h3>Description</h3>

<p>Compute validation measures for ncvreg model objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncvreg_validate_tauc(
  x_tr,
  x_te,
  y_tr,
  y_te,
  model.type,
  gamma,
  alpha,
  lambda,
  tauc.type,
  tauc.time
)
</code></pre>


<h3>Value</h3>

<p>time-dependent AUC (tAUC) value
</p>

<hr>
<h2 id='palette_aaas'>Color Palette for AAAS Journals</h2><span id='topic+palette_aaas'></span>

<h3>Description</h3>

<p>A 10-color discrete color palette based on the colors
used in figures in AAAS journals such as <em>Science</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette_aaas()
</code></pre>

<hr>
<h2 id='palette_jco'>Color Palette for Journal of Clinical Oncology (JCO)</h2><span id='topic+palette_jco'></span>

<h3>Description</h3>

<p>A 10-color discrete color palette based on the colors
used in figures in <em>Journal of Clinical Oncology</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette_jco()
</code></pre>

<hr>
<h2 id='palette_lancet'>Color Palette for Lancet Journals</h2><span id='topic+palette_lancet'></span>

<h3>Description</h3>

<p>A 9-color discrete color palette based on the colors
used in figures in <em>Lancet Oncology</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette_lancet()
</code></pre>

<hr>
<h2 id='palette_npg'>Color Palette for NPG Journals</h2><span id='topic+palette_npg'></span>

<h3>Description</h3>

<p>A 10-color discrete color palette based on the colors
used in figures in NPG journals such as <em>Nature Reviews Cancer</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette_npg()
</code></pre>

<hr>
<h2 id='penalized_basesurv'>Breslow baseline hazard estimator for penfit objects</h2><span id='topic+penalized_basesurv'></span>

<h3>Description</h3>

<p>Derived from <code>peperr:::basesurv</code> and <code>gbm::basehaz.gbm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalized_basesurv(time, event, lp, times.eval = NULL, centered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalized_basesurv_+3A_time">time</code></td>
<td>
<p>Survival time</p>
</td></tr>
<tr><td><code id="penalized_basesurv_+3A_event">event</code></td>
<td>
<p>Status indicator</p>
</td></tr>
<tr><td><code id="penalized_basesurv_+3A_lp">lp</code></td>
<td>
<p>Linear predictors</p>
</td></tr>
<tr><td><code id="penalized_basesurv_+3A_times.eval">times.eval</code></td>
<td>
<p>Survival time to evaluate</p>
</td></tr>
<tr><td><code id="penalized_basesurv_+3A_centered">centered</code></td>
<td>
<p>Should we center the survival curve?
See <code><a href="survival.html#topic+basehaz">basehaz</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing cumulative base hazard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='penalized_calibrate_external_surv_prob_pred'>Compute penfit predicted survival probabilities for external calibration</h2><span id='topic+penalized_calibrate_external_surv_prob_pred'></span>

<h3>Description</h3>

<p>Compute penfit predicted survival probabilities for external calibration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalized_calibrate_external_surv_prob_pred(object, x_tr, x_te, y_tr, pred.at)
</code></pre>


<h3>Value</h3>

<p>list containing predicted survival probability
</p>

<hr>
<h2 id='penalized_calibrate_surv_prob_pred'>Compute penfit predicted survival probabilities for calibration</h2><span id='topic+penalized_calibrate_surv_prob_pred'></span>

<h3>Description</h3>

<p>Compute penfit predicted survival probabilities for calibration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalized_calibrate_surv_prob_pred(x_tr, x_te, y_tr, lambda1, lambda2, pred.at)
</code></pre>


<h3>Value</h3>

<p>list containing predicted survival probability
</p>

<hr>
<h2 id='penalized_survcurve'>Survival curve prediction for penfit objects</h2><span id='topic+penalized_survcurve'></span>

<h3>Description</h3>

<p>Derived from c060::predictProb.coxnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalized_survcurve(object, time, event, x, survtime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalized_survcurve_+3A_object">object</code></td>
<td>
<p><code>penalized</code> model object</p>
</td></tr>
<tr><td><code id="penalized_survcurve_+3A_time">time</code></td>
<td>
<p>Survival time</p>
</td></tr>
<tr><td><code id="penalized_survcurve_+3A_event">event</code></td>
<td>
<p>Status indicator</p>
</td></tr>
<tr><td><code id="penalized_survcurve_+3A_x">x</code></td>
<td>
<p>Predictor matrix</p>
</td></tr>
<tr><td><code id="penalized_survcurve_+3A_survtime">survtime</code></td>
<td>
<p>Survival time to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing predicted survival probabilities and
linear predictors for all samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='penalized_tune_lambda'>Automatic lambda tuning function for fused lasso by k-fold cross-validation</h2><span id='topic+penalized_tune_lambda'></span>

<h3>Description</h3>

<p>Automatic lambda tuning function for fused lasso by k-fold cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalized_tune_lambda(..., lambda1, lambda2, seed, trace, parallel)
</code></pre>


<h3>Value</h3>

<p>best model object, best lambda1, and best lambda2
</p>

<hr>
<h2 id='penalized_validate_external_tauc'>Compute external validation measures for penfit model objects</h2><span id='topic+penalized_validate_external_tauc'></span>

<h3>Description</h3>

<p>Compute external validation measures for penfit model objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalized_validate_external_tauc(
  object,
  x_tr,
  x_te,
  y_tr,
  y_te,
  tauc.type,
  tauc.time
)
</code></pre>


<h3>Value</h3>

<p>time-dependent AUC (tAUC) value
</p>

<hr>
<h2 id='penalized_validate_tauc'>Compute validation measures for penfit model objects</h2><span id='topic+penalized_validate_tauc'></span>

<h3>Description</h3>

<p>Compute validation measures for penfit model objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalized_validate_tauc(
  x_tr,
  x_te,
  y_tr,
  y_te,
  lambda1,
  lambda2,
  tauc.type,
  tauc.time
)
</code></pre>


<h3>Value</h3>

<p>time-dependent AUC (tAUC) value
</p>

<hr>
<h2 id='plot.hdnom.calibrate'>Plot calibration results</h2><span id='topic+plot.hdnom.calibrate'></span>

<h3>Description</h3>

<p>Plot calibration results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.calibrate'
plot(
  x,
  xlim = c(0, 1),
  ylim = c(0, 1),
  col.pal = c("JCO", "Lancet", "NPG", "AAAS"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hdnom.calibrate_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+calibrate">calibrate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.calibrate_+3A_xlim">xlim</code></td>
<td>
<p>x axis limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.hdnom.calibrate_+3A_ylim">ylim</code></td>
<td>
<p>y axis limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.hdnom.calibrate_+3A_col.pal">col.pal</code></td>
<td>
<p>Color palette to use. Possible values are
<code>"JCO"</code>, <code>"Lancet"</code>, <code>"NPG"</code>, and <code>"AAAS"</code>.
Default is <code>"JCO"</code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.calibrate_+3A_...">...</code></td>
<td>
<p>Other parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='plot.hdnom.calibrate.external'>Plot external calibration results</h2><span id='topic+plot.hdnom.calibrate.external'></span>

<h3>Description</h3>

<p>Plot external calibration results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.calibrate.external'
plot(
  x,
  xlim = c(0, 1),
  ylim = c(0, 1),
  col.pal = c("JCO", "Lancet", "NPG", "AAAS"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hdnom.calibrate.external_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+calibrate_external">calibrate_external</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.calibrate.external_+3A_xlim">xlim</code></td>
<td>
<p>x axis limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.hdnom.calibrate.external_+3A_ylim">ylim</code></td>
<td>
<p>y axis limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.hdnom.calibrate.external_+3A_col.pal">col.pal</code></td>
<td>
<p>Color palette to use. Possible values are
<code>"JCO"</code>, <code>"Lancet"</code>, <code>"NPG"</code>, and <code>"AAAS"</code>.
Default is <code>"JCO"</code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.calibrate.external_+3A_...">...</code></td>
<td>
<p>Other parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='plot.hdnom.compare.calibrate'>Plot model comparison by calibration results</h2><span id='topic+plot.hdnom.compare.calibrate'></span>

<h3>Description</h3>

<p>Plot model comparison by calibration results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.compare.calibrate'
plot(
  x,
  xlim = c(0, 1),
  ylim = c(0, 1),
  col.pal = c("JCO", "Lancet", "NPG", "AAAS"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hdnom.compare.calibrate_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+compare_by_calibrate">compare_by_calibrate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.compare.calibrate_+3A_xlim">xlim</code></td>
<td>
<p>x axis limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.hdnom.compare.calibrate_+3A_ylim">ylim</code></td>
<td>
<p>y axis limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.hdnom.compare.calibrate_+3A_col.pal">col.pal</code></td>
<td>
<p>Color palette to use. Possible values are
<code>"JCO"</code>, <code>"Lancet"</code>, <code>"NPG"</code>, and <code>"AAAS"</code>.
Default is <code>"JCO"</code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.compare.calibrate_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='plot.hdnom.compare.validate'>Plot model comparison by validation results</h2><span id='topic+plot.hdnom.compare.validate'></span>

<h3>Description</h3>

<p>Plot model comparison by validation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.compare.validate'
plot(
  x,
  interval = FALSE,
  col.pal = c("JCO", "Lancet", "NPG", "AAAS"),
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hdnom.compare.validate_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+compare_by_validate">compare_by_validate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.compare.validate_+3A_interval">interval</code></td>
<td>
<p>Show maximum, minimum, 0.25, and 0.75 quantiles of
time-dependent AUC as ribbons? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.compare.validate_+3A_col.pal">col.pal</code></td>
<td>
<p>Color palette to use. Possible values are
<code>"JCO"</code>, <code>"Lancet"</code>, <code>"NPG"</code>, and <code>"AAAS"</code>.
Default is <code>"JCO"</code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.compare.validate_+3A_ylim">ylim</code></td>
<td>
<p>Range of y coordinates. For example, <code>c(0.5, 1)</code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.compare.validate_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='plot.hdnom.nomogram'>Plot nomogram objects</h2><span id='topic+plot.hdnom.nomogram'></span>

<h3>Description</h3>

<p>Plot nomogram objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.nomogram'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hdnom.nomogram_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+as_nomogram">as_nomogram</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.nomogram_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='plot.hdnom.validate'>Plot optimism-corrected time-dependent discrimination curves for validation</h2><span id='topic+plot.hdnom.validate'></span>

<h3>Description</h3>

<p>Plot optimism-corrected time-dependent discrimination curves for validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.validate'
plot(x, col.pal = c("JCO", "Lancet", "NPG", "AAAS"), ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hdnom.validate_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+validate">validate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.validate_+3A_col.pal">col.pal</code></td>
<td>
<p>Color palette to use. Possible values are
<code>"JCO"</code>, <code>"Lancet"</code>, <code>"NPG"</code>, and <code>"AAAS"</code>.
Default is <code>"JCO"</code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.validate_+3A_ylim">ylim</code></td>
<td>
<p>Range of y coordinates. For example, <code>c(0.5, 1)</code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.validate_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='plot.hdnom.validate.external'>Plot time-dependent discrimination curves for external validation</h2><span id='topic+plot.hdnom.validate.external'></span>

<h3>Description</h3>

<p>Plot time-dependent discrimination curves for external validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.validate.external'
plot(x, col.pal = c("JCO", "Lancet", "NPG", "AAAS"), ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hdnom.validate.external_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+validate_external">validate_external</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.validate.external_+3A_col.pal">col.pal</code></td>
<td>
<p>Color palette to use. Possible values are
<code>"JCO"</code>, <code>"Lancet"</code>, <code>"NPG"</code>, and <code>"AAAS"</code>.
Default is <code>"JCO"</code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.validate.external_+3A_ylim">ylim</code></td>
<td>
<p>Range of y coordinates. For example, <code>c(0.5, 1)</code>.</p>
</td></tr>
<tr><td><code id="plot.hdnom.validate.external_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='predict.hdnom.model'>Make predictions from high-dimensional Cox models</h2><span id='topic+predict.hdnom.model'></span>

<h3>Description</h3>

<p>Predict overall survival probability at certain time points
from fitted Cox models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.model'
predict(object, x, y, newx, pred.at, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hdnom.model_+3A_object">object</code></td>
<td>
<p>Model object.</p>
</td></tr>
<tr><td><code id="predict.hdnom.model_+3A_x">x</code></td>
<td>
<p>Data matrix used to fit the model.</p>
</td></tr>
<tr><td><code id="predict.hdnom.model_+3A_y">y</code></td>
<td>
<p>Response matrix made with <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="predict.hdnom.model_+3A_newx">newx</code></td>
<td>
<p>Matrix (with named columns) of new values for <code>x</code>
at which predictions are to be made.</p>
</td></tr>
<tr><td><code id="predict.hdnom.model_+3A_pred.at">pred.at</code></td>
<td>
<p>Time point at which prediction should take place.</p>
</td></tr>
<tr><td><code id="predict.hdnom.model_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>nrow(newx) x length(pred.at)</code> matrix containing
overall survival probablity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

fit &lt;- fit_lasso(x, y, nfolds = 5, rule = "lambda.1se", seed = 11)
predict(fit, x, y, newx = x[101:105, ], pred.at = 1:10 * 365)
</code></pre>

<hr>
<h2 id='print.hdnom.calibrate'>Print calibration results</h2><span id='topic+print.hdnom.calibrate'></span>

<h3>Description</h3>

<p>Print calibration results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.calibrate'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hdnom.calibrate_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+calibrate">calibrate</a></code>.</p>
</td></tr>
<tr><td><code id="print.hdnom.calibrate_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='print.hdnom.calibrate.external'>Print external calibration results</h2><span id='topic+print.hdnom.calibrate.external'></span>

<h3>Description</h3>

<p>Print external calibration results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.calibrate.external'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hdnom.calibrate.external_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+calibrate_external">calibrate_external</a></code>.</p>
</td></tr>
<tr><td><code id="print.hdnom.calibrate.external_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='print.hdnom.compare.calibrate'>Print model comparison by calibration results</h2><span id='topic+print.hdnom.compare.calibrate'></span>

<h3>Description</h3>

<p>Print model comparison by calibration results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.compare.calibrate'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hdnom.compare.calibrate_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+compare_by_calibrate">compare_by_calibrate</a></code>.</p>
</td></tr>
<tr><td><code id="print.hdnom.compare.calibrate_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='print.hdnom.compare.validate'>Print model comparison by validation results</h2><span id='topic+print.hdnom.compare.validate'></span>

<h3>Description</h3>

<p>Print model comparison by validation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.compare.validate'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hdnom.compare.validate_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+compare_by_validate">compare_by_validate</a></code>.</p>
</td></tr>
<tr><td><code id="print.hdnom.compare.validate_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='print.hdnom.model'>Print high-dimensional Cox model objects</h2><span id='topic+print.hdnom.model'></span>

<h3>Description</h3>

<p>Print high-dimensional Cox model objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.model'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hdnom.model_+3A_x">x</code></td>
<td>
<p>Model object.</p>
</td></tr>
<tr><td><code id="print.hdnom.model_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

fit &lt;- fit_lasso(x, y, nfolds = 5, rule = "lambda.1se", seed = 11)
print(fit)
</code></pre>

<hr>
<h2 id='print.hdnom.nomogram'>Print nomograms objects</h2><span id='topic+print.hdnom.nomogram'></span>

<h3>Description</h3>

<p>Print nomograms objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.nomogram'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hdnom.nomogram_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+as_nomogram">as_nomogram</a></code>.</p>
</td></tr>
<tr><td><code id="print.hdnom.nomogram_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='print.hdnom.validate'>Print validation results</h2><span id='topic+print.hdnom.validate'></span>

<h3>Description</h3>

<p>Print validation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.validate'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hdnom.validate_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+validate">validate</a></code>.</p>
</td></tr>
<tr><td><code id="print.hdnom.validate_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='print.hdnom.validate.external'>Print external validation results</h2><span id='topic+print.hdnom.validate.external'></span>

<h3>Description</h3>

<p>Print external validation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.validate.external'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hdnom.validate.external_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+validate_external">validate_external</a></code>.</p>
</td></tr>
<tr><td><code id="print.hdnom.validate.external_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='smart'>Imputed SMART study data</h2><span id='topic+smart'></span>

<h3>Description</h3>

<p>Imputed SMART study data (no missing values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(smart)
</code></pre>


<h3>Format</h3>

<p>A numeric matrix with 3873 samples, and 29 variables
(27 variables + time variable + event variable):
</p>

<ul>
<li><p> Demographics
</p>

<ul>
<li><p> SEX - gender
</p>
</li>
<li><p> AGE - age in years
</p>
</li></ul>

</li>
<li><p> Classical risk factors
</p>

<ul>
<li><p> SMOKING - smoking (never, former, current)
</p>
</li>
<li><p> PACKYRS - in years
</p>
</li>
<li><p> ALCOHOL - alcohol use (never, former, current)
</p>
</li>
<li><p> BMI - Body mass index, in kg/m^2
</p>
</li>
<li><p> DIABETES
</p>
</li></ul>

</li>
<li><p> Blood pressure
</p>

<ul>
<li><p> SYSTH - Systolic, by hand, in mm Hg
</p>
</li>
<li><p> SYSTBP - Systolic, automatic, in mm Hg
</p>
</li>
<li><p> DIASTH - Diastolic, by hand, in mm Hg
</p>
</li>
<li><p> DIASTBP - Diastolic, automatic, in mm Hg
</p>
</li></ul>

</li>
<li><p> Lipid levels
</p>

<ul>
<li><p> CHOL - Total cholesterol, in mmol/L
</p>
</li>
<li><p> HDL - High-density lipoprotein cholesterol, in mmol/L
</p>
</li>
<li><p> LDL - Low-density lipoprotein cholesterol, in mmol/L
</p>
</li>
<li><p> TRIG - Triglycerides, in mmol/L
</p>
</li></ul>

</li>
<li><p> Previous symptomatic atherosclerosis
</p>

<ul>
<li><p> CEREBRAL - Cerebral
</p>
</li>
<li><p> CARDIAC - Coronary
</p>
</li>
<li><p> PERIPH - Peripheral
</p>
</li>
<li><p> AAA - Abdominal aortic aneurysm
</p>
</li></ul>

</li>
<li><p> Markers of atherosclerosis
</p>

<ul>
<li><p> HOMOC - Homocysteine, in <code class="reqn">\mu</code>mol/L
</p>
</li>
<li><p> GLUT - Glutamine, in <code class="reqn">\mu</code>mol/L
</p>
</li>
<li><p> CREAT - Creatinine clearance, in mL/min
</p>
</li>
<li><p> ALBUMIN - Albumin (no, micro, macro)
</p>
</li>
<li><p> IMT - Intima media thickness, in mm
</p>
</li>
<li><p> STENOSIS - Carotid artery stenosis &gt; 50%
</p>
</li></ul>

</li></ul>



<h3>Note</h3>

<p>See <code>data-raw/smart.R</code> for the code to generate this data.
</p>


<h3>References</h3>

<p>Steyerberg, E. W. (2008). Clinical prediction models:
a practical approach to development, validation, and updating.
Springer Science &amp; Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(smart)
dim(smart)
</code></pre>

<hr>
<h2 id='smarto'>Original SMART study data</h2><span id='topic+smarto'></span>

<h3>Description</h3>

<p>Original SMART study data (with missing values) from Steyerberg et, al. 2008.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(smarto)
</code></pre>


<h3>Format</h3>

<p>A numeric matrix with 3873 samples, and 29 variables
(27 variables + time variable + event variable):
</p>

<ul>
<li><p> Demographics
</p>

<ul>
<li><p> SEX - gender
</p>
</li>
<li><p> AGE - age in years
</p>
</li></ul>

</li>
<li><p> Classical risk factors
</p>

<ul>
<li><p> SMOKING - smoking (never, former, current)
</p>
</li>
<li><p> PACKYRS - in years
</p>
</li>
<li><p> ALCOHOL - alcohol use (never, former, current)
</p>
</li>
<li><p> BMI - Body mass index, in kg/m^2
</p>
</li>
<li><p> DIABETES
</p>
</li></ul>

</li>
<li><p> Blood pressure
</p>

<ul>
<li><p> SYSTH - Systolic, by hand, in mm Hg
</p>
</li>
<li><p> SYSTBP - Systolic, automatic, in mm Hg
</p>
</li>
<li><p> DIASTH - Diastolic, by hand, in mm Hg
</p>
</li>
<li><p> DIASTBP - Diastolic, automatic, in mm Hg
</p>
</li></ul>

</li>
<li><p> Lipid levels
</p>

<ul>
<li><p> CHOL - Total cholesterol, in mmol/L
</p>
</li>
<li><p> HDL - High-density lipoprotein cholesterol, in mmol/L
</p>
</li>
<li><p> LDL - Low-density lipoprotein cholesterol, in mmol/L
</p>
</li>
<li><p> TRIG - Triglycerides, in mmol/L
</p>
</li></ul>

</li>
<li><p> Previous symptomatic atherosclerosis
</p>

<ul>
<li><p> CEREBRAL - Cerebral
</p>
</li>
<li><p> CARDIAC - Coronary
</p>
</li>
<li><p> PERIPH - Peripheral
</p>
</li>
<li><p> AAA - Abdominal aortic aneurysm
</p>
</li></ul>

</li>
<li><p> Markers of atherosclerosis
</p>

<ul>
<li><p> HOMOC - Homocysteine, in <code class="reqn">\mu</code>mol/L
</p>
</li>
<li><p> GLUT - Glutamine, in <code class="reqn">\mu</code>mol/L
</p>
</li>
<li><p> CREAT - Creatinine clearance, in mL/min
</p>
</li>
<li><p> ALBUMIN - Albumin (no, micro, macro)
</p>
</li>
<li><p> IMT - Intima media thickness, in mm
</p>
</li>
<li><p> STENOSIS - Carotid artery stenosis &gt; 50%
</p>
</li></ul>

</li></ul>



<h3>References</h3>

<p>Steyerberg, E. W. (2008). Clinical prediction models:
a practical approach to development, validation, and updating.
Springer Science &amp; Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(smarto)
dim(smarto)
</code></pre>

<hr>
<h2 id='summary.hdnom.calibrate'>Summary of calibration results</h2><span id='topic+summary.hdnom.calibrate'></span>

<h3>Description</h3>

<p>Summary of calibration results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.calibrate'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.hdnom.calibrate_+3A_object">object</code></td>
<td>
<p>An object returned by <code><a href="#topic+calibrate">calibrate</a></code>.</p>
</td></tr>
<tr><td><code id="summary.hdnom.calibrate_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='summary.hdnom.calibrate.external'>Summary of external calibration results</h2><span id='topic+summary.hdnom.calibrate.external'></span>

<h3>Description</h3>

<p>Summary of external calibration results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.calibrate.external'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.hdnom.calibrate.external_+3A_object">object</code></td>
<td>
<p>An object returned by <code><a href="#topic+calibrate_external">calibrate_external</a></code>.</p>
</td></tr>
<tr><td><code id="summary.hdnom.calibrate.external_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='summary.hdnom.compare.calibrate'>Summary of model comparison by calibration results</h2><span id='topic+summary.hdnom.compare.calibrate'></span>

<h3>Description</h3>

<p>Summary of model comparison by calibration results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.compare.calibrate'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.hdnom.compare.calibrate_+3A_object">object</code></td>
<td>
<p>An object returned by <code><a href="#topic+compare_by_calibrate">compare_by_calibrate</a></code>.</p>
</td></tr>
<tr><td><code id="summary.hdnom.compare.calibrate_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='summary.hdnom.compare.validate'>Summary of model comparison by validation results</h2><span id='topic+summary.hdnom.compare.validate'></span>

<h3>Description</h3>

<p>Summary of model comparison by validation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.compare.validate'
summary(object, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.hdnom.compare.validate_+3A_object">object</code></td>
<td>
<p>An object <code><a href="#topic+compare_by_validate">compare_by_validate</a></code>.</p>
</td></tr>
<tr><td><code id="summary.hdnom.compare.validate_+3A_silent">silent</code></td>
<td>
<p>Print summary table header or not,
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.hdnom.compare.validate_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='summary.hdnom.validate'>Summary of validation results</h2><span id='topic+summary.hdnom.validate'></span>

<h3>Description</h3>

<p>Summary of validation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.validate'
summary(object, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.hdnom.validate_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+validate">validate</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.hdnom.validate_+3A_silent">silent</code></td>
<td>
<p>Print summary table header or not,
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.hdnom.validate_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='summary.hdnom.validate.external'>Summary of external validation results</h2><span id='topic+summary.hdnom.validate.external'></span>

<h3>Description</h3>

<p>Summary of external validation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdnom.validate.external'
summary(object, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.hdnom.validate.external_+3A_object">object</code></td>
<td>
<p>An object returned by <code><a href="#topic+validate_external">validate_external</a></code>.</p>
</td></tr>
<tr><td><code id="summary.hdnom.validate.external_+3A_silent">silent</code></td>
<td>
<p>Print summary table header or not,
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.hdnom.validate.external_+3A_...">...</code></td>
<td>
<p>Other parameters (not used).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>NULL
</code></pre>

<hr>
<h2 id='theme_hdnom'>Plot theme (ggplot2) for hdnom</h2><span id='topic+theme_hdnom'></span>

<h3>Description</h3>

<p>Plot theme (ggplot2) for hdnom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_hdnom(base_size = 14)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_hdnom_+3A_base_size">base_size</code></td>
<td>
<p>base font size</p>
</td></tr>
</table>

<hr>
<h2 id='validate'>Validate high-dimensional Cox models with time-dependent AUC</h2><span id='topic+validate'></span>

<h3>Description</h3>

<p>Validate high-dimensional Cox models with time-dependent AUC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate(
  x,
  time,
  event,
  model.type = c("lasso", "alasso", "flasso", "enet", "aenet", "mcp", "mnet", "scad",
    "snet"),
  alpha,
  lambda,
  pen.factor = NULL,
  gamma,
  lambda1,
  lambda2,
  method = c("bootstrap", "cv", "repeated.cv"),
  boot.times = NULL,
  nfolds = NULL,
  rep.times = NULL,
  tauc.type = c("CD", "SZ", "UNO"),
  tauc.time,
  seed = 1001,
  trace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_+3A_x">x</code></td>
<td>
<p>Matrix of training data used for fitting the model;
on which to run the validation.</p>
</td></tr>
<tr><td><code id="validate_+3A_time">time</code></td>
<td>
<p>Survival time.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_event">event</code></td>
<td>
<p>Status indicator, normally 0 = alive, 1 = dead.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_model.type">model.type</code></td>
<td>
<p>Model type to validate. Could be one of <code>"lasso"</code>,
<code>"alasso"</code>, <code>"flasso"</code>, <code>"enet"</code>, <code>"aenet"</code>,
<code>"mcp"</code>, <code>"mnet"</code>, <code>"scad"</code>, or <code>"snet"</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_alpha">alpha</code></td>
<td>
<p>Value of the elastic-net mixing parameter alpha for
<code>enet</code>, <code>aenet</code>, <code>mnet</code>, and <code>snet</code> models.
For <code>lasso</code>, <code>alasso</code>, <code>mcp</code>, and <code>scad</code> models,
please set <code>alpha = 1</code>.
<code>alpha=1</code>: lasso (l1) penalty; <code>alpha=0</code>: ridge (l2) penalty.
Note that for <code>mnet</code> and <code>snet</code> models,
<code>alpha</code> can be set to very close to 0 but not 0 exactly.</p>
</td></tr>
<tr><td><code id="validate_+3A_lambda">lambda</code></td>
<td>
<p>Value of the penalty parameter lambda to use in the
model fits on the resampled data. From the fitted Cox model.</p>
</td></tr>
<tr><td><code id="validate_+3A_pen.factor">pen.factor</code></td>
<td>
<p>Penalty factors to apply to each coefficient.
From the fitted <em>adaptive lasso</em> or <em>adaptive elastic-net</em> model.</p>
</td></tr>
<tr><td><code id="validate_+3A_gamma">gamma</code></td>
<td>
<p>Value of the model parameter gamma for
MCP/SCAD/Mnet/Snet models.</p>
</td></tr>
<tr><td><code id="validate_+3A_lambda1">lambda1</code></td>
<td>
<p>Value of the penalty parameter lambda1 for fused lasso model.</p>
</td></tr>
<tr><td><code id="validate_+3A_lambda2">lambda2</code></td>
<td>
<p>Value of the penalty parameter lambda2 for fused lasso model.</p>
</td></tr>
<tr><td><code id="validate_+3A_method">method</code></td>
<td>
<p>Validation method.
Could be <code>"bootstrap"</code>, <code>"cv"</code>, or <code>"repeated.cv"</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_boot.times">boot.times</code></td>
<td>
<p>Number of repetitions for bootstrap.</p>
</td></tr>
<tr><td><code id="validate_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds for cross-validation and
repeated cross-validation.</p>
</td></tr>
<tr><td><code id="validate_+3A_rep.times">rep.times</code></td>
<td>
<p>Number of repeated times for repeated cross-validation.</p>
</td></tr>
<tr><td><code id="validate_+3A_tauc.type">tauc.type</code></td>
<td>
<p>Type of time-dependent AUC.
Including <code>"CD"</code> proposed by Chambless and Diao (2006).,
<code>"SZ"</code> proposed by Song and Zhou (2008).,
<code>"UNO"</code> proposed by Uno et al. (2007).</p>
</td></tr>
<tr><td><code id="validate_+3A_tauc.time">tauc.time</code></td>
<td>
<p>Numeric vector. Time points at which to evaluate
the time-dependent AUC.</p>
</td></tr>
<tr><td><code id="validate_+3A_seed">seed</code></td>
<td>
<p>A random seed for resampling.</p>
</td></tr>
<tr><td><code id="validate_+3A_trace">trace</code></td>
<td>
<p>Logical. Output the validation progress or not.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chambless, L. E. and G. Diao (2006).
Estimation of time-dependent area under the ROC curve for long-term
risk prediction.
<em>Statistics in Medicine</em> 25, 3474&ndash;3486.
</p>
<p>Song, X. and X.-H. Zhou (2008).
A semiparametric approach for the covariate specific ROC curve with
survival outcome.
<em>Statistica Sinica</em> 18, 947&ndash;965.
</p>
<p>Uno, H., T. Cai, L. Tian, and L. J. Wei (2007).
Evaluating prediction rules for t-year survivors with censored
regression models.
<em>Journal of the American Statistical Association</em> 102, 527&ndash;537.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(smart)
x &lt;- as.matrix(smart[, -c(1, 2)])[1:500, ]
time &lt;- smart$TEVENT[1:500]
event &lt;- smart$EVENT[1:500]
y &lt;- survival::Surv(time, event)

fit &lt;- fit_lasso(x, y, nfolds = 5, rule = "lambda.1se", seed = 11)

# Model validation by bootstrap with time-dependent AUC
# Normally boot.times should be set to 200 or more,
# we set it to 3 here only to save example running time.
val.boot &lt;- validate(
  x, time, event,
  model.type = "lasso",
  alpha = 1, lambda = fit$lambda,
  method = "bootstrap", boot.times = 3,
  tauc.type = "UNO", tauc.time = seq(0.25, 2, 0.25) * 365,
  seed = 1010
)

# Model validation by 5-fold cross-validation with time-dependent AUC
val.cv &lt;- validate(
  x, time, event,
  model.type = "lasso",
  alpha = 1, lambda = fit$lambda,
  method = "cv", nfolds = 5,
  tauc.type = "UNO", tauc.time = seq(0.25, 2, 0.25) * 365,
  seed = 1010
)

# Model validation by repeated cross-validation with time-dependent AUC
val.repcv &lt;- validate(
  x, time, event,
  model.type = "lasso",
  alpha = 1, lambda = fit$lambda,
  method = "repeated.cv", nfolds = 5, rep.times = 3,
  tauc.type = "UNO", tauc.time = seq(0.25, 2, 0.25) * 365,
  seed = 1010
)

# bootstrap-based discrimination curves has a very narrow band
print(val.boot)
summary(val.boot)
plot(val.boot)

# k-fold cv provides a more strict evaluation than bootstrap
print(val.cv)
summary(val.cv)
plot(val.cv)

# repeated cv provides similar results as k-fold cv
# but more robust than k-fold cv
print(val.repcv)
summary(val.repcv)
plot(val.repcv)
# # Test fused lasso, SCAD, and Mnet models
#
# data(smart)
# x = as.matrix(smart[, -c(1, 2)])[1:500,]
# time = smart$TEVENT[1:500]
# event = smart$EVENT[1:500]
# y = survival::Surv(time, event)
#
# set.seed(1010)
# val.boot = validate(
#   x, time, event, model.type = "flasso",
#   lambda1 = 5, lambda2 = 2,
#   method = "bootstrap", boot.times = 10,
#   tauc.type = "UNO", tauc.time = seq(0.25, 2, 0.25) * 365,
#   seed = 1010)
#
# val.cv = validate(
#   x, time, event, model.type = "scad",
#   gamma = 3.7, alpha = 1, lambda = 0.05,
#   method = "cv", nfolds = 5,
#   tauc.type = "UNO", tauc.time = seq(0.25, 2, 0.25) * 365,
#   seed = 1010)
#
# val.repcv = validate(
#   x, time, event, model.type = "mnet",
#   gamma = 3, alpha = 0.3, lambda = 0.05,
#   method = "repeated.cv", nfolds = 5, rep.times = 3,
#   tauc.type = "UNO", tauc.time = seq(0.25, 2, 0.25) * 365,
#   seed = 1010)
#
# print(val.boot)
# summary(val.boot)
# plot(val.boot)
#
# print(val.cv)
# summary(val.cv)
# plot(val.cv)
#
# print(val.repcv)
# summary(val.repcv)
# plot(val.repcv)
</code></pre>

<hr>
<h2 id='validate_external'>Externally validate high-dimensional Cox models with time-dependent AUC</h2><span id='topic+validate_external'></span>

<h3>Description</h3>

<p>Externally validate high-dimensional Cox models with time-dependent AUC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_external(
  object,
  x,
  time,
  event,
  x_new,
  time_new,
  event_new,
  tauc.type = c("CD", "SZ", "UNO"),
  tauc.time
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_external_+3A_object">object</code></td>
<td>
<p>Model object fitted by <code>hdnom::fit_*()</code>.</p>
</td></tr>
<tr><td><code id="validate_external_+3A_x">x</code></td>
<td>
<p>Matrix of training data used for fitting the model.</p>
</td></tr>
<tr><td><code id="validate_external_+3A_time">time</code></td>
<td>
<p>Survival time of the training data.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="validate_external_+3A_event">event</code></td>
<td>
<p>Status indicator of the training data,
normally 0 = alive, 1 = dead.
Must be of the same length with the number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="validate_external_+3A_x_new">x_new</code></td>
<td>
<p>Matrix of predictors for the external validation data.</p>
</td></tr>
<tr><td><code id="validate_external_+3A_time_new">time_new</code></td>
<td>
<p>Survival time of the external validation data.
Must be of the same length with the number of rows as <code>x_new</code>.</p>
</td></tr>
<tr><td><code id="validate_external_+3A_event_new">event_new</code></td>
<td>
<p>Status indicator of the external validation data,
normally 0 = alive, 1 = dead.
Must be of the same length with the number of rows as <code>x_new</code>.</p>
</td></tr>
<tr><td><code id="validate_external_+3A_tauc.type">tauc.type</code></td>
<td>
<p>Type of time-dependent AUC.
Including <code>"CD"</code> proposed by Chambless and Diao (2006).,
<code>"SZ"</code> proposed by Song and Zhou (2008).,
<code>"UNO"</code> proposed by Uno et al. (2007).</p>
</td></tr>
<tr><td><code id="validate_external_+3A_tauc.time">tauc.time</code></td>
<td>
<p>Numeric vector. Time points at which to evaluate
the time-dependent AUC.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chambless, L. E. and G. Diao (2006).
Estimation of time-dependent area under the ROC curve for long-term
risk prediction.
<em>Statistics in Medicine</em> 25, 3474&ndash;3486.
</p>
<p>Song, X. and X.-H. Zhou (2008).
A semiparametric approach for the covariate specific ROC curve with
survival outcome.
<em>Statistica Sinica</em> 18, 947&ndash;965.
</p>
<p>Uno, H., T. Cai, L. Tian, and L. J. Wei (2007).
Evaluating prediction rules for t-year survivors with censored
regression models.
<em>Journal of the American Statistical Association</em> 102, 527&ndash;537.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(smart)
# Use the first 1000 samples as training data
# (the data used for internal validation)
x &lt;- as.matrix(smart[, -c(1, 2)])[1:1000, ]
time &lt;- smart$TEVENT[1:1000]
event &lt;- smart$EVENT[1:1000]

# Take the next 1000 samples as external validation data
# In practice, usually use data collected in other studies
x_new &lt;- as.matrix(smart[, -c(1, 2)])[1001:2000, ]
time_new &lt;- smart$TEVENT[1001:2000]
event_new &lt;- smart$EVENT[1001:2000]

# Fit Cox model with lasso penalty
fit &lt;- fit_lasso(
  x, survival::Surv(time, event),
  nfolds = 5, rule = "lambda.1se", seed = 11
)

# External validation with time-dependent AUC
val.ext &lt;- validate_external(
  fit, x, time, event,
  x_new, time_new, event_new,
  tauc.type = "UNO",
  tauc.time = seq(0.25, 2, 0.25) * 365
)

print(val.ext)
summary(val.ext)
plot(val.ext)

# # Test fused lasso, MCP, and Snet models
# data(smart)
# # Use first 600 samples as training data
# # (the data used for internal validation)
# x &lt;- as.matrix(smart[, -c(1, 2)])[1:600, ]
# time &lt;- smart$TEVENT[1:600]
# event &lt;- smart$EVENT[1:600]
#
# # Take 500 samples as external validation data.
# # In practice, usually use data collected in other studies.
# x_new &lt;- as.matrix(smart[, -c(1, 2)])[1001:1500, ]
# time_new &lt;- smart$TEVENT[1001:1500]
# event_new &lt;- smart$EVENT[1001:1500]
#
# flassofit &lt;- fit_flasso(x, survival::Surv(time, event), nfolds = 5, seed = 11)
# scadfit &lt;- fit_mcp(x, survival::Surv(time, event), nfolds = 5, seed = 11)
# mnetfit &lt;- fit_snet(x, survival::Surv(time, event), nfolds = 5, seed = 11)
#
# val.ext1 &lt;- validate_external(
#   flassofit, x, time, event,
#   x_new, time_new, event_new,
#   tauc.type = "UNO",
#   tauc.time = seq(0.25, 2, 0.25) * 365)
#
# val.ext2 &lt;- validate_external(
#   scadfit, x, time, event,
#   x_new, time_new, event_new,
#   tauc.type = "CD",
#   tauc.time = seq(0.25, 2, 0.25) * 365)
#
# val.ext3 &lt;- validate_external(
#   mnetfit, x, time, event,
#   x_new, time_new, event_new,
#   tauc.type = "SZ",
#   tauc.time = seq(0.25, 2, 0.25) * 365)
#
# print(val.ext1)
# summary(val.ext1)
# plot(val.ext1)
#
# print(val.ext2)
# summary(val.ext2)
# plot(val.ext2)
#
# print(val.ext3)
# summary(val.ext3)
# plot(val.ext3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
