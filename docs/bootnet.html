<!DOCTYPE html><html><head><title>Help for package bootnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bootnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootnet-package'>
<p>Bootstrap Methods for Various Network Estimation Routines</p></a></li>
<li><a href='#binarize'>
<p>Binarizes a dataset</p></a></li>
<li><a href='#bootInclude'>
<p>Inclusion proportion graph</p></a></li>
<li><a href='#bootnet'>
<p>Bootstrapped network estimation</p></a></li>
<li><a href='#bootThreshold'>
<p>Threshold network based on bootstrapped intervals</p></a></li>
<li><a href='#corStability'>
<p>Correlation stability coefficient</p></a></li>
<li><a href='#differenceTest'>
<p>Bootstrapped difference test</p></a></li>
<li><a href='#estimateNetwork'>
<p>Estimate a network structure</p></a></li>
<li><a href='#genGGM'>
<p>Generates a GGM small-world network.</p></a></li>
<li><a href='#ggmGenerator'>
<p>Generates a function that simulates data from the Gaussian graphical model (GGM)</p></a></li>
<li><a href='#IsingGenerator'>
<p>Generates a function that simulates data from the Ising model</p></a></li>
<li><a href='#multiverse'>
<p>Multiverse plot of bootnet results</p></a></li>
<li><a href='#netSimulator'>
<p>Network Estimation Performance</p></a></li>
<li><a href='#netSimulator and replicationSimulator methods'>
<p>netSimulator S3 methods</p></a></li>
<li><a href='#null'>
<p>Returns NULL</p></a></li>
<li><a href='#plot.bootnet'>
<p>Plots bootnet results</p></a></li>
<li><a href='#plot.bootnetResult'>
<p>Plot method for bootnetResult objects</p></a></li>
<li><a href='#print.bootnet'>
<p>Print method for bootnet and bootnetResult objects</p></a></li>
<li><a href='#summary.bootnet'>
<p>Summarize bootnet results</p></a></li>
<li><a href='#transformation'>
<p>Data transformation functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bootstrap Methods for Various Network Estimation Routines</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2, R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, igraph, IsingFit (&ge; 0.4), qgraph, dplyr (&ge;
0.3.0.2), tidyr, gtools, corpcor, IsingSampler (&ge; 0.2.3),
mvtnorm, abind, Matrix, snow, mgm (&ge; 1.2), NetworkToolbox (&ge;
1.1.0), pbapply, networktools, rlang, tibble, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>glasso, GGMncv, BDgraph, graphicalVAR, relaimpo, lavaan,
psychTools, huge</td>
</tr>
<tr>
<td>Description:</td>
<td>Bootstrap methods to assess accuracy and stability of estimated network structures
              and centrality indices &lt;<a href="https://doi.org/10.3758%2Fs13428-017-0862-1">doi:10.3758/s13428-017-0862-1</a>&gt;. Allows for flexible 
              specification of any undirected network estimation procedure in R, and offers 
              default sets for various estimation routines.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SachaEpskamp/bootnet/issues">https://github.com/SachaEpskamp/bootnet/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SachaEpskamp/bootnet">https://github.com/SachaEpskamp/bootnet</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-21 04:00:15 UTC; sachaepskamp</td>
</tr>
<tr>
<td>Author:</td>
<td>Sacha Epskamp [aut, cre],
  Eiko I. Fried [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-21 08:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootnet-package'>
Bootstrap Methods for Various Network Estimation Routines
</h2><span id='topic+bootnet-package'></span>

<h3>Description</h3>

<p>Bootstrap standard errors on various network estimation routines, such as EBICglasso from the qgraph package and IsingFit from the IsingFit package. See <code><a href="#topic+bootnet">bootnet</a></code>
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp
</p>
<p>Maintainer: Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootnet">bootnet</a></code>
</p>

<hr>
<h2 id='binarize'>
Binarizes a dataset
</h2><span id='topic+binarize'></span>

<h3>Description</h3>

<p>This function will transform data into binary data (0,1). If the data is already binary, this function does nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarize(x, split = "median", na.rm = TRUE, removeNArows = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binarize_+3A_x">x</code></td>
<td>

<p>A data frame or matrix
</p>
</td></tr>
<tr><td><code id="binarize_+3A_split">split</code></td>
<td>

<p>Either a function to split on (as character or as function) or a vector. e.g., <code>split = "mean"</code> will split every variable on the mean of that variable, <code>split=2</code> will make every value above 2 a 1 and every value below 2 a 0 and a vector of the same length as each variable in the dataset will use those elements to split.
</p>
</td></tr>
<tr><td><code id="binarize_+3A_na.rm">na.rm</code></td>
<td>

<p>The <code>na.rm</code> argument used in the split function.
</p>
</td></tr>
<tr><td><code id="binarize_+3A_removenarows">removeNArows</code></td>
<td>

<p>Logical, should rows with <code>NA</code> be removed?
</p>
</td></tr>
<tr><td><code id="binarize_+3A_verbose">verbose</code></td>
<td>
<p>Output progress to the console?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binarized data frame
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='bootInclude'>
Inclusion proportion graph
</h2><span id='topic+bootInclude'></span>

<h3>Description</h3>

<p>This function takes bootstrap results and returns a inclusion probability network (edge weights indicate how often a certain edge was included in the model). Note that the plotting method automatically uses a black-white color scheme (as edges are not signed and always positive).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootInclude(bootobject, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootInclude_+3A_bootobject">bootobject</code></td>
<td>

<p>Nonparametric bootstrap results from <code><a href="#topic+bootnet">bootnet</a></code>
</p>
</td></tr>
<tr><td><code id="bootInclude_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should progress be reported to the console?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bootnetResult</code> object with the following elements:
</p>
<table>
<tr><td><code>graph</code></td>
<td>
<p>The weights matrix of the network</p>
</td></tr>
<tr><td><code>intercepts</code></td>
<td>
<p>The intercepts</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>The results of the estimation procedure</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A vector with node labels</p>
</td></tr>
<tr><td><code>nNodes</code></td>
<td>
<p>Number of nodes in the network</p>
</td></tr>
<tr><td><code>nPerson</code></td>
<td>
<p>Number of persons in the network</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>Input used, including the result of the default set used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootnet">bootnet</a></code>, <code><a href="#topic+estimateNetwork">estimateNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# BFI Extraversion data from psychTools package:
library("psychTools")
data(bfi)
# Subset of data:
bfiSub &lt;- bfi[1:250,1:25]

# Estimate ggmModSelect networks (not stepwise to increase speed):
Network &lt;- estimateNetwork(bfiSub], default = "ggmModSelect", corMethod = "cor",
              stepwise = FALSE)

# Bootstrap 100 values, using 8 cores (100 to incease speed, preferably 1000+):
boots &lt;- bootnet(Network, nBoots = 100, nCores = 8)

# Threshold network:
Network_inclusion &lt;- bootInclude(boots)

# Plot:
plot(Network_inclusion)

## End(Not run)
</code></pre>

<hr>
<h2 id='bootnet'>
Bootstrapped network estimation
</h2><span id='topic+bootnet'></span>

<h3>Description</h3>

<p>This function can be used to bootstrap network estimation methods so that the spread of parameter and centrality estimates can be assessed. Most important methods are <code>type = 'nonparametric'</code> for the non-parametric bootstrap and <code>type = 'case'</code> for the case-dropping bootstrap. See also Epskamp, Borsboom and Fried (2016) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootnet(data, nBoots = 1000, default = c("none", "EBICglasso",
                 "ggmModSelect", "pcor", "IsingFit", "IsingSampler",
                 "huge", "adalasso", "mgm", "relimp", "cor", "TMFG",
                 "ggmModSelect", "LoGo", "SVAR_lavaan", "GGMncv"), type
                 = c("nonparametric", "parametric", "node", "person",
                 "jackknife", "case"), nCores = 1, statistics =
                 c("edge", "strength", "outStrength", "inStrength"),
                 model = c("detect", "GGM", "Ising", "graphicalVAR"),
                 fun, verbose = TRUE, labels, alpha = 1, caseMin =
                 0.05, caseMax = 0.75, caseN = 10, subNodes, subCases,
                 computeCentrality = TRUE, propBoot = 1, replacement =
                 TRUE, graph, sampleSize, intercepts, weighted, signed,
                 directed, includeDiagonal = FALSE, communities,
                 useCommunities, bridgeArgs = list(), library =
                 .libPaths(), memorysaver = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootnet_+3A_data">data</code></td>
<td>

<p>A data frame or matrix containing the raw data. Must be numeric, integer or ordered factors.
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_nboots">nBoots</code></td>
<td>

<p>Number of bootstraps
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_default">default</code></td>
<td>

<p>A string indicating the method to use. See documentation at <code><a href="#topic+estimateNetwork">estimateNetwork</a></code>.
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_type">type</code></td>
<td>

<p>The kind of bootstrap method to use.
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_ncores">nCores</code></td>
<td>

<p>Number of cores to use in computing results. Set to 1 to not use parallel computing.
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_statistics">statistics</code></td>
<td>

<p>Vector indicating which statistics to store. Options are:
</p>

<dl>
<dt><code>"edge"</code></dt><dd><p>Edge-weight</p>
</dd>
<dt><code>"strength"</code></dt><dd><p>Degree or node-strength</p>
</dd>
<dt><code>"outStrength"</code></dt><dd><p>Out-degree or Out-strength</p>
</dd>
<dt><code>"inStrength"</code></dt><dd><p>In-degree or In-strength</p>
</dd>
<dt><code>"expectedInfluence"</code></dt><dd><p>Expected Influence</p>
</dd>
<dt><code>"outExpectedInfluence"</code></dt><dd><p>Outgoing expected influence</p>
</dd>
<dt><code>"inExpectedInfluence"</code></dt><dd><p>Incoming expected influence</p>
</dd>
<dt><code>"bridgeInDegree"</code></dt><dd><p>Bridge in-degree (see <code><a href="networktools.html#topic+bridge">bridge</a></code>)</p>
</dd>
<dt><code>"bridgeOutnDegree"</code></dt><dd><p>Bridge out-degree (see <code><a href="networktools.html#topic+bridge">bridge</a></code>)</p>
</dd>
<dt><code>"bridgeStrength"</code></dt><dd><p>Bridge-strength (see <code><a href="networktools.html#topic+bridge">bridge</a></code>)</p>
</dd>
<dt><code>"bridgeCloseness"</code></dt><dd><p>Bridge-closeness (see <code><a href="networktools.html#topic+bridge">bridge</a></code>)</p>
</dd>
<dt><code>"bridgeBetweenness"</code></dt><dd><p>Bridge-betweenness (see <code><a href="networktools.html#topic+bridge">bridge</a></code>)</p>
</dd>
<dt><code>"rspbc"</code></dt><dd><p>Randomized shortest paths betweenness centrality (see <code><a href="NetworkToolbox.html#topic+rspbc">rspbc</a></code>)</p>
</dd>
<dt><code>"hybrid"</code></dt><dd><p>Hybrid centrality (see <code><a href="NetworkToolbox.html#topic+hybrid">hybrid</a></code>)</p>
</dd>
<dt><code>"eigenvector"</code></dt><dd><p>Eigenvector centrality (see <code><a href="NetworkToolbox.html#topic+eigenvector">eigenvector</a></code>)</p>
</dd>
</dl>

<p>Can contain <code>"edge"</code>, <code>"strength"</code>, <code>"closeness"</code>, <code>"betweenness"</code>, <code>"length"</code>, <code>"distance"</code>, <code>"expectedInfluence"</code>, <code>"inExpectedInfluence"</code>, <code>"outExpectedInfluence"</code>. By default, length and distance are not stored.
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_model">model</code></td>
<td>

<p>The modeling framework to use. Automatically detects if data is binary or not.
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_fun">fun</code></td>
<td>

<p>A custom estimation function, when no default set is used. This must be a function that takes the data as input (first argument) and returns either a weights matrix or a list containing the elements <code>"graph"</code> for the weights matrix, <code>"intercepts"</code> for the intercepts (optional) and <code>"results"</code> for the full estimation results (optional).
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_verbose">verbose</code></td>
<td>

<p>Logical. Should progress of the function be printed to the console?
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_labels">labels</code></td>
<td>

<p>A character vector containing the node labels. If omitted the column names of the data are used.
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_alpha">alpha</code></td>
<td>

<p>The centrality tuning parameter as used in <code><a href="qgraph.html#topic+centrality">centrality</a></code>.
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_subnodes">subNodes</code></td>
<td>

<p>Range of nodes to sample in node-drop bootstrap
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_casemin">caseMin</code></td>
<td>
<p>Minimum proportion of cases to drop when <code>type = "case"</code>.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_casemax">caseMax</code></td>
<td>
<p>Maximum proportion of cases to drop when <code>type = "case"</code>.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_casen">caseN</code></td>
<td>
<p>Number of sampling levels to test when <code>type = "case"</code>.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_subcases">subCases</code></td>
<td>

<p>Range of persons to sample in person-drop bootstrap
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_computecentrality">computeCentrality</code></td>
<td>

<p>Logical, should centrality be computed?  
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_propboot">propBoot</code></td>
<td>

<p>Proportion of persons to sample in bootstraps. Set to lower than 1 for m out of n bootstrap
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_replacement">replacement</code></td>
<td>

<p>Logical, should replacement be used in bootstrap sampling?
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_graph">graph</code></td>
<td>
<p>A given network structure to use in parametric bootstrap.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_samplesize">sampleSize</code></td>
<td>
<p>The samplesize to use in parametric bootstrap.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_intercepts">intercepts</code></td>
<td>
<p>Intercepts to use in parametric bootstrap.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_weighted">weighted</code></td>
<td>
<p>Logical, should the analyzed network be weighted?</p>
</td></tr>
<tr><td><code id="bootnet_+3A_signed">signed</code></td>
<td>
<p>Logical, should the analyzed network be signed?</p>
</td></tr>
<tr><td><code id="bootnet_+3A_directed">directed</code></td>
<td>
<p>Logical, is the analyzed network directed? Usually does not have to be set and is detected automatically.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_includediagonal">includeDiagonal</code></td>
<td>
<p>Logical, should diagonal elements (self-loops) be included in the bootstrap? Only used when <code>directed = TRUE</code>.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_communities">communities</code></td>
<td>

<p>Used for bridge centrality measures (see <code><a href="networktools.html#topic+bridge">bridge</a></code>).
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_usecommunities">useCommunities</code></td>
<td>

<p>Used for bridge centrality measures (see <code><a href="networktools.html#topic+bridge">bridge</a></code>).
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_library">library</code></td>
<td>

<p>Library location to be used in parallel computing.
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_memorysaver">memorysaver</code></td>
<td>

<p>Logical. If TRUE (recommended) then raw bootstrapped data and results are not stored in the output object. This saves a lot of memory. Set this only to TRUE if you need the raw results or bootstrap data.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_bridgeargs">bridgeArgs</code></td>
<td>

<p>List of arguments used in the 'bridge' function for computing bridge centrality
</p>
</td></tr>
<tr><td><code id="bootnet_+3A_...">...</code></td>
<td>

<p>Additional arguments used in the estimator function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bootnet</code> object with the following elements:
</p>
<table>
<tr><td><code>sampleTable</code></td>
<td>
<p> A data frame containing all estimated values on the real sample. </p>
</td></tr>
<tr><td><code>bootTable</code></td>
<td>
<p> A data frame containing all estimated values on all bootstrapped samples. </p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p> A <code>bootnetResult</code> object with plot and print method containing the estimated network of the real sample.  </p>
</td></tr>
<tr><td><code>boots</code></td>
<td>
<p>A list of <code>bootnetResult</code> objects containing the raw bootstrap results.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>References</h3>

<p>Epskamp, S., Borsboom, D., &amp; Fried, E. I. (2018). Estimating psychological networks and their accuracy: A tutorial paper. Behavior Research Methods, 50(1), 195-212.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateNetwork">estimateNetwork</a></code>, <code><a href="#topic+differenceTest">differenceTest</a></code>, <code><a href="#topic+corStability">corStability</a></code>, <code><a href="#topic+plot.bootnet">plot.bootnet</a></code>, <code><a href="#topic+summary.bootnet">summary.bootnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># BFI Extraversion data from psychTools package:
library("psychTools")
data(bfi)
bfiSub &lt;- bfi[,1:25]

# Estimate network:
Network &lt;- estimateNetwork(bfiSub, default = "EBICglasso")

# Centrality indices:
library("qgraph")
centralityPlot(Network)


# Estimated network:
plot(Network, layout = 'spring') 

### Non-parametric bootstrap ###
# Bootstrap 1000 values, using 8 cores:
Results1 &lt;- bootnet(Network, nBoots = 1000, nCores = 8)

# Plot bootstrapped edge CIs:
plot(Results1, labels = FALSE, order = "sample")

# Plot significant differences (alpha = 0.05) of edges:
plot(Results1, "edge", plot = "difference",onlyNonZero = TRUE,
     order = "sample") 

# Plot significant differences (alpha = 0.05) of node strength:
plot(Results1, "strength", plot = "difference")

# Test for difference in strength between node "A1" and "C2":
differenceTest(Results1,  "A1", "C2", "strength")

### Case-drop bootstrap ###
# Bootstrap 1000 values, using 8 cores:
Results2 &lt;- bootnet(Network, nBoots = 1000, nCores = 8, 
              type = "case")

# Plot centrality stability:
plot(Results2)

# Compute CS-coefficients:
corStability(Results2)

</code></pre>

<hr>
<h2 id='bootThreshold'>
Threshold network based on bootstrapped intervals
</h2><span id='topic+bootThreshold'></span>

<h3>Description</h3>

<p>This function takes the output of <code><a href="#topic+bootnet">bootnet</a></code> and returns a network as if it had been estimated using <code><a href="#topic+estimateNetwork">estimateNetwork</a></code>, but with edges removed (set to zero) based on some significance level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootThreshold(bootobject, alpha = 0.05, verbose = TRUE, thresholdIntercepts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootThreshold_+3A_bootobject">bootobject</code></td>
<td>

<p>Nonparametric bootstrap results from <code><a href="#topic+bootnet">bootnet</a></code>
</p>
</td></tr>
<tr><td><code id="bootThreshold_+3A_alpha">alpha</code></td>
<td>

<p>Significance level
</p>
</td></tr>
<tr><td><code id="bootThreshold_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should progress be reported to the console?
</p>
</td></tr>
<tr><td><code id="bootThreshold_+3A_thresholdintercepts">thresholdIntercepts</code></td>
<td>

<p>Logical, should intercepts also be thresholded?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bootnetResult</code> object with the following elements:
</p>
<table>
<tr><td><code>graph</code></td>
<td>
<p>The weights matrix of the network</p>
</td></tr>
<tr><td><code>intercepts</code></td>
<td>
<p>The intercepts</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>The results of the estimation procedure</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A vector with node labels</p>
</td></tr>
<tr><td><code>nNodes</code></td>
<td>
<p>Number of nodes in the network</p>
</td></tr>
<tr><td><code>nPerson</code></td>
<td>
<p>Number of persons in the network</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>Input used, including the result of the default set used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootnet">bootnet</a></code>, <code><a href="#topic+estimateNetwork">estimateNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# BFI Extraversion data from psychTools package:
library("psychTools")
data(bfi)
bfiSub &lt;- bfi[,1:25]

# Estimate unregularized network:
Network &lt;- estimateNetwork(bfiSub, default = "pcor", corMethod = "cor")

# Bootstrap 1000 values, using 8 cores:
boots &lt;- bootnet(Network, nBoots = 1000, nCores = 8)

# Threshold network:
Network_thresholded &lt;- bootThreshold(boots)

# Plot:
plot(Network_thresholded)

## End(Not run)
</code></pre>

<hr>
<h2 id='corStability'>
Correlation stability coefficient
</h2><span id='topic+corStability'></span>

<h3>Description</h3>

<p>This coefficient denotes the estimated maximum number of cases that can be dropped from the data to retain, with 95% probability, a correlation of at least 0.7 (default) between statistics based on the original network and statistics computed with less cases. This coefficient should not be below 0.25 and is preferably above 0.5. See also Epskamp, Borsboom and Fried (2016) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corStability(x, cor = 0.7, statistics = "all", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corStability_+3A_x">x</code></td>
<td>

<p>Output of <code><a href="#topic+bootnet">bootnet</a></code>. Must be case-drop bootstrap.
</p>
</td></tr>
<tr><td><code id="corStability_+3A_cor">cor</code></td>
<td>

<p>The correlation level tot est at.
</p>
</td></tr>
<tr><td><code id="corStability_+3A_statistics">statistics</code></td>
<td>

<p>The statistic(s) to test for. Can also be <code>"all"</code>.
</p>
</td></tr>
<tr><td><code id="corStability_+3A_verbose">verbose</code></td>
<td>
<p>Logical, should information on the progress be printed to the console?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>References</h3>

<p>Epskamp, S., Borsboom, D., &amp; Fried, E. I. (2016). Estimating psychological networks and their accuracy: a tutorial paper. arXiv preprint, arXiv:1604.08462.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootnet">bootnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# BFI Extraversion data from psychTools package:
library("psychTools")
data(bfi)
bfiSub &lt;- bfi[,1:25]

# Estimate network:
Network &lt;- estimateNetwork(bfiSub, default = "EBICglasso")

# Bootstrap 1000 values, using 8 cores:
# Bootstrap 1000 values, using 8 cores:
Results2 &lt;- bootnet(Network, nBoots = 1000, nCores = 8, 
              type = "case")

# Compute CS-coefficients:
corStability(Results2)

## End(Not run)
</code></pre>

<hr>
<h2 id='differenceTest'>
Bootstrapped difference test
</h2><span id='topic+differenceTest'></span>

<h3>Description</h3>

<p>This function computes the bootstrapped difference test for edge-weights and centrality indices. A confidence interval is constructured on the difference of two values, and the test is deemed significant if zero is not in this confidence interval. See also Epskamp, Borsboom and Fried (2016) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>differenceTest(bootobject, x, y, measure = c("strength", "closeness", "betweenness"),
                alpha = 0.05, x2, y2, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="differenceTest_+3A_bootobject">bootobject</code></td>
<td>

<p>Output of <code><a href="#topic+bootnet">bootnet</a></code>. Must be nonparametric or parametric bootstrap.
</p>
</td></tr>
<tr><td><code id="differenceTest_+3A_x">x</code></td>
<td>

<p>A character string indicating the ID of a node or an edge, or a number indiacting the node or edge. For an edge, can be e.g., <code>"1--2"</code> or <code>"x = 1, x2 = 2"</code>.
</p>
</td></tr>
<tr><td><code id="differenceTest_+3A_y">y</code></td>
<td>

<p>A character string indicating the ID of a node or an edge, or a number indiacting the node or edge. For an edge, can be e.g., <code>"1--2"</code> or <code>"y = 1, y2 = 2"</code>.
</p>
</td></tr>
<tr><td><code id="differenceTest_+3A_measure">measure</code></td>
<td>

<p>Measure to test. Can be <code>"strength"</code>, <code>"closeness"</code>, <code>"betweenness"</code>, <code>"edge"</code> or <code>"distance"</code>.
</p>
</td></tr>
<tr><td><code id="differenceTest_+3A_alpha">alpha</code></td>
<td>

<p>Signifiance level to test at. Note that the actual signifiance level is influenced by the number of bootstrap samples, and is returned in a message.
</p>
</td></tr>
<tr><td><code id="differenceTest_+3A_x2">x2</code></td>
<td>

<p>Second node in an edge. optional.
</p>
</td></tr>
<tr><td><code id="differenceTest_+3A_y2">y2</code></td>
<td>

<p>Second node in an edge. optional.
</p>
</td></tr>
<tr><td><code id="differenceTest_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should the message indiacting actual signifiance level be printed?
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>References</h3>

<p>Epskamp, S., Borsboom, D., &amp; Fried, E. I. (2016). Estimating psychological networks and their accuracy: a tutorial paper. arXiv preprint, arXiv:1604.08462.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootnet">bootnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# BFI Extraversion data from psychTools package:
library("psychTools")
data(bfi)
bfiSub &lt;- bfi[,1:25]

# Estimate network:
Network &lt;- estimateNetwork(bfiSub, default = "EBICglasso")

# Bootstrap 1000 values, using 8 cores:
Results1 &lt;- bootnet(Network, nBoots = 1000, nCores = 8)

# Test for difference in strength between node "A1" and "C2":
differenceTest(Results,  "A1", "C2", "strength")

# Test for difference between edge N1--N2 and N3--N4:
differenceTest(Results,  "N1--N2", "N3--N4", "edge")

# Alternative:
differenceTest(Results,  x = "N1", x2 = "N2", y = "N3", 
                y2 = "N4", measure = "edge")

## End(Not run)
</code></pre>

<hr>
<h2 id='estimateNetwork'>
Estimate a network structure
</h2><span id='topic+estimateNetwork'></span><span id='topic+bootnet_EBICglasso'></span><span id='topic+bootnet_pcor'></span><span id='topic+bootnet_cor'></span><span id='topic+bootnet_IsingFit'></span><span id='topic+bootnet_IsingSampler'></span><span id='topic+bootnet_adalasso'></span><span id='topic+bootnet_huge'></span><span id='topic+bootnet_mgm'></span><span id='topic+bootnet_relimp'></span><span id='topic+bootnet_TMFG'></span><span id='topic+bootnet_LoGo'></span><span id='topic+bootnet_ggmModSelect'></span><span id='topic+bootnet_graphicalVAR'></span><span id='topic+bootnet_SVAR_lavaan'></span><span id='topic+bootnet_piecewiseIsing'></span><span id='topic+bootnet_GGMncv'></span>

<h3>Description</h3>

<p>This function allows for flexible estimation of a network structure using various R packages and model frameworks. This is typically done by using one of the default sets. See details for manual specification. See also Epskamp, Borsboom and Fried (2016) for more details. IMPORTANT: THE ESTIMATOR FUNCTIONS (e.g., <code>fun = bootnet_pcor</code>) ARE NOT INTENDED TO BE USED MANUALY (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateNetwork(data, default = c("none", "EBICglasso", "pcor",
                 "IsingFit", "IsingSampler", "huge", "adalasso", "mgm",
                 "relimp", "cor", "TMFG", "ggmModSelect", "LoGo",
                 "graphicalVAR", "piecewiseIsing", "SVAR_lavaan", "GGMncv"),
                 fun, labels, verbose = TRUE, .dots = list(), weighted = TRUE,
                 signed = TRUE, directed, datatype, checkNumeric = FALSE, ...,
                 .input, memorysaver = FALSE)

bootnet_EBICglasso(data, tuning = 0.5, corMethod = c("cor", "cov",
                    "cor_auto", "npn", "spearman"), missing =
                    c("pairwise", "listwise", "fiml", "stop"), sampleSize
                    = c("pairwise_average", "maximum", "minimum",
                    "pairwise_maximum", "pairwise_minimum",
                    "pairwise_average_v1.5", "pairwise_maximum_v1.5",
                    "pairwise_minimum_v1.5"), verbose = TRUE, corArgs =
                    list(), refit = FALSE, principalDirection = FALSE,
                    lambda.min.ratio = 0.01, nlambda = 100, threshold =
                    FALSE, unlock = FALSE, nonPositiveDefinite = c("stop",
                    "continue"), transform = c("none", "rank",
                    "quantile"), ...)

bootnet_pcor(data, corMethod = c("cor", "cov", "cor_auto", "npn",
                    "spearman"), missing = c("pairwise", "listwise",
                    "fiml", "stop"), sampleSize = c("pairwise_average",
                    "maximum", "minimum", "pairwise_maximum",
                    "pairwise_minimum", "pairwise_average_v1.5",
                    "pairwise_maximum_v1.5", "pairwise_minimum_v1.5"),
                    verbose = TRUE, corArgs = list(), threshold = 0, alpha
                    = 0.05, adjacency, principalDirection = FALSE, unlock
                    = FALSE, nonPositiveDefinite = c("stop", "continue"),
                    transform = c("none", "rank", "quantile"))

bootnet_cor(data, corMethod = c("cor", "cov", "cor_auto", "npn",
                    "spearman"), missing = c("pairwise", "listwise",
                    "fiml", "stop"), sampleSize = c("pairwise_average",
                    "maximum", "minimum", "pairwise_maximum",
                    "pairwise_minimum", "pairwise_average_v1.5",
                    "pairwise_maximum_v1.5", "pairwise_minimum_v1.5"),
                    verbose = TRUE, corArgs = list(), threshold = 0, alpha
                    = 0.05, principalDirection = FALSE, unlock = FALSE,
                    nonPositiveDefinite = c("stop", "continue"), transform
                    = c("none", "rank", "quantile"))

bootnet_IsingFit(data, tuning = 0.25, missing = c("listwise", "stop"),
                    verbose = TRUE, rule = c("AND", "OR"), split =
                    "median", principalDirection = FALSE,
                    min_sum = -Inf, unlock = FALSE)

bootnet_IsingSampler(data, missing = c("listwise", "stop"), verbose = TRUE,
                    split = "median", method = c("uni", "ll", "pl", "bi"),
                    principalDirection = FALSE, unlock = FALSE, threshold
                    = FALSE, alpha = 0.01, min_sum = -Inf, rule = c("AND",
                    "OR"))

bootnet_adalasso(data, missing = c("listwise", "stop"), verbose = TRUE,
                   nFolds = 10, principalDirection = FALSE, unlock =
                   FALSE, transform = c("none", "rank", "quantile"), ...)

bootnet_huge(data, tuning = 0.5, missing = c("listwise", "stop"),
                   verbose = TRUE, npn = TRUE, criterion = c("ebic",
                   "ric", "stars"), principalDirection = FALSE,
                   lambda.min.ratio = 0.01, nlambda = 100, unlock =
                   FALSE, transform = c("none", "rank", "quantile"), ...)

bootnet_mgm(data, type, level, tuning = 0.25, missing =
                   c("listwise", "stop"), verbose = TRUE, criterion =
                   c("EBIC", "CV"), nFolds = 10, order = 2, rule =
                   c("AND", "OR"), binarySign, unlock = FALSE, transform
                   = c("none", "rank", "quantile"), ...)

bootnet_relimp(data, normalized = TRUE, type = "lmg",
                   structureDefault = c("none", "custom", "EBICglasso",
                   "pcor", "IsingFit", "IsingSampler", "huge",
                   "adalasso", "mgm", "cor", "TMFG", "ggmModSelect",
                   "LoGo"), missing = c("listwise", "stop"), ..., verbose
                   = TRUE, threshold = 0, unlock = FALSE, transform =
                   c("none", "rank", "quantile"))

bootnet_TMFG(data, graphType = c("cor", "pcor"), corMethod =
                   c("cor", "cov", "cor", "npn", "cor_auto"), missing =
                   c("pairwise", "listwise", "fiml", "stop"), verbose =
                   TRUE, corArgs = list(), principalDirection = FALSE,
                   unlock = FALSE, transform = c("none", "rank",
                   "quantile"), ...)

bootnet_LoGo(data, corMethod = c("cor", "cov", "cor", "npn",
                   "cor_auto"), missing = c("pairwise", "listwise",
                   "fiml", "stop"), verbose = TRUE, corArgs = list(),
                   principalDirection = FALSE, unlock = FALSE, transform
                   = c("none", "rank", "quantile"), ...)

bootnet_graphicalVAR(data, tuning = 0.5, verbose = TRUE, principalDirection
                   = FALSE, missing = c("listwise", "stop"), unlock =
                   FALSE, transform = c("none", "rank", "quantile"), ...)

bootnet_ggmModSelect(data, tuning = 0, corMethod = c("cor", "cov",
                    "cor_auto", "npn", "spearman"), missing =
                    c("pairwise", "listwise", "fiml", "stop"), sampleSize
                    = c("pairwise_average", "maximum", "minimum",
                    "pairwise_maximum", "pairwise_minimum",
                    "pairwise_average_v1.5", "pairwise_maximum_v1.5",
                    "pairwise_minimum_v1.5"), verbose = TRUE, corArgs =
                    list(), principalDirection = FALSE, start =
                    c("glasso", "empty", "full"), stepwise = TRUE, nCores
                    = 1, unlock = FALSE, nonPositiveDefinite = c("stop",
                    "continue"), transform = c("none", "rank",
                    "quantile"), ...)

bootnet_piecewiseIsing(data, cutoff, missing = c("listwise", "stop"), verbose
                    = TRUE, IsingDefault = c("IsingSampler", "IsingFit",
                    "custom"), zeroThreshold = 1, minimalN = ncol(data) +
                    1, unlock = FALSE, ...)

bootnet_SVAR_lavaan(data, verbose = TRUE, principalDirection = FALSE,
                   missing = c("listwise", "stop"), criterion = "bic",
                   eqThreshold = 1e-04, tempWhitelist, tempBlacklist,
                   contWhitelist, contBlacklist, minimalModInd = 10,
                   unlock = FALSE, transform = c("none", "rank",
                   "quantile"), ...)

bootnet_GGMncv(data, penalty = c("atan", "selo", "exp", "log",
                    "sica", "scad", "mcp", "lasso"), corMethod = c("cor",
                    "cov", "cor_auto", "npn", "spearman"), missing =
                    c("pairwise", "listwise", "fiml", "stop"), sampleSize
                    = c("pairwise_average", "maximum", "minimum",
                    "pairwise_maximum", "pairwise_minimum",
                    "pairwise_average_v1.5", "pairwise_maximum_v1.5",
                    "pairwise_minimum_v1.5"), verbose = TRUE, corArgs =
                    list(), principalDirection = FALSE, unlock = FALSE,
                    nonPositiveDefinite = c("stop", "continue"), transform
                    = c("none", "rank", "quantile"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateNetwork_+3A_data">data</code></td>
<td>

<p>A data frame or matrix containing the raw data. Must be numeric, integer or ordered factors.
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_default">default</code></td>
<td>

<p>A string indicating the method to use. Specifying a <code>default</code> sets default values to <code>prepFun</code>, <code>prepArgs</code>, <code>estFun</code>, <code>estArgs</code>, <code>graphFun</code>, <code>graphArgs</code>, <code>intFun</code> and <code>intArgs</code>. Setting a <code>default</code> can be omitted but that does require specifying all above mentioned arguments. Current options are:
</p>

<dl>
<dt><code>"EBICglasso"</code></dt><dd><p>Gaussian Markov random field estimation using graphical LASSO and extended Bayesian information criterion to select optimal regularization parameter. Using <code><a href="qgraph.html#topic+EBICglasso">EBICglasso</a></code> from the qgraph package. Calls <code>bootnet_EBICglasso</code>.</p>
</dd>
<dt><code>"IsingFit"</code></dt><dd><p>Ising model estimation using LASSO regularized nodewise logistic regression and extended Bayesian information criterion to select optimal regularization parameter. Using <code><a href="IsingFit.html#topic+IsingFit">IsingFit</a></code> from the IsingFit package.  Calls <code>bootnet_IsingFit</code>.</p>
</dd>
<dt><code>"IsingSampler"</code></dt><dd><p>Calls the <code><a href="IsingSampler.html#topic+EstimateIsing">EstimateIsing</a></code> function from the IsingSampler package. </p>
</dd>
<dt><code>"pcor"</code></dt><dd><p>Partial correlation network (non-regularized Gaussian Markov random field), using <code><a href="corpcor.html#topic+cor2pcor">cor2pcor</a></code> from the corpcor package.  Calls <code>bootnet_pcor</code>.</p>
</dd>
<dt><code>"cor"</code></dt><dd><p>Correlation network.</p>
</dd>
<dt><code>"huge"</code></dt><dd><p>Uses EBIC model selection of GGM networks estimated via the glasso algorithm as implemented in the huge package (as opposed to glasso and qgraph packages used in <code>default = "EBICglasso"</code>). Uses nonparanormal transformation in preparing the data and does not use polychoric correlations. Calls <code>bootnet_huge</code>.</p>
</dd>
<dt><code>"mgm"</code></dt><dd><p>Estimates a Mixed graphical model by using the the mgm (or mgmfit in older versions) function of the mgm package. Calls <code>bootnet_mgm</code>.</p>
</dd>
<dt><code>"TMFG"</code></dt><dd><p>Estimates a Triangulated Maximally Filtered Graph, using the function <code>TMFG</code> of the NetworkToolbox package.  Calls <code>bootnet_TMFG</code>. Note that this estimates a *correlation network* by default (use the 'graphType' argument to estimate a partial correlation network instead).</p>
</dd>
<dt><code>"LoGo"</code></dt><dd><p>Estimates a Local/Global Sparse Inverse Covariance Matrix, using the function <code>LoGo</code> of the NetworkToolbox package.  Calls <code>bootnet_LoGo</code>.</p>
</dd>
<dt><code>"relimp"</code></dt><dd><p>Estimates a (directed) relative importance network, using the function 'calc.relimp' of the 'relaimpo' package. The 'structureDefault' argument can be used to use a different default set for estimating the structure of the graph. Calls <code>bootnet_relimp</code>.</p>
</dd>
<dt><code>"ggmModSelect"</code></dt><dd><p>Estimates an unregularized GGM using the glasso algorithm and stepwise model selection, using the 'ggmModSelect' function from the qgraph package. Calls <code>bootnet_ggmModSelect</code>.</p>
</dd>
<dt><code>"graphicalVAR"</code></dt><dd><p>Estimates a graphical VAR model using the graphicalVAR package. This results in two networks which can be plotted using the 'graph' argument in the plot method. Calls <code>bootnet_graphicalVAR</code>.</p>
</dd>
</dl>

<p>See details section for a more detailed description.
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_fun">fun</code></td>
<td>

<p>A custom estimation function, when no default set is used. This must be a function that takes the data as input (first argument) and returns either a weights matrix or a list containing the elements <code>"graph"</code> for the weights matrix, <code>"intercepts"</code> for the intercepts (optional) and <code>"results"</code> for the full estimation results (optional).
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_tuning">tuning</code></td>
<td>
<p>EBIC tuning parameter, used in 'EBICglasso', 'IsingFit', 'huge', 'mgm' and 'ggmModSelect' default sets. Note that the default value differs: 'EBICglasso', 'huge' and 'mgm' use 0.5, 'IsingFit' uses 0.25 and 'ggmModSelect uses 0.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_cormethod">corMethod</code></td>
<td>
<p>Correlation method, used in 'EBICglasso' and 'pcor' default sets. <code>"cor_auto"</code> uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> for polychoric and polyserial correlations, <code>"cov"</code> uses the <code><a href="stats.html#topic+cov">cov</a></code> function for covariances, <code>"cor"</code> will use the <code><a href="stats.html#topic+cor">cor</a></code> function for correlations and <code>"npn"</code> will apply the nonparanormal transformation (via <code><a href="huge.html#topic+huge.npn">huge.npn</a></code>) and then compute correlations.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_missing">missing</code></td>
<td>
<p>How to handle missing data? <code>"pairwise"</code> for pairwise deletion, <code>"listwise"</code> for listwise deletion, <code>"fiml"</code> for full-information maximum likelihood and <code>"stop"</code> to stop with an error.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_samplesize">sampleSize</code></td>
<td>
<p>How will sample size be computed in EBICglasso default set? The default <code>"pairwise_average"</code> will set the sample size to the average of sample sizes used for each individual correlation. Other options are <code>"pairwise_maximum"</code> (largest sample sized used for each individual correlation), <code>"pairwise_minimum"</code> (smallest sample sized used for each individual correlation), <code>"maximum"</code> (takes total number of rows including rows with NA), and <code>"minimum"</code> (takes total number of rows that contain no NA). The arguments &quot;pairwise_average_v1.5&quot;, &quot;pairwise_minimum_v1.5&quot;, and &quot;pairwise_maximum_v1.5&quot; can be used to mimic bootnet's behavior in version 1.5 and earlier (which also computed the sample size based on the sample sizes for the variances).</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_corargs">corArgs</code></td>
<td>
<p>A list with arguments for the function used defined by <code>corMethod</code>.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_threshold">threshold</code></td>
<td>

<p>Thresholding to use in partial correlation networks. Can be a fixed number to threshold all absolute edges below this value, <code>'locfdr'</code> for local FDR, or any option corresponding to adjustments in <code><a href="psych.html#topic+corr.p">corr.p</a></code> (<code>'none'</code>, <code>'sig'</code>, <code>'holm'</code>, <code>'hochberg'</code>, <code>'hommel'</code>, <code>'bonferroni'</code>, <code>'BH'</code>, <code>'BY'</code> or <code>'fdr'</code>)). Can also be used for <code>default = "IsingSampler"</code> but can only be set to a logical enabling or disabling significance thresholding.
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_refit">refit</code></td>
<td>
<p>Logical used in EBICglasso default set: should the estimated model structure be refitted without LASSO regularization?</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_rule">rule</code></td>
<td>
<p>The rule to use to select an edge in nodewise estimation. <code>"AND"</code> to only select in edge if both regression coefficients are nonzero and <code>"OR"</code> if only one is nonzero. Used in 'IsingFit' and 'mgm' default sets.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_split">split</code></td>
<td>
<p>A function or character string (<code>"median"</code> or <code>"mean"</code>) indicating how to binarize values when estimating an Ising model.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_method">method</code></td>
<td>
<p>The estimation method used in the IsingSampler default set (see <code><a href="IsingSampler.html#topic+EstimateIsing">EstimateIsing</a></code>).</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_npn">npn</code></td>
<td>
<p>Logical, should nonparanormal be used in huge default set?</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_criterion">criterion</code></td>
<td>
<p>The criterion used in model selection. <code>"ebic"</code>, <code>"ric"</code> or <code>"stars"</code> in the huge default set or <code>"EBIC"</code> or <code>"CV"</code> in the mgm default set.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_nfolds">nFolds</code></td>
<td>
<p>Number of folds used in k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_type">type</code></td>
<td>
<p>For mgm, see mgm or mgmfit; for relative importance networks, see <code><a href="relaimpo.html#topic+calc.relimp">calc.relimp</a></code></p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_level">level</code></td>
<td>
<p>See  <code><a href="mgm.html#topic+mgm">mgm</a></code>. Automatically set if not assigned.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_order">order</code></td>
<td>
<p>Order up until including which interactions are included in the model. See  <code><a href="mgm.html#topic+mgm">mgm</a></code>. Automatically set if not assigned.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_binarysign">binarySign</code></td>
<td>
<p>See  <code><a href="mgm.html#topic+mgm">mgm</a></code>. Automatically set if not assigned.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_normalized">normalized</code></td>
<td>
<p>Should normalized relative importance be used in relative importance networks?</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_structuredefault">structureDefault</code></td>
<td>
<p>In relative importance networks, default set used to compute the graph structure. Any other arguments used (using ...) are sent to the graph estimator function as well.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_graphtype">graphType</code></td>
<td>
<p><code>"cor"</code> to estimate a correlation network and <code>"pcor"</code> to estimate a partial correlation network (GGM)</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_alpha">alpha</code></td>
<td>
<p>Significance level to test at.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_principaldirection">principalDirection</code></td>
<td>

<p>Rescales variables according to the sign of the first eigen-vector. This will lead to most correlations to be positive (positive manifold), leading to negative edges to be substantively interpretable.
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_stepwise">stepwise</code></td>
<td>
<p>Logical indicating if 'ggmModSelect' should use stepwise estimation.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_start">start</code></td>
<td>
<p>See <code><a href="qgraph.html#topic+ggmModSelect">ggmModSelect</a></code></p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_labels">labels</code></td>
<td>

<p>A character vector containing the node labels. If omitted the column names of the data are used.
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_verbose">verbose</code></td>
<td>

<p>Logical, currently only used when <code>default = "EBICglasso"</code> in the <code>cor_auto</code> function.
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_weighted">weighted</code></td>
<td>
<p>Logical, should the analyzed network be weighted?</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_signed">signed</code></td>
<td>
<p>Logical, should the analyzed network be signed?</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_directed">directed</code></td>
<td>
<p>Logical, is the analyzed network directed? Usually does not have to be set and is detected automatically.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_datatype">datatype</code></td>
<td>

<p><code>"normal"</code> if the data argument is a data frame, or <code>"graphicalVAR"</code> if the data argument is a data list that can be used as input to the graphicalVAR package.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_checknumeric">checkNumeric</code></td>
<td>

<p>Logical: should the data be checked to be numeric?
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>

<p>Minimal lambda ratio (LASSO tuning parameter)
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_nlambda">nlambda</code></td>
<td>

<p>Number of LASSO tuning parameters to test
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_ncores">nCores</code></td>
<td>

<p>Number of cores to use in estimating networks
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_.dots">.dots</code></td>
<td>

<p>A list of arguments used in the estimation function set by a default set or by the <code>fun</code> argument.
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_...">...</code></td>
<td>

<p>A list of arguments used in the estimation function set by a default set or by the <code>fun</code> argument.
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_.input">.input</code></td>
<td>
<p>Used internally in the bootnet function. Do not use.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_memorysaver">memorysaver</code></td>
<td>

<p>Logical. If TRUE attempts to save memory (RAM) by removing some objects from the output. Used by bootnet by default for bootstraps.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_cutoff">cutoff</code></td>
<td>

<p>Cutoff score for sum-score to condition on when using <code>default = "piecewiseIsing"</code>. This is *experimental*!
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_isingdefault">IsingDefault</code></td>
<td>

<p>Default set for Ising model structure estimation in piecewise Ising estimation. This is *experimental*!
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_zerothreshold">zeroThreshold</code></td>
<td>

<p>Used in piecewise Ising estimation. Proportion of edges needed to be exactly 0 in pieces to set edge to zero in final network. This is *experimental*!
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_minimaln">minimalN</code></td>
<td>

<p>Used in piecewise Ising estimation. Minimal sample sizes needed in piece estimation. This is *experimental*!
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_eqthreshold">eqThreshold</code></td>
<td>

<p>Used in SVAR_lavaan estimation (stepup SVAR estimation). This is *experimental*! Maximum difference in criterion to decide if two models are equivalent (and select one at random).
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_tempwhitelist">tempWhitelist</code></td>
<td>

<p>Used in SVAR_lavaan estimation (step up SVAR estimation). This is *experimental*! Matrix with edges to be whitelisted in the temporal model. The matrix should contain two columns and a row for each edge. The elements should be characters indicating the variable names of each edge (from, to).
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_tempblacklist">tempBlacklist</code></td>
<td>

<p>Used in SVAR_lavaan estimation (step up SVAR estimation). This is *experimental*! Matrix with edges to be blacklisted in the temporal model. The matrix should contain two columns and a row for each edge. The elements should be characters indicating the variable names of each edge (from, to).
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_contwhitelist">contWhitelist</code></td>
<td>

<p>Used in SVAR_lavaan estimation (step up SVAR estimation). This is *experimental*! Matrix with edges to be whitelisted in the contemporaneous model. The matrix should contain two columns and a row for each edge. The elements should be characters indicating the variable names of each edge (from, to).
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_contblacklist">contBlacklist</code></td>
<td>

<p>Used in SVAR_lavaan estimation (step up SVAR estimation). This is *experimental*! Matrix with edges to be blacklisted in the contemporaneous model. The matrix should contain two columns and a row for each edge. The elements should be characters indicating the variable names of each edge (from, to).
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_minimalmodind">minimalModInd</code></td>
<td>

<p>Minimal modification index to consider when adding parameters in SVAR search.
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_adjacency">adjacency</code></td>
<td>

<p>An 'adjacency' matrix indicating the graph structure (zeroes indicate a missing edge).
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_nonpositivedefinite">nonPositiveDefinite</code></td>
<td>

<p>Set to <code>"stop"</code> to stop with an error when the input matrix is not positive definite, and to <code>"continue"</code> (old behavior) to continue anyway.
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_unlock">unlock</code></td>
<td>

<p>Set to <code>TRUE</code> to not result in a standard error. This is to prevent using the inner functions seperatly (see details below).
</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_transform">transform</code></td>
<td>
<p>Should data be transformed before estimate the network? <code>"rank"</code> will call <code><a href="#topic+rank_transformation">rank_transformation</a></code> and <code>"quantile"</code>&quot; will call <code><a href="#topic+quantile_transformation">quantile_transformation</a></code>.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_penalty">penalty</code></td>
<td>
<p>Penalty to use in the GGMncv methods.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_min_sum">min_sum</code></td>
<td>
<p> The minimum sum score that is artifically possible in the dataset. Defaults to -Inf. Set this only if you know a lower sum score is not possible in the data, for example due to selection bias.</p>
</td></tr>
<tr><td><code id="estimateNetwork_+3A_and">AND</code></td>
<td>
<p>Logical, should an AND-rule (both regressions need to be significant) or OR-rule (one of the regressions needs to be significant) be used?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can manually specify an estimation method by assigning a custom function to the <code>'fun'</code> argument. This function must take data as input and output an estimated network. Fhe functions <code>bootnet_</code> correspond to the functions used when using default sets. E.g, <code>default = "pcor"</code> sets <code>fun = bootnet_pcor</code>. As the <code>...</code> leads to any argument to <code>estimateNetwork</code> to be passed to the estimator function, the arguments described above in these estimator functions can be used for the appropriate default method. For example, if <code>default = "pcor"</code>, the arguments of <code>fun = bootnet_pcor</code> can be used in <code>estimateNetwork</code>. IMPORTANT NOTE: DO NOT USE THE ESTIMATOR FUNCTIONS (e.g., <code>fun = bootnet_pcor</code>) YOURSELF, THEY ARE ONLY INCLUDED HERE TO SHOW WHICH ARGUMENTS YOU CAN USE IN  <code>estimateNetwork</code>.
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>References</h3>

<p>Epskamp, S., Borsboom, D., &amp; Fried, E. I. (2016). Estimating psychological networks and their accuracy: a tutorial paper. arXiv preprint, arXiv:1604.08462.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootnet">bootnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># BFI Extraversion data from psychTools package:
library("psychTools")
data(bfi)
bfiSub &lt;- bfi[,1:25]

# Estimate network:
Network &lt;- estimateNetwork(bfiSub, default = "EBICglasso")

## Not run: 
# Some pointers:
print(Network)

# Estimated network:
plot(Network, layout = 'spring')

# Centrality indices:
library("qgraph")
centralityPlot(Network)

# BIC model selection:
Network_BIC &lt;- estimateNetwork(bfiSub, default = "EBICglasso", tuning = 0)

# Ising model:
Network_BIC &lt;- estimateNetwork(bfiSub, default = "IsingFit")

## End(Not run)
</code></pre>

<hr>
<h2 id='genGGM'>
Generates a GGM small-world network.
</h2><span id='topic+genGGM'></span>

<h3>Description</h3>

<p>Simulates a GGM as described by Yin and Li (2011), using the Watts and Strogatz (1998) algorithm for generating the graph structure (see <code><a href="igraph.html#topic+watts.strogatz.game">watts.strogatz.game</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genGGM(Nvar, p = 0, nei = 1, parRange = c(0.5,1), constant = 1.5, propPositive = 0.5,
  clusters = NULL, graph = c("smallworld","random", "scalefree", "hub", "cluster"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genGGM_+3A_nvar">Nvar</code></td>
<td>

<p>Number of nodes
</p>
</td></tr>
<tr><td><code id="genGGM_+3A_p">p</code></td>
<td>

<p>Rewiring probability if graph = &quot;smallworld&quot; or &quot;cluster&quot;, or connection probability if graph = &quot;random&quot;. If cluster, can add multiple p's for each cluster, e.g., &quot;c(.1, .5)&quot; 
</p>
</td></tr>
<tr><td><code id="genGGM_+3A_nei">nei</code></td>
<td>

<p>Neighborhood (see <code><a href="igraph.html#topic+watts.strogatz.game">watts.strogatz.game</a></code>).
</p>
</td></tr>
<tr><td><code id="genGGM_+3A_parrange">parRange</code></td>
<td>

<p>Range of partial correlation coefficients to be originally sampled.
</p>
</td></tr>
<tr><td><code id="genGGM_+3A_constant">constant</code></td>
<td>

<p>A constant as described by  Yin and Li (2011).
</p>
</td></tr>
<tr><td><code id="genGGM_+3A_proppositive">propPositive</code></td>
<td>

<p>Proportion of edges to be set positive.
</p>
</td></tr>
<tr><td><code id="genGGM_+3A_clusters">clusters</code></td>
<td>

<p>Number of clusters if graph = &quot;cluster&quot;
</p>
</td></tr>
<tr><td><code id="genGGM_+3A_graph">graph</code></td>
<td>
<p>Type of graph to simulate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>References</h3>

<p>Yin, J., and Li, H. (2011). A sparse conditional gaussian graphical model for analysis of genetical genomics data. The annals of applied statistics, 5(4), 2630.
</p>
<p>Watts, D. J., &amp; Strogatz, S. H. (1998). Collective dynamics of &lsquo;small-world&rsquo; networks. nature, 393(6684), 440-442.
</p>

<hr>
<h2 id='ggmGenerator'>
Generates a function that simulates data from the Gaussian graphical model (GGM)
</h2><span id='topic+ggmGenerator'></span>

<h3>Description</h3>

<p>Generates data given a partial correlation network. Data can be made ordinal by using a threshold model with equally spaced thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggmGenerator(ordinal = FALSE, nLevels = 4, skewFactor = 1, type =
                   c("uniform", "random"), missing = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggmGenerator_+3A_ordinal">ordinal</code></td>
<td>

<p>Logical, should ordinal data be generated?
</p>
</td></tr>
<tr><td><code id="ggmGenerator_+3A_nlevels">nLevels</code></td>
<td>

<p>Number of levels used in ordinal data.
</p>
</td></tr>
<tr><td><code id="ggmGenerator_+3A_skewfactor">skewFactor</code></td>
<td>

<p>How skewed should ordinal data be? 1 indicates uniform data and higher values increase skewedness.
</p>
</td></tr>
<tr><td><code id="ggmGenerator_+3A_type">type</code></td>
<td>

<p>Should thresholds for ordinal data be sampled at random or determined uniformly?
</p>
</td></tr>
<tr><td><code id="ggmGenerator_+3A_missing">missing</code></td>
<td>

<p>Proportion of data that should be simulated to be missing.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='IsingGenerator'>
Generates a function that simulates data from the Ising model
</h2><span id='topic+IsingGenerator'></span>

<h3>Description</h3>

<p>Uses <code><a href="IsingSampler.html#topic+IsingSampler">IsingSampler</a></code> to generate the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsingGenerator(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IsingGenerator_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="IsingSampler.html#topic+IsingSampler">IsingSampler</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function with as first argument the sample size and as second argument a named list, with element <code>graph</code> encoding a weights matrix and element <code>intercepts</code> encoding thresholds.
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='multiverse'>
Multiverse plot of bootnet results
</h2><span id='topic+multiverse'></span>

<h3>Description</h3>

<p>This function makes a 'multiverse' plot of bootstrap results. Every row indicates an edge and every column a bootstrap; colors are in line of the edge strength as drawn with <code>plot.bootnetResult</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiverse(x, labels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiverse_+3A_x">x</code></td>
<td>

<p>Results from <code><a href="#topic+bootnet">bootnet</a></code></p>
</td></tr>
<tr><td><code id="multiverse_+3A_labels">labels</code></td>
<td>

<p>Logical, should labels be printed next to the plot?
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='netSimulator'>
Network Estimation Performance
</h2><span id='topic+netSimulator'></span><span id='topic+replicationSimulator'></span>

<h3>Description</h3>

<p>This function can be used to run a simulation study on the performance of network estimation by varying sample size or any argument used as input to <code><a href="#topic+estimateNetwork">estimateNetwork</a></code>. The purpose of this function is to provide a way to assess the required sample size given a network structure, as well as to easily perform simulation studies. By default, the function uses <code><a href="#topic+genGGM">genGGM</a></code> to simulate a chain graph or small-world network. See details for more information. The <code>replicationSimulator</code> function instead assesses how well a network based on a second independent sample would replicate the network based on the first independent sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netSimulator(
      input = genGGM(Nvar = 10), 
      nCases = c(50, 100, 250, 500, 1000, 2500), 
      nReps = 100,
      nCores = 1, 
      default,
      dataGenerator, 
      ...,
      moreArgs = list(),
      moreOutput = list())
    
replicationSimulator(
      input = genGGM(Nvar = 10), 
      nCases = c(50, 100, 250, 500, 1000, 2500), 
      nReps = 100,
      nCores = 1, 
      default,
      dataGenerator, 
      ..., 
      moreArgs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netSimulator_+3A_input">input</code></td>
<td>

<p>Either a weights matrix, a list containing elements <code>graph</code> (encoding the weights matrix) and <code>intercepts</code> (encoding the intercepts), or a function generating such objects. By default, <code><a href="#topic+genGGM">genGGM</a></code> is used to generate a Gaussian graphical model. However, it is reccomended to replace this with a prior expected graph structure.
</p>
</td></tr>
<tr><td><code id="netSimulator_+3A_ncases">nCases</code></td>
<td>

<p>The sample sizes to test for.
</p>
</td></tr>
<tr><td><code id="netSimulator_+3A_nreps">nReps</code></td>
<td>

<p>Number of repetitions per sampling level.
</p>
</td></tr>
<tr><td><code id="netSimulator_+3A_ncores">nCores</code></td>
<td>

<p>Number of cores to use. Set to more than 1 to use parallel computing.
</p>
</td></tr>
<tr><td><code id="netSimulator_+3A_default">default</code></td>
<td>

<p>Default set used (see <code><a href="#topic+estimateNetwork">estimateNetwork</a></code>). In most cases, this will set <code>dataGenerator</code> to the relevant generator.
</p>
</td></tr>
<tr><td><code id="netSimulator_+3A_datagenerator">dataGenerator</code></td>
<td>

<p>A function that generates data. The first argument must be the sample size, the second argument must be the output of <code>input</code>. Can often be ignored if <code>default</code> is set.
</p>
</td></tr>
<tr><td><code id="netSimulator_+3A_moreargs">moreArgs</code></td>
<td>
<p>A named list of arguments to be used when estimating the network, but which should not be interpreted as different conditions. Use this argument to assign arguments that require vectors.</p>
</td></tr>
<tr><td><code id="netSimulator_+3A_moreoutput">moreOutput</code></td>
<td>
<p>List with functions that take the estimated weights matrix as first argument and the true weights matrix as second argument to produce some output.</p>
</td></tr>
<tr><td><code id="netSimulator_+3A_...">...</code></td>
<td>

<p>Arguments used by <code><a href="#topic+estimateNetwork">estimateNetwork</a></code> to estimate the network structure. Providing a vector for any argument will simulate under each value. This way, any argument in <code><a href="#topic+estimateNetwork">estimateNetwork</a></code> can be used in a simulation study.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>*any* argument to <code><a href="#topic+estimateNetwork">estimateNetwork</a></code> can be used in a simulation study, with a vector (e.g., <code>rule = c("AND","OR")</code>) specifying that both conditions are tested. Adding too many conditions can quickly make any simulation study intractible, so only vary some arguments! The <code>dataGenerator</code> argument can be any function that generates data. Currently, only <code><a href="#topic+ggmGenerator">ggmGenerator</a></code> and <code><a href="#topic+IsingGenerator">IsingGenerator</a></code> are implemented in bootnet itself, which generates data given a Gaussian graphical model.
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 5-node GGM chain graph:
trueNetwork &lt;- genGGM(5)

# Simulate:
Res &lt;- netSimulator(trueNetwork, nReps = 10)

# Results:
Res



# Plot:
plot(Res)

# BFI example:
# Load data:
library("psychTools")
data(bfi)
bfiData &lt;- bfi[,1:25]

# Estimate a network structure, with parameters refitted without LASSO regularization:
library("qgraph")
Network &lt;- EBICglasso(cor_auto(bfiData), nrow(bfiData), refit = TRUE)

# Simulate 100 repititions in 8 cores under different sampling levels:
Sim1 &lt;- netSimulator(Network,
                     default = "EBICglasso",
                     nCases = c(100,250,500),
                     nReps = 100,
                     nCores = 8)

# Table of results:
Sim1

# Plot results:
plot(Sim1)

# Compare different default set at two sampling levels:
Sim2_EBICglasso &lt;- netSimulator(Network,
                     default = c("EBICglasso"),
                     nCases = c(100,250,500),
                     nReps = 100,
                     nCores = 8)

Sim2_pcor &lt;- netSimulator(Network,
                                default = c("pcor"),
                                nCases = c(100,250,500),
                                nReps = 100,
                                nCores = 8)

Sim2_huge &lt;- netSimulator(Network,
                          default = c("huge"),
                          nCases = c(100,250,500),
                          nReps = 100,
                          nCores = 8)

Sim2 &lt;- rbind(Sim2_EBICglasso, Sim2_pcor, Sim2_huge)

# Print results:
Sim2

# Plot results:
plot(Sim2, xfacet = "default", yvar = "correlation")

# Difference using polychoric or pearson correlations in ordinal data:
Sim3 &lt;- netSimulator(Network,
                     dataGenerator = ggmGenerator(ordinal = TRUE, nLevels = 4),
                     default = "EBICglasso",
                     corMethod = c("cor","cor_auto"),
                     nCases = c(100,250, 500),
                     nReps = 100,
                     nCores = 8)

# Print results:
Sim3

# Plot results:
plot(Sim3, color = "corMethod")

# Ising model:
trueNetwork &lt;- read.csv('http://sachaepskamp.com/files/weiadj.csv')[,-1]
trueNetwork &lt;- as.matrix(trueNetwork)
Symptoms &lt;- rownames(trueNetwork) &lt;- colnames(trueNetwork)
Thresholds &lt;- read.csv('http://sachaepskamp.com/files/thr.csv')[,-1]

# Create an input list (intercepts now needed)
input &lt;- list(graph=trueNetwork,intercepts=Thresholds)

# Simulate under different sampling levels:
Sim4 &lt;- netSimulator(
  input = input,
  default = "IsingFit",
  nCases = c(250,500,1000),
  nReps = 100,
  nCores = 8)

# Results:
Sim4

# Plot:
plot(Sim4)

# Compare AND and OR rule:
Sim5 &lt;- netSimulator(
  input = input,
  default = "IsingFit",
  nCases = c(250,500,1000),
  rule = c("AND","OR"),
  nReps = 100,
  nCores = 8)

# Print:
Sim5

# Plot:
plot(Sim5, yfacet = "rule")


</code></pre>

<hr>
<h2 id='netSimulator+20and+20replicationSimulator+20methods'>
netSimulator S3 methods
</h2><span id='topic+plot.netSimulator'></span><span id='topic+print.netSimulator'></span><span id='topic+summary.netSimulator'></span><span id='topic+plot.replicationSimulator'></span><span id='topic+print.replicationSimulator'></span><span id='topic+summary.replicationSimulator'></span>

<h3>Description</h3>

<p>Plot, print and summary methods for <code><a href="#topic+netSimulator">netSimulator</a></code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netSimulator'
plot(x, xvar = "factor(nCases)", yvar = c("sensitivity",
                 "specificity", "correlation"), xfacet = "measure",
                 yfacet = ".", color = NULL, ylim = c(0, 1), print =
                 TRUE, xlab = "Number of cases", ylab, outlier.size =
                 0.5, boxplot.lwd = 0.5, style = c("fancy", "basic"),
                 ...)
## S3 method for class 'netSimulator'
print(x, digits = 2, ...)
## S3 method for class 'netSimulator'
summary(object, digits = 2, ...)

## S3 method for class 'replicationSimulator'
plot(x, yvar = c("correlation", "jaccard",
                 "replicatedEdges", "replicatedZeroes"), ...)
## S3 method for class 'replicationSimulator'
print(x, digits = 2, ...)
## S3 method for class 'replicationSimulator'
summary(object, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_x">x</code></td>
<td>

<p>Output of <code><a href="#topic+netSimulator">netSimulator</a></code>.
</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_object">object</code></td>
<td>

<p>Output of <code><a href="#topic+netSimulator">netSimulator</a></code>.
</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_xvar">xvar</code></td>
<td>

<p>String indicating the variable to be used on the x-axis.
</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_yvar">yvar</code></td>
<td>

<p>String vector indicating the variable(s) to be used on the y-axis.
</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_xfacet">xfacet</code></td>
<td>

<p>String indicating the variable to be used on the horizontal facets (or <code>"."</code> to omit).
</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_yfacet">yfacet</code></td>
<td>

<p>String indicating the variable to be used on the vertical facets (or <code>"."</code> to omit).
</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_color">color</code></td>
<td>

<p>String indicating the variable to be used in coloring boxplots.
</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_ylim">ylim</code></td>
<td>

<p>Y-axis limits.
</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_print">print</code></td>
<td>

<p>Logical, should the plot be printed? This helps printing the plots to PDF files.
</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_digits">digits</code></td>
<td>

<p>Number of digits to be used in print and summary method.
</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_xlab">xlab</code></td>
<td>

<p>X-axis label
</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_ylab">ylab</code></td>
<td>

<p>Y-axis label. Defaults to combining the values in <code>yvar</code>. Is hidden when <code>xfacet = "measure"</code>, as then it is clear what the y-axis represent from the facet labels.
</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_outlier.size">outlier.size</code></td>
<td>
<p>Size of the outliers as plotted in boxplots.</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_boxplot.lwd">boxplot.lwd</code></td>
<td>
<p>Line width of the boxplots</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_style">style</code></td>
<td>
<p><code>"fance"</code> for a style including several aesthethic enhancements, and <code>"basic"</code> for a as simple as possible style.</p>
</td></tr>
<tr><td><code id="netSimulator+2B20and+2B20replicationSimulator+2B20methods_+3A_...">...</code></td>
<td>

<p>Arguments sent to <code>"plot.netSimulator"</code> from <code>"plot.replicationSimulator"</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='null'>
Returns NULL
</h2><span id='topic+null'></span>

<h3>Description</h3>

<p>This function simply returns <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_+3A_...">...</code></td>
<td>

<p>Anything
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>null("Not NULL")
</code></pre>

<hr>
<h2 id='plot.bootnet'>
Plots bootnet results
</h2><span id='topic+plot.bootnet'></span>

<h3>Description</h3>

<p>This function can be used to plot bootnet results by plotting all bootstrapped statistics as line or by plotting confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bootnet'
plot(x, statistics, plot, graph, CIstyle = c(
                 "quantiles", "SE"), rank = FALSE, sampleColor =
                 "darkred", samplelwd = 1, meanColor = "black", meanlwd
                 = 0.5, bootColor = "black", bootAlpha = 0.01, bootlwd
                 = 0.9, areaAlpha = 0.1, order = c("id", "sample",
                 "mean"), decreasing = TRUE, perNode = FALSE,
                 legendNcol = 2, labels = TRUE, legend = TRUE,
                 subsetRange = c(100, 0), area = !perNode, alpha =
                 0.05, onlyNonZero = FALSE, differenceShowValue,
                 differenceEdgeColor = TRUE, verbose = TRUE, panels =
                 TRUE, split0 = FALSE, prop0 = ifelse(split0, TRUE,
                 FALSE), prop0_cex = 1, prop0_alpha = 0.8,
                 prop0_minAlpha = 0.25, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bootnet_+3A_x">x</code></td>
<td>

<p>A <code>bootnet</code> object
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_statistics">statistics</code></td>
<td>

<p>The types of statistics to plot.Defaults to <code>"edge"</code> for regular bootstrap and <code>c("strength", "outStrength", "inStrength")</code> for node and person drop bootstrap. Use <code>"all"</code> to obtain all pairwise statistics tested for regular bootstraps and all nodewise statistics tested for person and node drop bootstarps.</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_plot">plot</code></td>
<td>

<p>Character string indicating what to plot. Can be <code>"area"</code> to produce a graph with the area indicating the confidence region, or <code>"difference"</code> producing a plot showing significant differences. Other options are <code>"line"</code> and <code>"interval"</code>, which are currently unstable and not recommended to use.
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_graph">graph</code></td>
<td>
<p>If multipe graphs are estimated, which graph should be plotted? Currently used for <code>default = "graphicalVAR"</code> to plot a temporal network using <code>graph = "temporal"</code> or a contemporaneous network using <code>graph = "contemporaneous"</code></p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_cistyle">CIstyle</code></td>
<td>

<p>Style of CIs to construct. <code>"SE"</code> shows the sample statistic plus and minus two times the standard deviation of bootstraps, and <code>"quantiles"</code> the area between the 2.5th and 97.5th quantile. Defaults to  <code>"quantiles"</code>.
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_rank">rank</code></td>
<td>

<p>Logical, should plots show rank of statistics instead of statistics?
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_samplecolor">sampleColor</code></td>
<td>

<p>Color of the original sample line
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_samplelwd">samplelwd</code></td>
<td>

<p>Line width of the original sample line
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_bootcolor">bootColor</code></td>
<td>

<p>Color of the bootstrap lines
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_bootalpha">bootAlpha</code></td>
<td>

<p>Alpha of the bootstrap lines
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_bootlwd">bootlwd</code></td>
<td>

<p>Line width of the bootstrap lines
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_areaalpha">areaAlpha</code></td>
<td>

<p>Alpha of the area
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_order">order</code></td>
<td>

<p>String indicating how to order nodes. <code>"id"</code> will order nodes based on their name, <code>"mean"</code> will order nodes based on the average bootstrapped value of the first statistic in <code>statistics</code>, and <code>"sample"</code> will order the nodes as done in  <code>"mean"</code> but orders ties based on their sample value.
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_decreasing">decreasing</code></td>
<td>

<p>Logical indicating if the ordering is decreasing or increasing.
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_pernode">perNode</code></td>
<td>

<p>Logical, should centrality estimates per node be plotted instead of correlation with original parameter. Only used in node and person drop bootstrap.
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_legendncol">legendNcol</code></td>
<td>

<p>Number of columns in the legend if <code>perNode = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_labels">labels</code></td>
<td>

<p>Logical, should labels be plotted?
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_legend">legend</code></td>
<td>

<p>Logical, should the legend be plotted?
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_subsetrange">subsetRange</code></td>
<td>

<p>Range in percentages of the x-axis in node and person drop plots.
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_area">area</code></td>
<td>

<p>Logical, should the confidence area be plotted?
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_alpha">alpha</code></td>
<td>

<p>Signifiance level used in <code>plot = "difference"</code>.
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_onlynonzero">onlyNonZero</code></td>
<td>
<p>Logical used when <code>plot = "difference", statistics = "edge"</code>, should only edges be included that were nonzero in the estimated network structure?</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_differenceshowvalue">differenceShowValue</code></td>
<td>
<p>Logical used when <code>plot = "difference"</code>. Should values be shown in the diagonal of the difference plot?
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_differenceedgecolor">differenceEdgeColor</code></td>
<td>
<p>Logical used when <code>plot = "difference", statistics = "edge"</code>. Should diagonal blocks be colored according to default edge colors?
</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_verbose">verbose</code></td>
<td>
<p>Should expected alpha be printed?</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_panels">panels</code></td>
<td>
<p>Logical, should panel titles be printed?</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_meancolor">meanColor</code></td>
<td>
<p>Color of the bootstrap means.</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_meanlwd">meanlwd</code></td>
<td>
<p>Line width of the bootstrap means</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_split0">split0</code></td>
<td>
<p>Logical. When set to TRUE, the displayed intervals are based on occasions when the parameter was not estimated to be zero, and an extra box is added indicating the number of times a parameter is estimated to be zero.</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_prop0">prop0</code></td>
<td>
<p>Logical, should boxes indicating the proportion of times parameters were estimated to be zero be added to the plot?</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_prop0_cex">prop0_cex</code></td>
<td>
<p>Size of the boxes indicating number of times a parameter was set to zero.</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_prop0_alpha">prop0_alpha</code></td>
<td>
<p>Transparency of the boxes indicating number of times a parameter was set to zero.</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_prop0_minalpha">prop0_minAlpha</code></td>
<td>
<p>Minimal transparency of the *lines* of plotted intervals as the proportion of times an edge was not included goes to 0.</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_subset">subset</code></td>
<td>
<p>Vector indicating labels of nodes to include in the plot. This can be used to show, for example, only edges related to one particular node.</p>
</td></tr>
<tr><td><code id="plot.bootnet_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='plot.bootnetResult'>
Plot method for bootnetResult objects
</h2><span id='topic+plot.bootnetResult'></span>

<h3>Description</h3>

<p>Plots the graph using the qgraph package and the <code><a href="qgraph.html#topic+qgraph">qgraph</a></code> function. Defined as <code>qgraph::qgraph(x[['graph']],labels=x[['labels']],...)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bootnetResult'
plot(x, graph, weighted, signed, directed, labels, layout =
                 "spring", parallelEdge = TRUE, cut = 0, theme =
                 "colorblind", bootIncludeOverwrite = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bootnetResult_+3A_x">x</code></td>
<td>

<p>A <code>bootnetResult</code> object
</p>
</td></tr>
<tr><td><code id="plot.bootnetResult_+3A_graph">graph</code></td>
<td>
<p>Numeric or string indicating which graph to plot. Only needed when multiple graphs are estimated. For example, when using <code>default = "graphicalVAR"</code>, <code>graph = "temporal"</code> plots the temporal network and <code>graph = "contemporaneous"</code> plots the contemporaneous network.</p>
</td></tr>
<tr><td><code id="plot.bootnetResult_+3A_weighted">weighted</code></td>
<td>
<p>Logical, should the analyzed network be weighted?</p>
</td></tr>
<tr><td><code id="plot.bootnetResult_+3A_signed">signed</code></td>
<td>
<p>Logical, should the analyzed network be signed?</p>
</td></tr>
<tr><td><code id="plot.bootnetResult_+3A_directed">directed</code></td>
<td>
<p>Logical, is the analyzed network directed? Usually does not have to be set and is detected automatically.</p>
</td></tr>
<tr><td><code id="plot.bootnetResult_+3A_labels">labels</code></td>
<td>
<p>Labels of the nodes. Defaults to the column names of the data if missing.</p>
</td></tr>
<tr><td><code id="plot.bootnetResult_+3A_layout">layout</code></td>
<td>
<p>Placement of the nodes. See  <code><a href="qgraph.html#topic+qgraph">qgraph</a></code>. Always defaults to <code>"spring"</code>.</p>
</td></tr>
<tr><td><code id="plot.bootnetResult_+3A_paralleledge">parallelEdge</code></td>
<td>
<p>Should edges in directed networks be plotted parallel? See  <code><a href="qgraph.html#topic+qgraph">qgraph</a></code>. Defaults to <code>TRUE</code> instead of <code>FALSE</code> (as in qgraph).</p>
</td></tr>
<tr><td><code id="plot.bootnetResult_+3A_cut">cut</code></td>
<td>
<p>Should scaling in width and saturation of edges be split? See  <code><a href="qgraph.html#topic+qgraph">qgraph</a></code>. Defaults to <code>0</code> to disable cut (qgraph chooses a cutoff with at least 20 nodes).</p>
</td></tr>
<tr><td><code id="plot.bootnetResult_+3A_theme">theme</code></td>
<td>
<p>Theme of the edge and node colors. See  <code><a href="qgraph.html#topic+qgraph">qgraph</a></code>. Defaults to <code>"colorblind"</code> rather than the default used in qgraph (<code>"classic"</code>).</p>
</td></tr>
<tr><td><code id="plot.bootnetResult_+3A_bootincludeoverwrite">bootIncludeOverwrite</code></td>
<td>

<p>Logical. If <code>TRUE</code>, several plot defaults are overwritten when the input is the result of <code><a href="#topic+bootInclude">bootInclude</a></code> (e.g., edge colors are set to black and white).
</p>
</td></tr>
<tr><td><code id="plot.bootnetResult_+3A_...">...</code></td>
<td>

<p>Arguments sent to <code><a href="qgraph.html#topic+qgraph">qgraph</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='print.bootnet'>
Print method for bootnet and bootnetResult objects
</h2><span id='topic+print.bootnet'></span><span id='topic+print.bootnetResult'></span><span id='topic+summary.bootnetResult'></span>

<h3>Description</h3>

<p>Prints a short overview of the results of <code><a href="#topic+bootnet">bootnet</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bootnet'
print(x, ...)
## S3 method for class 'bootnetResult'
print(x, ...)
## S3 method for class 'bootnetResult'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bootnet_+3A_x">x</code></td>
<td>

<p>A <code>bootnet</code> or <code>bootnetResult</code> object
</p>
</td></tr>
<tr><td><code id="print.bootnet_+3A_object">object</code></td>
<td>

<p>A <code>bootnetResult</code> object
</p>
</td></tr>
<tr><td><code id="print.bootnet_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='summary.bootnet'>
Summarize bootnet results
</h2><span id='topic+summary.bootnet'></span>

<h3>Description</h3>

<p>Creates a data frame (wrapped as <code><a href="dplyr.html#topic+tbl_df">tbl_df</a></code>) containing summarized results of the bootstraps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bootnet'
summary(object, graph, statistics = c("edge", "intercept",
                 "strength", "closeness", "betweenness", "distance"),
                 perNode = FALSE, rank = FALSE, tol =
                 sqrt(.Machine$double.eps), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bootnet_+3A_object">object</code></td>
<td>

<p>A <code>bootnet</code> object
</p>
</td></tr>
<tr><td><code id="summary.bootnet_+3A_graph">graph</code></td>
<td>
<p>Numeric or string indicating which graph to summarize. Only needed when multiple graphs are estimated. For example, when using <code>default = "graphicalVAR"</code>, <code>graph = "temporal"</code> plots the temporal network and <code>graph = "contemporaneous"</code> plots the contemporaneous network.</p>
</td></tr>
<tr><td><code id="summary.bootnet_+3A_statistics">statistics</code></td>
<td>

<p>The types of statistics to include in the summary table
</p>
</td></tr>
<tr><td><code id="summary.bootnet_+3A_pernode">perNode</code></td>
<td>

<p>Logical, should centrality estimates per node be plotted instead of correlation with original parameter. Only used in node and person drop bootstrap.
</p>
</td></tr>
<tr><td><code id="summary.bootnet_+3A_rank">rank</code></td>
<td>

<p>Logical, should plots show rank of statistics instead of statistics?
</p>
</td></tr>
<tr><td><code id="summary.bootnet_+3A_tol">tol</code></td>
<td>
<p>Tolerance level for assuming an edge is set to zero.</p>
</td></tr>
<tr><td><code id="summary.bootnet_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tbl_df</code> (data frame) containing summarized statistics.
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

<hr>
<h2 id='transformation'>
Data transformation functions
</h2><span id='topic+quantile_transformation'></span><span id='topic+rank_transformation'></span>

<h3>Description</h3>

<p>Functions to transform data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_transformation(x)
rank_transformation(x, ties.method = c("average", "first", 
    "last", "random", "max", "min"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformation_+3A_x">x</code></td>
<td>

<p>A dataset
</p>
</td></tr>
<tr><td><code id="transformation_+3A_ties.method">ties.method</code></td>
<td>
<p>See <code>rank</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sacha Epskamp &lt;mail@sachaepskamp.com&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
