<!DOCTYPE html><html lang="en"><head><title>Help for package survcompare</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {survcompare}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#linear_beta'><p>Auxiliary function for simulatedata functions</p></a></li>
<li><a href='#ml_hyperparams_srf'><p>Internal function for getting grid of hyperparameters</p>
for random or grid search of size = max_grid_size</a></li>
<li><a href='#print.survcompare'><p>Print survcompare object</p></a></li>
<li><a href='#print.survensemble_cv'><p>Prints trained survensemble object</p></a></li>
<li><a href='#simulate_crossterms'><p>Simulated sample with survival outcomes with non-linear and cross-term dependencies</p></a></li>
<li><a href='#simulate_linear'><p>Simulated sample with survival outcomes with linear dependencies</p></a></li>
<li><a href='#simulate_nonlinear'><p>Simulated sample with survival outcomes with non-linear dependencies</p></a></li>
<li><a href='#summary.survcompare'><p>Summary of survcompare results</p></a></li>
<li><a href='#summary.survensemble_cv'><p>Prints summary of a trained survensemble_cv object</p></a></li>
<li><a href='#surv_brierscore'><p>Calculates time-dependent Brier Score</p></a></li>
<li><a href='#surv_validate'><p>Computes performance statistics for a survival data given the predicted event probabilities</p></a></li>
<li><a href='#survcompare'><p>Cross-validates and compares Cox Proportionate Hazards and Survival Random Forest models</p></a></li>
<li><a href='#survcompare2'><p>Compares two cross-validated models using surv____cv functions of this package.</p></a></li>
<li><a href='#survcox_cv'><p>Cross-validates Cox or CoxLasso model</p></a></li>
<li><a href='#survcox_predict'><p>Computes event probabilities from a trained cox model</p></a></li>
<li><a href='#survcox_train'><p>Trains CoxPH using survival package, or trains CoxLasso (cv.glmnet, lambda.min),</p>
and then re-trains survival:coxph on non-zero predictors</a></li>
<li><a href='#survcoxlasso_train'><p>Trains CoxLasso, using cv.glmnet(s=&quot;lambda.min&quot;)</p></a></li>
<li><a href='#survival_prob_km'><p>Calculates survival probability estimated by Kaplan-Meier survival curve</p>
Uses polynomial extrapolation in survival function space, using poly(n=3)</a></li>
<li><a href='#survsrf_cv'><p>Cross-validates Survival Random Forest</p></a></li>
<li><a href='#survsrf_predict'><p>Predicts event probability by a trained Survival Random Forest</p></a></li>
<li><a href='#survsrf_train'><p>Fits randomForestSRC, with tuning by mtry, nodedepth, and nodesize.</p>
Underlying model is by Ishwaran et al(2008)
https://www.randomforestsrc.org/articles/survival.html
Ishwaran H, Kogalur UB, Blackstone EH, Lauer MS. Random survival forests.
The Annals of Applied Statistics. 2008;2:841–60.</a></li>
<li><a href='#survsrf_tune'><p>A repeated 3-fold CV over a hyperparameters grid</p></a></li>
<li><a href='#survsrf_tune_single'><p>Internal function for survsrf_tune(), performs 1 CV</p></a></li>
<li><a href='#survsrfens_cv'><p>Cross-validates predictive performance for SRF Ensemble</p></a></li>
<li><a href='#survsrfens_predict'><p>Predicts event probability by a trained sequential ensemble of Survival Random Forest and CoxPH</p></a></li>
<li><a href='#survsrfens_train'><p>Fits an ensemble of Cox-PH and Survival Random Forest (SRF)</p>
with internal CV to tune SRF hyperparameters.</a></li>
<li><a href='#survsrfstack_cv'><p>Cross-validates stacked ensemble of the CoxPH and Survival Random Forest models</p></a></li>
<li><a href='#survsrfstack_predict'><p>Predicts event probability by a trained stacked ensemble of Survival Random Forest and CoxPH</p></a></li>
<li><a href='#survsrfstack_train'><p>Trains the stacked ensemble of the CoxPH and Survival Random Forest</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Nested Cross-Validation to Compare Cox-PH, Cox-Lasso, Survival
Random Forests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-02</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs repeated nested cross-validation for Cox Proportionate Hazards, Cox Lasso, Survival Random Forest, and their ensemble. Returns internally validated concordance index, time-dependent area under the curve, Brier score, calibration slope, and statistical testing of non-linear ensemble outperforming the baseline Cox model. In this, it helps researchers to quantify the gain of using a more complex survival model, or justify its redundancy. Equally, it shows the performance value of the non-linear and interaction terms, and may highlight the need of further feature transformation. Further details can be found in Shamsutdinova, Stamate, Roberts, &amp; Stahl (2022) "Combining Cox Model and Tree-Based Algorithms to Boost Performance and Preserve Interpretability for Health Outcomes" &lt;<a href="https://doi.org/10.1007%2F978-3-031-08337-2_15">doi:10.1007/978-3-031-08337-2_15</a>&gt;, where the method is described as Ensemble 1.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1), survival (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, timeROC, caret, glmnet, randomForestSRC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Diana Shamsutdinova &lt;diana.shamsutdinova.github@gmail.com&gt;</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-05 08:16:26 UTC; dinab</td>
</tr>
<tr>
<td>Author:</td>
<td>Diana Shamsutdinova
    <a href="https://orcid.org/0000-0003-2434-3641"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Daniel Stahl <a href="https://orcid.org/0000-0001-7987-6619"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-05 17:00:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='linear_beta'>Auxiliary function for simulatedata functions</h2><span id='topic+linear_beta'></span>

<h3>Description</h3>

<p>Auxiliary function for simulatedata functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_beta(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_beta_+3A_df">df</code></td>
<td>
<p>data</p>
</td></tr>
</table>

<hr>
<h2 id='ml_hyperparams_srf'>Internal function for getting grid of hyperparameters
for random or grid search of size = max_grid_size</h2><span id='topic+ml_hyperparams_srf'></span>

<h3>Description</h3>

<p>Internal function for getting grid of hyperparameters
for random or grid search of size = max_grid_size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ml_hyperparams_srf(
  mlparams = list(),
  p = 10,
  max_grid_size = 10,
  dftune_size = 1000,
  randomseed = NaN
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ml_hyperparams_srf_+3A_mlparams">mlparams</code></td>
<td>
<p>list of params</p>
</td></tr>
<tr><td><code id="ml_hyperparams_srf_+3A_p">p</code></td>
<td>
<p>number of predictors to detine mtry options</p>
</td></tr>
<tr><td><code id="ml_hyperparams_srf_+3A_max_grid_size">max_grid_size</code></td>
<td>
<p>grid size for tuning</p>
</td></tr>
<tr><td><code id="ml_hyperparams_srf_+3A_dftune_size">dftune_size</code></td>
<td>
<p>size of the tuning data to define nodesize options</p>
</td></tr>
<tr><td><code id="ml_hyperparams_srf_+3A_randomseed">randomseed</code></td>
<td>
<p>randomseed to select the tuning grid</p>
</td></tr>
</table>

<hr>
<h2 id='print.survcompare'>Print survcompare object</h2><span id='topic+print.survcompare'></span>

<h3>Description</h3>

<p>Print survcompare object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survcompare'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.survcompare_+3A_x">x</code></td>
<td>
<p>output object of the survcompare function</p>
</td></tr>
<tr><td><code id="print.survcompare_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>

<hr>
<h2 id='print.survensemble_cv'>Prints trained survensemble object</h2><span id='topic+print.survensemble_cv'></span>

<h3>Description</h3>

<p>Prints trained survensemble object
</p>
<p>Prints survensemble_cv object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survensemble_cv'
print(x, ...)

## S3 method for class 'survensemble_cv'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.survensemble_cv_+3A_x">x</code></td>
<td>
<p>survensemble_cv object</p>
</td></tr>
<tr><td><code id="print.survensemble_cv_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>
<p>x
</p>

<hr>
<h2 id='simulate_crossterms'>Simulated sample with survival outcomes with non-linear and cross-term dependencies</h2><span id='topic+simulate_crossterms'></span>

<h3>Description</h3>

<p>Simulated sample with exponentially or Weibull distributed time-to-event;
log-hazard depends non-linearly on risk factors, and includes cross-terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_crossterms(
  N = 300,
  observe_time = 10,
  percentcensored = 0.75,
  randomseed = NULL,
  lambda = 0.1,
  distr = "Exp",
  rho_w = 1,
  drop_out = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_crossterms_+3A_n">N</code></td>
<td>
<p>sample size, 300 by default</p>
</td></tr>
<tr><td><code id="simulate_crossterms_+3A_observe_time">observe_time</code></td>
<td>
<p>study's observation time, 10 by default</p>
</td></tr>
<tr><td><code id="simulate_crossterms_+3A_percentcensored">percentcensored</code></td>
<td>
<p>expected number of non-events by observe_time, 0.75 by default (i.e. event rate is 0.25)</p>
</td></tr>
<tr><td><code id="simulate_crossterms_+3A_randomseed">randomseed</code></td>
<td>
<p>random seed for replication</p>
</td></tr>
<tr><td><code id="simulate_crossterms_+3A_lambda">lambda</code></td>
<td>
<p>baseline hazard rate, 0.1 by default</p>
</td></tr>
<tr><td><code id="simulate_crossterms_+3A_distr">distr</code></td>
<td>
<p>time-to-event distribution, &quot;Exp&quot; for exponential (default), &quot;W&quot; for Weibull</p>
</td></tr>
<tr><td><code id="simulate_crossterms_+3A_rho_w">rho_w</code></td>
<td>
<p>shape parameter for Weibull distribution, 0.3 by default</p>
</td></tr>
<tr><td><code id="simulate_crossterms_+3A_drop_out">drop_out</code></td>
<td>
<p>expected rate of drop out before observe_time, 0.3 by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame; &quot;time&quot; and &quot;event&quot; columns describe survival outcome; predictors are &quot;age&quot;, &quot;sex&quot;, &quot;hyp&quot;, &quot;bmi&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- simulate_crossterms()
head(mydata)
</code></pre>

<hr>
<h2 id='simulate_linear'>Simulated sample with survival outcomes with linear dependencies</h2><span id='topic+simulate_linear'></span>

<h3>Description</h3>

<p>Simulated sample with exponentially or Weibull distributed time-to-event;
log-hazard (lambda parameter) depends linearly on risk factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_linear(
  N = 300,
  observe_time = 10,
  percentcensored = 0.75,
  randomseed = NULL,
  lambda = 0.1,
  distr = "Exp",
  rho_w = 1,
  drop_out = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_linear_+3A_n">N</code></td>
<td>
<p>sample size, 300 by default</p>
</td></tr>
<tr><td><code id="simulate_linear_+3A_observe_time">observe_time</code></td>
<td>
<p>study's observation time, 10 by default</p>
</td></tr>
<tr><td><code id="simulate_linear_+3A_percentcensored">percentcensored</code></td>
<td>
<p>expected number of non-events by observe_time, 0.75 by default (i.e. event rate is 0.25)</p>
</td></tr>
<tr><td><code id="simulate_linear_+3A_randomseed">randomseed</code></td>
<td>
<p>random seed for replication</p>
</td></tr>
<tr><td><code id="simulate_linear_+3A_lambda">lambda</code></td>
<td>
<p>baseline hazard rate, 0.1 by default</p>
</td></tr>
<tr><td><code id="simulate_linear_+3A_distr">distr</code></td>
<td>
<p>time-to-event distribution, &quot;Exp&quot; for exponential (default), &quot;W&quot; for Weibull</p>
</td></tr>
<tr><td><code id="simulate_linear_+3A_rho_w">rho_w</code></td>
<td>
<p>shape parameter for Weibull distribution, 0.3 by default</p>
</td></tr>
<tr><td><code id="simulate_linear_+3A_drop_out">drop_out</code></td>
<td>
<p>expected rate of drop out before observe_time, 0.3 by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame; &quot;time&quot; and &quot;event&quot; columns describe survival outcome; predictors are &quot;age&quot;, &quot;sex&quot;, &quot;hyp&quot;, &quot;bmi&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- simulate_linear()
head(mydata)
</code></pre>

<hr>
<h2 id='simulate_nonlinear'>Simulated sample with survival outcomes with non-linear dependencies</h2><span id='topic+simulate_nonlinear'></span>

<h3>Description</h3>

<p>Simulated sample with exponentially or Weibull distributed time-to-event;
log-hazard (lambda parameter) depends non-linearly on risk factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_nonlinear(
  N = 300,
  observe_time = 10,
  percentcensored = 0.75,
  randomseed = NULL,
  lambda = 0.1,
  distr = "Exp",
  rho_w = 1,
  drop_out = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_nonlinear_+3A_n">N</code></td>
<td>
<p>sample size, 300 by default</p>
</td></tr>
<tr><td><code id="simulate_nonlinear_+3A_observe_time">observe_time</code></td>
<td>
<p>study's observation time, 10 by default</p>
</td></tr>
<tr><td><code id="simulate_nonlinear_+3A_percentcensored">percentcensored</code></td>
<td>
<p>expected number of non-events by observe_time, 0.75 by default (i.e. event rate is 0.25)</p>
</td></tr>
<tr><td><code id="simulate_nonlinear_+3A_randomseed">randomseed</code></td>
<td>
<p>random seed for replication</p>
</td></tr>
<tr><td><code id="simulate_nonlinear_+3A_lambda">lambda</code></td>
<td>
<p>baseline hazard rate, 0.1 by default</p>
</td></tr>
<tr><td><code id="simulate_nonlinear_+3A_distr">distr</code></td>
<td>
<p>time-to-event distribution, &quot;Exp&quot; for exponential (default), &quot;W&quot; for Weibull</p>
</td></tr>
<tr><td><code id="simulate_nonlinear_+3A_rho_w">rho_w</code></td>
<td>
<p>shape parameter for Weibull distribution, 0.3 by default</p>
</td></tr>
<tr><td><code id="simulate_nonlinear_+3A_drop_out">drop_out</code></td>
<td>
<p>expected rate of drop out before observe_time, 0.3 by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame; &quot;time&quot; and &quot;event&quot; columns describe survival outcome; predictors are &quot;age&quot;, &quot;sex&quot;, &quot;hyp&quot;, &quot;bmi&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- simulate_nonlinear()
head(mydata)
</code></pre>

<hr>
<h2 id='summary.survcompare'>Summary of survcompare results</h2><span id='topic+summary.survcompare'></span>

<h3>Description</h3>

<p>Summary of survcompare results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survcompare'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.survcompare_+3A_object">object</code></td>
<td>
<p>output object of the survcompare function</p>
</td></tr>
<tr><td><code id="summary.survcompare_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed</p>
</td></tr>
</table>

<hr>
<h2 id='summary.survensemble_cv'>Prints summary of a trained survensemble_cv object</h2><span id='topic+summary.survensemble_cv'></span>

<h3>Description</h3>

<p>Prints summary of a trained survensemble_cv object
</p>
<p>Prints a summary of survensemble_cv object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survensemble_cv'
summary(object, ...)

## S3 method for class 'survensemble_cv'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.survensemble_cv_+3A_object">object</code></td>
<td>
<p>survensemble_cv object</p>
</td></tr>
<tr><td><code id="summary.survensemble_cv_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object
</p>
<p>object
</p>

<hr>
<h2 id='surv_brierscore'>Calculates time-dependent Brier Score</h2><span id='topic+surv_brierscore'></span>

<h3>Description</h3>

<p>Calculates time-dependent Brier Scores for a vector of times. Calculations are similar to that in:
https://scikit-survival.readthedocs.io/en/stable/api/generated/sksurv.metrics.brier_score.html#sksurv.metrics.brier_score
https://github.com/sebp/scikit-survival/blob/v0.19.0.post1/sksurv/metrics.py#L524-L644
The function uses IPCW (inverse probability of censoring weights), computed using the Kaplan-Meier
survival function, where events are censored events from train data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv_brierscore(
  y_predicted_newdata,
  df_brier_train,
  df_newdata,
  time_point,
  weighted = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surv_brierscore_+3A_y_predicted_newdata">y_predicted_newdata</code></td>
<td>
<p>computed event probabilities (! not survival probabilities)</p>
</td></tr>
<tr><td><code id="surv_brierscore_+3A_df_brier_train">df_brier_train</code></td>
<td>
<p>train data</p>
</td></tr>
<tr><td><code id="surv_brierscore_+3A_df_newdata">df_newdata</code></td>
<td>
<p>test data for which brier score is computed</p>
</td></tr>
<tr><td><code id="surv_brierscore_+3A_time_point">time_point</code></td>
<td>
<p>times at which BS calculated</p>
</td></tr>
<tr><td><code id="surv_brierscore_+3A_weighted">weighted</code></td>
<td>
<p>TRUE/FALSE for IPWC to use or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of time-dependent Brier Scores for all time_point
</p>

<hr>
<h2 id='surv_validate'>Computes performance statistics for a survival data given the predicted event probabilities</h2><span id='topic+surv_validate'></span>

<h3>Description</h3>

<p>Computes performance statistics for a survival data given the predicted event probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv_validate(
  y_predict,
  predict_time,
  df_train,
  df_test,
  weighted = TRUE,
  alpha = "logit"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surv_validate_+3A_y_predict">y_predict</code></td>
<td>
<p>probabilities of event by predict_time (matrix=observations x times)</p>
</td></tr>
<tr><td><code id="surv_validate_+3A_predict_time">predict_time</code></td>
<td>
<p>times for which event probabilities are given</p>
</td></tr>
<tr><td><code id="surv_validate_+3A_df_train">df_train</code></td>
<td>
<p>train data, data frame</p>
</td></tr>
<tr><td><code id="surv_validate_+3A_df_test">df_test</code></td>
<td>
<p>test data, data frame</p>
</td></tr>
<tr><td><code id="surv_validate_+3A_weighted">weighted</code></td>
<td>
<p>TRUE/FALSE, for IPWC</p>
</td></tr>
<tr><td><code id="surv_validate_+3A_alpha">alpha</code></td>
<td>
<p>calibration alpha as mean difference in probabilities, or in log-odds (from logistic regression, default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame(T, AUCROC, Brier Score, Scaled Brier Score, C_score, Calib slope, Calib alpha)
</p>

<hr>
<h2 id='survcompare'>Cross-validates and compares Cox Proportionate Hazards and Survival Random Forest models</h2><span id='topic+survcompare'></span><span id='topic++22_PACKAGE+22'></span>

<h3>Description</h3>

<p>The function performs a repeated nested cross-validation for
</p>

<ol>
<li><p> Cox-PH (survival package, survival::coxph) or Cox-Lasso (glmnet package, glmnet::cox.fit)
</p>
</li>
<li><p> Survival Random Forest (randomForestSRC::rfsrc), or its ensemble with the Cox model (if use_ensemble =TRUE)
</p>
</li></ol>

<p>The same random seed for the train/test splits are used for all models to aid fair comparison;
and the performance metrics are computed for the tree models including Harrel's c-index,
time-dependent AUC-ROC, time-dependent Brier Score, and calibration slope.
The statistical significance of the performance differences between Cox-PH and Cox-SRF Ensemble is tested and reported.
</p>
<p>The function is designed to help with the model selection by quantifying the loss of predictive
performance (if any) if Cox-PH is used instead of a more complex model such as SRF
which can capture non-linear and interaction terms, as well as non-proportionate hazards.
The difference in performance of the Ensembled Cox and SRF and the baseline Cox-PH
can be viewed as quantification of the non-linear and cross-terms contribution to
the predictive power of the supplied predictors.
</p>
<p>The function is a wrapper for survcompare2(), for comparison of the CoxPH and SRF models, and
an alternative way to do the same analysis is to run survcox_cv() and survsrf_cv(), then using survcompare2()
</p>
<p>Cross-validates and compares Cox Proportionate Hazards and Survival Random Forest models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survcompare(
  df_train,
  predict_factors,
  fixed_time = NaN,
  randomseed = NaN,
  useCoxLasso = FALSE,
  outer_cv = 3,
  inner_cv = 3,
  tuningparams = list(),
  return_models = FALSE,
  repeat_cv = 2,
  ml = "SRF",
  use_ensemble = FALSE,
  max_grid_size = 10,
  suppresswarn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survcompare_+3A_df_train">df_train</code></td>
<td>
<p>training data, a data frame with &quot;time&quot; and &quot;event&quot; columns to define the survival outcome</p>
</td></tr>
<tr><td><code id="survcompare_+3A_predict_factors">predict_factors</code></td>
<td>
<p>list of column names to be used as predictors</p>
</td></tr>
<tr><td><code id="survcompare_+3A_fixed_time">fixed_time</code></td>
<td>
<p>prediction time of interest. If NULL, 0.90th quantile of event times is used</p>
</td></tr>
<tr><td><code id="survcompare_+3A_randomseed">randomseed</code></td>
<td>
<p>random seed for replication</p>
</td></tr>
<tr><td><code id="survcompare_+3A_usecoxlasso">useCoxLasso</code></td>
<td>
<p>TRUE / FALSE, for whether to use regularized version of the Cox model, FALSE is default</p>
</td></tr>
<tr><td><code id="survcompare_+3A_outer_cv">outer_cv</code></td>
<td>
<p>k in k-fold CV</p>
</td></tr>
<tr><td><code id="survcompare_+3A_inner_cv">inner_cv</code></td>
<td>
<p>k in k-fold CV for internal CV to tune survival random forest hyper-parameters</p>
</td></tr>
<tr><td><code id="survcompare_+3A_tuningparams">tuningparams</code></td>
<td>
<p>list of tuning parameters for random forest: 1) NULL for using a default tuning grid, or 2) a list(&quot;mtry&quot;=c(...), &quot;nodedepth&quot; = c(...), &quot;nodesize&quot; = c(...))</p>
</td></tr>
<tr><td><code id="survcompare_+3A_return_models">return_models</code></td>
<td>
<p>TRUE/FALSE to return the trained models; default is FALSE, only performance is returned</p>
</td></tr>
<tr><td><code id="survcompare_+3A_repeat_cv">repeat_cv</code></td>
<td>
<p>if NULL, runs once, otherwise repeats several times with different random split for CV, reports average of all</p>
</td></tr>
<tr><td><code id="survcompare_+3A_ml">ml</code></td>
<td>
<p>this is currently for Survival Random Forest only (&quot;SRF&quot;)</p>
</td></tr>
<tr><td><code id="survcompare_+3A_use_ensemble">use_ensemble</code></td>
<td>
<p>TRUE/FALSE for whether to train SRF on its own, apart from the CoxPH-&gt;SRF ensemble. Default is FALSE as there is not much information in SRF itself compared to the ensembled version.</p>
</td></tr>
<tr><td><code id="survcompare_+3A_max_grid_size">max_grid_size</code></td>
<td>
<p>number of random grid searches for model tuning</p>
</td></tr>
<tr><td><code id="survcompare_+3A_suppresswarn">suppresswarn</code></td>
<td>
<p>TRUE/FALSE, TRUE by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outcome - cross-validation results for CoxPH, SRF, and an object containing the comparison results
</p>


<h3>Author(s)</h3>

<p>Diana Shamsutdinova <a href="mailto:diana.shamsutdinova.github@gmail.com">diana.shamsutdinova.github@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;-simulate_nonlinear(100)
predictors &lt;- names(df)[1:4]
srf_params &lt;- list("mtry" = c(2), "nodedepth"=c(25), "nodesize" =c(15))
mysurvcomp &lt;- survcompare(df, predictors, tuningparams = srf_params, max_grid_size = 1)
summary(mysurvcomp)

</code></pre>

<hr>
<h2 id='survcompare2'>Compares two cross-validated models using surv____cv functions of this package.</h2><span id='topic+survcompare2'></span>

<h3>Description</h3>

<p>#' The two arguments are two cross-validated models, base and alternative,
e.g., Cox Proportionate Hazards Model (or Cox LASSO), and Survival Random Forest,
or DeepHit (if installed from GitHub, not in CRAN version). Please see examples below.
</p>
<p>Both cross-validations should be done with the same random seed, number of repetitions
(repeat_cv), outer_cv and inner_cv to ensure the models are compared on the same train/test splits.
</p>
<p>Harrel's c-index,time-dependent AUC-ROC, time-dependent Brier Score, and calibration slopes are reported.
The statistical significance of the performance differences is tested for the C-indeces.
</p>
<p>The function is designed to help with the model selection by quantifying the loss of predictive
performance (if any) if &quot;alternative&quot; is used instead of &quot;base.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survcompare2(base, alternative)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survcompare2_+3A_base">base</code></td>
<td>
<p>an object of type &quot;survensemble_cv&quot;, for example, outcomes of survcox_cv, survsrf_cv, survsrfens_cv, survsrfstack_cv</p>
</td></tr>
<tr><td><code id="survcompare2_+3A_alternative">alternative</code></td>
<td>
<p>an object of type &quot;survensemble_cv&quot;, to compare to &quot;base&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outcome = list(data frame with performance results, fitted Cox models, fitted DeespSurv)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;-simulate_nonlinear(100)
params &lt;- names(df)[1:4]
cv1 &lt;- survcox_cv(df, params, randomseed = 42, repeat_cv =1)
cv2 &lt;- survsrf_cv(df, params, randomseed = 42, repeat_cv = 1)
survcompare2(cv1, cv2)
</code></pre>

<hr>
<h2 id='survcox_cv'>Cross-validates Cox or CoxLasso model</h2><span id='topic+survcox_cv'></span>

<h3>Description</h3>

<p>Cross-validates Cox or CoxLasso model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survcox_cv(
  df,
  predict.factors,
  fixed_time = NaN,
  outer_cv = 3,
  repeat_cv = 2,
  randomseed = NaN,
  return_models = FALSE,
  inner_cv = 3,
  useCoxLasso = FALSE,
  suppresswarn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survcox_cv_+3A_df">df</code></td>
<td>
<p>data frame with the data, &quot;time&quot; and &quot;event&quot; for survival outcome</p>
</td></tr>
<tr><td><code id="survcox_cv_+3A_predict.factors">predict.factors</code></td>
<td>
<p>list of predictor names</p>
</td></tr>
<tr><td><code id="survcox_cv_+3A_fixed_time">fixed_time</code></td>
<td>
<p>at which performance metrics are computed</p>
</td></tr>
<tr><td><code id="survcox_cv_+3A_outer_cv">outer_cv</code></td>
<td>
<p>k in k-fold CV, default 3</p>
</td></tr>
<tr><td><code id="survcox_cv_+3A_repeat_cv">repeat_cv</code></td>
<td>
<p>if NULL, runs once, otherwise repeats CV</p>
</td></tr>
<tr><td><code id="survcox_cv_+3A_randomseed">randomseed</code></td>
<td>
<p>random seed</p>
</td></tr>
<tr><td><code id="survcox_cv_+3A_return_models">return_models</code></td>
<td>
<p>TRUE/FALSE, if TRUE returns all CV objects</p>
</td></tr>
<tr><td><code id="survcox_cv_+3A_inner_cv">inner_cv</code></td>
<td>
<p>k in the inner loop of k-fold CV, default is 3; only used if CoxLasso is TRUE</p>
</td></tr>
<tr><td><code id="survcox_cv_+3A_usecoxlasso">useCoxLasso</code></td>
<td>
<p>TRUE/FALSE, FALSE by default</p>
</td></tr>
<tr><td><code id="survcox_cv_+3A_suppresswarn">suppresswarn</code></td>
<td>
<p>TRUE/FALSE, TRUE by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of outputs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- simulate_nonlinear()
coxph_cv &lt;- survcox_cv(df, names(df)[1:4])
summary(coxph_cv)

</code></pre>

<hr>
<h2 id='survcox_predict'>Computes event probabilities from a trained cox model</h2><span id='topic+survcox_predict'></span>

<h3>Description</h3>

<p>Computes event probabilities from a trained cox model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survcox_predict(trained_model, newdata, fixed_time, interpolation = "constant")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survcox_predict_+3A_trained_model">trained_model</code></td>
<td>
<p>pre-trained cox model of coxph class</p>
</td></tr>
<tr><td><code id="survcox_predict_+3A_newdata">newdata</code></td>
<td>
<p>data to compute event probabilities for</p>
</td></tr>
<tr><td><code id="survcox_predict_+3A_fixed_time">fixed_time</code></td>
<td>
<p>at which event probabilities are computed</p>
</td></tr>
<tr><td><code id="survcox_predict_+3A_interpolation">interpolation</code></td>
<td>
<p>&quot;constant&quot; by default, can also be &quot;linear&quot;, for between times interpolation for hazard rates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns matrix(nrow = length(newdata), ncol = length(fixed_time))
</p>

<hr>
<h2 id='survcox_train'>Trains CoxPH using survival package, or trains CoxLasso (cv.glmnet, lambda.min),
and then re-trains survival:coxph on non-zero predictors</h2><span id='topic+survcox_train'></span>

<h3>Description</h3>

<p>Trains CoxPH using survival package, or trains CoxLasso (cv.glmnet, lambda.min),
and then re-trains survival:coxph on non-zero predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survcox_train(
  df_train,
  predict.factors,
  fixed_time = NaN,
  useCoxLasso = FALSE,
  retrain_cox = FALSE,
  inner_cv = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survcox_train_+3A_df_train">df_train</code></td>
<td>
<p>data, &quot;time&quot; and &quot;event&quot; should describe survival outcome</p>
</td></tr>
<tr><td><code id="survcox_train_+3A_predict.factors">predict.factors</code></td>
<td>
<p>list of the column names to be used as predictors</p>
</td></tr>
<tr><td><code id="survcox_train_+3A_fixed_time">fixed_time</code></td>
<td>
<p>target time, NaN by default; needed here only to re-align with other methods</p>
</td></tr>
<tr><td><code id="survcox_train_+3A_usecoxlasso">useCoxLasso</code></td>
<td>
<p>TRUE or FALSE</p>
</td></tr>
<tr><td><code id="survcox_train_+3A_retrain_cox">retrain_cox</code></td>
<td>
<p>if useCoxLasso is TRUE, whether to re-train coxph on non-zero predictors, FALSE by default</p>
</td></tr>
<tr><td><code id="survcox_train_+3A_inner_cv">inner_cv</code></td>
<td>
<p>k in k-fold CV for training lambda for Cox Lasso, only used for useCoxLasso = TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitted CoxPH or CoxLasso model
</p>

<hr>
<h2 id='survcoxlasso_train'>Trains CoxLasso, using cv.glmnet(s=&quot;lambda.min&quot;)</h2><span id='topic+survcoxlasso_train'></span>

<h3>Description</h3>

<p>Trains CoxLasso, using cv.glmnet(s=&quot;lambda.min&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survcoxlasso_train(
  df_train,
  predict.factors,
  inner_cv = 5,
  fixed_time = NaN,
  retrain_cox = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survcoxlasso_train_+3A_df_train">df_train</code></td>
<td>
<p>data frame with the data, &quot;time&quot; and &quot;event&quot; should describe survival outcome</p>
</td></tr>
<tr><td><code id="survcoxlasso_train_+3A_predict.factors">predict.factors</code></td>
<td>
<p>list of the column names to be used as predictors</p>
</td></tr>
<tr><td><code id="survcoxlasso_train_+3A_inner_cv">inner_cv</code></td>
<td>
<p>k in k-fold CV for lambda tuning</p>
</td></tr>
<tr><td><code id="survcoxlasso_train_+3A_fixed_time">fixed_time</code></td>
<td>
<p>not used here, for internal use</p>
</td></tr>
<tr><td><code id="survcoxlasso_train_+3A_retrain_cox">retrain_cox</code></td>
<td>
<p>whether to re-train coxph on non-zero predictors; FALSE by default</p>
</td></tr>
<tr><td><code id="survcoxlasso_train_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE prints warnings if no predictors in Lasso</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitted CoxPH object with coefficient of CoxLasso or re-trained CoxPH with non-zero CoxLasso if retrain_cox = FALSE or TRUE
</p>

<hr>
<h2 id='survival_prob_km'>Calculates survival probability estimated by Kaplan-Meier survival curve
Uses polynomial extrapolation in survival function space, using poly(n=3)</h2><span id='topic+survival_prob_km'></span>

<h3>Description</h3>

<p>Calculates survival probability estimated by Kaplan-Meier survival curve
Uses polynomial extrapolation in survival function space, using poly(n=3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survival_prob_km(df_km_train, times, estimate_censoring = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survival_prob_km_+3A_df_km_train">df_km_train</code></td>
<td>
<p>event probabilities (!not survival)</p>
</td></tr>
<tr><td><code id="survival_prob_km_+3A_times">times</code></td>
<td>
<p>times at which survival is estimated</p>
</td></tr>
<tr><td><code id="survival_prob_km_+3A_estimate_censoring">estimate_censoring</code></td>
<td>
<p>FALSE by default, if TRUE, event and censoring is reversed (for IPCW calculations)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of survival probabilities for time_point
</p>

<hr>
<h2 id='survsrf_cv'>Cross-validates Survival Random Forest</h2><span id='topic+survsrf_cv'></span>

<h3>Description</h3>

<p>Cross-validates Survival Random Forest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survsrf_cv(
  df,
  predict.factors,
  fixed_time = NaN,
  outer_cv = 3,
  inner_cv = 3,
  repeat_cv = 2,
  randomseed = NaN,
  return_models = FALSE,
  tuningparams = list(),
  max_grid_size = 10,
  verbose = FALSE,
  suppresswarn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survsrf_cv_+3A_df">df</code></td>
<td>
<p>data, &quot;time&quot; and &quot;event&quot; should describe survival outcome</p>
</td></tr>
<tr><td><code id="survsrf_cv_+3A_predict.factors">predict.factors</code></td>
<td>
<p>list of predictor names</p>
</td></tr>
<tr><td><code id="survsrf_cv_+3A_fixed_time">fixed_time</code></td>
<td>
<p>time at which performance is maximized</p>
</td></tr>
<tr><td><code id="survsrf_cv_+3A_outer_cv">outer_cv</code></td>
<td>
<p>number of cross-validation folds for model validation</p>
</td></tr>
<tr><td><code id="survsrf_cv_+3A_inner_cv">inner_cv</code></td>
<td>
<p>number of cross-validation folds for hyperparameters' tuning</p>
</td></tr>
<tr><td><code id="survsrf_cv_+3A_repeat_cv">repeat_cv</code></td>
<td>
<p>number of CV repeats, if NaN, runs once</p>
</td></tr>
<tr><td><code id="survsrf_cv_+3A_randomseed">randomseed</code></td>
<td>
<p>random seed to control tuning including data splits</p>
</td></tr>
<tr><td><code id="survsrf_cv_+3A_return_models">return_models</code></td>
<td>
<p>if all models are stored and returned</p>
</td></tr>
<tr><td><code id="survsrf_cv_+3A_tuningparams">tuningparams</code></td>
<td>
<p>if given, list of hyperparameters, list(mtry=c(), nodedepth=c(),nodesize=c()), otherwise a wide default grid is used</p>
</td></tr>
<tr><td><code id="survsrf_cv_+3A_max_grid_size">max_grid_size</code></td>
<td>
<p>number of random grid searches for model tuning</p>
</td></tr>
<tr><td><code id="survsrf_cv_+3A_verbose">verbose</code></td>
<td>
<p>FALSE(default)/TRUE</p>
</td></tr>
<tr><td><code id="survsrf_cv_+3A_suppresswarn">suppresswarn</code></td>
<td>
<p>TRUE/FALSE, TRUE by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of outputs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

df &lt;- simulate_nonlinear()
srf_cv &lt;- survsrf_cv(df, names(df)[1:4])
summary(srf_cv)


</code></pre>

<hr>
<h2 id='survsrf_predict'>Predicts event probability by a trained Survival Random Forest</h2><span id='topic+survsrf_predict'></span>

<h3>Description</h3>

<p>Predicts event probability by a trained Survival Random Forest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survsrf_predict(trained_model, newdata, fixed_time, extrapsurvival = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survsrf_predict_+3A_trained_model">trained_model</code></td>
<td>
<p>a trained SRF model, output of survsrf_train(), or randomForestSRC::rfsrc()</p>
</td></tr>
<tr><td><code id="survsrf_predict_+3A_newdata">newdata</code></td>
<td>
<p>new data for which predictions are made</p>
</td></tr>
<tr><td><code id="survsrf_predict_+3A_fixed_time">fixed_time</code></td>
<td>
<p>time of interest for which event probabilities are computed</p>
</td></tr>
<tr><td><code id="survsrf_predict_+3A_extrapsurvival">extrapsurvival</code></td>
<td>
<p>if probabilities are extrapolated beyond trained times (using probability of
the lastest available time). Can be helpful for cross-validation of small data, where random
split may cause the time of interest being outside of the training set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of predicted event probabilities
</p>

<hr>
<h2 id='survsrf_train'>Fits randomForestSRC, with tuning by mtry, nodedepth, and nodesize.
Underlying model is by Ishwaran et al(2008)
https://www.randomforestsrc.org/articles/survival.html
Ishwaran H, Kogalur UB, Blackstone EH, Lauer MS. Random survival forests.
The Annals of Applied Statistics. 2008;2:841–60.</h2><span id='topic+survsrf_train'></span>

<h3>Description</h3>

<p>Fits randomForestSRC, with tuning by mtry, nodedepth, and nodesize.
Underlying model is by Ishwaran et al(2008)
https://www.randomforestsrc.org/articles/survival.html
Ishwaran H, Kogalur UB, Blackstone EH, Lauer MS. Random survival forests.
The Annals of Applied Statistics. 2008;2:841–60.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survsrf_train(
  df_train,
  predict.factors,
  fixed_time = NaN,
  tuningparams = list(),
  max_grid_size = 10,
  inner_cv = 3,
  randomseed = NaN,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survsrf_train_+3A_df_train">df_train</code></td>
<td>
<p>data, &quot;time&quot; and &quot;event&quot; should describe survival outcome</p>
</td></tr>
<tr><td><code id="survsrf_train_+3A_predict.factors">predict.factors</code></td>
<td>
<p>list of predictor names</p>
</td></tr>
<tr><td><code id="survsrf_train_+3A_fixed_time">fixed_time</code></td>
<td>
<p>time at which performance is maximized</p>
</td></tr>
<tr><td><code id="survsrf_train_+3A_tuningparams">tuningparams</code></td>
<td>
<p>if given, list of hyperparameters, list(mtry=c(), nodedepth=c(),nodesize=c()), otherwise a wide default grid is used</p>
</td></tr>
<tr><td><code id="survsrf_train_+3A_max_grid_size">max_grid_size</code></td>
<td>
<p>number of random grid searches for model tuning</p>
</td></tr>
<tr><td><code id="survsrf_train_+3A_inner_cv">inner_cv</code></td>
<td>
<p>number of cross-validation folds for hyperparameters' tuning</p>
</td></tr>
<tr><td><code id="survsrf_train_+3A_randomseed">randomseed</code></td>
<td>
<p>random seed to control tuning including data splits</p>
</td></tr>
<tr><td><code id="survsrf_train_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE, FALSE by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output = list(bestparams, allstats, model)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;-simulate_nonlinear(100)
p&lt;- names(d)[1:4]
tuningparams = list(
 "mtry" = c(5,10,15),
 "nodedepth" = c(5,10,15,20),
 "nodesize" =    c(20,30,50)
)
m_srf&lt;- survsrf_train(d,p,tuningparams=tuningparams)
</code></pre>

<hr>
<h2 id='survsrf_tune'>A repeated 3-fold CV over a hyperparameters grid</h2><span id='topic+survsrf_tune'></span>

<h3>Description</h3>

<p>A repeated 3-fold CV over a hyperparameters grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survsrf_tune(
  df_tune,
  predict.factors,
  repeat_tune = 1,
  fixed_time = NaN,
  tuningparams = list(),
  max_grid_size = 10,
  inner_cv = 3,
  randomseed = NaN
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survsrf_tune_+3A_df_tune">df_tune</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="survsrf_tune_+3A_predict.factors">predict.factors</code></td>
<td>
<p>list of predictor names</p>
</td></tr>
<tr><td><code id="survsrf_tune_+3A_repeat_tune">repeat_tune</code></td>
<td>
<p>number of repeats</p>
</td></tr>
<tr><td><code id="survsrf_tune_+3A_fixed_time">fixed_time</code></td>
<td>
<p>not used here, but for some models the time for which performance is optimized</p>
</td></tr>
<tr><td><code id="survsrf_tune_+3A_tuningparams">tuningparams</code></td>
<td>
<p>if given, list of hyperparameters, list(mtry=c(), nodedepth=c(),nodesize=c()), otherwise a wide default grid is used</p>
</td></tr>
<tr><td><code id="survsrf_tune_+3A_max_grid_size">max_grid_size</code></td>
<td>
<p>number of random grid searches for model tuning</p>
</td></tr>
<tr><td><code id="survsrf_tune_+3A_inner_cv">inner_cv</code></td>
<td>
<p>number of cross-validation folds for hyperparameter tuning</p>
</td></tr>
<tr><td><code id="survsrf_tune_+3A_randomseed">randomseed</code></td>
<td>
<p>to choose random subgroup of hyperparams</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output=list(cindex_ordered, bestparams)
</p>

<hr>
<h2 id='survsrf_tune_single'>Internal function for survsrf_tune(), performs 1 CV</h2><span id='topic+survsrf_tune_single'></span>

<h3>Description</h3>

<p>Internal function for survsrf_tune(), performs 1 CV
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survsrf_tune_single(
  df_tune,
  predict.factors,
  fixed_time = NaN,
  grid_hyperparams = c(),
  inner_cv = 3,
  randomseed = NaN,
  progressbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survsrf_tune_single_+3A_df_tune">df_tune</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="survsrf_tune_single_+3A_predict.factors">predict.factors</code></td>
<td>
<p>list of predictor names</p>
</td></tr>
<tr><td><code id="survsrf_tune_single_+3A_fixed_time">fixed_time</code></td>
<td>
<p>predictions for which time are computed for c-index</p>
</td></tr>
<tr><td><code id="survsrf_tune_single_+3A_grid_hyperparams">grid_hyperparams</code></td>
<td>
<p>hyperparameters grid (or a default will be used )</p>
</td></tr>
<tr><td><code id="survsrf_tune_single_+3A_inner_cv">inner_cv</code></td>
<td>
<p>number of folds for each CV</p>
</td></tr>
<tr><td><code id="survsrf_tune_single_+3A_randomseed">randomseed</code></td>
<td>
<p>randomseed</p>
</td></tr>
<tr><td><code id="survsrf_tune_single_+3A_progressbar">progressbar</code></td>
<td>
<p>FALSE(default)/TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output=list(grid, cindex, cindex_mean)
</p>

<hr>
<h2 id='survsrfens_cv'>Cross-validates predictive performance for SRF Ensemble</h2><span id='topic+survsrfens_cv'></span>

<h3>Description</h3>

<p>Cross-validates predictive performance for SRF Ensemble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survsrfens_cv(
  df,
  predict.factors,
  fixed_time = NaN,
  outer_cv = 3,
  inner_cv = 3,
  repeat_cv = 2,
  randomseed = NaN,
  return_models = FALSE,
  useCoxLasso = FALSE,
  tuningparams = list(),
  max_grid_size = 10,
  verbose = FALSE,
  suppresswarn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survsrfens_cv_+3A_df">df</code></td>
<td>
<p>data frame with the data, &quot;time&quot; and &quot;event&quot; for survival outcome</p>
</td></tr>
<tr><td><code id="survsrfens_cv_+3A_predict.factors">predict.factors</code></td>
<td>
<p>list of predictor names</p>
</td></tr>
<tr><td><code id="survsrfens_cv_+3A_fixed_time">fixed_time</code></td>
<td>
<p>at which performance metrics are computed</p>
</td></tr>
<tr><td><code id="survsrfens_cv_+3A_outer_cv">outer_cv</code></td>
<td>
<p>number of folds in outer CV, default 3</p>
</td></tr>
<tr><td><code id="survsrfens_cv_+3A_inner_cv">inner_cv</code></td>
<td>
<p>number of folds for model tuning CV, default 3</p>
</td></tr>
<tr><td><code id="survsrfens_cv_+3A_repeat_cv">repeat_cv</code></td>
<td>
<p>number of CV repeats, if NaN, runs once</p>
</td></tr>
<tr><td><code id="survsrfens_cv_+3A_randomseed">randomseed</code></td>
<td>
<p>random seed</p>
</td></tr>
<tr><td><code id="survsrfens_cv_+3A_return_models">return_models</code></td>
<td>
<p>TRUE/FALSE, if TRUE returns all trained models</p>
</td></tr>
<tr><td><code id="survsrfens_cv_+3A_usecoxlasso">useCoxLasso</code></td>
<td>
<p>TRUE/FALSE, default is FALSE</p>
</td></tr>
<tr><td><code id="survsrfens_cv_+3A_tuningparams">tuningparams</code></td>
<td>
<p>if given, list of hyperparameters, list(mtry=c(), nodedepth=c(),nodesize=c()), otherwise a wide default grid is used</p>
</td></tr>
<tr><td><code id="survsrfens_cv_+3A_max_grid_size">max_grid_size</code></td>
<td>
<p>number of random grid searches for model tuning</p>
</td></tr>
<tr><td><code id="survsrfens_cv_+3A_verbose">verbose</code></td>
<td>
<p>FALSE(default)/TRUE</p>
</td></tr>
<tr><td><code id="survsrfens_cv_+3A_suppresswarn">suppresswarn</code></td>
<td>
<p>TRUE/FALSE, TRUE by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of outputs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

df &lt;- simulate_nonlinear()
ens_cv &lt;- survsrfens_cv(df, names(df)[1:4])
summary(ens_cv)


</code></pre>

<hr>
<h2 id='survsrfens_predict'>Predicts event probability by a trained sequential ensemble of Survival Random Forest and CoxPH</h2><span id='topic+survsrfens_predict'></span>

<h3>Description</h3>

<p>Predicts event probability by a trained sequential ensemble of Survival Random Forest and CoxPH
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survsrfens_predict(trained_model, newdata, fixed_time, extrapsurvival = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survsrfens_predict_+3A_trained_model">trained_model</code></td>
<td>
<p>a trained model, output of survsrfens_train()</p>
</td></tr>
<tr><td><code id="survsrfens_predict_+3A_newdata">newdata</code></td>
<td>
<p>new data for which predictions are made</p>
</td></tr>
<tr><td><code id="survsrfens_predict_+3A_fixed_time">fixed_time</code></td>
<td>
<p>time of interest, for which event probabilities are computed</p>
</td></tr>
<tr><td><code id="survsrfens_predict_+3A_extrapsurvival">extrapsurvival</code></td>
<td>
<p>if probabilities are extrapolated beyond trained times (constant)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of predicted event probabilities
</p>

<hr>
<h2 id='survsrfens_train'>Fits an ensemble of Cox-PH and Survival Random Forest (SRF)
with internal CV to tune SRF hyperparameters.</h2><span id='topic+survsrfens_train'></span>

<h3>Description</h3>

<p>Details: the function trains Cox model, then adds its out-of-the-box
predictions to Survival Random Forest as an additional predictor
to mimic stacking procedure used in Machine Learning and reduce over-fitting.
#' Cox model is fitted to .9 data to predict the rest .1 for each 1/10s fold;
these out-of-the-bag predictions are passed on to SRF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survsrfens_train(
  df_train,
  predict.factors,
  fixed_time = NaN,
  inner_cv = 3,
  randomseed = NaN,
  tuningparams = list(),
  useCoxLasso = FALSE,
  max_grid_size = 10,
  var_importance_calc = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survsrfens_train_+3A_df_train">df_train</code></td>
<td>
<p>data, &quot;time&quot; and &quot;event&quot; should describe survival outcome</p>
</td></tr>
<tr><td><code id="survsrfens_train_+3A_predict.factors">predict.factors</code></td>
<td>
<p>list of predictor names</p>
</td></tr>
<tr><td><code id="survsrfens_train_+3A_fixed_time">fixed_time</code></td>
<td>
<p>time at which performance is maximized</p>
</td></tr>
<tr><td><code id="survsrfens_train_+3A_inner_cv">inner_cv</code></td>
<td>
<p>number of cross-validation folds for hyperparameters' tuning</p>
</td></tr>
<tr><td><code id="survsrfens_train_+3A_randomseed">randomseed</code></td>
<td>
<p>random seed to control tuning including data splits</p>
</td></tr>
<tr><td><code id="survsrfens_train_+3A_tuningparams">tuningparams</code></td>
<td>
<p>if given, list of hyperparameters, list(mtry=c(), nodedepth=c(),nodesize=c()), otherwise a wide default grid is used</p>
</td></tr>
<tr><td><code id="survsrfens_train_+3A_usecoxlasso">useCoxLasso</code></td>
<td>
<p>if CoxLasso is used (TRUE) or not (FALSE, default)</p>
</td></tr>
<tr><td><code id="survsrfens_train_+3A_max_grid_size">max_grid_size</code></td>
<td>
<p>number of random grid searches for model tuning</p>
</td></tr>
<tr><td><code id="survsrfens_train_+3A_var_importance_calc">var_importance_calc</code></td>
<td>
<p>if variable importance is computed</p>
</td></tr>
<tr><td><code id="survsrfens_train_+3A_verbose">verbose</code></td>
<td>
<p>FALSE (default)/TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>trained object of class survsrf_ens
</p>

<hr>
<h2 id='survsrfstack_cv'>Cross-validates stacked ensemble of the CoxPH and Survival Random Forest models</h2><span id='topic+survsrfstack_cv'></span>

<h3>Description</h3>

<p>Cross-validates stacked ensemble of the CoxPH and Survival Random Forest models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survsrfstack_cv(
  df,
  predict.factors,
  fixed_time = NaN,
  outer_cv = 3,
  inner_cv = 3,
  repeat_cv = 2,
  randomseed = NaN,
  return_models = FALSE,
  useCoxLasso = FALSE,
  tuningparams = list(),
  max_grid_size = 10,
  verbose = FALSE,
  suppresswarn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survsrfstack_cv_+3A_df">df</code></td>
<td>
<p>data, &quot;time&quot; and &quot;event&quot; should describe survival outcome</p>
</td></tr>
<tr><td><code id="survsrfstack_cv_+3A_predict.factors">predict.factors</code></td>
<td>
<p>list of predictor names</p>
</td></tr>
<tr><td><code id="survsrfstack_cv_+3A_fixed_time">fixed_time</code></td>
<td>
<p>time at which performance is maximized</p>
</td></tr>
<tr><td><code id="survsrfstack_cv_+3A_outer_cv">outer_cv</code></td>
<td>
<p>number of cross-validation folds for model validation</p>
</td></tr>
<tr><td><code id="survsrfstack_cv_+3A_inner_cv">inner_cv</code></td>
<td>
<p>number of cross-validation folds for hyperparameters' tuning</p>
</td></tr>
<tr><td><code id="survsrfstack_cv_+3A_repeat_cv">repeat_cv</code></td>
<td>
<p>number of CV repeats, if NaN, runs once</p>
</td></tr>
<tr><td><code id="survsrfstack_cv_+3A_randomseed">randomseed</code></td>
<td>
<p>random seed to control tuning including data splits</p>
</td></tr>
<tr><td><code id="survsrfstack_cv_+3A_return_models">return_models</code></td>
<td>
<p>TRUE/FALSE, if TRUE returns all CV objects</p>
</td></tr>
<tr><td><code id="survsrfstack_cv_+3A_usecoxlasso">useCoxLasso</code></td>
<td>
<p>if CoxLasso is used (TRUE) or not (FALSE, default)</p>
</td></tr>
<tr><td><code id="survsrfstack_cv_+3A_tuningparams">tuningparams</code></td>
<td>
<p>if given, list of hyperparameters, list(mtry=c(), nodedepth=c(),nodesize=c()), otherwise a wide default grid is used</p>
</td></tr>
<tr><td><code id="survsrfstack_cv_+3A_max_grid_size">max_grid_size</code></td>
<td>
<p>number of random grid searches for model tuning</p>
</td></tr>
<tr><td><code id="survsrfstack_cv_+3A_verbose">verbose</code></td>
<td>
<p>FALSE(default)/TRUE</p>
</td></tr>
<tr><td><code id="survsrfstack_cv_+3A_suppresswarn">suppresswarn</code></td>
<td>
<p>TRUE/FALSE, TRUE by default</p>
</td></tr>
</table>

<hr>
<h2 id='survsrfstack_predict'>Predicts event probability by a trained stacked ensemble of Survival Random Forest and CoxPH</h2><span id='topic+survsrfstack_predict'></span>

<h3>Description</h3>

<p>Predicts event probability by a trained stacked ensemble of Survival Random Forest and CoxPH
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survsrfstack_predict(
  trained_object,
  newdata,
  fixed_time,
  predict.factors,
  extrapsurvival = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survsrfstack_predict_+3A_trained_object">trained_object</code></td>
<td>
<p>a trained model, output of survsrfstack_train()</p>
</td></tr>
<tr><td><code id="survsrfstack_predict_+3A_newdata">newdata</code></td>
<td>
<p>new data for which predictions are made</p>
</td></tr>
<tr><td><code id="survsrfstack_predict_+3A_fixed_time">fixed_time</code></td>
<td>
<p>time of interest, for which event probabilities are computed</p>
</td></tr>
<tr><td><code id="survsrfstack_predict_+3A_predict.factors">predict.factors</code></td>
<td>
<p>list of predictor names</p>
</td></tr>
<tr><td><code id="survsrfstack_predict_+3A_extrapsurvival">extrapsurvival</code></td>
<td>
<p>if probabilities are extrapolated beyond trained times (constant)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of predicted event probabilities
</p>

<hr>
<h2 id='survsrfstack_train'>Trains the stacked ensemble of the CoxPH and Survival Random Forest</h2><span id='topic+survsrfstack_train'></span>

<h3>Description</h3>

<p>Trains the stacked ensemble of the CoxPH and Survival Random Forest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survsrfstack_train(
  df_train,
  predict.factors,
  fixed_time = NaN,
  inner_cv = 3,
  randomseed = NaN,
  useCoxLasso = FALSE,
  tuningparams = list(),
  max_grid_size = 10,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survsrfstack_train_+3A_df_train">df_train</code></td>
<td>
<p>data, &quot;time&quot; and &quot;event&quot; should describe survival outcome</p>
</td></tr>
<tr><td><code id="survsrfstack_train_+3A_predict.factors">predict.factors</code></td>
<td>
<p>list of predictor names</p>
</td></tr>
<tr><td><code id="survsrfstack_train_+3A_fixed_time">fixed_time</code></td>
<td>
<p>time at which performance is maximized</p>
</td></tr>
<tr><td><code id="survsrfstack_train_+3A_inner_cv">inner_cv</code></td>
<td>
<p>number of cross-validation folds for hyperparameters' tuning</p>
</td></tr>
<tr><td><code id="survsrfstack_train_+3A_randomseed">randomseed</code></td>
<td>
<p>random seed to control tuning including data splits</p>
</td></tr>
<tr><td><code id="survsrfstack_train_+3A_usecoxlasso">useCoxLasso</code></td>
<td>
<p>if CoxLasso is used (TRUE) or not (FALSE, default)</p>
</td></tr>
<tr><td><code id="survsrfstack_train_+3A_tuningparams">tuningparams</code></td>
<td>
<p>if given, list of hyperparameters, list(mtry=c(), nodedepth=c(),nodesize=c()), otherwise a wide default grid is used</p>
</td></tr>
<tr><td><code id="survsrfstack_train_+3A_max_grid_size">max_grid_size</code></td>
<td>
<p>number of random grid searches for model tuning</p>
</td></tr>
<tr><td><code id="survsrfstack_train_+3A_verbose">verbose</code></td>
<td>
<p>FALSE(default)/TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output = list(bestparams, allstats, model)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;-simulate_nonlinear(100)
p&lt;- names(d)[1:4]
tuningparams = list(
 "mtry" = c(5,10,15),
 "nodedepth" = c(5,10,15,20),
 "nodesize" =    c(20,30,50)
)
m_srf&lt;- survsrf_train(d,p,tuningparams=tuningparams)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
