<!DOCTYPE html><html lang="en"><head><title>Help for package spTDyn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spTDyn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spTDyn-package'>
<p>Spatially varying and spatio-temporal dynamic linear models</p></a></li>
<li><a href='#decay'><p>Choice for sampling spatial decay parameter <code class="reqn">\phi</code>.</p></a></li>
<li><a href='#def.time'><p>Timer series information.</p></a></li>
<li><a href='#GibbsDyn'><p>MCMC sampling for the models.</p></a></li>
<li><a href='#initials'><p>Initial values for the spatio-temporal models.</p></a></li>
<li><a href='#ObsGridLoc'><p>Combining observation and nearest grid locations and data.</p></a></li>
<li><a href='#plot.spTD'><p>Plots for spTDyn output.</p></a></li>
<li><a href='#predict.spTD'><p>Spatial and temporal predictions for the spatio-temporal models.</p></a></li>
<li><a href='#priors'><p>Priors for the spatio-temporal models.</p></a></li>
<li><a href='#sp'><p>Defining spatially varying coefficients in the formula</p></a></li>
<li><a href='#spTimerDyn-internal'><p>Service functions and some undocumented functions for the spTimer library</p></a></li>
<li><a href='#summary.spTD'><p>Summary statistics of the parameters.</p></a></li>
<li><a href='#tp'><p>Defining dynamic time-series coefficients in the formula</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatially Varying and Spatio-Temporal Dynamic Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-09</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.4.0), spTimer</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits, spatially predicts, and temporally forecasts space-time data using Gaussian Process (GP): (1) spatially varying coefficient process models and (2) spatio-temporal dynamic linear models. Bakar et al., (2016). Bakar et al., (2015).</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, sp, spacetime, grDevices, graphics, stats, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-09 01:18:27 UTC; kbak4671</td>
</tr>
<tr>
<td>Author:</td>
<td>K. Shuvo Bakar <a href="https://orcid.org/0000-0003-3215-4496"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Philip Kokic [ctb],
  Huidong Jin <a href="https://orcid.org/0000-0002-3925-0256"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>K. Shuvo Bakar &lt;shuvo.bakar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-09 19:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='spTDyn-package'>
Spatially varying and spatio-temporal dynamic linear models
</h2><span id='topic+spTDyn-package'></span><span id='topic+spTDyn'></span>

<h3>Description</h3>

<p>This package uses different hierarchical Bayesian spatio-temporal modelling strategies, namely: <br />
(1) Spatially varying coefficient process models, <br />
(2) Temporally varying coefficient process models, also known as the spatio-temporal dynamic linear models.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> spTDyn</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The back-end code of this package is built under c language.<br />
Main functions used: <br />
<code>&gt; <a href="#topic+GibbsDyn">GibbsDyn</a></code> <br />
<code>&gt; <a href="#topic+predict.spTD">predict.spTD</a></code> <br />
</p>


<h3>Author(s)</h3>

<p>K.S. Bakar <br />
Maintainer: K.S. Bakar &lt;shuvo.bakar@gmail.com&gt;
</p>


<h3>References</h3>

<p>Bakar, K. S., Kokic, P. and Jin, H. (2015). A spatio-dynamic model for assessing frost risk in south-eastern Australia. Journal of the Royal Statistical Society, Series C. DOI: 10.1111/rssc.12103 <br />
Bakar, K. S., Kokic, P. and Jin, H. (2015). Hierarchical spatially varying coefficient and temporal dynamic process models using spTDyn. Journal of Statistical Computation and Simulation. DOI:10.1080/00949655.2015.1038267
</p>


<h3>See Also</h3>

<p>Packages 'spTimer'; 'forecast'; 'spBayes'; 'maps'; 'MBA'; 'coda'; website: <code>http://www.r-project.org/</code>.
</p>

<hr>
<h2 id='decay'>Choice for sampling spatial decay parameter <code class="reqn">\phi</code>.</h2><span id='topic+decay'></span>

<h3>Description</h3>

<p>This function initialises the sampling method for the spatial decay parameter <code class="reqn">\phi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decay(distribution=Gamm(a=2,b=1), tuning=NULL, npoints=NULL, value=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decay_+3A_distribution">distribution</code></td>
<td>
<p>Prior distribution for <code class="reqn">\phi</code>. Currently available methods are, Gamm(a,b) and Unif(low,up). One can also used &quot;FIXED&quot; value for <code class="reqn">\phi</code> parameter.</p>
</td></tr>
<tr><td><code id="decay_+3A_tuning">tuning</code></td>
<td>
<p>If the Gamma prior distribution is used then we need to define the tuning parameter for sampling <code class="reqn">\phi</code>. The <code>tuning</code> is the standard deviation for the normal proposal distribution of the random-walk Metropolis algorithm used to sample <code class="reqn">\phi</code> on the log-scale.  </p>
</td></tr>
<tr><td><code id="decay_+3A_npoints">npoints</code></td>
<td>
<p>If Unif distribution is used then need to define the number of segments for the range of limits by npoints. Default value is 5.</p>
</td></tr>
<tr><td><code id="decay_+3A_value">value</code></td>
<td>
<p>If distribution=&quot;FIXED&quot; type is used then need to define the value for <code class="reqn">\phi</code>. The default value is 3/dmax where dmax is the maximum distance between the fitting sites provided by <code>coords</code>. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GibbsDyn">GibbsDyn</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 

# input for random-walk Metropolis within Gibbs 
# sampling for phi parameter
spatial.decay&lt;-decay(distribution=Gamm(2,1), tuning=0.08)

# input for discrete sampling of phi parameter 
# with uniform prior distribution
spatial.decay&lt;-decay(distribution=Unif(0.01,0.02),npoints=5)

# input for spatial decay if FIXED is used
spatial.decay&lt;-decay(distribution="FIXED", value=0.01)

##
</code></pre>

<hr>
<h2 id='def.time'>Timer series information.</h2><span id='topic+def.time'></span>

<h3>Description</h3>

<p>This function defines the time series in the spatio-temporal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>def.time(t.series, segments=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="def.time_+3A_t.series">t.series</code></td>
<td>
<p>Number of times within each segment in each series. Can take only regular time-series. </p>
</td></tr>
<tr><td><code id="def.time_+3A_segments">segments</code></td>
<td>
<p>Number of segments in each time series. This should  be a constant. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GibbsDyn">GibbsDyn</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 

# regular time-series in each year
time.data&lt;-def.time(t.series=30,segments=2)

##
</code></pre>

<hr>
<h2 id='GibbsDyn'>MCMC sampling for the models.</h2><span id='topic+GibbsDyn'></span>

<h3>Description</h3>

<p>This function is used to draw MCMC samples using the Gibbs sampler. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GibbsDyn(formula, data=parent.frame(), model="GP", time.data=NULL, coords, 
	priors=NULL, initials=NULL, nItr=5000, nBurn=1000, report=1, tol.dist=0.05, 
	distance.method="geodetic:km", cov.fnc="exponential", scale.transform="NONE", 
	spatial.decay=decay(distribution="FIXED"),truncation.para=list(at=0,lambda=2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GibbsDyn_+3A_formula">formula</code></td>
<td>
<p>The symnbolic description of the model equation of the regression part of the space-time model. The terms <a href="#topic+sp">sp</a> and <a href="#topic+tp">tp</a> are used to define spatially and temporally varying parameters for the model.</p>
</td></tr> 
<tr><td><code id="GibbsDyn_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the model. If omitted, the variables are taken from environment(formula), typically the environment from which spT.Gibbs is called. The data should be ordered first by the time and then by the sites specified by the <code>coords</code> below. One can also supply coordinates through this argument, where coordinate names should be &quot;Latitude&quot; and &quot;Longitude&quot;.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_model">model</code></td>
<td>
<p>The spatio-temporal models to be fitted, current choices are: &quot;GP&quot;, and &quot;truncated&quot;, with the first one as the default.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_time.data">time.data</code></td>
<td>
<p>Defining the segments of the time-series set up using the function <code><a href="#topic+def.time">def.time</a></code>.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_coords">coords</code></td>
<td>
<p>The n by 2 matrix or data frame defining the locations (e.g., longitude/easting, latitude/northing) of the fitting sites, where n is the number of fitting sites. One can also supply coordinates through a formula argument such as ~Longitude+Latitude.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_priors">priors</code></td>
<td>
<p>The prior distributions for the parameters. Default distributions are specified if these are not provided. If priors=NULL a flat prior distribution will be used with large variance. See details in <code><a href="#topic+priors">priors</a></code>.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_initials">initials</code></td>
<td>
<p>The preferred initial values for the parameters. If omitted, default values are provided automatically. Further  details are provided in  <code><a href="#topic+initials">initials</a></code>.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_nitr">nItr</code></td>
<td>
<p>Number of MCMC iterations. Default value is 5000.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_nburn">nBurn</code></td>
<td>
<p>Number of burn-in samples. This number of samples will be discarded before making any inference. Default value is 1000.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_report">report</code></td>
<td>
<p>Number of reports to display while running the Gibbs sampler. Defaults to number of iterations. </p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_distance.method">distance.method</code></td>
<td>
<p>The preferred method to calculate the distance between any two locations. The available options are &quot;geodetic:km&quot;, &quot;geodetic:mile&quot;, &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, and &quot;canberra&quot;. See details in <code><a href="stats.html#topic+dist">dist</a></code>. The default is &quot;geodetic:km&quot;.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_tol.dist">tol.dist</code></td>
<td>
<p>Minimum separation distance between any two locations out of those  specified by coords, knots.coords and pred.coords. The default is 0.005. The programme will exit if the minimum distance is less than the non-zero specified value. This will ensure non-singularity of the covariance matrices.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_cov.fnc">cov.fnc</code></td>
<td>
<p>Covariance function for the spatial effects. The available options  are &quot;exponential&quot;, &quot;gaussian&quot;, &quot;spherical&quot; and &quot;matern&quot;. If &quot;matern&quot; is used then by default the smooth parameter (<code class="reqn">\nu</code>) is estimated from (0,1) uniform distribution using discrete samples.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_scale.transform">scale.transform</code></td>
<td>
<p>The transformation method for the response variable. Currently implemented options are: &quot;NONE&quot;, &quot;SQRT&quot;, and &quot;LOG&quot; with  &quot;NONE&quot; as the deault.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_spatial.decay">spatial.decay</code></td>
<td>
<p>Provides the prior distribution for the spatial decay parameter <code class="reqn">\phi</code>. Currently implemented options  are  &quot;FIXED&quot;, &quot;Unif&quot;, or &quot;Gamm&quot;.  Further details for each of these are specified by <code><a href="#topic+decay">decay</a></code>.</p>
</td></tr>
<tr><td><code id="GibbsDyn_+3A_truncation.para">truncation.para</code></td>
<td>
<p>Provides truncation parameter <code class="reqn">\lambda</code> and truncation point &quot;at&quot; using list.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>accept</code></td>
<td>
<p>The acceptance rate for the <code class="reqn">\phi</code> parameter if the &quot;MH&quot; method of sampling is chosen.</p>
</td></tr>
<tr><td><code>phip</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code>nup</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\nu</code>. Only available if &quot;matern&quot; covariance function is used.</p>
</td></tr>
<tr><td><code>sig2eps</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\sigma^2_\epsilon</code>.</p>
</td></tr>
<tr><td><code>sig2etap</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\sigma^2_\eta</code>.</p>
</td></tr>
<tr><td><code>sig2betap</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\sigma^2_\beta</code>, only applicable for spatially varying coefficient process model.</p>
</td></tr>
<tr><td><code>sig2deltap</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\sigma^2_\delta</code>, for  <code class="reqn">\beta_j</code>, <code class="reqn">j=1,...,u</code>. Only applicable for spatio-temporal DLM.</p>
</td></tr>
<tr><td><code>sig2op</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\sigma^2_o</code>, for  initial variance of <code class="reqn">\beta_0</code>. Only applicable for spatio-dynamic and spatio-temporal DLM.</p>
</td></tr>
<tr><td><code>betap</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>rhop</code></td>
<td>
<p>MCMC samples for <code class="reqn">\rho</code>.</p>
</td></tr>
<tr><td><code>op</code></td>
<td>
<p>MCMC samples for the true observations.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>MCMC summary (mean and sd) for the fitted values.</p>
</td></tr>
<tr><td><code>tol.dist</code></td>
<td>
<p>Minimum tolerance distance limit between the locations.</p>
</td></tr>
<tr><td><code>distance.method</code></td>
<td>
<p>Name of the distance calculation method.</p>
</td></tr>
<tr><td><code>cov.fnc</code></td>
<td>
<p>Name of the covariance function used in model fitting.</p>
</td></tr>
<tr><td><code>scale.transform</code></td>
<td>
<p>Name of the scale.transformation method.</p>
</td></tr>
<tr><td><code>sampling.sp.decay</code></td>
<td>
<p>The method of sampling for the spatial decay parameter <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code>covariate.names</code></td>
<td>
<p>Name of the covariates used in the model.</p>
</td></tr>
<tr><td><code>Distance.matrix</code></td>
<td>
<p>The distance matrix.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>The coordinate values.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Total number of sites.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Total number of segments in time, e.g., years.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Total points of time, e.g., days within each year.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Total number of model coefficients, i.e., <code class="reqn">\beta</code>'s including the intercept.</p>
</td></tr>
<tr><td><code>initials</code></td>
<td>
<p>The initial values used in the model.</p>
</td></tr>
<tr><td><code>priors</code></td>
<td>
<p>The prior distributions used in the model.</p>
</td></tr>
<tr><td><code>PMCC</code></td>
<td>
<p>The predictive model choice criteria obtained by minimising the expected value of a loss function, see Gelfand and Ghosh (1998). Results for both goodness of fit and penalty are given.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>The number of samples for the MCMC chain, without burn-in.</p>
</td></tr>
<tr><td><code>nBurn</code></td>
<td>
<p>The number of burn-in period for the MCMC chain.</p>
</td></tr>
<tr><td><code>computation.time</code></td>
<td>
<p>The computation time required for the fitted model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bakar, K. S., Kokic, P. and Jin, H. (2015). A spatio-dynamic model for assessing frost risk in south-eastern Australia. Journal of the Royal Statistical Society, Series C.
Bakar, K. S., Kokic, P. and Jin, H. (2015). Hierarchical spatially varying coefficient and temporal dynamic process models using spTDyn. Journal of Statistical Computation and Simulation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+priors">priors</a>, <a href="#topic+initials">initials</a>, <a href="stats.html#topic+dist">dist</a>, <a href="#topic+sp">sp</a>, <a href="#topic+tp">tp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##

###########################
## Attach library spTDyn
###########################

library(spTDyn)

## Read Aus data ##
data(AUSdata)
# set a side data for validation
library(spTimer)
s&lt;-c(1,4,10)
AUSdataFit&lt;-spT.subset(data=AUSdata, var.name=c("s.index"), s=s, reverse=TRUE)
AUSdataFit&lt;-subset(AUSdataFit, with(AUSdataFit, !(year == 2009)))
AUSdataPred&lt;-spT.subset(data=AUSdata, var.name=c("s.index"), s=s)
AUSdataPred&lt;-subset(AUSdataPred, with(AUSdataPred, !(year == 2009)))
AUSdataFore&lt;-spT.subset(data=AUSdata, var.name=c("s.index"), s=s)
AUSdataFore&lt;-subset(AUSdataFore, with(AUSdataFore, (year == 2009)))

## Read NY data ##
data(NYdata)
# set a side data for validation
s&lt;-c(5,8,10,15,20,22,24,26)
fday&lt;-c(25:31)
NYdataFit&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE)
NYdataFit&lt;-subset(NYdataFit, with(NYdataFit, !(Day %in% fday &amp; Month == 8)))
NYdataPred&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s)
NYdataPred&lt;-subset(NYdataPred, with(NYdataPred, !(Day %in% fday &amp; Month == 8)))
NYdataFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s)
NYdataFore&lt;-subset(NYdataFore, with(NYdataFore, (Day %in% fday &amp; Month == 8)))

## Code for analysing temperature data in Section: 4 ##
## Model: Spatially varying coefficient process models ##

nItr&lt;-13000
nBurn&lt;-3000

# MCMC via Gibbs using defaults
# Spatially varying coefficient process model

library("spTDyn", warn.conflicts = FALSE)
set.seed(11)
post.sp &lt;- GibbsDyn(tmax ~ soi+sp(soi)+grid+sp(grid),
           data=AUSdataFit, nItr=nItr, nBurn=nBurn, coords=~lon+lat,
           spatial.decay=decay(distribution=Gamm(2,1),tuning=0.06))
print(post.sp)

## Table: 3, Section: 4.1 ##
post.sp$PMCC

# parameter summary
summary(post.sp) # without spatially varying coefficients
summary(post.sp, coefficient="spatial")

#plot(post.sp, density=FALSE)  # without spatially varying coefficients
#plot(post.sp, coefficient="spatial", density=FALSE)

## Code for Figures: 3(a), 3(b) Section: 4.1 ##
Figure_3a&lt;-function(){
  boxplot(t(post.sp$betasp[1:9,]),pch=".",main="SOI",
          xlab="Sites",ylab="Values")
}
Figure_3b&lt;-function(){
  boxplot(t(post.sp$betasp[10:18,]),pch=".",main="Grid",
          xlab="Sites",ylab="Values")
}
Figure_3a()
Figure_3b()

## spatial prediction
set.seed(11)
pred.sp &lt;- predict(post.sp,newcoords=~lon+lat,newdata=AUSdataPred)

## Table: 4, Section: 4.1, validations ##
spT.validation(AUSdataPred$tmax,c(pred.sp$Mean))
plot(AUSdataPred$tmax,c(pred.sp$Mean))

## temporal prediction
set.seed(11)
pred.sp.f &lt;- predict(post.sp,type="temporal",foreStep=12,
                     newcoords=~lon+lat, newdata=AUSdataFore)

## Table: 4, Section: 4.1, validations ##
spT.validation(AUSdataFore$tmax,c(pred.sp.f$Mean))
plot(AUSdataFore$tmax,c(pred.sp.f$Mean))

## Code for analysing Ozone data in Section: 4 ##
## Model: spatio-temporal DLM ##

# MCMC via Gibbs using defaults
# spatio-temporal DLM

library("spTDyn", warn.conflicts = FALSE)
set.seed(11)
post.tp &lt;- GibbsDyn(o8hrmax ~ tp(cMAXTMP)-1, data=NYdataFit,
           nItr=nItr, nBurn=nBurn, coords=~Longitude+Latitude,
           initials=initials(rhotp=0), scale.transform="SQRT",
           spatial.decay=decay(distribution=Gamm(2,1),tuning=0.05))
print(post.tp)
summary(post.tp)

## Table: 5, Section: 4.2 ##
post.tp$PMCC

## Figure: 5, Section: 4.2 ##
Figure_5&lt;-function(){
  stat&lt;-apply(post.tp$betatp[1:55,],1,quantile,prob=c(0.025,0.5,0.975))
  plot(stat[2,],type="p",lty=3,col=1,ylim=c(min(c(stat)),max(c(stat))),
       pch=19,ylab="",xlab="Days",axes=FALSE,main="cMAXTMP",cex=0.8)
  for(i in 1:55){
    segments(i, stat[2,i], i, stat[3,i])
    segments(i, stat[2,i], i, stat[1,i])
  }
  axis(1,1:55,labels=1:55);axis(2)
  abline(v=31.5,lty=2)
  text(15,0.32,"July");  text(45,0.32,"August");
}
Figure_5()

## spatial prediction
set.seed(11)
pred.tp &lt;- predict(post.tp, newdata=NYdataPred, newcoords=~Longitude+Latitude)

## Table 6, Section: 4.2, validation ##
spT.validation(NYdataPred$o8hrmax,c(pred.tp$Mean))

## temporal prediction
set.seed(11)
pred.tp.f &lt;- predict(post.tp, newdata=NYdataFore, newcoords=~Longitude+Latitude,
                     type="temporal", foreStep=7)

## Table 6, Section: 4.2, validation ##
spT.validation(NYdataFore$o8hrmax,c(pred.tp.f$Mean))

######################################################
## The Truncated/Censored models:
######################################################

## Read Aus data ##
data(AUSdata)
# set the truncation point at tmax=30
AUSdata$tmax &lt;- replace(AUSdata$tmax, AUSdata$tmax&lt;=30, 30)

# set a side data for validation
library(spTimer)
s&lt;-c(1,4,10)
AUSdataFit&lt;-spT.subset(data=AUSdata, var.name=c("s.index"), s=s, reverse=TRUE)
AUSdataFit&lt;-subset(AUSdataFit, with(AUSdataFit, !(year == 2009)))
AUSdataPred&lt;-spT.subset(data=AUSdata, var.name=c("s.index"), s=s)
AUSdataPred&lt;-subset(AUSdataPred, with(AUSdataPred, !(year == 2009)))
AUSdataFore&lt;-spT.subset(data=AUSdata, var.name=c("s.index"), s=s)
AUSdataFore&lt;-subset(AUSdataFore, with(AUSdataFore, (year == 2009)))

#
nItr &lt;- 5000 # number of MCMC samples for each model
nBurn &lt;- 1000 # number of burn-in from the MCMC samples
# Truncation at 30 
# fit truncated spatially varying model 

## The Truncated/Censored spatially varying models:
library("spTDyn", warn.conflicts = FALSE)
set.seed(11)
out &lt;- GibbsDyn(tmax ~ soi+sp(soi)+grid+sp(grid),model="truncated",
           data=AUSdataFit, nItr=nItr, nBurn=nBurn, coords=~lon+lat,
           spatial.decay=decay(distribution=Gamm(2,1),tuning=0.06),
           truncation.para = list(at = 30,lambda = 2))
print(out)
summary(out)
head(fitted(out))
plot(out,density=FALSE)
#
head(cbind(AUSdataFit$tmax,fitted(out)[,1]))
plot(AUSdataFit$tmax,fitted(out)[,1])
spT.validation(AUSdataFit$tmax,fitted(out)[,1])

## spatial prediction
set.seed(11)
pred.sp &lt;- predict(out,newcoords=~lon+lat,newdata=AUSdataPred)
spT.validation(AUSdataPred$tmax,c(pred.sp$Mean))
plot(AUSdataPred$tmax,c(pred.sp$Mean))

## temporal prediction
set.seed(11)
pred.sp.f &lt;- predict(out,type="temporal",foreStep=12,
                     newcoords=~lon+lat, newdata=AUSdataFore)
spT.validation(AUSdataFore$tmax,c(pred.sp.f$Mean))
plot(AUSdataFore$tmax,c(pred.sp.f$Mean))

## The Truncated/Censored temporal dynamic DLM models:
library("spTDyn", warn.conflicts = FALSE)
set.seed(11)
out &lt;- GibbsDyn(tmax ~ soi+tp(soi)+grid,model="truncated",
           data=AUSdataFit, nItr=nItr, nBurn=nBurn, coords=~lon+lat,
           spatial.decay=decay(distribution=Gamm(2,1),tuning=0.06),
           truncation.para = list(at = 30,lambda = 2))
print(out)
summary(out)
head(fitted(out))
plot(out,density=FALSE)
#
head(cbind(AUSdataFit$tmax,fitted(out)[,1]))
plot(AUSdataFit$tmax,fitted(out)[,1])
spT.validation(AUSdataFit$tmax,fitted(out)[,1])

## spatial prediction
set.seed(11)
pred.tp &lt;- predict(out,newcoords=~lon+lat,newdata=AUSdataPred)
spT.validation(AUSdataPred$tmax,c(pred.tp$Mean))
plot(AUSdataPred$tmax,c(pred.tp$Mean))

## temporal prediction
set.seed(11)
pred.tp.f &lt;- predict(out,type="temporal",foreStep=12,
                     newcoords=~lon+lat, newdata=AUSdataFore)
spT.validation(AUSdataFore$tmax,c(pred.tp.f$Mean))
plot(AUSdataFore$tmax,c(pred.tp.f$Mean))


##############################################################################


</code></pre>

<hr>
<h2 id='initials'>Initial values for the spatio-temporal models.</h2><span id='topic+initials'></span>

<h3>Description</h3>

<p>This command is useful to assign the initial values of the hyper-parameters of the prior distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initials(sig2eps=0.01, sig2eta=NULL, sig2beta=NULL, sig2delta=NULL,
   rhotp=NULL, rho=NULL, beta=NULL, phi=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initials_+3A_sig2eps">sig2eps</code></td>
<td>
<p>Initial value for the parameter <code class="reqn">\sigma</code>^2_<code class="reqn">\epsilon</code>.</p>
</td></tr>
<tr><td><code id="initials_+3A_sig2eta">sig2eta</code></td>
<td>
<p>Initial value for the parameter <code class="reqn">\sigma</code>^2_<code class="reqn">\eta</code>.</p>
</td></tr>
<tr><td><code id="initials_+3A_sig2beta">sig2beta</code></td>
<td>
<p>Initial value for the parameter <code class="reqn">\sigma</code>^2_<code class="reqn">\beta</code> for spatially varying model.</p>
</td></tr>
<tr><td><code id="initials_+3A_sig2delta">sig2delta</code></td>
<td>
<p>Initial value for the parameter <code class="reqn">\sigma</code>^2_<code class="reqn">\delta</code> for dynamic state-space model.</p>
</td></tr>
<tr><td><code id="initials_+3A_rhotp">rhotp</code></td>
<td>
<p>Value for the parameter <code class="reqn">\rho</code> for dynamic state-space model. For <code>rhotp=1</code>, <code class="reqn">\rho</code> parameters are not sampled and fixed at value 1. For <code>rhotp=0</code>, <code class="reqn">\rho</code> parameters are sampled from the full conditional distribution via MCMC with initial value 0.</p>
</td></tr>
<tr><td><code id="initials_+3A_rho">rho</code></td>
<td>
<p>Initial value for the parameter <code class="reqn">\rho</code>.</p>
</td></tr>
<tr><td><code id="initials_+3A_beta">beta</code></td>
<td>
<p>Initial value for the parameter <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="initials_+3A_phi">phi</code></td>
<td>
<p>Initial value for the parameter <code class="reqn">\phi</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Initial values are automatically given if the user does not provide these. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GibbsDyn">GibbsDyn</a>, <a href="#topic+priors">priors</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 

initials&lt;-initials(sig2eps=0.01, sig2eta=0.5, beta=NULL, phi=0.001)
initials

##
</code></pre>

<hr>
<h2 id='ObsGridLoc'>Combining observation and nearest grid locations and data.</h2><span id='topic+ObsGridLoc'></span><span id='topic+gridTodata'></span><span id='topic+ObsGridData'></span>

<h3>Description</h3>

<p>These commands combine observation and nearest grid locations, data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ObsGridLoc(obsLoc, gridLoc, distance.method="geodetic:km", plot=FALSE)
gridTodata(gridData, gridLoc=NULL, gridLon=NULL, gridLat=NULL)
ObsGridData(obsData, gridData, obsLoc, gridLoc, distance.method="geodetic:km")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ObsGridLoc_+3A_obsloc">obsLoc</code></td>
<td>
<p>The observed/measurement locations, first column is longitude/easting/x-axis and second column is latitude/northing/y-axis.</p>
</td></tr>
<tr><td><code id="ObsGridLoc_+3A_gridloc">gridLoc</code></td>
<td>
<p>Grid locations, first column is longitude/easting/x-axis and second column is latitude/northing/y-axis.</p>
</td></tr>
<tr><td><code id="ObsGridLoc_+3A_distance.method">distance.method</code></td>
<td>
<p>The preferred method to calculate the distance between any two locations. The available options are &quot;geodetic:km&quot;, &quot;geodetic:mile&quot;, &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, and &quot;canberra&quot;. See details in <code><a href="stats.html#topic+dist">dist</a></code>.</p>
</td></tr>
<tr><td><code id="ObsGridLoc_+3A_plot">plot</code></td>
<td>
<p>Logical argument, if TRUE then plot observed and nearest grid locations.</p>
</td></tr>
<tr><td><code id="ObsGridLoc_+3A_griddata">gridData</code></td>
<td>
<p>Gridded data, should be in array form with dimenstions as longitude/x-axis, latitude/y-axis, day/time1, year/time2.</p>
</td></tr>
<tr><td><code id="ObsGridLoc_+3A_gridlon">gridLon</code></td>
<td>
<p>Longitude/easting/x-axis of grid locations.</p>
</td></tr>
<tr><td><code id="ObsGridLoc_+3A_gridlat">gridLat</code></td>
<td>
<p>Latitude/northing/y-axis of grid locations.</p>
</td></tr>
<tr><td><code id="ObsGridLoc_+3A_obsdata">obsData</code></td>
<td>
<p>Observation data in data frame.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##

library(spTimer)
data(NYdata)	
data(NYgrid)

obsLoc&lt;-unique(cbind(NYdata$Longitude,NYdata$Latitude))
gridLoc&lt;-unique(cbind(NYgrid$Longitude,NYgrid$Latitude))

# find closest observed and grid locations
dat&lt;-ObsGridLoc(obsLoc, gridLoc)
head(dat)
# with plots
dat&lt;-ObsGridLoc(obsLoc, gridLoc, plot=TRUE)
head(dat)

# convert array gridData to spTimer data format
gridData&lt;-array(1:(10*10*31*2),dim=c(10,10,31,2)) # lon, lat, day, year
dat&lt;-gridTodata(gridData, gridLoc)
head(dat)

# combine observed and grid data and locations
obsData&lt;-NYdata
gridData&lt;-array(1:(10*10*31*2),dim=c(10,10,31,2)) # lon, lat, day, year
dat&lt;-ObsGridData(obsData, gridData, obsLoc, gridLoc)
head(dat)

# combine observed and more than one grid datasets
obsData&lt;-NYdata
gridData1&lt;-array(1:(10*10*31*2),dim=c(10,10,31,2)) # lon, lat, day, year
gridData2&lt;-array(((10*10*31*2)+1):(2*(10*10*31*2)),dim=c(10,10,31,2)) # lon, lat, day, year
gridLoc1&lt;-unique(cbind(NYgrid$Longitude,NYgrid$Latitude))
gridLoc2&lt;-unique(cbind(NYgrid$Longitude,NYgrid$Latitude))
dat&lt;-ObsGridData(obsData, gridData=list(gridData1,gridData2),
        obsLoc, gridLoc=list(gridLoc1, gridLoc2))
head(dat)

##
</code></pre>

<hr>
<h2 id='plot.spTD'>Plots for spTDyn output.</h2><span id='topic+plot.spTD'></span>

<h3>Description</h3>

<p>This function is used to obtain MCMC summary, residual and fitted surface plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spTD'
plot(x, residuals=FALSE, coefficient=NULL, ...)

## 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.spTD_+3A_x">x</code></td>
<td>
<p>Object of class inheriting from &quot;spTD&quot;.</p>
</td></tr>
<tr><td><code id="plot.spTD_+3A_residuals">residuals</code></td>
<td>
<p>If TRUE then plot residual vs. fitted and normal qqplot of the residuals. If FALSE then plot MCMC samples of the parameters using coda package. Defaults value is FALSE.</p>
</td></tr>
<tr><td><code id="plot.spTD_+3A_coefficient">coefficient</code></td>
<td>
<p>Takes values: &quot;spatial&quot;, &quot;temporal&quot; and &quot;rho&quot; for summary statistics of spatial, temporal and rho coefficients respectively. If NULL then provides parameter plots without spatial and temporal coefficients.</p>
</td></tr>
<tr><td><code id="plot.spTD_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GibbsDyn">GibbsDyn</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##

plot(out) # where out is the output from spT class
plot(out, residuals=TRUE) # where out is the output from spT class
plot(out, coefficient="spatial") # for spatially varying coefficients

##

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.spTD'>Spatial and temporal predictions for the spatio-temporal models.</h2><span id='topic+predict.spTD'></span>

<h3>Description</h3>

<p>This function is used to obtain spatial predictions in the unknown locations and also to get the temporal forecasts using MCMC samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spTD'
predict(object, newdata, newcoords, foreStep=NULL, type="spatial", 
        nBurn, tol.dist, Summary=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.spTD_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;spTD&quot;.</p>
</td></tr>
<tr><td><code id="predict.spTD_+3A_newdata">newdata</code></td>
<td>
<p>The data set providing the covariate values for spatial prediction or temporal forecasts. This data should have the same space-time structure as the original data frame.</p>
</td></tr>
<tr><td><code id="predict.spTD_+3A_newcoords">newcoords</code></td>
<td>
<p>The coordinates for the prediction or forecast sites. The locations are in similar format to <code>coords</code>, see <code><a href="#topic+spT.Gibbs">spT.Gibbs</a></code>.</p>
</td></tr>
<tr><td><code id="predict.spTD_+3A_forestep">foreStep</code></td>
<td>
<p>Number of K-step (time points) ahead forecast, K=1,2, ...; Only applicable if type=&quot;temporal&quot;.</p>
</td></tr>
<tr><td><code id="predict.spTD_+3A_type">type</code></td>
<td>
<p>If the value is &quot;spatial&quot; then only spatial prediction will be performed at the <code>newcoords</code> which must be different from the fitted sites provided by <code>coords</code>.  When the &quot;temporal&quot; option is specified then forecasting will be performed  and in this case the <code>newcoords</code> may also contain elements of the fitted sites in which case only temporal forecasting beyond the last fitted time point will be performed. </p>
</td></tr> 
<tr><td><code id="predict.spTD_+3A_nburn">nBurn</code></td>
<td>
<p>Number of burn-in. Initial MCMC samples to discard before making inference.</p>
</td></tr>
<tr><td><code id="predict.spTD_+3A_tol.dist">tol.dist</code></td>
<td>
<p>Minimum tolerance distance limit between fitted and predicted locations.</p>
</td></tr>
<tr><td><code id="predict.spTD_+3A_summary">Summary</code></td>
<td>
<p>To obtain summary statistics for the posterior predicted MCMC samples. Default is TRUE.</p>
</td></tr>
<tr><td><code id="predict.spTD_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pred.samples or fore.samples</code></td>
<td>
<p>Prediction or forecast MCMC samples.</p>
</td></tr>
<tr><td><code>pred.coords or fore.coords</code></td>
<td>
<p>prediction or forecast coordinates.</p>
</td></tr>
<tr><td><code>Mean</code></td>
<td>
<p>Average of the MCMC predictions</p>
</td></tr>
<tr><td><code>Median</code></td>
<td>
<p>Median of the MCMC predictions</p>
</td></tr>
<tr><td><code>SD</code></td>
<td>
<p>Standard deviation of the MCMC predictions</p>
</td></tr>
<tr><td><code>Low</code></td>
<td>
<p>Lower limit for the 95 percent CI of the MCMC predictions</p>
</td></tr>
<tr><td><code>Up</code></td>
<td>
<p>Upper limit for the 95 percent CI of the MCMC predictions</p>
</td></tr>
<tr><td><code>computation.time</code></td>
<td>
<p>The computation time.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model method used for prediction.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>&quot;spatial&quot; or &quot;temporal&quot;.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Other values &quot;obsData&quot;, &quot;fittedData&quot; and &quot;residuals&quot; are provided only for temporal prediction.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bakar, K. S., Kokic, P. and Jin, H. (2015). A spatio-dynamic model for assessing frost risk in south-eastern Australia. Journal of the Royal Statistical Society, Series C.
Bakar, K. S., Kokic, P. and Jin, H. (2015). Hierarchical spatially varying coefficient and temporal dynamic process models using spTDyn. Journal of Statistical Computation and Simulation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GibbsDyn">GibbsDyn</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##

library(spTDyn)

## Read Aus data ##
data(AUSdata)
# set a side data for validation
s&lt;-c(1,4,10)
AUSdataFit&lt;-spT.subset(data=AUSdata, var.name=c("s.index"), s=s, reverse=TRUE)
AUSdataFit&lt;-subset(AUSdataFit, with(AUSdataFit, !(year == 2009)))
AUSdataPred&lt;-spT.subset(data=AUSdata, var.name=c("s.index"), s=s)
AUSdataPred&lt;-subset(AUSdataPred, with(AUSdataPred, !(year == 2009)))
AUSdataFore&lt;-spT.subset(data=AUSdata, var.name=c("s.index"), s=s)
AUSdataFore&lt;-subset(AUSdataFore, with(AUSdataFore, (year == 2009)))

## Read NY data ##
data(NYdata)
# set a side data for validation
s&lt;-c(5,8,10,15,20,22,24,26)
fday&lt;-c(25:31)
NYdataFit&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE)
NYdataFit&lt;-subset(NYdataFit, with(NYdataFit, !(Day %in% fday &amp; Month == 8)))
NYdataPred&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s)
NYdataPred&lt;-subset(NYdataPred, with(NYdataPred, !(Day %in% fday &amp; Month == 8)))
NYdataFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s)
NYdataFore&lt;-subset(NYdataFore, with(NYdataFore, (Day %in% fday &amp; Month == 8)))

## Code for analysing temperature data in Section: 4 ##
## Model: Spatially varying coefficient process models ##

nItr&lt;-13000
nBurn&lt;-3000

# MCMC via Gibbs using defaults
# Spatially varying coefficient process model

library("spTDyn", warn.conflicts = FALSE)
set.seed(11)
post.sp &lt;- GibbsDyn(tmax ~ soi+sp(soi)+grid+sp(grid),
           data=AUSdataFit, nItr=nItr, nBurn=nBurn, coords=~lon+lat,
           spatial.decay=decay(distribution=Gamm(2,1),tuning=0.06))
print(post.sp)

## Table: 3, Section: 4.1 ##
post.sp$PMCC

# parameter summary
summary(post.sp) # without spatially varying coefficients
summary(post.sp, coefficient="spatial")

#plot(post.sp, density=FALSE)  # without spatially varying coefficients
#plot(post.sp, coefficient="spatial", density=FALSE)

## Code for Figures: 3(a), 3(b) Section: 4.1 ##
Figure_3a&lt;-function(){
  boxplot(t(post.sp$betasp[1:9,]),pch=".",main="SOI",
          xlab="Sites",ylab="Values")
}
Figure_3b&lt;-function(){
  boxplot(t(post.sp$betasp[10:18,]),pch=".",main="Grid",
          xlab="Sites",ylab="Values")
}
Figure_3a()
Figure_3b()

## spatial prediction
set.seed(11)
pred.sp &lt;- predict(post.sp,newcoords=~lon+lat,newdata=AUSdataPred)

## Table: 4, Section: 4.1, validations ##
spT.validation(AUSdataPred$tmax,c(pred.sp$Mean))
plot(AUSdataPred$tmax,c(pred.sp$Mean))

## temporal prediction
set.seed(11)
pred.sp.f &lt;- predict(post.sp,type="temporal",foreStep=12,
                     newcoords=~lon+lat, newdata=AUSdataFore)

## Table: 4, Section: 4.1, validations ##
spT.validation(AUSdataFore$tmax,c(pred.sp.f$Mean))
plot(AUSdataFore$tmax,c(pred.sp.f$Mean))

## Code for analysing Ozone data in Section: 4 ##
## Model: spatio-temporal DLM ##

# MCMC via Gibbs using defaults
# spatio-temporal DLM

library("spTDyn", warn.conflicts = FALSE)
set.seed(11)
post.tp &lt;- GibbsDyn(o8hrmax ~ tp(cMAXTMP)-1, data=NYdataFit,
           nItr=nItr, nBurn=nBurn, coords=~Longitude+Latitude,
           initials=initials(rhotp=0), scale.transform="SQRT",
           spatial.decay=decay(distribution=Gamm(2,1),tuning=0.05))
print(post.tp)
summary(post.tp)

## Table: 5, Section: 4.2 ##
post.tp$PMCC

## Figure: 5, Section: 4.2 ##
Figure_5&lt;-function(){
  stat&lt;-apply(post.tp$betatp[1:55,],1,quantile,prob=c(0.025,0.5,0.975))
  plot(stat[2,],type="p",lty=3,col=1,ylim=c(min(c(stat)),max(c(stat))),
       pch=19,ylab="",xlab="Days",axes=FALSE,main="cMAXTMP",cex=0.8)
  for(i in 1:55){
    segments(i, stat[2,i], i, stat[3,i])
    segments(i, stat[2,i], i, stat[1,i])
  }
  axis(1,1:55,labels=1:55);axis(2)
  abline(v=31.5,lty=2)
  text(15,0.32,"July");  text(45,0.32,"August");
}
Figure_5()

## spatial prediction
set.seed(11)
pred.tp &lt;- predict(post.tp, newdata=NYdataPred, newcoords=~Longitude+Latitude)

## Table 6, Section: 4.2, validation ##
spT.validation(NYdataPred$o8hrmax,c(pred.tp$Mean))

## temporal prediction
set.seed(11)
pred.tp.f &lt;- predict(post.tp, newdata=NYdataFore, newcoords=~Longitude+Latitude,
                     type="temporal", foreStep=7)

## Table 6, Section: 4.2, validation ##
spT.validation(NYdataFore$o8hrmax,c(pred.tp.f$Mean))

##############################################################################

</code></pre>

<hr>
<h2 id='priors'>Priors for the spatio-temporal models.</h2><span id='topic+priors'></span>

<h3>Description</h3>

<p>This command is useful to assign the hyper-parameters of the prior distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priors(inv.var.prior=Gamm(a=2,b=1),beta.prior=Norm(0,10^10), 
  rho.prior=Norm(0,10^10))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="priors_+3A_inv.var.prior">inv.var.prior</code></td>
<td>
<p>The hyper-parameter for the Gamma prior distribution (with mean = a/b) of the precision (inverse variance) model parameters (e.g., 1/<code class="reqn">\sigma</code>2_<code class="reqn">\epsilon</code>, 1/<code class="reqn">\sigma</code>2_<code class="reqn">\eta</code>).</p>
</td></tr>
<tr><td><code id="priors_+3A_beta.prior">beta.prior</code></td>
<td>
<p>The hyper-parameter for the Normal prior distribution of the <code class="reqn">\beta</code> model parameters.</p>
</td></tr>
<tr><td><code id="priors_+3A_rho.prior">rho.prior</code></td>
<td>
<p>The hyper-parameter for the Normal prior distribution of the <code class="reqn">\rho</code> model parameter.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If no prior information are given (assigned as NULL), then it use flat prior values of the corresponding distributions. <br />
<code>Gam</code> and <code>Nor</code> refers to Gamma and Normal distributions respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GibbsDyn">GibbsDyn</a>, <a href="#topic+initials">initials</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 
library(spTimer)
priors&lt;-priors(inv.var.prior=Gamm(2,1), beta.prior=Norm(0,10^4))
priors

##
</code></pre>

<hr>
<h2 id='sp'>Defining spatially varying coefficients in the formula</h2><span id='topic+sp'></span>

<h3>Description</h3>

<p>This function is used to define spatially varying coefficients within the formula for the Gaussian process spatio-dynamic and spatially varying coefficient process models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sp_+3A_x">x</code></td>
<td>
<p>The variable/covariate for which spatially varying coefficient is defined.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GibbsDyn">GibbsDyn</a>, <a href="#topic+tp">tp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##

###########################
## Attach library spTimer
###########################

library(spTDyn)

###########################
## The GP models:
###########################

##
## Model fitting
##

# Read data 
data(NYdata); 

# Define the coordinates
coords&lt;-as.matrix(unique(cbind(NYdata[,2:3])))

# MCMC via Gibbs using default choices
set.seed(11)
post.gp &lt;- GibbsDyn(formula=o8hrmax ~cMAXTMP+WDSP+sp(RH),   
         data=NYdata, coords=coords, scale.transform="SQRT")
print(post.gp)


</code></pre>

<hr>
<h2 id='spTimerDyn-internal'>Service functions and some undocumented functions for the spTimer library</h2><span id='topic+.First.lib'></span><span id='topic+.onLoad'></span><span id='topic+.onAttach'></span><span id='topic+stat.sum'></span><span id='topic+Formula.matrix'></span><span id='topic+Formula.coords'></span><span id='topic+Gamm'></span><span id='topic+Norm'></span><span id='topic+Unif'></span><span id='topic+PMCC'></span><span id='topic+fnc.time'></span><span id='topic+initials.checking.ar'></span><span id='topic+initials.checking.gp'></span><span id='topic+initials.checking.gpp'></span><span id='topic+print.spTD'></span><span id='topic+print.spTpred'></span><span id='topic+print.spTprd'></span><span id='topic+print.spTfore'></span><span id='topic+priors.checking.ar'></span><span id='topic+priors.checking.gp'></span><span id='topic+priors.checking.gpp'></span><span id='topic+spAR.Gibbs'></span><span id='topic+spAR.MCMC.Pred'></span><span id='topic+spAR.forecast'></span><span id='topic+spAR.prediction'></span><span id='topic+spGP.Gibbs'></span><span id='topic+spGP.MCMC.Pred'></span><span id='topic+spGP.forecast'></span><span id='topic+spGP.prediction'></span><span id='topic+spGPP.Gibbs'></span><span id='topic+spGPP.MCMC.Pred'></span><span id='topic+spGPP.forecast'></span><span id='topic+spGPP.prediction'></span><span id='topic+spT.Gibbs'></span><span id='topic+spT.priors'></span><span id='topic+spT.initials'></span><span id='topic+spT.decay'></span><span id='topic+spT.fit.pred'></span><span id='topic+spT.hit.false'></span><span id='topic+spT.forecast'></span><span id='topic+spT.prediction'></span><span id='topic+spT.Summary.Stat'></span><span id='topic+spT.MCMC.plot'></span><span id='topic+spT.MCMC.stat'></span><span id='topic+as.mcmc.spTD'></span><span id='topic+MCMC.plot.obj'></span><span id='topic+coef.spTD'></span><span id='topic+model.frame.spT'></span><span id='topic+residuals.spTD'></span><span id='topic+formula.spT'></span><span id='topic+terms.spT'></span><span id='topic+model.matrix.spT'></span><span id='topic+sp.dimname.fnc'></span><span id='topic+tp.dimname.fnc'></span><span id='topic+spT.keep.morethan.dist'></span><span id='topic+spT.grid.coords'></span><span id='topic+spT.check.locations'></span><span id='topic+spT.segment.plot'></span><span id='topic+spT.subset'></span><span id='topic+spT.geodist'></span><span id='topic+spT.pCOVER'></span><span id='topic+spT.validation'></span><span id='topic+confint.spTD'></span><span id='topic+fitted.spTD'></span><span id='topic+spT.check.sites.inside'></span><span id='topic+spT.geo.dist'></span><span id='topic+spT.geo_dist'></span><span id='topic+spT.time'></span><span id='topic+as.forecast.object'></span><span id='topic+NYdata'></span><span id='topic+AUSdata'></span><span id='topic+truncated.fnc'></span><span id='topic+reverse.truncated.fnc'></span><span id='topic+prob.below.threshold'></span>

<h3>Description</h3>

<p>Internal spTDyn functions</p>

<hr>
<h2 id='summary.spTD'>Summary statistics of the parameters.</h2><span id='topic+summary.spTD'></span>

<h3>Description</h3>

<p>This function is used to obtain MCMC summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spTD'
summary(object, digits=4, package="spTDyn", coefficient=NULL, ...)

## 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.spTD_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;spTD&quot;.</p>
</td></tr>
<tr><td><code id="summary.spTD_+3A_digits">digits</code></td>
<td>
<p>Rounds the specified number of decimal places (default 4).</p>
</td></tr>
<tr><td><code id="summary.spTD_+3A_package">package</code></td>
<td>
<p>If &quot;coda&quot; then summary statistics are given using coda package. Defaults value is &quot;spTDyn&quot;.</p>
</td></tr>
<tr><td><code id="summary.spTD_+3A_coefficient">coefficient</code></td>
<td>
<p>Takes values: &quot;spatial&quot;, &quot;temporal&quot; and &quot;rho&quot; for summary statistics of spatial, temporal and rho coefficients respectively. If NULL then provides parameter summary without spatial and temporal coefficients.</p>
</td></tr>
<tr><td><code id="summary.spTD_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sig2eps</code></td>
<td>
<p>Summary statistics for <code class="reqn">\sigma_\epsilon^2</code>.</p>
</td></tr> 
<tr><td><code>sig2eta</code></td>
<td>
<p>Summary statistics for <code class="reqn">\sigma_\eta^2</code>.</p>
</td></tr> 
<tr><td><code>phi</code></td>
<td>
<p>Summary statistics for spatial decay parameter <code class="reqn">\phi</code>, if estimated using <code>decay</code>.</p>
</td></tr> 
<tr><td><code>...</code></td>
<td>
<p>Summary statistics for other parameters used in the models.</p>
</td></tr> 
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GibbsDyn">GibbsDyn</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##

summary(out) # where out is the output from spT class
summary(out, digit=2) # where out is the output from spT class
summary(out, pack="coda") # where out is the output from spT class
summary(out, coefficient="spatial") # for spatially varying coefficients
summary(out, coefficient="temporal") # for temporally varying coefficients

##

## End(Not run)
</code></pre>

<hr>
<h2 id='tp'>Defining dynamic time-series coefficients in the formula</h2><span id='topic+tp'></span>

<h3>Description</h3>

<p>This function is used to define dynamic time-series coefficients within the formula for the Gaussian process spatio-dynamic and spatio-temporal DLM. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tp_+3A_x">x</code></td>
<td>
<p>The variable/covariate for which time varying coefficient is defined.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GibbsDyn">GibbsDyn</a>, <a href="#topic+sp">sp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##

###########################
## Attach library spTimer
###########################

library(spTDyn)

###########################
## The GP models:
###########################

##
## Model fitting
##

# Read data 
data(NYdata); 

# Define the coordinates
coords&lt;-as.matrix(unique(cbind(NYdata[,2:3])))

# MCMC via Gibbs using default choices
set.seed(11)
post.gp &lt;- GibbsDyn(formula=o8hrmax ~cMAXTMP+WDSP+tp(RH),   
         data=NYdata, coords=coords, scale.transform="SQRT")
print(post.gp)

##

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
