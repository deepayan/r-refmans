<!DOCTYPE html><html><head><title>Help for package BHSBVAR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BHSBVAR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BH_SBVAR'><p>Structural Bayesian Vector Autoregression</p></a></li>
<li><a href='#BHSBVAR-package'><p>BHSBVAR: Structural Bayesian Vector Autoregression Models</p></a></li>
<li><a href='#Dist_Plots'><p>Plot Posterior Distributions Against Priors</p></a></li>
<li><a href='#FEVD'><p>Forecast Error Variance Decompositions</p></a></li>
<li><a href='#FEVD_Plots'><p>Plot Forecast Error Variance Decompositions</p></a></li>
<li><a href='#HD'><p>Historical Decompositions</p></a></li>
<li><a href='#HD_Plots'><p>Plot Historical Decompositions</p></a></li>
<li><a href='#IRF'><p>Impulse Responses</p></a></li>
<li><a href='#IRF_Plots'><p>Plot Impulse Responses</p></a></li>
<li><a href='#USLMData'><p>U.S. Labor Market Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Structural Bayesian Vector Autoregression Models</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Richardson</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Richardson &lt;p.richardson.54391@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a function for estimating the parameters of Structural Bayesian Vector Autoregression models with the method developed by Baumeister and Hamilton (2015) &lt;<a href="https://doi.org/10.3982%2FECTA12356">doi:10.3982/ECTA12356</a>&gt;, Baumeister and Hamilton (2017) &lt;<a href="https://doi.org/10.3386%2Fw24167">doi:10.3386/w24167</a>&gt;, and Baumeister and Hamilton (2018) &lt;<a href="https://doi.org/10.1016%2Fj.jmoneco.2018.06.005">doi:10.1016/j.jmoneco.2018.06.005</a>&gt;. Functions for plotting impulse responses, historical decompositions, and posterior distributions of model parameters are also provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.6)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-05 15:08:58 UTC; prich</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-05 15:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='BH_SBVAR'>Structural Bayesian Vector Autoregression</h2><span id='topic+BH_SBVAR'></span>

<h3>Description</h3>

<p>Estimates the parameters of a Structural Bayesian Vector Autoregression model with the method developed by Baumeister and Hamilton (2015/2017/2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH_SBVAR(
  y,
  nlags,
  pA,
  pdetA = NULL,
  pH = NULL,
  pP = NULL,
  pP_sig = NULL,
  pR_sig = NULL,
  kappa1 = NULL,
  itr = 5000,
  burn = 0,
  thin = 1,
  cri = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BH_SBVAR_+3A_y">y</code></td>
<td>
<p><em>(T x n)</em> matrix containing the endogenous variables. <em>T</em> is the number of observations and <em>n</em> is the number of endogenous variables.</p>
</td></tr>
<tr><td><code id="BH_SBVAR_+3A_nlags">nlags</code></td>
<td>
<p>Integer specifying the lag order.</p>
</td></tr>
<tr><td><code id="BH_SBVAR_+3A_pa">pA</code></td>
<td>
<p><em>(n x n x 8)</em> array where <em>n</em> is the number of endogenous variables and each slice of the third dimension contains the prior distributions (NA - no prior, 0 - symmetric t-distribution, 1 - non-central t-distribution, 2 - inverted beta distribution, 3 - beta distribution), sign restrictions (NA - no restriction, 1 - positive restriction, -1 - negative restriction), distribution position parameters, distribution scale or shape1 parameters for t-distributions or inverted beta and beta distributions, distribution degrees of freedom or shape2 parameters for t-distributions or inverted beta and beta distributions, distribution skew parameters for t-distributions, indication for long-run restrictions (NA - no long-run restriction, 1 - long-run restriction), and random-walk proposal scale parameters for <em>A</em>, respectively.</p>
</td></tr>
<tr><td><code id="BH_SBVAR_+3A_pdeta">pdetA</code></td>
<td>
<p><em>(1 x 1 x 6)</em> array where each slice of the third dimension contains the prior distributions (NA - no prior, 0 - symmetric t-distribution, 1 - non-central t-distribution, 2 - inverted beta distribution, 3 - beta distribution), sign restrictions (NA - no restriction, 1 - positive restriction, -1 - negative restriction), distribution position parameters, distribution scale or shape1 parameters for t-distributions or inverted beta and beta distributions, distribution degrees of freedom or shape2 parameters for t-distributions or inverted beta and beta distributions, and distribution skew parameters for t-distributions for the determinant of <em>A</em>, respectively (default = NULL). NULL indicates no priors for the determinant of <em>A</em>.</p>
</td></tr>
<tr><td><code id="BH_SBVAR_+3A_ph">pH</code></td>
<td>
<p><em>(n x n x 6)</em> array where <em>n</em> is the number of endogenous variables and each slice of the third dimension contains the prior distributions (NA - no prior, 0 - symmetric t-distribution, 1 - non-central t-distribution, 2 - inverted beta distribution, 3 - beta distribution), sign restrictions (NA - no restriction, 1 - positive restriction, -1 - negative restriction), distribution position parameters, distribution scale or shape1 parameters for t-distributions or inverted beta and beta distributions, distribution degrees of freedom or shape2 parameters for t-distributions or inverted beta and beta distributions, and distribution skew parameters for t-distributions for <em>H</em>, the inverse of <em>A</em>, respectively (default = NULL). NULL indicates no priors for the inverse of <em>A</em>.</p>
</td></tr>
<tr><td><code id="BH_SBVAR_+3A_pp">pP</code></td>
<td>
<p><em>(k x n)</em> matrix containing the prior position parameters for the reduced form lagged coefficient matrix <em><code class="reqn">\Phi</code></em> (default = NULL). <em><code class="reqn">k = n L + 1</code></em>, <em>n</em> is the number of endogenous variables, and <em>L</em> is the lag length. NULL indicates no priors for <em><code class="reqn">\Phi</code></em>.</p>
</td></tr>
<tr><td><code id="BH_SBVAR_+3A_pp_sig">pP_sig</code></td>
<td>
<p><em>(k x k)</em> matrix containing values indicating confidence in the priors for <em><code class="reqn">\Phi</code></em> (default = NULL). <em><code class="reqn">k = n L + 1</code></em>, <em>n</em> is the number of endogenous variables, and <em>L</em> is the lag length. NULL indicates no priors for <em><code class="reqn">\Phi</code></em>.</p>
</td></tr>
<tr><td><code id="BH_SBVAR_+3A_pr_sig">pR_sig</code></td>
<td>
<p><em>(k x k x n)</em> array containing values indicating confidence in long-run restrictions on the lagged structural coefficient matrix <em>B</em> (default = NULL). <em><code class="reqn">k = n L + 1</code></em>, <em>n</em> is the number of endogenous variables, and <em>L</em> is the lag length. NULL indicates no long-run restrictions.</p>
</td></tr>
<tr><td><code id="BH_SBVAR_+3A_kappa1">kappa1</code></td>
<td>
<p><em>(1 x n)</em> matrix containing values indicating confidence in priors for the structural variances (default = NULL). <em>n</em> is the number of endogenous variables. NULL indicates no priors for structural variances.</p>
</td></tr>
<tr><td><code id="BH_SBVAR_+3A_itr">itr</code></td>
<td>
<p>Integer specifying the total number of iterations for the algorithm (default = 5000).</p>
</td></tr>
<tr><td><code id="BH_SBVAR_+3A_burn">burn</code></td>
<td>
<p>Integer specifying the number of draws to throw out at the beginning of the algorithm (default = 0).</p>
</td></tr>
<tr><td><code id="BH_SBVAR_+3A_thin">thin</code></td>
<td>
<p>Integer specifying the thinning parameter (default = 1). All draws beyond burn are kept when thin = 1. Draw 1, draw 3, etc. beyond burn are kept when thin = 2.</p>
</td></tr>
<tr><td><code id="BH_SBVAR_+3A_cri">cri</code></td>
<td>
<p>credibility intervals for the estimates to be returned (default = 0.95). A value of 0.95 will return 95% credibility intervals. A value of 0.90 will return 90% credibility intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the parameters of a Structural Bayesian Vector Autoregression model with the method developed in Baumeister and Hamilton (2015/2017/2018). The function returns a list containing the results.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<p>accept_rate: Acceptance rate of the algorithm.
</p>
<p>y and x: Matrices containing the endogenous variables and their lags.
</p>
<p>nlags: Numeric value indicating the number of lags included in the model.
</p>
<p>pA, pdetA, pH, pP, pP_sig, pR, pR_sig, tau1, and kappa1: Matrices and arrays containing prior information.
</p>
<p>A_start: Matrix containing estimates of the parameters in <em>A</em> from the optimization routine.
</p>
<p>A, detA, H, B, Phi, and D: Arrays containing estimates of the model parameters. The first, second, and third slices of the third dimension are lower, median, and upper bounds of the estimates.
</p>
<p>A_den, detA_den, and H_den: Lists containing the horizontal and vertical axis coordinates of posterior densities of <em>A</em>, <em>det(A)</em>, and <em>H</em>.
</p>
<p>A_chain, B_chain, D_chain, detA_chain, H_chain: Arrays containing the raw results for <em>A</em>, <em>B</em>, <em>D</em>, <em>detA</em>, <em>H</em>.
</p>
<p>Line and ACF plots of the estimates for <em>A</em>, <em>det(A)</em>, and <em>H</em>.
</p>


<h3>Author(s)</h3>

<p>Paul Richardson
</p>


<h3>References</h3>

<p>Baumeister, C., &amp; Hamilton, J.D. (2015). Sign restrictions, structural vector autoregressions, and useful prior information. <em>Econometrica</em>, 83(5), 1963-1999.
</p>
<p>Baumeister, C., &amp; Hamilton, J.D. (2017). Structural interpretation of vector autoregressions with incomplete identification: Revisiting the role of oil supply and demand shocks (No. w24167). National Bureau of Economic Research.
</p>
<p>Baumeister, C., &amp; Hamilton, J.D. (2018). Inference in structural vector autoregressions when the identifying assumptions are not fully believed: Re-evaluating the role of monetary policy in economic fluctuations. <em>Journal of Monetary Economics</em>, 100, 48-65.
</p>


<h3>See Also</h3>

<p>Dr. Christiane Baumeister's website <a href="https://sites.google.com/site/cjsbaumeister/">https://sites.google.com/site/cjsbaumeister/</a>.
</p>
<p>Dr. James D. Hamilton's website <a href="https://econweb.ucsd.edu/~jhamilton/">https://econweb.ucsd.edu/~jhamilton/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data
library(BHSBVAR)
set.seed(123)
data(USLMData)
y0 &lt;- matrix(data = c(USLMData$Wage, USLMData$Employment), ncol = 2)
y &lt;- y0 - (matrix(data = 1, nrow = nrow(y0), ncol = ncol(y0)) %*% 
             diag(x = colMeans(x = y0, na.rm = FALSE, dims = 1)))
colnames(y) &lt;- c("Wage", "Employment")

# Set function arguments
nlags &lt;- 8
itr &lt;- 5000
burn &lt;- 0
thin &lt;- 1
cri &lt;- 0.95

# Priors for A
pA &lt;- array(data = NA, dim = c(2, 2, 8))
pA[, , 1] &lt;- c(0, NA, 0, NA)
pA[, , 2] &lt;- c(1, NA, -1, NA)
pA[, , 3] &lt;- c(0.6, 1, -0.6, 1)
pA[, , 4] &lt;- c(0.6, NA, 0.6, NA)
pA[, , 5] &lt;- c(3, NA, 3, NA)
pA[, , 6] &lt;- c(NA, NA, NA, NA)
pA[, , 7] &lt;- c(NA, NA, 1, NA)
pA[, , 8] &lt;- c(2, NA, 2, NA)

# Position priors for Phi
pP &lt;- matrix(data = 0, nrow = ((nlags * ncol(pA)) + 1), ncol = ncol(pA))
pP[1:nrow(pA), 1:ncol(pA)] &lt;-
  diag(x = 1, nrow = nrow(pA), ncol = ncol(pA))

# Confidence in the priors for Phi
x1 &lt;- 
  matrix(data = NA, nrow = (nrow(y) - nlags), 
         ncol = (ncol(y) * nlags))
for (k in 1:nlags) {
  x1[, (ncol(y) * (k - 1) + 1):(ncol(y) * k)] &lt;-
    y[(nlags - k + 1):(nrow(y) - k),]
}
x1 &lt;- cbind(x1, 1)
colnames(x1) &lt;- 
  c(paste(rep(colnames(y), nlags),
          "_L",
          sort(rep(seq(from = 1, to = nlags, by = 1), times = ncol(y)),
               decreasing = FALSE),
          sep = ""),
    "cons")
y1 &lt;- y[(nlags + 1):nrow(y),]
ee &lt;- matrix(data = NA, nrow = nrow(y1), ncol = ncol(y1))
for (i in 1:ncol(y1)) {
  xx &lt;- cbind(x1[, seq(from = i, to = (ncol(x1) - 1), by = ncol(y1))], 1)
  yy &lt;- matrix(data = y1[, i], ncol = 1)
  phi &lt;- solve(t(xx) %*% xx, t(xx) %*% yy)
  ee[, i] &lt;- yy - (xx %*% phi)
}
somega &lt;- (t(ee) %*% ee) / nrow(ee)
lambda0 &lt;- 0.2
lambda1 &lt;- 1
lambda3 &lt;- 100
v1 &lt;- matrix(data = (1:nlags), nrow = nlags, ncol = 1)
v1 &lt;- v1^((-2) * lambda1)
v2 &lt;- matrix(data = diag(solve(diag(diag(somega)))), ncol = 1)
v3 &lt;- kronecker(v1, v2)
v3 &lt;- (lambda0^2) * rbind(v3, (lambda3^2))
v3 &lt;- 1 / v3
pP_sig &lt;- diag(x = 1, nrow = nrow(v3), ncol = nrow(v3))
diag(pP_sig) &lt;- v3

# Confidence in long-run restriction priors
pR_sig &lt;-
  array(data = 0,
        dim = c(((nlags * ncol(y)) + 1),
                ((nlags * ncol(y)) + 1),
                ncol(y)))
Ri &lt;-
  cbind(kronecker(matrix(data = 1, nrow = 1, ncol = nlags),
                  matrix(data = c(1, 0), nrow = 1)),
        0)
pR_sig[, , 2] &lt;- (t(Ri) %*% Ri) / 0.1

# Confidence in priors for D
kappa1 &lt;- matrix(data = 2, nrow = 1, ncol = ncol(y))

# Set graphical parameters
par(cex.axis = 0.8, cex.main = 1, font.main = 1, family = "serif",
    mfrow = c(2, 2), mar = c(2, 2.2, 2, 1), las = 1)

# Estimate the parameters of the model
results1 &lt;- 
  BH_SBVAR(y = y, nlags = nlags, pA = pA, pP = pP, pP_sig = pP_sig,
           pR_sig = pR_sig, kappa1 = kappa1, itr = itr, burn = burn,
           thin = thin, cri = cri)
</code></pre>

<hr>
<h2 id='BHSBVAR-package'>BHSBVAR: Structural Bayesian Vector Autoregression Models</h2><span id='topic+BHSBVAR'></span><span id='topic+BHSBVAR-package'></span>

<h3>Description</h3>

<p>Provides a function for estimating the parameters of Structural Bayesian Vector Autoregression models with the method developed by Baumeister and Hamilton (2015) <a href="https://doi.org/10.3982/ECTA12356">doi:10.3982/ECTA12356</a>, Baumeister and Hamilton (2017) <a href="https://doi.org/10.3386/w24167">doi:10.3386/w24167</a>, and Baumeister and Hamilton (2018) <a href="https://doi.org/10.1016/j.jmoneco.2018.06.005">doi:10.1016/j.jmoneco.2018.06.005</a>. Functions for plotting impulse responses, historical decompositions, and posterior distributions of model parameters are also provided.
</p>


<h3>Details</h3>

<p>See vignette.
</p>


<h3>References</h3>

<p>Baumeister, C., &amp; Hamilton, J.D. (2015). Sign restrictions, structural vector autoregressions, and useful prior information. <em>Econometrica</em>, 83(5), 1963-1999.
</p>
<p>Baumeister, C., &amp; Hamilton, J.D. (2017). Structural interpretation of vector autoregressions with incomplete identification: Revisiting the role of oil supply and demand shocks (No. w24167). National Bureau of Economic Research.
</p>
<p>Baumeister, C., &amp; Hamilton, J.D. (2018). Inference in structural vector autoregressions when the identifying assumptions are not fully believed: Re-evaluating the role of monetary policy in economic fluctuations. <em>Journal of Monetary Economics</em>, 100, 48-65.
</p>


<h3>See Also</h3>

<p>Dr. Christiane Baumeister's website <a href="https://sites.google.com/site/cjsbaumeister/">https://sites.google.com/site/cjsbaumeister/</a>.
</p>
<p>Dr. James D. Hamilton's website <a href="https://econweb.ucsd.edu/~jhamilton/">https://econweb.ucsd.edu/~jhamilton/</a>.
</p>

<hr>
<h2 id='Dist_Plots'>Plot Posterior Distributions Against Priors</h2><span id='topic+Dist_Plots'></span>

<h3>Description</h3>

<p>Plot Posterior Distributions Against Priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dist_Plots(results, A_titles, H_titles = NULL, xlab = NULL, ylab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dist_Plots_+3A_results">results</code></td>
<td>
<p>List containing the results from running BH_SBVAR().</p>
</td></tr>
<tr><td><code id="Dist_Plots_+3A_a_titles">A_titles</code></td>
<td>
<p><em>(n x n)</em> matrix containing the titles for the plots of the estimated parameters in the coefficient matrix <em>A</em>. <em>n</em> is the number of endogenous variables.</p>
</td></tr>
<tr><td><code id="Dist_Plots_+3A_h_titles">H_titles</code></td>
<td>
<p><em>(n x n)</em> matrix containing the titles for the plots of the estimated parameters in the coefficient matrix <em>H</em> (default = NULL). <em>n</em> is the number of endogenous variables.</p>
</td></tr>
<tr><td><code id="Dist_Plots_+3A_xlab">xlab</code></td>
<td>
<p>Character label for the horizontal axis of historical decomposition plots (default = NULL). Default produces plots without a label for the horizontal axis.</p>
</td></tr>
<tr><td><code id="Dist_Plots_+3A_ylab">ylab</code></td>
<td>
<p>Character label for the vertical axis of historical decomposition plots (default = NULL). Default produces plots without a label for the vertical axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots posterior distributions against prior distributions.
</p>


<h3>Author(s)</h3>

<p>Paul Richardson
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data
library(BHSBVAR)
set.seed(123)
data(USLMData)
y0 &lt;- matrix(data = c(USLMData$Wage, USLMData$Employment), ncol = 2)
y &lt;- y0 - (matrix(data = 1, nrow = nrow(y0), ncol = ncol(y0)) %*% 
             diag(x = colMeans(x = y0, na.rm = FALSE, dims = 1)))
colnames(y) &lt;- c("Wage", "Employment")

# Set function arguments
nlags &lt;- 8
itr &lt;- 5000
burn &lt;- 0
thin &lt;- 1
acc &lt;- TRUE
h &lt;- 20
cri &lt;- 0.95

# Priors for A
pA &lt;- array(data = NA, dim = c(2, 2, 8))
pA[, , 1] &lt;- c(0, NA, 0, NA)
pA[, , 2] &lt;- c(1, NA, -1, NA)
pA[, , 3] &lt;- c(0.6, 1, -0.6, 1)
pA[, , 4] &lt;- c(0.6, NA, 0.6, NA)
pA[, , 5] &lt;- c(3, NA, 3, NA)
pA[, , 6] &lt;- c(NA, NA, NA, NA)
pA[, , 7] &lt;- c(NA, NA, 1, NA)
pA[, , 8] &lt;- c(2, NA, 2, NA)

# Position priors for Phi
pP &lt;- matrix(data = 0, nrow = ((nlags * ncol(pA)) + 1), ncol = ncol(pA))
pP[1:nrow(pA), 1:ncol(pA)] &lt;-
  diag(x = 1, nrow = nrow(pA), ncol = ncol(pA))

# Confidence in the priors for Phi
x1 &lt;- 
  matrix(data = NA, nrow = (nrow(y) - nlags), 
         ncol = (ncol(y) * nlags))
for (k in 1:nlags) {
  x1[, (ncol(y) * (k - 1) + 1):(ncol(y) * k)] &lt;-
    y[(nlags - k + 1):(nrow(y) - k),]
}
x1 &lt;- cbind(x1, 1)
colnames(x1) &lt;- 
  c(paste(rep(colnames(y), nlags),
          "_L",
          sort(rep(seq(from = 1, to = nlags, by = 1), times = ncol(y)),
               decreasing = FALSE),
          sep = ""),
    "cons")
y1 &lt;- y[(nlags + 1):nrow(y),]
ee &lt;- matrix(data = NA, nrow = nrow(y1), ncol = ncol(y1))
for (i in 1:ncol(y1)) {
  xx &lt;- cbind(x1[, seq(from = i, to = (ncol(x1) - 1), by = ncol(y1))], 1)
  yy &lt;- matrix(data = y1[, i], ncol = 1)
  phi &lt;- solve(t(xx) %*% xx, t(xx) %*% yy)
  ee[, i] &lt;- yy - (xx %*% phi)
}
somega &lt;- (t(ee) %*% ee) / nrow(ee)
lambda0 &lt;- 0.2
lambda1 &lt;- 1
lambda3 &lt;- 100
v1 &lt;- matrix(data = (1:nlags), nrow = nlags, ncol = 1)
v1 &lt;- v1^((-2) * lambda1)
v2 &lt;- matrix(data = diag(solve(diag(diag(somega)))), ncol = 1)
v3 &lt;- kronecker(v1, v2)
v3 &lt;- (lambda0^2) * rbind(v3, (lambda3^2))
v3 &lt;- 1 / v3
pP_sig &lt;- diag(x = 1, nrow = nrow(v3), ncol = nrow(v3))
diag(pP_sig) &lt;- v3

# Confidence in long-run restriction priors
pR_sig &lt;-
  array(data = 0,
        dim = c(((nlags * ncol(y)) + 1),
                ((nlags * ncol(y)) + 1),
                ncol(y)))
Ri &lt;-
  cbind(kronecker(matrix(data = 1, nrow = 1, ncol = nlags),
                  matrix(data = c(1, 0), nrow = 1)),
        0)
pR_sig[, , 2] &lt;- (t(Ri) %*% Ri) / 0.1

# Confidence in priors for D
kappa1 &lt;- matrix(data = 2, nrow = 1, ncol = ncol(y))

# Set graphical parameters
par(cex.axis = 0.8, cex.main = 1, font.main = 1, family = "serif",
    mfrow = c(2, 2), mar = c(2, 2.2, 2, 1), las = 1)

# Estimate the parameters of the model
results1 &lt;- 
  BH_SBVAR(y = y, nlags = nlags, pA = pA, pP = pP, pP_sig = pP_sig,
           pR_sig = pR_sig, kappa1 = kappa1, itr = itr, burn = burn,
           thin = thin, cri = cri)

# Plot Posterior and Prior Densities
A_titles &lt;- 
  matrix(data = NA_character_, nrow = dim(pA)[1], ncol = dim(pA)[2])
A_titles[1, 1] &lt;- "Wage Elasticity of Labor Demand"
A_titles[1, 2] &lt;- "Wage Elasticity of Labor Supply"
par(mfcol = c(1, 2))
dist_results &lt;- 
  Dist_Plots(results = results1, A_titles = A_titles)
</code></pre>

<hr>
<h2 id='FEVD'>Forecast Error Variance Decompositions</h2><span id='topic+FEVD'></span>

<h3>Description</h3>

<p>Forecast Error Variance Decompositions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FEVD(results, h = 12, acc = TRUE, cri = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FEVD_+3A_results">results</code></td>
<td>
<p>List containing the results from running BH_SBVAR().</p>
</td></tr>
<tr><td><code id="FEVD_+3A_h">h</code></td>
<td>
<p>Integer specifying the time horizon for computing impulse responses (default = 12).</p>
</td></tr>
<tr><td><code id="FEVD_+3A_acc">acc</code></td>
<td>
<p>Boolean indicating whether accumulated impulse responses are to be returned (default = TRUE).</p>
</td></tr>
<tr><td><code id="FEVD_+3A_cri">cri</code></td>
<td>
<p>credibility intervals for the estimates to be returned (default = 0.95). A value of 0.95 will return 95% credibility intervals. A value of 0.90 will return 90% credibility intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes forecast error variance decomposition estimates.
</p>


<h3>Value</h3>

<p>An array containing forecast error variance decomposition estimates.
</p>


<h3>Author(s)</h3>

<p>Paul Richardson
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data
library(BHSBVAR)
set.seed(123)
data(USLMData)
y0 &lt;- matrix(data = c(USLMData$Wage, USLMData$Employment), ncol = 2)
y &lt;- y0 - (matrix(data = 1, nrow = nrow(y0), ncol = ncol(y0)) %*% 
             diag(x = colMeans(x = y0, na.rm = FALSE, dims = 1)))
colnames(y) &lt;- c("Wage", "Employment")

# Set function arguments
nlags &lt;- 8
itr &lt;- 5000
burn &lt;- 0
thin &lt;- 1
acc &lt;- TRUE
h &lt;- 20
cri &lt;- 0.95

# Priors for A
pA &lt;- array(data = NA, dim = c(2, 2, 8))
pA[, , 1] &lt;- c(0, NA, 0, NA)
pA[, , 2] &lt;- c(1, NA, -1, NA)
pA[, , 3] &lt;- c(0.6, 1, -0.6, 1)
pA[, , 4] &lt;- c(0.6, NA, 0.6, NA)
pA[, , 5] &lt;- c(3, NA, 3, NA)
pA[, , 6] &lt;- c(NA, NA, NA, NA)
pA[, , 7] &lt;- c(NA, NA, 1, NA)
pA[, , 8] &lt;- c(2, NA, 2, NA)

# Position priors for Phi
pP &lt;- matrix(data = 0, nrow = ((nlags * ncol(pA)) + 1), ncol = ncol(pA))
pP[1:nrow(pA), 1:ncol(pA)] &lt;-
  diag(x = 1, nrow = nrow(pA), ncol = ncol(pA))

# Confidence in the priors for Phi
x1 &lt;- 
  matrix(data = NA, nrow = (nrow(y) - nlags), 
         ncol = (ncol(y) * nlags))
for (k in 1:nlags) {
  x1[, (ncol(y) * (k - 1) + 1):(ncol(y) * k)] &lt;-
    y[(nlags - k + 1):(nrow(y) - k),]
}
x1 &lt;- cbind(x1, 1)
colnames(x1) &lt;- 
  c(paste(rep(colnames(y), nlags),
          "_L",
          sort(rep(seq(from = 1, to = nlags, by = 1), times = ncol(y)),
               decreasing = FALSE),
          sep = ""),
    "cons")
y1 &lt;- y[(nlags + 1):nrow(y),]
ee &lt;- matrix(data = NA, nrow = nrow(y1), ncol = ncol(y1))
for (i in 1:ncol(y1)) {
  xx &lt;- cbind(x1[, seq(from = i, to = (ncol(x1) - 1), by = ncol(y1))], 1)
  yy &lt;- matrix(data = y1[, i], ncol = 1)
  phi &lt;- solve(t(xx) %*% xx, t(xx) %*% yy)
  ee[, i] &lt;- yy - (xx %*% phi)
}
somega &lt;- (t(ee) %*% ee) / nrow(ee)
lambda0 &lt;- 0.2
lambda1 &lt;- 1
lambda3 &lt;- 100
v1 &lt;- matrix(data = (1:nlags), nrow = nlags, ncol = 1)
v1 &lt;- v1^((-2) * lambda1)
v2 &lt;- matrix(data = diag(solve(diag(diag(somega)))), ncol = 1)
v3 &lt;- kronecker(v1, v2)
v3 &lt;- (lambda0^2) * rbind(v3, (lambda3^2))
v3 &lt;- 1 / v3
pP_sig &lt;- diag(x = 1, nrow = nrow(v3), ncol = nrow(v3))
diag(pP_sig) &lt;- v3

# Confidence in long-run restriction priors
pR_sig &lt;-
  array(data = 0,
        dim = c(((nlags * ncol(y)) + 1),
                ((nlags * ncol(y)) + 1),
                ncol(y)))
Ri &lt;-
  cbind(kronecker(matrix(data = 1, nrow = 1, ncol = nlags),
                  matrix(data = c(1, 0), nrow = 1)),
        0)
pR_sig[, , 2] &lt;- (t(Ri) %*% Ri) / 0.1

# Confidence in priors for D
kappa1 &lt;- matrix(data = 2, nrow = 1, ncol = ncol(y))

# Set graphical parameters
par(cex.axis = 0.8, cex.main = 1, font.main = 1, family = "serif",
    mfrow = c(2, 2), mar = c(2, 2.2, 2, 1), las = 1)

# Estimate the parameters of the model
results1 &lt;- 
  BH_SBVAR(y = y, nlags = nlags, pA = pA, pP = pP, pP_sig = pP_sig,
           pR_sig = pR_sig, kappa1 = kappa1, itr = itr, burn = burn,
           thin = thin, cri = cri)

fevd &lt;- FEVD(results = results1, h = h, acc = acc, cri = cri)

# Plot impulse responses
varnames &lt;- colnames(USLMData)[2:3]
shocknames &lt;- c("Labor Demand","Labor Supply")
fevd_results &lt;- 
  FEVD_Plots(results = fevd, varnames = varnames,
            shocknames = shocknames)
</code></pre>

<hr>
<h2 id='FEVD_Plots'>Plot Forecast Error Variance Decompositions</h2><span id='topic+FEVD_Plots'></span>

<h3>Description</h3>

<p>Plot Forecast Error Variance Decompositions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FEVD_Plots(
  results,
  varnames,
  shocknames = NULL,
  xlab = NULL,
  ylab = NULL,
  rel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FEVD_Plots_+3A_results">results</code></td>
<td>
<p>List containing the results from running BH_SBVAR().</p>
</td></tr>
<tr><td><code id="FEVD_Plots_+3A_varnames">varnames</code></td>
<td>
<p>Character vector containing the names of the endogenous variables.</p>
</td></tr>
<tr><td><code id="FEVD_Plots_+3A_shocknames">shocknames</code></td>
<td>
<p>Character vector containing the names of the shocks.</p>
</td></tr>
<tr><td><code id="FEVD_Plots_+3A_xlab">xlab</code></td>
<td>
<p>Character label for the horizontal axis of impulse response plots (default = NULL). Default produces plots without a label for the horizontal axis.</p>
</td></tr>
<tr><td><code id="FEVD_Plots_+3A_ylab">ylab</code></td>
<td>
<p>Character label for the vertical axis of impulse response plots (default = NULL). Default produces plots without a label for the vertical axis.</p>
</td></tr>
<tr><td><code id="FEVD_Plots_+3A_rel">rel</code></td>
<td>
<p>Boolean indicating whether to display forecast error variance explained by the shock as a percent of total forecast error variance (default = TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots forecast error variance decompositions and returns a list containing the actual processed data used to create the plots.
</p>


<h3>Value</h3>

<p>A list containing forecast error variance decompositions.
</p>


<h3>Author(s)</h3>

<p>Paul Richardson
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data
library(BHSBVAR)
set.seed(123)
data(USLMData)
y0 &lt;- matrix(data = c(USLMData$Wage, USLMData$Employment), ncol = 2)
y &lt;- y0 - (matrix(data = 1, nrow = nrow(y0), ncol = ncol(y0)) %*% 
             diag(x = colMeans(x = y0, na.rm = FALSE, dims = 1)))
colnames(y) &lt;- c("Wage", "Employment")

# Set function arguments
nlags &lt;- 8
itr &lt;- 5000
burn &lt;- 0
thin &lt;- 1
acc &lt;- TRUE
h &lt;- 20
cri &lt;- 0.95

# Priors for A
pA &lt;- array(data = NA, dim = c(2, 2, 8))
pA[, , 1] &lt;- c(0, NA, 0, NA)
pA[, , 2] &lt;- c(1, NA, -1, NA)
pA[, , 3] &lt;- c(0.6, 1, -0.6, 1)
pA[, , 4] &lt;- c(0.6, NA, 0.6, NA)
pA[, , 5] &lt;- c(3, NA, 3, NA)
pA[, , 6] &lt;- c(NA, NA, NA, NA)
pA[, , 7] &lt;- c(NA, NA, 1, NA)
pA[, , 8] &lt;- c(2, NA, 2, NA)

# Position priors for Phi
pP &lt;- matrix(data = 0, nrow = ((nlags * ncol(pA)) + 1), ncol = ncol(pA))
pP[1:nrow(pA), 1:ncol(pA)] &lt;-
  diag(x = 1, nrow = nrow(pA), ncol = ncol(pA))

# Confidence in the priors for Phi
x1 &lt;- 
  matrix(data = NA, nrow = (nrow(y) - nlags), 
         ncol = (ncol(y) * nlags))
for (k in 1:nlags) {
  x1[, (ncol(y) * (k - 1) + 1):(ncol(y) * k)] &lt;-
    y[(nlags - k + 1):(nrow(y) - k),]
}
x1 &lt;- cbind(x1, 1)
colnames(x1) &lt;- 
  c(paste(rep(colnames(y), nlags),
          "_L",
          sort(rep(seq(from = 1, to = nlags, by = 1), times = ncol(y)),
               decreasing = FALSE),
          sep = ""),
    "cons")
y1 &lt;- y[(nlags + 1):nrow(y),]
ee &lt;- matrix(data = NA, nrow = nrow(y1), ncol = ncol(y1))
for (i in 1:ncol(y1)) {
  xx &lt;- cbind(x1[, seq(from = i, to = (ncol(x1) - 1), by = ncol(y1))], 1)
  yy &lt;- matrix(data = y1[, i], ncol = 1)
  phi &lt;- solve(t(xx) %*% xx, t(xx) %*% yy)
  ee[, i] &lt;- yy - (xx %*% phi)
}
somega &lt;- (t(ee) %*% ee) / nrow(ee)
lambda0 &lt;- 0.2
lambda1 &lt;- 1
lambda3 &lt;- 100
v1 &lt;- matrix(data = (1:nlags), nrow = nlags, ncol = 1)
v1 &lt;- v1^((-2) * lambda1)
v2 &lt;- matrix(data = diag(solve(diag(diag(somega)))), ncol = 1)
v3 &lt;- kronecker(v1, v2)
v3 &lt;- (lambda0^2) * rbind(v3, (lambda3^2))
v3 &lt;- 1 / v3
pP_sig &lt;- diag(x = 1, nrow = nrow(v3), ncol = nrow(v3))
diag(pP_sig) &lt;- v3

# Confidence in long-run restriction priors
pR_sig &lt;-
  array(data = 0,
        dim = c(((nlags * ncol(y)) + 1),
                ((nlags * ncol(y)) + 1),
                ncol(y)))
Ri &lt;-
  cbind(kronecker(matrix(data = 1, nrow = 1, ncol = nlags),
                  matrix(data = c(1, 0), nrow = 1)),
        0)
pR_sig[, , 2] &lt;- (t(Ri) %*% Ri) / 0.1

# Confidence in priors for D
kappa1 &lt;- matrix(data = 2, nrow = 1, ncol = ncol(y))

# Set graphical parameters
par(cex.axis = 0.8, cex.main = 1, font.main = 1, family = "serif",
    mfrow = c(2, 2), mar = c(2, 2.2, 2, 1), las = 1)

# Estimate the parameters of the model
results1 &lt;- 
  BH_SBVAR(y = y, nlags = nlags, pA = pA, pP = pP, pP_sig = pP_sig,
           pR_sig = pR_sig, kappa1 = kappa1, itr = itr, burn = burn,
           thin = thin, cri = cri)

fevd &lt;- FEVD(results = results1, h = h, acc = acc, cri = cri)

# Plot impulse responses
varnames &lt;- colnames(USLMData)[2:3]
shocknames &lt;- c("Labor Demand","Labor Supply")
fevd_results &lt;- 
  FEVD_Plots(results = fevd, varnames = varnames,
            shocknames = shocknames)
</code></pre>

<hr>
<h2 id='HD'>Historical Decompositions</h2><span id='topic+HD'></span>

<h3>Description</h3>

<p>Historical Decompositions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HD(results, cri = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HD_+3A_results">results</code></td>
<td>
<p>List containing the results from running BH_SBVAR().</p>
</td></tr>
<tr><td><code id="HD_+3A_cri">cri</code></td>
<td>
<p>credibility intervals for the estimates to be returned (default = 0.95). A value of 0.95 will return 95% credibility intervals. A value of 0.90 will return 90% credibility intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes historical decomposition estimates.
</p>


<h3>Value</h3>

<p>An array containing historical decomposition estimates.
</p>


<h3>Author(s)</h3>

<p>Paul Richardson
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data
library(BHSBVAR)
set.seed(123)
data(USLMData)
y0 &lt;- matrix(data = c(USLMData$Wage, USLMData$Employment), ncol = 2)
y &lt;- y0 - (matrix(data = 1, nrow = nrow(y0), ncol = ncol(y0)) %*% 
             diag(x = colMeans(x = y0, na.rm = FALSE, dims = 1)))
colnames(y) &lt;- c("Wage", "Employment")

# Set function arguments
nlags &lt;- 8
itr &lt;- 5000
burn &lt;- 0
thin &lt;- 1
acc &lt;- TRUE
h &lt;- 20
cri &lt;- 0.95

# Priors for A
pA &lt;- array(data = NA, dim = c(2, 2, 8))
pA[, , 1] &lt;- c(0, NA, 0, NA)
pA[, , 2] &lt;- c(1, NA, -1, NA)
pA[, , 3] &lt;- c(0.6, 1, -0.6, 1)
pA[, , 4] &lt;- c(0.6, NA, 0.6, NA)
pA[, , 5] &lt;- c(3, NA, 3, NA)
pA[, , 6] &lt;- c(NA, NA, NA, NA)
pA[, , 7] &lt;- c(NA, NA, 1, NA)
pA[, , 8] &lt;- c(2, NA, 2, NA)

# Position priors for Phi
pP &lt;- matrix(data = 0, nrow = ((nlags * ncol(pA)) + 1), ncol = ncol(pA))
pP[1:nrow(pA), 1:ncol(pA)] &lt;-
  diag(x = 1, nrow = nrow(pA), ncol = ncol(pA))

# Confidence in the priors for Phi
x1 &lt;- 
  matrix(data = NA, nrow = (nrow(y) - nlags), 
         ncol = (ncol(y) * nlags))
for (k in 1:nlags) {
  x1[, (ncol(y) * (k - 1) + 1):(ncol(y) * k)] &lt;-
    y[(nlags - k + 1):(nrow(y) - k),]
}
x1 &lt;- cbind(x1, 1)
colnames(x1) &lt;- 
  c(paste(rep(colnames(y), nlags),
          "_L",
          sort(rep(seq(from = 1, to = nlags, by = 1), times = ncol(y)),
               decreasing = FALSE),
          sep = ""),
    "cons")
y1 &lt;- y[(nlags + 1):nrow(y),]
ee &lt;- matrix(data = NA, nrow = nrow(y1), ncol = ncol(y1))
for (i in 1:ncol(y1)) {
  xx &lt;- cbind(x1[, seq(from = i, to = (ncol(x1) - 1), by = ncol(y1))], 1)
  yy &lt;- matrix(data = y1[, i], ncol = 1)
  phi &lt;- solve(t(xx) %*% xx, t(xx) %*% yy)
  ee[, i] &lt;- yy - (xx %*% phi)
}
somega &lt;- (t(ee) %*% ee) / nrow(ee)
lambda0 &lt;- 0.2
lambda1 &lt;- 1
lambda3 &lt;- 100
v1 &lt;- matrix(data = (1:nlags), nrow = nlags, ncol = 1)
v1 &lt;- v1^((-2) * lambda1)
v2 &lt;- matrix(data = diag(solve(diag(diag(somega)))), ncol = 1)
v3 &lt;- kronecker(v1, v2)
v3 &lt;- (lambda0^2) * rbind(v3, (lambda3^2))
v3 &lt;- 1 / v3
pP_sig &lt;- diag(x = 1, nrow = nrow(v3), ncol = nrow(v3))
diag(pP_sig) &lt;- v3

# Confidence in long-run restriction priors
pR_sig &lt;-
  array(data = 0,
        dim = c(((nlags * ncol(y)) + 1),
                ((nlags * ncol(y)) + 1),
                ncol(y)))
Ri &lt;-
  cbind(kronecker(matrix(data = 1, nrow = 1, ncol = nlags),
                  matrix(data = c(1, 0), nrow = 1)),
        0)
pR_sig[, , 2] &lt;- (t(Ri) %*% Ri) / 0.1

# Confidence in priors for D
kappa1 &lt;- matrix(data = 2, nrow = 1, ncol = ncol(y))

# Set graphical parameters
par(cex.axis = 0.8, cex.main = 1, font.main = 1, family = "serif",
    mfrow = c(2, 2), mar = c(2, 2.2, 2, 1), las = 1)

# Estimate the parameters of the model
results1 &lt;- 
  BH_SBVAR(y = y, nlags = nlags, pA = pA, pP = pP, pP_sig = pP_sig,
           pR_sig = pR_sig, kappa1 = kappa1, itr = itr, burn = burn,
           thin = thin, cri = cri)
           
hd &lt;- HD(results = results1, cri = cri)

# Plot historical decompositions
varnames &lt;- colnames(USLMData)[2:3]
shocknames &lt;- c("Labor Demand","Labor Supply")
freq &lt;- 4
start_date &lt;- 
  c(floor(USLMData[(nlags + 1), 1]),
    round(((USLMData[(nlags + 1), 1] %% 1) * freq), digits = 0))
hd_results &lt;- 
  HD_Plots(results  = hd, varnames = varnames,
           shocknames = shocknames,
           freq = freq, start_date = start_date)
</code></pre>

<hr>
<h2 id='HD_Plots'>Plot Historical Decompositions</h2><span id='topic+HD_Plots'></span>

<h3>Description</h3>

<p>Plot Historical Decompositions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HD_Plots(
  results,
  varnames,
  shocknames = NULL,
  xlab = NULL,
  ylab = NULL,
  freq,
  start_date
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HD_Plots_+3A_results">results</code></td>
<td>
<p>List containing the results from running BH_SBVAR().</p>
</td></tr>
<tr><td><code id="HD_Plots_+3A_varnames">varnames</code></td>
<td>
<p>Character vector containing the names of the endogenous variables.</p>
</td></tr>
<tr><td><code id="HD_Plots_+3A_shocknames">shocknames</code></td>
<td>
<p>Character vector containing the names of the shocks.</p>
</td></tr>
<tr><td><code id="HD_Plots_+3A_xlab">xlab</code></td>
<td>
<p>Character label for the horizontal axis of historical decomposition plots (default = NULL). Default produces plots without a label for the horizontal axis.</p>
</td></tr>
<tr><td><code id="HD_Plots_+3A_ylab">ylab</code></td>
<td>
<p>Character label for the vertical axis of historical decomposition plots (default = NULL). Default produces plots without a label for the vertical axis.</p>
</td></tr>
<tr><td><code id="HD_Plots_+3A_freq">freq</code></td>
<td>
<p>Numeric value indicating the frequency of the data.</p>
</td></tr>
<tr><td><code id="HD_Plots_+3A_start_date">start_date</code></td>
<td>
<p>Numeric vector indicating the date of the first observation of the endogenous variables included in the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots historical decompositions and returns a list containing the actual processed data used to create the plots.
</p>


<h3>Value</h3>

<p>A list containing historical decompositions.
</p>


<h3>Author(s)</h3>

<p>Paul Richardson
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data
library(BHSBVAR)
set.seed(123)
data(USLMData)
y0 &lt;- matrix(data = c(USLMData$Wage, USLMData$Employment), ncol = 2)
y &lt;- y0 - (matrix(data = 1, nrow = nrow(y0), ncol = ncol(y0)) %*% 
             diag(x = colMeans(x = y0, na.rm = FALSE, dims = 1)))
colnames(y) &lt;- c("Wage", "Employment")

# Set function arguments
nlags &lt;- 8
itr &lt;- 5000
burn &lt;- 0
thin &lt;- 1
acc &lt;- TRUE
h &lt;- 20
cri &lt;- 0.95

# Priors for A
pA &lt;- array(data = NA, dim = c(2, 2, 8))
pA[, , 1] &lt;- c(0, NA, 0, NA)
pA[, , 2] &lt;- c(1, NA, -1, NA)
pA[, , 3] &lt;- c(0.6, 1, -0.6, 1)
pA[, , 4] &lt;- c(0.6, NA, 0.6, NA)
pA[, , 5] &lt;- c(3, NA, 3, NA)
pA[, , 6] &lt;- c(NA, NA, NA, NA)
pA[, , 7] &lt;- c(NA, NA, 1, NA)
pA[, , 8] &lt;- c(2, NA, 2, NA)

# Position priors for Phi
pP &lt;- matrix(data = 0, nrow = ((nlags * ncol(pA)) + 1), ncol = ncol(pA))
pP[1:nrow(pA), 1:ncol(pA)] &lt;-
  diag(x = 1, nrow = nrow(pA), ncol = ncol(pA))

# Confidence in the priors for Phi
x1 &lt;- 
  matrix(data = NA, nrow = (nrow(y) - nlags), 
         ncol = (ncol(y) * nlags))
for (k in 1:nlags) {
  x1[, (ncol(y) * (k - 1) + 1):(ncol(y) * k)] &lt;-
    y[(nlags - k + 1):(nrow(y) - k),]
}
x1 &lt;- cbind(x1, 1)
colnames(x1) &lt;- 
  c(paste(rep(colnames(y), nlags),
          "_L",
          sort(rep(seq(from = 1, to = nlags, by = 1), times = ncol(y)),
               decreasing = FALSE),
          sep = ""),
    "cons")
y1 &lt;- y[(nlags + 1):nrow(y),]
ee &lt;- matrix(data = NA, nrow = nrow(y1), ncol = ncol(y1))
for (i in 1:ncol(y1)) {
  xx &lt;- cbind(x1[, seq(from = i, to = (ncol(x1) - 1), by = ncol(y1))], 1)
  yy &lt;- matrix(data = y1[, i], ncol = 1)
  phi &lt;- solve(t(xx) %*% xx, t(xx) %*% yy)
  ee[, i] &lt;- yy - (xx %*% phi)
}
somega &lt;- (t(ee) %*% ee) / nrow(ee)
lambda0 &lt;- 0.2
lambda1 &lt;- 1
lambda3 &lt;- 100
v1 &lt;- matrix(data = (1:nlags), nrow = nlags, ncol = 1)
v1 &lt;- v1^((-2) * lambda1)
v2 &lt;- matrix(data = diag(solve(diag(diag(somega)))), ncol = 1)
v3 &lt;- kronecker(v1, v2)
v3 &lt;- (lambda0^2) * rbind(v3, (lambda3^2))
v3 &lt;- 1 / v3
pP_sig &lt;- diag(x = 1, nrow = nrow(v3), ncol = nrow(v3))
diag(pP_sig) &lt;- v3

# Confidence in long-run restriction priors
pR_sig &lt;-
  array(data = 0,
        dim = c(((nlags * ncol(y)) + 1),
                ((nlags * ncol(y)) + 1),
                ncol(y)))
Ri &lt;-
  cbind(kronecker(matrix(data = 1, nrow = 1, ncol = nlags),
                  matrix(data = c(1, 0), nrow = 1)),
        0)
pR_sig[, , 2] &lt;- (t(Ri) %*% Ri) / 0.1

# Confidence in priors for D
kappa1 &lt;- matrix(data = 2, nrow = 1, ncol = ncol(y))

# Set graphical parameters
par(cex.axis = 0.8, cex.main = 1, font.main = 1, family = "serif",
    mfrow = c(2, 2), mar = c(2, 2.2, 2, 1), las = 1)

# Estimate the parameters of the model
results1 &lt;- 
  BH_SBVAR(y = y, nlags = nlags, pA = pA, pP = pP, pP_sig = pP_sig,
           pR_sig = pR_sig, kappa1 = kappa1, itr = itr, burn = burn,
           thin = thin, cri = cri)
           
hd &lt;- HD(results = results1, cri = cri)

# Plot historical decompositions
varnames &lt;- colnames(USLMData)[2:3]
shocknames &lt;- c("Labor Demand","Labor Supply")
freq &lt;- 4
start_date &lt;- 
  c(floor(USLMData[(nlags + 1), 1]),
    round(((USLMData[(nlags + 1), 1] %% 1) * freq), digits = 0))
hd_results &lt;- 
  HD_Plots(results  = hd, varnames = varnames,
           shocknames = shocknames,
           freq = freq, start_date = start_date)
</code></pre>

<hr>
<h2 id='IRF'>Impulse Responses</h2><span id='topic+IRF'></span>

<h3>Description</h3>

<p>Impulse Responses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRF(results, h = 12, acc = TRUE, cri = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IRF_+3A_results">results</code></td>
<td>
<p>List containing the results from running BH_SBVAR().</p>
</td></tr>
<tr><td><code id="IRF_+3A_h">h</code></td>
<td>
<p>Integer specifying the time horizon for computing impulse responses (default = 12).</p>
</td></tr>
<tr><td><code id="IRF_+3A_acc">acc</code></td>
<td>
<p>Boolean indicating whether accumulated impulse responses are to be returned (default = TRUE).</p>
</td></tr>
<tr><td><code id="IRF_+3A_cri">cri</code></td>
<td>
<p>credibility intervals for the estimates to be returned (default = 0.95). A value of 0.95 will return 95% credibility intervals. A value of 0.90 will return 90% credibility intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes impulse response estimates.
</p>


<h3>Value</h3>

<p>An Array containing the impulse response estimates.
</p>


<h3>Author(s)</h3>

<p>Paul Richardson
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data
library(BHSBVAR)
set.seed(123)
data(USLMData)
y0 &lt;- matrix(data = c(USLMData$Wage, USLMData$Employment), ncol = 2)
y &lt;- y0 - (matrix(data = 1, nrow = nrow(y0), ncol = ncol(y0)) %*% 
             diag(x = colMeans(x = y0, na.rm = FALSE, dims = 1)))
colnames(y) &lt;- c("Wage", "Employment")

# Set function arguments
nlags &lt;- 8
itr &lt;- 5000
burn &lt;- 0
thin &lt;- 1
acc &lt;- TRUE
h &lt;- 20
cri &lt;- 0.95

# Priors for A
pA &lt;- array(data = NA, dim = c(2, 2, 8))
pA[, , 1] &lt;- c(0, NA, 0, NA)
pA[, , 2] &lt;- c(1, NA, -1, NA)
pA[, , 3] &lt;- c(0.6, 1, -0.6, 1)
pA[, , 4] &lt;- c(0.6, NA, 0.6, NA)
pA[, , 5] &lt;- c(3, NA, 3, NA)
pA[, , 6] &lt;- c(NA, NA, NA, NA)
pA[, , 7] &lt;- c(NA, NA, 1, NA)
pA[, , 8] &lt;- c(2, NA, 2, NA)

# Position priors for Phi
pP &lt;- matrix(data = 0, nrow = ((nlags * ncol(pA)) + 1), ncol = ncol(pA))
pP[1:nrow(pA), 1:ncol(pA)] &lt;-
  diag(x = 1, nrow = nrow(pA), ncol = ncol(pA))

# Confidence in the priors for Phi
x1 &lt;- 
  matrix(data = NA, nrow = (nrow(y) - nlags), 
         ncol = (ncol(y) * nlags))
for (k in 1:nlags) {
  x1[, (ncol(y) * (k - 1) + 1):(ncol(y) * k)] &lt;-
    y[(nlags - k + 1):(nrow(y) - k),]
}
x1 &lt;- cbind(x1, 1)
colnames(x1) &lt;- 
  c(paste(rep(colnames(y), nlags),
          "_L",
          sort(rep(seq(from = 1, to = nlags, by = 1), times = ncol(y)),
               decreasing = FALSE),
          sep = ""),
    "cons")
y1 &lt;- y[(nlags + 1):nrow(y),]
ee &lt;- matrix(data = NA, nrow = nrow(y1), ncol = ncol(y1))
for (i in 1:ncol(y1)) {
  xx &lt;- cbind(x1[, seq(from = i, to = (ncol(x1) - 1), by = ncol(y1))], 1)
  yy &lt;- matrix(data = y1[, i], ncol = 1)
  phi &lt;- solve(t(xx) %*% xx, t(xx) %*% yy)
  ee[, i] &lt;- yy - (xx %*% phi)
}
somega &lt;- (t(ee) %*% ee) / nrow(ee)
lambda0 &lt;- 0.2
lambda1 &lt;- 1
lambda3 &lt;- 100
v1 &lt;- matrix(data = (1:nlags), nrow = nlags, ncol = 1)
v1 &lt;- v1^((-2) * lambda1)
v2 &lt;- matrix(data = diag(solve(diag(diag(somega)))), ncol = 1)
v3 &lt;- kronecker(v1, v2)
v3 &lt;- (lambda0^2) * rbind(v3, (lambda3^2))
v3 &lt;- 1 / v3
pP_sig &lt;- diag(x = 1, nrow = nrow(v3), ncol = nrow(v3))
diag(pP_sig) &lt;- v3

# Confidence in long-run restriction priors
pR_sig &lt;-
  array(data = 0,
        dim = c(((nlags * ncol(y)) + 1),
                ((nlags * ncol(y)) + 1),
                ncol(y)))
Ri &lt;-
  cbind(kronecker(matrix(data = 1, nrow = 1, ncol = nlags),
                  matrix(data = c(1, 0), nrow = 1)),
        0)
pR_sig[, , 2] &lt;- (t(Ri) %*% Ri) / 0.1

# Confidence in priors for D
kappa1 &lt;- matrix(data = 2, nrow = 1, ncol = ncol(y))

# Set graphical parameters
par(cex.axis = 0.8, cex.main = 1, font.main = 1, family = "serif",
    mfrow = c(2, 2), mar = c(2, 2.2, 2, 1), las = 1)

# Estimate the parameters of the model
results1 &lt;- 
  BH_SBVAR(y = y, nlags = nlags, pA = pA, pP = pP, pP_sig = pP_sig,
           pR_sig = pR_sig, kappa1 = kappa1, itr = itr, burn = burn,
           thin = thin, cri = cri)
           
irf &lt;- IRF(results = results1, h = h, acc = acc, cri = cri)

# Plot impulse responses
varnames &lt;- colnames(USLMData)[2:3]
shocknames &lt;- c("Labor Demand","Labor Supply")
irf_results &lt;- 
  IRF_Plots(results = irf, varnames = varnames,
            shocknames = shocknames)
</code></pre>

<hr>
<h2 id='IRF_Plots'>Plot Impulse Responses</h2><span id='topic+IRF_Plots'></span>

<h3>Description</h3>

<p>Plot Impulse Responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRF_Plots(results, varnames, shocknames = NULL, xlab = NULL, ylab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IRF_Plots_+3A_results">results</code></td>
<td>
<p>List containing the results from running BH_SBVAR().</p>
</td></tr>
<tr><td><code id="IRF_Plots_+3A_varnames">varnames</code></td>
<td>
<p>Character vector containing the names of the endogenous variables.</p>
</td></tr>
<tr><td><code id="IRF_Plots_+3A_shocknames">shocknames</code></td>
<td>
<p>Character vector containing the names of the shocks.</p>
</td></tr>
<tr><td><code id="IRF_Plots_+3A_xlab">xlab</code></td>
<td>
<p>Character label for the horizontal axis of impulse response plots (default = NULL). Default produces plots without a label for the horizontal axis.</p>
</td></tr>
<tr><td><code id="IRF_Plots_+3A_ylab">ylab</code></td>
<td>
<p>Character label for the vertical axis of impulse response plots (default = NULL). Default produces plots without a label for the vertical axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots impulse responses and returns a list containing the actual processed data used to create the plots.
</p>


<h3>Value</h3>

<p>A list containing impulse responses.
</p>


<h3>Author(s)</h3>

<p>Paul Richardson
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data
library(BHSBVAR)
set.seed(123)
data(USLMData)
y0 &lt;- matrix(data = c(USLMData$Wage, USLMData$Employment), ncol = 2)
y &lt;- y0 - (matrix(data = 1, nrow = nrow(y0), ncol = ncol(y0)) %*% 
             diag(x = colMeans(x = y0, na.rm = FALSE, dims = 1)))
colnames(y) &lt;- c("Wage", "Employment")

# Set function arguments
nlags &lt;- 8
itr &lt;- 5000
burn &lt;- 0
thin &lt;- 1
acc &lt;- TRUE
h &lt;- 20
cri &lt;- 0.95

# Priors for A
pA &lt;- array(data = NA, dim = c(2, 2, 8))
pA[, , 1] &lt;- c(0, NA, 0, NA)
pA[, , 2] &lt;- c(1, NA, -1, NA)
pA[, , 3] &lt;- c(0.6, 1, -0.6, 1)
pA[, , 4] &lt;- c(0.6, NA, 0.6, NA)
pA[, , 5] &lt;- c(3, NA, 3, NA)
pA[, , 6] &lt;- c(NA, NA, NA, NA)
pA[, , 7] &lt;- c(NA, NA, 1, NA)
pA[, , 8] &lt;- c(2, NA, 2, NA)

# Position priors for Phi
pP &lt;- matrix(data = 0, nrow = ((nlags * ncol(pA)) + 1), ncol = ncol(pA))
pP[1:nrow(pA), 1:ncol(pA)] &lt;-
  diag(x = 1, nrow = nrow(pA), ncol = ncol(pA))

# Confidence in the priors for Phi
x1 &lt;- 
  matrix(data = NA, nrow = (nrow(y) - nlags), 
         ncol = (ncol(y) * nlags))
for (k in 1:nlags) {
  x1[, (ncol(y) * (k - 1) + 1):(ncol(y) * k)] &lt;-
    y[(nlags - k + 1):(nrow(y) - k),]
}
x1 &lt;- cbind(x1, 1)
colnames(x1) &lt;- 
  c(paste(rep(colnames(y), nlags),
          "_L",
          sort(rep(seq(from = 1, to = nlags, by = 1), times = ncol(y)),
               decreasing = FALSE),
          sep = ""),
    "cons")
y1 &lt;- y[(nlags + 1):nrow(y),]
ee &lt;- matrix(data = NA, nrow = nrow(y1), ncol = ncol(y1))
for (i in 1:ncol(y1)) {
  xx &lt;- cbind(x1[, seq(from = i, to = (ncol(x1) - 1), by = ncol(y1))], 1)
  yy &lt;- matrix(data = y1[, i], ncol = 1)
  phi &lt;- solve(t(xx) %*% xx, t(xx) %*% yy)
  ee[, i] &lt;- yy - (xx %*% phi)
}
somega &lt;- (t(ee) %*% ee) / nrow(ee)
lambda0 &lt;- 0.2
lambda1 &lt;- 1
lambda3 &lt;- 100
v1 &lt;- matrix(data = (1:nlags), nrow = nlags, ncol = 1)
v1 &lt;- v1^((-2) * lambda1)
v2 &lt;- matrix(data = diag(solve(diag(diag(somega)))), ncol = 1)
v3 &lt;- kronecker(v1, v2)
v3 &lt;- (lambda0^2) * rbind(v3, (lambda3^2))
v3 &lt;- 1 / v3
pP_sig &lt;- diag(x = 1, nrow = nrow(v3), ncol = nrow(v3))
diag(pP_sig) &lt;- v3

# Confidence in long-run restriction priors
pR_sig &lt;-
  array(data = 0,
        dim = c(((nlags * ncol(y)) + 1),
                ((nlags * ncol(y)) + 1),
                ncol(y)))
Ri &lt;-
  cbind(kronecker(matrix(data = 1, nrow = 1, ncol = nlags),
                  matrix(data = c(1, 0), nrow = 1)),
        0)
pR_sig[, , 2] &lt;- (t(Ri) %*% Ri) / 0.1

# Confidence in priors for D
kappa1 &lt;- matrix(data = 2, nrow = 1, ncol = ncol(y))

# Set graphical parameters
par(cex.axis = 0.8, cex.main = 1, font.main = 1, family = "serif",
    mfrow = c(2, 2), mar = c(2, 2.2, 2, 1), las = 1)

# Estimate the parameters of the model
results1 &lt;- 
  BH_SBVAR(y = y, nlags = nlags, pA = pA, pP = pP, pP_sig = pP_sig,
           pR_sig = pR_sig, kappa1 = kappa1, itr = itr, burn = burn,
           thin = thin, cri = cri)
           
irf &lt;- IRF(results = results1, h = h, acc = acc, cri = cri)

# Plot impulse responses
varnames &lt;- colnames(USLMData)[2:3]
shocknames &lt;- c("Labor Demand","Labor Supply")
irf_results &lt;- 
  IRF_Plots(results = irf, varnames = varnames,
            shocknames = shocknames)
</code></pre>

<hr>
<h2 id='USLMData'>U.S. Labor Market Data</h2><span id='topic+USLMData'></span>

<h3>Description</h3>

<p>Quarterly U.S. labor market time-series data. These data are the data used in Baumeister and Hamilton (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USLMData)
</code></pre>


<h3>Format</h3>

<p>Data frame object that includes &quot;Date&quot;, &quot;Wage&quot;, and &quot;Employment&quot; variables. These data are the percent change in U.S. real wage and employment and were created by taking the difference of the natural log of U.S. real wage and employment levels and multiplying by 100.
</p>


<h3>Source</h3>

<p>Dr. Christiane Baumeister's website <a href="https://sites.google.com/site/cjsbaumeister/">https://sites.google.com/site/cjsbaumeister/</a>.
</p>
<p>Dr. James D. Hamilton's website <a href="https://econweb.ucsd.edu/~jhamilton/">https://econweb.ucsd.edu/~jhamilton/</a>.
</p>


<h3>References</h3>

<p>Baumeister, C., &amp; Hamilton, J.D. (2015). Sign restrictions, structural vector autoregressions, and useful prior information. <em>Econometrica</em>, 83(5), 1963-1999.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USLMData)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
