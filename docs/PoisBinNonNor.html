<!DOCTYPE html><html><head><title>Help for package PoisBinNonNor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PoisBinNonNor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#correlation.bound.check'><p>Checks if the pairwise correlation among variables are within the feasible range</p></a></li>
<li><a href='#correlation.limits'><p>Computes lower and upper correlation bounds for each pair of variables</p></a></li>
<li><a href='#fleishman.coef'><p>Computes the coefficients of Fleishman third order polynomials</p></a></li>
<li><a href='#gen.PoisBinNonNor'><p>Simulates a sample of size n from a set of multivariate Poisson, binary, and</p>
continuous data</a></li>
<li><a href='#intermediate.corr.BB'><p>Computes an intermediate normal correlation matrix for binary variables given</p>
the specified correlation matrix</a></li>
<li><a href='#intermediate.corr.BC'><p>Computes intermediate correlation matrix for binary and continuous variables given the specified correlation matrix</p></a></li>
<li><a href='#intermediate.corr.CC'><p>Computes an intermediate correlation matrix for continuous variables given the specified correlation</p>
matrix</a></li>
<li><a href='#intermediate.corr.PB'><p>Computes the pairwise entries of the intermediate normal correlation matrix for all Poisson-binary combinations</p>
given the specified correlation matrix.</a></li>
<li><a href='#intermediate.corr.PC'><p>Computes the pairwise entries of the intermediate normal correlation matrix for all Poisson-continuous combinations</p>
given the specified correlation matrix.</a></li>
<li><a href='#intermediate.corr.PP'><p>Computes an intermediate normal correlation matrix for Poisson variables given the specified correlation matrix</p></a></li>
<li><a href='#overall.corr.mat'><p>Computes the final intermediate correlation matrix</p></a></li>
<li><a href='#PoisBinNonNor-package'><p>Data Generation with Count, Binary and Continuous Components</p></a></li>
<li><a href='#validation.bin'><p>Validates the marginal specification of the binary variables</p></a></li>
<li><a href='#validation.corr'><p>Validates the specified correlation matrix</p></a></li>
<li><a href='#validation.skewness.kurtosis'><p>Validates the marginal specification of the continuous variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Generation with Poisson, Binary and Continuous Components</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Gul Inan, Hakan Demirtas, Ran Gao</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ran Gao &lt;rgao8@uic.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generation of multiple count, binary and continuous variables simultaneously 
             given the marginal characteristics and association structure. Throughout the package,
             the word 'Poisson' is used to imply count data under the assumption of Poisson distribution. 
             The details of the method are explained in Amatya et al. (2015) &lt;<a href="https://doi.org/10.1080%2F00949655.2014.953534">doi:10.1080/00949655.2014.953534</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>BB, corpcor, Matrix, mvtnorm</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-22 02:00:11 UTC; rangao</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-22 05:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='correlation.bound.check'>Checks if the pairwise correlation among variables are within the feasible range</h2><span id='topic+correlation.bound.check'></span>

<h3>Description</h3>

<p>This function checks if there are range violations among correlation of Poisson-Poisson, 
Poisson-binary, Poisson-continuous, binary-binary, binary-continuous, and continuous-continuous combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation.bound.check(n.P, n.B, n.C, lambda.vec = NULL, prop.vec = NULL, 
coef.mat = NULL, corr.vec = NULL, corr.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlation.bound.check_+3A_n.p">n.P</code></td>
<td>
<p>Number of Poisson variables.</p>
</td></tr>
<tr><td><code id="correlation.bound.check_+3A_n.b">n.B</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="correlation.bound.check_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="correlation.bound.check_+3A_lambda.vec">lambda.vec</code></td>
<td>
<p>Rate vector for Poisson variables.</p>
</td></tr>
<tr><td><code id="correlation.bound.check_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Proportion vector for binary variables.</p>
</td></tr>
<tr><td><code id="correlation.bound.check_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
<tr><td><code id="correlation.bound.check_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered column-wise.</p>
</td></tr>
<tr><td><code id="correlation.bound.check_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns TRUE if no specification problem is encountered. Otherwise, it returns an error message.</p>


<h3>References</h3>

<p>Demirtas, H. and Hedeker, D. (2011). A practical way for computing approximate lower and upper
correlation bounds. The American Statistician, 65(2), 104-109.
</p>
<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data
by power polynomials. Statistics in Medicine, 31(27), 3337-3346.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+validation.corr">validation.corr</a></code>, <code><a href="#topic+correlation.limits">correlation.limits</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n.P&lt;-1
n.B&lt;-1
n.C&lt;-1
lambda.vec&lt;-c(1)
prop.vec&lt;-c(0.3)
coef.mat&lt;-matrix(c(-0.3137491,0.8263239,0.3137491,0.0227066),4,1,byrow=F) 
corr.mat=matrix(c(1,0.2,0.1,0.2,1,0.5,0.1,0.5,1),3,3)
correlation.bound.check(n.P,n.B,n.C,lambda.vec,prop.vec,coef.mat,corr.vec=NULL, 
corr.mat)

n.P&lt;-2
n.B&lt;-2
n.C&lt;-2
lambda.vec&lt;-c(1,2)
prop.vec&lt;-c(0.3,0.5)
coef.mat&lt;-matrix(c(
-0.3137491,  0.0000000,   
 0.8263239,  1.0857433,    
 0.3137491,  0.0000000,
 0.0227066, -0.0294495),4,2,byrow=F)  
corr.mat=matrix(0.8,6,6)
diag(corr.mat)=1
correlation.bound.check(n.P,n.B,n.C,lambda.vec,prop.vec,coef.mat,corr.vec=NULL, 
corr.mat)

## End(Not run)
</code></pre>

<hr>
<h2 id='correlation.limits'>Computes lower and upper correlation bounds for each pair of variables</h2><span id='topic+correlation.limits'></span>

<h3>Description</h3>

<p>This function computes lower and upper limits for pairwise correlations of Poisson-Poisson, 
Poisson-binary, Poisson-continuous, binary-binary, binary-continuous, and continuous-continuous combinations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation.limits(n.P, n.B, n.C, lambda.vec = NULL, prop.vec = NULL, 
coef.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlation.limits_+3A_n.p">n.P</code></td>
<td>
<p>Number of Poisson variables.</p>
</td></tr>
<tr><td><code id="correlation.limits_+3A_n.b">n.B</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="correlation.limits_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="correlation.limits_+3A_lambda.vec">lambda.vec</code></td>
<td>
<p>Rate vector for Poisson variables.</p>
</td></tr>
<tr><td><code id="correlation.limits_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Proportion vector for binary variables.</p>
</td></tr>
<tr><td><code id="correlation.limits_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While the function computes the exact lower and upper bounds for pairwise correlations among
binary-binary variables as formulated in Demirtas et al. (2012), it computes approximate lower and
upper bounds for pairwise correlations among Poisson-Poisson, Poisson-binary, Poisson-continuous, 
binary-continuous, and continuous-continuous variables through the method suggested by Demirtas and Hedeker (2011).</p>


<h3>Value</h3>

<p>The function returns a matrix of size (n.P + n.B + n.C)*(n.P + n.B + n.C), where the lower triangular
part of the matrix contains the lower bounds and the upper triangular part of the matrix contains the
upper bounds of the feasible correlations.</p>


<h3>References</h3>

<p>Demirtas, H. and Hedeker, D. (2011). A practical way for computing approximate lower and upper
correlation bounds. The American Statistician, 65(2), 104-109.
</p>
<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data
by power polynomials. Statistics in Medicine, 31(27), 3337-3346.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+validation.corr">validation.corr</a></code>, <code><a href="#topic+correlation.bound.check">correlation.bound.check</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n.P&lt;-3
n.B&lt;-2
n.C&lt;-3
lambda.vec&lt;-c(1,2,3)
prop.vec&lt;-c(0.3,0.5)
coef.mat&lt;-matrix(c(
-0.3137491,  0.0000000,  0.1004464, 
 0.8263239,  1.0857433,  1.1050196,  
 0.3137491,  0.0000000, -0.1004464,
 0.0227066, -0.0294495, -0.0400078),4,3,byrow=F)  

#Correlation limits among Poisson variables
correlation.limits(n.P,n.B=0,n.C=0,lambda.vec,prop.vec=NULL,coef.mat=NULL)

#See also Cor.PP.Limit in R package PoisNor 

#Correlation limits among binary variables
correlation.limits(n.P=0,n.B,n.C=0,lambda.vec=NULL,prop.vec,coef.mat=NULL)

#See also correlation.limits in R package BinNonNor 

#Correlation limits among continuous variables
correlation.limits(n.P=0,n.B=0,n.C,lambda.vec=NULL,prop.vec=NULL,coef.mat)

#Correlation limits among Poisson and binary variables and within themselves.
correlation.limits(n.P,n.B,n.C=0,lambda.vec,prop.vec,coef.mat=NULL)

#Correlation limits among Poisson and continuous variables and within themselves.
correlation.limits(n.P,n.B=0,n.C,lambda.vec,prop.vec=NULL,coef.mat)

#Correlation limits among binary and continuous variables and within themselves.
correlation.limits(n.P=0,n.B,n.C,lambda.vec=NULL,prop.vec,coef.mat)

#Correlation limits among Poisson, binary, and continuous variables and within themselves.
correlation.limits(n.P,n.B,n.C,lambda.vec,prop.vec,coef.mat)

n.P&lt;-2
lambda.vec=c(-1,1)
correlation.limits(n.P,n.B=0,n.C=0,lambda.vec,prop.vec=NULL,coef.mat=NULL)


## End(Not run)
</code></pre>

<hr>
<h2 id='fleishman.coef'>Computes the coefficients of Fleishman third order polynomials</h2><span id='topic+fleishman.coef'></span>

<h3>Description</h3>

<p>Computes the coefficients of Fleishman third order polynomials given the marginal skewness and kurtosis parameters of
continuous variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fleishman.coef(n.C, skewness.vec = NULL, kurtosis.vec = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fleishman.coef_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="fleishman.coef_+3A_skewness.vec">skewness.vec</code></td>
<td>
<p>Skewness vector for continuous variables.</p>
</td></tr>
<tr><td><code id="fleishman.coef_+3A_kurtosis.vec">kurtosis.vec</code></td>
<td>
<p>Kurtosis vector for continuous variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The execution of the function may take some time since it uses multiple starting points to solve the system of nonlinear equations based on 
the third order Fleishman polynomials. However, since users need to run it only once for a given set of specifications, it does not constitute a problem.</p>


<h3>Value</h3>

<p>A matrix of coefficients. The columns represent the variables and rows represent the corresponding a,b,c, and d coefficients.</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.
</p>
<p>Fleishman, A.I. (1978). A method for simulating non-normal distributions. Psychometrika, 43(4), 521-532.</p>


<h3>See Also</h3>

<p><code><a href="#topic+validation.skewness.kurtosis">validation.skewness.kurtosis</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Consider four continuous variables, which come from
#Exp(1),Beta(4,4),Beta(4,2) and Gamma(10,10), respectively.
#Skewness and kurtosis values of these variables are as follows:
n.C&lt;-4
skewness.vec=c(2,0,-0.4677,0.6325)
kurtosis.vec=c(6,-0.5455,-0.3750,0.6)
coef.mat=fleishman.coef(n.C,skewness.vec,kurtosis.vec)

n.C&lt;-1
skewness.vec=c(0)
kurtosis.vec=c(-1.2)
coef.mat=fleishman.coef(n.C,skewness.vec,kurtosis.vec)

n.C&lt;-1
skewness.vec1=c(3)
kurtosis.vec1=c(5)
coef.mat=fleishman.coef(n.C,skewness.vec1,kurtosis.vec1)

## End(Not run)
</code></pre>

<hr>
<h2 id='gen.PoisBinNonNor'>Simulates a sample of size n from a set of multivariate Poisson, binary, and
continuous data</h2><span id='topic+gen.PoisBinNonNor'></span>

<h3>Description</h3>

<p>This function simulates a sample of size n from a set of multivariate Poisson, binary, and
continuous data with pre-specified marginals and a correlation matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.PoisBinNonNor(n, n.P, n.B, n.C, lambda.vec = NULL, prop.vec = NULL, 
mean.vec=NULL, variance.vec=NULL, coef.mat = NULL, final.corr.mat)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.PoisBinNonNor_+3A_n">n</code></td>
<td>
<p>Number of variates.</p>
</td></tr>
<tr><td><code id="gen.PoisBinNonNor_+3A_n.p">n.P</code></td>
<td>
<p>Number of Poisson variables.</p>
</td></tr>
<tr><td><code id="gen.PoisBinNonNor_+3A_n.b">n.B</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="gen.PoisBinNonNor_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="gen.PoisBinNonNor_+3A_lambda.vec">lambda.vec</code></td>
<td>
<p>Rate vector for Poisson variables.</p>
</td></tr>
<tr><td><code id="gen.PoisBinNonNor_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Proportion vector for binary variables.</p>
</td></tr>
<tr><td><code id="gen.PoisBinNonNor_+3A_mean.vec">mean.vec</code></td>
<td>
<p>Mean vector of continuous variables.</p>
</td></tr>
<tr><td><code id="gen.PoisBinNonNor_+3A_variance.vec">variance.vec</code></td>
<td>
<p>Variance vector of continuous variables.</p>
</td></tr>
<tr><td><code id="gen.PoisBinNonNor_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
<tr><td><code id="gen.PoisBinNonNor_+3A_final.corr.mat">final.corr.mat</code></td>
<td>
<p>Final correlation matrix produced from <code><a href="#topic+overall.corr.mat">overall.corr.mat</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size n*(n.P + n.B + n.C), of which the first n.P 
columns are Poisson variables, the next n.B columns are binary variables, and the last n.C 
columns are continuous variables.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n=100000
n.P&lt;-2
n.B&lt;-2
n.C&lt;-2
lambda.vec&lt;-c(2,3)
prop.vec&lt;-c(0.3,0.5)
mean.vec&lt;-c(0,0)
variance.vec&lt;-c(1,1)
coef.mat=matrix(rep(c(0,1,0,0), each=2),4,2,byrow=T)
corr.mat=matrix(0.4,6,6)
diag(corr.mat)=1
final.corr.mat=overall.corr.mat(n.P,n.B,n.C,lambda.vec,prop.vec, 
coef.mat,corr.vec=NULL,corr.mat)

mymixdata=gen.PoisBinNonNor(n,n.P,n.B,n.C,lambda.vec,prop.vec, 
mean.vec,variance.vec,coef.mat,final.corr.mat)

#Check marginals
#apply(mymixdata,2,mean)
#cor(mymixdata)

n=100000
n.P&lt;-2
n.B&lt;-2
n.N&lt;-2
lambda.vec&lt;-c(2,3)
prop.vec&lt;-c(0.3,0.5)
mean.vec=c(1,0.5)
variance.vec=c(1,0.02777778)
skewness.vec=c(2,0)
kurtosis.vec=c(6,-0.5455)
coef.mat=fleishman.coef(2,skewness.vec, kurtosis.vec)
corr.mat=matrix(0.3,6,6)
diag(corr.mat)=1
final.corr.mat=overall.corr.mat(n.P,n.B,n.N,lambda.vec,prop.vec,
coef.mat,corr.vec=NULL,corr.mat)
mymixdata=gen.PoisBinNonNor(n,n.P,n.B,n.N,lambda.vec,prop.vec,
mean.vec, variance.vec,coef.mat,final.corr.mat)

#Check marginals
#apply(mymixdata,2,mean)[4:5] 
#apply(mymixdata,2,var)[4:5]  
#cor(mymixdata)

## End(Not run)
</code></pre>

<hr>
<h2 id='intermediate.corr.BB'>Computes an intermediate normal correlation matrix for binary variables given 
the specified correlation matrix</h2><span id='topic+intermediate.corr.BB'></span>

<h3>Description</h3>

<p>Computes an intermediate normal correlation matrix for binary variables before 
dichotomization given the specified correlation matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>intermediate.corr.BB(n.P, n.B, n.C, prop.vec, corr.vec = NULL, corr.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intermediate.corr.BB_+3A_n.p">n.P</code></td>
<td>
<p>Number of Poisson variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.BB_+3A_n.b">n.B</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.BB_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.BB_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Proportion vector for binary variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.BB_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered column-wise.</p>
</td></tr>
<tr><td><code id="intermediate.corr.BB_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix of size n.B*n.B.</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.</p>


<h3>See Also</h3>

<p><code><a href="#topic+intermediate.corr.PB">intermediate.corr.PB</a></code>, <code><a href="#topic+intermediate.corr.BC">intermediate.corr.BC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n.P&lt;-2
n.B&lt;-2
n.C&lt;-2
prop.vec=c(0.4,0.7)
corr.vec = NULL
corr.mat=matrix(c(1.0,-0.3,-0.3,-0.3,-0.3,-0.3,
-0.3,1.0,-0.3,-0.3,-0.3,-0.3,
-0.3,-0.3,1.0,0.4,0.5,0.6,
-0.3,-0.3,0.4,1.0,0.7,0.8,
-0.3,-0.3,0.5,0.7,1.0,0.9,
-0.3,-0.3,0.6,0.8,0.9,1.0),6,by=TRUE)

intmatBB=intermediate.corr.BB(n.P,n.B,n.C,prop.vec,corr.vec=NULL,corr.mat)
intmatBB

## End(Not run)
</code></pre>

<hr>
<h2 id='intermediate.corr.BC'>Computes intermediate correlation matrix for binary and continuous variables given the specified correlation matrix</h2><span id='topic+intermediate.corr.BC'></span>

<h3>Description</h3>

<p>This function computes the intermediate correlation matrix for binary-continuous combinations as formulated in Demirtas et al.
(2012).</p>


<h3>Usage</h3>

<pre><code class='language-R'>intermediate.corr.BC(n.P, n.B, n.C, lambda.vec = NULL, prop.vec = NULL, 
coef.mat = NULL, corr.vec = NULL, corr.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intermediate.corr.BC_+3A_n.p">n.P</code></td>
<td>
<p>Number of Poisson variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.BC_+3A_n.b">n.B</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.BC_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.BC_+3A_lambda.vec">lambda.vec</code></td>
<td>
<p>Rate vector for Poisson variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.BC_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Proportion vector for binary variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.BC_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
<tr><td><code id="intermediate.corr.BC_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered column-wise.</p>
</td></tr>
<tr><td><code id="intermediate.corr.BC_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix of size n.B*n.C.</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.</p>


<h3>See Also</h3>

<p><code><a href="#topic+intermediate.corr.BB">intermediate.corr.BB</a></code>, <code><a href="#topic+intermediate.corr.CC">intermediate.corr.CC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n.B&lt;-2
n.C&lt;-4
prop.vec=c(0.4,0.7)
coef.mat=matrix(c(
 -0.31375,  0.00000,  0.10045, -0.10448,
  0.82632,  1.08574,  1.10502,  0.98085,
  0.31375,  0.00000, -0.10045,  0.10448,
  0.02271, -0.02945, -0.04001,  0.00272),4,byrow=TRUE)
corr.vec = NULL
corr.mat=matrix(c(1.0,-0.3,-0.3,-0.3,-0.3,-0.3,
-0.3,1.0,-0.3,-0.3,-0.3,-0.3,
-0.3,-0.3,1.0,0.4,0.5,0.6,
-0.3,-0.3,0.4,1.0,0.7,0.8,
-0.3,-0.3,0.5,0.7,1.0,0.9,
-0.3,-0.3,0.6,0.8,0.9,1.0),6,byrow=TRUE)

intmatBC=intermediate.corr.BC(n.P=0,n.B,n.C,lambda.vec=NULL,prop.vec,coef.mat, 
corr.vec=NULL,corr.mat)
intmatBC

n.B&lt;-1
n.C&lt;-1
prop.vec=0.6
coef.mat=matrix(c(-0.31375,0.82632,0.31375,0.02271),4,1)
corr.vec=NULL
corr.mat=matrix(c(1,-0.3,-0.3,1),2,2)

intmatBC=intermediate.corr.BC(n.P=0,n.B,n.C,lambda.vec=NULL,prop.vec,coef.mat, 
corr.vec=NULL,corr.mat)
intmatBC

## End(Not run)
</code></pre>

<hr>
<h2 id='intermediate.corr.CC'>Computes an intermediate correlation matrix for continuous variables given the specified correlation 
matrix</h2><span id='topic+intermediate.corr.CC'></span>

<h3>Description</h3>

<p>This function computes the intermediate correlation matrix for continuous-continuous 
combinations as formulated in Demirtas et al. (2012).</p>


<h3>Usage</h3>

<pre><code class='language-R'>intermediate.corr.CC(n.P, n.B, n.C, coef.mat = NULL, corr.vec = NULL, corr.mat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intermediate.corr.CC_+3A_n.p">n.P</code></td>
<td>
<p>Number of Poisson variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.CC_+3A_n.b">n.B</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.CC_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.CC_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
<tr><td><code id="intermediate.corr.CC_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered column-wise.</p>
</td></tr>
<tr><td><code id="intermediate.corr.CC_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix of size n.C*n.C.</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.
</p>
<p>Vale, C.D. and Maurelli, V.A. (1983). Simulating multivariate nonnormal distributions. Psychometrika, 48(3), 465-471.</p>


<h3>See Also</h3>

<p><code><a href="#topic+intermediate.corr.PC">intermediate.corr.PC</a></code>, <code><a href="#topic+intermediate.corr.BC">intermediate.corr.BC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n.P=2
n.C=4
coef.mat=matrix(c(
 -0.31375,  0.00000,  0.10045, -0.10448,
  0.82632,  1.08574,  1.10502,  0.98085,
  0.31375,  0.00000, -0.10045,  0.10448,
  0.02271, -0.02945, -0.04001,  0.00272),4,byrow=TRUE)
corr.vec = NULL
corr.mat=matrix(c(1.0,-0.3,-0.3,-0.3,-0.3,-0.3,
-0.3,1.0,-0.3,-0.3,-0.3,-0.3,
-0.3,-0.3,1.0,0.4,0.5,0.6,
-0.3,-0.3,0.4,1.0,0.7,0.8,
-0.3,-0.3,0.5,0.7,1.0,0.9,
-0.3,-0.3,0.6,0.8,0.9,1.0),6,byrow=TRUE)

intmatCC=intermediate.corr.CC(n.P,n.B=0,n.C,coef.mat,corr.vec=NULL,corr.mat)
intmatCC

## End(Not run)
</code></pre>

<hr>
<h2 id='intermediate.corr.PB'>Computes the pairwise entries of the intermediate normal correlation matrix for all Poisson-binary combinations 
given the specified correlation matrix.</h2><span id='topic+intermediate.corr.PB'></span>

<h3>Description</h3>

<p>This function computes the pairwise entries of the intermediate normal correlation matrix for all Poisson-binary 
combinations given the specified correlation matrix as formulated in Amatya and Demirtas (2015).</p>


<h3>Usage</h3>

<pre><code class='language-R'>intermediate.corr.PB(n.P, n.B, n.C, lambda.vec = NULL, prop.vec = NULL, 
coef.mat = NULL, corr.vec = NULL, corr.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intermediate.corr.PB_+3A_n.p">n.P</code></td>
<td>
<p>Number of Poisson variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PB_+3A_n.b">n.B</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PB_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PB_+3A_lambda.vec">lambda.vec</code></td>
<td>
<p>Rate vector for Poisson variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PB_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Proportion vector for binary variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PB_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PB_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered column-wise.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PB_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of n.P*n.B.</p>


<h3>References</h3>

<p>Amatya, A. and Demirtas, H. (2015). Simultaneous generation of multivariate mixed data with Poisson and normal
marginals. Journal of Statistical Computation and Simulation, (85)15, 3129-3139.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intermediate.corr.PP">intermediate.corr.PP</a></code>, <code><a href="#topic+intermediate.corr.BB">intermediate.corr.BB</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n.P&lt;-2
n.B&lt;-1
lambda.vec&lt;-c(2,3)
prop.vec&lt;-c(0.3)
corr.mat=matrix(c(1,0.2,0.1,0.2,1,0.5,0.1,0.5,1),3,3)

intmatPB=intermediate.corr.PB(n.P,n.B,n.C=0,lambda.vec,prop.vec,coef.mat=NULL, 
corr.vec=NULL,corr.mat)
intmatPB

## End(Not run)
</code></pre>

<hr>
<h2 id='intermediate.corr.PC'>Computes the pairwise entries of the intermediate normal correlation matrix for all Poisson-continuous combinations 
given the specified correlation matrix.</h2><span id='topic+intermediate.corr.PC'></span>

<h3>Description</h3>

<p>This function computes the pairwise entries of the intermediate normal correlation matrix for all Poisson-continuous 
combinations given the specified correlation matrix as formulated in Amatya and Demirtas (2015).</p>


<h3>Usage</h3>

<pre><code class='language-R'>intermediate.corr.PC(n.P, n.B, n.C, lambda.vec = NULL, prop.vec = NULL, coef.mat = NULL, 
corr.vec = NULL, corr.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intermediate.corr.PC_+3A_n.p">n.P</code></td>
<td>
<p>Number of Poisson variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PC_+3A_n.b">n.B</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PC_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PC_+3A_lambda.vec">lambda.vec</code></td>
<td>
<p>Rate vector for Poisson variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PC_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Proportion vector for binary variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PC_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PC_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered column-wise.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PC_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix of size n.P*n.C.</p>


<h3>References</h3>

<p>Amatya, A. and Demirtas, H. (2015). Simultaneous generation of multivariate mixed data with Poisson and normal
marginals. Journal of Statistical Computation and Simulation, (85)15, 3129-3139.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intermediate.corr.PP">intermediate.corr.PP</a></code>, <code><a href="#topic+intermediate.corr.CC">intermediate.corr.CC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n.P=2
n.C=4
lambda.vec=c(2,3)
coef.mat=matrix(rep(c(0,1,0,0),each=4),4,byrow=TRUE)
corr.vec = NULL
corr.mat=matrix(c(1.0,-0.3,-0.3,-0.3,-0.3,-0.3,
-0.3,1.0,-0.3,-0.3,-0.3,-0.3,
-0.3,-0.3,1.0,0.4,0.5,0.6,
-0.3,-0.3,0.4,1.0,0.7,0.8,
-0.3,-0.3,0.5,0.7,1.0,0.9,
-0.3,-0.3,0.6,0.8,0.9,1.0),6,byrow=TRUE)

intmatPC=intermediate.corr.PC(n.P,n.B=0,n.C,lambda.vec,prop.vec=NULL, 
coef.mat,corr.vec=NULL,corr.mat)

intmatPC

#See also cmat.star in  R package PoisNor 
#cmat.star(no.pois=2,no.norm=4,corMat=corr.mat,lamvec=lambda.vec)

## End(Not run)
</code></pre>

<hr>
<h2 id='intermediate.corr.PP'>Computes an intermediate normal correlation matrix for Poisson variables given the specified correlation matrix</h2><span id='topic+intermediate.corr.PP'></span>

<h3>Description</h3>

<p>This function computes the intermediate normal correlation matrix for Poisson-Poisson combinations before inverse cdf matching 
as formulated in Amatya and Demirtas (2015).</p>


<h3>Usage</h3>

<pre><code class='language-R'>intermediate.corr.PP(n.P, n.B, n.C, lambda.vec, corr.vec = NULL, corr.mat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intermediate.corr.PP_+3A_n.p">n.P</code></td>
<td>
<p>Number of Poisson variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PP_+3A_n.b">n.B</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PP_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PP_+3A_lambda.vec">lambda.vec</code></td>
<td>
<p>Rate vector for Poisson variables</p>
</td></tr>
<tr><td><code id="intermediate.corr.PP_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered column-wise.</p>
</td></tr>
<tr><td><code id="intermediate.corr.PP_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix of size n.P*n.P.</p>


<h3>References</h3>

<p>Amatya, A. and Demirtas, H. (2015). Simultaneous generation of multivariate mixed data with Poisson and normal
marginals. Journal of Statistical Computation and Simulation, (85)15, 3129-3139.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intermediate.corr.PB">intermediate.corr.PB</a></code>, <code><a href="#topic+intermediate.corr.PC">intermediate.corr.PC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n.P&lt;-3
lambda.vec&lt;-c(1,2,3)
corr.mat&lt;-matrix(c(1,0.352,0.265,0.352,1,0.121,0.265,0.121,1),n.P,n.P)
intmatPP=intermediate.corr.PP(n.P,n.B=0,n.C=0,lambda.vec,corr.vec=NULL,corr.mat)
intmatPP

## Not run: 
#See also cmat.star in  R package PoisNor 
#cmat.star(no.pois=3,no.norm=0,corMat=corr.mat,lamvec=lambda.vec)

## End(Not run)
</code></pre>

<hr>
<h2 id='overall.corr.mat'>Computes the final intermediate correlation matrix</h2><span id='topic+overall.corr.mat'></span>

<h3>Description</h3>

<p>This function computes the final correlation matrix by combining pairwise intermediate correlation matrix entries for Poisson-Poisson, 
Poisson-binary, Poisson-continuous, binary-binary, binary-continuous, and continuous-continuous combinations. If
the resulting correlation matrix is not positive definite, a nearest positive matrix will be used.</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall.corr.mat(n.P, n.B, n.C, lambda.vec = NULL, prop.vec = NULL, coef.mat = NULL, 
corr.vec = NULL, corr.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overall.corr.mat_+3A_n.p">n.P</code></td>
<td>
<p>Number of Poisson variables.</p>
</td></tr>
<tr><td><code id="overall.corr.mat_+3A_n.b">n.B</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="overall.corr.mat_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="overall.corr.mat_+3A_lambda.vec">lambda.vec</code></td>
<td>
<p>Rate vector for Poisson variables.</p>
</td></tr>
<tr><td><code id="overall.corr.mat_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Proportion vector for binary variables.</p>
</td></tr>
<tr><td><code id="overall.corr.mat_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
<tr><td><code id="overall.corr.mat_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered column-wise.</p>
</td></tr>
<tr><td><code id="overall.corr.mat_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix of size (n.P+N.B+n.C)*(n.P+N.B+n.C).</p>


<h3>See Also</h3>

<p><code><a href="#topic+intermediate.corr.PP">intermediate.corr.PP</a></code>, <code><a href="#topic+intermediate.corr.BB">intermediate.corr.BB</a></code>, <code><a href="#topic+intermediate.corr.CC">intermediate.corr.CC</a></code>,
</p>
<p><code><a href="#topic+intermediate.corr.PB">intermediate.corr.PB</a></code>, <code><a href="#topic+intermediate.corr.PC">intermediate.corr.PC</a></code>, <code><a href="#topic+intermediate.corr.BC">intermediate.corr.BC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n.P&lt;-1
n.B&lt;-1
n.C&lt;-1
lambda.vec&lt;-c(1)
prop.vec&lt;-c(0.3)
coef.mat&lt;-matrix(c(0,1,0,0),4,1)
corr.vec=NULL
corr.mat=matrix(c(1,0.2,0.1,0.2,1,0.5,0.1,0.5,1),3,3)

finalmat=overall.corr.mat(n.P,n.B,n.C,lambda.vec,prop.vec,coef.mat, 
corr.vec=NULL,corr.mat)
finalmat

## End(Not run)
</code></pre>

<hr>
<h2 id='PoisBinNonNor-package'>Data Generation with Count, Binary and Continuous Components</h2><span id='topic+PoisBinNonNor-package'></span><span id='topic+PoisBinNonNor'></span>

<h3>Description</h3>

<p>Provides R functions for generation of multiple count, binary and continuous variables 
simultaneously given the marginal characteristics and association structure. Continuous variables can be 
of any nonnormal shape allowed by the Fleishman polynomials, taking the normal distribution as a special case.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> PoisBinNonNor</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-03-21</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package consists of fourteen functions. The functions <code><a href="#topic+validation.bin">validation.bin</a></code>, <code><a href="#topic+validation.corr">validation.corr</a></code>, and 
<code><a href="#topic+validation.skewness.kurtosis">validation.skewness.kurtosis</a></code> validate the specified quantities. <code><a href="#topic+correlation.limits">correlation.limits</a></code> returns the lower and upper bounds of pairwise correlations of 
Poisson, binary and continuous variables. <code><a href="#topic+correlation.bound.check">correlation.bound.check</a></code>
validates pairwise correlation values.
<br /> <code><a href="#topic+intermediate.corr.PP">intermediate.corr.PP</a></code>, <code><a href="#topic+intermediate.corr.BB">intermediate.corr.BB</a></code>, <code><a href="#topic+intermediate.corr.CC">intermediate.corr.CC</a></code>, 
<br /> <code><a href="#topic+intermediate.corr.PB">intermediate.corr.PB</a></code>, <code><a href="#topic+intermediate.corr.PC">intermediate.corr.PC</a></code>, and <code><a href="#topic+intermediate.corr.BC">intermediate.corr.BC</a></code> 
compute intermediate correlation matrix for Poisson-Poisson combinations, binary-binary, 
continuous-continuous, Poisson-binary, Poisson-continuous,
binary-continuous combinations, respectively.  The function <code><a href="#topic+overall.corr.mat">overall.corr.mat</a></code> assembles 
the final correlation matrix. The engine function <code><a href="#topic+gen.PoisBinNonNor">gen.PoisBinNonNor</a></code>
generates mixed data in accordance with the specified marginal and correlational quantities.
Throughout the package, variables are supposed to be inputted in a certain order, namely, 
first count variables, next binary variables, and then continuous variables should be placed. 
</p>


<h3>Author(s)</h3>

<p>Gul Inan, Hakan Demirtas, Ran Gao 
</p>
<p>Maintainer: Ran Gao &lt;rgao8@uic.edu&gt;</p>


<h3>References</h3>

<p>Amatya, A. and Demirtas, H. (2015). Simultaneous generation of multivariate mixed data with Poisson and normal
marginals. Journal of Statistical Computation and Simulation, (85)15, 3129-3139.
</p>
<p>Demirtas, H. and Hedeker, D. (2011). A practical way for computing approximate lower and upper
correlation bounds. The American Statistician, 65(2), 104-109.
</p>
<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data
by power polynomials. Statistics in Medicine, 31(27), 3337-3346.
</p>

<hr>
<h2 id='validation.bin'>Validates the marginal specification of the binary variables</h2><span id='topic+validation.bin'></span>

<h3>Description</h3>

<p>Checks whether the marginal specification of the binary part is valid and consistent.</p>


<h3>Usage</h3>

<pre><code class='language-R'>validation.bin(n.B, prop.vec = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validation.bin_+3A_n.b">n.B</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="validation.bin_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Proportion vector for binary variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns TRUE if no specification problem is encountered. Otherwise, it returns an error message.</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.B&lt;-3
prop.vec&lt;-c(0.25,0.5,0.75)
validation.bin(n.B, prop.vec)

## Not run: 
n.B&lt;-3
validation.bin(n.B)

n.B&lt;--3
prop.vec&lt;-c(0.25,0.5,0.75)
validation.bin(n.B, prop.vec)

n.B&lt;-0
prop.vec&lt;-c(0.25,0.5,0.75)
validation.bin(n.B, prop.vec)

n.B&lt;-5
prop.vec&lt;-c(0.25,0.5,0.75)
validation.bin(n.B, prop.vec)

n.B&lt;-3
prop.vec&lt;-c(0.25,0.5,-0.75)
validation.bin(n.B, prop.vec)

## End(Not run)
</code></pre>

<hr>
<h2 id='validation.corr'>Validates the specified correlation matrix</h2><span id='topic+validation.corr'></span>

<h3>Description</h3>

<p>This function validates the specified correlation vector and/or matrix for appropriate dimension,
symmetry, range, and positive definiteness. If both correlation matrix and correlation vector are
supplied, it checks whether the matrix and vector are conformable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>validation.corr(n.P, n.B, n.C, corr.vec = NULL, corr.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validation.corr_+3A_n.p">n.P</code></td>
<td>
<p>Number of Poisson variables.</p>
</td></tr>
<tr><td><code id="validation.corr_+3A_n.b">n.B</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="validation.corr_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="validation.corr_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered column-wise.</p>
</td></tr>
<tr><td><code id="validation.corr_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns TRUE if no specification problem is encountered. Otherwise, it returns an
error message.</p>


<h3>See Also</h3>

<p><code><a href="#topic+correlation.limits">correlation.limits</a></code>, <code><a href="#topic+correlation.bound.check">correlation.bound.check</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>n.P&lt;-1
n.B&lt;-1
n.C&lt;-1
corr.vec=c(0.2,0.1,0.5)
validation.corr(n.P,n.B,n.C,corr.vec,corr.mat=NULL)

n.P&lt;-2
n.B&lt;-2
n.C&lt;-2
corr.mat=matrix(0.5,6,6)
diag(corr.mat)=1
validation.corr(n.P,n.B,n.C,corr.vec=NULL,corr.mat)

## Not run: 
n.P&lt;-2
n.B&lt;-2
n.C&lt;-1
corr.mat=matrix(0.5,6,6)
diag(corr.mat)=1
validation.corr(n.P,n.B,n.C,corr.vec=NULL,corr.mat)

n.P&lt;-2
n.B&lt;-2
n.C&lt;-2
corr.mat=matrix(0.5,6,6)
corr.mat[1,2]=0.4
diag(corr.mat)=1
validation.corr(n.P,n.B,n.C,corr.vec=NULL,corr.mat)

## End(Not run)
</code></pre>

<hr>
<h2 id='validation.skewness.kurtosis'>Validates the marginal specification of the continuous variables</h2><span id='topic+validation.skewness.kurtosis'></span>

<h3>Description</h3>

<p>Checks whether the marginal specification of the continuous part is valid and consistent.</p>


<h3>Usage</h3>

<pre><code class='language-R'>validation.skewness.kurtosis(n.C, skewness.vec = NULL, kurtosis.vec = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validation.skewness.kurtosis_+3A_n.c">n.C</code></td>
<td>
<p>Number of continuous variables.</p>
</td></tr>
<tr><td><code id="validation.skewness.kurtosis_+3A_skewness.vec">skewness.vec</code></td>
<td>
<p>Skewness vector for continuous variables.</p>
</td></tr>
<tr><td><code id="validation.skewness.kurtosis_+3A_kurtosis.vec">kurtosis.vec</code></td>
<td>
<p>Kurtosis vector for continuous variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns TRUE if no specification problem is encountered. Otherwise, it returns an error message.</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.C&lt;-3
skewness.vec=c(0,2,3)
kurtosis.vec=c(-1.2,6,8)
validation.skewness.kurtosis(n.C,skewness.vec,kurtosis.vec)

## Not run: 
n.C&lt;--1
skewness.vec=c(0)
kurtosis.vec=c(-1.2)
validation.skewness.kurtosis(n.C,skewness.vec,kurtosis.vec)

n.C&lt;-3
skewness.vec=c(0,2,3)
kurtosis.vec=c(-1.2,6,5)
validation.skewness.kurtosis(3)

n.C&lt;-3
skewness.vec=c(0,2,3)
kurtosis.vec=c(-1.2,6,5)
validation.skewness.kurtosis(n.C,skewness.vec)
validation.skewness.kurtosis(n.C,kurtosis.vec)

n.C&lt;-0
skewness.vec=c(0,2,3)
kurtosis.vec=c(-1.2,6,8)
validation.skewness.kurtosis(n.C,skewness.vec,kurtosis.vec)

n.C&lt;-2
skewness.vec=c(0,2,3)
kurtosis.vec=c(-1.2,6,8)
validation.skewness.kurtosis(n.C,skewness.vec,kurtosis.vec)

n.C&lt;-2
skewness.vec=c(0,2,3)
kurtosis.vec=c(-1.2,6)
validation.skewness.kurtosis(n.C,skewness.vec,kurtosis.vec)

skewness.vec=c(2,3)
kurtosis.vec=c(1,5)
validation.skewness.kurtosis(n.C,skewness.vec,kurtosis.vec)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
