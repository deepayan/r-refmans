<!DOCTYPE html><html lang="en"><head><title>Help for package msir</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {msir}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#msir-package'><p>Model-based Sliced Inverse Regression (MSIR)</p></a></li>
<li><a href='#loess.sd'><p>Local Polynomial Regression Fitting with Variability bands</p></a></li>
<li><a href='#msir'><p>Model-based Sliced Inverse Regression (MSIR)</p></a></li>
<li><a href='#msir-internal'><p>Internal <code>'msir'</code> functions</p></a></li>
<li><a href='#msir.bic'><p>BIC-type criterion for dimensionality</p></a></li>
<li><a href='#msir.nslices'><p>Default number of slices</p></a></li>
<li><a href='#msir.permutation.test'><p>Permutation test for dimensionality</p></a></li>
<li><a href='#msir.regularizedSigma'><p>Regularized estimate of predictors covariance matrix.</p></a></li>
<li><a href='#msir.slices'><p>Slice a vector into slices of approximately equal size</p></a></li>
<li><a href='#plot.msir'><p>Plot method for <code>'msir'</code> objects.</p></a></li>
<li><a href='#predict.msir'><p>Model-based Sliced Inverse Regression directions</p></a></li>
<li><a href='#spinplot'><p>Rotating three-dimensional plot</p></a></li>
<li><a href='#summary.msir'><p>Summary and print methods for <code>'msir'</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-12-15</td>
</tr>
<tr>
<td>Title:</td>
<td>Model-Based Sliced Inverse Regression</td>
</tr>
<tr>
<td>Description:</td>
<td>An R package for dimension reduction based on finite Gaussian mixture modeling of inverse regression.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mclust (&ge; 5.4), stats, utils, graphics, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.20), rmarkdown (&ge; 1.10), rgl (&ge; 0.100)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mclust-org.github.io/msir/">https://mclust-org.github.io/msir/</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-12-16 09:45:43 UTC; luca</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Scrucca <a href="https://orcid.org/0000-0003-3826-0484"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Scrucca &lt;luca.scrucca@unipg.it&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-12-16 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='msir-package'>Model-based Sliced Inverse Regression (MSIR)</h2><span id='topic+msir-package'></span>

<h3>Description</h3>

<p>An R package that implements MSIR, a dimension reduction method based on Gaussian finite mixture models. The basis of the subspace is estimated by modeling the inverse distribution within slice using finite mixtures of Gaussians, with number of components and covariance matrix parameterization selected by BIC or defined by the user.
The method provides an extension to sliced inverse regression (SIR) and allows to overcome the main limitation of SIR, i.e., the failure in the presence of regression symmetric relationships, without the need to impose further assumptions.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>References</h3>

<p>Scrucca, L. (2011) Model-based SIR for dimension reduction. 
<em>Computational Statistics &amp; Data Analysis</em>, 55(11), 3010-3026.</p>


<h3>See Also</h3>

<p><code><a href="#topic+msir">msir</a></code></p>

<hr>
<h2 id='loess.sd'>Local Polynomial Regression Fitting with Variability bands</h2><span id='topic+loess.sd'></span><span id='topic+panel.loess'></span>

<h3>Description</h3>

<p>Nonparametric estimation of mean function with variability bands.</p>


<h3>Usage</h3>

<pre><code class='language-R'>loess.sd(x, y = NULL, nsigma = 1, ...)

panel.loess(x, y, col = par("col"), bg = NA, pch = par("pch"), cex = 1, 
            col.smooth = "red", span = 2/3, degree = 2, nsigma = 1, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loess.sd_+3A_x">x</code></td>
<td>
<p>a vector of values for the predictor variable <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code id="loess.sd_+3A_y">y</code></td>
<td>
<p>a vector of values for the response variable <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="loess.sd_+3A_nsigma">nsigma</code></td>
<td>
<p>a multiplier for the standard deviation function.</p>
</td></tr>
<tr><td><code id="loess.sd_+3A_col">col</code>, <code id="loess.sd_+3A_bg">bg</code>, <code id="loess.sd_+3A_pch">pch</code>, <code id="loess.sd_+3A_cex">cex</code></td>
<td>
<p>numeric or character codes for the color(s), point type and size of points; see also <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="loess.sd_+3A_col.smooth">col.smooth</code></td>
<td>
<p>color to be used by <code>lines</code> for drawing the smooths.</p>
</td></tr>
<tr><td><code id="loess.sd_+3A_span">span</code></td>
<td>
<p>smoothing parameter for <code><a href="stats.html#topic+loess">loess</a></code>.</p>
</td></tr>
<tr><td><code id="loess.sd_+3A_degree">degree</code></td>
<td>
<p>the degree of the polynomials to be used, see <code><a href="stats.html#topic+loess">loess</a></code>.</p>
</td></tr>
<tr><td><code id="loess.sd_+3A_...">...</code></td>
<td>
<p>further argument passed to the function <code><a href="stats.html#topic+loess">loess</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>loess.sd</code> computes the loess smooth for the mean function and the mean plus and minus <code>k</code> times the standard deviation function.
</p>
<p>The function <code>panel.loess</code> can be used to add to a scatterplot matrix panel a smoothing of mean function using loess with variability bands at plus and minus <code>nsigmas</code> times the standard deviation.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>References</h3>

<p>Weisberg, S. (2005) Applied Linear Regression, 3rd ed., Wiley, New York, pp. 275-278.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+loess">loess</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cars)
plot(cars, main = "lowess.sd(cars)")
lines(l &lt;- loess.sd(cars))
lines(l$x, l$upper, lty=2)
lines(l$x, l$lower, lty=2)
</code></pre>

<hr>
<h2 id='msir'>Model-based Sliced Inverse Regression (MSIR)</h2><span id='topic+msir'></span><span id='topic+print.msir'></span>

<h3>Description</h3>

<p>A dimension reduction method based on Gaussian finite mixture models which provides an extension to sliced inverse regression (SIR). The basis of the subspace is estimated by modeling the inverse distribution within slice using Gaussian finite mixtures with number of components and covariance matrix parameterization selected by BIC or defined by the user.</p>


<h3>Usage</h3>

<pre><code class='language-R'>msir(x, y, nslices = msir.nslices, slice.function = msir.slices, 
     modelNames = NULL, G = NULL, cov = c("mle", "regularized"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msir_+3A_x">x</code></td>
<td>
<p>A <code class="reqn">(n \times p)</code> design matrix containing the predictors data values.</p>
</td></tr>
<tr><td><code id="msir_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">(n \times 1)</code> vector of data values for the response variable. It can be a numeric vector (regression) but also a factor (classification). In the latter case, the levels of the factor define the slices used.</p>
</td></tr>
<tr><td><code id="msir_+3A_nslices">nslices</code></td>
<td>
<p>The number of slices used, unless <code>y</code> is a factor. By default the value returned by <code><a href="#topic+msir.nslices">msir.nslices</a></code>.</p>
</td></tr>
<tr><td><code id="msir_+3A_slice.function">slice.function</code></td>
<td>
<p>The slice functions to be used, by default <code><a href="#topic+msir.slices">msir.slices</a></code>, but the user can provide a different slicing function.</p>
</td></tr>
<tr><td><code id="msir_+3A_modelnames">modelNames</code></td>
<td>
<p>A vector of character strings indicating the Gaussian mixture models to be fitted as described in <code><a href="mclust.html#topic+mclustModelNames">mclustModelNames</a></code>. If a  vector of strings is given they are used for all the slices. If a list of vectors is provided then each vector refers to a single slice.</p>
</td></tr>
<tr><td><code id="msir_+3A_g">G</code></td>
<td>
<p>An integer vector specifying the numbers of mixture components used in fitting Gaussian mixture models. If a list of vectors is provided then each vector refers to a single slice.</p>
</td></tr>
<tr><td><code id="msir_+3A_cov">cov</code></td>
<td>
<p>The predictors marginal covariance matrix. Possible choices are:
</p>

<ul>
<li> <p><code>"mle"</code>: for the maximum likelihood estimate
</p>
</li>
<li> <p><code>"regularized"</code>: for a regularized estimate of the covariance matrix (see <code><a href="#topic+msir.regularizedSigma">msir.regularizedSigma</a></code>)
</p>
</li>
<li> <p><code>R matrix</code>: a <code class="reqn">(p \times p)</code> user defined covariance matrix
</p>
</li></ul>

</td></tr>
<tr><td><code id="msir_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>msir.compute</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>'msir'</code> with attributes:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the design matrix.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector.</p>
</td></tr>
<tr><td><code>slice.info</code></td>
<td>
<p>output from slicing function.</p>
</td></tr>
<tr><td><code>mixmod</code></td>
<td>
<p>a list of finite mixture model objects as described in  <code><a href="mclust.html#topic+mclustModel">mclustModel</a></code>.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the log-likelihood for the mixture models.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>a vector of length equal to the total number of mixture components containing the fraction of observations in each fitted component within slices.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a matrix of component within slices predictors means.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the marginal predictors covariance matrix.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>the msir kernel matrix.</p>
</td></tr>
<tr><td><code>evalues</code></td>
<td>
<p>the eigenvalues from the generalized eigen-decomposition of <code>M</code>.</p>
</td></tr>
<tr><td><code>evectors</code></td>
<td>
<p>the raw eigenvectors from the generalized eigen-decomposition of <code>M</code> ordered according to the eigenvalues.</p>
</td></tr>
<tr><td><code>basis</code></td>
<td>
<p>the normalized eigenvectors from the generalized eigen-decomposition of <code>M</code> ordered according to the eigenvalues.</p>
</td></tr>
<tr><td><code>std.basis</code></td>
<td>
<p>standardized basis vectors obtained by multiplying each coefficient of the eigenvectors by the standard deviation of the corresponding predictor. The resulting coefficients are scaled such that all predictors have unit standard deviation.</p>
</td></tr>
<tr><td><code>numdir</code></td>
<td>
<p>the maximal number of directions estimated.</p>
</td></tr>
<tr><td><code>dir</code></td>
<td>
<p>the estimated MSIR directions from mean-centered predictors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>References</h3>

<p>Scrucca, L. (2011) Model-based SIR for dimension reduction. <em>Computational Statistics &amp; Data Analysis</em>, 55(11), 3010-3026.</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.msir">summary.msir</a></code>, <code><a href="#topic+plot.msir">plot.msir</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1-dimensional simple regression
n &lt;- 200
p &lt;- 5
b &lt;- as.matrix(c(1,-1,rep(0,p-2)))
x &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
y &lt;- exp(0.5 * x%*%b) + 0.1*rnorm(n)
MSIR &lt;- msir(x, y)
summary(MSIR)
plot(MSIR, type = "2Dplot")

# 1-dimensional symmetric response curve
n &lt;- 200
p &lt;- 5
b &lt;- as.matrix(c(1,-1,rep(0,p-2)))
x &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
y &lt;- (0.5 * x%*%b)^2 + 0.1*rnorm(n)
MSIR &lt;- msir(x, y)
summary(MSIR)
plot(MSIR, type = "2Dplot")
plot(MSIR, type = "coefficients")

# 2-dimensional response curve
n &lt;- 300
p &lt;- 5
b1 &lt;- c(1, 1, 1, rep(0, p-3))
b2 &lt;- c(1,-1,-1, rep(0, p-3))
b &lt;- cbind(b1,b2)
x &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
y &lt;- x %*% b1 + (x %*% b1)^3 + 4*(x %*% b2)^2 + rnorm(n)
MSIR &lt;- msir(x, y)
summary(MSIR)
plot(MSIR, which = 1:2)
## Not run: plot(MSIR, type = "spinplot")
plot(MSIR, which = 1, type = "2Dplot", span = 0.7)
plot(MSIR, which = 2, type = "2Dplot", span = 0.7)
</code></pre>

<hr>
<h2 id='msir-internal'>Internal <code>'msir'</code> functions</h2><span id='topic+msir.fit'></span><span id='topic+eigen.decomp'></span><span id='topic+mvdnorm'></span><span id='topic+normalize'></span><span id='topic+msir.parameters'></span><span id='topic+msir.components'></span><span id='topic+msir.componentsSlice'></span><span id='topic+msir.recoverdir'></span><span id='topic+catwrap'></span>

<h3>Description</h3>

<p>Internal functions for package <code>'msir'</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>msir.fit(data, labels, G = NULL, modelNames = NULL, 
         control = emControl(itmax = c(.Machine$integer.max, 50)), 
         initialization = NULL, warn = FALSE, verbose = FALSE, ...) 

eigen.decomp(X1, X2, inv = FALSE, tol = sqrt(.Machine$double.eps))

mvdnorm(x, mean, sigma, log = FALSE, tol = sqrt(.Machine$double.eps))

normalize(x)
    
msir.parameters(object, numdir = object$numdir)

msir.components(object)
msir.componentsSlice(object)

msir.recoverdir(object, data, normalized = TRUE, std = FALSE)
</code></pre>


<h3>Details</h3>

<p>These functions are not intended to be called by the user.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+msir">msir</a></code></p>

<hr>
<h2 id='msir.bic'>BIC-type criterion for dimensionality</h2><span id='topic+msir.bic'></span><span id='topic+bicDimRed'></span>

<h3>Description</h3>

<p>BIC-type criterion for selecting the dimensionality of a dimension reduction subspace.</p>


<h3>Usage</h3>

<pre><code class='language-R'>msir.bic(object, type = 1, plot = FALSE)

bicDimRed(M, x, nslices, type = 1, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msir.bic_+3A_object">object</code></td>
<td>
<p>a <code>'msir'</code> object</p>
</td></tr>
<tr><td><code id="msir.bic_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> a plot of the criterion is shown.</p>
</td></tr>
<tr><td><code id="msir.bic_+3A_m">M</code></td>
<td>
<p>the kernel matrix. See details below.</p>
</td></tr>
<tr><td><code id="msir.bic_+3A_x">x</code></td>
<td>
<p>the predictors data matrix. See details below.</p>
</td></tr>
<tr><td><code id="msir.bic_+3A_type">type</code></td>
<td>
<p>See details below.</p>
</td></tr>
<tr><td><code id="msir.bic_+3A_nslices">nslices</code></td>
<td>
<p>the number of slices. See details below.</p>
</td></tr>
<tr><td><code id="msir.bic_+3A_tol">tol</code></td>
<td>
<p>a tolerance value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This BIC-type criterion for the determination of the structural dimension selects <code class="reqn">d</code> as the maximizer of
</p>
<p style="text-align: center;"><code class="reqn">G(d) = l(d) - Penalty(p,d,n)</code>
</p>

<p>where <code class="reqn">l(d)</code> is the log-likelihood for dimensions up to <code class="reqn">d</code>, <code class="reqn">p</code> is the number of predictors, and <code class="reqn">n</code> is the sample size.
The term <code class="reqn">Penalty(p,d,n)</code> is the type of penalty to be used:
</p>

<ul>
<li> <p><code>type = 1</code>: <code class="reqn">Penalty(p,d,n) = -(p-d) \log(n)</code>
</p>
</li>
<li> <p><code>type = 2</code>: <code class="reqn">Penalty(p,d,n) = 0.5 C d (2p-d+1)</code>, where <code class="reqn">C = (0.5 \log(n) + 0.1 n^(1/3))/2  nslices/n</code>
</p>
</li>
<li> <p><code>type = 3</code>: <code class="reqn">Penalty(p,d,n) = 0.5 C d (2p-d+1)</code>, where <code class="reqn">C = \log(n) nslices/n</code>
</p>
</li>
<li> <p><code>type = 4</code> <code class="reqn">Penalty(p,d,n) = 1/2 d \log(n)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>evalues</code></td>
<td>
<p>eigenvalues</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>log-likelihood</p>
</td></tr>
<tr><td><code>crit</code></td>
<td>
<p>BIC-type criterion</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>selected dimensionality</p>
</td></tr>
</table>
<p>The <code>msir.bic</code> also assign the above information to the corresponding <code>'msir'</code> object.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>References</h3>

<p>Zhu, Miao and Peng (2006) &quot;Sliced Inverse Regression for CDR Space Estimation&quot;, JASA.<br />
Zhu, Zhu (2007) &quot;On kernel method for SAVE&quot;, Journal of Multivariate Analysis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msir">msir</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># 1-dimensional symmetric response curve
n &lt;- 200
p &lt;- 5
b &lt;- as.matrix(c(1,-1,rep(0,p-2)))
x &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
y &lt;- (0.5 * x%*%b)^2 + 0.1*rnorm(n)
MSIR &lt;- msir(x, y)
msir.bic(MSIR, plot = TRUE)
summary(MSIR)
msir.bic(MSIR, type = 3, plot = TRUE)
summary(MSIR)
</code></pre>

<hr>
<h2 id='msir.nslices'>Default number of slices</h2><span id='topic+msir.nslices'></span>

<h3>Description</h3>

<p>This function computes a Sturges' type number of slices to be used as default in the <code><a href="#topic+msir">msir</a></code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>msir.nslices(n, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msir.nslices_+3A_n">n</code></td>
<td>
<p>the number of observations in the sample.</p>
</td></tr>
<tr><td><code id="msir.nslices_+3A_p">p</code></td>
<td>
<p>the number of predictors in the sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a single value, i.e. the number of slices.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+msir">msir</a></code></p>

<hr>
<h2 id='msir.permutation.test'>Permutation test for dimensionality</h2><span id='topic+msir.permutation.test'></span>

<h3>Description</h3>

<p>Approximates marginal dimension test significance levels by sampling from the permutation distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>msir.permutation.test(object, npermute = 99, numdir = object$numdir, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msir.permutation.test_+3A_object">object</code></td>
<td>
<p>a <code>'msir'</code> object.</p>
</td></tr>
<tr><td><code id="msir.permutation.test_+3A_npermute">npermute</code></td>
<td>
<p>number of permutations to compute.</p>
</td></tr>
<tr><td><code id="msir.permutation.test_+3A_numdir">numdir</code></td>
<td>
<p>maximum value of the dimension to test.</p>
</td></tr>
<tr><td><code id="msir.permutation.test_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> a textual progress bar is shown during computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function approximates significance levels of the marginal dimension tests based on a permutation test.</p>


<h3>Value</h3>

<p>The function returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>summary</code></td>
<td>
<p>a table containing the hypotheses, the test statistics, the permutation p-values.</p>
</td></tr>
<tr><td><code>npermute</code></td>
<td>
<p>the number of permutations used.</p>
</td></tr>
</table>
<p>Furthermore, it also assigns the above information to the corresponding <code>'msir'</code> object.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>References</h3>

<p>Scrucca, L. (2011) Model-based SIR for dimension reduction. <em>Computational Statistics &amp; Data Analysis</em>, 55(11), 3010-3026.</p>


<h3>See Also</h3>

<p>Function <code>dr()</code> in package <span class="pkg">dr</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# 1-dimensional simple regression
n &lt;- 200
p &lt;- 5
b &lt;- as.matrix(c(1,-1,rep(0,p-2)))
x &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
y &lt;- exp(0.5 * x%*%b) + 0.1*rnorm(n)
MSIR &lt;- msir(x, y)
msir.permutation.test(MSIR)
summary(MSIR)

## End(Not run)
</code></pre>

<hr>
<h2 id='msir.regularizedSigma'>Regularized estimate of predictors covariance matrix.</h2><span id='topic+msir.regularizedSigma'></span>

<h3>Description</h3>

<p>This function computes a regularized version of the covariance matrix of the predictors. Among the possible models the one which maximizes BIC is returned.</p>


<h3>Usage</h3>

<pre><code class='language-R'>msir.regularizedSigma(x, inv = FALSE, model = c("XII", "XXI", "XXX"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msir.regularizedSigma_+3A_x">x</code></td>
<td>
<p>Ahe predictors data matrix.</p>
</td></tr>
<tr><td><code id="msir.regularizedSigma_+3A_inv">inv</code></td>
<td>
<p>A logical specifying what must be returned. If <code>TRUE</code> the inverse of the estimated covariance matrix is returned, otherwise the estimated covariance matrix (default).</p>
</td></tr>
<tr><td><code id="msir.regularizedSigma_+3A_model">model</code></td>
<td>
<p>A character string specifying the available models:
</p>

<ul>
<li> <p><code>XII</code>: diagonal equal variances
</p>
</li>
<li> <p><code>XXI</code>: diagonal unequal variances
</p>
</li>
<li> <p><code>XXX</code>: full covariance matrix
</p>
</li></ul>

</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">(p \times p)</code> covariance matrix estimate.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+msir">msir</a></code></p>

<hr>
<h2 id='msir.slices'>Slice a vector into slices of approximately equal size</h2><span id='topic+msir.slices'></span>

<h3>Description</h3>

<p>Function used for slicing a continuous response variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>msir.slices(y, nslices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msir.slices_+3A_y">y</code></td>
<td>
<p>a vector of <code class="reqn">n</code> values</p>
</td></tr>
<tr><td><code id="msir.slices_+3A_nslices">nslices</code></td>
<td>
<p>the number of slices, no larger than <code class="reqn">n</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>slice.indicator</code></td>
<td>
<p>an indicator variable for the slices.</p>
</td></tr>
<tr><td><code>nslices</code></td>
<td>
<p>the actual number of slices produced.</p>
</td></tr>
<tr><td><code>slice.sizes</code></td>
<td>
<p>the number of observations in each slice.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+msir">msir</a></code></p>

<hr>
<h2 id='plot.msir'>Plot method for <code>'msir'</code> objects.</h2><span id='topic+plot.msir'></span>

<h3>Description</h3>

<p>Plots directions and other information from MSIR estimation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msir'
plot(x, which, 
     type = c("pairs", "2Dplot", "spinplot", "evalues", "coefficients"), 
     span = NULL, std = TRUE, ylab, xlab, restore.par = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.msir_+3A_x">x</code></td>
<td>
<p>a <code>'msir'</code> object.</p>
</td></tr>
<tr><td><code id="plot.msir_+3A_which">which</code></td>
<td>
<p>a vector of value(s) giving the directions for which the plot should be drawn.</p>
</td></tr>
<tr><td><code id="plot.msir_+3A_type">type</code></td>
<td>
<p>the type of plot to be drawn.</p>
</td></tr>
<tr><td><code id="plot.msir_+3A_span">span</code></td>
<td>
<p>the span of smoother (only for <code>type = "pairs" | "2Dplot"</code>).</p>
</td></tr>
<tr><td><code id="plot.msir_+3A_std">std</code></td>
<td>
<p>if <code>TRUE</code> coefficients are standardized (only for <code>type = "coefficients"</code>).</p>
</td></tr>
<tr><td><code id="plot.msir_+3A_ylab">ylab</code></td>
<td>
<p>a character string for the y-axis label.</p>
</td></tr>
<tr><td><code id="plot.msir_+3A_xlab">xlab</code></td>
<td>
<p>a character string for the x-axis label.</p>
</td></tr>
<tr><td><code id="plot.msir_+3A_restore.par">restore.par</code></td>
<td>
<p>if <code>TRUE</code> the graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>) changed are restored to the previous state. If you want to manipulate the resulting plot you should set <code>restore.par = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.msir_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>References</h3>

<p>Scrucca, L. (2011) Model-based SIR for dimension reduction. <em>Computational Statistics &amp; Data Analysis</em>, 55(11), 3010-3026.</p>


<h3>See Also</h3>

<p><code><a href="#topic+msir">msir</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# 2-dimensional response curve
n &lt;- 300
p &lt;- 5
b1 &lt;- c(1, 1, 1, rep(0, p-3))
b2 &lt;- c(1,-1,-1, rep(0, p-3))
b &lt;- cbind(b1,b2)
x &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
y &lt;- x %*% b1 + (x %*% b1)^3 + 4*(x %*% b2)^2 + rnorm(n)
MSIR &lt;- msir(x, y)
summary(MSIR)
plot(MSIR)
plot(MSIR, which = 1:2)
plot(MSIR, type = "2Dplot", which = 1, span = 0.7)
plot(MSIR, type = "2Dplot", which = 2, span = 0.7)
plot(MSIR, type = "spinplot")
plot(MSIR, type = "evalues")
plot(MSIR, type = "coefficients")

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.msir'>Model-based Sliced Inverse Regression directions</h2><span id='topic+predict.msir'></span>

<h3>Description</h3>

<p>MSIR estimates a set of <code class="reqn">d \le p</code> orthogonal direction vectors of length <code class="reqn">p</code> which are estimates of the basis of the dimensional reduction subspace.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'msir'
predict(object, dim = 1:object$numdir, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.msir_+3A_object">object</code></td>
<td>
<p>an object of class <code>'msir'</code> resulting from a call to <code><a href="#topic+msir">msir</a>.</code></p>
</td></tr>
<tr><td><code id="predict.msir_+3A_dim">dim</code></td>
<td>
<p>the dimensions of the reduced subspace used for prediction.</p>
</td></tr>
<tr><td><code id="predict.msir_+3A_newdata">newdata</code></td>
<td>
<p>a data frame or matrix giving the data. If missing the data obtained from the call to <code><a href="#topic+msir">msir</a></code> are used.</p>
</td></tr>
<tr><td><code id="predict.msir_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a matrix of points projected on the subspace spanned by the estimated basis vectors.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>References</h3>

<p>Scrucca, L. (2011) Model-based SIR for dimension reduction. <em>Computational Statistics &amp; Data Analysis</em>, 55(11), 3010-3026.</p>


<h3>See Also</h3>

<p><code>{msir}</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 200
p &lt;- 5
b &lt;- as.matrix(c(1,-1,rep(0,p-2)))
x &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
y &lt;- exp(0.5 * x%*%b) + 0.1*rnorm(n)
pairs(cbind(y,x), gap = 0)

MSIR &lt;- msir(x, y)
summary(MSIR)
plot(MSIR, which = 1, type = "2Dplot")
all.equal(predict(MSIR), MSIR$dir)
predict(MSIR, dim = 1:2)

x0 &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
y0 &lt;- exp(0.5 * x0%*%b) + 0.1*rnorm(n)
plot(predict(MSIR, dim = 1, newdata = x0), y0)
</code></pre>

<hr>
<h2 id='spinplot'>Rotating three-dimensional plot</h2><span id='topic+spinplot'></span>

<h3>Description</h3>

<p>General function to draw a rgl-based rotating 3D scatterplot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>spinplot(x, y, z, 
         scaling = c("abc", "aaa"), 
         rem.lin.trend = FALSE, 
         uncor.vars = FALSE, 
         fit.ols = FALSE, 
         fit.smooth = FALSE, 
         span = 0.75, 
         ngrid = 25, 
         markby, 
         pch.points = 1, 
         col.points = "black", 
         cex.points = 1,
         col.axis   = "gray50", 
         col.smooth = "limegreen", 
         col.ols    = "lightsteelblue",
         background = "white", 
         ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spinplot_+3A_x">x</code></td>
<td>
<p>a vector of values for the variable in the horizontal (H) screen axis.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_y">y</code></td>
<td>
<p>a vector of values for the variable in the vertical (V) screen axis.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_z">z</code></td>
<td>
<p>a vector of values for the variable in the out-of-screen (O) axis.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_scaling">scaling</code></td>
<td>
<p>the scaling applied. Two possible values are <code>"abc"</code> and <code>"aaa"</code>.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_rem.lin.trend">rem.lin.trend</code></td>
<td>
<p>a logical specifying if the linear trend should be remove. If <code>TRUE</code> then the vertical axis is replaced by e(V|H,O), i.e. the residuals from a linear fit of the vertical axis variable on the others.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_uncor.vars">uncor.vars</code></td>
<td>
<p>a logical specifying if uncorrelated H and O variables should be used. If <code>TRUE</code> then the O variable is replaced by e(O|H), i.e. the residuals of the regression of O on H, hence obtaining a pair of uncorrelated variables.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_fit.ols">fit.ols</code></td>
<td>
<p>a logical specifying if a fitted OLS plane should be included.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_fit.smooth">fit.smooth</code></td>
<td>
<p>a logical specifying if a nonparametric smoothing plane should be included.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_span">span</code></td>
<td>
<p>the span used by <code><a href="stats.html#topic+loess">loess</a></code> to fit the polynomial surface.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_ngrid">ngrid</code></td>
<td>
<p>the number of grid points to use for displaing the fitted plane.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_markby">markby</code></td>
<td>
<p>a variable (usually a factor) to be used for marking the points.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_pch.points">pch.points</code></td>
<td>
<p>a vector of symbols for marking the points.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_col.points">col.points</code></td>
<td>
<p>a vector of colors for marking the points.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_cex.points">cex.points</code></td>
<td>
<p>the cex for points.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_col.axis">col.axis</code></td>
<td>
<p>the color of the axis.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_col.ols">col.ols</code></td>
<td>
<p>the color to be used for drawing the OLS plane.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_col.smooth">col.smooth</code></td>
<td>
<p>the color to be used for drawing the smoothing plane.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_background">background</code></td>
<td>
<p>the color of background space.</p>
</td></tr>
<tr><td><code id="spinplot_+3A_...">...</code></td>
<td>
<p>catch further unused arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly based on the functionality of the <code>spin-plot</code> function once available in XLisp-Stat software <a href="https://en.wikipedia.org/wiki/XLispStat">https://en.wikipedia.org/wiki/XLispStat</a>, and the adds-on introduced by the Arc software <a href="http://www.stat.umn.edu/arc/index.html">http://www.stat.umn.edu/arc/index.html</a>.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>References</h3>

<p>Cook R. D., Weisberg S. (1999) <em>Applied Regression Including Computing and Graphics</em>, Wiley, Chapter 8
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x1 &lt;- rnorm(100)
x2 &lt;- rnorm(100)
y  &lt;- 2*x1 + x2^2 + 0.5*rnorm(100)
spinplot(x1, y, x2)
spinplot(x1, y, x2, scaling = "aaa")
spinplot(x1, y, x2, rem.lin.trend = "TRUE")
spinplot(x1, y, x2, fit.smooth = TRUE)
spinplot(x1, y, x2, fit.ols = TRUE)

x &lt;- iris[,1:3]
y &lt;- iris[,5]
spinplot(x)
spinplot(x, markby = y)
spinplot(x, markby = y, col.points = c("dodgerblue2", "orange", "green3"))
spinplot(x, markby = y, pch = c(0,3,1), col.points = c("dodgerblue2", "orange", "green3"))

# to save plots use 
# rgl.postscript("plot.pdf", fmt="pdf")
# or
# rgl.snapshot("plot.png")

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.msir'>Summary and print methods for <code>'msir'</code> objects</h2><span id='topic+summary.msir'></span><span id='topic+print.summary.msir'></span>

<h3>Description</h3>

<p>Summary and print methods for <code>'msir'</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msir'
summary(object, numdir = object$numdir, std = FALSE, verbose = TRUE, ...)
## S3 method for class 'summary.msir'
print(x, digits = max(5, getOption("digits") - 3), ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.msir_+3A_object">object</code></td>
<td>
<p>a <code>'msir'</code> object</p>
</td></tr>
<tr><td><code id="summary.msir_+3A_numdir">numdir</code></td>
<td>
<p>the number of directions to be shown.</p>
</td></tr>
<tr><td><code id="summary.msir_+3A_std">std</code></td>
<td>
<p>if <code>TRUE</code> the coefficients basis are scaled such that all predictors have unit standard deviation.</p>
</td></tr>
<tr><td><code id="summary.msir_+3A_verbose">verbose</code></td>
<td>
<p>if <code>FALSE</code> the coefficients basis are omitted; by default <code>verbose = TRUE</code>.</p>
</td></tr>  
<tr><td><code id="summary.msir_+3A_x">x</code></td>
<td>
<p>a <code>'summary.msir'</code> object.</p>
</td></tr>
<tr><td><code id="summary.msir_+3A_digits">digits</code></td>
<td>
<p>the significant digits to use.</p>
</td></tr>
<tr><td><code id="summary.msir_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+msir">msir</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
