<!DOCTYPE html><html lang="en-US"><head><title>Help for package mrgsim.parallel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mrgsim.parallel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bg_mclapply'><p>Multicore lapply in the background</p></a></li>
<li><a href='#bg_mrgsim_d'><p>Run mrgsim in the background</p></a></li>
<li><a href='#chunk_data_frame'><p>Chunk a data frame</p></a></li>
<li><a href='#ext_stream'><p>Set or change the file extension on file_stream names</p></a></li>
<li><a href='#file_set'><p>Generate a sequence of file objects</p></a></li>
<li><a href='#file_stream'><p>Create a stream of files</p></a></li>
<li><a href='#format_is_set'><p>Check format status of file set item</p></a></li>
<li><a href='#format_stream'><p>Set the format for a stream_file object</p></a></li>
<li><a href='#head_fst'><p>Get the head of an fst file set</p></a></li>
<li><a href='#internalize_fst'><p>Get the contents of an fst file set</p></a></li>
<li><a href='#is_locker_dir'><p>Check if a directory is dedicated locker space</p></a></li>
<li><a href='#is.file_set_item'><p>Check if an object is a file_set_item</p></a></li>
<li><a href='#is.file_stream'><p>Check if an object inherits from file_stream</p></a></li>
<li><a href='#is.locker_stream'><p>Check if an object inherits from locker_stream</p></a></li>
<li><a href='#list_fst'><p>List all output files in a fst file set</p></a></li>
<li><a href='#locate_stream'><p>Set or change the directory for file_stream objects</p></a></li>
<li><a href='#mrgsim_ms'><p>Run mrgsim after trying to load the shared object</p></a></li>
<li><a href='#mrgsim.parallel'><p>Simulate with 'mrgsolve' in Parallel</p></a></li>
<li><a href='#new_stream'><p>Create a stream of outputs and inputs</p></a></li>
<li><a href='#noreset_locker'><p>Prohibit a locker space from being reset</p></a></li>
<li><a href='#parallel_mrgsim_d'><p>Simulate a data set in parallel</p></a></li>
<li><a href='#parallel_mrgsim_ei'><p>Simulate an idata set in parallel</p></a></li>
<li><a href='#reset_locker'><p>Initialize the locker directory</p></a></li>
<li><a href='#setup_locker'><p>Set up a data storage locker</p></a></li>
<li><a href='#temp_ds'><p>Create a path to a dataset in tempdir</p></a></li>
<li><a href='#version_locker'><p>Version locker contents</p></a></li>
<li><a href='#write_stream'><p>Writer functions for stream_file objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate with 'mrgsolve' in Parallel</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Kyle Baron</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kyle Baron &lt;kylebtwin@imap.cc&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulation from an 'mrgsolve' 
    <a href="https://cran.r-project.org/package=mrgsolve">https://cran.r-project.org/package=mrgsolve</a> model using a parallel backend.  
    Input data sets are split (chunked) and simulated in parallel using 
    mclapply() or future_lapply() 
    <a href="https://cran.r-project.org/package=future.apply">https://cran.r-project.org/package=future.apply</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, dplyr, future, future.apply, callr, fst</td>
</tr>
<tr>
<td>Depends:</td>
<td>mrgsolve, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, arrow, qs, knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kylebaron/mrgsim.parallel">https://github.com/kylebaron/mrgsim.parallel</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kylebaron/mrgsim.parallel/issues">https://github.com/kylebaron/mrgsim.parallel/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-17 19:06:16 UTC; kyleb</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-17 19:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='bg_mclapply'>Multicore lapply in the background</h2><span id='topic+bg_mclapply'></span>

<h3>Description</h3>

<p>Multicore lapply in the background
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bg_mclapply(X, FUN, mc.cores = 1, ..., .wait = TRUE, .seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bg_mclapply_+3A_x">X</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="bg_mclapply_+3A_fun">FUN</code></td>
<td>
<p>The function to be applied to each element of <code>X</code>.</p>
</td></tr>
<tr><td><code id="bg_mclapply_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Passed to <code><a href="parallel.html#topic+mclapply">parallel::mclapply()</a></code>.</p>
</td></tr>
<tr><td><code id="bg_mclapply_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="bg_mclapply_+3A_.wait">.wait</code></td>
<td>
<p>If <code>FALSE</code>, the function returns immediately; if <code>TRUE</code>, then
wait until the background job is finished.</p>
</td></tr>
<tr><td><code id="bg_mclapply_+3A_.seed">.seed</code></td>
<td>
<p>A <code>numeric</code> value used to set the seed for the simulation;
this is the only way to control the random number generation for your
simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of output data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ans &lt;- bg_mclapply(seq(10), sqrt, mc.cores = 2)

</code></pre>

<hr>
<h2 id='bg_mrgsim_d'>Run mrgsim in the background</h2><span id='topic+bg_mrgsim_d'></span>

<h3>Description</h3>

<p>This function uses <code><a href="callr.html#topic+r_bg">callr::r_bg()</a></code> to simulate a dataset in the background,
optionally in parallel and optionally saving the results directly to
disk in  <code>fst</code>, <code>arrow</code> or <code>rds</code> format. Parallelization can be mediated
by the <code>parallel</code> package on unix or macos or <code>future</code> on any os.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bg_mrgsim_d(
  mod,
  data,
  nchunk = 1,
  ...,
  .locker = NULL,
  .tag = NULL,
  .format = c("fst", "feather", "rds"),
  .wait = TRUE,
  .seed = FALSE,
  .cores = 1,
  .plan = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bg_mrgsim_d_+3A_mod">mod</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="bg_mrgsim_d_+3A_data">data</code></td>
<td>
<p>Data set to simulate; see <code><a href="mrgsolve.html#topic+data_set">mrgsolve::data_set()</a></code>.</p>
</td></tr>
<tr><td><code id="bg_mrgsim_d_+3A_nchunk">nchunk</code></td>
<td>
<p>Number of chunks in which to split the data set</p>
</td></tr>
<tr><td><code id="bg_mrgsim_d_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="mrgsolve.html#topic+mrgsim">mrgsolve::mrgsim()</a></code>.</p>
</td></tr>
<tr><td><code id="bg_mrgsim_d_+3A_.locker">.locker</code></td>
<td>
<p>A directory for saving simulated data; use this to collect
results from several different runs in a single folder.</p>
</td></tr>
<tr><td><code id="bg_mrgsim_d_+3A_.tag">.tag</code></td>
<td>
<p>A name to use for the current run; results are saved under
<code>.tag</code> in <code>.path</code> folder.</p>
</td></tr>
<tr><td><code id="bg_mrgsim_d_+3A_.format">.format</code></td>
<td>
<p>The output format for saving simulations; using format
<code>fst</code> will allow saved results to be read with <code><a href="fst.html#topic+write_fst">fst::read_fst()</a></code>; using
format <code>arrow</code> will allow saved results to be read with
<code><a href="arrow.html#topic+open_dataset">arrow::open_dataset()</a></code> with <code>format = "feather"</code>; note that <code>fst</code> is
installed with <code>mrgsim.parallel</code> but <code>arrow</code> may need explicit installation.</p>
</td></tr>
<tr><td><code id="bg_mrgsim_d_+3A_.wait">.wait</code></td>
<td>
<p>If <code>FALSE</code>, the function returns immediately; if <code>TRUE</code>, then
wait until the background job is finished.</p>
</td></tr>
<tr><td><code id="bg_mrgsim_d_+3A_.seed">.seed</code></td>
<td>
<p>A <code>numeric</code> value used to set the seed for the simulation;
this is the only way to control the random number generation for your
simulation.</p>
</td></tr>
<tr><td><code id="bg_mrgsim_d_+3A_.cores">.cores</code></td>
<td>
<p>The number of cores to parallelize across; pass 1 to run the
simulation sequentially.</p>
</td></tr>
<tr><td><code id="bg_mrgsim_d_+3A_.plan">.plan</code></td>
<td>
<p>The name of a <code><a href="future.html#topic+plan">future::plan()</a></code> strategy; if passed, the
parallelization will be handled by the <code>future</code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+bg_mrgsim_d">bg_mrgsim_d()</a></code> returns a <a href="processx.html#topic+process">processx::process</a> object (follow that link to
see a list of methods). You will have to call <code>process$get_result()</code> to
retrieve the result. When an output <code>.locker</code> is not specified, simulated
data are returned; when an output <code>.locker</code> is specified, the path to
the <code>fst</code> file on disk is returned.  The <code>fst</code> files  should be read with
<code><a href="fst.html#topic+write_fst">fst::read_fst()</a></code>. When the results are not saved to <code>.locker</code>, you will
get a single data frame when <code>nchunk</code> is 1 or a list of data frames when
<code>nchunk</code> is greater than 1. It is safest to call <code><a href="dplyr.html#topic+bind">dplyr::bind_rows()</a></code> or
something equivalent on the result if you are expecting data frame.
</p>


<h3>Value</h3>

<p>An <code>r_process</code> object; see <code><a href="callr.html#topic+r_bg">callr::r_bg()</a></code>. Call <code>process$get_resuilt()</code> to
get the actual result (see <code>details</code>). If a <code>.locker</code> path is supplied,
the simulated data is saved to disk and a list of file names is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+future_mrgsim_d">future_mrgsim_d()</a></code>, <code><a href="#topic+internalize_fst">internalize_fst()</a></code>, <code><a href="#topic+list_fst">list_fst()</a></code>,
<code><a href="#topic+head_fst">head_fst()</a></code>, <code><a href="#topic+setup_locker">setup_locker()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- mrgsolve::house(delta = 24, end = 168)
data &lt;- mrgsolve::expand.ev(
  amt = c(100, 300, 450), 
  ID = 1:100, 
  ii = 24, 
  addl = 6
)
data &lt;- dplyr::mutate(data, dose = amt)
process &lt;- bg_mrgsim_d(
  mod, 
  data, 
  carry_out = "dose", 
  outvars = "CP",
  .wait = TRUE
) 
process$get_result()
 
 
ds &lt;- file.path(tempdir(), "sims")
files &lt;- bg_mrgsim_d(
  mod, data, carry_out = "dose", 
  .wait = TRUE, 
  .locker = ds,
  .format = "fst"
)
files
sims &lt;- internalize_fst(ds)
head(sims)
  

</code></pre>

<hr>
<h2 id='chunk_data_frame'>Chunk a data frame</h2><span id='topic+chunk_data_frame'></span><span id='topic+chunk_by_id'></span><span id='topic+chunk_by_cols'></span><span id='topic+chunk_by_row'></span>

<h3>Description</h3>

<p>Use <a href="#topic+chunk_by_id">chunk_by_id</a> to split up a data set by the <code>ID</code> column; use
<a href="#topic+chunk_by_row">chunk_by_row</a> split a data set by rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk_by_id(data, nchunk, id_col = "ID", mark = NULL)

chunk_by_cols(data, nchunk, cols, mark = NULL)

chunk_by_row(data, nchunk, mark = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chunk_data_frame_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="chunk_data_frame_+3A_nchunk">nchunk</code></td>
<td>
<p>The number of chunks.</p>
</td></tr>
<tr><td><code id="chunk_data_frame_+3A_id_col">id_col</code></td>
<td>
<p>Character name specifying the column containing the <code>ID</code> for
chunking.</p>
</td></tr>
<tr><td><code id="chunk_data_frame_+3A_mark">mark</code></td>
<td>
<p>When populated as a character label, adds a column to the
chunked data frames with that name and with value the integer group number.</p>
</td></tr>
<tr><td><code id="chunk_data_frame_+3A_cols">cols</code></td>
<td>
<p>A character vector of columns to use for deriving <code>ID</code> to use
for chunking.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- expand.grid(ID = 1:10, B = rev(1:10))

chunk_by_id(x, nchunk = 3)

chunk_by_row(x, nchunk = 4)

</code></pre>

<hr>
<h2 id='ext_stream'>Set or change the file extension on file_stream names</h2><span id='topic+ext_stream'></span>

<h3>Description</h3>

<p>Add or update the file extension for items in a <code>file_stream</code> object.
If a file extension exists, it is removed first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ext_stream(x, ext)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ext_stream_+3A_x">x</code></td>
<td>
<p>A <code>file_stream</code> object.</p>
</td></tr>
<tr><td><code id="ext_stream_+3A_ext">ext</code></td>
<td>
<p>The new extension.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+format_stream">format_stream()</a></code>, <code><a href="#topic+locate_stream">locate_stream()</a></code>, <code><a href="#topic+new_stream">new_stream()</a></code>, <code><a href="#topic+file_stream">file_stream()</a></code>,
<code><a href="#topic+file_set">file_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- new_stream(3)
x &lt;- ext_stream(x, "feather")
x[[1]]$file

</code></pre>

<hr>
<h2 id='file_set'>Generate a sequence of file objects</h2><span id='topic+file_set'></span>

<h3>Description</h3>

<p>File names have a numbered core that communicates the current file number
as well as the total number of files in the set. For example, <code>02-20</code> would
indicate the second file in a set of 20. Other customizations can be added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_set(n, where = NULL, prefix = NULL, pad = TRUE, sep = "-", ext = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file_set_+3A_n">n</code></td>
<td>
<p>The number of file names to create.</p>
</td></tr>
<tr><td><code id="file_set_+3A_where">where</code></td>
<td>
<p>An optional output file path.</p>
</td></tr>
<tr><td><code id="file_set_+3A_prefix">prefix</code></td>
<td>
<p>A character prefix for the file name.</p>
</td></tr>
<tr><td><code id="file_set_+3A_pad">pad</code></td>
<td>
<p>If <code>TRUE</code>, numbers will be padded with zeros.</p>
</td></tr>
<tr><td><code id="file_set_+3A_sep">sep</code></td>
<td>
<p>Separator character.</p>
</td></tr>
<tr><td><code id="file_set_+3A_ext">ext</code></td>
<td>
<p>A file extension, including the dot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default a list length <code>n</code> of lists length 2; each sublist contains the
integer file number as <code>i</code> and the file name as <code>file</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setup_locker">setup_locker()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- file_set(3, where = "foo/bar")
length(x)
x[2]

x &lt;- file_set(25, ext = ".feather")
x[17]

</code></pre>

<hr>
<h2 id='file_stream'>Create a stream of files</h2><span id='topic+file_stream'></span>

<h3>Description</h3>

<p>Optionally, setup a locker storage space on disk with a specific file
format (e.g. <code>fst</code> or <code>feather</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_stream(n, locker = NULL, format = NULL, where = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file_stream_+3A_n">n</code></td>
<td>
<p>The number of file names to generate; must be a single numeric
value greater than or equal to 1.</p>
</td></tr>
<tr><td><code id="file_stream_+3A_locker">locker</code></td>
<td>
<p>Passed to <code><a href="#topic+setup_locker">setup_locker()</a></code> as <code>dir</code>; important to note that the
directory will be unlinked if it exists and is an established locker
directory.</p>
</td></tr>
<tr><td><code id="file_stream_+3A_format">format</code></td>
<td>
<p>Passed to <code><a href="#topic+format_stream">format_stream()</a></code>.</p>
</td></tr>
<tr><td><code id="file_stream_+3A_where">where</code></td>
<td>
<p>An optional file path; this is replaced by <code>locker</code> if it is
also passed.</p>
</td></tr>
<tr><td><code id="file_stream_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+file_set">file_set()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pass <code>locker</code> to set up locker space for saving outputs; this involves
clearing the <code>locker</code> directory (see <code><a href="#topic+setup_locker">setup_locker()</a></code> for details). Passing
<code>locker</code> also sets the path for output files. If you want to set up the path
for output files without setting up <code>locker</code> space, pass <code>where</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+format_stream">format_stream()</a></code>, <code><a href="#topic+locate_stream">locate_stream()</a></code>, <code><a href="#topic+ext_stream">ext_stream()</a></code>, <code><a href="#topic+new_stream">new_stream()</a></code>,
<code><a href="#topic+file_set">file_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- file_stream(3, locker = temp_ds("foo"), format = "fst")
x[[1]]

</code></pre>

<hr>
<h2 id='format_is_set'>Check format status of file set item</h2><span id='topic+format_is_set'></span><span id='topic+is.stream_format'></span>

<h3>Description</h3>

<p>This can be used to check if a file set item has been assigned an output
format (e.g. <code>fst</code>, <code>feather</code>, <code>qs</code> or <code>rds</code>). If the check returns
<code>FALSE</code> it would signal that data should be returned rather than calling
<code><a href="#topic+write_stream">write_stream()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_is_set(x)

is.stream_format(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_is_set_+3A_x">x</code></td>
<td>
<p>An object, usually a <code>file_set_item</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating if <code>x</code> inherits from one of the stream format classes. .
</p>

<hr>
<h2 id='format_stream'>Set the format for a stream_file object</h2><span id='topic+format_stream'></span>

<h3>Description</h3>

<p>The format is set on the file objects inside the list so that the file
object can be used to call a write method. See <code><a href="#topic+write_stream">write_stream()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_stream(
  x,
  type = c("fst", "feather", "qs", "rds"),
  set_ext = TRUE,
  warn = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_stream_+3A_x">x</code></td>
<td>
<p>A <code>file_stream</code> object.</p>
</td></tr>
<tr><td><code id="format_stream_+3A_type">type</code></td>
<td>
<p>The file format type; if <code>feather</code> is chosen, then a check will
be made to ensure the <code>arrow</code> package is loaded.</p>
</td></tr>
<tr><td><code id="format_stream_+3A_set_ext">set_ext</code></td>
<td>
<p>If <code>TRUE</code>, the existing extension (if it exists) is stripped
and a new extension is added based on the value of <code>type</code>.</p>
</td></tr>
<tr><td><code id="format_stream_+3A_warn">warn</code></td>
<td>
<p>If <code>TRUE</code> a warning will be issued in case the output format
is set but there is no directory path associated with the <code>file</code> spot in
<code>x[[1]]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is returned with a new class attribute reflecting the expected output
format (<code>fst</code>, <code>feather</code> (arrow), <code>qs</code> or <code>rds</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+format_is_set">format_is_set()</a></code>, <code><a href="#topic+locate_stream">locate_stream()</a></code>, <code><a href="#topic+ext_stream">ext_stream()</a></code>,
<code><a href="#topic+new_stream">new_stream()</a></code>, <code><a href="#topic+file_stream">file_stream()</a></code>, <code><a href="#topic+file_set">file_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- new_stream(2)
fs &lt;- format_stream(fs, "fst")
fs[[1]]

format_is_set(fs[[1]])  
 
</code></pre>

<hr>
<h2 id='head_fst'>Get the head of an fst file set</h2><span id='topic+head_fst'></span>

<h3>Description</h3>

<p>Get the head of an fst file set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head_fst(path, n = 5, i = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="head_fst_+3A_path">path</code></td>
<td>
<p>The directory to search.</p>
</td></tr>
<tr><td><code id="head_fst_+3A_n">n</code></td>
<td>
<p>Number of rows to show.</p>
</td></tr>
<tr><td><code id="head_fst_+3A_i">i</code></td>
<td>
<p>Which output output chunk to show.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+get_fst">get_fst()</a></code>, <code><a href="#topic+list_fst">list_fst()</a></code>
</p>

<hr>
<h2 id='internalize_fst'>Get the contents of an fst file set</h2><span id='topic+internalize_fst'></span><span id='topic+get_fst'></span>

<h3>Description</h3>

<p>Get the contents of an fst file set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>internalize_fst(path, .as_list = FALSE, ...)

get_fst(path, .as_list = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internalize_fst_+3A_path">path</code></td>
<td>
<p>The directory to search.</p>
</td></tr>
<tr><td><code id="internalize_fst_+3A_.as_list">.as_list</code></td>
<td>
<p>Should the results be returned as a list (<code>TRUE</code>) or a
tibble (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="internalize_fst_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list_fst">list_fst()</a></code>, <code><a href="#topic+head_fst">head_fst()</a></code>
</p>

<hr>
<h2 id='is_locker_dir'>Check if a directory is dedicated locker space</h2><span id='topic+is_locker_dir'></span>

<h3>Description</h3>

<p>Check if a directory is dedicated locker space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_locker_dir(where)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_locker_dir_+3A_where">where</code></td>
<td>
<p>The locker location.</p>
</td></tr>
</table>

<hr>
<h2 id='is.file_set_item'>Check if an object is a file_set_item</h2><span id='topic+is.file_set_item'></span>

<h3>Description</h3>

<p>Check if an object is a file_set_item
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.file_set_item(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.file_set_item_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value indicating if <code>x</code> has the <code>file_set_item</code> attribute set..
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- new_stream(2)
is.file_set_item(x[[2]])

</code></pre>

<hr>
<h2 id='is.file_stream'>Check if an object inherits from file_stream</h2><span id='topic+is.file_stream'></span>

<h3>Description</h3>

<p>Check if an object inherits from file_stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.file_stream(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.file_stream_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value indicating if <code>x</code> inherits from <code>file_stream</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- new_stream(2)
is.file_stream(x)

</code></pre>

<hr>
<h2 id='is.locker_stream'>Check if an object inherits from locker_stream</h2><span id='topic+is.locker_stream'></span>

<h3>Description</h3>

<p>Check if an object inherits from locker_stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.locker_stream(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.locker_stream_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value indicating if <code>x</code> inherits from <code>locker_stream</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- new_stream(2, locker = temp_ds("locker-stream-example"))
is.locker_stream(x)

</code></pre>

<hr>
<h2 id='list_fst'>List all output files in a fst file set</h2><span id='topic+list_fst'></span>

<h3>Description</h3>

<p>Use the function to read all of the <code>.fst</code> files that were saved when
<code>bg_mrgsim_d</code> was called and <code>.path</code> was passed along with <code>.format = "fst"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_fst(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_fst_+3A_path">path</code></td>
<td>
<p>The (full) directory path to search.</p>
</td></tr>
</table>

<hr>
<h2 id='locate_stream'>Set or change the directory for file_stream objects</h2><span id='topic+locate_stream'></span>

<h3>Description</h3>

<p>Add or update the directory location for items in a <code>file_stream</code> object.
If a directory path already exists, it is removed first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate_stream(x, where, initialize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locate_stream_+3A_x">x</code></td>
<td>
<p>A <code>file_stream</code> object.</p>
</td></tr>
<tr><td><code id="locate_stream_+3A_where">where</code></td>
<td>
<p>The new location.</p>
</td></tr>
<tr><td><code id="locate_stream_+3A_initialize">initialize</code></td>
<td>
<p>If <code>TRUE</code>, then the <code>where</code> directory is passed to a call
to <code><a href="#topic+reset_locker">reset_locker()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>initialize</code> is set to <code>TRUE</code>, the locker space is initialized <strong>or</strong>
reset. In order to initialize, <code>where</code> must not exist or it must have been
previously set up as locker space. See <code><a href="#topic+setup_locker">setup_locker()</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+format_stream">format_stream()</a></code>, <code><a href="#topic+ext_stream">ext_stream()</a></code>, <code><a href="#topic+new_stream">new_stream()</a></code>, <code><a href="#topic+file_stream">file_stream()</a></code>,
<code><a href="#topic+file_set">file_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- new_stream(5)
x &lt;- locate_stream(x, file.path(tempdir(), "foo"))
x[[1]]$file

</code></pre>

<hr>
<h2 id='mrgsim_ms'>Run mrgsim after trying to load the shared object</h2><span id='topic+mrgsim_ms'></span><span id='topic+mrgsim_worker'></span>

<h3>Description</h3>

<p>Use this function when running mrgsolve while parallelizing on a
multisession worker node where the model dll might not be loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrgsim_ms(mod, ...)

mrgsim_worker(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mrgsim_ms_+3A_mod">mod</code></td>
<td>
<p>a model object</p>
</td></tr>
<tr><td><code id="mrgsim_ms_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="mrgsolve.html#topic+mrgsim">mrgsolve::mrgsim()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
mrgsim_worker(mrgsolve:::house())

</code></pre>

<hr>
<h2 id='mrgsim.parallel'>Simulate with 'mrgsolve' in Parallel</h2><span id='topic+mrgsim.parallel'></span>

<h3>Description</h3>

<p>Simulate with 'mrgsolve' in Parallel
</p>


<h3>Package options</h3>


<ul>
<li> <p><code>mrgsim.parallel.mc.able</code>: if <code>TRUE</code>, multicore will be used if appropriate.
</p>
</li></ul>


<hr>
<h2 id='new_stream'>Create a stream of outputs and inputs</h2><span id='topic+new_stream'></span><span id='topic+new_stream.list'></span><span id='topic+new_stream.data.frame'></span><span id='topic+new_stream.numeric'></span><span id='topic+new_stream.character'></span>

<h3>Description</h3>

<p>By stream we mean a list that pre-specifies the output file names,
replicate numbers and possibly input objects for a simulation. Passing
<code>locker</code> initiates a call to <code><a href="#topic+setup_locker">setup_locker()</a></code>, which sets up or resets
the output directories.
</p>
<p>For the <code>data.frame</code> method, the data are chunked into a list by columns
listed in <code>cols</code>. Ideally, this is a singlel column that operates as
a unique <code>ID</code> across the data set and is used by <code><a href="#topic+chunk_by_id">chunk_by_id()</a></code> to
form the chunks. Alternatively, <code>cols</code> can be multiple column names which
are pasted together to form a unique <code>ID</code> that is used for splitting
via <code><a href="#topic+chunk_by_cols">chunk_by_cols()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_stream(x, ...)

## S3 method for class 'list'
new_stream(x, locker = NULL, format = NULL, ...)

## S3 method for class 'data.frame'
new_stream(x, nchunk, cols = "ID", locker = NULL, format = NULL, ...)

## S3 method for class 'numeric'
new_stream(x, ...)

## S3 method for class 'character'
new_stream(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_stream_+3A_x">x</code></td>
<td>
<p>A list or vector to template the stream; for the <code>numeric</code> method,
passing a single number will fill <code>x</code> with a sequence of that length.</p>
</td></tr>
<tr><td><code id="new_stream_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+file_set">file_set()</a></code>.</p>
</td></tr>
<tr><td><code id="new_stream_+3A_locker">locker</code></td>
<td>
<p>Passed to <code><a href="#topic+setup_locker">setup_locker()</a></code> as <code>dir</code>; important to note that the
directory will be unlinked if it exists and is an established locker
directory.</p>
</td></tr>
<tr><td><code id="new_stream_+3A_format">format</code></td>
<td>
<p>Passed to <code><a href="#topic+format_stream">format_stream()</a></code>.</p>
</td></tr>
<tr><td><code id="new_stream_+3A_nchunk">nchunk</code></td>
<td>
<p>The number of chunks.</p>
</td></tr>
<tr><td><code id="new_stream_+3A_cols">cols</code></td>
<td>
<p>The name(s) of the column(s) specifying unique IDs to use to
split the <code>data.frame</code> into chunks; this could be a unique <code>ID</code> or a
combination of columns that when pasted together form a unique ID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>i</code> the position number
</p>
</li>
<li> <p><code>file</code> the output file name
</p>
</li>
<li> <p><code>x</code> the input object.
</p>
</li></ul>

<p>The list has class <code>file_stream</code> as well as <code>locker_stream</code> (if <code>locker</code> was
passed) and a class attribute for the output if <code>format</code> was passed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+format_stream">format_stream()</a></code>, <code><a href="#topic+locate_stream">locate_stream()</a></code>, <code><a href="#topic+ext_stream">ext_stream()</a></code>, <code><a href="#topic+file_stream">file_stream()</a></code>,
<code><a href="#topic+file_set">file_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- new_stream(3)
x[[1]]

new_stream(2, locker = file.path(tempdir(), "foo"))

df &lt;- data.frame(ID = c(1,2,3,4))
x &lt;- new_stream(df, nchunk = 2)
x[[2]]

format_is_set(x[[2]])

x &lt;- new_stream(3, format = "fst")
format_is_set(x[[2]])

</code></pre>

<hr>
<h2 id='noreset_locker'>Prohibit a locker space from being reset</h2><span id='topic+noreset_locker'></span>

<h3>Description</h3>

<p>This function removes the the hidden locker file which designates a directory
as a locker. Once the locker is modified this way, it cannot be reset again
by calling <code><a href="#topic+setup_locker">setup_locker()</a></code> or <code><a href="#topic+new_stream">new_stream()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noreset_locker(where)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noreset_locker_+3A_where">where</code></td>
<td>
<p>The locker location.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating if write ability was successfully revoked.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setup_locker">setup_locker()</a></code>, <code><a href="#topic+reset_locker">reset_locker()</a></code>, <code><a href="#topic+version_locker">version_locker()</a></code>
</p>

<hr>
<h2 id='parallel_mrgsim_d'>Simulate a data set in parallel</h2><span id='topic+parallel_mrgsim_d'></span><span id='topic+future_mrgsim_d'></span><span id='topic+mc_mrgsim_d'></span><span id='topic+fu_mrgsim_d'></span><span id='topic+fu_mrgsim_d0'></span>

<h3>Description</h3>

<p>Use <code><a href="#topic+future_mrgsim_d">future_mrgsim_d()</a></code> to simulate with the <code>future</code> package.  Use
<code><a href="#topic+mc_mrgsim_d">mc_mrgsim_d()</a></code> to simulate with <code>parallel::mclapply</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_mrgsim_d(
  mod,
  data,
  nchunk = 4,
  ...,
  .as_list = FALSE,
  .p = NULL,
  .dry = FALSE,
  .seed = TRUE,
  .parallel = TRUE
)

mc_mrgsim_d(
  mod,
  data,
  nchunk = 4,
  ...,
  .as_list = FALSE,
  .p = NULL,
  .dry = FALSE,
  .seed = NULL,
  .parallel = TRUE
)

fu_mrgsim_d(
  mod,
  data,
  nchunk = 4,
  ...,
  .as_list = FALSE,
  .p = NULL,
  .dry = FALSE,
  .seed = TRUE,
  .parallel = TRUE
)

fu_mrgsim_d0(..., .dry = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parallel_mrgsim_d_+3A_mod">mod</code></td>
<td>
<p>The mrgsolve model object see <a href="mrgsolve.html#topic+mrgmod-class">mrgsolve::mrgmod</a>.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_d_+3A_data">data</code></td>
<td>
<p>Data set to simulate; see <code><a href="mrgsolve.html#topic+data_set">mrgsolve::data_set()</a></code>.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_d_+3A_nchunk">nchunk</code></td>
<td>
<p>Number of chunks in which to split the data set</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_d_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="mrgsolve.html#topic+mrgsim_d">mrgsim_d()</a></code>.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_d_+3A_.as_list">.as_list</code></td>
<td>
<p>If <code>TRUE</code> a list is return; otherwise (default) a data frame</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_d_+3A_.p">.p</code></td>
<td>
<p>Post processing function executed on the worker; arguments should
be (1) the simulated output (2) the model object.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_d_+3A_.dry">.dry</code></td>
<td>
<p>If <code>TRUE</code> neither the simulation nor the post processing will
be done.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_d_+3A_.seed">.seed</code></td>
<td>
<p>Passed to <code><a href="future.apply.html#topic+future_lapply">future_lapply()</a></code> as <code>future.seed</code>.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_d_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>FALSE</code>, the simulation will not be parallelized; this is
intended for debugging and testing use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or list of simulated data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+future_mrgsim_ei">future_mrgsim_ei()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod &lt;- mrgsolve::house()

data &lt;- mrgsolve::expand.ev(amt = seq(10))

out &lt;- future_mrgsim_d(mod, data, nchunk = 2)

</code></pre>

<hr>
<h2 id='parallel_mrgsim_ei'>Simulate an idata set in parallel</h2><span id='topic+parallel_mrgsim_ei'></span><span id='topic+future_mrgsim_ei'></span><span id='topic+fu_mrgsim_ei'></span><span id='topic+fu_mrgsim_ei0'></span><span id='topic+mc_mrgsim_ei'></span>

<h3>Description</h3>

<p>Use <a href="#topic+future_mrgsim_ei">future_mrgsim_ei</a> to simulate with the <code>future</code> package.  Use
<a href="#topic+mc_mrgsim_ei">mc_mrgsim_ei</a> to simulate with <code>parallel::mclapply</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_mrgsim_ei(
  mod,
  events,
  idata,
  nchunk = 4,
  ...,
  .as_list = FALSE,
  .p = NULL,
  .dry = FALSE,
  .seed = TRUE,
  .parallel = TRUE
)

fu_mrgsim_ei(
  mod,
  events,
  idata,
  nchunk = 4,
  ...,
  .as_list = FALSE,
  .p = NULL,
  .dry = FALSE,
  .seed = TRUE,
  .parallel = TRUE
)

fu_mrgsim_ei0(..., .dry = TRUE)

mc_mrgsim_ei(
  mod,
  events,
  idata,
  nchunk = 4,
  ...,
  .as_list = FALSE,
  .p = NULL,
  .dry = FALSE,
  .seed = NULL,
  .parallel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parallel_mrgsim_ei_+3A_mod">mod</code></td>
<td>
<p>The mrgsolve model object see <a href="mrgsolve.html#topic+mrgmod-class">mrgsolve::mrgmod</a>.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_ei_+3A_events">events</code></td>
<td>
<p>An event object from mrgsolve; see <code><a href="mrgsolve.html#topic+ev">mrgsolve::ev()</a></code>.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_ei_+3A_idata">idata</code></td>
<td>
<p>An idata set of parameters, one per simulation unit (individual);
see <code><a href="mrgsolve.html#topic+idata_set">mrgsolve::idata_set()</a></code>.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_ei_+3A_nchunk">nchunk</code></td>
<td>
<p>Number of chunks in which to split the data set</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_ei_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="mrgsolve.html#topic+mrgsim_d">mrgsim_d()</a></code>.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_ei_+3A_.as_list">.as_list</code></td>
<td>
<p>If <code>TRUE</code> a list is return; otherwise (default) a data frame</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_ei_+3A_.p">.p</code></td>
<td>
<p>Post processing function executed on the worker; arguments should
be (1) the simulated output (2) the model object.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_ei_+3A_.dry">.dry</code></td>
<td>
<p>If <code>TRUE</code> neither the simulation nor the post processing will
be done.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_ei_+3A_.seed">.seed</code></td>
<td>
<p>Passed to <code><a href="future.apply.html#topic+future_lapply">future_lapply()</a></code> as <code>future.seed</code>.</p>
</td></tr>
<tr><td><code id="parallel_mrgsim_ei_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>FALSE</code>, the simulation will not be parallelized; this is
intended for debugging and testing use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or list of simulated data.
</p>


<h3>See Also</h3>

<p><a href="#topic+future_mrgsim_ei">future_mrgsim_ei</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod &lt;- mrgsolve::house()

events &lt;- mrgsolve::ev(amt = 100)

idata &lt;- data.frame(CL = runif(10, 0.5, 1.5))

out &lt;- future_mrgsim_ei(mod, events, idata)

</code></pre>

<hr>
<h2 id='reset_locker'>Initialize the locker directory</h2><span id='topic+reset_locker'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+setup_locker">setup_locker()</a></code> to initialize and
re-initialize a locker directory. We call it <code>reset_locker</code> because it is
expected that the locker space is created once and then repeatedly
reset and simulations are run and re-run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_locker(where, pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reset_locker_+3A_where">where</code></td>
<td>
<p>The full path to the locker.</p>
</td></tr>
<tr><td><code id="reset_locker_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression for finding files to clear from the
locker directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the locker space to be initialized, the <code>where</code> directory must not
exist; if it exists, there will be an error. It is also an error for
<code>where</code> to exist and not contain a particular hidden locker file name
that marks the directory as established locker space.
</p>
<p><strong>NOTE</strong>: when the locker is reset, all contents are cleared according
to the files matched by <code>pattern</code>. If any un-matched files exist after
clearing the directory, a warning will be issued.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setup_locker">setup_locker()</a></code>, <code><a href="#topic+noreset_locker">noreset_locker()</a></code>, <code><a href="#topic+version_locker">version_locker()</a></code>
</p>

<hr>
<h2 id='setup_locker'>Set up a data storage locker</h2><span id='topic+setup_locker'></span>

<h3>Description</h3>

<p>A locker is a directory structure where an enclosing folder contains
subfolders that in turn contain the results of different simulation runs.
When the number of simulation result sets is known, a stream of file names
is returned. This function is mainly called by other functions; an exported
function and documentation is provided in order to better communicate how
the locker works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_locker(where, tag = locker_tag(where))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_locker_+3A_where">where</code></td>
<td>
<p>The directory that contains tagged directories of run
results.</p>
</td></tr>
<tr><td><code id="setup_locker_+3A_tag">tag</code></td>
<td>
<p>The name of a folder under <code>where</code>; this directory must not
exist the first time the locker is set up and <strong>will be deleted</strong> and
re-created each time it is used to store output from a new simulation run.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>where</code> must exist when setting up the locker. The directory <code>tag</code> will be
created under <code>where</code> and must not exist except if it had previously been
set up using <code>setup_locker</code>. Existing <code>tag</code> directories will have a
hidden file in them indicating that they are established simulation output
folders.
</p>
<p>When recreating the <code>tag</code> directory, it will be unlinked and created new.
To not try to set up a locker directory that already contains outputs that
need to be preserved. You can call <code><a href="#topic+noreset_locker">noreset_locker()</a></code> on that directory
to prevent future resets.
</p>


<h3>Value</h3>

<p>The locker location.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reset_locker">reset_locker()</a></code>, <code><a href="#topic+noreset_locker">noreset_locker()</a></code>, <code><a href="#topic+version_locker">version_locker()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- setup_locker(tempdir(), tag = "my-sims")
x

</code></pre>

<hr>
<h2 id='temp_ds'>Create a path to a dataset in tempdir</h2><span id='topic+temp_ds'></span>

<h3>Description</h3>

<p>Create a path to a dataset in tempdir
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temp_ds(tag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="temp_ds_+3A_tag">tag</code></td>
<td>
<p>The dataset subdirectory.</p>
</td></tr>
</table>

<hr>
<h2 id='version_locker'>Version locker contents</h2><span id='topic+version_locker'></span>

<h3>Description</h3>

<p>Version locker contents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>version_locker(where, version = "save", overwrite = FALSE, noreset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="version_locker_+3A_where">where</code></td>
<td>
<p>The locker location.</p>
</td></tr>
<tr><td><code id="version_locker_+3A_version">version</code></td>
<td>
<p>A tag to be appended to <code>where</code> for creating a backup of the
locker contents.</p>
</td></tr>
<tr><td><code id="version_locker_+3A_overwrite">overwrite</code></td>
<td>
<p>If <code>TRUE</code>, the new location will be removed with <code><a href="base.html#topic+unlink">unlink()</a></code>
if it exists.</p>
</td></tr>
<tr><td><code id="version_locker_+3A_noreset">noreset</code></td>
<td>
<p>If <code>TRUE</code>, <code><a href="#topic+noreset_locker">noreset_locker()</a></code> is called <strong>on the new version</strong>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether or not all files were successfully copied
to the backup, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reset_locker">reset_locker()</a></code>, <code><a href="#topic+noreset_locker">noreset_locker()</a></code>, <code><a href="#topic+setup_locker">setup_locker()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>locker &lt;- file.path(tempdir(), "version-locker-example")

if(dir.exists(locker)) unlink(locker, recursive = TRUE)

x &lt;- new_stream(1, locker = locker)

cat("test", file = file.path(locker, "1-1"))

dir.exists(locker)

list.files(locker, all.files = TRUE)

y &lt;- version_locker(locker, version = "y")

y

list.files(y, all.files = TRUE)

</code></pre>

<hr>
<h2 id='write_stream'>Writer functions for stream_file objects</h2><span id='topic+write_stream'></span><span id='topic+write_stream.default'></span><span id='topic+write_stream.stream_format_fst'></span><span id='topic+write_stream.stream_format_feather'></span><span id='topic+write_stream.stream_format_qs'></span><span id='topic+write_stream.stream_format_rds'></span>

<h3>Description</h3>

<p>This function will write out objects that have been assigned a format
with either <code><a href="#topic+format_stream">format_stream()</a></code> or the <code>format</code> argument to <code><a href="#topic+new_stream">new_stream()</a></code>.
See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_stream(x, ...)

## Default S3 method:
write_stream(x, data, ...)

## S3 method for class 'stream_format_fst'
write_stream(x, data, dir = NULL, ...)

## S3 method for class 'stream_format_feather'
write_stream(x, data, dir = NULL, ...)

## S3 method for class 'stream_format_qs'
write_stream(x, data, dir = NULL, ...)

## S3 method for class 'stream_format_rds'
write_stream(x, data, dir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_stream_+3A_x">x</code></td>
<td>
<p>A <code>file_stream</code> object.</p>
</td></tr>
<tr><td><code id="write_stream_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="write_stream_+3A_data">data</code></td>
<td>
<p>An object to write.</p>
</td></tr>
<tr><td><code id="write_stream_+3A_dir">dir</code></td>
<td>
<p>An optional directory location to be used if not already in
the <code>file</code> spot in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method always returns <code>FALSE</code>; other methods which get invoked
if a <code>format</code> was set will return <code>TRUE</code>. So, the user can always call
<code>write_stream()</code> and check the return value: if <code>TRUE</code>, the file was written
to disk and the data to not need to be returned; a <code>FALSE</code> return value
indicates that no format was set and the data should be returned.
</p>
<p>Note the write methods can be invoked directly for a specific format
if no <code>format</code> was set (see examples).
</p>


<h3>Value</h3>

<p>A logical value indicating if the output was written or not.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+format_stream">format_stream()</a></code>, <code><a href="#topic+ext_stream">ext_stream()</a></code>, <code><a href="#topic+locate_stream">locate_stream()</a></code>, <code><a href="#topic+new_stream">new_stream()</a></code>,
<code><a href="#topic+file_stream">file_stream()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- temp_ds("example")

fs &lt;- new_stream(2, locker = ds, format = "fst")

data &lt;- data.frame(x = rnorm(10))

x &lt;- lapply(fs, write_stream, data = data)

list.files(ds)

reset_locker(ds)

fs &lt;- format_stream(fs, "rds")

x &lt;- lapply(fs, write_stream, data = data)

list.files(ds)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
