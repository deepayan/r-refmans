<!DOCTYPE html><html lang="en"><head><title>Help for package XRPython</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {XRPython}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#XRPython-package'>
<p>Functional and Object-based Interface from R to Python</p></a></li>
<li><a href='#convert'><p>Convert Proxy Objects between XRPython and reticulate</p></a></li>
<li><a href='#dict_Python-class'><p>Proxy Class for Python Dictionaries</p></a></li>
<li><a href='#from_Python-class'><p>Class for General Python Class Objects</p></a></li>
<li><a href='#functions'><p>Function Versions of Methods for Python Interface evaluators.</p></a></li>
<li><a href='#ipython'><p>Write a File of Python Commands to Test Package Modules in Python</p></a></li>
<li><a href='#isinstance'><p>Test if a Proxy Object is an Instance of a Python Type</p></a></li>
<li><a href='#list_Python-class'><p>Proxy Class for Python Lists</p></a></li>
<li><a href='#Modules'><p>Import a Python module or add a directory to the Python Search Path</p></a></li>
<li><a href='#noScalar'><p>Send a Non-scalar Version of an Object</p></a></li>
<li><a href='#okPython'><p>Check for a Valid Python for Interface</p></a></li>
<li><a href='#PythonClassDef-class'><p>Class and Generator for Python Class Description from Python Metadata</p></a></li>
<li><a href='#PythonFunction-class'><p>Proxy Objects in R for Python Functions</p></a></li>
<li><a href='#PythonInterface-class'><p>An Interface to Python</p></a></li>
<li><a href='#PythonObject-class'><p>Proxy Objects in R for Python Objects</p></a></li>
<li><a href='#pythonTask'><p>Register an Evaluator Command or Expression at Initialization</p></a></li>
<li><a href='#RPython'><p>An Evaluator for the Python Interface.</p></a></li>
<li><a href='#setPythonClass'><p>Create a Proxy Class for a Python Class</p></a></li>
<li><a href='#setupStep'><p>The Setup Step</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Structured Interface to 'Python'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-10-22</td>
</tr>
<tr>
<td>Author:</td>
<td>John M. Chambers</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Chambers &lt;jmc@r-project.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A 'Python' interface structured according to the general
    form described in package 'XR' and in the book "Extending R".</td>
</tr>
<tr>
<td>Collate:</td>
<td>pythonInterface.R classStructure.R pythonProxyClasses.R</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, XR (&ge; 0.7.1), reticulate</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-10-24 22:16:44 UTC; jmc</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-10-24 22:29:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='XRPython-package'>
Functional and Object-based Interface from R to Python
</h2><span id='topic+XRPython-package'></span><span id='topic+XRPython'></span>

<h3>Description</h3>

<p>An Interface from R to Python using, in a very preliminary way, the
principles of functional and object-based interface design presented
in the reference.
</p>


<h3>Author(s)</h3>

<p>John M. Chambers
</p>


<h3>References</h3>

<p>Chambers, John M. (book in progress)
<em>Extending R</em>
</p>

<hr>
<h2 id='convert'>Convert Proxy Objects between XRPython and reticulate</h2><span id='topic+convert'></span><span id='topic+fromRtclt'></span><span id='topic+toRtclt'></span>

<h3>Description</h3>

<p>Packages XRPython and reticulate both support proxies for Python objects; that is, R objects that are
proxies for objects created in Python by evaluations in the respective packages.  Function <code>fromRtclt()</code>
returns the equivalent XRPython proxy object given a reticulate object.
Function <code>toRtclt()</code> returns the equivalent reticulate proxy object given an XRPython object.
Normally, no copying is involved in either direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromRtclt(obj, .ev = XRPython::RPython())

toRtclt(obj, .ev = XRPython::RPython())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_+3A_obj">obj</code></td>
<td>
<p>a proxy object, computed in XRPython for <code>toRtclt</code> or by reticulate for <code>fromRtclt</code></p>
</td></tr>
<tr><td><code id="convert_+3A_.ev">.ev</code></td>
<td>
<p>an XRPython evaluator, by default and usually the current evaluator.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>fromRtclt</code>: Convert from reticulate to XRPython
</p>
</li>
<li> <p><code>toRtclt</code>: Convert from XRPython to reticulate
</p>
</li></ul>

<hr>
<h2 id='dict_Python-class'>Proxy Class for Python Dictionaries</h2><span id='topic+dict_Python-class'></span><span id='topic+dict_Python'></span>

<h3>Description</h3>

<p>This class is a proxy for ordinary dictionary objects in Python.  All the
standard Python methods for such objects (e.g., <code>keys()</code>) are
available, but methods for R functions are not implemented.
</p>


<h3>Methods</h3>


<dl>
<dt><code>clear(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: clear()
D.clear() -&gt; None.  Remove all items from D.</p>
</dd>
<dt><code>fromkeys(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: fromkeys()
dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.
v defaults to None.</p>
</dd>
<dt><code>get(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: get()
D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</p>
</dd>
<dt><code>has_key(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: has_key()
D.has_key(k) -&gt; True if D has a key k, else False</p>
</dd>
<dt><code>items(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: items()
D.items() -&gt; list of D's (key, value) pairs, as 2-tuples</p>
</dd>
<dt><code>iteritems(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: iteritems()
D.iteritems() -&gt; an iterator over the (key, value) items of D</p>
</dd>
<dt><code>iterkeys(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: iterkeys()
D.iterkeys() -&gt; an iterator over the keys of D</p>
</dd>
<dt><code>itervalues(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: itervalues()
D.itervalues() -&gt; an iterator over the values of D</p>
</dd>
<dt><code>keys(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: keys()
D.keys() -&gt; list of D's keys</p>
</dd>
<dt><code>pop(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: pop()
D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised</p>
</dd>
<dt><code>popitem(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: popitem()
D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a
2-tuple; but raise KeyError if D is empty.</p>
</dd>
<dt><code>setdefault(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: setdefault()
D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p>
</dd>
<dt><code>update(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: update()
D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k in F: D[k] = F[k]</p>
</dd>
<dt><code>values(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: values()
D.values() -&gt; list of D's values</p>
</dd>
<dt><code>viewitems(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: viewitems()
D.viewitems() -&gt; a set-like object providing a view on D's items</p>
</dd>
<dt><code>viewkeys(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: viewkeys()
D.viewkeys() -&gt; a set-like object providing a view on D's keys</p>
</dd>
<dt><code>viewvalues(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: viewvalues()
D.viewvalues() -&gt; an object providing a view on D's values</p>
</dd>
</dl>

<hr>
<h2 id='from_Python-class'>Class for General Python Class Objects</h2><span id='topic+from_Python-class'></span>

<h3>Description</h3>

<p>The Python side of the interface will return a general object from a Python class as an R
object of class &quot;from_Python&quot;.  Its Python fields (converted to R objects) can be accessed by the <code>$</code>
operator.
</p>


<h3>Slots</h3>


<dl>
<dt><code>serverClass</code></dt><dd><p>the Python type.</p>
</dd>
<dt><code>module</code></dt><dd><p>the Python module, or &quot;&quot;</p>
</dd>
<dt><code>fields</code></dt><dd><p>the converted versioin of the Python fields; these are accessed by the <code>$</code> operator.</p>
</dd>
</dl>

<hr>
<h2 id='functions'>Function Versions of Methods for Python Interface evaluators.</h2><span id='topic+functions'></span><span id='topic+pythonSend'></span><span id='topic+pythonEval'></span><span id='topic+pythonCommand'></span><span id='topic+pythonCall'></span><span id='topic+pythonGet'></span><span id='topic+pythonSource'></span><span id='topic+pythonDefine'></span><span id='topic+pythonSerialize'></span><span id='topic+pythonUnserialize'></span><span id='topic+pythonName'></span><span id='topic+pythonShell'></span>

<h3>Description</h3>

<p>These functions allow application code to invoke evaluator methods for essentially all basic computations.   Usually, they access
the current Python evaluator, starting one if none exists.  For details, see the documentation for the corresponding method, under
<a href="#topic+PythonInterface">PythonInterface</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pythonSend(object, evaluator = XR::getInterface(.PythonInterfaceClass))

pythonEval(expr, ..., evaluator = XR::getInterface(.PythonInterfaceClass))

pythonCommand(expr, ..., evaluator = XR::getInterface(.PythonInterfaceClass))

pythonCall(fun, ..., evaluator = XR::getInterface(.PythonInterfaceClass))

pythonGet(object, evaluator = XR::getInterface(.PythonInterfaceClass))

pythonSource(file, ..., evaluator = XR::getInterface(.PythonInterfaceClass))

pythonDefine(text, file, ...,
  evaluator = XR::getInterface(.PythonInterfaceClass))

pythonSerialize(object, file, append = FALSE,
  evaluator = XR::getInterface(.PythonInterfaceClass))

pythonUnserialize(file, all = FALSE,
  evaluator = XR::getInterface(.PythonInterfaceClass))

pythonName(object)

pythonShell(..., evaluator = XR::getInterface(.PythonInterfaceClass))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="functions_+3A_object">object</code></td>
<td>
<p>For <code>pythonSend()</code>, an R object, to be sent to Python.  For <code>pythonGet()</code>,
<code>pythonSerialize()</code> and <code>pythonNqme()</code>, a proxy object for
a Python object.</p>
</td></tr>
<tr><td><code id="functions_+3A_evaluator">evaluator</code></td>
<td>
<p>The evaluator object to use.  By default, and usually, the current evaluator
is used, and one is started if none has been.</p>
</td></tr>
<tr><td><code id="functions_+3A_expr">expr</code></td>
<td>
<p>A string for a Python expression or command, with C-style fields (<code>"%s"</code>) to be substituted for the following arguments, if any.</p>
</td></tr>
<tr><td><code id="functions_+3A_...">...</code></td>
<td>
<p>For the evaluation functions: Objects, either R objects to be converted or proxies for Python objects previously computed.
For other functions, specialized arguments for the corresponding method.
In particular, <code>.get=</code> for controlling whether the computed result should be converted.</p>
</td></tr>
<tr><td><code id="functions_+3A_fun">fun</code></td>
<td>
<p>the string name of the function; a module name must be included in the string if the function has
not been explicitly imported from that module.</p>
</td></tr>
<tr><td><code id="functions_+3A_file">file</code></td>
<td>
<p>A filename or an open connection, for reading or writing depending on the function</p>
</td></tr>
<tr><td><code id="functions_+3A_text">text</code></td>
<td>
<p>the definition as text (supply argument  file= instead  to read it from a file)</p>
</td></tr>
<tr><td><code id="functions_+3A_append">append</code></td>
<td>
<p>should the serializing text be appended to a file; otherwise the file will be truncated on opening.</p>
</td></tr>
<tr><td><code id="functions_+3A_all">all</code></td>
<td>
<p>should the unserialized object be a list of all serialized objects on the file?</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>pythonSend</code>: sends the <code>object</code> to Python, converting it via methods for
<code><a href="XR.html#topic+asServerObject">asServerObject</a></code> and returns a proxy for the converted object.
</p>
</li>
<li> <p><code>pythonEval</code>: evaluates the <code>expr</code> string subsituting the arguments.
</p>
</li>
<li> <p><code>pythonCommand</code>: evaluates the <code>expr</code> string subsituting the arguments; used for a command that is not
an expression.
</p>
</li>
<li> <p><code>pythonCall</code>: call the function in Python, with arguments given.
</p>
</li>
<li> <p><code>pythonGet</code>: converts the proxy object that is its argument to an <span class="rlang"><b>R</b></span> object.
</p>
</li>
<li> <p><code>pythonSource</code>: evaluate the file of Python source.
</p>
</li>
<li> <p><code>pythonDefine</code>: define a Python function
</p>
</li>
<li> <p><code>pythonSerialize</code>: serialize the <code>object</code> in Python, via <code>pickle</code>
</p>
</li>
<li> <p><code>pythonUnserialize</code>: unserialize the file in Python, via <code>pickle</code>
</p>
</li>
<li> <p><code>pythonName</code>: return the name by which this proxy object was assigned in Python
</p>
</li>
<li> <p><code>pythonShell</code>: Start an interactive Python shell.  See the chapter file in the documentation, section 14.3.
</p>
</li></ul>

<hr>
<h2 id='ipython'>Write a File of Python Commands to Test Package Modules in Python</h2><span id='topic+ipython'></span>

<h3>Description</h3>

<p>A file of python commands will be written that set up an interactive Python session
having imported the contents from a file (module) of python code in an R package.
Typically, uploading such a file to <code>ipython</code> notebook allows the python code, along with additional or modified code, to
be tested directly without interfacing from R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipython(file, package, module = "", ..., RPython = TRUE,
  folder = "python")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ipython_+3A_file">file</code></td>
<td>
<p>A file name or open write connection.  The python commands generated will be written to this file.</p>
</td></tr>
<tr><td><code id="ipython_+3A_package">package</code></td>
<td>
<p>The R package containing the relevent module</p>
</td></tr>
<tr><td><code id="ipython_+3A_module">module</code></td>
<td>
<p>The file (module) to be imported.  Specifically, a command <code>"from ... import *"</code> will be generated.
Omit this argument or supply it as <code>""</code> to suppress this command, in which case explicit commands should be provided.</p>
</td></tr>
<tr><td><code id="ipython_+3A_...">...</code></td>
<td>
<p>Additional python commands to be appended to the output file.</p>
</td></tr>
<tr><td><code id="ipython_+3A_rpython">RPython</code></td>
<td>
<p>Should the path include the XRPython code, default <code>TRUE</code>, which is usually what you want.</p>
</td></tr>
<tr><td><code id="ipython_+3A_folder">folder</code></td>
<td>
<p>The name of the folder in the installed package; the default is the suggested <code>"python"</code>; that is, the installed
version of folder <code>"inst/python"</code> in the source for the package.  Note that it's the installed version; changes to the source
code must be installed to show up in the output.</p>
</td></tr>
</table>

<hr>
<h2 id='isinstance'>Test if a Proxy Object is an Instance of a Python Type</h2><span id='topic+isinstance'></span>

<h3>Description</h3>

<p>Applies the Python function <code>isinstance()</code> to <code>object</code>.  NOTE:  this function should be used to test inheritance on the Python side,
even if there are proxy classes for everything involved.  It is not true (with the present version of the package) that inheritance in Python
corresponds to inheritance in R for the proxy classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isinstance(object, type, .ev = RPython())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isinstance_+3A_object">object</code></td>
<td>
<p>Any object.  The function returns <code>FALSE</code> without further testing if the object is not a proxy object.</p>
</td></tr>
<tr><td><code id="isinstance_+3A_type">type</code></td>
<td>
<p>A character string corresponding to the Python type (not to the name of a proxy class for the type).
</p>
<p>A Python error will result
if there is no such type, or if <code>object</code> is a proxy from another language.
The implementation diverges from a direct mapping into the Python <code>isinstance</code> to handle a Python bizarre for functions:  although <code>type(f)</code>
causes you to think functions have the obvious type, that doesn't work in <code>isinstance</code>.  So the R code uses what works for this case.
(Before we get too sarcastic, the problem is similar to that in R from primitives, making <code>class(f)</code> and <code>typeof(f)</code> confusing.)</p>
</td></tr>
<tr><td><code id="isinstance_+3A_.ev">.ev</code></td>
<td>
<p>an XRPython evaluator, by default and usually the current evaluator.</p>
</td></tr>
</table>

<hr>
<h2 id='list_Python-class'>Proxy Class for Python Lists</h2><span id='topic+list_Python-class'></span><span id='topic+list_Python'></span>

<h3>Description</h3>

<p>This class is a proxy for ordinary list objects in Python.  All the
standard Python methods for such objects (e.g., <code>append()</code>) are
available, but methods for R functions such as <code>]</code> are not
implemented because Python operators do not behave functionally.
Instead, additional methods are defined for the proxy lists, e.g.,
<code>el(i)</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>append(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: append()
L.append(object) &ndash; append object to end</p>
</dd>
<dt><code>count(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: count()
L.count(value) -&gt; integer &ndash; return number of occurrences of value</p>
</dd>
<dt><code>el(i, .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Extract an element from the list (zero based indexing).
The index will be coerced to integer (unless a proxy).</p>
</dd>
<dt><code>extend(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: extend()
L.extend(iterable) &ndash; extend list by appending elements from the iterable</p>
</dd>
<dt><code>index(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: index()
L.index(value, [start, [stop]]) -&gt; integer &ndash; return first index of value.
Raises ValueError if the value is not present.</p>
</dd>
<dt><code>insert(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: insert()
L.insert(index, object) &ndash; insert object before index</p>
</dd>
<dt><code>pop(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: pop()
L.pop([index]) -&gt; item &ndash; remove and return item at index (default last).
Raises IndexError if list is empty or index is out of range.</p>
</dd>
<dt><code>remove(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: remove()
L.remove(value) &ndash; remove first occurrence of value.
Raises ValueError if the value is not present.</p>
</dd>
<dt><code>reverse(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: reverse()
L.reverse() &ndash; reverse *IN PLACE*</p>
</dd>
<dt><code>sort(..., .ev = XRPython::RPython(), .get = NA)</code></dt><dd><p>Python Method: sort()
L.sort(cmp=None, key=None, reverse=False) &ndash; stable sort *IN PLACE*;
cmp(x, y) -&gt; -1, 0, 1</p>
</dd>
</dl>

<hr>
<h2 id='Modules'>Import a Python module or add a directory to the Python Search Path</h2><span id='topic+Modules'></span><span id='topic+pythonImport'></span><span id='topic+pythonAddToPath'></span>

<h3>Description</h3>

<p>If called from the source directory of a package during installation, both <code>pythonImport</code>
and <code>pythonAddToPath()</code> also set up
a load action for that package.  The functional versions, not the methods themselves, should
be called from package source files to ensure that the load actions are created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pythonImport(..., evaluator, where = topenv(parent.frame()))

pythonAddToPath(directory = "python",
  package = utils::packageName(topenv(parent.frame())), pos = NA, evaluator,
  where = topenv(parent.frame()))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Modules_+3A_...">...</code>, <code id="Modules_+3A_where">where</code></td>
<td>
<p>arguments for the <code>$Import()</code> method. See the method documentation for details.</p>
</td></tr>
<tr><td><code id="Modules_+3A_evaluator">evaluator</code></td>
<td>
<p>The evaluator object to use. Supplying this argument suppresses the load action.</p>
</td></tr>
<tr><td><code id="Modules_+3A_directory">directory</code></td>
<td>
<p>the directory to add, defaults to &quot;python&quot;</p>
</td></tr>
<tr><td><code id="Modules_+3A_package">package</code>, <code id="Modules_+3A_pos">pos</code></td>
<td>
<p>arguments <code>package</code> and <code>pos</code> to the method, usually omitted.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>pythonImport</code>: Add the module and name information specified to the objects imported for Python evaluators.
</p>
</li>
<li> <p><code>pythonAddToPath</code>: Add the directory specified to the search path for future Python objects.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## How to search from a local directory, import a function from a file there
## and call the function.
## Including the evaluator argument causes the path change and import to happen
## right now, not in a package being loaded
ev &lt;- RPython()
pythonAddToPath("/Users/me/myPython/", package = "",
                evaluator = ev)
pythonImport("funEx", "foo", evaluator = ev)
pythonCall("foo", 1.1, 1.2)

## End(Not run)
</code></pre>

<hr>
<h2 id='noScalar'>Send a Non-scalar Version of an Object</h2><span id='topic+noScalar'></span>

<h3>Description</h3>

<p>Ensures that an object is interpreted as a vector (array) when sent to the server language.
The default strategy is to send length-1 vectors as scalars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noScalar(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noScalar_+3A_object">object</code></td>
<td>
<p>A vector object.  Calling with a non-vector is an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object, but with the S4 bit turned on.
Relies on the convention that XR interfaces leave S4 objects
as vectors, not scalars, even when they are of length 1
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='okPython'>Check for a Valid Python for Interface</h2><span id='topic+okPython'></span>

<h3>Description</h3>

<p>The function returns true or false according to whether a Python interface can be established.  This
will fail if no Python exists, if it is incompatible with this version of XRPython (e.g., 32 vs 64 bits
in Windows), or if for some reason it can't evaluate a trivial expression correctly.  Warnings are printed
but ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>okPython(verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="okPython_+3A_verbose">verbose</code></td>
<td>
<p>Should a message with the cause of a failure be reported?  Default <code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='PythonClassDef-class'>Class and Generator for Python Class Description from Python Metadata</h2><span id='topic+PythonClassDef'></span><span id='topic+PythonClassDef-class'></span>

<h3>Description</h3>

<p>A description of a Python class, obtained from the Python class
definition object.
This class extends the <code>"ServerClassDef"</code> class in the XR package.
</p>


<h3>Fields</h3>


<dl>
<dt><code>className</code></dt><dd><p>the name of the Python class
##</p>
</dd>
<dt><code>module</code></dt><dd><p>the name of the Python module</p>
</dd>
</dl>

<hr>
<h2 id='PythonFunction-class'>Proxy Objects in R for Python Functions</h2><span id='topic+PythonFunction-class'></span><span id='topic+PythonFunction'></span>

<h3>Description</h3>

<p>A class and generator function for proxies in R for Python functions.
</p>


<h3>Details</h3>

<p>An object from this class is an R function that is a proxy for a function in Python. Calls to the R function evaluate
a call to the Python function.  The arguments in the call are converted to equivalent Python objects;
these typically include proxy objects for results previously computed through the XRPython interface.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>the name of the server language function</p>
</dd>
<dt><code>module</code></dt><dd><p>the name of the module, if that needs to be imported</p>
</dd>
<dt><code>evaluatorClass</code></dt><dd><p>the class for the evaluator, by default and usually, <code><a href="#topic+PythonInterface">PythonInterface</a></code></p>
</dd>
<dt><code>serverDoc</code></dt><dd><p>the docstring from Python, if any.</p>
</dd>
<dt><code>serverArgs</code></dt><dd><p>the Python argument names (not currently used).</p>
</dd>
</dl>

<hr>
<h2 id='PythonInterface-class'>An Interface to Python</h2><span id='topic+PythonInterface'></span><span id='topic+PythonInterface-class'></span>

<h3>Description</h3>

<p>The <code>"PythonInterface"</code> class provides an evaluator for computations in Python, following the structure
in the XR  package.  Proxy functions and classes allow use of the interface with no explicit
reference to the evaluator.  The function <code>RPython()</code> returns an evaluator object.
</p>


<h3>Details</h3>

<p>The class extends the <code>"Interface"</code> class in the XR package and has the same fields.
Python-specific methods use the rPython low-level interface.  See the Chapter from the
&ldquo;Extending R&rdquo; book in the documents for this package for details.
</p>


<h3>Methods</h3>


<dl>
<dt><code>Define(text, file)</code></dt><dd><p>Define a Python function from a character vector, 'text' or by reading the text
from a file via readLines().  Character vectors are taken to represent lines of Python code
in a function definiition.  The method returns a proxy function with a name inferred from
the first line of the text.</p>
</dd>
<dt><code>Import(module, ...)</code></dt><dd><p>The Python version of this method replaces the general version in XR with the &quot;import&quot; or
&quot;from ... import&quot; directives in Python as appropriate.  Returns the 'reticulate' version of the module object, which can be used directly.</p>
</dd>
<dt><code>initialize(...)</code></dt><dd><p>The Python version, with special defaults for prototypeObject and modules</p>
</dd>
<dt><code>PythonCommand(strings)</code></dt><dd><p>A low-level command execution, needed for initializing.  Normally should not be used by applications
since it does no error checking; use $Command() instead.</p>
</dd>
<dt><code>ServerAddToPath(serverDirectory, serverPos)</code></dt><dd><p>The Python version using sys.path.append()</p>
</dd>
<dt><code>ServerClassDef(Class, module = "", example = TRUE)</code></dt><dd><p>The Python version using PythonClassDef()</p>
</dd>
<dt><code>ServerEval(strings, key = "", get = NA)</code></dt><dd><p>The Python version using value_for_R()</p>
</dd>
<dt><code>ServerFunctionDef(name, module = "")</code></dt><dd><p>The Python version using PythonFunction()</p>
</dd>
<dt><code>ServerRemove(key)</code></dt><dd><p>The Python version using del_for_R())</p>
</dd>
<dt><code>ServerSerialize(key, file)</code></dt><dd><p>Serializing and unserializing in the Python interface use the pickle structure in Python.
Serialization does not rely on the R equivalent object.</p>
</dd>
<dt><code>ServerUnserialize(file, all = FALSE)</code></dt><dd><p>The Python unserialize using unpickle</p>
</dd>
<dt><code>Shell(endCode = "exit", prompt = "Py&gt;: ", cont = "Py+: ")</code></dt><dd><p>Starts an interactive Python shell.  Each line of input must be a complete Python expression
or command, which will be evaluated in the same context as $Eval() expressions.
To continue over multiple lines, end all but the last with an unescaped backslash.
The argument 'endCode' is the string to type to leave the shell, by default &quot;exit&quot;.</p>
</dd>
<dt><code>Source(filename)</code></dt><dd><p>The $Source() method uses the Python function execfile() and therefore is quite efficient.</p>
</dd>
</dl>

<hr>
<h2 id='PythonObject-class'>Proxy Objects in R for Python Objects</h2><span id='topic+PythonObject-class'></span><span id='topic+PythonObject'></span>

<h3>Description</h3>

<p>This is a class for all proxy objects from a Python class with an R proxy class definition.
Objects will normally be from a subclass of this class, for the specific Python class.
</p>


<h3>Details</h3>

<p>Proxy objects returned from the Python interface will be promoted to objects
from a specific R proxy class for their Python class, if such a class has been defined.
</p>

<hr>
<h2 id='pythonTask'>Register an Evaluator Command or Expression at Initialization</h2><span id='topic+pythonTask'></span>

<h3>Description</h3>

<p>An unevalated command or expression for the interface is supplied, typically using
<code>quote()</code> or <code>substitute</code>.  When an evaluator from the class is created, this
command will be evaluated.  Repeated calls to this function, to <code>serverAddToPath()</code>
and to <code>serverImport()</code> will evaluate the corresponding requests, in the order in
which the corresponding calls took place (typically in the source of a pacakage).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pythonTask(command)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pythonTask_+3A_command">command</code></td>
<td>
<p>an <em>unevaluated</em> command or expression for the evaluator.</p>
</td></tr>
</table>

<hr>
<h2 id='RPython'>An Evaluator for the Python Interface.</h2><span id='topic+RPython'></span>

<h3>Description</h3>

<p>Returns an evaluator for the Python interface.  Starts one on the first call, or if arguments are provided;
providing argument <code>.makeNew = TRUE</code> will force a new evaluator.  Otherwise, the current evaluator is
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RPython(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RPython_+3A_...">...</code></td>
<td>
<p>arguments to control whether a new evaluator is started.  Normally omitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+PythonInterface">PythonInterface</a></code> for details of the evaluator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(okPython(TRUE)) {
  ev &lt;- RPython()
  xx &lt;- ev$Eval("[1, %s, 5]", pi)
  xx
  xx$append(4.5)
  ev$Command("print %s", xx)
}
</code></pre>

<hr>
<h2 id='setPythonClass'>Create a Proxy Class for a Python Class</h2><span id='topic+setPythonClass'></span>

<h3>Description</h3>

<p>An R class is defined to act as a proxy for a specified Python class.  This specializes the
<code><a href="XR.html#topic+setProxyClass">setProxyClass</a></code> function using Python facilities for finding the class definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPythonClass(Class, module = "", fields = character(), methods = NULL,
  ServerClass = Class, where = topenv(parent.frame()),
  contains = character(), proxyObjectClass = "PythonObject", ...,
  example = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPythonClass_+3A_class">Class</code></td>
<td>
<p>the Python name for the class.</p>
</td></tr>
<tr><td><code id="setPythonClass_+3A_module">module</code></td>
<td>
<p>the Python module, if this is not a standard library class.</p>
</td></tr>
<tr><td><code id="setPythonClass_+3A_fields">fields</code>, <code id="setPythonClass_+3A_methods">methods</code>, <code id="setPythonClass_+3A_where">where</code>, <code id="setPythonClass_+3A_...">...</code></td>
<td>
<p>arguments to <code>setProxyClass</code> and usually omitted.</p>
</td></tr>
<tr><td><code id="setPythonClass_+3A_serverclass">ServerClass</code>, <code id="setPythonClass_+3A_contains">contains</code>, <code id="setPythonClass_+3A_proxyobjectclass">proxyObjectClass</code></td>
<td>
<p>ditto.</p>
</td></tr>
<tr><td><code id="setPythonClass_+3A_example">example</code></td>
<td>
<p>an optional (proxy for) an object from the class, to be used to define the fields in the
class.  If omitted, the interface tries to create a standard object from the class by calling the Python
generator with no argument.  Argument <code>example</code> can also be supplied as <code>FALSE</code> to suppress
generating the default object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods and (inferred) fields of a Python Class are determined and returned consistently
with the XR structure.
Python classes are coded as class objects in Python, but only the methods are fixed and defined.
Objects from the class can have any fields, usually created at initialization time but entirely legal
to be added by other methods later.  By default, the initialize method tries to create an object from the
class, with no arguments in the call to the class generator.   Supply the <code>example</code> argument to
override.
</p>

<hr>
<h2 id='setupStep'>The Setup Step</h2><span id='topic+setupStep'></span>

<h3>Description</h3>

<p>The file <code>"setup.R"</code> in the <code>tools</code> directory is designed to create an explicit definiion of proxy
classes for the <code>"list"</code> and <code>"dict"</code> types in Python.  The file would be run through
<code>XR::packageSetup()</code> when creating or modifying these classes in the <code>XRPython</code> package.  It provides
a useful example for the general task of creating an explicit, written-out version of a proxy class.
</p>


<h3>Details</h3>

<p>The setup step generates a file <code>"R/pythonProxyClasses.R"</code> in the source directory for the package.  The
setup step needs to be run twice, first to generate the R code in that file, and again to use the
<code>roxygen2</code> package to generate documentation.
</p>
<p>For the first round, the package needs to be installed with an empty version of the file (the file has to exist
because the package uses a <code>Collate:</code> directive that mentions it.  Running <code>packageSetup()</code> this time
defines the proxy classes and dumps them (with some extra stuff) to the target file.  and  adds a line to the
<code>NAMESPACE</code> to export both classes. (If we were willing to let <code>roxygenize()</code> create the namespace
directives this would be automatic, but I'm not willing.)
</p>
<p>Now the package needs to be installed again, this time with the proxy classes, The second pass of the setup file
runs <code>roxygenize()</code>.  Finally, as usual with <code>roxygenize()</code>,
the package has to be installed one more time to generate the actual documentation.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
