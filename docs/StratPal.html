<!DOCTYPE html><html lang="en-US"><head><title>Help for package StratPal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {StratPal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#StratPal-package'><p>StratPal: Stratigraphic Paleobiology Modeling Pipelines</p></a></li>
<li><a href='#apply_niche'><p>apply niche model</p></a></li>
<li><a href='#apply_taphonomy'><p>model taphonomic effects</p></a></li>
<li><a href='#bounded_niche'><p>define niche from boundaries</p></a></li>
<li><a href='#ornstein_uhlenbeck'><p>simulate ornstein-uhlenbeck (OU) process</p></a></li>
<li><a href='#ornstein_uhlenbeck_sl'><p>simulate ornstein-uhlenbeck (OU) process (specimen level)</p></a></li>
<li><a href='#p3'><p>simulate Poisson point process</p></a></li>
<li><a href='#p3_var_rate'><p>simulate variable rate Poisson point process</p></a></li>
<li><a href='#plot.pre_paleoTS'><p>plot pre-paleoTS objects</p></a></li>
<li><a href='#prob_remove'><p>probabilistic removal of elements</p></a></li>
<li><a href='#random_walk'><p>simulate (un)biased random walk</p></a></li>
<li><a href='#random_walk_sl'><p>simulate (un)biased random walk (specimen level)</p></a></li>
<li><a href='#reduce_to_paleoTS'><p>reduce pre-paleoTS format to paleoTS</p></a></li>
<li><a href='#rej_samp'><p>random numbers from rejection sampling</p></a></li>
<li><a href='#scenarioA'><p>example data, scenario A from Hohmann et al. (2024)</p></a></li>
<li><a href='#snd_niche'><p>simple niche model</p></a></li>
<li><a href='#stasis'><p>simulate phenotypic stasis</p></a></li>
<li><a href='#stasis_sl'><p>simulate phenotypic stasis (specimen level)</p></a></li>
<li><a href='#strict_stasis_sl'><p>simulate strict phenotypic stasis (specimen level)</p></a></li>
<li><a href='#thin'><p>thin a series of events (e.g. fossil occurrences)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Stratigraphic Paleobiology Modeling Pipelines</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>The fossil record is a joint expression of ecological, taphonomic, 
    evolutionary, and stratigraphic processes (Holland and Patzkowsky, 2012, ISBN:978-0226649382).
    This package allowing to simulate biological processes in the time domain
    (e.g., trait evolution, fossil abundance), and examine how their expression
    in the rock record (stratigraphic domain) is influenced based on 
    age-depth models, ecological niche models, and taphonomic effects.
    Functions simulating common processes used in modeling trait evolution or 
    event type data such as first/last occurrences are provided and can be used 
    standalone or as part of a pipeline. The package comes with example 
    data sets and tutorials in several vignettes, which can be used as a 
    template to set up one's own simulation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>admtools (&ge; 0.4.0), paleoTS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mindthegap-erc.github.io/StratPal/">https://mindthegap-erc.github.io/StratPal/</a> ,
<a href="https://github.com/MindTheGap-ERC/StratPal">https://github.com/MindTheGap-ERC/StratPal</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MindTheGap-ERC/StratPal/issues">https://github.com/MindTheGap-ERC/StratPal/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-20 11:26:43 UTC; hohma004</td>
</tr>
<tr>
<td>Author:</td>
<td>Niklas Hohmann <a href="https://orcid.org/0000-0003-1559-1838"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Niklas Hohmann &lt;N.H.Hohmann@uu.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-20 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='StratPal-package'>StratPal: Stratigraphic Paleobiology Modeling Pipelines</h2><span id='topic+StratPal'></span><span id='topic+StratPal-package'></span>

<h3>Description</h3>

<p>The fossil record is a joint expression of ecological, taphonomic, evolutionary, and stratigraphic processes (Holland and Patzkowsky, 2012, ISBN:978-0226649382). This package allowing to simulate biological processes in the time domain (e.g., trait evolution, fossil abundance), and examine how their expression in the rock record (stratigraphic domain) is influenced based on age-depth models, ecological niche models, and taphonomic effects. Functions simulating common processes used in modeling trait evolution or event type data such as first/last occurrences are provided and can be used standalone or as part of a pipeline. The package comes with example data sets and tutorials in several vignettes, which can be used as a template to set up one's own simulation.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Niklas Hohmann <a href="mailto:N.H.Hohmann@uu.nl">N.H.Hohmann@uu.nl</a> (<a href="https://orcid.org/0000-0003-1559-1838">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mindthegap-erc.github.io/StratPal/">https://mindthegap-erc.github.io/StratPal/</a>
</p>
</li>
<li> <p><a href="https://github.com/MindTheGap-ERC/StratPal">https://github.com/MindTheGap-ERC/StratPal</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/MindTheGap-ERC/StratPal/issues">https://github.com/MindTheGap-ERC/StratPal/issues</a>
</p>
</li></ul>


<hr>
<h2 id='apply_niche'>apply niche model</h2><span id='topic+apply_niche'></span>

<h3>Description</h3>

<p>Models niches by removing events (fossil occurrences) or specimens when they are outside of their niche. For event type data, this is done using the function <code>thin</code>, for <code>pre_paleoTS</code> this is done by applying the function <code>prob_remove</code> on the specimens.
Combines the functions <code>niche_def</code> and <code>gc</code> (&quot;gradient change&quot;) to determine how the taxons' collection probability changes with time/position. This is done by composing <code>niche_def</code> and <code>gc</code>. The result is then used to remove events/specimens in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_niche(x, niche_def, gc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_niche_+3A_x">x</code></td>
<td>
<p>events type data, e.g. vector of times/ages of fossil occurrences or their stratigraphic position, or a <code>pre_paleoTS</code> object (e.g. produced by <code>stasis_sl</code>).</p>
</td></tr>
<tr><td><code id="apply_niche_+3A_niche_def">niche_def</code></td>
<td>
<p>function, specifying the niche along a gradient. Should return 0 when taxon is outside of niche, and 1 when inside niche. Values between 0 and 1 are interpreted as collection probabilities. Must be vectorized, meaning if given a vector, it must return a vector of equal length.</p>
</td></tr>
<tr><td><code id="apply_niche_+3A_gc">gc</code></td>
<td>
<p>function, stands for &quot;gradient change&quot;. Specifies how the gradient changes, e.g. with time. Must be vectorized, meaning if given a vector, it must return a vector of equal length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for a numeric vector input, returns a numeric vector, timing/location of events (e.g. fossil ages/locations) preserved after the niche model is applied. For a <code>pre_paleoTS</code> object as input, returns a <code>pre_paleoTS</code> object with specimens removed according to the niche model.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+snd_niche">snd_niche()</a></code> and <code><a href="#topic+bounded_niche">bounded_niche()</a></code> for template niche models
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;vignette("advanced_functionality)&#8288;</code> for how to create user-defined niche models
</p>
</li>
<li> <p><code><a href="#topic+apply_taphonomy">apply_taphonomy()</a></code> to model taphonomic effects based on a similar principle
</p>
</li>
<li> <p><code><a href="#topic+thin">thin()</a></code> and <code><a href="#topic+prob_remove">prob_remove()</a></code> for the underlying mathematical procedures
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>### example for event type data
## setup
# using water depth as gradient
 t = scenarioA$t_myr
 wd = scenarioA$wd_m[,"8km"]
 gc = approxfun(t, wd)
 plot(t, gc(t), type = "l", xlab = "Time", ylab = "water depth [m]",
  main = "gradient change with time")
 # define niche
 # preferred wd 10 m, tolerant to intermediate wd changes (standard deviation 10 m), non-terrestrial
 niche_def = snd_niche(opt = 10, tol = 10, cutoff_val = 0)
 plot(seq(-1, 50, by = 0.5), niche_def(seq(-1, 50, by = 0.5)), type = "l",
 xlab = "water depth", ylab = "collection probability", main = "Niche def")
 # niche pref with time
 plot(t, niche_def(gc(t)), type = "l", xlab = "time",
 ylab = "collection probability", main = "collection probability with time")

 ## simulate fossil occurrences
 foss_occ = p3(rate = 100, from = 0, to = max(t))
 # foss occ without niche pref
 hist(foss_occ, xlab = "time")
 foss_occ_niche = apply_niche(foss_occ, niche_def, gc)
 # fossil occurrences with niche preference
 hist(foss_occ_niche, xlab = "time")

 # see also
 #vignette("event_data")
 # for a detailed example on niche modeling for event type data

 ### example for pre_paleoTS objects
 # we reuse the niche definition and gradient change from above!
 x = stasis_sl(seq(0, max(t), length.out = 10))
 plot(reduce_to_paleoTS(x), main = "Trait evolution before niche modeling")
 y = apply_niche(x, niche_def, gc)
 plot(reduce_to_paleoTS(y), main = "Trait evolution after niche modeling")
 # note that there are fewer sampling sites
 # bc the taxon does not appear everywhere
 # and there are fewer specimens per sampling site

</code></pre>

<hr>
<h2 id='apply_taphonomy'>model taphonomic effects</h2><span id='topic+apply_taphonomy'></span>

<h3>Description</h3>

<p>Models taphonomy by combining the change in taphonomic conditions with the preservation potential as a function of taphonomic conditions to determine how preservation potential changes. This is then used to systematically remove (thin) the event data using <code>thin</code>/ remove specimens from the <code>pre_paleoTS</code> object using <code>prob_remove</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_taphonomy(x, pres_potential, ctc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_taphonomy_+3A_x">x</code></td>
<td>
<p>event type data, e.g. times/ages of fossil occurrences or their stratigraphic position, or a <code>pre_paleoTS</code> object.</p>
</td></tr>
<tr><td><code id="apply_taphonomy_+3A_pres_potential">pres_potential</code></td>
<td>
<p>function. Takes taphonomic conditions as input and returns the preservation potential (a number between 0 and 1). Must be vectorized, meaning if given a vector, it must return a vector of equal length.</p>
</td></tr>
<tr><td><code id="apply_taphonomy_+3A_ctc">ctc</code></td>
<td>
<p>function, change in taphonomic conditions (ctc) with time or stratigraphic position. . Must be vectorized, meaning if given a vector, it must return a vector of equal length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if given event type data, a numeric vector, location/timing of events (e.g. fossil occurrences) after the taphonomic filter is applied. If given a <code>pre_paleoTS</code> object, returns another <code>pre_paleoTS</code> object with reduced number of specimens.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+apply_niche">apply_niche()</a></code> for modeling niche preferences based on the same principle. Internally, these functions are structured identically.
</p>
</li>
<li> <p><code><a href="#topic+thin">thin()</a></code> and <code><a href="#topic+prob_remove">prob_remove()</a></code> for the underlying mathematical procedures.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# see
#vignette("advanced_functionality")
# for details on usage


</code></pre>

<hr>
<h2 id='bounded_niche'>define niche from boundaries</h2><span id='topic+bounded_niche'></span>

<h3>Description</h3>

<p>Defines a simple niche model where the niche defined is given by a lower limit (<code>g_min</code>) and an upper limit (<code>g_max</code>) of a gradient the taxon can tolerate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounded_niche(g_min, g_max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bounded_niche_+3A_g_min">g_min</code></td>
<td>
<p>lowest value of the gradient the taxon can tolerate</p>
</td></tr>
<tr><td><code id="bounded_niche_+3A_g_max">g_max</code></td>
<td>
<p>highest value of the gradient the taxon can tolerate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function describing the niche for usage with <code>apply_niche</code>. The function returns 1 if the taxon is within its niche (the gradient is between <code>g_min</code> and <code>g_max</code>), and 0 otherwise
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+snd_niche">snd_niche()</a></code> for an alternative niche model
</p>
</li>
<li> <p><code><a href="#topic+apply_niche">apply_niche()</a></code> for the function that uses the function returned
</p>
</li>
<li> <p><code>vignette("advanced_functionality")</code> for details how to create user-defined niche models
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
x = seq(0, 10, by = 0.2)
f = bounded_niche(2,5)
plot(x, f(x), type = "l",
xlab = "Gradient", ylab = "Observation probability",
main = "Observation probability of taxon")

# see also
#vignette("event_data")
# for details how to use this functionality


</code></pre>

<hr>
<h2 id='ornstein_uhlenbeck'>simulate ornstein-uhlenbeck (OU) process</h2><span id='topic+ornstein_uhlenbeck'></span>

<h3>Description</h3>

<p>Simulates an Ornstein-Uhlenbeck process using the Euler-Maruyama method. The process is simulated on a scale of <code>0.25 * min(diff(t))</code> and then interpolated to the values of <code>t</code>. Note that different parametrizations of OU processes are used in the literature. Here we use the parametrization common in mathematics. This translates to the parametrization used in evolutionary biology (specifically, the one in Hansen (1997)) as follows:
</p>

<ul>
<li> <p><code>sigma</code> is identical
</p>
</li>
<li> <p><code>mu</code> used in the <code>StratPal</code> package corresponds to <code>theta</code> sensu Hansen (1997)
</p>
</li>
<li> <p><code>theta</code> as used in the <code>StratPal</code> package corresponds to <code>alpha</code> sensu Hansen (1997)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ornstein_uhlenbeck(t, mu = 0, theta = 1, sigma = 1, y0 = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ornstein_uhlenbeck_+3A_t">t</code></td>
<td>
<p>times at which the process is simulated. Can be heterodistant</p>
</td></tr>
<tr><td><code id="ornstein_uhlenbeck_+3A_mu">mu</code></td>
<td>
<p>number, long term mean</p>
</td></tr>
<tr><td><code id="ornstein_uhlenbeck_+3A_theta">theta</code></td>
<td>
<p>number, mean reversion speed</p>
</td></tr>
<tr><td><code id="ornstein_uhlenbeck_+3A_sigma">sigma</code></td>
<td>
<p>positive number, strength of randomness</p>
</td></tr>
<tr><td><code id="ornstein_uhlenbeck_+3A_y0">y0</code></td>
<td>
<p>number, initial value (value of process at the first entry of t)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: <code>t</code> and <code>y</code>. <code>t</code> is a duplicate of the input <code>t</code>, <code>y</code> are the values of the OU process at these times. Output list is of S3 class <code>timelist</code> (inherits from <code>list</code>) and can thus be plotted directly using <code>plot</code>, see <code>?admtools::plot.timelist</code>
</p>


<h3>References</h3>


<ul>
<li><p> Hansen, Thomas F. 1997. “Stabilizing Selection and the Comparative Analysis of Adaptation.” Evolution 51 (5): 1341–51. <a href="https://doi.org/10.1111/j.1558-5646.1997.tb01457.x">doi:10.1111/j.1558-5646.1997.tb01457.x</a>.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+ornstein_uhlenbeck_sl">ornstein_uhlenbeck_sl()</a></code> for simulation on specimen level - for use in conjunction with <code>paleoTS</code> package
</p>
</li>
<li> <p><code><a href="#topic+random_walk">random_walk()</a></code> and <code><a href="#topic+stasis">stasis()</a></code> to simulate other modes of evolution
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library("admtools") # required for plotting of results
t = seq(0, 3, by = 0.01)
l = ornstein_uhlenbeck(t, y0 = 3) # start away from optimum (mu)
plot(l, type = "l")
l2 = ornstein_uhlenbeck(t, y0 = 0) # start in optimum
lines(l2$t, l2$y, col = "red")

</code></pre>

<hr>
<h2 id='ornstein_uhlenbeck_sl'>simulate ornstein-uhlenbeck (OU) process (specimen level)</h2><span id='topic+ornstein_uhlenbeck_sl'></span>

<h3>Description</h3>

<p>Simulates an Ornstein-Uhlenbeck process on specimen level (_sl). The mean trait value is simulated using the Euler-Maruyama method. The process is simulated on a scale of <code>0.25 * min(diff(t))</code> and then interpolated to the values of <code>t</code>. At each sampling location there are <code>n_per_sample</code> specimens that are normally distributed around the mean trait value with a variance of <code>intrapop_var</code>.
Note that different parametrizations of OU processes are used in the literature. Here we use the parametrization common in mathematics. This translates to the parametrization used in evolutionary biology (specifically, the one in Hansen (1997)) as follows:
</p>

<ul>
<li> <p><code>sigma</code> is identical
</p>
</li>
<li> <p><code>mu</code> used in the <code>StratPal</code> package corresponds to <code>theta</code> sensu Hansen (1997)
</p>
</li>
<li> <p><code>theta</code> as used in the <code>StratPal</code> package corresponds to <code>alpha</code> sensu Hansen (1997)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ornstein_uhlenbeck_sl(
  t,
  mu = 0,
  theta = 1,
  sigma = 1,
  y0 = 0,
  intrapop_var = 1,
  n_per_sample = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ornstein_uhlenbeck_sl_+3A_t">t</code></td>
<td>
<p>times at which the process is simulated. Can be heterodistant</p>
</td></tr>
<tr><td><code id="ornstein_uhlenbeck_sl_+3A_mu">mu</code></td>
<td>
<p>number, long term mean</p>
</td></tr>
<tr><td><code id="ornstein_uhlenbeck_sl_+3A_theta">theta</code></td>
<td>
<p>number, mean reversion speed</p>
</td></tr>
<tr><td><code id="ornstein_uhlenbeck_sl_+3A_sigma">sigma</code></td>
<td>
<p>positive number, strength of randomness</p>
</td></tr>
<tr><td><code id="ornstein_uhlenbeck_sl_+3A_y0">y0</code></td>
<td>
<p>number, initial value (value of process at the first entry of t)</p>
</td></tr>
<tr><td><code id="ornstein_uhlenbeck_sl_+3A_intrapop_var">intrapop_var</code></td>
<td>
<p>intrapopulation variance, determines how much specimens from the same population vary</p>
</td></tr>
<tr><td><code id="ornstein_uhlenbeck_sl_+3A_n_per_sample">n_per_sample</code></td>
<td>
<p>integer, number of specimens sampled per population/sampling locality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of S3 class <code>pre_paleoTS</code>, inherits from <code>timelist</code> and <code>list</code>. The list has two elements: <code>t</code>, containing a vector of times of sampling, and <code>vals</code>, a list of trait values of the same length as <code>t</code>, with element containing trait values of individual specimens.  This object can be transformed using <code>apply_taphonomy</code>, <code>apply_niche</code> or <code>time_to_strat</code>, and then reduced to a <code>paleoTS</code> object using <code>reduce_to_paleoTS</code>. This can then be used to test for different modes of evolution.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+ornstein_uhlenbeck">ornstein_uhlenbeck()</a></code> to model mean trait values,
</p>
</li>
<li> <p><code><a href="#topic+reduce_to_paleoTS">reduce_to_paleoTS()</a></code> to transform outputs into <code>paleoTS</code> format
</p>
</li>
<li> <p><code><a href="#topic+stasis_sl">stasis_sl()</a></code>, <code><a href="#topic+strict_stasis_sl">strict_stasis_sl()</a></code> and <code><a href="#topic+random_walk_sl">random_walk_sl()</a></code> to simulate other modes of evolution
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library("paleoTS")
x = ornstein_uhlenbeck_sl(1:5)
y = reduce_to_paleoTS(x) # turn into paleoTS format
plot(y) # plot using the paleoTS package

# see also
#vignette("paleoTS_functionality")
#for details and advanced usage


</code></pre>

<hr>
<h2 id='p3'>simulate Poisson point process</h2><span id='topic+p3'></span>

<h3>Description</h3>

<p>Simulates events in the interval <code>from</code> to <code>to</code> based on a Poisson point process with rate <code>rate</code>. If the parameter <code>n</code> is used, the number of fossils is conditioned to be <code>n</code>
In the context of paleontology, these events can be interpreted as fossil occurrences or first/last occurrences of species. In this case, the rate is the average number of fossil occurrences (resp first/last occurrences) per unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p3(rate, from, to, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p3_+3A_rate">rate</code></td>
<td>
<p>strictly positive number, rate of events (avg events per unit)</p>
</td></tr>
<tr><td><code id="p3_+3A_from">from</code></td>
<td>
<p>lowest boundary of observed interval</p>
</td></tr>
<tr><td><code id="p3_+3A_to">to</code></td>
<td>
<p>upper boundary of observed interval</p>
</td></tr>
<tr><td><code id="p3_+3A_n">n</code></td>
<td>
<p>integer of NULL (default). Number of events to return. If NULL, the number is random and determined by the rate parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with timing/location of events.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p3_var_rate">p3_var_rate()</a></code> for the variable rate implementation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# for fossil occ.
x = p3(rate = 5, from = 0, to = 1) # 5 fossil occurrences per myr on avg.
hist(x, xlab = "Time (Myr)", ylab = "Fossil Occurrences" )

x = p3(rate = 3, from = 0, to = 4)
hist(x, main = paste0(length(x), " samples")) # no of events is random

x = p3(rate = 3, from = 0, to = 4, n = 10)
hist(x, main = paste0(length(x), " samples")) # no of events is fixed to n

# see also
#vignette("event_data")
# for details on usage and applications to paleontology


</code></pre>

<hr>
<h2 id='p3_var_rate'>simulate variable rate Poisson point process</h2><span id='topic+p3_var_rate'></span>

<h3>Description</h3>

<p>simulates events based on a variable rate Poisson point process. Rates can be either specified by a function passed to <code>x</code>, or by providing two vectors <code>x</code> and <code>y</code>. In this case the rate is specified by <code>approxfun(x, y, rule = 2)</code>, i.e. by linear interpolation between the values of x (abscissa) and y (ordinate). See <code>?approxfun</code> for details.
In the context of paleontology, these events can be interpreted as fossil occurrences or first/last occurrences of species. In this case, the rate is the average number of fossil occurrences (resp first/last occurrences) per unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p3_var_rate(x, y = NULL, from = 0, to = 1, f_max = 1, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p3_var_rate_+3A_x">x</code></td>
<td>
<p>numeric vector or function. If x is a function, it is used to specify the variable rate. If x is a vector, x and y together specify the variable rate using linear interpolation</p>
</td></tr>
<tr><td><code id="p3_var_rate_+3A_y">y</code></td>
<td>
<p>numeric vector or NULL. If not NULL, determines the variable rate. This is done by using linear interpolation between the values of y. Here x specifies the ordinate and y the abscissa</p>
</td></tr>
<tr><td><code id="p3_var_rate_+3A_from">from</code></td>
<td>
<p>lower boundary of the observed interval</p>
</td></tr>
<tr><td><code id="p3_var_rate_+3A_to">to</code></td>
<td>
<p>upper boundary of the observed</p>
</td></tr>
<tr><td><code id="p3_var_rate_+3A_f_max">f_max</code></td>
<td>
<p>maximum value of <code>x</code> in the interval from <code>x_min</code> to <code>x_max</code>. If x attains values larger than <code>f_max</code> a warning is throw, <code>f_max</code> is adjusted, and sampling is started again</p>
</td></tr>
<tr><td><code id="p3_var_rate_+3A_n">n</code></td>
<td>
<p>NULL or an integer. Number of events drawn. If NULL, the number of events is determined by the rate (specified by x and y). If an integer is passed, n events are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, timing/location of events. Depending on the modeling framework, these events can represent location/age of fossils, or first/last occurrences of a group of taxa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p3">p3()</a></code> for the constant rate implementation, <code><a href="#topic+rej_samp">rej_samp()</a></code> for the underlying random number generation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# assuming events are fossil occurrences
# then rate is the avg rate of fossil occ. per unit
#linear decrease in rate from 50 at x = 0 to 0 at x = 1
x = c(0, 1)
y = c(50, 0)
s = p3_var_rate(x, y, f_max = 50)
hist(s, xlab = "Time (myr)", main = "Fossil Occurrences")
# conditioned to return 100 samples
s = p3_var_rate(x, y, f_max = 50, n = 100)
# hand over function
s = p3_var_rate(x = sin, from = 0 , to = 3 * pi, n = 50)
hist(s) # note that negative values of f (sin) are ignored in sampling

# see also
#vignette("event_data")
# for details on usage and applications to paleontology


</code></pre>

<hr>
<h2 id='plot.pre_paleoTS'>plot pre-paleoTS objects</h2><span id='topic+plot.pre_paleoTS'></span>

<h3>Description</h3>

<p>This functions throws an error on purpose, as <code>pre_paleoTS</code> objects can not be plotted directly. To plot them, first use <code>reduce_to_paleoTS</code> and use <code>plot</code> on the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pre_paleoTS'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pre_paleoTS_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="plot.pre_paleoTS_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+reduce_to_paleoTS">reduce_to_paleoTS()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x = stasis_sl(1:4)
# throws error
plot(x)
library("paleoTS")
# correct way to plot pre-paleoTS objects
y = reduce_to_paleoTs(x)
plot(y)
# this plots via the procedures of the paleoTS package (which must be installed and loaded)

## End(Not run)

</code></pre>

<hr>
<h2 id='prob_remove'>probabilistic removal of elements</h2><span id='topic+prob_remove'></span>

<h3>Description</h3>

<p>probabilistic removal of elements from x. For each element, the probability to be preserved is independent and specified by prob
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_remove(x, prob)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_remove_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="prob_remove_+3A_prob">prob</code></td>
<td>
<p>number between 0 and 1, probability to preserve elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same type as x
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+apply_niche">apply_niche()</a></code> and <code><a href="#topic+apply_taphonomy">apply_taphonomy()</a></code> for functions that use this function for transformation of <code>pre_paleoTS</code> objects
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x = prob_remove(1:10, 0.5)
x
x = prob_remove(1:10, 0.5)
x
</code></pre>

<hr>
<h2 id='random_walk'>simulate (un)biased random walk</h2><span id='topic+random_walk'></span>

<h3>Description</h3>

<p>Simulates a (continuous time) random walk as a Brownian drift. For <code>mu = 0</code> the random walk is unbiased, otherwise it is biased.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_walk(t, sigma = 1, mu = 0, y0 = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_walk_+3A_t">t</code></td>
<td>
<p>numeric vector with strictly increasing elements, can be heterodistant. Times at which the random walk is evaluated</p>
</td></tr>
<tr><td><code id="random_walk_+3A_sigma">sigma</code></td>
<td>
<p>positive number, variance parameter</p>
</td></tr>
<tr><td><code id="random_walk_+3A_mu">mu</code></td>
<td>
<p>number, directionality parameter</p>
</td></tr>
<tr><td><code id="random_walk_+3A_y0">y0</code></td>
<td>
<p>number, starting value (value of the random walk at the first entry of <code>t</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>t</code> and <code>y</code>. <code>t</code> is a duplicate of the input parameter and is the times at which the random walk is evaluated. <code>y</code> are the values of the random walk at said times. Output list is of S3 class <code>timelist</code> (inherits from <code>list</code>) and can thus be plotted directly using <code>plot</code>, see <code>?admtools::plot.timelist</code>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+stasis">stasis()</a></code> and <code><a href="#topic+ornstein_uhlenbeck">ornstein_uhlenbeck()</a></code> to simulate other modes of evolution
</p>
</li>
<li> <p><code><a href="#topic+random_walk_sl">random_walk_sl()</a></code> to simulate random walk on specimen level - for usage in conjunction with the <code>paleoTS</code> package
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library("admtools") # required for plotting of results
t = seq(0, 1, by = 0.01)
l = random_walk(t, sigma = 3) # high variability, no direction
plot(l, type = "l")
l2 = random_walk(t, mu = 1) # low variabliity, increasing trend
lines(l2$t, l2$y, col = "red")


</code></pre>

<hr>
<h2 id='random_walk_sl'>simulate (un)biased random walk (specimen level)</h2><span id='topic+random_walk_sl'></span>

<h3>Description</h3>

<p>Simulates a (continuous time) random walk as a Brownian drift on specimen level. For <code>mu = 0</code> the random walk is unbiased, otherwise it is biased.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_walk_sl(
  t,
  sigma = 1,
  mu = 0,
  y0 = 0,
  intrapop_var = 1,
  n_per_sample = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_walk_sl_+3A_t">t</code></td>
<td>
<p>numeric vector with strictly increasing elements, can be heterodistant. Times at which the random walk is evaluated</p>
</td></tr>
<tr><td><code id="random_walk_sl_+3A_sigma">sigma</code></td>
<td>
<p>positive number, variance parameter</p>
</td></tr>
<tr><td><code id="random_walk_sl_+3A_mu">mu</code></td>
<td>
<p>number, directionality parameter</p>
</td></tr>
<tr><td><code id="random_walk_sl_+3A_y0">y0</code></td>
<td>
<p>number, starting value (value of the random walk at the first entry of <code>t</code>)</p>
</td></tr>
<tr><td><code id="random_walk_sl_+3A_intrapop_var">intrapop_var</code></td>
<td>
<p>intrapopulation variance, determines how much specimens from the same population vary</p>
</td></tr>
<tr><td><code id="random_walk_sl_+3A_n_per_sample">n_per_sample</code></td>
<td>
<p>integer, number of specimens sampled per population/sampling locality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of S3 class <code>pre_paleoTS</code>, inherits from <code>timelist</code> and <code>list</code>. The list has two elements: <code>t</code>, containing a vector of times of sampling, and <code>vals</code>, a list of trait values of the same length as <code>t</code>, with element containing trait values of individual specimens.  This object can be transformed using <code>apply_taphonomy</code>, <code>apply_niche</code> or <code>time_to_strat</code>, and then reduced to a <code>paleoTS</code> object using <code>reduce_to_paleoTS</code>. This can then be used to test for different modes of evolution.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+random_walk">random_walk()</a></code> for the equivalent function to simulate mean trait values
</p>
</li>
<li> <p><code><a href="#topic+reduce_to_paleoTS">reduce_to_paleoTS()</a></code> to transform outputs into <code>paleoTS</code> format.
</p>
</li>
<li> <p><code><a href="#topic+stasis_sl">stasis_sl()</a></code>, <code><a href="#topic+strict_stasis_sl">strict_stasis_sl()</a></code> and <code><a href="#topic+ornstein_uhlenbeck_sl">ornstein_uhlenbeck_sl()</a></code> to simulate other modes of evolution
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library("paleoTS")
x = random_walk_sl(1:5)
y = reduce_to_paleoTS(x) # turn into paleoTS format
plot(y) # plot using the paleoTS package
# see also
#vignette("paleoTS_functionality")
#for details and advanced usage



</code></pre>

<hr>
<h2 id='reduce_to_paleoTS'>reduce pre-paleoTS format to paleoTS</h2><span id='topic+reduce_to_paleoTS'></span>

<h3>Description</h3>

<p>paleoTS is a format for paleontological time series. It is a summary format where interpopulation variance is provided as a parameter. As a result, taphonomic and ecological effects that act on individual specimens can not be modeled for paleoTS objects. To resolve this, the pre_paleoTS format tracks each specimen individually. This function reduces the pre-paleoTS format into standard paleoTS object, which can be used by the paleoTS package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_to_paleoTS(x, min_n = 1, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce_to_paleoTS_+3A_x">x</code></td>
<td>
<p>a <code>pre_paleoTS</code> object</p>
</td></tr>
<tr><td><code id="reduce_to_paleoTS_+3A_min_n">min_n</code></td>
<td>
<p>minimum number of specimens. If the number of specimens at a sampling location falls below this number, the sampling location will be removed</p>
</td></tr>
<tr><td><code id="reduce_to_paleoTS_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If sampling locations are NA (e.g., because of erosion), should the sample be removed?</p>
</td></tr>
<tr><td><code id="reduce_to_paleoTS_+3A_...">...</code></td>
<td>
<p>other options. currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>paleoTS</code> object
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+stasis_sl">stasis_sl()</a></code>, <a href="#topic+strict_stasis_sl">strict_stasis_sl</a>, <a href="#topic+random_walk_sl">random_walk_sl</a>, and <code><a href="#topic+ornstein_uhlenbeck_sl">ornstein_uhlenbeck_sl()</a></code> to simulate trait evolution on specimen level (sl), returning an object of type <code>pre_paleoTS</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x = stasis_sl(t = 0:5)     # create pre_paleoTS object representing stasis on specimen level
y = reduce_to_paleoTS(x)   # reduce to standard paleoTS format
plot(y)
# now analyses using the paleoTS package can be applied to y

</code></pre>

<hr>
<h2 id='rej_samp'>random numbers from rejection sampling</h2><span id='topic+rej_samp'></span>

<h3>Description</h3>

<p>Rejection sampling from the (pseudo) pdf <code>f</code> in the interval between <code>x_min</code> and <code>x_max</code>. Returns <code>n</code> samples. Note that values of <code>f</code> below 0 are capped to zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rej_samp(f, x_min, x_max, n = 1L, f_max = 1, max_try = 10^4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rej_samp_+3A_f">f</code></td>
<td>
<p>function. (pseudo) pdf from which the sample is drawn</p>
</td></tr>
<tr><td><code id="rej_samp_+3A_x_min">x_min</code></td>
<td>
<p>number, lower limit of the examined interval</p>
</td></tr>
<tr><td><code id="rej_samp_+3A_x_max">x_max</code></td>
<td>
<p>number, upper limit of the examined interval</p>
</td></tr>
<tr><td><code id="rej_samp_+3A_n">n</code></td>
<td>
<p>integer. number of samples drawn</p>
</td></tr>
<tr><td><code id="rej_samp_+3A_f_max">f_max</code></td>
<td>
<p>number, maximum value of <code>f</code> in the interval from <code>x_min</code> to <code>x_max</code>. If f attains values larger than <code>f_max</code> a warning is throw, <code>f_max</code> is adjusted, and sampling is started again</p>
</td></tr>
<tr><td><code id="rej_samp_+3A_max_try">max_try</code></td>
<td>
<p>maximum number of tries in the rejection sampling algorithm. If more tries are needed, an error is thrown. If this is the case, inspect of your function <code>f</code> is well-defined and positive, and if <code>f_max</code> provides a reasonable upper bound on it. Adjust <code>max_try</code> if you are certain that both is the case, e.g. if <code>f</code> is highly irregular.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, sample of size <code>n</code> drawn from the (pseudo) pdf specified by <code>f</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p3_var_rate">p3_var_rate()</a></code> for the derived variable rate Poisson point process implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f = sin
x = rej_samp(f, 0, 3*pi, n = 100)
hist(x) # note that no samples are drawn where sin is negative

</code></pre>

<hr>
<h2 id='scenarioA'>example data, scenario A from Hohmann et al. (2024)</h2><span id='topic+scenarioA'></span>

<h3>Description</h3>

<p>Scenario A as described in Hohmann et al. (2024), published in Hohmann et al. (2023). Contains data from a carbonate platform simulated using CarboCAT Lite (Burgess 2013, 2023)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scenarioA
</code></pre>


<h3>Format</h3>

<p>A list with 6 elements:
</p>

<ul>
<li> <p><code>t_myr</code> : numeric vector. timesteps of the simulation in Myr
</p>
</li>
<li> <p><code>sl_m</code> : numeric vector. eustatic sea level in m
</p>
</li>
<li> <p><code>dist_from_shore</code> : character vector. Distance from shore in km of locations at which the observations were made. Available distances are &quot;2km&quot;, &quot;4km&quot;, &quot;6km&quot;, &quot;8km&quot;, &quot;10km&quot;, &quot;12km&quot;.
</p>
</li>
<li> <p><code>h_m</code> : matrix of size length(t_myr) x length(dist_from_shore). Accumulated sediment height in m at examined locations
</p>
</li>
<li> <p><code>wd_m</code>: matrix of size length(t_myr) x length(dist_from_shore). Water depth in m at examined locations
</p>
</li>
<li> <p><code>strat_col</code>: list with length(dist_from shore) elements. Represents a stratigraphic column. Each element is a list with two elements:
</p>

<ul>
<li> <p><code>bed_thickness_m</code>: numeric vector. Bed thickness in m
</p>
</li>
<li> <p><code>facies_code</code> : integer vector. facies code of the bed
</p>
</li></ul>

</li></ul>



<h3>References</h3>


<ul>
<li><p> Burgess, Peter. 2013. &quot;CarboCAT: A cellular automata model of heterogeneous carbonate strata.&quot; Computers &amp; Geosciences. <a href="https://doi.org/10.1016/j.cageo.2011.08.026">doi:10.1016/j.cageo.2011.08.026</a>.
</p>
</li>
<li><p> Burgess, Peter. 2023. &quot;CarboCATLite v1.0.1.&quot; Zenodo. <a href="https://doi.org/10.5281/zenodo.8402578">doi:10.5281/zenodo.8402578</a>
</p>
</li>
<li><p> Hohmann, Niklas; Koelewijn, Joël R.; Burgess, Peter; Jarochowska, Emilia. 2024. &quot;Identification of the mode of evolution in incomplete carbonate successions.&quot; BMC Ecology and Evolution 24, 113. <a href="https://doi.org/10.1186/s12862-024-02287-2">doi:10.1186/s12862-024-02287-2</a>.
</p>
</li>
<li><p> Hohmann, Niklas, Koelewijn, Joël R.; Burgess, Peter; Jarochowska, Emilia. 2023. “Identification of the Mode of Evolution in Incomplete Carbonate Successions - Supporting Data.” Open Science Framework. <a href="https://doi.org/10.17605/OSF.IO/ZBPWA">doi:10.17605/OSF.IO/ZBPWA</a>, published under the <a href="https://creativecommons.org/licenses/by/4.0/">CC-BY 4.0</a> license.
</p>
</li></ul>


<hr>
<h2 id='snd_niche'>simple niche model</h2><span id='topic+snd_niche'></span>

<h3>Description</h3>

<p>Defines niche model based in the &quot;Probability of collection&quot; model by Holland and Patzkowsky (1999).
The collection probability follows the shape of a bell curve across a gradient, where <code>opt</code> determines the peak (mean) of the bell curve, and <code>tol</code> the standard deviation. &quot;snd&quot; stands for &quot;scaled normal distribution&quot;, as the collection probability has the shape of the probability density of the normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snd_niche(opt, tol, prob_modifier = 1, cutoff_val = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snd_niche_+3A_opt">opt</code></td>
<td>
<p>optimum value, gradient value where collection probability is highest</p>
</td></tr>
<tr><td><code id="snd_niche_+3A_tol">tol</code></td>
<td>
<p>tolerance to changes in gradient. For large values, collection probability drops off slower away from <code>opt</code></p>
</td></tr>
<tr><td><code id="snd_niche_+3A_prob_modifier">prob_modifier</code></td>
<td>
<p>collection probability modifier, collection probability at <code>opt</code>.</p>
</td></tr>
<tr><td><code id="snd_niche_+3A_cutoff_val">cutoff_val</code></td>
<td>
<p>NULL or a number. If a number, all collection probabilities at gradient values below <code>cutoff_value</code> are set to 0. This can for example be used to model exclusively marine species when the gradient is water depth (see examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function for usage with <code>apply_niche</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Holland, Steven M. and Patzkowsky, Mark E. 1999. &quot;Models for simulating the fossil record.&quot; Geology. https://doi.org/10.1130/0091-7613(1999)027%3C0491:MFSTFR%3E2.3.CO;2
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+apply_niche">apply_niche()</a></code> for usage of the returned function
</p>
</li>
<li> <p><code><a href="#topic+bounded_niche">bounded_niche()</a></code> for another niche model
</p>
</li>
<li> <p><code>vignette("advenced_functionality")</code> for details on how to create user defined niche models
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# using water depth as niche
wd = seq(-3, 40, by = 0.5)
f = snd_niche(opt = 10, tol = 5)

plot(wd, f(wd), xlab = "Water depth", ylab = "Prob. of collection")
# set cutoff value at to 0 to model non-terrestrial species.
f = snd_niche(opt = 10, tol = 5, cutoff_val = 0)
plot(wd, f(wd), xlab = "Water depth", ylab = "Prob. of collection")

# see also
#vignette("event_data")
#for examples how to use it for niche modeling



</code></pre>

<hr>
<h2 id='stasis'>simulate phenotypic stasis</h2><span id='topic+stasis'></span>

<h3>Description</h3>

<p>Simulates stasis of mean trait values as independent, normally distributed random variables with mean <code>mean</code> and standard deviation <code>sd</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stasis(t, mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stasis_+3A_t">t</code></td>
<td>
<p>times at which the traits are determined</p>
</td></tr>
<tr><td><code id="stasis_+3A_mean">mean</code></td>
<td>
<p>number, mean trait value</p>
</td></tr>
<tr><td><code id="stasis_+3A_sd">sd</code></td>
<td>
<p>strictly positive number, standard deviation of traits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: <code>t</code> and <code>y</code>. <code>t</code> is a duplicate of the input <code>t</code>, <code>y</code> are the corresponding trait values. Output list is of S3 class <code>timelist</code> (inherits from <code>list</code>) and can thus be plotted directly using <code>plot</code>, see <code>?admtools::plot.timelist</code>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+random_walk">random_walk()</a></code> and <code><a href="#topic+ornstein_uhlenbeck">ornstein_uhlenbeck()</a></code> to simulate other modes of evolution
</p>
</li>
<li> <p><code><a href="#topic+stasis_sl">stasis_sl()</a></code> to simulate stasis on specimen level - for usage in conjunction with the <code>paleoTS</code> package.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
 library("admtools") # required for plotting of results
 t = seq(0, 1, by = 0.01)
 l = stasis(t)
 plot(l, type = "l") # plot lineage
 l2 = stasis(t, mean = 0.5, sd = 0.3) # simulate second lineage
 lines(l2$t, l2$y, col = "red") # plot second lineage


</code></pre>

<hr>
<h2 id='stasis_sl'>simulate phenotypic stasis (specimen level)</h2><span id='topic+stasis_sl'></span>

<h3>Description</h3>

<p>simulates stasis as independent, normally distributed random variables with mean <code>mean</code> and standard deviation <code>sd</code>, draws <code>n_per_sample</code> samples from each sampling location (population) that have specified variance <code>intrapop_var</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stasis_sl(t, mean = 0, sd = 1, intrapop_var = 1, n_per_sample = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stasis_sl_+3A_t">t</code></td>
<td>
<p>times at which the traits are determined</p>
</td></tr>
<tr><td><code id="stasis_sl_+3A_mean">mean</code></td>
<td>
<p>mean trait value</p>
</td></tr>
<tr><td><code id="stasis_sl_+3A_sd">sd</code></td>
<td>
<p>strictly positive number, standard deviation of traits around the mean</p>
</td></tr>
<tr><td><code id="stasis_sl_+3A_intrapop_var">intrapop_var</code></td>
<td>
<p>intrapopulation variance, determines how much specimens from the same population vary</p>
</td></tr>
<tr><td><code id="stasis_sl_+3A_n_per_sample">n_per_sample</code></td>
<td>
<p>integer, number of specimens sampled per population/sampling locality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of S3 class <code>pre_paleoTS</code>, inherits from <code>timelist</code> and <code>list</code>. The list has two elements: <code>t</code>, containing a vector of times of sampling, and <code>vals</code>, a list of trait values of the same length as <code>t</code>, with element containing trait values of individual specimens.  This object can be transformed using <code>apply_taphonomy</code>, <code>apply_niche</code> or <code>time_to_strat</code>, and then reduced to a <code>paleoTS</code> object using <code>reduce_to_paleoTS</code>. This can then be used to test for different modes of evolution.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+stasis">stasis()</a></code> for the version that simulates stasis of mean trait values
</p>
</li>
<li> <p><code><a href="#topic+strict_stasis_sl">strict_stasis_sl()</a></code> for more narrow definition of stasis
</p>
</li>
<li> <p><code><a href="#topic+reduce_to_paleoTS">reduce_to_paleoTS()</a></code> to transform into the outputs into <code>paleoTS</code> format (e.g., for plotting or further analysis)
</p>
</li>
<li> <p><code><a href="#topic+random_walk_sl">random_walk_sl()</a></code> and <code><a href="#topic+ornstein_uhlenbeck_sl">ornstein_uhlenbeck_sl()</a></code> for other modes of evolution
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library("paleoTS")
x = stasis_sl(1:5, mean = 2, sd = 2)
y = reduce_to_paleoTS(x) # turn into paleoTS format
plot(y) # plot using paleoTS package
# see also
#vignette("paleoTS_functionality")
#for details and advanced usage

</code></pre>

<hr>
<h2 id='strict_stasis_sl'>simulate strict phenotypic stasis (specimen level)</h2><span id='topic+strict_stasis_sl'></span>

<h3>Description</h3>

<p>simulates strict stasis on the population level (Hunt et al. 2015). This means each population has the same mean trait value, and all deviations are due to the fact that specimens traits differ from this value due to randomness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strict_stasis_sl(t, mean = 0, intrapop_var = 1, n_per_sample = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strict_stasis_sl_+3A_t">t</code></td>
<td>
<p>times at which the traits are determined</p>
</td></tr>
<tr><td><code id="strict_stasis_sl_+3A_mean">mean</code></td>
<td>
<p>mean trait value</p>
</td></tr>
<tr><td><code id="strict_stasis_sl_+3A_intrapop_var">intrapop_var</code></td>
<td>
<p>intrapopulation variance, determines how much specimens from the same population vary</p>
</td></tr>
<tr><td><code id="strict_stasis_sl_+3A_n_per_sample">n_per_sample</code></td>
<td>
<p>integer, number of specimens sampled per population/sampling locality/time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of S3 class <code>pre_paleoTS</code>, inherits from <code>timelist</code> and <code>list</code>. The list has two elements: <code>t</code>, containing a vector of times of sampling, and <code>vals</code>, a list of trait values of the same length as <code>t</code>, with element containing trait values of individual specimens.  This object can be transformed using <code>apply_taphonomy</code>, <code>apply_niche</code> or <code>time_to_strat</code>, and then reduced to a <code>paleoTS</code> object using <code>reduce_to_paleoTS</code>. This can then be used to test for different modes of evolution.
</p>


<h3>References</h3>


<ul>
<li><p> Hunt, Gene, Melanie J. Hopkins, and Scott Lidgard. 2015. “Simple versus Complex Models of Trait Evolution and Stasis as a Response to Environmental Change.” Proceedings of the National Academy of Sciences of the United States of America 112 (16): 4885–90. https://doi.org/10.1073/pnas.1403662111.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+stasis_sl">stasis_sl()</a></code> for the (non-strict) equivalent
</p>
</li>
<li> <p><code><a href="#topic+reduce_to_paleoTS">reduce_to_paleoTS()</a></code> to transform outputs into <code>paleoTS</code> format
</p>
</li>
<li> <p><code><a href="#topic+random_walk_sl">random_walk_sl()</a></code> and <code><a href="#topic+ornstein_uhlenbeck_sl">ornstein_uhlenbeck_sl()</a></code> for other modes of evolution
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library("paleoTS")
x = strict_stasis_sl(1:5, mean = 2, intrapop_var = 2) # simulate strict stasis
y = reduce_to_paleoTS(x)   # transform into paloeTS format
plot(y) # plot using paleoTS package

# see also
#vignette("paleoTS_functionality")
#for details and advanced usage




</code></pre>

<hr>
<h2 id='thin'>thin a series of events (e.g. fossil occurrences)</h2><span id='topic+thin'></span>

<h3>Description</h3>

<p>Thins a vector of events using the function thin, meaning the probability that the ith event in x is preserved is given by <em>thin(x(i))</em>. Values of
<code>thin</code> below 0 and above 1 are ignored.
Is used to model niche preferences in <code>apply_niche</code> and taphonomic effects in <code>apply_taphonomy</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin(x, thin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thin_+3A_x">x</code></td>
<td>
<p>numeric vectors with events (e.g. locations, height, times)</p>
</td></tr>
<tr><td><code id="thin_+3A_thin">thin</code></td>
<td>
<p>a function used for thinning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, events after thinning. Depending on the modeling framework, these events can represent fossil ages/locations or first/last occurrences, and the thinning taphonomic or ecological effects.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+apply_niche">apply_niche()</a></code> and <code><a href="#topic+apply_taphonomy">apply_taphonomy()</a></code> for use cases with biological meaning. Use <code>thin</code> to model effects of taphonomy and ecology for event data.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
x = p3(rate = 100, from = 0, to = 3 * pi) # simulate Poisson point process
y = thin(x, sin)
hist(y) # not how negative values of sin are treated as 0
yy = thin(x, function(x) 5 * sin(x))
hist(yy) # note how values of 5 * sin above 1 are not affecting the thinning


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
