<!DOCTYPE html><html><head><title>Help for package shotGroups</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shotGroups}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#shotGroups-package'><p>Analyze shot group data</p></a></li>
<li><a href='#analyzeGroup'><p>Analysis for a single group of bullet holes</p></a></li>
<li><a href='#combineData'><p>Combine list of data frames into one</p></a></li>
<li><a href='#compareGroups'><p>Compare bullet hole groups</p></a></li>
<li><a href='#DF300BLK'><p>Combined bullet hole data</p></a></li>
<li><a href='#DF300BLKhl'><p>Combined bullet hole data</p></a></li>
<li><a href='#DFcciHV'><p>Combined bullet hole data</p></a></li>
<li><a href='#DFcm'><p>Combined bullet hole data</p></a></li>
<li><a href='#DFdistr'><p>Lookup table for distribution of range statistics and Rayleigh sigma</p></a></li>
<li><a href='#DFinch'><p>Combined bullet hole data</p></a></li>
<li><a href='#DFlandy01'><p>Combined bullet hole data</p></a></li>
<li><a href='#DFlandy02'><p>Combined bullet hole data</p></a></li>
<li><a href='#DFlandy03'><p>Combined bullet hole data</p></a></li>
<li><a href='#DFlandy04'><p>Combined bullet hole data</p></a></li>
<li><a href='#DFlistCm'><p>List containing several data frames with bullet hole data</p></a></li>
<li><a href='#DFsavage'><p>Combined bullet hole data</p></a></li>
<li><a href='#DFscar17'><p>Combined bullet hole data</p></a></li>
<li><a href='#DFtalon'><p>Combined bullet hole data</p></a></li>
<li><a href='#drawBox'><p>Draw an axis-aligned box</p></a></li>
<li><a href='#drawBox2'><p>Draw an oriented box</p></a></li>
<li><a href='#drawCircle'><p>Draw a circle</p></a></li>
<li><a href='#drawEllipse'><p>Draw an ellipse</p></a></li>
<li><a href='#drawGroup'><p>Draw a group of bullet holes with additional measures</p></a></li>
<li><a href='#drawTarget'><p>Draw a target pattern</p></a></li>
<li><a href='#efficiency'><p>Estimate number of required groups for given CI level and width</p></a></li>
<li><a href='#fromMOA'><p>Conversion from angular diameter to absolute size</p></a></li>
<li><a href='#getBoundingBox'><p>Bounding box for a set of 2D-points</p></a></li>
<li><a href='#getCEP'><p>Circular Error Probable (CEP) and Spherical Error Probable (SEP)</p></a></li>
<li><a href='#getConfEll'><p>Confidence ellipse</p></a></li>
<li><a href='#getDistance'><p>Get distance based on absolute and angular size</p></a></li>
<li><a href='#getDistToCtr'><p>Distances to center for a set of points</p></a></li>
<li><a href='#getHitProb'><p>Hit probability within given region</p></a></li>
<li><a href='#getHoytParam'><p>Determine parameters q and omega of the Hoyt distribution</p></a></li>
<li><a href='#getKuchnost'><p>Kuchnost precision estimate</p></a></li>
<li><a href='#getMaxPairDist'><p>Maximum pairwise distance for a set of points</p></a></li>
<li><a href='#getMinBBox'><p>Minimum-area bounding box for a set of 2D-points</p></a></li>
<li><a href='#getMinCircle'><p>Minimum enclosing circle for a set of 2D-points</p></a></li>
<li><a href='#getMinEllipse'><p>Minimum enclosing ellipse for a set of 2D-points</p></a></li>
<li><a href='#getMOA'><p>Conversion of absolute size to angular diameter</p></a></li>
<li><a href='#getRangeStat'><p>Range statistics</p></a></li>
<li><a href='#getRayParam'><p>Estimate Rayleigh parameters sigma, mean and standard deviation</p></a></li>
<li><a href='#getRiceParam'><p>Estimate Rice parameters nu and sigma</p></a></li>
<li><a href='#getXYmat'><p>Extract (x,y)-coordinates (relative to point of aim) from a data frame</p></a></li>
<li><a href='#groupLocation'><p>Accuracy: Location measures for a single group of bullet holes</p></a></li>
<li><a href='#groupShape'><p>Shape analysis for a single group of bullet holes</p></a></li>
<li><a href='#groupSpread'><p>Precision: Spread measures of a single group of bullet holes</p></a></li>
<li><a href='#Hoyt'><p>The Hoyt Distribution</p></a></li>
<li><a href='#Maxwell'><p>The Maxwell-Boltzmann Distribution</p></a></li>
<li><a href='#mvnEll'><p>Multivariate normal offset ellipse probabilities</p></a></li>
<li><a href='#range2CEP'><p>Estimate circular error probable (CEP) based on range statistics</p></a></li>
<li><a href='#range2sigma'><p>Estimate Rayleigh sigma based on range statistics</p></a></li>
<li><a href='#rangeStat'><p>Distribution of range statistics</p></a></li>
<li><a href='#Rayleigh'><p>The Rayleigh Distribution</p></a></li>
<li><a href='#readDataMisc'><p>Read data from text files</p></a></li>
<li><a href='#readDataOT1'><p>Read data files exported by OnTarget PC v1.1*</p></a></li>
<li><a href='#readDataOT2'><p>Read data files exported by OnTarget PC v2.* or OnTarget TDS v3.*</p></a></li>
<li><a href='#readDataShotMarker'><p>Read data files exported by the ShotMarker e-target system</p></a></li>
<li><a href='#readDataSMT'><p>Read data files exported by the Silver Mountain e-target system</p></a></li>
<li><a href='#Rice'><p>The Rice Distribution</p></a></li>
<li><a href='#runGUI'><p>Open web-based GUI in browser</p></a></li>
<li><a href='#simRingCount'><p>Calculate simulated ring count for a given group and target</p></a></li>
<li><a href='#targets'><p>List containing definitions of several circular target types from the shooting federations ISSF, NRA, DSB, BDS, BDMP, DSU</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyze Shot Group Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Wollschlaeger</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Wollschlaeger &lt;dwoll@kuci.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, coin, CompQuadForm (&ge; 1.4.2), graphics, grDevices,
KernSmooth, robustbase, stats, tools, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, energy, mvoutlier, shiny, jsonlite, interp,
MBA, bs4Dash</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyzes shooting data with respect to group shape,
        precision, and accuracy. This includes graphical methods,
        descriptive statistics, and inference tests using standard,
        but also non-parametric and robust statistical methods.
        Implements distributions for radial error in bivariate normal
        variables. Works with files exported by 'OnTarget PC/TDS',
        'Silver Mountain' e-target, 'ShotMarker' e-target, or 'Taran',
        as well as with custom data files in text format.
        Supports inference from range statistics such as extreme
        spread. Includes a set of web-based graphical user interfaces.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-17 17:49:59 UTC; Daniel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-17 19:06:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='shotGroups-package'>Analyze shot group data</h2><span id='topic+shotGroups-package'></span><span id='topic+shotGroups'></span>

<h3>Description</h3>

<p>The <code>shotGroups</code> package provides functions to read in, plot, statistically describe, analyze, and compare shooting data with respect to group shape, precision, and accuracy. This includes graphical methods, descriptive statistics, and inference tests using standard, but also non-parametric and robust statistical methods. Works with files exported by 'OnTarget PC/TDS', 'Silver Mountain' e-target, 'ShotMarker' e-target, or 'Taran', as well as with custom data files in text format. Supports inference from range statistics such as extreme spread. Includes web-based graphical user interface.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> shotGroups</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.8.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-09-17</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> boot, coin, CompQuadForm (&gt;= 1.4.2), graphics, grDevices, KernSmooth, robustbase, stats, tools, utils</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr, energy, mvoutlier, shiny, jsonlite, interp, MBA, bs4Dash</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Use <code>help(package='shotGroups')</code> for a list of all functions and links to the detailed help pages with information on options, usage and output. For further explanantions and an example walkthrough, see <code>vignette('shotGroups')</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Wollschlaeger
</p>
<p>Maintainer: Daniel Wollschlaeger <a href="mailto:dwoll@kuci.org">dwoll@kuci.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>groupSpread(DFcciHV, dstTarget=100, conversion='yd2in', bootCI='none')
</code></pre>

<hr>
<h2 id='analyzeGroup'>Analysis for a single group of bullet holes</h2><span id='topic+analyzeGroup'></span>

<h3>Description</h3>

<p>Performs a comprehensive numerical and graphical analysis of a single group of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyzeGroup(DF, xyTopLeft = TRUE, center = FALSE,
             dstTarget, conversion, bandW = 0.5,
             CEPtype = 'CorrNormal', bootCI = 'none')</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyzeGroup_+3A_df">DF</code></td>
<td>
<p>a data frame containing (at least) either the variables <code>point.x</code>, <code>point.y</code> or <code>x</code>, <code>y</code> defining the bullet holes. Variables <code>distance</code> (distance to target), <code>aim.x</code>, <code>aim.y</code> (point of aim) are useful - if they are missing, a warning is given and a default assumed.</p>
</td></tr>
<tr><td><code id="analyzeGroup_+3A_xytopleft">xyTopLeft</code></td>
<td>
<p>logical: is the origin of the absolute coordinate system in the top-left corner? See details.</p>
</td></tr>
<tr><td><code id="analyzeGroup_+3A_center">center</code></td>
<td>
<p>logical: center groups to mean (0,0) first? If variable <code>series</code> does not exist, all shots are treated as belonging to the same group.</p>
</td></tr>
<tr><td><code id="analyzeGroup_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in <code>DF</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="analyzeGroup_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Acts as override if variables <code>dist.unit</code> and <code>point.unit</code> are already included in <code>DF</code>. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="analyzeGroup_+3A_bandw">bandW</code></td>
<td>
<p>for argument <code>bandwith</code> of <code><a href="graphics.html#topic+smoothScatter">smoothScatter</a></code>.</p>
</td></tr>
<tr><td><code id="analyzeGroup_+3A_ceptype">CEPtype</code></td>
<td>
<p>string vector indicating which CEP estimate to report in <code><a href="#topic+getCEP">getCEP</a></code>.</p>
</td></tr>
<tr><td><code id="analyzeGroup_+3A_bootci">bootCI</code></td>
<td>
<p>a character vector to select which bootstrap confidence interval type to report. Possible types are <code>'none'</code> (no bootstrap CI), <code>'norm'</code>, <code>'basic'</code>, <code>'perc'</code>, <code>'bca'</code>. See <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, OnTarget PC/TDS' 'Export Point Data' places the origin of the absolute coordinate system in the top-left corner. In OnTarget TDS, this setting can be changed by checking the box 'Tools -&gt; Options -&gt; Options tab -&gt; Data Export -&gt; Invert Y-Axis on Export'. In that case, use <code>xyTopLeft=FALSE</code>. If groups appear to be upside-down, <code>xyTopLeft</code> is the setting to change.
</p>
<p>Robust estimates for the group center and the covariance matrix of (x,y)-coordinates are from <code><a href="robustbase.html#topic+covMcd">covMcd</a></code> using the MCD algorithm. <br />
This function is a wrapper for <code><a href="#topic+groupShape">groupShape</a></code>, <code><a href="#topic+groupLocation">groupLocation</a></code>, and <code><a href="#topic+groupSpread">groupSpread</a></code>. <br />
If the data is missing information about the point of aim, (0,0) is assumed. If distance to target is missing, 100 is assumed. <br />
The number of replicates for the reported bootstrap confidence intervals is at least 1499. If the BCa interval is reported, it is at least the number of points.
</p>
<p>In addition to the numerical results listed below, this function produces the following diagrams:
</p>

<ul>
<li><p> a combined plot for multivariate outlier identification as produced by <code><a href="mvoutlier.html#topic+aq.plot">aq.plot</a></code>
</p>
</li>
<li><p> a scatterplot of the (x,y)-coordinates together with group center, circle with average distance to center, 50%-confidence ellipse - the latter also based on a robust estimate for the covariance matrix
</p>
</li>
<li><p> a scatterplot of the (x,y)-coordinates together with the minimum bounding box, minimum enclosing circle, and maximum group spread
</p>
</li>
<li><p> a chi-square Q-Q-plot for eyeballing multivariate normality as produced by <code><a href="mvoutlier.html#topic+chisq.plot">chisq.plot</a></code>, including a reference line with intercept 0 and slope 1
</p>
</li>
<li><p> a heatmap of a 2D-kernel density estimate for the (x,y)-coordinates as produced by <code><a href="graphics.html#topic+smoothScatter">smoothScatter</a></code> together with group center and error ellipse based on a robust estimate for the covariance matrix
</p>
</li>
<li><p> a Q-Q-plot of x-coordinates for eyeballing normality
</p>
</li>
<li><p> a Q-Q-plot of y-coordinates for eyeballing normality
</p>
</li>
<li><p> a histogram of x-coordinates including a fitted normal distribution as well as a non-parametric kernel density estimate
</p>
</li>
<li><p> a histogram of y-coordinates including a fitted normal distribution as well as a non-parametric kernel density estimate
</p>
</li>
<li><p> a histogram of distances to group center including a fitted Rayleigh distribution as well as a non-parametric kernel density estimate
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the results from the numerical analyses and statistical tests.
</p>
<table>
<tr><td><code>corXY</code></td>
<td>
<p>correlation matrix of (x,y)-coordinates.</p>
</td></tr>
<tr><td><code>corXYrob</code></td>
<td>
<p>robust estimate of correlation matrix of (x,y)-coordinates.</p>
</td></tr>
<tr><td><code>Outliers</code></td>
<td>
<p>a vector of row indices for observations identified as outliers.</p>
</td></tr>
<tr><td><code>ShapiroX</code></td>
<td>
<p>Shapiro-Wilk-Test result for normality of x-coordinates.</p>
</td></tr>
<tr><td><code>ShapiroY</code></td>
<td>
<p>Shapiro-Wilk-Test result for normality of y-coordinates.</p>
</td></tr>
<tr><td><code>multNorm</code></td>
<td>
<p>E-statistic-Test result for multivariate normality of (x,y)-coordinates.</p>
</td></tr>
<tr><td><code>sdXY</code></td>
<td>
<p>standard deviations of x- and y-coordinates (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>sdXci</code></td>
<td>
<p>parametric and bootstrap confidence intervals for the standard deviation of x-coordinates (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>sdYci</code></td>
<td>
<p>parametric and bootstrap confidence intervals for the standard deviation of y-coordinates (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>sdXYrob</code></td>
<td>
<p>robust standard deviations of x- and y-coordinates (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>covXY</code></td>
<td>
<p>covariance matrix of (x,y)-coordinates.</p>
</td></tr>
<tr><td><code>covXYrob</code></td>
<td>
<p>robust estimate of covariance matrix of (x,y)-coordinates.</p>
</td></tr>
<tr><td><code>distToCtr</code></td>
<td>
<p>mean and median distance from points to their center as well as estimated Rayleigh parameters sigma (precision), radial standard deviation RSD, and mean radius MR (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>sigmaCI</code></td>
<td>
<p>95%-parametric and bootstrap confidence intervals for sigma (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>RSDci</code></td>
<td>
<p>95%-parametric and bootstrap confidence intervals for radial standard deviation RSD (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>MRci</code></td>
<td>
<p>95%-parametric and bootstrap confidence intervals for mean radius MR (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>maxPairDist</code></td>
<td>
<p>maximum pairwise distance between points (center-to-center, = maximum spread, in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>groupRect</code></td>
<td>
<p>width and height of bounding box with diagonal and figure of merit FoM (average side length, in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>groupRectMin</code></td>
<td>
<p>width and height of minimum-area bounding box with diagonal and figure of merit FoM (average side length, in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>minCircleRad</code></td>
<td>
<p>radius for the minimum enclosing circle (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>confEll</code></td>
<td>
<p>length of semi-major and semi-minor axis of the 50%-confidence ellipse (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>confEllRob</code></td>
<td>
<p>length of semi-major and semi-minor axis of the 50%-confidence ellipse based on a robust estimate for the covariance matrix (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>confEllShape</code></td>
<td>
<p>aspect ratio and flattening of the 50%-confidence ellipse.</p>
</td></tr>
<tr><td><code>confEllShapeRob</code></td>
<td>
<p>aspect ratio and flattening of the 50%-confidence ellipse based on a robust estimate for the covariance matrix.</p>
</td></tr>
<tr><td><code>CEP</code></td>
<td>
<p>estimate(s) for the 50%-circular error probable (CEP, in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>ctr</code></td>
<td>
<p>(x,y)-offset of group center relative to point of aim.</p>
</td></tr>
<tr><td><code>ctrXci</code></td>
<td>
<p>95%-parametric and bootstrap confidence intervals for center x-coordinate.</p>
</td></tr>
<tr><td><code>ctrYci</code></td>
<td>
<p>95%-parametric and bootstrap confidence intervals for center y-coordinate.</p>
</td></tr>
<tr><td><code>ctrRob</code></td>
<td>
<p>robust estimate of group center offset relative to point of aim (MCD algorithm).</p>
</td></tr>
<tr><td><code>distPOA</code></td>
<td>
<p>distance from group center to point of aim (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>distPOArob</code></td>
<td>
<p>distance from robust estimate of group center to point of aim (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>Hotelling</code></td>
<td>
<p>Hotelling's T^2-Test result from testing if group center equals point of aim.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+groupShape">groupShape</a></code>,
<code><a href="#topic+groupLocation">groupLocation</a></code>,
<code><a href="#topic+groupSpread">groupSpread</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>,
<code><a href="#topic+getDistToCtr">getDistToCtr</a></code>,
<code><a href="#topic+getMaxPairDist">getMaxPairDist</a></code>,
<code><a href="#topic+getBoundingBox">getBoundingBox</a></code>,
<code><a href="#topic+getMinBBox">getMinBBox</a></code>,
<code><a href="#topic+getMinCircle">getMinCircle</a></code>,
<code><a href="#topic+getConfEll">getConfEll</a></code>,
<code><a href="#topic+getCEP">getCEP</a></code>,
<code><a href="#topic+getRayParam">getRayParam</a></code>,
<code><a href="#topic+getMOA">getMOA</a></code>,
<code><a href="graphics.html#topic+smoothScatter">smoothScatter</a></code>,
<code><a href="mvoutlier.html#topic+chisq.plot">chisq.plot</a></code>,
<code><a href="mvoutlier.html#topic+aq.plot">aq.plot</a></code>,
<code><a href="mvoutlier.html#topic+pcout">pcout</a></code>,
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code>,
<code><a href="graphics.html#topic+hist">hist</a></code>,
<code><a href="stats.html#topic+kernel">kernel</a></code>,
<code><a href="stats.html#topic+shapiro.test">shapiro.test</a></code>,
<code><a href="energy.html#topic+mvnorm.etest">mvnorm.etest</a></code>,
<code><a href="stats.html#topic+anova.mlm">anova.mlm</a></code>,
<code><a href="boot.html#topic+boot">boot</a></code>,
<code><a href="boot.html#topic+boot.ci">boot.ci</a></code>,
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFinch)

# select combined data from only first 2 series
DF  &lt;- subset(DFinch, series %in% 1:2)
res &lt;- analyzeGroup(DF, conversion='yd2in', bootCI='none')
names(res)
res$multNorm
res$corXY
res$ctrRob
res$ctrXci
res$ctrYci
</code></pre>

<hr>
<h2 id='combineData'>Combine list of data frames into one</h2><span id='topic+combineData'></span>

<h3>Description</h3>

<p>Combines a list of data frames (the result from using <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or <code><a href="#topic+readDataMisc">readDataMisc</a></code> with <code>combine=FALSE</code>) into one big data frame.</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineData(DFs)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineData_+3A_dfs">DFs</code></td>
<td>
<p> a list of data frames with a shared set of variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes that the data frames in the list have a non-empty set of shared variables. Among them at least either <code>point.x</code>, <code>point.y</code> or <code>x</code>, <code>y</code> defining the bullet holes. To be useful for functions <code><a href="#topic+analyzeGroup">analyzeGroup</a></code> or <code><a href="#topic+compareGroups">compareGroups</a></code>, the data frames should also have variables <code>group</code>, <code>distance</code>, <code>aim.x</code>, <code>aim.y</code> defining point of aim. If <code>group</code> is missing, it is set to 1.</p>


<h3>Value</h3>

<p>A data frame with the shared set of variables. In addition, it also contains factors identifying the original file (<code>file</code>), and a factor identifying all groups from different data frames (<code>series</code>).
</p>
<table>
<tr><td><code>...</code></td>
<td>
<p>the shared set of variables from the the data frames in the list.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>a factor that is the original <code>group</code> variable as defined by OnTarget PC/TDS.</p>
</td></tr>
<tr><td><code>groupVerb</code></td>
<td>
<p>a factor that codes group with more descriptive levels taken from the original project title, file name and ammunition (if available).</p>
</td></tr>
<tr><td><code>file</code></td>
<td>
<p>a factor that codes from which original file the data is.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>a factor that codes each separate group across original files.</p>
</td></tr>
<tr><td><code>seriesNum</code></td>
<td>
<p>a factor that codes each separate group as a number that runs consecutively across original files.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+readDataMisc">readDataMisc</a></code>,
<code><a href="#topic+readDataOT1">readDataOT1</a></code>,
<code><a href="#topic+readDataOT2">readDataOT2</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## combine list of data frames to one single data frame
data(DFlistCm)
DFcm &lt;- combineData(DFlistCm)
str(DFcm)
head(DFcm)
</code></pre>

<hr>
<h2 id='compareGroups'>Compare bullet hole groups</h2><span id='topic+compareGroups'></span>

<h3>Description</h3>

<p>Numerically and graphically compare accuracy, precision, and distribution shape of up to 15 groups of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareGroups(DF, plots = TRUE, xyTopLeft = TRUE, center = FALSE,
              ABalt = c('two.sided', 'less', 'greater'),
              Walt = c('two.sided', 'less', 'greater'),
              CEPtype = 'CorrNormal', CEPlevel = 0.5, CIlevel = 0.95,
              dstTarget, conversion)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareGroups_+3A_df">DF</code></td>
<td>
<p>a data frame containing (at least) these variables: <code>series</code> (a <code><a href="base.html#topic+factor">factor</a></code>), and either <code>point.x</code>, <code>point.y</code> or <code>x</code>, <code>y</code> defining the bullet holes. Variables <code>distance</code> (distance to target), <code>aim.x</code>, <code>aim.y</code> (point of aim) are useful - if they are missing, a warning is given and a default assumed.</p>
</td></tr>
<tr><td><code id="compareGroups_+3A_plots">plots</code></td>
<td>
<p>logical: show diagrams?</p>
</td></tr>
<tr><td><code id="compareGroups_+3A_xytopleft">xyTopLeft</code></td>
<td>
<p>logical: is the origin of the absolute coordinate system in the top-left corner? See details.</p>
</td></tr>
<tr><td><code id="compareGroups_+3A_center">center</code></td>
<td>
<p>logical: center groups to mean (0,0) first to compare only with respect to precision?</p>
</td></tr>
<tr><td><code id="compareGroups_+3A_abalt">ABalt</code></td>
<td>
<p>a character string indicating the hypothesis for the Ansari-Bradley-Test for equal variances. Only used when exactly 2 groups are compared.</p>
</td></tr>
<tr><td><code id="compareGroups_+3A_walt">Walt</code></td>
<td>
<p>a character string indicating the hypothesis for the Wilcoxon-Rank-Sum-Test for equality of average distance to group center (equivalent to the Mann-Whitney-U-Test). Only used when exactly 2 groups are compared.</p>
</td></tr>
<tr><td><code id="compareGroups_+3A_ceptype">CEPtype</code></td>
<td>
<p>string indicating which CEP estimate to report from <code><a href="#topic+getCEP">getCEP</a></code>.</p>
</td></tr>
<tr><td><code id="compareGroups_+3A_ceplevel">CEPlevel</code></td>
<td>
<p>a numerical value giving the coverage of the confidence ellipse and CEP.</p>
</td></tr>
<tr><td><code id="compareGroups_+3A_cilevel">CIlevel</code></td>
<td>
<p>a numerical value giving the level for the confidence intervals (for standard deviations and Rayleigh sigma, MR).</p>
</td></tr>
<tr><td><code id="compareGroups_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in <code>DF</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="compareGroups_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Acts as override if variables <code>dist.unit</code> and <code>point.unit</code> are already included in <code>DF</code>. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, OnTarget PC/TDS' 'Export Point Data' places the origin of the absolute coordinate system in the top-left corner. In OnTarget TDS, this setting can be changed by checking the box 'Tools -&gt; Options -&gt; Options tab -&gt; Data Export -&gt; Invert Y-Axis on Export'. In that case, use <code>xyTopLeft=FALSE</code>. If groups appear to be upside-down, <code>xyTopLeft</code> is the setting to change.
</p>
<p>OnTarget PC/TDS' <code>Group</code> variable identifies groups just within one file, whereas factor <code>series</code> is taken to number groups also across different original files. If your data was read with <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code> or <code><a href="#topic+readDataMisc">readDataMisc</a></code>, <code>series</code> is added automatically. For data from just one file, you can otherwise copy variable <code>group</code> to <code>series</code> in a data frame called <code>shots</code> with <code>shots$series</code> <code>&lt;-</code> <code>shots$group</code>.<br />
If the data is missing information about the point of aim, (0,0) is assumed. If distance to target is missing, 100 is assumed.
</p>
<p>In addition to the numerical results listed below, this function produces the following diagrams:
</p>

<ul>
<li><p> a scatterplot showing all groups as well as their respective center and confidence ellipse
</p>
</li>
<li><p> a scatterplot showing all groups as well as their respective (minimum) bounding box and maximum group spread
</p>
</li>
<li><p> a scatterplot showing all groups as well as their respective minimum enclosing circle and circle with average distance to center
</p>
</li>
<li><p> a boxplot for the distances to group center per group
</p>
</li>
<li><p> a stripchart showing the distances to group center per group together with the estimated Rayleigh mean radius and its confidence interval
</p>
</li></ul>

<p>If package <code>shiny</code> is installed, an interactive web app for this functionality can be run with <code>runGUI("analyze")</code>.
</p>


<h3>Value</h3>

<p>A list with the results from numerical comparisons and statistical tests.
</p>
<table>
<tr><td><code>ctr</code></td>
<td>
<p>group center offset from the respective point of aim.</p>
</td></tr>
<tr><td><code>distPOA</code></td>
<td>
<p>distances from group centers to point of aim (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>MANOVA</code></td>
<td>
<p>MANOVA result from testing equality of group center offset from the respective point of aim (test statistic is Wilk's lambda).</p>
</td></tr>
<tr><td><code>corXY</code></td>
<td>
<p>group correlation matrices for the (x,y)-coordinates.</p>
</td></tr>
<tr><td><code>sdXY</code></td>
<td>
<p>list with group standard deviations of the x- and y-coordinates (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>sdXYci</code></td>
<td>
<p>list with group parametric (chi^2) confidence intervals for the standard deviations of x- and y coordinates (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>meanDistToCtr</code></td>
<td>
<p>average distances from points to their respective group center (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>maxPairDist</code></td>
<td>
<p>maximum pairwise distance between points for each group (center-to-center, = maximum spread, in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>bbFoM</code></td>
<td>
<p>minimum-area bounding box figure of merit (average side length) for each group (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>bbDiag</code></td>
<td>
<p>minimum-area bounding box diagonal length for each group (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>minCircleRad</code></td>
<td>
<p>radius of the minimum enclosing circle for each group (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>estimated Rayleigh parameter sigma (precision) for each group (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>MR</code></td>
<td>
<p>estimated Rayleigh mean radius for each group (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>sigmaMRci</code></td>
<td>
<p>parametric (chi^2) confidence intervals for Rayleigh sigma and MR (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>CEP</code></td>
<td>
<p>Estimate for the circular error probable (CEP) in each group (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>AnsariX</code></td>
<td>
<p>Ansari-Bradley-Test result from testing equality of group variances for x-coordinates. When two groups are compared.</p>
</td></tr>
<tr><td><code>AnsariY</code></td>
<td>
<p>Ansari-Bradley-Test result from testing equality of group variances for y-coordinates. When two groups are compared.</p>
</td></tr>
<tr><td><code>Wilcoxon</code></td>
<td>
<p>Wilcoxon-Rank-Sum-Test result from testing equality of average point distances to their respective group center. When two groups are compared.</p>
</td></tr>
<tr><td><code>FlignerX</code></td>
<td>
<p>Fligner-Killeen-Test result from testing equality of group variances for x-coordinates. When more than two groups are compared.</p>
</td></tr>
<tr><td><code>FlignerY</code></td>
<td>
<p>Fligner-Killeen-Test result from testing equality of group variances for y-coordinates. When more than two groups are compared.</p>
</td></tr>
<tr><td><code>Kruskal</code></td>
<td>
<p>Kruskal-Wallis-Test result from testing equality of average point distances to their respective group center. When more than two groups are compared.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+getDistToCtr">getDistToCtr</a></code>,
<code><a href="#topic+getMaxPairDist">getMaxPairDist</a></code>,
<code><a href="#topic+getMinBBox">getMinBBox</a></code>,
<code><a href="#topic+getMinCircle">getMinCircle</a></code>,
<code><a href="#topic+getCEP">getCEP</a></code>,
<code><a href="#topic+getMOA">getMOA</a></code>,
<code><a href="#topic+getRayParam">getRayParam</a></code>,
<code><a href="#topic+drawEllipse">drawEllipse</a></code>,
<code><a href="stats.html#topic+anova.mlm">anova.mlm</a></code>,
<code><a href="coin.html#topic+ansari_test">ansari_test</a></code>,
<code><a href="coin.html#topic+fligner_test">fligner_test</a></code>,
<code><a href="coin.html#topic+wilcox_test">wilcox_test</a></code>,
<code><a href="coin.html#topic+kruskal_test">kruskal_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cmp &lt;- compareGroups(DF300BLKhl, dstTarget=100, conversion='yd2in')
names(cmp)
cmp$ctr
cmp$meanDistToCtr
cmp$CEP
cmp$Kruskal
</code></pre>

<hr>
<h2 id='DF300BLK'>Combined bullet hole data</h2><span id='topic+DF300BLK'></span>

<h3>Description</h3>

<p>Example of a data frame from one file with one group of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DF300BLK)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 9 variables.
</p>

<dl>
<dt><code>group</code></dt><dd><p>a factor with level <code>1</code>.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numerical vector giving the distance to the target.</p>
</dd>
<dt><code>aim.x</code></dt><dd><p>a numerical vector of x-coordinates giving the point of aim.</p>
</dd>
<dt><code>aim.y</code></dt><dd><p>a numerical vector of y-coordinates giving the of point of aim.</p>
</dd>
<dt><code>point.x</code></dt><dd><p>a numerical vector of absolute x-coordinates of bullet holes.</p>
</dd>
<dt><code>point.y</code></dt><dd><p>a numerical vector of absolute y-coordinates of bullet holes.</p>
</dd>
<dt><code>origin</code></dt><dd><p>a factor with level <code>1</code>. This factor codes from which original output file the data is.</p>
</dd>
<dt><code>orgser</code></dt><dd><p>a factor with level <code>1.1</code>. This factor results from <code><a href="base.html#topic+droplevels">droplevels</a>(<a href="base.html#topic+interaction">interaction</a>(origin, group))</code>, and codes each separate group across original files. The order of the factor levels is alphabetical.</p>
</dd>
<dt><code>series</code></dt><dd><p>a factor with level <code>1</code>. This factor codes each separate group as defined by <code>orgser</code>, but more conveniently as a number that runs consecutively across original files.</p>
</dd>
<dt><code>distance.unit</code></dt><dd><p>Measurement unit distance to target</p>
</dd>
<dt><code>point.unit</code></dt><dd><p>Measurement unit (x,y)-coordinates</p>
</dd>
</dl>



<h3>Details</h3>

<p>One group of shooting a Noveske AR-15 rifle in 300BLK at 100yd with factory ammunition. The measurement unit for coordinates is inch, for distance yards. <br />
This data frame is like those returned by <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or <code><a href="#topic+readDataMisc">readDataMisc</a></code> with option <code>combine=TRUE</code>. <br />
Data courtesy of David Bookstaber, 2013. <code>http://ballistipedia.com/</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DF300BLK)
str(DF300BLK)
</code></pre>

<hr>
<h2 id='DF300BLKhl'>Combined bullet hole data</h2><span id='topic+DF300BLKhl'></span>

<h3>Description</h3>

<p>Example of a data frame from one file with one group of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DF300BLK)</code></pre>


<h3>Format</h3>

<p>A data frame with 60 observations on the following 9 variables.
</p>

<dl>
<dt><code>group</code></dt><dd><p>a factor with level <code>1</code>.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numerical vector giving the distance to the target.</p>
</dd>
<dt><code>aim.x</code></dt><dd><p>a numerical vector of x-coordinates giving the point of aim.</p>
</dd>
<dt><code>aim.y</code></dt><dd><p>a numerical vector of y-coordinates giving the of point of aim.</p>
</dd>
<dt><code>point.x</code></dt><dd><p>a numerical vector of absolute x-coordinates of bullet holes.</p>
</dd>
<dt><code>point.y</code></dt><dd><p>a numerical vector of absolute y-coordinates of bullet holes.</p>
</dd>
<dt><code>origin</code></dt><dd><p>a factor with level <code>1</code>. This factor codes from which original output file the data is.</p>
</dd>
<dt><code>orgser</code></dt><dd><p>a factor with levels <code>1.1</code>, <code>1.2</code>, <code>1.3</code>. This factor results from <code><a href="base.html#topic+droplevels">droplevels</a>(<a href="base.html#topic+interaction">interaction</a>(origin, group))</code>, and codes each separate group across original files. The order of the factor levels is alphabetical.</p>
</dd>
<dt><code>series</code></dt><dd><p>a factor with levels <code>1</code>, <code>2</code>, <code>3</code>. This factor codes each separate group as defined by <code>orgser</code>, but more conveniently as a number that runs consecutively across original files.</p>
</dd>
<dt><code>distance.unit</code></dt><dd><p>Measurement unit distance to target</p>
</dd>
<dt><code>point.unit</code></dt><dd><p>Measurement unit (x,y)-coordinates</p>
</dd>
</dl>



<h3>Details</h3>

<p>Three groups of shooting a Noveske AR-15 rifle in 300BLK at 100yd with handloaded ammunition. The measurement unit for coordinates is inch, for distance yards. <br />
This data frame is like those returned by <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or <code><a href="#topic+readDataMisc">readDataMisc</a></code> with option <code>combine=TRUE</code>. <br />
Data courtesy of David Bookstaber, 2014. <code>http://ballistipedia.com/</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DF300BLK)
str(DF300BLK)
</code></pre>

<hr>
<h2 id='DFcciHV'>Combined bullet hole data</h2><span id='topic+DFcciHV'></span>

<h3>Description</h3>

<p>Example of a data frame from one file with two groups of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DFcciHV)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 9 variables.
</p>

<dl>
<dt><code>group</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code>.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numerical vector giving the distance to the target.</p>
</dd>
<dt><code>aim.x</code></dt><dd><p>a numerical vector of x-coordinates giving the point of aim.</p>
</dd>
<dt><code>aim.y</code></dt><dd><p>a numerical vector of y-coordinates giving the of point of aim.</p>
</dd>
<dt><code>point.x</code></dt><dd><p>a numerical vector of absolute x-coordinates of bullet holes.</p>
</dd>
<dt><code>point.y</code></dt><dd><p>a numerical vector of absolute y-coordinates of bullet holes.</p>
</dd>
<dt><code>origin</code></dt><dd><p>a factor with levels <code>1</code>. This factor codes from which original output file the data is.</p>
</dd>
<dt><code>orgser</code></dt><dd><p>a factor with levels <code>1.1</code> <code>1.2</code>. This factor results from <code><a href="base.html#topic+droplevels">droplevels</a>(<a href="base.html#topic+interaction">interaction</a>(origin, group))</code>, and codes each separate group across original files. The order of the factor levels is alphabetical.</p>
</dd>
<dt><code>series</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code>. This factor codes each separate group as defined by <code>orgser</code>, but more conveniently as a number that runs consecutively across original files.</p>
</dd>
<dt><code>distance.unit</code></dt><dd><p>Measurement unit distance to target</p>
</dd>
<dt><code>point.unit</code></dt><dd><p>Measurement unit (x,y)-coordinates</p>
</dd>
</dl>



<h3>Details</h3>

<p>Two groups of shooting a PWS T3 rifle in .22LR at 100yd. The measurement unit for coordinates is inch, for distance yards. <br />
This data frame is like those returned by <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or <code><a href="#topic+readDataMisc">readDataMisc</a></code> with option <code>combine=TRUE</code>. <br />
Data courtesy of David Bookstaber, 2013. <code>http://ballistipedia.com/</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFcciHV)
str(DFcciHV)
</code></pre>

<hr>
<h2 id='DFcm'>Combined bullet hole data</h2><span id='topic+DFcm'></span>

<h3>Description</h3>

<p>Example of a combined data frame from several files exported by OnTarget PC/TDS, each with several groups of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DFcm)</code></pre>


<h3>Format</h3>

<p>A data frame with 487 observations on the following 13 variables.
</p>

<dl>
<dt><code>project.title</code></dt><dd><p>a character vector giving the OnTarget PC/TDS project title.</p>
</dd>
<dt><code>group</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code> <code>3</code>. This is the original <code>Group</code> variable as defined by OnTarget PC/TDS.</p>
</dd>
<dt><code>ammunition</code></dt><dd><p>a character vector describing the ammo.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numerical vector giving the distance to the target.</p>
</dd>
<dt><code>aim.x</code></dt><dd><p>a numerical vector of x-coordinates giving the point of aim.</p>
</dd>
<dt><code>aim.y</code></dt><dd><p>a numerical vector of y-coordinates giving the of point of aim.</p>
</dd>
<dt><code>center.x</code></dt><dd><p>a numerical vector of x-coordinates giving the group centers.</p>
</dd>
<dt><code>center.y</code></dt><dd><p>a numerical vector of y-coordinates giving the group centers.</p>
</dd>
<dt><code>point.x</code></dt><dd><p>a numerical vector of absolute x-coordinates of bullet holes.</p>
</dd>
<dt><code>point.y</code></dt><dd><p>a numerical vector of absolute y-coordinates of bullet holes.</p>
</dd>
<dt><code>origin</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code> <code>3</code>. This factor codes from which original output file the data is.</p>
</dd>
<dt><code>orgser</code></dt><dd><p>a factor with levels <code>1.1</code> <code>2.1</code> <code>3.1</code> <code>1.2</code> <code>2.2</code> <code>3.2</code> <code>1.3</code> <code>2.3</code> <code>3.3</code>. This factor results from <code><a href="base.html#topic+droplevels">droplevels</a>(<a href="base.html#topic+interaction">interaction</a>(origin, group))</code>, and codes each separate group across original files. The order of the factor levels is alphabetical.</p>
</dd>
<dt><code>series</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>8</code> <code>9</code>. This factor codes each separate group as defined by <code>orgser</code>, but more conveniently as a number that runs consecutively across original files.</p>
</dd>
<dt><code>distance.unit</code></dt><dd><p>Measurement unit distance to target</p>
</dd>
<dt><code>point.unit</code></dt><dd><p>Measurement unit (x,y)-coordinates</p>
</dd>
<dt><code>target</code></dt><dd><p>Character string <code>"BDS9"</code> indicating the target face. See <code><a href="#topic+targets">targets</a></code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Several groups of shooting a 9x19mm pistol at 25m. The measurement unit for coordinates is cm, for distance meters. <br />
This data frame is like those returned by <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or <code><a href="#topic+readDataMisc">readDataMisc</a></code> with option <code>combine=TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFcm)
str(DFcm)
</code></pre>

<hr>
<h2 id='DFdistr'>Lookup table for distribution of range statistics and Rayleigh sigma</h2><span id='topic+DFdistr'></span>

<h3>Description</h3>

<p>Lookup table for the distribution of range statistics and Rayleigh sigma from a Monte Carlo simulation of circular bivariate normal shot groups with 0 mean and variance 1 in both directions. Includes the first four moments and several quantiles of the distribution of extreme spread, figure of merit, bounding box diagonal, and Rayleigh sigma for each combination of number of shots per group and number of groups, repeated 10 million times.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DFdistr)</code></pre>


<h3>Format</h3>

<p>A data frame with 590 observations on the following 77 variables.
</p>

<dl>
<dt>n</dt><dd><p>number of shots in each group. One of 2, 3, ..., 49, 50, 45, ..., 95, 100.</p>
</dd>
<dt>nGroups</dt><dd><p>number of groups with individual simulated range statistics that were averaged over to yield the final value. One of 1, 2, ..., 9, 10.</p>
</dd>
<dt>nShots</dt><dd><p>total number of shots, i.e., <code>n*nGroups</code>.</p>
</dd>
<dt>ES_M</dt><dd><p>Extreme spread mean over all Monte Carlo simulations</p>
</dd>
<dt>ES_V</dt><dd><p>Extreme spread variance over all Monte Carlo simulations</p>
</dd>
<dt>ES_SD</dt><dd><p>Extreme spread standard deviation over all Monte Carlo simulations</p>
</dd>
<dt>ES_CV</dt><dd><p>Extreme spread coefficient of variation over all Monte Carlo simulations</p>
</dd>
<dt>ESSQ_M</dt><dd><p>Squard extreme spread mean over all Monte Carlo simulations</p>
</dd>
<dt>ESSQ_V</dt><dd><p>Squared extreme spread variance over all Monte Carlo simulations</p>
</dd>
<dt>ES_SKEW</dt><dd><p>Extreme spread skewness over all Monte Carlo simulations (smoothed)</p>
</dd>
<dt>ES_KURT</dt><dd><p>Extreme spread kurtosis over all Monte Carlo simulations (smoothed)</p>
</dd>
<dt>ES_MED</dt><dd><p>Extreme spread median (50% quantile) over all Monte Carlo simulations</p>
</dd>
<dt>ES_Q005</dt><dd><p>Extreme spread 0.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>ES_Q025</dt><dd><p>Extreme spread 2.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>ES_Q050</dt><dd><p>Extreme spread 5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>ES_Q100</dt><dd><p>Extreme spread 10% quantile over all Monte Carlo simulations</p>
</dd>
<dt>ES_Q250</dt><dd><p>Extreme spread 25% quantile over all Monte Carlo simulations</p>
</dd>
<dt>ES_Q500</dt><dd><p>Extreme spread 50% quantile (median) over all Monte Carlo simulations</p>
</dd>
<dt>ES_Q750</dt><dd><p>Extreme spread 75% quantile over all Monte Carlo simulations</p>
</dd>
<dt>ES_Q900</dt><dd><p>Extreme spread 90% quantile over all Monte Carlo simulations</p>
</dd>
<dt>ES_Q950</dt><dd><p>Extreme spread 95% quantile over all Monte Carlo simulations</p>
</dd>
<dt>ES_Q975</dt><dd><p>Extreme spread 97.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>ES_Q995</dt><dd><p>Extreme spread 99.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>FoM_M</dt><dd><p>Figure of merit mean over all Monte Carlo simulations</p>
</dd>
<dt>FoM_V</dt><dd><p>Figure of merit variance over all Monte Carlo simulations</p>
</dd>
<dt>FoM_SD</dt><dd><p>Figure of merit standard deviation over all Monte Carlo simulations</p>
</dd>
<dt>FoM_CV</dt><dd><p>Figure of merit coefficient of variation over all Monte Carlo simulations</p>
</dd>
<dt>FoM_SKEW</dt><dd><p>Figure of merit skewness over all Monte Carlo simulations (smoothed)</p>
</dd>
<dt>FoM_KURT</dt><dd><p>Figure of merit kurtosis over all Monte Carlo simulations (smoothed)</p>
</dd>
<dt>FoM_MED</dt><dd><p>Figure of merit median (50% quantile) over all Monte Carlo simulations</p>
</dd>
<dt>FoM_Q005</dt><dd><p>Figure of merit 0.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>FoM_Q025</dt><dd><p>Figure of merit 2.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>FoM_Q050</dt><dd><p>Figure of merit 0.25% quantile over all Monte Carlo simulations</p>
</dd>
<dt>FoM_Q100</dt><dd><p>Figure of merit 10% quantile over all Monte Carlo simulations</p>
</dd>
<dt>FoM_Q250</dt><dd><p>Figure of merit 25% quantile over all Monte Carlo simulations</p>
</dd>
<dt>FoM_Q500</dt><dd><p>Figure of merit 50% quantile (median) over all Monte Carlo simulations</p>
</dd>
<dt>FoM_Q750</dt><dd><p>Figure of merit 75% quantile over all Monte Carlo simulations</p>
</dd>
<dt>FoM_Q900</dt><dd><p>Figure of merit 90% quantile over all Monte Carlo simulations</p>
</dd>
<dt>FoM_Q950</dt><dd><p>Figure of merit 95% quantile over all Monte Carlo simulations</p>
</dd>
<dt>FoM_Q975</dt><dd><p>Figure of merit 97.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>FoM_Q995</dt><dd><p>Figure of merit 99.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>D_M</dt><dd><p>Bounding box diagonal mean over all Monte Carlo simulations</p>
</dd>
<dt>D_V</dt><dd><p>Bounding box diagonal variance over all Monte Carlo simulations</p>
</dd>
<dt>D_SD</dt><dd><p>Bounding box diagonal standard deviation over all Monte Carlo simulations</p>
</dd>
<dt>D_CV</dt><dd><p>Bounding box diagonal coefficient of variation over all Monte Carlo simulations</p>
</dd>
<dt>D_SKEW</dt><dd><p>Bounding box diagonal skewness over all Monte Carlo simulations (smoothed)</p>
</dd>
<dt>D_KURT</dt><dd><p>Bounding box diagonal kurtosis over all Monte Carlo simulations (smoothed)</p>
</dd>
<dt>D_MED</dt><dd><p>Bounding box diagonal median (50% quantile) over all Monte Carlo simulations</p>
</dd>
<dt>D_Q005</dt><dd><p>Bounding box diagonal 0.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>D_Q025</dt><dd><p>Bounding box diagonal 2.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>D_Q050</dt><dd><p>Bounding box diagonal 5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>D_Q100</dt><dd><p>Bounding box diagonal 10% quantile over all Monte Carlo simulations</p>
</dd>
<dt>D_Q250</dt><dd><p>Bounding box diagonal 25% quantile over all Monte Carlo simulations</p>
</dd>
<dt>D_Q500</dt><dd><p>Bounding box diagonal 50% quantile (median) over all Monte Carlo simulations</p>
</dd>
<dt>D_Q750</dt><dd><p>Bounding box diagonal 75% quantile over all Monte Carlo simulations</p>
</dd>
<dt>D_Q900</dt><dd><p>Bounding box diagonal 90% quantile over all Monte Carlo simulations</p>
</dd>
<dt>D_Q950</dt><dd><p>Bounding box diagonal 95% quantile over all Monte Carlo simulations</p>
</dd>
<dt>D_Q975</dt><dd><p>Bounding box diagonal 97.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>D_Q995</dt><dd><p>Bounding box diagonal 99.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>RS_M</dt><dd><p>Rayleigh sigma mean over all Monte Carlo simulations</p>
</dd>
<dt>RS_V</dt><dd><p>Rayleigh sigma variance over all Monte Carlo simulations</p>
</dd>
<dt>RS_SD</dt><dd><p>Rayleigh sigma standard deviation over all Monte Carlo simulations</p>
</dd>
<dt>RS_CV</dt><dd><p>Rayleigh sigma coefficient of variation over all Monte Carlo simulations</p>
</dd>
<dt>RS_SKEW</dt><dd><p>Rayleigh sigma skewness over all Monte Carlo simulations (smoothed)</p>
</dd>
<dt>RS_KURT</dt><dd><p>Rayleigh sigma kurtosis over all Monte Carlo simulations (smoothed)</p>
</dd>
<dt>RS_MED</dt><dd><p>Rayleigh sigma median (50% quantile) over all Monte Carlo simulations</p>
</dd>
<dt>RS_Q005</dt><dd><p>Rayleigh sigma 0.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>RS_Q025</dt><dd><p>Rayleigh sigma 2.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>RS_Q050</dt><dd><p>Rayleigh sigma 5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>RS_Q100</dt><dd><p>Rayleigh sigma 10% quantile over all Monte Carlo simulations</p>
</dd>
<dt>RS_Q250</dt><dd><p>Rayleigh sigma 25% quantile over all Monte Carlo simulations</p>
</dd>
<dt>RS_Q500</dt><dd><p>Rayleigh sigma 50% quantile (median) over all Monte Carlo simulations</p>
</dd>
<dt>RS_Q750</dt><dd><p>Rayleigh sigma 75% quantile over all Monte Carlo simulations</p>
</dd>
<dt>RS_Q900</dt><dd><p>Rayleigh sigma 90% quantile over all Monte Carlo simulations</p>
</dd>
<dt>RS_Q950</dt><dd><p>Rayleigh sigma 95% quantile over all Monte Carlo simulations</p>
</dd>
<dt>RS_Q975</dt><dd><p>Rayleigh sigma 97.5% quantile over all Monte Carlo simulations</p>
</dd>
<dt>RS_Q995</dt><dd><p>Rayleigh sigma 99.5% quantile over all Monte Carlo simulations</p>
</dd>
</dl>



<h3>Details</h3>

<p>The Monte Carlo distribution used 10 million repetitions in each scenario. One scenario was a combination of the <code>n</code> shots in each group, and the <code>nGroups</code> groups over which individual range statistics were averaged. Values for <code>n</code> were 2, 3, ..., 49, 50, 45, ..., 95, 100. Values for <code>nGroups</code> were 1, 2, ... 9, 10.
</p>
<p>Skewness and kurtosis were smoothed using separate linear spline fits for each number of groups except for kurtosis of Rayleigh sigma which was fitted using the density of the gamma distribution. 
</p>
<p>Used in <code><a href="#topic+range2sigma">range2sigma</a></code> to estimate Rayleigh parameter sigma from range statistics, and in <code><a href="#topic+efficiency">efficiency</a></code> to estimate the number of groups and total shots required to estimate the confidence interval (CI) for Rayleigh sigma with a given coverage probability (CI level) and width.
</p>
<p>See the following source for an independent simulation, and for the rationale behind using it to estimate Rayleigh sigma:
</p>
<p><a href="http://ballistipedia.com/index.php?title=Range_Statistics">http://ballistipedia.com/index.php?title=Range_Statistics</a>
</p>
<p>An older eqivalent simulation with less repetitions was done by Taylor and Grubbs (1975).
</p>


<h3>References</h3>

<p>Taylor, M. S., &amp; Grubbs, F. E. (1975). Approximate Probability Distributions for the Extreme Spread (BRL-MR-2438). Aberdeen Proving Ground, MD: U.S. Ballistic Research Laboratory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+range2sigma">range2sigma</a></code>,
<code><a href="#topic+efficiency">efficiency</a></code>,
<code><a href="#topic+getMaxPairDist">getMaxPairDist</a></code>,
<code><a href="#topic+getBoundingBox">getBoundingBox</a></code>,
<code><a href="#topic+getRayParam">getRayParam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFdistr)
str(DFdistr)
</code></pre>

<hr>
<h2 id='DFinch'>Combined bullet hole data</h2><span id='topic+DFinch'></span>

<h3>Description</h3>

<p>Example of a combined data frame from several files exported by OnTarget PC/TDS, each with several groups of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DFinch)</code></pre>


<h3>Format</h3>

<p>A data frame with 487 observations on the following 13 variables.
</p>

<dl>
<dt><code>project.title</code></dt><dd><p>a character vector giving the OnTarget PC/TDS project title.</p>
</dd>
<dt><code>group</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code> <code>3</code>. This is the original <code>Group</code> variable as defined by OnTarget PC/TDS.</p>
</dd>
<dt><code>ammunition</code></dt><dd><p>a character vector describing the ammo.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numerical vector giving the distance to the target.</p>
</dd>
<dt><code>aim.x</code></dt><dd><p>a numerical vector of x-coordinates giving the point of aim.</p>
</dd>
<dt><code>aim.y</code></dt><dd><p>a numerical vector of y-coordinates giving the of point of aim.</p>
</dd>
<dt><code>center.x</code></dt><dd><p>a numerical vector of x-coordinates giving the group centers.</p>
</dd>
<dt><code>center.y</code></dt><dd><p>a numerical vector of y-coordinates giving the group centers.</p>
</dd>
<dt><code>point.x</code></dt><dd><p>a numerical vector of absolute x-coordinates of bullet holes.</p>
</dd>
<dt><code>point.y</code></dt><dd><p>a numerical vector of absolute y-coordinates of bullet holes.</p>
</dd>
<dt><code>origin</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code> <code>3</code>. This factor codes from which original output file the data is.</p>
</dd>
<dt><code>orgser</code></dt><dd><p>a factor with levels <code>1.1</code> <code>2.1</code> <code>3.1</code> <code>1.2</code> <code>2.2</code> <code>3.2</code> <code>1.3</code> <code>2.3</code> <code>3.3</code>. This factor results from <code><a href="base.html#topic+droplevels">droplevels</a>(<a href="base.html#topic+interaction">interaction</a>(origin, group))</code>, and codes each separate group across original files. The order of the factor levels is alphabetical.</p>
</dd>
<dt><code>series</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>8</code> <code>9</code>. This factor codes each separate group as defined by <code>orgser</code>, but more conveniently as a number that runs consecutively across original files.</p>
</dd>
<dt><code>distance.unit</code></dt><dd><p>Measurement unit distance to target</p>
</dd>
<dt><code>point.unit</code></dt><dd><p>Measurement unit (x,y)-coordinates</p>
</dd>
<dt><code>target</code></dt><dd><p>Character string <code>"BDS9"</code> indicating the target face. See <code><a href="#topic+targets">targets</a></code></p>
</dd>
</dl>



<h3>Details</h3>

<p>Several groups of shooting a 9x19mm pistol at 27yd. The measurement unit for coordinates is inch, for distance yards. <br />
This data frame is like those returned by <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or <code><a href="#topic+readDataMisc">readDataMisc</a></code> with option <code>combine=TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFinch)
str(DFinch)
</code></pre>

<hr>
<h2 id='DFlandy01'>Combined bullet hole data</h2><span id='topic+DFlandy01'></span>

<h3>Description</h3>

<p>Example of a data frame from one file with one group of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DFlandy01)</code></pre>


<h3>Format</h3>

<p>A data frame with 530 observations on the following 15 variables.
</p>

<dl>
<dt><code>group</code></dt><dd><p>a numerical vector with group numbers 1 to 53.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numerical vector giving the distance to the target.</p>
</dd>
<dt><code>aim.x</code></dt><dd><p>a numerical vector of x-coordinates giving the point of aim.</p>
</dd>
<dt><code>aim.y</code></dt><dd><p>a numerical vector of y-coordinates giving the of point of aim.</p>
</dd>
<dt><code>point.x</code></dt><dd><p>a numerical vector of absolute x-coordinates of bullet holes.</p>
</dd>
<dt><code>point.y</code></dt><dd><p>a numerical vector of absolute y-coordinates of bullet holes.</p>
</dd>
<dt><code>ammunition</code></dt><dd><p>a character vector giving ammunition and lot number.</p>
</dd>
<dt><code>velocity</code></dt><dd><p>a numerical vector of chronograph readings in ft/s.</p>
</dd>
<dt><code>control</code></dt><dd><p>undocumented.</p>
</dd>
<dt><code>phase1</code></dt><dd><p>undocumented.</p>
</dd>
<dt><code>phase2</code></dt><dd><p>undocumented.</p>
</dd>
<dt><code>file</code></dt><dd><p>a character vector with the original file name.</p>
</dd>
<dt><code>groupVerb</code></dt><dd><p>a character vector designating the group by combining the original file name and ammunition.</p>
</dd>
<dt><code>series</code></dt><dd><p>a character vector that codes each separate group in an alternative way.</p>
</dd>
<dt><code>seriesNum</code></dt><dd><p>like <code>series</code> but numeric.</p>
</dd>
<dt><code>distance.unit</code></dt><dd><p>Measurement unit distance to target</p>
</dd>
<dt><code>point.unit</code></dt><dd><p>Measurement unit (x,y)-coordinates</p>
</dd>
</dl>



<h3>Details</h3>

<p>53 groups with 10 shots each of .22LR shot at Eley test center on Oct 2 2016 using a Stiller 2500X action at a distance of 50m. The measurement unit for coordinates is mm, for distance m. <br />
This data frame is like those returned by <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or <code><a href="#topic+readDataMisc">readDataMisc</a></code> with option <code>combine=TRUE</code>. <br />
Data courtesy of Larry Landercasper, 2017. Analyzed by Albert Highe.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFlandy01)
str(DFlandy01)
</code></pre>

<hr>
<h2 id='DFlandy02'>Combined bullet hole data</h2><span id='topic+DFlandy02'></span>

<h3>Description</h3>

<p>Example of a data frame from one file with one group of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DFlandy02)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 12 variables.
</p>

<dl>
<dt><code>group</code></dt><dd><p>a numerical vector with group numbers 1, 2.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numerical vector giving the distance to the target.</p>
</dd>
<dt><code>aim.x</code></dt><dd><p>a numerical vector of x-coordinates giving the point of aim.</p>
</dd>
<dt><code>aim.y</code></dt><dd><p>a numerical vector of y-coordinates giving the of point of aim.</p>
</dd>
<dt><code>point.x</code></dt><dd><p>a numerical vector of absolute x-coordinates of bullet holes.</p>
</dd>
<dt><code>point.y</code></dt><dd><p>a numerical vector of absolute y-coordinates of bullet holes.</p>
</dd>
<dt><code>ammunition</code></dt><dd><p>a character vector giving ammunition and lot number.</p>
</dd>
<dt><code>velocity</code></dt><dd><p>a numerical vector of chronograph readings in ft/s.</p>
</dd>
<dt><code>file</code></dt><dd><p>a character vector with the original file name.</p>
</dd>
<dt><code>groupVerb</code></dt><dd><p>a character vector designating the group by combining the original file name and ammunition.</p>
</dd>
<dt><code>series</code></dt><dd><p>a character vector that codes each separate group in an alternative way.</p>
</dd>
<dt><code>seriesNum</code></dt><dd><p>like <code>series</code> but numeric.</p>
</dd>
<dt><code>distance.unit</code></dt><dd><p>Measurement unit distance to target</p>
</dd>
<dt><code>point.unit</code></dt><dd><p>Measurement unit (x,y)-coordinates</p>
</dd>
</dl>


<h3>Details</h3>

<p>2 groups with 50 shots each of .22LR shot using a Stiller 2500X action at a distance of 50yd. The measurement unit for coordinates is inch, for distance yards. Group 1 is from the best of 3 lots, group 2 from worst of 3 lots. <br />
This data frame is like those returned by <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or <code><a href="#topic+readDataMisc">readDataMisc</a></code> with option <code>combine=TRUE</code>. <br />
Data courtesy of Larry Landercasper, 2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFlandy02)
str(DFlandy02)
</code></pre>

<hr>
<h2 id='DFlandy03'>Combined bullet hole data</h2><span id='topic+DFlandy03'></span>

<h3>Description</h3>

<p>Example of a data frame from one file with one group of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DFlandy03)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 12 variables.
</p>

<dl>
<dt><code>group</code></dt><dd><p>a numerical vector with group numbers 1, 2.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numerical vector giving the distance to the target.</p>
</dd>
<dt><code>aim.x</code></dt><dd><p>a numerical vector of x-coordinates giving the point of aim.</p>
</dd>
<dt><code>aim.y</code></dt><dd><p>a numerical vector of y-coordinates giving the of point of aim.</p>
</dd>
<dt><code>point.x</code></dt><dd><p>a numerical vector of absolute x-coordinates of bullet holes.</p>
</dd>
<dt><code>point.y</code></dt><dd><p>a numerical vector of absolute y-coordinates of bullet holes.</p>
</dd>
<dt><code>ammunition</code></dt><dd><p>a character vector giving ammunition and lot number.</p>
</dd>
<dt><code>velocity</code></dt><dd><p>a numerical vector of chronograph readings in ft/s.</p>
</dd>
<dt><code>file</code></dt><dd><p>a character vector with the original file name.</p>
</dd>
<dt><code>groupVerb</code></dt><dd><p>a character vector designating the group by combining the original file name and ammunition.</p>
</dd>
<dt><code>series</code></dt><dd><p>a character vector that codes each separate group in an alternative way.</p>
</dd>
<dt><code>seriesNum</code></dt><dd><p>like <code>series</code> but numeric.</p>
</dd>
<dt><code>distance.unit</code></dt><dd><p>Measurement unit distance to target</p>
</dd>
<dt><code>point.unit</code></dt><dd><p>Measurement unit (x,y)-coordinates</p>
</dd>
</dl>


<h3>Details</h3>

<p>4 groups with 25 shots each of .22LR shot at a distance of 50yd. The measurement unit for coordinates is inch, for distance yards. <br />
Data courtesy of Larry Landercasper, 2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFlandy03)
str(DFlandy03)
</code></pre>

<hr>
<h2 id='DFlandy04'>Combined bullet hole data</h2><span id='topic+DFlandy04'></span>

<h3>Description</h3>

<p>Example of a data frame from one file with one group of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DFlandy04)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 12 variables.
</p>

<dl>
<dt><code>group</code></dt><dd><p>a numerical vector with group numbers 1, 2.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numerical vector giving the distance to the target.</p>
</dd>
<dt><code>aim.x</code></dt><dd><p>a numerical vector of x-coordinates giving the point of aim.</p>
</dd>
<dt><code>aim.y</code></dt><dd><p>a numerical vector of y-coordinates giving the of point of aim.</p>
</dd>
<dt><code>point.x</code></dt><dd><p>a numerical vector of absolute x-coordinates of bullet holes.</p>
</dd>
<dt><code>point.y</code></dt><dd><p>a numerical vector of absolute y-coordinates of bullet holes.</p>
</dd>
<dt><code>ammunition</code></dt><dd><p>a character vector giving ammunition and lot number.</p>
</dd>
<dt><code>velocity</code></dt><dd><p>a numerical vector of chronograph readings in ft/s.</p>
</dd>
<dt><code>file</code></dt><dd><p>a character vector with the original file name.</p>
</dd>
<dt><code>groupVerb</code></dt><dd><p>a character vector designating the group by combining the original file name and ammunition.</p>
</dd>
<dt><code>series</code></dt><dd><p>a character vector that codes each separate group in an alternative way.</p>
</dd>
<dt><code>seriesNum</code></dt><dd><p>like <code>series</code> but numeric.</p>
</dd>
<dt><code>distance.unit</code></dt><dd><p>Measurement unit distance to target</p>
</dd>
<dt><code>point.unit</code></dt><dd><p>Measurement unit (x,y)-coordinates</p>
</dd>
</dl>


<h3>Details</h3>

<p>6 groups with 25 shots each (groups 1-5) or 50 shots (group 6) of .22LR shot at a distance of 50yd. The measurement unit for coordinates is inch, for distance yards. <br />
Groups 1-3 shot with a Stiller Copperhead action with Shilen Octagon Barrel. Group 4-5 shot with a Baity Falcon action with Shilen Ratchet Barrel. Group 6 shot with a Stiller 2500X action with Shilen Octagon Barrel. <br />
This data frame is like those returned by <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or <code><a href="#topic+readDataMisc">readDataMisc</a></code> with option <code>combine=TRUE</code>. <br />
Data courtesy of Larry Landercasper, 2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFlandy04)
str(DFlandy04)
</code></pre>

<hr>
<h2 id='DFlistCm'>List containing several data frames with bullet hole data</h2><span id='topic+DFlistCm'></span>

<h3>Description</h3>

<p>Example list containing several data frames with bullet hole data as produced by <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or by <code><a href="#topic+readDataMisc">readDataMisc</a></code> with option <code>combine=FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DFlistCm)</code></pre>


<h3>Details</h3>

<p>Several groups of shooting a 9x19mm pistol at 25m. The measurement unit for coordinates is cm, for distance meters. <br />
This list can be used as an argument for <code><a href="#topic+combineData">combineData</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+readDataMisc">readDataMisc</a></code>,
<code><a href="#topic+readDataOT1">readDataOT1</a></code>,
<code><a href="#topic+readDataOT2">readDataOT2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFlistCm)
str(DFlistCm)

## combine list of data frames to one single data frame
DFcm &lt;- combineData(DFlistCm)
str(DFcm)
</code></pre>

<hr>
<h2 id='DFsavage'>Combined bullet hole data</h2><span id='topic+DFsavage'></span>

<h3>Description</h3>

<p>Example of a combined data frame from several original files, each with one group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DFsavage)</code></pre>


<h3>Format</h3>

<p>A data frame with 180 observations on the following 10 variables.
</p>

<dl>
<dt><code>point.x</code></dt><dd><p>a numerical vector of absolute x-coordinates of bullet holes.</p>
</dd>
<dt><code>point.y</code></dt><dd><p>a numerical vector of absolute y-coordinates of bullet holes.</p>
</dd>
<dt><code>aim.x</code></dt><dd><p>a numerical vector of x-coordinates giving the point of aim.</p>
</dd>
<dt><code>aim.y</code></dt><dd><p>a numerical vector of y-coordinates giving the of point of aim.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numerical vector giving the distance to the target.</p>
</dd>
<dt><code>group</code></dt><dd><p>a factor with level <code>1</code>. This is the original <code>Group</code> variable as defined by OnTarget PC/TDS.</p>
</dd>
<dt><code>bullet</code></dt><dd><p>a character vector describing the bullet type.</p>
</dd>
<dt><code>origin</code></dt><dd><p>a factor with levels <code>1</code> ... <code>9</code>. This factor codes from which original output file the data is.</p>
</dd>
<dt><code>orgser</code></dt><dd><p>a factor with levels <code>1.1</code> ... <code>9.1</code>. This factor results from <code><a href="base.html#topic+droplevels">droplevels</a>(<a href="base.html#topic+interaction">interaction</a>(Origin, Group))</code>, and codes each separate group across original files. The order of the factor levels is alphabetical.</p>
</dd>
<dt><code>series</code></dt><dd><p>a factor with levels <code>1</code> ... <code>9</code>. This factor codes each separate group as defined by <code>orgser</code>, but more conveniently as a number that runs consecutively across original files.</p>
</dd>
<dt><code>distance.unit</code></dt><dd><p>Measurement unit distance to target</p>
</dd>
<dt><code>point.unit</code></dt><dd><p>Measurement unit (x,y)-coordinates</p>
</dd>
</dl>



<h3>Details</h3>

<p>Several groups of shooting a Savage 12 FT/R rifle in .308 Win at distances from 100 to 300m. The measurement unit for coordinates is mm, for distance meters. Shots 1-5 in <code>series</code> 4, and shots 1-3 in <code>series</code> 7 moved the scope. <br />
This data frame is like those returned by <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or <code><a href="#topic+readDataMisc">readDataMisc</a></code> with option <code>combine=TRUE</code>. <br />
Data copyright Charles McMillan and Paul McMillan, 2008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFsavage)
str(DFsavage)
</code></pre>

<hr>
<h2 id='DFscar17'>Combined bullet hole data</h2><span id='topic+DFscar17'></span>

<h3>Description</h3>

<p>Example of a data frame from one file with one group of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DFscar17)</code></pre>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 9 variables.
</p>

<dl>
<dt><code>group</code></dt><dd><p>a factor with level <code>1</code>.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numerical vector giving the distance to the target.</p>
</dd>
<dt><code>aim.x</code></dt><dd><p>a numerical vector of x-coordinates giving the point of aim.</p>
</dd>
<dt><code>aim.y</code></dt><dd><p>a numerical vector of y-coordinates giving the of point of aim.</p>
</dd>
<dt><code>point.x</code></dt><dd><p>a numerical vector of absolute x-coordinates of bullet holes.</p>
</dd>
<dt><code>point.y</code></dt><dd><p>a numerical vector of absolute y-coordinates of bullet holes.</p>
</dd>
<dt><code>origin</code></dt><dd><p>a factor with level <code>1</code>. This factor codes from which original output file the data is.</p>
</dd>
<dt><code>orgser</code></dt><dd><p>a factor with level <code>1.1</code>. This factor results from <code><a href="base.html#topic+droplevels">droplevels</a>(<a href="base.html#topic+interaction">interaction</a>(origin, group))</code>, and codes each separate group across original files. The order of the factor levels is alphabetical.</p>
</dd>
<dt><code>series</code></dt><dd><p>a factor with levels <code>1</code>. This factor codes each separate group as defined by <code>orgser</code>, but more conveniently as a number that runs consecutively across original files.</p>
</dd>
<dt><code>distance.unit</code></dt><dd><p>Measurement unit distance to target</p>
</dd>
<dt><code>point.unit</code></dt><dd><p>Measurement unit (x,y)-coordinates</p>
</dd>
</dl>



<h3>Details</h3>

<p>One group of shooting an FN SCAR 17 rifle in .308 Win at 100yd. The measurement unit for coordinates is inch, for distance yards. <br />
This data frame is like those returned by <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or <code><a href="#topic+readDataMisc">readDataMisc</a></code> with option <code>combine=TRUE</code>. <br />
Data courtesy of David Bookstaber, 2013. <code>http://ballistipedia.com/</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFscar17)
str(DFscar17)
</code></pre>

<hr>
<h2 id='DFtalon'>Combined bullet hole data</h2><span id='topic+DFtalon'></span>

<h3>Description</h3>

<p>Example of a combined data frame from several original files, each file containing one group.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DFtalon)</code></pre>


<h3>Format</h3>

<p>A data frame with 180 observations on the following 10 variables.
</p>

<dl>
<dt><code>point.x</code></dt><dd><p>a numerical vector of absolute x-coordinates of bullet holes.</p>
</dd>
<dt><code>point.y</code></dt><dd><p>a numerical vector of absolute y-coordinates of bullet holes.</p>
</dd>
<dt><code>aim.x</code></dt><dd><p>a numerical vector of x-coordinates giving the point of aim.</p>
</dd>
<dt><code>aim.y</code></dt><dd><p>a numerical vector of y-coordinates giving the of point of aim.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numerical vector giving the distance to the target.</p>
</dd>
<dt><code>group</code></dt><dd><p>a factor with level <code>1</code>. This is the original <code>Group</code> variable as defined by OnTarget PC/TDS.</p>
</dd>
<dt><code>bullet</code></dt><dd><p>a character vector describing the bullet type.</p>
</dd>
<dt><code>origin</code></dt><dd><p>a factor with levels <code>1</code> ... <code>9</code>. This factor codes from which original output file the data is.</p>
</dd>
<dt><code>orgser</code></dt><dd><p>a factor with levels <code>1.1</code> ... <code>9.1</code>. This factor results from <code><a href="base.html#topic+droplevels">droplevels</a>(<a href="base.html#topic+interaction">interaction</a>(Origin, Group))</code>, and codes each separate group across original files. The order of the factor levels is alphabetical.</p>
</dd>
<dt><code>series</code></dt><dd><p>a factor with levels <code>1</code> ... <code>9</code>. This factor codes each separate group as defined by <code>orgser</code>, but more conveniently as a number that runs consecutively across original files.</p>
</dd>
<dt><code>distance.unit</code></dt><dd><p>Measurement unit distance to target</p>
</dd>
<dt><code>point.unit</code></dt><dd><p>Measurement unit (x,y)-coordinates</p>
</dd>
</dl>



<h3>Details</h3>

<p>Several groups of shooting a Talon SS air rifle at 10m. The measurement unit for coordinates is mm, for distance meters. <br />
This data frame is like those returned by <code><a href="#topic+readDataOT1">readDataOT1</a></code>, <code><a href="#topic+readDataOT2">readDataOT2</a></code>, or <code><a href="#topic+readDataMisc">readDataMisc</a></code> with option <code>combine=TRUE</code>. <br />
Data copyright Charles McMillan and Paul McMillan, 2008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+analyzeGroup">analyzeGroup</a></code>,
<code><a href="#topic+compareGroups">compareGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFtalon)
str(DFtalon)
</code></pre>

<hr>
<h2 id='drawBox'>Draw an axis-aligned box</h2><span id='topic+drawBox'></span><span id='topic+drawBox.list'></span><span id='topic+drawBox.default'></span>

<h3>Description</h3>

<p>Adds an axis-aligned box to an existing plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawBox(x, fg = par('fg'), bg = NA,
        colCtr = NA, lty = par('lty'), lwd = par('lwd'),
        pch = par('pch'), cex = par('cex'))

## S3 method for class 'list'
drawBox(x, fg = par('fg'), bg = NA,
        colCtr = NA, lty = par('lty'), lwd = par('lwd'),
        pch = par('pch'), cex = par('cex'))

## Default S3 method:
drawBox(x, fg = par('fg'), bg = NA,
        colCtr = NA, lty = par('lty'), lwd = par('lwd'),
        pch = par('pch'), cex = par('cex'))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawBox_+3A_x">x</code></td>
<td>
<p>either a list with component <code>pts</code> as returned by <code><a href="#topic+getBoundingBox">getBoundingBox</a></code>, or a vector giving coordinates xleft, ybottom, xright, ytop.</p>
</td></tr>
<tr><td><code id="drawBox_+3A_fg">fg</code></td>
<td>
<p>color of the box' rim.</p>
</td></tr>
<tr><td><code id="drawBox_+3A_bg">bg</code></td>
<td>
<p>the box' fill color. Set to <code>NA</code> for a fully transparent box.</p>
</td></tr>
<tr><td><code id="drawBox_+3A_colctr">colCtr</code></td>
<td>
<p>color of the center point. Set to <code>NA</code> to omit.</p>
</td></tr>
<tr><td><code id="drawBox_+3A_lty">lty</code></td>
<td>
<p>line type of the box.</p>
</td></tr>
<tr><td><code id="drawBox_+3A_lwd">lwd</code></td>
<td>
<p>line width of the box.</p>
</td></tr>
<tr><td><code id="drawBox_+3A_pch">pch</code></td>
<td>
<p>symbol used for the center of the box.</p>
</td></tr>
<tr><td><code id="drawBox_+3A_cex">cex</code></td>
<td>
<p>magnification factor for the symbol used for the center of the box.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly a wrapper for <code><a href="graphics.html#topic+rect">rect</a></code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+getBoundingBox">getBoundingBox</a></code>,
<code><a href="graphics.html#topic+rect">rect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy  &lt;- matrix(round(rnorm(20, 100, 15), 1), ncol=2)
(bb &lt;- getBoundingBox(xy))

plot(xy, asp=1, pch=16)
drawBox(bb, fg='blue', colCtr='blue', pch=4, cex=2)
</code></pre>

<hr>
<h2 id='drawBox2'>Draw an oriented box</h2><span id='topic+drawBox2'></span><span id='topic+drawBox2.list'></span><span id='topic+drawBox2.default'></span>

<h3>Description</h3>

<p>Adds an oriented box to an existing plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawBox2(x, fg = par('fg'), bg = NA, colCtr = NA,
         lty = par('lty'), lwd = par('lwd'), pch = par('pch'),
         cex = par('cex'))

## S3 method for class 'list'
drawBox2(x, fg = par('fg'), bg = NA, colCtr = NA,
         lty = par('lty'), lwd = par('lwd'), pch = par('pch'),
         cex = par('cex'))

## Default S3 method:
drawBox2(x, fg = par('fg'), bg = NA, colCtr = NA,
         lty = par('lty'), lwd = par('lwd'), pch = par('pch'),
         cex = par('cex'))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawBox2_+3A_x">x</code></td>
<td>
<p>either a list with component <code>pts</code> as returned by <code><a href="#topic+getMinBBox">getMinBBox</a></code>, or a numerical (4 x 2)-matrix giving the (x,y)-coordinates of the ordered box vertices.</p>
</td></tr>
<tr><td><code id="drawBox2_+3A_fg">fg</code></td>
<td>
<p>color of the box' rim.</p>
</td></tr>
<tr><td><code id="drawBox2_+3A_bg">bg</code></td>
<td>
<p>the box' fill color. Set to <code>NA</code> for a fully transparent box.</p>
</td></tr>
<tr><td><code id="drawBox2_+3A_colctr">colCtr</code></td>
<td>
<p>color of the center point. Set to <code>NA</code> to omit.</p>
</td></tr>
<tr><td><code id="drawBox2_+3A_lty">lty</code></td>
<td>
<p>line type of the box.</p>
</td></tr>
<tr><td><code id="drawBox2_+3A_lwd">lwd</code></td>
<td>
<p>line width of the box.</p>
</td></tr>
<tr><td><code id="drawBox2_+3A_pch">pch</code></td>
<td>
<p>symbol used for the center of the box.</p>
</td></tr>
<tr><td><code id="drawBox2_+3A_cex">cex</code></td>
<td>
<p>magnification factor for the symbol used for the center of the box.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly a wrapper for <code><a href="graphics.html#topic+polygon">polygon</a></code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMinBBox">getMinBBox</a></code>,
<code><a href="graphics.html#topic+polygon">polygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy  &lt;- matrix(round(rnorm(20, 100, 15), 1), ncol=2)
(bb &lt;- getMinBBox(xy))

plot(xy, xlim=range(c(xy[ , 1], bb$pts[ , 1])),
         ylim=range(c(xy[ , 2], bb$pts[ , 2])), asp=1, pch=16)
drawBox2(bb, fg='blue', colCtr='blue', pch=4, cex=2)
</code></pre>

<hr>
<h2 id='drawCircle'>Draw a circle</h2><span id='topic+drawCircle'></span><span id='topic+drawCircle.list'></span><span id='topic+drawCircle.default'></span>

<h3>Description</h3>

<p>Adds a circle to an existing plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawCircle(x, radius, nv = 100, fg = par('fg'), bg = NA,
           colCtr = NA, lty = par('lty'), lwd = par('lwd'),
           pch = par('pch'), cex = par('cex'))

## S3 method for class 'list'
drawCircle(x, radius, nv = 100, fg = par('fg'), bg = NA,
           colCtr = NA, lty = par('lty'), lwd = par('lwd'),
           pch = par('pch'), cex = par('cex'))

## Default S3 method:
drawCircle(x, radius, nv = 100, fg = par('fg'), bg = NA,
           colCtr = NA, lty = par('lty'), lwd = par('lwd'),
           pch = par('pch'), cex = par('cex'))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawCircle_+3A_x">x</code></td>
<td>
<p>either a numerical vector giving the center's (x,y)-coordinates or a list with the components <code>ctr</code> and <code>rad</code> as returned by <code><a href="#topic+getMinCircle">getMinCircle</a></code>.</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_radius">radius</code></td>
<td>
<p>a numerical vector giving the circle's radius.</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_nv">nv</code></td>
<td>
<p>number of vertices in the approximating polygon.</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_fg">fg</code></td>
<td>
<p>color of the circle's rim.</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_bg">bg</code></td>
<td>
<p>the circle's fill color. Set to <code>NA</code> for a fully transparent circle.</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_colctr">colCtr</code></td>
<td>
<p>color of the center point. Set to <code>NA</code> to omit.</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_lty">lty</code></td>
<td>
<p>line type of the circle.</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_lwd">lwd</code></td>
<td>
<p>line width of the circle.</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_pch">pch</code></td>
<td>
<p>symbol used for the center of the circle.</p>
</td></tr>
<tr><td><code id="drawCircle_+3A_cex">cex</code></td>
<td>
<p>magnification factor for the symbol used for the center of the circle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly a wrapper for <code><a href="graphics.html#topic+polygon">polygon</a></code>. To draw more than a few circles efficiently, use <code><a href="graphics.html#topic+symbols">symbols</a></code> instead.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+polygon">polygon</a></code>,
<code><a href="graphics.html#topic+symbols">symbols</a></code>,
<code><a href="#topic+getMinCircle">getMinCircle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- c(1, 2)                 # circle center
c2 &lt;- c(2, 3)                 # another circle center
r1 &lt;- 2                       # circle radius
r2 &lt;- 0.5                     # another circle radius

# determine axis limits so that circles will be visible
xLims &lt;- c1[1] + c(-r1, r1)
yLims &lt;- c1[2] + c(-r1, r1)

plot(c1[1], c1[2], type='n', asp=1, xlim=xLims, ylim=yLims)
drawCircle(c1, r1, fg='blue', colCtr='blue', pch=19)
drawCircle(c2, r2, fg='red', bg='red', colCtr='black', pch=4)
</code></pre>

<hr>
<h2 id='drawEllipse'>Draw an ellipse</h2><span id='topic+drawEllipse'></span><span id='topic+drawEllipse.list'></span><span id='topic+drawEllipse.default'></span>

<h3>Description</h3>

<p>Adds an ellipse to an existing plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawEllipse(x, shape, radius, nv = 100, axes = FALSE,
            fg = par('fg'), bg = NA, colCtr = NA, lty = par('lty'),
            lwd = par('lwd'), pch = par('pch'), cex = par('cex'))

## S3 method for class 'list'
drawEllipse(x, shape, radius, nv = 100, axes = FALSE,
            fg = par('fg'), bg = NA, colCtr = NA, lty = par('lty'),
            lwd = par('lwd'), pch = par('pch'), cex = par('cex'))

## Default S3 method:
drawEllipse(x, shape, radius, nv = 100, axes = FALSE,
            fg = par('fg'), bg = NA, colCtr = NA, lty = par('lty'),
            lwd = par('lwd'), pch = par('pch'), cex = par('cex'))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawEllipse_+3A_x">x</code></td>
<td>
<p>either a numerical 2-vector giving the (x,y)-coordinates of the center or a list with the components <code>ctr</code>, <code>cov</code> and <code>magFac</code> as returned by <code><a href="#topic+getConfEll">getConfEll</a></code> or <code><a href="#topic+getMinEllipse">getMinEllipse</a></code>.</p>
</td></tr>
<tr><td><code id="drawEllipse_+3A_shape">shape</code></td>
<td>
<p>a numerical symmetric (2 x 2)-matrix whose eigen-structure determines the ellipse's shape.</p>
</td></tr>
<tr><td><code id="drawEllipse_+3A_radius">radius</code></td>
<td>
<p>a numerical value giving the ellipse's magnification factor.</p>
</td></tr>
<tr><td><code id="drawEllipse_+3A_nv">nv</code></td>
<td>
<p>number of vertices in the approximating polygon.</p>
</td></tr>
<tr><td><code id="drawEllipse_+3A_axes">axes</code></td>
<td>
<p>logical: should ellipse axes be drawn?</p>
</td></tr>
<tr><td><code id="drawEllipse_+3A_fg">fg</code></td>
<td>
<p>color of the ellipse's rim.</p>
</td></tr>
<tr><td><code id="drawEllipse_+3A_bg">bg</code></td>
<td>
<p>the ellipse's fill color. Set to <code>NA</code> for a fully transparent ellipse.</p>
</td></tr>
<tr><td><code id="drawEllipse_+3A_colctr">colCtr</code></td>
<td>
<p>color of the center point. Set to <code>NA</code> to omit.</p>
</td></tr>
<tr><td><code id="drawEllipse_+3A_lty">lty</code></td>
<td>
<p>line type of the ellipse.</p>
</td></tr>
<tr><td><code id="drawEllipse_+3A_lwd">lwd</code></td>
<td>
<p>line width of the ellipse.</p>
</td></tr>
<tr><td><code id="drawEllipse_+3A_pch">pch</code></td>
<td>
<p>symbol used for the center of the ellipse.</p>
</td></tr>
<tr><td><code id="drawEllipse_+3A_cex">cex</code></td>
<td>
<p>magnification factor for the symbol used for the center of the ellipse.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly a wrapper for <code><a href="graphics.html#topic+polygon">polygon</a></code>.</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+polygon">polygon</a></code>,
<code><a href="#topic+getConfEll">getConfEll</a></code>,
<code><a href="#topic+getMinEllipse">getMinEllipse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## error ellipse for a set of points
xy &lt;- matrix(round(rnorm(100, 0, 8), 2), ncol=2)
ce &lt;- getConfEll(xy)
plot(xy, pch=16, asp=1)
drawEllipse(ce, radius=1, axes=TRUE, fg='blue', colCtr='blue',
            lwd=2, pch=4, cex=2)
</code></pre>

<hr>
<h2 id='drawGroup'>Draw a group of bullet holes with additional measures</h2><span id='topic+drawGroup'></span><span id='topic+drawGroup.data.frame'></span><span id='topic+drawGroup.default'></span>

<h3>Description</h3>

<p>Draws a group with scaled bullet holes on a target background. Spread measures can be selected individually.</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawGroup(xy, center = FALSE, xyTopLeft = TRUE,
          bb = FALSE, bbMin = FALSE, bbDiag = FALSE,
          minCirc = FALSE, minEll = FALSE, maxSpread = FALSE,
          meanDist = FALSE, confEll = FALSE,
          CEP = FALSE, ringID = FALSE, valueID = TRUE, doRob = FALSE,
          level = 0.95, scaled = TRUE, caliber = 9, dstTarget, conversion,
          unit = 'unit', alpha = 0.5, target)

## S3 method for class 'data.frame'
drawGroup(xy, center = FALSE, xyTopLeft = TRUE,
          bb = FALSE, bbMin = FALSE, bbDiag = FALSE,
          minCirc = FALSE, minEll = FALSE,
          maxSpread = FALSE, meanDist = FALSE, confEll = FALSE,
          CEP = FALSE, ringID = FALSE, valueID = TRUE, doRob = FALSE,
          level = 0.95, scaled = TRUE, caliber = 9, dstTarget, conversion,
          unit = 'unit', alpha = 0.5, target)

## Default S3 method:
drawGroup(xy, center = FALSE, xyTopLeft = TRUE,
          bb = FALSE, bbMin = FALSE, bbDiag = FALSE,
          minCirc = FALSE, minEll = FALSE,
          maxSpread = FALSE, meanDist = FALSE, confEll = FALSE,
          CEP = FALSE, ringID = FALSE, valueID = TRUE, doRob = FALSE,
          level = 0.95, scaled = TRUE, caliber = 9, dstTarget, conversion,
          unit = 'unit', alpha = 0.5, target)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawGroup_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x 2)-matrix with the (x,y)-coordinates of n points (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code> as well as <code>aim.x</code>, <code>aim.y</code> giving the point of aim. If missing, point of aim is assumed to be in (0,0).</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_center">center</code></td>
<td>
<p>logical: center groups to mean (0,0) first? If variable <code>series</code> does not exist, all shots are treated as belonging to the same group. Only available in method <code>drawGroup.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_xytopleft">xyTopLeft</code></td>
<td>
<p>logical: is the origin of the absolute coordinate system in the top-left corner? This is the default for data exported by OnTarget PC/TDS. If an (n x 2)-matrix is supplied for <code>xy</code>, point of aim is assumed to be in (0,0).</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_bb">bb</code></td>
<td>
<p>logical: draw bounding box?</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_bbmin">bbMin</code></td>
<td>
<p>logical: draw minimum-area bounding box?</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_bbdiag">bbDiag</code></td>
<td>
<p>logical: draw bounding box diagonal?</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_mincirc">minCirc</code></td>
<td>
<p>logical: draw minimum enclosing circle?</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_minell">minEll</code></td>
<td>
<p>logical: draw minimum enclosing ellipse?</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_maxspread">maxSpread</code></td>
<td>
<p>logical: draw maximum spread?</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_meandist">meanDist</code></td>
<td>
<p>logical: draw circle with mean distance to group center?</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_confell">confEll</code></td>
<td>
<p>logical: draw confidence ellipse with coverage <code>level</code>?</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_cep">CEP</code></td>
<td>
<p>draw estimate of CEP circle with coverage <code>level</code>? Either logical or a string defining the CEP type. See <code><a href="#topic+getCEP">getCEP</a></code>.</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_ringid">ringID</code></td>
<td>
<p>logical: identify and display the ring count for each shot?</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_valueid">valueID</code></td>
<td>
<p>logical: display numerical values of calculated measures in the diagram?</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_dorob">doRob</code></td>
<td>
<p>logical: use robust estimation of group center and confidence ellipse?</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_scaled">scaled</code></td>
<td>
<p>logical: draw bullet holes to scale?</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_caliber">caliber</code></td>
<td>
<p>a numerical value indicating the bullet diameter in mm.</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_level">level</code></td>
<td>
<p>a numerical vector giving the coverages of the confidence ellipses and CEPs.</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in <code>xy</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Acts as override if variables <code>dist.unit</code> and <code>point.unit</code> are already included in <code>xy</code>. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_unit">unit</code></td>
<td>
<p>Measurement unit for the diagram. Defalt <code>'unit'</code> indicates that the measurement unit given in <code>conversion</code> should be used. Possible values are <code>'unit', 'm', 'cm', 'mm', 'yd', 'ft', 'in', 'deg', 'MOA', 'SMOA', 'rad', 'mrad', 'mil'</code>.</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_alpha">alpha</code></td>
<td>
<p>a numerical value in [0,1] which controls the alpha blending for simulated transparency used to draw the bullet holes</p>
</td></tr>
<tr><td><code id="drawGroup_+3A_target">target</code></td>
<td>
<p>a character string like 'ISSF_100m' indicating the target type to be drawn in the scatterplot. See <code><a href="#topic+targets">targets</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a list with the following components, all converted to <code>unit</code> (if they were requested):
</p>
<table>
<tr><td><code>xy</code></td>
<td>
<p>(x,y)-coordinates converted to <code>unit</code>.</p>
</td></tr>
<tr><td><code>ctr</code></td>
<td>
<p>(x,y)-offset of group center relative to point of aim in <code>unit</code> (robust with <code>doRob=TRUE</code>).</p>
</td></tr>
<tr><td><code>bb</code></td>
<td>
<p>bounding box as returned by <code><a href="#topic+getBoundingBox">getBoundingBox</a></code>.</p>
</td></tr>
<tr><td><code>bbMin</code></td>
<td>
<p>minimum-area bounding box as returned by <code><a href="#topic+getMinBBox">getMinBBox</a></code>.</p>
</td></tr>
<tr><td><code>bbDiag</code></td>
<td>
<p>length of diagonal of bounding box.</p>
</td></tr>
<tr><td><code>bbMinDiag</code></td>
<td>
<p>length of diagonal of minimum-area bounding box.</p>
</td></tr>
<tr><td><code>minCirc</code></td>
<td>
<p>minimum enclosing circle as returned by <code><a href="#topic+getMinCircle">getMinCircle</a></code>.</p>
</td></tr>
<tr><td><code>minEll</code></td>
<td>
<p>minimum enclosing ellipse as returned by <code><a href="#topic+getMinEllipse">getMinEllipse</a></code>.</p>
</td></tr>
<tr><td><code>maxPairDist</code></td>
<td>
<p>maximum pairwise distance between points (center-to-center, = maximum spread).</p>
</td></tr>
<tr><td><code>meanDist</code></td>
<td>
<p>mean distance to group center.</p>
</td></tr>
<tr><td><code>confEll</code></td>
<td>
<p>confidence ellipse with coverage <code>level</code> as returned by <code><a href="#topic+getConfEll">getConfEll</a></code> (robust with <code>doRob=TRUE</code>).</p>
</td></tr>
<tr><td><code>CEP</code></td>
<td>
<p>Rayleigh estimate for the circular error probable CEP with coverage <code>level</code>.</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>Definition of the selected target in original and converted measurement units.</p>
</td></tr>
<tr><td><code>ringCount</code></td>
<td>
<p>Simulated and maximum ring count as returned by <code><a href="#topic+simRingCount">simRingCount</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+getBoundingBox">getBoundingBox</a></code>,
<code><a href="#topic+getMinBBox">getMinBBox</a></code>,
<code><a href="#topic+getMinCircle">getMinCircle</a></code>,
<code><a href="#topic+getMinEllipse">getMinEllipse</a></code>,
<code><a href="#topic+getMaxPairDist">getMaxPairDist</a></code>,
<code><a href="#topic+getDistToCtr">getDistToCtr</a></code>,
<code><a href="#topic+getConfEll">getConfEll</a></code>,
<code><a href="#topic+drawBox">drawBox</a></code>,
<code><a href="#topic+drawBox2">drawBox2</a></code>,
<code><a href="#topic+drawCircle">drawCircle</a></code>,
<code><a href="#topic+drawEllipse">drawEllipse</a></code>,
<code><a href="#topic+targets">targets</a></code>,
<code><a href="#topic+drawTarget">drawTarget</a></code>,
<code><a href="#topic+simRingCount">simRingCount</a></code>,
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># draw group in MOA
dg &lt;- drawGroup(DFcciHV, xyTopLeft=TRUE, bb=TRUE, minCirc=TRUE,
                confEll=TRUE, maxSpread=TRUE, caliber=5.56, unit='MOA',
                dstTarget=100, conversion='yd2in', target='BDS9')

# mininum enclosing circle in MOA
dg$minCirc

# show Grubbs-Patnaik CEP estimator for mulitple levels
drawGroup(DF300BLKhl, CEP="GrubbsPatnaik", level=c(0.5, 0.9, 0.95),
          dstTarget=100, conversion="yd2in", caliber=7.62)
</code></pre>

<hr>
<h2 id='drawTarget'>Draw a target pattern</h2><span id='topic+drawTarget'></span>

<h3>Description</h3>

<p>Draws a target pattern - either from the name of a pre-specified target type or from a supplied list defining the target.</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawTarget(x, unit, dstTarget, conversion,
           add = FALSE, cex = par('cex'))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawTarget_+3A_x">x</code></td>
<td>
<p>either a character value with the name of a target in <code><a href="#topic+targets">targets</a></code> or a list with a target definition containing the same components as those in <code><a href="#topic+targets">targets</a></code> (see below).</p>
</td></tr>
<tr><td><code id="drawTarget_+3A_unit">unit</code></td>
<td>
<p>the measurement unit that should be used in the plot. Possible values are <code>'cm', 'mm', 'm', 'in', 'ft', 'yd', 'deg', 'MOA', 'SMOA', 'rad', 'mrad', 'mil'</code>.</p>
</td></tr>
<tr><td><code id="drawTarget_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value with the distance to the target - used in MOA calculation. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="drawTarget_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates - used in MOA calculation. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="drawTarget_+3A_add">add</code></td>
<td>
<p>logical: add to existing plot or create new plot?</p>
</td></tr>
<tr><td><code id="drawTarget_+3A_cex">cex</code></td>
<td>
<p>numerical value specifying the magnification factor for plotting the ring numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a list with (at least) the following components defining the target:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>target name.</p>
</td></tr>
<tr><td><code>unitTarget</code></td>
<td>
<p>measurement unit for ring diameters and radii.</p>
</td></tr>
<tr><td><code>nRings</code></td>
<td>
<p>number of rings.</p>
</td></tr>
<tr><td><code>maxCount</code></td>
<td>
<p>highest ring count for scoring.</p>
</td></tr>
<tr><td><code>ringD10</code></td>
<td>
<p>diameter of ring number 10 (highest-valued ring).</p>
</td></tr>
<tr><td><code>ringD10i</code></td>
<td>
<p>diameter of sub-division of ring number 10 (Innenzehn). If target has no sub-division, equal to <code>ringD10</code>.</p>
</td></tr>
<tr><td><code>ringW</code></td>
<td>
<p>width of the remaining rings number 9, 8, 7, ...</p>
</td></tr>
<tr><td><code>cols</code></td>
<td>
<p><code>nRings</code>+1 colors of the rings - right half of the target, starting with the sub-division of ring number 10 and going outwards.</p>
</td></tr>
<tr><td><code>colsTxt</code></td>
<td>
<p><code>nRings</code>-1 colors of the ring numbers, starting with ring number 9 and going outwards.</p>
</td></tr>
<tr><td><code>ringR</code></td>
<td>
<p><code>nRings</code>+1 ring radii, including sub-division of ring number 10.</p>
</td></tr>
<tr><td><code>unitConv</code></td>
<td>
<p>measurement unit for <code>ringD10u</code>, <code>ringD10iu</code>, <code>ringWu</code>, <code>ringRu</code> as defined by <code>unit</code>.</p>
</td></tr>
<tr><td><code>ringD10u</code></td>
<td>
<p>diameter of ring number 10 converted to <code>unit</code>.</p>
</td></tr>
<tr><td><code>ringD10iu</code></td>
<td>
<p>diameter of sub-division of ring number 10 (Innenzehn) converted to <code>unit</code>.</p>
</td></tr>
<tr><td><code>ringWu</code></td>
<td>
<p>width of the remaining rings number 9, 8, 7, ... converted to <code>unit</code>.</p>
</td></tr>
<tr><td><code>ringRu</code></td>
<td>
<p><code>nRings</code>+1 ring radii, including sub-division of ring number 10, converted to <code>unit</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+targets">targets</a></code>,
<code><a href="#topic+drawGroup">drawGroup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># draw ISSF 300m target in inch
trgt &lt;- drawTarget('ISSF_300m', unit='in')

# target definition
trgt
</code></pre>

<hr>
<h2 id='efficiency'>Estimate number of required groups for given CI level and width</h2><span id='topic+efficiency'></span>

<h3>Description</h3>

<p>Estimates the approximate number of required groups for a given number of shots per group, confidence interval (CI) level and CI width - when using the Rayleigh sigma estimator based on (x,y)-coordinates, or a range statistic such as extreme spread, figure of merit, or the bounding box diagonal. The function may also be used to obtain the estimated CI width when the number of shots per group and the number of groups is given. This functions assumes a circular bivariate normal shot distribution with 0 mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiency(n, nGroups, CIlevel=0.95, CIwidth,
           stat=c("Rayleigh", "ES", "FoM", "D"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiency_+3A_n">n</code></td>
<td>
<p>a vector of integers between 2 and 100. Number of shots in each group.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_ngroups">nGroups</code></td>
<td>
<p>integer between 1 and 10. Number of groups over which individually-measured statistics will be averaged - when given, <code>CIwidth</code> must be missing, and the estimated CI width that can be achieved with the given <code>n</code>, <code>nGroups</code> and chosen statistic is returned.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_cilevel">CIlevel</code></td>
<td>
<p>confidence level - coverage probability of the CI.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_ciwidth">CIwidth</code></td>
<td>
<p>CI width as a fraction of the mean of the chosen statistic for given <code>n</code> and <code>nGroups</code>. In other sources (see details) <code>CIwidth/2</code> is also called <code>E</code> - the width as a fraction of the mean on either side. When given, <code>nGroups</code> must be missing, and the estimated required number of groups to achieve the desired CI width for the CI coverage probability <code>CIlevel</code> is returned.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_stat">stat</code></td>
<td>
<p>a character vector with elements <code>"Rayleigh"</code> (Rayleigh sigma), <code>"ES"</code> (extreme spread), <code>"FoM"</code> (figure of merit), or <code>"D"</code> (bounding box diagonal) indicating which statistic would be measured.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the lookup table <code><a href="#topic+DFdistr">DFdistr</a></code> with results form a Monte Carlo simulation. If the value of <code>n</code> is not among those simulated (but is less than 100), a spline interpolation between the neighboring simulated values of the statistic's coefficient of variation is used.
</p>
<p>The number of required groups is approximate as the calculation assumes a normal distribution for the mean statistic. Details for the calculation can be found under
</p>
<p><a href="http://ballistipedia.com/index.php?title=Range_Statistics">http://ballistipedia.com/index.php?title=Range_Statistics</a>
</p>
<p><a href="http://www.geoffrey-kolbe.com/articles/rimfire_accuracy/group_statistics.htm">http://www.geoffrey-kolbe.com/articles/rimfire_accuracy/group_statistics.htm</a>
</p>
<p><a href="http://ballistipedia.com/images/3/32/Sitton_1990.pdf">http://ballistipedia.com/images/3/32/Sitton_1990.pdf</a>
</p>
<p>If package <code>shiny</code> is installed, an interactive web app for this functionality can be run with <code>runGUI("range")</code>.
</p>


<h3>Value</h3>

<p>When <code>CIwidth</code> is given, a data frame with the estimated number of required groups and total shots to achieve the given <code>CIlevel</code>.
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>Number of shots per group.</p>
</td></tr>
<tr><td><code>nGroupsReq</code></td>
<td>
<p>Number of required groups - as calculated (fractional number).</p>
</td></tr>
<tr><td><code>nGroupsReqCeil</code></td>
<td>
<p>Number of required groups - rounded upwards to a whole number.</p>
</td></tr>
<tr><td><code>nShotsReq</code></td>
<td>
<p>Total number of required shots - using <code>nGroupsReq</code> as calculated (fractional number).</p>
</td></tr>
<tr><td><code>nShotsReqCeil</code></td>
<td>
<p>Total number of required shots - using <code>nGroupsReq</code> rounded upwards to a whole number.</p>
</td></tr>
<tr><td><code>CIlevel</code></td>
<td>
<p>The CI level</p>
</td></tr>
<tr><td><code>CIwidth</code></td>
<td>
<p>The CI width</p>
</td></tr>
</table>
<p>When <code>nGroups</code> is given, a data frame with the estimated CI width required to achieve the desired <code>CIlevel</code>.
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>Number of shots per group.</p>
</td></tr>
<tr><td><code>nGroups</code></td>
<td>
<p>Number of groups that will be averaged over.</p>
</td></tr>
<tr><td><code>nShots</code></td>
<td>
<p>The total number of shots</p>
</td></tr>
<tr><td><code>CIlevel</code></td>
<td>
<p>The CI level</p>
</td></tr>
<tr><td><code>CIwidth</code></td>
<td>
<p>Required CI width as a fraction of the mean statistic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+DFdistr">DFdistr</a></code>,
<code><a href="#topic+range2sigma">range2sigma</a></code>,
<code><a href="#topic+getRayParam">getRayParam</a></code>,
<code><a href="#topic+getMaxPairDist">getMaxPairDist</a></code>,
<code><a href="#topic+getBoundingBox">getBoundingBox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get required number of shots to achieve 90% CI with
# a CI width of 20% of the mean (10% on either side)
# using 10 shots per group and measuring extreme spread
efficiency(n=10, CIlevel=0.9, CIwidth=0.2, stat="ES")

# as above, but using Rayleigh sigma
efficiency(n=10, CIlevel=0.9, CIwidth=0.2, stat="Rayleigh")

# check that the result for ES is about right
# -&gt; 5% quantile with 10 groups is about 10% below the mean
# -&gt; 95% quantile with 10 groups is about 10% above the mean
with(subset(DFdistr, (n == 10L) &amp; (nGroups == 10L)),
     c(ES_Q050/ES_M, ES_Q950/ES_M))

# get achievable 90% CI width with 10 groups of 5 shots each
# using extreme spread
efficiency(n=5, nGroups=10, CIlevel=0.9, stat="ES")
</code></pre>

<hr>
<h2 id='fromMOA'>Conversion from angular diameter to absolute size</h2><span id='topic+fromMOA'></span>

<h3>Description</h3>

<p>Converts angular diameter (degree, radian, minute of angle MOA = arcminute, Shooter's MOA SMOA, milliradian mrad, NATO mil) to object size.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromMOA(x, dst, conversion,
        type = c('deg', 'rad', 'MOA', 'SMOA', 'mrad', 'mil'))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromMOA_+3A_x">x</code></td>
<td>
<p>a numerical vector of angles.</p>
</td></tr>
<tr><td><code id="fromMOA_+3A_dst">dst</code></td>
<td>
<p>a numerical vector of viewing distances.</p>
</td></tr>
<tr><td><code id="fromMOA_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates. Either a character vector indicating the conversion such as <code>'m2cm'</code> for meter to centimeter, <code>'yd2in'</code> for yards to inches, or <code>'ft2cm'</code> for feet to cm. Imperial (yd, ft, in) and metric units (m, cm, mm) can be freely mixed. Alternatively, a numerical vector giving the multiplication factor for conversion: 100 for m to cm, 36 for yd to in, and 12 for ft to in.</p>
</td></tr>
<tr><td><code id="fromMOA_+3A_type">type</code></td>
<td>
<p>type of angular diameter: <code>'deg'</code> for degree, <code>'rad'</code> for radian, <code>'MOA'</code> for minute of angle, <code>'SMOA'</code> for Shooter's MOA, <code>'mrad'</code> for milliradian, <code>'mil'</code> for NATO mil. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1 MOA (minute of angle, arcmin) = 1/60 degree. Shooter's MOA = SMOA = Inches Per Hundred Yards IPHY. 1 inch at 100 yards = 1 SMOA. 1 milliradian = 1/1000 radian. 1 mil = 2*pi/6400 radian (NATO definition: the circle circumference is divided into 6400 mils). Details are given in the vignette, see <code>vignette('shotGroups') .</code>
</p>
<p>If package <code>shiny</code> is installed, an interactive web app for this functionality can be run with <code>runGUI("angular")</code>.
</p>


<h3>Value</h3>

<p>A numerical vector with the object sizes. The measurement unit is determined by <code>conversion</code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMOA">getMOA</a></code>,
<code><a href="#topic+getDistance">getDistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size &lt;- seq(1, 20, by=5)   # inch
dst  &lt;- 100                # yard
fromMOA(size, dst=dst, conversion='yd2in', type='MOA')

# this should return objSize
MOA &lt;- getMOA(size, dst=dst, conversion='yd2in', type='MOA')
fromMOA(MOA, dst=dst, conversion='yd2in', type='MOA')
        
# SMOA
fromMOA(c(1, 2, 5), dst=100, conversion='yd2in', type='SMOA')

# milliradian
fromMOA(c(1, 2, 5), dst=100, conversion='m2mm', type='mrad')
</code></pre>

<hr>
<h2 id='getBoundingBox'>Bounding box for a set of 2D-points</h2><span id='topic+getBoundingBox'></span><span id='topic+getBoundingBox.data.frame'></span><span id='topic+getBoundingBox.default'></span>

<h3>Description</h3>

<p>Calculates the vertices of the (axis-parallel) bounding box given a set of 2D-coordinates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBoundingBox(xy)

## S3 method for class 'data.frame'
getBoundingBox(xy)

## Default S3 method:
getBoundingBox(xy)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBoundingBox_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x 2)-matrix with the (x,y)-coordinates of n points (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No coordinate transforms are done (unlike in <code><a href="#topic+groupLocation">groupLocation</a></code>, <code><a href="#topic+groupShape">groupShape</a></code>, <code><a href="#topic+groupSpread">groupSpread</a></code>), i.e., origin is not assumed to be in top-left corner, and points are not taken relative to point of aim.</p>


<h3>Value</h3>

<p>A list with the following information about the bounding box:
</p>
<table>
<tr><td><code>pts</code></td>
<td>
<p>a numerical 4-vector giving the coordinates <code>xleft</code>, <code>ybottom</code>, <code>xright</code>, <code>ytop</code>.</p>
</td></tr>
<tr><td><code>width</code></td>
<td>
<p>width of the box.</p>
</td></tr>
<tr><td><code>height</code></td>
<td>
<p>height of the box.</p>
</td></tr>
<tr><td><code>FoM</code></td>
<td>
<p>figure of merit, i.e., the average side length of the box: (<code>width</code> + <code>height</code>) / 2.</p>
</td></tr>
<tr><td><code>diag</code></td>
<td>
<p>length of box diagonal.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+drawBox">drawBox</a></code>,
<code><a href="#topic+getMinBBox">getMinBBox</a></code>,
<code><a href="#topic+getMinCircle">getMinCircle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
bb &lt;- getBoundingBox(DFsavage)

# draw points and bounding box
plot(point.y ~ point.x, data=DFsavage, asp=1, pch=16)
drawBox(bb, fg='blue', colCtr='blue', pch=4, cex=2)

bb$FoM                                   # figure of merit

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(20, 100, 15), 1), ncol=2)
getBoundingBox(xy)

## End(Not run)
</code></pre>

<hr>
<h2 id='getCEP'>Circular Error Probable (CEP) and Spherical Error Probable (SEP)</h2><span id='topic+getCEP'></span><span id='topic+getCEP.data.frame'></span><span id='topic+getCEP.default'></span>

<h3>Description</h3>

<p>Estimates the Circular Error Probable (CEP) or the Spherical Error Probable (SEP). CEP/SEP is defined as the radius of the circle/sphere around the point of aim such that it contains a certain fraction of points of impact, e.g., 50% or 90%.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCEP(xy, CEPlevel=0.5, dstTarget, conversion,
       center = FALSE, accuracy = FALSE, type = 'CorrNormal', doRob = FALSE)

## S3 method for class 'data.frame'
getCEP(xy, CEPlevel=0.5, dstTarget, conversion,
       center = FALSE, accuracy = FALSE, type = 'CorrNormal', doRob = FALSE)

## Default S3 method:
getCEP(xy, CEPlevel=0.5, dstTarget, conversion,
       center = FALSE, accuracy = FALSE, type = 'CorrNormal', doRob = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCEP_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x p)-matrix with the coordinates of n points (1 row of p coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code> (optionally <code>z</code> or <code>point.z</code>).</p>
</td></tr>
<tr><td><code id="getCEP_+3A_ceplevel">CEPlevel</code></td>
<td>
<p>a numerical vector with the coverage values for the CEP/SEP.</p>
</td></tr>
<tr><td><code id="getCEP_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in <code>xy</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="getCEP_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Acts as override if variables <code>dist.unit</code> and <code>point.unit</code> are already included in <code>xy</code>. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="getCEP_+3A_center">center</code></td>
<td>
<p>logical: center groups to mean (0,0) first? If variable <code>series</code> does not exist, all shots are treated as belonging to the same group. Only available in method <code>getCEP.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="getCEP_+3A_accuracy">accuracy</code></td>
<td>
<p>logical: take systematic location bias into account? See details.</p>
</td></tr>
<tr><td><code id="getCEP_+3A_type">type</code></td>
<td>
<p>string vector indicating which CEP/SEP estimate to report. Possible values are <code>'CorrNormal', 'GrubbsPearson', 'GrubbsPatnaik', 'GrubbsLiu', 'Rayleigh', 'Krempasky', 'Ignani', 'RMSE', 'Ethridge', 'RAND', 'Valstar'</code>. See details.</p>
</td></tr>
<tr><td><code id="getCEP_+3A_dorob">doRob</code></td>
<td>
<p>logical: use robust estimation of center and covariance matrix as basis for estimators?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>accuracy=FALSE</code> (default), the reported CEP/SEP estimates do not take into account accuracy, i.e., any systematic location bias. The data is then first centered on the empirical group mean, assumed to coincide with the point of aim. The resulting CEP/SEP-MPI (around Mean Point of Impact) is a pure precision (spread) measure. Set <code>accuracy=TRUE</code> to incorporate systematic accuracy bias such that the point of aim is in the origin 0, possibly offset from the true group center.
</p>

<ul>
<li> <p><code>CorrNormal</code>: For <code>accuracy=FALSE</code> and two-dimensional data, this estimate is based on the correlated bivariate normal distribution re-written in polar coordinates (radius and angle) (see <code><a href="#topic+Hoyt">Hoyt</a></code>). For <code>accuracy=TRUE</code> or three-dimensional data, it is based on the (offset) circle/sphere probabilities for the correlated multivariate normal distribution (DiDonato &amp; Jarnagin, 1961; DiDonato, 1981, see <code><a href="#topic+qmvnEll">qmvnEll</a></code>). This estimate is available for all probability levels.
</p>
</li>
<li> <p><code>GrubbsPearson</code>: The Grubbs-Pearson estimate (Grubbs, 1964) is based on the Pearson three-moment central chi^2-approximation of the true cumulative distribution function of radial error. The eigenvalues of the covariance matrix of shot-coordinates are used as variance estimates since they are the variances of the principal components (the PCA-rotated = decorrelated data). This estimate is available for all probability levels, and generalizes to three dimensions.
</p>
</li>
<li> <p><code>GrubbsPatnaik</code>: The Grubbs-Patnaik estimate (Grubbs, 1964) differs from the Grubbs-Pearson estimate insofar as it is based on the Patnaik two-moment central chi^2-approximation of the true cumulative distribution function of radial error.
</p>
</li>
<li> <p><code>GrubbsLiu</code>: The Grubbs-Liu estimate was not proposed by Grubbs but follows the same principle as his original estimates. It differs from them insofar as it is based on the Liu-Tang-Zhang four-moment non-central chi^2-approximation of the true cumulative distribution function of radial error. For <code>accuracy=FALSE</code>, it is identical to <code>GrubbsPearson</code>.
</p>
</li>
<li> <p><code>Rayleigh</code>: For <code>accuracy=FALSE</code> and two-dimensional data, this estimate uses the Rayleigh distribution (see <code><a href="#topic+getRayParam">getRayParam</a></code>). It is valid for uncorrelated bivariate normal coordinates with equal variances. This estimate is available for all probability levels. For <code>accuracy=FALSE</code> and three-dimensional data, the Maxwell-Boltzmann distribution is used (see <code><a href="#topic+getRayParam">getRayParam</a></code>). For <code>accuracy=TRUE</code> and two-dimensional data, the estimate uses the Rice distribution (see <code><a href="#topic+getRiceParam">getRiceParam</a></code>). For <code>accuracy=TRUE</code> and three-dimensional data, it is based on the offset sphere probabilities for the multivariate normal distribution set to have equal variances (see <code><a href="#topic+qmvnEll">qmvnEll</a></code>).
</p>
</li>
<li> <p><code>Krempasky</code>: The Krempasky estimate (Krempasky, 2003) is based on a nearly exact closed-form solution for the 50% quantile of the radial error for the correlated bivariate normal distribution with 0 mean. It requires estimating the covariance matrix and can only be reported for probability 0.5 with <code>accuracy=FALSE</code>. It does not generalize to three dimensions.
</p>
</li>
<li> <p><code>Ignani</code>: The Ignani estimate (Ignani, 2010) is based on a polynomial approximation for some quantiles of the radial error for the correlated bivariate normal distribution with 0 mean. It requires estimating the covariance matrix and can only be reported for probabilities 0.5, 0.9, 0.95, 0.99 with <code>accuracy=FALSE</code>. It generalizes to three dimensions.
</p>
</li>
<li> <p><code>RMSE</code>: For <code>accuracy=FALSE</code>, this estimator is the RMSE estimator often described in the GPS literature (van Diggelen, 2007) when using centered data for calculating RMSE (square root of the mean squared error). It is very similar to the <code>Rayleigh</code> estimator. For <code>accuracy=TRUE</code>, this the RMSE estimator often described in the GPS literature when using the original, non-centered data for calculating RMSE. It is similar to the <code>Rayleigh</code> estimator only when bias is small, but becomes seriously wrong otherwise. It is available for all probability levels, and generalizes to three dimensions.
</p>
</li>
<li> <p><code>Ethridge</code>: The Ethridge estimate (Ethridge, 1983; Puhek, 1992) is not based on the assumption of multivariate normality of coordinates but uses a robust unbiased estimator for the median radius (Hogg, 1967). It can only be reported for probability 0.5 but generalizes to three dimensions.
</p>
</li>
<li> <p><code>RAND</code>: The modified RAND R-234 estimate (RAND, 1952; Pesapane &amp; Irvine, 1977; Puhek 1992) is a weighted sum of the square root of the eigenvalues of the covariance matrix of shot coordinates (the standard deviations of the data that is first de-correlated through rotation). It can only be reported for probability 0.5 and does not generalize to three dimensions.
</p>
</li>
<li> <p><code>Valstar</code>: Very similar to the RAND R-234 estimate with <code>accuracy=FALSE</code> except for very elliptical distributions but with a different bias correction with <code>accuracy=TRUE</code>. It can only be reported for probability 0.5 and does not generalize to three dimensions.
</p>
</li></ul>

<p>Estimators based on the normal distribution use the plug-in method (Blischke &amp; Halpin, 1966), i.e., they substitute the true covariance matrix and mean vector with those estimated from the data. They are thus strictly valid only for the asymptotic distribution, while the finite sample distribution may differ somewhat.
</p>
<p>If package <code>shiny</code> is installed, an interactive web app for this functionality can be run with <code>runGUI("hitprob")</code>.
</p>


<h3>Value</h3>

<p>A list with the (chosen) CEP/SEP estimates and supplementary information on the distribution shape.
</p>
<table>
<tr><td><code>CEP</code></td>
<td>
<p>a numerical matrix with the chosen CEP/SEP estimates at the indicated <code>CEPlevel</code> (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>ellShape</code></td>
<td>
<p>a numerical vector with the aspect ratio of the ellipse (the square root of condition index <code><a href="base.html#topic+kappa">kappa</a></code>) and its flattening (1 - inverse aspect ratio).</p>
</td></tr>
<tr><td><code>ctr</code></td>
<td>
<p>group center</p>
</td></tr>
</table>


<h3>References</h3>

<p>Blischke W. R. and Halpin, A. H. (1966). Asymptotic properties of some estimators of quantiles of circular error. Journal of the American Statistical Association, 61 (315), 618-632.
</p>
<p>DiDonato, A. R. (1988). Integration of the trivariate normal distribution over an offset spehere and an inverse problem (NSWC TR 87-27). Dahlgren, VA: U.S. Naval Surface Weapons Center Dahlgren Division.
</p>
<p>DiDonato, A. R., &amp; Jarnagin, M. P. (1961). Integration of the general bivariate Gaussian distribution over an offset circle. Mathematics of Computation, 15 (76), 375-382.
</p>
<p>Grubbs, F. E. (1964). Approximate circular and noncircular offset probabilities of hitting. Operations Research, 12(1), 51-62.
</p>
<p>Hogg, R. V. (1967). Some observations on robust estimation. Journal of the American Statistical Association, 62 (320), 1179-1186.
</p>
<p>Ignani, B. (2010). Determination of Circular and Spherical Position-Error Bounds in System Performance Analysis. Journal of Guidance, Control, and Dynamics, 33 (4), 1301-1304.
</p>
<p>Krempasky, J. J. (2003). CEP equation exact to the fourth order. Navigation: Journal of The Institute of Navigation, 50 (3), 143-149.
</p>
<p>Liu, H., Tang, Y., &amp; Zhang, H. H. (2009). A new chi-square approximation to the distribution of non-negative definite quadratic forms in non-central normal variables. Computational Statistics &amp; Data Analysis, 53(4), 853-856.
</p>
<p>Pesapane, J., &amp; Irvine, R. B. (1977). Derivation of CEP formula to approximate RAND-234 tables. Offut AFB, NE: Ballistic Missile Evaluation, HQ SAC.
</p>
<p>Puhek, P. (1992). Sensitivity analysis of circular error probable approximation techniques (AFIT/GOR/ENS/92M-23). Wright-Patterson AFB, OH: Air Force Institute of Technology.
</p>
<p>RAND Corporation. (1952). Offset circle probabilities (RAND-234). Santa Monica, CA: RAND Corporation.
</p>
<p>Singh, H. P. 1992. Estimation of Circular Probable Error. The Indian Journal of Statistics, Series B 5(3), 289-305.
</p>
<p>van Diggelen, F. 2007. Update: GNSS Accuracy: Lies, Damn Lies, and Statistics. GPS World.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rayleigh">Rayleigh</a></code>,
<code><a href="#topic+Maxwell">Maxwell</a></code>,
<code><a href="#topic+Hoyt">Hoyt</a></code>,
<code><a href="#topic+Rice">Rice</a></code>,
<code><a href="#topic+mvnEll">mvnEll</a></code>,
<code><a href="#topic+getHoytParam">getHoytParam</a></code>,
<code><a href="#topic+getRayParam">getRayParam</a></code>,
<code><a href="#topic+getRiceParam">getRiceParam</a></code>,
<code><a href="#topic+getConfEll">getConfEll</a></code>,
<code><a href="#topic+getHitProb">getHitProb</a></code>,
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
(cep &lt;- getCEP(DFtalon, CEPlevel=0.5, accuracy=FALSE,
               dstTarget=10, conversion='m2mm',
               type=c('CorrNormal', 'GrubbsPatnaik', 'Rayleigh')))

# plot points, centers, and circles indicating 50%-CEP estimates
plot(point.y ~ point.x, data=DFtalon, asp=1, pch=16)
drawCircle(cep$ctr, cep$CEP$CEP0.5['unit', 'CorrNormal'],    fg='red')
drawCircle(cep$ctr, cep$CEP$CEP0.5['unit', 'GrubbsPatnaik'], fg='green3')
drawCircle(cep$ctr, cep$CEP$CEP0.5['unit', 'Rayleigh'],      fg='blue')
points(cep$ctr[1], cep$ctr[2], pch=4, col='gray50', cex=2, lwd=2)
legend(x='bottomleft',
       legend=c('Grubbs 50', 'Corr Normal 50', 'Rayleigh 50', 'center'),
       col=c('red', 'green3', 'blue', 'gray50'), lwd=2,
       lty=c(1, 1, 1, NA), pch=c(NA, NA, NA, 4), bg='white')

# calculate actual coverage percentage of 50% CEP estimates
dists &lt;- getDistToCtr(DFtalon)           # distances to center

# extract CEP radius for all estimates
CEPr &lt;- cep$CEP$CEP0.5['unit', ]

# percentage of points in circle with radius = CEP
100 * sapply(CEPr, function(x) sum(dists &lt;= x)) / length(dists)

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(100, 0, 5), 2), ncol=2)
getCEP(xy, accuracy=FALSE, dstTarget=25, conversion='m2cm',
       type=c('Grubbs', 'CorrNormal', 'Rayleigh'))

## End(Not run)
</code></pre>

<hr>
<h2 id='getConfEll'>Confidence ellipse</h2><span id='topic+getConfEll'></span><span id='topic+getConfEll.data.frame'></span><span id='topic+getConfEll.default'></span>

<h3>Description</h3>

<p>Calculates the confidence ellipse for the true mean of shot coordinates under the assumption of multivariate normality. Also includes the ellipse based on a robust estimate for the covariance matrix of the shot coordinates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConfEll(xy, level = 0.5, dstTarget, conversion,
          center = FALSE, doRob=TRUE)

## S3 method for class 'data.frame'
getConfEll(xy, level = 0.5, dstTarget, conversion,
          center = FALSE, doRob=TRUE)

## Default S3 method:
getConfEll(xy, level = 0.5, dstTarget, conversion,
          center = FALSE, doRob=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConfEll_+3A_xy">xy</code></td>
<td>
<p>Shot coordinates of n points: either a numerical (n x p)-matrix (1 row of p coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code> (optionally <code>z</code> or <code>point.z</code>).</p>
</td></tr>
<tr><td><code id="getConfEll_+3A_level">level</code></td>
<td>
<p>a numerical value with the coverage for the confidence ellipse.</p>
</td></tr>
<tr><td><code id="getConfEll_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in <code>xy</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="getConfEll_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Acts as override if variables <code>dist.unit</code> and <code>point.unit</code> are already included in <code>xy</code>. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="getConfEll_+3A_center">center</code></td>
<td>
<p>logical: center groups to mean (0,0) first? If variable <code>series</code> does not exist, all shots are treated as belonging to the same group. Only available in method <code>getConfEll.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="getConfEll_+3A_dorob">doRob</code></td>
<td>
<p>logical: should robust covariance matrix estimate be used as well?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No coordinate transforms are done (unlike in <code><a href="#topic+groupLocation">groupLocation</a></code>, <code><a href="#topic+groupShape">groupShape</a></code>, <code><a href="#topic+groupSpread">groupSpread</a></code>), i.e., origin is not assumed to be in top-left corner, and points are not taken relative to point of aim.
</p>
<p>Robust estimate for the covariance matrix of coordinates is from <code><a href="robustbase.html#topic+covMcd">covMcd</a></code> using the MCD algorithm. See <code><a href="#topic+getCEP">getCEP</a></code> for estimates of the circular/spherical error probable.</p>


<h3>Value</h3>

<p>A list with the confidence ellipse measures.
</p>
<table>
<tr><td><code>ctr</code></td>
<td>
<p>coordinates group center.</p>
</td></tr>
<tr><td><code>ctrRob</code></td>
<td>
<p>coordinates robust estimate of group center.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>covariance matrix.</p>
</td></tr>
<tr><td><code>covRob</code></td>
<td>
<p>robust estimate of covariance matrix.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>a numerical matrix with the lengths of the semi-axes of the ellipse (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>sizeRob</code></td>
<td>
<p>a numerical matrix with the lengths of the semi-axes of the ellipse based on a robust estimate for the covariance matrix of shot coordinates (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>a numerical vector with the angle, the aspect ratio of the ellipse (square root of condition index <code><a href="base.html#topic+kappa">kappa</a></code>), its flattening (1 - inverse aspect ratio) as well as the trace and determinant of the covariance matrix.</p>
</td></tr>
<tr><td><code>shapeRob</code></td>
<td>
<p>a numerical vector with the aspect ratio and the flattening of the ellipse as well as the trace and determinant based on a robust estimate for the covariance matrix of shot coordinates.</p>
</td></tr>
<tr><td><code>magFac</code></td>
<td>
<p>magnification factor used to turn the error ellipse into the confidence ellipse as determined by the F(p, n-1)-distribution.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+getCEP">getCEP</a></code>,
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>,
<code><a href="#topic+drawEllipse">drawEllipse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
(ce &lt;- getConfEll(DFsavage, level=0.5, dstTarget=100,
                  conversion='yd2in'))

# plot points, center, parametric confidence
# ellipse, and its axes
plot(point.y ~ point.x, data=DFsavage, asp=1, pch=16)
drawEllipse(ce, axes=TRUE, fg='blue', colCtr='blue', lwd=2, pch=4, cex=2)

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(100, 0, 5), 2), ncol=2)
getConfEll(xy, level=0.5, dstTarget=25, conversion='m2cm')

## End(Not run)
</code></pre>

<hr>
<h2 id='getDistance'>Get distance based on absolute and angular size</h2><span id='topic+getDistance'></span>

<h3>Description</h3>

<p>Calculates the distance to an object based on the object's absolute and angular size.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDistance(x, angular, conversion,
            type = c('deg', 'rad', 'MOA', 'SMOA', 'mrad', 'mil'))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDistance_+3A_x">x</code></td>
<td>
<p>a numerical vector of absolute object sizes.</p>
</td></tr>
<tr><td><code id="getDistance_+3A_angular">angular</code></td>
<td>
<p>a numerical vector of angular object sizes.</p>
</td></tr>
<tr><td><code id="getDistance_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for the returned distance to object to that of given absolute object size. Either a character vector indicating the conversion such as <code>'m2cm'</code> for meter to centimeter, <code>'yd2in'</code> for yards to inches, or <code>'ft2cm'</code> for feet to cm. Imperial (yd, ft, in) and metric units (m, cm, mm) can be freely mixed. Alternatively, a numerical vector giving the multiplication factor for conversion: 100 for m to cm, 36 for yd to in, and 12 for ft to in.</p>
</td></tr>
<tr><td><code id="getDistance_+3A_type">type</code></td>
<td>
<p>type of angular measure used in <code>angular</code>: <code>'deg'</code> for degree, <code>'rad'</code> for radian, <code>'MOA'</code> for minute of angle, <code>'SMOA'</code> for Shooter's MOA, <code>'mrad'</code> for milliradian, <code>'mil'</code> for NATO mil. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1 MOA (minute of angle, arcmin) = 1/60 degree. Shooter's MOA = SMOA = Inches Per Hundred Yards IPHY. 1 inch at 100 yards = 1 SMOA. 1 milliradian = 1/1000 radian. 1 mil = 2*pi/6400 radian (NATO definition: the circle circumference is divided into 6400 mils). Details are given in the vignette, see <code>vignette('shotGroups')</code>
</p>


<h3>Value</h3>

<p>A numerical vector with the distance values.</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMOA">getMOA</a></code>,
<code><a href="#topic+fromMOA">fromMOA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size &lt;- seq(1, 20, by=5)   # inch
dst  &lt;- 100                # yard

# get angular size in MOA from absolute size
angular &lt;- getMOA(size, dst=dst, conversion='yd2in', type='MOA')

# this should return dst throughout
getDistance(size, angular=angular, conversion='yd2in', type='MOA')
</code></pre>

<hr>
<h2 id='getDistToCtr'>Distances to center for a set of points</h2><span id='topic+getDistToCtr'></span><span id='topic+getDistToCtr.data.frame'></span><span id='topic+getDistToCtr.default'></span>

<h3>Description</h3>

<p>Calculates the distances of a set of points to their center.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDistToCtr(xy)

## S3 method for class 'data.frame'
getDistToCtr(xy)

## Default S3 method:
getDistToCtr(xy)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDistToCtr_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x p)-matrix with the coordinates of n points in p-dimensional space (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with the distances from each point to the center of the set.</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
getDistToCtr(DFtalon)

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(20, 100, 15), 1), ncol=2)
getDistToCtr(xy)

## End(Not run)
</code></pre>

<hr>
<h2 id='getHitProb'>Hit probability within given region</h2><span id='topic+getHitProb'></span><span id='topic+getHitProb.data.frame'></span><span id='topic+getHitProb.default'></span>

<h3>Description</h3>

<p>Calculates the hit probability within a circular or spherical region for a given group of two- or three-dimensional coordinates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHitProb(xy, r=1, unit = 'unit', dstTarget, conversion,
           center = FALSE, accuracy = FALSE, type = 'CorrNormal', doRob = FALSE)

## S3 method for class 'data.frame'
getHitProb(xy, r=1, unit = 'unit', dstTarget, conversion,
           center = FALSE, accuracy = FALSE, type = 'CorrNormal', doRob = FALSE)

## Default S3 method:
getHitProb(xy, r=1, unit = 'unit', dstTarget, conversion,
           center = FALSE, accuracy = FALSE, type = 'CorrNormal', doRob = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getHitProb_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x p)-matrix with the coordinates of n points (1 row of p coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code> (optionally <code>z</code> or <code>point.z</code>).</p>
</td></tr>
<tr><td><code id="getHitProb_+3A_r">r</code></td>
<td>
<p>a numerical vector with the radius values for the circle/sphere that defines the region for which the probability should be calculated.</p>
</td></tr>
<tr><td><code id="getHitProb_+3A_unit">unit</code></td>
<td>
<p>Measurement unit for radius <code>r</code>. Default <code>'unit'</code> indicates that the measurement unit for (x,y)-coordinates given in <code>conversion</code>. Possible values are <code>'unit', 'm', 'cm', 'mm', 'yd', 'ft', 'in', 'deg', 'MOA', 'SMOA', 'rad', 'mrad', 'mil'</code>.</p>
</td></tr>
<tr><td><code id="getHitProb_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in <code>xy</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="getHitProb_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Acts as override if variables <code>dist.unit</code> and <code>point.unit</code> are already included in <code>xy</code>. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="getHitProb_+3A_center">center</code></td>
<td>
<p>logical: center groups to mean (0,0) first? If variable <code>series</code> does not exist, all shots are treated as belonging to the same group. Only available in method <code>getHitProb.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="getHitProb_+3A_accuracy">accuracy</code></td>
<td>
<p>logical: take systematic location bias into account? See details.</p>
</td></tr>
<tr><td><code id="getHitProb_+3A_type">type</code></td>
<td>
<p>string vector indicating which estimation method to use. Possible values are <code>'CorrNormal', 'GrubbsPearson', 'GrubbsPatnaik', 'GrubbsLiu', 'Rayleigh'</code>.</p>
</td></tr>
<tr><td><code id="getHitProb_+3A_dorob">doRob</code></td>
<td>
<p>logical: use robust estimation of center and covariance matrix as basis for estimates? For Rayleigh only available when <code>accuracy=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimated hit probability is the same as the estimated fraction of shots with a distance to their group center of at most <code>r</code>.
</p>
<p>For <code>accuracy=FALSE</code> (default), the estimated hit probability does not take into account accuracy, i.e., any systematic location bias. The data is then first centered on the empirical group mean, assumed to coincide with the point of aim. Set <code>accuracy=TRUE</code> to incorporate systematic accuracy bias such that the point of aim is in the origin 0, possibly offset from the true group center.
</p>

<ul>
<li> <p><code>CorrNormal</code>: For <code>accuracy=FALSE</code> and two-dimensional data, this estimate is based on the quantile function of the correlated bivariate normal distribution re-written in polar coordinates (radius and angle) (see <code><a href="#topic+Hoyt">Hoyt</a></code>). For <code>accuracy=TRUE</code> or three-dimensional data, it is based on the (offset) circle/sphere probabilities for the correlated multivariate normal distribution (DiDonato &amp; Jarnagin, 1961; DiDonato, 1981, see <code><a href="#topic+pmvnEll">pmvnEll</a></code>).
</p>
</li>
<li> <p><code>GrubbsPearson</code>: The Grubbs-Pearson estimate (Grubbs, 1964) is based on the Pearson three-moment central chi^2-approximation of the true cumulative distribution function of radial error. The eigenvalues of the covariance matrix of shot-coordinates are used as variance estimates since they are the variances of the principal components (the PCA-rotated = decorrelated data).
</p>
</li>
<li> <p><code>GrubbsPatnaik</code>: The Grubbs-Patnaik estimate (Grubbs, 1964) differs from the Grubbs-Pearson estimate insofar as it is based on the Patnaik two-moment central chi^2-approximation of the true cumulative distribution function of radial error.
</p>
</li>
<li> <p><code>GrubbsLiu</code>: The Grubbs-Liu estimate was not proposed by Grubbs but follows the same principle as his original estimates. It differs from them insofar as it is based on the Liu-Tang-Zhang four-moment non-central chi^2-approximation of the true cumulative distribution function of radial error. For <code>accuracy=FALSE</code>, it is identical to <code>GrubbsPearson</code>.
</p>
</li>
<li> <p><code>Rayleigh</code>: For <code>accuracy=FALSE</code> and two-dimensional data, this estimate uses the Rayleigh distribution (see <code><a href="#topic+getRayParam">getRayParam</a></code>). It is valid for uncorrelated bivariate normal coordinates with equal variances. This estimate is available for all probability levels. For <code>accuracy=FALSE</code> and three-dimensional data, the Maxwell-Boltzmann distribution is used (see <code><a href="#topic+getRayParam">getRayParam</a></code>). For <code>accuracy=TRUE</code> and two-dimensional data, the estimate uses the Rice distribution (see <code><a href="#topic+getRiceParam">getRiceParam</a></code>). For <code>accuracy=TRUE</code> and three-dimensional data, it is based on the offset sphere probabilities for the multivariate normal distribution set to have equal variances (see <code><a href="#topic+qmvnEll">qmvnEll</a></code>).
</p>
</li></ul>

<p>If package <code>shiny</code> is installed, an interactive web app for this functionality can be run with <code>runGUI("hitprob")</code>.
</p>


<h3>Value</h3>

<p>A vector with the (chosen) hit-probability estimates. For more than one <code>r</code> and more than one <code>type</code>, a matrix.
</p>


<h3>References</h3>

<p>DiDonato, A. R. (1988). Integration of the trivariate normal distribution over an offset spehere and an inverse problem (NSWC TR 87-27). Dahlgren, VA: U.S. Naval Surface Weapons Center Dahlgren Division.
</p>
<p>DiDonato, A. R., &amp; Jarnagin, M. P. (1961). Integration of the general bivariate Gaussian distribution over an offset circle. Mathematics of Computation, 15 (76), 375-382.
</p>
<p>Grubbs, F. E. (1964). Approximate circular and noncircular offset probabilities of hitting. Operations Research, 12(1), 51-62.
</p>
<p>Liu, H., Tang, Y., &amp; Zhang, H. H. (2009). A new chi-square approximation to the distribution of non-negative definite quadratic forms in non-central normal variables. Computational Statistics &amp; Data Analysis, 53(4), 853-856.
</p>
<p>Singh, H. P. 1992. Estimation of Circular Probable Error. The Indian Journal of Statistics, Series B 5(3), 289-305.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rayleigh">Rayleigh</a></code>,
<code><a href="#topic+Maxwell">Maxwell</a></code>,
<code><a href="#topic+Hoyt">Hoyt</a></code>,
<code><a href="#topic+mvnEll">mvnEll</a></code>,
<code><a href="#topic+getHoytParam">getHoytParam</a></code>,
<code><a href="#topic+getRayParam">getRayParam</a></code>,
<code><a href="#topic+getCEP">getCEP</a></code>,
<code><a href="#topic+getConfEll">getConfEll</a></code>,
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
# estimated fraction of shots within a circle with radius
# 1 and 1.5 MOA.
getHitProb(DFscar17, r=c(1, 1.5), unit='MOA', accuracy=FALSE,
           dstTarget=100, conversion='yd2in',
           type=c('CorrNormal', 'GrubbsPatnaik'))

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(100, 0, 5), 2), ncol=2)
getHitProb(xy, r=c(2, 2.5), unit='MOA', accuracy=FALSE,
           dstTarget=100, conversion='yd2in',
           type=c('CorrNormal', 'GrubbsPatnaik'))

## End(Not run)
</code></pre>

<hr>
<h2 id='getHoytParam'>Determine parameters q and omega of the Hoyt distribution</h2><span id='topic+getHoytParam'></span><span id='topic+getHoytParam.data.frame'></span><span id='topic+getHoytParam.matrix'></span><span id='topic+getHoytParam.list'></span><span id='topic+getHoytParam.default'></span>

<h3>Description</h3>

<p>Determines the Hoyt distribution's shape parameter q and scale parameter omega from the eigenvalues of a (2 x 2)-covariance matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHoytParam(x)

## S3 method for class 'matrix'
getHoytParam(x)

## S3 method for class 'list'
getHoytParam(x)

## S3 method for class 'data.frame'
getHoytParam(x)

## Default S3 method:
getHoytParam(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getHoytParam_+3A_x">x</code></td>
<td>
<p>one of the following: a (2 x 2)-covariance matrix, a list of (2 x 2)-covariance matrices, a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code>, a 2-vector with eigenvalues.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code>q</code> and <code>omega</code> derive from the eigenvalues ev1, ev2 of the covariance matrix of the bivariate normal distribution as follows: <code>q = 1 / sqrt(((ev1+ev2)/ev2) - 1)</code> and <code>omega = ev1 + ev2</code>.
</p>
<p>If <code>x</code> is a data frame, its sample covariance matrix is used to estimate the eigenvalues. Note that the Hoyt distribution is only approximately valid for large samples if estimated parameters are used.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>q</code></td>
<td>
<p>A vector with values of the shape parameter <code>q</code>.</p>
</td></tr>
<tr><td><code>omega</code></td>
<td>
<p>A vector with values of the scale parameter <code>omega</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hoyt, R. S. (1947). Probability functions for the modulus and angle of the normal complex variate.
Bell System Technical Journal, 26(2), 318-359.
</p>
<p><a href="https://reference.wolfram.com/language/ref/HoytDistribution.html">https://reference.wolfram.com/language/ref/HoytDistribution.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hoyt">Hoyt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## q and omega based on coordinates in a data frame
getHoytParam(DFscar17)

## q and omega based on a covariance matrix
cm1 &lt;- cbind(c(8, 0), c(0, 2))
getHoytParam(cm1)

## q and omega based on a list of covariance matrices
cm2 &lt;- cbind(c(6, 0), c(0, 4))
cmL &lt;- list(cm1, cm2)
getHoytParam(cmL)

## q and omega based on eigenvalues
ev &lt;- eigen(cm1)$values
getHoytParam(cm1)
</code></pre>

<hr>
<h2 id='getKuchnost'>Kuchnost precision estimate</h2><span id='topic+getKuchnost'></span><span id='topic+getKuchnost.data.frame'></span><span id='topic+getKuchnost.default'></span>

<h3>Description</h3>

<p>Estimates the Kuchnost precision measure. The maximum distance to the group center after removing outliers.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKuchnost(xy, dstTarget, conversion,
       center = FALSE, doRob = FALSE, strict = FALSE)

## S3 method for class 'data.frame'
getKuchnost(xy, dstTarget, conversion,
       center = FALSE, doRob = FALSE, strict = FALSE)

## Default S3 method:
getKuchnost(xy, dstTarget, conversion,
       center = FALSE, doRob = FALSE, strict = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getKuchnost_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x p)-matrix with the coordinates of n points (1 row of p coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code> (optionally <code>z</code> or <code>point.z</code>).</p>
</td></tr>
<tr><td><code id="getKuchnost_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in <code>xy</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="getKuchnost_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Acts as override if variables <code>dist.unit</code> and <code>point.unit</code> are already included in <code>xy</code>. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="getKuchnost_+3A_center">center</code></td>
<td>
<p>logical: center groups to mean (0,0) first? If variable <code>series</code> does not exist, all shots are treated as belonging to the same group. Only available in method <code>getCEP.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="getKuchnost_+3A_dorob">doRob</code></td>
<td>
<p>logical: use robust estimation of center and covariance matrix as basis for estimators?</p>
</td></tr>
<tr><td><code id="getKuchnost_+3A_strict">strict</code></td>
<td>
<p>logical: enable check that <code>xy</code> contains exactly 4 shots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An outlier is defined as a shot that is at least 2.5 times further away from the group center defined by all remaining shots compared to the maximum distance to center of those shots themselves.
</p>


<h3>Value</h3>

<p>A list with 3 components.
</p>
<table>
<tr><td><code>Kuchnost</code></td>
<td>
<p>The Kuchnost precision measure.</p>
</td></tr>
<tr><td><code>outlier</code></td>
<td>
<p>Indices of outliers, if any.</p>
</td></tr>
<tr><td><code>ctr</code></td>
<td>
<p>group center after removing outliers</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://github.com/lstange/mcgs">https://github.com/lstange/mcgs</a>
</p>


<h3>See Also</h3>

<p><code><a href="robustbase.html#topic+covMcd">covMcd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getKuchnost(DF300BLK)
</code></pre>

<hr>
<h2 id='getMaxPairDist'>Maximum pairwise distance for a set of points</h2><span id='topic+getMaxPairDist'></span><span id='topic+getMaxPairDist.data.frame'></span><span id='topic+getMaxPairDist.default'></span>

<h3>Description</h3>

<p>Calculates the maximum of pairwise distances between points given a set of coordinates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMaxPairDist(xy)

## S3 method for class 'data.frame'
getMaxPairDist(xy)

## Default S3 method:
getMaxPairDist(xy)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMaxPairDist_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x p)-matrix with the coordinates of n points in p-dimensional space (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>numerical value with the maximum pairwise distance between points.</p>
</td></tr>
<tr><td><code>idx</code></td>
<td>
<p>a vector with two entries giving the row indices of the points that are farthest apart.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
(maxPD &lt;- getMaxPairDist(DFsavage))

# plot points and point pair with maximum distance
plot(point.y ~ point.x, data=DFsavage, asp=1, pch=16)
x0 &lt;- DFsavage$point.x[maxPD$idx[1]]     # 1st point x
y0 &lt;- DFsavage$point.y[maxPD$idx[1]]     # 1st point y
x1 &lt;- DFsavage$point.x[maxPD$idx[2]]     # 2nd point x
y1 &lt;- DFsavage$point.y[maxPD$idx[2]]     # 2nd point y
segments(x0, y0, x1, y1, col="green3", lwd=2)

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(20, 100, 15), 1), ncol=2)
getMaxPairDist(xy)

## End(Not run)
</code></pre>

<hr>
<h2 id='getMinBBox'>Minimum-area bounding box for a set of 2D-points</h2><span id='topic+getMinBBox'></span><span id='topic+getMinBBox.data.frame'></span><span id='topic+getMinBBox.default'></span>

<h3>Description</h3>

<p>Calculates the vertices of the minimum-area, possibly oriented bounding box given a set of 2D-coordinates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMinBBox(xy)

## S3 method for class 'data.frame'
getMinBBox(xy)

## Default S3 method:
getMinBBox(xy)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMinBBox_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x 2)-matrix with the (x,y)-coordinates of n &gt;= 2 points (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No coordinate transforms are done (unlike in <code><a href="#topic+groupLocation">groupLocation</a></code>, <code><a href="#topic+groupShape">groupShape</a></code>, <code><a href="#topic+groupSpread">groupSpread</a></code>), i.e., origin is not assumed to be in top-left corner, and points are not taken relative to point of aim.<br />
Uses the rotating calipers algorithm (Toussaint, 1983).</p>


<h3>Value</h3>

<p>A list with the following information about the minimum-area bounding box:
</p>
<table>
<tr><td><code>pts</code></td>
<td>
<p>a (4 x 2)-matrix containing the coordinates of the (ordered) vertices.</p>
</td></tr>
<tr><td><code>width</code></td>
<td>
<p>width of the box.</p>
</td></tr>
<tr><td><code>height</code></td>
<td>
<p>height of the box.</p>
</td></tr>
<tr><td><code>FoM</code></td>
<td>
<p>figure of merit, i.e., the average side length of the box: (<code>width</code> + <code>height</code>) / 2.</p>
</td></tr>
<tr><td><code>diag</code></td>
<td>
<p>length of box diagonal.</p>
</td></tr>
<tr><td><code>angle</code></td>
<td>
<p>orientation of the box' longer edge pointing up as returned by <code><a href="base.html#topic+atan2">atan2</a></code>, but in degree.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Computational Geometry Algorithms Library. 2021. CGAL Chapter 65: Bounding Volumes. <a href="https://doc.cgal.org/Manual/latest/doc_html/cgal_manual/Bounding_volumes/Chapter_main.html">https://doc.cgal.org/Manual/latest/doc_html/cgal_manual/Bounding_volumes/Chapter_main.html</a>
Toussaint, G. T. 1983. Solving geometric problems with the rotating calipers. In: Proceedings of the 1983 IEEE MELECON. Athens, Greece: IEEE Computer Society.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawBox2">drawBox2</a></code>,
<code><a href="#topic+getBoundingBox">getBoundingBox</a></code>,
<code><a href="#topic+getMinCircle">getMinCircle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
bb &lt;- getMinBBox(DFsavage)               # minimum bounding box

# plot points and minimum bounding box
plot(point.y ~ point.x, data=DFsavage, asp=1,
     xlim=range(bb$pts[ , 1]), ylim=range(bb$pts[ , 2]), pch=16)
drawBox2(bb, fg='blue', colCtr='blue', pch=4, cex=2)

bb$FoM                                   # figure of merit
bb$angle                                 # box orientation

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(16, 100, 15)), ncol=2)
getMinBBox(xy)

## End(Not run)
</code></pre>

<hr>
<h2 id='getMinCircle'>Minimum enclosing circle for a set of 2D-points</h2><span id='topic+getMinCircle'></span><span id='topic+getMinCircle.data.frame'></span><span id='topic+getMinCircle.default'></span>

<h3>Description</h3>

<p>Calculates center and radius of the minimum enclosing circle given a set of 2D-coordinates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMinCircle(xy)

## S3 method for class 'data.frame'
getMinCircle(xy)

## Default S3 method:
getMinCircle(xy)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMinCircle_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x 2)-matrix with the (x,y)-coordinates of n &gt;= 2 points (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No coordinate transforms are done (unlike in <code><a href="#topic+groupLocation">groupLocation</a></code>, <code><a href="#topic+groupShape">groupShape</a></code>, <code><a href="#topic+groupSpread">groupSpread</a></code>), i.e., origin is not assumed to be in top-left corner, and points are not taken relative to point of aim. <br /> <br />
Uses the Skyum algorithm based on the convex hull.</p>


<h3>Value</h3>

<p>A list containing the center and radius of the circle.
</p>
<table>
<tr><td><code>ctr</code></td>
<td>
<p>a numerical 2-vector giving the (x,y)-coordinates of the circle's center.</p>
</td></tr>
<tr><td><code>rad</code></td>
<td>
<p>a numerical value giving the radius of the circle.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Computational Geometry Algorithms Library. 2021. CGAL Chapter 65: Bounding Volumes. <a href="https://doc.cgal.org/Manual/latest/doc_html/cgal_manual/Bounding_volumes/Chapter_main.html">https://doc.cgal.org/Manual/latest/doc_html/cgal_manual/Bounding_volumes/Chapter_main.html</a>
Fischer, K.; Gaertner, B.; Kutz, M. 2003. Fast smallest-enclosing-ball computation in high dimensions. In: Proceedings of the 11th  European Symposium on Algorithms (ESA), 630-641. <a href="https://github.com/hbf/miniball">https://github.com/hbf/miniball</a>
Gaertner, B. 2021. Miniball: Smallest Enclosing Balls of Points. <a href="https://people.inf.ethz.ch/gaertner/subdir/software/miniball.html">https://people.inf.ethz.ch/gaertner/subdir/software/miniball.html</a>
Skyum, S. 1991. A simple algorithm for computing the smallest enclosing circle. Information Processing Letters 37(3), 121-125.
Welzl, E. 1991. Smallest enclosing disks (balls and ellipsoids). In: Maurer H. (eds), New Results and New Trends in Computer Science 555, 359-370. doi 10.1007/BFb0038202.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawCircle">drawCircle</a></code>,
<code><a href="#topic+getMinBBox">getMinBBox</a></code>,
<code><a href="#topic+getBoundingBox">getBoundingBox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
mc &lt;- getMinCircle(DFsavage)

# determine axis limits so that circle will be visible
xLims &lt;- mc$ctr[1] + c(-mc$rad, mc$rad)
yLims &lt;- mc$ctr[2] + c(-mc$rad, mc$rad)
plot(point.y ~ point.x, data=DFsavage,
     pch=16, asp=1, xlim=xLims, ylim=yLims)
drawCircle(mc, fg='blue')

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(20, 100, 15), 2), ncol=2)
getMinCircle(xy)

## End(Not run)
</code></pre>

<hr>
<h2 id='getMinEllipse'>Minimum enclosing ellipse for a set of 2D-points</h2><span id='topic+getMinEllipse'></span><span id='topic+getMinEllipse.data.frame'></span><span id='topic+getMinEllipse.default'></span>

<h3>Description</h3>

<p>Calculates center, shape matrix, and area of the minimum enclosing ellipse given a set of 2D-coordinates using Khachiyan's algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMinEllipse(xy, tol = 0.001, max_iter = 1000)

## S3 method for class 'data.frame'
getMinEllipse(xy, tol = 0.001, max_iter = 1000)

## Default S3 method:
getMinEllipse(xy, tol = 0.001, max_iter = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMinEllipse_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x 2)-matrix with the (x,y)-coordinates of n &gt;= 2 points (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code>.</p>
</td></tr>
<tr><td><code id="getMinEllipse_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance value. Should be &lt; 1.</p>
</td></tr>
<tr><td><code id="getMinEllipse_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No coordinate transforms are done (unlike in <code><a href="#topic+groupLocation">groupLocation</a></code>, <code><a href="#topic+groupShape">groupShape</a></code>, <code><a href="#topic+groupSpread">groupSpread</a></code>), i.e., origin is not assumed to be in top-left corner, and points are not taken relative to point of aim.</p>


<h3>Value</h3>

<p>A list containing the center, (2 x 2)-shape matrix, and area of the ellipse.
</p>
<table>
<tr><td><code>ctr</code></td>
<td>
<p>a numerical 2-vector giving the (x,y)-coordinates of the ellipse's center.</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>a numerical positive definite (2 x 2)-matrix defining the ellipse in the form ((x-c)' E (x-c)) &lt;= 1 </p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>matrix, whose eigen-structure determines shape of ellipse. Inverse of E. Useful for plotting with <code><a href="#topic+drawEllipse">drawEllipse</a></code>.</p>
</td></tr>
<tr><td><code>area</code></td>
<td>
<p>a numerical value giving the area of the ellipse.</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>a numerical vector with the orientation of the ellipse's major axis pointing up as returned by <code><a href="base.html#topic+atan2">atan2</a></code> (but in degree), the aspect ratio of the ellipse (square root of condition index <code><a href="base.html#topic+kappa">kappa</a></code>), its flattening (1 - inverse aspect ratio) as well as the trace and determinant of the covariance matrix.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>a numerical vector with the lengths of the semi-axes of the ellipse.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Computational Geometry Algorithms Library. 2021. CGAL Chapter 65: Bounding Volumes. <a href="https://doc.cgal.org/Manual/latest/doc_html/cgal_manual/Bounding_volumes/Chapter_main.html">https://doc.cgal.org/Manual/latest/doc_html/cgal_manual/Bounding_volumes/Chapter_main.html</a>
</p>
<p>Todd MJ and Yildrim EA. On Khachiyan's Algorithm for the Computation of Minimum Volume Enclosing Ellipsoids. Discrete Applied Mathematics 2007: 155: 1731-1744. <a href="https://people.orie.cornell.edu/miketodd/TYKhach.pdf">https://people.orie.cornell.edu/miketodd/TYKhach.pdf</a>
</p>
<p>Jacob. Bounding ellipse. <a href="https://stackoverflow.com/a/1768440">https://stackoverflow.com/a/1768440</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawEllipse">drawEllipse</a></code>,
<code><a href="#topic+getMinCircle">getMinCircle</a></code>,
<code><a href="#topic+getMinBBox">getMinBBox</a></code>,
<code><a href="#topic+getBoundingBox">getBoundingBox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
me &lt;- getMinEllipse(DFsavage, tol=0.001)

plot(point.y ~ point.x, data=DFsavage, pch=16, asp=1)
drawEllipse(me, fg='blue')

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(20, 100, 15), 2), ncol=2)
getMinEllipse(xy, tol=0.001)

## End(Not run)
</code></pre>

<hr>
<h2 id='getMOA'>Conversion of absolute size to angular diameter</h2><span id='topic+getMOA'></span>

<h3>Description</h3>

<p>Converts object size to angular diameter (degree, radian, minute of angle MOA = arcminute, Shooter's MOA SMOA, milliradian mrad, NATO mil).</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMOA(x, dst, conversion,
       type = c('deg', 'rad', 'MOA', 'SMOA', 'mrad', 'mil'))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMOA_+3A_x">x</code></td>
<td>
<p>a numerical vector of object sizes.</p>
</td></tr>
<tr><td><code id="getMOA_+3A_dst">dst</code></td>
<td>
<p>a numerical vector of viewing distances.</p>
</td></tr>
<tr><td><code id="getMOA_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates. Either a character vector indicating the conversion such as <code>'m2cm'</code> for meter to centimeter, <code>'yd2in'</code> for yards to inches, or <code>'ft2cm'</code> for feet to cm. Imperial (yd, ft, in) and metric units (m, cm, mm) can be freely mixed. Alternatively, a numerical vector giving the multiplication factor for conversion: 100 for m to cm, 36 for yd to in, and 12 for ft to in.</p>
</td></tr>
<tr><td><code id="getMOA_+3A_type">type</code></td>
<td>
<p>type of angular diameter: <code>'deg'</code> for degree, <code>'rad'</code> for radian, <code>'MOA'</code> for minute of angle, <code>'SMOA'</code> for Shooter's MOA, <code>'mrad'</code> for milliradian, <code>'mil'</code> for NATO mil. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1 MOA (minute of angle, arcmin) = 1/60 degree. Shooter's MOA = SMOA = Inches Per Hundred Yards IPHY. 1 inch at 100 yards = 1 SMOA. 1 milliradian = 1/1000 radian. 1 mil = 2*pi/6400 radian (NATO definition: the circle circumference is divided into 6400 mils). Details are given in the vignette, see <code>vignette('shotGroups') .</code>
</p>
<p>If package <code>shiny</code> is installed, an interactive web app for this functionality can be run with <code>runGUI("angular")</code>.
</p>


<h3>Value</h3>

<p>A numerical vector with the angular diameter values.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fromMOA">fromMOA</a></code>,
<code><a href="#topic+getDistance">getDistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size &lt;- seq(1, 20, by=5)   # inch
dst  &lt;- 100                # yard
getMOA(size, dst=dst, conversion='yd2in', type='MOA')

# this should return objSize
MOA &lt;- getMOA(size, dst=dst, conversion='yd2in', type='MOA')
fromMOA(MOA, dst=dst, conversion='yd2in', type='MOA')

# SMOA
getMOA(c(1, 2, 5), dst=100, conversion='yd2in', type='SMOA')

# milliradian
getMOA(c(10, 20, 50), dst=100, conversion='m2mm', type='mrad')
</code></pre>

<hr>
<h2 id='getRangeStat'>Range statistics</h2><span id='topic+getRangeStat'></span><span id='topic+getRangeStat.data.frame'></span><span id='topic+getRangeStat.default'></span>

<h3>Description</h3>

<p>Returns range statistics: extreme spread, figure of merit, bounding box diagonal</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRangeStat(xy, dstTarget, conversion)

## S3 method for class 'data.frame'
getRangeStat(xy, dstTarget, conversion)

## Default S3 method:
getRangeStat(xy, dstTarget, conversion)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRangeStat_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x p)-matrix with the coordinates of n points (1 row of p coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code> (optionally <code>z</code> or <code>point.z</code>).</p>
</td></tr>
<tr><td><code id="getRangeStat_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in <code>xy</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="getRangeStat_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Acts as override if variables <code>dist.unit</code> and <code>point.unit</code> are already included in <code>xy</code>. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector with elements <code>ES</code> (extreme spread), <code>FoM</code> (figure of merit), <code>D</code> (bounding box diagonal).
</p>


<h3>References</h3>

<p>Grubbs, F. E. (1964b). Statistical measures of accuracy for riflemen and missile engineers. Ann Arbor, ML: Edwards Brothers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMaxPairDist">getMaxPairDist</a></code>,
<code><a href="#topic+getBoundingBox">getBoundingBox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getRangeStat(DFscar17)
</code></pre>

<hr>
<h2 id='getRayParam'>Estimate Rayleigh parameters sigma, mean and standard deviation</h2><span id='topic+getRayParam'></span><span id='topic+getRayParam.data.frame'></span><span id='topic+getRayParam.default'></span>

<h3>Description</h3>

<p>Estimates the radial precision parameter sigma of the Rayleigh distribution together with the radial mean MR and radial standard deviation RSD, including parametric confidence intervals. For 1D data, it estimates the parameters of the half normal distribution. For 3D data, it estimates the parameters of the Maxwell-Boltzmann distribution</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRayParam(xy, level = 0.95, mu, doRob = FALSE)

## S3 method for class 'data.frame'
getRayParam(xy, level = 0.95, mu, doRob = FALSE)

## Default S3 method:
getRayParam(xy, level = 0.95, mu, doRob = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRayParam_+3A_xy">xy</code></td>
<td>
<p>either a numerical matrix with the coordinates of n points (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code>.</p>
</td></tr>
<tr><td><code id="getRayParam_+3A_level">level</code></td>
<td>
<p>a numerical value with the coverage for the confidence intervals for sigma, MR, RSD.</p>
</td></tr>
<tr><td><code id="getRayParam_+3A_mu">mu</code></td>
<td>
<p>numerical 2-vector with the true group center (optional). See details.</p>
</td></tr>
<tr><td><code id="getRayParam_+3A_dorob">doRob</code></td>
<td>
<p>logical: use robust estimation of covariance matrix as basis for estimators?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the true mean <code>mu</code> of the distribution is given, the sigma estimate uses the sum of squared radii for the variance estimate (the total un-corrected variance of the coordinates), and employs the c4 correction factor for taking the square root. When <code>mu</code> is missing, the sum of squared radii is Bessel-corrected for estimating the center.
</p>
<p>The robust estimate for the covariance matrix of (x,y)-coordinates is from <code><a href="robustbase.html#topic+covMcd">covMcd</a></code> using the MCD algorithm.
</p>


<h3>Value</h3>

<p>A list with the estimates for sigma, RSD, and MR including the confidence intervals.
</p>
<table>
<tr><td><code>sigma</code></td>
<td>
<p>A vector with the sigma estimate and confidence interval bounds as named elements <code>sigma</code>, <code>sigCIlo</code>, <code>sigCIup</code>.</p>
</td></tr>
<tr><td><code>RSD</code></td>
<td>
<p>A vector with the RSD estimate and confidence interval bounds as named elements <code>RSD</code>, <code>RSDciLo</code>, <code>RSDciUp</code>.</p>
</td></tr>
<tr><td><code>MR</code></td>
<td>
<p>A vector with the MR estimate and confidence interval bounds as named elements <code>MR</code>, <code>MRciLo</code>, <code>MRciUp</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://ballistipedia.com/index.php?title=Closed_Form_Precision">http://ballistipedia.com/index.php?title=Closed_Form_Precision</a>
</p>
<p>Singh, H. P. 1992. Estimation of Circular Probable Error. The Indian Journal of Statistics, Series B 5(3), 289-305.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rayleigh">Rayleigh</a></code>,
<code><a href="#topic+Maxwell">Maxwell</a></code>,
<code><a href="#topic+getCEP">getCEP</a></code>,
<code><a href="#topic+getHitProb">getHitProb</a></code>,
<code><a href="#topic+groupSpread">groupSpread</a></code>,
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
getRayParam(DFtalon, level=0.95, doRob=FALSE)

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(100, 0, 5), 2), ncol=2)
getRayParam(xy, level=0.95, doRob=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='getRiceParam'>Estimate Rice parameters nu and sigma</h2><span id='topic+getRiceParam'></span><span id='topic+getRiceParam.data.frame'></span><span id='topic+getRiceParam.default'></span>

<h3>Description</h3>

<p>Estimates the location parameter nu and the scale parameter sigma of the Rice distribution together with the radial mean MR and radial standard deviation RSD based on a set of 2D-coordinates. Includes the parametric confidence interval for sigma.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRiceParam(xy, level = 0.95, doRob = FALSE, type = c('LiZhangDai', 'MOM'))

## S3 method for class 'data.frame'
getRiceParam(xy, level = 0.95, doRob = FALSE, type=c('LiZhangDai', 'MOM'))

## Default S3 method:
getRiceParam(xy, level = 0.95, doRob = FALSE, type=c("LiZhangDai", 'MOM'))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRiceParam_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x 2)-matrix with the (x,y)-coordinates of n points (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code>.</p>
</td></tr>
<tr><td><code id="getRiceParam_+3A_level">level</code></td>
<td>
<p>a numerical value with the coverage for the confidence interval for sigma.</p>
</td></tr>
<tr><td><code id="getRiceParam_+3A_dorob">doRob</code></td>
<td>
<p>logical: use robust estimation of center and covariance matrix as basis for estimators?</p>
</td></tr>
<tr><td><code id="getRiceParam_+3A_type">type</code></td>
<td>
<p>The initial biased nu estimate is the Euclidean norm of the group center. For <code>'LiZhangDai'</code>, the bias-correction from Liu et al., 2009. For <code>'MOM'</code>, the estimated bias is subtracted. If the estimated bias is larger than the initial estimate, the final estimate is then set to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sigma estimate uses <code><a href="#topic+getRayParam">getRayParam</a></code>. The robust estimate for the center and for the covariance matrix of (x,y,z)-coordinates is from <code><a href="robustbase.html#topic+covMcd">covMcd</a></code> using the MCD algorithm.
</p>


<h3>Value</h3>

<p>A list with the estimates for nu, sigma, RSD, and MR including the confidence interval for sigma.
</p>
<table>
<tr><td><code>nu</code></td>
<td>
<p>The estimated location parameter nu.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>A vector with the sigma estimate and confidence interval bounds as named elements <code>sigma</code>, <code>sigCIlo</code>, <code>sigCIup</code>.</p>
</td></tr>
<tr><td><code>MR</code></td>
<td>
<p>The MR estimate.</p>
</td></tr>
<tr><td><code>RSD</code></td>
<td>
<p>The RSD estimate.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://reference.wolfram.com/language/ref/RiceDistribution.html">https://reference.wolfram.com/language/ref/RiceDistribution.html</a>
</p>
<p>Li, Q., Zhang, J., &amp; Dai, S. (2009). On estimating the non-centrality parameter of a chi-squared distribution. Statistics and Probability Letters 79, 98-114.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rice">Rice</a></code>,
<code><a href="#topic+getRayParam">getRayParam</a></code>,
<code><a href="#topic+getCEP">getCEP</a></code>,
<code><a href="#topic+getHitProb">getHitProb</a></code>,
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getRiceParam(DF300BLKhl, level=0.95, doRob=FALSE)

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(60, 0, 5), 2), ncol=2)
getRiceParam(xy, level=0.95, doRob=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='getXYmat'>Extract (x,y)-coordinates (relative to point of aim) from a data frame</h2><span id='topic+getXYmat'></span>

<h3>Description</h3>

<p>Extracts (x,y)- or (x,y,z)-coordinates of the points of impact (relative to the point of aim) from a data frame and returns them as a matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getXYmat(DF, xyTopLeft = TRUE, relPOA = TRUE, center = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getXYmat_+3A_df">DF</code></td>
<td>
<p>a data frame containing (at least) either the variables <code>point.x</code>, <code>point.y</code> or <code>x</code>, <code>y</code> defining the bullet holes. For three-dimensional data, variables <code>point.z</code> or <code>z</code> are recognized. Variables <code>aim.x</code>, <code>aim.y</code>, and for three-dimensional data <code>point.z</code> can define the point of aim. If missing, point of aim is assumed to be in the origin 0.</p>
</td></tr>
<tr><td><code id="getXYmat_+3A_xytopleft">xyTopLeft</code></td>
<td>
<p>logical: is the origin of the absolute coordinate system in the top-left corner? See details.</p>
</td></tr>
<tr><td><code id="getXYmat_+3A_relpoa">relPOA</code></td>
<td>
<p>logical: should returned coordinates be relative to the point of aim?</p>
</td></tr>
<tr><td><code id="getXYmat_+3A_center">center</code></td>
<td>
<p>logical: center groups to mean (0,0)? If variable <code>series</code> does not exist, all shots are treated as belonging to the same group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, OnTarget PC/TDS' 'Export Point Data' places the origin of the absolute coordinate system in the top-left corner. In OnTarget TDS, this setting can be changed by checking the box 'Tools -&gt; Options -&gt; Options tab -&gt; Data Export -&gt; Invert Y-Axis on Export'. In that case, use <code>xyTopLeft=FALSE</code>. If groups appear to be upside-down, <code>xyTopLeft</code> is the setting to change.
</p>


<h3>Value</h3>

<p>A numerical matrix with the (x,y)- or (x,y,z)-coordinates.</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupLocation">groupLocation</a></code>,
<code><a href="#topic+groupShape">groupShape</a></code>,
<code><a href="#topic+groupSpread">groupSpread</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DFcm)

# select data from only first series
DFsub &lt;- subset(DFcm, series == 1)
getXYmat(DFsub, xyTopLeft=TRUE, relPOA=TRUE)
</code></pre>

<hr>
<h2 id='groupLocation'>Accuracy: Location measures for a single group of bullet holes</h2><span id='topic+groupLocation'></span><span id='topic+groupLocation.data.frame'></span><span id='topic+groupLocation.default'></span>

<h3>Description</h3>

<p>Calculates location measures for a single group of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupLocation(xy, level = 0.95, plots = TRUE, bootCI = 'none',
              dstTarget, conversion)

## S3 method for class 'data.frame'
groupLocation(xy, level = 0.95, plots = TRUE, bootCI = 'none',
              dstTarget, conversion)

## Default S3 method:
groupLocation(xy, level = 0.95, plots = TRUE, bootCI = 'none',
              dstTarget, conversion)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupLocation_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x 2)-matrix with the (x,y)-coordinates of n points (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code> as well as <code>aim.x</code>, <code>aim.y</code> giving the point of aim. If missing, point of aim is assumed to be in (0,0).</p>
</td></tr>
<tr><td><code id="groupLocation_+3A_level">level</code></td>
<td>
<p>a numerical value giving the level for the confidence intervals for the center (x,y)-coordinates.</p>
</td></tr>
<tr><td><code id="groupLocation_+3A_plots">plots</code></td>
<td>
<p>logical: show a 2D-scatterplot?</p>
</td></tr>
<tr><td><code id="groupLocation_+3A_bootci">bootCI</code></td>
<td>
<p>a character vector to select which bootstrap confidence interval type to report. Possible types are <code>'none'</code> (no bootstrap CI), <code>'norm'</code>, <code>'basic'</code>, <code>'perc'</code>, <code>'bca'</code>. See <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>.</p>
</td></tr>
<tr><td><code id="groupLocation_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in <code>xy</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="groupLocation_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Acts as override if variables <code>dist.unit</code> and <code>point.unit</code> are already included in <code>xy</code>. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of replicates for the reported bootstrap confidence intervals is at least 1499. If the BCa interval is reported, it is at least the number of points.
</p>
<p>If package <code>shiny</code> is installed, an interactive web app for this functionality can be run with <code>runGUI("analyze")</code>.
</p>


<h3>Value</h3>

<p>A list with the results from the numerical analyses and statistical tests.
</p>
<table>
<tr><td><code>ctr</code></td>
<td>
<p>(x,y)-offset of group center relative to point of aim.</p>
</td></tr>
<tr><td><code>ctrXci</code></td>
<td>
<p>parametric (t) and bootstrap confidence intervals for center x-coordinate.</p>
</td></tr>
<tr><td><code>ctrYci</code></td>
<td>
<p>parametric (t) and bootstrap confidence intervals for center y-coordinate.</p>
</td></tr>
<tr><td><code>ctrRob</code></td>
<td>
<p>robust estimate of group center offset relative to point of aim (MCD algorithm).</p>
</td></tr>
<tr><td><code>distPOA</code></td>
<td>
<p>distance from group center to point of aim (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>distPOArob</code></td>
<td>
<p>distance from robust estimate of group center to point of aim (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>Hotelling</code></td>
<td>
<p>Hotelling's T^2-Test result from testing if group center equals point of aim.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+getMOA">getMOA</a></code>,
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>,
<code><a href="stats.html#topic+anova.mlm">anova.mlm</a></code>,
<code><a href="boot.html#topic+boot">boot</a></code>,
<code><a href="boot.html#topic+boot.ci">boot.ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
res &lt;- groupLocation(DFsavage, dstTarget=100, conversion='m2mm',
                     level=0.95, plots=2, bootCI='basic')
names(res)
res$ctr
res$distPOA
res$ctrXci
res$ctrYci

# coordinates given by a matrix
## Not run: 
# assume data from pistol shooting at 25m with 9mm ammo
# metric units
xy &lt;- matrix(round(rnorm(100, 0, 5), 2), ncol=2)
groupLocation(xy, dstTarget=25, conversion='m2cm', plots=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='groupShape'>Shape analysis for a single group of bullet holes</h2><span id='topic+groupShape'></span><span id='topic+groupShape.data.frame'></span><span id='topic+groupShape.default'></span>

<h3>Description</h3>

<p>Assesses shape of a single group of bullet holes: Outlier analysis as well as numerical and graphical normality checks for a set of (x,y)-coordinates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupShape(xy, center = FALSE, plots = TRUE, bandW = 0.5,
           outlier = c('mcd', 'pca'), dstTarget, conversion, ...)

## S3 method for class 'data.frame'
groupShape(xy, center = FALSE, plots = TRUE, bandW = 0.5,
           outlier=c('mcd', 'pca'), dstTarget, conversion, ...)

## Default S3 method:
groupShape(xy, center = FALSE, plots = TRUE, bandW = 0.5,
           outlier=c('mcd', 'pca'), dstTarget, conversion, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupShape_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x 2)-matrix with the (x,y)-coordinates of n points (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code> as well as <code>aim.x</code>, <code>aim.y</code> giving the point of aim. If missing, point of aim is assumed to be in (0,0).</p>
</td></tr>
<tr><td><code id="groupShape_+3A_center">center</code></td>
<td>
<p>logical: center groups to mean (0,0) first? If variable <code>series</code> does not exist, all shots are treated as belonging to the same group. Only available in method <code>groupShape.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="groupShape_+3A_plots">plots</code></td>
<td>
<p>logical: show diagrams?</p>
</td></tr>
<tr><td><code id="groupShape_+3A_bandw">bandW</code></td>
<td>
<p>for argument <code>bandwith</code> of <code><a href="graphics.html#topic+smoothScatter">smoothScatter</a></code>.</p>
</td></tr>
<tr><td><code id="groupShape_+3A_outlier">outlier</code></td>
<td>
<p>method for outlier identification: <code>mcd</code> uses robust Mahalanobis distances (see <code><a href="mvoutlier.html#topic+aq.plot">aq.plot</a></code>), <code>pca</code> uses robust principal components analysis (see <code><a href="mvoutlier.html#topic+pcout">pcout</a></code>). Requires installing package <code>mvoutlier</code>.</p>
</td></tr>
<tr><td><code id="groupShape_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in <code>xy</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="groupShape_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Acts as override if variables <code>dist.unit</code> and <code>point.unit</code> are already included in <code>xy</code>. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="groupShape_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="mvoutlier.html#topic+pcout">pcout</a></code> with <code>outlier='pca'</code> - final sensitivity can be adjusted with option <code>outbound</code>, a sensible candidate value seems to be around 0.45.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the numerical results listed below, this function produces the following diagrams:
</p>

<ul>
<li><p> a combined plot for multivariate outlier identification as produced by <code><a href="mvoutlier.html#topic+aq.plot">aq.plot</a></code> - requires installing package <code>mvoutlier</code>
</p>
</li>
<li><p> a chi-square Q-Q-plot for eyeballing multivariate normality as produced by <code><a href="mvoutlier.html#topic+chisq.plot">chisq.plot</a></code>, including a reference line with intercept 0 and slope 1
</p>
</li>
<li><p> a heatmap of a non-parametric 2D-kernel density estimate for the (x,y)-coordinates as produced by <code><a href="graphics.html#topic+smoothScatter">smoothScatter</a></code> together with group center and error ellipses (original and scaled by factor 2) based on a robust estimate for the covariance matrix (from <code><a href="robustbase.html#topic+covMcd">covMcd</a></code> using the MCD algorithm)
</p>
</li>
<li><p> a Q-Q-plot of x-coordinates for eyeballing normality
</p>
</li>
<li><p> a Q-Q-plot of y-coordinates for eyeballing normality
</p>
</li>
<li><p> a histogram of x-coordinates including a fitted normal distribution as well as a non-parametric kernel density estimate
</p>
</li>
<li><p> a histogram of y-coordinates including a fitted normal distribution as well as a non-parametric kernel density estimate
</p>
</li></ul>

<p>If package <code>shiny</code> is installed, an interactive web app for this functionality can be run with <code>runGUI("analyze")</code>.
</p>


<h3>Value</h3>

<p>A list with the results from the numerical analyses and statistical tests.
</p>
<table>
<tr><td><code>corXY</code></td>
<td>
<p>correlation matrix of (x,y)-coordinates.</p>
</td></tr>
<tr><td><code>corXYrob</code></td>
<td>
<p>robust estimate of correlation matrix of (x,y)-coordinates.</p>
</td></tr>
<tr><td><code>Outliers</code></td>
<td>
<p>a vector of row indices for observations identified as outliers - only if package <code>mvoutlier</code> is installed.</p>
</td></tr>
<tr><td><code>ShapiroX</code></td>
<td>
<p>Shapiro-Wilk-Test result for normality of x-coordinates. Only for at most 5000 points. For more than 5000 points, replaced by Kolmogorov-Smirnov-Test in <code>ksX</code>.</p>
</td></tr>
<tr><td><code>ShapiroY</code></td>
<td>
<p>Shapiro-Wilk-Test result for normality of y-coordinates. Only for at most 5000 points. For more than 5000 points, replaced by Kolmogorov-Smirnov-Test in <code>ksY</code>.</p>
</td></tr>
<tr><td><code>multNorm</code></td>
<td>
<p>E-statistic-Test result for multivariate normality of (x,y)-coordinates - only available if package <code>energy</code> is installed.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The chi-square distribution is only strictly valid for squared Mahalanobis distances if the true center and the true covariance matrix are used in calculation. The goodness of approximation for situations where sample estimates are used should be sufficient here.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqnorm">qqnorm</a></code>,
<code><a href="graphics.html#topic+smoothScatter">smoothScatter</a></code>,
<code><a href="graphics.html#topic+hist">hist</a></code>,
<code><a href="stats.html#topic+kernel">kernel</a></code>,
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>,
<code><a href="stats.html#topic+shapiro.test">shapiro.test</a></code>,
<code><a href="stats.html#topic+ks.test">ks.test</a></code>,
<code><a href="energy.html#topic+mvnorm.etest">mvnorm.etest</a></code>,
<code><a href="mvoutlier.html#topic+chisq.plot">chisq.plot</a></code>,
<code><a href="mvoutlier.html#topic+aq.plot">aq.plot</a></code>,
<code><a href="mvoutlier.html#topic+pcout">pcout</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
res &lt;- groupShape(DFsavage, bandW=4, outlier='mcd',
                  dstTarget=100, conversion='m2mm')
names(res)
res$corXY
res$Outliers
res$multNorm

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(200, 0, 5), 2), ncol=2)
groupShape(xy, bandW=1.6)

## End(Not run)
</code></pre>

<hr>
<h2 id='groupSpread'>Precision: Spread measures of a single group of bullet holes</h2><span id='topic+groupSpread'></span><span id='topic+groupSpread.data.frame'></span><span id='topic+groupSpread.default'></span>

<h3>Description</h3>

<p>Provides spread measures and their graphical representations for a single group of bullet holes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupSpread(xy, center = FALSE, plots = TRUE, CEPlevel = 0.5,
            CIlevel = 0.95, CEPtype = 'CorrNormal', bootCI = 'none',
            dstTarget, conversion)

## S3 method for class 'data.frame'
groupSpread(xy, center = FALSE, plots = TRUE, CEPlevel = 0.5,
            CIlevel = 0.95, CEPtype = 'CorrNormal', bootCI = 'none',
            dstTarget, conversion)

## Default S3 method:
groupSpread(xy, center = FALSE, plots = TRUE, CEPlevel = 0.5,
            CIlevel = 0.95, CEPtype = 'CorrNormal', bootCI = 'none',
            dstTarget, conversion)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupSpread_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x 2)-matrix with the (x,y)-coordinates of n points (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code> as well as <code>aim.x</code>, <code>aim.y</code> giving the point of aim. If missing, point of aim is assumed to be in (0,0).</p>
</td></tr>
<tr><td><code id="groupSpread_+3A_center">center</code></td>
<td>
<p>logical: center groups to mean (0,0) first? If variable <code>series</code> does not exist, all shots are treated as belonging to the same group. Only available in method <code>groupSpread.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="groupSpread_+3A_plots">plots</code></td>
<td>
<p>logical: show diagrams?</p>
</td></tr>
<tr><td><code id="groupSpread_+3A_ceplevel">CEPlevel</code></td>
<td>
<p>a numerical value giving the coverage for the CEP and for the confidence ellipse.</p>
</td></tr>
<tr><td><code id="groupSpread_+3A_cilevel">CIlevel</code></td>
<td>
<p>a numerical value giving the level for the confidence intervals (for standard deviations as well as for Rayleigh sigma, RSD, MR).</p>
</td></tr>
<tr><td><code id="groupSpread_+3A_ceptype">CEPtype</code></td>
<td>
<p>string indicating which CEP estimate to report from <code><a href="#topic+getCEP">getCEP</a></code>.</p>
</td></tr>
<tr><td><code id="groupSpread_+3A_bootci">bootCI</code></td>
<td>
<p>a character vector to select which bootstrap confidence interval type to report. Possible types are <code>'none'</code> (no bootstrap CI), <code>'norm'</code>, <code>'basic'</code>, <code>'perc'</code>, <code>'bca'</code>. See <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>.</p>
</td></tr>
<tr><td><code id="groupSpread_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in <code>xy</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="groupSpread_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Acts as override if variables <code>dist.unit</code> and <code>point.unit</code> are already included in <code>xy</code>. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Explanations and formula for many reported precision measures such as CEP, sigma, RSD, MR, FoM can be found in the references.<br />
Robust estimate for the covariance matrix of (x,y)-coordinates is from <code><a href="robustbase.html#topic+covMcd">covMcd</a></code> using the MCD algorithm. <br />
The number of replicates for the reported bootstrap confidence intervals is at least 1499. If the BCa interval is reported, it is at least the number of points. <br />
In addition to the numerical results listed below, this function produces the following diagrams:
</p>

<ul>
<li><p> a scatterplot of the (x,y)-coordinates together with group center, circle with average distance to center, and 100*<code>level</code>%-confidence ellipse - the latter also based on a robust estimate for the covariance matrix
</p>
</li>
<li><p> a scatterplot of the (x,y)-coordinates together with the bounding box, minimum bounding box, minimum enclosing circle, and maximum group spread
</p>
</li>
<li><p> a histogram of distances to group center including a fitted Rayleigh distribution as well as a non-parametric kernel density estimate
</p>
</li></ul>

<p>If package <code>shiny</code> is installed, an interactive web app for this functionality can be run with <code>runGUI("analyze")</code>.
</p>


<h3>Value</h3>

<p>A list with the results from the numerical analyses and statistical tests.
</p>
<table>
<tr><td><code>sdXY</code></td>
<td>
<p>standard deviations of x- and y-coordinates (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>sdXci</code></td>
<td>
<p>parametric (chi^2) and bootstrap confidence intervals for the standard deviation of x-coordinates (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>sdYci</code></td>
<td>
<p>parametric (chi^2) and bootstrap confidence intervals for the standard deviation of y-coordinates (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>sdXYrob</code></td>
<td>
<p>robust standard deviations of x- and y-coordinates (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>covXY</code></td>
<td>
<p>covariance matrix of (x,y)-coordinates.</p>
</td></tr>
<tr><td><code>covXYrob</code></td>
<td>
<p>robust estimate of covariance matrix of (x,y)-coordinates.</p>
</td></tr>
<tr><td><code>distToCtr</code></td>
<td>
<p>mean, median and maximum distance from points to their center as well as estimated Rayleigh parameters sigma (precision), radial standard deviation RSD, and mean radius MR (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>sigmaCI</code></td>
<td>
<p>parametric (chi^2) and bootstrap confidence intervals for sigma (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>RSDci</code></td>
<td>
<p>parametric (chi^2) and bootstrap confidence intervals for radial standard deviation RSD (number of points), in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>MRci</code></td>
<td>
<p>parametric (chi^2) and bootstrap confidence intervals for mean radius MR (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>maxPairDist</code></td>
<td>
<p>maximum pairwise distance between points (center-to-center, = maximum spread, in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>groupRect</code></td>
<td>
<p>width and height of bounding box with diagonal and figure of merit FoM (average side length, in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>groupRectMin</code></td>
<td>
<p>width and height of minimum-area bounding box with diagonal and figure of merit FoM (average side length, in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>minCircleRad</code></td>
<td>
<p>radius for the minimum enclosing circle (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>minEll</code></td>
<td>
<p>length of semi-major and semi-minor axis of the minimum enclosing ellipse (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>confEll</code></td>
<td>
<p>length of semi-major and semi-minor axis of the confidence ellipse (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>confEllRob</code></td>
<td>
<p>length of semi-major and semi-minor axis of the confidence ellipse based on a robust estimate for the covariance matrix (in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
<tr><td><code>confEllShape</code></td>
<td>
<p>aspect ratio of the confidence ellipse (square root of condition index <code><a href="base.html#topic+kappa">kappa</a></code>), its flattening (1 - inverse aspect ratio) as well as the trace and determinant of the covariance matrix.</p>
</td></tr>
<tr><td><code>confEllShapeRob</code></td>
<td>
<p>aspect ratio and flattening of the confidence ellipse based on a robust estimate for the covariance matrix as well as its trace and determinant.</p>
</td></tr>
<tr><td><code>CEP</code></td>
<td>
<p>estimate(s) for the circular error probable (CEP, in original measurement units, MOA, SMOA, milliradian).</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://ballistipedia.com/index.php?title=Describing_Precision">http://ballistipedia.com/index.php?title=Describing_Precision</a>
</p>
<p><a href="http://ballistipedia.com/index.php?title=Measuring_Precision">http://ballistipedia.com/index.php?title=Measuring_Precision</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDistToCtr">getDistToCtr</a></code>,
<code><a href="#topic+getMaxPairDist">getMaxPairDist</a></code>,
<code><a href="#topic+getBoundingBox">getBoundingBox</a></code>,
<code><a href="#topic+getMinBBox">getMinBBox</a></code>,
<code><a href="#topic+getMinCircle">getMinCircle</a></code>,
<code><a href="#topic+getConfEll">getConfEll</a></code>,
<code><a href="#topic+getCEP">getCEP</a></code>,
<code><a href="#topic+getRayParam">getRayParam</a></code>,
<code><a href="#topic+getMOA">getMOA</a></code>,
<code><a href="graphics.html#topic+hist">hist</a></code>,
<code><a href="boot.html#topic+boot">boot</a></code>,
<code><a href="boot.html#topic+boot.ci">boot.ci</a></code>,
<code><a href="stats.html#topic+kernel">kernel</a></code>,
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coordinates given by a suitable data frame
res &lt;- groupSpread(DFtalon, CEPtype=c('Grubbs', 'Rayleigh'), CEPlevel=0.5,
                   CIlevel=0.95, bootCI='none', dstTarget=10, conversion='m2mm')
names(res)
res$sdXYrob
res$distToCtr
res$maxPairDist
res$CEP

# coordinates given by a matrix
## Not run: 
xy &lt;- matrix(round(rnorm(200, 0, 5), 2), ncol=2)
groupSpread(xy, CEPlevel=0.5, CIlevel=0.95, dstTarget=25, conversion='m2cm')

## End(Not run)
</code></pre>

<hr>
<h2 id='Hoyt'>The Hoyt Distribution</h2><span id='topic+Hoyt'></span><span id='topic+dHoyt'></span><span id='topic+pHoyt'></span><span id='topic+qHoyt'></span><span id='topic+rHoyt'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random deviate generation for the Hoyt distribution. The radius around the true mean in a bivariate normal random variable, re-written in polar coordinates (radius and angle), follows a Hoyt distribution. Equivalently, the modulus of a complex normal random variable does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dHoyt(x, qpar, omega)
pHoyt(q, qpar, omega, lower.tail = TRUE)
qHoyt(p, qpar, omega, lower.tail = TRUE, loUp = NULL)
rHoyt(n, qpar, omega, method = c('eigen', 'chol', 'cdf'), loUp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hoyt_+3A_x">x</code>, <code id="Hoyt_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Hoyt_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Hoyt_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="Hoyt_+3A_qpar">qpar</code></td>
<td>
<p>vector of Hoyt shape parameters q. See details.</p>
</td></tr>
<tr><td><code id="Hoyt_+3A_omega">omega</code></td>
<td>
<p>vector of Hoyt scale parameters omega. See details.</p>
</td></tr>
<tr><td><code id="Hoyt_+3A_method">method</code></td>
<td>
<p>string indicating which method to use for generating random deviates. See details.</p>
</td></tr>
<tr><td><code id="Hoyt_+3A_loup">loUp</code></td>
<td>
<p>search interval for numerical root finding. Either a vector with the lower and upper interval boundary, a list of such vectors, or an (n x 2)-matrix. See details.</p>
</td></tr>
<tr><td><code id="Hoyt_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), probabilities are <code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code>qpar</code> and <code>omega</code> may be determined with <code><a href="#topic+getHoytParam">getHoytParam</a></code>.
</p>
<p><code>dHoyt</code> involves the modified Bessel function of the first kind and order 0 (Chew &amp; Boye, 1962; Hoyt, 1947). <code>pHoyt</code> is implemented as the symmetric difference between two Marcum Q-functions (Paris, 2009). The Marcum Q-function is the cdf of a non-central chi^2 variable (Nuttall, 1975).
</p>
<p><code>qHoyt</code> is implemented through numerical root finding of <code>pHoyt</code>. If no search interval for <code><a href="stats.html#topic+uniroot">uniroot</a></code> is provided, the quantiles of an approximating central chi^2 distribution are used to determine the search intervals.
</p>
<p><code>rHoyt</code> with <code>method='eigen'</code> or with <code>method='chol'</code> simulates 2D normal deviates based on the covariance matrix corresponding to parameters <code>qpar</code> and <code>omega</code>, and then determines the radius. <code>rHoyt</code> with <code>method='cdf'</code> is much slower as it performs numerical root finding of <code>pHoyt</code> given simulated quantiles from a uniform random variable in (0,1). If no search interval for <code><a href="stats.html#topic+uniroot">uniroot</a></code> is provided, the quantiles of an approximating central chi^2 distribution are used to determine the search intervals.
</p>
<p>See <code><a href="#topic+Rice">Rice</a></code> for the distribution of radial error around an offset center for uncorrelated bivariate normal variables with equal variances. See <code><a href="#topic+Rayleigh">Rayleigh</a></code> for the distribution of radial error around the true center of uncorrelated bivariate normal variables with equal variances. See <code><a href="#topic+mvnEll">mvnEll</a></code> for the distribution of radial error around an offset center for correlated normal variables with unequal variances.
</p>


<h3>Value</h3>

<p><code>dHoyt</code> gives the density, <code>pHoyt</code> gives the cumulative distribution function, <code>qHoyt</code> gives the quantile function, <code>rHoyt</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rHoyt</code>, and is the maximum of the lengths of the numerical parameters for the other functions.  
</p>
<p>In <code>dHoyt</code>, <code>pHoyt</code> and <code>qHoyt</code>, the numerical parameters are recycled to the length of the result. Only the first element of the logical parameters is used. In <code>rHoyt</code>, only the first element of <code>qpar</code> and <code>omega</code> is used.
</p>


<h3>References</h3>

<p>Chew, V. &amp; Boyce, R. (1962). Distribution of radial error in bivariate elliptical normal distributions. Technometrics, 4(1), 138-140.
</p>
<p>Hoyt, R. S. (1947). Probability functions for the modulus and angle of the normal complex variate.
Bell System Technical Journal, 26(2), 318-359.
</p>
<p>Nuttall, AH. (1975). Some integrals involving the Q-M function.
IEEE Transactions on Information Theory, 21 (1), 95-96
</p>
<p>Paris, JF. 2009. Nakagami-q (Hoyt) distribution function with applications.
Electronics Letters, 45(4). 210-211. Erratum: doi:10.1049/el.2009.0828
</p>
<p><a href="https://reference.wolfram.com/language/ref/HoytDistribution.html">https://reference.wolfram.com/language/ref/HoytDistribution.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getHoytParam">getHoytParam</a></code>,
<code><a href="#topic+Rayleigh">Rayleigh</a></code>,
<code><a href="#topic+Rice">Rice</a></code>,
<code><a href="#topic+mvnEll">mvnEll</a></code>,
<code><a href="base.html#topic+Bessel">Bessel</a></code>,
<code><a href="stats.html#topic+Chisquare">Chisquare</a></code>,
<code><a href="stats.html#topic+uniroot">uniroot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dHoyt(1, qpar=c(0.1, 0.5, 0.9), omega=10)
pHoyt(c(0.1, 0.5, 0.9), qpar=0.5, omega=10)
qHoyt(0.5, qpar=0.5, omega=c(5, 10, 15))
rHoyt(5, qpar=0.5, omega=10)
</code></pre>

<hr>
<h2 id='Maxwell'>The Maxwell-Boltzmann Distribution</h2><span id='topic+Maxwell'></span><span id='topic+dMaxwell'></span><span id='topic+pMaxwell'></span><span id='topic+qMaxwell'></span><span id='topic+rMaxwell'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random deviate generation for the Maxwell-Boltzmann distribution. The radius around the true mean in a trivariate uncorrelated normal random variable with equal variances, re-written in polar coordinates (radius, azimuth, elevation), follows a Maxwell-Boltzmann distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dMaxwell(x, sigma)
pMaxwell(q, sigma, lower.tail = TRUE)
qMaxwell(p, sigma, lower.tail = TRUE)
rMaxwell(n, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Maxwell_+3A_x">x</code>, <code id="Maxwell_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Maxwell_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Maxwell_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="Maxwell_+3A_sigma">sigma</code></td>
<td>
<p>vector of parameter sigma (common standard deviation of the underlying normal distribution of each 3D-coordinate).</p>
</td></tr>
<tr><td><code id="Maxwell_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), probabilities are <code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>sigma</code> may be determined with <code><a href="#topic+getRayParam">getRayParam</a></code>.
</p>
<p>See <code><a href="#topic+Rayleigh">Rayleigh</a></code> for the distribution of radial error around the true center of uncorrelated bivariate normal variables with equal variances. See <code><a href="#topic+Hoyt">Hoyt</a></code> for the distribution of radial error around the true center of correlated bivariate normal variables with unequal variances. See <code><a href="#topic+Rice">Rice</a></code> for the distribution of radial error around an offset center for uncorrelated bivariate normal variables with equal variances. See <code><a href="#topic+mvnEll">mvnEll</a></code> for the distribution of radial error around an offset center for correlated normal variables with unequal variances.
</p>


<h3>Value</h3>

<p><code>dMaxwell</code> gives the density, <code>pMaxwell</code> gives the cumulative distribution function, <code>qMaxwell</code> gives the quantile function, <code>rMaxwell</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rMaxwell</code>, and is the maximum of the lengths of the numerical parameters for the other functions.  
</p>
<p>In <code>dMaxwell</code>, <code>pMaxwell</code> and <code>qMaxwell</code> are recycled to the length of the result. Only the first element of the logical parameters is used. In <code>rRayleigh</code>, only the first element of <code>sigma</code> is used.
</p>


<h3>References</h3>

<p><a href="https://reference.wolfram.com/language/ref/MaxwellDistribution.html">https://reference.wolfram.com/language/ref/MaxwellDistribution.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRayParam">getRayParam</a></code>,
<code><a href="#topic+Rayleigh">Rayleigh</a></code>,
<code><a href="#topic+Hoyt">Hoyt</a></code>,
<code><a href="#topic+Rice">Rice</a></code>,
<code><a href="#topic+mvnEll">mvnEll</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dMaxwell(1, sigma=10)
pMaxwell(c(0.1, 0.5, 0.9), sigma=10)
qMaxwell(0.5, sigma=c(5, 10, 15))
rMaxwell(5, sigma=10)
</code></pre>

<hr>
<h2 id='mvnEll'>Multivariate normal offset ellipse probabilities</h2><span id='topic+mvnEll'></span><span id='topic+pmvnEll'></span><span id='topic+qmvnEll'></span><span id='topic+rmvnEll'></span>

<h3>Description</h3>

<p>Probability of an offset ellipsoid for a correlated multivariate normal distribution. Offset circle probabilities are a special case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvnEll(r=1, sigma = diag(2), mu, e, x0, lower.tail = TRUE,
        method_cdf = c('integrate', 'saddlepoint'))
        
qmvnEll(p,   sigma = diag(2), mu, e, x0, lower.tail = TRUE,
        loUp=NULL, method_cdf = c('integrate', 'saddlepoint'))

rmvnEll(n,   sigma = diag(2), mu, e, x0,
        method = c('eigen', 'chol', 'cdf'), loUp=NULL,
        method_cdf = c('integrate', 'saddlepoint'))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvnEll_+3A_r">r</code></td>
<td>
<p>vector of radii for the offset ellipse defined by <code>e</code>.</p>
</td></tr>
<tr><td><code id="mvnEll_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="mvnEll_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="mvnEll_+3A_sigma">sigma</code></td>
<td>
<p>true positive definite covariance matrix of multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="mvnEll_+3A_mu">mu</code></td>
<td>
<p>true center of multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="mvnEll_+3A_e">e</code></td>
<td>
<p>positive definite matrix characterizing the offset ellipse defined by (x-x0)' e (x-x0) &lt; r^2. If the ellipse defined by <code>e</code> has semi-axis lengths equal to the square root of the eigenvalues of a matrix S, and is oriented along the eigenvectors of S, then e = S^-1. By default a circle.</p>
</td></tr>
<tr><td><code id="mvnEll_+3A_x0">x0</code></td>
<td>
<p>center of the offset ellipse.</p>
</td></tr>
<tr><td><code id="mvnEll_+3A_method">method</code></td>
<td>
<p>string indicating which method to use for generating random deviates. See details.</p>
</td></tr>
<tr><td><code id="mvnEll_+3A_loup">loUp</code></td>
<td>
<p>search interval for numerical root finding. Either a vector with the lower and upper interval boundary, a list of such vectors, or an (n x 2)-matrix. See details.</p>
</td></tr>
<tr><td><code id="mvnEll_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), probabilities are <code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="mvnEll_+3A_method_cdf">method_cdf</code></td>
<td>
<p>string indicating which method to use for calculating the sum of non-central chi^2 variables. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pmvnEll</code> is implemented by first transforming the integration region to the unit disc/sphere, then decorrelating the normal distribution through rotation. Finally, the quadratic form (sum of non-central chi^2 variables) is calculated depending on <code>method_cdf</code>. For <code>method_cdf='integrate'</code>, numerical integration using <code><a href="CompQuadForm.html#topic+farebrother">farebrother</a></code> is chosen, for <code>method_cdf='saddlepoint'</code>, Kuonen's (1999) saddlepoint approximation. Note that the equation for the cumulant generating function K has a missing zeta in the numerator of the second term in Kuonen (1999), see Imhof (1961) instead. Lower tail probabilities are calculated as '1 - upper tail probability', so loss of accuracy is likely when the upper tail probability is very small (&lt;1e-9).
</p>
<p><code>qmvnEll</code> is implemented through numerical root finding of <code>pmvnEll</code>. If no search interval for <code><a href="stats.html#topic+uniroot">uniroot</a></code> is provided, the quantiles of an approximating non-central chi^2 distribution are used to determine the search intervals.
</p>
<p><code>rmvnEll</code> with <code>method='eigen'</code> or with <code>method='chol'</code> simulates 2D normal deviates based on <code>sigma</code> and <code>mu</code>, and then determines the radius around <code>x0</code>. <code>rmvnEll</code> with <code>method='cdf'</code> is much slower as it performs numerical root finding of <code>pmvnEll</code> given simulated quantiles from a uniform random variable in (0,1). If no search interval for <code><a href="stats.html#topic+uniroot">uniroot</a></code> is provided, the quantiles of an approximating non-central chi^2 distribution are used to determine the search intervals.
</p>
<p>See <code><a href="#topic+Hoyt">Hoyt</a></code> for the distribution of radial error around the true center of correlated bivariate normal variables with unequal variances. See <code><a href="#topic+Rice">Rice</a></code> for the distribution of radial error around an offset center for uncorrelated bivariate normal variables with equal variances. See <code><a href="#topic+Rayleigh">Rayleigh</a></code> for the distribution of radial error around the true center of uncorrelated bivariate normal variables with equal variances.
</p>


<h3>Value</h3>

<p><code>pmvnEll</code> integrates the multivariate normal distribution over an arbitrary ellipsoid and thus gives the cumulative distribution function. <code>qmvnEll</code> gives the quantile function, <code>rmvnEll</code> generates random deviates.
</p>
<p>The functions are vectorized in <code>r</code> and <code>p</code> but not in the remaining parameters.
</p>


<h3>References</h3>

<p>DiDonato, A. R., &amp; Jarnagin, M. P. (1961a). Integration of the general bivariate Gaussian
distribution over an offset circle. Mathematics of Computation, 15 (76), 375-382.
</p>
<p>DiDonato, A. R., &amp; Jarnagin, M. P. (1961b). Integration of the general bivariate Gaussian distribution over an offset ellipse (NWL TR 1710). Dahlgren, VA: U.S. Naval Weapons Laboratory.
</p>
<p>Duchesne, P., &amp; Lafaye de Micheaux, P. (2010). Computing the distribution of quadratic forms:
Further comparisons between the Liu-Tang-Zhang approximation and exact methods.
Computational Statistics and Data Analysis, 54, 858-862.
</p>
<p>Imhof, J. P. (1961). Computing the distribution of quadratic forms in normal variables. Biometrika, 48, 419-426.
</p>
<p>Kuonen D. (1999). Saddlepoint Approximations for Distributions of Quadratic Forms in Normal Variables. Biometrika, 86, 929-935.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hoyt">Hoyt</a></code>,
<code><a href="CompQuadForm.html#topic+farebrother">farebrother</a></code>,
<code><a href="stats.html#topic+uniroot">uniroot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define a bivariate normal distribution
mu    &lt;- c(2, -1)                        # true mean
sigma &lt;- cbind(c(10, 6), c(6, 10))       # covariance matrix

# define circular integration region
ctr &lt;- c(1, 0)                           # center
e1  &lt;- diag(2)                           # circle
r   &lt;- 2                                 # radius
pmvnEll(r,   sigma=sigma, mu=mu, e=e1, x0=ctr) # probability
qmvnEll(0.5, sigma=sigma, mu=mu, e=e1, x0=ctr) # quantile
rmvnEll(5,   sigma=sigma, mu=mu, e=e1, x0=ctr) # random numbers

# define elliptical integration region
S  &lt;- cbind(c(3.5, -0.3), c(-0.3, 1.7))
e2 &lt;- solve(S)
pmvnEll(r,   sigma=sigma, mu=mu, e=e2, x0=ctr) # probability
qmvnEll(0.5, sigma=sigma, mu=mu, e=e2, x0=ctr) # quantile
rmvnEll(5,   sigma=sigma, mu=mu, e=e2, x0=ctr) # random numbers

# plot all regions
evSig &lt;- eigen(sigma)$values
evS   &lt;- eigen(S)$values
xLims &lt;- range(c( mu[1]+c(-1, 1)*sqrt(evSig[1]),
                 ctr[1]+c(-r, r)*sqrt(evS[1])))
yLims &lt;- range(c( mu[2]+c(-1.25, 1.25)*sqrt(evSig[1]),
                 ctr[2]+c(-r, r)*sqrt(evS[1])))

plot(xLims, yLims, type="n", asp=1)
points(mu[1],  mu[2],  pch=16, cex=2, col="black")
points(ctr[1], ctr[2], pch=15, cex=2, col="blue")
drawEllipse(mu, sigma, r=0.75, fg="black")
drawEllipse(mu, sigma, r=1,    fg="black")
drawEllipse(mu, sigma, r=1.25, fg="black")
drawEllipse(mu, sigma, r=1.5,  fg="black")
drawEllipse(ctr, e1, r=r, fg="blue")
drawEllipse(ctr, S,  r=r, fg="red")
legend(x="bottomright", legend=c("normal iso-densities",
       "integration circle", "integration ellipse"),
       lty=1, col=c("black", "blue", "red"))
</code></pre>

<hr>
<h2 id='range2CEP'>Estimate circular error probable (CEP) based on range statistics</h2><span id='topic+range2CEP'></span>

<h3>Description</h3>

<p>Estimate the circular error probable (CEP) based on range statistics such as extreme spread, figure of merit, or the bounding box diagonal. This function assumes a circular bivariate normal shot distribution with 0 mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>range2CEP(x, stat="ES", n=5, nGroups=1, CEPlevel=0.5, CIlevel=0.95,
            collapse=TRUE, dstTarget, conversion)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range2CEP_+3A_x">x</code></td>
<td>
<p>a numerical vector with values for extreme spread (ES), figure of merit (FoM), or the diagonal of the bounding box (D).</p>
</td></tr>
<tr><td><code id="range2CEP_+3A_stat">stat</code></td>
<td>
<p>a character vector with elements <code>"ES"</code> (extreme spread), <code>"FoM"</code> (figure of merit), or <code>"D"</code> (bounding box diagonal) indicating which range statistic is given in <code>x</code>. Elements correspond to those in <code>x</code> in the sense that the second element of <code>stat</code> indicates the statistic for the second element of <code>x</code>. If all elements of <code>x</code> are the same kind of statistic, <code>stat</code> only needs to indicate it once.</p>
</td></tr>
<tr><td><code id="range2CEP_+3A_n">n</code></td>
<td>
<p>integer between 2 and 100. Number of shots in each group.</p>
</td></tr>
<tr><td><code id="range2CEP_+3A_ngroups">nGroups</code></td>
<td>
<p>integer between 1 and 10. Number of groups when <code>x</code> is the average of individually-measured range statistics from several groups.</p>
</td></tr>
<tr><td><code id="range2CEP_+3A_ceplevel">CEPlevel</code></td>
<td>
<p>a numerical vector with the coverage values for the CEP.</p>
</td></tr>
<tr><td><code id="range2CEP_+3A_cilevel">CIlevel</code></td>
<td>
<p>confidence level (coverage probability) for the CEP confidence interval. If one of <code>0.5</code>, <code>0.9</code>, <code>0.95</code>, <code>0.99</code>, the CI is based on the corresponding quantiles of the Monte Carlo distribution of the range statistic for given <code>n</code> and <code>nGroups</code>. If not, CI can only be calculated for extreme spread using a Patnaik chi^2 approximation to the conditional distribution as suggested by Taylor and Grubbs (1975).</p>
</td></tr>
<tr><td><code id="range2CEP_+3A_collapse">collapse</code></td>
<td>
<p>logical: should the list with CIs be simplified if possible?</p>
</td></tr>
<tr><td><code id="range2CEP_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="range2CEP_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the lookup table <code><a href="#topic+DFdistr">DFdistr</a></code> with results form a Monte Carlo simulation. The Rayleigh sigma parameter is estimated using <code><a href="#topic+range2sigma">range2sigma</a></code>, and then converted to CEP with <code><a href="#topic+qRayleigh">qRayleigh</a></code>.
</p>
<p>If package <code>shiny</code> is installed, an interactive web app for this functionality can be run with <code>runGUI("range")</code>.
</p>


<h3>Value</h3>

<p>A list with the calculated CEP values in one component, and the corresponding CIs in the other component.
</p>
<table>
<tr><td><code>CEP</code></td>
<td>
<p>The calculated CEP values in the original measurement unit as well as in angular size measures.</p>
</td></tr>
<tr><td><code>CEPCI</code></td>
<td>
<p>The calculated CEP CIs in the original measurement unit as well as in angular size measures.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Taylor, M. S., &amp; Grubbs, F. E. (1975). Approximate Probability Distributions for the Extreme Spread (BRL-MR-2438). Aberdeen Proving Ground, MD: U.S. Ballistic Research Laboratory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DFdistr">DFdistr</a></code>,
<code><a href="#topic+range2sigma">range2sigma</a></code>
<code><a href="#topic+qRayleigh">qRayleigh</a></code>
<code><a href="#topic+getCEP">getCEP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>es  &lt;- getMaxPairDist(DFscar17)$d
fom &lt;- getBoundingBox(DFscar17)$FoM
d   &lt;- getBoundingBox(DFscar17)$diag
range2CEP(c(es, fom, d), stat=c("ES", "FoM", "D"),
          n=nrow(DFscar17), nGroups=1, CEPlevel=0.5, CIlevel=0.9)

# compare with Rayleigh CEP estimate from using
# (x,y)-coordinates of all shots
getCEP(DFscar17, CEPlevel=0.5, type="Rayleigh")
</code></pre>

<hr>
<h2 id='range2sigma'>Estimate Rayleigh sigma based on range statistics</h2><span id='topic+range2sigma'></span>

<h3>Description</h3>

<p>Estimate the Rayleigh sigma parameter based on range statistics like extreme spread, figure of merit, or the bounding box diagonal. This function assumes a circular bivariate normal shot distribution with 0 mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>range2sigma(x, stat="ES", n=5, nGroups=1, CIlevel=0.95,
            collapse=TRUE, dstTarget, conversion)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range2sigma_+3A_x">x</code></td>
<td>
<p>a numerical vector with values for extreme spread (ES), figure of merit (FoM), or the diagonal of the bounding box (D).</p>
</td></tr>
<tr><td><code id="range2sigma_+3A_stat">stat</code></td>
<td>
<p>a character vector with elements <code>"ES"</code> (extreme spread), <code>"FoM"</code> (figure of merit), or <code>"D"</code> (bounding box diagonal) indicating which range statistic is given in <code>x</code>. Elements correspond to those in <code>x</code> in the sense that the second element of <code>stat</code> indicates the statistic for the second element of <code>x</code>. If all elements of <code>x</code> are the same kind of statistic, <code>stat</code> only needs to indicate it once.</p>
</td></tr>
<tr><td><code id="range2sigma_+3A_n">n</code></td>
<td>
<p>integer between 2 and 100. Number of shots in each group.</p>
</td></tr>
<tr><td><code id="range2sigma_+3A_ngroups">nGroups</code></td>
<td>
<p>integer between 1 and 10. Number of groups when <code>x</code> is the average of individually-measured range statistics from several groups.</p>
</td></tr>
<tr><td><code id="range2sigma_+3A_cilevel">CIlevel</code></td>
<td>
<p>confidence level (coverage probability) for the Rayleigh sigma confidence interval. If one of <code>0.5</code>, <code>0.9</code>, <code>0.95</code>, <code>0.99</code>, the CI is based on the corresponding quantiles of the Monte Carlo distribution of the range statistic for given <code>n</code> and <code>nGroups</code>. If not, CI can only be calculated for extreme spread using a Patnaik chi^2 approximation to the conditional distribution as suggested by Taylor and Grubbs (1975).</p>
</td></tr>
<tr><td><code id="range2sigma_+3A_collapse">collapse</code></td>
<td>
<p>logical: should the list with CIs be simplified if possible?</p>
</td></tr>
<tr><td><code id="range2sigma_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value giving the distance to the target - used in MOA calculation. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
<tr><td><code id="range2sigma_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the lookup table <code><a href="#topic+DFdistr">DFdistr</a></code> with results form a Monte Carlo simulation. If the value of <code>n</code> is not among those simulated (but is less than 100), a monotonic spline interpolation between the neighboring simulated values of the statistic's coefficient of variation is used.
</p>
<p>For conversion to the circular error probable, see <code><a href="#topic+range2CEP">range2CEP</a></code>.
</p>
<p>Details for the calculation can be found under
</p>
<p><a href="http://ballistipedia.com/index.php?title=Range_Statistics">http://ballistipedia.com/index.php?title=Range_Statistics</a>
</p>
<p>If package <code>shiny</code> is installed, an interactive web app for this functionality can be run with <code>runGUI("range")</code>.
</p>


<h3>Value</h3>

<p>A list with the calculated values for sigma in one component, and the corresponding CIs in the other component.
</p>
<table>
<tr><td><code>sigma</code></td>
<td>
<p>The calculated values for sigma in the original measurement unit as well as in angular size measures.</p>
</td></tr>
<tr><td><code>sigmaCI</code></td>
<td>
<p>The calculated CIs for sigma in the original measurement unit as well as in angular size measures.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Taylor, M. S., &amp; Grubbs, F. E. (1975). Approximate Probability Distributions for the Extreme Spread (BRL-MR-2438). Aberdeen Proving Ground, MD: U.S. Ballistic Research Laboratory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DFdistr">DFdistr</a></code>,
<code><a href="#topic+range2CEP">range2CEP</a></code>,
<code><a href="#topic+efficiency">efficiency</a></code>,
<code><a href="#topic+getRayParam">getRayParam</a></code>,
<code><a href="#topic+getMaxPairDist">getMaxPairDist</a></code>,
<code><a href="#topic+getBoundingBox">getBoundingBox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>es  &lt;- getMaxPairDist(DFscar17)$d
fom &lt;- getBoundingBox(DFscar17)$FoM
d   &lt;- getBoundingBox(DFscar17)$diag
range2sigma(c(es, fom, d), stat=c("ES", "FoM", "D"),
            n=nrow(DFscar17), nGroups=1, CIlevel=0.9)

# compare with Rayleigh sigma estimate from using
# (x,y)-coordinates of all shots
getRayParam(DFscar17, level=0.9)
</code></pre>

<hr>
<h2 id='rangeStat'>Distribution of range statistics</h2><span id='topic+rangeStat'></span><span id='topic+pRangeStat'></span><span id='topic+qRangeStat'></span><span id='topic+rRangeStat'></span>

<h3>Description</h3>

<p>Approximate cumulative distribution function, quantile function and random deviates of range statistics based on a lookup table generated by simulations. Includes extreme spread (ES), figure of merit (FoM), bounding box diagonal (D). This function assumes a circular bivariate normal shot distribution with 0 mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pRangeStat(q, sigma = 1, nPerGroup = 5, nGroups = 1, stat = c("ES", "FoM", "D"),
           lower.tail = TRUE, loUp)
qRangeStat(p, sigma = 1, nPerGroup = 5, nGroups = 1, stat = c("ES", "FoM", "D"),
           method = c("linear", "spline"), lower.tail = TRUE)
rRangeStat(n, sigma = 1, nPerGroup = 5, nGroups = 1, stat = c("ES", "FoM", "D"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rangeStat_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="rangeStat_+3A_p">p</code></td>
<td>
<p>vector of probabilities. Must be within [0.005, 0.995].</p>
</td></tr>
<tr><td><code id="rangeStat_+3A_n">n</code></td>
<td>
<p>number of observations. Must be &lt;= 100. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rangeStat_+3A_stat">stat</code></td>
<td>
<p>character string indicating the range statistic. One of <code>"ES"</code> (extreme spread), <code>"FoM"</code> (figure of merit), or <code>"D"</code> (bounding box diagonal).</p>
</td></tr>
<tr><td><code id="rangeStat_+3A_npergroup">nPerGroup</code></td>
<td>
<p>integer between 2 and 100. Number of shots in each group.</p>
</td></tr>
<tr><td><code id="rangeStat_+3A_ngroups">nGroups</code></td>
<td>
<p>integer between 1 and 10. Number of groups. For <code>nGroups</code> &gt; 1, the quantile of the average range statistic is returned.</p>
</td></tr>
<tr><td><code id="rangeStat_+3A_sigma">sigma</code></td>
<td>
<p>numeric value &gt; 0 indicating the Rayleigh scale parameter (common standard deviation of the underlying normal distribution of each 2D-coordinate). See <code><a href="#topic+Rayleigh">Rayleigh</a></code>.</p>
</td></tr>
<tr><td><code id="rangeStat_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), probabilities are <code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="rangeStat_+3A_method">method</code></td>
<td>
<p>method for bivariate interpolation if both, <code>p</code> and <code>nPerGroup</code>, are missing from the lookup table. <code>"linear"</code> for bilinear interpolation (requires installing package <code>interp</code>), <code>"spline"</code> for bivariate spline approximation (requires installing package <code>MBA</code>).</p>
</td></tr>
<tr><td><code id="rangeStat_+3A_loup">loUp</code></td>
<td>
<p>search interval for numerical root finding. A vector with the lower and upper interval boundary. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the lookup table <code><a href="#topic+DFdistr">DFdistr</a></code> with results form a Monte Carlo simulation. If the value either for <code>p</code> or for <code>nPerGroup</code> is missing from the lookup table, a monotone spline interpolation between the neighboring simulated values is used.
</p>
<p><code>pRangeStat</code> is implemented through numerical root finding of <code>qRangeStat</code>. If no search interval for <code><a href="stats.html#topic+uniroot">uniroot</a></code> is provided, whole interval of probabilities available in <code><a href="#topic+DFdistr">DFdistr</a></code> is used. <code>NA</code> is returned for quantiles corresponding to probabilities outside of the available range.
</p>


<h3>Value</h3>

<p><code>pRangeStat</code> gives the cumulative distribution function, <code>qRangeStat</code> gives the quantile function, <code>rRangeStat</code> generates random deviates.</p>


<h3>References</h3>

<p><a href="http://ballistipedia.com/index.php?title=Range_Statistics">http://ballistipedia.com/index.php?title=Range_Statistics</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DFdistr">DFdistr</a></code>,
<code><a href="#topic+range2sigma">range2sigma</a></code>,
<code><a href="#topic+Rayleigh">Rayleigh</a></code>,
<code><a href="interp.html#topic+interp">interp</a></code>,
<code><a href="MBA.html#topic+mba.surf">mba.surf</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(q45 &lt;- pRangeStat(c(4, 5), sigma=1.5, n=5, nGroups=3, stat="ES"))

# should be the 4 and 5
qRangeStat(q45, sigma=1.5, n=5, nGroups=3, stat="ES")

rRangeStat(5, sigma=2, nPerGroup=5, nGroups=3, stat="D")
</code></pre>

<hr>
<h2 id='Rayleigh'>The Rayleigh Distribution</h2><span id='topic+Rayleigh'></span><span id='topic+dRayleigh'></span><span id='topic+pRayleigh'></span><span id='topic+qRayleigh'></span><span id='topic+rRayleigh'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random deviate generation for the Rayleigh distribution. The radius around the true mean in a bivariate uncorrelated normal random variable with equal variances, re-written in polar coordinates (radius and angle), follows a Rayleigh distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dRayleigh(x, scale)
pRayleigh(q, scale, lower.tail = TRUE)
qRayleigh(p, scale, lower.tail = TRUE)
rRayleigh(n, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rayleigh_+3A_x">x</code>, <code id="Rayleigh_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Rayleigh_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Rayleigh_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="Rayleigh_+3A_scale">scale</code></td>
<td>
<p>vector of Rayleigh scale parameters (common standard deviation of the underlying normal distribution of each 2D-coordinate).</p>
</td></tr>
<tr><td><code id="Rayleigh_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), probabilities are <code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>scale</code> may be determined with <code><a href="#topic+getRayParam">getRayParam</a></code>.
</p>
<p>See <code><a href="#topic+Maxwell">Maxwell</a></code> for the distribution of radial error around the true center of uncorrelated trivariate normal variables with equal variances. See <code><a href="#topic+Hoyt">Hoyt</a></code> for the distribution of radial error around the true center of correlated bivariate normal variables with unequal variances. See <code><a href="#topic+Rice">Rice</a></code> for the distribution of radial error around an offset center for uncorrelated bivariate normal variables with equal variances. See <code><a href="#topic+mvnEll">mvnEll</a></code> for the distribution of radial error around an offset center for correlated normal variables with unequal variances.
</p>


<h3>Value</h3>

<p><code>dRayleigh</code> gives the density, <code>pRayleigh</code> gives the cumulative distribution function, <code>qRayleigh</code> gives the quantile function, <code>rRayleigh</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rRayleigh</code>, and is the maximum of the lengths of the numerical parameters for the other functions.  
</p>
<p>In <code>dRayleigh</code>, <code>pRayleigh</code> and <code>qRayleigh</code>, the numerical parameters are recycled to the length of the result. Only the first element of the logical parameters is used. In <code>rRayleigh</code>, only the first element of <code>scale</code> is used.
</p>


<h3>References</h3>

<p><a href="https://reference.wolfram.com/language/ref/RayleighDistribution.html">https://reference.wolfram.com/language/ref/RayleighDistribution.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRayParam">getRayParam</a></code>,
<code><a href="#topic+Maxwell">Maxwell</a></code>,
<code><a href="#topic+Rice">Rice</a></code>,
<code><a href="#topic+Hoyt">Hoyt</a></code>,
<code><a href="#topic+mvnEll">mvnEll</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dRayleigh(1, scale=10)
pRayleigh(c(0.1, 0.5, 0.9), scale=10)
qRayleigh(0.5, scale=c(5, 10, 15))
rRayleigh(5, scale=10)
</code></pre>

<hr>
<h2 id='readDataMisc'>Read data from text files</h2><span id='topic+readDataMisc'></span>

<h3>Description</h3>

<p>Reads data from text files that have a similar structure to OnTarget PC/TDS output files, specifically from Taran. Several files can be read with one call.</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDataMisc(fPath = ".", fNames, fPat, combine = TRUE,
            dstTarget, conversion)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDataMisc_+3A_fpath">fPath</code></td>
<td>
<p>a character string containing the path to the folder with the data files, e.g. <code>'c:/folder/otFiles'</code>.</p>
</td></tr>
<tr><td><code id="readDataMisc_+3A_fnames">fNames</code></td>
<td>
<p>a character vector containing the file names of the files that should be read in.</p>
</td></tr>
<tr><td><code id="readDataMisc_+3A_fpat">fPat</code></td>
<td>
<p>a character string containing the regular-expression that describes all names of files that should be read in. E.g., <code>'^points[[:digit:]]{2}\\.txt$'</code> for filenames <code>'points**.txt'</code>, where <code>**</code> are 2 digits. See <code><a href="base.html#topic+regex">regex</a></code>, <code><a href="utils.html#topic+glob2rx">glob2rx</a></code>.</p>
</td></tr>
<tr><td><code id="readDataMisc_+3A_combine">combine</code></td>
<td>
<p>logical: combine the data into one big data frame with <code><a href="#topic+combineData">combineData</a></code>?</p>
</td></tr>
<tr><td><code id="readDataMisc_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value/vector giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in the data.</p>
</td></tr>
<tr><td><code id="readDataMisc_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>fNames</code> is provided, <code>fPat</code> is ignored.
</p>
<p>If neither <code>fNames</code> nor <code>fPat</code> is provided, and we are in interactive mode under Windows, files can be chosen interactively.
</p>
<p>This function is basically a wrapper for <code><a href="utils.html#topic+read.table">read.table</a></code> and <code><a href="utils.html#topic+read.csv">read.csv</a></code>.
</p>
<p>The files need to be either comma-separated or whitespace-delimited, and have a header with the variable names. Variable names must not contain spaces. In order to be later used by functions <code><a href="#topic+analyzeGroup">analyzeGroup</a></code> or <code><a href="#topic+compareGroups">compareGroups</a></code>, coordinates for points of impact must be given with <code>point.x</code>, <code>point.y</code>, <code>x</code>, <code>y</code>, or <code>ShotX</code>, <code>ShotY</code>. Point of aim can be given with <code>aim.x</code>, <code>aim.y</code>, otherwise (0,0) will be assumed in analysis functions. Distance to target can be given with <code>distance</code>, otherwise 100m will be assumed in analysis functions. Files should to contain the variable <code>Group</code> if <code><a href="#topic+combineData">combineData</a></code> should be later used to combine them into one big data frame. There can only be exactly as many variable names as there are non-empty data-columns.
</p>
<p>For reading in files exported from OnTarget PC 1.*, see <code><a href="#topic+readDataOT1">readDataOT1</a></code>. <br />
For reading in files exported from OnTarget PC 2.* or OnTarget TDS v3.*, see <code><a href="#topic+readDataOT2">readDataOT2</a></code>.
</p>


<h3>Value</h3>

<p>With <code>combine=FALSE</code>: a list of data frames, each from one file that was read in. This list can then be combined into one big data frame by <code><a href="#topic+combineData">combineData</a></code>.
</p>
<table>
<tr><td><code>file1</code></td>
<td>
<p>data frame containing data from the first file</p>
</td></tr>
<tr><td><code>file2</code></td>
<td>
<p>data frame containing data from the second file</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>more data frames</p>
</td></tr>
</table>
<p>With <code>combine=TRUE</code>: a combined data frame from <code><a href="#topic+combineData">combineData</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>,
<code><a href="base.html#topic+regex">regex</a></code>,
<code><a href="utils.html#topic+glob2rx">glob2rx</a></code>,
<code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+readDataOT1">readDataOT1</a></code>,
<code><a href="#topic+readDataOT2">readDataOT2</a></code>,
<code><a href="#topic+readDataSMT">readDataSMT</a></code>,
<code><a href="#topic+readDataShotMarker">readDataShotMarker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fPath   &lt;- 'c:/folder/files'             # folder with data files
fileNam &lt;- c('pts01.txt', 'pts02.txt')   # desired files in that folder
DFgroup &lt;- readDataMisc(fPath, fNames=fileNam, combine=TRUE)

## alternatively, specify filename pattern for all files to be read in
fPath   &lt;- 'c:/folder/otFiles'           # folder with data files
fPat    &lt;- '^pts[[:digit:]]{2}\\.txt$' # filename pattern
DFgroup &lt;- readDataMisc(fPath, fPat=pattern, combine=TRUE)

## End(Not run)

## result should look like this
data(DFcm)
head(DFcm)
</code></pre>

<hr>
<h2 id='readDataOT1'>Read data files exported by OnTarget PC v1.1*</h2><span id='topic+readDataOT1'></span>

<h3>Description</h3>

<p>Reads in data from files exported by OnTarget PC v1.1*. Several files can be read with one call.</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDataOT1(fPath = ".", fNames, fPat, combine = TRUE,
            dstTarget, conversion)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDataOT1_+3A_fpath">fPath</code></td>
<td>
<p>a character string containing the path to the folder with the OnTarget PC output files. E.g., <code>'c:/folder/otFiles'</code>.</p>
</td></tr>
<tr><td><code id="readDataOT1_+3A_fnames">fNames</code></td>
<td>
<p>a character vector containing the file names of the files that should be read in.</p>
</td></tr>
<tr><td><code id="readDataOT1_+3A_fpat">fPat</code></td>
<td>
<p>a character string containing the regular-expression that describes all names of files that should be read in. E.g., <code>'^points[[:digit:]]{2}\\.txt$'</code> for filenames <code>'points**.txt'</code>, where <code>**</code> are 2 digits. See <code><a href="base.html#topic+regex">regex</a></code>, <code><a href="utils.html#topic+glob2rx">glob2rx</a></code>.</p>
</td></tr>
<tr><td><code id="readDataOT1_+3A_combine">combine</code></td>
<td>
<p>logical: combine the data into one big data frame with <code><a href="#topic+combineData">combineData</a></code>?</p>
</td></tr>
<tr><td><code id="readDataOT1_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value/vector giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in the data.</p>
</td></tr>
<tr><td><code id="readDataOT1_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>fNames</code> is provided, <code>fPat</code> is ignored. <br /> <br />
If neither <code>fNames</code> nor <code>fPat</code> is provided, and we are in interactive mode under Windows, files can be chosen interactively. <br /> <br />
This function is basically a wrapper for <code><a href="utils.html#topic+read.delim">read.delim</a></code>. <br /> <br />
Output files need to be tab-delimited files from OnTarget PC v1.1*: 'Tools -&gt; Export Point Data'. Files need a trailing tab in each row, and need to contain exactly the following variable names in this order: <code>Project Title</code>, <code>Group</code>, <code>Ammunition</code>, <code>Distance</code>, <code>Aim X</code>, <code>Aim Y</code>, <code>Center X</code>, <code>Center Y</code>, <code>Point X</code>, <code>Point Y</code>. <br /> <br />
Tested with OnTarget PC v1.10. <br />
For reading in files exported from OnTarget PC v2.* or OnTarget TDS v3.*, see <code><a href="#topic+readDataOT2">readDataOT2</a></code>. <br />
For reading in other text files, see <code><a href="#topic+readDataMisc">readDataMisc</a></code>.
</p>


<h3>Value</h3>

<p>With <code>combine=FALSE</code>: a list of data frames, each from one file that was read in. This list can then be combined into one big data frame by <code><a href="#topic+combineData">combineData</a></code>.
</p>
<table>
<tr><td><code>file1</code></td>
<td>
<p>data frame containing data from the first file</p>
</td></tr>
<tr><td><code>file2</code></td>
<td>
<p>data frame containing data from the second file</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>more data frames</p>
</td></tr>
</table>
<p>With <code>combine=TRUE</code>: a combined data frame from <code><a href="#topic+combineData">combineData</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.delim">read.delim</a></code>,
<code><a href="base.html#topic+regex">regex</a></code>,
<code><a href="utils.html#topic+glob2rx">glob2rx</a></code>,
<code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+readDataOT2">readDataOT2</a></code>,
<code><a href="#topic+readDataSMT">readDataSMT</a></code>,
<code><a href="#topic+readDataShotMarker">readDataShotMarker</a></code>,
<code><a href="#topic+readDataMisc">readDataMisc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# folder with OnTarget PC v1.1* output files
fPath   &lt;- 'c:/folder/otFiles'
fileNam &lt;- c('pts01.txt', 'pts02.txt')   # desired files in that folder
DFgroup &lt;- readDataOT1(fPath, fNames=fileNam)

## alternatively, specify filename pattern for all files to be read in
fPath   &lt;- 'c:/folder/otFiles'           # folder with data files
fPat    &lt;- '^pts[[:digit:]]{2}\\.txt$' # filename pattern
DFgroup &lt;- readDataOT1(fPath, fPat=pattern)

## End(Not run)

## result should look like this
data(DFcm)
head(DFcm)
</code></pre>

<hr>
<h2 id='readDataOT2'>Read data files exported by OnTarget PC v2.* or OnTarget TDS v3.*</h2><span id='topic+readDataOT2'></span>

<h3>Description</h3>

<p>Reads in data from files exported by OnTarget PC v2.* or OnTarget TDS v3.*. Several files can be read with one call.</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDataOT2(fPath = ".", fNames, fPat, combine = TRUE,
            dstTarget, conversion)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDataOT2_+3A_fpath">fPath</code></td>
<td>
<p>a character string containing the path to the folder with the OnTarget PC/TDS output files, e.g. <code>'c:/folder/otFiles'</code>.</p>
</td></tr>
<tr><td><code id="readDataOT2_+3A_fnames">fNames</code></td>
<td>
<p>a character vector containing the file names of the files that should be read in.</p>
</td></tr>
<tr><td><code id="readDataOT2_+3A_fpat">fPat</code></td>
<td>
<p>a character string containing the regular-expression that describes all names of files that should be read in. E.g., <code>'^points[[:digit:]]{2}\\.txt$'</code> for filenames <code>'points**.txt'</code>, where <code>**</code> are 2 digits. See <code><a href="base.html#topic+regex">regex</a></code>, <code><a href="utils.html#topic+glob2rx">glob2rx</a></code>.</p>
</td></tr>
<tr><td><code id="readDataOT2_+3A_combine">combine</code></td>
<td>
<p>logical: combine the data into one big data frame with <code><a href="#topic+combineData">combineData</a></code>?</p>
</td></tr>
<tr><td><code id="readDataOT2_+3A_dsttarget">dstTarget</code></td>
<td>
<p>a numerical value/vector giving the distance to the target - used in MOA calculation. Acts as override if variable <code>distance</code> is already included in the data.</p>
</td></tr>
<tr><td><code id="readDataOT2_+3A_conversion">conversion</code></td>
<td>
<p>how to convert the measurement unit for distance to target to that of the (x,y)-coordinates in MOA calculation. Example <code>'m2cm'</code>. See <code><a href="#topic+getMOA">getMOA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>fNames</code> is provided, <code>fPat</code> is ignored. <br /> <br />
If neither <code>fNames</code> nor <code>fPat</code> is provided, and we are in interactive mode under Windows, files can be chosen interactively. <br /> <br />
This function is basically a wrapper for <code><a href="utils.html#topic+read.csv">read.csv</a></code>. <br /> <br />
Output files need to be comma-separated files (file type <code>.csv</code>) from OnTarget PC v2.* or OnTarget TDS v3.*: 'Tools -&gt; Export Point Data'. Files need to contain exactly the following variable names in this order: <code>Project Title</code>, <code>Group</code>, <code>Ammunition</code>, <code>Distance</code>, <code>Aim X</code>, <code>Aim Y</code>, <code>Center X</code>, <code>Center Y</code>, <code>Point X</code>, <code>Point Y</code>, and optionally <code>Velocity</code>. <br /> <br />
Tested with OnTarget PC v2.10 and v2.28 as well as OnTarget TDS v3.71, v3.89, v6.09.<br />
For reading in files exported from OnTarget PC v1.*, see <code><a href="#topic+readDataOT1">readDataOT1</a></code>. <br />
For reading in other text files, see <code><a href="#topic+readDataMisc">readDataMisc</a></code>.
</p>


<h3>Value</h3>

<p>With <code>combine=FALSE</code>: a list of data frames, each from one file that was read in. This list can then be combined into one big data frame by <code><a href="#topic+combineData">combineData</a></code>.
</p>
<table>
<tr><td><code>file1</code></td>
<td>
<p>data frame containing data from the first file</p>
</td></tr>
<tr><td><code>file2</code></td>
<td>
<p>data frame containing data from the second file</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>more data frames</p>
</td></tr>
</table>
<p>With <code>combine=TRUE</code>: a combined data frame from <code><a href="#topic+combineData">combineData</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.csv">read.csv</a></code>,
<code><a href="base.html#topic+regex">regex</a></code>,
<code><a href="utils.html#topic+glob2rx">glob2rx</a></code>,
<code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+readDataOT1">readDataOT1</a></code>,
<code><a href="#topic+readDataSMT">readDataSMT</a></code>,
<code><a href="#topic+readDataShotMarker">readDataShotMarker</a></code>,
<code><a href="#topic+readDataMisc">readDataMisc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# folder with OnTarget PC v2.* or OnTarget TDS v3.* output files
fPath   &lt;- 'c:/folder/otFiles'
fileNam &lt;- c('pts01.csv', 'pts02.csv')   # desired files in that folder
DFgroup &lt;- readDataOT2(fPath, fNames=fileNam, combine=TRUE)

## alternatively, specify filename pattern for all files to be read in
fPath   &lt;- 'c:/folder/otFiles'            # folder with data files
fPat    &lt;- '^pts[[:digit:]]{2}\\.txt$'  # filename pattern
DFgroup &lt;- readDataOT2(fPath, fPat=pattern, combine=TRUE)

## End(Not run)

## result should look like this
data(DFcm)
head(DFcm)
</code></pre>

<hr>
<h2 id='readDataShotMarker'>Read data files exported by the ShotMarker e-target system</h2><span id='topic+readDataShotMarker'></span>

<h3>Description</h3>

<p>Reads in data from files exported by the ShotMarker e-target system. Either CSV files or backup files. Several files can be read with one call.</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDataShotMarker(fPath = ".", fNames, fPat, combine = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDataShotMarker_+3A_fpath">fPath</code></td>
<td>
<p>a character string containing the path to the folder with the ShotMarker output files, e.g. <code>'c:/folder/smFiles'</code>.</p>
</td></tr>
<tr><td><code id="readDataShotMarker_+3A_fnames">fNames</code></td>
<td>
<p>a character vector containing the file names of the files that should be read in. Can be either plain text CSV file(s) or complete <code>.tar</code> backup file(s).</p>
</td></tr>
<tr><td><code id="readDataShotMarker_+3A_fpat">fPat</code></td>
<td>
<p>a character string containing the regular-expression that describes all names of files that should be read in. E.g., <code>'^points[[:digit:]]{2}\\.txt$'</code> for filenames <code>'points**.txt'</code>, where <code>**</code> are 2 digits. See <code><a href="base.html#topic+regex">regex</a></code>, <code><a href="utils.html#topic+glob2rx">glob2rx</a></code>.</p>
</td></tr>
<tr><td><code id="readDataShotMarker_+3A_combine">combine</code></td>
<td>
<p>logical: combine the data into one big data frame with <code><a href="#topic+combineData">combineData</a></code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>fNames</code> is provided, <code>fPat</code> is ignored. <br /> <br />
If neither <code>fNames</code> nor <code>fPat</code> is provided, and we are in interactive mode under Windows, files can be chosen interactively. <br /> <br />
For CSV files, this function is basically a wrapper for <code><a href="utils.html#topic+read.csv">read.csv</a></code>. To read in backup files, package <code>jsonlite</code> must be installed.<br /> <br />
Output files can be comma-separated files (file type <code>.csv</code>) from ShotMarker e-target.<br /> <br />
Coordinates are stored in inch, distance is converted to yard.
</p>


<h3>Value</h3>

<p>With <code>combine=FALSE</code>: a list of data frames, each from one file that was read in. This list can then be combined into one big data frame by <code><a href="#topic+combineData">combineData</a></code>.
</p>
<table>
<tr><td><code>file1</code></td>
<td>
<p>data frame containing data from the first file</p>
</td></tr>
<tr><td><code>file2</code></td>
<td>
<p>data frame containing data from the second file</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>more data frames</p>
</td></tr>
</table>
<p>With <code>combine=TRUE</code>: a combined data frame from <code><a href="#topic+combineData">combineData</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.csv">read.csv</a></code>,
<code><a href="base.html#topic+regex">regex</a></code>,
<code><a href="utils.html#topic+glob2rx">glob2rx</a></code>,
<code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+readDataOT1">readDataOT1</a></code>,
<code><a href="#topic+readDataOT2">readDataOT2</a></code>,
<code><a href="#topic+readDataSMT">readDataSMT</a></code>,
<code><a href="#topic+readDataMisc">readDataMisc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# folder with Silver Mountain e-target output files
fPath   &lt;- 'c:/folder/smtFiles'
fileNam &lt;- c('pts01.csv', 'pts02.csv')    # desired files in that folder
DFgroup &lt;- readDataShotMarker(fPath, fNames=fileNam, combine=TRUE)

## alternatively, specify filename pattern for all files to be read in
fPath   &lt;- 'c:/folder/smtFiles'           # folder with data files
fPat    &lt;- '^pts[[:digit:]]{2}\\.csv$'    # filename pattern
DFgroup &lt;- readDataShotMarker(fPath, fPat=pattern, combine=TRUE)

## End(Not run)

## result should look like this
data(DFcm)
head(DFcm)
</code></pre>

<hr>
<h2 id='readDataSMT'>Read data files exported by the Silver Mountain e-target system</h2><span id='topic+readDataSMT'></span>

<h3>Description</h3>

<p>Reads in data from CSV files exported by the Silver Mountain e-target system. Several files can be read with one call.</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDataSMT(fPath = ".", fNames, fPat, combine = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDataSMT_+3A_fpath">fPath</code></td>
<td>
<p>a character string containing the path to the folder with the SMT output files, e.g. <code>'c:/folder/smtFiles'</code>.</p>
</td></tr>
<tr><td><code id="readDataSMT_+3A_fnames">fNames</code></td>
<td>
<p>a character vector containing the file names of the files that should be read in.</p>
</td></tr>
<tr><td><code id="readDataSMT_+3A_fpat">fPat</code></td>
<td>
<p>a character string containing the regular-expression that describes all names of files that should be read in. E.g., <code>'^points[[:digit:]]{2}\\.txt$'</code> for filenames <code>'points**.txt'</code>, where <code>**</code> are 2 digits. See <code><a href="base.html#topic+regex">regex</a></code>, <code><a href="utils.html#topic+glob2rx">glob2rx</a></code>.</p>
</td></tr>
<tr><td><code id="readDataSMT_+3A_combine">combine</code></td>
<td>
<p>logical: combine the data into one big data frame with <code><a href="#topic+combineData">combineData</a></code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>fNames</code> is provided, <code>fPat</code> is ignored. <br /> <br />
If neither <code>fNames</code> nor <code>fPat</code> is provided, and we are in interactive mode under Windows, files can be chosen interactively. <br /> <br />
This function is basically a wrapper for <code><a href="utils.html#topic+read.csv">read.csv</a></code>. <br /> <br />
Output files need to be comma-separated files (file type <code>.csv</code>) from Silver Mountain e-target. Files need to contain exactly the following variable names in this order: <code>string</code>, <code>shooter</code>, <code>frame</code>, <code>distance</code>, <code>date</code>, <code>score</code>, <code>moa_x</code>, <code>moa_y</code>, <code>scope_x</code>, <code>scope_y</code>, <code>adj_x</code>, <code>adj_y</code>, <code>v</code>, <code>adj_y_avg</code>, <code>adj_y_sd</code>, <code>v_avg</code>, <code>v_sd</code>. <br /> <br />
Coordinates are converted from MOA to inch, distance is converted from meter to yard. <br /> <br />
For reading in other text files, see <code><a href="#topic+readDataMisc">readDataMisc</a></code>.
</p>


<h3>Value</h3>

<p>With <code>combine=FALSE</code>: a list of data frames, each from one file that was read in. This list can then be combined into one big data frame by <code><a href="#topic+combineData">combineData</a></code>.
</p>
<table>
<tr><td><code>file1</code></td>
<td>
<p>data frame containing data from the first file</p>
</td></tr>
<tr><td><code>file2</code></td>
<td>
<p>data frame containing data from the second file</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>more data frames</p>
</td></tr>
</table>
<p>With <code>combine=TRUE</code>: a combined data frame from <code><a href="#topic+combineData">combineData</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.csv">read.csv</a></code>,
<code><a href="base.html#topic+regex">regex</a></code>,
<code><a href="utils.html#topic+glob2rx">glob2rx</a></code>,
<code><a href="#topic+combineData">combineData</a></code>,
<code><a href="#topic+readDataOT1">readDataOT1</a></code>,
<code><a href="#topic+readDataOT2">readDataOT2</a></code>,
<code><a href="#topic+readDataShotMarker">readDataShotMarker</a></code>,
<code><a href="#topic+readDataMisc">readDataMisc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# folder with Silver Mountain e-target output files
fPath   &lt;- 'c:/folder/smtFiles'
fileNam &lt;- c('pts01.csv', 'pts02.csv')    # desired files in that folder
DFgroup &lt;- readDataSMT(fPath, fNames=fileNam, combine=TRUE)

## alternatively, specify filename pattern for all files to be read in
fPath   &lt;- 'c:/folder/smtFiles'           # folder with data files
fPat    &lt;- '^pts[[:digit:]]{2}\\.csv$'    # filename pattern
DFgroup &lt;- readDataSMT(fPath, fPat=pattern, combine=TRUE)

## End(Not run)

## result should look like this
data(DFcm)
head(DFcm)
</code></pre>

<hr>
<h2 id='Rice'>The Rice Distribution</h2><span id='topic+Rice'></span><span id='topic+dRice'></span><span id='topic+pRice'></span><span id='topic+qRice'></span><span id='topic+rRice'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random deviate generation for the Rice distribution. The radius around the origin in a bivariate uncorrelated normal random variable with equal variances and an offset mean, re-written in polar coordinates (radius and angle), follows a Rice distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dRice(x, nu, sigma)
pRice(q, nu, sigma, lower.tail = TRUE)
qRice(p, nu, sigma, lower.tail = TRUE)
rRice(n, nu, sigma, method = c('eigen', 'chol', 'cdf'))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rice_+3A_x">x</code>, <code id="Rice_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Rice_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Rice_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="Rice_+3A_nu">nu</code></td>
<td>
<p>vector of Rice shape parameters nu. See details.</p>
</td></tr>
<tr><td><code id="Rice_+3A_sigma">sigma</code></td>
<td>
<p>vector of Rice scale parameter sigma. See details.</p>
</td></tr>
<tr><td><code id="Rice_+3A_method">method</code></td>
<td>
<p>string indicating which method to use for generating random deviates. See details.</p>
</td></tr>
<tr><td><code id="Rice_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), probabilities are <code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dRice</code> involves the modified Bessel function of the first kind and order 0. <code>pRice</code> and <code>qRice</code> are implemented using the Marcum Q-function. The Marcum Q-function is the cdf of a non-central chi^2 variable (Nuttall, 1975).
</p>
<p><code>rRice</code> with <code>method='eigen'</code> or with <code>method='chol'</code> simulates 2D normal deviates based on the diagonal covariance matrix with entries <code>sigma</code>^2, and then determines the radius. <code>rRice</code> with <code>method='cdf'</code> uses <code>qRice</code> with simulated quantiles from a uniform random variable in (0,1).
</p>
<p>See <code><a href="#topic+Hoyt">Hoyt</a></code> for the distribution of radial error around the true center of correlated bivariate normal variables with unequal variances. See <code><a href="#topic+Rayleigh">Rayleigh</a></code> for the distribution of radial error around the true center of uncorrelated bivariate normal variables with equal variances. See <code><a href="#topic+mvnEll">mvnEll</a></code> for the distribution of radial error around an offset center for correlated normal variables with unequal variances.
</p>
<p>For very large signal-to-noise ratios (nu/sigma), a normal approximation is used.
</p>


<h3>Value</h3>

<p><code>dRice</code> gives the density, <code>pRice</code> gives the cumulative distribution function, <code>qRice</code> gives the quantile function, <code>rRice</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rRice</code>, and is the maximum of the lengths of the numerical parameters for the other functions.  
</p>
<p>In <code>dRice</code>, <code>pRice</code> and <code>qRice</code>, the numerical parameters are recycled to the length of the result. Only the first element of the logical parameters is used. In <code>rRice</code>, only the first element of <code>nu</code> and <code>sigma</code> is used.
</p>


<h3>References</h3>

<p>Nuttall, AH. (1975). Some integrals involving the Q-M function.
IEEE Transactions on Information Theory, 21 (1), 95-96
</p>
<p><a href="https://reference.wolfram.com/language/ref/RiceDistribution.html">https://reference.wolfram.com/language/ref/RiceDistribution.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rayleigh">Rayleigh</a></code>,
<code><a href="#topic+Hoyt">Hoyt</a></code>,
<code><a href="#topic+mvnEll">mvnEll</a></code>,
<code><a href="base.html#topic+Bessel">Bessel</a></code>,
<code><a href="stats.html#topic+Chisquare">Chisquare</a></code>,
<code><a href="stats.html#topic+uniroot">uniroot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dRice(1, nu=c(0.1, 0.5, 0.9), sigma=10)
pRice(c(0.1, 0.5, 0.9), nu=0.5, sigma=10)
qRice(0.5, nu=0.5, sigma=c(5, 10, 15))
rRice(5, nu=0.5, sigma=10)
</code></pre>

<hr>
<h2 id='runGUI'>Open web-based GUI in browser</h2><span id='topic+runGUI'></span>

<h3>Description</h3>

<p>Opens one of four web-based GUIs for <code>shotGroups</code> functionality in an external browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runGUI(app=c("analyze", "hitprob", "range", "angular"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runGUI_+3A_app">app</code></td>
<td>
<p>character string. One of <code>"analyze"</code> - shot group analysis based on data with (x,y)-coordinates of shots, <code>"hitprob"</code> - calculate hit probability within a region, <code>"range"</code> - use measured range statistics to estimate Rayleigh sigma parameter or get required number of groups to achieve a desired CI width, <code>"angular"</code> - angular size conversions</p>
</td></tr>
<tr><td><code id="runGUI_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="shiny.html#topic+runApp">runApp</a></code>. Supply <code>port=80</code> if a web browser refuses to connect to the randomly chosen port for security reasons. Requires installing package<code>shiny</code> first.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires installing package <code>shiny</code> first. This function calls <code><a href="shiny.html#topic+runApp">runApp</a></code> to run the included shotGroupsApp application.
</p>


<h3>See Also</h3>

<p><code><a href="shiny.html#topic+runApp">runApp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
runGUI(app="analzye")

## End(Not run)
</code></pre>

<hr>
<h2 id='simRingCount'>Calculate simulated ring count for a given group and target</h2><span id='topic+simRingCount'></span><span id='topic+simRingCount.data.frame'></span><span id='topic+simRingCount.default'></span>

<h3>Description</h3>

<p>Calculates the simulated ring count given a group, bullet diameter, and target type.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simRingCount(xy, center = FALSE, target, caliber, unit = 'cm')

## S3 method for class 'data.frame'
simRingCount(xy, center = FALSE, target, caliber, unit = 'cm')

## Default S3 method:
simRingCount(xy, center = FALSE, target, caliber, unit='cm')</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simRingCount_+3A_xy">xy</code></td>
<td>
<p>either a numerical (n x 2)-matrix with the (x,y)-coordinates of n points (1 row of coordinates per point), or a data frame with either the variables <code>x</code>, <code>y</code> or <code>point.x</code>, <code>point.y</code> as well as <code>aim.x</code>, <code>aim.y</code> giving the point of aim (= bullseye). If missing, point of aim (bullseye) is assumed to be in (0,0).</p>
</td></tr>
<tr><td><code id="simRingCount_+3A_center">center</code></td>
<td>
<p>logical: center groups to mean (0,0) first? If variable <code>series</code> does not exist, all shots are treated as belonging to the same group. Only available in method <code>simRingCount.data.frame()</code>.</p>
</td></tr>
<tr><td><code id="simRingCount_+3A_target">target</code></td>
<td>
<p>either a character value with the name of a target in <code><a href="#topic+targets">targets</a></code> or a list with a target definition containing the same components as those in <code><a href="#topic+targets">targets</a></code> (<code>name</code>, <code>unitTarget</code>, <code>nRings</code>, <code>ringD10</code>, <code>ringD10i</code>, <code>ringW</code>, <code>cols</code>, <code>colsTxt</code>).</p>
</td></tr>
<tr><td><code id="simRingCount_+3A_caliber">caliber</code></td>
<td>
<p>a numerical value indicating the bullet diameter in mm.</p>
</td></tr>
<tr><td><code id="simRingCount_+3A_unit">unit</code></td>
<td>
<p>measurement unit of the (x,y)-coordinates in <code>xy</code>. Possible values are <code>'cm', 'mm', 'm', 'in', 'ft', 'yd'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned ring count assumes that bullet holes exactly have the diameter given by <code>caliber</code>, and that rings exactly have the diameter/width given in the definition of <code>target</code>. The count thus ignores the possibility of ragged bullet holes as well as the physical width of the ring markings. The simulated ring count therefore need not be equal to the calculated ring count from the corresponding physical target.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>count</code></td>
<td>
<p>the total ring count.</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>the maximum ring count achievable with the given number of shots.</p>
</td></tr>
<tr><td><code>rings</code></td>
<td>
<p>the individual ring count for each shot.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+targets">targets</a></code>,
<code><a href="#topic+getDistToCtr">getDistToCtr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simRingCount(DFscar17, target='ISSF_100m', caliber=5.56, unit='in')

# ring count for all groups in DFcm data set
rc &lt;- by(DFcm, DFcm$series, FUN=simRingCount, target='BDS9',
         caliber=9, unit='cm')

sapply(rc, function(x) with(x, c(count=count, max=max)))
</code></pre>

<hr>
<h2 id='targets'>List containing definitions of several circular target types from the shooting federations ISSF, NRA, DSB, BDS, BDMP, DSU</h2><span id='topic+targets'></span>

<h3>Description</h3>

<p>List containing definitions of several circular german (DSB, BDS, BDMP, DSU), ISSF, and NRA target types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(targets)</code></pre>


<h3>Format</h3>

<p>A list with the following components, each defining one target type.
</p>

<dl>
<dt><code>ISSF_10mAR</code></dt><dd><p>ISSF 10m Air Rifle.</p>
</dd>
<dt><code>ISSF_10mAP</code></dt><dd><p>ISSF 10m Air Pistol.</p>
</dd>
<dt><code>ISSF_25mPP</code></dt><dd><p>ISSF 25m Precision Pistol, 50m Pistol.</p>
</dd>
<dt><code>ISSF_25mRFP</code></dt><dd><p>ISSF 25m Rapid Fire Pistol.</p>
</dd>
<dt><code>ISSF_50m</code></dt><dd><p>ISSF 50m Rifle.</p>
</dd>
<dt><code>ISSF_100m</code></dt><dd><p>ISSF 100m Rifle (same as <code>ISSF_25mPP</code>).</p>
</dd>
<dt><code>ISSF_300m</code></dt><dd><p>ISSF 300m Rifle.</p>
</dd>
<dt><code>ISSF_25ydPP</code></dt><dd><p>ISSF 25m and 50m Precision Pistol target adapted to 25yd.</p>
</dd>
<dt><code>ISSF_50ydPP</code></dt><dd><p>ISSF 25m and 50m Precision Pistol target adapted to 50yd.</p>
</dd>
<dt><code>ISSF_50ftPP</code></dt><dd><p>ISSF 25m and 50m Precision Pistol target adapted to 50ft.</p>
</dd>
<dt><code>ISSF_50ftSP</code></dt><dd><p>ISSF 25m and 50m Precision Pistol target adapted to 50ft Sport Pistol.</p>
</dd>
<dt><code>ISSF_25ydRFP</code></dt><dd><p>ISSF 25m Rapid Fire Pistol target adapted to 25yd.</p>
</dd>
<dt><code>ISSF_50ftRFP</code></dt><dd><p>ISSF 25m Rapid Fire Pistol target adapted to 50ft.</p>
</dd>
<dt><code>ISSF_50ft</code></dt><dd><p>ISSF 50m Rifle target adapted to 50ft.</p>
</dd>
<dt><code>ISSF_50yd</code></dt><dd><p>ISSF 50m Rifle target adapted to 50yd.</p>
</dd>
<dt><code>ISSF_100yd</code></dt><dd><p>ISSF 300m Rifle target adapted to 100yd.</p>
</dd>
<dt><code>ISSF_200yd</code></dt><dd><p>ISSF 300m Rifle target adapted to 200yd.</p>
</dd>
<dt><code>ISSF_300yd</code></dt><dd><p>ISSF 300m Rifle target adapted to 300yd.</p>
</dd>
<dt><code>NRA_HPR_SR</code></dt><dd><p>NRA 200yd High Powered Rifle SR: Military Target, Rifle Competition, Short Range.</p>
</dd>
<dt><code>NRA_HPR_SR3</code></dt><dd><p>NRA 300yd High Powered Rifle SR-3.</p>
</dd>
<dt><code>NRA_P_B16</code></dt><dd><p>NRA 25yd Pistol Slow Fire B-16.</p>
</dd>
<dt><code>NRA_MR-1</code></dt><dd><p>NRA MR-1.</p>
</dd>
<dt><code>NRA_MR-1FC</code></dt><dd><p>NRA MR-1 F-class.</p>
</dd>
<dt><code>NRA_MR-63</code></dt><dd><p>NRA MR-63 300yd.</p>
</dd>
<dt><code>NRA_MR-63FC</code></dt><dd><p>NRA MR-63 F-class.</p>
</dd>
<dt><code>NRA_MR-65</code></dt><dd><p>NRA MR-65 500yd.</p>
</dd>
<dt><code>NRA_MR-65FC</code></dt><dd><p>NRA MR-65 F-class.</p>
</dd>
<dt><code>NRA_LR</code></dt><dd><p>NRA LR.</p>
</dd>
<dt><code>NRA_LRFC</code></dt><dd><p>NRA LR F-class.</p>
</dd>
<dt><code>DSB1</code></dt><dd><p>DSB 10m Luftgewehr (same as <code>ISSF_10mAR</code>).</p>
</dd>
<dt><code>DSB2</code></dt><dd><p>DSB 15m Zimmerstutzen.</p>
</dd>
<dt><code>DSB3</code></dt><dd><p>DSB 50m Kleinkalibergewehr (same as <code>ISSF_50m</code>).</p>
</dd>
<dt><code>DSB4</code></dt><dd><p>DSB 100m Kleinkalibergewehr, 25m Pistole-Praezision, 25m Standardpistole, 50m Pistole (same as <code>ISSF_25mPP</code>).</p>
</dd>
<dt><code>DSB5</code></dt><dd><p>DSB 300m Gewehr/Vorderlader Freigewehr (same as <code>ISSF_300m</code>).</p>
</dd>
<dt><code>DSB6</code></dt><dd><p>DSB 50m Muskete Luntenschlossgewehr.</p>
</dd>
<dt><code>DSB7</code></dt><dd><p>DSB 10m Luftpistole (same as <code>ISSF_10mAP</code>).</p>
</dd>
<dt><code>DSB9</code></dt><dd><p>DSB 25m Schnellfeuerpistole, 25m Pistole Duell (same as <code>ISSF_25mRFP</code>).</p>
</dd>
<dt><code>DSB11</code></dt><dd><p>DSB 10m Laufende Scheibe.</p>
</dd>
<dt><code>BDS1</code></dt><dd><p>BDS 100m.</p>
</dd>
<dt><code>BDS2</code></dt><dd><p>BDS 50m Zielfernrohr.</p>
</dd>
<dt><code>BDS3</code></dt><dd><p>BDS 50m (same as <code>ISSF_50m</code>).</p>
</dd>
<dt><code>BDS4</code></dt><dd><p>BDS 100m Zielfernrohr.</p>
</dd>
<dt><code>BDS5</code></dt><dd><p>BDS Pistole 25m, Pistole 50m (same as <code>ISSF_100m</code>).</p>
</dd>
<dt><code>BDS7</code></dt><dd><p>BDS 300m (same as <code>ISSF_300m</code>).</p>
</dd>
<dt><code>BDS8</code></dt><dd><p>BDS 300m Zielfernrohr.</p>
</dd>
<dt><code>BDS9</code></dt><dd><p>BDS 25m Kurzwaffe.</p>
</dd>
<dt><code>BDS13</code></dt><dd><p>BDS 10m Luftgewehr (same as <code>ISSF_10mAR</code>).</p>
</dd>
<dt><code>BDS14</code></dt><dd><p>BDS 10m Luftpistole (same as <code>DSB7</code>).</p>
</dd>
<dt><code>BDMP1_25m</code></dt><dd><p>BDMP 25m .30 M1 Carbine.</p>
</dd>
<dt><code>BDMP1_50m</code></dt><dd><p>BDMP 50m .30 M1 Carbine.</p>
</dd>
<dt><code>BDMP1_100m</code></dt><dd><p>BDMP 100m SG 1, CISM-Gewehr, .30 M1 Carbine.</p>
</dd>
<dt><code>BDMP2</code></dt><dd><p>BDMP 300m SG 2, CISM-Gewehr, DG 2, FG 1, PVDG 1, PHDG 1, SDG 1, SDG 2, PFG 1, SPPDG 1 (same as <code>ISSF_300m</code>).</p>
</dd>
<dt><code>BDMP3</code></dt><dd><p>BDMP ZG 1.</p>
</dd>
<dt><code>BDMP4</code></dt><dd><p>BDMP ZG 2, ZG 3, ZG 4.</p>
</dd>
<dt><code>BDMP5</code></dt><dd><p>BDMP 300m DG 3, DG 4.</p>
</dd>
<dt><code>DSUa2</code></dt><dd><p>DSU a2.</p>
</dd>
<dt><code>DSUb2</code></dt><dd><p>DSU b2.</p>
</dd>
<dt><code>DSUb3</code></dt><dd><p>DSU b3.</p>
</dd>
<dt><code>DSUb4</code></dt><dd><p>DSU b4.</p>
</dd>
<dt><code>DSUb5</code></dt><dd><p>DSU b5.</p>
</dd>
<dt><code>DSUb5P</code></dt><dd><p>DSU b5 Praezision.</p>
</dd>
<dt><code>DSU_200mP</code></dt><dd><p>DSU 200m Praezision.</p>
</dd>
<dt><code>DSU_UITP</code></dt><dd><p>DSU UIT Praezision (same as <code>ISSF_100m</code>).</p>
</dd>
<dt><code>DSU_KKI</code></dt><dd><p>DSU KK international (same as <code>ISSF_50m</code>).</p>
</dd></dl>



<h3>Details</h3>

<p>Each target is defined by (at least) the following parameters
</p>

<ul>
<li> <p><code>name</code>: target name
</p>
</li>
<li> <p><code>unitTarget</code>: measurement unit for ring diameters and radii
</p>
</li>
<li> <p><code>nRings</code>: number of rings
</p>
</li>
<li> <p><code>maxCount</code>: highest ring count for scoring
</p>
</li>
<li> <p><code>ringD10</code>: diameter of ring number 10 (highest-valued ring)
</p>
</li>
<li> <p><code>ringD10i</code>: diameter of sub-division of ring number 10 (Innenzehn). If target has no sub-division, equal to <code>ringD10</code>
</p>
</li>
<li> <p><code>ringW</code>: width of the remaining rings number 9, 8, 7, ...
</p>
</li>
<li> <p><code>cols</code>: <code>nRings</code>+1 colors of the rings - right half of the target, starting with the sub-division of ring number 10 and going outwards
</p>
</li>
<li> <p><code>colsTxt</code>: <code>nRings</code>-1 colors of the ring numbers, starting with ring number 9 and going outwards
</p>
</li></ul>

<p>A target may have more parameters, e.g., <code>draw</code> to indicate the drawing function that should be used, or <code>countMouche</code> if the inner 10 (mouche) should be counted extra in scoring.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawTarget">drawTarget</a></code>,
<code><a href="#topic+drawGroup">drawGroup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(targets)
names(targets)

targets$ISSF_25mPP
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
