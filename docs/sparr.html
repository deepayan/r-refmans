<!DOCTYPE html><html lang="en"><head><title>Help for package sparr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sparr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sparr-package'><p>The sparr Package: Spatial and Spatiotemporal Relative Risk</p></a></li>
<li><a href='#available.h0'><p>Available global bandwidth range</p></a></li>
<li><a href='#bivariate.density'><p>Bivariate kernel density/intensity estimation</p></a></li>
<li><a href='#BOOT.density'>
<p>Bootstrap bandwidth for a spatial kernel density estimate</p></a></li>
<li><a href='#BOOT.spattemp'>
<p>Bootstrap bandwidths for a spatiotemporal kernel density estimate</p></a></li>
<li><a href='#burk'><p>Burkitt's lymphoma in Uganda</p></a></li>
<li><a href='#fft2d'><p>2D fast-Fourier wrapper around 'fftwtools' or 'stats' package</p></a></li>
<li><a href='#fmd'><p>Veterinary foot-and-mouth disease outbreak data</p></a></li>
<li><a href='#LIK.density'><p>Cross-validation bandwidths for spatial kernel density estimates</p></a></li>
<li><a href='#LIK.spattemp'>
<p>Cross-validation bandwidths for spatiotemporal kernel density estimates</p></a></li>
<li><a href='#LSCV.risk'><p>Jointly optimal bandwidth selection for the spatial relative risk function</p></a></li>
<li><a href='#multiscale.density'><p>Multi-scale adaptive kernel density/intensity estimation</p></a></li>
<li><a href='#multiscale.slice'><p>Slicing a multi-scale density/intensity object</p></a></li>
<li><a href='#NS'><p>Normal scale (NS) bandwidth selector</p></a></li>
<li><a href='#OS'><p>Oversmoothing (OS) bandwidth selector</p></a></li>
<li><a href='#pbc'><p>Primary biliary cirrhosis data</p></a></li>
<li><a href='#plot.bivden'><p>Plotting sparr objects</p></a></li>
<li><a href='#print.bivden'><p>Printing sparr objects</p></a></li>
<li><a href='#rimpoly'><p>Random point generation inside polygon</p></a></li>
<li><a href='#risk'><p>Spatial relative risk/density ratio</p></a></li>
<li><a href='#SLIK.adapt'><p>Simultaneous global/pilot likelihood bandwidth selection</p></a></li>
<li><a href='#sparr-internal'>
<p>Internal <code>sparr</code> functions</p></a></li>
<li><a href='#spattemp.density'>
<p>Spatiotemporal kernel density estimation</p></a></li>
<li><a href='#spattemp.risk'>
<p>Spatiotemporal relative risk/density ratio</p></a></li>
<li><a href='#spattemp.slice'><p>Slicing a spatiotemporal object</p></a></li>
<li><a href='#summary.bivden'><p>Summarising sparr objects</p></a></li>
<li><a href='#tol.classify'><p>Classification by <em>p</em>-value surfaces</p></a></li>
<li><a href='#tol.classplot'><p>Plot tolerance contour classification scheme</p></a></li>
<li><a href='#tol.contour'><p>Plot tolerance contours</p></a></li>
<li><a href='#tolerance'><p>Tolerance by <em>p</em>-value surfaces</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial and Spatiotemporal Relative Risk</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3-16</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to estimate kernel-smoothed spatial and spatio-temporal densities and relative risk functions, and perform subsequent inference. Methodological details can be found in the accompanying tutorial: Davies et al. (2018) &lt;<a href="https://doi.org/10.1002%2Fsim.7577">doi:10.1002/sim.7577</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.1), spatstat (&ge; 2.3-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.utils, spatstat.geom, spatstat.explore,
spatstat.random, spatstat.univar, doParallel, parallel,
foreach, misc3d</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fftwtools (&ge; 0.9.8)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tilmandavies.github.io/sparr/">https://tilmandavies.github.io/sparr/</a>,
<a href="https://github.com/tilmandavies/sparr/">https://github.com/tilmandavies/sparr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tilmandavies/sparr/issues/">https://github.com/tilmandavies/sparr/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-20 01:03:03 UTC; davti75p</td>
</tr>
<tr>
<td>Author:</td>
<td>Tilman M. Davies [aut, cre],
  Jonathan C. Marshall [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tilman M. Davies &lt;tilman.davies@otago.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-20 03:40:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='sparr-package'>The sparr Package: Spatial and Spatiotemporal Relative Risk</h2><span id='topic+sparr-package'></span><span id='topic+sparr'></span>

<h3>Description</h3>

<p>Provides functions to estimate fixed and adaptive kernel-smoothed spatial relative
risk surfaces via the density-ratio method and perform subsequent inference. Fixed-bandwidth spatiotemporal density and relative risk estimation is also supported.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> sparr</td>
</tr>
<tr>
 <td style="text-align: left;">
Date:</td><td style="text-align: left;"> 2025-03-20</td>
</tr>
<tr>
 <td style="text-align: left;">
Version:</td><td style="text-align: left;"> 2.3-16</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Kernel smoothing, and the
flexibility afforded by this methodology, provides an attractive approach to
estimating complex probability density functions.
</p>
<p>The <em>spatial relative risk function</em>, constructed as a ratio of estimated case
to control densities (Bithell, 1990; 1991; Kelsall and Diggle, 1995a,b), describes the variation in the
&lsquo;risk&rsquo; of the disease, given the underlying at-risk population. This is a
technique that has been applied successfully for mainly exploratory purposes
in a number of different analyses (see for example Sabel et al., 2000;
Prince et al., 2001; Wheeler, 2007, Elson et al., 2021). It has also grown in popularity in very
different fields that pose similarly styled research questions, such as ecology
(e.g. Campos and Fedigan, 2014); physiology (Davies et al., 2013); and archaeology
(e.g. Bevan, 2012; Smith et al. 2015).
</p>
<p>This package provides functions for spatial (i.e. bivariate/planar/2D) kernel density estimation
(KDE), implementing both fixed and &lsquo;variable&rsquo; or &lsquo;adaptive&rsquo; (Abramson, 1982)
smoothing parameter options. A selection of bandwidth calculators for bivariate KDE and the
relative risk function are provided, including one based on the maximal
smoothing principle (Terrell, 1990), and others involving a leave-one-out
cross-validation (see below). In addition, the ability to
construct both Monte-Carlo and asymptotic <em>p</em>-value surfaces (&lsquo;tolerance&rsquo;
contours of which signal statistically significant sub-regions of extremity
in a risk surface - Hazelton and Davies, 2009; Davies and Hazelton, 2010) as
well as some visualisation tools are provided.
</p>
<p>Spatiotemporal estimation is also supported, largely following developments
in Fernando and Hazelton (2014). This includes their fixed-bandwith kernel estimator
of spatiotemporal densities, relative risk, and asymptotic tolerance contours.
</p>
<p>Key content of <code>sparr</code> can be broken up as follows:<br />
</p>
<p><b>DATASETS/DATA GENERATION</b>
</p>
<p><code><a href="#topic+pbc">pbc</a></code> a case/control planar point pattern (<code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code>) concerning liver disease in northern
England.
</p>
<p><code><a href="#topic+fmd">fmd</a></code> an anonymised (jittered) case/control spatiotemporal point pattern of the 2001 outbreak of veterinary foot-and-mouth disease in Cumbria (courtesy of the Animal and Plant Health Agency, UK).
</p>
<p><code><a href="#topic+burk">burk</a></code> a spatiotemporal point pattern of Burkitt's lymphoma in Uganda; artificially simulated control data are also provided for experimentation.
</p>
<p>Also available are a number of relevant additional spatial datasets built-in to the
<code><a href="spatstat.html#topic+spatstat">spatstat</a></code> package (Baddeley and Turner, 2005; Baddeley et al., 2015) through <code>spatstat.data</code>, such as
<code><a href="spatstat.data.html#topic+chorley">chorley</a></code>, which concerns the distribution of
laryngeal cancer in an area of Lancashire, UK.
</p>
<p><code><a href="#topic+rimpoly">rimpoly</a></code> a wrapper function of <code><a href="spatstat.random.html#topic+rpoint">rpoint</a></code> to allow generated
spatial point patterns based on a pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age to be returned with a
polygonal <code><a href="spatstat.geom.html#topic+owin">owin</a></code>.<br />
</p>
<p><b>SPATIAL</b>
</p>
<p><em>Bandwidth calculators</em>
</p>
<p><code><a href="#topic+OS">OS</a></code> estimation of an isotropic
smoothing parameter for fixed-bandwidth bivariate KDE, based on the
oversmoothing principle introduced by Terrell (1990).
</p>
<p><code><a href="#topic+NS">NS</a></code>
estimation of an isotropic smoothing parameter for fixed-bandwidth bivariate
KDE, based on the asymptotically optimal value for a normal density
(bivariate normal scale rule - see e.g. Wand and Jones, 1995).
</p>
<p><code><a href="#topic+LSCV.density">LSCV.density</a></code> a least-squares cross-validated (LSCV) estimate
of an isotropic fixed bandwidth for bivariate, edge-corrected KDE (see e.g. Bowman and
Azzalini, 1997).
</p>
<p><code><a href="#topic+LIK.density">LIK.density</a></code> a likelihood cross-validated (LIK) estimate
of an isotropic fixed bandwidth for bivariate, edge-corrected KDE (see e.g. Silverman, 1986).
</p>
<p><code><a href="#topic+SLIK.adapt">SLIK.adapt</a></code> an experimental likelihood cross-validation function
for simultaneous global/pilot bandwidth selection for adaptive density estimates.
</p>
<p><code><a href="#topic+BOOT.density">BOOT.density</a></code> a bootstrap approach to optimisation
of an isotropic fixed bandwidth for bivariate, edge-corrected KDE (see e.g. Taylor, 1989).
</p>
<p><code><a href="#topic+LSCV.risk">LSCV.risk</a></code> Estimation of a jointly optimal,
common isotropic case-control fixed bandwidth for the kernel-smoothed risk
function based on the mean integrated squared error (MISE), a weighted MISE,
or the asymptotic MISE (see respectively Kelsall and Diggle, 1995a; Hazelton, 2008;
Davies, 2013).
</p>
<p><em>Density and relative risk estimation</em>
</p>
<p><code><a href="#topic+bivariate.density">bivariate.density</a></code> kernel density
estimate of bivariate data; fixed or adaptive smoothing.
</p>
<p><code><a href="#topic+multiscale.density">multiscale.density</a></code> multi-scale adaptive kernel density
estimates for multiple global bandwidths as per Davies and Baddeley
(2018).
</p>
<p><code><a href="#topic+multiscale.slice">multiscale.slice</a></code> a single adaptive kernel estimate
based on taking a slice from a multi-scale estimate.
</p>
<p><code><a href="#topic+risk">risk</a></code> estimation of a (log) spatial relative risk function, either from data or
pre-existing bivariate density estimates; fixed (Kelsall and Diggle, 1995a); fixed with shrinkage (Hazelton, 2023); or both asymmetric (Davies and Hazelton, 2010) and symmetric (Davies et al., 2016) adaptive estimates are possible.
</p>
<p><code><a href="#topic+tolerance">tolerance</a></code>
calculation of asymptotic or Monte-Carlo <em>p</em>-value surfaces.
</p>
<p><code><a href="#topic+tol.classify">tol.classify</a></code> classification of individual points based on a 
<em>p</em>-value surface from which tolerance contours are produced.
</p>
<p><em>Visualisation</em>
</p>
<p><code>S3</code> methods of the <code>plot</code> function; see
<code><a href="#topic+plot.bivden">plot.bivden</a></code> for visualising a single bivariate density
estimate from <code><a href="#topic+bivariate.density">bivariate.density</a></code>, <code><a href="#topic+plot.rrs">plot.rrs</a></code> for
visualisation of a spatial relative risk function from
<code><a href="#topic+risk">risk</a></code>, or <code><a href="#topic+plot.msden">plot.msden</a></code> for viewing animations of
multi-scale density estimates from <code><a href="#topic+multiscale.density">multiscale.density</a></code>.
</p>
<p><code><a href="#topic+tol.contour">tol.contour</a></code> provides more flexibility for plotting and
superimposing tolerance contours upon an existing plot of spatial relative risk (i.e. given output from
<code><a href="#topic+tolerance">tolerance</a></code>).
</p>
<p><code><a href="#topic+tol.classplot">tol.classplot</a></code> is a utility to view the classification scheme
with respect to unique tolerance contours/significance regions as 
identified by <code><a href="#topic+tol.classify">tol.classify</a></code>.
</p>
<p><em>Printing and summarising</em>
</p>
<p><code>S3</code> methods (<code><a href="#topic+print.bivden">print.bivden</a></code>, <code><a href="#topic+print.rrs">print.rrs</a></code>,
<code><a href="#topic+print.msden">print.msden</a></code>, <code><a href="#topic+summary.bivden">summary.bivden</a></code>,
<code><a href="#topic+summary.rrs">summary.rrs</a></code>, and <code><a href="#topic+summary.msden">summary.msden</a></code>) are available for
the bivariate density, spatial relative risk, and multi-scale adaptive density objects.
</p>
<p><b>SPATIOTEMPORAL</b>
</p>
<p><em>Bandwidth calculators</em>
</p>
<p><code><a href="#topic+OS.spattemp">OS.spattemp</a></code> estimation of an isotropic
smoothing parameter for the spatial margin and another for the temporal margin
for spatiotemporal densities, based on the 2D and 1D versions, respectively, of the
oversmoothing principle introduced by Terrell (1990).
</p>
<p><code><a href="#topic+NS.spattemp">NS.spattemp</a></code> as above, based on the 2D and 1D versions of the
normal scale rule (Silverman, 1986).
</p>
<p><code><a href="#topic+LSCV.spattemp">LSCV.spattemp</a></code> least-squares cross-validated (LSCV) estimates
of scalar spatial and temporal bandwidths for edge-corrected spatiotemporal KDE.
</p>
<p><code><a href="#topic+LIK.spattemp">LIK.spattemp</a></code> as above, based on likelihood cross-validation.
</p>
<p><code><a href="#topic+BOOT.spattemp">BOOT.spattemp</a></code> bootstrap bandwidth selection for the spatial and temporal margins; 
for spatiotemporal, edge-corrected KDE (Taylor, 1989).
</p>
<p><em>Density and relative risk estimation</em>
</p>
<p><code><a href="#topic+spattemp.density">spattemp.density</a></code> fixed-bandwidth kernel density estimate of spatiotemporal data.
</p>
<p><code><a href="#topic+spattemp.risk">spattemp.risk</a></code> fixed-bandwidth kernel density estimate of spatiotemporal relative risk, either with a time-static or time-varying control density (Fernando and Hazelton, 2014).
</p>
<p><code><a href="#topic+spattemp.slice">spattemp.slice</a></code> extraction function of the spatial density/relative risk at prespecified time(s).
</p>
<p><em>Visualisation</em>
</p>
<p><code>S3</code> methods of the <code>plot</code> function; see
<code><a href="#topic+plot.stden">plot.stden</a></code> for various options (including animation) for visualisation of a spatiotemporal density,
and <code><a href="#topic+plot.rrst">plot.rrst</a></code> for viewing spatiotemporal relative risk surfaces (including animation and tolerance contour superimposition).
</p>
<p><em>Printing and summarising objects</em>
</p>
<p><code>S3</code> methods (<code><a href="#topic+print.stden">print.stden</a></code>, <code><a href="#topic+print.rrst">print.rrst</a></code>, <code><a href="#topic+summary.stden">summary.stden</a></code>, and <code><a href="#topic+summary.rrst">summary.rrst</a></code>) are available for
the spatiotemporal density and spatiotemporal relative risk objects respectively.
</p>


<h3>Dependencies</h3>

<p>The <code>sparr</code> package depends upon
<code><a href="spatstat.html#topic+spatstat">spatstat</a></code>. In particular, the user should familiarise
themselves with <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> objects and
<code><a href="spatstat.geom.html#topic+im">im</a></code> objects, which are used throughout. For spatiotemporal density estimation, <code>sparr</code> is assisted by importing from the <code>misc3d</code> package, and for the
experimental capabilities involving parallel processing, <code>sparr</code> also
currently imports <code><a href="doParallel.html#topic+doParallel">doParallel</a></code>,
<code><a href="parallel.html#topic+parallel">parallel</a></code>, and <code><a href="foreach.html#topic+foreach">foreach</a></code>.
</p>


<h3>Citation</h3>

<p>To cite use of current versions of <code>sparr</code> in publications or research projects please use:<br />
</p>
<p>Davies, T.M., Marshall, J.C. and Hazelton, M.L. (2018) Tutorial on kernel estimation of continuous spatial
and spatiotemporal relative risk, <em>Statistics in Medicine</em>, <b>37</b>(7), 1191-1221. &lt;DOI:10.1002/sim.7577&gt;
</p>
<p>Old versions of <code>sparr</code> (&lt;= 2.1-09) can be referenced by Davies et al. (2011) (see reference list).
</p>


<h3>Author(s)</h3>

<p>T.M. Davies<br /> <em>Dept. of Mathematics &amp; Statistics, University of
Otago, Dunedin, New Zealand.</em><br />
J.C. Marshall<br />
<em>Institute of Fundamantal Sciences, Massey University, Palmerston North, New Zealand.</em><br />
</p>
<p>Maintainer: T.M.D. <a href="mailto:tilman.davies@otago.ac.nz">tilman.davies@otago.ac.nz</a>
</p>


<h3>References</h3>

<p>Abramson, I. (1982), On bandwidth variation in kernel estimates
&mdash; a square root law, <em>Annals of Statistics</em>, <b>10</b>(4),
1217-1223.
</p>
<p>Baddeley, A. and Turner, R. (2005),
spatstat: an R package for analyzing spatial point patterns, <em>Journal
of Statistical Software</em>, <b>12</b>(6), 1-42.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>, Chapman and Hall/CRC Press, UK.
</p>
<p>Bevan A. (2012), Spatial methods for analysing large-scale artefact inventories. <em>Antiquity</em>, <b>86</b>, 492-506.
</p>
<p>Bithell, J.F. (1990), An
application of density estimation to geographical epidemiology,
<em>Statistics in Medicine</em>, <b>9</b>, 691-701.
</p>
<p>Bithell, J.F. (1991),
Estimation of relative risk function, <em>Statistics in Medicine</em>,
<b>10</b>, 1745-1751.
</p>
<p>Bowman, A.W. and Azzalini, A. (1997), <em>Applied
Smoothing Techniques for Data Analysis: The Kernel Approach with S-Plus
Illustrations.</em> Oxford University Press Inc., New York. ISBN
0-19-852396-3.
</p>
<p>Campos, F.A. and Fedigan, L.M. (2014) Spatial ecology of perceived predation risk and vigilance behavior in white-faced capuchins, <em>Behavioral Ecology</em>, <b>25</b>, 477-486.
</p>
<p>Davies, T.M. (2013), Jointly optimal bandwidth selection
for the planar kernel-smoothed density-ratio, <em>Spatial and
Spatio-temporal Epidemiology</em>, <b>5</b>, 51-65.
</p>
<p>Davies, T.M. and Baddeley A. (2018), Fast computation of spatially adaptive kernel estimates,
<em>Statistics and Computing</em>, <b>28</b>(4), 937-956.
</p>
<p>Davies, T.M., Cornwall, J. and Sheard, P.W. (2013) Modelling dichotomously marked muscle fibre configurations, <em>Statistics in Medicine</em>, <b>32</b>, 4240-4258.
</p>
<p>Davies, T.M. and Hazelton, M.L. (2010), Adaptive kernel
estimation of spatial relative risk, <em>Statistics in Medicine</em>,
<b>29</b>(23) 2423-2437.
</p>
<p>Davies, T.M., Hazelton, M.L. and Marshall, J.C.
(2011), <code>sparr</code>: Analyzing spatial relative risk using fixed and
adaptive kernel density estimation in <code>R</code>, <em>Journal of Statistical
Software</em> <b>39</b>(1), 1-14.
</p>
<p>Davies, T.M., Jones, K. and Hazelton, M.L.
(2016), Symmetric adaptive smoothing regimens for estimation of the spatial
relative risk function, <em>Computational Statistics &amp; Data Analysis</em>,
<b>101</b>, 12-28.
</p>
<p>Elson, R., Davies, T. M., Lake, I. R., Vivancos, R., Blomquist, P. B., Charlett, A. and Dabrera, G. (2021), The spatio-temporal distribution of COVID-19 infection in England between January and June 2020, <em>Epidemiology and Infection</em>, <b>149</b>, e73.
</p>
<p>Fernando, W.T.P.S. and Hazelton, M.L. (2014), Generalizing the spatial relative risk function, <em>Spatial and Spatio-temporal Epidemiology</em>, <b>8</b>, 1-10.
</p>
<p>Hazelton, M.L. (2008), Letter to the editor: Kernel
estimation of risk surfaces without the need for edge correction,
<em>Statistics in Medicine</em>, <b>27</b>, 2269-2272.
</p>
<p>Hazelton, M.L. (2023), Shrinkage estimators of the spatial relative
risk function, <em>Submitted for publication</em>.
</p>
<p>Hazelton, M.L. and
Davies, T.M. (2009), Inference based on kernel estimates of the relative
risk function in geographical epidemiology, <em>Biometrical Journal</em>,
<b>51</b>(1), 98-109.
</p>
<p>Kelsall, J.E. and Diggle, P.J. (1995a), Kernel
estimation of relative risk, <em>Bernoulli</em>, <b>1</b>, 3-16.
</p>
<p>Kelsall, J.E. and Diggle, P.J. (1995b), Non-parametric estimation of spatial
variation in relative risk, <em>Statistics in Medicine</em>, <b>14</b>,
2335-2342.
</p>
<p>Prince, M. I., Chetwynd, A., Diggle, P. J., Jarner, M.,
Metcalf, J. V. and James, O. F. W. (2001), The geographical distribution of
primary biliary cirrhosis in a well-defined cohort, <em>Hepatology</em>
<b>34</b>, 1083-1088.
</p>
<p>Sabel, C. E., Gatrell, A. C., Loytonen, M.,
Maasilta, P. and Jokelainen, M. (2000), Modelling exposure opportunitites:
estimating relative risk for motor disease in Finland, <em>Social Science
&amp; Medicine</em> <b>50</b>, 1121-1137.
</p>
<p>Smith, B.A., Davies, T.M. and Higham, C.F.W. (2015) Spatial and social variables in the Bronze Age phase 4 cemetery of Ban Non Wat, Northeast Thailand, <em>Journal of Archaeological Science: Reports</em>, <b>4</b>, 362-370.
</p>
<p>Taylor, C.C. (1989) Bootstrap choice of the smoothing parameter in kernel density estimation, <em>Biometrika</em>, <b>76</b>, 705-712.
</p>
<p>Terrell, G.R. (1990), The maximal
smoothing principle in density estimation, <em>Journal of the American
Statistical Association</em>, <b>85</b>, 470-477.
</p>
<p>Venables, W. N. and Ripley,
B. D. (2002). <em>Modern Applied Statistics with S</em>, Fourth Edition,
Springer, New York.
</p>
<p>Wand, M.P. and Jones, C.M., 1995. <em>Kernel
Smoothing</em>, Chapman &amp; Hall, London.
</p>
<p>Wheeler, D. C. (2007), A comparison
of spatial clustering and cluster detection techniques for childhood
leukemia incidence in Ohio, 1996-2003, <em>International Journal of Health
Geographics</em>, <b>6</b>(13).
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://tilmandavies.github.io/sparr/">https://tilmandavies.github.io/sparr/</a>
</p>
</li>
<li> <p><a href="https://github.com/tilmandavies/sparr/">https://github.com/tilmandavies/sparr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tilmandavies/sparr/issues/">https://github.com/tilmandavies/sparr/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='available.h0'>Available global bandwidth range</h2><span id='topic+available.h0'></span>

<h3>Description</h3>

<p>Gets universally available global bandwidths as represented by several
multi-scale density estimate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available.h0(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="available.h0_+3A_...">...</code></td>
<td>
<p>Any number of objects of class <code><a href="#topic+msden">msden</a></code>; possibly
named.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simple function merely accesses and returns the maximum lower limit and
minimum upper limit of all <code>h0range</code> components of the
<code><a href="#topic+msden">msden</a></code> objects passed through <code>...</code>. Natural numeric error
arising from any changes to the bandwidth-axis discretisation resolution in
the creation of the <code><a href="#topic+msden">msden</a></code> objects (i.e. through the
'<code>dimz</code>' argument) means individual global bandwidth ranges can differ
slightly between affected multi-scale estimates, even if they are all
applied to the same data set. Can additionally be useful when, for example,
creating asymmetric relative risk surfaces based on slices of multi-scale
densities with respect to the case and control data sets, because the
bandwidth factors differ.
</p>
<p>Throws an error if one or more of the <code>h0range</code> components is
incompatible (i.e. all <code>h0range</code> components must overlap).
</p>


<h3>Value</h3>

<p>A numeric vector of length 2 providing the range of available global
bandwidths compatible with all supplied multi-scale density estimates.
</p>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multiscale.density">multiscale.density</a></code>, <code><a href="#topic+multiscale.slice">multiscale.slice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See ?multiscale.slice

</code></pre>

<hr>
<h2 id='bivariate.density'>Bivariate kernel density/intensity estimation</h2><span id='topic+bivariate.density'></span><span id='topic+bivden'></span>

<h3>Description</h3>

<p>Provides an isotropic adaptive or fixed bandwidth kernel density/intensity
estimate of bivariate/planar/2D data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bivariate.density(
  pp,
  h0,
  hp = NULL,
  adapt = FALSE,
  resolution = 128,
  gamma.scale = "geometric",
  edge = c("uniform", "diggle", "none"),
  weights = NULL,
  intensity = FALSE,
  trim = 5,
  xy = NULL,
  pilot.density = NULL,
  leaveoneout = FALSE,
  parallelise = NULL,
  davies.baddeley = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bivariate.density_+3A_pp">pp</code></td>
<td>
<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the observed
2D data set to be smoothed.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_h0">h0</code></td>
<td>
<p>Global bandwidth for adaptive smoothing or fixed bandwidth for
constant smoothing. A numeric value &gt; 0.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_hp">hp</code></td>
<td>
<p>Pilot bandwidth (scalar, numeric &gt; 0) to be used for fixed
bandwidth estimation of a pilot density in the case of adaptive smoothing.
If <code>NULL</code> (default), it will take on the value of <code>h0</code>. Ignored
when <code>adapt = FALSE</code> or if <code>pilot.density</code> is supplied as a
pre-defined pixel image.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_adapt">adapt</code></td>
<td>
<p>Logical value indicating whether to perform adaptive kernel
estimation. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_resolution">resolution</code></td>
<td>
<p>Numeric value &gt; 0. Resolution of evaluation grid; the
density/intensity will be returned on a [<code>resolution</code> <code class="reqn">\times</code>
<code>resolution</code>] grid.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_gamma.scale">gamma.scale</code></td>
<td>
<p>Scalar, numeric value &gt; 0; controls rescaling of the
variable bandwidths. Defaults to the geometric mean of the bandwidth factors
given the pilot density (as per Silverman, 1986). See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_edge">edge</code></td>
<td>
<p>Character string giving the type of edge correction to employ.
<code>"uniform"</code> (default) corrects based on evaluation grid coordinate and
<code>"diggle"</code> reweights each observation-specific kernel. Setting
<code>edge = "none"</code> requests no edge correction. Further details can be
found in the documentation for <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_weights">weights</code></td>
<td>
<p>Optional numeric vector of nonnegative weights corresponding to
each observation in <code>pp</code>. Must have length equal to <code>npoints(pp)</code>.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_intensity">intensity</code></td>
<td>
<p>Logical value indicating whether to return an intensity
estimate (integrates to the sample size over the study region), or a density
estimate (default, integrates to 1).</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_trim">trim</code></td>
<td>
<p>Numeric value &gt; 0; controls bandwidth truncation for adaptive
estimation. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_xy">xy</code></td>
<td>
<p>Optional alternative specification of the evaluation grid; matches
the argument of the same tag in <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>. If
supplied, <code>resolution</code> is ignored.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_pilot.density">pilot.density</code></td>
<td>
<p>An optional pixel image (class
<code><a href="spatstat.geom.html#topic+im">im</a></code>) giving the pilot density to be used for
calculation of the variable bandwidths in adaptive estimation, <b>or</b> a
<code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code> giving the data upon which to base a
fixed-bandwidth pilot estimate using <code>hp</code>. If used, the pixel image
<em>must</em> be defined over the same domain as the data given
<code>resolution</code> or the supplied pre-set <code>xy</code> evaluation grid;
<b>or</b> the planar point pattern data must be defined with respect to the
same polygonal study region as in <code>pp</code>.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_leaveoneout">leaveoneout</code></td>
<td>
<p>Logical value indicating whether to compute and return
the value of the density/intensity at each data point for an adaptive
estimate. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_parallelise">parallelise</code></td>
<td>
<p>Numeric argument to invoke parallel processing, giving
the number of CPU cores to use when <code>leaveoneout = TRUE</code>. Experimental.
Test your system first using <code>parallel::detectCores()</code> to identify the
number of cores available to you.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_davies.baddeley">davies.baddeley</code></td>
<td>
<p>An optional numeric vector of length 3 to control
bandwidth partitioning for approximate adaptive estimation, giving the
quantile step values for the variable bandwidths for density/intensity and
edge correction surfaces and the resolution of the edge correction surface.
May also be provided as a single numeric value. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="bivariate.density_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether to print a function progress
bar to the console when <code>adapt = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a data set <code class="reqn">x_1,\dots,x_n</code> in 2D, the isotropic kernel estimate of
its probability density function, <code class="reqn">\hat{f}(x)</code>, is given by
</p>
<p style="text-align: center;"><code class="reqn">\hat{f}(y)=n^{-1}\sum_{i=1}^{n}h(x_i)^{-2}K((y-x_i)/h(x_i)) </code>
</p>

<p>where <code class="reqn">h(x)</code> is the bandwidth function, and <code class="reqn">K(.)</code> is the
bivariate standard normal smoothing kernel. Edge-correction factors (not
shown above) are also implemented.
</p>

<dl>
<dt><b>Fixed</b></dt><dd>
<p>The classic fixed bandwidth kernel estimator is used when
<code>adapt = FALSE</code>. This amounts to setting <code class="reqn">h(u)=</code><code>h0</code> for all <code class="reqn">u</code>.
Further details can be found in the documentation for <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>.</p>
</dd>
<dt><b>Adaptive</b></dt><dd><p>Setting <code>adapt = TRUE</code> requests computation of Abramson's (1982)
variable-bandwidth estimator. Under this framework, we have
<code class="reqn">h(u)=</code><code>h0</code>*min[<code class="reqn">\tilde{f}(u)^{-1/2}</code>,<code class="reqn">G*</code><code>trim</code>]/<code class="reqn">\gamma</code>,
where <code class="reqn">\tilde{f}(u)</code> is a fixed-bandwidth kernel density estimate
computed using the pilot bandwidth <code>hp</code>.
</p>

<ul>
<li><p> Global smoothing of the variable bandwidths is controlled with the global bandwidth
<code>h0</code>.
</p>
</li>
<li><p> In the above statement, <code class="reqn">G</code> is the geometric mean of the
&ldquo;bandwidth factors&rdquo; <code class="reqn">\tilde{f}(x_i)^{-1/2}</code>; <code class="reqn">i=1,\dots,n</code>. By
default, the variable bandwidths are rescaled by <code class="reqn">\gamma=G</code>, which is
set with <code>gamma.scale = "geometric"</code>. This allows <code>h0</code> to be
considered on the same scale as the smoothing parameter in a fixed-bandwidth
estimate i.e. on the scale of the recorded data. You can use any other
rescaling of <code>h0</code> by setting <code>gamma.scale</code> to be any scalar
positive numeric value; though note this only affects <code class="reqn">\gamma</code> &ndash; see
the next bullet. When using a scale-invariant <code>h0</code>, set
<code>gamma.scale = 1</code>.
</p>
</li>
<li><p> The variable bandwidths must be trimmed to
prevent excessive values (Hall and Marron, 1988). This is achieved through
<code>trim</code>, as can be seen in the equation for <code class="reqn">h(u)</code> above. The
trimming of the variable bandwidths is universally enforced by the geometric
mean of the bandwidth factors <code class="reqn">G</code> independent of the choice of
<code class="reqn">\gamma</code>. By default, the function truncates bandwidth factors at five
times their geometric mean. For stricter trimming, reduce <code>trim</code>, for
no trimming, set <code>trim = Inf</code>.
</p>
</li>
<li><p> For even moderately sized data sets
and evaluation grid <code>resolution</code>, adaptive kernel estimation can be
rather computationally expensive. The argument <code>davies.baddeley</code> is
used to approximate an adaptive kernel estimate by a sum of fixed bandwidth
estimates operating on appropriate subsets of <code>pp</code>. These subsets are
defined by &ldquo;bandwidth bins&rdquo;, which themselves are delineated by a quantile
step value <code class="reqn">0&lt;\delta&lt;1</code>. E.g. setting <code class="reqn">\delta=0.05</code> will create 20
bandwidth bins based on the 0.05th quantiles of the Abramson variable
bandwidths. Adaptive edge-correction also utilises the partitioning, with
pixel-wise bandwidth bins defined using the value <code class="reqn">0&lt;\beta&lt;1</code>, and the
option to decrease the resolution of the edge-correction surface for
computation to a [<code class="reqn">L</code> <code class="reqn">\times</code> <code class="reqn">L</code>] grid, where <code class="reqn">0 &lt;L
        \le</code> <code>resolution</code>. If <code>davies.baddeley</code> is supplied as a vector of
length 3, then the values <code>[1], [2], and [3]</code> correspond to the
parameters <code class="reqn">\delta</code>, <code class="reqn">\beta</code>, and <code class="reqn">L_M=L_N</code> in Davies and
Baddeley (2018). If the argument is simply a single numeric value, it is
used for both <code class="reqn">\delta</code> and <code class="reqn">\beta</code>, with
<code class="reqn">L_M=L_N=</code><code>resolution</code> (i.e. no edge-correction surface
coarsening).
</p>
</li>
<li><p> Computation of leave-one-out values (when
<code>leaveoneout = TRUE</code>) is done by brute force, and is therefore very
computationally expensive for adaptive smoothing. This is because the
leave-one-out mechanism is applied to both the pilot estimation and the
final estimation stages. Experimental code to do this via parallel
processing using the <code><a href="foreach.html#topic+foreach">foreach</a></code> routine is implemented.
Fixed-bandwidth leave-one-out can be performed directly in
<code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>.
</p>
</li></ul>

</dd>
</dl>



<h3>Value</h3>

<p>If <code>leaveoneout = FALSE</code>, an object of class <code>"bivden"</code>.
This is effectively a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>z</code></td>
<td>
<p>The
resulting density/intensity estimate, a pixel image object of class
<code><a href="spatstat.geom.html#topic+im">im</a></code>.</p>
</td></tr>
<tr><td><code>h0</code></td>
<td>
<p>A copy of the value of <code>h0</code>
used.</p>
</td></tr> <tr><td><code>hp</code></td>
<td>
<p>A copy of the value of <code>hp</code> used.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>A numeric
vector of length equal to the number of data points, giving the bandwidth
used for the corresponding observation in <code>pp</code>.</p>
</td></tr>
<tr><td><code>him</code></td>
<td>
<p>A pixel
image (class <code><a href="spatstat.geom.html#topic+im">im</a></code>), giving the &lsquo;hypothetical&rsquo; Abramson
bandwidth at each pixel coordinate conditional upon the observed data.
<code>NULL</code> for fixed-bandwidth estimates.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>Edge-correction
weights; a pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age if <code>edge = "uniform"</code>, a
numeric vector if <code>edge = "diggle"</code>, and <code>NULL</code> if <code>edge =
"none"</code>.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>The value of <code class="reqn">\gamma</code> used in scaling the
bandwidths. <code>NA</code> if a fixed bandwidth estimate is computed.</p>
</td></tr>
<tr><td><code>geometric</code></td>
<td>
<p>The geometric mean <code class="reqn">G</code> of the untrimmed bandwidth
factors <code class="reqn">\tilde{f}(x_i)^{-1/2}</code>. <code>NA</code> if a fixed bandwidth estimate
is computed.</p>
</td></tr>
<tr><td><code>pp</code></td>
<td>
<p>A copy of the <code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code>
initially passed to the <code>pp</code> argument, containing the data that were
smoothed.</p>
</td></tr>
</table>
<p>Else, if <code>leaveoneout = TRUE</code>, simply a numeric vector of length equal to the
number of data points, giving the leave-one-out value of the function at the
corresponding coordinate.
</p>


<h3>Author(s)</h3>

<p>T.M. Davies and J.C. Marshall
</p>


<h3>References</h3>

<p>Abramson, I. (1982). On bandwidth variation in kernel estimates
&mdash; a square root law, <em>Annals of Statistics</em>, <b>10</b>(4),
1217-1223.
</p>
<p>Davies, T.M. and Baddeley A. (2018), Fast computation of
spatially adaptive kernel estimates, <em>Statistics and Computing</em>, <b>28</b>(4), 937-956.
</p>
<p>Davies, T.M. and Hazelton, M.L. (2010), Adaptive kernel estimation of spatial relative
risk, <em>Statistics in Medicine</em>, <b>29</b>(23) 2423-2437.
</p>
<p>Davies, T.M., Jones, K. and Hazelton, M.L. (2016), Symmetric adaptive smoothing
regimens for estimation of the spatial relative risk function,
<em>Computational Statistics &amp; Data Analysis</em>, <b>101</b>, 12-28.
</p>
<p>Diggle, P.J. (1985), A kernel method for smoothing point process data,
<em>Journal of the Royal Statistical Society, Series C</em>, <b>34</b>(2),
138-147.
</p>
<p>Hall P. and Marron J.S. (1988) Variable window width kernel
density estimates of probability densities. <em>Probability Theory and
Related Fields</em>, <b>80</b>, 37-49.
</p>
<p>Marshall, J.C. and Hazelton, M.L. (2010) Boundary kernels for adaptive density
estimators on regions with irregular boundaries, <em>Journal of Multivariate
Analysis</em>, <b>101</b>, 949-963.
</p>
<p>Silverman, B.W. (1986), <em>Density Estimation for
Statistics and Data Analysis</em>, Chapman &amp; Hall, New York.
</p>
<p>Wand, M.P. and Jones, C.M., 1995. <em>Kernel Smoothing</em>, Chapman &amp; Hall, London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(chorley) # Chorley-Ribble data from package 'spatstat'

# Fixed bandwidth kernel density; uniform edge correction
chden1 &lt;- bivariate.density(chorley,h0=1.5) 

# Fixed bandwidth kernel density; diggle edge correction; coarser resolution
chden2 &lt;- bivariate.density(chorley,h0=1.5,edge="diggle",resolution=64) 


# Adaptive smoothing; uniform edge correction
chden3 &lt;- bivariate.density(chorley,h0=1.5,hp=1,adapt=TRUE)

# Adaptive smoothing; uniform edge correction; partitioning approximation
chden4 &lt;- bivariate.density(chorley,h0=1.5,hp=1,adapt=TRUE,davies.baddeley=0.025)
 
oldpar &lt;- par(mfrow=c(2,2))
plot(chden1);plot(chden2);plot(chden3);plot(chden4)
par(oldpar)


</code></pre>

<hr>
<h2 id='BOOT.density'>
Bootstrap bandwidth for a spatial kernel density estimate
</h2><span id='topic+BOOT.density'></span>

<h3>Description</h3>

<p>Isotropic fixed or global (for adaptive) bandwidth selection for a standalone 2D density based on bootstrap estimation of the MISE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BOOT.density(pp, hlim = NULL, eta = NULL, type = c("fixed", "adaptive"),
  hp = NULL, edge = c("uniform", "none"), ref.density = NULL,
  resolution = 64, rmdiag = TRUE, sim.adapt = list(N = 50, B = 100,
  dimz = 64, objective = FALSE), parallelise = NA, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BOOT.density_+3A_pp">pp</code></td>
<td>

<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the observed 2D data to be smoothed.
</p>
</td></tr>
<tr><td><code id="BOOT.density_+3A_hlim">hlim</code></td>
<td>

<p>An optional vector of length 2 giving the limits of the optimisation routine with respect to the bandwidth. If <code>NULL</code>, the function attempts to choose this automatically.
</p>
</td></tr>
<tr><td><code id="BOOT.density_+3A_eta">eta</code></td>
<td>

<p>Fixed scalar bandwidth to use for the reference density estimate; if <code>NULL</code> it is calculated as the oversmoothing bandwidth of <code>pp</code> using <code><a href="#topic+OS">OS</a></code>. Ignored if <code>ref.density</code> is supplied. See &lsquo;Details&rsquo;. 
</p>
</td></tr>
<tr><td><code id="BOOT.density_+3A_type">type</code></td>
<td>

<p>A character string indicating selection type. Either <code>"fixed"</code> (default) for selection of a constant bandwidth for the fixed-bandwidth estimator based on theory extended from results in Taylor (1989); or <code>"adaptive"</code> for selection of the global bandwidth for an adaptive kernel density. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="BOOT.density_+3A_hp">hp</code></td>
<td>

<p>Pilot bandwidth used for adaptive estimates in the bootstrap; see the argument of the same tag in <code><a href="#topic+bivariate.density">bivariate.density</a></code>. Ignored when <code>type = "fixed"</code> or when <code>ref.density</code> is supplied.
</p>
</td></tr>
<tr><td><code id="BOOT.density_+3A_edge">edge</code></td>
<td>

<p>Character string dictating edge correction for the bootstrapped estimates. <code>"uniform"</code> (default) corrects based on evaluation grid coordinate. Setting <code>edge="none"</code> requests no edge correction.
</p>
</td></tr>
<tr><td><code id="BOOT.density_+3A_ref.density">ref.density</code></td>
<td>

<p>Optional. An object of class <code><a href="#topic+bivden">bivden</a></code> giving the reference density from which data will be generated. Based on theory, this must be a fixed-bandwidth estimate if <code>type = "fixed"</code>; see &lsquo;Details&rsquo;. Must be edge-corrected if <code>edge = "uniform"</code>.
</p>
</td></tr>
<tr><td><code id="BOOT.density_+3A_resolution">resolution</code></td>
<td>

<p>Spatial grid size; the optimisation will be based on a [<code>resolution</code> <code class="reqn">\times</code> <code>resolution</code>] density estimate.
</p>
</td></tr>
<tr><td><code id="BOOT.density_+3A_rmdiag">rmdiag</code></td>
<td>

<p>Logical control value for removal of mirrored evaluation points as suggested by Taylor (1989) in the theoretical expression of the fixed-bandwidth MISE estimate. See &lsquo;Details&rsquo;. Ignored when <code>type = "adaptive"</code>
</p>
</td></tr>
<tr><td><code id="BOOT.density_+3A_sim.adapt">sim.adapt</code></td>
<td>

<p>List of control values for bootstrap simulation in the adaptive case; see &lsquo;Details&rsquo;. Ignored when <code>type = "fixed"</code>.
</p>
</td></tr>
<tr><td><code id="BOOT.density_+3A_parallelise">parallelise</code></td>
<td>

<p>Optional numeric argument to reduce computation time by invoking parallel processing, by giving the number of CPU cores to use in either evaluation (fixed) or in the actual bootstrap replicate generation (adaptive). Experimental. Test your system first using <code>parallel::detectCores()</code> to identify the number of cores available to you.
</p>
</td></tr>
<tr><td><code id="BOOT.density_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print function progress during execution.
</p>
</td></tr>
<tr><td><code id="BOOT.density_+3A_...">...</code></td>
<td>

<p>Optional arguments controlling scaling to be passed to <code><a href="#topic+multiscale.density">multiscale.density</a></code> for the adaptive bootstrap; ignored when <code>type = "fixed"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a 2D kernel density estimate <code class="reqn">\hat{f}</code> defined on <code class="reqn">W \in R^2</code>, the mean integrated squared error (MISE) is given by <code class="reqn">E[\int_W (\hat{f}(x) - f(x))^2 dx]</code>, where <code class="reqn">f</code> is the corresponding true density. Given an observed data set <code class="reqn">X</code> (argument <code>pp</code>) of <code class="reqn">n</code> observations, this function finds the bandwidth <code class="reqn">h</code> that minimises
</p>
<p style="text-align: center;"><code class="reqn">E^*[\int_W (\hat{f}^*(x) - \hat{f}(x))^2 dx],</code>
</p>

<p>where <code class="reqn">\hat{f}(x)</code> is a density estimate of <code class="reqn">X</code> constructed with &lsquo;reference&rsquo; bandwidth <code class="reqn">\eta</code> (argument <code>eta</code> or <code>ref.density</code>), and <code class="reqn">\hat{f}^*(x)</code> is a density estimate using bandwidth <code class="reqn">h</code> of <code class="reqn">n</code> observations <code class="reqn">X^*</code> generated from <code class="reqn">\hat{f}(x)</code>. The notation <code class="reqn">E^*</code> denotes expectation with respect to the distribution of the <code class="reqn">X^*</code>.
</p>

<dl>
<dt><b>Fixed</b></dt><dd>
<p>When <code>type = "fixed"</code>, the function assumes you want to select a constant bandwidth for use with the fixed-bandwith density estimator. This implementation is based on extending the remarkable results of Taylor (1989) (see also Sain et al., 1994), who demonstrates that when the Gaussian kernel is being used, we can find the optimal <code class="reqn">h</code> with respect to the aforementioned bootstrap-estimated MISE without any actual resampling. This implementation extends these results to the bivariate setting, and allows for edge-correction of both the reference and bootstrap densities.
</p>

<ul>
<li><p> Taylor (1989) does not distinguish between the reference bandwidth <code class="reqn">\eta</code> and the target of optimisation, <code class="reqn">h</code>, thus allowing the reference bandwidth to vary alongside the target in the optimisation. This is not optimal, and this function always assumes a static reference bandwidth. Hall et al. (1992) indicate that a generous amount of smoothing is to be preferred in the reference density (hence the default <code>eta</code> set using <code><a href="#topic+OS">OS</a></code>).
</p>
</li>
<li><p> If <code>ref.density</code> is supplied, it <b>must</b> be a fixed-bandwidth density estimate as an object of class <code><a href="#topic+bivden">bivden</a></code> for validity of the theory. Edge-correction must be present if <code>edge = "uniform"</code>; and it must be evaluated on the same spatial domain as dictated by <code>Window(pp)</code> and <code>resolution</code>. If unsupplied, the function internally computes an appropriate fixed-bandwidth density estimate using <code>eta</code> as the reference bandwidth.
</p>
</li>
<li><p> Finally, Taylor (1989) argues it is preferable to avoid summation at identical evaluation grid points in the expression for the optimal bandwidth, which is performed when <code>rmdiag = TRUE</code>. Setting <code>rmdiag = FALSE</code> disables this correction.
</p>
</li></ul>

</dd>
<dt><b>Adaptive</b></dt><dd>
<p>When <code>type = "adaptive"</code>, the function assumes you want to select a global bandwidth (argument <code>h0</code> in <code><a href="#topic+bivariate.density">bivariate.density</a></code>) for use in 2D adaptive kernel density estimation.
</p>

<ul>
<li><p> An expression similar to Taylor (1989) is not possible for the adaptive estimator. Thus, in the adaptive setting, the optimal bootstrap bandwidth is calculated by brute force as was performed in Davies and Baddeley (2018) by taking advantage of the multiscale estimation theory implemented in <code><a href="#topic+multiscale.density">multiscale.density</a></code>. The value that minimises an interpolating cubic spline of the estimated MISE on bandwidth is identified as the optimal global bandwidth.
</p>
</li>
<li><p> The user can pass either a fixed or adaptive <code>bivden</code> object to <code>ref.density</code>. If this is the case, <code>hp</code> is ignored and the pilot bandwidth for each iteration of the bootstrap in estimation of the <code class="reqn">\hat{f}^*(x)</code> uses <code>ref.density$hp</code> (if <code>ref.density</code> is adaptive) or <code>ref.density$h0</code> (if <code>ref.density</code> is fixed). When <code>ref.density</code> is unsupplied, the function uses a fixed-bandwidth kernel estimate with bandwidth <code>eta</code> as the reference density, and if additionally <code>hp</code> is unsupplied, the same value <code>eta</code> is used for the constant pilot bandwidth.
</p>
</li>
<li><p> Control over the bootstrap is achieved with four optional named arguments passed as a list to <code>sim.adapt</code>. <code>N</code> controls the number of bootstrap iterates per bandwidth; <code>B</code> controls the resolution of the sequence of bandwidths trialled (i.e. between <code>hlim[1]</code> and <code>hlim[2]</code>); <code>dimz</code> specifies the resolution of the bandwidth axis in the trivariate convolution evaluated by <code><a href="#topic+multiscale.density">multiscale.density</a></code>; and <code>objective</code> specifies whether to return the set of estimated MISEs for all bandwidths (nice to plot), or merely the optimal bandwidth (see &lsquo;Value&rsquo;).
</p>
</li>
<li><p> The <code>...</code> are intended for any relevant optional arguments to be passed to the internal call to <code><a href="#topic+multiscale.density">multiscale.density</a></code>, such as <code>gamma.scale</code> or <code>trim</code>.
</p>
</li></ul>

</dd>
</dl>



<h3>Value</h3>

<p>The optimal fixed or global (for adaptive) scalar bandwidth. If <code>simargs$objective = TRUE</code> for the adaptive bootstrap, the return object is instead a <code class="reqn">[</code><code>simargs$B</code> <code class="reqn">x 2]</code> matrix, with the first column giving the trialled bandwidth and the second giving the corresponding value of the estimated bootstrap MISE.
</p>


<h3>Warning</h3>

<p>Even with the implemented computational tricks, bootstrapping for bandwidth selection for spatial data is still computationally demanding, especially for adaptive kernel estimates. The user can reduce this time by keeping the evaluation grid at modest <code>resolution</code>s, and experimenting with parallelising the internal loops via <code>parallelise</code>. The &lsquo;Examples&rsquo; section offers some rough indications of evaluation times on this author's local machine.
</p>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>References</h3>

<p>Davies, T.M. and Baddeley A. (2018), Fast computation of spatially adaptive kernel estimates, <em>Statistics and Computing</em>, <b>28</b>(4), 937-956.<br /><br />
Hall, P., Marron, J.S. and Park, B.U. (1992) Smoothed cross-validation, <em>Probability Theory and Related Fields</em>, <b>92</b>, 1-20.<br /><br />
Sain, S.R., Baggerly, K.A. and Scott, D.W. (1994) Cross-validation of multivariate densities, <em>Journal of the American Statistical Association</em>, <b>89</b>, 807-817.<br /><br />
Taylor, C.C. (1989) Bootstrap choice of the smoothing parameter in kernel density estimation, <em>Biometrika</em>, <b>76</b>, 705-712.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bivariate.density">bivariate.density</a></code>, <code><a href="#topic+OS">OS</a></code>, <code><a href="#topic+multiscale.density">multiscale.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc)

## Fixed bandwidth selection ##
BOOT.density(pbc) # ~20 secs
BOOT.density(pbc,eta=OS(pbc)/2) # halve default reference bandwidth
BOOT.density(pbc,eta=OS(pbc)*2) # double default reference bandwidth

# supplying pre-defined reference density as fixed-bandwidth 'bivden' object
pbcfix &lt;- bivariate.density(pbc,h0=2.5,resolution=64)
system.time(hfix &lt;- BOOT.density(pbc,ref.density=pbcfix))
hfix

## Global (for adaptive) bandwidth selection ##
# ~200 secs next line; use 'parallelise' for speedup
system.time(hada &lt;- BOOT.density(pbc,type="adaptive")) # minimal usage for adaptive bootstrap
hada

# ~80 secs next line. Set custom h limits; increase reference bandwidth;
#    set custom pilot bandwidth; return objective function; use 'parallelise' for speedup
system.time(hada &lt;- BOOT.density(pbc,hlim=c(0.9,8),eta=3.5,type="adaptive",
                                 hp=OS(pbc)/2,sim.adapt=list(objective=TRUE)))
hada[which.min(hada[,2]),1]
plot(hada);abline(v=hada[which.min(hada[,2]),1],col=2)

</code></pre>

<hr>
<h2 id='BOOT.spattemp'>
Bootstrap bandwidths for a spatiotemporal kernel density estimate
</h2><span id='topic+BOOT.spattemp'></span>

<h3>Description</h3>

<p>Bandwidth selection for standalone spatiotemporal density/intensity based on bootstrap estimation of the MISE, providing an isotropic scalar spatial bandwidth and a scalar temporal bandwidth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BOOT.spattemp(pp, tt = NULL, tlim = NULL, eta = NULL, nu = NULL,
  sedge = c("uniform", "none"), tedge = sedge, ref.density = NULL,
  sres = 64, tres = sres, start = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BOOT.spattemp_+3A_pp">pp</code></td>
<td>

<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the spatial coordinates of the observations to be smoothed. Possibly marked with the time of each event; see argument <code>tt</code>.
</p>
</td></tr>
<tr><td><code id="BOOT.spattemp_+3A_tt">tt</code></td>
<td>

<p>A numeric vector of equal length to the number of points in <code>pp</code>, giving the time corresponding to each spatial observation. If unsupplied, the function attempts to use the values in the <code><a href="spatstat.geom.html#topic+marks">marks</a></code> attribute of the <code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code> in <code>pp</code>.
</p>
</td></tr>
<tr><td><code id="BOOT.spattemp_+3A_tlim">tlim</code></td>
<td>

<p>A numeric vector of length 2 giving the limits of the temporal domain over which to smooth. If supplied, all times in <code>tt</code> must fall within this interval (equality with limits allowed). If unsupplied, the function simply uses the range of the observed temporal values.
</p>
</td></tr>
<tr><td><code id="BOOT.spattemp_+3A_eta">eta</code></td>
<td>

<p>Fixed scalar bandwidth to use for the spatial margin of the reference density estimate; if <code>NULL</code> it is calculated as the oversmoothing bandwidth of <code>pp</code> using <code><a href="#topic+OS">OS</a></code>. Ignored if <code>ref.density</code> is supplied. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="BOOT.spattemp_+3A_nu">nu</code></td>
<td>

<p>Fixed scalar bandwidth to use for the temporal margin of the reference density estimate; if <code>NULL</code> it is calculated from <code>tt</code> using the univariate version of Terrell's (1990) oversmoothing principle. Ignored if <code>ref.density</code> is supplied. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="BOOT.spattemp_+3A_sedge">sedge</code></td>
<td>

<p>Character string dictating spatial edge correction. <code>"uniform"</code> (default) corrects based on evaluation grid coordinate. Setting <code>sedge="none"</code> requests no edge correction.
</p>
</td></tr>
<tr><td><code id="BOOT.spattemp_+3A_tedge">tedge</code></td>
<td>

<p>As <code>sedge</code>, for temporal edge correction.
</p>
</td></tr>
<tr><td><code id="BOOT.spattemp_+3A_ref.density">ref.density</code></td>
<td>

<p>Optional. An object of class <code><a href="#topic+stden">stden</a></code> giving the reference density from which data is assumed to originate in the bootstrap. Must be spatially edge-corrected if <code>sedge = "uniform"</code>.
</p>
</td></tr>
<tr><td><code id="BOOT.spattemp_+3A_sres">sres</code></td>
<td>

<p>Numeric value &gt; 0. Resolution of the [<code>sres</code> <code class="reqn">\times</code> <code>sres</code>] evaluation grid in the spatial margin.
</p>
</td></tr>
<tr><td><code id="BOOT.spattemp_+3A_tres">tres</code></td>
<td>

<p>Numeric value &gt; 0. Resolution of the evaluation points in the temporal margin as defined by the <code>tlim</code> interval. If unsupplied, the density is evaluated at integer values between <code>tlim[1]</code> and <code>tlim[2]</code>.
</p>
</td></tr>
<tr><td><code id="BOOT.spattemp_+3A_start">start</code></td>
<td>

<p>Optional positive numeric vector of length 2 giving starting values for the internal call to <code><a href="stats.html#topic+optim">optim</a></code>, in the order of (&lt;spatial bandwidth&gt;, &lt;temporal bandwidth&gt;).
</p>
</td></tr>
<tr><td><code id="BOOT.spattemp_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print a function progress bar to the console during evaluation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a spatiotemporal kernel density estimate <code class="reqn">\hat{f}</code> defined on <code class="reqn">W x T \in R^3</code>, the mean integrated squared error (MISE) is given by <code class="reqn">E[\int_W \int_T (\hat{f}(x,t) - f(x,t))^2 dt dx]</code>, where <code class="reqn">f</code> is the corresponding true density. Given observed spatiotemporal locations <code class="reqn">X</code> (arguments <code>pp</code> and <code>tt</code>) of <code class="reqn">n</code> observations, this function finds the scalar spatial bandwidth <code class="reqn">h</code> and scalar temporal bandwidth <code class="reqn">\lambda</code> that jointly minimise
</p>
<p style="text-align: center;"><code class="reqn">E^*[\int_W \int_T (\hat{f}^*(x,t) - \hat{f}(x,t))^2 dt dx],</code>
</p>

<p>where <code class="reqn">\hat{f}(x,t)</code> is a density estimate of <code class="reqn">X</code> constructed with &lsquo;reference&rsquo; bandwidths <code class="reqn">\eta</code> (spatial; argument <code>eta</code>) and <code class="reqn">\nu</code> (temporal; argument <code>nu</code>); <code class="reqn">\hat{f}^*(x,t)</code> is a density estimate using bandwidths <code class="reqn">h</code> and <code class="reqn">\lambda</code> of <code class="reqn">n</code> observations <code class="reqn">X^*</code> generated from <code class="reqn">\hat{f}(x,t)</code>. The notation <code class="reqn">E^*</code> denotes expectation with respect to the distribution of the <code class="reqn">X^*</code>. The user may optionally supply <code>ref.density</code> as an object of class <code><a href="#topic+stden">stden</a></code>, which must be evaluated on the same spatial and temporal domains <code class="reqn">W</code> and <code class="reqn">T</code> as the data (arguments <code>pp</code>, <code>tt</code>, and <code>tlim</code>). In this case, the reference bandwidths are extracted from this object, and <code>eta</code> and <code>nu</code> are ignored.
</p>
<p>This function is based on an extension of the theory of Taylor (1989) to the spatiotemporal domain and to cope with the inclusion of edge-correction factors. No resampling is necessary due to the theoretical properties of the Gaussian kernel.
</p>


<h3>Value</h3>

<p>A numeric vector of length 2 giving the jointly optimised spatial and temporal bandwidths (named <code>h</code> and <code>lambda</code> respectively).
</p>


<h3>Warning</h3>

<p>Bootstrapping for spatiotemporal bandwidth selection for spatiotemporal data is very computationally demanding. Keeping <code>verbose = TRUE</code> offers an indication of the computational burden by printing each pair of bandwidths at each iteration of the <code><a href="stats.html#topic+optim">optim</a></code>isation routine. The &lsquo;Examples&rsquo; section also offers some rough indications of evaluation times on this author's local machine.
</p>


<h3>Author(s)</h3>

<p>T. M. Davies
</p>


<h3>References</h3>

<p>Taylor, C.C. (1989) Bootstrap choice of the smoothing parameter in kernel density estimation, <em>Biometrika</em>, <b>76</b>, 705-712.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LSCV.spattemp">LSCV.spattemp</a></code>, <code><a href="#topic+spattemp.density">spattemp.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(burk) # Burkitt's Uganda lymphoma data
burkcas &lt;- burk$cases

#~85 secs
hlam1 &lt;- BOOT.spattemp(burkcas) 

#~75 secs. Widen time limits, reduce ref. bw.
hlam2 &lt;- BOOT.spattemp(burkcas,tlim=c(400,5800),eta=8,nu=450) 

#~150 secs. Increase ref. bw., custom starting vals
hlam3 &lt;- BOOT.spattemp(burkcas,eta=20,nu=800,start=c(7,400)) 

rbind(hlam1,hlam2,hlam3)

</code></pre>

<hr>
<h2 id='burk'>Burkitt's lymphoma in Uganda</h2><span id='topic+burk'></span>

<h3>Description</h3>

<p>Data of the spatiotemporal locations of Burkitt's lymphoma in the Western Nile district of Uganda
from 1960 to 1975.
</p>


<h3>Format</h3>

<p><code>burk</code> is a named list with three members:
</p>

<dl>
<dt><code>$cases</code></dt><dd>
<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the spatial locations (eastings/northings) 
of the 188 cases of Burkitt's lymphoma recorded in individuals of various ages (mostly children); the spatial study region as a polygonal <code><a href="spatstat.geom.html#topic+owin">owin</a></code>; as well as the time
(in days since 1/1/1960) of each observation stored as the <code>marks</code> of the points.
</p>
</dd>
<dt><code>$cases.age</code></dt><dd>
<p>A numeric vector of length 188 giving the age of each individual in <code>$cases</code>.
</p>
</dd>
<dt><code>$controls</code></dt><dd>
<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving 500 <b>artificially simulated</b> spatial-only
observations to pose as a &lsquo;control&rsquo; data set representing the at-risk population. The data were
generated from a smooth kernel estimate of the spatial margin of the cases. The similarity between the case point distribution
and the true at-risk population dispersion can be seen in e.g. Figure 2 of Middleton and Greenland (1954).
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The case data were extracted from the <code><a href="splancs.html#topic+burkitt">burkitt</a></code> object of the <code>splancs</code> R package;
see <br /><br />
Rowlingson B. and Diggle P.J. (2017), splancs: Spatial and Space-Time Point Pattern Analysis, R
package version 2.01-40; <a href="https://CRAN.R-project.org/package=splancs">https://CRAN.R-project.org/package=splancs</a>.
</p>


<h3>References</h3>

<p>Bailey, T.C. and Gatrell, A.C. (1995), <em>Interactive spatial data analysis</em>, Longman; Harlow.
</p>
<p>Middleton, J.F.M. and Greenland, D.J. (1954), Land and population in West Nile District, Uganda, <em>The Geographical Journal</em>, <b>120</b>, 446&ndash;455.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(burk)
summary(burk$cases)

oldpar &lt;- par(mfrow=c(1,3))
plot(burk$cases)
plot(burk$controls)
plot(density(marks(burk$cases)),xlim=range(marks(burk$cases)))
par(oldpar)
</code></pre>

<hr>
<h2 id='fft2d'>2D fast-Fourier wrapper around 'fftwtools' or 'stats' package</h2><span id='topic+fft2d'></span>

<h3>Description</h3>

<p>Utilises the Fastest Fourier Transform in the West (FFTW) via the 'fftwtools'
package if available, else reverts to built-in functionality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fft2d(x, inverse = FALSE, fftw = fftw_available())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fft2d_+3A_x">x</code></td>
<td>
<p>A numeric matrix to be transformed.</p>
</td></tr>
<tr><td><code id="fft2d_+3A_inverse">inverse</code></td>
<td>
<p>Whether it should compute the inverse transform (defaults to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="fft2d_+3A_fftw">fftw</code></td>
<td>
<p>Whether the <code>fftwtools</code> R package is available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called wherever <code>sparr</code> seeks to perform a 2D fast-Fourier
transform. Where available, computational expense is noticeably reduced by appealing to routines 
in the independent &lsquo;FFTW&rsquo; toolbox. The user is encouraged to install the corresponding R package <code>fftwtools</code> from CRAN;
this function will automatically detect and use the faster option, otherwise will 
defer to the built-in <code><a href="stats.html#topic+fft">fft</a></code>.
</p>


<h3>Value</h3>

<p>The fast-Fourier (inverse) transform. A complex-valued matrix of the same size as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>J.C. Marshall
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# System check
sparr:::fftw_available()

system.time(fft(matrix(1:2000^2,2000)))
system.time(fft2d(matrix(1:2000^2,2000)))


</code></pre>

<hr>
<h2 id='fmd'>Veterinary foot-and-mouth disease outbreak data</h2><span id='topic+fmd'></span>

<h3>Description</h3>

<p>Data of the spatial locations and time of farms infected by veterinary foot-and-mouth disease
in the county of Cumbria, UK, over a course of nearly 250 days between February and August in 2001.
There are 410 infected farms (the cases), and 1866 uninfected farms (the controls). The data
have been jittered and randomly thinned by an unspecified amount to preserve anonymity.
</p>


<h3>Format</h3>

<p><code>fmd</code> is a named list with two members:
</p>

<dl>
<dt><code>$cases</code></dt><dd>
<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the spatial locations of the 410 infected
farms within a polygonal study region representing the county of Cumbria. The <code><a href="spatstat.geom.html#topic+marks">marks</a></code>
component of this object contain the integer day of infection (from beginning of study period).
</p>
</dd>
<dt><code>$controls</code></dt><dd>
<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> defined over the same spatial study region with the locations
of the 1866 uninfected farms.
</p>
</dd>
</dl>



<h3>Acknowledgements</h3>

<p>The Animal and Plant Health Agency (APHA), UK, provided permission to use this dataset.
</p>


<h3>References</h3>

<p>Fernando, W.T.P.S. and Hazelton, M.L. (2014), Generalizing the spatial relative risk function,
<em>Spatial and Spatio-temporal Epidemiology</em>, <b>8</b>, 1-10.
</p>
<p>Keeling M, Woolhouse M, Shaw D, Matthews L, Chase-Topping M, Haydon D, et al. (2001),
Dynamics of the 2001 UK foot and mouth epidemic: stochastic dispersal in a heterogeneous landscape,
<em>Science</em>, <b>294</b>, 813-817.
</p>
<p>Lawson A, Zhou H. (2005), Spatial statistical modeling of disease outbreaks with particular
reference to the UK foot and mouth disease (FMD) epidemic of 2001,
<em>Preventative Veterinary Medicine</em>, <b>71</b>, 141-156.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fmd)
summary(fmd$cases)
summary(fmd$controls)

oldpar &lt;- par(mfrow=c(1,2))
plot(fmd$cases)
plot(fmd$controls)
par(oldpar)

</code></pre>

<hr>
<h2 id='LIK.density'>Cross-validation bandwidths for spatial kernel density estimates</h2><span id='topic+LIK.density'></span><span id='topic+LSCV.density'></span>

<h3>Description</h3>

<p>Isotropic fixed or global (for adaptive) bandwidth selection for standalone 2D density/intensity
based on either unbiased least squares cross-validation (LSCV) or likelihood (LIK) cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LIK.density(
  pp,
  hlim = NULL,
  hseq = NULL,
  resolution = 64,
  edge = TRUE,
  auto.optim = TRUE,
  type = c("fixed", "adaptive"),
  seqres = 30,
  parallelise = NULL,
  zero.action = 0,
  verbose = TRUE,
  ...
)

LSCV.density(
  pp,
  hlim = NULL,
  hseq = NULL,
  resolution = 64,
  edge = TRUE,
  auto.optim = TRUE,
  type = c("fixed", "adaptive"),
  seqres = 30,
  parallelise = NULL,
  zero.action = 0,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LIK.density_+3A_pp">pp</code></td>
<td>
<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the observed
2D data to be smoothed.</p>
</td></tr>
<tr><td><code id="LIK.density_+3A_hlim">hlim</code></td>
<td>
<p>An optional vector of length 2 giving the limits of the
optimisation routine with respect to the bandwidth. If unspecified, the
function attempts to choose this automatically.</p>
</td></tr>
<tr><td><code id="LIK.density_+3A_hseq">hseq</code></td>
<td>
<p>An optional increasing sequence of bandwidth values at which to
manually evaluate the optimisation criterion. Used only in the case
<code>(!auto.optim &amp;&amp; is.null(hlim))</code>.</p>
</td></tr>
<tr><td><code id="LIK.density_+3A_resolution">resolution</code></td>
<td>
<p>Spatial grid size; the optimisation will be based on a
[<code>resolution</code> <code class="reqn">\times</code> <code>resolution</code>] density estimate.</p>
</td></tr>
<tr><td><code id="LIK.density_+3A_edge">edge</code></td>
<td>
<p>Logical value indicating whether to edge-correct the density
estimates used.</p>
</td></tr>
<tr><td><code id="LIK.density_+3A_auto.optim">auto.optim</code></td>
<td>
<p>Logical value indicating whether to automate the numerical
optimisation using <code><a href="stats.html#topic+optimise">optimise</a></code>. If <code>FALSE</code>, the optimisation
criterion is evaluated over <code>hseq</code> (if supplied), or over a seqence of
values controlled by <code>hlim</code> and <code>seqres</code>.</p>
</td></tr>
<tr><td><code id="LIK.density_+3A_type">type</code></td>
<td>
<p>A character string; <code>"fixed"</code> (default) performs classical leave-one-out
cross-validation for the fixed-bandwidth estimator. Alternatively, <code>"adaptive"</code> utilises
multiscale adaptive kernel estimation (Davies &amp; Baddeley, 2018) to run the cross-validation
in an effort to find a suitable global bandwidth for the adaptive estimator. Note that data points are not &lsquo;left out&rsquo; of
the pilot density estimate when using this option (this capability is currently in development). See also the entry for <code>...</code>.</p>
</td></tr>
<tr><td><code id="LIK.density_+3A_seqres">seqres</code></td>
<td>
<p>Optional resolution of an increasing sequence of bandwidth
values. Only used if <code>(!auto.optim &amp;&amp; is.null(hseq))</code>.</p>
</td></tr>
<tr><td><code id="LIK.density_+3A_parallelise">parallelise</code></td>
<td>
<p>Numeric argument to invoke parallel processing, giving
the number of CPU cores to use when <code>!auto.optim</code> <b>and</b> <code>type = "fixed"</code>. Experimental. Test
your system first using <code>parallel::detectCores()</code> to identify the
number of cores available to you.</p>
</td></tr>
<tr><td><code id="LIK.density_+3A_zero.action">zero.action</code></td>
<td>
<p>A numeric integer, either <code>-1</code>, <code>0</code> (default), <code>1</code> or <code>2</code> controlling how the function should behave in response to numerical errors at very small bandwidths, when such a bandwidth results in one or more zero or negative density values during the leave-one-out computations. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="LIK.density_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether to provide function progress
commentary.</p>
</td></tr>
<tr><td><code id="LIK.density_+3A_...">...</code></td>
<td>
<p>Additional arguments controlling pilot density estimation and multi-scale bandwidth-axis
resolution when <code>type = "adaptive"</code>. Relevant arguments are <code>hp</code>, <code>pilot.density</code>,
<code>gamma.scale</code>, and <code>trim</code> from <code><a href="#topic+bivariate.density">bivariate.density</a></code>; and <code>dimz</code> from 
<code><a href="#topic+multiscale.density">multiscale.density</a></code>. If <code>hp</code> is missing and required, the function makes a (possibly recursive)
call to <code>LSCV.density</code> to set this using fixed-bandwidth LSCV. The remaining defaults are <code>pilot.density = pp</code>,
<code>gamma.scale = "geometric"</code>, <code>trim = 5</code>, and <code>dimz = resolution</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the bivariate, edge-corrected versions of fixed-bandwidth least squares cross-validation and likelihood cross-validation
as outlined in Sections 3.4.3 and 3.4.4 of Silverman (1986) in order to select an optimal fixed smoothing bandwidth. With <code>type = "adaptive"</code> it may also be used to select the global bandwidth
for adaptive kernel density estimates, making use of multi-scale estimation (Davies and Baddeley, 2018) via <code><a href="#topic+multiscale.density">multiscale.density</a></code>.
Note that for computational reasons, the leave-one-out procedure is not performed on the pilot density in the adaptive setting; it
is only performed on the final stage estimate. Current development efforts include extending this functionality, see <code><a href="#topic+SLIK.adapt">SLIK.adapt</a></code>. See also &lsquo;Warning&rsquo; below.
</p>
<p>Where <code>LSCV.density</code> is based on minimisation of an unbiased estimate of the mean integrated squared error (MISE) of the density, <code>LIK.density</code> is based on
maximisation of the cross-validated leave-one-out average of the log-likelihood of the density estimate with respect to <code class="reqn">h</code>.
</p>
<p>In both functions, the argument <code>zero.action</code> can be used to control the level of severity in response to small bandwidths that result (due to numerical error) in at least one density value being zero or less.
When <code>zero.action = -1</code>, the function strictly forbids bandwidths that would result in one or more <em>pixel</em> values of a kernel estimate of the original data (i.e. anything over the whole region) being zero or less&mdash;this is the most restrictive truncation. With <code>zero.action = 0</code> (default), the function
automatically forbids bandwidths that yield erroneous values at the leave-one-out data point locations only. With <code>zero.action = 1</code>, the minimum machine value (see <code>.Machine$double.xmin</code> at the prompt) is
used to replace these individual leave-one-out values. When <code>zero.action = 2</code>, the minimum value of the valid (greater than zero) leave-one-out values is used to replace any erroneous leave-one-out values.
</p>


<h3>Value</h3>

<p>A single numeric value of the estimated bandwidth (if
<code>auto.optim = TRUE</code>). Otherwise, a <code class="reqn">[</code><code>seqres</code> <code class="reqn">x</code> 2<code class="reqn">]</code> matrix 
giving the bandwidth sequence and corresponding CV
function value.
</p>


<h3>Warning</h3>

<p>Leave-one-out CV for bandwidth selection in kernel
density estimation is notoriously unstable in practice and has a tendency to
produce rather small bandwidths, particularly for spatial data. Satisfactory bandwidths are not guaranteed
for every application; <code>zero.action</code> can curb adverse numeric effects for very small bandwidths during the optimisation procedures. This method can also be computationally expensive for
large data sets and fine evaluation grid resolutions. The user may also need to
experiment with adjusting <code>hlim</code> to find a suitable minimum.
</p>


<h3>Author(s)</h3>

<p>T. M. Davies
</p>


<h3>References</h3>

<p>Davies, T.M. and Baddeley A. (2018), Fast computation of
spatially adaptive kernel estimates, <em>Statistics and Computing</em>, <b>28</b>(4), 937-956.
</p>
<p>Silverman, B.W. (1986), <em>Density Estimation for Statistics
and Data Analysis</em>, Chapman &amp; Hall, New York.
</p>
<p>Wand, M.P. and Jones,
C.M., 1995. <em>Kernel Smoothing</em>, Chapman &amp; Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SLIK.adapt">SLIK.adapt</a></code> and functions for bandwidth selection in package
<code>spatstat</code>: <code><a href="spatstat.explore.html#topic+bw.diggle">bw.diggle</a></code>;
<code><a href="spatstat.explore.html#topic+bw.ppl">bw.ppl</a></code>; <code><a href="spatstat.explore.html#topic+bw.scott">bw.scott</a></code>;
<code><a href="spatstat.explore.html#topic+bw.frac">bw.frac</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc)
pbccas &lt;- split(pbc)$case

LIK.density(pbccas)
LSCV.density(pbccas)


#* FIXED 

# custom limits
LIK.density(pbccas,hlim=c(0.01,4))
LSCV.density(pbccas,hlim=c(0.01,4))

# disable edge correction
LIK.density(pbccas,hlim=c(0.01,4),edge=FALSE)
LSCV.density(pbccas,hlim=c(0.01,4),edge=FALSE)

# obtain objective function
hcv &lt;- LIK.density(pbccas,hlim=c(0.01,4),auto.optim=FALSE)
plot(hcv);abline(v=hcv[which.max(hcv[,2]),1],lty=2,col=2)

#* ADAPTIVE
LIK.density(pbccas,type="adaptive")
LSCV.density(pbccas,type="adaptive")
 
# change pilot bandwidth used
LIK.density(pbccas,type="adaptive",hp=2)
LSCV.density(pbccas,type="adaptive",hp=2)
 

</code></pre>

<hr>
<h2 id='LIK.spattemp'>
Cross-validation bandwidths for spatiotemporal kernel density estimates
</h2><span id='topic+LSCV.spattemp'></span><span id='topic+LIK.spattemp'></span>

<h3>Description</h3>

<p>Bandwidth selection for standalone spatiotemporal density/intensity based on either unbiased least squares cross-validation (LSCV) or likelihood (LIK) cross-validation, providing an isotropic scalar spatial bandwidth and a scalar temporal bandwidth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LIK.spattemp(pp, tt = NULL, tlim = NULL, sedge = c("uniform", "none"),
  tedge = sedge, parallelise = NA, start = NULL, verbose = TRUE)

LSCV.spattemp(pp, tt = NULL, tlim = NULL, sedge = c("uniform", "none"),
  tedge = sedge, sres = 64, tres = sres, parallelise = NA,
  start = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LIK.spattemp_+3A_pp">pp</code></td>
<td>

<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the spatial coordinates of the observations to be smoothed. Possibly marked with the time of each event; see argument <code>tt</code>.
</p>
</td></tr>
<tr><td><code id="LIK.spattemp_+3A_tt">tt</code></td>
<td>

<p>A numeric vector of equal length to the number of points in <code>pp</code>, giving the time corresponding to each spatial observation. If unsupplied, the function attempts to use the values in the <code><a href="spatstat.geom.html#topic+marks">marks</a></code> attribute of the <code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code> in <code>pp</code>.
</p>
</td></tr>
<tr><td><code id="LIK.spattemp_+3A_tlim">tlim</code></td>
<td>

<p>A numeric vector of length 2 giving the limits of the temporal domain over which to smooth. If supplied, all times in <code>tt</code> must fall within this interval (equality with limits allowed). If unsupplied, the function simply uses the range of the observed temporal values.
</p>
</td></tr>
<tr><td><code id="LIK.spattemp_+3A_sedge">sedge</code></td>
<td>

<p>Character string dictating spatial edge correction. <code>"uniform"</code> (default) corrects based on evaluation grid coordinate. Setting <code>sedge="none"</code> requests no edge correction.
</p>
</td></tr>
<tr><td><code id="LIK.spattemp_+3A_tedge">tedge</code></td>
<td>

<p>As <code>sedge</code>, for temporal edge correction.
</p>
</td></tr>
<tr><td><code id="LIK.spattemp_+3A_sres">sres</code></td>
<td>

<p>Numeric value &gt; 0. Resolution of the [<code>sres</code> <code class="reqn">\times</code> <code>sres</code>] evaluation grid in the spatial margin.
</p>
</td></tr>
<tr><td><code id="LIK.spattemp_+3A_tres">tres</code></td>
<td>

<p>Numeric value &gt; 0. Resolution of the evaluation points in the temporal margin as defined by the <code>tlim</code> interval. If unsupplied, the density is evaluated at integer values between <code>tlim[1]</code> and <code>tlim[2]</code>.
</p>
</td></tr>
<tr><td><code id="LIK.spattemp_+3A_parallelise">parallelise</code></td>
<td>

<p>Optional numeric argument to invoke parallel processing, by giving the number of CPU cores to use optimisation. This is only useful for larger data sets of many thousand observations. Experimental. Test your system first using <code>parallel::detectCores()</code> to identify the number of cores available to you.
</p>
</td></tr>
<tr><td><code id="LIK.spattemp_+3A_start">start</code></td>
<td>

<p>Optional positive numeric vector of length 2 giving starting values for the internal call to <code><a href="stats.html#topic+optim">optim</a></code>, in the order of (&lt;spatial bandwidth&gt;, &lt;temporal bandwidth&gt;).
</p>
</td></tr>
<tr><td><code id="LIK.spattemp_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print a function progress bar to the console during evaluation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 2 giving the jointly optimised spatial and temporal bandwidths (named <code>h</code> and <code>lambda</code> respectively).
</p>


<h3>Warning</h3>

<p>Leave-one-out CV for bandwidth selection in kernel
density estimation is notoriously unstable in practice and has a tendency to
produce rather small bandwidths in the fixed bandwidth case. Satisfactory bandwidths are not guaranteed
for every application. This method can also be computationally expensive for
large data sets and fine evaluation grid resolutions.
</p>


<h3>Author(s)</h3>

<p>T. M. Davies
</p>


<h3>References</h3>

<p>Silverman, B.W. (1986), <em>Density Estimation for Statistics and Data Analysis</em>, Chapman &amp; Hall, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BOOT.spattemp">BOOT.spattemp</a></code>, <code><a href="#topic+spattemp.density">spattemp.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(burk) # Burkitt's Uganda lymphoma data
burkcas &lt;- burk$cases

hlam1 &lt;- LSCV.spattemp(burkcas) #~9 secs
hlam2 &lt;- LSCV.spattemp(burkcas,tlim=c(400,5800)) 
hlam3 &lt;- LSCV.spattemp(burkcas,start=c(7,400))
rbind(hlam1,hlam2,hlam3)

hlam1 &lt;- LIK.spattemp(burkcas) #~3 secs
hlam2 &lt;- LIK.spattemp(burkcas,tlim=c(400,5800)) 
hlam3 &lt;- LIK.spattemp(burkcas,start=c(7,400))
rbind(hlam1,hlam2,hlam3)


</code></pre>

<hr>
<h2 id='LSCV.risk'>Jointly optimal bandwidth selection for the spatial relative risk function</h2><span id='topic+LSCV.risk'></span>

<h3>Description</h3>

<p>Methods to find a jointly optimal, common case-control isotropic bandwidth for use in
estimation of the fixed or adaptive kernel-smoothed relative risk function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LSCV.risk(
  f,
  g = NULL,
  hlim = NULL,
  hseq = NULL,
  type = c("fixed", "adaptive"),
  method = c("kelsall-diggle", "hazelton", "davies"),
  resolution = 64,
  edge = TRUE,
  hp = NULL,
  pilot.symmetry = c("none", "f", "g", "pooled"),
  auto.optim = TRUE,
  seqres = 30,
  parallelise = NA,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LSCV.risk_+3A_f">f</code></td>
<td>
<p>Either a pre-calculated object of class <code><a href="#topic+bivden">bivden</a></code>
representing the &lsquo;case&rsquo; (numerator) density estimate, or an object of class
<code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the observed case data. Alternatively, if
<code>f</code> is <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> object with dichotomous
factor-valued <code><a href="spatstat.geom.html#topic+marks">marks</a></code>, the function treats the first
level as the case data, and the second as the control data, obviating the
need to supply <code>g</code>.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_g">g</code></td>
<td>
<p>As for <code>f</code>, for the &lsquo;control&rsquo; (denominator) density; this
object must be of the same class as <code>f</code>. Ignored if, as stated above,
<code>f</code> contains both case and control observations.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_hlim">hlim</code></td>
<td>
<p>An optional vector of length 2 giving the limits of the
optimisation routine with respect to the bandwidth. If unspecified, the
function attempts to choose this automatically.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_hseq">hseq</code></td>
<td>
<p>An optional increasing sequence of bandwidth values at which to
manually evaluate the optimisation criterion. Used only in the case
<code>(!auto.optim &amp;&amp; is.null(hlim))</code>.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_type">type</code></td>
<td>
<p>A character string; <code>"fixed"</code> (default) performs classical leave-one-out
cross-validation for a jointly optimal fixed bandwidth. Alternatively, <code>"adaptive"</code> utilises
multiscale adaptive kernel estimation (Davies &amp; Baddeley, 2018) to run the cross-validation
in an effort to find a suitable jointly optimal, common global bandwidth for the adaptive relative risk function. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_method">method</code></td>
<td>
<p>A character string controlling the selector to use. There are
three types, based on either the mean integrated squared error (MISE)
(Kelsall and Diggle, 1995; default &ndash; <code>method = "kelsall-diggle"</code>); a
weighted MISE (Hazelton, 2008 &ndash; <code>method = "hazelton"</code>); or an
approximation to the asymptotic MISE (Davies, 2013 &ndash; <code>method =
"davies"</code>). See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_resolution">resolution</code></td>
<td>
<p>Spatial grid size; the optimisation will be based on a
[<code>resolution</code> <code class="reqn">\times</code> <code>resolution</code>] density estimate.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_edge">edge</code></td>
<td>
<p>Logical value indicating whether to edge-correct the density
estimates used.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_hp">hp</code></td>
<td>
<p>A single numeric value or a vector of length 2 giving the pilot
bandwidth(s) to be used for estimation of the pilot
densities for adaptive risk surfaces. Ignored if <code>type = "fixed"</code>.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_pilot.symmetry">pilot.symmetry</code></td>
<td>
<p>A character string used to control the type of
symmetry, if any, to use for the bandwidth factors when computing an
adaptive relative risk surface. See &lsquo;Details&rsquo;. Ignored if <code>type = "fixed"</code>.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_auto.optim">auto.optim</code></td>
<td>
<p>Logical value indicating whether to automate the numerical
optimisation using <code><a href="stats.html#topic+optimise">optimise</a></code>. If <code>FALSE</code>, the optimisation
criterion is evaluated over <code>hseq</code> (if supplied), or over a seqence of
values controlled by <code>hlim</code> and <code>seqres</code>.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_seqres">seqres</code></td>
<td>
<p>Optional resolution of an increasing sequence of bandwidth
values. Only used if <code>(!auto.optim &amp;&amp; is.null(hseq))</code>.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_parallelise">parallelise</code></td>
<td>
<p>Numeric argument to invoke parallel processing, giving
the number of CPU cores to use when <code>!auto.optim</code>. Experimental. Test
your system first using <code>parallel::detectCores()</code> to identify the
number of cores available to you.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether to provide function progress
commentary.</p>
</td></tr>
<tr><td><code id="LSCV.risk_+3A_...">...</code></td>
<td>
<p>Additional arguments such as <code>dimz</code> and <code>trim</code> to be passed to
the internal calls to <code><a href="#topic+multiscale.density">multiscale.density</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the established preference of using a common bandwidth for both case
and control density estimates when constructing a relative
risk surface, This function calculates a &lsquo;jointly optimal&rsquo;, common isotropic
LSCV bandwidth for the (Gaussian) kernel-smoothed relative risk function
(case-control density-ratio). It can be shown that choosing a bandwidth that
is equal for both case and control density estimates is preferable to
computing &lsquo;separately optimal&rsquo; bandwidths (Kelsall and Diggle, 1995). The user
can choose to either calculate a common smoothing parameter for a fixed-bandwidth
relative risk surface (<code>type = "fixed"</code>; default), or a common global bandwidth for
an adaptive risk surface (<code>type = "adaptive"</code>). See further comments below.
</p>

<ul>
<li><p><code>method = "kelsall-diggle"</code>: the function computes the
common bandwidth which minimises the approximate mean integrated squared
error (MISE) of the log-transformed risk surface (Kelsall and Diggle, 1995).
</p>
</li>
<li><p><code>method = "hazelton"</code>: the function minimises a
<em>weighted-by-control</em> MISE of the (raw) relative risk function
(Hazelton, 2008).
</p>
</li>
<li><p><code>method = "davies"</code>: the optimal bandwidth is
one that minimises a crude plug-in approximation to the <em>asymptotic</em>
MISE (Davies, 2013). Only possible for <code>type = "fixed"</code>.
</p>
</li></ul>

<p>For jointly optimal, common global bandwidth selection when <code>type = "adaptive"</code>, the
optimisation routine utilises <code><a href="#topic+multiscale.density">multiscale.density</a></code>. Like <code><a href="#topic+LSCV.density">LSCV.density</a></code>,
the leave-one-out procedure does not affect the pilot density, for which additional
control is offered via the <code>hp</code> and <code>pilot.symmetry</code> arguments. The user has the option of
obtaining a so-called <em>symmetric</em> estimate (Davies et al. 2016) via
<code>pilot.symmetry</code>. This amounts to choosing the same pilot density for
both case and control densities. By choosing <code>"none"</code> (default), the
result uses the case and control data separately for the fixed-bandwidth
pilots, providing the original asymmetric density-ratio of Davies and
Hazelton (2010). By selecting either of <code>"f"</code>, <code>"g"</code>, or
<code>"pooled"</code>, the pilot density is calculated based on the case, control,
or pooled case/control data respectively (using <code>hp[1]</code> as the fixed
bandwidth). Davies et al. (2016) noted some beneficial practical behaviour
of the symmetric adaptive surface over the asymmetric. (The pilot bandwidth(s), if not supplied in <code>hp</code>, are calculated
internally via default use of <code><a href="#topic+LSCV.density">LSCV.density</a></code>, using the requested symmetric-based data set, or separately with respect to the case and control datasets <code>f</code> and <code>g</code> if
<code>pilot.symmetry = "none"</code>.)
</p>


<h3>Value</h3>

<p>A single numeric value of the estimated bandwidth (if
<code>auto.optim = TRUE</code>). Otherwise, a list of two numeric vectors of equal
length giving the bandwidth sequence (as <code>hs</code>) and corresponding CV
function value (as <code>CV</code>).
</p>


<h3>Warning</h3>

<p>The jointly optimal bandwidth selector can be
computationally expensive for large data sets and fine evaluation grid
resolutions. The user may need to experiment with adjusting <code>hlim</code> to
find a suitable minimum.
</p>


<h3>Author(s)</h3>

<p>T. M. Davies
</p>


<h3>References</h3>

<p>Davies, T. M. (2013), Jointly optimal bandwidth selection for
the planar kernel-smoothed density-ratio, <em>Spatial and Spatio-temporal
Epidemiology</em>, <b>5</b>, 51-65.
</p>
<p>Davies, T.M. and Baddeley A. (2018), Fast computation of
spatially adaptive kernel estimates, <em>Statistics and Computing</em>, <b>28</b>(4), 937-956.
</p>
<p>Davies, T.M. and Hazelton, M.L. (2010), Adaptive kernel
estimation of spatial relative risk, <em>Statistics in Medicine</em>,
<b>29</b>(23) 2423-2437.
</p>
<p>Davies, T.M., Jones, K. and Hazelton, M.L.
(2016), Symmetric adaptive smoothing regimens for estimation of the spatial
relative risk function, <em>Computational Statistics &amp; Data Analysis</em>,
<b>101</b>, 12-28.
</p>
<p>Hazelton, M. L. (2008), Letter to the
editor: Kernel estimation of risk surfaces without the need for edge
correction, <em>Statistics in Medicine</em>, <b>27</b>, 2269-2272.
</p>
<p>Kelsall, J.E. and Diggle, P.J. (1995), Kernel estimation of relative risk,
<em>Bernoulli</em>, <b>1</b>, 3-16.
</p>
<p>Silverman, B.W. (1986), <em>Density Estimation for Statistics and Data Analysis</em>,
Chapman &amp; Hall, New York.
</p>
<p>Wand, M.P. and Jones, C.M., 1995. <em>Kernel Smoothing</em>, Chapman &amp; Hall,
London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bivariate.density">bivariate.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


data(pbc)
pbccas &lt;- split(pbc)$case
pbccon &lt;- split(pbc)$control

# FIXED (for common h)

LSCV.risk(pbccas,pbccon)
LSCV.risk(pbccas,pbccon,method="hazelton")
hcv &lt;- LSCV.risk(pbccas,pbccon,method="davies",auto.optim=FALSE)
plot(hcv[,1],log(hcv[,2]));abline(v=hcv[which.min(hcv[,2]),1],col=2,lty=2)


# ADAPTIVE (for common h0)

LSCV.risk(pbccas,pbccon,type="adaptive")

# change pilot bandwidths used
LSCV.risk(pbccas,pbccon,type="adaptive",hp=c(OS(pbccas)/2,OS(pbccon)/2))

# specify pooled-data symmetric relative risk estimator 
LSCV.risk(pbccas,pbccon,type="adaptive",hp=OS(pbc),pilot.symmetry="pooled")

# as above, for Hazelton selector
LSCV.risk(pbccas,pbccon,type="adaptive",method="hazelton")
LSCV.risk(pbccas,pbccon,type="adaptive",method="hazelton",hp=c(OS(pbccas)/2,OS(pbccon)/2))
LSCV.risk(pbccas,pbccon,type="adaptive",method="hazelton",hp=OS(pbc),pilot.symmetry="pooled")


</code></pre>

<hr>
<h2 id='multiscale.density'>Multi-scale adaptive kernel density/intensity estimation</h2><span id='topic+multiscale.density'></span><span id='topic+msden'></span>

<h3>Description</h3>

<p>Computes adaptive kernel estimates of spatial density/intensity using a 3D
FFT for multiple global bandwidth scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiscale.density(
  pp,
  h0,
  hp = NULL,
  h0fac = c(0.25, 1.5),
  edge = c("uniform", "none"),
  resolution = 128,
  dimz = 64,
  gamma.scale = "geometric",
  trim = 5,
  intensity = FALSE,
  pilot.density = NULL,
  xy = NULL,
  taper = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiscale.density_+3A_pp">pp</code></td>
<td>
<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the observed
2D data set to be smoothed.</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_h0">h0</code></td>
<td>
<p>Reference global bandwidth for adaptive smoothing; numeric value &gt;
0. Multiscale estimates will be computed by rescaling this value as per
<code>h0fac</code>.</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_hp">hp</code></td>
<td>
<p>Pilot bandwidth (scalar, numeric &gt; 0) to be used for fixed
bandwidth estimation of the pilot density. If <code>NULL</code> (default), it will
take on the value of <code>h0</code>. Ignored when <code>pilot.density</code> is
supplied as a pre-defined pixel image.</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_h0fac">h0fac</code></td>
<td>
<p>A numeric vector of length 2 stipulating the span of the global
bandwidths in the multiscale estimates. Interpreted as a multiplicative
factor on <code>h0</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_edge">edge</code></td>
<td>
<p>Character string dictating edge correction. <code>"uniform"</code>
(default) corrects based on evaluation grid coordinate. Setting <code>edge="none"</code>
requests no edge correction.</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_resolution">resolution</code></td>
<td>
<p>Numeric value &gt; 0. Resolution of evaluation grid in the
spatial domain; the densities/intensities will be returned on a
[<code>resolution</code> <code class="reqn">\times</code> <code>resolution</code>] grid.</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_dimz">dimz</code></td>
<td>
<p>Resolution of z- (rescaled bandwidth)-axis in the trivariate
convolution. Higher values increase precision of the multiscale estimates at
a computational cost. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_gamma.scale">gamma.scale</code></td>
<td>
<p>Scalar, numeric value &gt; 0; controls rescaling of the
variable bandwidths. Defaults to the geometric mean of the bandwidth factors
given the pilot density (as per Silverman, 1986). See the documentation for
<code><a href="#topic+bivariate.density">bivariate.density</a></code>.</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_trim">trim</code></td>
<td>
<p>Numeric value &gt; 0; controls bandwidth truncation for adaptive
estimation. See the documentation for <code><a href="#topic+bivariate.density">bivariate.density</a></code>.</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_intensity">intensity</code></td>
<td>
<p>Logical value indicating whether to return an intensity
estimate (integrates to the sample size over the study region), or a density
estimate (default, integrates to 1).</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_pilot.density">pilot.density</code></td>
<td>
<p>An optional pixel image (class
<code><a href="spatstat.geom.html#topic+im">im</a></code>) giving the pilot density to be used for
calculation of the variable bandwidths in adaptive estimation, <b>or</b> a
<code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code> giving the data upon which to base a
fixed-bandwidth pilot estimate using <code>hp</code>. See the documentation for
<code><a href="#topic+bivariate.density">bivariate.density</a></code>.</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_xy">xy</code></td>
<td>
<p>Optional alternative specification of the spatial evaluation grid;
matches the argument of the same tag in <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>. If
supplied, <code>resolution</code> is ignored.</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_taper">taper</code></td>
<td>
<p>Logical value indicating whether to taper off the trivariate
kernel outside the range of <code>h0*h0fac</code> in the scale space; see Davies &amp;
Baddeley (2018). Keep at the default <code>TRUE</code> if you don't know what this
means.</p>
</td></tr>
<tr><td><code id="multiscale.density_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether to print function progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Davies &amp; Baddeley (2018) investigated computational aspects of Abramson's
(1982) adaptive kernel smoother for spatial (2D) data. This function is the
implementation of the 3D convolution via a fast-Fourier transform (FFT)
which allows simultaneous calculation of an adaptive kernel estimate at
multiple global bandwidth scales.
</p>
<p>These &lsquo;multiple global bandwidth scales&rsquo; are computed with respect to
rescaling a reference value of the global bandwidth passed to the <code>h0</code>
argument. This rescaling is defined by the range provided to the argument
<code>h0fac</code>. For example, by default, the function will compute the
adaptive kernel estimate for a range of global bandwidths between
0.25*<code>h0</code> and 1.5*<code>h0</code>. The exact numeric limits are subject to
discretisation, and so the returned valid range of global bandwidths will
differ slightly. The exact resulting range following function execution is
returned as the <code>h0range</code> element of the result, see &lsquo;Value&rsquo; below.
</p>
<p>The distinct values of global bandwidth used (which define the
aforementioned <code>h0range</code>) and hence the total number of pixel
<code><a href="spatstat.geom.html#topic+im">im</a>ages</code> returned depend on both the width of the span
<code>h0fac</code> and the discretisation applied to the bandwidth axis through
<code>dimz</code>. Increasing this z-resolution will provide more pixel images and
hence greater numeric precision, but increases computational cost. The
returned pixel <code><a href="spatstat.geom.html#topic+im">im</a>ages</code> that represent the multiscale
estimates are stored in a named list (see &lsquo;Value&rsquo;), whose names reflect the
corresponding distinct global bandwidth. See &lsquo;Examples&rsquo; for the easy way to
extract these distinct global bandwidths.
</p>
<p>The user can request an interpolated density/intensity estimate for any
global bandwidth value within <code>h0range</code> by using the
<code><a href="#topic+multiscale.slice">multiscale.slice</a></code> function, which returns an object of class
<code><a href="#topic+bivden">bivden</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"msden"</code>. This is very similar to a
<code><a href="#topic+bivden">bivden</a></code> object, with lists of pixel
<code><a href="spatstat.geom.html#topic+im">im</a></code>ages in the <code>z</code>, <code>him</code>, and <code>q</code>
components (instead of standalone images).
</p>
<table role = "presentation">
<tr><td><code>z</code></td>
<td>
<p>A list of the resulting
density/intensity estimates; each member being a pixel image object of class
<code><a href="spatstat.geom.html#topic+im">im</a></code>. They are placed in increasing order of the
discretised values of <code>h0</code>.</p>
</td></tr>
<tr><td><code>h0</code></td>
<td>
<p>A copy of the reference value of <code>h0</code> used.</p>
</td></tr>
<tr><td><code>h0range</code></td>
<td>
<p>A vector of length 2 giving the actual range
of global bandwidth values available (inclusive).</p>
</td></tr>
<tr><td><code>hp</code></td>
<td>
<p>A copy of the value of <code>hp</code> used.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>A numeric vector of length equal to the
number of data points, giving the bandwidth used for the corresponding
observation in <code>pp</code> with respect to the reference global bandwidth
<code>h0</code>.</p>
</td></tr>
<tr><td><code>him</code></td>
<td>
<p>A list of pixel images (class <code><a href="spatstat.geom.html#topic+im">im</a></code>),
corresponding to <code>z</code>, giving the
&lsquo;hypothetical&rsquo; Abramson bandwidth at each pixel coordinate conditional upon
the observed data and the global bandwidth used.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>Edge-correction weights; list of pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>ages
corresponding to <code>z</code> if <code>edge = "uniform"</code>, and <code>NULL</code> if
<code>edge = "none"</code>.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>The numeric value of <code>gamma.scale</code> used in scaling the bandwidths.</p>
</td></tr>
<tr><td><code>geometric</code></td>
<td>
<p>The geometric mean of the
untrimmed variable bandwidth factors. This will be identical to <code>gamma</code>
if <code>gamma.scale = "geometric"</code> as per default.</p>
</td></tr>
<tr><td><code>pp</code></td>
<td>
<p>A copy of the <code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code> initially passed to the
<code>pp</code> argument, containing the data that were smoothed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>T.M. Davies and A. Baddeley
</p>


<h3>References</h3>

<p>Abramson, I. (1982). On bandwidth variation in kernel estimates
&mdash; a square root law, <em>Annals of Statistics</em>, <b>10</b>(4),
1217-1223.
</p>
<p>Davies, T.M. and Baddeley A. (2018), Fast computation of
spatially adaptive kernel estimates, <em>Statistics and Computing</em>, <b>28</b>(4), 937-956.
</p>
<p>Silverman, B.W. (1986), <em>Density Estimation for Statistics and Data Analysis</em>,
Chapman &amp; Hall, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bivariate.density">bivariate.density</a></code>, <code><a href="#topic+multiscale.slice">multiscale.slice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(chorley) # Chorley-Ribble data (package 'spatstat')
ch.multi &lt;- multiscale.density(chorley,h0=1)
plot(ch.multi)

ch.pilot &lt;- bivariate.density(chorley,h0=0.75) # with pre-defined pilot density
ch.multi2 &lt;- multiscale.density(chorley,h0=1,pilot.density=ch.pilot$z)
plot(ch.multi2)

data(pbc)
# widen h0 scale, increase z-axis resolution
pbc.multi &lt;- multiscale.density(pbc,h0=2,hp=1,h0fac=c(0.25,2.5),dimz=128) 
plot(pbc.multi)

</code></pre>

<hr>
<h2 id='multiscale.slice'>Slicing a multi-scale density/intensity object</h2><span id='topic+multiscale.slice'></span>

<h3>Description</h3>

<p>Takes slices of a multi-scale density/intensity estimate at desired
global bandwidths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiscale.slice(msob, h0, checkargs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiscale.slice_+3A_msob">msob</code></td>
<td>
<p>An object of class <code><a href="#topic+msden">msden</a></code> giving the multi-scale
estimate from which to take slices.</p>
</td></tr>
<tr><td><code id="multiscale.slice_+3A_h0">h0</code></td>
<td>
<p>Desired global bandwidth(s); the density/intensity estimate
corresponding to which will be returned. A numeric vector. All values <b>must</b> be in the
available range provided by <code>msob$h0range</code>; see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="multiscale.slice_+3A_checkargs">checkargs</code></td>
<td>
<p>Logical value indicating whether to check validity of
<code>msob</code> and <code>h0</code>. Disable only if you know this check will be
unnecessary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Davies &amp; Baddeley (2018) demonstrate that once a multi-scale
density/intensity estimate has been computed, we may take slices parallel to
the spatial domain of the trivariate convolution to return the estimate at
any desired global bandwidth. This function is the implementation thereof
based on a multi-scale estimate resulting from a call to
<code><a href="#topic+multiscale.density">multiscale.density</a></code>.
</p>
<p>The function returns an error if the
requested slices at <code>h0</code> are not all within the available range of
pre-computed global bandwidth scalings as defined by the <code>h0range</code>
component of <code>msob</code>.
</p>
<p>Because the contents of the <code>msob</code> argument, an object of class
<code><a href="#topic+msden">msden</a></code>, are returned based on a discretised set of global
bandwidth scalings, the function internally computes the desired surface as
a pixel-by-pixel linear interpolation using the two discretised global
bandwidth rescalings that bound each requested <code>h0</code>. (Thus, numeric
accuracy of the slices is improved with an increase to the <code>dimz</code>
argument of the preceding call to <code>multiscale.density</code> at the cost of
additional computing time.)
</p>


<h3>Value</h3>

<p>If <code>h0</code> is scalar, an object of class <code><a href="#topic+bivden">bivden</a></code> with components
corresponding to the requested slice at <code>h0</code>. If <code>h0</code> is a vector, a list of objects
of class <code><a href="#topic+bivden">bivden</a></code>.
</p>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>References</h3>

<p>Davies, T.M. and Baddeley A. (2018), Fast computation of
spatially adaptive kernel estimates, <em>Statistics and Computing</em>, <b>28</b>(4), 937-956.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multiscale.density">multiscale.density</a></code>, <code><a href="#topic+bivariate.density">bivariate.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(chorley) # Chorley-Ribble data (package 'spatstat')
ch.multi &lt;- multiscale.density(chorley,h0=1,h0fac=c(0.5,2))

available.h0(ch.multi)
ch.slices &lt;- multiscale.slice(ch.multi,h0=c(0.7,1.1,1.6))

par(mfcol=c(2,3)) # plot each density and edge-correction surface
for(i in 1:3) { plot(ch.slices[[i]]$z); plot(ch.slices[[i]]$q) }


</code></pre>

<hr>
<h2 id='NS'>Normal scale (NS) bandwidth selector</h2><span id='topic+NS'></span><span id='topic+NS.spattemp'></span>

<h3>Description</h3>

<p>Provides the asymptotically optimal fixed bandwidths for spatial or spatiotemporal 
normal densities based on a simple expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NS(
  pp,
  nstar = c("npoints", "geometric"),
  scaler = c("silverman", "IQR", "sd", "var")
)

NS.spattemp(
  pp,
  tt = NULL,
  nstar = "npoints",
  scaler = c("silverman", "IQR", "sd", "var")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NS_+3A_pp">pp</code></td>
<td>
<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the observed
2D data to be smoothed.</p>
</td></tr>
<tr><td><code id="NS_+3A_nstar">nstar</code></td>
<td>
<p>Optional. Controls the value to use in place of the number of
observations <em>n</em> in the normal scale formula. Either a character
string, <code>"npoints"</code> (default) or <code>"geometric"</code> (only possible for <code>NS</code>), or a positive
numeric value. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="NS_+3A_scaler">scaler</code></td>
<td>
<p>Optional. Controls the value for a scalar representation of
the spatial (and temporal for <code>NS.spattemp</code>) scale of the data. Either a character string, <code>"silverman"</code>
(default), <code>"IQR"</code>, <code>"sd"</code>, or <code>"var"</code>; or a positive numeric
value. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="NS_+3A_tt">tt</code></td>
<td>
<p>A numeric vector of equal length to the number of points in <code>pp</code>, 
giving the time corresponding to each spatial observation. If unsupplied, 
the function attempts to use the values in the <code><a href="spatstat.geom.html#topic+marks">marks</a></code> 
attribute of the <code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code> in <code>pp</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions calculate scalar smoothing bandwidths for kernel density
estimates of spatial or spatiotemporal data: the optimal values would minimise the
asymptotic mean integrated squared error assuming normally distributed data; see pp. 46-48
of Silverman (1986). The <code>NS</code> function returns a single bandwidth for isotropic smoothing
of spatial (2D) data. The <code>NS.spattemp</code> function returns two values &ndash; one for
the spatial margin and another for the temporal margin, based on independently applying
the normal scale rule (in 2D and 1D) to the spatial and temporal margins of the supplied data.
</p>

<dl>
<dt><b>Effective sample size</b></dt><dd><p> The formula
requires a sample size, and this can be minimally tailored via <code>nstar</code>.
By default, the function simply uses the number of observations in
<code>pp</code>: <code>nstar = "npoints"</code>. Alternatively, the user can specify their own value by simply
supplying a single positive numeric value to <code>nstar</code>. 
For <code>NS</code> (not applicable to <code>NS.spattemp</code>), if <code>pp</code> is a
<code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code> with factor-valued
<code><a href="spatstat.geom.html#topic+marks">marks</a></code>, then the user has the option of using
<code>nstar = "geometric"</code>, which sets the sample size used in the formula
to the geometric mean of the counts of observations of each mark. This can
be useful for e.g. relative risk calculations, see Davies and Hazelton
(2010). 
</p>
</dd>
<dt><b>Spatial (and temporal) scale</b></dt><dd><p>The <code>scaler</code> argument is used to specify spatial
(as well as temporal, in use of <code>NS.spattemp</code>) scale. For isotropic smoothing in the spatial
margin, one may use the &lsquo;robust&rsquo; estimate
of standard deviation found by a weighted mean of the interquartile ranges
of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the data respectively
(<code>scaler = "IQR"</code>). Two other options are the raw mean of the
coordinate-wise standard deviations (<code>scaler = "sd"</code>), or the square
root of the mean of the two variances (<code>scaler = "var"</code>). A fourth
option, <code>scaler = "silverman"</code> (default), sets the scaling constant to
be the minimum of the <code>"IQR"</code> and <code>"sd"</code> options; see Silverman
(1986), p. 47. In use of <code>NS.spattemp</code> the univariate version of the elected scale
statistic is applied to the recorded times of the data for the temporal bandwidth.
Alternatively, like <code>nstar</code>, the user can specify their
own value by simply supplying a single positive numeric value to
<code>scaler</code> for <code>NS</code>, or a numeric vector of length 2 (in the order of <em>[&lt;spatial scale&gt;, &lt;temporal scale&gt;]</em>)
for <code>NS.spattemp</code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A single numeric value of the estimated spatial bandwidth for <code>NS</code>, or a named numeric vector of length 2 giving
the spatial bandwidth (as <code>h</code>) and the temporal bandwidth (as <code>lambda</code>) for <code>NS.spattemp</code>.
</p>


<h3>Warning</h3>

<p>The NS bandwidth is an approximation, and assumes
<em>that the target density is normal</em>. This is considered rare
in most real-world applications. Nevertheless, it remains a quick and easy
&lsquo;rule-of-thumb&rsquo; method with which one may obtain a smoothing parameter. Note that a similar expression for the adaptive kernel
estimator is not possible (Davies et al., 2018).
</p>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>References</h3>

<p>Davies, T.M. and Hazelton, M.L. (2010), Adaptive kernel
estimation of spatial relative risk, <em>Statistics in Medicine</em>,
<b>29</b>(23) 2423-2437.
</p>
<p>Davies, T.M., Flynn, C.R. and Hazelton, M.L.
(2018), On the utility of asymptotic bandwidth selectors for spatially
adaptive kernel density estimation, <em>Statistics &amp; Probability Letters</em> [in press].
</p>
<p>Silverman, B.W. (1986), <em>Density Estimation for Statistics and Data Analysis</em>, Chapman
&amp; Hall, New York.
</p>
<p>Wand, M.P. and Jones, C.M., 1995. <em>Kernel Smoothing</em>, Chapman &amp; Hall, London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc)

NS(pbc)
NS(pbc,nstar="geometric") # uses case-control marks to replace sample size
NS(pbc,scaler="var") # set different scalar measure of spread

data(burk)
NS.spattemp(burk$cases)
NS.spattemp(burk$cases,scaler="sd") 

</code></pre>

<hr>
<h2 id='OS'>Oversmoothing (OS) bandwidth selector</h2><span id='topic+OS'></span><span id='topic+OS.spattemp'></span>

<h3>Description</h3>

<p>Provides fixed bandwidths for spatial or spatiotemporal data based on the
maximal smoothing (oversmoothing) principle of Terrell (1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OS(
  pp,
  nstar = c("npoints", "geometric"),
  scaler = c("silverman", "IQR", "sd", "var")
)

OS.spattemp(
  pp,
  tt = NULL,
  nstar = "npoints",
  scaler = c("silverman", "IQR", "sd", "var")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OS_+3A_pp">pp</code></td>
<td>
<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the observed
2D data to be smoothed.</p>
</td></tr>
<tr><td><code id="OS_+3A_nstar">nstar</code></td>
<td>
<p>Optional. Controls the value to use in place of the number of
observations <em>n</em> in the oversmoothing formula. Either a character
string, <code>"npoints"</code> (default) or <code>"geometric"</code> (only possible for <code>OS</code>), or a positive
numeric value. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="OS_+3A_scaler">scaler</code></td>
<td>
<p>Optional. Controls the value for a scalar representation of
the spatial (and temporal for <code>OS.spattemp</code>) scale of the data. Either a character string, <code>"silverman"</code>
(default), <code>"IQR"</code>, <code>"sd"</code>, or <code>"var"</code>; or positive numeric
value(s). See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="OS_+3A_tt">tt</code></td>
<td>
<p>A numeric vector of equal length to the number of points in <code>pp</code>, 
giving the time corresponding to each spatial observation. If unsupplied, 
the function attempts to use the values in the <code><a href="spatstat.geom.html#topic+marks">marks</a></code> 
attribute of the <code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code> in <code>pp</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions calculate scalar smoothing bandwidths for kernel density
estimates of spatial or spatiotemporal data: the &ldquo;maximal amount of smoothing
compatible with the estimated scale of the observed data&rdquo;. See Terrell
(1990). The <code>OS</code> function returns a single bandwidth for isotropic smoothing
of spatial (2D) data. The <code>OS.spattemp</code> function returns two values &ndash; one for
the spatial margin and another for the temporal margin, based on independently applying
Terrell's (1990) rule (in 2D and 1D) to the spatial and temporal margins of the supplied data.
</p>

<dl>
<dt><b>Effective sample size</b></dt><dd><p> The formula
requires a sample size, and this can be minimally tailored via <code>nstar</code>.
By default, the function simply uses the number of observations in
<code>pp</code>: <code>nstar = "npoints"</code>. Alternatively, the user can specify their own value by simply
supplying a single positive numeric value to <code>nstar</code>. 
For <code>OS</code> (not applicable to <code>OS.spattemp</code>), if <code>pp</code> is a
<code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code> with factor-valued
<code><a href="spatstat.geom.html#topic+marks">marks</a></code>, then the user has the option of using
<code>nstar = "geometric"</code>, which sets the sample size used in the formula
to the geometric mean of the counts of observations of each mark. This can
be useful for e.g. relative risk calculations, see Davies and Hazelton
(2010). 
</p>
</dd>
<dt><b>Spatial (and temporal) scale</b></dt><dd><p>The <code>scaler</code> argument is used to specify spatial
(as well as temporal, in use of <code>OS.spattemp</code>) scale. For isotropic smoothing in the spatial
margin, one may use the &lsquo;robust&rsquo; estimate
of standard deviation found by a weighted mean of the interquartile ranges
of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the data respectively
(<code>scaler = "IQR"</code>). Two other options are the raw mean of the
coordinate-wise standard deviations (<code>scaler = "sd"</code>), or the square
root of the mean of the two variances (<code>scaler = "var"</code>). A fourth
option, <code>scaler = "silverman"</code> (default), sets the scaling constant to
be the minimum of the <code>"IQR"</code> and <code>"sd"</code> options; see Silverman
(1986), p. 47. In use of <code>OS.spattemp</code> the univariate version of the elected scale
statistic is applied to the recorded times of the data for the temporal bandwidth.
Alternatively, like <code>nstar</code>, the user can specify their
own value by simply supplying a single positive numeric value to
<code>scaler</code> for <code>OS</code>, or a numeric vector of length 2 (in the order of <em>[&lt;spatial scale&gt;, &lt;temporal scale&gt;]</em>)
for <code>OS.spattemp</code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A single numeric value of the estimated spatial bandwidth for <code>OS</code>, or a named numeric vector of length 2 giving
the spatial bandwidth (as <code>h</code>) and the temporal bandwidth (as <code>lambda</code>) for <code>OS.spattemp</code>.
</p>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>References</h3>

<p>Davies, T.M. and Hazelton, M.L. (2010), Adaptive kernel
estimation of spatial relative risk, <em>Statistics in Medicine</em>,
<b>29</b>(23) 2423-2437.
</p>
<p>Terrell, G.R. (1990), The maximal smoothing
principle in density estimation, <em>Journal of the American Statistical
Association</em>, <b>85</b>, 470-477.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc)

OS(pbc)
OS(pbc,nstar="geometric") # uses case-control marks to replace sample size
OS(pbc,scaler="var") # set different scalar measure of spread

data(burk)
OS.spattemp(burk$cases)
OS.spattemp(burk$cases,scaler="sd") 

</code></pre>

<hr>
<h2 id='pbc'>Primary biliary cirrhosis data</h2><span id='topic+pbc'></span>

<h3>Description</h3>

<p>Data of the locations of 761 cases of primary biliary cirrhosis in several
adjacent health regions of north-eastern England, along with 3020 controls
representing the at-risk population, collected between 1987 and 1994. These
data were first presented and analysed by Prince et al. (2001); subsequent
analysis of these data in the spirit of <code><a href="#topic+sparr">sparr</a></code> was performed in
Davies and Hazelton (2010). Also included is the polygonal study region.
</p>


<h3>Format</h3>

<p><code>pbc</code> is a dichotomously marked
<code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code>, with locations expressed in UK Ordnance
Survey Coordinates (km).
</p>


<h3>Acknowledgements</h3>

<p>The authors thank Prof. Peter Diggle for providing access
to these data.
</p>


<h3>Source</h3>

<p>Prince et al. (2001), The geographical distribution of primary
biliary cirrhosis in a well-defined cohort, <em>Hepatology</em>, <b>34</b>,
1083-1088.
</p>


<h3>References</h3>

<p>Davies, T.M. and Hazelton, M.L. (2010), Adaptive kernel
estimation of spatial relative risk, <em>Statistics in Medicine</em>,
<b>29</b>(23) 2423-2437.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc)
summary(pbc)
plot(pbc)

</code></pre>

<hr>
<h2 id='plot.bivden'>Plotting sparr objects</h2><span id='topic+plot.bivden'></span><span id='topic+plot.rrs'></span><span id='topic+plot.msden'></span><span id='topic+plot.stden'></span><span id='topic+plot.rrst'></span>

<h3>Description</h3>

<p><code>plot</code> methods for classes <code><a href="#topic+bivden">bivden</a></code>, <code><a href="#topic+stden">stden</a></code>,
<code><a href="#topic+rrs">rrs</a></code>, <code><a href="#topic+rrst">rrst</a></code> and <code><a href="#topic+msden">msden</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bivden'
plot(
  x,
  what = c("z", "edge", "bw"),
  add.pts = FALSE,
  auto.axes = TRUE,
  override.par = TRUE,
  ...
)

## S3 method for class 'msden'
plot(x, what = c("z", "edge", "bw"), sleep = 0.2, override.par = TRUE, ...)

## S3 method for class 'rrs'
plot(
  x,
  auto.axes = TRUE,
  tol.show = TRUE,
  tol.type = c("upper", "lower", "two.sided"),
  tol.args = list(levels = 0.05, lty = 1, drawlabels = TRUE),
  ...
)

## S3 method for class 'rrst'
plot(
  x,
  tselect = NULL,
  type = c("joint", "conditional"),
  fix.range = FALSE,
  tol.show = TRUE,
  tol.type = c("upper", "lower", "two.sided"),
  tol.args = list(levels = 0.05, lty = 1, drawlabels = TRUE),
  sleep = 0.2,
  override.par = TRUE,
  expscale = FALSE,
  ...
)

## S3 method for class 'stden'
plot(
  x,
  tselect = NULL,
  type = c("joint", "conditional"),
  fix.range = FALSE,
  sleep = 0.2,
  override.par = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bivden_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+bivden">bivden</a></code>, <code><a href="#topic+stden">stden</a></code>,
<code><a href="#topic+rrs">rrs</a></code>, <code><a href="#topic+rrst">rrst</a></code>, or <code><a href="#topic+msden">msden</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_what">what</code></td>
<td>
<p>A character string to select plotting of result (<code>"z"</code>;
default); edge-correction surface (<code>"edge"</code>); or variable bandwidth
surface (<code>"bw"</code>).</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_add.pts">add.pts</code></td>
<td>
<p>Logical value indicating whether to add the observations to
the image plot using default <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_auto.axes">auto.axes</code></td>
<td>
<p>Logical value indicating whether to display the plot with
automatically added x-y axes and an &lsquo;L&rsquo; box in default styles.</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_override.par">override.par</code></td>
<td>
<p>Logical value indicating whether to override the
existing graphics device parameters prior to plotting, resetting
<code>mfrow</code> and <code>mar</code>. See &lsquo;Details&rsquo; for when you might want to
disable this.</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters to be passed to
<code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>, or in one instance, to
<code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code> (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_sleep">sleep</code></td>
<td>
<p>Single positive numeric value giving the amount of time (in
seconds) to <code><a href="base.html#topic+Sys.sleep">Sys.sleep</a></code> before drawing the next image in
the animation.</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_tol.show">tol.show</code></td>
<td>
<p>Logical value indicating whether to show pre-computed tolerance contours on the plot(s). The object <code>x</code> must already have the relevant <em>p</em>-value surface(s) stored in order for this argument to have any effect.</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_tol.type">tol.type</code></td>
<td>
<p>A character string used to control the type of tolerance contour displayed; a test for elevated risk (<code>"upper"</code>), decreased risk (<code>"lower"</code>), or a two-tailed test (<code>two.sided</code>).</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_tol.args">tol.args</code></td>
<td>
<p>A named list of valid arguments to be passed directly to <code><a href="graphics.html#topic+contour">contour</a></code> to control the appearance of plotted contours. Commonly used items are <code>levels</code>, <code>lty</code>, <code>lwd</code> and <code>drawlabels</code>.</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_tselect">tselect</code></td>
<td>
<p>Either a single numeric value giving the time at which to return the plot, or a vector of length 2 giving an interval of times over which to plot. This argument must respect the stored temporal bound in <code>x$tlim</code>, else an error will be thrown. By default, the full set of images (i.e. over the entire available time span) is plotted.</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_type">type</code></td>
<td>
<p>A character string to select plotting of joint/unconditional spatiotemporal
estimate (default) or conditional spatial density given time.</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_fix.range">fix.range</code></td>
<td>
<p>Logical value indicating whether use the same color scale limits for each plot in the sequence. Ignored if the user supplies a pre-defined <code><a href="spatstat.geom.html#topic+colourmap">colourmap</a></code> to the <code>col</code> argument, which is matched to <code>...</code> above and passed to <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>. See &lsquo;Examples&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.bivden_+3A_expscale">expscale</code></td>
<td>
<p>Logical value indicating whether to force a raw-risk scale. Useful for users
wishing to plot a log-relative risk surface, but to have the raw-risk displayed on the colour ribbon.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In all instances, visualisation is deferred to
<code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>, for which there are a variety of
customisations available the user can access via <code>...</code>. The one
exception is when plotting observation-specific <code>"diggle"</code> edge
correction factors&mdash;in this instance, a plot of the spatial observations is
returned with size proportional to the influence of each correction weight.
</p>
<p>When plotting a <code><a href="#topic+rrs">rrs</a></code> object, a pre-computed <em>p</em>-value
surface (see argument <code>tolerate</code> in <code><a href="#topic+risk">risk</a></code>) will
automatically be superimposed at a significance level of 0.05. Greater
flexibility in visualisation is gained by using <code><a href="#topic+tolerance">tolerance</a></code> in
conjunction with <code><a href="graphics.html#topic+contour">contour</a></code>.
</p>
<p>An <code><a href="#topic+msden">msden</a></code>, <code><a href="#topic+stden">stden</a></code>, or <code><a href="#topic+rrst">rrst</a></code> object is plotted as an animation, one pixel image
after another, separated by <code>sleep</code> seconds. If instead you intend the
individual images to be plotted in an array of images, you should first set
up your plot device layout, and ensure <code>override.par = FALSE</code> so that
the function does not reset these device parameters itself. In such an
instance, one might also want to set <code>sleep = 0</code>.
</p>


<h3>Value</h3>

<p>Plots to the relevant graphics device.
</p>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(pbc)
data(fmd)
data(burk)

# 'bivden' object
pbcden &lt;- bivariate.density(split(pbc)$case,h0=3,hp=2,adapt=TRUE,davies.baddeley=0.05,verbose=FALSE)
plot(pbcden)
plot(pbcden,what="bw",main="PBC cases\n variable bandwidth surface",xlab="Easting",ylab="Northing")

# 'stden' object
burkden &lt;- spattemp.density(burk$cases,tres=128) # observation times are stored in marks(burk$cases)
plot(burkden,fix.range=TRUE,sleep=0.1) # animation
plot(burkden,tselect=c(1000,3000),type="conditional") # spatial densities conditional on each time

# 'rrs' object
pbcrr &lt;- risk(pbc,h0=4,hp=3,adapt=TRUE,tolerate=TRUE,davies.baddeley=0.025,edge="diggle")
plot(pbcrr) # default
plot(pbcrr,tol.args=list(levels=c(0.05,0.01),lty=2:1,col="seagreen4"),auto.axes=FALSE)

# 'rrst' object
f &lt;- spattemp.density(fmd$cases,h=6,lambda=8)
g &lt;- bivariate.density(fmd$controls,h0=6)
fmdrr &lt;- spattemp.risk(f,g,tolerate=TRUE)
plot(fmdrr,sleep=0.1,fix.range=TRUE)
plot(fmdrr,type="conditional",sleep=0.1,tol.type="two.sided",
     tol.args=list(levels=0.05,drawlabels=FALSE))

# 'msden' object
pbcmult &lt;- multiscale.density(split(pbc)$case,h0=4,h0fac=c(0.25,2.5))
plot(pbcmult) # densities
plot(pbcmult,what="edge") # edge correction surfaces
plot(pbcmult,what="bw") # bandwidth surfaces

</code></pre>

<hr>
<h2 id='print.bivden'>Printing sparr objects</h2><span id='topic+print.bivden'></span><span id='topic+print.rrs'></span><span id='topic+print.msden'></span><span id='topic+print.stden'></span><span id='topic+print.rrst'></span>

<h3>Description</h3>

<p><code>print</code> methods for classes <code><a href="#topic+bivden">bivden</a></code>, <code><a href="#topic+stden">stden</a></code>,
<code><a href="#topic+rrs">rrs</a></code>, <code><a href="#topic+rrst">rrst</a></code> and <code><a href="#topic+msden">msden</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bivden'
print(x, ...)

## S3 method for class 'msden'
print(x, ...)

## S3 method for class 'rrs'
print(x, ...)

## S3 method for class 'rrst'
print(x, ...)

## S3 method for class 'stden'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bivden_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+bivden">bivden</a></code>, <code><a href="#topic+stden">stden</a></code>,
<code><a href="#topic+rrs">rrs</a></code>, <code><a href="#topic+rrst">rrst</a></code>, or <code><a href="#topic+msden">msden</a></code>.</p>
</td></tr>
<tr><td><code id="print.bivden_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>

<hr>
<h2 id='rimpoly'>Random point generation inside polygon</h2><span id='topic+rimpoly'></span>

<h3>Description</h3>

<p>Generates a random point pattern of <code class="reqn">n</code> iid points with any specified distribution based on a pixel image and a corresponding polygonal window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rimpoly(n, z, w = NULL, correction = 1.1, maxpass = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rimpoly_+3A_n">n</code></td>
<td>
<p>Number of points to generate.</p>
</td></tr>
<tr><td><code id="rimpoly_+3A_z">z</code></td>
<td>
<p>A pixel image of class <code><a href="spatstat.geom.html#topic+im">im</a></code> defining the probability density of the points, possibly unnormalised.</p>
</td></tr>
<tr><td><code id="rimpoly_+3A_w">w</code></td>
<td>
<p>A polygonal window of class <code><a href="spatstat.geom.html#topic+owin">owin</a></code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="rimpoly_+3A_correction">correction</code></td>
<td>
<p>An adjustment to the number of points generated at the initial pass of the internal loop in an effort to minimise the total number of passes required to reach <code class="reqn">n</code> points. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="rimpoly_+3A_maxpass">maxpass</code></td>
<td>
<p>The maximum number of passes allowed before the function exits. If this is reached before <code class="reqn">n</code> points are found that fall within <code>w</code>, a warning is issued.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a deliberate variant of <code><a href="spatstat.random.html#topic+rpoint">rpoint</a></code> (Baddeley et. al, 2015), to be accessed when the user desires 
a randomly generated point pattern based on a pixel image, but wants the window of the point pattern to be a corresponding irregular polygon, as opposed to a binary
image mask (which, when converted to a polygon directly, gives jagged edges based on the union of the pixels). When the user specifies their own polygonal window, a <code>while</code> loop is called and repeated as many
times as necessary (up to <code>maxpass</code> times) to find <code>n</code> points inside <code>w</code> (when <code>w = NULL</code>, then the aforementioned union of the pixels of <code>z</code>
is used, obtained via <code>as.polygonal(Window(z))</code>). The loop is necessary because the standard behaviour of <code><a href="spatstat.random.html#topic+rpoint">rpoint</a></code> can (and often does)
yield points that sit in corners of pixels which lie outside the corresponding <code>w</code>.
</p>
<p>The <code>correction</code> argument is used to determine how many points are generated initially,
which will be <code>ceiling(correction*n)</code>; to minimise the number of required passes over the loop this is by default set to give a number slightly higher than the requested <code>n</code>.
</p>
<p>An error is thrown if <code>Window(z)</code> and <code>w</code> do not overlap.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> containing the <code>n</code> generated points, defined with the polygonal <code><a href="spatstat.geom.html#topic+owin">owin</a></code>, <code>w</code>.
</p>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>, Chapman and Hall/CRC Press, UK.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc)
Y &lt;- bivariate.density(pbc,h0=2.5,res=25)

# Direct use of 'rpoint':
A &lt;- rpoint(500,Y$z)
npoints(A)

# Using 'rimpoly' without supplying polygon:
B &lt;- rimpoly(500,Y$z)
npoints(B)

# Using 'rimpoly' with the original pbc polygonal window:
C &lt;- rimpoly(500,Y$z,Window(Y$pp))
npoints(C)

oldpar &lt;- par(mfrow=c(1,3))
plot(A,main="rpoint")
plot(B,main="rimpoly (no polygon supplied)")
plot(C,main="rimpoly (original polygon supplied)")
par(oldpar)

</code></pre>

<hr>
<h2 id='risk'>Spatial relative risk/density ratio</h2><span id='topic+risk'></span><span id='topic+rrs'></span>

<h3>Description</h3>

<p>Estimates a <em>relative risk</em> function based on the ratio of two 2D
kernel density estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>risk(
  f,
  g = NULL,
  log = TRUE,
  h0 = NULL,
  hp = h0,
  adapt = FALSE,
  shrink = FALSE,
  shrink.args = list(rescale = TRUE, type = c("lasso", "Bithell"), lambda = NA),
  tolerate = FALSE,
  doplot = FALSE,
  pilot.symmetry = c("none", "f", "g", "pooled"),
  epsilon = 0,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="risk_+3A_f">f</code></td>
<td>
<p>Either a pre-calculated object of class <code><a href="#topic+bivden">bivden</a></code>
representing the &lsquo;case&rsquo; (numerator) density estimate, or an object of class
<code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the observed case data. Alternatively, if
<code>f</code> is <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> object with dichotomous
factor-valued <code><a href="spatstat.geom.html#topic+marks">marks</a></code>, the function treats the first
level as the case data, and the second as the control data, obviating the
need to supply <code>g</code>.</p>
</td></tr>
<tr><td><code id="risk_+3A_g">g</code></td>
<td>
<p>As for <code>f</code>, for the &lsquo;control&rsquo; (denominator) density; this
object must be of the same class as <code>f</code>. Ignored if, as stated above,
<code>f</code> contains both case and control observations.</p>
</td></tr>
<tr><td><code id="risk_+3A_log">log</code></td>
<td>
<p>Logical value indicating whether to return the (natural)
log-transformed relative risk function as recommended by Kelsall and Diggle
(1995a). Defaults to <code>TRUE</code>, with the alternative being the raw density
ratio.</p>
</td></tr>
<tr><td><code id="risk_+3A_h0">h0</code></td>
<td>
<p>A single positive numeric value or a vector of length 2 giving the
global bandwidth(s) to be used for case/control density estimates;
defaulting to a common oversmoothing bandwidth computed via <code><a href="#topic+OS">OS</a></code>
on the pooled data using <code>nstar = "geometric"</code> if unsupplied. Ignored if <code>f</code> and <code>g</code> are
already <code><a href="#topic+bivden">bivden</a></code> objects.</p>
</td></tr>
<tr><td><code id="risk_+3A_hp">hp</code></td>
<td>
<p>A single numeric value or a vector of length 2 giving the pilot
bandwidth(s) to be used for fixed-bandwidth estimation of the pilot
densities for adaptive risk surfaces. Ignored if <code>adapt = FALSE</code> or if
<code>f</code> and <code>g</code> are already <code><a href="#topic+bivden">bivden</a></code> objects.</p>
</td></tr>
<tr><td><code id="risk_+3A_adapt">adapt</code></td>
<td>
<p>A logical value indicating whether to employ adaptive smoothing
for internally estimating the densities. Ignored if <code>f</code> and <code>g</code>
are already <code><a href="#topic+bivden">bivden</a></code> objects.</p>
</td></tr>
<tr><td><code id="risk_+3A_shrink">shrink</code></td>
<td>
<p>A logical value indicating whether to compute the shrinkage estimator
of Hazelton (2023). This is only possible for <code>adapt=FALSE</code>.</p>
</td></tr>
<tr><td><code id="risk_+3A_shrink.args">shrink.args</code></td>
<td>
<p>A named list of optional arguments controlling the shrinkage estimator.
Possible entries are <code>rescale</code> (a logical value indicating whether to integrate
to one with respect to the control distribution over the window); <code>type</code> 
(a character string stipulating the shrinkage methodology to be used, either the
default <code>"lasso"</code> or the alternative <code>"Bithell"</code>); and <code>lambda</code>
(a non-negative numeric value determining the degree of shrinkage towards uniform
relative risk&mdash;when set to its default <code>NA</code>, it is selected via cross-validation).</p>
</td></tr>
<tr><td><code id="risk_+3A_tolerate">tolerate</code></td>
<td>
<p>A logical value indicating whether to internally calculate a
corresponding asymptotic p-value surface (for tolerance contours) for the
estimated relative risk function. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="risk_+3A_doplot">doplot</code></td>
<td>
<p>Logical. If <code>TRUE</code>, an image plot of the estimated
relative risk function is produced using various visual presets. If
additionally <code>tolerate</code> was <code>TRUE</code>, asymptotic tolerance contours
are automatically added to the plot at a significance level of 0.05 for
elevated risk (for more flexible options for calculating and plotting
tolerance contours, see <code><a href="#topic+tolerance">tolerance</a></code> and
<code><a href="#topic+tol.contour">tol.contour</a></code>).</p>
</td></tr>
<tr><td><code id="risk_+3A_pilot.symmetry">pilot.symmetry</code></td>
<td>
<p>A character string used to control the type of
symmetry, if any, to use for the bandwidth factors when computing an
adaptive relative risk surface. See &lsquo;Details&rsquo;. Ignored if <code>adapt =
FALSE</code>.</p>
</td></tr>
<tr><td><code id="risk_+3A_epsilon">epsilon</code></td>
<td>
<p>A single non-negative numeric value used for optional scaling
to produce additive constant to each density in the raw ratio (see
&lsquo;Details&rsquo;). A zero value requests no additive constant (default).</p>
</td></tr>
<tr><td><code id="risk_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether to print function progress
during execution.</p>
</td></tr>
<tr><td><code id="risk_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to any internal calls of
<code><a href="#topic+bivariate.density">bivariate.density</a></code> for estimation of the requisite densities.
Ignored if <code>f</code> and <code>g</code> are already <code><a href="#topic+bivden">bivden</a></code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relative risk function is defined here as the ratio of the &lsquo;case&rsquo;
density to the &lsquo;control&rsquo; (Bithell, 1990; 1991). Using kernel density
estimation to model these densities (Diggle, 1985), we obtain a workable
estimate thereof. This function defines the risk function <em>r</em> in the
following fashion: <br /><br /> <em>r</em><code> = (fd + epsilon*max(gd))/(gd +
epsilon*max(gd))</code>, <br /><br /> where <code>fd</code> and <code>gd</code> denote the case and
control density estimates respectively. Note the (optional) additive
constants defined by <code>epsilon</code> times the maximum of each of the
densities in the numerator and denominator respectively (see Bowman and
Azzalini, 1997). A more recent shrinkage estimator developed by Hazelton (2023)
is also implemented.
</p>
<p>The log-risk function <em>rho</em>, given by <em>rho</em> = log[<em>r</em>], is
argued to be preferable in practice as it imparts a sense of symmetry in the
way the case and control densities are treated (Kelsall and Diggle,
1995a;b). The option of log-transforming the returned risk function is
therefore selected by default.
</p>
<p>When computing adaptive relative risk functions, the user has the option of
obtaining a so-called <em>symmetric</em> estimate (Davies et al. 2016) via
<code>pilot.symmetry</code>. This amounts to choosing the same pilot density for
both case and control densities. By choosing <code>"none"</code> (default), the
result uses the case and control data separately for the fixed-bandwidth
pilots, providing the original asymmetric density-ratio of Davies and
Hazelton (2010). By selecting either of <code>"f"</code>, <code>"g"</code>, or
<code>"pooled"</code>, the pilot density is calculated based on the case, control,
or pooled case/control data respectively (using <code>hp[1]</code> as the fixed
bandwidth). Davies et al. (2016) noted some beneficial practical behaviour
of the symmetric adaptive surface over the asymmetric.
</p>
<p>If the user selects <code>tolerate = TRUE</code>, the function internally computes
asymptotic tolerance contours as per Hazelton and Davies (2009) and Davies
and Hazelton (2010). When <code>adapt = FALSE</code>, the reference density
estimate (argument <code>ref.density</code> in <code><a href="#topic+tolerance">tolerance</a></code>) is taken
to be the estimated control density. The returned pixel
<code><a href="spatstat.geom.html#topic+im">im</a></code>age of <em>p</em>-values (see &lsquo;Value&rsquo;) is
interpreted as an upper-tailed test i.e. smaller <em>p</em>-values represent
greater evidence in favour of significantly increased risk. For greater
control over calculation of tolerance contours, use <code><a href="#topic+tolerance">tolerance</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"rrs"</code>. This is a named list with the
following components:
</p>
<table role = "presentation">
<tr><td><code>rr</code></td>
<td>
<p>A pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age of the
estimated risk surface.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>An object of class <code><a href="#topic+bivden">bivden</a></code>
used as the numerator or &lsquo;case&rsquo; density estimate.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>An object of
class <code><a href="#topic+bivden">bivden</a></code> used as the denominator or &lsquo;control&rsquo; density
estimate.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>Only included if <code>tolerate = TRUE</code>. A pixel
<code><a href="spatstat.geom.html#topic+im">im</a></code>age of the <em>p</em>-value surface for tolerance
contours; <code>NULL</code> otherwise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>References</h3>

<p>Bithell, J.F. (1990), An application of density estimation to
geographical epidemiology, <em>Statistics in Medicine</em>, <b>9</b>,
691-701.
</p>
<p>Bithell, J.F. (1991), Estimation of relative risk functions,
<em>Statistics in Medicine</em>, <b>10</b>, 1745-1751.
</p>
<p>Bowman, A.W. and Azzalini A. (1997), <em>Applied Smoothing Techniques for Data Analysis:
The Kernel Approach with S-Plus Illustrations</em>, Oxford University Press
Inc., New York.
</p>
<p>Davies, T.M. and Hazelton, M.L. (2010), Adaptive
kernel estimation of spatial relative risk, <em>Statistics in Medicine</em>,
<b>29</b>(23) 2423-2437.
</p>
<p>Davies, T.M., Jones, K. and Hazelton, M.L.
(2016), Symmetric adaptive smoothing regimens for estimation of the spatial
relative risk function, <em>Computational Statistics &amp; Data Analysis</em>,
<b>101</b>, 12-28.
</p>
<p>Diggle, P.J. (1985), A kernel method for smoothing
point process data, <em>Journal of the Royal Statistical Society Series
C</em>, <b>34</b>(2), 138-147.
</p>
<p>Hazelton, M.L. (2023), Shrinkage estimators of the spatial relative
risk function, <em>Submitted for publication</em>.
</p>
<p>Hazelton, M.L. and Davies, T.M. (2009),
Inference based on kernel estimates of the relative risk function in
geographical epidemiology, <em>Biometrical Journal</em>, <b>51</b>(1),
98-109.
</p>
<p>Kelsall, J.E. and Diggle, P.J. (1995a), Kernel estimation of
relative risk, <em>Bernoulli</em>, <b>1</b>, 3-16.
</p>
<p>Kelsall, J.E. and
Diggle, P.J. (1995b), Non-parametric estimation of spatial variation in
relative risk, <em>Statistics in Medicine</em>, <b>14</b>, 2335-2342.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc)
pbccas &lt;- split(pbc)$case
pbccon &lt;- split(pbc)$control
h0 &lt;- OS(pbc,nstar="geometric")

# Fixed (with tolerance contours)
pbcrr1 &lt;- risk(pbccas,pbccon,h0=h0,tolerate=TRUE)

# Fixed shrinkage
pbcrr2 &lt;- risk(pbccas,pbccon,h0=h0,shrink=TRUE,shrink.args=list(lambda=4))

# Asymmetric adaptive
pbcrr3 &lt;- risk(pbccas,pbccon,h0=h0,adapt=TRUE,hp=c(OS(pbccas)/2,OS(pbccon)/2),
               tolerate=TRUE,davies.baddeley=0.05)

# Symmetric (pooled) adaptive
pbcrr4 &lt;- risk(pbccas,pbccon,h0=h0,adapt=TRUE,tolerate=TRUE,hp=OS(pbc)/2,
               pilot.symmetry="pooled",davies.baddeley=0.05)

# Symmetric (case) adaptive; from two existing 'bivden' objects
f &lt;- bivariate.density(pbccas,h0=h0,hp=2,adapt=TRUE,pilot.density=pbccas,
                       edge="diggle",davies.baddeley=0.05,verbose=FALSE) 
g &lt;- bivariate.density(pbccon,h0=h0,hp=2,adapt=TRUE,pilot.density=pbccas,
                       edge="diggle",davies.baddeley=0.05,verbose=FALSE)
pbcrr5 &lt;- risk(f,g,tolerate=TRUE,verbose=FALSE)

oldpar &lt;- par(mfrow=c(2,2))
plot(pbcrr1,override.par=FALSE,main="Fixed")
plot(pbcrr2,override.par=FALSE,main="Fixed shrinkage")
plot(pbcrr3,override.par=FALSE,main="Asymmetric adaptive")
plot(pbcrr4,override.par=FALSE,main="Symmetric (pooled) adaptive") 
par(oldpar)

</code></pre>

<hr>
<h2 id='SLIK.adapt'>Simultaneous global/pilot likelihood bandwidth selection</h2><span id='topic+SLIK.adapt'></span>

<h3>Description</h3>

<p>Isotropic global and pilot bandwidth selection for adaptive density/intensity
based on likelihood cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SLIK.adapt(
  pp,
  hold = TRUE,
  start = rep(OS(pp), 2),
  hlim = NULL,
  edge = TRUE,
  zero.action = c(-1, 0),
  optim.control = list(),
  parallelise = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SLIK.adapt_+3A_pp">pp</code></td>
<td>
<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the observed
2D data to be smoothed.</p>
</td></tr>
<tr><td><code id="SLIK.adapt_+3A_hold">hold</code></td>
<td>
<p>Logical value indicating whether to hold the global and pilot bandwidths equal throughout the
optimisation; defaults to <code>TRUE</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="SLIK.adapt_+3A_start">start</code></td>
<td>
<p>A positively-valued numeric vector of length 2 giving the starting values to be used for the global/pilot
optimisation routine when <code>hold = FALSE</code>. Defaults to the oversmoothing bandwidth (<code><a href="#topic+OS">OS</a></code>) for both values;
ignored when <code>hold = TRUE</code>.</p>
</td></tr>
<tr><td><code id="SLIK.adapt_+3A_hlim">hlim</code></td>
<td>
<p>An optional vector of length 2 giving the limits of the
optimisation routine with respect to the bandwidth when <code>hold = TRUE</code>. If unspecified, the
function attempts to choose this automatically. Ignored when <code>hold = FALSE</code>.</p>
</td></tr>
<tr><td><code id="SLIK.adapt_+3A_edge">edge</code></td>
<td>
<p>Logical value indicating whether to edge-correct the density
estimates used.</p>
</td></tr>
<tr><td><code id="SLIK.adapt_+3A_zero.action">zero.action</code></td>
<td>
<p>A numeric vector of length 2, each value being either <code>-1</code>, <code>0</code> (default), <code>1</code> or <code>2</code> controlling how the function should behave in response to numerical errors at very small bandwidths, when such a bandwidth results in one or more zero or negative density values during the leave-one-out computations. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="SLIK.adapt_+3A_optim.control">optim.control</code></td>
<td>
<p>An optional list to be passed to the <code>control</code> argument of <code><a href="stats.html#topic+optim">optim</a></code> for further control over the numeric optimisation when <code>hold = FALSE</code>. See the documentation for <code><a href="stats.html#topic+optim">optim</a></code> for further details.</p>
</td></tr>
<tr><td><code id="SLIK.adapt_+3A_parallelise">parallelise</code></td>
<td>
<p>Numeric argument to invoke parallel processing in the brute force leave-one-out calculations, giving
the number of CPU cores to use. Experimental. Test
your system first using <code>parallel::detectCores()</code> to identify the
number of cores available to you. If <code>NA</code> (default), no parallelisation performed and a single loop is used.</p>
</td></tr>
<tr><td><code id="SLIK.adapt_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether to provide function progress
commentary.</p>
</td></tr>
<tr><td><code id="SLIK.adapt_+3A_...">...</code></td>
<td>
<p>Additional arguments controlling density estimation for the internal calculations. Relevant arguments are <code>resolution</code>, <code>gamma.scale</code>, and <code>trim</code>. If unsupplied these default to <code>64</code>, <code>"geometric"</code>, and <code>5</code> respectively; see <code><a href="#topic+bivariate.density">bivariate.density</a></code> for a further explanation of these arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a generalisation of <code><a href="#topic+LIK.density">LIK.density</a></code>, and is used in attempts to simultaneously choose
an optimal global and pilot bandwidth for adaptive kernel density estimates. Where <code><a href="#topic+LIK.density">LIK.density</a></code> for adaptive
estimates assumes the pilot density is held constant (and is not subject to the leave-one-out operations), this function
allows the pilot bandwidth to vary alongside the global.
</p>
<p>Thus, in contrast to <code><a href="#topic+LIK.density">LIK.density</a></code> the internal leave-one-out operations now also affect the
pilot estimation stage. Hence, the set of variable bandwidths changes as each point is left out. In turn, this means the leave-one-out operations must
be computed by brute force, and this is computationally expensive.
</p>
<p>Identifiability problems can sometimes arise when the global and pilot bandwidths are allowed to &lsquo;float freely&rsquo; in the bivariate optimisation routine, which is the default
behaviour of the function (with <code>hold = FALSE</code>). This can be curbed by setting <code>hold = TRUE</code>, which forces both the global and pilot
to be held at the same value during optimisation. Doing this also has the beneficial side effect of turning the problem into one of univariate optimisation, thereby reducing total computational cost. Current work (Davies &amp; Lawson, 2018) provides some empirical evidence that this strategy performs quite well in practice.
</p>
<p>Like <code><a href="#topic+LSCV.density">LSCV.density</a></code> and <code><a href="#topic+LIK.density">LIK.density</a></code>, the argument <code>zero.action</code> can be used to control the level of severity in response to small bandwidths that result (due to numerical error) in at least one density value being zero or less. 
When this argument is passed a vector of length 2, the first entry corresponds to the global bandwidth (and hence refers to checks of the final adaptive density estimate and its leave-one-out values) and the second to the pilot bandwidth (and hence checks the fixed-bandwidth pilot density and its leave-one-out values).
Alternatively a single value may be supplied, which will be taken to be the same for both global and pilot.
See the help page for <code><a href="#topic+LIK.density">LIK.density</a></code> for an explanation of the four allowable values (<code>-1</code>, <code>0</code>, <code>1</code>, <code>2</code>) for each component of this argument.
</p>


<h3>Value</h3>

<p>A numeric vector of length 2 giving the likelihood-maximised global and pilot bandwidths.
</p>


<h3>Note</h3>

<p>While theoretically valid, this is a largely experimental function. There is presently little in the literature to suggest how well this
type of simultaneous global/pilot bandwidth selection might perform in practice. Current research efforts (Davies &amp; Lawson, 2018)
seek in part to address these questions.
</p>


<h3>Author(s)</h3>

<p>T. M. Davies
</p>


<h3>References</h3>

<p>Davies, T.M. and Lawson, A.B. (2018), An evaluation of likelihood-based bandwidth selectors for spatial and spatiotemporal kernel estimates, <em>Submitted for publication</em>.
</p>
<p>Silverman, B.W. (1986), <em>Density Estimation for Statistics
and Data Analysis</em>, Chapman &amp; Hall, New York.
</p>
<p>Wand, M.P. and Jones,
C.M., 1995. <em>Kernel Smoothing</em>, Chapman &amp; Hall, London.
</p>


<h3>See Also</h3>

<p>Functions for bandwidth selection in package
<code>spatstat</code>: <code><a href="spatstat.explore.html#topic+bw.diggle">bw.diggle</a></code>;
<code><a href="spatstat.explore.html#topic+bw.ppl">bw.ppl</a></code>; <code><a href="spatstat.explore.html#topic+bw.scott">bw.scott</a></code>;
<code><a href="spatstat.explore.html#topic+bw.frac">bw.frac</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



data(pbc)
pbccas &lt;- split(pbc)$case

SLIK.adapt(pbccas)
SLIK.adapt(pbccas,hold=TRUE)

 

</code></pre>

<hr>
<h2 id='sparr-internal'>
Internal <code>sparr</code> functions
</h2><span id='topic+sparr-internal'></span><span id='topic+adens'></span><span id='topic+BAM.single'></span><span id='topic+BAM.prep'></span><span id='topic+bivden.LOO'></span><span id='topic+checkdb'></span><span id='topic+checkedge'></span><span id='topic+checkit'></span><span id='topic+checkran'></span><span id='topic+cv.RelRisk'></span><span id='topic+cv.RelRisk.Bithell'></span><span id='topic+edgeh'></span><span id='topic+gethcats'></span><span id='topic+identical_windows'></span><span id='topic+K0'></span><span id='topic+LSCV.density.spatial.single'></span><span id='topic+LSCV.risk.single'></span><span id='topic+posifybivden'></span><span id='topic+processgamma'></span><span id='topic+processnstar'></span><span id='topic+processscaler'></span><span id='topic+point_image_by_bw'></span><span id='topic+taperoff'></span><span id='topic+tol.asy.ada'></span><span id='topic+tol.asy.fix'></span><span id='topic+tol.mc.ada'></span><span id='topic+tol.mc.fix'></span>

<h3>Description</h3>

<p>Internal <code><a href="#topic+sparr">sparr</a></code> functions, only meant to be accessed by the user directly in a life-threatening situation.
</p>


<h3>Usage</h3>

<p><code>adens(x,bwim,bwpts,resolution,edge,diggle,weights,intensity,hstep,qstep,qres,verbose)</code><br />
<code>BAM.single(h,edge,BP)</code><br />
<code>BAM.prep(cases,controls,lambda,erode,res)</code><br />
<code>bivden.LOO(pp,h0,hp,gamma.scale,trim,resolution,parallel)</code><br />
<code>checkdb(db)</code><br />
<code>checkedge(edge)</code><br />
<code>checkit(h,str)</code><br />
<code>checkran(ran,nm)</code><br />
<code>cv.RelRisk(X1,X2=NULL,h=NA,lambda.min=0.1,lambda.max=20,LHmin=TRUE,n.lambda=32)</code><br />
<code>cv.RelRisk.Bithell(X1,X2=NULL,h=NA,lambda.min=0.1,lambda.max=20,LHmin=TRUE,n.lambda=32)</code><br />
<code>edgeh(bwim,pres,tres,step,W,verbose=FALSE)</code><br />
<code>gethcats(h,breaks=NULL,step=0.05)</code><br />
<code>identical_windows(w1,w2)</code><br />
<code>KO(xy)</code><br />
<code>LSCV.density.spatial.single(h,pp,res,edge)</code><br />
<code>LSCV.risk.single(h,cases,controls,res,edge,hazey)</code><br />
<code>posifybivden(x,eps=.Machine$double.xmin)</code><br />
<code>processgamma(gamma.scale,pds)</code><br />
<code>processnstar(n,pp)</code><br />
<code>processscaler(s,pp)</code><br />
<code>point_image_by_bw(h,hc,points,weights,WM)</code><br />
<code>taperoff(x,zeropoint=0,onepoint=1,type=c("smooth", "cosine"))</code><br />
<code>tol.asy.ada(f,g,beta,verbose=FALSE)</code><br />
<code>tol.asy.fix(f,g,pooled,verbose=FALSE)</code><br />
<code>tol.mc.ada(rs,ITER,parallelise,verbose,...)</code><br />
<code>tol.mc.fix(rs,ITER,parallelise,verbose,...)</code><br />
</p>


<h3>Author(s)</h3>

<p>T.M. Davies</p>

<hr>
<h2 id='spattemp.density'>
Spatiotemporal kernel density estimation
</h2><span id='topic+spattemp.density'></span><span id='topic+stden'></span>

<h3>Description</h3>

<p>Provides a fixed-bandwidth kernel estimate of continuous spatiotemporal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spattemp.density(pp, h = NULL, tt = NULL, lambda = NULL,
  tlim = NULL, sedge = c("uniform", "none"), tedge = sedge, 
  sres = 128, tres = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spattemp.density_+3A_pp">pp</code></td>
<td>

<p>An object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> giving the spatial coordinates of the observations to be smoothed. Possibly marked with the time of each event; see argument <code>tt</code>.
</p>
</td></tr>
<tr><td><code id="spattemp.density_+3A_h">h</code></td>
<td>

<p>Fixed bandwidth to smooth the spatial margin. A numeric value &gt; 0. If unsupplied, the oversmoothing bandwidth is used as per <code><a href="#topic+OS">OS</a></code>.
</p>
</td></tr>
<tr><td><code id="spattemp.density_+3A_tt">tt</code></td>
<td>

<p>A numeric vector of equal length to the number of points in <code>pp</code>, giving the time corresponding to each spatial observation. If unsupplied, the function attempts to use the values in the <code><a href="spatstat.geom.html#topic+marks">marks</a></code> attribute of the <code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code> in <code>pp</code>.
</p>
</td></tr>
<tr><td><code id="spattemp.density_+3A_lambda">lambda</code></td>
<td>

<p>Fixed bandwidth to smooth the temporal margin; a numeric value &gt; 0. If unsupplied, the function internally computes the Sheather-Jones bandwith using <code><a href="stats.html#topic+bw.SJ">bw.SJ</a></code> (Sheather &amp; Jones, 1991).
</p>
</td></tr>
<tr><td><code id="spattemp.density_+3A_tlim">tlim</code></td>
<td>

<p>A numeric vector of length 2 giving the limits of the temporal domain over which to smooth. If supplied, all times in <code>tt</code> must fall within this interval (equality with limits allowed). If unsupplied, the function simply uses the range of the observed temporal values.  
</p>
</td></tr>
<tr><td><code id="spattemp.density_+3A_sedge">sedge</code></td>
<td>

<p>Character string dictating spatial edge correction. <code>"uniform"</code> (default) corrects based on evaluation grid coordinate. Setting <code>sedge="none"</code> requests no edge correction.  
</p>
</td></tr>
<tr><td><code id="spattemp.density_+3A_tedge">tedge</code></td>
<td>

<p>As <code>sedge</code>, for temporal edge correction.
</p>
</td></tr>
<tr><td><code id="spattemp.density_+3A_sres">sres</code></td>
<td>

<p>Numeric value &gt; 0. Resolution of the [<code>sres</code> <code class="reqn">\times</code> <code>sres</code>] evaluation grid in the spatial margin.
</p>
</td></tr>
<tr><td><code id="spattemp.density_+3A_tres">tres</code></td>
<td>

<p>Numeric value &gt; 0. Resolution of the evaluation points in the temporal margin as defined by the <code>tlim</code> interval. If unsupplied, the density is evaluated at integer values between <code>tlim[1]</code> and <code>tlim[2]</code>.
</p>
</td></tr>
<tr><td><code id="spattemp.density_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print a function progress bar to the console during evaluation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a fixed-bandwidth kernel estimate of a single spatiotemporal density, with isotropic smoothing in the spatial margin, as per Fernando &amp; Hazelton (2014). Estimates may be edge-corrected for an irregular spatial study window <em>and</em> for the bounds on the temporal margin as per <code>tlim</code>; this edge-correction is performed in precisely the same way as the <code>"uniform"</code> option in <code><a href="#topic+bivariate.density">bivariate.density</a></code>.
</p>
<p>Specifically, for <code class="reqn">n</code> trivariate points in space-time (<code>pp</code>, <code>tt</code>, <code>tlim</code>), we have
</p>
<p style="text-align: center;"><code class="reqn">\hat{f}(x,t)=n^{-1}\sum_{i=1}^{n}h^{-2}\lambda^{-1}K((x-x_i)/h)L((t-t_i)/\lambda)/(q(x)q(t)),</code>
</p>

<p>where <code class="reqn">x\in W\subset R^2</code> and <code class="reqn">t\in T\subset R</code>; <code class="reqn">K</code> and <code class="reqn">L</code> are the 2D and 1D Gaussian kernels controlled by fixed bandwidths <code class="reqn">h</code> (<code>h</code>) and <code class="reqn">\lambda</code> (<code>lambda</code>) respectively; and <code class="reqn">q(x)=\int_W h^{-2}K((u-x)/h)du</code> and <code class="reqn">q(t)=\int_T \lambda^{-1}L((w-t)/\lambda)dw</code> are optional edge-correction factors (<code>sedge</code> and <code>tedge</code>).
</p>
<p>The above equation provides the <em>joint</em> or <em>unconditional</em> density at a given space-time location <code class="reqn">(x,t)</code>. In addition to this, the function also yields the <em>conditional</em> density at each grid time, defined as
</p>
<p style="text-align: center;"><code class="reqn">\hat{f}(x|t)=\hat{f}(x,t)/\hat{f}(t),</code>
</p>

<p>where <code class="reqn">\hat{f}(t)=n^{-1}\sum_{i=1}^{n}\lambda^{-1}L((t-t_i)/\lambda)/q(t)</code> is the univariate kernel estimate of the temporal margin. Normalisation of the two versions <code class="reqn">\hat{f}(x,t)</code> and <code class="reqn">\hat{f}(x|t)</code> is the only way they differ. Where in the unconditional setting we have <code class="reqn">\int_W\int_T\hat{f}(x,t)dt dx=1</code>, in the conditional setting we have <code class="reqn">\int_W\hat{f}(x|t) dx=1</code> for all <code class="reqn">t</code>. See Fernando &amp; Hazelton (2014) for further details and practical reasons as to why we might prefer one over the other in certain situations.
</p>
<p>The objects returned by this function (see &lsquo;Value&rsquo; below) are necessary for kernel estimation of spatiotemporal relative risk surfaces, which is performed by <code><a href="#topic+spattemp.risk">spattemp.risk</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"stden"</code>. This is effectively a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>z</code></td>
<td>

<p>A named (by time-point) list of pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>ages corresponding to the joint spatiotemporal density over space at each discretised time.
</p>
</td></tr>
<tr><td><code>z.cond</code></td>
<td>

<p>A named (by time-point) list of pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>ages corresponding to the conditional spatial density given each discretised time.
</p>
</td></tr>
<tr><td><code>h</code></td>
<td>

<p>The scalar bandwidth used for spatial smoothing.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The scalar bandwidth used for temporal smoothing.
</p>
</td></tr>
<tr><td><code>tlim</code></td>
<td>

<p>A numeric vector of length two giving the temporal bound of the density estimate.
</p>
</td></tr>
<tr><td><code>spatial.z</code></td>
<td>

<p>A pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age giving the overall spatial margin as a single 2D density estimate (i.e. ignoring time).
</p>
</td></tr>
<tr><td><code>temporal.z</code></td>
<td>

<p>An object of class <code><a href="stats.html#topic+density">density</a></code> giving the overall temporal margin as a single 1D density estimate (i.e. ignoring space).
</p>
</td></tr>
<tr><td><code>qs</code></td>
<td>

<p>A pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age giving the edge-correction surface for the spatial margin. <code>NULL</code> if <code>sedge = "none"</code>.
</p>
</td></tr>
<tr><td><code>qt</code></td>
<td>

<p>A numeric vector giving the edge-correction weights for the temporal margin. <code>NULL</code> if <code>tedge = "none"</code>.
</p>
</td></tr>
<tr><td><code>pp</code></td>
<td>

<p>A <code><a href="spatstat.geom.html#topic+ppp">ppp.object</a></code> of the spatial data passed to the argument of the same name in the initial function call, with <code><a href="spatstat.geom.html#topic+marks">marks</a></code> of the observation times.
</p>
</td></tr>
<tr><td><code>tgrid</code></td>
<td>

<p>A numeric vector giving the discretised time grid at which the spatiotemporal density was evaluated (matches the names of <code>z</code> and <code>z.cond</code>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>References</h3>

<p>Duong, T. (2007), ks: Kernel Density Estimation and Kernel Discriminant Analysis for Multivariate Data in R, <em>Journal of Statistical Software</em>, <b>21</b>(7), 1-16.<br /><br />
Fernando, W.T.P.S. and Hazelton, M.L. (2014), Generalizing the spatial relative risk function, <em>Spatial and Spatio-temporal Epidemiology</em>, <b>8</b>, 1-10.<br /><br />
Kelsall, J.E. and Diggle, P.J. (1995), Kernel estimation of relative risk, <em>Bernoulli</em>, <b>1</b>, 3-16.<br /><br />
Sheather, S. J. and Jones, M. C. (1991), A reliable data-based bandwidth selection method for kernel density estimation. Journal of the Royal Statistical Society Series B, <b>53</b>, 683-690.<br /><br />
Silverman, B.W. (1986), <em>Density Estimation for Statistics and Data Analysis</em>, Chapman &amp; Hall, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bivariate.density">bivariate.density</a></code>, <code><a href="#topic+spattemp.risk">spattemp.risk</a></code>, <code><a href="#topic+spattemp.slice">spattemp.slice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(burk)
burkcas &lt;- burk$cases

burkden1 &lt;- spattemp.density(burkcas,tres=128)
summary(burkden1)


hlam &lt;- LIK.spattemp(burkcas,tlim=c(400,5900),verbose=FALSE)
burkden2 &lt;- spattemp.density(burkcas,h=hlam[1],lambda=hlam[2],tlim=c(400,5900),tres=256)
tims &lt;- c(1000,2000,3500)
par(mfcol=c(2,3))
for(i in tims){ 
  plot(burkden2,i,override.par=FALSE,fix.range=TRUE,main=paste("joint",i))
  plot(burkden2,i,"conditional",override.par=FALSE,main=paste("cond.",i))
}

</code></pre>

<hr>
<h2 id='spattemp.risk'>
Spatiotemporal relative risk/density ratio
</h2><span id='topic+spattemp.risk'></span><span id='topic+rrst'></span>

<h3>Description</h3>

<p>Produces a spatiotemporal relative risk surface based on the ratio of two kernel estimates of spatiotemporal densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spattemp.risk(f, g, log = TRUE, tolerate = FALSE, finiteness = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spattemp.risk_+3A_f">f</code></td>
<td>

<p>An object of class <code><a href="#topic+stden">stden</a></code> representing the &lsquo;case&rsquo; (numerator) density estimate.
</p>
</td></tr>
<tr><td><code id="spattemp.risk_+3A_g">g</code></td>
<td>

<p>Either an object of class <code><a href="#topic+stden">stden</a></code>, or an object of class <code><a href="#topic+bivden">bivden</a></code> for the &lsquo;control&rsquo; (denominator) density estimate. This object <b>must</b> match the spatial (and temporal, if <code><a href="#topic+stden">stden</a></code>) domain of <code>f</code> completely; see &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="spattemp.risk_+3A_log">log</code></td>
<td>

<p>Logical value indicating whether to return the log relative risk (default) or the raw ratio.
</p>
</td></tr>
<tr><td><code id="spattemp.risk_+3A_tolerate">tolerate</code></td>
<td>

<p>Logical value indicating whether to compute and return asymptotic <code class="reqn">p</code>-value surfaces for elevated risk; see &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="spattemp.risk_+3A_finiteness">finiteness</code></td>
<td>

<p>Logical value indicating whether to internally correct infinite risk (on the log-scale) to the nearest finite value to avoid numerical problems. A small extra computational cost is required.
</p>
</td></tr>
<tr><td><code id="spattemp.risk_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print function progress during execution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fernando &amp; Hazelton (2014) generalise the spatial relative risk function (e.g. Kelsall &amp; Diggle, 1995) to the spatiotemporal domain. This is the implementation of their work, yielding the generalised log-relative risk function for <code class="reqn">x\in W\subset R^2</code> and <code class="reqn">t\in T\subset R</code>. It produces
</p>
<p style="text-align: center;"><code class="reqn">\hat{\rho}(x,t)=\log(\hat{f}(x,t))-\log(\hat{g}(x,t)),</code>
</p>

<p>where <code class="reqn">\hat{f}(x,t)</code> is a fixed-bandwidth kernel estimate of the spatiotemporal density of the cases (argument <code>f</code>) and <code class="reqn">\hat{g}(x,t)</code> is the same for the controls (argument <code>g</code>).
</p>

<ul>
<li><p> When argument <code>g</code> is an object of class <code><a href="#topic+stden">stden</a></code> arising from a call to <code><a href="#topic+spattemp.density">spattemp.density</a></code>, the resolution, spatial domain, and temporal domain of this spatiotemporal estimate must match that of <code>f</code> exactly, else an error will be thrown.
</p>
</li>
<li><p> When argument <code>g</code> is an object of class <code><a href="#topic+bivden">bivden</a></code> arising from a call to <code><a href="#topic+bivariate.density">bivariate.density</a></code>, it is assumed the &lsquo;at-risk&rsquo; control density is static over time. In this instance, the above equation for the relative risk becomes <code class="reqn">\hat{\rho}=\log(\hat{f}(x,t))+\log|T|-\log(g(x))</code>. The spatial density estimate in <code>g</code> must match the spatial domain of <code>f</code> exactly, else an error will be thrown.
</p>
</li>
<li><p> The estimate <code class="reqn">\hat{\rho}(x,t)</code> represents the joint or unconditional spatiotemporal relative risk over <code class="reqn">W\times T</code>. This means that the raw relative risk <code class="reqn">\hat{r}(x,t)=\exp{\hat{\rho}(x,t)}</code> integrates to 1 with respect to the control density over space and time: <code class="reqn">\int_W \int_T r(x,t)g(x,t) dt dx = 1</code>. This function also computes the <b>conditional</b> spatiotemporal relative risk at each time point, namely
</p>
<p style="text-align: center;"><code class="reqn">\hat{\rho}(x|t)=\log{\hat{f}(x|t)}-\log{\hat{g}(x|t)},</code>
</p>

<p>where <code class="reqn">\hat{f}(x|t)</code> and <code class="reqn">\hat{g}(x|t)</code> are the conditional densities over space of the cases and controls given a specific time point <code class="reqn">t</code> (see the documentation for <code><a href="#topic+spattemp.density">spattemp.density</a></code>). In terms of normalisation, we therefore have <code class="reqn">\int_W r(x|t)g(x|t) dx = 1</code>. In the case where <code class="reqn">\hat{g}</code> is static over time, one may simply replace <code class="reqn">\hat{g}(x|t)</code> with <code class="reqn">\hat{g}(x)</code> in the above.
</p>
</li>
<li><p> Based on the asymptotic properties of the estimator, Fernando &amp; Hazelton (2014) also define the calculation of tolerance contours for detecting statistically significant fluctuations in such spatiotemporal log-relative risk surfaces. This function can produce the required <code class="reqn">p</code>-value surfaces by setting <code>tolerate = TRUE</code>; and if so, results are returned for both the unconditional (x,t) and conditional (x|t) surfaces. See the examples in the documentation for <code><a href="#topic+plot.rrst">plot.rrst</a></code> for details on how one may superimpose contours at specific <code class="reqn">p</code>-values for given evaluation times <code class="reqn">t</code> on a plot of relative risk on the spatial margin. 
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &ldquo;<code>rrst</code>&rdquo;. This is effectively a list with the following members:
</p>
<table role = "presentation">
<tr><td><code>rr</code></td>
<td>

<p>A named (by time-point) list of pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>ages corresponding to the joint spatiotemporal relative risk over space at each discretised time.
</p>
</td></tr>
<tr><td><code>rr.cond</code></td>
<td>

<p>A named list of pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>ages corresponding to the conditional spatial relative risk given each discretised time.
</p>
</td></tr>
<tr><td><code>P</code></td>
<td>

<p>A named list of pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>ages of the <code class="reqn">p</code>-value surfaces testing for elevated risk for the joint estimate. If <code>tolerate = FALSE</code>, this will be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>P.cond</code></td>
<td>

<p>As above, for the conditional relative risk surfaces.
</p>
</td></tr>
<tr><td><code>f</code></td>
<td>

<p>A copy of the object <code>f</code> used in the initial call.
</p>
</td></tr>
<tr><td><code>g</code></td>
<td>

<p>As above, for <code>g</code>.
</p>
</td></tr>
<tr><td><code>tlim</code></td>
<td>

<p>A numeric vector of length two giving the temporal bound of the density estimate.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>References</h3>

<p>Fernando, W.T.P.S. and Hazelton, M.L. (2014), Generalizing the spatial relative risk function, <em>Spatial and Spatio-temporal Epidemiology</em>, <b>8</b>, 1-10.<br /><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spattemp.density">spattemp.density</a></code>, <code><a href="#topic+spattemp.slice">spattemp.slice</a></code>, <code><a href="#topic+bivariate.density">bivariate.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fmd)
fmdcas &lt;- fmd$cases
fmdcon &lt;- fmd$controls

f &lt;- spattemp.density(fmdcas,h=6,lambda=8) # stden object as time-varying case density
g &lt;- bivariate.density(fmdcon,h0=6) # bivden object as time-static control density
rho &lt;- spattemp.risk(f,g,tolerate=TRUE) 
print(rho)

oldpar &lt;- par(mfrow=c(2,3))
plot(rho$f$spatial.z,main="Spatial margin (cases)") # spatial margin of cases
plot(rho$f$temporal.z,main="Temporal margin (cases)") # temporal margin of cases
plot(rho$g$z,main="Spatial margin (controls)") # spatial margin of controls
plot(rho,tselect=50,type="conditional",tol.args=list(levels=c(0.05,0.0001),
     lty=2:1,lwd=1:2),override.par=FALSE)
plot(rho,tselect=100,type="conditional",tol.args=list(levels=c(0.05,0.0001),
     lty=2:1,lwd=1:2),override.par=FALSE)
plot(rho,tselect=200,type="conditional",tol.args=list(levels=c(0.05,0.0001),
     lty=2:1,lwd=1:2),override.par=FALSE)
par(oldpar)

</code></pre>

<hr>
<h2 id='spattemp.slice'>Slicing a spatiotemporal object</h2><span id='topic+spattemp.slice'></span>

<h3>Description</h3>

<p>Takes slices of the spatiotemporal kernel density or 
relative risk function estimate at desired times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spattemp.slice(stob, tt, checkargs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spattemp.slice_+3A_stob">stob</code></td>
<td>
<p>An object of class <code><a href="#topic+stden">stden</a></code> or <code><a href="#topic+rrst">rrst</a></code> giving the spatiotemporal
estimate from which to take slices.</p>
</td></tr>
<tr><td><code id="spattemp.slice_+3A_tt">tt</code></td>
<td>
<p>Desired time(s); the density/risk surface estimate
corresponding to which will be returned. This value <b>must</b> be in the
available range provided by <code>stob$tlim</code>; see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="spattemp.slice_+3A_checkargs">checkargs</code></td>
<td>
<p>Logical value indicating whether to check validity of
<code>stob</code> and <code>tt</code>. Disable only if you know this check will be
unnecessary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contents of the <code>stob</code> argument are returned based on a discretised set of times.
This function internally computes the desired surfaces as
pixel-by-pixel linear interpolations using the two discretised times
that bound each requested <code>tt</code>.
</p>
<p>The function returns an error if any of the
requested slices at <code>tt</code> are not within the available range of
times as given by the <code>tlim</code>
component of <code>stob</code>.
</p>


<h3>Value</h3>

<p>A list of lists of pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>ages, each of which corresponds to
the requested times in <code>tt</code>, and are named as such.<br />
If <code>stob</code> is an object of class <code><a href="#topic+stden">stden</a></code>:
</p>
<table role = "presentation">
<tr><td><code>z</code></td>
<td>

<p>Pixel images of the joint spatiotemporal density corresponding to <code>tt</code>.
</p>
</td></tr>
<tr><td><code>z.cond</code></td>
<td>

<p>Pixel images of the conditional spatiotemporal density given each time in <code>tt</code>.
</p>
</td></tr>
</table>
<p>If <code>stob</code> is an object of class <code><a href="#topic+rrst">rrst</a></code>:
</p>
<table role = "presentation">
<tr><td><code>rr</code></td>
<td>

<p>Pixel images of the joint spatiotemporal relative risk corresponding to <code>tt</code>.
</p>
</td></tr>
<tr><td><code>rr.cond</code></td>
<td>

<p>Pixel images of the conditional spatiotemporal relative risk given each time in <code>tt</code>.
</p>
</td></tr>
<tr><td><code>P</code></td>
<td>

<p>Only present if <code>tolerate = TRUE</code> in the preceding call to <code><a href="#topic+spattemp.risk">spattemp.risk</a></code>.
Pixel images of the <code class="reqn">p</code>-value surfaces for the joint spatiotemporal relative risk.
</p>
</td></tr>
<tr><td><code>P.cond</code></td>
<td>

<p>Only present if <code>tolerate = TRUE</code> in the preceding call to <code><a href="#topic+spattemp.risk">spattemp.risk</a></code>.
Pixel images of the <code class="reqn">p</code>-value surfaces for the conditional spatiotemporal relative risk.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>


<h3>References</h3>

<p>Fernando, W.T.P.S. and Hazelton, M.L. (2014), Generalizing the spatial relative risk function, <em>Spatial and Spatio-temporal Epidemiology</em>, <b>8</b>, 1-10.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spattemp.density">spattemp.density</a></code>, <code><a href="#topic+spattemp.risk">spattemp.risk</a></code>, <code><a href="#topic+bivariate.density">bivariate.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(fmd)
fmdcas &lt;- fmd$cases
fmdcon &lt;- fmd$controls

f &lt;- spattemp.density(fmdcas,h=6,lambda=8)
g &lt;- bivariate.density(fmdcon,h0=6)
rho &lt;- spattemp.risk(f,g,tolerate=TRUE) 

f$tlim # requested slices must be in this range

# slicing 'stden' object
f.slice1 &lt;- spattemp.slice(f,tt=50) # evaluation timestamp
f.slice2 &lt;- spattemp.slice(f,tt=150.5) # interpolated timestamp
oldpar &lt;- par(mfrow=c(2,2))
plot(f.slice1$z$'50')
plot(f.slice1$z.cond$'50')
plot(f.slice2$z$'150.5')
plot(f.slice2$z.cond$'150.5')
par(oldpar)

# slicing 'rrst' object
rho.slices &lt;- spattemp.slice(rho,tt=c(50,150.5))
oldpar &lt;- par(mfrow=c(2,2))
plot(rho.slices$rr$'50');tol.contour(rho.slices$P$'50',levels=0.05,add=TRUE)
plot(rho.slices$rr$'150.5');tol.contour(rho.slices$P$'150.5',levels=0.05,add=TRUE)
plot(rho.slices$rr.cond$'50');tol.contour(rho.slices$P.cond$'50',levels=0.05,add=TRUE)
plot(rho.slices$rr.cond$'150.5');tol.contour(rho.slices$P.cond$'150.5',levels=0.05,add=TRUE)
par(oldpar)


</code></pre>

<hr>
<h2 id='summary.bivden'>Summarising sparr objects</h2><span id='topic+summary.bivden'></span><span id='topic+summary.rrs'></span><span id='topic+summary.msden'></span><span id='topic+summary.stden'></span><span id='topic+summary.rrst'></span>

<h3>Description</h3>

<p><code>summary</code> methods for classes <code><a href="#topic+bivden">bivden</a></code>, <code><a href="#topic+stden">stden</a></code>,
<code><a href="#topic+rrs">rrs</a></code>, <code><a href="#topic+rrst">rrst</a></code> and <code><a href="#topic+msden">msden</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bivden'
summary(object, ...)

## S3 method for class 'msden'
summary(object, ...)

## S3 method for class 'rrs'
summary(object, ...)

## S3 method for class 'rrst'
summary(object, ...)

## S3 method for class 'stden'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bivden_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+bivden">bivden</a></code>, <code><a href="#topic+stden">stden</a></code>,
<code><a href="#topic+rrs">rrs</a></code>, <code><a href="#topic+rrst">rrst</a></code>, or <code><a href="#topic+msden">msden</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bivden_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>T.M. Davies
</p>

<hr>
<h2 id='tol.classify'>Classification by <em>p</em>-value surfaces</h2><span id='topic+tol.classify'></span>

<h3>Description</h3>

<p>Classifies observed case/control points according to an estimated 
<em>p</em>-value surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tol.classify(rs, cutoff = 0.05, pim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tol.classify_+3A_rs">rs</code></td>
<td>
<p>An object of class <code><a href="#topic+rrs">rrs</a></code> giving the estimated relative
risk function of the case-control points to be classified.</p>
</td></tr>
<tr><td><code id="tol.classify_+3A_cutoff">cutoff</code></td>
<td>
<p>A numeric value between 0 and 1, defining the cutoff p-value
used to classify points; defaults to 0.05.</p>
</td></tr>
<tr><td><code id="tol.classify_+3A_pim">pim</code></td>
<td>
<p>A pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age defining the p-value 
surface with respect to which the observations are to be classified. 
Typically the result of a call to <code><a href="#topic+tolerance">tolerance</a></code>. Ignored if 
<code>rs</code> possesses a non-<code>NULL</code> <code>P</code> component (which takes
precedence).</p>
</td></tr>
<tr><td><code id="tol.classify_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+tolerance">tolerance</a></code> in order to
compute the desired p-value surface in the event neither <code>rs$P</code> nor
<code>pim</code> exist. Ignored otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes in a relative risk surface computed with
<code><a href="#topic+risk">risk</a></code> and corresponding p-value surface (the latter used for
drawing tolerance contours), and attempts to classify both the case and 
control points as either falling within or without contours drawn at a level
of <code>cutoff</code>. Points that fall 'inside' the contours are deemed to be
associated with p-values less than or equal to <code>cutoff</code> and hence are
usually interpreted as being in spatial areas of significant risk. This is
useful for identifying characteristics of points that fall inside
'pockets of significance' as delineated by tolerance contours.
</p>
<p>Upon execution, the function first inspects the <code>rs</code> object to
determine whether it possesses a <code>P</code> component (i.e. an internally
computed p-value surface provided when <code><a href="#topic+risk">risk</a></code> is called with 
optional argument <code>tolerate=TRUE</code>). If it exists, this is used. If not,
the function then looks to see if the <code>pim</code> argument has been supplied.
If it has, it must be a pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age compatible
with the risk surface in <code>rs$rr</code>. If neither <code>rs$P</code> nor <code>pim</code>
is present, the function internally calls <code><a href="#topic+tolerance">tolerance</a></code> with 
arguments supplied to <code>...</code> to produce the desired surface.
</p>
<p>The return object is a list that splits each of the case and control <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>
data objects (these are stored as <code>rs$f$pp</code> and <code>rs$g$pp</code>) in the
originally supplied risk surface object) into two constituent <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>
objects &ndash; one comprising the points inside the <code>cutoff</code> contours (<code>fin</code> and <code>gin</code>), the 
other for those points outside the <code>cutoff</code> contours (<code>fout</code> and <code>gout</code>).
In addition, the index values of the original data objects <code>rs$f$pp</code> and 
<code>rs$g$pp</code> that correspond to the points in <code>fin</code> and <code>gin</code> are
provided as numeric vectors (<code>findex</code> and <code>gindex</code>). These objects
are useful if you need to cross-reference data-specific characteristics from 
some other (corresponding) data set.
</p>
<p>Further supplied in the returned list are quantities describing the overall classification
structure (<code>pcmask</code>), as well as contour-specific identification and classification
(<code>finsplit</code>, <code>ginsplit</code>, <code>pcpolys</code>). The <code>pcpolys</code> object can be plotted
to illustrate the unique contour IDs with <code><a href="#topic+tol.classplot">tol.classplot</a></code>.
</p>


<h3>Value</h3>

<p>A list of ten components:
</p>
<table role = "presentation">
<tr><td><code>fin</code></td>
<td>
<p>Point pattern of 'case' observations classified as being inside
the <code>cutoff</code> contours of the p-value surface. An object of class
<code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>.</p>
</td></tr>
<tr><td><code>fout</code></td>
<td>
<p>Point pattern of 'case' observations falling outside the
<code>cutoff</code> contours of the p-value surface. An object of class
<code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>.</p>
</td></tr>
<tr><td><code>gin</code></td>
<td>
<p>As <code>fin</code>, for the control points.</p>
</td></tr>
<tr><td><code>gout</code></td>
<td>
<p>As <code>fout</code>, for the control points.</p>
</td></tr>
<tr><td><code>findex</code></td>
<td>
<p>Numeric vector giving the raw index values of the original 
pattern of cases which provide <code>fin</code>.</p>
</td></tr>
<tr><td><code>gindex</code></td>
<td>
<p>As <code>findex</code>, for the controls.</p>
</td></tr>
<tr><td><code>finsplit</code></td>
<td>
<p>A list of the indexes in <code>findex</code>, with separate members
splitting up the indexes of case observations as falling inside each unique
tolerance contour.</p>
</td></tr>
<tr><td><code>ginsplit</code></td>
<td>
<p>As <code>ginsplit</code>, for the controls.</p>
</td></tr>
<tr><td><code>pcmask</code></td>
<td>
<p>The classification object of class <code><a href="spatstat.geom.html#topic+owin">owin</a></code>. This is
a pixel image mask derived from <code>pim</code> and <code>cutoff</code>.</p>
</td></tr>
<tr><td><code>pcpolys</code></td>
<td>
<p>A list of the same length as <code>finsplit</code> and <code>ginsplit</code>, 
identifying each unique contour as a polygonal <code><a href="spatstat.geom.html#topic+owin">owin</a></code>. The order of these
objects in the list correspond to the membership of <code>finsplit</code> and <code>ginsplit</code>. Use
<code><a href="#topic+tol.classplot">tol.classplot</a></code> on this component to plot the classification indexes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>T. M. Davies
</p>


<h3>References</h3>

<p>Davies, T.M. and Hazelton, M.L. (2010), Adaptive kernel estimation of spatial relative
risk, <em>Statistics in Medicine</em>, <b>29</b>(23) 2423-2437.
</p>
<p>Hazelton, M.L. and Davies, T.M. (2009), Inference based on kernel estimates
of the relative risk function in geographical epidemiology,
<em>Biometrical Journal</em>, <b>51</b>(1), 98-109.
</p>
<p>Kelsall, J.E. and Diggle, P.J. (1995), Kernel estimation of relative risk, <em>Bernoulli</em>,
<b>1</b>, 3-16.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc)
pbccas &lt;- split(pbc)$case
pbccon &lt;- split(pbc)$control
h0 &lt;- OS(pbc,nstar="geometric")

pbcrr &lt;- risk(pbccas,pbccon,h0=h0,tolerate=TRUE)
pbcclass &lt;- tol.classify(pbcrr)

## Not run: 
plot(pbcrr)
points(pbcclass$fin,col="red",pch=3,cex=0.5)
points(pbcclass$fout,col="seagreen4",cex=0.5)

chrr &lt;- risk(chorley,h0=0.7,tolerate=TRUE)
chclass &lt;- tol.classify(chrr,cutoff=0.4)
plot(chrr,tol.args=list(levels=0.4))
for(i in 1:length(chclass$finsplit)){
   points(chrr$f$pp[chclass$finsplit[[i]]],col=i,pch=19)
}

## End(Not run)





</code></pre>

<hr>
<h2 id='tol.classplot'>Plot tolerance contour classification scheme</h2><span id='topic+tol.classplot'></span>

<h3>Description</h3>

<p>Permits illustration of the uniquely identified tolerance contour regions
arising from a call to <code><a href="#topic+tol.classify">tol.classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tol.classplot(pcpolys, add = FALSE, annotate = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tol.classplot_+3A_pcpolys">pcpolys</code></td>
<td>
<p>A list of polygonal windows, each of class <code><a href="spatstat.geom.html#topic+owin">owin</a></code>.
This will almost always be the <code>pcpolys</code> component of the object
returned by a call to <code><a href="#topic+tol.classify">tol.classify</a></code>.</p>
</td></tr>
<tr><td><code id="tol.classplot_+3A_add">add</code></td>
<td>
<p>A logical value indicating whether to add the unique regions to an
existing plot (see 'Examples').</p>
</td></tr>
<tr><td><code id="tol.classplot_+3A_annotate">annotate</code></td>
<td>
<p>A logical value indicating whether to annotate each unique
region with its identifying number (which will correspond to the uniquely 
split/classified points in a corresponding call to <code><a href="#topic+tol.classify">tol.classify</a></code>).</p>
</td></tr>
<tr><td><code id="tol.classplot_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="graphics.html#topic+text">text</a></code> 
to control the appearance of the annotations when <code>annotate=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+tol.classify">tol.classify</a></code> function permits identification of 
individual significance regions (that is, the tolerance contours). In
turn, <code>tol.classplot</code> may be used to visualise these regions
optionally annotated by their unique identification number to better
understand the region-specific classifications of the case and control points.
</p>


<h3>Value</h3>

<p>Plots to the relevant graphics device.
</p>


<h3>Author(s)</h3>

<p>T. M. Davies
</p>


<h3>References</h3>

<p>Davies, T.M. and Hazelton, M.L. (2010), Adaptive kernel estimation of spatial relative
risk, <em>Statistics in Medicine</em>, <b>29</b>(23) 2423-2437.
</p>
<p>Hazelton, M.L. and Davies, T.M. (2009), Inference based on kernel estimates
of the relative risk function in geographical epidemiology,
<em>Biometrical Journal</em>, <b>51</b>(1), 98-109.
</p>
<p>Kelsall, J.E. and Diggle, P.J. (1995), Kernel estimation of relative risk, <em>Bernoulli</em>,
<b>1</b>, 3-16.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
chrr &lt;- risk(chorley,h0=0.7,tolerate=TRUE)
chclass &lt;- tol.classify(chrr,cutoff=0.4)

oldpar &lt;- par(mfrow=c(1,3))
#
plot(chrr,tol.args=list(levels=0.4))
tol.classplot(chclass$pcpolys)
plot(Window(chorley))
axis(1)
axis(2)
box(bty="l")
tol.classplot(chclass$pcpolys,add=TRUE,col=2,font=2,cex=1.5)
#
par(oldpar)


## End(Not run)





</code></pre>

<hr>
<h2 id='tol.contour'>Plot tolerance contours</h2><span id='topic+tol.contour'></span>

<h3>Description</h3>

<p>Draw contours based on a <em>p</em>-value matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tol.contour(pim, test = c("upper", "lower", "two-sided"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tol.contour_+3A_pim">pim</code></td>
<td>
<p>A pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age of <em>p</em>-values,
typically obtained from a call to <code><a href="#topic+tolerance">tolerance</a></code>, computed with
respect to a test for elevated risk.</p>
</td></tr>
<tr><td><code id="tol.contour_+3A_test">test</code></td>
<td>
<p>An optional character string giving the type of manipulation to
be applied to the <em>p</em>-values, corresponding to a test for significantly
elevated risk (<code>"upper"</code>; default); for reduced risk (<code>"lower"</code>);
or for both (<code>"two-sided"</code>).</p>
</td></tr>
<tr><td><code id="tol.contour_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="graphics.html#topic+contour">contour</a></code>.
Commonly used options include <code>add</code> (to superimpose the contours upon
an existing plot); <code>levels</code> (to control the specific significance
levels at which to delineate the <em>p</em>-values); and <code>lty</code> or
<code>lwd</code> for aesthetics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that no checks on the numeric content of <code>pim</code> are made. The
function assumes the pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age of <em>p</em>-values
in <code>pim</code> is supplied with respect to an upper-tailed test for elevated
risk (this is exactly the way the <em>p</em>-value surface is returned when
<code><a href="#topic+tolerance">tolerance</a></code> is used). This is important if one makes subsequent
use of <code>test</code>, which manipulates the <em>p</em>-values to draw at desired
significance <code>levels</code>.
</p>


<h3>Value</h3>

<p>Opens a new graphics device and displays a <code><a href="graphics.html#topic+contour">contour</a></code>
plot if <code>add = FALSE</code>, otherwise adds the contours to the plot in the
existing active graphics device.
</p>


<h3>Author(s)</h3>

<p>T. M. Davies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See ?tolerance

</code></pre>

<hr>
<h2 id='tolerance'>Tolerance by <em>p</em>-value surfaces</h2><span id='topic+tolerance'></span>

<h3>Description</h3>

<p>Calculates a <em>p</em>-value surface based on asymptotic theory or
Monte-Carlo (MC) permutations describing the extremity of risk given a fixed
or adaptive kernel-smoothed density-ratio, allowing the drawing of
<em>tolerance contours</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tolerance(
  rs,
  method = c("ASY", "MC"),
  ref.density = NULL,
  beta = 0.025,
  ITER = 100,
  parallelise = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tolerance_+3A_rs">rs</code></td>
<td>
<p>An object of class <code><a href="#topic+rrs">rrs</a></code> giving the estimated relative
risk function for which to calculate the <em>p</em>-value surface.</p>
</td></tr>
<tr><td><code id="tolerance_+3A_method">method</code></td>
<td>
<p>A character string specifying the method of calculation.
<code>"ASY"</code> (default) instructs the function to compute the <em>p</em>-values
using asymptotic theory. <code>"MC"</code> computes the values by random
permutations of the data. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="tolerance_+3A_ref.density">ref.density</code></td>
<td>
<p>Required if <code>rs</code> is based on fixed-bandwidth
estimates of the case and control densities and <code>method = "ASY"</code>.
Either a pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age or an object of class
<code><a href="#topic+bivden">bivden</a></code> giving the reference density to use in asymptotic
formulae. May be unnormalised. Ignored if <code>rs</code> is based on adaptive
kernel estimates or if <code>method = "MC"</code>.</p>
</td></tr>
<tr><td><code id="tolerance_+3A_beta">beta</code></td>
<td>
<p>A numeric value <code class="reqn">0 &lt;</code> <code>beta</code> <code class="reqn">&lt; 1</code> giving the
fineness of the adaptive bandwidth partitioning to use for calculation of
the required quantities for asymptotic adaptive <em>p</em>-value surfaces.
Smaller values provide more accurate bandwidth bins at the cost of
additional computing time, see Davies and Baddeley (2018); the default is
sensible in most cases. Ignored if <code>rs</code> is based on fixed-bandwidth
kernel estimates.</p>
</td></tr>
<tr><td><code id="tolerance_+3A_iter">ITER</code></td>
<td>
<p>Number of iterations for the Monte-Carlo permutations. Ignored
if <code>method = "ASY"</code>.</p>
</td></tr>
<tr><td><code id="tolerance_+3A_parallelise">parallelise</code></td>
<td>
<p>Numeric argument to invoke parallel processing, giving
the number of CPU cores to use when <code>method = "MC"</code>. Experimental. Test
your system first using <code>parallel::detectCores()</code> to identify the
number of cores available to you.</p>
</td></tr>
<tr><td><code id="tolerance_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether to print function progress
during execution.</p>
</td></tr>
<tr><td><code id="tolerance_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+risk">risk</a></code> when
<code>method = "MC"</code>. While most information needed for the MC repetitions
is implicitly gleaned from the object passed to <code>rs</code>, this ellipsis is
typically used to set the appropriate <code>epsilon</code> and
<code>pilot.symmetry</code> values for the internal calls to <code><a href="#topic+risk">risk</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements developments in Hazelton and Davies (2009) (fixed)
and Davies and Hazelton (2010) (adaptive) to compute pointwise
<em>p</em>-value surfaces based on asymptotic theory of kernel-smoothed
relative risk surfaces. Alternatively, the user may elect to calculate the
<em>p</em>-value surfaces using Monte-Carlo methods (see Kelsall and Diggle,
1995). Superimposition upon a plot of the risk surface contours of these
<em>p</em>-values at given significance levels (i.e. &ldquo;tolerance contours&rdquo;)
can be an informative way of exploring the statistical significance of the
extremity of risk across the defined study region.
</p>
<p>Implementation of the Monte-Carlo method simply involves random allocation of case/control marks and
re-estimation of the risk surface <code>ITER</code> times, against which the
original estimate is compared.  While not dependent on asymptotic theory, it is
computationally expensive, and it has been suggested that it might have some
undesirable practical consequences in certain settings (Hazelton and Davies,
2009). When performing the MC simulations, the same global (and pilot, if
necessary) bandwidths and edge-correction regimens are employed as were used
in the initial density estimates of the observed data. With regard to
arguments to be passed to internal calls of <code><a href="#topic+risk">risk</a></code>, the user
should take care to use <code>...</code> to set the <code>epsilon</code> value to match
that which was used in creation of the object passed to <code>rs</code> (if this
was set to a non-default value). Furthermore, if performing MC simulations
for the adaptive relative risk function, the function borrows the value of
the <code>beta</code> argument to speed things up via partitioning, and the user
should additionally access <code>...</code> to set the same <code>pilot.symmetry</code>
value as was used for creation of the object passed to <code>rs</code>, in the
same way as for any non-default use of <code>epsilon</code>. This will ensure the
simulations are all performed under the same conditions as were used to estimate the original risk
function.
</p>


<h3>Value</h3>

<p>A pixel <code><a href="spatstat.geom.html#topic+im">im</a></code>age of the estimated
<em>p</em>-value surface.
</p>


<h3>Note</h3>

<p>The returned <em>p</em>-values are geared so that &ldquo;smallness&rdquo;
corresponds to statistical significance of elevated risk, that is, an
upper-tailed test. The complement of the <em>p</em>-values will yeild
significance of reduced risk; a lower-tailed test. When using
<code><a href="#topic+tol.contour">tol.contour</a></code>, the user can control what type of contours to
display.
</p>


<h3>Author(s)</h3>

<p>T. M. Davies
</p>


<h3>References</h3>

<p>Davies, T.M. and Baddeley A. (2018), Fast computation of
spatially adaptive kernel estimates, <em>Statistics and Computing</em>, <b>28</b>(4), 937-956.
</p>
<p>Davies, T.M. and Hazelton, M.L. (2010), Adaptive kernel estimation of spatial relative
risk, <em>Statistics in Medicine</em>, <b>29</b>(23) 2423-2437.
</p>
<p>Davies, T.M., Jones, K. and Hazelton, M.L. (2016), Symmetric adaptive smoothing regimens for estimation of the spatial
relative risk function, <em>Computational Statistics &amp; Data Analysis</em>,
<b>101</b>, 12-28.
</p>
<p>Hazelton, M.L. and Davies, T.M. (2009), Inference based on kernel estimates
of the relative risk function in geographical epidemiology,
<em>Biometrical Journal</em>, <b>51</b>(1), 98-109.
</p>
<p>Kelsall, J.E. and Diggle, P.J. (1995), Kernel estimation of relative risk, <em>Bernoulli</em>,
<b>1</b>, 3-16.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


data(pbc)
h0 &lt;- LSCV.risk(pbc,method="hazelton");h0
pbccas &lt;- split(pbc)[[1]]
pbccon &lt;- split(pbc)[[2]]

# ASY
riskfix &lt;- risk(pbc,h0=h0)
fixtol1 &lt;- tolerance(riskfix,ref.density=density(pbc,OS(pbc)))

riskada &lt;- risk(pbc,h0=h0,adapt=TRUE,hp=NS(pbc),pilot.symmetry="pooled",davies.baddeley=0.025)
adatol1 &lt;- tolerance(riskada)

oldpar &lt;- par(mfrow=c(1,2))
plot(riskfix)
tol.contour(fixtol1,levels=c(0.1,0.05,0.01),lty=3:1,add=TRUE)
plot(riskada)
tol.contour(adatol1,levels=c(0.1,0.05,0.01),lty=3:1,add=TRUE)
par(oldpar)

# MC
fixtol2 &lt;- tolerance(riskfix,method="MC",ITER=200) 
adatol2 &lt;- tolerance(riskada,method="MC",ITER=200,parallelise=2) # ~90secs with parallelisation

oldpar &lt;- par(mfrow=c(1,2))
plot(riskfix)
tol.contour(fixtol2,levels=c(0.1,0.05,0.01),lty=3:1,add=TRUE)
plot(riskada)
tol.contour(adatol2,levels=c(0.1,0.05,0.01),lty=3:1,add=TRUE)
par(oldpar)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
