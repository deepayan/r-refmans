<!DOCTYPE html><html><head><title>Help for package spatstat.geom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatstat.geom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.texture'>
<p>Fill Plot With Texture</p></a></li>
<li><a href='#affine'><p>Apply Affine Transformation</p></a></li>
<li><a href='#affine.im'><p>Apply Affine Transformation To Pixel Image</p></a></li>
<li><a href='#affine.owin'><p>Apply Affine Transformation To Window</p></a></li>
<li><a href='#affine.ppp'><p>Apply Affine Transformation To Point Pattern</p></a></li>
<li><a href='#affine.psp'><p>Apply Affine Transformation To Line Segment Pattern</p></a></li>
<li><a href='#affine.tess'><p>Apply Geometrical Transformation To Tessellation</p></a></li>
<li><a href='#angles.psp'><p>Orientation Angles of Line Segments</p></a></li>
<li><a href='#anylist'>
<p>List of Objects</p></a></li>
<li><a href='#anyNA.im'>
<p>Check Whether Image Contains NA Values</p></a></li>
<li><a href='#append.psp'><p>Combine Two Line Segment Patterns</p></a></li>
<li><a href='#applynbd'><p>Apply Function to Every Neighbourhood in a Point Pattern</p></a></li>
<li><a href='#area.owin'><p>Area of a Window</p></a></li>
<li><a href='#areaGain'><p>Difference of Disc Areas</p></a></li>
<li><a href='#areaLoss'><p>Difference of Disc Areas</p></a></li>
<li><a href='#as.box3'>
<p>Convert Data to Three-Dimensional Box</p></a></li>
<li><a href='#as.boxx'><p>Convert Data to Multi-Dimensional Box</p></a></li>
<li><a href='#as.colourmap'>
<p>Convert to Colour Map</p></a></li>
<li><a href='#as.data.frame.hyperframe'><p>Coerce Hyperframe to Data Frame</p></a></li>
<li><a href='#as.data.frame.im'><p>Convert Pixel Image to Data Frame</p></a></li>
<li><a href='#as.data.frame.owin'><p>Convert Window to Data Frame</p></a></li>
<li><a href='#as.data.frame.ppp'><p>Coerce Point Pattern to a Data Frame</p></a></li>
<li><a href='#as.data.frame.psp'><p>Coerce Line Segment Pattern to a Data Frame</p></a></li>
<li><a href='#as.data.frame.tess'><p>Convert Tessellation to Data Frame</p></a></li>
<li><a href='#as.function.im'>
<p>Convert Pixel Image to Function of Coordinates</p></a></li>
<li><a href='#as.function.owin'>
<p>Convert Window to Indicator Function</p></a></li>
<li><a href='#as.function.tess'>
<p>Convert a Tessellation to a Function</p></a></li>
<li><a href='#as.hyperframe'>
<p>Convert Data to Hyperframe</p></a></li>
<li><a href='#as.hyperframe.ppx'>
<p>Extract coordinates and marks of multidimensional point pattern</p></a></li>
<li><a href='#as.im'><p>Convert to Pixel Image</p></a></li>
<li><a href='#as.layered'><p>Convert Data To Layered Object</p></a></li>
<li><a href='#as.mask'><p>Pixel Image Approximation of a Window</p></a></li>
<li><a href='#as.matrix.im'><p>Convert Pixel Image to Matrix or Array</p></a></li>
<li><a href='#as.matrix.owin'><p>Convert Pixel Image to Matrix</p></a></li>
<li><a href='#as.owin'><p>Convert Data To Class owin</p></a></li>
<li><a href='#as.polygonal'>
<p>Convert a Window to a Polygonal Window</p></a></li>
<li><a href='#as.ppp'><p>Convert Data To Class ppp</p></a></li>
<li><a href='#as.psp'><p>Convert Data To Class psp</p></a></li>
<li><a href='#as.rectangle'><p>Window Frame</p></a></li>
<li><a href='#as.solist'>
<p>Convert List of Two-Dimensional Spatial Objects</p></a></li>
<li><a href='#as.tess'><p>Convert Data To Tessellation</p></a></li>
<li><a href='#bdist.pixels'><p>Distance to Boundary of Window</p></a></li>
<li><a href='#bdist.points'><p>Distance to Boundary of Window</p></a></li>
<li><a href='#bdist.tiles'><p>Distance to Boundary of Window</p></a></li>
<li><a href='#beachcolours'>
<p>Create Colour Scheme for a Range of Numbers</p></a></li>
<li><a href='#border'><p>Border Region of a Window</p></a></li>
<li><a href='#bounding.box.xy'><p>Convex Hull of Points</p></a></li>
<li><a href='#boundingbox'>
<p>Bounding Box of a Window, Image, or Point Pattern</p></a></li>
<li><a href='#boundingcircle'>
<p>Smallest Enclosing Circle</p></a></li>
<li><a href='#box3'>
<p>Three-Dimensional Box</p></a></li>
<li><a href='#boxx'>
<p>Multi-Dimensional Box</p></a></li>
<li><a href='#bufftess'>
<p>Buffer Distance Tessellation</p></a></li>
<li><a href='#by.im'><p>Apply Function to Image Broken Down by Factor</p></a></li>
<li><a href='#by.ppp'><p>Apply a Function to a Point Pattern Broken Down by Factor</p></a></li>
<li><a href='#cbind.hyperframe'>
<p>Combine Hyperframes by Rows or by Columns</p></a></li>
<li><a href='#centroid.owin'><p>Centroid of a window</p></a></li>
<li><a href='#chop.tess'><p>Subdivide a Window or Tessellation using a Set of Lines</p></a></li>
<li><a href='#clickbox'><p>Interactively Define a Rectangle</p></a></li>
<li><a href='#clickdist'><p>Interactively Measure Distance</p></a></li>
<li><a href='#clickpoly'><p>Interactively Define a Polygon</p></a></li>
<li><a href='#clickppp'><p>Interactively Add Points</p></a></li>
<li><a href='#clip.infline'><p>Intersect Infinite Straight Lines with a Window</p></a></li>
<li><a href='#closepairs'>
<p>Close Pairs of Points</p></a></li>
<li><a href='#closepairs.pp3'>
<p>Close Pairs of Points in 3 Dimensions</p></a></li>
<li><a href='#closetriples'>
<p>Close Triples of Points</p></a></li>
<li><a href='#closing'><p>Morphological Closing</p></a></li>
<li><a href='#colourmap'><p>Colour Lookup Tables</p></a></li>
<li><a href='#colouroutputs'>
<p>Extract or Assign Colour Values in a Colour Map</p></a></li>
<li><a href='#colourtools'>
<p>Convert and Compare Colours in Different Formats</p></a></li>
<li><a href='#commonGrid'><p>Determine A Common Spatial Domain And Pixel Resolution</p></a></li>
<li><a href='#compatible'><p>Test Whether Objects Are Compatible</p></a></li>
<li><a href='#compatible.im'><p>Test Whether Pixel Images Are Compatible</p></a></li>
<li><a href='#complement.owin'><p>Take Complement of a Window</p></a></li>
<li><a href='#concatxy'><p>Concatenate x,y Coordinate Vectors</p></a></li>
<li><a href='#connected'>
<p>Connected components</p></a></li>
<li><a href='#connected.ppp'>
<p>Connected Components of a Point Pattern</p></a></li>
<li><a href='#connected.tess'>
<p>Connected Components of Tiles of a Tessellation</p></a></li>
<li><a href='#contour.im'><p>Contour plot of pixel image</p></a></li>
<li><a href='#contour.imlist'><p>Array of Contour Plots</p></a></li>
<li><a href='#convexhull'><p>Convex Hull</p></a></li>
<li><a href='#convexhull.xy'><p>Convex Hull of Points</p></a></li>
<li><a href='#convexify'>
<p>Weil's Convexifying Operation</p></a></li>
<li><a href='#convexmetric'>
<p>Distance Metric Defined by Convex Set</p></a></li>
<li><a href='#convolve.im'><p>Convolution of Pixel Images</p></a></li>
<li><a href='#coords'>
<p>Extract or Change Coordinates of a Spatial or Spatiotemporal Point Pattern</p></a></li>
<li><a href='#corners'><p>Corners of a rectangle</p></a></li>
<li><a href='#covering'><p>Cover Region with Discs</p></a></li>
<li><a href='#crossdist'><p>Pairwise distances</p></a></li>
<li><a href='#crossdist.default'><p>Pairwise distances between two different sets of points</p></a></li>
<li><a href='#crossdist.pp3'><p>Pairwise distances between two different three-dimensional point patterns</p></a></li>
<li><a href='#crossdist.ppp'><p>Pairwise distances between two different point patterns</p></a></li>
<li><a href='#crossdist.ppx'><p>Pairwise Distances Between Two Different Multi-Dimensional Point Patterns</p></a></li>
<li><a href='#crossdist.psp'><p>Pairwise distances between two different line segment patterns</p></a></li>
<li><a href='#crossing.psp'><p>Crossing Points of Two Line Segment Patterns</p></a></li>
<li><a href='#cut.im'><p>Convert Pixel Image from Numeric to Factor</p></a></li>
<li><a href='#cut.ppp'><p>Classify Points in a Point Pattern</p></a></li>
<li><a href='#default.dummy'><p>Generate a Default Pattern of Dummy Points</p></a></li>
<li><a href='#delaunay'><p>Delaunay Triangulation of Point Pattern</p></a></li>
<li><a href='#delaunayDistance'><p>Distance on Delaunay Triangulation</p></a></li>
<li><a href='#deltametric'>
<p>Delta Metric</p></a></li>
<li><a href='#diameter'><p>Diameter of an Object</p></a></li>
<li><a href='#diameter.box3'>
<p>Geometrical Calculations for Three-Dimensional Box</p></a></li>
<li><a href='#diameter.boxx'>
<p>Geometrical Calculations for Multi-Dimensional Box</p></a></li>
<li><a href='#diameter.owin'><p>Diameter of a Window</p></a></li>
<li><a href='#dilated.areas'>
<p>Areas of Morphological Dilations</p></a></li>
<li><a href='#dilation'><p>Morphological Dilation</p></a></li>
<li><a href='#dirichlet'><p>Dirichlet Tessellation of Point Pattern</p></a></li>
<li><a href='#dirichletAreas'>
<p>Compute Areas of Tiles in Dirichlet Tessellation</p></a></li>
<li><a href='#dirichletVertices'>
<p>Vertices and Edges of Dirichlet Tessellation</p></a></li>
<li><a href='#dirichletWeights'><p>Compute Quadrature Weights Based on Dirichlet Tessellation</p></a></li>
<li><a href='#disc'><p>Circular Window</p></a></li>
<li><a href='#discpartarea'>
<p>Area of Part of Disc</p></a></li>
<li><a href='#discretise'>
<p>Safely Convert Point Pattern Window to Binary Mask</p></a></li>
<li><a href='#discs'>
<p>Union of Discs</p></a></li>
<li><a href='#distfun'>
<p>Distance Map as a Function</p></a></li>
<li><a href='#distmap'>
<p>Distance Map</p></a></li>
<li><a href='#distmap.owin'><p>Distance Map of Window</p></a></li>
<li><a href='#distmap.ppp'>
<p>Distance Map of Point Pattern</p></a></li>
<li><a href='#distmap.psp'>
<p>Distance Map of Line Segment Pattern</p></a></li>
<li><a href='#domain'>
<p>Extract the Domain of any Spatial Object</p></a></li>
<li><a href='#duplicated.ppp'><p>Determine Duplicated Points in a Spatial Point Pattern</p></a></li>
<li><a href='#edges'>
<p>Extract Boundary Edges of a Window.</p></a></li>
<li><a href='#edges2triangles'>
<p>List Triangles in a Graph</p></a></li>
<li><a href='#edges2vees'>
<p>List Dihedral Triples in a Graph</p></a></li>
<li><a href='#edit.hyperframe'>
<p>Invoke Text Editor on Hyperframe</p></a></li>
<li><a href='#edit.ppp'>
<p>Invoke Text Editor on Spatial Data</p></a></li>
<li><a href='#ellipse'>
<p>Elliptical Window.</p></a></li>
<li><a href='#endpoints.psp'><p>Endpoints of Line Segment Pattern</p></a></li>
<li><a href='#eroded.areas'><p>Areas of Morphological Erosions</p></a></li>
<li><a href='#erosion'><p>Morphological Erosion by a Disc</p></a></li>
<li><a href='#erosionAny'><p>Morphological Erosion of Windows</p></a></li>
<li><a href='#eval.im'><p>Evaluate Expression Involving Pixel Images</p></a></li>
<li><a href='#ewcdf'><p>Weighted Empirical Cumulative Distribution Function</p></a></li>
<li><a href='#Extract.anylist'><p>Extract or Replace Subset of a List of Things</p></a></li>
<li><a href='#Extract.hyperframe'><p>Extract or Replace Subset of Hyperframe</p></a></li>
<li><a href='#Extract.im'><p>Extract Subset of Image</p></a></li>
<li><a href='#Extract.layered'><p>Extract or Replace Subset of a Layered Object</p></a></li>
<li><a href='#Extract.listof'><p>Extract or Replace Subset of a List of Things</p></a></li>
<li><a href='#Extract.owin'><p>Extract Subset of Window</p></a></li>
<li><a href='#Extract.ppp'><p>Extract or Replace Subset of Point Pattern</p></a></li>
<li><a href='#Extract.ppx'><p>Extract Subset of Multidimensional Point Pattern</p></a></li>
<li><a href='#Extract.psp'><p>Extract Subset of Line Segment Pattern</p></a></li>
<li><a href='#Extract.quad'><p>Subset of Quadrature Scheme</p></a></li>
<li><a href='#Extract.solist'><p>Extract or Replace Subset of a List of Spatial Objects</p></a></li>
<li><a href='#Extract.splitppp'><p>Extract or Replace Sub-Patterns</p></a></li>
<li><a href='#Extract.tess'><p>Extract or Replace Subset of Tessellation</p></a></li>
<li><a href='#extrapolate.psp'>
<p>Extrapolate Line Segments to Obtain Infinite Lines</p></a></li>
<li><a href='#fardist'>
<p>Farthest Distance to Boundary of Window</p></a></li>
<li><a href='#flipxy'><p>Exchange X and Y Coordinates</p></a></li>
<li><a href='#fourierbasis'><p>Fourier Basis Functions</p></a></li>
<li><a href='#Frame'>
<p>Extract or Change the Containing Rectangle of a Spatial Object</p></a></li>
<li><a href='#framedist.pixels'><p>Distance to Bounding Frame</p></a></li>
<li><a href='#funxy'>
<p>Spatial Function Class</p></a></li>
<li><a href='#gridcentres'><p>Rectangular grid of points</p></a></li>
<li><a href='#gridweights'><p>Compute Quadrature Weights Based on Grid Counts</p></a></li>
<li><a href='#grow.boxx'><p>Add margins to box in any dimension</p></a></li>
<li><a href='#grow.rectangle'><p>Add margins to rectangle</p></a></li>
<li><a href='#harmonise'><p>Make Objects Compatible</p></a></li>
<li><a href='#harmonise.im'><p>Make Pixel Images Compatible</p></a></li>
<li><a href='#harmonise.owin'><p>Make Windows Compatible</p></a></li>
<li><a href='#harmoniseLevels'>
<p>Harmonise the levels of several factors, or factor-valued pixel images.</p></a></li>
<li><a href='#has.close'>
<p>Check Whether Points Have Close Neighbours</p></a></li>
<li><a href='#headtail'>
<p>First or Last Part of a Spatial Pattern</p></a></li>
<li><a href='#hextess'>
<p>Hexagonal Grid or Tessellation</p></a></li>
<li><a href='#hist.funxy'><p>Histogram of Values of a Spatial Function</p></a></li>
<li><a href='#hist.im'><p>Histogram of Pixel Values in an Image</p></a></li>
<li><a href='#hotrod'>
<p>Heat Kernel for a One-Dimensional Rod</p></a></li>
<li><a href='#hyperframe'><p>Hyper Data Frame</p></a></li>
<li><a href='#identify.ppp'><p>Identify Points in a Point Pattern</p></a></li>
<li><a href='#identify.psp'><p>Identify Segments in a Line Segment Pattern</p></a></li>
<li><a href='#im'><p>Create a Pixel Image Object</p></a></li>
<li><a href='#im.apply'>
<p>Apply Function Pixelwise to List of Images</p></a></li>
<li><a href='#im.object'><p>Class of Images</p></a></li>
<li><a href='#imcov'><p>Spatial Covariance of a Pixel Image</p></a></li>
<li><a href='#incircle'><p>Find Largest Circle Inside Window</p></a></li>
<li><a href='#infline'><p>Infinite Straight Lines</p></a></li>
<li><a href='#inside.boxx'><p>Test Whether Points Are Inside A Multidimensional Box</p></a></li>
<li><a href='#inside.owin'><p>Test Whether Points Are Inside A Window</p></a></li>
<li><a href='#integral'>
<p>Integral of a Function or Spatial Object</p></a></li>
<li><a href='#integral.density'>
<p>Compute Integral of One-Dimensional Kernel Density Estimate.</p></a></li>
<li><a href='#integral.im'>
<p>Integral of a Pixel Image</p></a></li>
<li><a href='#intensity'>
<p>Intensity of a Dataset or a Model</p></a></li>
<li><a href='#intensity.ppp'>
<p>Empirical Intensity of Point Pattern</p></a></li>
<li><a href='#intensity.ppx'><p>Intensity of a Multidimensional Space-Time Point Pattern</p></a></li>
<li><a href='#intensity.psp'>
<p>Empirical Intensity of Line Segment Pattern</p></a></li>
<li><a href='#intensity.quadratcount'>
<p>Intensity Estimates Using Quadrat Counts</p></a></li>
<li><a href='#interp.colourmap'>
<p>Interpolate smoothly between specified colours</p></a></li>
<li><a href='#interp.im'><p>Interpolate a Pixel Image</p></a></li>
<li><a href='#intersect.boxx'><p>Intersection Of Boxes Of Arbitrary Dimension</p></a></li>
<li><a href='#intersect.owin'><p>Intersection, Union or Set Subtraction of Windows</p></a></li>
<li><a href='#intersect.tess'><p>Intersection of Two Tessellations</p></a></li>
<li><a href='#invoke.metric'>
<p>Perform Geometric Task using a Specified Metric</p></a></li>
<li><a href='#invoke.symbolmap'>
<p>Plot Data Using Graphics Symbol Map</p></a></li>
<li><a href='#is.boxx'>
<p>Recognise a Multi-Dimensional Box</p></a></li>
<li><a href='#is.connected'>
<p>Determine Whether an Object is Connected</p></a></li>
<li><a href='#is.connected.ppp'>
<p>Determine Whether a Point Pattern is Connected</p></a></li>
<li><a href='#is.convex'><p>Test Whether a Window is Convex</p></a></li>
<li><a href='#is.empty'><p>Test Whether An Object Is Empty</p></a></li>
<li><a href='#is.im'><p>Test Whether An Object Is A Pixel Image</p></a></li>
<li><a href='#is.linim'><p>Test Whether an Object is a Pixel Image on a Linear Network</p></a></li>
<li><a href='#is.linnet'><p>Test Whether An Object Is A Linear Network</p></a></li>
<li><a href='#is.lpp'><p>Test Whether An Object Is A Point Pattern on a Linear Network</p></a></li>
<li><a href='#is.marked'><p>Test Whether Marks Are Present</p></a></li>
<li><a href='#is.marked.ppp'><p>Test Whether A Point Pattern is Marked</p></a></li>
<li><a href='#is.multitype'><p>Test whether Object is Multitype</p></a></li>
<li><a href='#is.multitype.ppp'><p>Test Whether A Point Pattern is Multitype</p></a></li>
<li><a href='#is.owin'><p>Test Whether An Object Is A Window</p></a></li>
<li><a href='#is.ppp'><p>Test Whether An Object Is A Point Pattern</p></a></li>
<li><a href='#is.rectangle'><p>Determine Type of Window</p></a></li>
<li><a href='#is.subset.owin'><p>Determine Whether One Window is Contained In Another</p></a></li>
<li><a href='#layered'>
<p>Create List of Plotting Layers</p></a></li>
<li><a href='#layerplotargs'>
<p>Extract or Replace the Plot Arguments of a Layered Object</p></a></li>
<li><a href='#layout.boxes'>
<p>Generate a Row or Column Arrangement of Rectangles.</p></a></li>
<li><a href='#lengths_psp'><p>Lengths of Line Segments</p></a></li>
<li><a href='#levelset'><p>Level Set of a Pixel Image</p></a></li>
<li><a href='#lut'><p>Lookup Tables</p></a></li>
<li><a href='#marks'><p>Marks of a Point Pattern</p></a></li>
<li><a href='#marks.psp'><p>Marks of a Line Segment Pattern</p></a></li>
<li><a href='#marks.tess'><p>Marks of a Tessellation</p></a></li>
<li><a href='#markstat'><p>Summarise Marks in Every Neighbourhood in a Point Pattern</p></a></li>
<li><a href='#matchingdist'><p>Distance for a Point Pattern Matching</p></a></li>
<li><a href='#Math.im'><p>S3 Group Generic methods for images</p></a></li>
<li><a href='#Math.imlist'><p>S3 Group Generic methods for List of Images</p></a></li>
<li><a href='#maxnndist'>
<p>Compute Minimum or Maximum Nearest-Neighbour Distance</p></a></li>
<li><a href='#mean.ewcdf'><p>Mean of Empirical Cumulative Distribution Function</p></a></li>
<li><a href='#mean.im'><p>Mean and Median of Pixel Values in an Image</p></a></li>
<li><a href='#mergeLevels'>
<p>Merge Levels of a Factor</p></a></li>
<li><a href='#methods.box3'>
<p>Methods for Three-Dimensional Box</p></a></li>
<li><a href='#methods.boxx'>
<p>Methods for Multi-Dimensional Box</p></a></li>
<li><a href='#methods.distfun'>
<p>Geometrical Operations for Distance Functions</p></a></li>
<li><a href='#methods.funxy'>
<p>Methods for Spatial Functions</p></a></li>
<li><a href='#methods.layered'>
<p>Methods for Layered Objects</p></a></li>
<li><a href='#methods.pp3'>
<p>Methods for three-dimensional point patterns</p></a></li>
<li><a href='#methods.ppx'>
<p>Methods for Multidimensional Space-Time Point Patterns</p></a></li>
<li><a href='#methods.unitname'>
<p>Methods for Units</p></a></li>
<li><a href='#metric.object'><p>Distance Metric</p></a></li>
<li><a href='#midpoints.psp'><p>Midpoints of Line Segment Pattern</p></a></li>
<li><a href='#MinkowskiSum'><p>Minkowski Sum of Windows</p></a></li>
<li><a href='#multiplicity.ppp'><p>Count Multiplicity of Duplicate Points</p></a></li>
<li><a href='#nearest.raster.point'><p>Find Pixel Nearest to a Given Point</p></a></li>
<li><a href='#nearestsegment'><p>Find Line Segment Nearest to Each Point</p></a></li>
<li><a href='#nearestValue'>
<p>Image of Nearest Defined Pixel Value</p></a></li>
<li><a href='#nestsplit'>
<p>Nested Split</p></a></li>
<li><a href='#nncross'><p>Nearest Neighbours Between Two Patterns</p></a></li>
<li><a href='#nncross.pp3'><p>Nearest Neighbours Between Two Patterns in 3D</p></a></li>
<li><a href='#nncross.ppx'><p>Nearest Neighbours Between Two Patterns in Any Dimensions</p></a></li>
<li><a href='#nndist'><p>Nearest neighbour distances</p></a></li>
<li><a href='#nndist.pp3'><p>Nearest neighbour distances in three dimensions</p></a></li>
<li><a href='#nndist.ppx'><p>Nearest Neighbour Distances in Any Dimensions</p></a></li>
<li><a href='#nndist.psp'><p>Nearest neighbour distances between line segments</p></a></li>
<li><a href='#nnfun'>
<p>Nearest Neighbour Index Map as a Function</p></a></li>
<li><a href='#nnmap'>
<p>K-th Nearest Point Map</p></a></li>
<li><a href='#nnmark'>
<p>Mark of Nearest Neighbour</p></a></li>
<li><a href='#nnwhich'><p>Nearest neighbour</p></a></li>
<li><a href='#nnwhich.pp3'><p>Nearest neighbours in three dimensions</p></a></li>
<li><a href='#nnwhich.ppx'><p>Nearest Neighbours in Any Dimensions</p></a></li>
<li><a href='#nobjects'>
<p>Count Number of Geometrical Objects in a Spatial Dataset</p></a></li>
<li><a href='#npoints'><p>Number of Points in a Point Pattern</p></a></li>
<li><a href='#nsegments'>
<p>Number of Line Segments in a Line Segment Pattern</p></a></li>
<li><a href='#nvertices'>
<p>Count Number of Vertices</p></a></li>
<li><a href='#opening'><p>Morphological Opening</p></a></li>
<li><a href='#overlap.owin'>
<p>Compute Area of Overlap</p></a></li>
<li><a href='#owin'><p>Create a Window</p></a></li>
<li><a href='#owin.object'><p>Class owin</p></a></li>
<li><a href='#owin2mask'>
<p>Convert Window to Binary Mask under Constraints</p></a></li>
<li><a href='#padimage'>
<p>Pad the Border of a Pixel Image</p></a></li>
<li><a href='#pairdist'><p>Pairwise distances</p></a></li>
<li><a href='#pairdist.default'><p>Pairwise distances</p></a></li>
<li><a href='#pairdist.pp3'><p>Pairwise distances in Three Dimensions</p></a></li>
<li><a href='#pairdist.ppp'><p>Pairwise distances</p></a></li>
<li><a href='#pairdist.ppx'><p>Pairwise Distances in Any Dimensions</p></a></li>
<li><a href='#pairdist.psp'><p>Pairwise distances between line segments</p></a></li>
<li><a href='#perimeter'>
<p>Perimeter Length of Window</p></a></li>
<li><a href='#periodify'>
<p>Make Periodic Copies of a Spatial Pattern</p></a></li>
<li><a href='#persp.im'><p>Perspective Plot of Pixel Image</p></a></li>
<li><a href='#perspPoints'>
<p>Draw Points or Lines on a Surface Viewed in Perspective</p></a></li>
<li><a href='#pHcolourmap'>
<p>Colour Map for pH Values</p></a></li>
<li><a href='#pixelcentres'>
<p>Extract Pixel Centres as Point Pattern</p></a></li>
<li><a href='#pixellate'>
<p>Convert Spatial Object to Pixel Image</p></a></li>
<li><a href='#pixellate.owin'>
<p>Convert Window to Pixel Image</p></a></li>
<li><a href='#pixellate.ppp'><p>Convert Point Pattern to Pixel Image</p></a></li>
<li><a href='#pixellate.psp'>
<p>Convert Line Segment Pattern to Pixel Image</p></a></li>
<li><a href='#pixelquad'><p>Quadrature Scheme Based on Pixel Grid</p></a></li>
<li><a href='#plot.anylist'><p>Plot a List of Things</p></a></li>
<li><a href='#plot.colourmap'><p>Plot a Colour Map</p></a></li>
<li><a href='#plot.hyperframe'><p>Plot Entries in a Hyperframe</p></a></li>
<li><a href='#plot.im'><p>Plot a Pixel Image</p></a></li>
<li><a href='#plot.imlist'><p>Plot a List of Images</p></a></li>
<li><a href='#plot.layered'>
<p>Layered Plot</p></a></li>
<li><a href='#plot.listof'><p>Plot a List of Things</p></a></li>
<li><a href='#plot.onearrow'><p>Plot an Arrow</p></a></li>
<li><a href='#plot.owin'><p>Plot a Spatial Window</p></a></li>
<li><a href='#plot.pp3'>
<p>Plot a Three-Dimensional Point Pattern</p></a></li>
<li><a href='#plot.ppp'><p>plot a Spatial Point Pattern</p></a></li>
<li><a href='#plot.pppmatching'>
<p>Plot a Point Matching</p></a></li>
<li><a href='#plot.psp'><p>plot a Spatial Line Segment Pattern</p></a></li>
<li><a href='#plot.quad'><p>Plot a Spatial Quadrature Scheme</p></a></li>
<li><a href='#plot.quadratcount'>
<p>Plot Quadrat Counts</p></a></li>
<li><a href='#plot.solist'><p>Plot a List of Spatial Objects</p></a></li>
<li><a href='#plot.splitppp'><p>Plot a List of Point Patterns</p></a></li>
<li><a href='#plot.symbolmap'>
<p>Plot a Graphics Symbol Map</p></a></li>
<li><a href='#plot.tess'><p>Plot a Tessellation</p></a></li>
<li><a href='#plot.textstring'><p>Plot a Text String</p></a></li>
<li><a href='#plot.texturemap'>
<p>Plot a Texture Map</p></a></li>
<li><a href='#plot.yardstick'>
<p>Plot a Yardstick or Scale Bar</p></a></li>
<li><a href='#pointsOnLines'><p>Place Points Evenly Along Specified Lines</p></a></li>
<li><a href='#polartess'>
<p>Tessellation Using Polar Coordinates</p></a></li>
<li><a href='#pp3'>
<p>Three Dimensional Point Pattern</p></a></li>
<li><a href='#ppp'><p>Create a Point Pattern</p></a></li>
<li><a href='#ppp.object'><p>Class of Point Patterns</p></a></li>
<li><a href='#pppdist'><p>Distance Between Two Point Patterns</p></a></li>
<li><a href='#pppmatching'><p>Create a Point Matching</p></a></li>
<li><a href='#pppmatching.object'><p>Class of Point Matchings</p></a></li>
<li><a href='#ppx'>
<p>Multidimensional Space-Time Point Pattern</p></a></li>
<li><a href='#print.im'><p>Print Brief Details of an Image</p></a></li>
<li><a href='#print.owin'><p>Print Brief Details of a Spatial Window</p></a></li>
<li><a href='#print.ppp'><p>Print Brief Details of a Point Pattern Dataset</p></a></li>
<li><a href='#print.psp'><p>Print Brief Details of a Line Segment Pattern Dataset</p></a></li>
<li><a href='#print.quad'><p>Print a Quadrature Scheme</p></a></li>
<li><a href='#progressreport'><p>Print Progress Reports</p></a></li>
<li><a href='#project2segment'><p>Move Point To Nearest Line</p></a></li>
<li><a href='#project2set'>
<p>Find Nearest Point in a Region</p></a></li>
<li><a href='#psp'><p>Create a Line Segment Pattern</p></a></li>
<li><a href='#psp.object'><p>Class of Line Segment Patterns</p></a></li>
<li><a href='#psp2mask'>
<p>Convert Line Segment Pattern to Binary Pixel Mask</p></a></li>
<li><a href='#quad.object'><p>Class of Quadrature Schemes</p></a></li>
<li><a href='#quadratcount'><p>Quadrat counting for a point pattern</p></a></li>
<li><a href='#quadrats'><p>Divide Region into Quadrats</p></a></li>
<li><a href='#quadscheme'><p>Generate a Quadrature Scheme from a Point Pattern</p></a></li>
<li><a href='#quadscheme.logi'><p>Generate a Logistic Regression Quadrature Scheme from a Point Pattern</p></a></li>
<li><a href='#quantess'><p>Quantile Tessellation</p></a></li>
<li><a href='#quantile.ewcdf'>
<p>Quantiles of Weighted Empirical Cumulative Distribution Function</p></a></li>
<li><a href='#quantile.im'><p>Sample Quantiles of Pixel Image</p></a></li>
<li><a href='#quantilefun'>
<p>Quantile Function</p></a></li>
<li><a href='#quantilefun.im'>
<p>Quantile Function for Images</p></a></li>
<li><a href='#quasirandom'>
<p>Quasirandom Patterns</p></a></li>
<li><a href='#raster.x'><p>Cartesian Coordinates for a Pixel Raster</p></a></li>
<li><a href='#rectdistmap'>
<p>Distance Map Using Rectangular Distance Metric</p></a></li>
<li><a href='#reflect'><p>Reflect In Origin</p></a></li>
<li><a href='#regularpolygon'>
<p>Create A Regular Polygon</p></a></li>
<li><a href='#relevel.im'>
<p>Reorder Levels of a Factor-Valued Image or Pattern</p></a></li>
<li><a href='#Replace.im'><p>Reset Values in Subset of Image</p></a></li>
<li><a href='#requireversion'>
<p>Require a Specific Version of a Package</p></a></li>
<li><a href='#rescale'><p>Convert dataset to another unit of length</p></a></li>
<li><a href='#rescale.im'><p>Convert Pixel Image to Another Unit of Length</p></a></li>
<li><a href='#rescale.owin'><p>Convert Window to Another Unit of Length</p></a></li>
<li><a href='#rescale.ppp'><p>Convert Point Pattern to Another Unit of Length</p></a></li>
<li><a href='#rescale.psp'><p>Convert Line Segment Pattern to Another Unit of Length</p></a></li>
<li><a href='#rescue.rectangle'><p>Convert Window Back To Rectangle</p></a></li>
<li><a href='#restrict.colourmap'>
<p>Restrict a Colour Map to a Subset of Values</p></a></li>
<li><a href='#rexplode'>
<p>Explode a Point Pattern by Displacing Duplicated Points</p></a></li>
<li><a href='#rgbim'><p>Create Colour-Valued Pixel Image</p></a></li>
<li><a href='#ripras'><p>Estimate window from points alone</p></a></li>
<li><a href='#rjitter'><p>Random Perturbation of a Point Pattern</p></a></li>
<li><a href='#rlinegrid'><p>Generate grid of parallel lines with random displacement</p></a></li>
<li><a href='#rotate'><p>Rotate</p></a></li>
<li><a href='#rotate.im'><p>Rotate a Pixel Image</p></a></li>
<li><a href='#rotate.infline'>
<p>Rotate or Shift Infinite Lines</p></a></li>
<li><a href='#rotate.owin'><p>Rotate a Window</p></a></li>
<li><a href='#rotate.ppp'><p>Rotate a Point Pattern</p></a></li>
<li><a href='#rotate.psp'><p>Rotate a Line Segment Pattern</p></a></li>
<li><a href='#round.ppp'>
<p>Apply Numerical Rounding to Spatial Coordinates</p></a></li>
<li><a href='#rounding'>
<p>Detect Numerical Rounding</p></a></li>
<li><a href='#rQuasi'>
<p>Generate Quasirandom Point Pattern in Given Window</p></a></li>
<li><a href='#rsyst'><p>Simulate systematic random point pattern</p></a></li>
<li><a href='#run.simplepanel'>
<p>Run Point-and-Click Interface</p></a></li>
<li><a href='#runifrect'><p>Generate N Uniform Random Points in a Rectangle</p></a></li>
<li><a href='#scalardilate'><p>Apply Scalar Dilation</p></a></li>
<li><a href='#scaletointerval'><p>Rescale Data to Lie Between Specified Limits</p></a></li>
<li><a href='#scanpp'><p>Read Point Pattern From Data File</p></a></li>
<li><a href='#selfcrossing.psp'><p>Crossing Points in a Line Segment Pattern</p></a></li>
<li><a href='#selfcut.psp'><p>Cut Line Segments Where They Intersect</p></a></li>
<li><a href='#sessionLibs'>
<p>Print Names and Version Numbers of Libraries Loaded</p></a></li>
<li><a href='#setcov'><p>Set Covariance of a Window</p></a></li>
<li><a href='#shift'><p>Apply Vector Translation</p></a></li>
<li><a href='#shift.im'><p>Apply Vector Translation To Pixel Image</p></a></li>
<li><a href='#shift.owin'><p>Apply Vector Translation To Window</p></a></li>
<li><a href='#shift.ppp'><p>Apply Vector Translation To Point Pattern</p></a></li>
<li><a href='#shift.ppx'><p>Apply Vector Translation To Box Or Point Pattern In Arbitrary Dimension</p></a></li>
<li><a href='#shift.psp'><p>Apply Vector Translation To Line Segment Pattern</p></a></li>
<li><a href='#sidelengths.owin'><p>Side Lengths of Enclosing Rectangle of a Window</p></a></li>
<li><a href='#simplepanel'><p>Simple Point-and-Click Interface Panels</p></a></li>
<li><a href='#simplify.owin'>
<p>Approximate a Polygon by a Simpler Polygon</p></a></li>
<li><a href='#solapply'>
<p>Apply a Function Over a List and Obtain a List of Objects</p></a></li>
<li><a href='#solist'>
<p>List of Two-Dimensional Spatial Objects</p></a></li>
<li><a href='#solutionset'><p>Evaluate Logical Expression Involving Pixel Images and Return</p>
Region Where Expression is True</a></li>
<li><a href='#spatdim'><p>Spatial Dimension of a Dataset</p></a></li>
<li><a href='#spatstat.geom-deprecated'><p>Deprecated spatstat.geom functions</p></a></li>
<li><a href='#spatstat.geom-internal'><p>Internal spatstat.geom functions</p></a></li>
<li><a href='#spatstat.geom-package'><p>The spatstat.geom Package</p></a></li>
<li><a href='#spatstat.options'><p>Internal Options in Spatstat Package</p></a></li>
<li><a href='#split.hyperframe'>
<p>Divide Hyperframe Into Subsets and Reassemble</p></a></li>
<li><a href='#split.im'><p>Divide Image Into Sub-images</p></a></li>
<li><a href='#split.ppp'><p>Divide Point Pattern into Sub-patterns</p></a></li>
<li><a href='#split.ppx'><p>Divide Multidimensional Point Pattern into Sub-patterns</p></a></li>
<li><a href='#spokes'><p>Spokes pattern of dummy points</p></a></li>
<li><a href='#square'><p>Square Window</p></a></li>
<li><a href='#stratrand'><p>Stratified random point pattern</p></a></li>
<li><a href='#subset.hyperframe'>
<p>Subset of Hyperframe Satisfying A Condition</p></a></li>
<li><a href='#subset.ppp'>
<p>Subset of Point Pattern Satisfying A Condition</p></a></li>
<li><a href='#subset.psp'>
<p>Subset of Line Segment Satisfying A Condition</p></a></li>
<li><a href='#summary.anylist'><p>Summary of a List of Things</p></a></li>
<li><a href='#summary.distfun'>
<p>Summarizing a Function of Spatial Location</p></a></li>
<li><a href='#summary.im'><p>Summarizing a Pixel Image</p></a></li>
<li><a href='#summary.listof'><p>Summary of a List of Things</p></a></li>
<li><a href='#summary.owin'><p>Summary of a Spatial Window</p></a></li>
<li><a href='#summary.ppp'><p>Summary of a Point Pattern Dataset</p></a></li>
<li><a href='#summary.psp'><p>Summary of a Line Segment Pattern Dataset</p></a></li>
<li><a href='#summary.quad'><p>Summarizing a Quadrature Scheme</p></a></li>
<li><a href='#summary.solist'><p>Summary of a List of Spatial Objects</p></a></li>
<li><a href='#summary.splitppp'><p>Summary of a Split Point Pattern</p></a></li>
<li><a href='#superimpose'><p>Superimpose Several Geometric Patterns</p></a></li>
<li><a href='#symbolmap'>
<p>Graphics Symbol Map</p></a></li>
<li><a href='#tess'><p>Create a Tessellation</p></a></li>
<li><a href='#test.crossing.psp'>
<p>Check Whether Segments Cross</p></a></li>
<li><a href='#text.ppp'>
<p>Add Text Labels to Spatial Pattern</p></a></li>
<li><a href='#texturemap'>
<p>Texture Map</p></a></li>
<li><a href='#textureplot'>
<p>Plot Image or Tessellation Using Texture Fill</p></a></li>
<li><a href='#tile.areas'><p>Compute Areas of Tiles in a Tessellation</p></a></li>
<li><a href='#tileindex'>
<p>Determine Which Tile Contains Each Given Point</p></a></li>
<li><a href='#tilenames'><p>Names of Tiles in a Tessellation</p></a></li>
<li><a href='#tiles'><p>Extract List of Tiles in a Tessellation</p></a></li>
<li><a href='#tiles.empty'><p>Check For Empty Tiles in a Tessellation</p></a></li>
<li><a href='#timed'>
<p>Record the Computation Time</p></a></li>
<li><a href='#timeTaken'>
<p>Extract the Total Computation Time</p></a></li>
<li><a href='#transformquantiles'>
<p>Transform the Quantiles</p></a></li>
<li><a href='#transmat'>
<p>Convert Pixel Array Between Different Conventions</p></a></li>
<li><a href='#triangulate.owin'>
<p>Decompose Window into Triangles</p></a></li>
<li><a href='#trim.rectangle'><p>Cut margins from rectangle</p></a></li>
<li><a href='#tweak.colourmap'>
<p>Change Colour Values in a Colour Map</p></a></li>
<li><a href='#union.quad'><p>Union of Data and Dummy Points</p></a></li>
<li><a href='#unique.ppp'><p>Extract Unique Points from a Spatial Point Pattern</p></a></li>
<li><a href='#uniquemap.default'>
<p>Map Duplicate Entries to Unique Entries</p></a></li>
<li><a href='#uniquemap.ppp'>
<p>Map Duplicate Entries to Unique Entries</p></a></li>
<li><a href='#unitname'><p>Name for Unit of Length</p></a></li>
<li><a href='#unmark'><p>Remove Marks</p></a></li>
<li><a href='#unnormdensity'>
<p>Weighted kernel smoother</p></a></li>
<li><a href='#unstack.ppp'>
<p>Separate Multiple Columns of Marks</p></a></li>
<li><a href='#unstack.solist'>
<p>Unstack Each Spatial Object in a List of Objects</p></a></li>
<li><a href='#update.symbolmap'>
<p>Update a Graphics Symbol Map.</p></a></li>
<li><a href='#venn.tess'>
<p>Tessellation Delimited by Several Sets</p></a></li>
<li><a href='#vertices'><p>Vertices of a Window</p></a></li>
<li><a href='#volume'><p>Volume of an Object</p></a></li>
<li><a href='#weighted.median'>
<p>Weighted Median, Quantiles or Variance</p></a></li>
<li><a href='#where.max'>
<p>Find Location of Maximum in a Pixel Image</p></a></li>
<li><a href='#whichhalfplane'>
<p>Test Which Side of Infinite Line a Point Falls On</p></a></li>
<li><a href='#whist'>
<p>Weighted Histogram</p></a></li>
<li><a href='#Window'>
<p>Extract or Change the Window of a Spatial Object</p></a></li>
<li><a href='#Window.tess'><p>Extract Window of Spatial Object</p></a></li>
<li><a href='#with.hyperframe'><p>Evaluate an Expression in Each Row of a Hyperframe</p></a></li>
<li><a href='#yardstick'>
<p>Text, Arrow or Scale Bar in a Diagram</p></a></li>
<li><a href='#zapsmall.im'><p>Rounding of Pixel Values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.2-9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-28</td>
</tr>
<tr>
<td>Title:</td>
<td>Geometrical Functionality of the 'spatstat' Family</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrian Baddeley &lt;Adrian.Baddeley@curtin.edu.au&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), spatstat.data (&ge; 3.0), stats, graphics,
grDevices, utils, methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.utils (&ge; 3.0-2), deldir (&ge; 1.0-2), polyclip (&ge;
1.10-0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spatstat.random, spatstat.explore, spatstat.model,
spatstat.linnet, spatial, fftwtools (&ge; 0.9-8), spatstat (&ge;
3.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Defines spatial data types and supports geometrical operations
	     on them. Data types include point patterns, windows (domains),
	     pixel images, line segment patterns, tessellations and hyperframes.
	     Capabilities include creation and manipulation of data
	     (using command line or graphical interaction),
	     plotting, geometrical operations (rotation, shift, rescale,
	     affine transformation), convex hull, discretisation and
	     pixellation, Dirichlet tessellation, Delaunay triangulation,
	     pairwise distances, nearest-neighbour distances,
	     distance transform, morphological operations
	     (erosion, dilation, closing, opening), quadrat counting,
	     geometrical measurement, geometrical covariance,
	     colour maps, calculus on spatial domains,
	     Gaussian blur, level sets of images, transects of images,
	     intersections between objects, minimum distance matching.
	     (Excludes spatial data on a network, which are supported by
	     the package 'spatstat.linnet'.)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://spatstat.org/">http://spatstat.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/spatstat/spatstat.geom/issues">https://github.com/spatstat/spatstat.geom/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-28 07:49:06 UTC; adrian</td>
</tr>
<tr>
<td>Author:</td>
<td>Adrian Baddeley <a href="https://orcid.org/0000-0001-9499-8382"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Rolf Turner <a href="https://orcid.org/0000-0001-5521-5218"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Ege Rubak <a href="https://orcid.org/0000-0002-6675-533X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Tilman Davies [ctb],
  Ute Hahn [ctb],
  Abdollah Jalilian [ctb],
  Greg McSwiggan [ctb, cph],
  Sebastian Meyer [ctb, cph],
  Jens Oehlschlaegel [ctb, cph],
  Suman Rakshit [ctb],
  Dominic Schuhmacher [ctb],
  Rasmus Waagepetersen [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-28 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.texture'>
Fill Plot With Texture
</h2><span id='topic+add.texture'></span>

<h3>Description</h3>

<p>Draws a simple texture inside a region on the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.texture(W, texture = 4, spacing = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.texture_+3A_w">W</code></td>
<td>

<p>Window (object of class <code>"owin"</code>) inside which the
texture should be drawn.
</p>
</td></tr>
<tr><td><code id="add.texture_+3A_texture">texture</code></td>
<td>

<p>Integer from 1 to 8 identifying the type of texture. See Details.
</p>
</td></tr>
<tr><td><code id="add.texture_+3A_spacing">spacing</code></td>
<td>

<p>Spacing between elements of the texture, in units of the
current plot.
</p>
</td></tr>
<tr><td><code id="add.texture_+3A_...">...</code></td>
<td>

<p>Further arguments controlling the plot colour, line width etc.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The chosen texture, confined to the window <code>W</code>,
will be added to the current plot.
The available textures are:
</p>

<dl>
<dt>texture=1:</dt><dd>
<p>Small crosses arranged in a square grid.
</p>
</dd>
<dt>texture=2:</dt><dd>
<p>Parallel vertical lines.
</p>
</dd>
<dt>texture=3:</dt><dd>
<p>Parallel horizontal lines.
</p>
</dd>
<dt>texture=4:</dt><dd> 
<p>Parallel diagonal lines at 45 degrees from the horizontal.
</p>
</dd>
<dt>texture=5:</dt><dd>
<p>Parallel diagonal lines at 135 degrees from the horizontal.
</p>
</dd>
<dt>texture=6:</dt><dd>
<p>Grid of horizontal and vertical lines.
</p>
</dd>
<dt>texture=7:</dt><dd>
<p>Grid of diagonal lines at 45 and 135 degrees from the horizontal.
</p>
</dd>
<dt>texture=8:</dt><dd>
<p>Grid of hexagons.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>, 
<code><a href="#topic+plot.owin">plot.owin</a></code>,
<code><a href="#topic+textureplot">textureplot</a></code>,
<code><a href="#topic+texturemap">texturemap</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  W &lt;- Window(chorley)
  plot(W, main="")
  add.texture(W, 7)
</code></pre>

<hr>
<h2 id='affine'>Apply Affine Transformation</h2><span id='topic+affine'></span>

<h3>Description</h3>

<p>Applies any affine transformation of the plane (linear transformation
plus vector shift) to a plane geometrical object,
such as a point pattern or a window. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  affine(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine_+3A_x">X</code></td>
<td>
<p>Any suitable dataset representing a two-dimensional
object, such as a point pattern (object of class <code>"ppp"</code>),
a line segment pattern (object of class <code>"psp"</code>),
a window (object of class <code>"owin"</code>) or a pixel image
(object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="affine_+3A_...">...</code></td>
<td>
<p>Arguments determining the affine transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is generic. Methods are provided for
point patterns (<code><a href="#topic+affine.ppp">affine.ppp</a></code>)
and windows (<code><a href="#topic+affine.owin">affine.owin</a></code>).
</p>


<h3>Value</h3>

<p>Another object of the same type, representing the
result of applying the affine transformation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+affine.ppp">affine.ppp</a></code>,
<code><a href="#topic+affine.psp">affine.psp</a></code>,
<code><a href="#topic+affine.owin">affine.owin</a></code>,
<code><a href="#topic+affine.im">affine.im</a></code>,
<code><a href="#topic+flipxy">flipxy</a></code>,
<code><a href="#topic+reflect">reflect</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+shift">shift</a></code>
</p>

<hr>
<h2 id='affine.im'>Apply Affine Transformation To Pixel Image</h2><span id='topic+affine.im'></span>

<h3>Description</h3>

<p>Applies any affine transformation of the plane (linear transformation
plus vector shift) to a pixel image. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
affine(X, mat=diag(c(1,1)), vec=c(0,0), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.im_+3A_x">X</code></td>
<td>
<p>Pixel image (object of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="affine.im_+3A_mat">mat</code></td>
<td>
<p>Matrix representing a linear transformation.</p>
</td></tr>
<tr><td><code id="affine.im_+3A_vec">vec</code></td>
<td>
<p>Vector of length 2 representing a translation.</p>
</td></tr>
<tr><td><code id="affine.im_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
controlling the pixel resolution of the transformed image.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The image is subjected first to the linear transformation represented by
<code>mat</code> (multiplying on the left by <code>mat</code>),
and then the result is translated by the vector <code>vec</code>.
</p>
<p>The argument <code>mat</code> must be a nonsingular <code class="reqn">2 \times 2</code>
matrix.
</p>
<p>This is a method for the generic function <code><a href="#topic+affine">affine</a></code>.
</p>


<h3>Value</h3>

<p>Another pixel image (of class <code>"im"</code>) representing the
result of applying the affine transformation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+affine.ppp">affine.ppp</a></code>,
<code><a href="#topic+affine.psp">affine.psp</a></code>,
<code><a href="#topic+affine.owin">affine.owin</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- setcov(owin())
  stretch &lt;- diag(c(2,3))
  Y &lt;- affine(X, mat=stretch)
  shear &lt;- matrix(c(1,0,0.6,1),ncol=2, nrow=2)
  Z &lt;- affine(X, mat=shear)
</code></pre>

<hr>
<h2 id='affine.owin'>Apply Affine Transformation To Window</h2><span id='topic+affine.owin'></span>

<h3>Description</h3>

<p>Applies any affine transformation of the plane (linear transformation
plus vector shift) to a window. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'owin'
affine(X, mat=diag(c(1,1)), vec=c(0,0), ..., rescue=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.owin_+3A_x">X</code></td>
<td>
<p>Window (object of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="affine.owin_+3A_mat">mat</code></td>
<td>
<p>Matrix representing a linear transformation.</p>
</td></tr>
<tr><td><code id="affine.owin_+3A_vec">vec</code></td>
<td>
<p>Vector of length 2 representing a translation.</p>
</td></tr>
<tr><td><code id="affine.owin_+3A_rescue">rescue</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the transformed window
will be processed by <code><a href="#topic+rescue.rectangle">rescue.rectangle</a></code>.
</p>
</td></tr>
<tr><td><code id="affine.owin_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
controlling the pixel resolution of the transformed window,
if <code>X</code> is a binary pixel mask.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The window is subjected first to the linear transformation represented by
<code>mat</code> (multiplying on the left by <code>mat</code>),
and then the result is translated by the vector <code>vec</code>.
</p>
<p>The argument <code>mat</code> must be a nonsingular <code class="reqn">2 \times 2</code>
matrix.
</p>
<p>This is a method for the generic function <code><a href="#topic+affine">affine</a></code>.
</p>


<h3>Value</h3>

<p>Another window (of class <code>"owin"</code>) representing the
result of applying the affine transformation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+affine.ppp">affine.ppp</a></code>,
<code><a href="#topic+affine.psp">affine.psp</a></code>,
<code><a href="#topic+affine.im">affine.im</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # shear transformation
  shear &lt;- matrix(c(1,0,0.6,1),ncol=2)
  X &lt;- affine(owin(), shear)
  if(interactive()) plot(X)
  affine(letterR, shear, c(0, 0.5))
  affine(as.mask(letterR), shear, c(0, 0.5))
</code></pre>

<hr>
<h2 id='affine.ppp'>Apply Affine Transformation To Point Pattern</h2><span id='topic+affine.ppp'></span>

<h3>Description</h3>

<p>Applies any affine transformation of the plane (linear transformation
plus vector shift) to a point pattern. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppp'
affine(X, mat=diag(c(1,1)), vec=c(0,0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.ppp_+3A_x">X</code></td>
<td>
<p>Point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="affine.ppp_+3A_mat">mat</code></td>
<td>
<p>Matrix representing a linear transformation.</p>
</td></tr>
<tr><td><code id="affine.ppp_+3A_vec">vec</code></td>
<td>
<p>Vector of length 2 representing a translation.</p>
</td></tr>
<tr><td><code id="affine.ppp_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+affine.owin">affine.owin</a></code> affecting
the handling of the observation window, if it is a binary pixel
mask.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The point pattern, and its window, are subjected first to the
linear transformation represented by
<code>mat</code> (multiplying on the left by <code>mat</code>),
and are then translated by the vector <code>vec</code>.
</p>
<p>The argument <code>mat</code> must be a nonsingular <code class="reqn">2 \times 2</code>
matrix.
</p>
<p>This is a method for the generic function <code><a href="#topic+affine">affine</a></code>.
</p>


<h3>Value</h3>

<p>Another point pattern (of class <code>"ppp"</code>) representing the
result of applying the affine transformation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+affine.owin">affine.owin</a></code>,
<code><a href="#topic+affine.psp">affine.psp</a></code>,
<code><a href="#topic+affine.im">affine.im</a></code>,
<code><a href="#topic+flipxy">flipxy</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # shear transformation
  X &lt;- affine(cells, matrix(c(1,0,0.6,1),ncol=2))
  if(interactive()) {
    plot(X)
    # rescale y coordinates by factor 1.3
    plot(affine(cells, diag(c(1,1.3))))
  }
</code></pre>

<hr>
<h2 id='affine.psp'>Apply Affine Transformation To Line Segment Pattern</h2><span id='topic+affine.psp'></span>

<h3>Description</h3>

<p>Applies any affine transformation of the plane (linear transformation
plus vector shift) to a line segment pattern. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'psp'
affine(X, mat=diag(c(1,1)), vec=c(0,0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.psp_+3A_x">X</code></td>
<td>
<p>Line Segment pattern (object of class <code>"psp"</code>).</p>
</td></tr>
<tr><td><code id="affine.psp_+3A_mat">mat</code></td>
<td>
<p>Matrix representing a linear transformation.</p>
</td></tr>
<tr><td><code id="affine.psp_+3A_vec">vec</code></td>
<td>
<p>Vector of length 2 representing a translation.</p>
</td></tr>
<tr><td><code id="affine.psp_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+affine.owin">affine.owin</a></code> affecting
the handling of the observation window, if it is a binary pixel
mask.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The line segment pattern, and its window, are subjected first to the
linear transformation represented by
<code>mat</code> (multiplying on the left by <code>mat</code>),
and are then translated by the vector <code>vec</code>.
</p>
<p>The argument <code>mat</code> must be a nonsingular <code class="reqn">2 \times 2</code>
matrix.
</p>
<p>This is a method for the generic function <code><a href="#topic+affine">affine</a></code>.
</p>


<h3>Value</h3>

<p>Another line segment pattern (of class <code>"psp"</code>) representing the
result of applying the affine transformation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+affine.owin">affine.owin</a></code>,
<code><a href="#topic+affine.ppp">affine.ppp</a></code>,
<code><a href="#topic+affine.im">affine.im</a></code>,
<code><a href="#topic+flipxy">flipxy</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  oldpar &lt;- par(mfrow=c(2,1))
  X &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  plot(X, main="original")
  # shear transformation
  Y &lt;- affine(X, matrix(c(1,0,0.6,1),ncol=2))
  plot(Y, main="transformed")
  par(oldpar)
  # 
  # rescale y coordinates by factor 0.2
  affine(X, diag(c(1,0.2)))
</code></pre>

<hr>
<h2 id='affine.tess'>Apply Geometrical Transformation To Tessellation</h2><span id='topic+reflect.tess'></span><span id='topic+flipxy.tess'></span><span id='topic+shift.tess'></span><span id='topic+rotate.tess'></span><span id='topic+scalardilate.tess'></span><span id='topic+affine.tess'></span>

<h3>Description</h3>

<p>Apply various geometrical transformations of the plane
to each tile in a tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'tess'
reflect(X)

  ## S3 method for class 'tess'
flipxy(X)

  ## S3 method for class 'tess'
shift(X, ...)

  ## S3 method for class 'tess'
rotate(X, angle=pi/2, ..., centre=NULL)

  ## S3 method for class 'tess'
scalardilate(X, f, ...)

  ## S3 method for class 'tess'
affine(X, mat=diag(c(1,1)), vec=c(0,0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.tess_+3A_x">X</code></td>
<td>
<p>Tessellation (object of class <code>"tess"</code>).</p>
</td></tr>
<tr><td><code id="affine.tess_+3A_angle">angle</code></td>
<td>

<p>Rotation angle in radians (positive values represent
anticlockwise rotations).
</p>
</td></tr>
<tr><td><code id="affine.tess_+3A_mat">mat</code></td>
<td>
<p>Matrix representing a linear transformation.</p>
</td></tr>
<tr><td><code id="affine.tess_+3A_vec">vec</code></td>
<td>
<p>Vector of length 2 representing a translation.</p>
</td></tr>
<tr><td><code id="affine.tess_+3A_f">f</code></td>
<td>
<p>Positive number giving scale factor.</p>
</td></tr>
<tr><td><code id="affine.tess_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="affine.tess_+3A_centre">centre</code></td>
<td>

<p>Centre of rotation.
Either a vector of length 2, or a character string
(partially matched to <code>"centroid"</code>, <code>"midpoint"</code>
or <code>"bottomleft"</code>).
The default is the coordinate origin <code>c(0,0)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are method for the generic functions 
<code><a href="#topic+reflect">reflect</a></code>,
<code><a href="#topic+flipxy">flipxy</a></code>,
<code><a href="#topic+shift">shift</a></code>,
<code><a href="#topic+rotate">rotate</a></code>, 
<code><a href="#topic+scalardilate">scalardilate</a></code>,
<code><a href="#topic+affine">affine</a></code>
for tessellations (objects of class <code>"tess"</code>).
</p>
<p>The individual tiles of the tessellation, and the window
containing the tessellation, are all subjected to the same
geometrical transformation.
</p>
<p>The transformations are performed by the corresponding method
for windows (class <code>"owin"</code>) or images (class <code>"im"</code>)
depending on the type of tessellation.
</p>
<p>If the argument <code>origin</code> is used in <code>shift.tess</code>
it is interpreted as applying to the window containing the
tessellation. Then all tiles are shifted by the same vector.
</p>


<h3>Value</h3>

<p>Another tessellation (of class <code>"tess"</code>) representing the
result of applying the geometrical transformation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p>Generic functions
<code><a href="#topic+reflect">reflect</a></code>,
<code><a href="#topic+shift">shift</a></code>,
<code><a href="#topic+rotate">rotate</a></code>, 
<code><a href="#topic+scalardilate">scalardilate</a></code>,
<code><a href="#topic+affine">affine</a></code>.
</p>
<p>Methods for windows:
<code><a href="#topic+reflect.default">reflect.default</a></code>,
<code><a href="#topic+shift.owin">shift.owin</a></code>,
<code><a href="#topic+rotate.owin">rotate.owin</a></code>, 
<code><a href="#topic+scalardilate.owin">scalardilate.owin</a></code>,
<code><a href="#topic+affine.owin">affine.owin</a></code>.
</p>
<p>Methods for images:
<code><a href="#topic+reflect.im">reflect.im</a></code>,
<code><a href="#topic+shift.im">shift.im</a></code>,
<code><a href="#topic+rotate.im">rotate.im</a></code>, 
<code><a href="#topic+scalardilate.im">scalardilate.im</a></code>,
<code><a href="#topic+affine.im">affine.im</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  live &lt;- interactive()
  if(live) {
    H &lt;- hextess(letterR, 0.2)
    plot(H)
    plot(reflect(H))
    plot(rotate(H, pi/3))
  } else H &lt;- hextess(letterR, 0.6)

  # shear transformation
  shear &lt;- matrix(c(1,0,0.6,1),2,2)
  sH &lt;- affine(H, shear)
  if(live) plot(sH)
</code></pre>

<hr>
<h2 id='angles.psp'>Orientation Angles of Line Segments</h2><span id='topic+angles.psp'></span>

<h3>Description</h3>

<p>Computes the orientation angle of each line segment
in a line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  angles.psp(x, directed=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angles.psp_+3A_x">x</code></td>
<td>

<p>A line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="angles.psp_+3A_directed">directed</code></td>
<td>

<p>Logical flag. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each line segment,  the angle of inclination to the <code class="reqn">x</code>-axis
(in radians) is computed,
and the angles are returned as a numeric vector.
</p>
<p>If <code>directed=TRUE</code>, the directed angle of orientation
is computed. The angle respects the
sense of direction from <code>(x0,y0)</code> to <code>(x1,y1)</code>.
The values returned are angles in the full range from <code class="reqn">-\pi</code>
to <code class="reqn">\pi</code>. The angle is computed as 
<code>atan2(y1-y0,x1-x0)</code>. See <code><a href="base.html#topic+atan2">atan2</a></code>.
</p>
<p>If <code>directed=FALSE</code>, the undirected angle of orientation
is computed. Angles differing by <code class="reqn">\pi</code> are
regarded as equivalent. The values returned are angles
in the range from <code class="reqn">0</code> to <code class="reqn">\pi</code>. These angles are
computed by first computing the directed angle,
then adding <code class="reqn">\pi</code> to any negative angles.
</p>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp">psp</a></code>,
<code><a href="#topic+marks.psp">marks.psp</a></code>,
<code><a href="#topic+summary.psp">summary.psp</a></code>,
<code><a href="#topic+midpoints.psp">midpoints.psp</a></code>,
<code><a href="#topic+lengths_psp">lengths_psp</a></code>,
<code><a href="#topic+endpoints.psp">endpoints.psp</a></code>,
<code><a href="#topic+extrapolate.psp">extrapolate.psp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  b &lt;- angles.psp(a)   
</code></pre>

<hr>
<h2 id='anylist'>
List of Objects
</h2><span id='topic+anylist'></span><span id='topic+as.anylist'></span>

<h3>Description</h3>

<p>Make a list of objects of any type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anylist(...)
as.anylist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anylist_+3A_...">...</code></td>
<td>

<p>Any number of arguments of any type.
</p>
</td></tr>
<tr><td><code id="anylist_+3A_x">x</code></td>
<td>

<p>A list.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"anylist"</code> is
a list of objects that the user intends to treat in a similar fashion.
</p>
<p>For example it may be desired to plot each of the objects
side-by-side: this can be done using the function
<code><a href="#topic+plot.anylist">plot.anylist</a></code>.
</p>
<p>The objects can belong to any class;
they may or may not all belong to the same class.
</p>
<p>In the <span class="pkg">spatstat</span> package, various functions produce
an object of class <code>"anylist"</code>.
</p>


<h3>Value</h3>

<p>A list, belonging to the class <code>"anylist"</code>,
containing the original objects.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+solist">solist</a></code>,
<code><a href="#topic+as.solist">as.solist</a></code>,
<code><a href="#topic+anylapply">anylapply</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(require(spatstat.explore)) {
    anylist(cells, intensity(cells), Kest(cells))
  } else {
    anylist(cells, intensity(cells))
  }
  anylist()
</code></pre>

<hr>
<h2 id='anyNA.im'>
Check Whether Image Contains NA Values
</h2><span id='topic+anyNA.im'></span>

<h3>Description</h3>

<p>Checks whether any pixel values in a pixel image are <code>NA</code>
(meaning that the pixel lies outside the domain of definition of the
image). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
anyNA(x, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anyNA.im_+3A_x">x</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="anyNA.im_+3A_recursive">recursive</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="Matrix.html#topic+anyNA">anyNA</a></code> is generic: <code>anyNA(x)</code> is a
faster alternative to <code>any(is.na(x))</code>.
</p>
<p>This function <code>anyNA.im</code> is a method for the generic <code>anyNA</code>
defined for pixel images. It returns the value <code>TRUE</code> if any of the pixel
values in <code>x</code> are <code>NA</code>, and
and otherwise returns <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>A single logical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im.object">im.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  anyNA(as.im(letterR))
</code></pre>

<hr>
<h2 id='append.psp'>Combine Two Line Segment Patterns</h2><span id='topic+append.psp'></span>

<h3>Description</h3>

<p>Combine two line segment patterns into a single pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  append.psp(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append.psp_+3A_a">A</code>, <code id="append.psp_+3A_b">B</code></td>
<td>

<p>Line segment patterns (objects of class <code>"psp"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to superimpose two line segment patterns
<code>A</code> and <code>B</code>.
</p>
<p>The two patterns must have <b>identical</b> windows. If one
pattern has marks, then the other must also have marks
of the same type.  It the marks are data frames then the
number of columns of these data frames, and the names of
the columns must be identical.
</p>
<p>(To combine two point patterns, see <code>superimpose</code>).
</p>
<p>If one of the arguments is <code>NULL</code>, it will be ignored
and the other argument will be returned.
</p>


<h3>Value</h3>

<p>Another line segment pattern (object of class <code>"psp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp">psp</a></code>,
<code><a href="#topic+as.psp">as.psp</a></code>,
<code><a href="#topic+superimpose">superimpose</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- psp(runif(20), runif(20), runif(20), runif(20),  window=owin())
  Y &lt;- psp(runif(5), runif(5), runif(5), runif(5),  window=owin())
  append.psp(X,Y)
</code></pre>

<hr>
<h2 id='applynbd'>Apply Function to Every Neighbourhood in a Point Pattern</h2><span id='topic+applynbd'></span>

<h3>Description</h3>

<p>Visit each point in a point pattern, find the neighbouring points,
and apply a given function to them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   applynbd(X, FUN, N=NULL, R=NULL, criterion=NULL, exclude=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applynbd_+3A_x">X</code></td>
<td>

<p>Point pattern. 
An object of class <code>"ppp"</code>,
or data which can be converted into 
this format by <code><a href="#topic+as.ppp">as.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="applynbd_+3A_fun">FUN</code></td>
<td>

<p>Function to be applied to each neighbourhood.
The arguments of <code>FUN</code> are described under <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="applynbd_+3A_n">N</code></td>
<td>

<p>Integer. If this argument is present,
the neighbourhood of a point of <code>X</code> is defined to consist of the
<code>N</code> points of <code>X</code> which are closest to it.
</p>
</td></tr>
<tr><td><code id="applynbd_+3A_r">R</code></td>
<td>

<p>Nonnegative numeric value. If this argument is present,
the neighbourhood of a point of <code>X</code> is defined to consist of
all points of <code>X</code> which lie within a distance <code>R</code>
of it.
</p>
</td></tr>
<tr><td><code id="applynbd_+3A_criterion">criterion</code></td>
<td>

<p>Function. If this argument is present, 
the neighbourhood of a point of <code>X</code> is determined by
evaluating this function. See under <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="applynbd_+3A_exclude">exclude</code></td>
<td>

<p>Logical. If <code>TRUE</code> then the point currently being visited
is excluded from its own neighbourhood.
</p>
</td></tr>
<tr><td><code id="applynbd_+3A_...">...</code></td>
<td>

<p>extra arguments passed to the function <code>FUN</code>.
They must be given in the form <code>name=value</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an analogue of <code><a href="base.html#topic+apply">apply</a></code>
for point patterns. It visits each point in the point pattern <code>X</code>,
determines which points of <code>X</code> are &ldquo;neighbours&rdquo; of the current
point, applies the function <code>FUN</code> to this neighbourhood,
and collects the values returned by <code>FUN</code>.
</p>
<p>The definition of &ldquo;neighbours&rdquo; depends on the arguments
<code>N</code>, <code>R</code> and <code>criterion</code>.
Also the argument <code>exclude</code> determines whether
the current point is excluded from its own neighbourhood.
</p>

<ul>
<li> 
<p>If <code>N</code> is given, then the neighbours of the current
point are the <code>N</code> points of <code>X</code> which are closest to
the current point (including the current point itself
unless <code>exclude=TRUE</code>).
</p>
</li>
<li>
<p>If <code>R</code> is given, then the neighbourhood of the current point
consists of all points of <code>X</code> which lie closer than a distance <code>R</code>
from the current point.
</p>
</li>
<li> 
<p>If <code>criterion</code> is given, then it must be a function
with two arguments <code>dist</code> and <code>drank</code> which will be
vectors of equal length.
The interpretation is that <code>dist[i]</code> will be the
distance of a point from the current point, and
<code>drank[i]</code> will be the rank of that distance (the three points
closest to the current point will have rank 1, 2 and 3).
This function must return a logical vector of the same length
as <code>dist</code> and <code>drank</code> whose <code>i</code>-th entry is
<code>TRUE</code> if the corresponding point should be included in
the neighbourhood. See the examples below.
</p>
</li>
<li>
<p>If more than one of the arguments <code>N</code>, <code>R</code> and
<code>criterion</code> is given, the neighbourhood is defined as
the <em>intersection</em> of the neighbourhoods specified by these arguments.
For example if <code>N=3</code> and <code>R=5</code> then the neighbourhood
is formed by finding the 3 nearest neighbours of current point,
and retaining only those neighbours which lie closer than 5 units
from the current point.
</p>
</li></ul>

<p>When <code>applynbd</code> is executed, 
each point of <code>X</code> is visited, and the following happens
for each point:
</p>

<ul>
<li>
<p>the neighbourhood of the current point is determined according
to the chosen rule, and stored as a point pattern <code>Y</code>;
</p>
</li>
<li>
<p>the function <code>FUN</code> is called as:
</p>
<p><code>FUN(Y=Y, current=current, dists=dists, dranks=dranks, ...)</code>
</p>
<p>where <code>current</code> is the location of the current point
(in a format explained below),
<code>dists</code> is a vector of distances from the current
point to each of the points in <code>Y</code>, 
<code>dranks</code> is a vector of the ranks of these distances
with respect to the full point pattern <code>X</code>,
and <code>...</code> are the arguments passed from the call to
<code>applynbd</code>;
</p>
</li>
<li>
<p>The result of the call to <code>FUN</code> is stored.
</p>
</li></ul>

<p>The results of each call to <code>FUN</code> are collected and returned
according to the usual rules for <code><a href="base.html#topic+apply">apply</a></code> and its
relatives. See the <b>Value</b> section of this help file.
</p>
<p>The format of the argument <code>current</code> is as follows.
If <code>X</code> is an unmarked point pattern, then <code>current</code> is a
list of length 2 with entries <code>current$x</code> and <code>current$y</code>
containing the coordinates of the current point.
If <code>X</code> is marked, then <code>current</code> is a point pattern
containing exactly one point, so that <code>current$x</code> is its
<code class="reqn">x</code>-coordinate and <code>current$marks</code> is its mark value.
In either case, the coordinates of the current point can be referred to as
<code>current$x</code> and <code>current$y</code>.
</p>
<p>Note that <code>FUN</code> will be called exactly as described above,
with each argument named explicitly. Care is required when writing the
function <code>FUN</code> to ensure that
the arguments will match up. See the Examples.
</p>
<p>See <code><a href="#topic+markstat">markstat</a></code> for a common use of this function.
</p>
<p>To simply tabulate the marks in every <code>R</code>-neighbourhood, use
<code><a href="spatstat.explore.html#topic+marktable">marktable</a></code>.
</p>


<h3>Value</h3>

<p>Similar to the result of <code><a href="base.html#topic+apply">apply</a></code>.
If each call to <code>FUN</code> returns a single numeric value,
the result is a vector of dimension <code>npoints(X)</code>, the number of points
in <code>X</code>.
If each call to <code>FUN</code> returns a vector of the same length
<code>m</code>, then the result is a matrix of dimensions <code>c(m,n)</code>;
note the transposition of the indices, as usual for the family of
<code>apply</code> functions.
If the calls to <code>FUN</code> return vectors of different lengths,
the result is a list of length <code>npoints(X)</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="base.html#topic+apply">apply</a></code>,
<code><a href="#topic+markstat">markstat</a></code>,
<code><a href="spatstat.explore.html#topic+marktable">marktable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  redwood
  # count the number of points within radius 0.2 of each point of X
  nneighbours &lt;- applynbd(redwood, R=0.2, function(Y, ...){npoints(Y)-1})
  # equivalent to:
  nneighbours &lt;- applynbd(redwood, R=0.2, function(Y, ...){npoints(Y)}, exclude=TRUE)

  # compute the distance to the second nearest neighbour of each point
  secondnndist &lt;- applynbd(redwood, N = 2,
                           function(dists, ...){max(dists)},
                           exclude=TRUE)

  # marked point pattern
  trees &lt;- longleaf
  
  # compute the median of the marks of all neighbours of a point
  # (see also 'markstat')
  dbh.med &lt;- applynbd(trees, R=90, exclude=TRUE,
                 function(Y, ...) { median(marks(Y))})


  # ANIMATION explaining the definition of the K function
  # (arguments `fullpicture' and 'rad' are passed to FUN)

  if(interactive()) {
  showoffK &lt;- function(Y, current, dists, dranks, fullpicture,rad) { 
	plot(fullpicture, main="")
	points(Y, cex=2)
        ux &lt;- current[["x"]]
        uy &lt;- current[["y"]]
	points(ux, uy, pch="+",cex=3)
	theta &lt;- seq(0,2*pi,length=100)
	polygon(ux + rad * cos(theta), uy+rad*sin(theta))
	text(ux + rad/3, uy + rad/2,npoints(Y),cex=3)
	if(interactive()) Sys.sleep(if(runif(1) &lt; 0.1) 1.5 else 0.3)
	return(npoints(Y))
  }
  applynbd(redwood, R=0.2, showoffK, fullpicture=redwood, rad=0.2, exclude=TRUE)

  # animation explaining the definition of the G function

  showoffG &lt;- function(Y, current, dists, dranks, fullpicture) { 
	plot(fullpicture, main="")
	points(Y, cex=2)
        u &lt;- current
	points(u[1],u[2],pch="+",cex=3)
	v &lt;- c(Y$x[1],Y$y[1])
	segments(u[1],u[2],v[1],v[2],lwd=2)
	w &lt;- (u + v)/2
	nnd &lt;- dists[1]
	text(w[1],w[2],round(nnd,3),cex=2)
	if(interactive()) Sys.sleep(if(runif(1) &lt; 0.1) 1.5 else 0.3)
	return(nnd)
  }

  applynbd(cells, N=1, showoffG, exclude=TRUE, fullpicture=cells)
  }
</code></pre>

<hr>
<h2 id='area.owin'>Area of a Window</h2><span id='topic+area'></span><span id='topic+area.owin'></span><span id='topic+area.default'></span><span id='topic+volume.owin'></span>

<h3>Description</h3>

<p>Computes the area of a window 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> area(w)

 ## S3 method for class 'owin'
area(w)

 ## Default S3 method:
area(w)

 ## S3 method for class 'owin'
volume(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area.owin_+3A_w">w</code></td>
<td>
<p>A window, whose area will be computed.
This should be an object of class <code><a href="#topic+owin">owin</a></code>,
or can be given in any format acceptable to <code><a href="#topic+as.owin">as.owin</a>()</code>.
</p>
</td></tr>
<tr><td><code id="area.owin_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+owin">owin</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the window <code>w</code> is of type <code>"rectangle"</code> or <code>"polygonal"</code>,
the area of this rectangular window is computed by analytic geometry.
If <code>w</code> is of type <code>"mask"</code> 
the area of the discrete raster approximation of the window is
computed by summing the binary image values and adjusting for
pixel size.
</p>
<p>The function <code>volume.owin</code> is identical to <code>area.owin</code>
except for the argument name. It is a method for the generic function
<code>volume</code>.
</p>


<h3>Value</h3>

<p>A numerical value giving the area of the window. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+perimeter">perimeter</a></code>,
<code><a href="#topic+diameter.owin">diameter.owin</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- unit.square()
  area(w)
       # returns 1.00000

  k &lt;- 6
  theta &lt;- 2 * pi * (0:(k-1))/k
  co &lt;- cos(theta)
  si &lt;- sin(theta)
  mas &lt;- owin(c(-1,1), c(-1,1), poly=list(x=co, y=si))
  area(mas)
      # returns approx area of k-gon
  
  mas &lt;- as.mask(square(2), eps=0.01)
  X &lt;- raster.x(mas)
  Y &lt;- raster.y(mas)
  mas$m &lt;- ((X - 1)^2 + (Y - 1)^2 &lt;= 1)
  area(mas)
       # returns 3.14 approx     

</code></pre>

<hr>
<h2 id='areaGain'>Difference of Disc Areas</h2><span id='topic+areaGain'></span>

<h3>Description</h3>

<p>Computes the area of that part of a disc
that is not covered by other discs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   areaGain(u, X, r, ..., W=as.owin(X), exact=FALSE,
                     ngrid=spatstat.options("ngrid.disc"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areaGain_+3A_u">u</code></td>
<td>

<p>Coordinates of the centre of the disc of interest.
A vector of length 2.
Alternatively, a point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="areaGain_+3A_x">X</code></td>
<td>

<p>Locations of the centres of other discs.
A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="areaGain_+3A_r">r</code></td>
<td>

<p>Disc radius, or vector of disc radii.
</p>
</td></tr>
<tr><td><code id="areaGain_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+distmap">distmap</a></code> to determine the pixel
resolution, when <code>exact=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="areaGain_+3A_w">W</code></td>
<td>

<p>Window (object of class <code>"owin"</code>)
in which the area should be computed.
</p>
</td></tr>
<tr><td><code id="areaGain_+3A_exact">exact</code></td>
<td>

<p>Choice of algorithm.
If <code>exact=TRUE</code>, areas are computed exactly using
analytic geometry. If <code>exact=FALSE</code> then a faster algorithm
is used to compute a discrete approximation to the areas.
</p>
</td></tr>
<tr><td><code id="areaGain_+3A_ngrid">ngrid</code></td>
<td>

<p>Integer. Number of points in the square grid used to compute
the discrete approximation, when <code>exact=FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the area of that part of
the disc of radius <code>r</code> centred at the location <code>u</code>
that is <em>not</em> covered by any of the discs of radius <code>r</code>
centred at the points of the pattern <code>X</code>.
This area is important in some calculations related to
the area-interaction model <code><a href="spatstat.model.html#topic+AreaInter">AreaInter</a></code>.
</p>
<p>If <code>u</code> is a point pattern and <code>r</code> is a vector,
the result is a matrix, with one row for each point in <code>u</code>
and one column for each entry of <code>r</code>. The <code>[i,j]</code> entry
in the matrix is the area of that part of the disc of radius
<code>r[j]</code> centred at the location <code>u[i]</code> that is
<em>not</em> covered by any of the discs of radius <code>r[j]</code>
centred at the points of the pattern <code>X</code>.
</p>
<p>If <code>W</code> is not <code>NULL</code>, then the areas are computed only
inside the window <code>W</code>. 
</p>


<h3>Value</h3>

<p>A matrix with one row for each point in <code>u</code>
and one column for each value in <code>r</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+AreaInter">AreaInter</a></code>,
<code><a href="#topic+areaLoss">areaLoss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   u &lt;- c(0.5,0.5)
   areaGain(u, cells, 0.1)
</code></pre>

<hr>
<h2 id='areaLoss'>Difference of Disc Areas</h2><span id='topic+areaLoss'></span>

<h3>Description</h3>

<p>Computes the area of that part of a disc
that is not covered by other discs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   areaLoss(X, r, ..., W=as.owin(X), subset=NULL,
                 exact=FALSE,
                 ngrid=spatstat.options("ngrid.disc"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areaLoss_+3A_x">X</code></td>
<td>

<p>Locations of the centres of discs.
A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="areaLoss_+3A_r">r</code></td>
<td>

<p>Disc radius, or vector of disc radii.
</p>
</td></tr>
<tr><td><code id="areaLoss_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="areaLoss_+3A_w">W</code></td>
<td>

<p>Optional. Window (object of class <code>"owin"</code>)
inside which the area should be calculated.
</p>
</td></tr>
<tr><td><code id="areaLoss_+3A_subset">subset</code></td>
<td>

<p>Optional. Index identifying a subset of the points of <code>X</code>
for which the area difference should be computed.
</p>
</td></tr>
<tr><td><code id="areaLoss_+3A_exact">exact</code></td>
<td>

<p>Choice of algorithm.
If <code>exact=TRUE</code>, areas are computed exactly using
analytic geometry. If <code>exact=FALSE</code> then a faster algorithm
is used to compute a discrete approximation to the areas.
</p>
</td></tr>
<tr><td><code id="areaLoss_+3A_ngrid">ngrid</code></td>
<td>

<p>Integer. Number of points in the square grid used to compute
the discrete approximation, when <code>exact=FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes, for each point <code>X[i]</code> in <code>X</code>
and for each radius <code>r</code>,
the area of that part of the disc of radius <code>r</code> centred at the
location <code>X[i]</code> that is <em>not</em> covered by any of the
other discs of radius <code>r</code> centred at the points <code>X[j]</code>
for <code>j</code> not equal to <code>i</code>.
This area is important in some calculations related to
the area-interaction model <code><a href="spatstat.model.html#topic+AreaInter">AreaInter</a></code>.
</p>
<p>The result is a matrix, with one row for each point in <code>X</code>
and one column for each entry of <code>r</code>. 
</p>


<h3>Value</h3>

<p>A matrix with one row for each point in <code>X</code> (or <code>X[subset]</code>)
and one column for each value in <code>r</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+AreaInter">AreaInter</a></code>,
<code><a href="#topic+areaGain">areaGain</a></code>,
<code><a href="#topic+dilated.areas">dilated.areas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   areaLoss(cells, 0.1)
</code></pre>

<hr>
<h2 id='as.box3'>
Convert Data to Three-Dimensional Box
</h2><span id='topic+as.box3'></span>

<h3>Description</h3>

<p>Interprets data as the dimensions of a three-dimensional box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.box3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.box3_+3A_...">...</code></td>
<td>

<p>Data that can be interpreted as giving the dimensions of a
three-dimensional box. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts data in various formats to
an object of class <code>"box3"</code> representing a three-dimensional
box (see <code><a href="#topic+box3">box3</a></code>). The arguments <code>...</code> may be
</p>

<ul>
<li><p> an object of class <code>"box3"</code>
</p>
</li>
<li><p> arguments acceptable to <code>box3</code>
</p>
</li>
<li><p> a numeric vector of length 6, interpreted as
<code>c(xrange[1],xrange[2],yrange[1],yrange[2],zrange[1],zrange[2])</code>
</p>
</li>
<li><p> an object of class <code>"pp3"</code> representing a
three-dimensional point pattern contained in a box.
</p>
</li></ul>



<h3>Value</h3>

<p>Object of class <code>"box3"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+box3">box3</a></code>, 
<code><a href="#topic+pp3">pp3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    X &lt;- c(0,10,0,10,0,5)
    as.box3(X)
    X &lt;- pp3(runif(42),runif(42),runif(42), box3(c(0,1)))
    as.box3(X)
</code></pre>

<hr>
<h2 id='as.boxx'>Convert Data to Multi-Dimensional Box</h2><span id='topic+as.boxx'></span>

<h3>Description</h3>

<p>Interprets data as the dimensions of a multi-dimensional box.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.boxx(..., warn.owin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.boxx_+3A_...">...</code></td>
<td>

<p>Data that can be interpreted as giving the dimensions of a
multi-dimensional box. See Details.
</p>
</td></tr>
<tr><td><code id="as.boxx_+3A_warn.owin">warn.owin</code></td>
<td>

<p>Logical value indicating whether to print a warning
if a non-rectangular window (object of class <code>"owin"</code>)
is supplied.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either a single argument should be provided which is one
of the following:
</p>

<ul>
<li><p> an object of class <code>"boxx"</code>
</p>
</li>
<li><p> an object of class <code>"box3"</code>
</p>
</li>
<li><p> an object of class <code>"owin"</code>
</p>
</li>
<li><p> a numeric vector of even length, specifying the corners
of the box. See Examples
</p>
</li></ul>

<p>or a list of arguments acceptable to <code><a href="#topic+boxx">boxx</a></code>.
</p>


<h3>Value</h3>

<p>A <code>"boxx"</code> object.</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Convert unit square to two dimensional box.
 W &lt;- owin()
 as.boxx(W)
 # Make three dimensional box [0,1]x[0,1]x[0,1] from numeric vector
 as.boxx(c(0,1,0,1,0,1))
</code></pre>

<hr>
<h2 id='as.colourmap'>
Convert to Colour Map
</h2><span id='topic+as.colourmap'></span><span id='topic+as.colourmap.colourmap'></span><span id='topic+as.colourmap.symbolmap'></span>

<h3>Description</h3>

<p>Convert some other kind of data to a colour map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.colourmap(x, ...)

  ## S3 method for class 'colourmap'
as.colourmap(x, ...)

  ## S3 method for class 'symbolmap'
as.colourmap(x, ..., warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.colourmap_+3A_x">x</code></td>
<td>

<p>Data to be converted to a colour map.
An object of class <code>"symbolmap"</code>, <code>"colourmap"</code>
or some other kind of suitable data.
</p>
</td></tr>
<tr><td><code id="as.colourmap_+3A_...">...</code></td>
<td>

<p>Other arguments passed to methods.
</p>
</td></tr>
<tr><td><code id="as.colourmap_+3A_warn">warn</code></td>
<td>

<p>Logical value specifying whether to issue a warning
if <code>x</code> does not contain any colour map information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> contains colour map information, it will be extracted
and returned as a colour map object. Otherwise, <code>NULL</code> will be
returned (and a warning will be issued if <code>warn=TRUE</code>, the default).
</p>


<h3>Value</h3>

<p>A colour map (object of class <code>"colourmap"</code>) or <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colourmap">colourmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- pHcolourmap(c(3,8))
  g &lt;- symbolmap(pch=21, bg=m, size=function(x){ 1.1 * x }, range=c(3,8))
  opa &lt;- par(mfrow=c(1,2))
  plot(g, vertical=TRUE)
  plot(as.colourmap(g), vertical=TRUE)
  par(opa)
</code></pre>

<hr>
<h2 id='as.data.frame.hyperframe'>Coerce Hyperframe to Data Frame</h2><span id='topic+as.data.frame.hyperframe'></span>

<h3>Description</h3>

<p>Converts a hyperframe to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyperframe'
as.data.frame(x, row.names = NULL,
                                  optional = FALSE, ..., 
                                  discard=TRUE, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.hyperframe_+3A_x">x</code></td>
<td>
<p>Hyperframe (object of class <code>"hyperframe"</code>).</p>
</td></tr>
<tr><td><code id="as.data.frame.hyperframe_+3A_row.names">row.names</code></td>
<td>
<p>Optional character vector of row names.</p>
</td></tr>
<tr><td><code id="as.data.frame.hyperframe_+3A_optional">optional</code></td>
<td>
<p>Argument passed to <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
controlling what happens to row names.</p>
</td></tr>
<tr><td><code id="as.data.frame.hyperframe_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="as.data.frame.hyperframe_+3A_discard">discard</code></td>
<td>
<p>Logical. Whether to discard columns of the hyperframe
that do not contain atomic data. See Details.
</p>
</td></tr>
<tr><td><code id="as.data.frame.hyperframe_+3A_warn">warn</code></td>
<td>
<p>Logical. Whether to issue a warning when columns are discarded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
for the class of hyperframes (see <code><a href="#topic+hyperframe">hyperframe</a></code>.
</p>
<p>If <code>discard=TRUE</code>, any columns of the hyperframe that
do not contain atomic data will be removed (and a warning will
be issued if <code>warn=TRUE</code>). 
If <code>discard=FALSE</code>, then such columns are converted to
strings indicating what class of data
they originally contained.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  h &lt;- hyperframe(X=1:3, Y=letters[1:3], f=list(sin, cos, tan))
  as.data.frame(h, discard=TRUE, warn=FALSE)
  as.data.frame(h, discard=FALSE)
</code></pre>

<hr>
<h2 id='as.data.frame.im'>Convert Pixel Image to Data Frame</h2><span id='topic+as.data.frame.im'></span>

<h3>Description</h3>

<p>Convert a pixel image to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.im_+3A_x">x</code></td>
<td>
<p>A pixel image (object of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="as.data.frame.im_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="base.html#topic+as.data.frame">as.data.frame.default</a></code>
to determine the row names and other features.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the pixel image <code>x</code>
and returns a data frame with three columns
containing the pixel coordinates and the pixel values.
</p>
<p>The data frame entries are automatically sorted in increasing order of
the <code>x</code> coordinate (and in increasing order of <code>y</code> within
<code>x</code>). 
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # artificial image
   Z &lt;- setcov(square(1))

   Y &lt;- as.data.frame(Z)

   head(Y)
</code></pre>

<hr>
<h2 id='as.data.frame.owin'>Convert Window to Data Frame</h2><span id='topic+as.data.frame.owin'></span>

<h3>Description</h3>

<p>Converts a window object to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'owin'
as.data.frame(x, ..., drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.owin_+3A_x">x</code></td>
<td>

<p>Window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="as.data.frame.owin_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="base.html#topic+as.data.frame">as.data.frame.default</a></code>
to determine the row names and other features.
</p>
</td></tr>
<tr><td><code id="as.data.frame.owin_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating whether to discard pixels that are
outside the window, when <code>x</code> is a binary mask.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a data frame specifying the coordinates of the
window.
</p>
<p>If <code>x</code> is a binary mask window,
the result is a data frame with columns <code>x</code> and <code>y</code>
containing the spatial coordinates of each <em>pixel</em>.
If <code>drop=TRUE</code> (the default), only pixels inside the window are retained.
If <code>drop=FALSE</code>, all pixels are retained, and the data frame has
an extra column <code>inside</code> containing the logical value of each pixel
(<code>TRUE</code> for pixels inside the window, <code>FALSE</code> for outside).
</p>
<p>If <code>x</code> is a rectangle or a polygonal window,
the result is a data frame with columns <code>x</code> and <code>y</code>
containing the spatial coordinates of the <em>vertices</em> of the
window. If the boundary consists of several polygons, the data frame
has additional columns <code>id</code>, identifying which polygon is being
traced, and <code>sign</code>, indicating whether the polygon is an
outer or inner boundary (<code>sign=1</code> and <code>sign=-1</code>
respectively).
</p>


<h3>Value</h3>

<p>A data frame with columns named <code>x</code> and <code>y</code>,
and possibly other columns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.data.frame.im">as.data.frame.im</a></code>,
<code><a href="#topic+as.owin.data.frame">as.owin.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   as.data.frame(square(1))

   holey &lt;- owin(poly=list(
                        list(x=c(0,10,0), y=c(0,0,10)),
                        list(x=c(2,2,4,4), y=c(2,4,4,2))))
   as.data.frame(holey)

   M &lt;- as.mask(holey, eps=0.5)
   Mdf &lt;- as.data.frame(M)
</code></pre>

<hr>
<h2 id='as.data.frame.ppp'>Coerce Point Pattern to a Data Frame</h2><span id='topic+as.data.frame.ppp'></span>

<h3>Description</h3>

<p>Extracts the coordinates of the points in a point pattern,
and their marks if any, and returns them in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
as.data.frame(x, row.names = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.ppp_+3A_x">x</code></td>
<td>
<p>Point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="as.data.frame.ppp_+3A_row.names">row.names</code></td>
<td>
<p>Optional character vector of row names.</p>
</td></tr>
<tr><td><code id="as.data.frame.ppp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
for the class <code>"ppp"</code> of point patterns.
</p>
<p>It extracts the coordinates of the points in the point pattern, and
returns them as columns named <code>x</code> and <code>y</code> in a data frame.
If the points were marked, the marks are returned as a column
named <code>marks</code> with the same type as in the point pattern dataset.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  df &lt;- as.data.frame(amacrine)
  df[1:5,]
</code></pre>

<hr>
<h2 id='as.data.frame.psp'>Coerce Line Segment Pattern to a Data Frame</h2><span id='topic+as.data.frame.psp'></span>

<h3>Description</h3>

<p>Extracts the coordinates of the endpoints in a line segment pattern,
and their marks if any, and returns them in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'psp'
as.data.frame(x, row.names = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.psp_+3A_x">x</code></td>
<td>
<p>Line segment pattern (object of class <code>"psp"</code>).</p>
</td></tr>
<tr><td><code id="as.data.frame.psp_+3A_row.names">row.names</code></td>
<td>
<p>Optional character vector of row names.</p>
</td></tr>
<tr><td><code id="as.data.frame.psp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
for the class <code>"psp"</code> of line segment patterns.
</p>
<p>It extracts the coordinates of the endpoints of the line segments,
and returns them as columns named <code>x0</code>, <code>y0</code>, <code>x1</code>
and <code>y1</code> in a data frame. If the line segments were marked,
the marks are appended as an extra column or columns to the
data frame which is returned.  If the marks are a vector then a
single column named <code>marks</code> is appended. in the data frame,
with the same type as in the line segment pattern dataset.  If the
marks are a data frame, then the columns of this data frame are
appended (retaining their names).
</p>


<h3>Value</h3>

<p>A data frame with 4 or 5 columns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  df &lt;- as.data.frame(copper$Lines)
</code></pre>

<hr>
<h2 id='as.data.frame.tess'>Convert Tessellation to Data Frame</h2><span id='topic+as.data.frame.tess'></span>

<h3>Description</h3>

<p>Converts a spatial tessellation object to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tess'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.tess_+3A_x">x</code></td>
<td>

<p>Tessellation (object of class <code>"tess"</code>).
</p>
</td></tr>
<tr><td><code id="as.data.frame.tess_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="#topic+as.data.frame.owin">as.data.frame.owin</a></code> or
<code><a href="#topic+as.data.frame.im">as.data.frame.im</a></code> and ultimately to
<code><a href="base.html#topic+as.data.frame">as.data.frame.default</a></code>
to determine the row names and other features.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts the tessellation <code>x</code> to a data frame.
</p>
<p>If <code>x</code> is a pixel image tessellation (a pixel image with factor
values specifying the tile membership of each pixel) then this
pixel image is converted to a data frame by
<code><a href="#topic+as.data.frame.im">as.data.frame.im</a></code>. The result is a data frame with
columns <code>x</code> and <code>y</code> giving the pixel coordinates,
and <code>Tile</code> identifying the tile containing the pixel.
</p>
<p>If <code>x</code> is a tessellation consisting of a rectangular grid of tiles
or a list of polygonal tiles, then each tile is converted to a
data frame by <code><a href="#topic+as.data.frame.owin">as.data.frame.owin</a></code>, and these data frames
are joined together, yielding a single large data frame containing
columns <code>x</code>, <code>y</code> giving the coordinates of vertices of the
polygons, and <code>Tile</code> identifying the tile.
</p>


<h3>Value</h3>

<p>A data frame with columns named <code>x</code>, <code>y</code>, <code>Tile</code>,
and possibly other columns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.data.frame.owin">as.data.frame.owin</a></code>,
<code><a href="#topic+as.data.frame.im">as.data.frame.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Z &lt;- as.data.frame(dirichlet(cells))
  head(Z, 10)
</code></pre>

<hr>
<h2 id='as.function.im'>
Convert Pixel Image to Function of Coordinates
</h2><span id='topic+as.function.im'></span>

<h3>Description</h3>

<p>Converts a pixel image to a function of the
<code class="reqn">x</code> and <code class="reqn">y</code> coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'im'
as.function(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.function.im_+3A_x">x</code></td>
<td>

<p>Pixel image (object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="as.function.im_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command converts a pixel image
(object of class <code>"im"</code>) to a <code>function(x,y)</code>
where the arguments <code>x</code> and <code>y</code> are (vectors of) spatial
coordinates. This function returns the pixel values at the
specified locations.
</p>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span> language, also belonging to the
class <code>"funxy"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic++5B.im">[.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- setcov(square(1))
  f &lt;- as.function(d)
  f(0.1, 0.3)
</code></pre>

<hr>
<h2 id='as.function.owin'>
Convert Window to Indicator Function
</h2><span id='topic+as.function.owin'></span>

<h3>Description</h3>

<p>Converts a spatial window to a function of the
<code class="reqn">x</code> and <code class="reqn">y</code> coordinates returning the value 1 inside the
window and 0 outside.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'owin'
as.function(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.function.owin_+3A_x">x</code></td>
<td>

<p>Pixel image (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="as.function.owin_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command converts a spatial window
(object of class <code>"owin"</code>) to a <code>function(x,y)</code>
where the arguments <code>x</code> and <code>y</code> are (vectors of) spatial
coordinates. This is the indicator function of the window:
it returns the value 1 for locations inside the window,
and returns 0 for values outside the window.
</p>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span> language with arguments <code>x,y</code>.
It also belongs to the class <code>"indicfun"</code> which has methods
for <code>plot</code> and <code>print</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.im.owin">as.im.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  W &lt;- Window(humberside)
  f &lt;- as.function(W)
  f
  f(5000, 4500)
  f(123456, 78910)
  X &lt;- runifrect(5, Frame(humberside))
  f(X)
  plot(f)
</code></pre>

<hr>
<h2 id='as.function.tess'>
Convert a Tessellation to a Function
</h2><span id='topic+as.function.tess'></span>

<h3>Description</h3>

<p>Convert a tessellation into a function of the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates.
The default function values are factor levels specifying which tile of the
tessellation contains the point <code class="reqn">(x,y)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'tess'
as.function(x,...,values=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.function.tess_+3A_x">x</code></td>
<td>

<p>A tessellation (object of class <code>"tess"</code>).
</p>
</td></tr>
<tr><td><code id="as.function.tess_+3A_values">values</code></td>
<td>

<p>Optional. A vector giving the values of the function for each tile
of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="as.function.tess_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command converts a tessellation
(object of class <code>"tess"</code>) to a <code>function(x,y)</code>
where the arguments <code>x</code> and <code>y</code> are (vectors of) spatial
coordinates. The corresponding function values are factor levels
identifying which tile of the tessellation contains each point.
Values are <code>NA</code> if the corresponding point lies outside the
tessellation.
</p>
<p>If the argument <code>values</code> is given, then it determines the value
of the function in each tile of <code>x</code>.
</p>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span> language, also belonging to the
class <code>"funxy"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tileindex">tileindex</a></code> for the low-level calculation of tile index.
</p>
<p><code><a href="#topic+cut.ppp">cut.ppp</a></code> and <code><a href="#topic+split.ppp">split.ppp</a></code> to
divide up the points of a point pattern according to
a tessellation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runifrect(7)
  V &lt;- dirichlet(X)
  f &lt;- as.function(V)
  f(0.1, 0.4)
  plot(f)
</code></pre>

<hr>
<h2 id='as.hyperframe'>
Convert Data to Hyperframe
</h2><span id='topic+as.hyperframe'></span><span id='topic+as.hyperframe.default'></span><span id='topic+as.hyperframe.data.frame'></span><span id='topic+as.hyperframe.hyperframe'></span><span id='topic+as.hyperframe.listof'></span><span id='topic+as.hyperframe.anylist'></span>

<h3>Description</h3>

<p>Converts data from any suitable format into a hyperframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.hyperframe(x, ...)

## Default S3 method:
as.hyperframe(x, ...)

## S3 method for class 'data.frame'
as.hyperframe(x, ..., stringsAsFactors=FALSE)

## S3 method for class 'hyperframe'
as.hyperframe(x, ...)

## S3 method for class 'listof'
as.hyperframe(x, ...)

## S3 method for class 'anylist'
as.hyperframe(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.hyperframe_+3A_x">x</code></td>
<td>

<p>Data in some other format.
</p>
</td></tr>
<tr><td><code id="as.hyperframe_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+hyperframe">hyperframe</a></code>.
</p>
</td></tr>
<tr><td><code id="as.hyperframe_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>

<p>Logical. If <code>TRUE</code>, any column of the data frame <code>x</code> that
contains character strings will be converted to a <code>factor</code>.
If <code>FALSE</code>, no such conversion will occur.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A hyperframe is like a data frame, except that its entries
can be objects of any kind.
</p>
<p>The generic function <code>as.hyperframe</code> converts any suitable kind
of data into a hyperframe.
</p>
<p>There are methods for the classes
<code>data.frame</code>, <code>listof</code>, <code>anylist</code> and a default method,
all of which convert data that is like a hyperframe into
a hyperframe object. (The method for the class <code>listof</code>
and <code>anylist</code> converts a list of objects, of
arbitrary type, into a hyperframe with one column.)
These methods do not discard any information.
</p>
<p>There are also methods for other classes
(see <code><a href="#topic+as.hyperframe.ppx">as.hyperframe.ppx</a></code>) which extract
the coordinates from a spatial dataset. These methods
do discard some information.
</p>


<h3>Value</h3>

<p>An object of class <code>"hyperframe"</code> created by
<code><a href="#topic+hyperframe">hyperframe</a></code>.
</p>


<h3>Conversion of Strings to Factors</h3>

<p>Note that <code>as.hyperframe.default</code>
will convert a character vector to a factor.
It behaves like <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.
</p>
<p>However <code>as.hyperframe.data.frame</code> does not convert strings to
factors; it respects the structure of the data frame <code>x</code>.
</p>
<p>The behaviour can be changed using the argument <code>stringsAsFactors</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyperframe">hyperframe</a></code>,
<code><a href="#topic+as.hyperframe.ppx">as.hyperframe.ppx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   df &lt;- data.frame(x=runif(4),y=letters[1:4])
   as.hyperframe(df)

   sims &lt;- replicate(3, runifrect(10), simplify=FALSE)
   as.hyperframe(as.listof(sims))
   as.hyperframe(as.solist(sims))
</code></pre>

<hr>
<h2 id='as.hyperframe.ppx'>
Extract coordinates and marks of multidimensional point pattern
</h2><span id='topic+as.hyperframe.ppx'></span><span id='topic+as.data.frame.ppx'></span><span id='topic+as.matrix.ppx'></span>

<h3>Description</h3>

<p>Given any kind of spatial or space-time point pattern,
extract the coordinates and marks of the points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppx'
as.hyperframe(x, ...)
## S3 method for class 'ppx'
as.data.frame(x, ...)
## S3 method for class 'ppx'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.hyperframe.ppx_+3A_x">x</code></td>
<td>

<p>A general multidimensional space-time point pattern 
(object of class <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="as.hyperframe.ppx_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"ppx"</code> (see <code><a href="#topic+ppx">ppx</a></code>)
represents a marked point pattern
in multidimensional space and/or time. There may be any
number of spatial coordinates, any number of temporal coordinates,
and any number of mark variables. The individual marks may be
atomic (numeric values, factor values, etc) or objects of any kind.
</p>
<p>The function <code>as.hyperframe.ppx</code> extracts the coordinates
and the marks as a <code>"hyperframe"</code> (see
<code><a href="#topic+hyperframe">hyperframe</a></code>) with one row of data for each
point in the pattern. This is a method for the generic
function <code><a href="#topic+as.hyperframe">as.hyperframe</a></code>.
</p>
<p>The function <code>as.data.frame.ppx</code> discards those mark variables
which are not atomic values, and extracts the coordinates
and the remaining marks as a <code>data.frame</code>
with one row of data for each
point in the pattern. This is a method for the generic
function <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.
</p>
<p>Finally <code>as.matrix(x)</code> is equivalent to
<code>as.matrix(as.data.frame(x))</code> for an object of class
<code>"ppx"</code>. Be warned that, if there are any columns of non-numeric
data (i.e. if there are mark variables that are factors),
the result will be a matrix of character values.
</p>


<h3>Value</h3>

<p>A <code>hyperframe</code>, <code>data.frame</code> or <code>matrix</code> as appropriate.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppx">ppx</a></code>,
<code><a href="#topic+hyperframe">hyperframe</a></code>,
<code><a href="#topic+as.hyperframe">as.hyperframe</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   df &lt;- data.frame(x=runif(4),y=runif(4),t=runif(4))
   X &lt;- ppx(data=df, coord.type=c("s","s","t"))
   as.data.frame(X)

   # ppx with marks which are point patterns
   val &lt;- runif(4, max=10)
   num &lt;- sapply(val, rpois, n=1)
   E &lt;- lapply(num, runifrect)
   hf &lt;- hyperframe(t=val, e=as.listof(E))
   Z &lt;- ppx(data=hf, domain=c(0,10))

   # convert ppx to a hyperframe
   as.hyperframe(Z)
   as.data.frame(Z)
</code></pre>

<hr>
<h2 id='as.im'>Convert to Pixel Image</h2><span id='topic+as.im'></span><span id='topic+as.im.im'></span><span id='topic+as.im.owin'></span><span id='topic+as.im.matrix'></span><span id='topic+as.im.tess'></span><span id='topic+as.im.function'></span><span id='topic+as.im.funxy'></span><span id='topic+as.im.expression'></span><span id='topic+as.im.distfun'></span><span id='topic+as.im.nnfun'></span><span id='topic+as.im.data.frame'></span><span id='topic+as.im.default'></span>

<h3>Description</h3>

<p>Converts various kinds of data to a pixel image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.im(X, ...)

  ## S3 method for class 'im'
as.im(X, W=NULL, ...,
        eps=NULL, dimyx=NULL, xy=NULL,
        rule.eps=c("adjust.eps", "grow.frame", "shrink.frame"),
        na.replace=NULL)

  ## S3 method for class 'owin'
as.im(X, W=NULL, ...,
        eps=NULL, dimyx=NULL, xy=NULL,
        rule.eps=c("adjust.eps", "grow.frame", "shrink.frame"),
        na.replace=NULL, value=1)

  ## S3 method for class 'matrix'
as.im(X, W=NULL, ...)

  ## S3 method for class 'tess'
as.im(X, W=NULL, ..., 
        eps=NULL, dimyx=NULL, xy=NULL,
        rule.eps=c("adjust.eps", "grow.frame", "shrink.frame"),
        na.replace=NULL, values=NULL)

  ## S3 method for class 'function'
as.im(X, W=NULL, ...,
        eps=NULL, dimyx=NULL, xy=NULL,
        rule.eps=c("adjust.eps", "grow.frame", "shrink.frame"),
        na.replace=NULL,
        stringsAsFactors=NULL,
        strict=FALSE, drop=TRUE)

  ## S3 method for class 'funxy'
as.im(X, W=Window(X), ...)

  ## S3 method for class 'expression'
as.im(X, W=NULL, ...)

  ## S3 method for class 'distfun'
as.im(X, W=NULL, ...,
        eps=NULL, dimyx=NULL, xy=NULL,
        rule.eps=c("adjust.eps", "grow.frame", "shrink.frame"),
        na.replace=NULL, approx=TRUE)

  ## S3 method for class 'nnfun'
as.im(X, W=NULL, ...,
        eps=NULL, dimyx=NULL, xy=NULL,
        rule.eps=c("adjust.eps", "grow.frame", "shrink.frame"),
        na.replace=NULL, approx=TRUE)

  ## S3 method for class 'data.frame'
as.im(X, ..., step, fatal=TRUE, drop=TRUE)

  ## Default S3 method:
as.im(X, W=NULL, ...,
        eps=NULL, dimyx=NULL, xy=NULL,
        rule.eps=c("adjust.eps", "grow.frame", "shrink.frame"),
        na.replace=NULL)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.im_+3A_x">X</code></td>
<td>
<p>Data to be converted to a pixel image.</p>
</td></tr>
<tr><td><code id="as.im_+3A_w">W</code></td>
<td>
<p>Window object which determines the spatial domain
and pixel array geometry.
</p>
</td></tr>
<tr><td><code id="as.im_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>X</code> when <code>X</code>
is a function.</p>
</td></tr>
<tr><td><code id="as.im_+3A_eps">eps</code>, <code id="as.im_+3A_dimyx">dimyx</code>, <code id="as.im_+3A_xy">xy</code>, <code id="as.im_+3A_rule.eps">rule.eps</code></td>
<td>

<p>Optional parameters passed to <code><a href="#topic+as.mask">as.mask</a></code>
which determine the pixel array geometry.
See <code><a href="#topic+as.mask">as.mask</a></code>.
</p>
</td></tr>
<tr><td><code id="as.im_+3A_na.replace">na.replace</code></td>
<td>
<p>Optional value to replace <code>NA</code> entries in the
output image.
</p>
</td></tr>
<tr><td><code id="as.im_+3A_value">value</code></td>
<td>
<p>Optional.
The value to be assigned to pixels inside the window,
if <code>X</code> is a window. A single atomic value (numeric, integer,
logical etc).
</p>
</td></tr>
<tr><td><code id="as.im_+3A_values">values</code></td>
<td>
<p>Optional.
Vector of values to be assigned to each tile of the tessellation,
when <code>X</code> is a tessellation. An atomic vector (numeric,
integer, logical etc.)
</p>
</td></tr>
<tr><td><code id="as.im_+3A_strict">strict</code></td>
<td>

<p>Logical value indicating whether to match formal arguments
of <code>X</code> when <code>X</code> is a function. If <code>strict=FALSE</code>
(the default), all the <code>...</code> arguments are passed to
<code>X</code>. If <code>strict=TRUE</code>, only named arguments
are passed, and only if they match the names of formal arguments of
<code>X</code>. 
</p>
</td></tr>
<tr><td><code id="as.im_+3A_step">step</code></td>
<td>

<p>Optional. A single number, or numeric vector of length 2,
giving the grid step lengths
in the <code class="reqn">x</code> and <code class="reqn">y</code> directions.
</p>
</td></tr>
<tr><td><code id="as.im_+3A_fatal">fatal</code></td>
<td>

<p>Logical value indicating what to do if the resulting image
would be too large for available memory. If <code>fatal=TRUE</code> (the
default), an error occurs. If <code>fatal=FALSE</code>, a warning is
issued and <code>NULL</code> is returned.
</p>
</td></tr>
<tr><td><code id="as.im_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating what to do if the result would
normally be a list of pixel images but the list contains
only one image.
If <code>drop=TRUE</code> (the default), the pixel image is extracted
and the result is a pixel image.
If <code>drop=FALSE</code>, this list is returned as the result.
</p>
</td></tr>
<tr><td><code id="as.im_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>

<p>Logical value (passed to <code><a href="base.html#topic+data.frame">data.frame</a></code>)
specifying how to handle pixel values which
are character strings. If <code>TRUE</code>, character values are
interpreted as factor levels. If <code>FALSE</code>, they remain
as character strings. The default depends on the version of <span class="rlang"><b>R</b></span>.
See section <em>Handling Character Strings</em>.
</p>
</td></tr>
<tr><td><code id="as.im_+3A_approx">approx</code></td>
<td>

<p>Logical value indicating whether to compute an approximate result
at faster speed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts the data <code>X</code> into a pixel image
object of class <code>"im"</code> (see <code><a href="#topic+im.object">im.object</a></code>).
The function <code>as.im</code> is generic, with methods for the classes
listed above.
</p>
<p>Currently <code>X</code> may be any of the following:
</p>

<ul>
<li>
<p>a pixel image object, of class <code>"im"</code>.
</p>
</li>
<li>
<p>a window object, of class <code>"owin"</code> (see
<code><a href="#topic+owin.object">owin.object</a></code>). The result is an image
with all pixel entries equal to <code>value</code> inside the window <code>X</code>,
and <code>NA</code> outside.
</p>
</li>
<li>
<p>a matrix. 
</p>
</li>
<li>
<p>a tessellation (object of class <code>"tess"</code>).
By default, the result is a factor-valued image, with one factor level
corresponding to each tile of the tessellation. Pixels are classified
according to the tile of the tessellation into which they fall.
If argument <code>values</code> is given, the result is a pixel image
in which every pixel inside the <code>i</code>-th tile of the tessellation
has pixel value equal to <code>values[i]</code>.
</p>
</li>
<li>
<p>a single number (or a single logical, complex, factor or character
value). The result is an image
with all pixel entries equal to this constant value
inside the window <code>W</code> (and <code>NA</code> outside, unless the
argument <code>na.replace</code> is given).
Argument <code>W</code> is required.
</p>
</li>
<li>
<p>a function of the form <code>function(x, y, ...)</code>
which is to be evaluated to yield the image pixel values.
In this case, the additional argument <code>W</code> must be present.
This window will be converted to
a binary image mask. Then the function <code>X</code> will be evaluated
in the form <code>X(x, y, ...)</code> where <code>x</code> and <code>y</code> are
<b>vectors</b> containing the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates
of all the pixels in the image mask, and <code>...</code> are any extra
arguments given. This function must return a
vector or factor of the same length as the input vectors,
giving the pixel values.
</p>
</li>
<li>
<p>an object of class <code>"funxy"</code> representing a
<code>function(x,y,...)</code> defined in a spatial region.
The function will be evaluated as described above.
The window <code>W</code> defaults to the domain of definition of the
function.
</p>
</li>
<li>
<p>an object of class <code>"funxy"</code> which also belongs to one of
the following special classes. If <code>approx=TRUE</code> (the default),
the function will be evaluated approximately using a very fast
algorithm. If <code>approx=FALSE</code>, the function will be evaluated
exactly at each grid location as described above.
</p>

<ul>
<li>
<p>an object of class <code>"distfun"</code> representing a distance function
(created by the command <code><a href="#topic+distfun">distfun</a></code>).
The fast approximation is 
the distance transform <code><a href="#topic+distmap">distmap</a></code>.
</p>
</li>
<li>
<p>an object of class <code>"nnfun"</code>
representing a nearest neighbour function
(created by the command <code><a href="#topic+nnfun">nnfun</a></code>).
The fast approximation is <code><a href="#topic+nnmap">nnmap</a></code>.
</p>
</li>
<li>
<p>an object of class <code>"densityfun"</code> representing a kernel
estimate of intensity (created by
the command <code><a href="spatstat.explore.html#topic+densityfun">densityfun</a></code>).
The fast approximation is the Fast Fourier Transform
algorithm in <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>.
</p>
</li>
<li>
<p>an object of class <code>"Smoothfun"</code> 
representing kernel-smoothed values
(created by the command <code><a href="spatstat.explore.html#topic+Smoothfun">Smoothfun</a></code>).
The fast approximation is the Fast Fourier Transform
algorithm in <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>.
</p>
</li></ul>

</li>
<li>
<p>An <code>expression</code> involving the variables <code>x</code> and <code>y</code>
representing the spatial coordinates, and possibly also involving other
variables.
The additional argument <code>W</code> must be present; it will be converted to
a binary image mask. The expression <code>X</code> will be evaluated
in an environment where <code>x</code> and <code>y</code> are
<b>vectors</b> containing the spatial coordinates
of all the pixels in the image mask.
Evaluation of the expression <code>X</code> must yield a vector or factor,
of the same length as <code>x</code> and <code>y</code>, giving the pixel values.
</p>
</li>
<li>
<p>a list with entries <code>x, y, z</code> in the format expected by
the standard <code>R</code> functions
<code><a href="graphics.html#topic+image.default">image.default</a></code> and <code><a href="graphics.html#topic+contour.default">contour.default</a></code>.
That is, <code>z</code> is a matrix of pixel values, <code>x</code> and <code>y</code>
are vectors of <code class="reqn">x</code> and <code class="reqn">y</code> coordinates respectively,
and <code>z[i,j]</code> is the pixel value for the location
<code>(x[i],y[j])</code>.
</p>
</li>
<li>
<p>a point pattern (object of class <code>"ppp"</code>).
See the separate documentation for <code><a href="#topic+as.im.ppp">as.im.ppp</a></code>.
</p>
</li>
<li>
<p>A data frame with at least three columns.
Columns named <code>x</code>, <code>y</code> and <code>z</code>, if present,
will be assumed to contain the spatial coordinates and the pixel
values, respectively. Otherwise the <code>x</code> and <code>y</code>
coordinates will be taken from the first two columns of the
data frame, and any remaining columns will be interpreted as
pixel values.
</p>
</li></ul>

<p>The spatial domain (enclosing rectangle) of the pixel image
is determined by the argument <code>W</code>. If <code>W</code> is absent, 
the spatial domain is determined by <code>X</code>.
When <code>X</code> is a function, a matrix, or a single numerical value,
<code>W</code> is required.
</p>
<p>The pixel array dimensions of the final resulting image are determined
by (in priority order)
</p>

<ul>
<li><p> the argument <code>eps</code>, <code>dimyx</code> or <code>xy</code> if present;
</p>
</li>
<li><p> the pixel dimensions of the window <code>W</code>, if it is
present and if it is a binary mask;
</p>
</li>
<li><p> the pixel dimensions of <code>X</code> if it is an image,
a binary mask, or a <code>list(x,y,z)</code>;
</p>
</li>
<li><p> the default pixel dimensions, 
controlled by <code><a href="#topic+spatstat.options">spatstat.options</a></code>.
</p>
</li></ul>

<p>Note that if <code>eps</code>, <code>dimyx</code> or <code>xy</code>
is given, this will override
the pixel dimensions of <code>X</code> if it has them.
Thus, <code>as.im</code> can be used to change an image's pixel dimensions.
</p>
<p>If the argument <code>na.replace</code> is given, then all <code>NA</code> entries
in the image will be replaced by this value.  The resulting image is
then defined everwhere on the full rectangular domain, instead of a
smaller window. Here <code>na.replace</code> should be a single value,
of the same type as the other entries in the image.
</p>
<p>If <code>X</code> is a pixel image that was created by an older version
of <span class="pkg">spatstat</span>, the command <code>X &lt;- as.im(X)</code> will
repair the internal format of <code>X</code> so that it conforms to the
current version of <span class="pkg">spatstat</span>.
</p>
<p>If <code>X</code> is a data frame with <code>m</code> columns,
then <code>m-2</code> columns of data are interpreted as pixel values,
yielding <code>m-2</code> pixel images. The result of
<code>as.im.data.frame</code> is a list of pixel
images, belonging to the class <code>"imlist"</code>.
If <code>m = 3</code> and <code>drop=TRUE</code> (the default), then the
result is a pixel image rather than a list containing this image.
</p>
<p>If <code>X</code> is a <code>function(x,y)</code> which returns a matrix of
values, then <code>as.im(X, W)</code> will be a list of pixel images.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>),
or a list of pixel images, 
or <code>NULL</code> if the conversion failed.
</p>


<h3>Character-valued images</h3>

<p>By default, if the pixel value data are character strings, they will be
treated as levels of a factor, and the resulting image will be
factor-valued. To prevent the conversion of character strings to
factors, use the argument <code>stringsAsFactors=FALSE</code>,
which is recognised by most of the
methods for <code>as.im</code>, or alternatively set
<code>options(stringsAsFactors=FALSE)</code>.
</p>


<h3>Handling Character Strings</h3>

<p>The argument <code>stringsAsFactors</code>
is a logical value (passed to <code><a href="base.html#topic+data.frame">data.frame</a></code>)
specifying how to handle pixel values which
are character strings. If <code>TRUE</code>, character values are
interpreted as factor levels. If <code>FALSE</code>, they remain
as character strings. The default values of <code>stringsAsFactors</code>
depends on the version of <span class="rlang"><b>R</b></span>.
</p>

<ul>
<li><p> In <span class="rlang"><b>R</b></span> versions <code>&lt; 4.1.0</code>
the factory-fresh default is <code>stringsAsFactors=FALSE</code> and
the default can be changed by setting
<code>options(stringsAsFactors=FALSE)</code>.
</p>
</li>
<li><p> In <span class="rlang"><b>R</b></span> versions <code>&gt;= 4.1.0</code> the default
is <code>stringsAsFactors=FALSE</code> and there is no option to
change the default.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p>Separate documentation for <code><a href="#topic+as.im.ppp">as.im.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # window object
  W &lt;- Window(demopat)
  plot(W)
  Z &lt;- as.im(W)
  image(Z)
  # function
  Z &lt;- as.im(function(x,y) {x^2 + y^2}, unit.square())
  image(Z)
  # or as an expression
  Z &lt;- as.im(expression(x^2+y^2), square(1))

  # function with extra arguments
  f &lt;- function(x, y, x0, y0) {
      sqrt((x - x0)^2 + (y-y0)^2)
  }
  Z &lt;- as.im(f, unit.square(), x0=0.5, y0=0.5)
  image(Z)

  # Revisit the Sixties
  Z &lt;- as.im(f, letterR, x0=2.5, y0=2)
  image(Z)
  # usual convention in R
  stuff &lt;- list(x=1:10, y=1:10, z=matrix(1:100, nrow=10))
  Z &lt;- as.im(stuff)
  # convert to finer grid
  Z &lt;- as.im(Z, dimyx=256)

  #' distance functions
  d &lt;- distfun(redwood)
  Zapprox &lt;- as.im(d)
  Zexact &lt;- as.im(d, approx=FALSE)
  plot(solist(approx=Zapprox, exact=Zexact), main="")

  # pixellate the Dirichlet tessellation
  Di &lt;- dirichlet(redwood)
  plot(as.im(Di))
  plot(Di, add=TRUE, border="white")

  # as.im.data.frame is the reverse of as.data.frame.im
  grad &lt;- bei.extra$grad
  slopedata &lt;- as.data.frame(grad)
  slope &lt;- as.im(slopedata)
  unitname(grad) &lt;- unitname(slope) &lt;- unitname(grad) # for compatibility
  all.equal(slope, grad) # TRUE

  ## handling of character values
  as.im("a", W=letterR, na.replace="b")
  as.im("a", W=letterR, na.replace="b", stringsAsFactors=FALSE)
</code></pre>

<hr>
<h2 id='as.layered'>Convert Data To Layered Object</h2><span id='topic+as.layered'></span><span id='topic+as.layered.default'></span><span id='topic+as.layered.ppp'></span><span id='topic+as.layered.splitppp'></span><span id='topic+as.layered.solist'></span><span id='topic+as.layered.listof'></span>

<h3>Description</h3>

<p>Converts spatial data into a layered object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> as.layered(X)

 ## Default S3 method:
as.layered(X)

 ## S3 method for class 'ppp'
as.layered(X)

 ## S3 method for class 'splitppp'
as.layered(X)

 ## S3 method for class 'solist'
as.layered(X)

 ## S3 method for class 'listof'
as.layered(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.layered_+3A_x">X</code></td>
<td>

<p>Some kind of spatial data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts the object <code>X</code>
into an object of class <code>"layered"</code>.
</p>
<p>The argument <code>X</code> should contain some kind of spatial data
such as a point pattern, window, or pixel image.
</p>
<p>If <code>X</code> is a simple object then it will be converted into
a <code>layered</code> object containing only one layer which is equivalent
to <code>X</code>.
</p>
<p>If <code>X</code> can be interpreted as consisting of
multiple layers of data, then the result will be a <code>layered</code>
object consisting of these separate layers of data.
</p>

<ul>
<li><p> if <code>X</code> is a list of class <code>"listof"</code> or <code>"solist"</code>,
then <code>as.layered(X)</code> consists of several layers,
one for each entry in the list <code>X</code>;
</p>
</li>
<li><p> if <code>X</code> is a multitype point pattern,
then <code>as.layered(X)</code> consists of several layers,
each containing the sub-pattern consisting of points of one type;
</p>
</li>
<li><p> if <code>X</code> is a vector-valued measure,
then <code>as.layered(X)</code> consists of several layers,
each containing a scalar-valued measure.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"layered"</code> (see <code><a href="#topic+layered">layered</a></code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+as.layered.msr">as.layered.msr</a></code>,
<code><a href="#topic+layered">layered</a></code>,
<code><a href="#topic+split.ppp">split.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   as.layered(cells)
   as.layered(amacrine)
</code></pre>

<hr>
<h2 id='as.mask'>Pixel Image Approximation of a Window</h2><span id='topic+as.mask'></span>

<h3>Description</h3>

<p>Obtain a discrete (pixel image) approximation of a given window
</p>


<h3>Usage</h3>

<pre><code class='language-R'> as.mask(w, eps=NULL, dimyx=NULL, xy=NULL,
         rule.eps=c("adjust.eps", "grow.frame", "shrink.frame"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mask_+3A_w">w</code></td>
<td>

<p>A window (object of class <code>"owin"</code>) or data acceptable
to <code><a href="#topic+as.owin">as.owin</a></code>.
</p>
</td></tr>
<tr><td><code id="as.mask_+3A_eps">eps</code></td>
<td>

<p>(optional) width and height of pixels.
A single number, or a numeric vector of length 2.
</p>
</td></tr>
<tr><td><code id="as.mask_+3A_dimyx">dimyx</code></td>
<td>

<p>(optional) pixel array dimensions.
A single integer, or an integer vector of length 2
giving dimensions in the <em>y</em> and <em>x</em> directions.
</p>
</td></tr>
<tr><td><code id="as.mask_+3A_xy">xy</code></td>
<td>

<p>(optional) data containing pixel coordinates,
such as a pixel image (object of class <code>"im"</code>),
or a window of type <code>"mask"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="as.mask_+3A_rule.eps">rule.eps</code></td>
<td>

<p>Character string (partially matched) specifying what to do when
<code>eps</code> is not a divisor of the frame size.
Ignored if <code>eps</code> is missing or null. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A &lsquo;mask&rsquo; is a spatial window that is
represented by a pixel image with binary values.
It is an object of class <code>"owin"</code> with type <code>"mask"</code>.
</p>
<p>This function <code>as.mask</code> creates a representation of any spatial window
<code>w</code> as a mask. It generates a rectangular grid of
locations in the plane, tests whether each of these locations lies
inside <code>w</code>, and stores the results as a mask.
</p>
<p>The most common use of this function is to approximate the shape
of a rectangular or polygonal window <code>w</code> by a mask,
for computational purposes. In this case,
we will usually want to have a very fine grid of pixels.
</p>
<p>This function can also be used to generate a coarsely-spaced grid of
locations inside a window, for purposes such as subsampling
and prediction.
</p>
<p>The argument <code>w</code> should be a window (object of class
<code>"owin"</code>). If it is another kind of spatial data,
then the window information will be extracted using <code><a href="#topic+as.owin">as.owin</a></code>. 
</p>
<p>The grid spacing and location are controlled by the
arguments <code>eps</code>, <code>dimyx</code> and <code>xy</code>,
which are mutually incompatible. 
</p>
<p>If <code>eps</code> is given, then it specifies the <em>desired</em> grid spacing,
that is, the desired size of the pixels. If <code>eps</code> is a single number,
it specifies that the desired grid spacing is <code>eps</code>
in both the <code class="reqn">x</code> and <code class="reqn">y</code> directions, that is, the desired pixels are
squares with side length <code>eps</code>. If <code>eps</code> is a
vector of length 2, it specifies that the desired grid spacing is
<code>eps[1]</code> in the <code class="reqn">x</code> direction and 
<code>eps[2]</code> in the <code class="reqn">y</code> direction. That is, the desired pixels are
rectangles of width <code>eps[1]</code> and height <code>eps[2]</code>.
</p>
<p>When <code>eps</code> is given,
the argument <code>rule.eps</code> specifies what to do if pixels
of the desired size would not fit exactly into the
rectangular frame of <code>w</code>. 
</p>

<ul>
<li>
<p>if <code>rule.eps="adjust.eps"</code> (the default),
the rectangular frame will remain unchanged, and
the grid spacing (pixel size) <code>eps</code> will be reduced slightly
so that an integer number of pixels fits exactly into the frame.
</p>
</li>
<li><p> if <code>rule.eps="grow.frame"</code>,
the grid spacing (pixel size) <code>eps</code> will remain unchanged,
and the rectangular frame will be expanded slightly
so that it consists of an integer number of pixels in each direction.
</p>
</li>
<li><p> if <code>rule.eps="shrink.frame"</code>,
the grid spacing (pixel size) <code>eps</code> will remain unchanged,
and the rectangular frame will be contracted slightly
so that it consists of an integer number of pixels in each direction.
</p>
</li></ul>

<p>If <code>dimyx</code> is given, then the pixel grid will be an
<code class="reqn">m \times n</code> rectangular grid
where <code class="reqn">m, n</code> are given by <code>dimyx[2]</code>, <code>dimyx[1]</code>
respectively. <b>Warning:</b> <code>dimyx[1]</code> is the number of
pixels in the <code class="reqn">y</code> direction, and <code>dimyx[2]</code> is the number
in the <code class="reqn">x</code> direction. The grid spacing (pixel size) is determined
by the frame size and the number of pixels.
</p>
<p>If <code>xy</code> is given, then this should be some kind of
data specifing the coordinates of a pixel grid. It may be
</p>

<ul>
<li> 
<p>a list or structure containing elements <code>x</code> and <code>y</code>
which are numeric vectors of equal length. These will be taken as
<code class="reqn">x</code> and <code>y</code> coordinates of the margins
of the grid. The pixel coordinates will be generated
from these two vectors.
</p>
</li>
<li>
<p>a pixel image (object of class <code>"im"</code>).
</p>
</li>
<li>
<p>a window (object of class <code>"owin"</code>) which is
of type <code>"mask"</code> so that it contains pixel coordinates.
</p>
</li></ul>

<p>If <code>xy</code> is given and is either a pixel image or a mask,
then <code>w</code> may be omitted, and the window
information will be extracted from <code>xy</code>.
</p>
<p>If neither <code>eps</code> nor <code>dimyx</code> nor <code>xy</code> is given,
the pixel raster dimensions are obtained from
<code><a href="#topic+spatstat.options">spatstat.options</a>("npixel")</code>.
</p>
<p>There is no inverse of this function. However, the function
<code><a href="#topic+as.polygonal">as.polygonal</a></code> will compute a polygonal approximation
of a binary mask.
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>)
of type <code>"mask"</code> representing a binary pixel image.
</p>


<h3>Discretisation rule</h3>

<p>The rule used in <code>as.mask</code> is that a pixel is part of the
discretised window if and only if the centre of the pixel falls in the
original window. This is usually sufficient for most purposes,
and is fast to compute.
</p>
<p>Other discretisation rules are possible; they are available using the
function <code><a href="#topic+owin2mask">owin2mask</a></code>.
</p>


<h3>Converting a spatial pattern to a mask</h3>

<p>If the intention is to discretise or pixellate a spatial pattern,
such as a point pattern, line segment pattern or a linear network, then
<code>as.mask</code> is not the appropriate function to use, because
<code>as.mask</code> extracts only the window information and converts this
window to a mask.
</p>
<p>To discretise a point pattern,
use <code><a href="#topic+pixellate.ppp">pixellate.ppp</a></code>. To discretise a line segment pattern,
use <code><a href="#topic+pixellate.psp">pixellate.psp</a></code> or <code><a href="#topic+psp2mask">psp2mask</a></code>.
To discretise a linear network, use
<code><a href="spatstat.linnet.html#topic+methods.linnet">pixellate.linnet</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin2mask">owin2mask</a></code>.
</p>
<p><code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+as.rectangle">as.rectangle</a></code>,
<code><a href="#topic+as.polygonal">as.polygonal</a></code>,
<code><a href="#topic+spatstat.options">spatstat.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- owin(c(0,10),c(0,10), poly=list(x=c(1,2,3,2,1), y=c(2,3,4,6,7)))
  m &lt;- as.mask(w)
  if(interactive()) {
     plot(w)
     plot(m)
  }
  x &lt;- 1:9
  y &lt;- seq(0.25, 9.75, by=0.5)
  m &lt;- as.mask(w, xy=list(x=x, y=y))

  B &lt;- square(1)
  as.mask(B, eps=0.3)
  as.mask(B, eps=0.3, rule.eps="g")
  as.mask(B, eps=0.3, rule.eps="s")
</code></pre>

<hr>
<h2 id='as.matrix.im'>Convert Pixel Image to Matrix or Array</h2><span id='topic+as.matrix.im'></span><span id='topic+as.array.im'></span>

<h3>Description</h3>

<p>Converts a pixel image to a matrix or an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
as.matrix(x, ...)
  ## S3 method for class 'im'
as.array(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.im_+3A_x">x</code></td>
<td>
<p>A pixel image (object of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="as.matrix.im_+3A_...">...</code></td>
<td>
<p>See below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>as.matrix.im</code> converts the pixel image <code>x</code>
into a matrix containing the pixel values.
It is handy when you want to extract a summary of the pixel values.
See the Examples.
</p>
<p>The function <code>as.array.im</code> converts the pixel image to an array.
By default this is a three-dimensional array of dimension <code class="reqn">n</code> by
<code class="reqn">m</code> by <code class="reqn">1</code>. 
If the extra arguments <code>...</code> are given, they will be passed
to <code><a href="base.html#topic+array">array</a></code>, and they may change the dimensions of the
array.
</p>


<h3>Value</h3>

<p>A matrix or array.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.owin">as.matrix.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # artificial image
   Z &lt;- setcov(square(1))

   M &lt;- as.matrix(Z)

   median(M)
   
   # plot the cumulative distribution function of pixel values
   # plot(ecdf(as.matrix(Z)))
</code></pre>

<hr>
<h2 id='as.matrix.owin'>Convert Pixel Image to Matrix</h2><span id='topic+as.matrix.owin'></span>

<h3>Description</h3>

<p>Converts a pixel image to a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'owin'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.owin_+3A_x">x</code></td>
<td>
<p>A window (object of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="as.matrix.owin_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to control the
pixel resolution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>as.matrix.owin</code> converts a window to a
logical matrux.
</p>
<p>It first converts the window <code>x</code> into a binary pixel mask
using <code><a href="#topic+as.mask">as.mask</a></code>. It then extracts the pixel entries
as a logical matrix.
</p>
<p>The resulting matrix has entries that are
<code>TRUE</code> if the corresponding pixel is inside the window,
and <code>FALSE</code> if it is outside.
</p>
<p>The function <code>as.matrix</code> is generic. The function
<code>as.matrix.owin</code>
is the method for windows (objects of class <code>"owin"</code>).
</p>
<p>Use <code><a href="#topic+as.im">as.im</a></code> to convert a window to a pixel image.
</p>


<h3>Value</h3>

<p>A logical matrix.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.im">as.matrix.im</a></code>,
<code><a href="#topic+as.im">as.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- as.matrix(letterR)
</code></pre>

<hr>
<h2 id='as.owin'>Convert Data To Class owin</h2><span id='topic+as.owin'></span><span id='topic+as.owin.default'></span><span id='topic+as.owin.owin'></span><span id='topic+as.owin.ppp'></span><span id='topic+as.owin.psp'></span><span id='topic+as.owin.quad'></span><span id='topic+as.owin.quadratcount'></span><span id='topic+as.owin.tess'></span><span id='topic+as.owin.im'></span><span id='topic+as.owin.layered'></span><span id='topic+as.owin.data.frame'></span><span id='topic+as.owin.distfun'></span><span id='topic+as.owin.nnfun'></span><span id='topic+as.owin.funxy'></span><span id='topic+as.owin.boxx'></span>

<h3>Description</h3>

<p>Converts data specifying an observation window
in any of several formats, into an object of class <code>"owin"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> as.owin(W, ..., fatal=TRUE)

 ## Default S3 method:
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'owin'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'ppp'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'psp'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'quad'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'quadratcount'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'tess'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'im'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'layered'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'data.frame'
as.owin(W, ..., step, fatal=TRUE)

 ## S3 method for class 'distfun'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'nnfun'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'funxy'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'boxx'
as.owin(W, ..., fatal=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.owin_+3A_w">W</code></td>
<td>

<p>Data specifying an observation window, in any of several formats
described under <em>Details</em> below.
</p>
</td></tr>
<tr><td><code id="as.owin_+3A_fatal">fatal</code></td>
<td>

<p>Logical value determining what to do
if the data cannot be converted to an observation window.
See Details.
</p>
</td></tr>
<tr><td><code id="as.owin_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="as.owin_+3A_step">step</code></td>
<td>

<p>Optional. A single number, or numeric vector of length 2,
giving the grid step lengths
in the <code class="reqn">x</code> and <code class="reqn">y</code> directions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>"owin"</code> is a way of specifying the observation window
for a point pattern. See <code><a href="#topic+owin.object">owin.object</a></code> for an overview.
</p>
<p>The generic function <code>as.owin</code> converts data in any of several formats 
into an object of class <code>"owin"</code> for use by the <span class="pkg">spatstat</span>
package. The function <code>as.owin</code> is generic, with methods
for different classes of objects, and a default method.
</p>
<p>The argument <code>W</code> may be
</p>

<ul>
<li>
<p>an object of class <code>"owin"</code>
</p>
</li>
<li>
<p>a structure with entries <code>xrange</code>, <code>yrange</code> specifying the 
<code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle
</p>
</li>
<li>
<p>a structure with entries named <code>xmin</code>, <code>xmax</code>, <code>ymin</code>,
<code>ymax</code> (in any order) 
specifying the <code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle.
This will accept objects of class <code>bbox</code> in the <code>sf</code> package.
</p>
</li>
<li>
<p>a numeric vector of length 4
(interpreted as <code>(xmin, xmax, ymin, ymax)</code> in that order)
specifying the <code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle
</p>
</li>
<li>
<p>a structure with entries named <code>xl</code>, <code>xu</code>, <code>yl</code>, <code>yu</code>
(in any order)
specifying the <code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle
as <code>(xmin, xmax) = (xl, xu)</code> and 
<code>(ymin, ymax) = (yl, yu)</code>. This will accept objects of
class <code>spp</code> used in the Venables and Ripley <span class="pkg">spatial</span>
package.
</p>
</li>
<li>
<p>an object of class <code>"ppp"</code> representing a point pattern.
In this case, the object's <code>window</code> structure will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"psp"</code> representing a line segment pattern.
In this case, the object's <code>window</code> structure will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"tess"</code> representing a tessellation.
In this case, the object's <code>window</code> structure will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"quad"</code> representing a quadrature scheme.
In this case, the window of the <code>data</code> component will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"im"</code> representing a pixel image.
In this case, a window of type <code>"mask"</code> will be returned,
with the same pixel raster coordinates as the image.
An image pixel value of <code>NA</code>, signifying that the pixel
lies outside the window, is transformed into the logical value
<code>FALSE</code>, which is the corresponding convention for window masks.
</p>
</li>
<li>
<p>an object of class <code>"ppm"</code>, <code>"kppm"</code>, <code>"slrm"</code>
or <code>"dppm"</code>
representing a fitted point process
model. In this case, if <code>from="data"</code> (the default),
<code>as.owin</code> extracts the  original point
pattern data to which the model was fitted, and returns the
observation window of this point pattern. If
<code>from="covariates"</code> then <code>as.owin</code> extracts the
covariate images to which the model was fitted,
and returns a binary mask window that specifies the pixel locations.
</p>
</li>
<li>
<p>an object of class <code>"lpp"</code>
representing a point pattern on a linear network.
In this case, <code>as.owin</code> extracts the linear network
and returns a window containing this network. 
</p>
</li>
<li>
<p>an object of class <code>"lppm"</code>
representing a fitted point process model on a linear network.
In this case, <code>as.owin</code> extracts the linear network
and returns a window containing this network. 
</p>
</li>
<li>
<p>A <code>data.frame</code> with exactly three columns. Each row of the
data frame corresponds to one pixel. Each row contains the
<code class="reqn">x</code> and <code class="reqn">y</code> coordinates of a pixel, and a logical value
indicating whether the pixel lies inside the window.   
</p>
</li>
<li>
<p>A <code>data.frame</code> with exactly two columns. Each row of the
data frame contains the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates of a pixel
that lies inside the window.
</p>
</li>
<li>
<p>an object of class <code>"distfun"</code>, <code>"nnfun"</code>
or <code>"funxy"</code> representing a function of spatial location,
defined on a spatial domain. The spatial domain of the function will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"rmhmodel"</code> representing a
point process model that can be simulated using <code><a href="spatstat.random.html#topic+rmh">rmh</a></code>.
The window (spatial domain) of the model will be extracted.
The window may be <code>NULL</code> in some circumstances (indicating that the
simulation window has not yet been determined). This is not treated
as an error, because the argument <code>fatal</code> defaults to
<code>FALSE</code> for this method.
</p>
</li>
<li>
<p>an object of class <code>"layered"</code> representing a
list of spatial objects. See <code><a href="#topic+layered">layered</a></code>.
In this case, <code>as.owin</code> will be applied to each
of the objects in the list, and the union of these windows
will be returned.
</p>
</li>
<li>
<p>an object of another suitable class from another package.
For full details, see <code>vignette('shapefiles')</code>.
</p>
</li></ul>

<p>If the argument <code>W</code> is not in one of these formats
and cannot be converted to a window, then an error will
be generated (if <code>fatal=TRUE</code>) or a value of <code>NULL</code>
will be returned (if <code>fatal=FALSE</code>).
</p>
<p>When <code>W</code> is a data frame, the argument <code>step</code>
can be used to specify the pixel grid spacing; otherwise, the spacing
will be guessed from the data.
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code> (see <code><a href="#topic+owin.object">owin.object</a></code>)
specifying an observation window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+as.owin.ppm">as.owin.ppm</a></code>,
<code><a href="spatstat.random.html#topic+as.owin.rmhmodel">as.owin.rmhmodel</a></code>,
<code><a href="spatstat.linnet.html#topic+as.owin.lpp">as.owin.lpp</a></code>.
</p>
<p><code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+owin">owin</a></code>.
</p>
<p>Additional methods for <code>as.owin</code> may be provided
by other packages outside the <span class="pkg">spatstat</span> family.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> w &lt;- as.owin(c(0,1,0,1))
 w &lt;- as.owin(list(xrange=c(0,5),yrange=c(0,10)))
 # point pattern
 w &lt;- as.owin(demopat)
 # image
 Z &lt;- as.im(function(x,y) { x + 3}, unit.square())
 w &lt;- as.owin(Z)

 # Venables &amp; Ripley 'spatial' package
 spatialpath &lt;- system.file(package="spatial")
 if(nchar(spatialpath) &gt; 0) {
   require(spatial)
   towns &lt;- ppinit("towns.dat")
   w &lt;- as.owin(towns)
   detach(package:spatial)
 }
</code></pre>

<hr>
<h2 id='as.polygonal'>
Convert a Window to a Polygonal Window
</h2><span id='topic+as.polygonal'></span>

<h3>Description</h3>

<p>Given a window <code>W</code> of any geometric type (rectangular,
polygonal or binary mask),  this function returns a polygonal window
that represents the same spatial domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.polygonal(W, repair=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.polygonal_+3A_w">W</code></td>
<td>

<p>A window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="as.polygonal_+3A_repair">repair</code></td>
<td>

<p>Logical value indicating whether to check the validity
of the polygon data and repair it,
if <code>W</code> is already a polygonal window.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a window <code>W</code> of any geometric type (rectangular,
polygonal or binary mask),  this function returns a polygonal window
that represents the same spatial domain.
</p>
<p>If <code>W</code> is a rectangle, it is converted to a polygon with
4 vertices.
</p>
<p>If <code>W</code> is already polygonal, it is returned unchanged, by default.  
However if <code>repair=TRUE</code> then the validity of the polygonal coordinates
will be checked (for example to check the boundary is not self-intersecting)
and repaired if necessary, so that the result could be different
from <code>W</code>.
</p>
<p>If <code>W</code> is a binary mask, then each pixel in the
mask is replaced by a small square or rectangle, and the union of these
squares or rectangles is computed. The result is a polygonal window
that has only horizontal and vertical edges. 
(Use <code><a href="#topic+simplify.owin">simplify.owin</a></code> to remove the staircase
appearance, if desired).
</p>


<h3>Value</h3>

<p>A polygonal window (object of class <code>"owin"</code>
and of type <code>"polygonal"</code>). 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+as.mask">as.mask</a></code>,
<code><a href="#topic+simplify.owin">simplify.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   m &lt;- as.mask(letterR, dimyx=32)
   p &lt;- as.polygonal(m)
   if(interactive()) {
      plot(m)
      plot(p, add=TRUE, lwd=2)
   }
</code></pre>

<hr>
<h2 id='as.ppp'>Convert Data To Class ppp</h2><span id='topic+as.ppp'></span><span id='topic+as.ppp.ppp'></span><span id='topic+as.ppp.psp'></span><span id='topic+as.ppp.quad'></span><span id='topic+as.ppp.matrix'></span><span id='topic+as.ppp.data.frame'></span><span id='topic+as.ppp.default'></span>

<h3>Description</h3>

<p>Tries to coerce any reasonable kind of data to a spatial point pattern
(an object of class <code>"ppp"</code>)
for use by the <span class="pkg">spatstat</span> package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.ppp(X, ..., fatal=TRUE)

  ## S3 method for class 'ppp'
as.ppp(X, ..., fatal=TRUE)

  ## S3 method for class 'psp'
as.ppp(X, ..., fatal=TRUE)

  ## S3 method for class 'quad'
as.ppp(X, ..., fatal=TRUE)

  ## S3 method for class 'matrix'
as.ppp(X, W=NULL, ..., fatal=TRUE)

  ## S3 method for class 'data.frame'
as.ppp(X, W=NULL, ..., fatal=TRUE)

  ## Default S3 method:
as.ppp(X, W=NULL, ..., fatal=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ppp_+3A_x">X</code></td>
<td>
<p>Data which will be converted into a point pattern</p>
</td></tr>
<tr><td><code id="as.ppp_+3A_w">W</code></td>
<td>

<p>Data which define a window for the pattern,
when <code>X</code> does not contain a window.
(Ignored if <code>X</code> contains window information.)
</p>
</td></tr>
<tr><td><code id="as.ppp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="as.ppp_+3A_fatal">fatal</code></td>
<td>

<p>Logical value specifying what to do if the
data cannot be converted.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts the dataset <code>X</code> to a point pattern
(an object of class <code>"ppp"</code>; see <code><a href="#topic+ppp.object">ppp.object</a></code> for
an overview).
</p>
<p>This function is normally used to convert an existing point pattern
dataset, stored in another format, to the <code>"ppp"</code> format.
To create a new point pattern from raw data such as <code class="reqn">x,y</code>
coordinates, it is normally easier to use the creator function
<code><a href="#topic+ppp">ppp</a></code>.
</p>
<p>The function <code>as.ppp</code> is generic, with methods for the
classes <code>"ppp"</code>, <code>"psp"</code>, <code>"quad"</code>, <code>"matrix"</code>,
<code>"data.frame"</code> and a default method.
</p>
<p>The dataset <code>X</code> may be:
</p>

<ul>
<li>
<p>an object of class <code>"ppp"</code>  
</p>
</li>
<li>
<p>an object of class <code>"psp"</code>
</p>
</li>
<li>
<p>a point pattern object created by the <span class="pkg">spatial</span> library
</p>
</li>
<li>
<p>an object of class <code>"quad"</code> representing a quadrature scheme
(see <code><a href="#topic+quad.object">quad.object</a></code>)
</p>
</li>
<li>
<p>a matrix or data frame with at least two columns
</p>
</li>
<li>
<p>a structure with entries <code>x</code>, <code>y</code> which are numeric vectors
of equal length
</p>
</li>
<li>
<p>a numeric vector of length 2, interpreted as the coordinates
of a single point.
</p>
</li></ul>

<p>In the last three cases, we need the second argument <code>W</code>
which is converted to a window object
by the function <code><a href="#topic+as.owin">as.owin</a></code>.
In the first four cases, <code>W</code> will be ignored.
</p>
<p>If <code>X</code> is a line segment pattern (an object of class <code>psp</code>)
the point pattern returned consists of the endpoints of the segments.
If <code>X</code> is marked then the point pattern returned will also be
marked, the mark associated with a point being the mark of the segment
of which that point was an endpoint.
</p>
<p>If <code>X</code> is a matrix or data frame, the first and second columns will
be interpreted as the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates respectively.
Any additional columns will be interpreted as marks.
</p>
<p>The argument <code>fatal</code> indicates what to do when 
<code>W</code> is missing and <code>X</code> contains no
information about the window. If <code>fatal=TRUE</code>, a fatal error
will be generated; if <code>fatal=FALSE</code>, the
value <code>NULL</code> is returned.
</p>
<p>In the <span class="pkg">spatial</span> library, a point pattern is represented
in either of the following formats:
</p>

<ul>
<li>
<p>(in <span class="pkg">spatial</span> versions 1 to 6)
a structure with entries <code>x</code>, <code>y</code>
<code>xl</code>, <code>xu</code>, <code>yl</code>, <code>yu</code>
</p>
</li>
<li>
<p>(in <span class="pkg">spatial</span> version 7)
a structure with entries
<code>x</code>, <code>y</code> and <code>area</code>,
where <code>area</code> is a structure with entries
<code>xl</code>, <code>xu</code>, <code>yl</code>, <code>yu</code>
</p>
</li></ul>

<p>where <code>x</code> and <code>y</code> are vectors of equal length
giving the point coordinates, and <code>xl</code>, <code>xu</code>, <code>yl</code>,
<code>yu</code> are numbers giving the dimensions of a rectangular window.
</p>
<p>Point pattern datasets can also be created by the function
<code><a href="#topic+ppp">ppp</a></code>.
</p>
<p>Methods for <code>as.ppp</code> exist for some other classes of data;
they are listed by <code>methods(as.ppp)</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"ppp"</code> (see <code><a href="#topic+ppp.object">ppp.object</a></code>)
describing the point pattern and its window of observation.
The value <code>NULL</code> may also be returned; see Details.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp">ppp</a></code>, <code><a href="#topic+ppp.object">ppp.object</a></code>, <code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>.
</p>
<p>Methods for <code>as.ppp</code> exist for some other classes of data;
they are listed by <code>methods(as.ppp)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> xy &lt;- matrix(runif(40), ncol=2)
 pp &lt;- as.ppp(xy, c(0,1,0,1))

 # Venables-Ripley format
 # check for 'spatial' package
 spatialpath &lt;- system.file(package="spatial")
 if(nchar(spatialpath) &gt; 0) {
   require(spatial)
   towns &lt;- ppinit("towns.dat")
   pp &lt;- as.ppp(towns) # converted to our format
   detach(package:spatial)
 }

 xyzt &lt;- matrix(runif(40), ncol=4)
 Z &lt;- as.ppp(xyzt, square(1))
</code></pre>

<hr>
<h2 id='as.psp'>Convert Data To Class psp</h2><span id='topic+as.psp'></span><span id='topic+as.psp.psp'></span><span id='topic+as.psp.data.frame'></span><span id='topic+as.psp.matrix'></span><span id='topic+as.psp.default'></span>

<h3>Description</h3>

<p>Tries to coerce any reasonable kind of data object to a line segment pattern
(an object of class <code>"psp"</code>)
for use by the <span class="pkg">spatstat</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.psp(x, ..., from=NULL, to=NULL)

  ## S3 method for class 'psp'
as.psp(x, ..., check=FALSE, fatal=TRUE)

  ## S3 method for class 'data.frame'
as.psp(x, ..., window=NULL, marks=NULL,
      check=spatstat.options("checksegments"), fatal=TRUE)

  ## S3 method for class 'matrix'
as.psp(x, ..., window=NULL, marks=NULL,
       check=spatstat.options("checksegments"), fatal=TRUE)

  ## Default S3 method:
as.psp(x, ..., window=NULL, marks=NULL,
       check=spatstat.options("checksegments"), fatal=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.psp_+3A_x">x</code></td>
<td>
<p>Data which will be converted into a line segment pattern</p>
</td></tr>
<tr><td><code id="as.psp_+3A_window">window</code></td>
<td>
<p>Data which define a window for the pattern.</p>
</td></tr>
<tr><td><code id="as.psp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="as.psp_+3A_marks">marks</code></td>
<td>
<p>(Optional) vector or data frame of marks for the pattern</p>
</td></tr>
<tr><td><code id="as.psp_+3A_check">check</code></td>
<td>

<p>Logical value indicating whether to check the validity of the data,
e.g. to check that the line segments lie inside the window.
</p>
</td></tr>
<tr><td><code id="as.psp_+3A_fatal">fatal</code></td>
<td>
<p>Logical value. See Details.</p>
</td></tr>
<tr><td><code id="as.psp_+3A_from">from</code>, <code id="as.psp_+3A_to">to</code></td>
<td>
<p>Point patterns (object of class <code>"ppp"</code>)
containing the first and second endpoints (respectively) of each
segment. Incompatible with <code>x</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts the dataset <code>x</code> to a line segment pattern
(an object of class <code>"psp"</code>; see <code><a href="#topic+psp.object">psp.object</a></code> for
an overview).
</p>
<p>This function is normally used to convert an existing line segment pattern
dataset, stored in another format, to the <code>"psp"</code> format.
To create a new point pattern from raw data such as <code class="reqn">x,y</code>
coordinates, it is normally easier to use the creator function
<code><a href="#topic+psp">psp</a></code>.
</p>
<p>The dataset <code>x</code> may be:
</p>

<ul>
<li>
<p>an object of class <code>"psp"</code>  
</p>
</li>
<li>
<p>a data frame with at least 4 columns
</p>
</li>
<li><p> a structure (list) with elements named  <code>x0, y0,
    x1, y1</code> or elements named <code>xmid, ymid, length, angle</code>
and possibly a fifth element named <code>marks</code>
</p>
</li></ul>

<p>If <code>x</code> is a data frame the interpretation of its columns is
as follows:
</p>

<ul>
<li>
<p>If there are columns named <code>x0, y0, x1, y1</code> then these
will be interpreted as the coordinates of the endpoints of
the segments and used to form the <code>ends</code> component of
the <code>psp</code> object to be returned.
</p>
</li>
<li>
<p>If there are columns named <code>xmid, ymid, length, angle</code>
then these will be interpreted as the coordinates of the segment
midpoints, the lengths of the segments, and the orientations
of the segments in radians and used to form the <code>ends</code>
component of the <code>psp</code> object to be returned.
</p>
</li>
<li>
<p>If there is a column named <code>marks</code> then this will
be interpreted as the marks of the pattern provided that
the argument <code>marks</code> of this function is <code>NULL</code>.
If argument <code>marks</code> is not <code>NULL</code> then the value
of this argument is taken to be the marks of the pattern and
the column named <code>marks</code> is ignored (with a warning).
In either case the column named marks is deleted and omitted
from further consideration.
</p>
</li>
<li>
<p>If there is no column named <code>marks</code> and if the <code>marks</code>
argument of this function is <code>NULL</code>, and if after
interpreting 4 columns of <code>x</code> as determining the <code>ends</code>
component of the <code>psp</code> object to be returned, there remain
other columns of <code>x</code>, then these remaining columns will be
taken to form a data frame of marks for the <code>psp</code> object
to be returned.
</p>
</li></ul>

<p>If <code>x</code> is a structure (list) with elements named <code>x0,
  y0, x1, y1, marks</code> or <code>xmid, ymid, length, angle, marks</code>,
then the element named <code>marks</code> will be interpreted as the
marks of the pattern provide that the argument <code>marks</code> of
this function is <code>NULL</code>.  If this argument is non-<code>NULL</code>
then it is interpreted as the marks of the pattern and the element
<code>marks</code> of <code>x</code> is ignored &mdash; with a warning.
</p>
<p>Alternatively, you may specify two point patterns
<code>from</code> and <code>to</code> containing the first and second endpoints
of the line segments.
</p>
<p>The argument <code>window</code> is converted to a window object
by the function <code><a href="#topic+as.owin">as.owin</a></code>.
</p>
<p>The argument <code>fatal</code> indicates what to do when
the data cannot be converted to a line segment pattern.
If <code>fatal=TRUE</code>, a fatal error
will be generated; if <code>fatal=FALSE</code>, the
value <code>NULL</code> is returned.
</p>
<p>The function <code>as.psp</code> is generic, with methods for the
classes <code>"psp"</code>, <code>"data.frame"</code>, <code>"matrix"</code>
and a default method.
</p>
<p>Point pattern datasets can also be created by the function
<code><a href="#topic+psp">psp</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"psp"</code> (see <code><a href="#topic+psp.object">psp.object</a></code>)
describing the line segment pattern and its window of observation.
The value <code>NULL</code> may also be returned; see Details.
</p>


<h3>Warnings</h3>

<p>If only a proper subset of the names <code>x0,y0,x1,y1</code> or
<code>xmid,ymid,length,angle</code> appear amongst the names of the
columns of <code>x</code> where <code>x</code> is a data frame, then these
special names are ignored.
</p>
<p>For example if the names of the columns were
<code>xmid,ymid,length,degrees</code>, then these columns would be
interpreted as if the represented <code>x0,y0,x1,y1</code> in that order.
</p>
<p>Whether it gets used or not, column named <code>marks</code> is
<em>always</em> removed from <code>x</code> before any attempt to form the
<code>ends</code> component of the <code>psp</code> object that is returned.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp">psp</a></code>,
<code><a href="#topic+psp.object">psp.object</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>.
</p>
<p>See <code><a href="#topic+edges">edges</a></code> for extracting the edges of a polygonal window
as a <code>"psp"</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   mat &lt;- matrix(runif(40), ncol=4)
   mx &lt;- data.frame(v1=sample(1:4,10,TRUE),
                    v2=factor(sample(letters[1:4],10,TRUE),levels=letters[1:4]))
   a &lt;- as.psp(mat, window=owin(),marks=mx)
   mat &lt;- cbind(as.data.frame(mat),mx)
   b &lt;- as.psp(mat, window=owin()) # a and b are identical.
   stuff &lt;- list(xmid=runif(10),
                 ymid=runif(10),
                 length=rep(0.1, 10),
                 angle=runif(10, 0, 2 * pi))
   a &lt;- as.psp(stuff, window=owin())
   b &lt;- as.psp(from=runifrect(10), to=runifrect(10))
</code></pre>

<hr>
<h2 id='as.rectangle'>Window Frame</h2><span id='topic+as.rectangle'></span>

<h3>Description</h3>

<p>Extract the window frame of a window
or other spatial dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'> as.rectangle(w, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.rectangle_+3A_w">w</code></td>
<td>
<p>A window, or a dataset that has a window.
Either a window (object of class <code>"owin"</code>),
a pixel image (object of class <code>"im"</code>)
or other data determining such a window.
</p>
</td></tr>
<tr><td><code id="as.rectangle_+3A_...">...</code></td>
<td>

<p>Optional. Auxiliary data to help determine the window. If
<code>w</code> does not belong to a recognised class,
the arguments <code>w</code> and <code>...</code> 
are passed to <code><a href="#topic+as.owin">as.owin</a></code> to determine the window.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the quickest way to determine a bounding rectangle
for a spatial dataset.
</p>
<p>If <code>w</code> is a window, the function
just extracts the outer bounding rectangle
of <code>w</code> as given by its elements <code>xrange,yrange</code>.
</p>
<p>The function can also be applied to any spatial dataset that has a window:
for example, a point pattern (object of class <code>"ppp"</code>) or
a line segment pattern (object of class <code>"psp"</code>).
The bounding rectangle of the window of the dataset is extracted.
</p>
<p>Use the function <code><a href="#topic+boundingbox">boundingbox</a></code> to compute the <em>smallest</em>
bounding rectangle of a dataset.
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>)
of type <code>"rectangle"</code> representing a rectangle.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+boundingbox">boundingbox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- owin(c(0,10),c(0,10), poly=list(x=c(1,2,3,2,1), y=c(2,3,4,6,7)))
  r &lt;- as.rectangle(w)
  # returns a 10 x 10 rectangle

  as.rectangle(lansing)

  as.rectangle(copper$SouthLines)
</code></pre>

<hr>
<h2 id='as.solist'>
Convert List of Two-Dimensional Spatial Objects
</h2><span id='topic+as.solist'></span>

<h3>Description</h3>

<p>Given a list of two-dimensional spatial objects,
convert it to the class <code>"solist"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.solist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.solist_+3A_x">x</code></td>
<td>

<p>A list of objects, each representing a two-dimensional
spatial dataset.
</p>
</td></tr>
<tr><td><code id="as.solist_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+solist">solist</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command makes the list <code>x</code> into an object of class <code>"solist"</code>
(spatial object list).
See <code><a href="#topic+solist">solist</a></code> for details.
</p>
<p>The entries in the list <code>x</code> should be
two-dimensional spatial datasets
(not necessarily of the same class).
</p>


<h3>Value</h3>

<p>A list, usually of class <code>"solist"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+solist">solist</a></code>,
<code><a href="#topic+as.anylist">as.anylist</a></code>,
<code><a href="#topic+solapply">solapply</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- list(cells, Window(cells), setcov(Window(cells)))
  y &lt;- as.solist(x)
</code></pre>

<hr>
<h2 id='as.tess'>Convert Data To Tessellation</h2><span id='topic+as.tess'></span><span id='topic+as.tess.tess'></span><span id='topic+as.tess.im'></span><span id='topic+as.tess.owin'></span><span id='topic+as.tess.quadratcount'></span><span id='topic+as.tess.list'></span>

<h3>Description</h3>

<p>Converts data specifying a tessellation,
in any of several formats, into an object of class <code>"tess"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> as.tess(X)
 ## S3 method for class 'tess'
as.tess(X)
 ## S3 method for class 'im'
as.tess(X)
 ## S3 method for class 'owin'
as.tess(X)
 ## S3 method for class 'quadratcount'
as.tess(X)
 ## S3 method for class 'list'
as.tess(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.tess_+3A_x">X</code></td>
<td>
<p>Data to be converted to a tessellation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation is a collection of disjoint spatial regions
(called <em>tiles</em>) that fit together to form a larger spatial
region. This command creates an object of class <code>"tess"</code> that
represents a tessellation. 
</p>
<p>This function converts data in any of several formats 
into an object of class <code>"tess"</code> for use by the <span class="pkg">spatstat</span>
package.  The argument <code>X</code> may be
</p>

<ul>
<li>
<p>an object of class <code>"tess"</code>.
The object will be stripped of any extraneous attributes
and returned.
</p>
</li>
<li>
<p>a pixel image (object of class <code>"im"</code>) with pixel values that
are logical or factor values. Each level of the factor will
determine a tile of the tessellation.
</p>
</li>
<li>
<p>a window (object of class <code>"owin"</code>). The result will be a
tessellation consisting of a single tile.
</p>
</li>
<li>
<p>a set of quadrat counts (object of class <code>"quadratcount"</code>)
returned by the command <code><a href="#topic+quadratcount">quadratcount</a></code>.
The quadrats
used to generate the counts will be extracted and returned as a
tessellation.
</p>
</li>
<li>
<p>a quadrat test (object of class <code>"quadrattest"</code>)
returned by the command <code><a href="spatstat.explore.html#topic+quadrat.test">quadrat.test</a></code>. 
The quadrats
used to perform the test will be extracted and returned as a
tessellation.
</p>
</li>
<li>
<p>a list of windows (objects of class <code>"owin"</code>)
giving the tiles of the tessellation.
</p>
</li></ul>

<p>The function <code>as.tess</code> is generic, with methods for
various classes, as listed above.
</p>


<h3>Value</h3>

<p>An object of class <code>"tess"</code> specifying a tessellation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # pixel image
 v &lt;- as.im(function(x,y){factor(round(5 * (x^2 + y^2)))}, W=owin())
 levels(v) &lt;- letters[seq(length(levels(v)))]
 as.tess(v)
 # quadrat counts
 qNZ &lt;- quadratcount(nztrees, nx=4, ny=3)
 as.tess(qNZ)

</code></pre>

<hr>
<h2 id='bdist.pixels'>Distance to Boundary of Window</h2><span id='topic+bdist.pixels'></span>

<h3>Description</h3>

<p>Computes the distances from each pixel in a window to the boundary of the window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> bdist.pixels(w, ..., style=c("image", "matrix", "coords"), method=c("C", "interpreted"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdist.pixels_+3A_w">w</code></td>
<td>
<p>A window (object of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="bdist.pixels_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine
the pixel resolution.</p>
</td></tr>
<tr><td><code id="bdist.pixels_+3A_style">style</code></td>
<td>

<p>Character string (partially matched) determining the format of
the output: either <code>"matrix"</code>, <code>"coords"</code> or
<code>"image"</code>.
</p>
</td></tr>
<tr><td><code id="bdist.pixels_+3A_method">method</code></td>
<td>
<p>Choice of algorithm to use when <code>w</code> is polygonal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes, for each pixel <code class="reqn">u</code> in the
Frame containing the window <code>w</code>, the shortest distance
<code class="reqn">d(u, w^c)</code> from <code class="reqn">u</code> to the complement of
<code class="reqn">w</code>. This value is zero for pixels lying outside <code>w</code>,
and is positive for pixels inside <code>w</code>.
</p>
<p>If the window is a binary mask then the distance from each pixel
to the boundary is computed using the distance transform algorithm
<code><a href="#topic+distmap.owin">distmap.owin</a></code>. The result is equivalent to
<code>distmap(W, invert=TRUE)</code>.
</p>
<p>If the window is a rectangle or a polygonal region,
the grid of pixels is determined by the arguments <code>"\dots"</code> 
passed to <code><a href="#topic+as.mask">as.mask</a></code>. The distance from each pixel to the
boundary is calculated exactly, using analytic geometry.
This is slower but more accurate than in the case of a binary mask.
</p>
<p>For software testing purposes, there are two implementations
available when <code>w</code> is a polygon: the default is <code>method="C"</code>
which is much faster than <code>method="interpreted"</code>.
</p>
<p>To compute the distance from each pixel to the bounding rectangular frame
<code>Frame(W)</code>, use <code><a href="#topic+framedist.pixels">framedist.pixels</a></code>.
</p>


<h3>Value</h3>

<p>If <code>style="image"</code>, a pixel image (object of class <code>"im"</code>)
containing the distances from each pixel in the image raster
to the boundary of the window.
</p>
<p>If <code>style="matrix"</code>,
a matrix giving the distances.
Rows of this matrix correspond to
the <code class="reqn">y</code> coordinate and columns to the <code class="reqn">x</code> coordinate.
</p>
<p>If <code>style="coords"</code>, a list with three components
<code>x,y,z</code>, where <code>x,y</code> are vectors of length <code class="reqn">m,n</code>
giving the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates respectively,
and <code>z</code> is an <code class="reqn">m \times n</code> matrix such that
<code>z[i,j]</code> is the distance from <code>(x[i],y[j])</code> to the
boundary of the window. Rows of this matrix correspond to the
<code class="reqn">x</code> coordinate and columns to the <code class="reqn">y</code> coordinate.
This result can be plotted with <code>persp</code>, <code>image</code>
or <code>contour</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+framedist.pixels">framedist.pixels</a></code>
</p>
<p><code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+erosion">erosion</a></code>,
<code><a href="#topic+bdist.points">bdist.points</a></code>,
<code><a href="#topic+bdist.tiles">bdist.tiles</a></code>,
<code><a href="#topic+distmap.owin">distmap.owin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  u &lt;- owin(c(0,1),c(0,1))
  d &lt;- bdist.pixels(u, eps=0.01)
  image(d)
  d &lt;- bdist.pixels(u, eps=0.01, style="matrix")
  mean(d &gt;= 0.1)
  # value is approx (1 - 2 * 0.1)^2 = 0.64
  opa &lt;- par(mfrow=c(1,2))
  plot(bdist.pixels(letterR))
  plot(framedist.pixels(letterR))
  par(opa)
</code></pre>

<hr>
<h2 id='bdist.points'>Distance to Boundary of Window</h2><span id='topic+bdist.points'></span>

<h3>Description</h3>

<p>Computes the distances 
from each point of a point pattern
to the boundary of the window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> bdist.points(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdist.points_+3A_x">X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes, for each point <code class="reqn">x_i</code>
in the point pattern <code>X</code>, the shortest distance
<code class="reqn">d(x_i, W^c)</code> from <code class="reqn">x_i</code>
to the boundary of the window <code class="reqn">W</code> of observation.
</p>
<p>If the window <code>Window(X)</code> is of type <code>"rectangle"</code>
or <code>"polygonal"</code>, then these distances are computed by
analytic geometry and are exact, up to rounding errors.
If the window is of type <code>"mask"</code> then the distances
are computed using the real-valued distance transform,
which is an approximation with maximum error equal to the width
of one pixel in the mask.
</p>


<h3>Value</h3>

<p>A numeric vector, giving the distances from each point of the pattern
to the boundary of the window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bdist.pixels">bdist.pixels</a></code>,
<code><a href="#topic+bdist.tiles">bdist.tiles</a></code>,
<code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+erosion">erosion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- bdist.points(cells)
</code></pre>

<hr>
<h2 id='bdist.tiles'>Distance to Boundary of Window</h2><span id='topic+bdist.tiles'></span>

<h3>Description</h3>

<p>Computes the shortest distances 
from each tile in a tessellation
to the boundary of the window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> bdist.tiles(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdist.tiles_+3A_x">X</code></td>
<td>
<p>A tessellation (object of class <code>"tess"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes, for each tile <code class="reqn">s_i</code>
in the tessellation <code>X</code>, the shortest distance
from <code class="reqn">s_i</code>
to the boundary of the window <code class="reqn">W</code> containing the tessellation.
</p>


<h3>Value</h3>

<p>A numeric vector, 
giving the shortest distance from each tile in the tessellation
to the boundary of the window.
Entries of the vector correspond to the entries of <code>tiles(X)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+bdist.points">bdist.points</a></code>,
<code><a href="#topic+bdist.pixels">bdist.pixels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  P &lt;- runifrect(15)
  X &lt;- dirichlet(P)
  plot(X, col="red")
  B &lt;- bdist.tiles(X)
  # identify tiles that do not touch the boundary
  plot(X[B &gt; 0], add=TRUE, col="green", lwd=3)
</code></pre>

<hr>
<h2 id='beachcolours'>
Create Colour Scheme for a Range of Numbers
</h2><span id='topic+beachcolours'></span><span id='topic+beachcolourmap'></span>

<h3>Description</h3>

<p>Given a range of numerical values, this command creates a
colour scheme that would be appropriate if the numbers were
altitudes (elevation above or below sea level).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beachcolours(range, sealevel = 0, monochrome = FALSE,
             ncolours = if (monochrome) 16 else 64,
             nbeach = 1)
beachcolourmap(range, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beachcolours_+3A_range">range</code></td>
<td>

<p>Range of numerical values to be mapped.
A numeric vector of length 2.
</p>
</td></tr>
<tr><td><code id="beachcolours_+3A_sealevel">sealevel</code></td>
<td>

<p>Value that should be treated as zero.
A single number,
lying between <code>range[1]</code> and <code>range[2]</code>.
</p>
</td></tr>
<tr><td><code id="beachcolours_+3A_monochrome">monochrome</code></td>
<td>

<p>Logical. If <code>TRUE</code> then a greyscale colour map is
constructed. 
</p>
</td></tr>
<tr><td><code id="beachcolours_+3A_ncolours">ncolours</code></td>
<td>

<p>Number of distinct colours to use.
</p>
</td></tr>
<tr><td><code id="beachcolours_+3A_nbeach">nbeach</code></td>
<td>

<p>Number of colours that will be yellow.
</p>
</td></tr>
<tr><td><code id="beachcolours_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>beachcolours</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a range of numerical values, these commands create a
colour scheme that would be appropriate if the numbers were
altitudes (elevation above or below sea level).
</p>
<p>Numerical values close to zero are portrayed in green (representing
the waterline). Negative values are blue (representing water)
and positive values are yellow to red (representing land).
At least, these are the colours of land and sea in Western Australia.
This colour scheme was proposed by Baddeley et al (2005).
</p>
<p>The function <code>beachcolours</code> returns these colours
as a character vector, while <code>beachcolourmap</code>
returns a colourmap object.
</p>
<p>The argument <code>range</code> should be a numeric vector of
length 2 giving a range of numerical values.
</p>
<p>The argument <code>sealevel</code> specifies the height value that will
be treated as zero, and mapped to the colour green.
A vector of <code>ncolours</code> colours will be created,
of which <code>nbeach</code> colours will be green.
</p>
<p>The argument <code>monochrome</code> is included
for convenience when preparing publications.
If <code>monochrome=TRUE</code> the colour map will be 
a simple grey scale containing <code>ncolours</code>
shades from black to white.
</p>


<h3>Value</h3>

<p>For <code>beachcolours</code>, 
a character vector of length <code>ncolours</code> specifying colour values.
For <code>beachcolourmap</code>, a colour map (object of class <code>"colourmap"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colourmap">colourmap</a></code>, 
<code><a href="#topic+colourtools">colourtools</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(beachcolourmap(c(-2,2)))
</code></pre>

<hr>
<h2 id='border'>Border Region of a Window</h2><span id='topic+border'></span>

<h3>Description</h3>

<p>Computes the border region of a window,
that is, the region lying within a specified distance of the boundary
of a window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>border(w, r, outside=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="border_+3A_w">w</code></td>
<td>
<p>A window (object of class <code>"owin"</code>)
or something acceptable to <code><a href="#topic+as.owin">as.owin</a></code>.
</p>
</td></tr>
<tr><td><code id="border_+3A_r">r</code></td>
<td>
<p>Numerical value.</p>
</td></tr>
<tr><td><code id="border_+3A_outside">outside</code></td>
<td>
<p>Logical value determining whether to compute the
border outside or inside <code>w</code>.</p>
</td></tr>
<tr><td><code id="border_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+erosion">erosion</a></code>
(if <code>outside=FALSE</code>) or to <code><a href="#topic+dilation">dilation</a></code>
(if <code>outside=TRUE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default (if <code>outside=FALSE</code>),
the border region is the subset of <code>w</code>
lying within a distance <code>r</code> of the boundary of <code>w</code>.
It is computed by eroding <code>w</code> by the distance <code>r</code> (using
<code><a href="#topic+erosion">erosion</a></code>) and
subtracting this eroded window from the original window <code>w</code>.
</p>
<p>If <code>outside=TRUE</code>, the border region is the set of locations
outside <code>w</code> lying within a distance <code>r</code> of <code>w</code>.
It is computed by dilating <code>w</code> by the distance <code>r</code>
(using <code><a href="#topic+dilation">dilation</a></code>) and
subtracting the original window <code>w</code> from the dilated window.
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+erosion">erosion</a></code>,
<code><a href="#topic+dilation">dilation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rectangle
   u &lt;- unit.square()
   border(u, 0.1)
   border(u, 0.1, outside=TRUE)
# polygon
   
   plot(letterR)
   plot(border(letterR, 0.1), add=TRUE)
   plot(border(letterR, 0.1, outside=TRUE), add=TRUE)
   
</code></pre>

<hr>
<h2 id='bounding.box.xy'>Convex Hull of Points</h2><span id='topic+bounding.box.xy'></span>

<h3>Description</h3>

<p>Computes the smallest rectangle containing a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounding.box.xy(x, y=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounding.box.xy_+3A_x">x</code></td>
<td>

<p>vector of <code>x</code> coordinates of observed points,
or a 2-column matrix giving <code>x,y</code> coordinates,
or a list with components <code>x,y</code> giving coordinates
(such as a point pattern object of class <code>"ppp"</code>.)
</p>
</td></tr>
<tr><td><code id="bounding.box.xy_+3A_y">y</code></td>
<td>
<p>(optional) vector of <code>y</code> coordinates of observed points,
if <code>x</code> is a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an observed pattern of points with coordinates 
given by <code>x</code> and <code>y</code>, this function finds the smallest
rectangle, with sides parallel to the coordinate axes, that contains
all the points, and returns it as a window.
</p>


<h3>Value</h3>

<p>A window (an object of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+convexhull.xy">convexhull.xy</a></code>,
<code><a href="#topic+ripras">ripras</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- runif(30)
  y &lt;- runif(30)
  w &lt;- bounding.box.xy(x,y)
  plot(owin(), main="bounding.box.xy(x,y)")
  plot(w, add=TRUE)
  points(x,y)

  X &lt;- runifrect(30)
  plot(X, main="bounding.box.xy(X)")
  plot(bounding.box.xy(X), add=TRUE)
</code></pre>

<hr>
<h2 id='boundingbox'>
Bounding Box of a Window, Image, or Point Pattern
</h2><span id='topic+boundingbox'></span><span id='topic+boundingbox.default'></span><span id='topic+boundingbox.im'></span><span id='topic+boundingbox.owin'></span><span id='topic+boundingbox.ppp'></span><span id='topic+boundingbox.psp'></span><span id='topic+boundingbox.lpp'></span><span id='topic+boundingbox.linnet'></span><span id='topic+boundingbox.solist'></span>

<h3>Description</h3>

<p>Find the smallest rectangle containing a given window(s),
image(s) or point pattern(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundingbox(...)

## Default S3 method:
boundingbox(...)

## S3 method for class 'im'
boundingbox(...)

## S3 method for class 'owin'
boundingbox(...)

## S3 method for class 'ppp'
boundingbox(...)

## S3 method for class 'psp'
boundingbox(...)

## S3 method for class 'lpp'
boundingbox(...)

## S3 method for class 'linnet'
boundingbox(...)

## S3 method for class 'solist'
boundingbox(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundingbox_+3A_...">...</code></td>
<td>
<p>One or more windows (objects of class <code>"owin"</code>),
pixel images (objects of class <code>"im"</code>) or
point patterns (objects of class <code>"ppp"</code> or <code>"lpp"</code>)
or line segment patterns (objects of class <code>"psp"</code>)
or linear networks (objects of class <code>"linnet"</code>)
or any combination of such objects.
Alternatively, the argument may be a list of such objects,
of class <code>"solist"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the smallest rectangle (with sides parallel to
the coordinate axes) that contains all the given objects.
</p>
<p>For a window (object of class <code>"owin"</code>), the bounding box
is the smallest rectangle that contains all the vertices of the
window (this is generally smaller than the enclosing frame,
which is returned by <code><a href="#topic+as.rectangle">as.rectangle</a></code>).
</p>
<p>For a point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>),
the bounding box
is the smallest rectangle that contains all the points of the pattern.
This is usually smaller than the bounding box of the window of the
point pattern.
</p>
<p>For a line segment pattern (object of class <code>"psp"</code>)
or a linear network (object of class <code>"linnet"</code>), the
bounding box is the smallest rectangle that contains all endpoints
of line segments.
</p>
<p>For a pixel image (object of class <code>"im"</code>), the image will
be converted to a window using <code><a href="#topic+as.owin">as.owin</a></code>,
and the bounding box of this window is obtained.
</p>
<p>If the argument is a list of several objects, then
this function finds the smallest rectangle that contains
all the bounding boxes of the objects.
</p>


<h3>Value</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+as.rectangle">as.rectangle</a></code>
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- owin(c(0,10),c(0,10), poly=list(x=c(1,2,3,2,1), y=c(2,3,4,6,7)))
  r &lt;- boundingbox(w)
  # returns rectangle [1,3] x [2,7]

  w2 &lt;- unit.square()
  r &lt;- boundingbox(w, w2)
  # returns rectangle [0,3] x [0,7]
</code></pre>

<hr>
<h2 id='boundingcircle'>
Smallest Enclosing Circle
</h2><span id='topic+boundingradius'></span><span id='topic+boundingradius.owin'></span><span id='topic+boundingradius.ppp'></span><span id='topic+boundingcentre'></span><span id='topic+boundingcircle'></span><span id='topic+boundingcentre.owin'></span><span id='topic+boundingcircle.owin'></span><span id='topic+boundingcentre.ppp'></span><span id='topic+boundingcircle.ppp'></span>

<h3>Description</h3>

<p>Find the smallest circle enclosing a spatial window
or other object. Return its radius, or the location of its centre,
or the circle itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundingradius(x, ...)

boundingcentre(x, ...)

boundingcircle(x, ...)

## S3 method for class 'owin'
boundingradius(x, ...)

## S3 method for class 'owin'
boundingcentre(x, ...)

## S3 method for class 'owin'
boundingcircle(x, ...)

## S3 method for class 'ppp'
boundingradius(x, ...)

## S3 method for class 'ppp'
boundingcentre(x, ...)

## S3 method for class 'ppp'
boundingcircle(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundingcircle_+3A_x">x</code></td>
<td>

<p>A window (object of class <code>"owin"</code>), or another spatial object. 
</p>
</td></tr>
<tr><td><code id="boundingcircle_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine the
pixel resolution for the calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>boundingcircle</code> of a spatial region <code class="reqn">W</code> is the smallest circle
that contains <code class="reqn">W</code>. The <code>boundingradius</code> is the radius of this circle,
and the <code>boundingcentre</code> is the centre of the circle.
</p>
<p>The functions <code>boundingcircle</code>, <code>boundingcentre</code> and
<code>boundingradius</code> are generic. There are methods
for objects of class <code>"owin"</code>, <code>"ppp"</code> and <code>"linnet"</code>.
</p>


<h3>Value</h3>

<p>The result of <code>boundingradius</code> is a single numeric value.
</p>
<p>The result of <code>boundingcentre</code> is a point pattern containing a
single point.
</p>
<p>The result of <code>boundingcircle</code> is a window representing the
boundingcircle.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diameter">diameter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  boundingradius(letterR)

  plot(grow.rectangle(Frame(letterR), 0.2), main="", type="n")
  plot(letterR, add=TRUE, col="grey")
  plot(boundingcircle(letterR), add=TRUE, border="green", lwd=2)
  plot(boundingcentre(letterR), pch="+", cex=2, col="blue", add=TRUE)

  X &lt;- runifrect(5)
  plot(X)
  plot(boundingcircle(X), add=TRUE)
  plot(boundingcentre(X), pch="+", cex=2, col="blue", add=TRUE)
</code></pre>

<hr>
<h2 id='box3'>
Three-Dimensional Box
</h2><span id='topic+box3'></span>

<h3>Description</h3>

<p>Creates an object representing a three-dimensional box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box3(xrange = c(0, 1), yrange = xrange, zrange = yrange, unitname = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="box3_+3A_xrange">xrange</code>, <code id="box3_+3A_yrange">yrange</code>, <code id="box3_+3A_zrange">zrange</code></td>
<td>

<p>Dimensions of the box in the <code class="reqn">x,y,z</code> directions.
Each of these arguments should be a numeric vector of length 2.
</p>
</td></tr>
<tr><td><code id="box3_+3A_unitname">unitname</code></td>
<td>

<p>Optional. Name of the unit of length. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an object representing
a three-dimensional rectangular parallelepiped (box)
with sides parallel to the coordinate axes.
</p>
<p>The object can be used to specify the domain of a three-dimensional
point pattern (see <code><a href="#topic+pp3">pp3</a></code>) and in various
geometrical calculations (see <code><a href="#topic+volume.box3">volume.box3</a></code>,
<code><a href="#topic+diameter.box3">diameter.box3</a></code>, <code><a href="#topic+eroded.volumes">eroded.volumes</a></code>). 
</p>
<p>The optional argument <code>unitname</code> specifies the name
of the unit of length. See <code><a href="#topic+unitname">unitname</a></code>
for valid formats.
</p>
<p>The function <code><a href="#topic+as.box3">as.box3</a></code> can be used to convert other kinds
of data to this format.
</p>


<h3>Value</h3>

<p>An object of class <code>"box3"</code>. There is a print method for this class.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.box3">as.box3</a></code>, 
<code><a href="#topic+pp3">pp3</a></code>,
<code><a href="#topic+volume.box3">volume.box3</a></code>,
<code><a href="#topic+diameter.box3">diameter.box3</a></code>,
<code><a href="#topic+eroded.volumes">eroded.volumes</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    box3()
    box3(c(0,10),c(0,10),c(0,5), unitname=c("metre","metres"))
    box3(c(-1,1))
</code></pre>

<hr>
<h2 id='boxx'>
Multi-Dimensional Box
</h2><span id='topic+boxx'></span>

<h3>Description</h3>

<p>Creates an object representing a multi-dimensional box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxx(..., unitname = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxx_+3A_...">...</code></td>
<td>

<p>Dimensions of the box. Vectors of length 2.
</p>
</td></tr>
<tr><td><code id="boxx_+3A_unitname">unitname</code></td>
<td>

<p>Optional. Name of the unit of length. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an object representing
a multi-dimensional rectangular parallelepiped (box)
with sides parallel to the coordinate axes.
</p>
<p>The object can be used to specify the domain of a multi-dimensional
point pattern (see <code><a href="#topic+ppx">ppx</a></code>) and in various
geometrical calculations (see <code><a href="#topic+volume.boxx">volume.boxx</a></code>,
<code><a href="#topic+diameter.boxx">diameter.boxx</a></code>, <code><a href="#topic+eroded.volumes">eroded.volumes</a></code>). 
</p>
<p>The optional argument <code>unitname</code> specifies the name
of the unit of length. See <code><a href="#topic+unitname">unitname</a></code>
for valid formats.
</p>


<h3>Value</h3>

<p>An object of class <code>"boxx"</code>. There is a print method for this class.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppx">ppx</a></code>,
<code><a href="#topic+volume.boxx">volume.boxx</a></code>,
<code><a href="#topic+diameter.boxx">diameter.boxx</a></code>,
<code><a href="#topic+eroded.volumes.boxx">eroded.volumes.boxx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    boxx(c(0,10),c(0,10),c(0,5),c(0,1), unitname=c("metre","metres"))
</code></pre>

<hr>
<h2 id='bufftess'>
Buffer Distance Tessellation
</h2><span id='topic+bufftess'></span>

<h3>Description</h3>

<p>Constructs a spatial tessellation, composed of rings or buffers at specified
distances away from the given spatial object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bufftess(X, breaks, W = Window(X), ..., polygonal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bufftess_+3A_x">X</code></td>
<td>

<p>A spatial object in two dimensions,
such as a point pattern (class <code>"ppp"</code>) or
line segment pattern (class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="bufftess_+3A_breaks">breaks</code></td>
<td>

<p>Either a numeric vector specifying the cut points for the
distance values, or a single integer specifying the number of cut points.
</p>
</td></tr>
<tr><td><code id="bufftess_+3A_w">W</code></td>
<td>

<p>Optional. Window (object of class <code>"owin"</code>) inside which the
tessellation will be constructed.
</p>
</td></tr>
<tr><td><code id="bufftess_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> controlling the
pixel resolution when <code>polygonal=FALSE</code>,
and optional arguments passed to <code><a href="base.html#topic+cut.default">cut.default</a></code>
controlling the labelling of the distance bands.
</p>
</td></tr>
<tr><td><code id="bufftess_+3A_polygonal">polygonal</code></td>
<td>

<p>Logical value specifying whether the tessellation should consist of
polygonal tiles (<code>polygonal=TRUE</code>, the default) or
should be constructed using a pixel image (<code>polygonal=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function divides space into tiles defined
by distance from the object <code>X</code>. The result is a tessellation
(object of class <code>"tess"</code>) that consists of concentric rings
around <code>X</code>.
</p>
<p>The distance values which determine the tiles are specified by
the argument <code>breaks</code>.
</p>

<ul>
<li>
<p>If <code>breaks</code> is a vector of numerical values, then these
values are taken to be the distances defining the tiles.
The first tile is the region of space that lies at distances
between <code>breaks[1]</code> and <code>breaks[2]</code> away from <code>X</code>;
the second tile is the region lying at distances between
<code>breaks[2]</code> and <code>breaks[3]</code> away from <code>X</code>; and so on.
The number of tiles will be <code>length(breaks)-1</code>.
</p>
</li>
<li>
<p>If <code>breaks</code> is a single integer, it is interpreted as specifying
the number of intervals between breakpoints.
There will be <code>breaks+1</code> equally spaced
break points, ranging from zero to the maximum
achievable distance. The number of tiles will equal <code>breaks</code>.
</p>
</li></ul>

<p>The tessellation can be computed using either raster calculations
or vector calculations.
</p>

<ul>
<li> 
<p>If <code>polygonal=TRUE</code> (the default), the tiles are computed as
polygonal windows using vector geometry, and the result is a
tessellation consisting of polygonal tiles.
This calculation could be slow and could require substantial memory,
but produces a geometrically accurate result.
</p>
</li>
<li>
<p>If <code>polygonal=FALSE</code>, the distance map of <code>X</code> is computed
as a pixel image (<code><a href="#topic+distmap">distmap</a></code>), then the distance values
are divided into discrete bands using <code><a href="#topic+cut.im">cut.im</a></code>. The result is a
tessellation specified by a pixel image. This computation is faster
but less accurate.
</p>
</li></ul>



<h3>Value</h3>

<p>A tessellation (object of class <code>"tess"</code>).
</p>
<p>The result also has an attribute <code>breaks</code> which is the vector of distance breakpoints.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>Polygonal calculations are performed using <code><a href="#topic+dilation">dilation</a></code>
and <code><a href="#topic+setminus.owin">setminus.owin</a></code>. Pixel calculations are performed
using <code><a href="#topic+distmap">distmap</a></code> and <code><a href="#topic+cut.im">cut.im</a></code>. See
<code><a href="#topic+as.mask">as.mask</a></code> for details of arguments that control pixel
resolution. 
</p>
<p>For other kinds of tessellations, see 
<code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+hextess">hextess</a></code>,
<code><a href="#topic+venn.tess">venn.tess</a></code>,
<code><a href="#topic+polartess">polartess</a></code>,
<code><a href="#topic+dirichlet">dirichlet</a></code>, <code><a href="#topic+delaunay">delaunay</a></code>,
<code><a href="#topic+quantess">quantess</a></code>, <code><a href="#topic+quadrats">quadrats</a></code>
and 
<code><a href="spatstat.random.html#topic+rpoislinetess">rpoislinetess</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- cells[c(FALSE,FALSE,FALSE,TRUE)]
  if(interactive()) {
    b &lt;- c(0, 0.05, 0.1, 0.15, 0.2, Inf)
    n &lt;- 5
  } else {
    ## simpler data for testing
    b &lt;- c(0, 0.1, 0.2, Inf)
    n &lt;- 3
  }
  plot(bufftess(X, b), do.col=TRUE, col=1:n)
</code></pre>

<hr>
<h2 id='by.im'>Apply Function to Image Broken Down by Factor</h2><span id='topic+by.im'></span>

<h3>Description</h3>

<p>Splits a pixel image into sub-images and applies a function to each
sub-image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im'
by(data, INDICES, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by.im_+3A_data">data</code></td>
<td>
<p>A pixel image (object of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="by.im_+3A_indices">INDICES</code></td>
<td>
<p>Grouping variable.
Either a tessellation (object of class <code>"tess"</code>) or
a factor-valued pixel image.
</p>
</td></tr>
<tr><td><code id="by.im_+3A_fun">FUN</code></td>
<td>
<p>Function to be applied to each sub-image of <code>data</code>.</p>
</td></tr>
<tr><td><code id="by.im_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+by">by</a></code> for
pixel images (class <code>"im"</code>).
</p>
<p>The pixel image <code>data</code> is first divided into sub-images according
to <code>INDICES</code>. Then the function <code>FUN</code> is applied to each subset.
The results of each computation are returned in a list.
</p>
<p>The grouping variable <code>INDICES</code> may be either
</p>

<ul>
<li><p> a tessellation (object of class <code>"tess"</code>). Each tile of
the tessellation delineates a subset of the spatial domain.
</p>
</li>
<li><p> a pixel image (object of class <code>"im"</code>) with factor
values. The levels of the factor determine subsets of the spatial
domain.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing the results of each evaluation of <code>FUN</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+split.im">split.im</a></code>,
<code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+im">im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  W &lt;- square(1)
  X &lt;- as.im(function(x,y){sqrt(x^2+y^2)}, W)
  Y &lt;- dirichlet(runifrect(12, W))
  # mean pixel value in each subset
  unlist(by(X, Y, mean))
  # trimmed mean
  unlist(by(X, Y, mean, trim=0.05))
</code></pre>

<hr>
<h2 id='by.ppp'>Apply a Function to a Point Pattern Broken Down by Factor</h2><span id='topic+by.ppp'></span>

<h3>Description</h3>

<p>Splits a point pattern into sub-patterns, and applies the function to each
sub-pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppp'
by(data, INDICES=marks(data), FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by.ppp_+3A_data">data</code></td>
<td>
<p>Point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="by.ppp_+3A_indices">INDICES</code></td>
<td>
<p>Grouping variable. Either a factor, a pixel image with
factor values, or a tessellation.</p>
</td></tr>
<tr><td><code id="by.ppp_+3A_fun">FUN</code></td>
<td>
<p>Function to be applied to subsets of <code>data</code>.</p>
</td></tr>
<tr><td><code id="by.ppp_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+by">by</a></code>
for point patterns (class <code>"ppp"</code>).
</p>
<p>The point pattern <code>data</code> is first divided into subsets
according to <code>INDICES</code>. Then the function <code>FUN</code>
is applied to each subset. The results of each computation are
returned in a list.
</p>
<p>The argument <code>INDICES</code> may be
</p>

<ul>
<li>
<p>a factor, of length equal to the number of points in <code>data</code>.
The levels of <code>INDICES</code>
determine the destination of each point in <code>data</code>.
The <code>i</code>th point of <code>data</code> will be placed in the sub-pattern
<code>split.ppp(data)$l</code> where <code>l = f[i]</code>.
</p>
</li>
<li>
<p>a pixel image (object of class <code>"im"</code>) with factor values.
The pixel value of <code>INDICES</code>
at each point of <code>data</code> will be used as the classifying variable.
</p>
</li>
<li>
<p>a tessellation (object of class <code>"tess"</code>).
Each point of <code>data</code> will be classified according to
the tile of the tessellation into which it falls.
</p>
</li></ul>

<p>If <code>INDICES</code> is missing, then <code>data</code> must be a multitype point pattern
(a marked point pattern whose marks vector is a factor).
Then the effect is that the points of each type
are separated into different point patterns.
</p>


<h3>Value</h3>

<p>A list (also of class <code>"anylist"</code> or <code>"solist"</code> as
appropriate) containing the results returned
from <code>FUN</code> for each of the subpatterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp">ppp</a></code>,
<code><a href="#topic+split.ppp">split.ppp</a></code>,
<code><a href="#topic+cut.ppp">cut.ppp</a></code>,
<code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+im">im</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # multitype point pattern, broken down by type
  by(amacrine, FUN=minnndist)
  by(amacrine, FUN=function(x) { intensity(unmark(x)) })

  if(require(spatstat.explore)) {
  # how to pass additional arguments to FUN
  by(amacrine, FUN=clarkevans, correction=c("Donnelly","cdf"))
  }

  # point pattern broken down by tessellation
  data(swedishpines)
  tes &lt;- quadrats(swedishpines, 4,4)
  ## compute minimum nearest neighbour distance for points in each tile
  B &lt;- by(swedishpines, tes, minnndist)

  if(require(spatstat.explore)) {
  B &lt;- by(swedishpines, tes, clarkevans, correction="Donnelly")
  simplify2array(B)
  }
</code></pre>

<hr>
<h2 id='cbind.hyperframe'>
Combine Hyperframes by Rows or by Columns
</h2><span id='topic+cbind.hyperframe'></span><span id='topic+rbind.hyperframe'></span>

<h3>Description</h3>

<p>Methods for <code>cbind</code> and <code>rbind</code> for hyperframes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyperframe'
cbind(...)
## S3 method for class 'hyperframe'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind.hyperframe_+3A_...">...</code></td>
<td>

<p>Any number of hyperframes (objects of class <code><a href="#topic+hyperframe">hyperframe</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for <code><a href="base.html#topic+cbind">cbind</a></code>
and <code><a href="base.html#topic+rbind">rbind</a></code> for hyperframes.
</p>
<p>Note that <em>all</em> the arguments must be hyperframes (because of
the peculiar dispatch rules of <code><a href="base.html#topic+cbind">cbind</a></code> and
<code><a href="base.html#topic+rbind">rbind</a></code>).
</p>
<p>To combine a hyperframe with a data frame, one should either 
convert the data frame to a hyperframe using
<code><a href="#topic+as.hyperframe">as.hyperframe</a></code>, or explicitly invoke the
function <code>cbind.hyperframe</code> or <code>rbind.hyperframe</code>.
</p>
<p>In other words: if <code>h</code> is a hyperframe and <code>d</code> is a data frame,
the result of <code>cbind(h,d)</code> will be the same as
<code>cbind(as.data.frame(h), d)</code>, so that all hypercolumns
of <code>h</code> will be deleted (and a warning will be issued).
To combine <code>h</code> with <code>d</code>
so that all columns of <code>h</code> are retained,
type either <code>cbind(h, as.hyperframe(d))</code> or
<code>cbind.hyperframe(h,d)</code>.
</p>


<h3>Value</h3>

<p>Another hyperframe.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyperframe">hyperframe</a></code>,
<code><a href="#topic+as.hyperframe">as.hyperframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(spatstat.random)) {
  lambda &lt;- runif(5, min=10, max=30)
  X &lt;- solapply(as.list(lambda), rpoispp)
  h &lt;- hyperframe(lambda=lambda, X=X)
  g &lt;- hyperframe(id=letters[1:5], Y=rev(X))
  gh &lt;- cbind(h, g)
  hh &lt;- rbind(h[1:2, ], h[3:5,])
}
</code></pre>

<hr>
<h2 id='centroid.owin'>Centroid of a window</h2><span id='topic+centroid.owin'></span>

<h3>Description</h3>

<p>Computes the centroid (centre of mass) of a window 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> centroid.owin(w, as.ppp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroid.owin_+3A_w">w</code></td>
<td>
<p>A window</p>
</td></tr>
<tr><td><code id="centroid.owin_+3A_as.ppp">as.ppp</code></td>
<td>
<p>Logical flag indicating whether to return the centroid
as a point pattern (<code>ppp</code> object)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The centroid of the window <code>w</code> is computed.
The centroid (&ldquo;centre of mass&rdquo;) 
is the point whose <code class="reqn">x</code> and <code class="reqn">y</code> coordinates 
are the mean values of the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates
of all points in the window.
</p>
<p>The argument <code>w</code> should be a window (an object of class
<code>"owin"</code>, see <code><a href="#topic+owin.object">owin.object</a></code> for details)
or can be given in any format acceptable to <code><a href="#topic+as.owin">as.owin</a>()</code>.
</p>
<p>The calculation uses an exact analytic formula for the case
of polygonal windows.
</p>
<p>Note that the centroid of a window is not necessarily inside 
the window, unless the window is convex.
If  <code>as.ppp=TRUE</code> and
the centroid of <code>w</code> lies outside <code>w</code>,
then the window of the returned point pattern
will be a rectangle containing the
original window (using <code><a href="#topic+as.rectangle">as.rectangle</a></code>. 
</p>


<h3>Value</h3>

<p>Either a list with components <code>x, y</code>, or a point pattern (of class
<code>ppp</code>) consisting of a single point, giving the coordinates of the
centroid of the window <code>w</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- owin(c(0,1),c(0,1))
  centroid.owin(w)
  # returns 0.5, 0.5

  w &lt;- Window(demopat)
  # an irregular window
  cent &lt;- centroid.owin(w, as.ppp = TRUE)

  wapprox &lt;- as.mask(w)
  # pixel approximation of window

  if(interactive()) {
    plot(cent)
    # plot the window and its centroid
    points(centroid.owin(wapprox))
    # should be indistinguishable 
  }
  	
</code></pre>

<hr>
<h2 id='chop.tess'>Subdivide a Window or Tessellation using a Set of Lines</h2><span id='topic+chop.tess'></span>

<h3>Description</h3>

<p>Divide a given window into tiles
delineated by a set of infinite straight lines, obtaining
a tessellation of the window.
Alternatively, given a tessellation, divide each tile of the
tessellation into sub-tiles delineated by the lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop.tess(X, L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chop.tess_+3A_x">X</code></td>
<td>

<p>A window (object of class <code>"owin"</code>) or tessellation
(object of class <code>"tess"</code>) to be subdivided by lines.
</p>
</td></tr>
<tr><td><code id="chop.tess_+3A_l">L</code></td>
<td>

<p>A set of infinite straight lines (object of class <code>"infline"</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>L</code> should be a set of infinite straight lines in the plane
(stored in an object <code>L</code> of class <code>"infline"</code> created by the
function <code><a href="#topic+infline">infline</a></code>).
</p>
<p>If <code>X</code> is a window, then it is divided into tiles
delineated by the lines in <code>L</code>.
</p>
<p>If <code>X</code> is a tessellation, then each tile of <code>X</code> is
subdivided into sub-tiles delineated by the lines in <code>L</code>.
</p>
<p>The result is a tessellation. 
</p>


<h3>Value</h3>

<p>A tessellation (object of class <code>"tess"</code>).
</p>


<h3>Warning</h3>

<p>If <code>X</code> is a non-convex window, or a tessellation containing
non-convex tiles, then <code>chop.tess(X,L)</code> may contain a tile
which consists of several unconnected pieces. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+infline">infline</a></code>,
<code><a href="#topic+clip.infline">clip.infline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  L &lt;- infline(p=1:3, theta=pi/4)
  W &lt;- square(4)
  chop.tess(W, L)
</code></pre>

<hr>
<h2 id='clickbox'>Interactively Define a Rectangle</h2><span id='topic+clickbox'></span>

<h3>Description</h3>

<p>Allows the user to specify a rectangle by
point-and-click in the display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  clickbox(add=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clickbox_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether to create a new plot
(<code>add=FALSE</code>) or draw over the existing plot (<code>add=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="clickbox_+3A_...">...</code></td>
<td>

<p>Graphics arguments passed to <code><a href="graphics.html#topic+polygon">polygon</a></code> to plot the
box.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the user to create a rectangular window 
by interactively clicking on the screen display.
</p>
<p>The user is prompted to point the mouse at any desired locations
for two corners of the rectangle,
and click the left mouse button to add each point.
</p>
<p>The return value is a window (object of class <code>"owin"</code>)
representing the rectangle.
</p>
<p>This function uses the <span class="rlang"><b>R</b></span> command <code><a href="graphics.html#topic+locator">locator</a></code> to
input the mouse clicks. It only works on screen devices such as
&lsquo;X11&rsquo;, &lsquo;windows&rsquo; and &lsquo;quartz&rsquo;. 
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>) representing the
selected rectangle.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clickpoly">clickpoly</a></code>,
<code><a href="#topic+clickppp">clickppp</a></code>,
<code><a href="#topic+clickdist">clickdist</a></code>,
<code><a href="graphics.html#topic+locator">locator</a></code>
</p>

<hr>
<h2 id='clickdist'>Interactively Measure Distance</h2><span id='topic+clickdist'></span>

<h3>Description</h3>

<p>Measures the distance between two points
which the user has clicked on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  clickdist()
</code></pre>


<h3>Details</h3>

<p>This function allows the user to measure the distance
between two spatial locations, interactively,
by clicking on the screen display.
</p>
<p>When <code>clickdist()</code> is called, the user is expected to
click two points in the current graphics device. The distance
between these points will be returned.
</p>
<p>This function uses the <span class="rlang"><b>R</b></span> command <code><a href="graphics.html#topic+locator">locator</a></code> to
input the mouse clicks. It only works on screen devices such as
&lsquo;X11&rsquo;, &lsquo;windows&rsquo; and &lsquo;quartz&rsquo;.
</p>


<h3>Value</h3>

<p>A single nonnegative number.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+locator">locator</a></code>,
<code><a href="#topic+clickppp">clickppp</a></code>,
<code><a href="#topic+clickpoly">clickpoly</a></code>,
<code><a href="#topic+clickbox">clickbox</a></code>
</p>

<hr>
<h2 id='clickpoly'>Interactively Define a Polygon</h2><span id='topic+clickpoly'></span>

<h3>Description</h3>

<p>Allows the user to create a polygon by
point-and-click in the display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  clickpoly(add=FALSE, nv=NULL, np=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clickpoly_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether to create a new plot
(<code>add=FALSE</code>) or draw over the existing plot (<code>add=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="clickpoly_+3A_nv">nv</code></td>
<td>

<p>Number of vertices of the polygon (if this is predetermined).
</p>
</td></tr>
<tr><td><code id="clickpoly_+3A_np">np</code></td>
<td>

<p>Number of polygons to create.
</p>
</td></tr>
<tr><td><code id="clickpoly_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+locator">locator</a></code> to control the
interactive plot, and to <code><a href="graphics.html#topic+polygon">polygon</a></code> to plot the
polygons.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the user to create a polygonal window 
by interactively clicking on the screen display.
</p>
<p>The user is prompted to point the mouse at any desired locations
for the polygon vertices,
and click the left mouse button to add each point.
Interactive input stops after <code>nv</code> clicks (if <code>nv</code> was given)
or when the middle mouse button is pressed.
</p>
<p>The return value is a window (object of class <code>"owin"</code>)
representing the polygon.
</p>
<p>This function uses the <span class="rlang"><b>R</b></span> command <code><a href="graphics.html#topic+locator">locator</a></code> to
input the mouse clicks. It only works on screen devices such as
&lsquo;X11&rsquo;, &lsquo;windows&rsquo; and &lsquo;quartz&rsquo;. Arguments that can be
passed to <code><a href="graphics.html#topic+locator">locator</a></code> through <code>...</code> include
<code>pch</code> (plotting character), <code>cex</code> (character expansion
factor) and <code>col</code> (colour). See <code><a href="graphics.html#topic+locator">locator</a></code>
and <code><a href="graphics.html#topic+par">par</a></code>.
</p>
<p>Multiple polygons can also be drawn, by specifying
<code>np &gt; 1</code>. The polygons must be disjoint. The result is 
a single window object consisting of all the polygons.
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>) representing the polygon.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+identify.ppp">identify.ppp</a></code>,
<code><a href="#topic+clickbox">clickbox</a></code>,
<code><a href="#topic+clickppp">clickppp</a></code>,
<code><a href="#topic+clickdist">clickdist</a></code>,
<code><a href="graphics.html#topic+locator">locator</a></code>
</p>

<hr>
<h2 id='clickppp'>Interactively Add Points</h2><span id='topic+clickppp'></span>

<h3>Description</h3>

<p>Allows the user to create a point pattern by
point-and-click in the display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  clickppp(n=NULL, win=square(1), types=NULL, ..., add=FALSE,
    main=NULL, hook=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clickppp_+3A_n">n</code></td>
<td>

<p>Number of points to be added (if this is predetermined).
</p>
</td></tr>
<tr><td><code id="clickppp_+3A_win">win</code></td>
<td>

<p>Window in which to create the point pattern.
An object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="clickppp_+3A_types">types</code></td>
<td>

<p>Vector of types, when creating a multitype point pattern.
</p>
</td></tr>
<tr><td><code id="clickppp_+3A_...">...</code></td>
<td>

<p>Optional extra arguments to be passed to <code><a href="graphics.html#topic+locator">locator</a></code>
to control the display.
</p>
</td></tr>
<tr><td><code id="clickppp_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether to create a new plot
(<code>add=FALSE</code>) or draw over the existing plot (<code>add=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="clickppp_+3A_main">main</code></td>
<td>

<p>Main heading for plot.
</p>
</td></tr>
<tr><td><code id="clickppp_+3A_hook">hook</code></td>
<td>
<p>For internal use only. Do not use this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the user to create a point pattern
by interactively clicking on the screen display.
</p>
<p>First the window <code>win</code> is plotted on the current screen device.
Then the user is prompted to point the mouse at any desired locations
and click the left mouse button to add each point.
Interactive input stops after <code>n</code> clicks (if <code>n</code> was given)
or when the middle mouse button is pressed.
</p>
<p>The return value is a point pattern
containing the locations of all the clicked points
inside the original window <code>win</code>,
provided that all of the clicked locations were
inside this window. Otherwise, the window is expanded to a box
large enough to contain all the points (as well as containing
the original window).
</p>
<p>If the argument <code>types</code> is given, then a multitype point pattern
will be created. The user is
prompted to input the locations of points of type <code>type[i]</code>,
for each successive index <code>i</code>. (If the argument <code>n</code> was
given, there will be <code>n</code> points of <em>each</em> type.)
The return value is a multitype point pattern.
</p>
<p>This function uses the <span class="rlang"><b>R</b></span> command <code><a href="graphics.html#topic+locator">locator</a></code> to
input the mouse clicks. It only works on screen devices such as
&lsquo;X11&rsquo;, &lsquo;windows&rsquo; and &lsquo;quartz&rsquo;. Arguments that can be
passed to <code><a href="graphics.html#topic+locator">locator</a></code> through <code>...</code> include
<code>pch</code> (plotting character), <code>cex</code> (character expansion
factor) and <code>col</code> (colour). See <code><a href="graphics.html#topic+locator">locator</a></code>
and <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Original by Dominic Schuhmacher.
Adapted by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+identify.ppp">identify.ppp</a></code>,
<code><a href="graphics.html#topic+locator">locator</a></code>,
<code><a href="#topic+clickpoly">clickpoly</a></code>,
<code><a href="#topic+clickbox">clickbox</a></code>,
<code><a href="#topic+clickdist">clickdist</a></code>
</p>

<hr>
<h2 id='clip.infline'>Intersect Infinite Straight Lines with a Window</h2><span id='topic+clip.infline'></span>

<h3>Description</h3>

<p>Take the intersection between a set of infinite straight lines
and a window, yielding a set of line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clip.infline(L, win)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clip.infline_+3A_l">L</code></td>
<td>

<p>Object of class <code>"infline"</code> specifying a set of infinite
straight lines in the plane.
</p>
</td></tr>
<tr><td><code id="clip.infline_+3A_win">win</code></td>
<td>

<p>Window (object of class <code>"owin"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the intersection between
a set of infinite straight lines in the plane
(stored in an object <code>L</code> of class <code>"infline"</code> created by the
function <code><a href="#topic+infline">infline</a></code>) and a window <code>win</code>.
The result is a pattern of line segments. Each line segment carries a
mark indicating which line it belongs to.
</p>


<h3>Value</h3>

<p>A line segment pattern (object of class <code>"psp"</code>)
with a single column of marks.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+infline">infline</a></code>,<code><a href="#topic+psp">psp</a></code>.
</p>
<p>To divide a window into pieces using infinite lines,
use <code><a href="#topic+chop.tess">chop.tess</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  L &lt;- infline(p=1:3, theta=pi/4)
  W &lt;- square(4)
  clip.infline(L, W)
</code></pre>

<hr>
<h2 id='closepairs'>
Close Pairs of Points
</h2><span id='topic+closepairs'></span><span id='topic+crosspairs'></span><span id='topic+closepairs.ppp'></span><span id='topic+crosspairs.ppp'></span>

<h3>Description</h3>

<p>Low-level functions to find all close pairs of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closepairs(X, rmax, ...)

## S3 method for class 'ppp'
closepairs(X, rmax, twice=TRUE,
                         what=c("all","indices","ijd"),
                         distinct=TRUE, neat=TRUE,
                         periodic=FALSE, ...)

crosspairs(X, Y, rmax, ...)

## S3 method for class 'ppp'
crosspairs(X, Y, rmax,
                        what=c("all", "indices", "ijd"),
                        periodic=FALSE, ...,
                        iX=NULL, iY=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closepairs_+3A_x">X</code>, <code id="closepairs_+3A_y">Y</code></td>
<td>

<p>Point patterns (objects of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="closepairs_+3A_rmax">rmax</code></td>
<td>

<p>Maximum distance between pairs of points to be counted as close pairs.
</p>
</td></tr>
<tr><td><code id="closepairs_+3A_twice">twice</code></td>
<td>

<p>Logical value indicating whether all ordered pairs of close points
should be returned. If <code>twice=TRUE</code> (the default),
each pair will appear twice in the output, as <code>(i,j)</code>
and again as <code>(j,i)</code>. If <code>twice=FALSE</code>,
then each pair will appear only once, as the pair <code>(i,j)</code>
with <code>i &lt; j</code>.
</p>
</td></tr>
<tr><td><code id="closepairs_+3A_what">what</code></td>
<td>

<p>String specifying the data to be returned for each close pair of points.
If <code>what="all"</code> (the default) then the
returned information includes the indices <code>i,j</code> of each pair,
their <code>x,y</code> coordinates, and the distance between them.
If <code>what="indices"</code> then only the indices <code>i,j</code> are
returned.
If <code>what="ijd"</code> then the indices <code>i,j</code> and the
distance <code>d</code> are returned.
</p>
</td></tr>
<tr><td><code id="closepairs_+3A_distinct">distinct</code></td>
<td>

<p>Logical value indicating whether to return only the
pairs of points with different indices <code>i</code> and <code>j</code>
(<code>distinct=TRUE</code>, the default) or to also include
the pairs where <code>i=j</code> (<code>distinct=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="closepairs_+3A_neat">neat</code></td>
<td>

<p>Logical value indicating whether to ensure that <code>i &lt; j</code>
in each output pair, when <code>twice=FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="closepairs_+3A_periodic">periodic</code></td>
<td>

<p>Logical value indicating whether to use the periodic edge correction.
The window of <code>X</code> should be a rectangle.
Opposite pairs of edges of the window will be treated as identical.
</p>
</td></tr>
<tr><td><code id="closepairs_+3A_...">...</code></td>
<td>
<p>Extra arguments, ignored by methods.</p>
</td></tr>
<tr><td><code id="closepairs_+3A_ix">iX</code>, <code id="closepairs_+3A_iy">iY</code></td>
<td>

<p>Optional vectors used to determine whether a point in <code>X</code>
is identical to a point in <code>Y</code>. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are the efficient low-level functions used by <span class="pkg">spatstat</span>
to find all close pairs of points in a point pattern
or all close pairs between two point patterns. 
</p>
<p><code>closepairs(X,rmax)</code> finds all pairs of distinct points
in the pattern <code>X</code> which lie at a distance less than or equal to
<code>rmax</code> apart, and returns them. The result is
a list with the following components:
</p>

<dl>
<dt>i</dt><dd><p>Integer vector of indices of the first point in each pair.</p>
</dd>
<dt>j</dt><dd><p>Integer vector of indices of the second point in each pair.</p>
</dd>
<dt>xi,yi</dt><dd><p>Coordinates of the first point in each pair.</p>
</dd>
<dt>xj,yj</dt><dd><p>Coordinates of the second point in each pair.</p>
</dd>
<dt>dx</dt><dd><p>Equal to <code>xj-xi</code></p>
</dd>
<dt>dy</dt><dd><p>Equal to <code>yj-yi</code></p>
</dd>
<dt>d</dt><dd><p>Euclidean distance between each pair of points.</p>
</dd>
</dl>

<p>If <code>what="indices"</code> then only the components <code>i</code> and
<code>j</code> are returned. This is slightly faster and more efficient
with use of memory.
</p>
<p><code>crosspairs(X,rmax)</code> identifies all pairs of neighbours
<code>(X[i], Y[j])</code> between the patterns <code>X</code> and <code>Y</code>,
and returns them. The result is
a list with the same format as for <code>closepairs</code>.
</p>
<p>The arguments <code>iX</code> and <code>iY</code> are used when
the two point patterns <code>X</code> and <code>Y</code> may have some points in
common.  In this situation <code>crosspairs(X, Y)</code> would return some
pairs of points in which the two points are identical.
To avoid this, attach a unique integer
identifier to each point, such that two points are identical if their
identifier values are equal. Let <code>iX</code> be the vector of
identifier values for the points in <code>X</code>, and <code>iY</code>
the vector of identifiers for points in <code>Y</code>. Then the code
will only compare two points if they have different values of the
identifier. 
</p>


<h3>Value</h3>

<p>A list with components <code>i</code> and <code>j</code>,
and possibly other components as described under Details.
</p>


<h3>Warning about accuracy</h3>

<p>The results of these functions may not agree exactly with
the correct answer (as calculated by a human) and may not
be consistent between different computers and different installations
of <span class="rlang"><b>R</b></span>. The discrepancies arise in marginal cases where the interpoint
distance is equal to, or very close to, the threshold <code>rmax</code>.
</p>
<p>Floating-point numbers in a computer
are not mathematical Real Numbers: they are approximations using
finite-precision binary arithmetic.
The approximation is accurate to a tolerance of about
<code>.Machine$double.eps</code>.
</p>
<p>If the true interpoint distance <code class="reqn">d</code> and the threshold <code>rmax</code>
are equal, or if their difference is no more than <code>.Machine$double.eps</code>,
the result may be incorrect.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+closepairs.pp3">closepairs.pp3</a></code> for the corresponding
functions for 3D point patterns.
</p>
<p><code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>, <code><a href="spatstat.explore.html#topic+Kcross">Kcross</a></code>,
<code><a href="#topic+nndist">nndist</a></code>, <code><a href="#topic+nncross">nncross</a></code>,
<code><a href="#topic+applynbd">applynbd</a></code>, <code><a href="#topic+markstat">markstat</a></code>
for functions which use these capabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   d &lt;- closepairs(cells, 0.1)
   head(as.data.frame(d))

   Y &lt;- split(amacrine)
   e &lt;- crosspairs(Y$on, Y$off, 0.1)
</code></pre>

<hr>
<h2 id='closepairs.pp3'>
Close Pairs of Points in 3 Dimensions
</h2><span id='topic+closepairs.pp3'></span><span id='topic+crosspairs.pp3'></span>

<h3>Description</h3>

<p>Low-level functions to find all close pairs of points
in three-dimensional point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pp3'
closepairs(X, rmax, twice=TRUE,
                         what=c("all", "indices", "ijd"),
                         distinct=TRUE, neat=TRUE, ...)

## S3 method for class 'pp3'
crosspairs(X, Y, rmax, what=c("all", "indices", "ijd"), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closepairs.pp3_+3A_x">X</code>, <code id="closepairs.pp3_+3A_y">Y</code></td>
<td>

<p>Point patterns in three dimensions (objects of class <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="closepairs.pp3_+3A_rmax">rmax</code></td>
<td>

<p>Maximum distance between pairs of points to be counted as close pairs.
</p>
</td></tr>
<tr><td><code id="closepairs.pp3_+3A_twice">twice</code></td>
<td>

<p>Logical value indicating whether all ordered pairs of close points
should be returned. If <code>twice=TRUE</code>, each pair will appear twice
in the output, as <code>(i,j)</code> and again as <code>(j,i)</code>. If
<code>twice=FALSE</code>, then each pair will appear only once,
as the pair <code>(i,j)</code> such that <code>i &lt; j</code>.
</p>
</td></tr>
<tr><td><code id="closepairs.pp3_+3A_what">what</code></td>
<td>

<p>String specifying the data to be returned for each close pair of points.
If <code>what="all"</code> (the default) then the
returned information includes the indices <code>i,j</code> of each pair,
their <code>x,y,z</code> coordinates, and the distance between them.
If <code>what="indices"</code> then only the indices <code>i,j</code> are returned.
If <code>what="ijd"</code> then the indices <code>i,j</code> and the
distance <code>d</code> are returned.
</p>
</td></tr>
<tr><td><code id="closepairs.pp3_+3A_distinct">distinct</code></td>
<td>

<p>Logical value indicating whether to return only the
pairs of points with different indices <code>i</code> and <code>j</code>
(<code>distinct=TRUE</code>, the default) or to also include
the pairs where <code>i=j</code> (<code>distinct=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="closepairs.pp3_+3A_neat">neat</code></td>
<td>

<p>Logical value indicating whether to ensure that <code>i &lt; j</code>
in each output pair, when <code>twice=FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="closepairs.pp3_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are the efficient low-level functions used by <span class="pkg">spatstat</span>
to find all close pairs of points in a three-dimensional point pattern
or all close pairs between two point patterns in three dimensions.
</p>
<p><code>closepairs(X,rmax)</code> identifies all pairs of neighbours 
in the pattern <code>X</code> and returns them. The result is
a list with the following components:
</p>

<dl>
<dt>i</dt><dd><p>Integer vector of indices of the first point in each pair.</p>
</dd>
<dt>j</dt><dd><p>Integer vector of indices of the second point in each pair.</p>
</dd>
<dt>xi,yi,zi</dt><dd><p>Coordinates of the first point in each pair.</p>
</dd>
<dt>xj,yj,zj</dt><dd><p>Coordinates of the second point in each pair.</p>
</dd>
<dt>dx</dt><dd><p>Equal to <code>xj-xi</code></p>
</dd>
<dt>dy</dt><dd><p>Equal to <code>yj-yi</code></p>
</dd>
<dt>dz</dt><dd><p>Equal to <code>zj-zi</code></p>
</dd>
<dt>d</dt><dd><p>Euclidean distance between each pair of points.</p>
</dd>
</dl>

<p>If <code>what="indices"</code> then only the components <code>i</code> and
<code>j</code> are returned. This is slightly faster.
</p>
<p><code>crosspairs(X,rmax)</code> identifies all pairs of neighbours
<code>(X[i], Y[j])</code> between the patterns <code>X</code> and <code>Y</code>,
and returns them. The result is
a list with the same format as for <code>closepairs</code>.
</p>


<h3>Value</h3>

<p>A list with components <code>i</code> and <code>j</code>,
and possibly other components as described under Details.
</p>


<h3>Warning about accuracy</h3>

<p>The results of these functions may not agree exactly with
the correct answer (as calculated by a human) and may not
be consistent between different computers and different installations
of <span class="rlang"><b>R</b></span>. The discrepancies arise in marginal cases where the interpoint
distance is equal to, or very close to, the threshold <code>rmax</code>.
</p>
<p>Floating-point numbers in a computer
are not mathematical Real Numbers: they are approximations using
finite-precision binary arithmetic.
The approximation is accurate to a tolerance of about
<code>.Machine$double.eps</code>.
</p>
<p>If the true interpoint distance <code class="reqn">d</code> and the threshold <code>rmax</code>
are equal, or if their difference is no more than <code>.Machine$double.eps</code>,
the result may be incorrect.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+closepairs">closepairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- pp3(runif(10), runif(10), runif(10), box3(c(0,1)))
   Y &lt;- pp3(runif(10), runif(10), runif(10), box3(c(0,1)))
   a &lt;- closepairs(X, 0.1)
   b &lt;- crosspairs(X, Y, 0.1)
</code></pre>

<hr>
<h2 id='closetriples'>
Close Triples of Points
</h2><span id='topic+closetriples'></span>

<h3>Description</h3>

<p>Low-level function to find all close triples of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closetriples(X, rmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closetriples_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code> or <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="closetriples_+3A_rmax">rmax</code></td>
<td>

<p>Maximum distance between each pair of points in a triple.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This low-level function
finds all triples of points in a point pattern
in which each pair lies closer than <code>rmax</code>.
</p>


<h3>Value</h3>

<p>A data frame with columns <code>i,j,k</code> giving the indices of the
points in each triple, and a column <code>diam</code> giving the diameter
(maximum pairwise distance) in the triple.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+closepairs">closepairs</a></code>,
<code><a href="spatstat.explore.html#topic+Tstat">Tstat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   closetriples(redwoodfull, 0.02)
   closetriples(redwoodfull, 0.005)
</code></pre>

<hr>
<h2 id='closing'>Morphological Closing</h2><span id='topic+closing'></span><span id='topic+closing.owin'></span><span id='topic+closing.ppp'></span><span id='topic+closing.psp'></span>

<h3>Description</h3>

<p>Perform morphological closing of a window, a line segment pattern
or a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> closing(w, r, ...)

 ## S3 method for class 'owin'
closing(w, r, ..., polygonal=NULL)

 ## S3 method for class 'ppp'
closing(w, r, ..., polygonal=TRUE)

 ## S3 method for class 'psp'
closing(w, r, ..., polygonal=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closing_+3A_w">w</code></td>
<td>

<p>A window (object of class <code>"owin"</code>
or a line segment pattern (object of class <code>"psp"</code>)
or a point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="closing_+3A_r">r</code></td>
<td>
<p>positive number: the radius of the closing.</p>
</td></tr>
<tr><td><code id="closing_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
controlling the pixel resolution, if a pixel approximation is used</p>
</td></tr>
<tr><td><code id="closing_+3A_polygonal">polygonal</code></td>
<td>

<p>Logical flag indicating whether to compute a polygonal
approximation to the erosion (<code>polygonal=TRUE</code>) or
a pixel grid approximation (<code>polygonal=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The morphological closing (Serra, 1982)
of a set <code class="reqn">W</code> by a distance <code class="reqn">r &gt; 0</code>
is the set of all points that cannot be
separated from <code class="reqn">W</code> by any circle of radius <code class="reqn">r</code>.
That is, a point <code class="reqn">x</code> belongs to the closing <code class="reqn">W*</code>
if it is impossible to draw any circle of radius <code class="reqn">r</code> that
has <code class="reqn">x</code> on the inside and <code class="reqn">W</code> on the outside.
The closing <code class="reqn">W*</code> contains the original set <code class="reqn">W</code>.
</p>
<p>For a small radius <code class="reqn">r</code>, the closing operation
has the effect of smoothing out irregularities in the boundary of
<code class="reqn">W</code>. For larger radii, the closing operation smooths out
concave features in the boundary. For very large radii,
the closed set <code class="reqn">W*</code> becomes more and more convex.
</p>
<p>The algorithm applies <code><a href="#topic+dilation">dilation</a></code> followed by
<code><a href="#topic+erosion">erosion</a></code>. 
</p>


<h3>Value</h3>

<p>If <code>r &gt; 0</code>, an object of class <code>"owin"</code> representing the
closed region. If <code>r=0</code>, the result is identical to <code>w</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Serra, J. (1982)
Image analysis and mathematical morphology.
Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opening">opening</a></code> for the opposite operation.
</p>
<p><code><a href="#topic+dilation">dilation</a></code>, <code><a href="#topic+erosion">erosion</a></code> for the basic
operations.  
</p>
<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code> for information about windows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  v &lt;- closing(letterR, 0.25)
  plot(v, main="closing")
  plot(letterR, add=TRUE)

  plot(closing(cells, 0.1))
  points(cells)
</code></pre>

<hr>
<h2 id='colourmap'>Colour Lookup Tables</h2><span id='topic+colourmap'></span>

<h3>Description</h3>

<p>Create a colour map (colour lookup table).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colourmap(col, ..., range=NULL, breaks=NULL, inputs=NULL, gamma=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colourmap_+3A_col">col</code></td>
<td>
<p>Vector of values specifying colours</p>
</td></tr>
<tr><td><code id="colourmap_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="colourmap_+3A_range">range</code></td>
<td>

<p>Interval to be mapped.
A numeric vector of length 2, specifying the endpoints of the
range of values to be mapped.
Incompatible with <code>breaks</code> or <code>inputs</code>.
</p>
</td></tr>
<tr><td><code id="colourmap_+3A_inputs">inputs</code></td>
<td>

<p>Values to which the colours are associated.
A factor or vector of the same length as <code>col</code>.
Incompatible with <code>breaks</code> or <code>range</code>.
</p>
</td></tr>
<tr><td><code id="colourmap_+3A_breaks">breaks</code></td>
<td>

<p>Breakpoints for the colour map.
A numeric vector of length equal to <code>length(col)+1</code>.
Incompatible with <code>range</code> or <code>inputs</code>.
</p>
</td></tr>
<tr><td><code id="colourmap_+3A_gamma">gamma</code></td>
<td>

<p>Exponent for the gamma correction, when <code>range</code> is given.
A single positive number.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A colour map is a mechanism for associating colours with data.
It can be regarded as a function, mapping data to colours.
</p>
<p>The command <code>colourmap</code> creates an object representing
a colour map, which can then be used to control the plot commands
in the <span class="pkg">spatstat</span> package. It can also be used to compute the
colour assigned to any data value. 
</p>
<p>The argument <code>col</code> specifies the colours to which
data values will be mapped. It should be a vector
whose entries can be interpreted as colours by the standard
<span class="rlang"><b>R</b></span> graphics system. The entries can be string names of colours
like <code>"red"</code>, or integers that refer to
colours in the standard palette, or strings containing
six-letter hexadecimal codes like <code>"#F0A0FF"</code>. 
</p>
<p>Exactly one of the arguments <code>range</code>, <code>inputs</code> or <code>breaks</code>
must be specified by name.
</p>

<ul>
<li>
<p>If <code>inputs</code> is given, then it should be a vector or factor,
of the same length as <code>col</code>. The entries of <code>inputs</code> can be
any atomic type (e.g. numeric, logical, character, complex) or factor
values. The resulting colour map associates the value <code>inputs[i]</code>
with the colour <code>col[i]</code>.
The argument <code>col</code> should have the same length as <code>inputs</code>.
</p>
</li>
<li>
<p>If <code>range</code> is given, then it determines the interval of the real
number line that will be mapped. It should be a numeric vector of
length 2. The interval will be divided evenly into bands, each of which is
assigned one of the colours in <code>col</code>. (If <code>gamma</code> is given,
then the bands are equally spaced on a scale where the original values
are raised to the power <code>gamma</code>.)
</p>
</li>
<li>
<p>If <code>breaks</code> is given, then it determines the precise intervals
of the real number line
which are mapped to each colour. It should be a numeric vector,
of length at least 2, with entries that are in increasing order.
Infinite values are allowed. Any number in the range
between <code>breaks[i]</code> and <code>breaks[i+1]</code> will be mapped to the
colour <code>col[i]</code>. 
The argument <code>col</code> should have length equal to
<code>length(breaks) - 1</code>.
</p>
</li></ul>

<p>It is also permissible for <code>col</code> to be a single colour value,
representing a trivial colour map in which all data values are mapped to
the same colour.
</p>
<p>The result is an object of class <code>"colourmap"</code>. 
There are <code>print</code> and <code>plot</code> methods for this class.
Some plot commands in the <span class="pkg">spatstat</span> package accept an object
of this class as a specification of the colour map.
</p>
<p>The result is also a function <code>f</code> which can be used to compute
the colour assigned to any data value. 
That is, <code>f(x)</code> returns the character value of the colour assigned
to <code>x</code>. This also works for vectors of data values.
</p>


<h3>Value</h3>

<p>A function, which is also an object of class <code>"colourmap"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>The plot method <code><a href="#topic+plot.colourmap">plot.colourmap</a></code>.
</p>
<p>See the <span class="rlang"><b>R</b></span> help file on
<code><a href="grDevices.html#topic+colors">colours</a></code> for information about the colours
that <span class="rlang"><b>R</b></span> recognises, and how to manipulate them.
</p>
<p>To make a smooth transition between colours, see
<code><a href="#topic+interp.colourmap">interp.colourmap</a></code>.
To alter individual colour values, see
<code><a href="#topic+tweak.colourmap">tweak.colourmap</a></code>.
To extract or replace all colour values, see
<code><a href="#topic+colouroutputs">colouroutputs</a></code>.
</p>
<p>See also <code><a href="#topic+restrict.colourmap">restrict.colourmap</a></code>.
</p>
<p>See <code><a href="#topic+colourtools">colourtools</a></code>
for more tools to manipulate colour values.
</p>
<p>See <code><a href="#topic+lut">lut</a></code> for lookup tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # colour map for real numbers, using breakpoints
  cr &lt;- colourmap(c("red", "blue", "green"), breaks=c(0,5,10,15))
  cr
  cr(3.2)
  cr(c(3,5,7))
  # a large colour map
  co &lt;- colourmap(rainbow(100), range=c(-1,1))
  co(0.2)
  # colour map for discrete set of values
  ct &lt;- colourmap(c("red", "green"), inputs=c(FALSE, TRUE))
  ct(TRUE)
</code></pre>

<hr>
<h2 id='colouroutputs'>
Extract or Assign Colour Values in a Colour Map
</h2><span id='topic+colouroutputs'></span><span id='topic+colouroutputs+3C-'></span>

<h3>Description</h3>

<p>Extract the colour values in a colour map,
or assign new colour values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colouroutputs(x)

colouroutputs(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colouroutputs_+3A_x">x</code></td>
<td>

<p>A colour map (object of class <code>"colourmap"</code>).
</p>
</td></tr>
<tr><td><code id="colouroutputs_+3A_value">value</code></td>
<td>

<p>A vector of values that can be interpreted as colours.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"colourmap"</code> is effectively a function that
maps its inputs (numbers or factor levels) to colour values.
</p>
<p>The command <code>colouroutputs(x)</code> extracts the colour values
in the colour map <code>x</code>.
</p>
<p>The assignment <code>colouroutputs(x) &lt;- value</code> replaces the colour
values in the colour map <code>x</code> by the entries in 
<code>value</code>. The replacement vector <code>value</code> should have the
same length as <code>colouroutputs(x)</code>, and its entries should be
interpretable as colours.
</p>
<p>To change only some of the colour values in a colour map,
it may be easier to use <code><a href="#topic+tweak.colourmap">tweak.colourmap</a></code>.
</p>


<h3>Value</h3>

<p>The result of <code>colouroutputs</code> is a character vector of
colour values. The result of the assignment
<code>colouroutputs(x) &lt;- value</code>  is 
another colour map (object of class <code>"colourmap"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colourmap">colourmap</a></code>, 
<code><a href="#topic+interp.colourmap">interp.colourmap</a></code>, 
<code><a href="#topic+tweak.colourmap">tweak.colourmap</a></code>, 
<code><a href="#topic+colourtools">colourtools</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- colourmap(rainbow(5), range=c(0,1))
  m
  # reverse order of colours
  colouroutputs(m) &lt;- rev(colouroutputs(m))
  m
</code></pre>

<hr>
<h2 id='colourtools'>
Convert and Compare Colours in Different Formats
</h2><span id='topic+colourtools'></span><span id='topic+paletteindex'></span><span id='topic+rgb2hex'></span><span id='topic+rgb2hsva'></span><span id='topic+col2hex'></span><span id='topic+paletteindex'></span><span id='topic+samecolour'></span><span id='topic+complementarycolour'></span><span id='topic+interp.colours'></span><span id='topic+is.colour'></span><span id='topic+is.grey'></span><span id='topic+to.grey'></span><span id='topic+to.opaque'></span><span id='topic+to.transparent'></span><span id='topic+to.saturated'></span>

<h3>Description</h3>

<p>These functions convert between different formats for specifying
a colour in <span class="rlang"><b>R</b></span>, determine whether colours are equivalent,
and convert colour to greyscale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2hex(x)
rgb2hex(v, maxColorValue=255)
rgb2hsva(red, green=NULL, blue=NULL, alpha=NULL, maxColorValue=255)
paletteindex(x)
samecolour(x,y)
complementarycolour(x)
interp.colours(x, length.out=512)
is.colour(x)
to.grey(x, weights=c(0.299, 0.587, 0.114), transparent=FALSE)
is.grey(x)
to.opaque(x)
to.transparent(x, fraction)
to.saturated(x, s=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colourtools_+3A_x">x</code>, <code id="colourtools_+3A_y">y</code></td>
<td>

<p>Any valid specification for a colour or sequence of colours
accepted by <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>.
</p>
</td></tr>
<tr><td><code id="colourtools_+3A_v">v</code></td>
<td>

<p>A numeric vector of length 3, giving the RGB values of
a single colour, or a 3-column matrix giving the RGB values of
several colours. Alternatively a vector of length 4 or a matrix with
4 columns, giving the RGB and alpha (transparency) values.
</p>
</td></tr>
<tr><td><code id="colourtools_+3A_red">red</code>, <code id="colourtools_+3A_green">green</code>, <code id="colourtools_+3A_blue">blue</code>, <code id="colourtools_+3A_alpha">alpha</code></td>
<td>

<p>Arguments acceptable to <code><a href="grDevices.html#topic+rgb">rgb</a></code>
determining the red, green, blue channels and optionally the
alpha (transparency) channel.
Note that <code>red</code> can also be a matrix with 3 <b>rows</b>
giving the RGB values, or a matrix with 4 rows
giving RGB and alpha values.
</p>
</td></tr>
<tr><td><code id="colourtools_+3A_maxcolorvalue">maxColorValue</code></td>
<td>

<p>Number giving the maximum possible value for the entries in
<code>v</code> or <code>red,green,blue,alpha</code>.
</p>
</td></tr>
<tr><td><code id="colourtools_+3A_weights">weights</code></td>
<td>

<p>Numeric vector of length 3 giving 
relative weights for the red, green, and blue
channels respectively.
</p>
</td></tr>
<tr><td><code id="colourtools_+3A_transparent">transparent</code></td>
<td>

<p>Logical value indicating whether transparent colours should
be converted to transparent grey values (<code>transparent=TRUE</code>)
or converted to opaque grey values (<code>transparent=FALSE</code>, the
default).
</p>
</td></tr>
<tr><td><code id="colourtools_+3A_fraction">fraction</code></td>
<td>

<p>Transparency fraction. Numerical value or vector of values
between 0 and 1, giving the opaqueness of a colour.
A fully opaque colour has <code>fraction=1</code>.
</p>
</td></tr>
<tr><td><code id="colourtools_+3A_length.out">length.out</code></td>
<td>

<p>Integer. Length of desired sequence.
</p>
</td></tr>
<tr><td><code id="colourtools_+3A_s">s</code></td>
<td>

<p>Saturation value (between 0 and 1).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is.colour(x)</code> can be applied to any kind of data <code>x</code>
and returns <code>TRUE</code> if <code>x</code> can be interpreted as a colour or
colours. The remaining functions expect data that can be interpreted
as colours.
</p>
<p><code>col2hex</code> converts colours specified in any format
into their hexadecimal character codes.
</p>
<p><code>rgb2hex</code> converts RGB colour values into their hexadecimal
character codes. It is a very minor extension to <code><a href="grDevices.html#topic+rgb">rgb</a></code>.
Arguments to <code>rgb2hex</code> should be similar to
arguments to <code><a href="grDevices.html#topic+rgb">rgb</a></code>.
</p>
<p><code>rgb2hsva</code> converts RGB colour values into HSV colour values
including the alpha (transparency) channel.
It is an extension of <code><a href="grDevices.html#topic+rgb2hsv">rgb2hsv</a></code>.
Arguments to <code>rgb2hsva</code> should be similar to arguments to
<code><a href="grDevices.html#topic+rgb2hsv">rgb2hsv</a></code>.
</p>
<p><code>paletteindex</code> checks whether the colour or colours specified
by <code>x</code> are available in the default palette returned by
<code><a href="grDevices.html#topic+palette">palette</a>()</code>. If so, it returns the index or indices of
the colours in the palette. If not, it returns <code>NA</code>.
</p>
<p><code>samecolour</code> decides whether two colours <code>x</code> and <code>y</code>
are equivalent.
</p>
<p><code>is.grey</code> determines whether each entry of <code>x</code> is a
greyscale colour, and returns a logical vector.
</p>
<p><code>to.grey</code> converts the colour data in <code>x</code> to greyscale
colours. Alternatively <code>x</code> can be an object of class <code>"colourmap"</code>
and <code>to.grey(x)</code> is the modified colour map.
</p>
<p><code>to.opaque</code> converts the colours in <code>x</code> to opaque
(non-transparent) colours, and <code>to.transparent</code> converts them
to transparent colours with a specified transparency value.
Note that <code>to.transparent(x,1)</code> is equivalent to <code>to.opaque(x)</code>.
</p>
<p>For <code>to.grey</code>, <code>to.opaque</code> and
<code>to.transparent</code>, if all the data in <code>x</code> specifies colours from the
standard palette, and if the result would be equivalent to <code>x</code>,
then the result is identical to <code>x</code>.
</p>
<p><code>to.saturated</code> converts each colour in <code>x</code> to
its fully-saturated equivalent. For example, pink is mapped to red.
Shades of grey are converted to black; white is unchanged.
</p>
<p><code>complementarycolour</code> replaces each colour by its
complementary colour in RGB space (the colour obtained by replacing
RGB values <code>(r, g, b)</code> by <code>(255-r, 255-g, 255-b)</code>).
The transparency value is not changed.
Alternatively <code>x</code> can be an object of class <code>"colourmap"</code>
and <code>complementarycolour(x)</code> is the modified colour map.
</p>
<p><code>interp.colours</code> interpolates between each successive pair of
colours in a sequence of colours, to generate a more finely-spaced
sequence. It uses linear interpolation in HSV space (with hue
represented as a two-dimensional unit vector).
</p>


<h3>Value</h3>

<p>For <code>col2hex</code> and <code>rgb2hex</code> 
a character vector containing hexadecimal colour codes.
</p>
<p>For <code>to.grey</code>, <code>to.opaque</code> and <code>to.transparent</code>,
either a character vector containing hexadecimal colour codes,
or a value identical to the input <code>x</code>.
</p>
<p>For <code>rgb2hsva</code>, a matrix with 3 or 4 rows containing
HSV colour values.
</p>
<p>For <code>paletteindex</code>, an integer vector, possibly containing
<code>NA</code> values.
</p>
<p>For <code>samecolour</code> and <code>is.grey</code>,
a logical value or logical vector.
</p>


<h3>Warning</h3>

<p><code>paletteindex("green")</code> returns <code>NA</code> because
the green colour in the default palette is called <code>"green3"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>,
<code><a href="grDevices.html#topic+rgb2hsv">rgb2hsv</a></code>,
<code><a href="grDevices.html#topic+palette">palette</a></code>.
</p>
<p>See also the class of colour map objects in the <span class="pkg">spatstat</span> package:
<code><a href="#topic+colourmap">colourmap</a></code>, 
<code><a href="#topic+interp.colourmap">interp.colourmap</a></code>, 
<code><a href="#topic+tweak.colourmap">tweak.colourmap</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  samecolour("grey", "gray")
  paletteindex("grey")
  col2hex("orange")
  to.grey("orange")
  to.saturated("orange")
  complementarycolour("orange")
  is.grey("lightgrey")
  is.grey(8)
  to.transparent("orange", 0.5)
  to.opaque("red")
  interp.colours(c("orange", "red", "violet"), 5)
</code></pre>

<hr>
<h2 id='commonGrid'>Determine A Common Spatial Domain And Pixel Resolution</h2><span id='topic+commonGrid'></span>

<h3>Description</h3>

<p>Determine a common spatial domain and pixel resolution for
several spatial objects such as images, masks, windows
and point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commonGrid(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commonGrid_+3A_...">...</code></td>
<td>

<p>Any number of pixel images (objects of class <code>"im"</code>),
binary masks (objects of class <code>"owin"</code> of type <code>"mask"</code>)
or data which can be converted to binary masks by <code><a href="#topic+as.mask">as.mask</a></code>.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function determines a common spatial resolution and spatial domain
for several spatial objects. 
</p>
<p>The arguments <code>...</code> may be pixel images,
binary masks, or other spatial objects acceptable to <code><a href="#topic+as.mask">as.mask</a></code>.
</p>
<p>The common pixel grid is determined by inspecting all the pixel images
and binary masks in the argument list, finding the pixel grid with the
highest spatial resolution, and extending this pixel grid to cover the
bounding box of all the spatial objects.
</p>
<p>The return value is a binary mask <code>M</code>, representing the bounding box
at the chosen pixel resolution.
Use <code><a href="#topic+as.im">as.im</a>(X, W=M)</code> to convert a pixel image <code>X</code> to this new
pixel resolution.
Use <code><a href="#topic+as.mask">as.mask</a>(W, xy=M)</code> to convert a window <code>W</code>
to a binary mask at this new pixel resolution.
See the Examples.
</p>


<h3>Value</h3>

<p>A binary mask (object of class <code>"owin"</code> and type <code>"mask"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+harmonise.im">harmonise.im</a></code>,
<code><a href="#topic+compatible.im">compatible.im</a></code>,
<code><a href="#topic+as.im">as.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(spatstat.random)) {
   A &lt;- setcov(square(1), dimyx=32)
   G &lt;- as.im(function(x,y) { x^2 - y }, W=owin(), dimyx=8)
   H &lt;- commonGrid(A, letterR, G)
   newR &lt;- as.mask(letterR, xy=H)
   newG &lt;- as.im(G, W=H)
   if(interactive()) plot(solist(G=newG, R=newR), main="")
}
</code></pre>

<hr>
<h2 id='compatible'>Test Whether Objects Are Compatible</h2><span id='topic+compatible'></span>

<h3>Description</h3>

<p>Tests whether two or more objects of the same class 
are compatible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  compatible(A, B, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compatible_+3A_a">A</code>, <code id="compatible_+3A_b">B</code>, <code id="compatible_+3A_...">...</code></td>
<td>
<p>Two or more objects of the same class</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function is used to check whether the
objects <code>A</code> and <code>B</code> (and any additional
objects <code>...</code>) are compatible.
</p>
<p>What is meant by &lsquo;compatible&rsquo; depends on the class of object.
</p>
<p>There are methods for the classes <code>"fv"</code>, <code>"fasp"</code>,
<code>"im"</code> and <code>"unitname"</code>. See the documentation for these
methods for further information.
</p>


<h3>Value</h3>

<p>Logical value: <code>TRUE</code> if the objects are compatible, and <code>FALSE</code>
if they are not.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+compatible.fv">compatible.fv</a></code>,
<code><a href="spatstat.explore.html#topic+compatible.fasp">compatible.fasp</a></code>,
<code><a href="#topic+compatible.im">compatible.im</a></code>,
<code><a href="#topic+compatible.unitname">compatible.unitname</a></code> 
</p>

<hr>
<h2 id='compatible.im'>Test Whether Pixel Images Are Compatible</h2><span id='topic+compatible.im'></span>

<h3>Description</h3>

<p>Tests whether two or more pixel image objects have compatible dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'im'
compatible(A, B, ..., tol=1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compatible.im_+3A_a">A</code>, <code id="compatible.im_+3A_b">B</code>, <code id="compatible.im_+3A_...">...</code></td>
<td>
<p>Two or more pixel images (objects of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="compatible.im_+3A_tol">tol</code></td>
<td>
<p>Tolerance factor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether the pixel images <code>A</code> and <code>B</code>
(and any additional images <code>...</code>)
have compatible pixel dimensions. They are compatible if they have
the same number of rows and columns, the same physical pixel
dimensions, and occupy the same rectangle in the plane.
</p>
<p>The argument <code>tol</code> specifies the maximum tolerated error
in the pixel coordinates, expressed as a
fraction of the dimensions of a single pixel.
</p>


<h3>Value</h3>

<p>Logical value: <code>TRUE</code> if the images are compatible, and <code>FALSE</code>
if they are not.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.im">eval.im</a></code>,
<code><a href="#topic+harmonise.im">harmonise.im</a></code>,
<code><a href="#topic+commonGrid">commonGrid</a></code>
</p>

<hr>
<h2 id='complement.owin'>Take Complement of a Window</h2><span id='topic+complement.owin'></span>

<h3>Description</h3>

<p>Take the set complement of a window, within its enclosing rectangle
or in a larger rectangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> complement.owin(w, frame=as.rectangle(w))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complement.owin_+3A_w">w</code></td>
<td>

<p>an object of class <code>"owin"</code> describing
a window of observation for a point pattern.
</p>
</td></tr>
<tr><td><code id="complement.owin_+3A_frame">frame</code></td>
<td>

<p>Optional. The enclosing rectangle,
with respect to which the set complement is taken.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This yields a window object (of class <code>"owin"</code>,
see <code><a href="#topic+owin.object">owin.object</a></code>) representing the set complement
of <code>w</code> with respect to the rectangle <code>frame</code>.
</p>
<p>By default, <code>frame</code> is the enclosing box of <code>w</code>
(originally specified by the arguments <code>xrange</code> and <code>yrange</code>
given to <code><a href="#topic+owin">owin</a></code> when <code>w</code> was created).
If <code>frame</code> is specified, it must be a rectangle (an object of
class <code>"owin"</code> whose type is <code>"rectangle"</code>) and it must be
larger than the enclosing box of <code>w</code>. This rectangle becomes the
enclosing box for the resulting window.
</p>
<p>If <code>w</code> is a rectangle, then <code>frame</code> must be specified.
Otherwise an error will occur (since the complement of <code>w</code> in
itself is empty).
</p>
<p>For rectangular and polygonal windows, the complement is computed by
reversing the sign of each boundary polygon, while for binary masks it is
computed by negating the pixel values.
</p>


<h3>Value</h3>

<p>Another object of class <code>"owin"</code> 
representing the complement of the window, i.e. the inside
of the window becomes the outside.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # rectangular
   a &lt;- owin(c(0,1),c(0,1))
   b &lt;- owin(c(-1,2),c(-1,2))
   bmina &lt;- complement.owin(a, frame=b)
   # polygonal
   w &lt;- Window(demopat)
   outside &lt;- complement.owin(w)
   # mask
   w &lt;- as.mask(Window(demopat))
   outside &lt;- complement.owin(w)
</code></pre>

<hr>
<h2 id='concatxy'>Concatenate x,y Coordinate Vectors</h2><span id='topic+concatxy'></span>

<h3>Description</h3>

<p>Concatenate any number of pairs of <code>x</code> and <code>y</code>
coordinate vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  concatxy(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concatxy_+3A_...">...</code></td>
<td>

<p>Any number of arguments, each of which is a structure
containing elements <code>x</code> and <code>y</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to superimpose two or more point patterns
of unmarked points (but see also <code><a href="#topic+superimpose">superimpose</a></code> which is
recommended). 
</p>
<p>It assumes that each of the arguments in
<code>...</code> is a structure containing (at least) the elements
<code>x</code> and <code>y</code>. It concatenates all the <code>x</code> elements
into a vector <code>x</code>, and similarly for <code>y</code>, and returns these
concatenated vectors.
</p>


<h3>Value</h3>

<p>A list with two components <code>x</code> and <code>y</code>, which are the
concatenations of all the corresponding <code>x</code> and <code>y</code>
vectors in the argument list.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+superimpose">superimpose</a></code>,
<code><a href="#topic+quadscheme">quadscheme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- runifrect(30)
  xy &lt;- list(x=runif(10),y=runif(10))
  new &lt;- concatxy(dat, xy)
</code></pre>

<hr>
<h2 id='connected'>
Connected components
</h2><span id='topic+connected'></span><span id='topic+connected.im'></span><span id='topic+connected.owin'></span>

<h3>Description</h3>

<p>Finds the topologically-connected components of a spatial object,
such as the connected clumps of pixels in a binary image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connected(X, ...)

## S3 method for class 'owin'
connected(X, ..., method="C", connect=8)

## S3 method for class 'im'
connected(X, ..., background = NA, method="C", connect=8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connected_+3A_x">X</code></td>
<td>

<p>A spatial object such as a pixel image (object of class <code>"im"</code>)
or a window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="connected_+3A_background">background</code></td>
<td>

<p>Optional. Treat pixels with this value 
as being part of the background.
</p>
</td></tr>
<tr><td><code id="connected_+3A_method">method</code></td>
<td>

<p>String indicating the algorithm to be used. Either <code>"C"</code>
or <code>"interpreted"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="connected_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine the
pixel resolution.
</p>
</td></tr>
<tr><td><code id="connected_+3A_connect">connect</code></td>
<td>

<p>The connectivity of the pixel grid: either 8 or 4.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>connected</code> is generic, with methods
for pixel images (class <code>"im"</code>) and windows (class <code>"owin"</code>)
described here. There are also methods for
tessellations (<code><a href="#topic+connected.tess">connected.tess</a></code>),
point patterns (<code><a href="#topic+connected.ppp">connected.ppp</a></code> and
<code>connected.lpp</code>),
and linear networks (<code>connected.linnet</code>).
</p>
<p>The functions described here compute the connected component transform
(Rosenfeld and Pfalz, 1966)
of a binary image or binary mask. The argument <code>X</code> is first
converted into a pixel image with logical values. Then the algorithm
identifies the connected components (topologically-connected clumps
of pixels) in the foreground.
</p>
<p>Two pixels belong to the same connected component if they have the value
<code>TRUE</code> and if they are neighbours.
This rule is applied repeatedly until it terminates.
Then each connected component
contains all the pixels that can be reached by stepping from neighbour
to neighbour.
</p>
<p>Pixels are defined to be neighbours if they are physically adjacent to
each other. If <code>connect=4</code>, each pixel has 4 neighbours,
lying one step above or below, or one step to the left or right.  
If <code>connect=8</code> (the default), each pixel has 8 neighbours,
lying one step above or below, or one step to the left or right,
or one diagonal step away. (Pixels at the edge of the image have fewer
neighbours.) The 8-connected algorithm is the default
because it gives better results when the pixel grid is coarse. The
4-connected algorithm is faster and is recommended when the pixel grid
is fine.
</p>
<p>If <code>method="C"</code>, the computation is performed by a compiled C language
implementation of the classical algorithm of Rosenfeld and Pfalz
(1966). If <code>method="interpreted"</code>, the computation is performed
by an <span class="rlang"><b>R</b></span> implementation of the algorithm of Park et al (2000). 
</p>
<p>The result is a factor-valued image, with levels that correspond to
the connected components. The Examples show how to extract each
connected component as a separate window object.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) with factor values.
The levels of the factor correspond to the connected components.
</p>


<h3>Warnings</h3>

<p>It may be hard to distinguish different components 
in the default plot because the colours of nearby components may be
very similar. See the Examples for a randomised colour map.
</p>
<p>The algorithm for <code>method="interpreted"</code>
can be very slow for large images (or images where
the connected components include a large number of pixels).
</p>


<h3>Author(s)</h3>

<p>Original <span class="rlang"><b>R</b></span> code by Julian Burgos, University of Washington.
Adapted for <span class="pkg">spatstat</span> by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Park, J.-M., Looney, C.G. and Chen, H.-C. (2000)
Fast connected component labeling algorithm using a divide and conquer
technique. Pages 373-376 in
S.Y. Shin (ed) <em>Computers and Their Applications:</em> Proceedings of
the ISCA 15th International Conference on Computers and Their
Applications, March 29-31, 2000, New Orleans, Louisiana USA. ISCA
2000, ISBN 1-880843-32-3. 
</p>
<p>Rosenfeld, A. and Pfalz, J.L. (1966)
Sequential operations in digital processing.
<em>Journal of the Association for Computing Machinery</em> <b>13</b>
471-494.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connected.ppp">connected.ppp</a></code>,
<code><a href="#topic+connected.tess">connected.tess</a></code>,
<code><a href="#topic+im.object">im.object</a></code>, 
<code><a href="#topic+tess">tess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- distmap(cells, dimyx=256)
  X &lt;- levelset(d, 0.07)
  plot(X)
  Z &lt;- connected(X)
  plot(Z)
  # or equivalently
  Z &lt;- connected(d &lt;= 0.07)

  # number of components
  nc &lt;- length(levels(Z))
  # plot with randomised colour map
  plot(Z, col=hsv(h=sample(seq(0,1,length=nc), nc)))

  # how to extract the components as a list of windows
  W &lt;- tiles(tess(image=Z))
</code></pre>

<hr>
<h2 id='connected.ppp'>
Connected Components of a Point Pattern
</h2><span id='topic+connected.ppp'></span><span id='topic+connected.pp3'></span>

<h3>Description</h3>

<p>Finds the topologically-connected components of a point pattern,
when all pairs of points closer than a threshold distance are joined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
connected(X, R, ...)

## S3 method for class 'pp3'
connected(X, R, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connected.ppp_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code> or <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="connected.ppp_+3A_r">R</code></td>
<td>

<p>Threshold distance. Pairs of points closer than <code>R</code> units apart
will be joined together.
</p>
</td></tr>
<tr><td><code id="connected.ppp_+3A_...">...</code></td>
<td>

<p>Other arguments, not recognised by these methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to identify clumps of points in a point pattern.
</p>
<p>The function <code>connected</code> is generic. This file documents the methods for
point patterns in dimension two or three (objects of class <code>"ppp"</code> or
<code>"pp3"</code>).
</p>
<p>The point pattern <code>X</code> is first converted into an abstract graph
by joining every pair of points that lie closer than <code>R</code> units
apart. Then the connected components of this graph are identified.
</p>
<p>Two points in <code>X</code> belong to the same connected component if they
can be reached by a series of steps between points of <code>X</code>,
each step being shorter than <code>R</code> units in length.
</p>
<p>The result is a vector of labels for the points of <code>X</code>
where all the points in a connected component have the same label.
</p>


<h3>Value</h3>

<p>A point pattern, equivalent to <code>X</code> except that the points
have factor-valued marks, with levels corresponding to the
connected components.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connected.im">connected.im</a></code>,
<code><a href="#topic+im.object">im.object</a></code>, 
<code><a href="#topic+tess">tess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Y &lt;- connected(redwoodfull, 0.1)
   if(interactive()) {
    plot(Y, cols=1:length(levels(marks(Y))),
         main="connected(redwoodfull, 0.1)")
   }
   X &lt;- osteo$pts[[1]]
   Z &lt;- connected(X, 32)
   if(interactive()) {
    plot(Z, col=marks(Z), main="")
   }
</code></pre>

<hr>
<h2 id='connected.tess'>
Connected Components of Tiles of a Tessellation
</h2><span id='topic+connected.tess'></span>

<h3>Description</h3>

<p>Given a tessellation, find the topologically-connected pieces
of each tile, and make a new tessellation using these pieces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tess'
connected(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connected.tess_+3A_x">X</code></td>
<td>

<p>A tessellation (object of class <code>"tess"</code>).
</p>
</td></tr>
<tr><td><code id="connected.tess_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine the
pixel resolution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>connected</code> is generic.
This function <code>connected.tess</code> is the method for tessellations.
</p>
<p>Given the tessellation <code>X</code>, the algorithm considers each tile
of the tessellation, and identifies its connected components
(topologically-connected pieces) using <code><a href="#topic+connected.owin">connected.owin</a></code>.
Each of these pieces is treated as a distinct tile
and a new tessellation is made from these pieces.
</p>
<p>The result is another tessellation obtained by subdividing each tile
of <code>X</code> into one or more new tiles.
</p>


<h3>Value</h3>

<p>Another tessellation (object of class <code>"tess"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connected.owin">connected.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  BB &lt;- grow.rectangle(Frame(letterR), 0.2)
  H &lt;- tess(tiles=list(IN=letterR, OUT=complement.owin(letterR, BB)))
  opa &lt;- par(mfrow=c(1,2))
  plot(H, do.col=TRUE)
  plot(connected(H), do.col=TRUE, col=2:4)
  par(opa)
</code></pre>

<hr>
<h2 id='contour.im'>Contour plot of pixel image</h2><span id='topic+contour.im'></span>

<h3>Description</h3>

<p>Generates a contour plot of a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'im'
contour(x, ..., main, axes=FALSE, add=FALSE,
            nlevels=10, levels=NULL, labels=NULL, log=FALSE, 
            col=par("fg"), 
            clipwin=NULL, show.all=!add, do.plot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour.im_+3A_x">x</code></td>
<td>

<p>Pixel image to be plotted.
An object of class <code>"im"</code>.
</p>
</td></tr>
<tr><td><code id="contour.im_+3A_main">main</code></td>
<td>

<p>Character string to be displayed as the main title.
</p>
</td></tr>
<tr><td><code id="contour.im_+3A_nlevels">nlevels</code>, <code id="contour.im_+3A_levels">levels</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+contour.default">contour.default</a></code>
controlling the choice of contour levels.
</p>
</td></tr>
<tr><td><code id="contour.im_+3A_labels">labels</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+contour.default">contour.default</a></code>
controlling the text labels plotted next to the contour lines.
</p>
</td></tr>
<tr><td><code id="contour.im_+3A_log">log</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, the contour levels will be
evenly-spaced on a logarithmic scale.
</p>
</td></tr>
<tr><td><code id="contour.im_+3A_axes">axes</code></td>
<td>

<p>Logical. If <code>TRUE</code>, coordinate axes are plotted
(with tick marks) around a region slightly larger than the image window.
If <code>FALSE</code> (the default), no axes are plotted,
and a box is drawn tightly around the image window.
Ignored if <code>add=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="contour.im_+3A_add">add</code></td>
<td>

<p>Logical. If <code>FALSE</code>, a new plot is created. If <code>TRUE</code>,
the contours are drawn over the existing plot.
</p>
</td></tr>
<tr><td><code id="contour.im_+3A_col">col</code></td>
<td>

<p>Colour in which to draw the contour lines.
Either a single value that can be interpreted as a colour value,
or a <code>colourmap</code> object.
</p>
</td></tr>
<tr><td><code id="contour.im_+3A_clipwin">clipwin</code></td>
<td>

<p>Optional. A window (object of class <code>"owin"</code>).
Only this subset of the data will be displayed.
</p>
</td></tr>
<tr><td><code id="contour.im_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="graphics.html#topic+contour.default">contour.default</a></code>
controlling the contour plot; see Details.
</p>
</td></tr>
<tr><td><code id="contour.im_+3A_show.all">show.all</code></td>
<td>

<p>Logical value indicating whether to display all plot elements
including the main title, bounding box, and (if
<code>axis=TRUE</code>) coordinate axis markings.
Default is <code>TRUE</code> for new plots and <code>FALSE</code> for added plots.
</p>
</td></tr>
<tr><td><code id="contour.im_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value indicating whether to actually perform the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic <code>contour</code> function,
for objects of the class <code>"im"</code>.
</p>
<p>An object of class <code>"im"</code> represents a pixel image;
see <code><a href="#topic+im.object">im.object</a></code>.
</p>
<p>This function displays the values of the pixel image <code>x</code>
as a contour plot on the current plot device,
using equal scales on the <code class="reqn">x</code> and <code class="reqn">y</code> axes.
</p>
<p>The appearance of the plot can be modified
using any of the arguments listed in the help for
<code><a href="graphics.html#topic+contour.default">contour.default</a></code>.
Useful ones include:
</p>

<dl>
<dt>nlevels</dt><dd>
<p>Number of contour levels to plot.
</p>
</dd>
<dt>drawlabels</dt><dd>
<p>Whether to label the contour lines with text.
</p>
</dd>
<dt>col,lty,lwd</dt><dd>
<p>Colour, type, and width of contour lines.
</p>
</dd>
</dl>

<p>See <code><a href="graphics.html#topic+contour.default">contour.default</a></code> for a full list of these arguments.
</p>
<p>The defaults for any of the abovementioned arguments
can be reset using <code><a href="#topic+spatstat.options">spatstat.options</a>("par.contour")</code>.
</p>
<p>If <code>log=TRUE</code>, the contour lines will be evenly-spaced
on a logarithmic scale, provided the range of pixel values
is at least 1.5 orders of magnitude (a ratio of at least 32).
Otherwise the levels will be evenly-spaced on the original scale.
</p>
<p>If <code>col</code> is a colour map (object of class <code>"colourmap"</code>,
see <code><a href="#topic+colourmap">colourmap</a></code>) then the contours will be plotted in
different colours as determined by the colour map.
The contour at level <code>z</code> will be plotted
in the colour <code>col(z)</code> associated with this level in the colour map.
</p>


<h3>Value</h3>

<p>Invisibly, a rectangle (object of class <code>"owin"</code> specifying a rectangle)
containing the plotted region.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im.object">im.object</a></code>,
<code><a href="#topic+plot.im">plot.im</a></code>,
<code><a href="#topic+persp.im">persp.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # an image
   Z &lt;- setcov(owin())
   contour(Z, axes=TRUE)
   contour(Z)

   V &lt;- 100 * Z^2 + 1
   contour(V, log=TRUE, labcex=1)

   co &lt;- colourmap(rainbow(100), range=c(0,1))
   contour(Z, col=co, lwd=2)
</code></pre>

<hr>
<h2 id='contour.imlist'>Array of Contour Plots</h2><span id='topic+contour.imlist'></span><span id='topic+contour.listof'></span>

<h3>Description</h3>

<p>Generates an array of contour plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'imlist'
contour(x, ...)

  ## S3 method for class 'listof'
contour(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour.imlist_+3A_x">x</code></td>
<td>

<p>An object of the class <code>"imlist"</code>
representing a list of pixel images.
Alternatively <code>x</code> may belong to the outdated class <code>"listof"</code>.
</p>
</td></tr>
<tr><td><code id="contour.imlist_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+plot.solist">plot.solist</a></code> to control the
spatial arrangement of panels, and arguments passed
to <code><a href="#topic+contour.im">contour.im</a></code> to control the display of each panel.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic command
<code>contour</code> for the class <code>"imlist"</code>.
An object of class <code>"imlist"</code> represents a list of pixel images.
</p>
<p>(The outdated class <code>"listof"</code> is also handled.)
</p>
<p>Each entry in the list <code>x</code> will be displayed as a contour plot,
in an array of panels laid out on the same graphics display,
using <code><a href="#topic+plot.solist">plot.solist</a></code>. Invididual panels are plotted
by <code><a href="#topic+contour.im">contour.im</a></code>.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.solist">plot.solist</a></code>,
<code><a href="#topic+contour.im">contour.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># bei.extra is a named list of covariate images
 contour(bei.extra,
         main="Barro Colorado: covariates")
</code></pre>

<hr>
<h2 id='convexhull'>Convex Hull</h2><span id='topic+convexhull'></span>

<h3>Description</h3>

<p>Computes the convex hull of a spatial object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convexhull(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convexhull_+3A_x">x</code></td>
<td>

<p>a window (object of class <code>"owin"</code>),
a point pattern (object of class <code>"ppp"</code>),
a line segment pattern (object of class <code>"psp"</code>),
or an object that can be converted to a window
by <code><a href="#topic+as.owin">as.owin</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the convex hull of the spatial object <code>x</code>.
</p>


<h3>Value</h3>

<p>A window (an object of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+convexhull.xy">convexhull.xy</a></code>,
<code><a href="#topic+is.convex">is.convex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   W &lt;- Window(demopat)
   plot(convexhull(W), col="lightblue", border=NA)
   plot(W, add=TRUE, lwd=2)
</code></pre>

<hr>
<h2 id='convexhull.xy'>Convex Hull of Points</h2><span id='topic+convexhull.xy'></span>

<h3>Description</h3>

<p>Computes the convex hull of a set of points in two dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convexhull.xy(x, y=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convexhull.xy_+3A_x">x</code></td>
<td>

<p>vector of <code>x</code> coordinates of observed points,
or a 2-column matrix giving <code>x,y</code> coordinates,
or a list with components <code>x,y</code> giving coordinates
(such as a point pattern object of class <code>"ppp"</code>.)
</p>
</td></tr>
<tr><td><code id="convexhull.xy_+3A_y">y</code></td>
<td>
<p>(optional) vector of <code>y</code> coordinates of observed points,
if <code>x</code> is a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an observed pattern of points with coordinates 
given by <code>x</code> and <code>y</code>, this function computes 
the convex hull of the points, and returns it as a window.
</p>


<h3>Value</h3>

<p>A window (an object of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+convexhull">convexhull</a></code>,
<code><a href="#topic+bounding.box.xy">bounding.box.xy</a></code>,
<code><a href="#topic+ripras">ripras</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- runif(30)
  y &lt;- runif(30)
  w &lt;- convexhull.xy(x,y)
  plot(owin(), main="convexhull.xy(x,y)", lty=2)
  plot(w, add=TRUE)
  points(x,y)

  X &lt;- runifrect(30)
  plot(X, main="convexhull.xy(X)")
  plot(convexhull.xy(X), add=TRUE)
</code></pre>

<hr>
<h2 id='convexify'>
Weil's Convexifying Operation
</h2><span id='topic+convexify'></span>

<h3>Description</h3>

<p>Converts the window <code>W</code> into a convex set by rearranging
the edges, preserving spatial orientation of each edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> convexify(W, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convexify_+3A_w">W</code></td>
<td>

<p>A window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="convexify_+3A_eps">eps</code></td>
<td>

<p>Optional. Minimum edge length of polygonal approximation,
if <code>W</code> is not a polygon.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weil (1995) defined a convexification operation 
for windows <code class="reqn">W</code> that belong to the convex ring (that is,
for any <code class="reqn">W</code> which is a finite union of convex sets).
Note that this is <b>not</b> the same as the convex hull.
</p>
<p>The convexified set <code class="reqn">f(W)</code> has the same total boundary length as
<code class="reqn">W</code> and the same distribution of orientations of the boundary.
If <code class="reqn">W</code> is a polygonal set, then the convexification <code class="reqn">f(W)</code>
is obtained by rearranging all the edges of <code class="reqn">W</code> in order of
their spatial orientation.
</p>
<p>The argument <code>W</code> must be a window. If it is not already a polygonal
window, it is first converted to one, using
<code><a href="#topic+simplify.owin">simplify.owin</a></code>.
The edges are sorted in increasing order of angular orientation
and reassembled into a convex polygon.
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Weil, W. (1995)
The estimation of mean particle shape and mean
particle number in overlapping particle systems in
the plane. <em>Advances in Applied Probability</em> <b>27</b>, 102&ndash;119.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convexhull">convexhull</a></code> for the convex hull of a window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  opa &lt;- par(mfrow=c(1,2))
  plot(letterR)
  plot(convexify(letterR))
  par(opa)
</code></pre>

<hr>
<h2 id='convexmetric'>
Distance Metric Defined by Convex Set
</h2><span id='topic+convexmetric'></span>

<h3>Description</h3>

<p>Create the distance metric associated with a given convex polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convexmetric(K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convexmetric_+3A_k">K</code></td>
<td>

<p>Convex set defining the metric.
A polygon that is symmetric about the origin. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates the distance metric
associated with the convex set <code>K</code>
so that the unit ball of the metric is equal to <code>K</code>.
It returns an object of class <code>"metric"</code> representing the metric
(see <code><a href="#topic+metric.object">metric.object</a></code>).
</p>
<p>The argument <code>K</code> must be a window (class <code>"owin"</code>).
It will be converted to a polygon.
It must be convex, and symmetric about the origin.
</p>
<p>To perform distance calculations (for example, nearest-neighbour
distances) using this metric instead of the
Euclidean metric, first check whether the standard function for this
purpose (for example <code>nndist.ppp</code>) 
has an argument named <code>metric</code>. If so, use the standard function
and add the argument <code>metric</code>; if not, use
the low-level function <code><a href="#topic+invoke.metric">invoke.metric</a></code>.
</p>
<p>To see which operations are currently supported by the metric,
use <code>summary</code>, as shown in the examples.
</p>


<h3>Value</h3>

<p>An object of class <code>"metric"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metric.object">metric.object</a></code>,
<code><a href="#topic+invoke.metric">invoke.metric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  K &lt;- owin(poly=list(x=c(2.5,2,0.5,-2.5,-2,-0.5),y=c(0,1,2,0,-1,-2)))
  plot(K)
  points(0,0)
  m &lt;- convexmetric(K)
  m
  summary(m)

  ## show redwood data and identify point number 43
  plot(redwood, main="")
  plot(redwood[43], pch=16, add=TRUE)

  ## compute nearest neighbour distances and identifiers
  ##   using the distance metric m
  nd &lt;- nndist(redwood, metric=m)
  nw &lt;- nnwhich(redwood, metric=m)

  ## Nearest neighbour distance for point number 43 is nd[43]; verify
  B43 &lt;- disc(radius=nd[43], centre=redwood[43], metric=m)
  plot(B43, add=TRUE)

  ## nearest neighbour for point number 43 is point number nw[43]; verify
  plot(redwood[nw[43]], pch=3, col="red", add=TRUE)
</code></pre>

<hr>
<h2 id='convolve.im'>Convolution of Pixel Images</h2><span id='topic+convolve.im'></span>

<h3>Description</h3>

<p>Computes the convolution of two pixel images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> convolve.im(X, Y=X, ..., reflectX=FALSE, reflectY=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convolve.im_+3A_x">X</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>.
</p>
</td></tr>
<tr><td><code id="convolve.im_+3A_y">Y</code></td>
<td>

<p>Optional. Another pixel image.
</p>
</td></tr>
<tr><td><code id="convolve.im_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="convolve.im_+3A_reflectx">reflectX</code>, <code id="convolve.im_+3A_reflecty">reflectY</code></td>
<td>

<p>Logical values specifying whether the images <code>X</code> and <code>Y</code>
(respectively) should be reflected in the origin before computing
the convolution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>convolution</em> of two pixel images <code class="reqn">X</code> and <code class="reqn">Y</code> in the plane
is the function <code class="reqn">C(v)</code> defined for each vector <code class="reqn">v</code> as
</p>
<p style="text-align: center;"><code class="reqn">
    C(v) = \int X(u)Y(v-u)\, {\rm d}u
  </code>
</p>

<p>where the integral is
over all spatial locations <code class="reqn">u</code>, and where <code class="reqn">X(u)</code> and
<code class="reqn">Y(u)</code> denote the pixel values of <code class="reqn">X</code> and <code class="reqn">Y</code> respectively
at location <code class="reqn">u</code>.
</p>
<p>This command computes a discretised approximation to
the convolution, using the Fast Fourier Transform.
The return value is
another pixel image (object of class <code>"im"</code>) whose greyscale values
are values of the convolution.
</p>
<p>If <code>reflectX = TRUE</code> then the pixel image <code>X</code> is reflected
in the origin (see <code><a href="#topic+reflect">reflect</a></code>)
before the convolution is computed, so that
<code>convolve.im(X,Y,reflectX=TRUE)</code> is mathematically
equivalent to <code>convolve.im(reflect(X), Y)</code>. (These two commands
are not exactly equivalent, because the reflection is performed
in the Fourier domain in the first command, and reflection is
performed in the spatial domain in the second command).
</p>
<p>Similarly if <code>reflectY = TRUE</code> then the pixel image <code>Y</code> is reflected
in the origin before the convolution is computed, so that
<code>convolve.im(X,Y,reflectY=TRUE)</code> is mathematically
equivalent to <code>convolve.im(X, reflect(Y))</code>.
</p>


<h3>Value</h3>

<p>A pixel image (an object of class <code>"im"</code>) representing the
convolution of <code>X</code> and <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+imcov">imcov</a></code>,
<code><a href="#topic+reflect">reflect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) {
    X &lt;- as.im(letterR)
    Y &lt;- as.im(square(1))
  } else {
    ## coarser image for testing
    X &lt;- as.im(letterR, dimyx=32)
    Y &lt;- as.im(square(1), dimyx=32)
  }
  plot(convolve.im(X, Y))
  plot(convolve.im(X, Y, reflectX=TRUE))
  plot(convolve.im(X))
</code></pre>

<hr>
<h2 id='coords'>
Extract or Change Coordinates of a Spatial or Spatiotemporal Point Pattern
</h2><span id='topic+coords'></span><span id='topic+coords.ppp'></span><span id='topic+coords.ppx'></span><span id='topic+coords.quad'></span><span id='topic+coords+3C-'></span><span id='topic+coords+3C-.ppp'></span><span id='topic+coords+3C-.ppx'></span>

<h3>Description</h3>

<p>Given any kind of spatial or space-time point pattern,
this function extracts the
(space and/or time and/or local) coordinates of the points
and returns them as a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  coords(x, ...)
  ## S3 method for class 'ppp'
coords(x, ...)
  ## S3 method for class 'ppx'
coords(x, ..., spatial = TRUE, temporal = TRUE, local=TRUE)
  coords(x, ...) &lt;- value
  ## S3 replacement method for class 'ppp'
coords(x, ...) &lt;- value
  ## S3 replacement method for class 'ppx'
coords(x, ..., spatial = TRUE, temporal = TRUE, local=TRUE) &lt;- value
  ## S3 method for class 'quad'
coords(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coords_+3A_x">x</code></td>
<td>

<p>A point pattern: either a two-dimensional point pattern
(object of class <code>"ppp"</code>), a three-dimensional point pattern
(object of class <code>"pp3"</code>), or a 
general multidimensional space-time point pattern 
(object of class <code>"ppx"</code>)
or a quadrature scheme (object of class <code>"quad"</code>).
</p>
</td></tr>
<tr><td><code id="coords_+3A_...">...</code></td>
<td>

<p>Further arguments passed to methods.
</p>
</td></tr>
<tr><td><code id="coords_+3A_spatial">spatial</code>, <code id="coords_+3A_temporal">temporal</code>, <code id="coords_+3A_local">local</code></td>
<td>

<p>Logical values indicating whether to extract spatial, temporal
and local coordinates, respectively. The default is to return all
such coordinates. (Only relevant to <code>ppx</code> objects).
</p>
</td></tr>
<tr><td><code id="coords_+3A_value">value</code></td>
<td>

<p>New values of the coordinates. A numeric vector with one entry for each
point in <code>x</code>, or a numeric matrix or data frame with one row
for each point in <code>x</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>coords</code> extracts the coordinates from
a point pattern. The function <code>coords&lt;-</code> replaces the coordinates
of the point pattern with new values.
</p>
<p>Both functions <code>coords</code> and <code>coords&lt;-</code> are generic, with methods for
the classes <code>"ppp"</code>) and <code>"ppx"</code>.
An object of class <code>"pp3"</code> also inherits from <code>"ppx"</code> and
is handled by the method for <code>"ppx"</code>.
</p>


<h3>Value</h3>

<p><code>coords</code> returns a <code>data.frame</code> with one row for each point,
containing the coordinates.
<code>coords&lt;-</code> returns the altered point pattern.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppx">ppx</a></code>,
<code><a href="#topic+pp3">pp3</a></code>,
<code><a href="#topic+ppp">ppp</a></code>,
<code>as.hyperframe.ppx</code>,
<code>as.data.frame.ppx</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   df &lt;- data.frame(x=runif(4),y=runif(4),t=runif(4))
   X &lt;- ppx(data=df, coord.type=c("s","s","t"))
   coords(X)
   coords(X, temporal=FALSE)
   coords(X) &lt;- matrix(runif(12), ncol=3)
</code></pre>

<hr>
<h2 id='corners'>Corners of a rectangle</h2><span id='topic+corners'></span>

<h3>Description</h3>

<p>Returns the four corners of a rectangle 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> corners(window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corners_+3A_window">window</code></td>
<td>
<p>A window. 
An object of class <code><a href="#topic+owin">owin</a></code>,
or data in any format acceptable to <code><a href="#topic+as.owin">as.owin</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This trivial function is occasionally convenient.
If <code>window</code> is of type <code>"rectangle"</code> this returns the
four corners of the window itself; 
otherwise, it returns the corners of the bounding rectangle
of the window.
</p>


<h3>Value</h3>

<p>A list with two components <code>x</code> and <code>y</code>, which are numeric
vectors of length 4 giving the coordinates of the four corner points
of the (bounding rectangle of the) window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="#topic+quadscheme">quadscheme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- unit.square()
  corners(w)
       # returns list(x=c(0,1,0,1),y=c(0,0,1,1))
</code></pre>

<hr>
<h2 id='covering'>Cover Region with Discs</h2><span id='topic+covering'></span>

<h3>Description</h3>

<p>Given a spatial region, this function finds an efficient
covering of the region using discs of a chosen radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> covering(W, r, ..., giveup=1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covering_+3A_w">W</code></td>
<td>

<p>A window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="covering_+3A_r">r</code></td>
<td>
<p>positive number: the radius of the covering discs.</p>
</td></tr>
<tr><td><code id="covering_+3A_...">...</code></td>
<td>

<p>extra arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
controlling the pixel resolution for the calculations.
</p>
</td></tr>
<tr><td><code id="covering_+3A_giveup">giveup</code></td>
<td>

<p>Maximum number of attempts to place additional discs.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds an efficient covering of the
window <code>W</code> using discs of the given radius <code>r</code>.
The result is a point pattern giving the centres of the discs.
</p>
<p>The algorithm tries to use as few discs as possible,
but is not guaranteed to find the minimal number of discs.
It begins by placing a hexagonal grid of points inside <code>W</code>,
then adds further points until every location inside <code>W</code> lies
no more than <code>r</code> units away from one of the points.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>)
giving the centres of the discs.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rr &lt;- 0.5
  X &lt;- covering(letterR, rr)
  plot(grow.rectangle(Frame(X), rr), type="n", main="")
  plot(X, pch=16, add=TRUE, col="red")
  plot(letterR, add=TRUE, lwd=3)
  plot(X %mark% (2*rr), add=TRUE, markscale=1)
</code></pre>

<hr>
<h2 id='crossdist'>Pairwise distances</h2><span id='topic+crossdist'></span>

<h3>Description</h3>

<p>Computes the distances between pairs of &lsquo;things&rsquo;
taken from two different datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  crossdist(X, Y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossdist_+3A_x">X</code>, <code id="crossdist_+3A_y">Y</code></td>
<td>

<p>Two objects of the same class.
</p>
</td></tr>
<tr><td><code id="crossdist_+3A_...">...</code></td>
<td>

<p>Additional arguments depending on the method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two datasets <code>X</code> and <code>Y</code>
(representing either two point patterns or
two line segment patterns)
<code>crossdist</code> computes the Euclidean distance from each thing
in the first dataset to each thing in the second dataset,
and returns a matrix containing these distances.
</p>
<p>The function <code>crossdist</code> is generic, with
methods for point patterns (objects of class <code>"ppp"</code>),
line segment patterns (objects of class <code>"psp"</code>),
and a default method. See the documentation for
<code><a href="#topic+crossdist.ppp">crossdist.ppp</a></code>,
<code><a href="#topic+crossdist.psp">crossdist.psp</a></code> or
<code><a href="#topic+crossdist.default">crossdist.default</a></code> for further details.
</p>


<h3>Value</h3>

<p>A matrix whose <code>[i,j]</code> entry is the distance
from the <code>i</code>-th thing in the first dataset
to the <code>j</code>-th thing in the second dataset.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossdist.ppp">crossdist.ppp</a></code>,
<code><a href="#topic+crossdist.psp">crossdist.psp</a></code>,
<code><a href="#topic+crossdist.default">crossdist.default</a></code>,
<code><a href="#topic+pairdist">pairdist</a></code>,
<code><a href="#topic+nndist">nndist</a></code>
</p>

<hr>
<h2 id='crossdist.default'>Pairwise distances between two different sets of points</h2><span id='topic+crossdist.default'></span>

<h3>Description</h3>

<p>Computes the distances between each pair of points
taken from two different sets of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## Default S3 method:
crossdist(X, Y, x2, y2, ...,
             period=NULL, method="C", squared=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossdist.default_+3A_x">X</code>, <code id="crossdist.default_+3A_y">Y</code></td>
<td>

<p>Numeric vectors of equal length specifying the coordinates of
the first set of points.
</p>
</td></tr>
<tr><td><code id="crossdist.default_+3A_x2">x2</code>, <code id="crossdist.default_+3A_y2">y2</code></td>
<td>

<p>Numeric vectors of equal length specifying the coordinates of
the second set of points.
</p>
</td></tr>
<tr><td><code id="crossdist.default_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="crossdist.default_+3A_period">period</code></td>
<td>

<p>Optional. Dimensions for periodic edge correction.
</p>
</td></tr>
<tr><td><code id="crossdist.default_+3A_method">method</code></td>
<td>

<p>String specifying which method of calculation to use.
Values are <code>"C"</code> and <code>"interpreted"</code>.
</p>
</td></tr>
<tr><td><code id="crossdist.default_+3A_squared">squared</code></td>
<td>

<p>Logical. If <code>squared=TRUE</code>, the squared distances are
returned instead (this computation is faster).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two sets of points,
this function computes the Euclidean distance from each point
in the first set to each point in the second set,
and returns a matrix containing these distances.
</p>
<p>This is a method for the generic function <code><a href="#topic+crossdist">crossdist</a></code>.
</p>
<p>This function expects <code>X</code> and <code>Y</code> to be numeric vectors
of equal length specifying the coordinates of the first set of points.
The arguments <code>x2</code>,<code>y2</code> specify the coordinates of the
second set of points.
</p>
<p>Alternatively if <code>period</code> is given,
then the distances will be computed in the &lsquo;periodic&rsquo;
sense (also known as &lsquo;torus&rsquo; distance).
The points will be treated as if they are in a rectangle
of width <code>period[1]</code> and height <code>period[2]</code>.
Opposite edges of the rectangle are regarded as equivalent.
</p>
<p>The argument <code>method</code> is not normally used. It is
retained only for checking the validity of the software.
If <code>method = "interpreted"</code> then the distances are
computed using interpreted R code only. If <code>method="C"</code>
(the default) then C code is used. 
The C code is faster by a factor of 4.
</p>


<h3>Value</h3>

<p>A matrix whose <code>[i,j]</code> entry is the distance
from the <code>i</code>-th point in the first set of points
to the <code>j</code>-th point in the second set of points.
</p>


<h3>Author(s)</h3>

<p>Pavel Grabarnik <a href="mailto:pavel.grabar@issp.serpukhov.su">pavel.grabar@issp.serpukhov.su</a>
and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossdist">crossdist</a></code>,
<code><a href="#topic+crossdist.ppp">crossdist.ppp</a></code>,
<code><a href="#topic+crossdist.psp">crossdist.psp</a></code>,
<code><a href="#topic+pairdist">pairdist</a></code>,
<code><a href="#topic+nndist">nndist</a></code>,
<code><a href="spatstat.explore.html#topic+Gest">Gest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   d &lt;- crossdist(runif(7), runif(7), runif(12), runif(12))
   d &lt;- crossdist(runif(7), runif(7), runif(12), runif(12), period=c(1,1))
</code></pre>

<hr>
<h2 id='crossdist.pp3'>Pairwise distances between two different three-dimensional point patterns</h2><span id='topic+crossdist.pp3'></span>

<h3>Description</h3>

<p>Computes the distances between pairs of points
taken from two different three-dimensional point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'pp3'
crossdist(X, Y, ..., periodic=FALSE, squared=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossdist.pp3_+3A_x">X</code>, <code id="crossdist.pp3_+3A_y">Y</code></td>
<td>

<p>Point patterns in three dimensions (objects of class <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="crossdist.pp3_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="crossdist.pp3_+3A_periodic">periodic</code></td>
<td>

<p>Logical. Specifies whether to apply a periodic edge correction.
</p>
</td></tr>
<tr><td><code id="crossdist.pp3_+3A_squared">squared</code></td>
<td>

<p>Logical. If <code>squared=TRUE</code>, the squared distances are
returned instead (this computation is faster).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two point patterns in three-dimensional space, 
this function computes the Euclidean distance from each point
in the first pattern to each point in the second pattern,
and returns a matrix containing these distances.
</p>
<p>This is a method for the generic function <code><a href="#topic+crossdist">crossdist</a></code>
for three-dimensional point patterns (objects of class <code>"pp3"</code>).
</p>
<p>This function expects two
point patterns <code>X</code> and <code>Y</code>, and returns the matrix
whose <code>[i,j]</code> entry is the distance from <code>X[i]</code> to
<code>Y[j]</code>.
</p>
<p>Alternatively if <code>periodic=TRUE</code>, then provided the windows
containing <code>X</code> and <code>Y</code> are identical and are rectangular,
then the distances will be computed in the &lsquo;periodic&rsquo;
sense (also known as &lsquo;torus&rsquo; distance): opposite edges of the
rectangle are regarded as equivalent.
This is meaningless if the window is not a rectangle.
</p>


<h3>Value</h3>

<p>A matrix whose <code>[i,j]</code> entry is the distance
from the <code>i</code>-th point in <code>X</code>
to the <code>j</code>-th point in <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
based on code for two dimensions by 
Pavel Grabarnik <a href="mailto:pavel.grabar@issp.serpukhov.su">pavel.grabar@issp.serpukhov.su</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossdist">crossdist</a></code>,
<code><a href="#topic+pairdist">pairdist</a></code>,
<code><a href="#topic+nndist">nndist</a></code>,
<code><a href="spatstat.explore.html#topic+G3est">G3est</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(spatstat.random)) {
   X &lt;- runifpoint3(20)
   Y &lt;- runifpoint3(30)
} else {
   X &lt;- osteo$pts[[1]]
   Y &lt;- osteo$pts[[2]]
   Y &lt;- Y[domain(X)]
}
   d &lt;- crossdist(X, Y)
   d &lt;- crossdist(X, Y, periodic=TRUE)
</code></pre>

<hr>
<h2 id='crossdist.ppp'>Pairwise distances between two different point patterns</h2><span id='topic+crossdist.ppp'></span>

<h3>Description</h3>

<p>Computes the distances between pairs of points
taken from two different point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
crossdist(X, Y, ...,
                periodic=FALSE, method="C", squared=FALSE,
                metric=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossdist.ppp_+3A_x">X</code>, <code id="crossdist.ppp_+3A_y">Y</code></td>
<td>

<p>Point patterns (objects of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="crossdist.ppp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="crossdist.ppp_+3A_periodic">periodic</code></td>
<td>

<p>Logical. Specifies whether to apply a periodic edge correction.
</p>
</td></tr>
<tr><td><code id="crossdist.ppp_+3A_method">method</code></td>
<td>

<p>String specifying which method of calculation to use.
Values are <code>"C"</code> and <code>"interpreted"</code>.
</p>
</td></tr>
<tr><td><code id="crossdist.ppp_+3A_squared">squared</code></td>
<td>

<p>Logical. If <code>squared=TRUE</code>, the squared distances are
returned instead (this computation is faster).
</p>
</td></tr>
<tr><td><code id="crossdist.ppp_+3A_metric">metric</code></td>
<td>

<p>Optional. A distance metric
(object of class <code>"metric"</code>, see <code><a href="#topic+metric.object">metric.object</a></code>)
which will be used to compute the distances.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two point patterns, 
this function computes the Euclidean distance from each point
in the first pattern to each point in the second pattern,
and returns a matrix containing these distances.
</p>
<p>This is a method for the generic function <code><a href="#topic+crossdist">crossdist</a></code>
for point patterns (objects of class <code>"ppp"</code>).
</p>
<p>This function expects two
point patterns <code>X</code> and <code>Y</code>, and returns the matrix
whose <code>[i,j]</code> entry is the distance from <code>X[i]</code> to
<code>Y[j]</code>.
</p>
<p>Alternatively if <code>periodic=TRUE</code>, then provided the windows
containing <code>X</code> and <code>Y</code> are identical and are rectangular,
then the distances will be computed in the &lsquo;periodic&rsquo;
sense (also known as &lsquo;torus&rsquo; distance): opposite edges of the
rectangle are regarded as equivalent.
This is meaningless if the window is not a rectangle.
</p>
<p>The argument <code>method</code> is not normally used. It is
retained only for checking the validity of the software.
If <code>method = "interpreted"</code> then the distances are
computed using interpreted R code only. If <code>method="C"</code>
(the default) then C code is used. 
The C code is faster by a factor of 4.
</p>


<h3>Value</h3>

<p>A matrix whose <code>[i,j]</code> entry is the distance
from the <code>i</code>-th point in <code>X</code>
to the <code>j</code>-th point in <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Pavel Grabarnik <a href="mailto:pavel.grabar@issp.serpukhov.su">pavel.grabar@issp.serpukhov.su</a>
and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossdist">crossdist</a></code>,
<code><a href="#topic+crossdist.default">crossdist.default</a></code>,
<code><a href="#topic+crossdist.psp">crossdist.psp</a></code>,
<code><a href="#topic+pairdist">pairdist</a></code>,
<code><a href="#topic+nndist">nndist</a></code>,
<code><a href="spatstat.explore.html#topic+Gest">Gest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Y &lt;- runifrect(6, Window(cells))
   d &lt;- crossdist(cells, Y)
   d &lt;- crossdist(cells, Y, periodic=TRUE)
</code></pre>

<hr>
<h2 id='crossdist.ppx'>Pairwise Distances Between Two Different Multi-Dimensional Point Patterns</h2><span id='topic+crossdist.ppx'></span>

<h3>Description</h3>

<p>Computes the distances between pairs of points
taken from two different multi-dimensional point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppx'
crossdist(X, Y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossdist.ppx_+3A_x">X</code>, <code id="crossdist.ppx_+3A_y">Y</code></td>
<td>

<p>Multi-dimensional point patterns (objects of class <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="crossdist.ppx_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+coords.ppx">coords.ppx</a></code> to determine
which coordinates should be used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two point patterns in multi-dimensional space, 
this function computes the Euclidean distance from each point
in the first pattern to each point in the second pattern,
and returns a matrix containing these distances.
</p>
<p>This is a method for the generic function <code><a href="#topic+crossdist">crossdist</a></code>
for three-dimensional point patterns (objects of class <code>"ppx"</code>).
</p>
<p>This function expects two multidimensional
point patterns <code>X</code> and <code>Y</code>, and returns the matrix
whose <code>[i,j]</code> entry is the distance from <code>X[i]</code> to
<code>Y[j]</code>.
</p>
<p>By default, both spatial and temporal coordinates are extracted.
To obtain the spatial distance between points in a space-time point
pattern, set <code>temporal=FALSE</code>.
</p>


<h3>Value</h3>

<p>A matrix whose <code>[i,j]</code> entry is the distance
from the <code>i</code>-th point in <code>X</code>
to the <code>j</code>-th point in <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossdist">crossdist</a></code>,
<code><a href="#topic+pairdist">pairdist</a></code>,
<code><a href="#topic+nndist">nndist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   df &lt;- data.frame(x=runif(3),y=runif(3),z=runif(3),w=runif(3))
   X &lt;- ppx(data=df)
   df &lt;- data.frame(x=runif(5),y=runif(5),z=runif(5),w=runif(5))
   Y &lt;- ppx(data=df)
   d &lt;- crossdist(X, Y)
</code></pre>

<hr>
<h2 id='crossdist.psp'>Pairwise distances between two different line segment patterns</h2><span id='topic+crossdist.psp'></span>

<h3>Description</h3>

<p>Computes the distances between all pairs of line segments
taken from two different line segment patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'psp'
crossdist(X, Y, ..., method="C", type="Hausdorff")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossdist.psp_+3A_x">X</code>, <code id="crossdist.psp_+3A_y">Y</code></td>
<td>

<p>Line segment patterns (objects of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="crossdist.psp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="crossdist.psp_+3A_method">method</code></td>
<td>
<p>String specifying which method of calculation to use.
Values are <code>"C"</code> and <code>"interpreted"</code>.
Usually not specified.
</p>
</td></tr>
<tr><td><code id="crossdist.psp_+3A_type">type</code></td>
<td>

<p>Type of distance to be computed. Options are
<code>"Hausdorff"</code> and <code>"separation"</code>. Partial matching is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+crossdist">crossdist</a></code>.
</p>
<p>Given two line segment patterns, 
this function computes the distance from each line segment
in the first pattern to each line segment in the second pattern,
and returns a matrix containing these distances.
</p>
<p>The distances between line segments are measured in one of two ways:
</p>

<ul>
<li><p> if <code>type="Hausdorff"</code>, distances are computed
in the Hausdorff metric. The Hausdorff
distance between two line segments is the <em>maximum</em> distance
from any point on one of the segments to the nearest point on
the other segment.
</p>
</li>
<li><p> if <code>type="separation"</code>, distances are computed
as the <em>minimum</em> distance from a point on one line segment to
a point on the other line segment. For example, line segments which
cross over each other have separation zero.
</p>
</li></ul>

<p>The argument <code>method</code> is not normally used. It is
retained only for checking the validity of the software.
If <code>method = "interpreted"</code> then the distances are
computed using interpreted <span class="rlang"><b>R</b></span> code only. If <code>method="C"</code>
(the default) then compiled <code>C</code> code is used. 
The <code>C</code> code is several times faster.
</p>


<h3>Value</h3>

<p>A matrix whose <code>[i,j]</code> entry is the distance
from the <code>i</code>-th line segment in <code>X</code>
to the <code>j</code>-th line segment in <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairdist">pairdist</a></code>,
<code><a href="#topic+nndist">nndist</a></code>,
<code><a href="spatstat.explore.html#topic+Gest">Gest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   L1 &lt;- psp(runif(5), runif(5), runif(5), runif(5), owin())
   L2 &lt;- psp(runif(10), runif(10), runif(10), runif(10), owin())
   D &lt;- crossdist(L1, L2)
   #result is a 5 x 10 matrix
   S &lt;- crossdist(L1, L2, type="sep")
</code></pre>

<hr>
<h2 id='crossing.psp'>Crossing Points of Two Line Segment Patterns</h2><span id='topic+crossing.psp'></span>

<h3>Description</h3>

<p>Finds any crossing points between 
two line segment patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  crossing.psp(A,B,fatal=TRUE,details=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossing.psp_+3A_a">A</code>, <code id="crossing.psp_+3A_b">B</code></td>
<td>

<p>Line segment patterns (objects of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="crossing.psp_+3A_details">details</code></td>
<td>

<p>Logical value indicating whether to return additional information.
See below.
</p>
</td></tr>
<tr><td><code id="crossing.psp_+3A_fatal">fatal</code></td>
<td>

<p>Logical value indicating what to do
if the windows of <code>A</code> and <code>B</code> do not overlap.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds any crossing points between
the line segment patterns <code>A</code> and <code>B</code>.
</p>
<p>A crossing point occurs whenever one of the line segments in <code>A</code>
intersects one of the line segments in <code>B</code>, at a nonzero
angle of intersection.
</p>
<p>The result is a point pattern consisting of all the intersection points.
</p>
<p>If <code>details=TRUE</code>, additional information is computed,
specifying where each intersection point came from.
The resulting point pattern has a data frame of marks, with columns
named <code>iA, jB, tA, tB</code>. The marks <code>iA</code>
and <code>jB</code> are the indices of the line segments in <code>A</code> and
<code>B</code>, respectively, which produced each intersection point.
The marks <code>tA</code> and <code>tB</code> are numbers between 0 and 1
specifying the position of the intersection point along the
original segments.
</p>
<p>If the windows <code>Window(A)</code> and <code>Window(B)</code> do not
overlap, then an error will be reported if <code>fatal=TRUE</code>,
while if <code>fatal=FALSE</code> an error will not occur
and the result will be <code>NULL</code>.
</p>


<h3>Value</h3>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selfcrossing.psp">selfcrossing.psp</a></code>,
<code><a href="#topic+psp.object">psp.object</a></code>,
<code><a href="#topic+ppp.object">ppp.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  b &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  plot(a, col="green", main="crossing.psp")
  plot(b, add=TRUE, col="blue")
  P &lt;- crossing.psp(a,b)
  plot(P, add=TRUE, col="red")
  as.data.frame(crossing.psp(a,b,details=TRUE))
</code></pre>

<hr>
<h2 id='cut.im'>Convert Pixel Image from Numeric to Factor</h2><span id='topic+cut.im'></span>

<h3>Description</h3>

<p>Transform the values of a pixel image
from numeric values into a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
cut(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut.im_+3A_x">x</code></td>
<td>

<p>A pixel image.
An object of class <code>"im"</code>.
</p>
</td></tr>
<tr><td><code id="cut.im_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="base.html#topic+cut.default">cut.default</a></code>.
They determine the breakpoints for the mapping from numerical values to
factor values. See <code><a href="base.html#topic+cut.default">cut.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simple function applies the generic <code><a href="base.html#topic+cut">cut</a></code> operation
to the pixel values of the image <code>x</code>. The range of pixel values
is divided into several intervals, and each
interval is associated with a level of a factor. 
The result is another pixel image,
with the same window and pixel grid as
<code>x</code>, but with the numeric value of each pixel discretised
by replacing it by the factor level. 
</p>
<p>This function is a convenient
way to inspect an image and to obtain summary statistics.
See the examples.
</p>
<p>To select a subset of an image, use the subset operator
<code><a href="#topic++5B.im">[.im</a></code> instead.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) with 
pixel values that are a factor.
See <code><a href="#topic+im.object">im.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>,
<code><a href="#topic+im.object">im.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # artificial image data
  Z &lt;- setcov(square(1))

  Y &lt;- cut(Z, 3)
  Y &lt;- cut(Z, breaks=seq(0,1,length=5))

  # cut at the quartiles
  # (divides the image into 4 equal areas)
  Y &lt;- cut(Z, quantile(Z))
</code></pre>

<hr>
<h2 id='cut.ppp'>Classify Points in a Point Pattern</h2><span id='topic+cut.ppp'></span>

<h3>Description</h3>

<p>Classifies the points in a point pattern into distinct types
according to the numerical marks in the pattern, or according to
another variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
cut(x, z=marks(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut.ppp_+3A_x">x</code></td>
<td>

<p>A two-dimensional point pattern.
An object of class <code>"ppp"</code>.
</p>
</td></tr>
<tr><td><code id="cut.ppp_+3A_z">z</code></td>
<td>

<p>Data determining the classification. A numeric vector,
a factor, a pixel image, a window, a tessellation, or a string
giving the name of a column of marks or the name of a spatial coordinate.
</p>
</td></tr>
<tr><td><code id="cut.ppp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="base.html#topic+cut.default">cut.default</a></code>.
They determine the breakpoints for the mapping from numerical values
in <code>z</code> to factor values in the output.
See <code><a href="base.html#topic+cut.default">cut.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has the effect of classifying each point in the point
pattern <code>x</code> into one of several possible types. The
classification is based on the dataset <code>z</code>, which may be either
</p>

<ul>
<li>
<p>a factor (of length equal to the number of points in <code>z</code>)
determining the classification of each point in <code>x</code>.
Levels of the factor determine the classification.
</p>
</li>
<li>
<p>a numeric vector (of length equal to the number of points in
<code>z</code>). The range of values of <code>z</code> will be divided into
bands (the number of bands is determined by <code>...</code>)
and <code>z</code> will be converted to a factor using
<code><a href="base.html#topic+cut.default">cut.default</a></code>.
</p>
</li>
<li>
<p>a pixel image (object of class <code>"im"</code>).
The value of <code>z</code> at each point of <code>x</code> will be
used as the classifying variable.
</p>
</li>
<li>
<p>a tessellation (object of class <code>"tess"</code>, see
<code><a href="#topic+tess">tess</a></code>). Each point of <code>x</code> will be classified
according to the tile of the tessellation into which it falls.
</p>
</li>
<li>
<p>a window (object of class <code>"owin"</code>).
Each point of <code>x</code> will be classified
according to whether it falls inside or outside this window.
</p>
</li>
<li>
<p>a character string, giving the name of one of the columns
of <code>marks(x)</code>, if this is a data frame.
</p>
</li>
<li>
<p>a character string <code>"x"</code> or <code>"y"</code> identifying one of the
spatial coordinates.
</p>
</li></ul>

<p>The default is to take <code>z</code> to be the vector of marks in
<code>x</code> (or the first column in the data frame of marks of <code>x</code>,
if it is a data frame). If the marks are numeric, then the range of values
of the numerical marks is divided into several intervals, and each
interval is associated with a level of a factor. 
The result is a
marked point pattern, with the same window and point locations as
<code>x</code>, but with the numeric mark of each point discretised
by replacing it by the factor level.
This is a convenient way to transform a marked point pattern
which has numeric marks into a multitype point pattern,
for example to plot it or analyse it. See the examples.
</p>
<p>To select some points from a point pattern, use the subset operators
<code><a href="#topic++5B.ppp">[.ppp</a></code> or <code><a href="#topic+subset.ppp">subset.ppp</a></code> instead.
</p>


<h3>Value</h3>

<p>A multitype point pattern, that is, a point pattern object
(of class <code>"ppp"</code>) with a <code>marks</code> vector that is a factor.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>,
<code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+tess">tess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # (1) cutting based on numeric marks of point pattern
 
 trees &lt;- longleaf
 # Longleaf Pines data
 # the marks are positive real numbers indicating tree diameters.

 
 if(interactive()) {
 plot(trees)
 }

 # cut the range of tree diameters into three intervals
 long3 &lt;- cut(trees, breaks=3)
 if(interactive()) {
 plot(long3)
 }

 # adult trees defined to have diameter at least 30 cm
 long2 &lt;- cut(trees, breaks=c(0,30,100), labels=c("Sapling", "Adult"))
 plot(long2)
 plot(long2, cols=c("green","blue"))

 # (2) cutting based on another numeric vector
 # Divide Swedish Pines data into 3 classes
 # according to nearest neighbour distance

 swedishpines
 plot(cut(swedishpines, nndist(swedishpines), breaks=3))

 # (3) cutting based on tessellation
 # Divide Swedish Pines study region into a 4 x 4 grid of rectangles
 # and classify points accordingly

 tes &lt;- tess(xgrid=seq(0,96,length=5),ygrid=seq(0,100,length=5))
 plot(cut(swedishpines, tes))
 plot(tes, lty=2, add=TRUE)

 # (4) inside/outside a given region
 with(murchison, cut(gold, greenstone))

 # (5) multivariate marks
 finpines
 cut(finpines, "height", breaks=4)
</code></pre>

<hr>
<h2 id='default.dummy'>Generate a Default Pattern of Dummy Points</h2><span id='topic+default.dummy'></span>

<h3>Description</h3>

<p>Generates a default pattern of dummy points
for use in a quadrature scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> default.dummy(X, nd, random=FALSE, ntile=NULL, npix=NULL,
              quasi=FALSE, ..., eps=NULL, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default.dummy_+3A_x">X</code></td>
<td>

<p>The observed data point pattern.
An object of class <code>"ppp"</code>
or in a format recognised by <code><a href="#topic+as.ppp">as.ppp</a>()</code>
</p>
</td></tr>
<tr><td><code id="default.dummy_+3A_nd">nd</code></td>
<td>

<p>Optional. Integer, or integer vector of length 2, specifying an
<code>nd * nd</code> or <code>nd[1] * nd[2]</code>
rectangular array of dummy points. 
</p>
</td></tr>
<tr><td><code id="default.dummy_+3A_random">random</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, the dummy points are
generated randomly.
</p>
</td></tr>
<tr><td><code id="default.dummy_+3A_quasi">quasi</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, the dummy points are
generated by a quasirandom sequence.
</p>
</td></tr>
<tr><td><code id="default.dummy_+3A_ntile">ntile</code></td>
<td>

<p>Optional. Integer or pair of integers specifying 
the number of rows and columns of tiles used in the counting rule.
</p>
</td></tr>
<tr><td><code id="default.dummy_+3A_npix">npix</code></td>
<td>

<p>Optional. Integer or pair of integers specifying the
number of rows and columns of pixels used in computing
approximate areas.
</p>
</td></tr>
<tr><td><code id="default.dummy_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="default.dummy_+3A_eps">eps</code></td>
<td>

<p>Optional. Grid spacing.
A positive number, or a vector of two positive numbers, giving the
horizontal and vertical spacing, respectively, of the grid of
dummy points. Incompatible with <code>nd</code>.
</p>
</td></tr>
<tr><td><code id="default.dummy_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, information about the construction of the
quadrature scheme is printed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a sensible default for the dummy points
in a quadrature scheme.
</p>
<p>A quadrature scheme consists of 
the original data point pattern, an additional pattern of dummy points,
and a vector of quadrature weights for all these points.
See <code><a href="#topic+quad.object">quad.object</a></code> for further information about
quadrature schemes.
</p>
<p>If <code>random</code> and <code>quasi</code> are both false (the default),
then the function creates dummy points
in a regular <code>nd[1]</code> by <code>nd[1]</code> rectangular grid.
If <code>random</code> is true and <code>quasi</code> is false,
then the frame of the window is divided into
an  <code>nd[1]</code> by <code>nd[1]</code> array of tiles, and one dummy point
is generated at random inside each tile.
If <code>quasi</code> is true, a quasirandom pattern of
<code>nd[1] * nd[2]</code> points is generated.
In all cases, the four corner points of the frame of the window
are added. Then if the window is not rectangular, any dummy points
lying outside it are deleted. 
</p>
<p>If <code>nd</code> is missing, a default value is computed by
the undocumented internal function <code><a href="#topic+default.n.tiling">default.n.tiling</a></code>,
using information about the data pattern <code>X</code>,
and other arguments and settings.
The default value of <code>nd</code> is always greater than or equal to
<code>spatstat.options("ndummy.min")</code>
and greater than or equal to <code>10 * ceiling(2 * sqrt(npoints(X))/10)</code>,
and satisfies some other constraints. 
The default is designed so that model-fitting is relatively fast and stable,
rather than highly accurate.
</p>
<p>Alternative functions for creating dummy patterns
include <code><a href="#topic+corners">corners</a></code>,
<code><a href="#topic+gridcentres">gridcentres</a></code>,
<code><a href="#topic+stratrand">stratrand</a></code> and
<code><a href="#topic+spokes">spokes</a></code>.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>,
see <code><a href="#topic+ppp.object">ppp.object</a></code>) containing the dummy points.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="#topic+quadscheme">quadscheme</a></code>,
<code><a href="#topic+corners">corners</a></code>,
<code><a href="#topic+gridcentres">gridcentres</a></code>,
<code><a href="#topic+stratrand">stratrand</a></code>,
<code><a href="#topic+spokes">spokes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  P &lt;- simdat
  D &lt;- default.dummy(P, 100)
  plot(D)
  Q &lt;- quadscheme(P, D, "grid")
  if(interactive()) {plot(union.quad(Q))}
</code></pre>

<hr>
<h2 id='delaunay'>Delaunay Triangulation of Point Pattern</h2><span id='topic+delaunay'></span>

<h3>Description</h3>

<p>Computes the Delaunay triangulation of a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delaunay(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delaunay_+3A_x">X</code></td>
<td>
<p>Spatial point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Delaunay triangulation of a spatial point pattern <code>X</code>
is defined as follows. First the Dirichlet/Voronoi tessellation
based on <code>X</code> is computed; see <code><a href="#topic+dirichlet">dirichlet</a></code>. This
tessellation is extended to cover the entire two-dimensional plane.
Then two points of <code>X</code>
are defined to be Delaunay neighbours if their Dirichlet/Voronoi tiles
share a common boundary. Every pair of Delaunay neighbours is
joined by a straight line to make the Delaunay triangulation.
The result is a tessellation, consisting of
disjoint triangles. The union of these triangles is the convex hull of
<code>X</code>.
</p>


<h3>Value</h3>

<p>A tessellation (object of class <code>"tess"</code>). The window of the
tessellation is the convex hull of <code>X</code>, not the original window
of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+dirichlet">dirichlet</a></code>,
<code><a href="#topic+convexhull.xy">convexhull.xy</a></code>,
<code><a href="#topic+ppp">ppp</a></code>,
<code><a href="#topic+delaunayDistance">delaunayDistance</a></code>,
<code>delaunayNetwork</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runifrect(42)
  plot(delaunay(X))
  plot(X, add=TRUE)
</code></pre>

<hr>
<h2 id='delaunayDistance'>Distance on Delaunay Triangulation</h2><span id='topic+delaunayDistance'></span>

<h3>Description</h3>

<p>Computes the graph distance in the Delaunay triangulation
of a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delaunayDistance(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delaunayDistance_+3A_x">X</code></td>
<td>
<p>Spatial point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Delaunay triangulation of a spatial point pattern <code>X</code>
is defined as follows. First the Dirichlet/Voronoi tessellation
based on <code>X</code> is computed; see <code><a href="#topic+dirichlet">dirichlet</a></code>. This
tessellation is extended to cover the entire two-dimensional plane.
Then two points of <code>X</code>
are defined to be Delaunay neighbours if their Dirichlet/Voronoi tiles
share a common boundary. Every pair of Delaunay neighbours is
joined by a straight line to make the Delaunay triangulation.
</p>
<p>The <em>graph distance</em> 
in the Delaunay triangulation between two points <code>X[i]</code> and <code>X[j]</code>
is the minimum number of edges of the Delaunay triangulation
that must be traversed to go from <code>X[i]</code> to <code>X[j]</code>.
Two points have graph distance 1 if they are immediate neighbours.
</p>
<p>This command returns a matrix <code>D</code> such that
<code>D[i,j]</code> is the graph distance
between <code>X[i]</code> and <code>X[j]</code>.
</p>


<h3>Value</h3>

<p>A symmetric square matrix with non-negative integer entries.
</p>


<h3>Definition of neighbours</h3>

<p>Note that <code><a href="#topic+dirichlet">dirichlet</a>(X)</code>
restricts the Dirichlet tessellation to the window containing
<code>X</code>, whereas <code>dirichletDistance</code> uses the Dirichlet
tessellation over the entire two-dimensional plane.
Some points may be Delaunay neighbours
according to <code>delaunayDistance(X)</code>
although the corresponding tiles of <code>dirichlet(X)</code>
do not share a boundary inside <code>Window(X)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delaunay">delaunay</a></code>,
<code>delaunayNetwork</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runifrect(20)
  M &lt;- delaunayDistance(X)
  plot(delaunay(X), lty=3)
  text(X, labels=M[1, ], cex=2)
</code></pre>

<hr>
<h2 id='deltametric'>
Delta Metric
</h2><span id='topic+deltametric'></span>

<h3>Description</h3>

<p>Computes the discrepancy between two sets <code class="reqn">A</code> and <code class="reqn">B</code>
according to Baddeley's delta-metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltametric(A, B, p = 2, c = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deltametric_+3A_a">A</code>, <code id="deltametric_+3A_b">B</code></td>
<td>

<p>The two sets which will be compared.
Windows (objects of class <code>"owin"</code>),
point patterns (objects of class <code>"ppp"</code>)
or line segment patterns (objects of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="deltametric_+3A_p">p</code></td>
<td>

<p>Index of the <code class="reqn">L^p</code> metric.
Either a positive numeric value, or <code>Inf</code>.
</p>
</td></tr>
<tr><td><code id="deltametric_+3A_c">c</code></td>
<td>

<p>Distance threshold. 
Either a positive numeric value, or <code>Inf</code>.
</p>
</td></tr>
<tr><td><code id="deltametric_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine the
pixel resolution of the distance maps computed by <code><a href="#topic+distmap">distmap</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Baddeley (1992a, 1992b) defined a distance
between two sets <code class="reqn">A</code> and <code class="reqn">B</code> contained in a space <code class="reqn">W</code> by 
</p>
<p style="text-align: center;"><code class="reqn">
    \Delta(A,B) = \left[
    \frac 1 {|W|}
    \int_W
    \left| \min(c, d(x,A)) - \min(c, d(x,B)) \right|^p \, {\rm d}x
    \right]^{1/p}
  </code>
</p>

<p>where <code class="reqn">c \ge 0</code> is a distance threshold parameter,
<code class="reqn">0 &lt; p \le \infty</code> is the exponent parameter,
and <code class="reqn">d(x,A)</code> denotes the 
shortest distance from a point <code class="reqn">x</code> to the set <code class="reqn">A</code>.
Also <code>|W|</code> denotes the area or volume of the containing space <code class="reqn">W</code>.
</p>
<p>This is defined so that it is a <em>metric</em>, i.e.
</p>

<ul>
<li> <p><code class="reqn">\Delta(A,B)=0</code> if and only if <code class="reqn">A=B</code>
</p>
</li>
<li> <p><code class="reqn">\Delta(A,B)=\Delta(B,A)</code>
</p>
</li>
<li> <p><code class="reqn">\Delta(A,C) \le \Delta(A,B) + \Delta(B,C)</code>
</p>
</li></ul>

<p>It is topologically equivalent to the Hausdorff metric
(Baddeley, 1992a) but has better stability properties
in practical applications (Baddeley, 1992b).
</p>
<p>If <code class="reqn">p=\infty</code> and <code class="reqn">c=\infty</code> the Delta metric
is equal to the Hausdorff metric.
</p>
<p>The algorithm uses <code><a href="#topic+distmap">distmap</a></code> to compute the distance maps
<code class="reqn">d(x,A)</code> and <code class="reqn">d(x,B)</code>, then approximates the integral
numerically.
The accuracy of the computation depends on the pixel resolution
which is controlled through the extra arguments <code>...</code> passed
to <code><a href="#topic+as.mask">as.mask</a></code>.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A.J. (1992a)
Errors in binary images and an <code class="reqn">L^p</code> version of the Hausdorff metric.
<em>Nieuw Archief voor Wiskunde</em> <b>10</b>, 157&ndash;183.
</p>
<p>Baddeley, A.J. (1992b)
An error metric for binary images.
In W. Foerstner and S. Ruwiedel (eds)
<em>Robust Computer Vision</em>. Karlsruhe: Wichmann.
Pages 59&ndash;78.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmap">distmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runifrect(20)
  Y &lt;- runifrect(10)
  deltametric(X, Y, p=1,c=0.1)
</code></pre>

<hr>
<h2 id='diameter'>Diameter of an Object</h2><span id='topic+diameter'></span>

<h3>Description</h3>

<p>Computes the diameter of an object such as a two-dimensional window
or three-dimensional box. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> diameter(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diameter_+3A_x">x</code></td>
<td>

<p>A window or other object whose diameter will be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the diameter of an object
such as a two-dimensional window or a three-dimensional box. 
The diameter is the maximum distance 
between any two points in the object.
</p>
<p>The function <code>diameter</code> is generic, with methods for
the class <code>"owin"</code> (two-dimensional windows),
<code>"box3"</code> (three-dimensional boxes),
<code>"boxx"</code> (multi-dimensional boxes)
and <code>"linnet"</code> (linear networks).
</p>


<h3>Value</h3>

<p>The numerical value of the diameter of the object.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diameter.owin">diameter.owin</a></code>,
<code><a href="#topic+diameter.box3">diameter.box3</a></code>,
<code><a href="#topic+diameter.boxx">diameter.boxx</a></code>,
</p>

<hr>
<h2 id='diameter.box3'>
Geometrical Calculations for Three-Dimensional Box
</h2><span id='topic+diameter.box3'></span><span id='topic+volume.box3'></span><span id='topic+shortside.box3'></span><span id='topic+sidelengths.box3'></span><span id='topic+eroded.volumes.box3'></span><span id='topic+shortside'></span><span id='topic+sidelengths'></span><span id='topic+eroded.volumes'></span>

<h3>Description</h3>

<p>Calculates the volume, diameter, shortest side, side lengths, 
or eroded volume of a three-dimensional box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'box3'
diameter(x)

## S3 method for class 'box3'
volume(x)

shortside(x)
sidelengths(x)
eroded.volumes(x, r)

## S3 method for class 'box3'
shortside(x)

## S3 method for class 'box3'
sidelengths(x)

## S3 method for class 'box3'
eroded.volumes(x, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diameter.box3_+3A_x">x</code></td>
<td>

<p>Three-dimensional box (object of class <code>"box3"</code>).
</p>
</td></tr>
<tr><td><code id="diameter.box3_+3A_r">r</code></td>
<td>

<p>Numeric value or vector of numeric values for which eroded volumes
should be calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>diameter.box3</code> computes the diameter of the box.
<code>volume.box3</code> computes the volume of the box.
<code>shortside.box3</code> finds the shortest of the three side lengths
of the box.
<code>sidelengths.box3</code> returns all three side lengths
of the box.
</p>
<p><code>eroded.volumes</code> computes, for each entry <code>r[i]</code>,
the volume of the smaller box obtained by removing a slab of
thickness <code>r[i]</code> from each face of the box. This smaller box is
the subset consisting of points that lie at least <code>r[i]</code> units
away from the boundary of the box.
</p>


<h3>Value</h3>

<p>For <code>diameter.box3</code>, <code>shortside.box3</code> and
<code>volume.box3</code>, a single numeric
value. For <code>sidelengths.box3</code>, a vector of three numbers.
For <code>eroded.volumes</code>, a numeric vector of the same length
as <code>r</code>.  
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.box3">as.box3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    X &lt;- box3(c(0,10),c(0,10),c(0,5))
    diameter(X) 
    volume(X)
    sidelengths(X)
    shortside(X)
    hd &lt;- shortside(X)/2
    eroded.volumes(X, seq(0,hd, length=10))
</code></pre>

<hr>
<h2 id='diameter.boxx'>
Geometrical Calculations for Multi-Dimensional Box
</h2><span id='topic+diameter.boxx'></span><span id='topic+volume.boxx'></span><span id='topic+shortside.boxx'></span><span id='topic+sidelengths.boxx'></span><span id='topic+eroded.volumes.boxx'></span>

<h3>Description</h3>

<p>Calculates the volume, diameter, shortest side,
side lengths, or eroded volume of a multi-dimensional box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boxx'
diameter(x)

## S3 method for class 'boxx'
volume(x)

## S3 method for class 'boxx'
shortside(x)

## S3 method for class 'boxx'
sidelengths(x)

## S3 method for class 'boxx'
eroded.volumes(x, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diameter.boxx_+3A_x">x</code></td>
<td>

<p>Multi-dimensional box (object of class <code>"boxx"</code>).
</p>
</td></tr>
<tr><td><code id="diameter.boxx_+3A_r">r</code></td>
<td>

<p>Numeric value or vector of numeric values for which eroded volumes
should be calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>diameter.boxx</code>, 
<code>volume.boxx</code> and <code>shortside.boxx</code>
compute the diameter, volume and shortest side length of the box.
<code>sidelengths.boxx</code> returns the lengths of each side of the box.
</p>
<p><code>eroded.volumes.boxx</code> computes, for each entry <code>r[i]</code>,
the volume of the smaller box obtained by removing a slab of
thickness <code>r[i]</code> from each face of the box. This smaller box is
the subset consisting of points that lie at least <code>r[i]</code> units
away from the boundary of the box.
</p>


<h3>Value</h3>

<p>For <code>diameter.boxx</code>, <code>shortside.boxx</code> and
<code>volume.boxx</code>, a single numeric value.
For <code>sidelengths.boxx</code>, a numeric vector of length equal to
the number of spatial dimensions.
For <code>eroded.volumes.boxx</code>, a numeric vector of the same length
as <code>r</code>.  
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxx">boxx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    X &lt;- boxx(c(0,10),c(0,10),c(0,5),c(0,2))
    diameter(X) 
    volume(X)
    shortside(X)
    sidelengths(X)
    hd &lt;- shortside(X)/2
    eroded.volumes(X, seq(0,hd, length=10))
</code></pre>

<hr>
<h2 id='diameter.owin'>Diameter of a Window</h2><span id='topic+diameter.owin'></span>

<h3>Description</h3>

<p>Computes the diameter of a window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'owin'
diameter(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diameter.owin_+3A_x">x</code></td>
<td>

<p>A window whose diameter will be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the 
diameter of a window of arbitrary shape,
i.e. the maximum distance between any two points
in the window.
</p>
<p>The argument <code>x</code> should be a window (an object of class
<code>"owin"</code>, see <code><a href="#topic+owin.object">owin.object</a></code> for details)
or can be given in any format acceptable to <code><a href="#topic+as.owin">as.owin</a>()</code>.
</p>
<p>The function <code>diameter</code> is generic. This function is the
method for the class <code>"owin"</code>.
</p>


<h3>Value</h3>

<p>The numerical value of the diameter of the window. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+area.owin">area.owin</a></code>,
<code><a href="#topic+perimeter">perimeter</a></code>,
<code><a href="#topic+edges">edges</a></code>,
<code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- owin(c(0,1),c(0,1))
  diameter(w) 
  # returns sqrt(2)
  diameter(letterR)
</code></pre>

<hr>
<h2 id='dilated.areas'>
Areas of Morphological Dilations
</h2><span id='topic+dilated.areas'></span>

<h3>Description</h3>

<p>Computes the areas of successive morphological dilations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dilated.areas(X, r, W=as.owin(X), ..., constrained=TRUE, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dilated.areas_+3A_x">X</code></td>
<td>

<p>Object to be dilated.
A point pattern (object of class <code>"ppp"</code>),
a line segment pattern (object of class <code>"psp"</code>),
or a window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="dilated.areas_+3A_r">r</code></td>
<td>

<p>Numeric vector of radii for the dilations. 
</p>
</td></tr>
<tr><td><code id="dilated.areas_+3A_w">W</code></td>
<td>

<p>Window (object of class <code>"owin"</code>) inside which the areas
will be computed, if <code>constrained=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="dilated.areas_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+distmap">distmap</a></code> to control the
pixel resolution, if <code>exact=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="dilated.areas_+3A_constrained">constrained</code></td>
<td>

<p>Logical flag indicating whether areas should be restricted
to the window <code>W</code>.
</p>
</td></tr>
<tr><td><code id="dilated.areas_+3A_exact">exact</code></td>
<td>

<p>Logical flag indicating whether areas should be computed
using analytic geometry (which is slower but more accurate).
Currently available only when <code>X</code> is a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the areas of the dilations of <code>X</code>
by each of the radii <code>r[i]</code>. Areas may also be computed
inside a specified window <code>W</code>.
</p>
<p>The morphological dilation of a set <code class="reqn">X</code> by a distance <code class="reqn">r &gt; 0</code>
is the subset 
consisting of all points <code class="reqn">x</code> such that the
distance from <code class="reqn">x</code> to <code class="reqn">X</code> is less than 
or equal to <code class="reqn">r</code>.
</p>
<p>When <code>X</code> is a point pattern, the dilation by a distance
<code class="reqn">r</code> is the union of
discs of radius <code class="reqn">r</code> centred at the points of <code>X</code>.
</p>
<p>The argument <code>r</code> should be a vector of nonnegative numbers.
</p>
<p>If <code>exact=TRUE</code> and if <code>X</code> is a point pattern,
then the areas are computed using analytic geometry, which is
slower but much more accurate. Otherwise the computation is performed
using <code><a href="#topic+distmap">distmap</a></code>.
</p>
<p>To compute the dilated object itself, use <code><a href="#topic+dilation">dilation</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+dilation">dilation</a></code>,
<code><a href="#topic+eroded.areas">eroded.areas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runifrect(10)
  a &lt;- dilated.areas(X, c(0.1,0.2), W=square(1), exact=TRUE)
</code></pre>

<hr>
<h2 id='dilation'>Morphological Dilation</h2><span id='topic+dilation'></span><span id='topic+dilation.owin'></span><span id='topic+dilation.ppp'></span><span id='topic+dilation.psp'></span>

<h3>Description</h3>

<p>Perform morphological dilation of a window, a line segment pattern
or a point pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'> dilation(w, r, ...)
 ## S3 method for class 'owin'
dilation(w, r, ..., polygonal=NULL, tight=TRUE)
 ## S3 method for class 'ppp'
dilation(w, r, ..., polygonal=TRUE, tight=TRUE)
 ## S3 method for class 'psp'
dilation(w, r, ..., polygonal=TRUE, tight=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dilation_+3A_w">w</code></td>
<td>

<p>A window (object of class <code>"owin"</code>
or a line segment pattern (object of class <code>"psp"</code>)
or a point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="dilation_+3A_r">r</code></td>
<td>
<p>positive number: the radius of dilation.</p>
</td></tr>
<tr><td><code id="dilation_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
controlling the pixel resolution, if the pixel approximation is
used; or passed to <code><a href="#topic+disc">disc</a></code> if the polygonal approximation
is used.
</p>
</td></tr>
<tr><td><code id="dilation_+3A_polygonal">polygonal</code></td>
<td>

<p>Logical flag indicating whether to compute a polygonal
approximation to the dilation (<code>polygonal=TRUE</code>) or
a pixel grid approximation (<code>polygonal=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="dilation_+3A_tight">tight</code></td>
<td>

<p>Logical flag indicating whether the bounding frame of the window
should be taken as the smallest rectangle enclosing the dilated region
(<code>tight=TRUE</code>), or should be the
dilation of the bounding frame of <code>w</code> (<code>tight=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The morphological dilation of a set <code class="reqn">W</code> by a distance <code class="reqn">r &gt; 0</code>
is the set consisting of all points lying at most <code class="reqn">r</code> units
away from <code class="reqn">W</code>. Effectively, dilation adds a margin of width
<code class="reqn">r</code> onto the set <code class="reqn">W</code>.
</p>
<p>If <code>polygonal=TRUE</code> then a polygonal approximation
to the dilation is computed.
If <code>polygonal=FALSE</code> then a pixel approximation
to the dilation is computed from the distance map of <code>w</code>.
The arguments <code>"\dots"</code> are passed to <code><a href="#topic+as.mask">as.mask</a></code>
to control the pixel resolution.
</p>
<p>When <code>w</code> is a window, the default (when <code>polygonal=NULL</code>)
is to compute a polygonal approximation if
<code>w</code> is a rectangle or polygonal window, and to compute a
pixel approximation if <code>w</code> is a window of type <code>"mask"</code>.
</p>


<h3>Value</h3>

<p>If <code>r &gt; 0</code>, an object of class <code>"owin"</code> representing the
dilated region. If <code>r=0</code>, the result is identical to <code>w</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+erosion">erosion</a></code> for the opposite operation.
</p>
<p><code><a href="#topic+dilationAny">dilationAny</a></code> for morphological dilation using any shape.
</p>
<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(dilation(redwood, 0.05))
  points(redwood)

  plot(dilation(letterR, 0.2))
  plot(letterR, add=TRUE, lwd=2, border="red")

  X &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  plot(dilation(X, 0.1))
  plot(X, add=TRUE, col="red")

</code></pre>

<hr>
<h2 id='dirichlet'>Dirichlet Tessellation of Point Pattern</h2><span id='topic+dirichlet'></span>

<h3>Description</h3>

<p>Computes the Dirichlet tessellation of a spatial point pattern.
Also known as the Voronoi or Thiessen tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirichlet(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirichlet_+3A_x">X</code></td>
<td>
<p>Spatial point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a spatial point pattern <code>X</code>, the Dirichlet tile associated
with a particular point <code>X[i]</code> is the region of space that is
closer to <code>X[i]</code> than to any other point in <code>X</code>. The
Dirichlet tiles divide the two-dimensional plane into disjoint
regions, forming a tessellation.
</p>
<p>The Dirichlet tessellation is also known as the Voronoi or
Thiessen tessellation.
</p>
<p>This function computes the Dirichlet tessellation (within the original
window of <code>X</code>) using the function <code><a href="deldir.html#topic+deldir">deldir</a></code>
in the package <span class="pkg">deldir</span>.
</p>
<p>To ensure that there is a one-to-one correspondence between the
points of <code>X</code> and the tiles of <code>dirichlet(X)</code>,
duplicated points in <code>X</code> should first be removed by
<code>X &lt;- unique(X, rule="deldir")</code>. 
</p>
<p>The tiles of the tessellation will be computed as polygons
if the original window is a rectangle or a polygon.
Otherwise the tiles will be computed as binary masks. 
</p>


<h3>Value</h3>

<p>A tessellation (object of class <code>"tess"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+delaunay">delaunay</a></code>,
<code><a href="#topic+ppp">ppp</a></code>,
<code><a href="#topic+dirichletVertices">dirichletVertices</a></code>.
</p>
<p>For the Dirichlet tessellation on a linear network,
see <code><a href="spatstat.linnet.html#topic+lineardirichlet">lineardirichlet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runifrect(42)
  plot(dirichlet(X))
  plot(X, add=TRUE)
</code></pre>

<hr>
<h2 id='dirichletAreas'>
Compute Areas of Tiles in Dirichlet Tessellation
</h2><span id='topic+dirichletAreas'></span>

<h3>Description</h3>

<p>Calculates the area of each tile in the 
Dirichlet-Voronoi tessellation of a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirichletAreas(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirichletAreas_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an efficient algorithm to calculate the areas
of the tiles in the Dirichlet-Voronoi tessellation.
</p>
<p>If the window of <code>X</code> is a binary pixel mask, the
tile areas are computed by counting pixels. Otherwise the
areas are computed exactly using analytic geometry.
</p>
<p>If any points of <code>X</code> are duplicated, the duplicates will
have tile area zero.
</p>


<h3>Value</h3>

<p>Numeric vector with one entry for each point of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dirichlet">dirichlet</a></code>,
<code><a href="#topic+dirichletVertices">dirichletVertices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> aa &lt;- dirichletAreas(cells)
</code></pre>

<hr>
<h2 id='dirichletVertices'>
Vertices and Edges of Dirichlet Tessellation
</h2><span id='topic+dirichletVertices'></span><span id='topic+dirichletEdges'></span>

<h3>Description</h3>

<p>Computes the Dirichlet-Voronoi tessellation of a point pattern
and extracts the vertices or edges of the tiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirichletVertices(X)

dirichletEdges(X, clip=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirichletVertices_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="dirichletVertices_+3A_clip">clip</code></td>
<td>

<p>Logical value specifying whether to clip the tile edges to the
window. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These function compute the Dirichlet-Voronoi tessellation of <code>X</code>
(see <code><a href="#topic+dirichlet">dirichlet</a></code>)
and extract the vertices or edges of the tiles of the tessellation.
</p>
<p>The Dirichlet vertices are the spatial locations which are locally
farthest away from <code>X</code>, that is, where the distance function
of <code>X</code> reaches a local maximum.
</p>
<p>The Dirichlet edges are the dividing lines equally distant between
a pair of points of <code>X</code>.
</p>
<p>The Dirichlet tessellation of <code>X</code> is computed
using <code><a href="#topic+dirichlet">dirichlet</a></code>. The vertices or edges of all
tiles of the tessellation are extracted.
</p>
<p>For <code>dirichletVertices</code>, any vertex which
lies on the boundary of the window of <code>X</code> is deleted.
The remaining vertices are returned, as a point pattern,
without duplicated entries.
</p>
<p>For <code>dirichletEdges</code>, the edges are initially computed
inside the rectangle <code>Frame(X)</code>.
Then if <code>clip=TRUE</code> (the default), these edges are intersected
with <code>Window(X)</code>, which may cause an edge to be broken into
several pieces.
</p>


<h3>Value</h3>

<p><code>dirichletVertices</code>
returns a point pattern (object of class <code>"ppp"</code>) in the same window
as <code>X</code>.
</p>
<p><code>dirichletEdges</code> returns a line segment pattern (object of
class <code>"psp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dirichlet">dirichlet</a></code>,
<code><a href="#topic+dirichletAreas">dirichletAreas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(dirichlet(cells))

  plot(dirichletVertices(cells), add=TRUE)

  ed &lt;- dirichletEdges(cells)
</code></pre>

<hr>
<h2 id='dirichletWeights'>Compute Quadrature Weights Based on Dirichlet Tessellation</h2><span id='topic+dirichletWeights'></span>

<h3>Description</h3>

<p>Computes quadrature weights for a given set of points,
using the areas of tiles in the Dirichlet tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> dirichletWeights(X, window=NULL, exact=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirichletWeights_+3A_x">X</code></td>
<td>
<p>Data defining a point pattern.</p>
</td></tr>
<tr><td><code id="dirichletWeights_+3A_window">window</code></td>
<td>
<p>Default window for the point pattern</p>
</td></tr>
<tr><td><code id="dirichletWeights_+3A_exact">exact</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, compute exact areas
using the package <code>deldir</code>. If <code>FALSE</code>, compute
approximate areas using a pixel raster.
</p>
</td></tr>
<tr><td><code id="dirichletWeights_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a set of quadrature weights
for a given pattern of points
(typically comprising both &ldquo;data&rdquo; and 'dummy&rdquo; points).
See <code><a href="#topic+quad.object">quad.object</a></code> for an explanation of quadrature
weights and quadrature schemes.
</p>
<p>The weights are computed using the Dirichlet tessellation.
First <code>X</code> and (optionally) <code>window</code> are converted into a
point pattern object. Then the Dirichlet tessellation of the points
of <code>X</code> is computed.
The weight attached to a point of <code>X</code> is the area of
its Dirichlet tile (inside the window <code>Window(X)</code>).
</p>
<p>If <code>exact=TRUE</code> the Dirichlet tessellation is computed exactly
by the Lee-Schachter algorithm using the package <code>deldir</code>.
Otherwise a pixel raster approximation is constructed and the areas
are approximations to the true weights. In all cases the sum of the
weights is equal to the area of the window.
</p>


<h3>Value</h3>

<p>Vector of nonnegative weights for each point in <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="#topic+gridweights">gridweights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Q &lt;- quadscheme(runifrect(10))
  X &lt;- as.ppp(Q) # data and dummy points together
  w &lt;- dirichletWeights(X, exact=FALSE)
</code></pre>

<hr>
<h2 id='disc'>Circular Window</h2><span id='topic+disc'></span>

<h3>Description</h3>

<p>Creates a circular window
</p>


<h3>Usage</h3>

<pre><code class='language-R'> disc(radius=1, centre=c(0,0), ...,
      mask=FALSE, npoly=128, delta=NULL,
      metric=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disc_+3A_radius">radius</code></td>
<td>
<p>Radius of the circle.</p>
</td></tr>
<tr><td><code id="disc_+3A_centre">centre</code></td>
<td>
<p>The centre of the circle.</p>
</td></tr>
<tr><td><code id="disc_+3A_mask">mask</code></td>
<td>
<p>Logical flag controlling the type of approximation
to a perfect circle. See Details.
</p>
</td></tr>
<tr><td><code id="disc_+3A_npoly">npoly</code></td>
<td>
<p>Number of edges of the polygonal approximation,
if <code>mask=FALSE</code>. Incompatible with <code>delta</code>.
</p>
</td></tr>
<tr><td><code id="disc_+3A_delta">delta</code></td>
<td>

<p>Tolerance of polygonal approximation: the length of arc
that will be replaced by one edge of the polygon.
Incompatible with <code>npoly</code>.
</p>
</td></tr>
<tr><td><code id="disc_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>as.mask</code> determining the
pixel resolution, if <code>mask=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="disc_+3A_metric">metric</code></td>
<td>

<p>Optional. A distance metric (object of class <code>"metric"</code>).
The disc with respect to this metric will be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command creates a window object
representing a disc, with the given radius and centre.
</p>
<p>By default, the circle is
approximated by a polygon with <code>npoly</code> edges.
</p>
<p>If <code>mask=TRUE</code>, then the disc is approximated by a binary pixel
mask. The resolution of the mask is controlled by
the arguments <code>...</code> which are passed to <code><a href="#topic+as.mask">as.mask</a></code>.
</p>
<p>The argument <code>radius</code> must be a single positive number.
The argument <code>centre</code> specifies the disc centre: it can be either 
a numeric vector of length 2 giving the coordinates,
or a <code>list(x,y)</code> giving the coordinates of exactly one point, or a
point pattern (object of class <code>"ppp"</code>) containing exactly one
point.
</p>
<p>If the argument <code>metric</code> is given, it should be a distance metric
(object of class <code>"metric"</code>). The disc with respect to this
metric will be computed. 
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code> (see <code><a href="#topic+owin.object">owin.object</a></code>)
specifying a window. 
</p>


<h3>Note</h3>

<p>This function can also be used to generate regular polygons,
by setting <code>npoly</code> to a small integer value. For example
<code>npoly=5</code> generates a pentagon and <code>npoly=13</code> a triskaidecagon.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ellipse">ellipse</a></code>,
<code><a href="#topic+discs">discs</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.mask">as.mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # unit disc
 W &lt;- disc()
 # disc of radius 3 centred at x=10, y=5
 W &lt;- disc(3, c(10,5))
 #
 plot(disc())
 plot(disc(mask=TRUE))
 # nice smooth circle
 plot(disc(npoly=256))
 # how to control the resolution of the mask
 plot(disc(mask=TRUE, dimyx=256))
 # check accuracy of approximation
 area(disc())/pi
 area(disc(mask=TRUE))/pi
</code></pre>

<hr>
<h2 id='discpartarea'>
Area of Part of Disc
</h2><span id='topic+discpartarea'></span>

<h3>Description</h3>

<p>Compute area of intersection between a disc and a window  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discpartarea(X, r, W=as.owin(X))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discpartarea_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>)
specifying the centres of the discs.
Alternatively, <code>X</code> may be in any format
acceptable to <code><a href="#topic+as.ppp">as.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="discpartarea_+3A_r">r</code></td>
<td>

<p>Matrix, vector or numeric value specifying the
radii of the discs.
</p>
</td></tr>
<tr><td><code id="discpartarea_+3A_w">W</code></td>
<td>

<p>Window (object of class <code>"owin"</code>) with which the
discs should be intersected.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm computes the exact area of the intersection between
a window <code>W</code> and a disc (or each of several discs).
The centres of the discs are specified by the point pattern
<code>X</code>, and their radii are specified by <code>r</code>.
</p>
<p>If <code>r</code> is a single numeric value, then the algorithm computes the
area of intersection between <code>W</code> and the disc of radius <code>r</code> centred
at each point of <code>X</code>, and returns a one-column matrix
containing one entry for each point of <code>X</code>.
</p>
<p>If <code>r</code> is a vector of length <code>m</code>, then the algorithm
returns an <code>n * m</code> matrix in which the entry on row <code>i</code>,
column <code>j</code> is the area of the
intersection between <code>W</code> and the disc centred at <code>X[i]</code>
with radius <code>r[j]</code>.
</p>
<p>If <code>r</code> is a matrix, it should have one row for each point in
<code>X</code>. The algorithm
returns a matrix in which the entry on row <code>i</code>,
column <code>j</code> is the area of the
intersection between <code>W</code> and the disc centred at <code>X[i]</code>
with radius <code>r[i,j]</code>.
</p>
<p>Areas are computed by analytic geometry.
</p>


<h3>Value</h3>

<p>Numeric matrix, with one row for each point of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+disc">disc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- unmark(demopat)[1:3]
  discpartarea(X, 0.2)
</code></pre>

<hr>
<h2 id='discretise'>
Safely Convert Point Pattern Window to Binary Mask
</h2><span id='topic+discretise'></span>

<h3>Description</h3>

<p>Given a point pattern, discretise its window by converting it to a
binary pixel mask, adjusting the mask so that it still contains all
the points. Optionally discretise the point locations as well,
by moving them to the nearest pixel centres.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  discretise(X, eps = NULL, dimyx = NULL, xy = NULL, move.points=FALSE,
             rule.eps=c("adjust.eps", "grow.frame", "shrink.frame"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretise_+3A_x">X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>) to be converted.</p>
</td></tr>
<tr><td><code id="discretise_+3A_eps">eps</code></td>
<td>
<p>(optional) width and height of each pixel</p>
</td></tr>
<tr><td><code id="discretise_+3A_dimyx">dimyx</code></td>
<td>
<p>(optional) pixel array dimensions</p>
</td></tr>
<tr><td><code id="discretise_+3A_xy">xy</code></td>
<td>
<p>(optional) pixel coordinates</p>
</td></tr>
<tr><td><code id="discretise_+3A_move.points">move.points</code></td>
<td>
<p>Logical value specifying whether the points should
also be discretised by moving each point to the nearest pixel
centre.</p>
</td></tr>
<tr><td><code id="discretise_+3A_rule.eps">rule.eps</code></td>
<td>

<p>Argument passed to <code><a href="#topic+as.mask">as.mask</a></code>
controlling the discretisation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function modifies the point pattern <code>X</code> by converting its
observation window <code>Window(X)</code> to a binary pixel image (a window
of type <code>"mask"</code>). It ensures that no points of <code>X</code> are
deleted by the discretisation.
If <code>move.points=TRUE</code>, the point coordinates are also discretised.
</p>
<p>The window is first discretised using <code><a href="#topic+as.mask">as.mask</a></code>.
Next,
</p>

<ul>
<li><p> If <code>move.points=TRUE</code>, each point of <code>X</code>
is moved to the centre of the nearest pixel inside the
discretised window.
</p>
</li>
<li><p> If <code>move.points=FALSE</code> (the default),
the point coordinates are unchanged.
It can happen that points of <code>X</code> that were inside the original
window may fall outside the new mask.
The <code>discretise</code> function corrects this by augmenting the mask
(so that the mask includes any pixel that contains a point of the
pattern).
</p>
</li></ul>

<p>The arguments <code>eps</code>, <code>dimyx</code>, <code>xy</code> and <code>rule.eps</code>
control the fineness of the pixel array. They are passed to
<code><a href="#topic+as.mask">as.mask</a></code>.
</p>
<p>If <code>eps</code>, <code>dimyx</code> and <code>xy</code> are all absent or
<code>NULL</code>, and if the window of <code>X</code> is of type <code>"mask"</code>
to start with, then <code>discretise(X)</code> returns <code>X</code> unchanged.
</p>
<p>See <code><a href="#topic+as.mask">as.mask</a></code> for further details
about the arguments <code>eps</code>, <code>dimyx</code>,
<code>xy</code> and <code>rule.eps</code>, and the process of converting
a window to one of type <code>mask</code>.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Error checking</h3>

<p>Before doing anything, <code>discretise</code> checks that
all the points of the pattern are actually
inside the original window.  This is guaranteed to
be the case if the pattern was constructed using <code><a href="#topic+ppp">ppp</a></code>
or <code><a href="#topic+as.ppp">as.ppp</a></code>. However anomalies are possible if the
point pattern was created or manipulated inappropriately.
These will cause an error.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.mask">as.mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- demopat
  plot(X, main="original pattern")
  Y &lt;- discretise(X, dimyx=50)
  plot(Y, main="discretise(X)")
  stopifnot(npoints(X) == npoints(Y))

  # what happens if we just convert the window to a mask?
  W &lt;- Window(X)
  M &lt;- as.mask(W, dimyx=50)
  plot(M, main="window of X converted to mask")
  plot(X, add=TRUE, pch=16)
  plot(X[M], add=TRUE, pch=1, cex=1.5)
  XM &lt;- X[M]
  cat(paste(npoints(X) - npoints(XM), "points of X lie outside M\n"))
</code></pre>

<hr>
<h2 id='discs'>
Union of Discs
</h2><span id='topic+discs'></span>

<h3>Description</h3>

<p>Make a spatial region composed of discs
with given centres and radii.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  discs(centres, radii = marks(centres)/2, ...,
        separate = FALSE, mask = FALSE, trim = TRUE,
        delta = NULL, npoly=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discs_+3A_centres">centres</code></td>
<td>

<p>Point pattern giving the locations of centres for the discs.
</p>
</td></tr>
<tr><td><code id="discs_+3A_radii">radii</code></td>
<td>

<p>Vector of radii for each disc, or a single number giving a common
radius.
(Notice that the default assumes that the marks of <code>X</code> are
<em>diameters</em>.)
</p>
</td></tr>
<tr><td><code id="discs_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine
the pixel resolution, if <code>mask=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="discs_+3A_separate">separate</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the result is a list
containing each disc as a separate entry.
If <code>FALSE</code> (the default), the result is a window
obtained by forming the union of the discs.
</p>
</td></tr>
<tr><td><code id="discs_+3A_mask">mask</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the result is a binary mask window.
If <code>FALSE</code>, the result is a polygonal window.
Applies only when <code>separate=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="discs_+3A_trim">trim</code></td>
<td>

<p>Logical value indicating whether to restrict the result
to the original window of the <code>centres</code>.
Applies only when <code>separate=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="discs_+3A_delta">delta</code></td>
<td>

<p>Argument passed to <code><a href="#topic+disc">disc</a></code> to determine the 
tolerance for the polygonal approximation of each disc.
Applies only when <code>mask=FALSE</code>.
Incompatible with <code>npoly</code>.
</p>
</td></tr>
<tr><td><code id="discs_+3A_npoly">npoly</code></td>
<td>

<p>Argument passed to <code><a href="#topic+disc">disc</a></code> to determine the 
number of edges in the polygonal approximation of each disc.
Applies only when <code>mask=FALSE</code>.
Incompatible with <code>delta</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command is typically applied to a marked point pattern
dataset <code>X</code> in which the marks represent the sizes of objects.
The result is a spatial region representing the space occupied by
the objects.
</p>
<p>If the marks of <code>X</code> represent the diameters of circular objects,
then the result of <code>discs(X)</code>
is a spatial region constructed by taking discs, of the specified
diameters, centred at the points of <code>X</code>, and forming the union
of these discs. If the marks of <code>X</code> represent the areas of
objects, one could take <code>discs(X, sqrt(marks(X)/pi))</code>
to produce discs of equivalent area.
</p>
<p>A fast algorithm is used to compute the result as a binary mask, when
<code>mask=TRUE</code>. This option is recommended unless polygons are
really necessary.
</p>
<p>If <code>mask=FALSE</code>, the discs will be constructed as polygons
by the function <code><a href="#topic+disc">disc</a></code>. To avoid computational problems,
by default, the discs will all be constructed using
the same physical tolerance value <code>delta</code>
passed to <code><a href="#topic+disc">disc</a></code>. The default is such that the smallest
disc will be approximated by a 16-sided polygon.
(The argument <code>npoly</code> should not normally be used, to avoid
computational problems arising with small radii.)
</p>


<h3>Value</h3>

<p>If <code>separate=FALSE</code>, a window (object of class <code>"owin"</code>).
</p>
<p>If <code>separate=TRUE</code>, a list of windows.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+union.owin">union.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(discs(anemones, mask=TRUE, eps=0.5))
</code></pre>

<hr>
<h2 id='distfun'>
Distance Map as a Function 
</h2><span id='topic+distfun'></span><span id='topic+distfun.ppp'></span><span id='topic+distfun.psp'></span><span id='topic+distfun.owin'></span>

<h3>Description</h3>

<p>Compute the distance function of an object, and return it as a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  distfun(X, ...)

  ## S3 method for class 'ppp'
distfun(X, ..., k=1, undef=Inf)

  ## S3 method for class 'psp'
distfun(X, ...)

  ## S3 method for class 'owin'
distfun(X, ..., invert=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distfun_+3A_x">X</code></td>
<td>
<p>Any suitable dataset representing a two-dimensional
object, such as a point pattern (object of class <code>"ppp"</code>),
a window (object of class <code>"owin"</code>) or a
line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="distfun_+3A_...">...</code></td>
<td>

<p>Extra arguments are ignored. 
</p>
</td></tr>
<tr><td><code id="distfun_+3A_k">k</code></td>
<td>

<p>An integer. The distance to the <code>k</code>th nearest point
will be computed.
</p>
</td></tr>
<tr><td><code id="distfun_+3A_undef">undef</code></td>
<td>

<p>The value that should be returned if the distance is undefined
(that is, if <code>X</code> contains fewer than <code>k</code> points).
</p>
</td></tr>
<tr><td><code id="distfun_+3A_invert">invert</code></td>
<td>

<p>If <code>TRUE</code>, compute the distance transform of the
complement of <code>X</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &ldquo;distance function&rdquo; of a set of points <code class="reqn">A</code> is the
mathematical function <code class="reqn">f</code> such that, for any 
two-dimensional spatial location <code class="reqn">(x,y)</code>,
the function value <code>f(x,y)</code>
is the shortest distance from <code class="reqn">(x,y)</code> to <code class="reqn">A</code>.
</p>
<p>The command <code>f &lt;- distfun(X)</code> returns a <em>function</em>
in the <span class="rlang"><b>R</b></span> language, with arguments <code>x,y</code>, that represents the
distance function of <code>X</code>. Evaluating the function <code>f</code>
in the form <code>v &lt;- f(x,y)</code>, where <code>x</code> and <code>y</code>
are any numeric vectors of equal length containing coordinates of
spatial locations, yields the values of the distance function at these
locations. Alternatively <code>x</code> can be a
point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>) of
locations at which the distance function should be computed (and then
<code>y</code> should be missing).
</p>
<p>This should be contrasted with the related command <code><a href="#topic+distmap">distmap</a></code>
which computes the distance function of <code>X</code>
on a grid of locations, and returns the distance
values in the form of a pixel image.
</p>
<p>The distance values returned by <code>f &lt;- distfun(X); d &lt;- f(x)</code>
are computed using coordinate geometry; they are more accurate,
but slower to compute, than the distance values returned by
<code>Z &lt;- distmap(X); d &lt;- Z[x]</code>
which are computed using a fast recursive algorithm. 
</p>
<p>The result of <code>f &lt;- distfun(X)</code> also belongs to the class
<code>"funxy"</code> and to the special class <code>"distfun"</code>.
It can be printed and plotted immediately as shown in the Examples.
</p>
<p>A <code>distfun</code> object can be converted to a pixel image
using <code><a href="#topic+as.im">as.im</a></code>.
</p>


<h3>Value</h3>

<p>A <code>function</code> with arguments <code>x,y</code>.
The function belongs to the class <code>"distfun"</code> which has
methods for <code>print</code> and <code>summary</code>, and for geometric
operations like <code>shift</code>.
It also belongs to the class <code>"funxy"</code> which has methods
for <code>plot</code>, <code>contour</code> and <code>persp</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmap">distmap</a></code>,
<code><a href="#topic+summary.distfun">summary.distfun</a></code>,
<code><a href="#topic+methods.distfun">methods.distfun</a></code>,
<code><a href="#topic+methods.funxy">methods.funxy</a></code>,
<code><a href="#topic+plot.funxy">plot.funxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   f &lt;- distfun(letterR)
   f
   plot(f)
   f(0.2, 0.3)

   plot(distfun(letterR, invert=TRUE), eps=0.1)

   d &lt;- distfun(cells)
   d2 &lt;- distfun(cells, k=2)
   d(0.5, 0.5)
   d2(0.5, 0.5)
   domain(d)
   summary(d)

   z &lt;- d(japanesepines)
</code></pre>

<hr>
<h2 id='distmap'>
Distance Map 
</h2><span id='topic+distmap'></span>

<h3>Description</h3>

<p>Compute the distance map of an object, and return it as a pixel image.
Generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  distmap(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distmap_+3A_x">X</code></td>
<td>
<p>Any suitable dataset representing a two-dimensional
object, such as a point pattern (object of class <code>"ppp"</code>),
a window (object of class <code>"owin"</code>) or a
line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="distmap_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
to control pixel resolution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &ldquo;distance map&rdquo; of a set of points <code class="reqn">A</code> is the function
<code class="reqn">f</code> whose value <code>f(x)</code> is defined for any two-dimensional
location <code class="reqn">x</code> as the shortest distance from <code class="reqn">x</code> to <code class="reqn">A</code>.
</p>
<p>This function computes the distance map of the set <code>X</code>
and returns the distance map as a pixel image.
</p>
<p>This is generic. Methods are provided for
point patterns (<code><a href="#topic+distmap.ppp">distmap.ppp</a></code>),
line segment patterns  (<code><a href="#topic+distmap.psp">distmap.psp</a></code>)
and windows (<code><a href="#topic+distmap.owin">distmap.owin</a></code>).
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) whose grey scale values
are the values of the distance map.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmap.ppp">distmap.ppp</a></code>,
<code><a href="#topic+distmap.psp">distmap.psp</a></code>,
<code><a href="#topic+distmap.owin">distmap.owin</a></code>,
<code><a href="#topic+distfun">distfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  U &lt;- distmap(cells)
  V &lt;- distmap(letterR)
  if(interactive()) {
  plot(U)
  plot(V)
  }
</code></pre>

<hr>
<h2 id='distmap.owin'>Distance Map of Window</h2><span id='topic+distmap.owin'></span>

<h3>Description</h3>

<p>Computes the distance from each pixel to the nearest point
in the given window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'owin'
distmap(X, ..., discretise=FALSE, invert=FALSE,
        connect=8, metric=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distmap.owin_+3A_x">X</code></td>
<td>

<p>A window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="distmap.owin_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
to control pixel resolution.
</p>
</td></tr>
<tr><td><code id="distmap.owin_+3A_discretise">discretise</code></td>
<td>

<p>Logical flag controlling the choice of algorithm when <code>X</code> is
a polygonal window. See Details.
</p>
</td></tr>
<tr><td><code id="distmap.owin_+3A_invert">invert</code></td>
<td>

<p>If <code>TRUE</code>, compute the distance transform of the
complement of the window.
</p>
</td></tr>
<tr><td><code id="distmap.owin_+3A_connect">connect</code></td>
<td>

<p>Neighbourhood connectivity for the discrete distance transform
algorithm. Either 8 or 24.
</p>
</td></tr>
<tr><td><code id="distmap.owin_+3A_metric">metric</code></td>
<td>

<p>Optional. A distance metric
(object of class <code>"metric"</code>, see <code><a href="#topic+metric.object">metric.object</a></code>)
which will be used to compute the distances.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &ldquo;distance map&rdquo; of a window <code class="reqn">W</code> is the function
<code class="reqn">f</code> whose value <code>f(u)</code> is defined for any two-dimensional
location <code class="reqn">u</code> as the shortest distance from <code class="reqn">u</code> to <code class="reqn">W</code>.
</p>
<p>This function computes the distance map of the window <code>X</code>
and returns the distance map as a pixel image. The greyscale value
at a pixel <code class="reqn">u</code> equals the distance from <code class="reqn">u</code> to the nearest
pixel in <code>X</code>.
</p>
<p>Additionally, the return value 
has an attribute <code>"bdry"</code> which is 
also a pixel image. The grey values in <code>"bdry"</code> give the
distance from each pixel to the bounding rectangle of the image.
</p>
<p>If <code>X</code> is a binary pixel mask,
the distance values computed are not the
usual Euclidean distances. Instead the distance between two pixels
is measured by the length of the
shortest path connecting the two pixels. A path is a series of steps
between neighbouring pixels (each pixel has 8 neighbours). 
This is the standard &lsquo;distance transform&rsquo; algorithm of image
processing (Rosenfeld and Kak, 1968; Borgefors, 1986).
</p>
<p>If <code>X</code> is a polygonal window, then exact Euclidean distances
will be computed if <code>discretise=FALSE</code>. If <code>discretise=TRUE</code>
then the window will first be converted to a binary pixel mask
and the discrete path distances will be computed.
</p>
<p>The arguments <code>...</code> are passed to <code><a href="#topic+as.mask">as.mask</a></code>
to control the pixel resolution.
</p>
<p>This function is a method for the generic <code><a href="#topic+distmap">distmap</a></code>.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) whose greyscale values
are the values of the distance map.
The return value has an attribute <code>"bdry"</code>
which is a pixel image.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Borgefors, G.
Distance transformations in digital images.
<em>Computer Vision, Graphics and Image Processing</em> <b>34</b>
(1986) 344&ndash;371.
</p>
<p>Rosenfeld, A. and Pfalz, J.L.
Distance functions on digital pictures.
<em>Pattern Recognition</em> <b>1</b> (1968) 33-61.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmap">distmap</a></code>,
<code><a href="#topic+distmap.ppp">distmap.ppp</a></code>,
<code><a href="#topic+distmap.psp">distmap.psp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  U &lt;- distmap(letterR)
  if(interactive()) {
  plot(U)
  plot(attr(U, "bdry"))
  }
</code></pre>

<hr>
<h2 id='distmap.ppp'>
Distance Map of Point Pattern
</h2><span id='topic+distmap.ppp'></span>

<h3>Description</h3>

<p>Computes the distance from each pixel to the nearest
point in the given point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
distmap(X, ..., clip=FALSE, metric=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distmap.ppp_+3A_x">X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="distmap.ppp_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
to control pixel resolution.
</p>
</td></tr>
<tr><td><code id="distmap.ppp_+3A_clip">clip</code></td>
<td>

<p>Logical value specifying whether the resulting pixel image
should be clipped to the window of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="distmap.ppp_+3A_metric">metric</code></td>
<td>

<p>Optional. A distance metric
(object of class <code>"metric"</code>, see <code><a href="#topic+metric.object">metric.object</a></code>)
which will be used to compute the distances.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &ldquo;distance map&rdquo; of a point pattern <code class="reqn">X</code> is the function
<code class="reqn">f</code> whose value <code>f(u)</code> is defined for any two-dimensional
location <code class="reqn">u</code> as the shortest distance from <code class="reqn">u</code> to <code class="reqn">X</code>.
</p>
<p>This function computes the distance map of the point pattern <code>X</code>
and returns the distance map as a pixel image. The greyscale value
at a pixel <code class="reqn">u</code> equals the distance from <code class="reqn">u</code> to the nearest
point of the pattern <code>X</code>.
</p>
<p>If <code>clip=FALSE</code> (the default), the resulting pixel values are defined at every pixel in
the rectangle <code>Frame(X)</code>. If <code>clip=TRUE</code>, the pixel values are defined
only inside <code>Window(X)</code>, and are <code>NA</code> outside this window.
Computation is faster when <code>clip=FALSE</code>.
</p>
<p>Additionally, the return value 
has two attributes, <code>"index"</code> and <code>"bdry"</code>, which are
also pixel images. The grey values in <code>"bdry"</code> give the
distance from each pixel to the boundary of the window containing <code>X</code>.
The grey values in <code>"index"</code> are integers identifying which
point of <code>X</code> is closest. 
</p>
<p>This is a method for the generic function <code><a href="#topic+distmap">distmap</a></code>.
</p>
<p>Note that this function gives the distance from the
<em>centre of each pixel</em> to the nearest data point.
To compute the exact distance from a given spatial location
to the nearest data point in <code>X</code>, use <code><a href="#topic+distfun">distfun</a></code> or 
<code><a href="#topic+nncross">nncross</a></code>.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) whose greyscale values
are the values of the distance map.
The return value has attributes <code>"index"</code> and <code>"bdry"</code>
which are also pixel images. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p>Generic function <code><a href="#topic+distmap">distmap</a></code> and other methods
<code><a href="#topic+distmap.psp">distmap.psp</a></code>,
<code><a href="#topic+distmap.owin">distmap.owin</a></code>.
</p>
<p>Generic function <code><a href="#topic+distfun">distfun</a></code>.
</p>
<p>Nearest neighbour distance <code><a href="#topic+nncross">nncross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  U &lt;- distmap(cells)
  if(interactive()) {
    plot(U)
    plot(attr(U, "bdry"))
    plot(attr(U, "index"))
  }
</code></pre>

<hr>
<h2 id='distmap.psp'>
Distance Map of Line Segment Pattern
</h2><span id='topic+distmap.psp'></span>

<h3>Description</h3>

<p>Computes the distance from each pixel to the nearest
line segment in the given line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'psp'
distmap(X, ..., extras=TRUE, clip=FALSE, metric=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distmap.psp_+3A_x">X</code></td>
<td>
<p>A line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="distmap.psp_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
to control pixel resolution.
</p>
</td></tr>
<tr><td><code id="distmap.psp_+3A_extras">extras</code></td>
<td>

<p>Logical value specifying whether to compute the
additional attributes <code>"index"</code> and <code>"bdry"</code>
described in Details.
</p>
</td></tr>
<tr><td><code id="distmap.psp_+3A_clip">clip</code></td>
<td>

<p>Logical value specifying whether the resulting pixel image
should be clipped to the window of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="distmap.psp_+3A_metric">metric</code></td>
<td>

<p>Optional. A distance metric
(object of class <code>"metric"</code>, see <code><a href="#topic+metric.object">metric.object</a></code>)
which will be used to compute the distances.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &ldquo;distance map&rdquo; of a line segment pattern <code class="reqn">X</code> is the function
<code class="reqn">f</code> whose value <code>f(u)</code> is defined for any two-dimensional
location <code class="reqn">u</code> as the shortest distance from <code class="reqn">u</code> to <code class="reqn">X</code>.
</p>
<p>This function computes the distance map of the line segment pattern <code>X</code>
and returns the distance map as a pixel image. The greyscale value
at a pixel <code class="reqn">u</code> equals the distance from <code class="reqn">u</code>
to the nearest line segment of the pattern <code>X</code>.
Distances are computed using analytic geometry.
</p>
<p>The result is a pixel image.
If <code>clip=FALSE</code> (the default), the pixel values are defined at every pixel in
the rectangle <code>Frame(X)</code>. If <code>clip=TRUE</code>, the pixel values are defined
only inside <code>Window(X)</code>, and are <code>NA</code> outside this window.
Computation is faster when <code>clip=FALSE</code>.
</p>
<p>Additionally, if <code>extras=TRUE</code>, the return value 
has two attributes, <code>"index"</code> and <code>"bdry"</code>, which are
also pixel images. The pixels values of <code>"bdry"</code> give the
distance from each pixel to the boundary of the window of <code>X</code>
(and are zero outside this window).
The pixel values of <code>"index"</code> are integers identifying which
line segment of <code>X</code> is closest. 
If <code>clip=FALSE</code> (the default), these images are defined at every pixel
in <code>Frame(X)</code>; if <code>clip=TRUE</code>, they are clipped to the window of <code>X</code>.
Computation is faster when <code>extras=FALSE</code>.
</p>
<p>This is a method for the generic function <code><a href="#topic+distmap">distmap</a></code>.
</p>
<p>Note that this function gives the exact distance from the
<em>centre of each pixel</em> to the nearest line segment.
To compute the exact distance from the points in a point pattern
to the nearest line segment, use <code><a href="#topic+distfun">distfun</a></code> or one of the
low-level functions <code><a href="#topic+nncross">nncross</a></code>
or <code><a href="#topic+project2segment">project2segment</a></code>.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) whose greyscale values
are the values of the distance map.
The return value has attributes <code>"index"</code> and <code>"bdry"</code>
which are also pixel images. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmap">distmap</a></code>,
<code><a href="#topic+distmap.owin">distmap.owin</a></code>,
<code><a href="#topic+distmap.ppp">distmap.ppp</a></code>,
<code><a href="#topic+distfun">distfun</a></code>,
<code><a href="#topic+nncross">nncross</a></code>,
<code><a href="#topic+nearestsegment">nearestsegment</a></code>,
<code><a href="#topic+project2segment">project2segment</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    a &lt;- psp(runif(20),runif(20),runif(20),runif(20), window=owin())
    Z &lt;- distmap(a)
    plot(Z)
    plot(a, add=TRUE)
</code></pre>

<hr>
<h2 id='domain'>
Extract the Domain of any Spatial Object
</h2><span id='topic+domain'></span><span id='topic+domain.ppp'></span><span id='topic+domain.psp'></span><span id='topic+domain.im'></span><span id='topic+domain.ppx'></span><span id='topic+domain.pp3'></span><span id='topic+domain.quad'></span><span id='topic+domain.quadratcount'></span><span id='topic+domain.tess'></span><span id='topic+domain.layered'></span><span id='topic+domain.distfun'></span><span id='topic+domain.nnfun'></span><span id='topic+domain.funxy'></span>

<h3>Description</h3>

<p>Given a spatial object such as a point pattern, in any number of dimensions,
this function extracts the spatial domain in which the object is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   domain(X, ...)

   ## S3 method for class 'ppp'
domain(X, ...)

   ## S3 method for class 'psp'
domain(X, ...)

   ## S3 method for class 'im'
domain(X, ...)

   ## S3 method for class 'ppx'
domain(X, ...)

   ## S3 method for class 'pp3'
domain(X, ...)

 ## S3 method for class 'quad'
domain(X, ...)

 ## S3 method for class 'quadratcount'
domain(X, ...)

 ## S3 method for class 'tess'
domain(X, ...)

 ## S3 method for class 'layered'
domain(X, ...)

 ## S3 method for class 'distfun'
domain(X, ...)

 ## S3 method for class 'nnfun'
domain(X, ...)

 ## S3 method for class 'funxy'
domain(X, ...)





</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain_+3A_x">X</code></td>
<td>

<p>A spatial object such as a point pattern (in any number
of dimensions), line segment pattern or pixel image.
</p>
</td></tr>
<tr><td><code id="domain_+3A_...">...</code></td>
<td>

<p>Extra arguments. They are ignored by all the methods listed here.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+domain">domain</a></code> is generic.
</p>
<p>For a spatial object <code>X</code> in any number of dimensions, 
<code>domain(X)</code> extracts the spatial domain in which <code>X</code> is
defined.
</p>
<p>For a two-dimensional object <code>X</code>, typically <code>domain(X)</code>
is the same as <code>Window(X)</code>.
</p>
<p>Exceptions occur for methods related to linear networks.
</p>


<h3>Value</h3>

<p>A spatial object representing the domain of <code>X</code>.
Typically a window (object of class <code>"owin"</code>),
a three-dimensional box (<code>"box3"</code>), a multidimensional
box (<code>"boxx"</code>) or a linear network (<code>"linnet"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+domain.ppm">domain.ppm</a></code>,
<code><a href="spatstat.explore.html#topic+domain.quadrattest">domain.quadrattest</a></code>,
<code><a href="spatstat.random.html#topic+domain.rmhmodel">domain.rmhmodel</a></code>,
<code><a href="spatstat.linnet.html#topic+domain.lpp">domain.lpp</a></code>.
<code><a href="#topic+Window">Window</a></code>,
<code><a href="#topic+Frame">Frame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  domain(redwood)
  domain(bei.extra$elev)
  domain(osteo$pts[[1]])
</code></pre>

<hr>
<h2 id='duplicated.ppp'>Determine Duplicated Points in a Spatial Point Pattern</h2><span id='topic+duplicated.ppp'></span><span id='topic+duplicated.ppx'></span><span id='topic+anyDuplicated.ppp'></span><span id='topic+anyDuplicated.ppx'></span>

<h3>Description</h3>

<p>Determines which points in a spatial point pattern
are duplicates of previous points, and returns a logical vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppp'
duplicated(x, ..., rule=c("spatstat", "deldir", "unmark"))

 ## S3 method for class 'ppx'
duplicated(x, ...)

 ## S3 method for class 'ppp'
anyDuplicated(x, ...)

 ## S3 method for class 'ppx'
anyDuplicated(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicated.ppp_+3A_x">x</code></td>
<td>

<p>A spatial point pattern
(object of class <code>"ppp"</code> or <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="duplicated.ppp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="duplicated.ppp_+3A_rule">rule</code></td>
<td>

<p>Character string.
The rule for determining duplicated points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions <code><a href="base.html#topic+duplicated">duplicated</a></code>
and <code><a href="base.html#topic+anyDuplicated">anyDuplicated</a></code> for 
point pattern datasets (of class <code>"ppp"</code>, see
<code><a href="#topic+ppp.object">ppp.object</a></code>, or class <code>"ppx"</code>).
</p>
<p><code>anyDuplicated(x)</code> is a faster version of
<code>any(duplicated(x))</code>.
</p>
<p>Two points in a point pattern are deemed to be identical
if their <code class="reqn">x,y</code> coordinates are the same,
and their marks are also the same (if they carry marks).
The Examples section illustrates how it is possible for
a point pattern to contain a pair of identical points.
</p>
<p>This function determines which points in <code>x</code> duplicate
other points that appeared earlier in the sequence. It 
returns a logical vector with entries that are <code>TRUE</code>
for duplicated points and <code>FALSE</code> for unique (non-duplicated)
points.
</p>
<p>If <code>rule="spatstat"</code> (the default), two points are deemed
identical if their coordinates are equal according to <code>==</code>,
<em>and</em> their marks are equal according to <code>==</code>.
This is the most stringent possible test.
If <code>rule="unmark"</code>, duplicated points are
determined by testing equality of their coordinates only,
using <code>==</code>.
If <code>rule="deldir"</code>, duplicated points are
determined by testing equality of their coordinates only,
using the function <code><a href="deldir.html#topic+duplicatedxy">duplicatedxy</a></code>
in the package <span class="pkg">deldir</span>, which currently uses
<code><a href="base.html#topic+duplicated.data.frame">duplicated.data.frame</a></code>. Setting <code>rule="deldir"</code>
will ensure consistency with functions in the <span class="pkg">deldir</span> package.
</p>


<h3>Value</h3>

<p><code>duplicated(x)</code> returns
a logical vector of length equal to the number of points in <code>x</code>.
</p>
<p><code>anyDuplicated(x)</code> is a number equal to 0 if there are no
duplicated points, and otherwise is equal to the index of the first
duplicated point.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+unique.ppp">unique.ppp</a></code>,
<code><a href="#topic+multiplicity.ppp">multiplicity.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- ppp(c(1,1,0.5), c(2,2,1), window=square(3))
   duplicated(X)
   duplicated(X, rule="deldir")
</code></pre>

<hr>
<h2 id='edges'>
Extract Boundary Edges of a Window.
</h2><span id='topic+edges'></span>

<h3>Description</h3>

<p>Extracts the boundary edges of a window
and returns them as a line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  edges(x, ..., window = NULL, check = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_+3A_x">x</code></td>
<td>

<p>A window (object of class <code>"owin"</code>), or
data acceptable to <code><a href="#topic+as.owin">as.owin</a></code>, specifying the window
whose boundary is to be extracted.
</p>
</td></tr>
<tr><td><code id="edges_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="edges_+3A_window">window</code></td>
<td>

<p>Window to contain the resulting line segments.
Defaults to <code>as.rectangle(x)</code>.
</p>
</td></tr>
<tr><td><code id="edges_+3A_check">check</code></td>
<td>

<p>Logical. Whether to check the validity of the resulting
segment pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The boundary edges of the window <code>x</code> will be extracted as a line
segment pattern.
</p>


<h3>Value</h3>

<p>A line segment pattern (object of class <code>"psp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+perimeter">perimeter</a></code> for calculating the total length of the boundary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  edges(square(1))
  edges(letterR)
</code></pre>

<hr>
<h2 id='edges2triangles'>
List Triangles in a Graph
</h2><span id='topic+edges2triangles'></span>

<h3>Description</h3>

<p>Given a list of edges between vertices,
compile a list of all triangles formed by these edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges2triangles(iedge, jedge, nvert=max(iedge, jedge), ...,
                check=TRUE, friendly=rep(TRUE, nvert))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges2triangles_+3A_iedge">iedge</code>, <code id="edges2triangles_+3A_jedge">jedge</code></td>
<td>

<p>Integer vectors, of equal length, specifying the edges.
</p>
</td></tr>
<tr><td><code id="edges2triangles_+3A_nvert">nvert</code></td>
<td>

<p>Number of vertices in the network.
</p>
</td></tr>
<tr><td><code id="edges2triangles_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="edges2triangles_+3A_check">check</code></td>
<td>
<p>Logical. Whether to check validity of input data.</p>
</td></tr>
<tr><td><code id="edges2triangles_+3A_friendly">friendly</code></td>
<td>

<p>Optional. For advanced use. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This low level function finds all the triangles (cliques of size 3)
in a finite graph with <code>nvert</code> vertices and with edges
specified by <code>iedge, jedge</code>. 
</p>
<p>The interpretation of <code>iedge, jedge</code> is that each successive
pair of entries specifies an edge in the graph.
The <code class="reqn">k</code>th edge joins vertex <code>iedge[k]</code> to vertex <code>jedge[k]</code>.
Entries of <code>iedge</code> and <code>jedge</code> must be integers
from 1 to <code>nvert</code>.
</p>
<p>To improve efficiency in some applications, the optional argument
<code>friendly</code> can be used. It should be a logical vector of
length <code>nvert</code> specifying a labelling of the vertices,
such that two vertices <code>j,k</code> which are <em>not</em> friendly
(<code>friendly[j] = friendly[k] = FALSE</code>)
are <em>never</em> connected by an edge. 
</p>


<h3>Value</h3>

<p>A 3-column matrix of integers, in which each row represents a triangle.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edges2vees">edges2vees</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> i &lt;- c(1, 2, 5, 5, 1, 4, 2)
 j &lt;- c(2, 3, 3, 1, 3, 2, 5)
 edges2triangles(i, j)
</code></pre>

<hr>
<h2 id='edges2vees'>
List Dihedral Triples in a Graph
</h2><span id='topic+edges2vees'></span>

<h3>Description</h3>

<p>Given a list of edges between vertices,
compile a list of all &lsquo;vees&rsquo; or dihedral triples
formed by these edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges2vees(iedge, jedge, nvert=max(iedge, jedge), ...,
                check=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges2vees_+3A_iedge">iedge</code>, <code id="edges2vees_+3A_jedge">jedge</code></td>
<td>

<p>Integer vectors, of equal length, specifying the edges.
</p>
</td></tr>
<tr><td><code id="edges2vees_+3A_nvert">nvert</code></td>
<td>

<p>Number of vertices in the network.
</p>
</td></tr>
<tr><td><code id="edges2vees_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="edges2vees_+3A_check">check</code></td>
<td>
<p>Logical. Whether to check validity of input data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a finite graph with <code>nvert</code> vertices and with edges
specified by <code>iedge, jedge</code>, this low-level function
finds all &lsquo;vees&rsquo; or &lsquo;dihedral triples&rsquo;
in the graph, that is, all triples
of vertices <code>(i,j,k)</code> where <code>i</code> and <code>j</code> are joined by
an edge and <code>i</code> and <code>k</code> are joined by an edge. 
</p>
<p>The interpretation of <code>iedge, jedge</code> is that each successive
pair of entries specifies an edge in the graph.
The <code class="reqn">k</code>th edge joins vertex <code>iedge[k]</code> to vertex <code>jedge[k]</code>.
Entries of <code>iedge</code> and <code>jedge</code> must be integers
from 1 to <code>nvert</code>.
</p>


<h3>Value</h3>

<p>A 3-column matrix of integers, in which each row represents a triple
of vertices, with the first vertex joined to the other two vertices.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edges2triangles">edges2triangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> i &lt;- c(1, 2, 5, 5, 1, 4, 2)
 j &lt;- c(2, 3, 3, 1, 3, 2, 5)
 edges2vees(i, j)
</code></pre>

<hr>
<h2 id='edit.hyperframe'>
Invoke Text Editor on Hyperframe
</h2><span id='topic+edit.hyperframe'></span>

<h3>Description</h3>

<p>Invokes a text editor allowing the user to inspect and change
entries in a hyperframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyperframe'
edit(name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edit.hyperframe_+3A_name">name</code></td>
<td>

<p>A hyperframe (object of class <code>"hyperframe"</code>).
</p>
</td></tr>
<tr><td><code id="edit.hyperframe_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="utils.html#topic+edit.data.frame">edit.data.frame</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="utils.html#topic+edit">edit</a></code> is generic. This function
is the methods for objects of class <code>"hyperframe"</code>.
</p>
<p>The hyperframe <code>name</code> is converted to a data frame or array,
and the text editor is invoked. The user can change entries in the
columns of data, and create new columns of data.
</p>
<p>Only the columns of atomic data
(numbers, characters, factor values etc) can be edited.
</p>
<p>Note that the original object <code>name</code> is not changed;
the function returns the edited dataset.
</p>


<h3>Value</h3>

<p>Another hyperframe.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+edit.data.frame">edit.data.frame</a></code>,
<code><a href="#topic+edit.ppp">edit.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) Z &lt;- edit(flu)
</code></pre>

<hr>
<h2 id='edit.ppp'>
Invoke Text Editor on Spatial Data
</h2><span id='topic+edit.ppp'></span><span id='topic+edit.psp'></span><span id='topic+edit.im'></span>

<h3>Description</h3>

<p>Invokes a text editor allowing the user to inspect and change
entries in a spatial dataset. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
edit(name, ...)

## S3 method for class 'psp'
edit(name, ...)

## S3 method for class 'im'
edit(name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edit.ppp_+3A_name">name</code></td>
<td>

<p>A spatial dataset
(object of class <code>"ppp"</code>, <code>"psp"</code> or <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="edit.ppp_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="utils.html#topic+edit.data.frame">edit.data.frame</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="utils.html#topic+edit">edit</a></code> is generic. These functions
are methods for spatial
objects of class <code>"ppp"</code>, <code>"psp"</code> and <code>"im"</code>.
</p>
<p>The spatial dataset <code>name</code> is converted to a data frame or array,
and the text editor is invoked. The user can change the values of spatial
coordinates or marks of the points in a point pattern,
or the coordinates or marks of the segments in a segment pattern,
or the pixel values in an image. 
The names of the columns of marks can also be edited.
</p>
<p>If <code>name</code> is a pixel image, it is converted to a matrix 
and displayed in the same spatial orientation as if
the image had been plotted.
</p>
<p>Note that the original object <code>name</code> is not changed;
the function returns the edited dataset.
</p>


<h3>Value</h3>

<p>Object of the same kind as <code>name</code> containing the edited data.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+edit.data.frame">edit.data.frame</a></code>,
<code><a href="#topic+edit.hyperframe">edit.hyperframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) Z &lt;- edit(cells)
</code></pre>

<hr>
<h2 id='ellipse'>
Elliptical Window.
</h2><span id='topic+ellipse'></span>

<h3>Description</h3>

<p>Create an elliptical window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ellipse(a, b, centre=c(0,0), phi=0, ..., mask=FALSE, npoly = 128)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipse_+3A_a">a</code>, <code id="ellipse_+3A_b">b</code></td>
<td>

<p>The half-lengths of the axes of the ellipse.
</p>
</td></tr>
<tr><td><code id="ellipse_+3A_centre">centre</code></td>
<td>

<p>The centre of the ellipse.
</p>
</td></tr>
<tr><td><code id="ellipse_+3A_phi">phi</code></td>
<td>

<p>The (anti-clockwise) angle through which the ellipse should be
rotated (about its centre) starting from an orientation in which
the axis of half-length <code>a</code> is horizontal.
</p>
</td></tr>
<tr><td><code id="ellipse_+3A_mask">mask</code></td>
<td>

<p>Logical value controlling the type of approximation
to a perfect ellipse. See Details.
</p>
</td></tr>
<tr><td><code id="ellipse_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine the
pixel resolution, if <code>mask</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ellipse_+3A_npoly">npoly</code></td>
<td>

<p>The number of edges in the polygonal approximation to the ellipse.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command creates a window object
representing an ellipse with the given centre and axes.
</p>
<p>By default, the ellipse is
approximated by a polygon with <code>npoly</code> edges.
</p>
<p>If <code>mask=TRUE</code>, then the ellipse is approximated by a binary pixel
mask. The resolution of the mask is controlled by
the arguments <code>...</code> which are passed to <code><a href="#topic+as.mask">as.mask</a></code>.
</p>
<p>The arguments <code>a</code> and <code>b</code> must be single positive numbers.
The argument <code>centre</code> specifies the ellipse centre: it can be either 
a numeric vector of length 2 giving the coordinates,
or a <code>list(x,y)</code> giving the coordinates of exactly one point, or a
point pattern (object of class <code>"ppp"</code>) containing exactly one point.
</p>


<h3>Value</h3>

<p>An object of class <code>owin</code> (either of type &ldquo;polygonal&rdquo;
or of type &ldquo;mask&rdquo;) specifying an elliptical window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.mask">as.mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  W &lt;- ellipse(a=5,b=2,centre=c(5,1),phi=pi/6)
  plot(W,lwd=2,border="red")
  WM &lt;- ellipse(a=5,b=2,centre=c(5,1),phi=pi/6,mask=TRUE,dimyx=64)
  plot(WM,add=TRUE,box=FALSE)
</code></pre>

<hr>
<h2 id='endpoints.psp'>Endpoints of Line Segment Pattern</h2><span id='topic+endpoints.psp'></span>

<h3>Description</h3>

<p>Extracts the endpoints of each line segment
in a line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  endpoints.psp(x, which="both")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="endpoints.psp_+3A_x">x</code></td>
<td>

<p>A line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="endpoints.psp_+3A_which">which</code></td>
<td>

<p>String specifying which endpoint or endpoints should be
returned. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts one endpoint, or both endpoints,
from each of the line segments in <code>x</code>,
and returns these points as a point pattern object.
</p>
<p>The argument <code>which</code> determines which endpoint or endpoints
of each line segment should be returned:
</p>

<dl>
<dt><code>which="both"</code></dt><dd>
<p>(the default): both endpoints
of each line segment are returned. The result is a point pattern
with twice as many points as there are line segments in <code>x</code>.
</p>
</dd>
<dt><code>which="first"</code></dt><dd>
<p>select the first endpoint
of each line segment (returns the points with coordinates
<code>x$ends$x0, x$ends$y0</code>).
</p>
</dd>
<dt><code>which="second"</code></dt><dd>
<p>select the second endpoint
of each line segment (returns the points with coordinates
<code>x$ends$x1, x$ends$y1</code>).
</p>
</dd>
<dt><code>which="left"</code></dt><dd>
<p>select the left-most endpoint
(the endpoint with the smaller <code class="reqn">x</code> coordinate)
of each line segment.
</p>
</dd>
<dt><code>which="right"</code></dt><dd>
<p>select the right-most endpoint
(the endpoint with the greater <code class="reqn">x</code> coordinate)
of each line segment.
</p>
</dd>
<dt><code>which="lower"</code></dt><dd>
<p>select the lower endpoint
(the endpoint with the smaller <code class="reqn">y</code> coordinate)
of each line segment.
</p>
</dd>
<dt><code>which="upper"</code></dt><dd>
<p>select the upper endpoint
(the endpoint with the greater <code class="reqn">y</code> coordinate)
of each line segment.
</p>
</dd>
</dl>

<p>The result is a point pattern. It also has an attribute
<code>"id"</code> which is an integer vector identifying
the segment which contributed each point.
</p>


<h3>Value</h3>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp.object">psp.object</a></code>,
<code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+marks.psp">marks.psp</a></code>,
<code><a href="#topic+summary.psp">summary.psp</a></code>,
<code><a href="#topic+midpoints.psp">midpoints.psp</a></code>,
<code><a href="#topic+lengths_psp">lengths_psp</a></code>,
<code><a href="#topic+angles.psp">angles.psp</a></code>,
<code><a href="#topic+extrapolate.psp">extrapolate.psp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  plot(a)
  b &lt;- endpoints.psp(a, "left")
  plot(b, add=TRUE)
</code></pre>

<hr>
<h2 id='eroded.areas'>Areas of Morphological Erosions</h2><span id='topic+eroded.areas'></span>

<h3>Description</h3>

<p>Computes the areas of successive morphological erosions of a window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> eroded.areas(w, r, subset=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eroded.areas_+3A_w">w</code></td>
<td>
<p>A window.</p>
</td></tr>
<tr><td><code id="eroded.areas_+3A_r">r</code></td>
<td>
<p>Numeric vector of radii at which erosions will be performed.</p>
</td></tr>
<tr><td><code id="eroded.areas_+3A_subset">subset</code></td>
<td>

<p>Optional window inside which the areas should be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the areas of the erosions of the window
<code>w</code> by each of the radii <code>r[i]</code>. 
</p>
<p>The morphological erosion of a set <code class="reqn">W</code> by a distance <code class="reqn">r &gt; 0</code>
is the subset 
consisting of all points <code class="reqn">x \in W</code> such that the
distance from <code class="reqn">x</code> to the boundary of <code class="reqn">W</code> is greater than
or equal to <code class="reqn">r</code>. In other words it is the result of trimming
a margin of width <code class="reqn">r</code> off the set <code class="reqn">W</code>.
</p>
<p>The argument <code>r</code> should be a vector of positive numbers.
The argument <code>w</code> should be a window (an object of class
<code>"owin"</code>, see <code><a href="#topic+owin.object">owin.object</a></code> for details)
or can be given in any format acceptable to <code><a href="#topic+as.owin">as.owin</a>()</code>.
</p>
<p>Unless <code>w</code> is a rectangle, the computation is performed
using a pixel raster approximation.
</p>
<p>To compute the eroded window itself, use <code><a href="#topic+erosion">erosion</a></code>.
</p>


<h3>Value</h3>

<p>Numeric vector, of the same length as <code>r</code>,
giving the areas of the successive erosions.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+erosion">erosion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- owin(c(0,1),c(0,1))
  a &lt;- eroded.areas(w, seq(0.01,0.49,by=0.01))
</code></pre>

<hr>
<h2 id='erosion'>Morphological Erosion by a Disc</h2><span id='topic+erosion'></span><span id='topic+erosion.owin'></span><span id='topic+erosion.ppp'></span><span id='topic+erosion.psp'></span>

<h3>Description</h3>

<p>Perform morphological erosion of a window, a line segment pattern
or a point pattern by a disc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> erosion(w, r, ...)
 ## S3 method for class 'owin'
erosion(w, r, shrink.frame=TRUE, ...,
   strict=FALSE, polygonal=NULL)
 ## S3 method for class 'ppp'
erosion(w, r,...)
 ## S3 method for class 'psp'
erosion(w, r,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erosion_+3A_w">w</code></td>
<td>

<p>A window (object of class <code>"owin"</code>
or a line segment pattern (object of class <code>"psp"</code>)
or a point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="erosion_+3A_r">r</code></td>
<td>
<p>positive number: the radius of erosion.</p>
</td></tr>
<tr><td><code id="erosion_+3A_shrink.frame">shrink.frame</code></td>
<td>
<p>logical: if <code>TRUE</code>, erode the bounding
rectangle as well.</p>
</td></tr>
<tr><td><code id="erosion_+3A_...">...</code></td>
<td>
<p>extra arguments to <code><a href="#topic+as.mask">as.mask</a></code>
controlling the pixel resolution, if pixel approximation is used.</p>
</td></tr>
<tr><td><code id="erosion_+3A_strict">strict</code></td>
<td>
<p>Logical flag determining the fate of boundary pixels,
if pixel approximation is used. See details.</p>
</td></tr>
<tr><td><code id="erosion_+3A_polygonal">polygonal</code></td>
<td>

<p>Logical flag indicating whether to compute a polygonal
approximation to the erosion (<code>polygonal=TRUE</code>) or
a pixel grid approximation (<code>polygonal=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The morphological erosion of a set <code class="reqn">W</code> by a distance <code class="reqn">r &gt; 0</code>
is the subset 
consisting of all points <code class="reqn">x \in W</code> such that the
distance from <code class="reqn">x</code> to the boundary of <code class="reqn">W</code> is greater than
or equal to <code class="reqn">r</code>. In other words it is the result of trimming
a margin of width <code class="reqn">r</code> off the set <code class="reqn">W</code>.
</p>
<p>If <code>polygonal=TRUE</code> then a polygonal approximation
to the erosion is computed.
If <code>polygonal=FALSE</code> then a pixel approximation
to the erosion is computed from the distance map of <code>w</code>.
The arguments <code>"\dots"</code> are passed to <code><a href="#topic+as.mask">as.mask</a></code>
to control the pixel resolution.
The erosion consists of all pixels whose distance
from the boundary of <code>w</code> is strictly greater than <code>r</code> (if
<code>strict=TRUE</code>) or is greater than or equal to <code>r</code> (if
<code>strict=FALSE</code>).
</p>
<p>When <code>w</code> is a window, the default (when <code>polygonal=NULL</code>)
is to compute a polygonal approximation if
<code>w</code> is a rectangle or polygonal window, and to compute a
pixel approximation if <code>w</code> is a window of type <code>"mask"</code>.
</p>
<p>If <code>shrink.frame</code> is false, the resulting window is given the
same outer, bounding rectangle as the original window <code>w</code>.
If <code>shrink.frame</code> is true, the original bounding rectangle
is also eroded by the same distance <code>r</code>.
</p>
<p>To simply compute the area of the eroded window,
use <code><a href="#topic+eroded.areas">eroded.areas</a></code>.
</p>


<h3>Value</h3>

<p>If <code>r &gt; 0</code>, an object of class <code>"owin"</code> representing the
eroded region (or <code>NULL</code> if this region is empty).
If <code>r=0</code>, the result is identical to <code>w</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dilation">dilation</a></code> for the opposite operation.
</p>
<p><code><a href="#topic+erosionAny">erosionAny</a></code> for morphological erosion using any shape.
</p>
<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+eroded.areas">eroded.areas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(letterR, main="erosion(letterR, 0.2)")
  plot(erosion(letterR, 0.2), add=TRUE, col="red")
</code></pre>

<hr>
<h2 id='erosionAny'>Morphological Erosion of Windows</h2><span id='topic+erosionAny'></span><span id='topic++25+28-+29+25'></span>

<h3>Description</h3>

<p>Compute the morphological erosion of one spatial window by another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erosionAny(A, B)

A %(-)% B
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erosionAny_+3A_a">A</code>, <code id="erosionAny_+3A_b">B</code></td>
<td>

<p>Windows (objects of class <code>"owin"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The operator <code>A %(-)% B</code> and function <code>erosionAny(A,B)</code>
are synonymous: they both compute the
morphological erosion of the window <code>A</code> by the window <code>B</code>.
</p>
<p>The morphological erosion
<code class="reqn">A \ominus B</code>
of region <code class="reqn">A</code> by region <code class="reqn">B</code>
is the spatial region consisting of all vectors <code class="reqn">z</code>
such that, when <code class="reqn">B</code> is shifted by the vector <code class="reqn">z</code>, the result
is a subset of <code class="reqn">A</code>.
</p>
<p>Equivalently
</p>
<p style="text-align: center;"><code class="reqn">
    A \ominus B = ((A^c \oplus (-B))^c
  </code>
</p>

<p>where <code class="reqn">\oplus</code> is the Minkowski sum,
<code class="reqn">A^c</code> denotes the set complement, and <code class="reqn">(-B)</code> is
the reflection of <code class="reqn">B</code> through the origin, consisting of all
vectors <code class="reqn">-b</code> where <code class="reqn">b</code> is a point in <code class="reqn">B</code>.
</p>
<p>If <code>B</code> is a disc of radius <code>r</code>, then
<code>erosionAny(A, B)</code> is equivalent to <code>erosion(A, r)</code>.
See <code><a href="#topic+erosion">erosion</a></code>.
</p>
<p>The algorithm currently computes the result as a polygonal
window using the <span class="pkg">polyclip</span> library. 
It will be quite slow if applied to binary mask windows.
</p>


<h3>Value</h3>

<p>Another window (object of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+erosion">erosion</a></code>,
<code><a href="#topic+MinkowskiSum">MinkowskiSum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  B &lt;- square(c(-0.1, 0.1))
  RminusB &lt;- letterR %(-)% B
  FR &lt;- grow.rectangle(Frame(letterR), 0.3)
  plot(FR, main="", type="n")
  plot(letterR, add=TRUE, lwd=2, hatch=TRUE, box=FALSE)
  plot(RminusB, add=TRUE, col="blue", box=FALSE)
  plot(shift(B, vec=c(3.49, 2.98)),
       add=TRUE, border="red", lwd=2)
</code></pre>

<hr>
<h2 id='eval.im'>Evaluate Expression Involving Pixel Images</h2><span id='topic+eval.im'></span>

<h3>Description</h3>

<p>Evaluates any expression involving one or more pixel images,
and returns a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  eval.im(expr, envir, harmonize=TRUE, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.im_+3A_expr">expr</code></td>
<td>
<p>An expression.</p>
</td></tr>
<tr><td><code id="eval.im_+3A_envir">envir</code></td>
<td>
<p>Optional. The environment in which to evaluate the
expression, or a named list containing pixel images to be used
in the expression.</p>
</td></tr>
<tr><td><code id="eval.im_+3A_harmonize">harmonize</code></td>
<td>

<p>Logical. Whether to resolve inconsistencies between
the pixel grids.
</p>
</td></tr>
<tr><td><code id="eval.im_+3A_warn">warn</code></td>
<td>

<p>Logical. Whether to issue a warning if the pixel grids were
inconsistent.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper to make it easier to perform
pixel-by-pixel calculations in an image. 
</p>
<p>Pixel images in <span class="pkg">spatstat</span>
are represented by objects of class <code>"im"</code>
(see <code><a href="#topic+im.object">im.object</a></code>). These are essentially matrices of
pixel values, with extra attributes recording the pixel dimensions,
etc.
</p>
<p>Suppose <code>X</code> is a pixel image. Then <code>eval.im(X+3)</code>
will add 3 to the value of every pixel in <code>X</code>, and return
the resulting pixel image.
</p>
<p>Suppose <code>X</code> and <code>Y</code> are two pixel images with compatible
dimensions: they have the same number of pixels, the same physical
size of pixels, and the same bounding box. Then
<code>eval.im(X + Y)</code> will add the corresponding pixel values in
<code>X</code> and <code>Y</code>, and return the resulting pixel image.
</p>
<p>In general, <code>expr</code> can be any expression in the R language involving
(a) the <em>names</em> of pixel images, (b) scalar
constants, and (c) functions which are vectorised.
See the Examples.
</p>
<p>First <code>eval.im</code> determines which of the <em>variable names</em>
in the expression <code>expr</code> refer to pixel images. Each such name
is replaced by a matrix containing the pixel values. The expression is
then evaluated. The result should be a matrix; it is taken as
the matrix of pixel values.
</p>
<p>The expression <code>expr</code> must be vectorised.
There must be at least one pixel image in the expression.
</p>
<p>All images must have compatible dimensions.
If <code>harmonize=FALSE</code>, images that are incompatible will cause an error.
If <code>harmonize=TRUE</code>, images that have incompatible dimensions
will be resampled so that they are compatible; if <code>warn=TRUE</code>,
a warning will be issued.
</p>


<h3>Value</h3>

<p>An image object of class <code>"im"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im.apply">im.apply</a></code> for operations similar to <code><a href="base.html#topic+apply">apply</a></code>,
such as taking the sum of a list of images.
</p>
<p><code><a href="#topic+as.im">as.im</a></code>,
<code><a href="#topic+compatible.im">compatible.im</a></code>,
<code><a href="#topic+harmonise.im">harmonise.im</a></code>,
<code><a href="#topic+im.object">im.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # test images
  X &lt;- as.im(function(x,y) { x^2 - y^2 }, unit.square())
  Y &lt;- as.im(function(x,y) { 3 * x + y }, unit.square())

  eval.im(X + 3)
  eval.im(X - Y)
  eval.im(abs(X - Y))
  Z &lt;- eval.im(sin(X * pi) + Y)

  ## Use of 'envir': bei.extra is a list with components 'elev' and 'grad'
  W &lt;- eval.im(atan(grad) * 180/pi, bei.extra)
</code></pre>

<hr>
<h2 id='ewcdf'>Weighted Empirical Cumulative Distribution Function</h2><span id='topic+ewcdf'></span>

<h3>Description</h3>

<p>Compute a weighted version of the
empirical cumulative distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewcdf(x, weights = NULL, normalise=TRUE, adjust=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ewcdf_+3A_x">x</code></td>
<td>
<p>Numeric vector of observations.</p>
</td></tr>
<tr><td><code id="ewcdf_+3A_weights">weights</code></td>
<td>

<p>Optional. Numeric vector of non-negative weights for <code>x</code>.
Defaults to equal weight 1 for each entry of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="ewcdf_+3A_normalise">normalise</code></td>
<td>

<p>Logical value indicating whether the weights should be rescaled
so that they sum to 1.
</p>
</td></tr>
<tr><td><code id="ewcdf_+3A_adjust">adjust</code></td>
<td>

<p>Numeric value. Adjustment factor.
The weights will be multiplied by <code>adjust</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a modification of the standard function <code><a href="stats.html#topic+ecdf">ecdf</a></code>
allowing the observations <code>x</code> to have weights.
</p>
<p>The weighted e.c.d.f. (empirical cumulative distribution function)
<code>Fn</code> is defined so that, for any real number <code>y</code>, the value of
<code>Fn(y)</code> is equal to the total weight of all entries of
<code>x</code> that are less than or equal to <code>y</code>. That is
<code>Fn(y) = sum(weights[x &lt;= y])</code>.
</p>
<p>Thus <code>Fn</code> is a step function which jumps at the
values of <code>x</code>. The height of the jump at a point <code>y</code>
is the total weight of all entries in <code>x</code> 
number of tied observations at that value.  Missing values are
ignored.
</p>
<p>If <code>weights</code> is omitted, the default is equivalent to
<code>ecdf(x)</code> except for the class membership.
</p>
<p>The result of <code>ewcdf</code> is a function, of class <code>"ewcdf"</code>,
inheriting from the classes <code>"ecdf"</code> (only if <code>normalise=TRUE</code>)
and <code>"stepfun"</code>.
</p>
<p>The class <code>ewcdf</code> has methods for
<code><a href="base.html#topic+print">print</a></code>, 
<code><a href="stats.html#topic+quantile">quantile</a></code>
and <code><a href="base.html#topic+mean">mean</a></code>.
</p>
<p>The inherited classes <code>ecdf</code> and <code>stepfun</code>
have methods for <code><a href="base.html#topic+plot">plot</a></code> and <code><a href="base.html#topic+summary">summary</a></code>.
</p>


<h3>Value</h3>

<p>A function, of class <code>"ewcdf"</code>, inheriting from 
<code>"ecdf"</code> (if <code>normalise=TRUE</code>) and <code>"stepfun"</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ecdf">ecdf</a></code>.
</p>
<p><code><a href="#topic+quantile.ewcdf">quantile.ewcdf</a></code>, <code><a href="#topic+mean.ewcdf">mean.ewcdf</a></code>.
</p>
<p>Integrals with respect to the weighted cumulative distribution function
can be computed using <code><a href="spatstat.explore.html#topic+stieltjes">stieltjes</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- rnorm(100)
   w &lt;- runif(100)
   plot(e &lt;- ewcdf(x,w))
   e
</code></pre>

<hr>
<h2 id='Extract.anylist'>Extract or Replace Subset of a List of Things</h2><span id='topic++5B.anylist'></span><span id='topic++5B+3C-.anylist'></span>

<h3>Description</h3>

<p>Extract or replace a subset of a list of things.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'anylist'
x[i, ...]

  ## S3 replacement method for class 'anylist'
x[i] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.anylist_+3A_x">x</code></td>
<td>

<p>An object of class <code>"anylist"</code> representing a list of things.
</p>
</td></tr>
<tr><td><code id="Extract.anylist_+3A_i">i</code></td>
<td>

<p>Subset index. Any valid subset index in the usual <span class="rlang"><b>R</b></span> sense.
</p>
</td></tr>
<tr><td><code id="Extract.anylist_+3A_value">value</code></td>
<td>

<p>Replacement value for the subset. 
</p>
</td></tr>
<tr><td><code id="Extract.anylist_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are the methods for extracting and replacing subsets 
for the class <code>"anylist"</code>.
</p>
<p>The argument <code>x</code> should be an object of class <code>"anylist"</code>
representing a list of things. See <code><a href="#topic+anylist">anylist</a></code>.
</p>
<p>The method replaces a designated
subset of <code>x</code>, and returns an object of class <code>"anylist"</code>.
</p>


<h3>Value</h3>

<p>Another object of class <code>"anylist"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anylist">anylist</a></code>,
<code><a href="#topic+plot.anylist">plot.anylist</a></code>,
<code><a href="#topic+summary.anylist">summary.anylist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- anylist(A=runif(10), B=runif(10), C=runif(10))
   x[1] &lt;- list(A=rnorm(10))
 </code></pre>

<hr>
<h2 id='Extract.hyperframe'>Extract or Replace Subset of Hyperframe</h2><span id='topic++5B.hyperframe'></span><span id='topic++5B+3C-.hyperframe'></span><span id='topic++24.hyperframe'></span><span id='topic++24+3C-.hyperframe'></span><span id='topic++5B+5B.hyperframe'></span><span id='topic++5B+5B+3C-.hyperframe'></span>

<h3>Description</h3>

<p>Extract or replace a subset of a hyperframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'hyperframe'
x[i, j, drop, strip=drop, ...]
  ## S3 replacement method for class 'hyperframe'
x[i, j] &lt;- value
  ## S3 method for class 'hyperframe'
x$name
  ## S3 replacement method for class 'hyperframe'
x$name &lt;- value
  ## S3 method for class 'hyperframe'
x[[...]]
  ## S3 replacement method for class 'hyperframe'
x[[i, j]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.hyperframe_+3A_x">x</code></td>
<td>

<p>A hyperframe (object of class <code>"hyperframe"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.hyperframe_+3A_i">i</code>, <code id="Extract.hyperframe_+3A_j">j</code></td>
<td>

<p>Row and column indices.
</p>
</td></tr>
<tr><td><code id="Extract.hyperframe_+3A_drop">drop</code>, <code id="Extract.hyperframe_+3A_strip">strip</code></td>
<td>

<p>Logical values indicating what to do when the
hyperframe has only one row or column.
See Details.
</p>
</td></tr>
<tr><td><code id="Extract.hyperframe_+3A_...">...</code></td>
<td>

<p>Indices specifying elements to extract by <code>[[.hyperframe</code>.
Ignored by <code>[.hyperframe</code>.
</p>
</td></tr>
<tr><td><code id="Extract.hyperframe_+3A_name">name</code></td>
<td>

<p>Name of a column of the hyperframe.
</p>
</td></tr>
<tr><td><code id="Extract.hyperframe_+3A_value">value</code></td>
<td>

<p>Replacement value for the subset. A hyperframe
or (if the subset is a single column) a list or an atomic vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract a designated subset of a hyperframe,
or replace the designated subset with another hyperframe.
</p>
<p>The function <code>[.hyperframe</code> is a method for the subset operator
<code><a href="Matrix.html#topic++5B">[</a></code> for the
class <code>"hyperframe"</code>. It extracts the subset of <code>x</code>
specified by the row index <code>i</code> and column index <code>j</code>.
</p>
<p>The argument <code>drop</code> determines whether the array structure
will be discarded if possible. The argument <code>strip</code> determines
whether the list structure in a row or column or cell will be discarded if
possible.
If <code>drop=FALSE</code> (the default), the return value is always
a hyperframe or data frame.
If <code>drop=TRUE</code>, and if the selected subset has only one row,
or only one column, or both, then
</p>

<ul>
<li>
<p>if <code>strip=FALSE</code>, the result is a
list, with one entry for each array cell that was selected.

</p>
</li>
<li>
<p>if <code>strip=TRUE</code>,
</p>

<ul>
<li><p> if the subset has one row containing several columns,
the result is a list or (if possible) an atomic vector;
</p>
</li>
<li><p> if the subset has one column containing several rows,
the result is a list or (if possible) an atomic vector;
</p>
</li>
<li><p> if the subset has exactly one row and exactly one column,
the result is the object (or atomic value)
contained in this row and column.
</p>
</li></ul>


</li></ul>

<p>The function <code>[&lt;-.hyperframe</code> is a method for the
subset replacement operator <code><a href="Matrix.html#topic++5B+3C-">[&lt;-</a></code> for the
class <code>"hyperframe"</code>. It replaces the designated
subset with the hyperframe <code>value</code>.
The subset of <code>x</code> to be replaced is designated by
the arguments <code>i</code> and <code>j</code> as above.
The replacement <code>value</code> should be a hyperframe with the
appropriate dimensions, or (if the specified subset is a single
column) a list of the appropriate length.
</p>
<p>The function <code>$.hyperframe</code> is a method for <code><a href="base.html#topic++24">$</a></code>
for hyperframes. It extracts the relevant column of the hyperframe.
The result is always a list (i.e. equivalent to using
<code>[.hyperframe</code> with <code>strip=FALSE</code>).
</p>
<p>The function <code>$&lt;-.hyperframe</code> is a method for <code><a href="base.html#topic++24+3C-">$&lt;-</a></code>
for hyperframes. It replaces the relevant column of the hyperframe.
The replacement value should be a list of the appropriate length.
</p>
<p>The functions <code>[[.hyperframe</code> and <code>[[&lt;-.hyperframe</code>
are methods for <code><a href="base.html#topic++5B+5B">[[</a></code> and <code>[[&lt;-.hyperframe</code>
for hyperframes. They are analogous to <code><a href="base.html#topic++5B+5B.data.frame">[[.data.frame</a></code>
and <code>[[&lt;-.data.frame</code> in that they can be used in different ways:
</p>

<ul>
<li><p> when <code>[[.hyperframe</code> or <code>[[&lt;-.hyperframe</code>
are used with a single index,
as in <code>x[[n]]</code> or <code>x[[n]] &lt;- value</code>,
they index the hyperframe as if it were a list,
extracting or replacing a column of the hyperframe.
</p>
</li>
<li><p> when <code>[[.hyperframe</code> or <code>[[&lt;-.hyperframe</code>
are used with two indices,
as in <code>x[[i,j]]</code> or <code>x[[i,j]] &lt;- value</code>,
they index the hyperframe as if it were a
matrix, and can only be used to extract or replace one element. 
</p>
</li></ul>



<h3>Value</h3>

<p>A hyperframe (of class <code>"hyperframe"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyperframe">hyperframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  h &lt;- hyperframe(X=list(square(1), square(2)), Y=list(sin, cos))
  h
  h[1, ]
  h[1, ,drop=TRUE]
  h[ , 1]
  h[ , 1, drop=TRUE]
  h[1,1]
  h[1,1,drop=TRUE]
  h[1,1,drop=TRUE,strip=FALSE]
  h[1,1] &lt;- list(square(3))
  # extract column
  h$X
  # replace existing column
  h$Y &lt;- list(cells, cells)
  # add new column
  h$Z &lt;- list(tan, exp)
  #
  h[["Y"]]
  h[[2,1]]
  h[[2,1]] &lt;- square(3)
</code></pre>

<hr>
<h2 id='Extract.im'>Extract Subset of Image</h2><span id='topic++5B.im'></span>

<h3>Description</h3>

<p>Extract a subset or subregion of a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
x[i, j, ..., drop=TRUE, tight=FALSE,
                                 raster=NULL, rescue=is.owin(i)]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.im_+3A_x">x</code></td>
<td>

<p>A two-dimensional pixel image.
An object of class <code>"im"</code>.
</p>
</td></tr>
<tr><td><code id="Extract.im_+3A_i">i</code></td>
<td>

<p>Object defining the subregion or subset to be extracted.
Either a spatial window (an object of class <code>"owin"</code>), or a
pixel image with logical values, or a linear network (object of
class <code>"linnet"</code>) or a point pattern (an object
of class <code>"ppp"</code>), or any type of index that applies to a
matrix, or something that can be converted to a point pattern
by <code><a href="#topic+as.ppp">as.ppp</a></code> (using the window of <code>x</code>).
</p>
</td></tr>
<tr><td><code id="Extract.im_+3A_j">j</code></td>
<td>

<p>An integer or logical vector serving as the column index if
matrix indexing is being used. Ignored if <code>i</code> is a spatial object.
</p>
</td></tr>
<tr><td><code id="Extract.im_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Extract.im_+3A_drop">drop</code></td>
<td>

<p>Logical value, specifying whether to return a vector containing
the selected pixel values (<code>drop=TRUE</code>, the default)
or to return a pixel image containing
these values in their original spatial positions
(<code>drop=FALSE</code>).
The exception is that if <code>i</code> is a point pattern,
then <code>drop</code> specifies whether to delete <code>NA</code> values.
See Details.
</p>
</td></tr>
<tr><td><code id="Extract.im_+3A_tight">tight</code></td>
<td>

<p>Logical value. If <code>tight=TRUE</code>, and if the result of the
subset operation is an image, the image will be trimmed
to the smallest possible rectangle.
</p>
</td></tr>
<tr><td><code id="Extract.im_+3A_raster">raster</code></td>
<td>

<p>Optional. An object of class <code>"owin"</code> or <code>"im"</code>
determining a pixel grid.
</p>
</td></tr>
<tr><td><code id="Extract.im_+3A_rescue">rescue</code></td>
<td>

<p>Logical value indicating whether rectangular blocks of data
should always be returned as pixel images.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts a subset of the pixel values in a
pixel image. (To reassign the pixel values, see <code><a href="#topic++5B+3C-.im">[&lt;-.im</a></code>).
</p>
<p>The image <code>x</code> must be an object of class
<code>"im"</code> representing a pixel image defined inside a
rectangle in two-dimensional space (see <code><a href="#topic+im.object">im.object</a></code>).
</p>
<p>The subset to be extracted is determined by the arguments <code>i,j</code>
according to the following rules (which are checked in this order):
</p>

<ol>
<li>
<p><code>i</code> is a spatial object such as a window,
a pixel image with logical values,
a linear network, or a point pattern;  or
</p>
</li>
<li>
<p><code>i,j</code> are indices for the matrix <code>as.matrix(x)</code>; or
</p>
</li>
<li>
<p><code>i</code> can be converted to a point pattern
by <code><a href="#topic+as.ppp">as.ppp</a>(i, W=Window(x))</code>,
and <code>i</code> is not a matrix.
</p>
</li></ol>

<p>If <code>i</code> is a spatial window (an object of class <code>"owin"</code>),
the pixels inside this window are selected. 
</p>

<ul>
<li>
<p>If <code>drop=TRUE</code> (the default) and either
<code>is.rectangle(i)=FALSE</code> or <code>rescue=FALSE</code>,
the pixel values are extracted;
the result is a vector, with one entry for each pixel of <code>x</code>
that lies inside the window <code>i</code>.
Pixel values may be <code>NA</code>, indicating that the selected pixel
lies outside the spatial domain of the image.
</p>
</li>
<li>
<p>if <code>drop=FALSE</code>,
the result is another pixel image, obtained by setting 
the pixel values to <code>NA</code> outside the window <code>i</code>.
The effect is that the pixel image <code>x</code> is clipped to the
window <code>i</code>.
</p>
</li>
<li> 
<p>if <code>i</code> is a rectangle and <code>rescue=TRUE</code>,
the result is a pixel image as described above.
</p>
</li>
<li>
<p>To ensure that an image is produced in all circumstances,
set <code>drop=FALSE</code>.
To ensure that pixel values are extracted as a vector
in all circumstances, set <code>drop=TRUE, rescue=FALSE</code>.
</p>
</li></ul>

<p>If <code>i</code> is a pixel image with logical values,
it is interpreted as a spatial window (with <code>TRUE</code> values
inside the window and <code>FALSE</code> outside).
</p>
<p>If <code>i</code> is a linear network (object of class <code>"linnet"</code>),
the pixels which lie on this network are selected.
</p>

<ul>
<li> 
<p>If <code>drop=TRUE</code> (the default),
the pixel values are extracted;
the result is a vector, with one entry for each pixel of <code>x</code>
that lies along the network <code>i</code>.
Pixel values may be <code>NA</code>, indicating that the selected pixel
lies outside the spatial domain of the image.
</p>
</li>
<li>
<p>if <code>drop=FALSE</code>,
the result is a pixel image on a linear network (object of
class <code>"linim"</code>), obtained by setting the pixel values of
<code>x</code> to <code>NA</code> except for those which lie on the network <code>i</code>.
The effect is that the pixel image <code>x</code> is restricted to the
network <code>i</code>.
</p>
</li></ul>

<p>If <code>i</code> is a point pattern (an object of class
<code>"ppp"</code>) or something that can be converted to a point pattern,
then the values of the pixel image at the points of
this pattern are extracted.
The result is a vector of pixel values.
This is a simple way to read the
pixel values at a given spatial location. 
</p>

<ul>
<li><p> if <code>drop=FALSE</code> the length of the result 
is equal to the number of points in the pattern. It may contain
<code>NA</code> values which indicate that the corresponding point
lies outside the spatial domain of the image.
</p>
</li>
<li><p> if <code>drop=TRUE</code> (the default), <code>NA</code> values are
deleted. The result is a vector whose length may be shorter than
the number of points of the pattern.
</p>
</li></ul>

<p>If the optional argument <code>raster</code> is given, then it should
be a binary image mask or a pixel image. Then
<code>x</code> will first be converted to an image defined on the
pixel grid implied by <code>raster</code>, before the subset operation
is carried out.
In particular, <code>x[i, raster=i, drop=FALSE]</code> will return
an image defined on the same pixel array as the object <code>i</code>.
</p>
<p>If <code>i</code> does not satisfy any of the conditions above, then
the algorithm attempts to interpret <code>i</code> and <code>j</code>
as indices for the matrix <code>as.matrix(x)</code>.
Either <code>i</code> or <code>j</code> may be missing or blank.
The result is usually a vector or matrix of pixel values.
Exceptionally the result is a pixel image if <code>i,j</code> determines
a rectangular subset of the pixel grid, and if the user specifies
<code>rescue=TRUE</code>.
</p>
<p>Finally, if none of the above conditions is met,
the object <code>i</code> may also be a data frame or list of <code>x,y</code>
coordinates which will be converted to a point pattern, taking the
observation window to be <code>Window(x)</code>. Then the pixel values
at these points will be extracted as a vector.
</p>


<h3>Value</h3>

<p>Either a pixel image or a vector of pixel values. See Details.
</p>


<h3>Warnings</h3>

<p>If you have a 2-column matrix containing the <code class="reqn">x,y</code> coordinates
of point locations, then to prevent this being interpreted as an
array index, you should convert it to a <code>data.frame</code>
or to a point pattern.
</p>
<p>If <code>W</code> is a window or a pixel image, then <code>x[W, drop=FALSE]</code> 
will return an image defined on the same pixel array
as the original image <code>x</code>. If you want to obtain an image
whose pixel dimensions agree with those of <code>W</code>, use the
<code>raster</code> argument, <code>x[W, raster=W, drop=FALSE]</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im.object">im.object</a></code>,
<code><a href="#topic++5B+3C-.im">[&lt;-.im</a></code>,
<code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+as.ppp">as.ppp</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+plot.im">plot.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # make up an image
 X &lt;- setcov(unit.square())
 plot(X)

 # a rectangular subset
 W &lt;- owin(c(0,0.5),c(0.2,0.8))
 Y &lt;- X[W]
 plot(Y)

 # a polygonal subset
 R &lt;- affine(letterR, diag(c(1,1)/2), c(-2,-0.7))
 plot(X[R, drop=FALSE])
 plot(X[R, drop=FALSE, tight=TRUE])

 # a point pattern
 Y &lt;- X[cells]

 # look up a specified location
 X[list(x=0.1,y=0.2)]

 # 10 x 10 pixel array
 X &lt;- as.im(function(x,y) { x + y }, owin(c(-1,1),c(-1,1)), dimyx=10)
 # 100 x 100 
 W &lt;- as.mask(disc(1, c(0,0)), dimyx=100)
 # 10 x 10 raster
 X[W,drop=FALSE]
 # 100 x 100 raster
 X[W, raster=W, drop=FALSE]
</code></pre>

<hr>
<h2 id='Extract.layered'>Extract or Replace Subset of a Layered Object</h2><span id='topic++5B.layered'></span><span id='topic++5B+3C-.layered'></span><span id='topic++5B+5B+3C-.layered'></span>

<h3>Description</h3>

<p>Extract or replace some or all of the layers of a layered object,
or extract a spatial subset of each layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'layered'
x[i, j, drop=FALSE, ...]

  ## S3 replacement method for class 'layered'
x[i] &lt;- value

  ## S3 replacement method for class 'layered'
x[[i]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.layered_+3A_x">x</code></td>
<td>

<p>A layered object (class <code>"layered"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.layered_+3A_i">i</code></td>
<td>

<p>Subset index for the list of layers.
A logical vector, integer vector or character vector
specifying which layers are to be extracted or replaced.
</p>
</td></tr>
<tr><td><code id="Extract.layered_+3A_j">j</code></td>
<td>

<p>Subset index to be applied to the data in each layer.
Typically a spatial window (class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.layered_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>i</code> specifies only a single layer
and <code>drop=TRUE</code>, then the contents of this layer
will be returned.
</p>
</td></tr>
<tr><td><code id="Extract.layered_+3A_...">...</code></td>
<td>

<p>Additional arguments, passed to other subset methods
if the subset index is a window.
</p>
</td></tr>
<tr><td><code id="Extract.layered_+3A_value">value</code></td>
<td>
<p>List of objects which shall replace the designated
subset, or an object which shall replace the designated element.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A layered object represents data that should be plotted in
successive layers, for example, a background and a foreground.
See <code><a href="#topic+layered">layered</a></code>.
</p>
<p>The function <code>[.layered</code>
extracts a designated subset of a layered object.
It is a method for <code><a href="Matrix.html#topic++5B">[</a></code> for the
class <code>"layered"</code>.
</p>
<p>The functions <code>[&lt;-.layered</code> and <code>[[&lt;-.layered</code>
replace a designated subset or designated entry of the object by new
values. They are methods for <code><a href="Matrix.html#topic++5B+3C-">[&lt;-</a></code> and <code><a href="base.html#topic++5B+5B+3C-">[[&lt;-</a></code>
for the <code>"layered"</code> class.
</p>
<p>The index <code>i</code> specifies which layers will be retained.
It should be a valid subset index for the list of layers.
</p>
<p>The index <code>j</code> will be applied to each layer. It is typically
a spatial window (class <code>"owin"</code>) so that each of the layers
will be restricted to the same spatial region.
Alternatively <code>j</code> may be any subset index
which is permissible for the <code>"["</code> method for each of the layers.
</p>


<h3>Value</h3>

<p>Usually an object of class <code>"layered"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layered">layered</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> D &lt;- distmap(cells)
 L &lt;- layered(D, cells,
              plotargs=list(list(ribbon=FALSE), list(pch=16)))

 L[-2]
 L[, square(0.5)]

 L[[3]] &lt;- japanesepines
 L
</code></pre>

<hr>
<h2 id='Extract.listof'>Extract or Replace Subset of a List of Things</h2><span id='topic++5B+3C-.listof'></span>

<h3>Description</h3>

<p>Replace a subset of a list of things.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 replacement method for class 'listof'
x[i] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.listof_+3A_x">x</code></td>
<td>

<p>An object of class <code>"listof"</code> representing a list of things
which all belong to one class.
</p>
</td></tr>
<tr><td><code id="Extract.listof_+3A_i">i</code></td>
<td>

<p>Subset index. Any valid subset index in the usual <span class="rlang"><b>R</b></span> sense.
</p>
</td></tr>
<tr><td><code id="Extract.listof_+3A_value">value</code></td>
<td>

<p>Replacement value for the subset. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a subset replacement method for the class <code>"listof"</code>.
</p>
<p>The argument <code>x</code> should be an object of class <code>"listof"</code>
representing a list of things that all belong to one class.
</p>
<p>The method replaces a designated
subset of <code>x</code>, and returns an object of class <code>"listof"</code>.
</p>


<h3>Value</h3>

<p>Another object of class <code>"listof"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.listof">plot.listof</a></code>,
<code><a href="#topic+summary.listof">summary.listof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- list(A=runif(10), B=runif(10), C=runif(10))
   class(x) &lt;- c("listof", class(x))
   x[1] &lt;- list(A=rnorm(10))
 </code></pre>

<hr>
<h2 id='Extract.owin'>Extract Subset of Window</h2><span id='topic++5B.owin'></span>

<h3>Description</h3>

<p>Extract a subset of a window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'owin'
x[i, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.owin_+3A_x">x</code></td>
<td>

<p>A spatial window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.owin_+3A_i">i</code></td>
<td>

<p>Object defining the subregion.
Either a spatial window, or a
pixel image with logical values.
</p>
</td></tr>
<tr><td><code id="Extract.owin_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the intersection
between the window <code>x</code> and the domain specified by <code>i</code>,
using <code><a href="#topic+intersect.owin">intersect.owin</a></code>.
</p>
<p>This function is a method for the subset operator <code>"["</code> for
spatial windows (objects of class <code>"owin"</code>). It is provided
mainly for completeness.
</p>
<p>The index <code>i</code> may be either a window, or a pixel image with
logical values (the <code>TRUE</code> values of the
image specify the spatial domain).
</p>


<h3>Value</h3>

<p>Another spatial window (object of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect.owin">intersect.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> W &lt;- owin(c(2.5, 3.2), c(1.4, 2.9))
 plot(letterR)
 plot(letterR[W], add=TRUE, col="red")
</code></pre>

<hr>
<h2 id='Extract.ppp'>Extract or Replace Subset of Point Pattern</h2><span id='topic++5B.ppp'></span><span id='topic++5B+3C-.ppp'></span>

<h3>Description</h3>

<p>Extract or replace a subset of a point pattern.
Extraction of a subset has the effect of thinning the 
points and/or trimming the window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
x[i, j, drop=FALSE, ..., clip=FALSE]
  ## S3 replacement method for class 'ppp'
x[i, j] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.ppp_+3A_x">x</code></td>
<td>

<p>A two-dimensional point pattern.
An object of class <code>"ppp"</code>.
</p>
</td></tr>
<tr><td><code id="Extract.ppp_+3A_i">i</code></td>
<td>

<p>Subset index. Either a valid subset index in the usual <span class="rlang"><b>R</b></span> sense,
indicating which points should be retained, or a window
(an object of class <code>"owin"</code>) 
delineating a subset of the original observation window,
or a pixel image with logical values defining a subset of the
original observation window.
</p>
</td></tr>
<tr><td><code id="Extract.ppp_+3A_value">value</code></td>
<td>

<p>Replacement value for the subset. A point pattern.
</p>
</td></tr>
<tr><td><code id="Extract.ppp_+3A_j">j</code></td>
<td>

<p>Redundant. Included for backward compatibility.
</p>
</td></tr>
<tr><td><code id="Extract.ppp_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating whether to remove unused levels
of the marks, if the marks are a factor.
</p>
</td></tr>
<tr><td><code id="Extract.ppp_+3A_clip">clip</code></td>
<td>

<p>Logical value indicating how to form the window of the resulting
point pattern, when <code>i</code> is a window. 
If <code>clip=FALSE</code> (the default), the result has window
equal to <code>i</code>. If <code>clip=TRUE</code>, the resulting window
is the intersection between the window of <code>x</code> and the
window <code>i</code>.
</p>
</td></tr>
<tr><td><code id="Extract.ppp_+3A_...">...</code></td>
<td>

<p>Ignored. This argument is required for compatibility
with the generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract a designated subset of a point pattern,
or replace the designated subset with another point pattern.
</p>
<p>The function <code>[.ppp</code> is a method for <code><a href="Matrix.html#topic++5B">[</a></code> for the
class <code>"ppp"</code>. It extracts a designated subset of a point pattern,
either by &ldquo;<em>thinning</em>&rdquo;
(retaining/deleting some points of a point pattern)
or &ldquo;<em>trimming</em>&rdquo; (reducing the window of observation
to a smaller subregion and retaining only
those points which lie in the subregion) or both.
</p>
<p>The pattern will be &ldquo;thinned&rdquo;
if <code>i</code> is a subset index in the usual <span class="rlang"><b>R</b></span> sense:
either a numeric vector
of positive indices (identifying the points to be retained),
a numeric vector of negative indices (identifying the points
to be deleted) or a logical vector of length equal to the number of
points in the point pattern <code>x</code>. In the latter case, 
the points <code>(x$x[i], x$y[i])</code> for which 
<code>subset[i]=TRUE</code> will be retained, and the others
will be deleted.
</p>
<p>The pattern will be &ldquo;trimmed&rdquo;
if <code>i</code> is an object of class 
<code>"owin"</code> specifying a window of observation.
The points of <code>x</code> lying inside the new
window <code>i</code> will be retained. Alternatively <code>i</code> may be a
pixel image (object of class <code>"im"</code>) with logical values;
the pixels with the value <code>TRUE</code> will be interpreted as a window.
</p>
<p>The argument <code>drop</code> determines whether to remove
unused levels of a factor, if the point pattern is multitype
(i.e. the marks are a factor) or if the marks are a data frame
in which some of the columns are factors.
</p>
<p>The function <code>[&lt;-.ppp</code> is a method for <code><a href="Matrix.html#topic++5B+3C-">[&lt;-</a></code> for the
class <code>"ppp"</code>. It replaces the designated
subset with the point pattern <code>value</code>.
The subset of <code>x</code> to be replaced is designated by
the argument <code>i</code> as above.
</p>
<p>The replacement point pattern <code>value</code> must lie inside the
window of the original pattern <code>x</code>.
The ordering of points in <code>x</code> will be preserved
if the replacement pattern <code>value</code> has the same number of points
as the subset to be replaced.  Otherwise the ordering is
unpredictable.
</p>
<p>If the original pattern <code>x</code> has marks, then the replacement
pattern <code>value</code> must also have marks, of the same type.
</p>
<p>Use the function <code><a href="#topic+unmark">unmark</a></code> to remove marks from a
marked point pattern.
</p>
<p>Use the function <code><a href="#topic+split.ppp">split.ppp</a></code> to select those points
in a marked point pattern which have a specified mark.
</p>


<h3>Value</h3>

<p>A point pattern (of class <code>"ppp"</code>).
</p>


<h3>Warnings</h3>

<p>The function does not check whether <code>i</code> is a subset of
<code>Window(x)</code>. Nor does it check whether <code>value</code> lies
inside <code>Window(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset.ppp">subset.ppp</a></code>.
</p>
<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+unmark">unmark</a></code>,
<code><a href="#topic+split.ppp">split.ppp</a></code>,
<code><a href="#topic+cut.ppp">cut.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Longleaf pines data
 lon &lt;- longleaf
 if(human &lt;- interactive()) {
 plot(lon)
 }
 

 # adult trees defined to have diameter at least 30 cm
 longadult &lt;- subset(lon, marks &gt;= 30)
 if(human){
 plot(longadult)
 }
 # note that the marks are still retained.
 # Use unmark(longadult) to remove the marks
 
 # New Zealand trees data
 if(human){
 plot(nztrees)          # plot shows a line of trees at the far right
 abline(v=148, lty=2)   # cut along this line
 }
 nzw &lt;- owin(c(0,148),c(0,95)) # the subwindow
 # trim dataset to this subwindow
 nzsub &lt;- nztrees[nzw]
 if(human){
 plot(nzsub)
 }

 # Redwood data
 if(human){
 plot(redwood)
 }
 # Random thinning: delete 60% of data
 retain &lt;- (runif(npoints(redwood)) &lt; 0.4)
 thinred &lt;- redwood[retain]
 if(human){
 plot(thinred)
 }

 # Scramble 60% of data
if(require(spatstat.random)) {
 X &lt;- redwood
 modif &lt;- (runif(npoints(X)) &lt; 0.6)
 X[modif] &lt;- runifpoint(ex=X[modif])
}

 # Lansing woods data - multitype points
 lan &lt;- lansing
 

 # Hickory trees
  hicks &lt;- split(lansing)$hickory

 # Trees in subwindow
  win &lt;- owin(c(0.3, 0.6),c(0.2, 0.5))
  lsub &lt;- lan[win]

if(require(spatstat.random)) {
 # Scramble the locations of trees in subwindow, retaining their marks
  lan[win] &lt;- runifpoint(ex=lsub) %mark% marks(lsub)
}

 # Extract oaks only
 oaknames &lt;- c("redoak", "whiteoak", "blackoak")
 oak &lt;- lan[marks(lan) %in% oaknames, drop=TRUE]
 oak &lt;- subset(lan, marks %in% oaknames, drop=TRUE)

 # To clip or not to clip
 X &lt;- unmark(demopat)
 B &lt;- owin(c(5500, 9000), c(2500, 7400))
 opa &lt;- par(mfrow=c(1,2))
 plot(X, main="X[B]")
 plot(X[B], add=TRUE,
      cols="blue", col="pink", border="blue",
      show.all=TRUE, main="")
 plot(Window(X), add=TRUE)
 plot(X, main="X[B, clip=TRUE]")
 plot(B, add=TRUE, lty=2)
 plot(X[B, clip=TRUE], add=TRUE,
      cols="blue", col="pink", border="blue", 
      show.all=TRUE, main="")
 par(opa)
</code></pre>

<hr>
<h2 id='Extract.ppx'>Extract Subset of Multidimensional Point Pattern</h2><span id='topic++5B.ppx'></span>

<h3>Description</h3>

<p>Extract a subset of a multidimensional point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppx'
x[i, drop=FALSE, clip=FALSE, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.ppx_+3A_x">x</code></td>
<td>

<p>A multidimensional point pattern (object of class <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.ppx_+3A_i">i</code></td>
<td>

<p>Subset index. A valid subset index in the usual <span class="rlang"><b>R</b></span> sense,
indicating which points should be retained;
or a spatial domain of class <code>"boxx"</code> or <code>"box3"</code>.
</p>
</td></tr>
<tr><td><code id="Extract.ppx_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating whether to remove unused levels
of the marks, if the marks are a factor.
</p>
</td></tr>
<tr><td><code id="Extract.ppx_+3A_clip">clip</code></td>
<td>

<p>Logical value indicating how to form the domain of the resulting
point pattern, when <code>i</code> is a box (object of class <code>"boxx"</code>). 
If <code>clip=FALSE</code> (the default), the result has domain
equal to <code>i</code>. If <code>clip=TRUE</code>, the resulting domain
is the intersection between the domain of <code>x</code> and the
domain <code>i</code>.
</p>
</td></tr>
<tr><td><code id="Extract.ppx_+3A_...">...</code></td>
<td>

<p>Ignored. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts a designated subset of a multidimensional
point pattern.
</p>
<p>The function <code>[.ppx</code> is a method for <code><a href="Matrix.html#topic++5B">[</a></code> for the
class <code>"ppx"</code>. It extracts a designated subset of a point pattern.
The argument <code>i</code> may be either
</p>

<ul>
<li><p> a subset index in the usual <span class="rlang"><b>R</b></span> sense:
either a numeric vector
of positive indices (identifying the points to be retained),
a numeric vector of negative indices (identifying the points
to be deleted) or a logical vector of length equal to the number of
points in the point pattern <code>x</code>. In the latter case, 
the points <code>(x$x[i], x$y[i])</code> for which 
<code>subset[i]=TRUE</code> will be retained, and the others
will be deleted.
</p>
</li>
<li>
<p>a spatial domain of class <code>"boxx"</code> or <code>"box3"</code>.
Points falling inside this region will be retained.
</p>
</li></ul>

<p>The argument <code>drop</code> determines whether to remove
unused levels of a factor, if the point pattern is multitype
(i.e. the marks are a factor) or if the marks are a data frame or hyperframe
in which some of the columns are factors.
</p>
<p>Use the function <code><a href="#topic+unmark">unmark</a></code> to remove marks from a
marked point pattern.
</p>


<h3>Value</h3>

<p>A multidimensional point pattern (of class <code>"ppx"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppx">ppx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   df &lt;- data.frame(x=runif(4),y=runif(4),z=runif(4))
   X &lt;- ppx(data=df, coord.type=c("s","s","t"))
   X[-2]
   Y &lt;- ppx(coords(cells), domain = boxx(c(0,1),c(0,1)))
   dom &lt;- shift(domain(Y), vec = c(.5,.5))
   Y[dom]
   Y[dom, clip=TRUE]
</code></pre>

<hr>
<h2 id='Extract.psp'>Extract Subset of Line Segment Pattern</h2><span id='topic++5B.psp'></span>

<h3>Description</h3>

<p>Extract a subset of a line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'psp'
x[i, j, drop, ..., fragments=TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.psp_+3A_x">x</code></td>
<td>

<p>A two-dimensional line segment pattern.
An object of class <code>"psp"</code>.
</p>
</td></tr>
<tr><td><code id="Extract.psp_+3A_i">i</code></td>
<td>

<p>Subset index. Either a valid subset index in the usual <span class="rlang"><b>R</b></span> sense,
indicating which segments should be retained, or a window
(an object of class <code>"owin"</code>)
delineating a subset of the original observation window. 
</p>
</td></tr>
<tr><td><code id="Extract.psp_+3A_j">j</code></td>
<td>

<p>Redundant - included for backward compatibility.
</p>
</td></tr>
<tr><td><code id="Extract.psp_+3A_drop">drop</code></td>
<td>

<p>Ignored. Required for compatibility with generic function.
</p>
</td></tr>
<tr><td><code id="Extract.psp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="Extract.psp_+3A_fragments">fragments</code></td>
<td>

<p>Logical value indicating whether to retain all pieces of line segments
that intersect the new window (<code>fragments=TRUE</code>, the default)
or to retain only those line segments
that lie entirely inside the new window (<code>fragments=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract a designated subset of a line segment pattern.
</p>
<p>The function <code>[.psp</code> is a method for <code><a href="Matrix.html#topic++5B">[</a></code> for the
class <code>"psp"</code>. It extracts a designated subset of a line segment pattern,
either by &ldquo;<em>thinning</em>&rdquo;
(retaining/deleting some line segments of a line segment pattern)
or &ldquo;<em>trimming</em>&rdquo; (reducing the window of observation
to a smaller subregion and clipping the line segments to
this boundary) or both.
</p>
<p>The pattern will be &ldquo;thinned&rdquo;
if  <code>subset</code> is specified. The line segments designated by <code>subset</code>
will be retained. Here <code>subset</code> can be a numeric vector
of positive indices (identifying the line segments to be retained),
a numeric vector of negative indices (identifying the line segments
to be deleted) or a logical vector of length equal to the number
of line segments in the line segment pattern <code>x</code>. In the latter case,
the line segments for which 
<code>subset[i]=TRUE</code> will be retained, and the others
will be deleted.
</p>
<p>The pattern will be &ldquo;trimmed&rdquo;
if <code>window</code> is specified. This should
be an object of class <code><a href="#topic+owin">owin</a></code> specifying a window of observation
to which the line segment pattern <code>x</code> will be
trimmed. Line segments of <code>x</code> lying inside the new
<code>window</code> will be retained unchanged. Line segments lying
partially inside the new <code>window</code> and partially outside it
will, by default, be clipped so that they lie entirely inside the window;
but if <code>fragments=FALSE</code>, such segments will be removed.
</p>
<p>Both &ldquo;thinning&rdquo; and &ldquo;trimming&rdquo; can be performed together.
</p>


<h3>Value</h3>

<p>A line segment pattern (of class <code>"psp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp.object">psp.object</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    a &lt;- psp(runif(20),runif(20),runif(20),runif(20), window=owin())
    plot(a)
  # thinning
    id &lt;- sample(c(TRUE, FALSE), 20, replace=TRUE)
    b &lt;- a[id]
    plot(b, add=TRUE, lwd=3)
 # trimming
    plot(a)
    w &lt;- owin(c(0.1,0.7), c(0.2, 0.8))
    b &lt;- a[w]
    plot(b, add=TRUE, col="red", lwd=2)
    plot(w, add=TRUE)
    u &lt;- a[w, fragments=FALSE]
    plot(u, add=TRUE, col="blue", lwd=3)
</code></pre>

<hr>
<h2 id='Extract.quad'>Subset of Quadrature Scheme</h2><span id='topic++5B.quad'></span>

<h3>Description</h3>

<p>Extract a subset of a quadrature scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'quad'
x[...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.quad_+3A_x">x</code></td>
<td>

<p>A quadrature scheme (object of class <code>"quad"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.quad_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic++5B.ppp">[.ppp</a></code> to determine the
subset.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts a designated subset of a quadrature scheme.
</p>
<p>The function <code>[.quad</code> is a method for <code><a href="Matrix.html#topic++5B">[</a></code> for the
class <code>"quad"</code>. It extracts a designated subset of a quadrature
scheme.
</p>
<p>The subset to be extracted is determined by the arguments <code>...</code> which
are interpreted by <code><a href="#topic++5B.ppp">[.ppp</a></code>. Thus it is possible to take the
subset consisting of all quadrature points that lie inside a
given region, or a subset of quadrature points identified by
numeric indices.
</p>


<h3>Value</h3>

<p>A quadrature scheme (object of class <code>"quad"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="#topic++5B.ppp">[.ppp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Q &lt;- quadscheme(nztrees)
 W &lt;- owin(c(0,148),c(0,95)) # a subwindow
 Q[W]
</code></pre>

<hr>
<h2 id='Extract.solist'>Extract or Replace Subset of a List of Spatial Objects</h2><span id='topic++5B.solist'></span><span id='topic++5B+3C-.solist'></span>

<h3>Description</h3>

<p>Extract or replace some entries in a list of spatial objects,
or extract a designated sub-region in each object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'solist'
x[i, ...]

  ## S3 replacement method for class 'solist'
x[i] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.solist_+3A_x">x</code></td>
<td>

<p>An object of class <code>"solist"</code> representing a list of
two-dimensional spatial objects.
</p>
</td></tr>
<tr><td><code id="Extract.solist_+3A_i">i</code></td>
<td>

<p>Subset index. Any valid subset index for vectors in the usual <span class="rlang"><b>R</b></span> sense,
or a window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.solist_+3A_value">value</code></td>
<td>

<p>Replacement value for the subset. 
</p>
</td></tr>
<tr><td><code id="Extract.solist_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for extracting and replacing subsets
for the class <code>"solist"</code>.
</p>
<p>The argument <code>x</code> should be an object of class <code>"solist"</code>
representing a list of two-dimensional spatial objects.
See <code><a href="#topic+solist">solist</a></code>.
</p>
<p>For the subset method, the subset index <code>i</code> can be either
a vector index (specifying some elements of the list)
or a spatial window (specifying a spatial sub-region). 
</p>
<p>For the replacement method,
<code>i</code> must be a vector index: the designated elements will be
replaced.
</p>


<h3>Value</h3>

<p>Another object of the same class as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+solist">solist</a></code>,
<code><a href="#topic+plot.solist">plot.solist</a></code>,
<code><a href="#topic+summary.solist">summary.solist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- solist(japanesepines, cells, redwood)
   x[2:3]
   x[square(0.5)]
   x[1] &lt;- list(finpines)
 </code></pre>

<hr>
<h2 id='Extract.splitppp'>Extract or Replace Sub-Patterns</h2><span id='topic++5B.splitppp'></span><span id='topic++5B+3C-.splitppp'></span>

<h3>Description</h3>

<p>Extract or replace some of the sub-patterns in a split point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'splitppp'
x[...]
  ## S3 replacement method for class 'splitppp'
x[...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.splitppp_+3A_x">x</code></td>
<td>

<p>An object of class <code>"splitppp"</code>, representing a point pattern
separated into a list of sub-patterns.
</p>
</td></tr>
<tr><td><code id="Extract.splitppp_+3A_...">...</code></td>
<td>

<p>Subset index. Any valid subset index in the usual <span class="rlang"><b>R</b></span> sense.
</p>
</td></tr>
<tr><td><code id="Extract.splitppp_+3A_value">value</code></td>
<td>

<p>Replacement value for the subset. A list of point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are subset methods for the class <code>"splitppp"</code>.
</p>
<p>The argument <code>x</code> should be an object of class <code>"splitppp"</code>,
representing a point pattern that has been separated into a
list of sub-patterns. It is created by <code><a href="#topic+split.ppp">split.ppp</a></code>.
</p>
<p>The methods extract or replace a designated
subset of the list <code>x</code>, and return an object of class <code>"splitppp"</code>.
</p>


<h3>Value</h3>

<p>Another object of class <code>"splitppp"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+split.ppp">split.ppp</a></code>,
<code><a href="#topic+plot.splitppp">plot.splitppp</a></code>,
<code><a href="#topic+summary.splitppp">summary.splitppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  y &lt;- split(amacrine)
  y[[1]]
  y[["off"]]
  y[[1]] &lt;- rsyst(Window(amacrine), 4, 3)
 </code></pre>

<hr>
<h2 id='Extract.tess'>Extract or Replace Subset of Tessellation</h2><span id='topic++5B.tess'></span><span id='topic++5B+3C-.tess'></span>

<h3>Description</h3>

<p>Extract, change or delete a subset of the tiles of a tessellation,
to make a new tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'tess'
x[i, ...]
  ## S3 replacement method for class 'tess'
x[i, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.tess_+3A_x">x</code></td>
<td>
<p>A tessellation (object of class <code>"tess"</code>).</p>
</td></tr>
<tr><td><code id="Extract.tess_+3A_i">i</code></td>
<td>

<p>Subset index for the tiles of the tessellation.
Alternatively a window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.tess_+3A_...">...</code></td>
<td>

<p>One argument that specifies the subset to be extracted or changed.
Any valid format for the subset index in a list.
</p>
</td></tr>
<tr><td><code id="Extract.tess_+3A_value">value</code></td>
<td>

<p>Replacement value for the selected tiles of the tessellation.
A list of windows (objects of class <code>"owin"</code>) or <code>NULL</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation (object of class <code>"tess"</code>, see <code><a href="#topic+tess">tess</a></code>)
is effectively a list of tiles (spatial regions) that cover a spatial region.
The subset operator <code>[.tess</code> extracts some
of these tiles and forms a new tessellation, which of course covers a
smaller region than the original. 
</p>
<p>For <code>[.tess</code> only, the subset index can also be a window
(object of class <code>"owin"</code>). The tessellation <code>x</code>
is then intersected with the window.
</p>
<p>The replacement operator changes the selected tiles. The replacement
<code>value</code> may be either <code>NULL</code> (which causes the selected tiles
to be removed from <code>x</code>) or a list of the same length as
the selected subset. The entries of <code>value</code> may be windows
(objects of class <code>"owin"</code>) or <code>NULL</code> to indicate that the
corresponding tile should be deleted.
</p>
<p>Generally it does not make sense to replace a tile in a tessellation
with a completely different tile, because the tiles are expected to
fit together. However this facility is sometimes useful for making
small adjustments to polygonal tiles.
</p>


<h3>Value</h3>

<p>A tessellation (object of class <code>"tess"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>, <code><a href="#topic+tiles">tiles</a></code>, <code><a href="#topic+intersect.tess">intersect.tess</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
   A &lt;- tess(xgrid=0:4, ygrid=0:3)
   B &lt;- A[c(1, 3, 7)]
   E &lt;- A[-1]
   A[c(2, 5, 11)] &lt;- NULL
   
</code></pre>

<hr>
<h2 id='extrapolate.psp'>
Extrapolate Line Segments to Obtain Infinite Lines
</h2><span id='topic+extrapolate.psp'></span>

<h3>Description</h3>

<p>Given a spatial pattern of line segments,
extrapolate the segments to infinite lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrapolate.psp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrapolate.psp_+3A_x">x</code></td>
<td>

<p>Spatial pattern of line segments (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="extrapolate.psp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each line segment in the pattern <code>x</code> is
extrapolated to an infinite line, drawn through its two endpoints.
The resulting pattern of infinite lines
is returned as an object of class <code>"infline"</code>.
</p>
<p>If a segment's endpoints are identical
(so that it has zero length)
the resulting infinite line is vertical (i.e. parallel to the <code class="reqn">y</code>
coordinate axis).
</p>


<h3>Value</h3>

<p>An object of class <code>"infline"</code> representing the pattern of
infinite lines. See <code><a href="#topic+infline">infline</a></code> for details of
structure.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp">psp</a></code>,
<code><a href="#topic+infline">infline</a></code>
</p>
<p><code><a href="#topic+midpoints.psp">midpoints.psp</a></code>,
<code><a href="#topic+lengths_psp">lengths_psp</a></code>
<code><a href="#topic+angles.psp">angles.psp</a></code>,
<code><a href="#topic+endpoints.psp">endpoints.psp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- psp(runif(4), runif(4), runif(4), runif(4), window=owin())
   Y &lt;- extrapolate.psp(X)
   plot(X, col=3, lwd=4)
   plot(Y, lty=3)
   Y
</code></pre>

<hr>
<h2 id='fardist'>
Farthest Distance to Boundary of Window
</h2><span id='topic+fardist'></span><span id='topic+fardist.ppp'></span><span id='topic+fardist.owin'></span>

<h3>Description</h3>

<p>Computes the farthest distance from each pixel, or each data point,
to the boundary of the window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fardist(X, ...)

  ## S3 method for class 'owin'
fardist(X, ..., squared=FALSE)

  ## S3 method for class 'ppp'
fardist(X, ..., squared=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fardist_+3A_x">X</code></td>
<td>

<p>A spatial object such as a window or point pattern.
</p>
</td></tr>
<tr><td><code id="fardist_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine
the pixel resolution, if required.
</p>
</td></tr>
<tr><td><code id="fardist_+3A_squared">squared</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the squared distances will be
returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fardist</code> is generic, with methods for
the classes <code>owin</code> and <code>ppp</code>.
</p>
<p>For a window <code>W</code>, the command <code>fardist(W)</code>
returns a pixel image in which the value at each pixel
is the <em>largest</em> distance from that pixel to the boundary of
<code>W</code>.
</p>
<p>For a point pattern <code>X</code>, with window <code>W</code>, the
command <code>fardist(X)</code> returns a numeric vector
with one entry for each point of <code>X</code>, giving the
largest distance from that data point to the boundary of <code>W</code>.
</p>


<h3>Value</h3>

<p>For <code>fardist.owin</code>, a pixel image (object of class <code>"im"</code>).
</p>
<p>For <code>fardist.ppp</code>, a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fardist(cells)

  plot(FR &lt;- fardist(letterR))
</code></pre>

<hr>
<h2 id='flipxy'>Exchange X and Y Coordinates</h2><span id='topic+flipxy'></span><span id='topic+flipxy.owin'></span><span id='topic+flipxy.ppp'></span><span id='topic+flipxy.psp'></span><span id='topic+flipxy.im'></span>

<h3>Description</h3>

<p>Exchanges the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates in a spatial dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> flipxy(X)
 ## S3 method for class 'owin'
flipxy(X)
 ## S3 method for class 'ppp'
flipxy(X)
 ## S3 method for class 'psp'
flipxy(X)
 ## S3 method for class 'im'
flipxy(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flipxy_+3A_x">X</code></td>
<td>
<p>Spatial dataset. An object of class
<code>"owin"</code>, <code>"ppp"</code>, <code>"psp"</code> or <code>"im"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function swaps the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates of a spatial
dataset. This could also be performed using the command <code><a href="#topic+affine">affine</a></code>,
but <code>flipxy</code> is faster.
</p>
<p>The function <code><a href="#topic+flipxy">flipxy</a></code> is generic, with methods
for the classes of objects listed above.
</p>


<h3>Value</h3>

<p>Another object of the same type, representing the
result of swapping the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+reflect">reflect</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- flipxy(cells)
</code></pre>

<hr>
<h2 id='fourierbasis'>Fourier Basis Functions</h2><span id='topic+fourierbasis'></span><span id='topic+fourierbasisraw'></span>

<h3>Description</h3>

<p>Evaluates the Fourier basis functions
on a <code class="reqn">d</code>-dimensional box
with <code class="reqn">d</code>-dimensional frequencies <code class="reqn">k_i</code> at the
<code class="reqn">d</code>-dimensional coordinates <code class="reqn">x_j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fourierbasis(x, k, win = boxx(rep(list(0:1), ncol(k))))
  fourierbasisraw(x, k, boxlengths)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourierbasis_+3A_x">x</code></td>
<td>

<p>Coordinates. 
A <code>data.frame</code> or matrix with
<code class="reqn">n</code> rows and <code class="reqn">d</code> columns giving
the <code class="reqn">d</code>-dimensional coordinates.
</p>
</td></tr>
<tr><td><code id="fourierbasis_+3A_k">k</code></td>
<td>
<p>Frequencies.
A <code>data.frame</code> or matrix with <code class="reqn">m</code> rows and <code class="reqn">d</code> columns
giving the frequencies of the Fourier-functions.
</p>
</td></tr>
<tr><td><code id="fourierbasis_+3A_win">win</code></td>
<td>

<p>window (of class <code>"owin"</code>, <code>"box3"</code> or <code>"boxx"</code>)
giving the <code class="reqn">d</code>-dimensional box domain of the Fourier functions.
</p>
</td></tr>
<tr><td><code id="fourierbasis_+3A_boxlengths">boxlengths</code></td>
<td>

<p>numeric giving the side lengths of the box domain of the Fourier functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result is an <code class="reqn">m</code> by <code class="reqn">n</code> matrix where the <code class="reqn">(i,j)</code>'th
entry is the <code class="reqn">d</code>-dimensional Fourier basis function with
frequency <code class="reqn">k_i</code> evaluated at the point <code class="reqn">x_j</code>, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">
    \frac{1}{\sqrt{|W|}}
    \exp(2\pi i \sum{l=1}^d k_{i,l} x_{j,l}/L_l)
  </code>
</p>

<p>where <code class="reqn">L_l</code>, <code class="reqn">l=1,...,d</code> are the box side lengths
and <code class="reqn">|W|</code> is the volume of the 
domain (window/box). Note that the algorithm does not check whether
the coordinates given in <code>x</code> are contained in the given box.
Actually the box is only used to determine the side lengths and volume of the
domain for normalization.
</p>
<p>The stripped down faster version <code>fourierbasisraw</code> doesn't do checking or
conversion of arguments and requires <code>x</code> and <code>k</code> to be matrices.
</p>


<h3>Value</h3>

<p>An <code>m</code> by <code>n</code> matrix of complex values.</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 27 rows of three dimensional Fourier frequencies:
k &lt;- expand.grid(-1:1,-1:1, -1:1)
## Two random points in the three dimensional unit box:
x &lt;- rbind(runif(3),runif(3))
## 27 by 2 resulting matrix:
v &lt;- fourierbasis(x, k)
head(v)
</code></pre>

<hr>
<h2 id='Frame'>
Extract or Change the Containing Rectangle of a Spatial Object
</h2><span id='topic+Frame'></span><span id='topic+Frame+3C-'></span><span id='topic+Frame.default'></span><span id='topic+Frame+3C-.default'></span><span id='topic+Frame+3C-.owin'></span><span id='topic+Frame+3C-.ppp'></span><span id='topic+Frame+3C-.im'></span>

<h3>Description</h3>

<p>Given a spatial object (such as a point pattern or pixel image)
in two dimensions, these functions extract or change the
containing rectangle inside which the object is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   Frame(X)

   ## Default S3 method:
Frame(X)

   Frame(X) &lt;- value

   ## S3 replacement method for class 'owin'
Frame(X) &lt;- value

   ## S3 replacement method for class 'ppp'
Frame(X) &lt;- value

   ## S3 replacement method for class 'im'
Frame(X) &lt;- value

   ## Default S3 replacement method:
Frame(X) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Frame_+3A_x">X</code></td>
<td>

<p>A spatial object such as a point pattern, line segment pattern
or pixel image.
</p>
</td></tr>
<tr><td><code id="Frame_+3A_value">value</code></td>
<td>

<p>A rectangular window (object of class <code>"owin"</code>
of type <code>"rectangle"</code>) to be used as the new containing
rectangle for <code>X</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>Frame</code> and <code>Frame&lt;-</code> are generic.
</p>
<p><code>Frame(X)</code> extracts the rectangle inside which <code>X</code> is
defined. 
</p>
<p><code>Frame(X) &lt;- R</code> changes the rectangle inside which <code>X</code> is defined
to the new rectangle <code>R</code>.
</p>


<h3>Value</h3>

<p>The result of <code>Frame</code> is a rectangular window (object of class
<code>"owin"</code> of type <code>"rectangle"</code>).
</p>
<p>The result of <code>Frame&lt;-</code> is the updated object <code>X</code>,
of the same class as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Window">Window</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Frame(cells)
   X &lt;- demopat
   Frame(X)
   Frame(X) &lt;- owin(c(0, 11000), c(400, 8000))
</code></pre>

<hr>
<h2 id='framedist.pixels'>Distance to Bounding Frame</h2><span id='topic+framedist.pixels'></span><span id='topic+framedist.pixels'></span>

<h3>Description</h3>

<p>Computes the distances from each pixel to the bounding rectangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> framedist.pixels(w, ..., style=c("image", "matrix", "coords"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="framedist.pixels_+3A_w">w</code></td>
<td>
<p>A window (object of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="framedist.pixels_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine
the pixel resolution.</p>
</td></tr>
<tr><td><code id="framedist.pixels_+3A_style">style</code></td>
<td>

<p>Character string (partially matched) determining the format of
the output: either <code>"matrix"</code>, <code>"coords"</code> or
<code>"image"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes, for each pixel <code class="reqn">u</code>
in the rectangular frame <code>Frame(w)</code>, the shortest distance
to the boundary of <code class="reqn">Frame(w)</code>.
</p>
<p>The grid of pixels is determined by the arguments <code>"\dots"</code> 
passed to <code><a href="#topic+as.mask">as.mask</a></code>. The distance from each pixel to the
boundary is calculated exactly, using analytic geometry.
</p>


<h3>Value</h3>

<p>If <code>style="image"</code>, a pixel image (object of class <code>"im"</code>)
containing the distances from each pixel in the image raster
to the boundary of the window.
</p>
<p>If <code>style="matrix"</code>,
a matrix giving the distances from each pixel in the image raster
to the boundary of the window. Rows of this matrix correspond to
the <code class="reqn">y</code> coordinate and columns to the <code class="reqn">x</code> coordinate.
</p>
<p>If <code>style="coords"</code>, a list with three components
<code>x,y,z</code>, where <code>x,y</code> are vectors of length <code class="reqn">m,n</code>
giving the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates respectively,
and <code>z</code> is an <code class="reqn">m \times n</code> matrix such that
<code>z[i,j]</code> is the distance from <code>(x[i],y[j])</code> to the
boundary of the window. Rows of this matrix correspond to the
<code class="reqn">x</code> coordinate and columns to the <code class="reqn">y</code> coordinate.
This result can be plotted with <code>persp</code>, <code>image</code>
or <code>contour</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bdist.pixels">bdist.pixels</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  opa &lt;- par(mfrow=c(1,2))
  plot(framedist.pixels(letterR))
  plot(bdist.pixels(letterR))
  par(opa)
</code></pre>

<hr>
<h2 id='funxy'>
Spatial Function Class
</h2><span id='topic+funxy'></span>

<h3>Description</h3>

<p>A simple class of functions of spatial location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  funxy(f, W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funxy_+3A_f">f</code></td>
<td>

<p>A <code>function</code> in the <span class="rlang"><b>R</b></span> language
with arguments <code>x,y</code> (at least)
</p>
</td></tr>
<tr><td><code id="funxy_+3A_w">W</code></td>
<td>

<p>Window (object of class <code>"owin"</code>) inside which the
function is well-defined.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command creates an object of class <code>"funxy"</code>.
This is a simple mechanism for handling a function
of spatial location <code class="reqn">f(x,y)</code> to make it easier to display
and manipulate.
</p>
<p><code>f</code> should be a <code>function</code> in the <span class="rlang"><b>R</b></span> language.
The first two arguments of <code>f</code> must be named <code>x</code> and <code>y</code>
respectively.
</p>
<p><code>W</code> should be a window (object of class <code>"owin"</code>) inside which the
function <code>f</code> is well-defined.
</p>
<p>The function <code>f</code> should be vectorised: that is,
if <code>x</code> and <code>y</code> are numeric vectors of the same length
<code>n</code>, then <code>v &lt;- f(x,y)</code> should be a vector of length
<code>n</code>.
</p>
<p>The resulting function <code>g &lt;- funxy(f, W)</code> has the same formal
arguments as <code>f</code> and can be called in the same way,
<code>v &lt;- g(x,y)</code> where <code>x</code> and <code>y</code> are numeric vectors.
However it can also be called as <code>v &lt;- g(X)</code>, where <code>X</code> is a point pattern
(object of class <code>"ppp"</code> or <code>"lpp"</code>)
or a quadrature scheme (class <code>"quad"</code>);
the function will be evaluated at the points of <code>X</code>.
</p>
<p>The result also has a <code><a href="#topic+unitname">unitname</a></code>, inherited from <code>W</code>.
</p>


<h3>Value</h3>

<p>A <code>function</code> with the same arguments as <code>f</code>,
which also belongs to the class <code>"funxy"</code>.
This class has methods for
<code>print</code>, <code>plot</code>, <code>contour</code> and <code>persp</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.funxy">plot.funxy</a></code>,
<code><a href="#topic+summary.funxy">summary.funxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   f &lt;- function(x,y) { x^2 + y^2 - 1} 
   g &lt;- funxy(f, square(2))
   g
   ## evaluate function at any x, y coordinates
   g(0.2, 0.3)
   ## evaluate function at the points of a point pattern
   g(cells[1:4])
</code></pre>

<hr>
<h2 id='gridcentres'>Rectangular grid of points</h2><span id='topic+gridcentres'></span><span id='topic+gridcenters'></span>

<h3>Description</h3>

<p>Generates a rectangular grid of points in a window
</p>


<h3>Usage</h3>

<pre><code class='language-R'> gridcentres(window, nx, ny)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridcentres_+3A_window">window</code></td>
<td>
<p>A window. 
An object of class <code><a href="#topic+owin">owin</a></code>,
or data in any format acceptable to <code><a href="#topic+as.owin">as.owin</a>()</code>.
</p>
</td></tr>
<tr><td><code id="gridcentres_+3A_nx">nx</code></td>
<td>
<p>Number of points
in each row of the rectangular grid.
</p>
</td></tr>
<tr><td><code id="gridcentres_+3A_ny">ny</code></td>
<td>
<p>Number of points
in each column of the rectangular grid.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a rectangular grid of points in the window.
</p>
<p>The bounding rectangle of the <code>window</code> is divided into
a regular <code class="reqn">nx \times ny</code> grid of rectangular tiles.
The function returns the <code class="reqn">x,y</code> coordinates of the
centres of these tiles.
</p>
<p>Note that some of these grid points may lie outside the window,
if <code>window</code> is not of type <code>"rectangle"</code>. The function
<code><a href="#topic+inside.owin">inside.owin</a></code> can be used to select those grid points
which do lie inside the window. See the examples.
</p>
<p>This function is useful in creating dummy points for quadrature
schemes (see <code><a href="#topic+quadscheme">quadscheme</a></code>) and for other miscellaneous
purposes.
</p>


<h3>Value</h3>

<p>A list with two components <code>x</code> and <code>y</code>, which are numeric
vectors giving the coordinates of the points of the
rectangular grid.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="#topic+quadscheme">quadscheme</a></code>,
<code><a href="#topic+inside.owin">inside.owin</a></code>,
<code><a href="#topic+stratrand">stratrand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- unit.square()
  xy &lt;- gridcentres(w, 10,15)
  if(human &lt;- interactive()) {
  plot(w)
  points(xy)
  }

  bdry &lt;- list(x=c(0.1,0.3,0.7,0.4,0.2),
               y=c(0.1,0.1,0.5,0.7,0.3))
  w &lt;- owin(c(0,1), c(0,1), poly=bdry)
  xy &lt;- gridcentres(w, 30, 30)
  ok &lt;- inside.owin(xy$x, xy$y, w)
  if(human) {
  plot(w)
  points(xy$x[ok], xy$y[ok])
  }
</code></pre>

<hr>
<h2 id='gridweights'>Compute Quadrature Weights Based on Grid Counts</h2><span id='topic+gridweights'></span>

<h3>Description</h3>

<p>Computes quadrature weights for a given set of points,
using the &ldquo;counting weights&rdquo; for a grid of rectangular tiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> gridweights(X, ntile, ..., window=NULL, verbose=FALSE, npix=NULL, areas=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridweights_+3A_x">X</code></td>
<td>
<p>Data defining a point pattern.</p>
</td></tr>
<tr><td><code id="gridweights_+3A_ntile">ntile</code></td>
<td>
<p>Number of tiles
in each row and column of the rectangular grid.
An integer vector of length 1 or 2.
</p>
</td></tr>
<tr><td><code id="gridweights_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="gridweights_+3A_window">window</code></td>
<td>
<p>Default window for the point pattern</p>
</td></tr>
<tr><td><code id="gridweights_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, information will be printed
about the computation of the grid weights.
</p>
</td></tr>
<tr><td><code id="gridweights_+3A_npix">npix</code></td>
<td>
<p>Dimensions of pixel grid to use when
computing a digital approximation to the tile areas.
</p>
</td></tr>
<tr><td><code id="gridweights_+3A_areas">areas</code></td>
<td>
<p>Vector of areas of the tiles, if they are already known.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a set of quadrature weights
for a given pattern of points
(typically comprising both &ldquo;data&rdquo; and 'dummy&rdquo; points).
See <code><a href="#topic+quad.object">quad.object</a></code> for an explanation of quadrature
weights and quadrature schemes.
</p>
<p>The weights are computed by the &ldquo;counting weights&rdquo; rule
based on a regular grid of rectangular tiles.
First <code>X</code> and (optionally) <code>window</code> are converted into a
point pattern object. Then the bounding rectangle of the window of
the point pattern is
divided into a regular <code>ntile[1] * ntile[2]</code> grid of rectangular tiles.
The weight attached to a point of <code>X</code> is the area of the tile
in which it lies, divided by the number of points of <code>X</code> lying in
that tile.
</p>
<p>For non-rectangular windows the tile areas are currently calculated
by approximating the window as a binary mask. The accuracy of this
approximation is controlled by <code>npix</code>, which becomes
the argument <code>dimyx</code> of <code><a href="#topic+as.mask">as.mask</a></code>. 
</p>


<h3>Value</h3>

<p>Vector of nonnegative weights for each point in <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="#topic+dirichletWeights">dirichletWeights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Q &lt;- quadscheme(runifrect(15))
  X &lt;- as.ppp(Q) # data and dummy points together
  w &lt;- gridweights(X, 10)
  w &lt;- gridweights(X, c(10, 10))
</code></pre>

<hr>
<h2 id='grow.boxx'>Add margins to box in any dimension</h2><span id='topic+grow.boxx'></span><span id='topic+grow.box3'></span>

<h3>Description</h3>

<p>Adds a margin to a box of class boxx.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> grow.boxx(W, left, right = left)
 grow.box3(W, left, right = left)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow.boxx_+3A_w">W</code></td>
<td>

<p>A box (object of class <code>"boxx"</code> or <code>"box3"</code>).
</p>
</td></tr>
<tr><td><code id="grow.boxx_+3A_left">left</code></td>
<td>
<p>Width of margin to be added to left endpoint
of box side in every dimension.
A single nonnegative number, or a vector of same length
as the dimension of the box to add different left margin in each dimension.
</p>
</td></tr>
<tr><td><code id="grow.boxx_+3A_right">right</code></td>
<td>
<p>Width of margin to be added to right endpoint
of box side in every dimension.
A single nonnegative number, or a vector of same length
as the dimension of the box to add different right margin in each dimension.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another object of the same class <code>"boxx"</code> or <code>"box3"</code>
representing the window after margins are added.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grow.rectangle">grow.rectangle</a></code>,
<code><a href="#topic+boxx">boxx</a></code>,
<code><a href="#topic+box3">box3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- boxx(c(0,10), c(0,10), c(0,10), c(0,10))
  # add a margin of size 1 on both sides in all four dimensions
  b12 &lt;- grow.boxx(w, 1)

  # add margin of size 2 at left, and margin of size 3 at right,
  # in each dimension.
  v &lt;- grow.boxx(w, 2, 3)
</code></pre>

<hr>
<h2 id='grow.rectangle'>Add margins to rectangle</h2><span id='topic+grow.rectangle'></span>

<h3>Description</h3>

<p>Adds a margin to a rectangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> grow.rectangle(W, xmargin=0, ymargin=xmargin, fraction=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow.rectangle_+3A_w">W</code></td>
<td>

<p>A window (object of class <code>"owin"</code>).
Must be of type <code>"rectangle"</code>.
</p>
</td></tr>
<tr><td><code id="grow.rectangle_+3A_xmargin">xmargin</code></td>
<td>
<p>Width of horizontal margin to be added.
A single nonnegative number, or a vector of length 2
indicating margins of unequal width at left and right.
</p>
</td></tr>
<tr><td><code id="grow.rectangle_+3A_ymargin">ymargin</code></td>
<td>
<p>Height of vertical margin to be added.
A single nonnegative number, or a vector of length 2
indicating margins of unequal width at bottom and top.
</p>
</td></tr>
<tr><td><code id="grow.rectangle_+3A_fraction">fraction</code></td>
<td>

<p>Fraction of width and height to be added.
A number greater than zero, or a numeric vector of length 2 indicating
different fractions of width and of height, respectively.
Incompatible with specifying <code>xmargin</code> and <code>ymargin</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple convenience function to add a
margin of specified width and height on each side of a
rectangular window. Unequal margins can also be added.
</p>


<h3>Value</h3>

<p>Another object of class <code>"owin"</code> representing the
window after margins are added.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trim.rectangle">trim.rectangle</a></code>,
<code><a href="#topic+dilation">dilation</a></code>,
<code><a href="#topic+erosion">erosion</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- square(10)
  # add a margin of width 1 on all four sides
  square12 &lt;- grow.rectangle(w, 1)

  # add margin of width 3 on the right side
  # and margin of height 4 on top.
  v &lt;- grow.rectangle(w, c(0,3), c(0,4))

  # grow by 5 percent on all sides
  grow.rectangle(w, fraction=0.05)
</code></pre>

<hr>
<h2 id='harmonise'>Make Objects Compatible</h2><span id='topic+harmonise'></span><span id='topic+harmonize'></span>

<h3>Description</h3>

<p>Converts several objects of the same class to a common format
so that they can be combined or compared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonise(...)
harmonize(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonise_+3A_...">...</code></td>
<td>

<p>Any number of objects of the same class.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This generic command takes any number of objects of the same
class, and <em>attempts</em> to make them compatible in the sense
of <code><a href="#topic+compatible">compatible</a></code> so that they can be combined or compared.
</p>
<p>There are methods for the classes <code>"fv"</code>
(<code><a href="spatstat.explore.html#topic+harmonise.fv">harmonise.fv</a></code>)
and <code>"im"</code> (<code><a href="#topic+harmonise.im">harmonise.im</a></code>).
</p>
<p>All arguments <code>...</code> must be objects of the same class.
The result will be a list, of length equal to the number of
arguments <code>...</code>, containing new versions of each of these
objects, converted to a common format.
If the arguments were named (<code>name=value</code>) then the return value
also carries these names.
</p>


<h3>Value</h3>

<p>A list, of length equal to the number of arguments <code>...</code>,
whose entries are objects of the same class.
If the arguments were named (<code>name=value</code>) then the return value
also carries these names.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compatible">compatible</a></code>,
<code><a href="spatstat.explore.html#topic+harmonise.fv">harmonise.fv</a></code>,
<code><a href="#topic+harmonise.im">harmonise.im</a></code>
</p>

<hr>
<h2 id='harmonise.im'>Make Pixel Images Compatible</h2><span id='topic+harmonise.im'></span><span id='topic+harmonize.im'></span>

<h3>Description</h3>

<p>Convert several pixel images to a common pixel raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im'
harmonise(...)

## S3 method for class 'im'
harmonize(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonise.im_+3A_...">...</code></td>
<td>

<p>Any number of pixel images (objects of class <code>"im"</code>)
or data which can be converted to pixel images by <code><a href="#topic+as.im">as.im</a></code>.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function makes any number of pixel images compatible,
by converting them all to a common pixel grid.
</p>
<p>The command <code><a href="#topic+harmonise">harmonise</a></code> is generic. This is the
method for objects of class <code>"im"</code>.
</p>
<p>At least one of the arguments <code>...</code> must be a pixel image.
Some arguments may be windows (objects of class <code>"owin"</code>),
functions (<code>function(x,y)</code>) or numerical constants. These will be
converted to images using <code><a href="#topic+as.im">as.im</a></code>.
</p>
<p>The common pixel grid is determined by inspecting all the pixel
images in the argument list, computing the bounding box of all the
images, then finding the image with the highest spatial resolution, 
and extending its pixel grid to cover the bounding box. 
</p>
<p>The return value is a list with entries corresponding to the input
arguments.
If the arguments were named (<code>name=value</code>) then the return value
also carries these names.
</p>
<p>If you just want to determine the appropriate pixel resolution,
without converting the images, use <code><a href="#topic+commonGrid">commonGrid</a></code>.
</p>


<h3>Value</h3>

<p>A list,
of length equal to the number of arguments <code>...</code>,
whose entries are pixel images.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+commonGrid">commonGrid</a></code>,
<code><a href="#topic+compatible.im">compatible.im</a></code>,
<code><a href="#topic+as.im">as.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Image1 &lt;- setcov(square(1), dimyx=32)
   Image2 &lt;- setcov(square(1), dimyx=16)
   Function1 &lt;- function(x,y) { x }
   Window1 &lt;- shift(letterR, c(-2, -1))
   h &lt;- harmonise(X=Image1, Y=Image2, Z=Function1, W=Window1)
   plot(h, main="")
</code></pre>

<hr>
<h2 id='harmonise.owin'>Make Windows Compatible</h2><span id='topic+harmonise.owin'></span><span id='topic+harmonize.owin'></span>

<h3>Description</h3>

<p>Convert several windows to a common pixel raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'owin'
harmonise(...)

## S3 method for class 'owin'
harmonize(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonise.owin_+3A_...">...</code></td>
<td>

<p>Any number of windows (objects of class <code>"owin"</code>)
or data which can be converted to windows by <code><a href="#topic+as.owin">as.owin</a></code>.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function makes any number of windows compatible,
by converting them all to a common pixel grid.
</p>
<p>This only has an effect if one of the windows is a binary mask.
If all the windows are rectangular or polygonal, they are
returned unchanged.
</p>
<p>The command <code><a href="#topic+harmonise">harmonise</a></code> is generic. This is the
method for objects of class <code>"owin"</code>.
</p>
<p>Each argument must be a window (object of class <code>"owin"</code>),
or data that can be converted to a window by <code><a href="#topic+as.owin">as.owin</a></code>.
</p>
<p>The common pixel grid is determined by inspecting all the windows
in the argument list, computing the bounding box of all the
windows, then finding the binary mask with the finest spatial resolution, 
and extending its pixel grid to cover the bounding box. 
</p>
<p>The return value is a list with entries corresponding to the input
arguments.
If the arguments were named (<code>name=value</code>) then the return value
also carries these names.
</p>
<p>If you just want to determine the appropriate pixel resolution,
without converting the windows, use <code><a href="#topic+commonGrid">commonGrid</a></code>.
</p>


<h3>Value</h3>

<p>A list of windows, of length equal to the number of arguments
<code>...</code>. The list belongs to the class <code>"solist"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+commonGrid">commonGrid</a></code>,
<code><a href="#topic+harmonise.im">harmonise.im</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   harmonise(X=letterR,
             Y=grow.rectangle(Frame(letterR), 0.2),
             Z=as.mask(letterR, eps=0.1),
             V=as.mask(letterR, eps=0.07))
</code></pre>

<hr>
<h2 id='harmoniseLevels'>
Harmonise the levels of several factors, or factor-valued pixel images.
</h2><span id='topic+harmoniseLevels'></span>

<h3>Description</h3>

<p>Given several factors (or factor-valued pixel images)
convert them so that they all use the same set of levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmoniseLevels(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmoniseLevels_+3A_...">...</code></td>
<td>

<p>Factors, or factor-valued pixel images.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All of the arguments <code>...</code> must be factors, or factor-valued
pixel images (objects of class <code>"im"</code>).
</p>
<p>The <code><a href="base.html#topic+levels">levels</a></code> of each factor will be extracted, and
combined by taking the union of all the levels. Then each factor will
be converted to a new factor so that all of the new factors have
exactly the same set of levels.
</p>


<h3>Value</h3>

<p>A list, containing the same number of arguments as the input,
consisting of factors or factor-valued pixel images.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+levels">levels</a></code>, <code><a href="#topic+levels.im">levels.im</a></code>,
<code><a href="#topic+mergeLevels">mergeLevels</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  (a &lt;- factor(sample(letters[1:3], 10, replace=TRUE)))
  (b &lt;- factor(sample(LETTERS[1:4], 7, replace=TRUE)))
  harmoniseLevels(a,b)

  (A &lt;- gorillas.extra$vegetation)
  (B &lt;- gorillas.extra$slopetype)
  harmoniseLevels(A,B)
</code></pre>

<hr>
<h2 id='has.close'>
Check Whether Points Have Close Neighbours
</h2><span id='topic+has.close'></span><span id='topic+has.close.default'></span><span id='topic+has.close.ppp'></span><span id='topic+has.close.pp3'></span>

<h3>Description</h3>

<p>For each point in a point pattern, determine whether the
point has a close neighbour in the same pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  has.close(X, r, Y=NULL, ...)

  ## Default S3 method:
has.close(X,r, Y=NULL, ..., periodic=FALSE)

  ## S3 method for class 'ppp'
has.close(X,r, Y=NULL, ..., periodic=FALSE, sorted=FALSE)

  ## S3 method for class 'pp3'
has.close(X,r, Y=NULL, ..., periodic=FALSE, sorted=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has.close_+3A_x">X</code>, <code id="has.close_+3A_y">Y</code></td>
<td>

<p>Point patterns of class <code>"ppp"</code> or <code>"pp3"</code> or <code>"lpp"</code>.
</p>
</td></tr>
<tr><td><code id="has.close_+3A_r">r</code></td>
<td>

<p>Threshold distance: a number greater than zero.
</p>
</td></tr>
<tr><td><code id="has.close_+3A_periodic">periodic</code></td>
<td>

<p>Logical value indicating whether to measure distances in the
periodic sense, so that opposite sides of the (rectangular) window
are treated as identical.
</p>
</td></tr>
<tr><td><code id="has.close_+3A_sorted">sorted</code></td>
<td>

<p>Logical value, indicating whether the points of <code>X</code>
(and <code>Y</code>, if given) are already sorted into increasing order of the
<code class="reqn">x</code> coordinates.
</p>
</td></tr>
<tr><td><code id="has.close_+3A_...">...</code></td>
<td>
<p>Other arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is simply a faster version of <code>(nndist(X) &lt;= r)</code>
or <code>(nncross(X,Y,what="dist") &lt;= r)</code>.
</p>
<p><code>has.close(X,r)</code> determines, for each point in the pattern <code>X</code>,
whether or not this point has a neighbour in the same pattern <code>X</code>
which lies at a distance less than or equal to <code>r</code>.
</p>
<p><code>has.close(X,r,Y)</code> determines, for each point in the pattern <code>X</code>,
whether or not this point has a neighbour in the <em>other</em> pattern
<code>Y</code> which lies at a distance less than or equal to <code>r</code>.
</p>
<p>The function <code>has.close</code> is generic, with methods for
<code>"ppp"</code> and <code>"pp3"</code> and a default method.
</p>


<h3>Value</h3>

<p>A logical vector, with one entry for each point of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndist">nndist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  has.close(redwood, 0.05)
  with(split(amacrine), has.close(on, 0.05, off))
  with(osteo, sum(has.close(pts, 20)))
</code></pre>

<hr>
<h2 id='headtail'>
First or Last Part of a Spatial Pattern
</h2><span id='topic+head.ppp'></span><span id='topic+head.ppx'></span><span id='topic+head.psp'></span><span id='topic+head.tess'></span><span id='topic+tail.ppp'></span><span id='topic+tail.ppx'></span><span id='topic+tail.psp'></span><span id='topic+tail.tess'></span>

<h3>Description</h3>

<p>Returns the first few elements (<code>head</code>) or the last few
elements (<code>tail</code>) of a spatial pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
head(x, n = 6L, ...)

  ## S3 method for class 'ppx'
head(x, n = 6L, ...)

  ## S3 method for class 'psp'
head(x, n = 6L, ...)

  ## S3 method for class 'tess'
head(x, n = 6L, ...)

  ## S3 method for class 'ppp'
tail(x, n = 6L, ...)

  ## S3 method for class 'ppx'
tail(x, n = 6L, ...)

  ## S3 method for class 'psp'
tail(x, n = 6L, ...)

  ## S3 method for class 'tess'
tail(x, n = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="headtail_+3A_x">x</code></td>
<td>

<p>A spatial pattern of geometrical figures,
such as a spatial pattern of points
(an object of class <code>"ppp"</code>, <code>"pp3"</code>, <code>"ppx"</code> or
<code>"lpp"</code>) or a spatial pattern of line segments
(an object of class <code>"psp"</code>) or a tessellation
(object of class <code>"tess"</code>).
</p>
</td></tr>
<tr><td><code id="headtail_+3A_n">n</code></td>
<td>

<p>Integer. The number of elements of the pattern that should be extracted.
</p>
</td></tr>
<tr><td><code id="headtail_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions <code><a href="utils.html#topic+head">head</a></code>
and <code><a href="utils.html#topic+tail">tail</a></code>. They extract the first or last
<code>n</code> elements from <code>x</code> and return them as an object of the
same kind as <code>x</code>.
</p>
<p>To inspect the spatial coordinates themselves, use
<code><a href="utils.html#topic+View">View</a>(x)</code>
or <code>head(as.data.frame(x))</code>.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+View">View</a></code>, <code><a href="utils.html#topic+edit">edit</a></code>.
</p>
<p>Conversion to data frame:
<code><a href="#topic+as.data.frame.ppp">as.data.frame.ppp</a></code>,
<code><a href="#topic+as.data.frame.ppx">as.data.frame.ppx</a></code>,
<code><a href="#topic+as.data.frame.psp">as.data.frame.psp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  head(cells)
  tail(edges(letterR), 5)
  head(dirichlet(cells), 4)
</code></pre>

<hr>
<h2 id='hextess'>
Hexagonal Grid or Tessellation
</h2><span id='topic+hexgrid'></span><span id='topic+hextess'></span>

<h3>Description</h3>

<p>Construct a hexagonal grid of points,
or a hexagonal tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexgrid(W, s, offset = c(0, 0), origin=NULL, trim = TRUE)

hextess(W, s, offset = c(0, 0), origin=NULL, trim = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hextess_+3A_w">W</code></td>
<td>

<p>Window in which to construct the hexagonal grid or tessellation.
An object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="hextess_+3A_s">s</code></td>
<td>

<p>Side length of hexagons. A positive number.
</p>
</td></tr>
<tr><td><code id="hextess_+3A_offset">offset</code></td>
<td>

<p>Numeric vector of length 2 specifying a shift of the
hexagonal grid. See Details.
</p>
</td></tr>
<tr><td><code id="hextess_+3A_origin">origin</code></td>
<td>

<p>Numeric vector of length 2 specifying the initial origin
of the hexagonal grid, before the offset is applied.
See Details.
</p>
</td></tr>
<tr><td><code id="hextess_+3A_trim">trim</code></td>
<td>

<p>Logical value indicating whether to restrict the result to
the window <code>W</code>. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hexgrid</code> constructs a hexagonal grid of points
on the window <code>W</code>. If <code>trim=TRUE</code> (the default),
the grid is intersected with <code>W</code> so that all points lie
inside <code>W</code>. If <code>trim=FALSE</code>, then we retain all grid points
which are the centres of hexagons that intersect <code>W</code>.
</p>
<p><code>hextess</code> constructs a tessellation of hexagons
on the window <code>W</code>. If <code>trim=TRUE</code> (the default),
the tessellation is restricted to the interior of <code>W</code>,
so that there will be some fragmentary hexagons near the
boundary of <code>W</code>. If <code>trim=FALSE</code>, the tessellation
consists of all hexagons which intersect <code>W</code>.
</p>
<p>The points of <code>hexgrid(...)</code> are the
centres of the tiles of <code>hextess(...)</code> 
in the same order.
</p>
<p>In the initial position of the grid or tessellation,
one of the grid points (tile centres) is placed at the 
<code>origin</code>, which defaults to the midpoint of the
bounding rectangle of <code>W</code>. The grid can be shifted
relative to this origin by specifing the <code>offset</code>.
</p>


<h3>Value</h3>

<p>The value of <code>hexgrid</code> is a point pattern (object of class
<code>"ppp"</code>).
</p>
<p>The value of <code>hextess</code> is a tessellation (object of class <code>"tess"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>
</p>
<p><code><a href="#topic+hexagon">hexagon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) {
    W &lt;- Window(chorley)
    s &lt;- 0.7
  } else {
    W &lt;- letterR
    s &lt;- 0.3
  }
  plot(hextess(W, s))
  plot(hexgrid(W, s), add=TRUE)
</code></pre>

<hr>
<h2 id='hist.funxy'>Histogram of Values of a Spatial Function</h2><span id='topic+hist.funxy'></span>

<h3>Description</h3>

<p>Computes and displays a histogram of the values of a spatial function
of class <code>"funxy"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'funxy'
hist(x, ..., xname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.funxy_+3A_x">x</code></td>
<td>
<p>A pixel image (object of class <code>"funxy"</code>).</p>
</td></tr>
<tr><td><code id="hist.funxy_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.im">as.im</a></code>
or <code><a href="#topic+hist.im">hist.im</a></code>.
</p>
</td></tr>
<tr><td><code id="hist.funxy_+3A_xname">xname</code></td>
<td>

<p>Optional. Character string to be used as the
name of the dataset <code>x</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes and (by default) displays a histogram
of the values of the function <code>x</code>.
</p>
<p>An object of class <code>"funxy"</code> 
describes a function of spatial location. It is a <code>function(x,y,..)</code>
in the <span class="rlang"><b>R</b></span> language, with additional attributes.
</p>
<p>The function <code>hist.funxy</code> is a method for the generic
function <code><a href="graphics.html#topic+hist">hist</a></code> for the class <code>"funxy"</code>.
</p>
<p>The function is first converted to a pixel image using <code><a href="#topic+as.im">as.im</a></code>,
then <code><a href="#topic+hist.im">hist.im</a></code> is called to produce the histogram.
</p>
<p>Any arguments in <code>...</code> are passed to <code><a href="#topic+as.im">as.im</a></code>
to determine the pixel resolution, 
or to <code><a href="#topic+hist.im">hist.im</a></code> to determine the histogram breaks
and to control or suppress plotting.
Useful arguments include <code>W</code> for the spatial domain,
<code>eps,dimyx</code> for pixel resolution, <code>main</code> for the main title.
</p>


<h3>Value</h3>

<p>An object of class <code>"histogram"</code> as returned
by <code><a href="graphics.html#topic+hist">hist.default</a></code>. This object can be
plotted.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+spatialcdf">spatialcdf</a></code> for the cumulative distribution function
of an image or function.
</p>
<p><code><a href="graphics.html#topic+hist">hist</a></code>,
<code><a href="graphics.html#topic+hist.default">hist.default</a></code>.
</p>
<p>For other statistical graphics such as Q-Q plots,
use <code>as.im(X)[]</code> to extract the pixel values of image <code>X</code>,
and apply the usual statistical graphics commands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f &lt;- funxy(function(x,y) {x^2}, unit.square())
  hist(f)
</code></pre>

<hr>
<h2 id='hist.im'>Histogram of Pixel Values in an Image</h2><span id='topic+hist.im'></span>

<h3>Description</h3>

<p>Computes and displays a histogram of the pixel values in a pixel image.
The <code>hist</code> method for class <code>"im"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
hist(x, ..., probability=FALSE, xname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.im_+3A_x">x</code></td>
<td>
<p>A pixel image (object of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="hist.im_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="graphics.html#topic+hist.default">hist.default</a></code>
or <code><a href="graphics.html#topic+barplot">barplot</a></code>.</p>
</td></tr>
<tr><td><code id="hist.im_+3A_probability">probability</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the histogram will be
normalised to give probabilities or probability densities.
</p>
</td></tr>
<tr><td><code id="hist.im_+3A_xname">xname</code></td>
<td>
<p>Optional. Character string to be used as the
name of the dataset <code>x</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes and (by default) displays a histogram
of the pixel values in the image <code>x</code>.
</p>
<p>An object of class <code>"im"</code>
describes a pixel image. See <code><a href="#topic+im.object">im.object</a></code>)
for details of this class.
</p>
<p>The function <code>hist.im</code> is a method for the generic
function <code><a href="graphics.html#topic+hist">hist</a></code> for the class <code>"im"</code>. 
</p>
<p>Any arguments in <code>...</code> are passed to <code><a href="graphics.html#topic+hist.default">hist.default</a></code>
(for numeric valued images) or <code><a href="graphics.html#topic+barplot">barplot</a></code> (for factor or
logical images).
For example, such arguments control the axes, and may be used to
suppress the plotting.
</p>


<h3>Value</h3>

<p>For numeric-valued images, an object of class <code>"histogram"</code> as returned
by <code><a href="graphics.html#topic+hist">hist.default</a></code>. This object can be
plotted.
</p>
<p>For factor-valued or logical images, an object of class
<code>"barplotdata"</code>, which can be plotted.
This is a list with components
called <code>counts</code> (contingency table of counts of the numbers of
pixels taking each possible value), <code>probs</code> (corresponding relative
frequencies) and <code>mids</code> (graphical <code class="reqn">x</code>-coordinates of the
midpoints of the bars in the barplot). 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+spatialcdf">spatialcdf</a></code> for the cumulative distribution function
of an image.
</p>
<p><code><a href="graphics.html#topic+hist">hist</a></code>,
<code><a href="graphics.html#topic+hist.default">hist.default</a></code>,
<code><a href="graphics.html#topic+barplot">barplot</a></code>.
</p>
<p>For other statistical graphics such as Q-Q plots,
use <code>X[]</code> to extract the pixel values of image <code>X</code>,
and apply the usual statistical graphics commands.
</p>
<p>For information about pixel images see
<code><a href="#topic+im.object">im.object</a></code>,
<code><a href="#topic+summary.im">summary.im</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- as.im(function(x,y) {x^2}, unit.square())
  hist(X)
  hist(cut(X,3))
</code></pre>

<hr>
<h2 id='hotrod'>
Heat Kernel for a One-Dimensional Rod
</h2><span id='topic+hotrod'></span>

<h3>Description</h3>

<p>Calculate values of the heat kernel on a one-dimensional rod.
The ends of the rod may be assumed to be insulated,
or absorbing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotrod(len, xsource, xquery, sigma, ends=c("insulated", "absorbing"), nmax=20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotrod_+3A_len">len</code></td>
<td>

<p>Length of the rod. A single number or numeric vector.
</p>
</td></tr>
<tr><td><code id="hotrod_+3A_xsource">xsource</code></td>
<td>

<p>Positions of the source points, from the left end of the rod
(in the same distance units as <code>len</code>).
A single number or numeric vector.
</p>
</td></tr>
<tr><td><code id="hotrod_+3A_xquery">xquery</code></td>
<td>

<p>Positions of the query points, from the left end of the rod
(in the same distance units as <code>len</code>).
A single number or numeric vector.
</p>
</td></tr>
<tr><td><code id="hotrod_+3A_sigma">sigma</code></td>
<td>

<p>Bandwidth for kernel. A single number or a numeric vector.
</p>
</td></tr>
<tr><td><code id="hotrod_+3A_ends">ends</code></td>
<td>

<p>Character string (partially matched) specifying whether the
ends of the rod are assumed to be insulated or absorbing.
</p>
</td></tr>
<tr><td><code id="hotrod_+3A_nmax">nmax</code></td>
<td>

<p>Number of terms in the infinite sum to use.
A single integer or an integer vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the heat kernel as an infinite sum.
</p>


<h3>Value</h3>

<p>Number or numeric vector.
</p>


<h3>Author(s)</h3>

<p>Greg McSwiggan and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  curve(hotrod(1, 0.1, x, 0.7))

  # check it's a probability density
  f &lt;- function(x) hotrod(1, 0.1, x, 0.7)
  integrate(f, 0, 1)

  ## absorbing ends
  curve(hotrod(1, 0.1, x, 0.7, ends="a"))
</code></pre>

<hr>
<h2 id='hyperframe'>Hyper Data Frame</h2><span id='topic+hyperframe'></span>

<h3>Description</h3>

<p>Create a hyperframe: a two-dimensional array in which each column
consists of values of the same atomic type (like the columns
of a data frame) or objects of the same class. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   hyperframe(...,
             row.names=NULL, check.rows=FALSE, check.names=TRUE,
             stringsAsFactors=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperframe_+3A_...">...</code></td>
<td>

<p>Arguments of the form <code>value</code> or <code>tag=value</code>.
Each <code>value</code> is either an atomic vector, or a list of objects of the
same class, or a single atomic value, or a single object.
Each <code>value</code> will become a column of the array.
The <code>tag</code> determines the name of the column. See Details.
</p>
</td></tr>
<tr><td><code id="hyperframe_+3A_row.names">row.names</code>, <code id="hyperframe_+3A_check.rows">check.rows</code>, <code id="hyperframe_+3A_check.names">check.names</code>, <code id="hyperframe_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>

<p>Arguments passed to <code><a href="base.html#topic+data.frame">data.frame</a></code> controlling the
names of the rows, whether to check that rows are consistent,
whether to check validity of the column names, and whether to
convert character columns to factors.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A hyperframe is like a data frame, except that its entries
can be objects of any kind.
</p>
<p>A hyperframe is a two-dimensional array in which each column consists of
values of one atomic type (as in a data frame) or consists of
objects of one class.
</p>
<p>The arguments <code>...</code> are any number of arguments of
the form <code>value</code> or <code>tag=value</code>. Each <code>value</code> will
become a column of the array. The <code>tag</code> determines the name
of the column.
</p>
<p>Each <code>value</code> can be either
</p>

<ul>
<li><p> an atomic vector or factor
(i.e. numeric vector, integer vector, character vector, logical
vector, complex vector or factor)
</p>
</li>
<li><p> a list of objects which are all of the same class
</p>
</li>
<li><p> one atomic value, which will be replicated to make an atomic
vector or factor
</p>
</li>
<li><p> one object, which will be replicated to make a list of objects.
</p>
</li></ul>

<p>All columns (vectors, factors and lists) must be of the same length,
if their length is greater than 1. 
</p>


<h3>Value</h3>

<p>An object of class <code>"hyperframe"</code>.
</p>


<h3>Methods for Hyperframes</h3>

<p>There are methods for
<code>print</code>, <code>plot</code>, <code>summary</code>, <code>with</code>, <code>split</code>,
<code>[</code>, <code>[&lt;-</code>,
<code>[[</code>, <code>[[&lt;-</code>,
<code>$</code>, <code>$&lt;-</code>,
<code>names</code>, <code>as.data.frame</code> <code>as.list</code>,
<code>cbind</code> and <code>rbind</code> for the class of hyperframes. There is also
<code>is.hyperframe</code> and <code><a href="#topic+as.hyperframe">as.hyperframe</a></code>.
</p>


<h3>Handling Character Strings</h3>

<p>The argument <code>stringsAsFactors</code>
is a logical value (passed to <code><a href="base.html#topic+data.frame">data.frame</a></code>)
specifying how to handle pixel values which
are character strings. If <code>TRUE</code>, character values are
interpreted as factor levels. If <code>FALSE</code>, they remain
as character strings. The default values of <code>stringsAsFactors</code>
depends on the version of <span class="rlang"><b>R</b></span>.
</p>

<ul>
<li><p> In <span class="rlang"><b>R</b></span> versions <code>&lt; 4.1.0</code>
the factory-fresh default is <code>stringsAsFactors=FALSE</code> and
the default can be changed by setting
<code>options(stringsAsFactors=FALSE)</code>.
</p>
</li>
<li><p> in <span class="rlang"><b>R</b></span> versions <code>&gt;= 4.1.0</code> the default
is <code>stringsAsFactors=FALSE</code> and there is no option to
change the default.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.hyperframe">as.hyperframe</a></code>,
<code><a href="#topic+as.hyperframe.ppx">as.hyperframe.ppx</a></code>,
<code><a href="#topic+plot.hyperframe">plot.hyperframe</a></code>,
<code><a href="#topic++5B.hyperframe">[.hyperframe</a></code>,
<code><a href="#topic+with.hyperframe">with.hyperframe</a></code>,
<code><a href="#topic+split.hyperframe">split.hyperframe</a></code>,
<code><a href="#topic+as.data.frame.hyperframe">as.data.frame.hyperframe</a></code>,
<code><a href="#topic+cbind.hyperframe">cbind.hyperframe</a></code>,
<code><a href="#topic+rbind.hyperframe">rbind.hyperframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # equivalent to a data frame
  hyperframe(X=1:10, Y=3)

 # list of functions
  hyperframe(f=list(sin, cos, tan))

 # table of functions and matching expressions
  hyperframe(f=list(sin, cos, tan),
             e=list(expression(sin(x)), expression(cos(x)), expression(tan(x))))

  hyperframe(X=1:10, Y=letters[1:10], Z=factor(letters[1:10]),
    stringsAsFactors=FALSE)

  lambda &lt;- runif(4, min=50, max=100)
if(require(spatstat.random)) {
  X &lt;- solapply(as.list(lambda), rpoispp)
} else {
  X &lt;- solapply(as.list(lambda), function(lam) runifrect(rpois(1, lam)))
}
  h &lt;- hyperframe(lambda=lambda, X=X)
  h

  h$lambda2 &lt;- lambda^2
  h[, "lambda3"] &lt;- lambda^3
  h[, "Y"] &lt;- X

  h[[2, "lambda3"]]
</code></pre>

<hr>
<h2 id='identify.ppp'>Identify Points in a Point Pattern</h2><span id='topic+identify.ppp'></span>

<h3>Description</h3>

<p>If a point pattern is plotted in the graphics window,
this function will find the point of the pattern which is nearest to
the mouse position, and print its mark value (or its serial number
if there is no mark).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
identify(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify.ppp_+3A_x">x</code></td>
<td>

<p>A point pattern
(object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="identify.ppp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+identify.default">identify.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="graphics.html#topic+identify">identify</a></code>
for point pattern objects.
</p>
<p>The point pattern <code>x</code> should first be plotted
using <code><a href="#topic+plot.ppp">plot.ppp</a></code>.
Then <code>identify(x)</code>
reads the position of the graphics pointer each time the
left mouse button is pressed.  It then finds 
the point of the pattern <code>x</code> closest to the mouse position.
If this closest point is sufficiently close to the mouse pointer,
its index (and its mark if any) 
will be returned as part of the value of the call.
</p>
<p>Each time a point of the pattern is identified,
text will be displayed next to the point,
showing its serial number (if <code>x</code> is unmarked)
or its mark value (if <code>x</code> is marked).
</p>


<h3>Value</h3>

<p>If <code>x</code> is unmarked, the result is 
a vector containing the serial numbers of the points in the pattern
<code>x</code> that were identified.
If <code>x</code> is marked, the result is a 
2-column matrix, the first column containing the serial numbers
and the second containing the marks for these points.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+identify">identify</a></code>,
<code><a href="#topic+clickppp">clickppp</a></code>
</p>

<hr>
<h2 id='identify.psp'>Identify Segments in a Line Segment Pattern</h2><span id='topic+identify.psp'></span>

<h3>Description</h3>

<p>If a line segment pattern is plotted in the graphics window,
this function will find the segment which is nearest to
the mouse position, and print its serial number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'psp'
identify(x, ..., labels=seq_len(nsegments(x)), n=nsegments(x), plot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify.psp_+3A_x">x</code></td>
<td>

<p>A line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="identify.psp_+3A_labels">labels</code></td>
<td>

<p>Labels associated with the segments, to be plotted when the
segments are identified. A character vector or numeric vector
of length equal to the number of segments in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="identify.psp_+3A_n">n</code></td>
<td>

<p>Maximum number of segments to be identified.
</p>
</td></tr>
<tr><td><code id="identify.psp_+3A_plot">plot</code></td>
<td>

<p>Logical. Whether to plot the labels when a segment is identified.
</p>
</td></tr>
<tr><td><code id="identify.psp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+text.default">text.default</a></code>
controlling the plotting of the labels.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="graphics.html#topic+identify">identify</a></code>
for line segment pattern objects.
</p>
<p>The line segment pattern <code>x</code> should first be plotted
using <code><a href="#topic+plot.psp">plot.psp</a></code>. Then <code>identify(x)</code>
reads the position of the graphics pointer each time the
left mouse button is pressed.  It then finds 
the segment in the pattern <code>x</code> that is closest to the mouse position.
This segment's index will be returned as part of the value of the call.
</p>
<p>Each time a segment is identified,
text will be displayed next to the point,
showing its serial number (or the relevant entry of <code>labels</code>).
</p>


<h3>Value</h3>

<p>Vector containing the serial numbers of the segments in the pattern
<code>x</code> that were identified.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+identify">identify</a></code>,
<code><a href="#topic+identify.ppp">identify.ppp</a></code>.
</p>

<hr>
<h2 id='im'>Create a Pixel Image Object</h2><span id='topic+im'></span>

<h3>Description</h3>

<p>Creates an object of
class <code>"im"</code> representing a two-dimensional pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  im(mat, xcol=seq_len(ncol(mat)), yrow=seq_len(nrow(mat)),
   xrange=NULL, yrange=NULL,
   unitname=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="im_+3A_mat">mat</code></td>
<td>

<p>matrix or vector containing the pixel values of the image.
</p>
</td></tr>
<tr><td><code id="im_+3A_xcol">xcol</code></td>
<td>

<p>vector of <code class="reqn">x</code> coordinates for the pixel grid
</p>
</td></tr>
<tr><td><code id="im_+3A_yrow">yrow</code></td>
<td>

<p>vector of <code class="reqn">y</code> coordinates for the pixel grid
</p>
</td></tr>
<tr><td><code id="im_+3A_xrange">xrange</code>, <code id="im_+3A_yrange">yrange</code></td>
<td>

<p>Optional. Vectors of length 2 giving the <code class="reqn">x</code> and <code class="reqn">y</code>
limits of the enclosing rectangle.
(Ignored if <code>xcol</code>, <code>yrow</code> are present.)
</p>
</td></tr>
<tr><td><code id="im_+3A_unitname">unitname</code></td>
<td>

<p>Optional. Name of unit of length. Either a single character string,
or a vector of two character strings giving the
singular and plural forms, respectively.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an object of class <code>"im"</code> representing
a &lsquo;pixel image&rsquo; or two-dimensional array of values.
</p>
<p>The pixel grid is rectangular and occupies a rectangular window
in the spatial coordinate system. 
The pixel values are <em>scalars</em>: they can be real numbers, integers, 
complex numbers, single characters or strings, 
logical values, or categorical values. A pixel's
value can also be <code>NA</code>, meaning that no value is defined
at that location, and effectively that pixel is &lsquo;outside&rsquo; the window. 
Although the pixel values must be scalar,
photographic colour images (i.e., with red, green, and blue brightness
channels) can be represented as character-valued images in <span class="pkg">spatstat</span>,
using <span class="rlang"><b>R</b></span>'s standard encoding of colours as character strings.
</p>
<p>The matrix <code>mat</code> contains the &lsquo;greyscale&rsquo; values
for a rectangular grid of pixels.
Note carefully that the entry <code>mat[i,j]</code>
gives the pixel value at the location <code>(xcol[j],yrow[i])</code>.
That is, the <b>row</b> index of the matrix <code>mat</code> corresponds
to increasing <b>y</b> coordinate, while the column index of <code>mat</code>
corresponds to increasing <b>x</b> coordinate.
Thus <code>yrow</code> has one entry for each row of <code>mat</code>
and <code>xcol</code> has one entry for each column of <code>mat</code>.
Under the usual convention in <span class="rlang"><b>R</b></span>, a correct
display of the image would be obtained by transposing the matrix, e.g.
<code>image.default(xcol, yrow, t(mat))</code>, if you wanted to do it by hand.
</p>
<p>The entries of <code>mat</code> may be numeric (real or integer), complex, 
logical, character, or factor values.
If <code>mat</code> is not a matrix, it will be converted into
a matrix with <code>nrow(mat) = length(yrow)</code> and
<code>ncol(mat) = length(xcol)</code>.
</p>
<p>To make a factor-valued image, note that 
<span class="rlang"><b>R</b></span> has a quirky way of handling matrices with
factor-valued entries. The command <code><a href="base.html#topic+matrix">matrix</a></code> cannot be used
directly, because it destroys factor information.
To make a factor-valued image, do one of the following:
</p>

<ul>
<li>
<p>Create a <code>factor</code> containing the pixel values,
say <code>mat &lt;- factor(.....)</code>, 
and then assign matrix dimensions to it by <code>dim(mat) &lt;- c(nr, nc)</code>
where <code>nr, nc</code> are the numbers of rows and columns. The
resulting object <code>mat</code> is both a factor and a vector.
</p>
</li>
<li>
<p>Supply <code>mat</code> as a one-dimensional factor
and specify the arguments <code>xcol</code> and <code>yrow</code>
to determine the dimensions of the image.
</p>
</li>
<li>
<p>Use the functions
<code><a href="#topic+cut.im">cut.im</a></code> or <code><a href="#topic+eval.im">eval.im</a></code> to make factor-valued
images from other images).
</p>
</li></ul>

<p>For a description of the methods available for pixel image objects,
see <code><a href="#topic+im.object">im.object</a></code>.
</p>
<p>To convert other kinds of data to a pixel image (for example,
functions or windows), use <code><a href="#topic+as.im">as.im</a></code>.
</p>


<h3>Warnings</h3>

<p>The internal representation of images is likely to change in future
releases of <span class="pkg">spatstat</span>. The safe way to extract pixel values
from an image object is to use <code><a href="#topic+as.matrix.im">as.matrix.im</a></code>
or <code><a href="#topic++5B.im">[.im</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im.object">im.object</a></code> for details of the class.
</p>
<p><code><a href="#topic+as.im">as.im</a></code> for converting other kinds of data to an image.
</p>
<p><code><a href="#topic+as.matrix.im">as.matrix.im</a></code>,
<code><a href="#topic++5B.im">[.im</a></code>,
<code><a href="#topic+eval.im">eval.im</a></code> for manipulating images.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   vec &lt;- rnorm(1200)
   mat &lt;- matrix(vec, nrow=30, ncol=40)
   whitenoise &lt;- im(mat)
   whitenoise &lt;- im(mat, xrange=c(0,1), yrange=c(0,1))
   whitenoise &lt;- im(mat, xcol=seq(0,1,length=40), yrow=seq(0,1,length=30))
   whitenoise &lt;- im(vec, xcol=seq(0,1,length=40), yrow=seq(0,1,length=30))
   plot(whitenoise)

   # Factor-valued images:
   f &lt;- factor(letters[1:12])
   dim(f) &lt;- c(3,4)
   Z &lt;- im(f)

   # Factor image from other image:
   cutwhite &lt;- cut(whitenoise, 3)
   plot(cutwhite)

   # Factor image from raw data
   cutmat &lt;- cut(mat, 3)
   dim(cutmat) &lt;- c(30,40)
   cutwhite &lt;- im(cutmat)
   plot(cutwhite)
</code></pre>

<hr>
<h2 id='im.apply'>
Apply Function Pixelwise to List of Images 
</h2><span id='topic+im.apply'></span>

<h3>Description</h3>

<p>Returns a pixel image obtained by applying a function
to the values of corresponding pixels in several pixel images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>im.apply(X, FUN, ..., fun.handles.na=FALSE, check=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="im.apply_+3A_x">X</code></td>
<td>

<p>A list of pixel images (objects of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="im.apply_+3A_fun">FUN</code></td>
<td>

<p>A function that can be applied to vectors,
or a character string giving the name of such a function.
</p>
</td></tr>
<tr><td><code id="im.apply_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code>FUN</code>.
</p>
</td></tr>
<tr><td><code id="im.apply_+3A_fun.handles.na">fun.handles.na</code></td>
<td>

<p>Logical value specifying what to do when the data include
<code>NA</code> values. See Details.
</p>
</td></tr>
<tr><td><code id="im.apply_+3A_check">check</code></td>
<td>

<p>Logical value specifying whether to check that the images in
<code>X</code> are compatible (for example that they have the same
grid of pixel locations) and to convert them to compatible images
if necessary.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>X</code> should be a list of pixel images
(objects of class <code>"im"</code>). If the images do not have
identical pixel grids, they will be converted to a common
grid using <code><a href="#topic+harmonise.im">harmonise.im</a></code>.
</p>
<p>At each pixel location, the values of the images in <code>X</code>
at that pixel will be extracted as a vector. The function
<code>FUN</code> will be applied to this vector. The result (which should be
a single value) becomes the pixel value of the resulting image.
</p>
<p>The argument <code>fun.handles.na</code> specifies what to do
when some of the pixel values are <code>NA</code>.
</p>

<ul>
<li><p> If <code>fun.handles.na=FALSE</code> (the default),
the function <code>FUN</code> is never applied to data that include
<code>NA</code> values; the result is defined to be <code>NA</code> whenever
the data contain <code>NA</code>.
</p>
</li>
<li>
<p>If <code>fun.handles.na=TRUE</code>, the function <code>FUN</code> will be applied to
all pixel data, including those which contain <code>NA</code> values.
</p>
</li></ul>



<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.im">eval.im</a></code> for algebraic operations with images.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # list of two pixel images
  Y &lt;- solapply(bei.extra, scaletointerval)
  plot(Y)
  im.apply(Y, max)
  im.apply(Y, sum)

  ## Example with incompatible patterns of NA values
  B &lt;- owin(c(438, 666), c(80, 310))
  Y[[1]][B] &lt;- NA
  opa &lt;- par(mfrow=c(2,2))
  plot(Y[[1]])
  plot(Y[[2]])
  #' Default action: NA -&gt; NA
  plot(im.apply(Y, mean))
  #' Use NA handling in mean.default
  plot(im.apply(Y, mean, na.rm=TRUE, fun.handles.na=TRUE))
  par(opa)
</code></pre>

<hr>
<h2 id='im.object'>Class of Images</h2><span id='topic+im.object'></span>

<h3>Description</h3>

<p>A class <code>"im"</code> to represent a two-dimensional pixel image.
</p>


<h3>Details</h3>

<p>An object of this class represents
a two-dimensional pixel image. It specifies
</p>

<ul>
<li><p> the dimensions of the rectangular array of pixels
</p>
</li>
<li> <p><code class="reqn">x</code> and <code class="reqn">y</code> coordinates for the pixels
</p>
</li>
<li><p> a numeric value (&ldquo;grey value&rdquo;) at each pixel
</p>
</li></ul>

<p>If <code>X</code> is an object of type <code>im</code>,
it contains the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>v</code> </td><td style="text-align: left;"> matrix of values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>dim</code> </td><td style="text-align: left;"> dimensions of matrix <code>v</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>xrange</code> </td><td style="text-align: left;"> range of <code class="reqn">x</code> coordinates of image window </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>yrange</code> </td><td style="text-align: left;"> range of <code class="reqn">y</code> coordinates of image window </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>xstep</code> </td><td style="text-align: left;"> width of one pixel </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ystep</code> </td><td style="text-align: left;"> height of one pixel </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>xcol</code> </td><td style="text-align: left;"> vector of <code class="reqn">x</code> coordinates of centres of pixels </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>yrow</code> </td><td style="text-align: left;"> vector of <code class="reqn">y</code> coordinates of centres of pixels 
  </td>
</tr>

</table>

<p>Users are strongly advised not to manipulate these entries
directly.
</p>
<p>Objects of class <code>"im"</code>
may be created by the functions
<code><a href="#topic+im">im</a></code> and <code><a href="#topic+as.im">as.im</a></code>.
Image objects are also returned by various functions including
<code><a href="#topic+distmap">distmap</a></code>, <code><a href="spatstat.explore.html#topic+Kmeasure">Kmeasure</a></code>, <code><a href="#topic+setcov">setcov</a></code>, 
<code><a href="#topic+eval.im">eval.im</a></code> and <code><a href="#topic+cut.im">cut.im</a></code>.
</p>
<p>Image objects may be displayed using the methods
<code><a href="#topic+plot.im">plot.im</a></code>, <code>image.im</code>, <code><a href="#topic+persp.im">persp.im</a></code>
and <code>contour.im</code>. There are also methods 
<code><a href="#topic+print.im">print.im</a></code> for printing information about an image,
<code><a href="#topic+summary.im">summary.im</a></code> for summarising an image,
<code><a href="#topic+mean.im">mean.im</a></code> for calculating the average pixel value, 
<code><a href="#topic+hist.im">hist.im</a></code> for plotting a histogram of pixel values,
<code><a href="#topic+quantile.im">quantile.im</a></code> for calculating quantiles of pixel values,
and <code><a href="#topic+cut.im">cut.im</a></code> for dividing the range of pixel values into
categories.
</p>
<p>Pixel values in an image may be extracted
using the subset operator <code><a href="#topic++5B.im">[.im</a></code>.
To extract all pixel values from an image object,
use <code><a href="#topic+as.matrix.im">as.matrix.im</a></code>.
The levels of a factor-valued image can be extracted and
changed with <code>levels</code> and <code>levels&lt;-</code>.
</p>
<p>Calculations involving one or more images (for example,
squaring all the pixel values in an image, converting numbers to 
factor levels, or 
subtracting one image from another) can often be done
easily using <code><a href="#topic+eval.im">eval.im</a></code>.
To find all pixels satisfying
a certain constraint, use <code><a href="#topic+solutionset">solutionset</a></code>.
</p>
<p>Note carefully that the entry <code>v[i,j]</code>
gives the pixel value at the location <code>(xcol[j],yrow[i]</code>.
That is, the <b>row</b> index of the matrix <code>v</code> corresponds
to increasing <b>y</b> coordinate, while the column index of <code>mat</code>
corresponds to increasing <b>x</b> coordinate.
Thus <code>yrow</code> has one entry for each row of <code>v</code>
and <code>xcol</code> has one entry for each column of <code>v</code>.
Under the usual convention in <span class="rlang"><b>R</b></span>, a correct
display of the image would be obtained by transposing the matrix, e.g.
<code>image.default(xcol, yrow, t(v))</code>, if you wanted to do it by hand.
</p>


<h3>Warnings</h3>

<p>The internal representation of images is likely to change in future
releases of <span class="pkg">spatstat</span>. Do not address the entries in an
image directly. To extract all pixel values from an image object,
use <code><a href="#topic+as.matrix.im">as.matrix.im</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im">im</a></code>,
<code><a href="#topic+as.im">as.im</a></code>,
<code><a href="#topic+plot.im">plot.im</a></code>,
<code><a href="#topic+persp.im">persp.im</a></code>,
<code><a href="#topic+eval.im">eval.im</a></code>,
<code><a href="#topic++5B.im">[.im</a></code>
</p>

<hr>
<h2 id='imcov'>Spatial Covariance of a Pixel Image</h2><span id='topic+imcov'></span>

<h3>Description</h3>

<p>Computes the unnormalised spatial covariance function of a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> imcov(X, Y=X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imcov_+3A_x">X</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>.
</p>
</td></tr>
<tr><td><code id="imcov_+3A_y">Y</code></td>
<td>

<p>Optional. Another pixel image.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (uncentred, unnormalised)
<em>spatial covariance function</em> of a pixel image <code class="reqn">X</code> in the plane
is the function <code class="reqn">C(v)</code> defined for each vector <code class="reqn">v</code> as
</p>
<p style="text-align: center;"><code class="reqn">
    C(v) = \int X(u)X(u-v)\, {\rm d}u
  </code>
</p>

<p>where the integral is
over all spatial locations <code class="reqn">u</code>, and where <code class="reqn">X(u)</code> denotes the
pixel value at location <code class="reqn">u</code>.
</p>
<p>This command computes a discretised approximation to
the spatial covariance function, using the Fast Fourier Transform.
The return value is
another pixel image (object of class <code>"im"</code>) whose greyscale values
are values of the spatial covariance function.
</p>
<p>If the argument <code>Y</code> is present, then <code>imcov(X,Y)</code>
computes the set <em>cross-covariance</em> function <code class="reqn">C(u)</code>
defined as 
</p>
<p style="text-align: center;"><code class="reqn">
    C(v) = \int X(u)Y(u-v)\, {\rm d}u.
  </code>
</p>

<p>Note that <code>imcov(X,Y)</code> is equivalent to
<code>convolve.im(X,Y,reflectY=TRUE)</code>.
</p>


<h3>Value</h3>

<p>A pixel image (an object of class <code>"im"</code>) representing the
spatial covariance function of <code>X</code>,
or the cross-covariance of <code>X</code> and <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setcov">setcov</a></code>,
<code><a href="#topic+convolve.im">convolve.im</a></code>,
<code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+erosion">erosion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- as.im(square(1))
  v &lt;- imcov(X)
  plot(v)
</code></pre>

<hr>
<h2 id='incircle'>Find Largest Circle Inside Window</h2><span id='topic+incircle'></span><span id='topic+inradius'></span>

<h3>Description</h3>

<p>Find the largest circle contained in a given window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incircle(W)

inradius(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incircle_+3A_w">W</code></td>
<td>
<p>A window (object of class <code>"owin"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a window <code>W</code> of any type and shape, 
the function <code>incircle</code> determines the largest circle
that is contained inside <code>W</code>, while <code>inradius</code> computes its
radius only.
</p>
<p>For non-rectangular windows, the incircle is computed approximately
by finding the maximum of the distance map (see
<code><a href="#topic+distmap">distmap</a></code>) of the complement of the window.
</p>


<h3>Value</h3>

<p>The result of <code>incircle</code> is 
a list with entries <code>x,y,r</code> giving the location <code>(x,y)</code>
and radius <code>r</code> of the incircle.
</p>
<p>The result of <code>inradius</code> is the numerical value of radius.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+centroid.owin">centroid.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  W &lt;- square(1)
  Wc &lt;- incircle(W)
  plot(W)
  plot(disc(Wc$r, c(Wc$x, Wc$y)), add=TRUE)

  plot(letterR)
  Rc &lt;- incircle(letterR)
  plot(disc(Rc$r, c(Rc$x, Rc$y)), add=TRUE)

  W &lt;- as.mask(letterR)
  plot(W)
  Rc &lt;- incircle(W)
  plot(disc(Rc$r, c(Rc$x, Rc$y)), add=TRUE)
</code></pre>

<hr>
<h2 id='infline'>Infinite Straight Lines</h2><span id='topic+infline'></span><span id='topic+plot.infline'></span><span id='topic+print.infline'></span>

<h3>Description</h3>

<p>Define the coordinates of one or more straight lines in the plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infline(a = NULL, b = NULL, h = NULL, v = NULL, p = NULL, theta = NULL)

## S3 method for class 'infline'
print(x, ...)

## S3 method for class 'infline'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infline_+3A_a">a</code>, <code id="infline_+3A_b">b</code></td>
<td>
<p>Numeric vectors of equal length giving the
intercepts <code class="reqn">a</code> and slopes <code class="reqn">b</code> of the lines.
Incompatible with <code>h,v,p,theta</code>
</p>
</td></tr>
<tr><td><code id="infline_+3A_h">h</code></td>
<td>
<p>Numeric vector giving the positions of horizontal lines when
they cross the <code class="reqn">y</code> axis.
Incompatible with <code>a,b,v,p,theta</code>
</p>
</td></tr>
<tr><td><code id="infline_+3A_v">v</code></td>
<td>
<p>Numeric vector giving the positions of vertical lines when
they cross the <code class="reqn">x</code> axis.
Incompatible with <code>a,b,h,p,theta</code>
</p>
</td></tr>
<tr><td><code id="infline_+3A_p">p</code>, <code id="infline_+3A_theta">theta</code></td>
<td>
<p>Numeric vectors of equal length
giving the polar coordinates of the line.
Incompatible with <code>a,b,h,v</code>
</p>
</td></tr>
<tr><td><code id="infline_+3A_x">x</code></td>
<td>
<p>An object of class <code>"infline"</code></p>
</td></tr>
<tr><td><code id="infline_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="base.html#topic+print">print</a></code>
for printing or <code><a href="graphics.html#topic+abline">abline</a></code> for plotting
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>infline</code> is a convenient way to handle
infinite straight lines in the plane.
</p>
<p>The position of a line can be specified in several ways:
</p>

<ul>
<li>
<p>its intercept <code class="reqn">a</code> and slope <code class="reqn">b</code> 
in the equation <code class="reqn">y = a + b x</code>
can be used unless the line is vertical.
</p>
</li>
<li>
<p>for vertical lines we can use the
position <code class="reqn">v</code> where the line crosses the <code class="reqn">y</code> axis
</p>
</li>
<li>
<p>for horizontal lines we can use the
position <code class="reqn">h</code> where the line crosses the <code class="reqn">x</code> axis
</p>
</li>
<li>
<p>the polar coordinates <code class="reqn">p</code> and <code class="reqn">\theta</code>
can be used for any line. The line equation is
</p>
<p style="text-align: center;"><code class="reqn">
      x \cos\theta + y \sin\theta = p
    </code>
</p>

</li></ul>

<p>The command <code>infline</code> will accept line coordinates in any
of these formats. The arguments <code>a,b,h,v</code> have the same interpretation
as they do in the line-plotting function
<code><a href="graphics.html#topic+abline">abline</a></code>.
</p>
<p>The command <code>infline</code> converts between different coordinate
systems (e.g. from <code>a,b</code> to <code>p,theta</code>) and returns an
object of class <code>"infline"</code>
that contains a representation of the lines in
each appropriate coordinate system. This object can be printed
and plotted.
</p>


<h3>Value</h3>

<p>The value of <code>infline</code> is an object of class <code>"infline"</code>
which is basically a data frame with columns <code>a,b,h,v,p,theta</code>.
Each row of the data frame represents one line. 
Entries may be <code>NA</code> if a coordinate is not applicable to
a particular line. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotate.infline">rotate.infline</a></code>,
<code><a href="#topic+clip.infline">clip.infline</a></code>,
<code><a href="#topic+chop.tess">chop.tess</a></code>,
<code><a href="#topic+whichhalfplane">whichhalfplane</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  infline(a=10:13,b=1)
  infline(p=1:3, theta=pi/4)
  plot(c(-1,1),c(-1,1),type="n",xlab="",ylab="", asp=1)
  plot(infline(p=0.4, theta=seq(0,pi,length=20)))
</code></pre>

<hr>
<h2 id='inside.boxx'>Test Whether Points Are Inside A Multidimensional Box</h2><span id='topic+inside.boxx'></span>

<h3>Description</h3>

<p>Test whether points lie inside or outside
a given multidimensional box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> inside.boxx(..., w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inside.boxx_+3A_...">...</code></td>
<td>

<p>Coordinates of points to be tested.
One vector for each dimension (all of same length).
(Alternatively, a single point pattern object
of class <code>"<a href="#topic+ppx">ppx</a>"</code>
or its coordinates as a <code>matrix</code>, <code>data.frame</code>, or 
<code>"<a href="#topic+hyperframe">hyperframe</a>"</code>)
</p>
</td></tr>
<tr><td><code id="inside.boxx_+3A_w">w</code></td>
<td>
<p>A window.
This should be an object of class <code><a href="#topic+boxx">boxx</a></code>,
or can be given in any format acceptable to <code><a href="#topic+as.boxx">as.boxx</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether each of the provided points lies inside or outside
the window <code>w</code> and returns <code>TRUE</code> if it is inside.
</p>
<p>The boundary of the window is treated as being inside.
</p>
<p>Normally each argument provided (except <code>w</code>) must be numeric vectors of
equal length (length zero is allowed) containing the coordinates
of points.
Alternatively a single point pattern (object of class <code>"ppx"</code>)
can be given; then the coordinates of the point pattern are extracted.
A single <code>matrix</code>, <code>data.frame</code>, or <code>"<a href="#topic+hyperframe">hyperframe</a>"</code>)
with the coordinates is also accepted.
</p>


<h3>Value</h3>

<p>Logical vector whose <code>i</code>th entry is 
<code>TRUE</code> if the corresponding point is inside <code>w</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxx">boxx</a></code>,
<code><a href="#topic+as.boxx">as.boxx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # 3D box with side [0,2]
  w &lt;- boxx(c(0,2), c(0,2), c(0,2))

  # Random points in box with side [-1,3]
  x &lt;- runif(30, min=-1, max=3)
  y &lt;- runif(30, min=-1, max=3)
  z &lt;- runif(30, min=-1, max=3)

  # Points falling in smaller box
  ok &lt;- inside.boxx(x, y, z, w=w)

  # Same using a point pattern as argument:
  X &lt;- ppx(data = cbind(x, y, z), domain = boxx(c(0,3), c(0,3), c(0,3)))
  ok2 &lt;- inside.boxx(X, w=w)

  # Same using the coordinates given as data.frame/matrix/hyperframe
  coords_mat &lt;- cbind(x,y,z)
  ok_mat &lt;- inside.boxx(coords_mat, w=w)
  coords_df &lt;- data.frame(x,y,z)
  ok_df &lt;- inside.boxx(coords_mat, w=w)
  coords_hyper &lt;- hyperframe(x,y,z)
  ok_hyper &lt;- inside.boxx(coords_mat, w=w)
  
</code></pre>

<hr>
<h2 id='inside.owin'>Test Whether Points Are Inside A Window</h2><span id='topic+inside.owin'></span>

<h3>Description</h3>

<p>Test whether points lie inside or outside
a given window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> inside.owin(x, y, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inside.owin_+3A_x">x</code></td>
<td>

<p>Vector of <code class="reqn">x</code> coordinates of points to be tested.
(Alternatively, a point pattern object providing both
<code class="reqn">x</code> and <code class="reqn">y</code> coordinates.)
</p>
</td></tr>
<tr><td><code id="inside.owin_+3A_y">y</code></td>
<td>

<p>Vector of <code class="reqn">y</code> coordinates of points to be tested.
</p>
</td></tr>
<tr><td><code id="inside.owin_+3A_w">w</code></td>
<td>
<p>A window.
This should be an object of class <code><a href="#topic+owin">owin</a></code>,
or can be given in any format acceptable to <code><a href="#topic+as.owin">as.owin</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether each of the points 
<code>(x[i],y[i])</code> lies inside or outside
the window <code>w</code> and returns <code>TRUE</code> if it is inside.
</p>
<p>The boundary of the window is treated as being inside.
</p>
<p>If <code>w</code> is of type <code>"rectangle"</code> or 
<code>"polygonal"</code>, the algorithm uses analytic geometry
(the discrete Stokes theorem).
Computation time is linear in the number of points
and (for polygonal windows) in the number of vertices of the
boundary polygon. Boundary cases are correct to single
precision accuracy.
</p>
<p>If <code>w</code> is of type <code>"mask"</code> then the 
pixel closest to <code>(x[i],y[i])</code> is tested. The
results may be incorrect for points lying within 
one pixel diameter of the window boundary.
</p>
<p>Normally <code>x</code> and <code>y</code> must be numeric vectors of
equal length (length zero is allowed) containing the coordinates
of points. Alternatively <code>x</code>
can be a point pattern (object of class <code>"ppp"</code>) while <code>y</code>
is missing; then the coordinates of the point pattern are extracted.
</p>


<h3>Value</h3>

<p>Logical vector whose <code>i</code>th entry is 
<code>TRUE</code> if the corresponding point <code>(x[i],y[i])</code>
is inside <code>w</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # hexagonal window
  k &lt;- 6
  theta &lt;- 2 * pi * (0:(k-1))/k
  co &lt;- cos(theta)
  si &lt;- sin(theta)
  mas &lt;- owin(c(-1,1), c(-1,1), poly=list(x=co, y=si))
  if(human &lt;- interactive()) {
  plot(mas)
  }

  # random points in rectangle
  x &lt;- runif(30,min=-1, max=1)
  y &lt;- runif(30,min=-1, max=1)

  ok &lt;- inside.owin(x, y, mas)

  if(human) {
  points(x[ok], y[ok])
  points(x[!ok], y[!ok], pch="x")
  }  
</code></pre>

<hr>
<h2 id='integral'>
Integral of a Function or Spatial Object
</h2><span id='topic+integral'></span>

<h3>Description</h3>

<p>Computes the integral of a function or spatial object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integral(f, domain=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integral_+3A_f">f</code></td>
<td>

<p>A function, or a spatial object that can be treated as a function.
</p>
</td></tr>
<tr><td><code id="integral_+3A_domain">domain</code></td>
<td>

<p>Optional. Data specifying the domain of integration.
</p>
</td></tr>
<tr><td><code id="integral_+3A_...">...</code></td>
<td>

<p>Arguments passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>integral</code> is generic.
It calculates the integral of a function, or
the integral of a spatial object that can be treated as a function.
It has methods
for one-dimensional functions (<code>"density"</code>, <code>"fv"</code>)
and for spatial objects
(<code>"im"</code>, <code>"msr"</code>, <code>"linim"</code>, <code>"linfun"</code>).
</p>


<h3>Value</h3>

<p>A single numeric or complex value, or a vector of such values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>




<p><code><a href="#topic+integral.density">integral.density</a></code>.
</p>
<p><code>integral.im</code> in package <code>spatstat.geom</code>.
</p>

<hr>
<h2 id='integral.density'>
Compute Integral of One-Dimensional Kernel Density Estimate.
</h2><span id='topic+integral.density'></span>

<h3>Description</h3>

<p>Compute the integral of a kernel density estimate
over a specified range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density'
integral(f, domain = NULL, weight=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integral.density_+3A_f">f</code></td>
<td>

<p>A one-dimensional probability density estimate
(object of class <code>"density"</code>) obtained from the
function <code><a href="stats.html#topic+density.default">density.default</a></code> or
from <code><a href="#topic+unnormdensity">unnormdensity</a></code>.
</p>
</td></tr>
<tr><td><code id="integral.density_+3A_domain">domain</code></td>
<td>

<p>Optional. Range of values of the argument <code class="reqn">x</code> over which the
density <code class="reqn">f(x)</code> should be integrated. A numeric vector of length
2 giving the minimum and maximum values of <code class="reqn">x</code>. Infinite limits
are permitted.
</p>
</td></tr>
<tr><td><code id="integral.density_+3A_weight">weight</code></td>
<td>

<p>Optional. A <code>function(x)</code> specifying a weight integrand.
</p>
</td></tr>
<tr><td><code id="integral.density_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+integral">integral</a></code>.
It computes the numerical integral
</p>
<p style="text-align: center;"><code class="reqn">
    I = \int f(x) dx
  </code>
</p>

<p>of the density estimate <code>f</code>.
If <code>weight</code> is specified, then the weighted integral
</p>
<p style="text-align: center;"><code class="reqn">
    I = \int w(x) f(x) dx
  </code>
</p>

<p>is computed, where <code class="reqn">w</code> is the function specified by <code>weight</code>.
This function must return finite numerical values.
</p>
<p>If <code>domain</code> is specified, the integral is restricted to the
interval of <code class="reqn">x</code> values given by the <code>domain</code>.
</p>
<p>Integrals are calculated numerically using the trapezoidal rule
restricted to the domain given.
</p>


<h3>Value</h3>

<p>A single numerical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>
</p>


<p><code>quantile.density</code>, <code>CDF.density</code> in package <span class="pkg">spatstat.explore</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- runif(10)
  d &lt;- density(x, bw=0.1)
  integral(d) # should be approximately 1
  integral(d, domain=c(-Inf, 0)) # mass on negative half-line
  ## mean of density
  integral(d, weight=function(x) x)
</code></pre>

<hr>
<h2 id='integral.im'>
Integral of a Pixel Image
</h2><span id='topic+integral.im'></span>

<h3>Description</h3>

<p>Computes the integral of a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im'
integral(f, domain=NULL, weight=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integral.im_+3A_f">f</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>) with pixel values
that can be treated as numeric or complex values.
</p>
</td></tr>
<tr><td><code id="integral.im_+3A_domain">domain</code></td>
<td>

<p>Optional. Window specifying the domain of integration.
Alternatively a tessellation.
</p>
</td></tr>
<tr><td><code id="integral.im_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="integral.im_+3A_weight">weight</code></td>
<td>

<p>Optional. A pixel image (object of class <code>"im"</code>)
or a <code>function(x,y)</code> giving a numerical weight
to be applied to the integration.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+integral">integral</a></code> is generic, with methods
for spatial objects
(<code>"im"</code>, <code>"msr"</code>, <code>"linim"</code>, <code>"linfun"</code>)
and one-dimensional functions (<code>"density"</code>, <code>"fv"</code>).
</p>
<p>The method <code>integral.im</code> treats the pixel image <code>f</code> as a function of
the spatial coordinates, and computes its integral.
The integral is calculated
by summing the pixel values and multiplying by the area of one pixel.
</p>
<p>The pixel values of <code>f</code> may be numeric, integer, logical or
complex. They cannot be factor or character values.
</p>
<p>The logical values <code>TRUE</code> and <code>FALSE</code> are converted to
<code>1</code> and <code>0</code> respectively, so that the integral of a logical
image is the total area of the <code>TRUE</code> pixels, in the same units
as <code>unitname(x)</code>.
</p>
<p>If <code>domain</code> is a window (class <code>"owin"</code>) then the integration
will be restricted to this window. If <code>domain</code> is a tessellation
(class <code>"tess"</code>) then the integral of <code>f</code> in each
tile of <code>domain</code> will be computed.
</p>
<p>If <code>weight</code> is given, it should be a pixel image or a function of
coordinates <code class="reqn">x</code> and <code class="reqn">y</code> returning numerical values.
Then each pixel value of <code>f</code>
will be multiplied by the corresponding value of <code>weight</code>.
Effectively, the result is the integral of <code>weight * f</code>.
</p>


<h3>Value</h3>

<p>A single numeric or complex value (or a vector of such values
if <code>domain</code> is a tessellation).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+integral">integral</a></code>,
<code><a href="#topic+eval.im">eval.im</a></code>,
<code><a href="#topic++5B.im">[.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # approximate integral of f(x,y) dx dy
   f &lt;- function(x,y){3*x^2 + 2*y}
   Z &lt;- as.im(f, square(1))
   integral(Z)
   # correct answer is 2

   # integrate over the subset [0.1,0.9] x [0.2,0.8]
   W &lt;- owin(c(0.1,0.9), c(0.2,0.8))
   integral(Z, W)

   # weighted integral
   integral(Z, weight=function(x,y){x})
</code></pre>

<hr>
<h2 id='intensity'>
Intensity of a Dataset or a Model
</h2><span id='topic+intensity'></span>

<h3>Description</h3>

<p>Generic function for computing the intensity of a spatial dataset
or spatial point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intensity(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intensity_+3A_x">X</code></td>
<td>

<p>A spatial dataset or a spatial point process model.
</p>
</td></tr>
<tr><td><code id="intensity_+3A_...">...</code></td>
<td>

<p>Further arguments depending on the class of <code>X</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function for computing the intensity of a spatial dataset
or spatial point process model. There are methods for point patterns
(objects of class <code>"ppp"</code>) and fitted point process models
(objects of class <code>"ppm"</code>).
</p>
<p>The empirical intensity of a dataset is the average density
(the average amount of &lsquo;stuff&rsquo; per unit area or volume).
The empirical intensity of a point pattern is computed by the
method <code><a href="#topic+intensity.ppp">intensity.ppp</a></code>.
</p>
<p>The theoretical intensity of a stochastic model is the expected density
(expected  amount of &lsquo;stuff&rsquo; per unit area or volume).
The theoretical intensity of a fitted point process model is computed by the
method <code><a href="spatstat.model.html#topic+intensity.ppm">intensity.ppm</a></code>.
</p>


<h3>Value</h3>

<p>Usually a numeric value or vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intensity.ppp">intensity.ppp</a></code>,
<code><a href="spatstat.model.html#topic+intensity.ppm">intensity.ppm</a></code>.
</p>

<hr>
<h2 id='intensity.ppp'>
Empirical Intensity of Point Pattern
</h2><span id='topic+intensity.ppp'></span><span id='topic+intensity.splitppp'></span>

<h3>Description</h3>

<p>Computes the average number of points per unit area
in a point pattern dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
intensity(X, ..., weights=NULL)

## S3 method for class 'splitppp'
intensity(X, ..., weights=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intensity.ppp_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="intensity.ppp_+3A_weights">weights</code></td>
<td>

<p>Optional.
Numeric vector of weights attached to the points of <code>X</code>.
Alternatively, an <code>expression</code> which can be evaluated to
give a vector of weights.
</p>
</td></tr>
<tr><td><code id="intensity.ppp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+intensity">intensity</a></code>.
It computes the empirical intensity of a point pattern
(object of class <code>"ppp"</code>),
i.e. the average density of points per unit area.
</p>
<p>If the point pattern is multitype, the intensities of the
different types are computed separately.
</p>
<p>Note that the intensity will be computed as the number of points
per square unit, based on the unit of length for <code>X</code>,
given by <code>unitname(X)</code>. If the unit of length is a strange multiple
of a standard unit, like <code>5.7 metres</code>, then it can be converted
to the standard unit using <code><a href="#topic+rescale">rescale</a></code>. See the Examples.
</p>
<p>If <code>weights</code> are given, then the intensity is
computed as the total <em>weight</em> per square unit.
The argument <code>weights</code> should be a numeric vector
of weights for each point of <code>X</code> (weights may be negative or
zero).
</p>
<p>Alternatively <code>weights</code> can be an <code>expression</code>
which will be evaluated for the dataset to yield a vector of weights.
The expression may involve the Cartesian coordinates <code class="reqn">x,y</code> of the
points, and the marks of the points, if any. Variable names
permitted in the expression include <code>x</code> and <code>y</code>,
the name <code>marks</code> if <code>X</code> has a single column of marks,
the names of any columns of marks if <code>X</code> has a data frame of
marks, and the names of constants or functions that exist
in the global environment. See the Examples.
</p>


<h3>Value</h3>

<p>A numeric value (giving the intensity) or numeric vector
(giving the intensity for each possible type).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intensity">intensity</a></code>, 
<code><a href="spatstat.model.html#topic+intensity.ppm">intensity.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  japanesepines
  intensity(japanesepines)
  unitname(japanesepines)
  intensity(rescale(japanesepines))

  intensity(amacrine)
  intensity(split(amacrine))

  # numeric vector of weights
  volumes &lt;- with(marks(finpines), (pi/4) * height * diameter^2)
  intensity(finpines, weights=volumes)

  # expression for weights
  intensity(finpines, weights=expression((pi/4) * height * diameter^2))
</code></pre>

<hr>
<h2 id='intensity.ppx'>Intensity of a Multidimensional Space-Time Point Pattern</h2><span id='topic+intensity.ppx'></span>

<h3>Description</h3>

<p>Calculates the intensity of points in a multi-dimensional point
pattern of class <code>"ppx"</code> or <code>"pp3"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppx'
intensity(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intensity.ppx_+3A_x">X</code></td>
<td>
<p>Point pattern of class <code>"ppx"</code> or <code>"pp3"</code>.</p>
</td></tr>
<tr><td><code id="intensity.ppx_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+intensity">intensity</a></code>.
It computes the empirical intensity of a multi-dimensional point pattern
(object of class <code>"ppx"</code> including <code>"pp3"</code>),
i.e. the average density of points per unit volume.
</p>
<p>If the point pattern is multitype, the intensities of the
different types are computed separately.
</p>


<h3>Value</h3>

<p>A single number or a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- osteo$pts[[1]]
  intensity(X)
  marks(X) &lt;- factor(sample(letters[1:3], npoints(X), replace=TRUE))
  intensity(X)
</code></pre>

<hr>
<h2 id='intensity.psp'>
Empirical Intensity of Line Segment Pattern
</h2><span id='topic+intensity.psp'></span>

<h3>Description</h3>

<p>Computes the average total length of segments per unit area
in a spatial pattern of line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'psp'
intensity(X, ..., weights=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intensity.psp_+3A_x">X</code></td>
<td>

<p>A line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="intensity.psp_+3A_weights">weights</code></td>
<td>

<p>Optional.
Numeric vector of weights attached to the segments of <code>X</code>.
Alternatively, an <code>expression</code> which can be evaluated to
give a vector of weights.
</p>
</td></tr>
<tr><td><code id="intensity.psp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+intensity">intensity</a></code>.
It computes the empirical intensity of a line segment pattern
(object of class <code>"psp"</code>),
i.e. the average total segment length per unit area.
</p>
<p>If the segment pattern is multitype, the intensities of the
different types are computed separately.
</p>
<p>Note that the intensity will be computed as the length per area
in units per square unit, based on the unit of length for <code>X</code>,
given by <code>unitname(X)</code>. If the unit of length is a strange multiple
of a standard unit, like <code>5.7 metres</code>, then it can be converted
to the standard unit using <code><a href="#topic+rescale">rescale</a></code>. See the Examples.
</p>
<p>If <code>weights</code> are given, then the intensity is
computed as the total <em>weight times length</em> per square unit.
The argument <code>weights</code> should be a numeric vector
of weights for each point of <code>X</code> (weights may be negative or
zero). 
</p>
<p>Alternatively <code>weights</code> can be an <code>expression</code>
which will be evaluated for the dataset to yield a vector of weights.
The expression may involve the Cartesian coordinates <code class="reqn">x,y</code> of the
points, and the marks of the points, if any. Variable names
permitted in the expression include <code>x0</code>, <code>x1</code>, <code>y0</code>,
<code>y1</code> for the coordinates of the segment endpoint,
the name <code>marks</code> if <code>X</code> has a single column of marks,
the names of any columns of marks if <code>X</code> has a data frame of
marks, and the names of constants or functions that exist
in the global environment. See the Examples.
</p>


<h3>Value</h3>

<p>A numeric value (giving the intensity) or numeric vector
(giving the intensity for each possible type).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intensity">intensity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  S &lt;- edges(letterR)
  intensity(S)
  intensity(S, weights=runif(nsegments(S)))
  intensity(S, weights=expression((x0+x1)/2))
</code></pre>

<hr>
<h2 id='intensity.quadratcount'>
Intensity Estimates Using Quadrat Counts
</h2><span id='topic+intensity.quadratcount'></span>

<h3>Description</h3>

<p>Uses quadrat count data to estimate the intensity of a point pattern
in each tile of a tessellation, assuming the intensity is constant in
each tile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'quadratcount'
intensity(X, ..., image=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intensity.quadratcount_+3A_x">X</code></td>
<td>

<p>An object of class <code>"quadratcount"</code>.
</p>
</td></tr>
<tr><td><code id="intensity.quadratcount_+3A_image">image</code></td>
<td>

<p>Logical value specifying whether to return
a table of estimated intensities (the default)
or a pixel image of the estimated intensity (<code>image=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="intensity.quadratcount_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine
the resolution of the pixel image, if <code>image=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+intensity">intensity</a></code>.
It computes an estimate of the intensity of a point pattern
from its quadrat counts.
</p>
<p>The argument <code>X</code> should be an object of class
<code>"quadratcount"</code>. It would have been obtained by applying the function
<code><a href="#topic+quadratcount">quadratcount</a></code> to a point pattern
(object of class <code>"ppp"</code>). It contains
the counts of the numbers of points of the point pattern falling in each
tile of a tessellation.
</p>
<p>Using this information, <code>intensity.quadratcount</code>
divides the quadrat counts by the tile areas,
yielding the average density of points per unit area
in each tile of the tessellation.
</p>
<p>If <code>image=FALSE</code> (the default), these intensity values
are returned in a contingency table. Cells of the contingency
table correspond to tiles of the tessellation.
</p>
<p>If <code>image=TRUE</code>, the estimated intensity function is
returned as a pixel image. For each pixel, the pixel value is the
estimated intensity in the tile which contains that pixel.
</p>


<h3>Value</h3>

<p>If <code>image=FALSE</code> (the default), a contingency table.
If <code>image=TRUE</code>, a pixel image (object of class <code>"im"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intensity">intensity</a></code>, 
<code><a href="#topic+quadratcount">quadratcount</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  qa &lt;- quadratcount(swedishpines, 4,3)
  qa
  intensity(qa)
  plot(intensity(qa, image=TRUE))
</code></pre>

<hr>
<h2 id='interp.colourmap'>
Interpolate smoothly between specified colours
</h2><span id='topic+interp.colourmap'></span>

<h3>Description</h3>

<p>Given a colourmap object which maps numbers to colours,
this function interpolates smoothly between the colours,
yielding a new colour map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp.colourmap(m, n = 512)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interp.colourmap_+3A_m">m</code></td>
<td>

<p>A colour map (object of class <code>"colourmap"</code>).
</p>
</td></tr>
<tr><td><code id="interp.colourmap_+3A_n">n</code></td>
<td>

<p>Number of colour steps to be created in the new colour map.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a colourmap object <code>m</code>, which maps numerical values to
colours, this function interpolates the mapping, 
yielding a new colour map.
</p>
<p>This makes it easy to build a colour map that
has smooth gradation between different colours or shades.
First specify a small vector of numbers <code>x</code> which should be mapped to
specific colours <code>y</code>. Use <code>m &lt;- colourmap(y, inputs=x)</code>
to create a colourmap that represents this simple
mapping. Then apply <code>interp.colourmap(m)</code>
to obtain a smooth transition between these points.
</p>


<h3>Value</h3>

<p>Another colour map (object of class <code>"colourmap"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colourmap">colourmap</a></code>, 
<code><a href="#topic+tweak.colourmap">tweak.colourmap</a></code>, 
<code><a href="#topic+colourtools">colourtools</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  co &lt;- colourmap(inputs=c(0, 0.5, 1), c("black", "red", "white"))
  plot(interp.colourmap(co))
</code></pre>

<hr>
<h2 id='interp.im'>Interpolate a Pixel Image</h2><span id='topic+interp.im'></span>

<h3>Description</h3>

<p>Interpolates the values of a pixel image at any
desired location in the frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp.im(Z, x, y=NULL, bilinear=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interp.im_+3A_z">Z</code></td>
<td>

<p>Pixel image (object of class <code>"im"</code>)
with numeric or integer values.
</p>
</td></tr>
<tr><td><code id="interp.im_+3A_x">x</code>, <code id="interp.im_+3A_y">y</code></td>
<td>

<p>Vectors of Cartesian coordinates.
Alternatively <code>x</code> can be a point pattern and <code>y</code> can be missing.
</p>
</td></tr>
<tr><td><code id="interp.im_+3A_bilinear">bilinear</code></td>
<td>

<p>Logical value specifying the choice of interpolation rule.
If <code>bilinear=TRUE</code> then a bilinear interpolation rule is used.
If <code>bilinear=FALSE</code> (the default) then a slightly biased rule
is used; this rule is consistent with earlier versions of
<span class="pkg">spatstat</span>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A value at each location <code>(x[i],y[i])</code> will be
interpolated using the pixel values of <code>Z</code> at the four
surrounding pixel centres, by simple bilinear interpolation.
</p>
<p>At the boundary (where <code>(x[i],y[i])</code> is not surrounded by
four pixel centres) the value at the nearest pixel
is taken.
</p>
<p>The arguments <code>x,y</code> can be anything acceptable to
<code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>.
</p>


<h3>Value</h3>

<p>Vector of interpolated values, with <code>NA</code> for points that lie
outside the domain of the image.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>,
with a contribution from an anonymous user.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   opa &lt;- par(mfrow=c(1,2))
   # coarse image
   V &lt;- as.im(function(x,y) { x^2 + y }, owin(), dimyx=10)
   plot(V, main="coarse image", col=terrain.colors(256))

   # lookup value at location (0.5,0.5)
   V[list(x=0.5,y=0.5)]
   # interpolated value at location (0.5,0.5)
   interp.im(V, 0.5, 0.5)
   interp.im(V, 0.5, 0.5, bilinear=TRUE)
   # true value is 0.75

   # how to obtain an interpolated image at a desired resolution
   U &lt;- as.im(interp.im, W=owin(), Z=V, dimyx=256)
   plot(U, main="interpolated image", col=terrain.colors(256))
   par(opa)
</code></pre>

<hr>
<h2 id='intersect.boxx'>Intersection Of Boxes Of Arbitrary Dimension</h2><span id='topic+intersect.boxx'></span>

<h3>Description</h3>

<p>Yields the intersection of boxes of arbitrary dimension (of class <code>"boxx"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   intersect.boxx(..., fatal=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect.boxx_+3A_...">...</code></td>
<td>

<p>Boxes (of class <code>"boxx"</code>).
</p>
</td></tr>
<tr><td><code id="intersect.boxx_+3A_fatal">fatal</code></td>
<td>
<p>Logical.
Determines what happens if the intersection is empty: If true
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the intersection is empty, then if <code>fatal=FALSE</code>
the result is <code>NULL</code>,
while if <code>fatal=TRUE</code> an error occurs.
</p>


<h3>Value</h3>

<p>A box (object of class <code>"boxx"</code>)
or possibly <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect.owin">intersect.owin</a></code>,
<code><a href="#topic+boxx">boxx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>intersect.boxx(boxx(c(-1,1),c(0,2)), boxx(c(0,3),c(0,1)))
</code></pre>

<hr>
<h2 id='intersect.owin'>Intersection, Union or Set Subtraction of Windows</h2><span id='topic+intersect.owin'></span><span id='topic+union.owin'></span><span id='topic+setminus.owin'></span>

<h3>Description</h3>

<p>Yields the intersection, union or set subtraction of windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   intersect.owin(..., fatal=FALSE, p)
   union.owin(..., p)
   setminus.owin(A, B, ..., p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect.owin_+3A_a">A</code>, <code id="intersect.owin_+3A_b">B</code></td>
<td>
<p>Windows (objects of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="intersect.owin_+3A_...">...</code></td>
<td>

<p>Windows,
or arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
to control the discretisation.
</p>
</td></tr>
<tr><td><code id="intersect.owin_+3A_fatal">fatal</code></td>
<td>
<p>Logical.
Determines what happens if the intersection is empty.
</p>
</td></tr>
<tr><td><code id="intersect.owin_+3A_p">p</code></td>
<td>

<p>Optional list of parameters passed to
<code><a href="polyclip.html#topic+polyclip">polyclip</a></code> to control the
accuracy of polygon geometry.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>intersect.owin</code> computes the intersection between
the windows given in <code>...</code>, while 
<code>union.owin</code> computes their union.
The function <code>setminus.owin</code> computes the intersection of
<code>A</code> with the complement of <code>B</code>.
</p>
<p>For <code>intersect.owin</code> and <code>union.owin</code>, 
the arguments <code>...</code> must be either
</p>

<ul>
<li><p> window objects of class <code>"owin"</code>,
</p>
</li>
<li><p> data that can be coerced to this class by
<code><a href="#topic+as.owin">as.owin</a></code>),
</p>
</li>
<li><p> lists of windows, of class <code>"solist"</code>,
</p>
</li>
<li><p> named arguments of <code><a href="#topic+as.mask">as.mask</a></code> to control
the discretisation if required.
</p>
</li></ul>

<p>For <code>setminus.owin</code>, the arguments <code>...</code>
must be named arguments of <code><a href="#topic+as.mask">as.mask</a></code>.
</p>
<p>If the intersection is empty, then if <code>fatal=FALSE</code>
the result is an empty window or <code>NULL</code>,
while if <code>fatal=TRUE</code> an error occurs.
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>)
or possibly <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.subset.owin">is.subset.owin</a></code>,
<code><a href="#topic+overlap.owin">overlap.owin</a></code>,
<code><a href="#topic+is.empty">is.empty</a></code>,
<code><a href="#topic+boundingbox">boundingbox</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rectangles
   u &lt;- unit.square()
   v &lt;- owin(c(0.5,3.5), c(0.4,2.5))
# polygon
   letterR
# mask
   m &lt;- as.mask(letterR)

# two rectangles
   intersect.owin(u, v) 
   union.owin(u,v)
   setminus.owin(u,v)

# polygon and rectangle
   intersect.owin(letterR, v)
   union.owin(letterR,v)
   setminus.owin(letterR,v)

# mask and rectangle
   intersect.owin(m, v)
   union.owin(m,v)
   setminus.owin(m,v)

# mask and polygon
   p &lt;- rotate(v, 0.2)
   intersect.owin(m, p)
   union.owin(m,p)
   setminus.owin(m,p)

# two polygons
   A &lt;- letterR
   B &lt;- rotate(letterR, 0.2)
   plot(boundingbox(A,B), main="intersection")
   w &lt;- intersect.owin(A, B)
   plot(w, add=TRUE, col="lightblue")
   plot(A, add=TRUE)
   plot(B, add=TRUE)

   plot(boundingbox(A,B), main="union")
   w &lt;- union.owin(A,B)
   plot(w, add=TRUE, col="lightblue")   
   plot(A, add=TRUE)
   plot(B, add=TRUE)

   plot(boundingbox(A,B), main="set minus")
   w &lt;- setminus.owin(A,B)
   plot(w, add=TRUE, col="lightblue")   
   plot(A, add=TRUE)
   plot(B, add=TRUE)

# intersection and union of three windows
   C &lt;- shift(B, c(0.2, 0.3))
   plot(union.owin(A,B,C))
   plot(intersect.owin(A,B,C))
</code></pre>

<hr>
<h2 id='intersect.tess'>Intersection of Two Tessellations</h2><span id='topic+intersect.tess'></span>

<h3>Description</h3>

<p>Yields the intersection of two tessellations,
or the intersection of a tessellation with a window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   intersect.tess(X, Y, ..., keepempty=FALSE, keepmarks=FALSE, sep="x")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect.tess_+3A_x">X</code>, <code id="intersect.tess_+3A_y">Y</code></td>
<td>
<p>Two tessellations (objects of class <code>"tess"</code>),
or windows (objects of class <code>"tess"</code>),
or other data that can be converted to 
tessellations by <code><a href="#topic+as.tess">as.tess</a></code>.
</p>
</td></tr>
<tr><td><code id="intersect.tess_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
to control the discretisation, if required.
</p>
</td></tr>
<tr><td><code id="intersect.tess_+3A_keepempty">keepempty</code></td>
<td>

<p>Logical value specifying whether empty intersections between tiles
should be retained (<code>keepempty=TRUE</code>) or
deleted (<code>keepempty=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="intersect.tess_+3A_keepmarks">keepmarks</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, the marks attached to the
tiles of <code>X</code> and <code>Y</code> will be retained as marks of
the intersection tiles. 
</p>
</td></tr>
<tr><td><code id="intersect.tess_+3A_sep">sep</code></td>
<td>

<p>Character string used to separate the names of tiles from <code>X</code>
and from <code>Y</code>, when forming the name of the tiles of the
intersection.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation is a collection of disjoint spatial regions
(called <em>tiles</em>) that fit together to form a larger spatial
region. See <code><a href="#topic+tess">tess</a></code>.
</p>
<p>If <code>X</code> and <code>Y</code> are not tessellations, they are first
converted into tessellations by <code><a href="#topic+as.tess">as.tess</a></code>.
</p>
<p>The function <code>intersect.tess</code> then computes the intersection between
the two tessellations. This is another tessellation, each of whose
tiles is the intersection of a tile from <code>X</code> and a tile from <code>Y</code>.
</p>
<p>One possible use of this function is to slice a window <code>W</code> into
subwindows determined by a tessellation. See the Examples.
</p>


<h3>Value</h3>

<p>A tessellation (object of class <code>"tess"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+as.tess">as.tess</a></code>,
<code><a href="#topic+intersect.owin">intersect.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  opa &lt;- par(mfrow=c(1,3))
# polygon
  plot(letterR)
# tessellation of rectangles
  X &lt;- tess(xgrid=seq(2, 4, length=10), ygrid=seq(0, 3.5, length=8))
  plot(X)
  plot(intersect.tess(X, letterR))

  A &lt;- runifrect(10)
  B &lt;- runifrect(10)
  plot(DA &lt;- dirichlet(A))
  plot(DB &lt;- dirichlet(B))
  plot(intersect.tess(DA, DB))
  par(opa)

  marks(DA) &lt;- 1:10
  marks(DB) &lt;- 1:10
  plot(Z &lt;- intersect.tess(DA,DB, keepmarks=TRUE))
  mZ &lt;- marks(Z)
  tZ &lt;- tiles(Z)
  for(i in which(mZ[,1] == 3)) plot(tZ[[i]], add=TRUE, col="pink")
</code></pre>

<hr>
<h2 id='invoke.metric'>
Perform Geometric Task using a Specified Metric
</h2><span id='topic+invoke.metric'></span>

<h3>Description</h3>

<p>Perform a desired geometrical operation
using a specified distance metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  invoke.metric(m, task, ..., evaluate=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invoke.metric_+3A_m">m</code></td>
<td>

<p>Metric (object of class <code>"metric"</code>)
</p>
</td></tr>
<tr><td><code id="invoke.metric_+3A_task">task</code></td>
<td>

<p>Character string specifying the task.
The name of a function that performs
the desired operation for the Euclidean metric. 
</p>
</td></tr>
<tr><td><code id="invoke.metric_+3A_...">...</code></td>
<td>

<p>Input to the function that performs the geometrical operation
(matching the arguments of <code>task</code>).
</p>
</td></tr>
<tr><td><code id="invoke.metric_+3A_evaluate">evaluate</code></td>
<td>

<p>Logical value specifying whether to actually perform the
computation and return the result (<code>evaluate=TRUE</code>, the default)
or to simply return the function which performs the computation
(<code>evaluate=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A &lsquo;metric&rsquo; is a measure of distance between points in space.
An object of class <code>"metric"</code> represents such a metric,
and supports many geometrical computations that involve
the metric. See <code><a href="#topic+metric.object">metric.object</a></code>.
</p>
<p>The argument <code>task</code> should be the name of an existing function
in the <span class="pkg">spatstat</span> family representing a geometrical operation, such
as computing pairwise distances, nearest-neighbour distances,
the distance map, and so on. The code will determine whether
this geometrical operation has a counterpart using the specified metric,
that is defined and supported in the object <code>m</code>.
If so, then this operation will be applied to the
data specified in <code>...</code>, and the result will be returned.
</p>
<p>For example, the <span class="pkg">spatstat</span> function <code><a href="#topic+nndist.ppp">nndist.ppp</a></code> computes
nearest-neighbour distances using the Euclidean distance metric.
To calculate nearest-neighbour distances for a point pattern <code>X</code>
using another metric <code>m</code>,
use <code>invoke.metric(m, "nndist.ppp", X)</code>.
</p>
<p>If <code>evaluate=FALSE</code>, the computation is not performed,
and <code>invoke.metric</code> simply returns a function to
perform the desired operation. 
</p>


<h3>Value</h3>

<p>If <code>evaluate=TRUE</code> (the default), the result of the computation has the
same format as the result of the computation using the existing
function named <code>task</code>.
</p>
<p>If <code>evaluate=FALSE</code>, the result is a <code>function</code> in the <span class="rlang"><b>R</b></span> language
to perform the desired operation;
or <code>NULL</code> if the operation is not supported by the metric.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convexmetric">convexmetric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## nearest-neighbour distances using rectangular metric (L^1 metric)
  d &lt;- convexmetric(square(c(-1,1)))
  y &lt;- invoke.metric(d, "nndist.ppp", cells)
  f &lt;- invoke.metric(d, "nndist.ppp", cells, evaluate=FALSE)
  y &lt;- f(cells)
  invoke.metric(d, "orderPizza", evaluate=FALSE)
</code></pre>

<hr>
<h2 id='invoke.symbolmap'>
Plot Data Using Graphics Symbol Map
</h2><span id='topic+invoke.symbolmap'></span>

<h3>Description</h3>

<p>Apply a graphics symbol map to a vector of data values and
plot the resulting symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invoke.symbolmap(map, values, x=NULL, y = NULL, ...,
                 angleref=NULL,
                 add = FALSE,
                 do.plot = TRUE, started = add &amp;&amp; do.plot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invoke.symbolmap_+3A_map">map</code></td>
<td>

<p>Graphics symbol map (object of class <code>"symbolmap"</code>).
</p>
</td></tr>
<tr><td><code id="invoke.symbolmap_+3A_values">values</code></td>
<td>

<p>Vector of data that can be mapped by the symbol map.
</p>
</td></tr>
<tr><td><code id="invoke.symbolmap_+3A_x">x</code>, <code id="invoke.symbolmap_+3A_y">y</code></td>
<td>

<p>Coordinate vectors for the spatial locations of the
symbols to be plotted.
</p>
</td></tr>
<tr><td><code id="invoke.symbolmap_+3A_...">...</code></td>
<td>

<p>Additional graphics parameters (which will be applied to the entire plot).
</p>
</td></tr>
<tr><td><code id="invoke.symbolmap_+3A_angleref">angleref</code></td>
<td>

<p>Optional. Reference angle, or vector of reference angles,
used when plotting some of the symbols. A numeric value or vector
giving angles in degrees between 0 and 360.
</p>
</td></tr>
<tr><td><code id="invoke.symbolmap_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether to add the symbols to
an existing plot (<code>add=TRUE</code>) or to initialise a new
plot (<code>add=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="invoke.symbolmap_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value indicating whether to actually perform the plotting.
</p>
</td></tr>
<tr><td><code id="invoke.symbolmap_+3A_started">started</code></td>
<td>

<p>Logical value indicating whether the plot has already been initialised.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A symbol map is an association between data values and graphical symbols. 
</p>
<p>This command applies the symbol map <code>map</code> to the data 
<code>values</code> and plots the resulting symbols at the locations
given by <code><a href="grDevices.html#topic+xy.coords">xy.coords</a>(x,y)</code>.
</p>


<h3>Value</h3>

<p>(Invisibly) the maximum diameter of the symbols, in user coordinate units.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.symbolmap">plot.symbolmap</a></code> to plot the graphics map itself.
</p>
<p><code><a href="#topic+symbolmap">symbolmap</a></code> to create a graphics map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  g &lt;- symbolmap(range=c(-1,1),
                   shape=function(x) ifelse(x &gt; 0, "circles", "squares"),
                   size=function(x) sqrt(ifelse(x &gt; 0, x/pi, -x))/15,
                   bg=function(x) ifelse(x &gt; 0, "green", "red"))
  plot(square(1), main="")
  a &lt;- invoke.symbolmap(g, runif(10, -1, 1), runifrect(10), add=TRUE)
  a 
</code></pre>

<hr>
<h2 id='is.boxx'>
Recognise a Multi-Dimensional Box
</h2><span id='topic+is.boxx'></span>

<h3>Description</h3>

<p>Checks whether its argument is a multidimensional box
(object of class <code>"boxx"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.boxx(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.boxx_+3A_x">x</code></td>
<td>

<p>Any object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether the object <code>x</code>
is a multidimensional box of class <code>"boxx"</code>.
</p>
<p>The result is determined to be <code>TRUE</code> if <code>x</code>
inherits from <code>"boxx"</code>, i.e. if <code>x</code>
has <code>"boxx"</code> amongst its classes.
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+methods.boxx">methods.boxx</a></code>,
<code><a href="#topic+boxx">boxx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   B &lt;- boxx(c(0,10),c(0,10),c(0,5),c(0,1), unitname="km")
   is.boxx(B)
   is.boxx(42)
</code></pre>

<hr>
<h2 id='is.connected'>
Determine Whether an Object is Connected
</h2><span id='topic+is.connected'></span><span id='topic+is.connected.default'></span>

<h3>Description</h3>

<p>Determine whether an object is 
topologically connected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.connected(X, ...)

## Default S3 method:
is.connected(X, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.connected_+3A_x">X</code></td>
<td>

<p>A spatial object such as a pixel image (object of class <code>"im"</code>),
or a window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="is.connected_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+connected">connected</a></code> to determine the
connected components.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command <code>is.connected(X)</code> returns <code>TRUE</code> if the object
<code>X</code> consists of a single, topologically-connected piece,
and returns <code>FALSE</code> if <code>X</code> consists of several pieces
which are not joined together.
</p>
<p>The function <code>is.connected</code> is generic.
The default method <code>is.connected.default</code> 
works for many classes of objects, including windows (class <code>"owin"</code>)
and images (class <code>"im"</code>).
There is 
a method for point patterns, described in <code><a href="#topic+is.connected.ppp">is.connected.ppp</a></code>.
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connected">connected</a></code>,
<code><a href="#topic+is.connected.ppp">is.connected.ppp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- distmap(cells, dimyx=256)
  X &lt;- levelset(d, 0.07)
  plot(X)
  is.connected(X)
</code></pre>

<hr>
<h2 id='is.connected.ppp'>
Determine Whether a Point Pattern is Connected
</h2><span id='topic+is.connected.ppp'></span>

<h3>Description</h3>

<p>Determine whether a point pattern is topologically connected
when all pairs of points closer than a threshold distance are joined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
is.connected(X, R, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.connected.ppp_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="is.connected.ppp_+3A_r">R</code></td>
<td>

<p>Threshold distance. Pairs of points closer than <code>R</code> units apart
will be joined together.
</p>
</td></tr>
<tr><td><code id="is.connected.ppp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>is.connected</code> is generic. This is the method for
point patterns (objects of class <code>"ppp"</code>).
</p>
<p>The point pattern <code>X</code> is first converted into an abstract graph
by joining every pair of points that lie closer than <code>R</code> units
apart. Then the algorithm determines whether this graph is connected.
</p>
<p>That is, the result of <code>is.connected(X)</code> is <code>TRUE</code>
if any point in <code>X</code> can be reached from any other point,
by a series of steps between points of <code>X</code>,
each step being shorter than <code>R</code> units in length.
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.connected">is.connected</a></code>, 
<code><a href="#topic+connected.ppp">connected.ppp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  is.connected(redwoodfull, 0.1)
  is.connected(redwoodfull, 0.2)
</code></pre>

<hr>
<h2 id='is.convex'>Test Whether a Window is Convex</h2><span id='topic+is.convex'></span>

<h3>Description</h3>

<p>Determines whether a window is convex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.convex(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.convex_+3A_x">x</code></td>
<td>

<p>Window (object of class <code>"owin"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a rectangle, the result is TRUE.
</p>
<p>If <code>x</code> is polygonal, the result is TRUE if <code>x</code> consists of a
single polygon and this polygon is equal to the minimal convex hull
of its vertices computed by <code><a href="grDevices.html#topic+chull">chull</a></code>. 
</p>
<p>If <code>x</code> is a mask, the algorithm first extracts all boundary
pixels of <code>x</code> using <code><a href="#topic+vertices">vertices</a></code>. Then it computes
the (polygonal) convex hull <code class="reqn">K</code> of the boundary pixels.
The result is TRUE if every boundary pixel lies within 
one pixel diameter of an edge of <code class="reqn">K</code>.
</p>


<h3>Value</h3>

<p>Logical value, equal to <code>TRUE</code> if <code>x</code> is convex.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+convexhull.xy">convexhull.xy</a></code>,
<code><a href="#topic+vertices">vertices</a></code>
</p>

<hr>
<h2 id='is.empty'>Test Whether An Object Is Empty</h2><span id='topic+is.empty'></span><span id='topic+is.empty.owin'></span><span id='topic+is.empty.ppp'></span><span id='topic+is.empty.psp'></span><span id='topic+is.empty.default'></span>

<h3>Description</h3>

<p>Checks whether the argument is an empty window,
an empty point pattern, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.empty(x)
## S3 method for class 'owin'
is.empty(x)
## S3 method for class 'ppp'
is.empty(x)
## S3 method for class 'psp'
is.empty(x)
## Default S3 method:
is.empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.empty_+3A_x">x</code></td>
<td>

<p>A window (object of class <code>"owin"</code>),
a point pattern (object of class <code>"ppp"</code>), or
a line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether the object <code>x</code>
represents an empty spatial object, such as an empty window,
a point pattern with zero points, or a line segment pattern
with zero line segments. 
</p>
<p>An empty window can be obtained as the output of
<code><a href="#topic+intersect.owin">intersect.owin</a></code>, <code><a href="#topic+erosion">erosion</a></code>,
<code><a href="#topic+opening">opening</a></code>, <code><a href="#topic+complement.owin">complement.owin</a></code>
and some other operations.
</p>
<p>An empty point pattern or line segment pattern can be
obtained as the result of simulation.
</p>


<h3>Value</h3>

<p>Logical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>

<hr>
<h2 id='is.im'>Test Whether An Object Is A Pixel Image</h2><span id='topic+is.im'></span>

<h3>Description</h3>

<p>Tests whether its argument is a pixel image
(object of class <code>"im"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.im(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.im_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether the argument <code>x</code> is a
pixel image object of class <code>"im"</code>. For details of this
class, see <code><a href="#topic+im.object">im.object</a></code>.
</p>
<p>The object is determined to be an image if it inherits from
class <code>"im"</code>.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a pixel image, otherwise <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>

<hr>
<h2 id='is.linim'>Test Whether an Object is a Pixel Image on a Linear Network</h2><span id='topic+is.linim'></span>

<h3>Description</h3>

<p>Tests whether its argument is a pixel image on a linear network
(object of class <code>"linim"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.linim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.linim_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether the argument <code>x</code> is a
pixel image on a linear network
(object of class <code>"linim"</code>). 
</p>
<p>The object is determined to be an image if it inherits from
class <code>"linim"</code>.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a pixel image on a linear network,
otherwise <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>

<hr>
<h2 id='is.linnet'>Test Whether An Object Is A Linear Network</h2><span id='topic+is.linnet'></span>

<h3>Description</h3>

<p>Checks whether its argument is a linear network
(object of class <code>"linnet"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.linnet(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.linnet_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether the object <code>x</code>
is a linear network (object of class <code>"linnet"</code>). 
</p>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is of class <code>"linnet"</code>,
otherwise <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.  
</p>

<hr>
<h2 id='is.lpp'>Test Whether An Object Is A Point Pattern on a Linear Network</h2><span id='topic+is.lpp'></span>

<h3>Description</h3>

<p>Checks whether its argument is a point pattern
on a linear network
(object of class <code>"lpp"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.lpp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.lpp_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether the object <code>x</code>
is a point pattern object of class <code>"lpp"</code>. 
</p>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a point pattern of class <code>"lpp"</code>,
otherwise <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>

<hr>
<h2 id='is.marked'>Test Whether Marks Are Present</h2><span id='topic+is.marked'></span>

<h3>Description</h3>

<p>Generic function to test whether a given object (usually a point
pattern or something related to a point pattern) has &ldquo;marks&rdquo;
attached to the points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.marked(X, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.marked_+3A_x">X</code></td>
<td>

<p>Object to be inspected
</p>
</td></tr>
<tr><td><code id="is.marked_+3A_...">...</code></td>
<td>

<p>Other arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&ldquo;Marks&rdquo; are observations attached to each point of a point pattern.
For example the <code><a href="spatstat.data.html#topic+longleaf">longleaf</a></code> dataset
contains the locations of trees, each tree being marked by its diameter;
the <code><a href="spatstat.data.html#topic+amacrine">amacrine</a></code> dataset gives the locations of cells
of two types (on/off) and the type of cell may be regarded as a mark attached
to the location of the cell.
</p>
<p>Other objects related to point patterns, such as point process models,
may involve marked points.
</p>
<p>This function tests whether the object <code>X</code>
contains or involves marked points.
It is generic; methods are provided
for point patterns (objects of class <code>"ppp"</code>)
and point process models (objects of class <code>"ppm"</code>).
</p>


<h3>Value</h3>

<p>Logical value, equal to <code>TRUE</code> if <code>X</code> is marked.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.marked.ppp">is.marked.ppp</a></code>,
<code><a href="spatstat.model.html#topic+is.marked.ppm">is.marked.ppm</a></code>
</p>

<hr>
<h2 id='is.marked.ppp'>Test Whether A Point Pattern is Marked</h2><span id='topic+is.marked.ppp'></span>

<h3>Description</h3>

<p>Tests whether a point pattern has &ldquo;marks&rdquo;
attached to the points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
is.marked(X, na.action="warn", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.marked.ppp_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>)
</p>
</td></tr>
<tr><td><code id="is.marked.ppp_+3A_na.action">na.action</code></td>
<td>

<p>String indicating what to do if <code>NA</code> values are
encountered amongst the marks.
Options are <code>"warn"</code>, <code>"fatal"</code> and <code>"ignore"</code>.
</p>
</td></tr>
<tr><td><code id="is.marked.ppp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&ldquo;Marks&rdquo; are observations attached to each point of a point pattern.
For example the <code><a href="spatstat.data.html#topic+longleaf">longleaf</a></code> dataset
contains the locations of trees, each tree being marked by its diameter;
the <code><a href="spatstat.data.html#topic+amacrine">amacrine</a></code> dataset gives the locations of cells
of two types (on/off) and the type of cell may be regarded as a mark attached
to the location of the cell.
</p>
<p>This function tests whether the point pattern <code>X</code>
contains or involves marked points.
It is a method for the generic function <code><a href="#topic+is.marked">is.marked</a></code>.
</p>
<p>The argument <code>na.action</code> determines what action will be taken
if the point pattern has a vector of marks but some or all of the
marks are <code>NA</code>. Options are   <code>"fatal"</code> to cause a fatal
error; <code>"warn"</code> to issue a warning and then return <code>TRUE</code>;
and <code>"ignore"</code> to take no action except returning <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>Logical value, equal to <code>TRUE</code> if <code>X</code> is a marked point pattern.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.marked">is.marked</a></code>,
<code><a href="spatstat.model.html#topic+is.marked.ppm">is.marked.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   is.marked(cells)  #FALSE
   data(longleaf)
   is.marked(longleaf) #TRUE
</code></pre>

<hr>
<h2 id='is.multitype'>Test whether Object is Multitype</h2><span id='topic+is.multitype'></span>

<h3>Description</h3>

<p>Generic function to test whether a given object (usually a point
pattern or something related to a point pattern) has &ldquo;marks&rdquo;
attached to the points which classify the points into several types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.multitype(X, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.multitype_+3A_x">X</code></td>
<td>

<p>Object to be inspected
</p>
</td></tr>
<tr><td><code id="is.multitype_+3A_...">...</code></td>
<td>

<p>Other arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&ldquo;Marks&rdquo; are observations attached to each point of a point pattern.
For example the <code><a href="spatstat.data.html#topic+longleaf">longleaf</a></code> dataset
contains the locations of trees, each tree being marked by its diameter;
the <code><a href="spatstat.data.html#topic+amacrine">amacrine</a></code> dataset gives the locations of cells
of two types (on/off) and the type of cell may be regarded as a mark attached
to the location of the cell.
Other objects related to point patterns, such as point process models,
may involve marked points.
</p>
<p>This function tests whether the object <code>X</code>
contains or involves marked points, <b>and</b> that the
marks are a factor.
</p>
<p>For example, the <code><a href="spatstat.data.html#topic+amacrine">amacrine</a></code>
dataset is multitype (there are two types of cells, on and off),
but the <code><a href="spatstat.data.html#topic+longleaf">longleaf</a></code> dataset is <em>not</em> multitype
(the marks are real numbers).
</p>
<p>This function is generic; methods are provided
for point patterns (objects of class <code>"ppp"</code>)
and point process models (objects of class <code>"ppm"</code>).
</p>


<h3>Value</h3>

<p>Logical value, equal to <code>TRUE</code> if <code>X</code> is multitype.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.multitype.ppp">is.multitype.ppp</a></code>,
<code><a href="spatstat.model.html#topic+is.multitype.ppm">is.multitype.ppm</a></code>
</p>

<hr>
<h2 id='is.multitype.ppp'>Test Whether A Point Pattern is Multitype</h2><span id='topic+is.multitype.ppp'></span>

<h3>Description</h3>

<p>Tests whether a point pattern has &ldquo;marks&rdquo;
attached to the points which classify the points into several types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
is.multitype(X, na.action="warn", ...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.multitype.ppp_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="is.multitype.ppp_+3A_na.action">na.action</code></td>
<td>

<p>String indicating what to do if <code>NA</code> values are
encountered amongst the marks.
Options are <code>"warn"</code>, <code>"fatal"</code> and <code>"ignore"</code>.
</p>
</td></tr>
<tr><td><code id="is.multitype.ppp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&ldquo;Marks&rdquo; are observations attached to each point of a point pattern.
For example the <code><a href="spatstat.data.html#topic+longleaf">longleaf</a></code> dataset
contains the locations of trees, each tree being marked by its diameter;
the <code><a href="spatstat.data.html#topic+amacrine">amacrine</a></code> dataset gives the locations of cells
of two types (on/off) and the type of cell may be regarded as a mark attached
to the location of the cell.
</p>
<p>This function tests whether the point pattern <code>X</code>
contains or involves marked points, <b>and</b> that the
marks are a factor.
It is a method for the generic function <code><a href="#topic+is.multitype">is.multitype</a></code>.
</p>
<p>For example, the <code><a href="spatstat.data.html#topic+amacrine">amacrine</a></code>
dataset is multitype (there are two types of cells, on and off),
but the <code><a href="spatstat.data.html#topic+longleaf">longleaf</a></code> dataset is <em>not</em> multitype
(the marks are real numbers).
</p>
<p>The argument <code>na.action</code> determines what action will be taken
if the point pattern has a vector of marks but some or all of the
marks are <code>NA</code>. Options are   <code>"fatal"</code> to cause a fatal
error; <code>"warn"</code> to issue a warning and then return <code>TRUE</code>;
and <code>"ignore"</code> to take no action except returning <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>Logical value, equal to <code>TRUE</code> if <code>X</code> is a multitype point pattern.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.multitype">is.multitype</a></code>,
<code><a href="spatstat.model.html#topic+is.multitype.ppm">is.multitype.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   is.multitype(cells)  #FALSE - no marks
   is.multitype(longleaf) #FALSE - real valued marks
   is.multitype(amacrine) #TRUE
</code></pre>

<hr>
<h2 id='is.owin'>Test Whether An Object Is A Window</h2><span id='topic+is.owin'></span>

<h3>Description</h3>

<p>Checks whether its argument is a window
(object of class <code>"owin"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.owin(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.owin_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether the object <code>x</code>
is a window object of class
<code>"owin"</code>. See <code><a href="#topic+owin.object">owin.object</a></code> for details
of this class.
</p>
<p>The result is determined to be <code>TRUE</code> if <code>x</code>
inherits from <code>"owin"</code>, i.e. if <code>x</code>
has <code>"owin"</code> amongst its classes.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a point pattern,
otherwise <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>

<hr>
<h2 id='is.ppp'>Test Whether An Object Is A Point Pattern</h2><span id='topic+is.ppp'></span>

<h3>Description</h3>

<p>Checks whether its argument is a point pattern
(object of class <code>"ppp"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ppp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.ppp_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether the object <code>x</code>
is a point pattern object of class
<code>"ppp"</code>. See <code><a href="#topic+ppp.object">ppp.object</a></code> for details
of this class.
</p>
<p>The result is determined to be <code>TRUE</code> if <code>x</code>
inherits from <code>"ppp"</code>, i.e. if <code>x</code>
has <code>"ppp"</code> amongst its classes.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a point pattern,
otherwise <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>

<hr>
<h2 id='is.rectangle'>Determine Type of Window</h2><span id='topic+is.rectangle'></span><span id='topic+is.polygonal'></span><span id='topic+is.mask'></span>

<h3>Description</h3>

<p>Determine whether a window is a
rectangle, a polygonal region, or a binary mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.rectangle(w)
  is.polygonal(w)
  is.mask(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.rectangle_+3A_w">w</code></td>
<td>

<p>Window to be inspected. An object of class <code>"owin"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These simple functions determine whether a window <code>w</code>
(object of class <code>"owin"</code>) is
a rectangle (<code>is.rectangle(w) = TRUE</code>), 
a domain with polygonal boundary (<code>is.polygonal(w) = TRUE</code>),
or 
a binary pixel mask (<code>is.mask(w) = TRUE</code>). 
</p>


<h3>Value</h3>

<p>Logical value, equal to <code>TRUE</code> if <code>w</code> is a window
of the specified type.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>
</p>

<hr>
<h2 id='is.subset.owin'>Determine Whether One Window is Contained In Another</h2><span id='topic+is.subset.owin'></span>

<h3>Description</h3>

<p>Tests whether window <code>A</code> is a subset of window <code>B</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.subset.owin(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.subset.owin_+3A_a">A</code></td>
<td>
<p>A window object (see Details).</p>
</td></tr>
<tr><td><code id="is.subset.owin_+3A_b">B</code></td>
<td>
<p>A window object (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether the window <code>A</code> is a subset
of the window <code>B</code>.
</p>
<p>The arguments <code>A</code> and <code>B</code> must be window objects
(either objects of class <code>"owin"</code>, or data that can be
coerced to this class by <code><a href="#topic+as.owin">as.owin</a></code>).
</p>
<p>Various algorithms are used, depending on the geometrical type
of the two windows.
</p>
<p>Note that if <code>B</code> is not rectangular, the algorithm proceeds by
discretising <code>A</code>, converting it to a pixel mask using 
<code><a href="#topic+as.mask">as.mask</a></code>. In this case the resulting
answer is only &ldquo;approximately correct&rdquo;. The accuracy of the
approximation can be controlled: see <code><a href="#topic+as.mask">as.mask</a></code>.
</p>


<h3>Value</h3>

<p>Logical scalar; <code>TRUE</code> if <code>A</code> is a sub-window of <code>B</code>,
otherwise <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   w1 &lt;- as.owin(c(0,1,0,1))
   w2 &lt;- as.owin(c(-1,2,-1,2))
   is.subset.owin(w1,w2)  # Returns TRUE.
   is.subset.owin(w2,w1)  # Returns FALSE.
</code></pre>

<hr>
<h2 id='layered'>
Create List of Plotting Layers
</h2><span id='topic+layered'></span>

<h3>Description</h3>

<p>Given several objects which are capable of being plotted,
create a list containing these objects as if they were
successive layers of a plot. The list can then be plotted
in different ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layered(..., plotargs = NULL, LayerList=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layered_+3A_...">...</code></td>
<td>

<p>Objects which can be plotted by <code>plot</code>.
</p>
</td></tr>
<tr><td><code id="layered_+3A_plotargs">plotargs</code></td>
<td>

<p>Default values of the plotting arguments for each of the objects.
A list of lists of arguments of the form <code>name=value</code>.
</p>
</td></tr>
<tr><td><code id="layered_+3A_layerlist">LayerList</code></td>
<td>

<p>A list of objects.
Incompatible with <code>...</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Layering is a simple mechanism for controlling
a high-level plot that is composed of
several successive plots, for example, a background and a foreground
plot. The layering mechanism makes it easier to issue the plot command,
to switch on or off the plotting of each individual layer,
to control the plotting arguments that are passed to each layer,
and to zoom in.
</p>
<p>Each individual layer in the plot should be saved as an object
that can be plotted using <code>plot</code>. It will typically belong to
some class, which has a method for the generic function <code>plot</code>.
</p>
<p>The command <code>layered</code> simply saves the objects <code>...</code>
as a list of class <code>"layered"</code>. This list can then be plotted by
the method <code><a href="#topic+plot.layered">plot.layered</a></code>. Thus, you only need to
type a single <code>plot</code> command to produce the multi-layered plot.
Individual layers of the plot can be switched on or off, or
manipulated, using arguments to <code><a href="#topic+plot.layered">plot.layered</a></code>.
</p>
<p>The argument <code>plotargs</code> contains default values of the
plotting arguments for each layer. It should be a list, with one
entry for each object in <code>...</code>. Each entry of  <code>plotargs</code>
should be a list of arguments in the form <code>name=value</code>, which are
recognised by the <code>plot</code> method for the relevant layer.
</p>
<p>The <code>plotargs</code> can also include an argument named <code>.plot</code>
specifying (the name of) a function to perform the plotting
instead of the generic <code>plot</code>.
</p>
<p>The length of <code>plotargs</code> should either be equal to the
number of layers, or equal to 1. In the latter case it will be
replicated to the appropriate length.
</p>


<h3>Value</h3>

<p>A list, belonging to the class <code>"layered"</code>.
There are methods for <code>plot</code>, <code>"["</code>,
<code>"shift"</code>, <code>"affine"</code>, <code>"rotate"</code> and <code>"rescale"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.layered">plot.layered</a></code>,
<code><a href="#topic+methods.layered">methods.layered</a></code>,
<code><a href="#topic+as.layered">as.layered</a></code>,
<code><a href="#topic++5B.layered">[.layered</a></code>,
<code><a href="#topic+layerplotargs">layerplotargs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   D &lt;- distmap(cells)
   L &lt;- layered(D, cells)
   L
   L &lt;- layered(D, cells,
    plotargs=list(list(ribbon=FALSE), list(pch=16)))
   plot(L)

   layerplotargs(L)[[1]] &lt;- list(.plot="contour")
   plot(L)
</code></pre>

<hr>
<h2 id='layerplotargs'>
Extract or Replace the Plot Arguments of a Layered Object
</h2><span id='topic+layerplotargs'></span><span id='topic+layerplotargs+3C-'></span>

<h3>Description</h3>

<p>Extracts or replaces the plot arguments of a layered object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layerplotargs(L)

layerplotargs(L) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layerplotargs_+3A_l">L</code></td>
<td>

<p>An object of class <code>"layered"</code>
created by the function <code><a href="#topic+layered">layered</a></code>.
</p>
</td></tr>
<tr><td><code id="layerplotargs_+3A_value">value</code></td>
<td>

<p>Replacement value. 
A list, with the same length as <code>L</code>,
whose elements are lists of plot arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These commands extract or replace the <code>plotargs</code>
in a layered object. See <code><a href="#topic+layered">layered</a></code>.
</p>
<p>The replacement <code>value</code> should normally have the same
length as the current value. However, it can also be a list with
<em>one</em> element which is a list of parameters. This will be
replicated to the required length.
</p>
<p>For the assignment function <code>layerplotargs&lt;-</code>,
the argument <code>L</code> can be any spatial object; it will be converted
to a <code>layered</code> object with a single layer.
</p>


<h3>Value</h3>

<p><code>layerplotargs</code> returns a list of lists of plot arguments.
</p>
<p><code>"layerplotargs&lt;-"</code> returns the updated object 
of class <code>"layered"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layered">layered</a></code>,
<code><a href="#topic+methods.layered">methods.layered</a></code>,
<code><a href="#topic++5B.layered">[.layered</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   W &lt;- square(2)
   L &lt;- layered(W=W, X=cells)
   ## The following are equivalent
   layerplotargs(L) &lt;- list(list(), list(pch=16))
   layerplotargs(L)[[2]] &lt;- list(pch=16)
   layerplotargs(L)$X &lt;- list(pch=16)

   ## The following are equivalent
   layerplotargs(L) &lt;- list(list(cex=2), list(cex=2))
   layerplotargs(L) &lt;- list(list(cex=2))
</code></pre>

<hr>
<h2 id='layout.boxes'>
Generate a Row or Column Arrangement of Rectangles.
</h2><span id='topic+layout.boxes'></span>

<h3>Description</h3>

<p>A simple utility to generate a row or column of boxes (rectangles)
for use in point-and-click panels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.boxes(B, n, horizontal = FALSE, aspect = 0.5, usefrac = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.boxes_+3A_b">B</code></td>
<td>

<p>Bounding rectangle for the boxes.
An object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="layout.boxes_+3A_n">n</code></td>
<td>

<p>Integer. The number of boxes.
</p>
</td></tr>
<tr><td><code id="layout.boxes_+3A_horizontal">horizontal</code></td>
<td>

<p>Logical. If <code>TRUE</code>, arrange the boxes in a horizontal row.
If <code>FALSE</code> (the default), arrange them in a vertical column.
</p>
</td></tr>
<tr><td><code id="layout.boxes_+3A_aspect">aspect</code></td>
<td>

<p>Aspect ratio (height/width) of each box.
</p>
</td></tr>
<tr><td><code id="layout.boxes_+3A_usefrac">usefrac</code></td>
<td>

<p>Number between 0 and 1. The 
fraction of height or width of <code>B</code> that should be
occupied by boxes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simple utility generates a list of boxes (rectangles)
inside the bounding box <code>B</code> arranged in a regular
row or column. It is useful for generating the
positions of the panel buttons in the function <code><a href="#topic+simplepanel">simplepanel</a></code>.
</p>


<h3>Value</h3>

<p>A list of rectangles.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simplepanel">simplepanel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  B &lt;- owin(c(0,10),c(0,1))
  boxes &lt;- layout.boxes(B, 5, horizontal=TRUE)
  plot(B, main="", col="blue")
  niets &lt;- lapply(boxes, plot, add=TRUE, col="grey")
</code></pre>

<hr>
<h2 id='lengths_psp'>Lengths of Line Segments</h2><span id='topic+lengths_psp'></span>

<h3>Description</h3>

<p>Computes the length of each line segment
in a line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lengths_psp(x, squared=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lengths_psp_+3A_x">x</code></td>
<td>

<p>A line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="lengths_psp_+3A_squared">squared</code></td>
<td>

<p>Logical value indicating whether to return
the squared lengths (<code>squared=TRUE</code>)
or the lengths themselves (<code>squared=FALSE</code>, the default).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The length of each line segment is computed
and the lengths are returned as a numeric vector.
</p>
<p>Using squared lengths may be more efficient for some purposes,
for example, to find the length of the shortest segment,
<code>sqrt(min(lengths.psp(x, squared=TRUE)))</code>
is faster than <code>min(lengths.psp(x))</code>.
</p>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>Change of name</h3>

<p>The name of this function has changed from <code>lengths.psp</code>
to <code>lengths_psp</code>, because the old name <code>lengths.psp</code>
could be misinterpreted as a method for <code><a href="base.html#topic+lengths">lengths</a></code>.
</p>
<p>The older function name <code>lengths.psp</code> is retained temporarily,
for consistency with older code and documentation.
</p>
<p>In future versions of <span class="pkg">spatstat</span>, the 
function name <code>lengths.psp</code> will be removed.
The newer function name <code>lengths_psp</code> should be used.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marks.psp">marks.psp</a></code>,
<code><a href="#topic+summary.psp">summary.psp</a></code>,
<code><a href="#topic+midpoints.psp">midpoints.psp</a></code>,
<code><a href="#topic+angles.psp">angles.psp</a></code>,
<code><a href="#topic+endpoints.psp">endpoints.psp</a></code>,
<code><a href="#topic+extrapolate.psp">extrapolate.psp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  b &lt;- lengths_psp(a)   
</code></pre>

<hr>
<h2 id='levelset'>Level Set of a Pixel Image</h2><span id='topic+levelset'></span>

<h3>Description</h3>

<p>Given a pixel image, find all pixels which have values less than a
specified threshold value (or greater than a threshold, etc),
and assemble these pixels into a window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  levelset(X, thresh, compare="&lt;=")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levelset_+3A_x">X</code></td>
<td>
<p>A pixel image (object of class &quot;im&quot;)</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="levelset_+3A_thresh">thresh</code></td>
<td>
<p>Threshold value.
A single number or value compatible with the pixel values in
<code>X</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="levelset_+3A_compare">compare</code></td>
<td>
<p>Character string specifying one of the comparison
operators <code>"&lt;", "&gt;", "==", "&lt;=", "&gt;=", "!="</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>X</code> is a pixel image with numeric values,
then <code>levelset(X, thresh)</code> finds the region of space
where the pixel values are less than or equal to
the threshold value <code>thresh</code>.
This region is returned as a spatial window.
</p>
<p>The argument <code>compare</code> specifies how the pixel values should be
compared with the threshold value.
Instead of requiring pixel values to be less than or equal to
<code>thresh</code>, you can specify that they must be less than (<code>&lt;</code>),
greater than (<code>&gt;</code>), equal to (<code>==</code>), greater than or equal
to (<code>&gt;=</code>), or not equal to (<code>!=</code>) the threshold value
<code>thresh</code>.
</p>
<p>If <code>X</code> has non-numeric pixel values (for example, logical
or factor values) it is advisable to use only the comparisons
<code>==</code> and <code>!=</code>, unless you really know what you are doing.
</p>
<p>For more complicated logical comparisons, see <code><a href="#topic+solutionset">solutionset</a></code>.
</p>


<h3>Value</h3>

<p>A spatial window (object of class <code>"owin"</code>,
see <code><a href="#topic+owin.object">owin.object</a></code>) containing the pixels satisfying the
constraint.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im.object">im.object</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+solutionset">solutionset</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # test image
  X &lt;- as.im(function(x,y) { x^2 - y^2 }, unit.square())

  W &lt;- levelset(X, 0.2)
  W &lt;- levelset(X, -0.3, "&gt;")

  # compute area of level set
  area(levelset(X, 0.1))
</code></pre>

<hr>
<h2 id='lut'>Lookup Tables</h2><span id='topic+lut'></span>

<h3>Description</h3>

<p>Create a lookup table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lut(outputs, ..., range=NULL, breaks=NULL, inputs=NULL, gamma=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lut_+3A_outputs">outputs</code></td>
<td>
<p>Vector of output values</p>
</td></tr>
<tr><td><code id="lut_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="lut_+3A_range">range</code></td>
<td>

<p>Interval of numbers to be mapped.
A numeric vector of length 2, specifying the ends of the range of values
to be mapped.
Incompatible with <code>breaks</code> or <code>inputs</code>.
</p>
</td></tr>
<tr><td><code id="lut_+3A_inputs">inputs</code></td>
<td>

<p>Input values to which the output values are associated.
A factor or vector of the same length as <code>outputs</code>.
Incompatible with <code>breaks</code> or <code>range</code>.
</p>
</td></tr>
<tr><td><code id="lut_+3A_breaks">breaks</code></td>
<td>

<p>Breakpoints for the lookup table.
A numeric vector of length equal to <code>length(outputs)+1</code>.
Incompatible with <code>range</code> or <code>inputs</code>.
</p>
</td></tr>
<tr><td><code id="lut_+3A_gamma">gamma</code></td>
<td>

<p>Exponent for gamma correction, when <code>range</code> is given.
A single positive number.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A lookup table is a function, mapping input values to output values.
</p>
<p>The command <code>lut</code> creates an object representing
a lookup table, which can then be used to control various behaviour
in the <span class="pkg">spatstat</span> package. It can also be used to compute the
output value assigned to any input value. 
</p>
<p>The argument <code>outputs</code> specifies the output values to which
input data values will be mapped. It should be a vector of
any atomic type (e.g. numeric, logical, character, complex) or factor
values. 
</p>
<p>Exactly one of the arguments <code>range</code>, <code>inputs</code> or <code>breaks</code>
must be specified by name.
</p>

<ul>
<li> 
<p>If <code>inputs</code> is given, then it should be a vector or factor,
of the same length as <code>outputs</code>. The entries of <code>inputs</code> can be
any atomic type (e.g. numeric, logical, character, complex) or factor
values. The resulting lookup table associates the value <code>inputs[i]</code>
with the value <code>outputs[i]</code>.
The argument <code>outputs</code> should have the same length as <code>inputs</code>.
</p>
</li>
<li>
<p>If <code>range</code> is given, then it determines the interval of the real
number line that will be mapped. It should be a numeric vector of
length 2. 
The interval will be divided evenly into bands, each of which is
mapped to an entry of <code>outputs</code>. (If <code>gamma</code> is given,
then the bands are equally spaced on a scale where the original values
are raised to the power <code>gamma</code>.)
</p>
</li>
<li>
<p>If <code>breaks</code> is given, then it determines intervals
of the real number line
which are mapped to each output value. It should be a numeric vector,
of length at least 2, with entries that are in increasing order.
Infinite values are allowed. Any number in the range
between <code>breaks[i]</code> and <code>breaks[i+1]</code> will be mapped to the
value <code>outputs[i]</code>. 
The argument <code>outputs</code> should have length equal to
<code>length(breaks) - 1</code>.
</p>
</li></ul>

<p>It is also permissible for <code>outputs</code> to be a single value,
representing a trivial lookup table in which all data values are mapped to
the same output value.
</p>
<p>The result is an object of class <code>"lut"</code>. 
There is a <code>print</code> method for this class.
Some plot commands in the <span class="pkg">spatstat</span> package accept an object
of this class as a specification of a lookup table.
</p>
<p>The result is also a function <code>f</code> which can be used to compute
the output value assigned to any input data value. 
That is, <code>f(x)</code> returns the output value assigned
to <code>x</code>. This also works for vectors of input data values.
</p>


<h3>Value</h3>

<p>A function, which is also an object of class <code>"lut"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colourmap">colourmap</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # lookup table for real numbers, using breakpoints
  cr &lt;- lut(factor(c("low", "medium", "high")), breaks=c(0,5,10,15))
  cr
  cr(3.2)
  cr(c(3,5,7))
  # lookup table for discrete set of values
  ct &lt;- lut(c(0,1), inputs=c(FALSE, TRUE))
  ct(TRUE)
</code></pre>

<hr>
<h2 id='marks'>Marks of a Point Pattern</h2><span id='topic+marks'></span><span id='topic+marks.ppp'></span><span id='topic+marks.ppx'></span><span id='topic+marks+3C-'></span><span id='topic+marks+3C-.ppp'></span><span id='topic+marks+3C-.ppx'></span><span id='topic+setmarks'></span><span id='topic++25mark+25'></span>

<h3>Description</h3>

<p>Extract or change the marks attached to
a point pattern dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marks(x, ...)

## S3 method for class 'ppp'
marks(x, ..., dfok=TRUE, drop=TRUE)           

## S3 method for class 'ppx'
marks(x, ..., drop=TRUE)

marks(x, ...) &lt;- value

## S3 replacement method for class 'ppp'
marks(x, ..., dfok=TRUE, drop=TRUE) &lt;- value

## S3 replacement method for class 'ppx'
marks(x, ...) &lt;- value

setmarks(x, value)

x %mark% value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marks_+3A_x">x</code></td>
<td>

<p>Point pattern dataset (object of class <code>"ppp"</code> or <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="marks_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="marks_+3A_dfok">dfok</code></td>
<td>

<p>Logical. If <code>FALSE</code>, data frames of marks are not permitted
and will generate an error.
</p>
</td></tr>
<tr><td><code id="marks_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>TRUE</code>, a data frame consisting of a single column
of marks will be converted to a vector or factor.
</p>
</td></tr>
<tr><td><code id="marks_+3A_value">value</code></td>
<td>

<p>Replacement value. A vector, data frame or hyperframe of mark values,
or <code>NULL</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract or change the marks
attached to the points of the point pattern <code>x</code>.
</p>
<p>The expression <code>marks(x)</code> extracts the marks of <code>x</code>.
The assignment <code>marks(x) &lt;- value</code> assigns new marks to the
dataset <code>x</code>, and updates the dataset <code>x</code> in the current
environment. The expression <code>setmarks(x,value)</code>
or equivalently <code>x %mark% value</code> returns a point pattern
obtained by replacing the marks of <code>x</code> by <code>value</code>, but does
not change the dataset <code>x</code> itself.
</p>
<p>For point patterns in two-dimensional space (objects of class
<code>"ppp"</code>) the marks can be a vector, a factor, or a data frame.
</p>
<p>For general point patterns (objects of class &quot;ppx&quot;) the
marks can be a vector, a factor, a data frame or a
hyperframe.
</p>
<p>For the assignment <code>marks(x) &lt;- value</code>, the <code>value</code>
should be a vector or factor of length equal to the number of
points in <code>x</code>, or a data frame or hyperframe with as many rows
as there are points in <code>x</code>. If <code>value</code> is a single value,
or a data frame or hyperframe with one row, then it will be replicated
so that the same marks will be attached to each point.
</p>
<p>To remove marks, use <code>marks(x) &lt;- NULL</code> or
<code><a href="#topic+unmark">unmark</a>(x)</code>.
</p>
<p>Use <code><a href="#topic+ppp">ppp</a></code> or <code><a href="#topic+ppx">ppx</a></code>
to create point patterns in more general
situations.
</p>


<h3>Value</h3>

<p>For <code>marks(x)</code>, the result is a vector, factor, data frame or hyperframe,
containing the mark values attached to the points of <code>x</code>.
</p>
<p>For <code>marks(x) &lt;- value</code>, the result is the updated point pattern
<code>x</code> (with the side-effect that the dataset <code>x</code> is updated in
the current environment).
</p>
<p>For <code>setmarks(x,value)</code> and <code>x %mark% value</code>, the return value
is the point pattern obtained by replacing the
marks of <code>x</code> by <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+ppx">ppx</a></code>,
<code><a href="#topic+unmark">unmark</a></code>,
<code><a href="#topic+hyperframe">hyperframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- amacrine
   # extract marks
   m &lt;- marks(X)
   # recode the mark values "off", "on" as 0, 1
   marks(X) &lt;- as.integer(m == "on")
</code></pre>

<hr>
<h2 id='marks.psp'>Marks of a Line Segment Pattern</h2><span id='topic+marks.psp'></span><span id='topic+marks+3C-.psp'></span>

<h3>Description</h3>

<p>Extract or change the marks attached to
a line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'psp'
marks(x, ..., dfok=TRUE)           
## S3 replacement method for class 'psp'
marks(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marks.psp_+3A_x">x</code></td>
<td>

<p>Line segment pattern dataset (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="marks.psp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="marks.psp_+3A_dfok">dfok</code></td>
<td>

<p>Logical. If <code>FALSE</code>, data frames of marks are not permitted
and will generate an error.
</p>
</td></tr>
<tr><td><code id="marks.psp_+3A_value">value</code></td>
<td>

<p>Vector or data frame of mark values,
or <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract or change the marks
attached to each of the line segments in the pattern <code>x</code>.
They are methods for the generic functions
<code><a href="#topic+marks">marks</a></code> and <code><a href="#topic+marks+3C-">marks&lt;-</a></code>
for the class <code>"psp"</code> of line segment patterns.
</p>
<p>The expression <code>marks(x)</code> extracts the marks of <code>x</code>.
The assignment <code>marks(x) &lt;- value</code> assigns new marks to the
dataset <code>x</code>, and updates the dataset <code>x</code> in the current
environment. 
</p>
<p>The marks can be a vector, a factor, or a data frame.
</p>
<p>For the assignment <code>marks(x) &lt;- value</code>, the <code>value</code>
should be a vector or factor of length equal to the number of
segments in <code>x</code>, or a data frame with as many rows
as there are segments in <code>x</code>. If <code>value</code> is a single value,
or a data frame with one row, then it will be replicated
so that the same marks will be attached to each segment.
</p>
<p>To remove marks, use <code>marks(x) &lt;- NULL</code> or <code>unmark(x)</code>.
</p>


<h3>Value</h3>

<p>For <code>marks(x)</code>, the result is a vector, factor or data frame,
containing the mark values attached to the line segments of <code>x</code>.
If there are no marks, the result is <code>NULL</code>.
</p>
<p>For <code>marks(x) &lt;- value</code>, the result is the updated line segment pattern
<code>x</code> (with the side-effect that the dataset <code>x</code> is updated in
the current environment).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp.object">psp.object</a></code>,
<code><a href="#topic+marks">marks</a></code>,
<code><a href="#topic+marks+3C-">marks&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- data.frame(A=1:10, B=letters[1:10])
  X &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin(), marks=m)

  marks(X) 
  marks(X)[,2]
  marks(X) &lt;- 42
  marks(X) &lt;- NULL
</code></pre>

<hr>
<h2 id='marks.tess'>Marks of a Tessellation</h2><span id='topic+marks.tess'></span><span id='topic+marks+3C-.tess'></span><span id='topic+unmark.tess'></span>

<h3>Description</h3>

<p>Extract or change the marks attached to
the tiles of a tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tess'
marks(x, ...)           

## S3 replacement method for class 'tess'
marks(x, ...) &lt;- value

## S3 method for class 'tess'
unmark(X)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marks.tess_+3A_x">x</code>, <code id="marks.tess_+3A_x">X</code></td>
<td>

<p>Tessellation (object of class <code>"tess"</code>)
</p>
</td></tr>
<tr><td><code id="marks.tess_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="marks.tess_+3A_value">value</code></td>
<td>

<p>Vector or data frame of mark values,
or <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract or change the marks
attached to each of the tiles in the tessellation <code>x</code>.
They are methods for the generic functions
<code><a href="#topic+marks">marks</a></code>, <code><a href="#topic+marks+3C-">marks&lt;-</a></code> and <code><a href="#topic+unmark">unmark</a></code>
for the class <code>"tess"</code> of tessellations
</p>
<p>The expression <code>marks(x)</code> extracts the marks of <code>x</code>.
The assignment <code>marks(x) &lt;- value</code> assigns new marks to the
dataset <code>x</code>, and updates the dataset <code>x</code> in the current
environment. 
</p>
<p>The marks can be a vector, a factor, or a data frame.
</p>
<p>For the assignment <code>marks(x) &lt;- value</code>, the <code>value</code>
should be a vector or factor of length equal to the number of
tiles in <code>x</code>, or a data frame with as many rows
as there are tiles in <code>x</code>. If <code>value</code> is a single value,
or a data frame with one row, then it will be replicated
so that the same marks will be attached to each tile.
</p>
<p>To remove marks, use <code>marks(x) &lt;- NULL</code> or <code>unmark(x)</code>.
</p>


<h3>Value</h3>

<p>For <code>marks(x)</code>, the result is a vector, factor or data frame,
containing the mark values attached to the tiles of <code>x</code>.
If there are no marks, the result is <code>NULL</code>.
</p>
<p>For <code>unmark(x)</code>, the result is the tessellation without marks.
</p>
<p>For <code>marks(x) &lt;- value</code>, the result is the updated tessellation
<code>x</code> (with the side-effect that the dataset <code>x</code> is updated in
the current environment).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marks">marks</a></code>,
<code><a href="#topic+marks+3C-">marks&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  D &lt;- dirichlet(cells)
  marks(D) &lt;- tile.areas(D)

</code></pre>

<hr>
<h2 id='markstat'>Summarise Marks in Every Neighbourhood in a Point Pattern</h2><span id='topic+markstat'></span>

<h3>Description</h3>

<p>Visit each point in a point pattern, find the neighbouring points,
and summarise their marks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   markstat(X, fun, N=NULL, R=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markstat_+3A_x">X</code></td>
<td>

<p>A marked point pattern. 
An object of class <code>"ppp"</code>.
</p>
</td></tr>
<tr><td><code id="markstat_+3A_fun">fun</code></td>
<td>

<p>Function to be applied to the vector of marks.
</p>
</td></tr>
<tr><td><code id="markstat_+3A_n">N</code></td>
<td>

<p>Integer. If this argument is present,
the neighbourhood of a point of <code>X</code> is defined to consist of the
<code>N</code> points of <code>X</code> which are closest to it.
</p>
</td></tr>
<tr><td><code id="markstat_+3A_r">R</code></td>
<td>

<p>Nonnegative numeric value. If this argument is present,
the neighbourhood of a point of <code>X</code> is defined to consist of
all points of <code>X</code> which lie within a distance <code>R</code>
of it.
</p>
</td></tr>
<tr><td><code id="markstat_+3A_...">...</code></td>
<td>

<p>extra arguments passed to the function <code>fun</code>.
They must be given in the form <code>name=value</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm visits each point in the point pattern <code>X</code>,
determines which points of <code>X</code> are &ldquo;neighbours&rdquo; of the current
point, extracts the marks of these neighbouring points,
applies the function <code>fun</code> to the marks,
and collects the value or values returned by <code>fun</code>.
</p>
<p>The definition of &ldquo;neighbours&rdquo; depends on the arguments
<code>N</code> and <code>R</code>, exactly one of which must be given.
</p>
<p>If <code>N</code> is given, then the neighbours of the current
point are the <code>N</code> points of <code>X</code> which are closest to
the current point (including the current point itself).
If <code>R</code> is given, then the neighbourhood of the current point
consists of all points of <code>X</code> which lie closer than a distance <code>R</code>
from the current point.
</p>
<p>Each point of <code>X</code> is visited; the neighbourhood
of the current point is determined; the marks of these points
are extracted as a vector <code>v</code>; then the function 
<code>fun</code> is called as:
</p>
<p><code>fun(v, ...)</code>
</p>
<p>where <code>...</code> are the arguments passed from the call to
<code>markstat</code>.
</p>
<p>The results of each call to <code>fun</code> are collected and returned
according to the usual rules for <code><a href="base.html#topic+apply">apply</a></code> and its
relatives. See the section on <b>Value</b>.
</p>
<p>This function is just a convenient wrapper for a common use of the
function <code><a href="#topic+applynbd">applynbd</a></code>. For more complex tasks,
use <code><a href="#topic+applynbd">applynbd</a></code>. 
To simply tabulate the marks in every <code>R</code>-neighbourhood, use
<code><a href="spatstat.explore.html#topic+marktable">marktable</a></code>.
</p>


<h3>Value</h3>

<p>Similar to the result of <code><a href="base.html#topic+apply">apply</a></code>.
if each call to <code>fun</code> returns a single numeric value,
the result is a vector of dimension <code>npoints(X)</code>, the number of points
in <code>X</code>.
If each call to <code>fun</code> returns a vector of the same length
<code>m</code>, then the result is a matrix of dimensions <code>c(m,n)</code>;
note the transposition of the indices, as usual for the family of
<code>apply</code> functions.
If the calls to <code>fun</code> return vectors of different lengths,
the result is a list of length <code>npoints(X)</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+applynbd">applynbd</a></code>,
<code><a href="spatstat.explore.html#topic+marktable">marktable</a></code>,
<code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="base.html#topic+apply">apply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  trees &lt;- longleaf
  

  # average diameter of 5 closest neighbours of each tree
  md &lt;- markstat(trees, mean, N=5)

  # range of diameters of trees within 10 metre radius
  rd &lt;- markstat(trees, range, R=10)
</code></pre>

<hr>
<h2 id='matchingdist'>Distance for a Point Pattern Matching</h2><span id='topic+matchingdist'></span>

<h3>Description</h3>

<p>Computes the distance associated with a matching between two point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  matchingdist(matching, type = NULL, cutoff = NULL, q = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchingdist_+3A_matching">matching</code></td>
<td>
<p>A point pattern matching (an object of class <code>"pppmatching"</code>).</p>
</td></tr>
<tr><td><code id="matchingdist_+3A_type">type</code></td>
<td>

<p>A character string giving the type of distance to be computed.
One of <code>"spa"</code>, <code>"ace"</code> or <code>"mat"</code>. See details below. 
</p>
</td></tr>
<tr><td><code id="matchingdist_+3A_cutoff">cutoff</code></td>
<td>

<p>The value <code class="reqn">&gt; 0</code> at which interpoint distances are cut off.
</p>
</td></tr>
<tr><td><code id="matchingdist_+3A_q">q</code></td>
<td>

<p>The order of the average that is applied to the interpoint distances.
May be <code>Inf</code>, in which case the maximum of the interpoint distances is taken.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the distance specified by <code>type</code>, <code>cutoff</code>, and <code>order</code>
for a point matching. If any of these arguments are not provided, the function
uses the corresponding elements of <code>matching</code> (if available).
</p>
<p>For the type <code>"spa"</code> (subpattern assignment) it is assumed that the points
of the point pattern with the smaller cardinality <code class="reqn">m</code> are matched to a
<code class="reqn">m</code>-point subpattern of the point pattern with the larger
cardinality <code class="reqn">n</code> in a 1-1 way. The distance
is then given as the <code>q</code>-th order average of the <code class="reqn">m</code> distances between
matched points (minimum of Euclidean distance and <code>cutoff</code>)
and <code class="reqn">n-m</code> &quot;penalty distances&quot; of value <code>cutoff</code>.
</p>
<p>For the type <code>"ace"</code> (assignment only if cardinalities equal) the matching
is assumed to be 1-1 if the cardinalities of the point patterns are
the same, in which case the <code>q</code>-th order average of the matching distances
(minimum of Euclidean distance and <code>cutoff</code>) is taken. If the cardinalities
are different, the matching may be arbitrary and the distance returned is always
equal to <code>cutoff</code>.
</p>
<p>For the type <code>mat</code> (mass transfer) it is assumed that each point of
the point pattern with the smaller cardinality <code class="reqn">m</code> has mass <code class="reqn">1</code>,
each point of the point pattern with the larger cardinality <code class="reqn">n</code>
has mass <code class="reqn">m/n</code>,
and fractions of these masses are matched in such a way that each point
contributes exactly its mass. The distance is then given as the <code>q</code>-th
order weighted average of all distances (minimum of Euclidean distance
and <code>cutoff</code>) of (partially) matched points with weights equal to the
fractional masses divided by <code class="reqn">m</code>.
</p>
<p>If the cardinalities of the two point patterns are equal,
<code>matchingdist(m, type, cutoff, q)</code> yields the same result
no matter if <code>type</code> is <code>"spa"</code>, <code>"ace"</code> or
<code>"mat"</code>.
</p>


<h3>Value</h3>

<p>Numeric value of the distance associated with the matching.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a>, URL <code>http://dominic.schuhmacher.name/</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pppdist">pppdist</a></code>
<code><a href="#topic+pppmatching.object">pppmatching.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # an optimal matching
  X &lt;- runifrect(20)
  Y &lt;- runifrect(20)
  m.opt &lt;- pppdist(X, Y)
  summary(m.opt)
  matchingdist(m.opt)
       # is the same as the distance given by summary(m.opt)
  
  # sequential nearest neighbour matching
  # (go through all points of point pattern X in sequence
  # and match each point with the closest point of Y that is
  # still unmatched)
  am &lt;- matrix(0, 20, 20)
  h &lt;- matrix(c(1:20, rep(0,20)), 20, 2)
  h[1,2] = nncross(X[1],Y)[1,2]
  for (i in 2:20) {
    nn &lt;- nncross(X[i],Y[-h[1:(i-1),2]])[1,2]
    h[i,2] &lt;- ((1:20)[-h[1:(i-1),2]])[nn]
  }
  am[h] &lt;- 1
  m.nn &lt;- pppmatching(X, Y, am)
  matchingdist(m.nn, type="spa", cutoff=1, q=1)
       # is &gt;= the distance obtained for m.opt
       # in most cases strictly &gt;

  opa &lt;- par(mfrow=c(1,2))
  plot(m.opt, main="optimal")
  plot(m.nn,  main="nearest neighbour")
  text(X, 1:20, pos=1, offset=0.3, cex=0.8)
  par(opa)
</code></pre>

<hr>
<h2 id='Math.im'>S3 Group Generic methods for images</h2><span id='topic+Math.im'></span><span id='topic+Ops.im'></span><span id='topic+Complex.im'></span><span id='topic+Summary.im'></span>

<h3>Description</h3>

<p>These are group generic methods for images of class <code>"im"</code>, which
allows for usual mathematical functions and operators to be applied
directly to images. See Details for a list of implemented functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 methods for group generics have prototypes:
Math(x, ...)
Ops(e1, e2)
Complex(z)
Summary(..., na.rm=FALSE, drop=TRUE)




</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Math.im_+3A_x">x</code>, <code id="Math.im_+3A_z">z</code>, <code id="Math.im_+3A_e1">e1</code>, <code id="Math.im_+3A_e2">e2</code></td>
<td>
<p>objects of class <code>"im"</code>.</p>
</td></tr>
<tr><td><code id="Math.im_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="Math.im_+3A_na.rm">na.rm</code>, <code id="Math.im_+3A_drop">drop</code></td>
<td>

<p>Logical values specifying whether missing values
should be removed. This will happen if either
<code>na.rm=TRUE</code> or <code>drop=TRUE</code>. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below is a list of mathematical functions and operators which are
defined for images. Not all functions will make sense for all
types of images. For example, none of the functions in the <code>"Math"</code> group
make sense for character-valued images. Note that the <code>"Ops"</code>
group methods are implemented using <code><a href="#topic+eval.im">eval.im</a></code>, which tries
to harmonise images via <code><a href="#topic+harmonise.im">harmonise.im</a></code> if they aren't
compatible to begin with.
</p>

<ol>
<li><p> Group <code>"Math"</code>:
</p>

<ul>
<li>
<p><code>abs</code>, <code>sign</code>, <code>sqrt</code>,<br />
<code>floor</code>, <code>ceiling</code>, <code>trunc</code>,<br />
<code>round</code>, <code>signif</code>
</p>
</li>
<li>
<p><code>exp</code>, <code>log</code>,  <code>expm1</code>, <code>log1p</code>,<br />
<code>cos</code>, <code>sin</code>, <code>tan</code>,<br />
<code>cospi</code>, <code>sinpi</code>, <code>tanpi</code>,<br />
<code>acos</code>, <code>asin</code>, <code>atan</code>
</p>
<p><code>cosh</code>, <code>sinh</code>, <code>tanh</code>,<br />
<code>acosh</code>, <code>asinh</code>, <code>atanh</code>
</p>
</li>
<li>
<p><code>lgamma</code>, <code>gamma</code>, <code>digamma</code>, <code>trigamma</code>
</p>
</li>
<li> <p><code>cumsum</code>, <code>cumprod</code>, <code>cummax</code>, <code>cummin</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Ops"</code>:
</p>

<ul>
<li>
<p><code>"+"</code>, <code>"-"</code>, <code>"*"</code>, <code>"/"</code>,
<code>"^"</code>, <code>"%%"</code>, <code>"%/%"</code>
</p>
</li>
<li> <p><code>"&amp;"</code>, <code>"|"</code>, <code>"!"</code>
</p>
</li>
<li> <p><code>"=="</code>, <code>"!="</code>,
<code>"&lt;"</code>, <code>"&lt;="</code>, <code>"&gt;="</code>, <code>"&gt;"</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Summary"</code>:
</p>

<ul>
<li> <p><code>all</code>, <code>any</code>
</p>
</li>
<li> <p><code>sum</code>, <code>prod</code>
</p>
</li>
<li> <p><code>min</code>, <code>max</code>
</p>
</li>
<li> <p><code>range</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Complex"</code>:
</p>

<ul>
<li> <p><code>Arg</code>, <code>Conj</code>, <code>Im</code>, <code>Mod</code>, <code>Re</code>
</p>
</li></ul>

</li></ol>

<p>For the <code>Summary</code> group, the generic has an argument
<code>na.rm=FALSE</code>, but for pixel images it makes
sense to set <code>na.rm=TRUE</code> so that pixels outside the domain of
the image are ignored. To enable this, we added the argument
<code>drop</code>. Pixel values that are <code>NA</code> are removed
if <code>drop=TRUE</code> or if <code>na.rm=TRUE</code>.
</p>
<p>For the <code>Ops</code> group, one of the arguments is permitted to be
a single atomic value instead of an image.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Kassel Hingee.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.im">eval.im</a></code> for evaluating expressions involving images.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Convert gradient values to angle of inclination:
  V &lt;- atan(bei.extra$grad) * 180/pi
  ## Make logical image which is TRUE when heat equals 'Moderate': 
  A &lt;- (gorillas.extra$heat == "Moderate")
  ## Summary:
  any(A)
  ## Complex:
  Z &lt;- exp(1 + V * 1i)
  Z
  Re(Z)
</code></pre>

<hr>
<h2 id='Math.imlist'>S3 Group Generic methods for List of Images</h2><span id='topic+Math.imlist'></span><span id='topic+Ops.imlist'></span><span id='topic+Complex.imlist'></span><span id='topic+Summary.imlist'></span>

<h3>Description</h3>

<p>These are group generic methods for the class <code>"imlist"</code>
of lists of images. These methods 
allows the usual mathematical functions and operators to be applied
directly to lists of images. See Details for a list of implemented functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 methods for group generics have prototypes:
Math(x, ...)
Ops(e1, e2)
Complex(z)
Summary(..., na.rm = TRUE)




</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Math.imlist_+3A_x">x</code>, <code id="Math.imlist_+3A_z">z</code>, <code id="Math.imlist_+3A_e1">e1</code>, <code id="Math.imlist_+3A_e2">e2</code></td>
<td>

<p>Lists of pixel images (objects of class <code>"imlist"</code>).
</p>
</td></tr>
<tr><td><code id="Math.imlist_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="Math.imlist_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: should missing values be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"imlist"</code> represents a list of pixel images.
It is a <code>list</code>, whose entries are pixel images
(objects of class <code>"im"</code>).
</p>
<p>The following mathematical functions and operators are
defined for lists of images.
</p>
<p>Not all functions will make sense for all
types of images. For example, none of the functions in the <code>"Math"</code> group
make sense for character-valued images. Note that the <code>"Ops"</code>
group methods are implemented using <code><a href="#topic+eval.im">eval.im</a></code>, which tries
to harmonise images via <code><a href="#topic+harmonise.im">harmonise.im</a></code> if they aren't
compatible to begin with.
</p>

<ol>
<li><p> Group <code>"Math"</code>:
</p>

<ul>
<li>
<p><code>abs</code>, <code>sign</code>, <code>sqrt</code>,<br />
<code>floor</code>, <code>ceiling</code>, <code>trunc</code>,<br />
<code>round</code>, <code>signif</code>
</p>
</li>
<li>
<p><code>exp</code>, <code>log</code>,  <code>expm1</code>, <code>log1p</code>,<br />
<code>cos</code>, <code>sin</code>, <code>tan</code>,<br />
<code>cospi</code>, <code>sinpi</code>, <code>tanpi</code>,<br />
<code>acos</code>, <code>asin</code>, <code>atan</code>
</p>
<p><code>cosh</code>, <code>sinh</code>, <code>tanh</code>,<br />
<code>acosh</code>, <code>asinh</code>, <code>atanh</code>
</p>
</li>
<li>
<p><code>lgamma</code>, <code>gamma</code>, <code>digamma</code>, <code>trigamma</code>
</p>
</li>
<li> <p><code>cumsum</code>, <code>cumprod</code>, <code>cummax</code>, <code>cummin</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Ops"</code>:
</p>

<ul>
<li>
<p><code>"+"</code>, <code>"-"</code>, <code>"*"</code>, <code>"/"</code>,
<code>"^"</code>, <code>"%%"</code>, <code>"%/%"</code>
</p>
</li>
<li> <p><code>"&amp;"</code>, <code>"|"</code>, <code>"!"</code>
</p>
</li>
<li> <p><code>"=="</code>, <code>"!="</code>,
<code>"&lt;"</code>, <code>"&lt;="</code>, <code>"&gt;="</code>, <code>"&gt;"</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Summary"</code>:
</p>

<ul>
<li> <p><code>all</code>, <code>any</code>
</p>
</li>
<li> <p><code>sum</code>, <code>prod</code>
</p>
</li>
<li> <p><code>min</code>, <code>max</code>
</p>
</li>
<li> <p><code>range</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Complex"</code>:
</p>

<ul>
<li> <p><code>Arg</code>, <code>Conj</code>, <code>Im</code>, <code>Mod</code>, <code>Re</code>
</p>
</li></ul>

</li></ol>

<p>For the binary operations in <code>"Ops"</code>,
either
</p>

<ul>
<li> <p><code>e1</code> and <code>e2</code> are lists of pixel images,
and contain the same number of images.


</p>
</li>
<li><p> one of <code>e1,e2</code> is a list of pixel images,
and the other is a single atomic value.
</p>
</li></ul>



<h3>Value</h3>

<p>The result of <code>"Math"</code>, <code>"Ops"</code> and <code>"Complex"</code> group
operations is another list of images.
The result of <code>"Summary"</code> group operations is a numeric vector of
length 1 or 2.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Math.im">Math.im</a></code> or <code><a href="#topic+eval.im">eval.im</a></code>
for evaluating expressions involving images.
<code><a href="#topic+solapply">solapply</a></code> for a wrapper for <code><a href="base.html#topic+lapply">lapply</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- solist(A=setcov(square(1)), B=setcov(square(2)))
  log(a)/2 - sqrt(a)
  range(a)
</code></pre>

<hr>
<h2 id='maxnndist'>
Compute Minimum or Maximum Nearest-Neighbour Distance
</h2><span id='topic+maxnndist'></span><span id='topic+minnndist'></span>

<h3>Description</h3>

<p>A faster way to compute the minimum or maximum
nearest-neighbour distance in a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minnndist(X, positive=FALSE, by=NULL)
maxnndist(X, positive=FALSE, by=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxnndist_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="maxnndist_+3A_positive">positive</code></td>
<td>

<p>Logical. If <code>FALSE</code> (the default), compute the usual
nearest-neighbour distance.
If <code>TRUE</code>, ignore coincident points, so that the
nearest neighbour distance for each point is greater than zero.
</p>
</td></tr>
<tr><td><code id="maxnndist_+3A_by">by</code></td>
<td>

<p>Optional. A factor, which separates <code>X</code> into groups.
The algorithm will compute the distance to
the nearest point in each group. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions find the minimum and maximum values
of nearest-neighbour distances in the point pattern <code>X</code>.
<code>minnndist(X)</code> and <code>maxnndist(X)</code> are 
equivalent to, but faster than, <code>min(nndist(X))</code>
and <code>max(nndist(X))</code> respectively.
</p>
<p>The value is <code>NA</code> if <code>npoints(X) &lt; 2</code>.
</p>


<h3>Value</h3>

<p>A single numeric value (possibly <code>NA</code>).
</p>
<p>If <code>by</code> is given, the result is a numeric matrix
giving the minimum or maximum nearest neighbour distance
between each subset of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndist">nndist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  min(nndist(swedishpines))
  minnndist(swedishpines)

  max(nndist(swedishpines))
  maxnndist(swedishpines)

  minnndist(lansing, positive=TRUE)

  if(interactive()) {
     X &lt;- runifrect(1e6)
     system.time(min(nndist(X)))
     system.time(minnndist(X))
  }

  minnndist(amacrine, by=marks(amacrine))
  maxnndist(amacrine, by=marks(amacrine))
</code></pre>

<hr>
<h2 id='mean.ewcdf'>Mean of Empirical Cumulative Distribution Function</h2><span id='topic+mean.ewcdf'></span><span id='topic+mean.ecdf'></span>

<h3>Description</h3>

<p>Calculates the mean of a (weighted or unweighted)
empirical cumulative distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ecdf'
mean(x, trim=0, ...)

## S3 method for class 'ewcdf'
mean(x, trim=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.ewcdf_+3A_x">x</code></td>
<td>

<p>An empirical cumulative distribution function
(object of class <code>"ecdf"</code> created by <code><a href="stats.html#topic+ecdf">ecdf</a></code>)
or a weighted empirical cumulative distribution function
(object of class <code>"ewcdf"</code> created by <code><a href="#topic+ewcdf">ewcdf</a></code>).
</p>
</td></tr>
<tr><td><code id="mean.ewcdf_+3A_trim">trim</code></td>
<td>

<p>The fraction (0 to 0.5) of data values to be trimmed from
each end of their range, before the mean is computed.
</p>
</td></tr>
<tr><td><code id="mean.ewcdf_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic
<code><a href="base.html#topic+mean">mean</a></code> 
for the classes <code>"ecdf"</code> and <code>"ewcdf"</code>.
</p>
<p>They calculate the mean of the probability distribution
corresponding to the cumulative distribution function <code>x</code>.
This is equivalent to calculating the (weighted or unweighted)
mean of the original data values.
</p>
<p>For <em>weighted</em> empirical cumulative distribution functions
(class <code>"ewcdf"</code>) the weights will first be normalised so that they
sum to 1. The result of <code>mean.ewcdf</code>
is always an average or weighted average or the original data values.
The argument <code>trim</code> is interpreted as a probability
under this normalised distribution; the corresponding
quantiles are computed, and data outside these quantiles is deleted
before calculating the weighted mean.
</p>


<h3>Value</h3>

<p>A single number.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>Generic <code><a href="base.html#topic+mean">mean</a></code> and
<code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>.
</p>
<p><code><a href="stats.html#topic+ecdf">ecdf</a></code>, <code><a href="#topic+ewcdf">ewcdf</a></code>
to create the cumulative distribution functions.
</p>
<p><code><a href="spatstat.explore.html#topic+stieltjes">stieltjes</a></code> for integration with respect to
a cumulative distribution function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- 1:5
  mean(x)
  mean(ecdf(x))
  w &lt;- 1:5
  mean(ewcdf(x, w))
</code></pre>

<hr>
<h2 id='mean.im'>Mean and Median of Pixel Values in an Image</h2><span id='topic+mean.im'></span><span id='topic+median.im'></span>

<h3>Description</h3>

<p>Calculates the mean or median
of the pixel values in a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im'
## mean(x, trim=0, na.rm=TRUE, ...) 

## S3 method for class 'im'
## median(x, na.rm=TRUE)        [R &lt; 3.4.0]
## median(x, na.rm=TRUE, ...)   [R &gt;= 3.4.0]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.im_+3A_x">x</code></td>
<td>
<p>A pixel image (object of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="mean.im_+3A_na.rm">na.rm</code></td>
<td>

<p>Logical value indicating whether <code>NA</code> values should be
stripped before the computation proceeds.
</p>
</td></tr>
<tr><td><code id="mean.im_+3A_trim">trim</code></td>
<td>

<p>The fraction (0 to 0.5) of pixel values to be trimmed from
each end of their range, before the mean is computed.
</p>
</td></tr>
<tr><td><code id="mean.im_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions calculate the mean and median
of the pixel values in the image <code>x</code>.
</p>
<p>An object of class <code>"im"</code>
describes a pixel image. See <code><a href="#topic+im.object">im.object</a></code>)
for details of this class.
</p>
<p>The function <code>mean.im</code> is a method for the generic
function <code><a href="base.html#topic+mean">mean</a></code> for the class <code>"im"</code>.
Similarly <code>median.im</code> is a method for the generic
<code><a href="stats.html#topic+median">median</a></code>.
</p>
<p>If the image <code>x</code> is logical-valued, the mean value of <code>x</code> is
the fraction of pixels that have the value <code>TRUE</code>. The median is
not defined. 
</p>
<p>If the image <code>x</code> is factor-valued, then the mean of <code>x</code>
is the mean of the integer codes of the pixel values. The median is
are not defined.
</p>
<p>Other mathematical operations on images are supported by
<code><a href="#topic+Math.im">Math.im</a></code>, <code><a href="#topic+Summary.im">Summary.im</a></code>
and <code><a href="#topic+Complex.im">Complex.im</a></code>.
</p>
<p>Other information about an image can be obtained using
<code><a href="#topic+summary.im">summary.im</a></code> or <code><a href="#topic+quantile.im">quantile.im</a></code>.
</p>


<h3>Value</h3>

<p>A single number.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Kassel Hingee.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Math.im">Math.im</a></code> for other operations.
</p>
<p>Generics and default methods:
<code><a href="base.html#topic+mean">mean</a></code>,
<code><a href="stats.html#topic+median">median</a></code>.
</p>
<p><code><a href="#topic+quantile.im">quantile.im</a></code>,
<code><a href="#topic+anyNA.im">anyNA.im</a></code>,
<code><a href="#topic+im.object">im.object</a></code>,
<code><a href="#topic+summary.im">summary.im</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- as.im(function(x,y) {x^2}, unit.square())
  mean(X)
  median(X)
  mean(X, trim=0.05)
</code></pre>

<hr>
<h2 id='mergeLevels'>
Merge Levels of a Factor
</h2><span id='topic+mergeLevels'></span>

<h3>Description</h3>

<p>Specified levels of the factor will be merged into a single level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeLevels(.f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeLevels_+3A_.f">.f</code></td>
<td>

<p>A factor (or a factor-valued pixel image
or a point pattern with factor-valued marks).
</p>
</td></tr>
<tr><td><code id="mergeLevels_+3A_...">...</code></td>
<td>

<p>List of <code>name=value</code> pairs, where <code>name</code> is the
new merged level, and <code>value</code> is the vector of old
levels that will be merged.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility function takes a factor <code>.f</code>
and merges specified levels of the factor.
</p>
<p>The grouping is specified by the arguments <code>...</code>
which must each be given in the form <code>new=old</code>, where
<code>new</code> is the name for the new merged level,
and <code>old</code> is a character vector containing the old levels
that are to be merged.
</p>
<p>The result is a new factor (or factor-valued object),
in which the levels listed in <code>old</code>
have been replaced by a single level <code>new</code>.
</p>
<p>An argument of the form <code>name=character(0)</code> or <code>name=NULL</code>
is interpreted to mean that all other levels of the old factor
should be mapped to <code>name</code>.
</p>


<h3>Value</h3>

<p>Another factor of the same length as <code>.f</code>
(or object of the same kind as <code>.f</code>).
</p>


<h3>Tips for manipulating factor levels</h3>

<p>To remove unused levels from a factor <code>f</code>,
just type <code>f &lt;- factor(f)</code>.
</p>
<p>To change the ordering of levels in a factor,
use <code><a href="base.html#topic+factor">factor</a>(f, levels=l)</code> or
<code><a href="stats.html#topic+relevel">relevel</a>(f, ref)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+factor">factor</a></code>,
<code><a href="stats.html#topic+relevel">relevel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   likert &lt;- c("Strongly Agree", "Agree", "Neutral",
               "Disagree", "Strongly Disagree")
   answers &lt;- factor(sample(likert, 15, replace=TRUE), levels=likert)
   answers
   mergeLevels(answers, Positive=c("Strongly Agree", "Agree"),
                        Negative=c("Strongly Disagree", "Disagree"))
</code></pre>

<hr>
<h2 id='methods.box3'>
Methods for Three-Dimensional Box
</h2><span id='topic+methods.box3'></span><span id='topic+print.box3'></span><span id='topic+unitname.box3'></span><span id='topic+unitname+3C-.box3'></span>

<h3>Description</h3>

<p>Methods for class <code>"box3"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'box3'
print(x, ...)
  ## S3 method for class 'box3'
unitname(x) 
  ## S3 replacement method for class 'box3'
unitname(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.box3_+3A_x">x</code></td>
<td>

<p>Object of class <code>"box3"</code> representing a three-dimensional box.
</p>
</td></tr>
<tr><td><code id="methods.box3_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code>print.default</code>.
</p>
</td></tr>
<tr><td><code id="methods.box3_+3A_value">value</code></td>
<td>

<p>Name of the unit of length. See <code><a href="#topic+unitname">unitname</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="base.html#topic+print">print</a></code> and <code><a href="#topic+unitname">unitname</a></code>
for the class <code>"box3"</code> of three-dimensional boxes.
</p>
<p>The <code>print</code> method prints a description of the box,
while the <code>unitname</code> method extracts the name of the unit of
length in which the box coordinates are expressed.
</p>


<h3>Value</h3>

<p>For <code>print.box3</code> the value is <code>NULL</code>.
For <code>unitname.box3</code> an object of class <code>"units"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+box3">box3</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="#topic+unitname">unitname</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- box3(c(0,10),c(0,10),c(0,5), unitname=c("metre", "metres"))
   X
   unitname(X)
   # Northern European usage
   unitname(X) &lt;- "meter"
</code></pre>

<hr>
<h2 id='methods.boxx'>
Methods for Multi-Dimensional Box
</h2><span id='topic+methods.boxx'></span><span id='topic+print.boxx'></span><span id='topic+unitname.boxx'></span><span id='topic+unitname+3C-.boxx'></span><span id='topic+scale.boxx'></span>

<h3>Description</h3>

<p>Methods for class <code>"boxx"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'boxx'
print(x, ...)
  ## S3 method for class 'boxx'
unitname(x)
  ## S3 replacement method for class 'boxx'
unitname(x) &lt;- value
  ## S3 method for class 'boxx'
scale(x, center=TRUE, scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.boxx_+3A_x">x</code></td>
<td>

<p>Object of class <code>"boxx"</code> representing a multi-dimensional box.
</p>
</td></tr>
<tr><td><code id="methods.boxx_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code>print.default</code>.
</p>
</td></tr>
<tr><td><code id="methods.boxx_+3A_value">value</code></td>
<td>

<p>Name of the unit of length. See <code><a href="#topic+unitname">unitname</a></code>.
</p>
</td></tr>
<tr><td><code id="methods.boxx_+3A_center">center</code>, <code id="methods.boxx_+3A_scale">scale</code></td>
<td>

<p>Arguments passed to <code><a href="base.html#topic+scale.default">scale.default</a></code>
to determine the rescaling.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+unitname">unitname</a></code>,
<code><a href="#topic+unitname+3C-">unitname&lt;-</a></code> and <code><a href="base.html#topic+scale">scale</a></code>
for the class <code>"boxx"</code> of multi-dimensional boxes.
</p>
<p>The 
<code>print</code> method prints a description of the box,
the <code>unitname</code> method extracts the name of the unit of
length in which the box coordinates are expressed, while the assignment method
for <code>unitname</code> assigns this unit name.
</p>
<p>The <code>scale</code> method rescales each spatial coordinate of <code>x</code>.
</p>


<h3>Value</h3>

<p>For <code>print.boxx</code> the value is <code>NULL</code>.
For <code>unitname.boxx</code> an object of class <code>"units"</code>.
For <code>unitname&lt;-.boxx</code> and
<code>scale.boxx</code> the result is the updated <code>"boxx"</code> object <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxx">boxx</a></code>,
<code><a href="#topic+is.boxx">is.boxx</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="#topic+unitname">unitname</a></code>,
<code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   B &lt;- boxx(c(0,10),c(0,10),c(0,5),c(0,1), unitname=c("metre", "metres"))
   B
   is.boxx(B)
   unitname(B)
   # Northern European usage
   unitname(B) &lt;- "meter"
   scale(B)
</code></pre>

<hr>
<h2 id='methods.distfun'>
Geometrical Operations for Distance Functions
</h2><span id='topic+methods.distfun'></span><span id='topic+shift.distfun'></span><span id='topic+rotate.distfun'></span><span id='topic+scalardilate.distfun'></span><span id='topic+affine.distfun'></span><span id='topic+flipxy.distfun'></span><span id='topic+reflect.distfun'></span><span id='topic+rescale.distfun'></span>

<h3>Description</h3>

<p>Methods for objects of the class <code>"distfun"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'distfun'
shift(X, ...)

## S3 method for class 'distfun'
rotate(X, ...)

## S3 method for class 'distfun'
scalardilate(X, ...)

## S3 method for class 'distfun'
affine(X, ...)

## S3 method for class 'distfun'
flipxy(X)

## S3 method for class 'distfun'
reflect(X)

## S3 method for class 'distfun'
rescale(X, s, unitname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.distfun_+3A_x">X</code></td>
<td>

<p>Object of class <code>"distfun"</code> representing the distance function
of a spatial object.
</p>
</td></tr>
<tr><td><code id="methods.distfun_+3A_...">...</code></td>
<td>

<p>Arguments passed to the next method for the geometrical operation.
See Details.
</p>
</td></tr>
<tr><td><code id="methods.distfun_+3A_s">s</code>, <code id="methods.distfun_+3A_unitname">unitname</code></td>
<td>

<p>Arguments passed to the next method for <code><a href="#topic+rescale">rescale</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="#topic+shift">shift</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+scalardilate">scalardilate</a></code>,
<code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+flipxy">flipxy</a></code> and <code><a href="#topic+reflect">reflect</a></code>
which perform geometrical operations on spatial objects,
and for the generic <code><a href="#topic+rescale">rescale</a></code> which changes the unit of length.
</p>
<p>The argument <code>X</code> should be an object of class <code>"distfun"</code>
representing the distance function of a spatial object <code>Y</code>.
Objects of class <code>"distfun"</code> are created by <code><a href="#topic+distfun">distfun</a></code>.
</p>
<p>The methods apply the specified geometrical transformation to
the original object <code>Y</code>, producing a new object <code>Z</code>
of the same type as <code>Y</code>. They then create a new <code>distfun</code>
object representing the distance function of <code>Z</code>.
</p>


<h3>Value</h3>

<p>Another object of class <code>"distfun"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distfun">distfun</a></code>,
<code><a href="#topic+methods.funxy">methods.funxy</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   (f &lt;- distfun(letterR))
   plot(f)
   flipxy(f)
   shift(f, origin="midpoint")
   plot(rotate(f, angle=pi/2))

   (g &lt;- distfun(lansing))
   rescale(g)
</code></pre>

<hr>
<h2 id='methods.funxy'>
Methods for Spatial Functions
</h2><span id='topic+methods.funxy'></span><span id='topic+contour.funxy'></span><span id='topic+persp.funxy'></span><span id='topic+plot.funxy'></span>

<h3>Description</h3>

<p>Methods for objects of the class <code>"funxy"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funxy'
contour(x, ...)
## S3 method for class 'funxy'
persp(x, ...)
## S3 method for class 'funxy'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.funxy_+3A_x">x</code></td>
<td>

<p>Object of class <code>"funxy"</code> representing a
function of <code class="reqn">x,y</code> coordinates.
</p>
</td></tr>
<tr><td><code id="methods.funxy_+3A_...">...</code></td>
<td>

<p>Named arguments controlling the plot. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="graphics.html#topic+contour">contour</a></code>
and <code><a href="graphics.html#topic+persp">persp</a></code>
for the class <code>"funxy"</code> of spatial functions.
</p>
<p>Objects of class <code>"funxy"</code> are created, for example,
by the commands <code><a href="#topic+distfun">distfun</a></code> and <code><a href="#topic+funxy">funxy</a></code>.
</p>
<p>The <code>plot</code>, <code>contour</code> and <code>persp</code> methods first convert
<code>x</code> to a pixel image object using <code><a href="#topic+as.im">as.im</a></code>,
then display it using <code><a href="#topic+plot.im">plot.im</a></code>, <code><a href="#topic+contour.im">contour.im</a></code> or
<code><a href="#topic+persp.im">persp.im</a></code>.
</p>
<p>Additional arguments <code>...</code> are either
passed to <code><a href="#topic+as.im.function">as.im.function</a></code> to
control the spatial resolution of the pixel image, or passed to 
<code><a href="#topic+contour.im">contour.im</a></code>,
<code><a href="#topic+persp.im">persp.im</a></code> or 
<code><a href="#topic+plot.im">plot.im</a></code> to control the appearance of the plot. 
</p>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funxy">funxy</a></code>,
<code><a href="#topic+distfun">distfun</a></code>,
<code><a href="#topic+as.im">as.im</a></code>,
<code><a href="#topic+plot.im">plot.im</a></code>,
<code><a href="#topic+persp.im">persp.im</a></code>,
<code><a href="#topic+contour.im">contour.im</a></code>,
<code><a href="#topic+spatstat.options">spatstat.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   f &lt;- distfun(letterR)
   contour(f)
   B &lt;- owin(c(1,5), c(-1, 4))
   contour(f, W=B)
   persp(f, W=B, theta=40, phi=40, border=NA, shade=0.7)
</code></pre>

<hr>
<h2 id='methods.layered'>
Methods for Layered Objects
</h2><span id='topic+methods.layered'></span><span id='topic+shift.layered'></span><span id='topic+reflect.layered'></span><span id='topic+flipxy.layered'></span><span id='topic+rotate.layered'></span><span id='topic+affine.layered'></span><span id='topic+rescale.layered'></span><span id='topic+scalardilate.layered'></span>

<h3>Description</h3>

<p>Methods for geometrical transformations of
layered objects (class <code>"layered"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'layered'
shift(X, vec=c(0,0), ...)

  ## S3 method for class 'layered'
rotate(X, ..., centre=NULL)

  ## S3 method for class 'layered'
affine(X, ...)

  ## S3 method for class 'layered'
reflect(X)

  ## S3 method for class 'layered'
flipxy(X)

  ## S3 method for class 'layered'
rescale(X, s, unitname)

  ## S3 method for class 'layered'
scalardilate(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.layered_+3A_x">X</code></td>
<td>

<p>Object of class <code>"layered"</code>.
</p>
</td></tr>
<tr><td><code id="methods.layered_+3A_...">...</code></td>
<td>

<p>Arguments passed to the relevant methods
when applying the operation to each layer of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="methods.layered_+3A_s">s</code></td>
<td>

<p>Rescaling factor passed to the relevant method for
<code><a href="#topic+rescale">rescale</a></code>. May be missing.
</p>
</td></tr>
<tr><td><code id="methods.layered_+3A_vec">vec</code></td>
<td>

<p>Shift vector (numeric vector of length 2).
</p>
</td></tr>
<tr><td><code id="methods.layered_+3A_centre">centre</code></td>
<td>

<p>Centre of rotation.
Either a vector of length 2, or a character string
(partially matched to <code>"centroid"</code>, <code>"midpoint"</code>
or <code>"bottomleft"</code>).
The default is the coordinate origin <code>c(0,0)</code>.
</p>
</td></tr>
<tr><td><code id="methods.layered_+3A_unitname">unitname</code></td>
<td>

<p>Optional. New name for the unit of length.
A value acceptable to the function <code><a href="#topic+unitname+3C-">unitname&lt;-</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="#topic+shift">shift</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+reflect">reflect</a></code>,
<code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+rescale">rescale</a></code>,
<code><a href="#topic+scalardilate">scalardilate</a></code> and
<code><a href="#topic+flipxy">flipxy</a></code>
for the class of layered objects.
</p>
<p>A layered object represents data that should be plotted in
successive layers, for example, a background and a foreground.
See <code><a href="#topic+layered">layered</a></code>.
</p>


<h3>Value</h3>

<p>Another object of class <code>"layered"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layered">layered</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  B &lt;- owin(c(5500, 9000), c(2500, 7400))
  L &lt;- layered(Window(demopat), unmark(demopat)[B])
  plot(L)
  plot(rotate(L, pi/4))
</code></pre>

<hr>
<h2 id='methods.pp3'>
Methods for three-dimensional point patterns
</h2><span id='topic+methods.pp3'></span><span id='topic+print.pp3'></span><span id='topic+summary.pp3'></span><span id='topic+print.summary.pp3'></span><span id='topic+unitname.pp3'></span><span id='topic+unitname+3C-.pp3'></span>

<h3>Description</h3>

<p>Methods for class <code>"pp3"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'pp3'
print(x, ...)
  ## S3 method for class 'summary.pp3'
print(x, ...)
  ## S3 method for class 'pp3'
summary(object, ...)
  ## S3 method for class 'pp3'
unitname(x)
  ## S3 replacement method for class 'pp3'
unitname(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.pp3_+3A_x">x</code>, <code id="methods.pp3_+3A_object">object</code></td>
<td>

<p>Object of class <code>"pp3"</code>.
</p>
</td></tr>
<tr><td><code id="methods.pp3_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="methods.pp3_+3A_value">value</code></td>
<td>

<p>Name of the unit of length. See <code><a href="#topic+unitname">unitname</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="#topic+unitname">unitname</a></code> and  <code><a href="#topic+unitname+3C-">unitname&lt;-</a></code>
for the class <code>"pp3"</code> of three-dimensional point patterns.
</p>
<p>The <code>print</code> and <code>summary</code> methods print a description
of the point pattern.
</p>
<p>The <code>unitname</code> method extracts the name of the unit of
length in which the point coordinates are expressed.
The <code>unitname&lt;-</code> method assigns the name of the unit of length.
</p>


<h3>Value</h3>

<p>For <code>print.pp3</code> the value is <code>NULL</code>.
For <code>unitname.pp3</code> an object of class <code>"units"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp3">pp3</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="#topic+unitname">unitname</a></code>
<code><a href="#topic+unitname+3C-">unitname&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- pp3(runif(42),runif(42),runif(42), box3(c(0,1), unitname="mm"))
   X
   unitname(X)
   unitname(X) &lt;- c("foot", "feet")
   summary(X)
</code></pre>

<hr>
<h2 id='methods.ppx'>
Methods for Multidimensional Space-Time Point Patterns
</h2><span id='topic+methods.ppx'></span><span id='topic+print.ppx'></span><span id='topic+plot.ppx'></span><span id='topic+unitname.ppx'></span><span id='topic+unitname+3C-.ppx'></span><span id='topic+scale.ppx'></span>

<h3>Description</h3>

<p>Methods for printing and plotting a general multidimensional
space-time point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppx'
print(x, ...)
## S3 method for class 'ppx'
plot(x, ...)
## S3 method for class 'ppx'
unitname(x)
## S3 replacement method for class 'ppx'
unitname(x) &lt;- value
## S3 method for class 'ppx'
scale(x, center=TRUE, scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.ppx_+3A_x">x</code></td>
<td>

<p>Multidimensional point pattern (object of class <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="methods.ppx_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to plot methods.
</p>
</td></tr>
<tr><td><code id="methods.ppx_+3A_value">value</code></td>
<td>

<p>Name of the unit of length. See <code><a href="#topic+unitname">unitname</a></code>.
</p>
</td></tr>
<tr><td><code id="methods.ppx_+3A_center">center</code>, <code id="methods.ppx_+3A_scale">scale</code></td>
<td>

<p>Arguments passed to <code><a href="base.html#topic+scale.default">scale.default</a></code>
to determine the rescaling.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="base.html#topic+print">print</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="#topic+unitname">unitname</a></code>,  <code><a href="#topic+unitname+3C-">unitname&lt;-</a></code>
and <code><a href="base.html#topic+scale">scale</a></code>
for the class <code>"ppx"</code> of multidimensional point patterns.
</p>
<p>The <code>print</code> method prints a description
of the point pattern and its spatial domain.
</p>
<p>The <code>unitname</code> method extracts the name of the unit of
length in which the point coordinates are expressed.
The <code>unitname&lt;-</code> method assigns the name of the unit of length.
</p>
<p>The <code>scale</code> method rescales each spatial coordinate of <code>x</code>.
</p>


<h3>Value</h3>

<p>For <code>print.ppx</code> and <code>plot.ppx</code> the value is <code>NULL</code>.
For <code>unitname.ppx</code> the value is an object of class <code>"units"</code>.
For <code>unitname&lt;-.ppx</code> and <code>scale.ppx</code>
the value is another object of class <code>"ppx"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppx">ppx</a></code>,
<code><a href="#topic+unitname">unitname</a></code>  
</p>

<hr>
<h2 id='methods.unitname'>
Methods for Units
</h2><span id='topic+methods.unitname'></span><span id='topic+print.unitname'></span><span id='topic+summary.unitname'></span><span id='topic+rescale.unitname'></span><span id='topic+compatible.unitname'></span><span id='topic+harmonise.unitname'></span><span id='topic+harmonize.unitname'></span>

<h3>Description</h3>

<p>Methods for class <code>"unitname"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'unitname'
print(x, ...)
  ## S3 method for class 'unitname'
summary(object, ...)
  ## S3 method for class 'unitname'
rescale(X, s, unitname)
  ## S3 method for class 'unitname'
compatible(A,B, ..., coerce=TRUE)
  ## S3 method for class 'unitname'
harmonise(..., coerce=TRUE, single=FALSE)
  ## S3 method for class 'unitname'
harmonize(..., coerce=TRUE, single=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.unitname_+3A_x">x</code>, <code id="methods.unitname_+3A_x">X</code>, <code id="methods.unitname_+3A_a">A</code>, <code id="methods.unitname_+3A_b">B</code>, <code id="methods.unitname_+3A_object">object</code></td>
<td>

<p>Objects of class <code>"unitname"</code> representing
units of length.
</p>
</td></tr>
<tr><td><code id="methods.unitname_+3A_...">...</code></td>
<td>

<p>Other arguments.
For <code>print.unitname</code> these arguments are passed to
<code><a href="base.html#topic+print.default">print.default</a></code>.
For <code>summary.unitname</code> they are ignored.
For <code>compatible.unitname</code> and <code>harmonise.unitname</code> these arguments
are other objects of class <code>"unitname"</code>.
</p>
</td></tr>
<tr><td><code id="methods.unitname_+3A_s">s</code></td>
<td>

<p>Conversion factor: the new units are <code>s</code> times the old units.
</p>
</td></tr>
<tr><td><code id="methods.unitname_+3A_unitname">unitname</code></td>
<td>

<p>Optional new name for the unit. If present, this overrides the
rescaling operation and simply substitutes the new name for the old
one.
</p>
</td></tr>
<tr><td><code id="methods.unitname_+3A_coerce">coerce</code></td>
<td>

<p>Logical. If <code>TRUE</code>, a null unit of length is compatible with
any non-null unit.
</p>
</td></tr>
<tr><td><code id="methods.unitname_+3A_single">single</code></td>
<td>

<p>Logical value indicating whether to return a single unitname,
or a list of unitnames.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+rescale">rescale</a></code>
and <code><a href="#topic+compatible">compatible</a></code>
for the class <code>"unitname"</code>.
</p>
<p>An object of class <code>"unitname"</code> represents a unit of length.
</p>
<p>The <code>print</code> method prints a description of the unit of length,
and the <code>summary</code> method gives a more detailed description.
</p>
<p>The <code>rescale</code> method changes the unit of length by rescaling it.
</p>
<p>The <code>compatible</code> method tests whether two or more units of length
are compatible.
</p>
<p>The <code>harmonise</code> method returns the common unit of length
if there is one. For consistency with other methods for
<code><a href="#topic+harmonise">harmonise</a></code>, the result is a list of unitname objects,
with one entry for each argument in <code>...</code>. All of these
entries are identical. This can be overridden by setting
<code>single=TRUE</code> when the result will be a single unitname object.
</p>


<h3>Value</h3>

<p>For <code>print.unitname</code> the value is <code>NULL</code>.
For <code>summary.unitname</code> the value is an object of class
<code>summary.unitname</code> (with its own print method).
For <code>rescale.unitname</code> the value is another object of class <code>"unitname"</code>.
For <code>compatible.unitname</code> the result is logical.
For <code>harmonise.unitname</code> the result is a list of
identical unitnames if <code>single=FALSE</code> (the default),
or a single unitname if <code>single=TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+box3">box3</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="#topic+unitname">unitname</a></code>
</p>

<hr>
<h2 id='metric.object'>Distance Metric</h2><span id='topic+metric.object'></span>

<h3>Description</h3>

<p>An object of class <code>"metric"</code> defines a measure of distance
between points, and supports many operations that involve distances.
</p>


<h3>Details</h3>

<p>A &lsquo;metric&rsquo; <code class="reqn">d</code> is a measure of distance between points that
satisfies
</p>

<ol>
<li>
<p><code class="reqn">d(x,x) = 0</code> for any point <code class="reqn">x</code>,
</p>
</li>
<li>
<p><code class="reqn">d(x,y) &gt; 0</code> for any two distinct points <code class="reqn">x</code> and <code class="reqn">y</code>
</p>
</li>
<li>
<p>symmetry: <code class="reqn">d(x,y) = d(y,x)</code> for any two points <code class="reqn">x</code> and <code class="reqn">y</code>
</p>
</li>
<li>
<p>triangle inequality:
<code class="reqn">d(x,y) \le d(x,z) + d(z,y)</code>
for any three points <code class="reqn">x,y,z</code>.
</p>
</li></ol>

<p>The Euclidean distance between points is an example of a metric.
</p>
<p>An object of class <code>"metric"</code> is a structure
that defines a metric and supports many computations that involve
the metric. The internal structure of this object,
and the mechanism for performing these computations,
are under development.
</p>
<p>Objects of class <code>"metric"</code> are produced by the function
<code><a href="#topic+convexmetric">convexmetric</a></code> and possibly by other functions.
</p>
<p>There are methods for <code>print</code> and <code>summary</code> 
for the class <code>"metric"</code>.
The <code>summary</code> method lists the operations that are supported
by the metric.
</p>
<p>To perform distance calculations (for example, nearest-neighbour
distances) using a desired metric instead of the
Euclidean metric, first check whether the standard function for this
purpose (for example <code>nndist.ppp</code>) 
has an argument named <code>metric</code>. 
If so, use the standard function
and add the argument <code>metric</code>; if not, use
the low-level function <code><a href="#topic+invoke.metric">invoke.metric</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convexmetric">convexmetric</a></code>, <code><a href="#topic+invoke.metric">invoke.metric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- convexmetric(square(c(-1,1)))
  summary(m)
  y &lt;- nndist(cells, metric=m)
</code></pre>

<hr>
<h2 id='midpoints.psp'>Midpoints of Line Segment Pattern</h2><span id='topic+midpoints.psp'></span>

<h3>Description</h3>

<p>Computes the midpoints of each line segment
in a line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  midpoints.psp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midpoints.psp_+3A_x">x</code></td>
<td>

<p>A line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The midpoint of each line segment is computed.
</p>


<h3>Value</h3>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marks.psp">marks.psp</a></code>,
<code><a href="#topic+summary.psp">summary.psp</a></code>,
<code><a href="#topic+lengths_psp">lengths_psp</a></code>
<code><a href="#topic+angles.psp">angles.psp</a></code>,
<code><a href="#topic+endpoints.psp">endpoints.psp</a></code>,
<code><a href="#topic+extrapolate.psp">extrapolate.psp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  b &lt;- midpoints.psp(a)   
</code></pre>

<hr>
<h2 id='MinkowskiSum'>Minkowski Sum of Windows</h2><span id='topic+MinkowskiSum'></span><span id='topic++25+28+2B+29+25'></span><span id='topic+dilationAny'></span>

<h3>Description</h3>

<p>Compute the Minkowski sum of two spatial windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinkowskiSum(A, B)

A %(+)% B

dilationAny(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MinkowskiSum_+3A_a">A</code>, <code id="MinkowskiSum_+3A_b">B</code></td>
<td>

<p>Windows (objects of class <code>"owin"</code>),
point patterns (objects of class <code>"ppp"</code>)
or line segment patterns (objects of class <code>"psp"</code>)
in any combination.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The operator <code>A %(+)% B</code> and function <code>MinkowskiSum(A,B)</code>
are synonymous: they both compute the
Minkowski sum of the windows <code>A</code> and <code>B</code>.
The function <code>dilationAny</code> computes the Minkowski dilation
<code>A %(+)% reflect(B)</code>.
</p>
<p>The Minkowski sum 
of two spatial regions <code class="reqn">A</code> and <code class="reqn">B</code>
is another region, formed by taking all possible pairs of points,
one in <code class="reqn">A</code> and one in <code class="reqn">B</code>, and adding them as vectors.
The Minkowski Sum <code class="reqn">A \oplus B</code>
is the set of all points <code class="reqn">a+b</code> where <code class="reqn">a</code> is in <code class="reqn">A</code>
and <code class="reqn">b</code> is in <code class="reqn">B</code>.
A few common facts about the Minkowski sum are:
</p>

<ul>
<li>
<p>The sum is symmetric:
<code class="reqn">A \oplus B = B \oplus A</code>.
</p>
</li>
<li>
<p>If <code class="reqn">B</code> is a single point, then <code class="reqn">A \oplus B</code>
is a shifted copy of <code class="reqn">A</code>.
</p>
</li>
<li>
<p>If <code class="reqn">A</code> is a square of side length <code class="reqn">a</code>,
and <code class="reqn">B</code> is a square of side length <code class="reqn">b</code>,
with sides that are parallel to the coordinate axes,
then <code class="reqn">A \oplus B</code> is a square of side length <code class="reqn">a+b</code>.
</p>
</li>
<li>
<p>If <code class="reqn">A</code> and <code class="reqn">B</code> are discs of radius <code class="reqn">r</code> and <code class="reqn">s</code>
respectively, then <code class="reqn">A \oplus B</code> is a disc
of redius <code class="reqn">r+s</code>.
</p>
</li>
<li>
<p>If <code class="reqn">B</code> is a disc of radius <code class="reqn">r</code> centred at the origin,
then <code class="reqn">A \oplus B</code> is equivalent to the
<em>morphological dilation</em> of <code class="reqn">A</code> by distance <code class="reqn">r</code>.
See <code><a href="#topic+dilation">dilation</a></code>.
</p>
</li></ul>

<p>The Minkowski dilation is the closely-related region
<code class="reqn">A \oplus (-B)</code>
where <code class="reqn">(-B)</code> is the reflection of <code class="reqn">B</code> through the origin.
The Minkowski dilation is the set of all vectors <code class="reqn">z</code>
such that, if <code class="reqn">B</code> is shifted by <code class="reqn">z</code>, the resulting set
<code class="reqn">B+z</code> has nonempty intersection with <code class="reqn">A</code>.
</p>
<p>The algorithm currently computes the result as a polygonal
window using the <span class="pkg">polyclip</span> library. 
It will be quite slow if applied to binary mask windows.
</p>
<p>The arguments <code>A</code> and <code>B</code> can also be point patterns or line
segment patterns. These are interpreted as spatial regions, the
Minkowski sum is computed, and the result is returned as an object of
the most appropriate type. The Minkowski sum of two point patterns is
another point pattern. The Minkowski sum of a point pattern and a line
segment pattern is another line segment pattern.
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>) except that
if <code>A</code> is a point pattern, then the result is an object of the same
type as <code>B</code> (and vice versa).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dilation">dilation</a></code>,
<code><a href="#topic+erosionAny">erosionAny</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  B &lt;- square(0.2)
  RplusB &lt;- letterR %(+)% B

  opa &lt;- par(mfrow=c(1,2))
  FR &lt;- grow.rectangle(Frame(letterR), 0.3)
  plot(FR, main="")
  plot(letterR, add=TRUE, lwd=2, hatch=TRUE, hatchargs=list(texture=5))
  plot(shift(B, vec=c(3.675, 3)),
       add=TRUE, border="red", lwd=2)
  plot(FR, main="")
  plot(letterR, add=TRUE, lwd=2, hatch=TRUE, hatchargs=list(texture=5))
  plot(RplusB, add=TRUE, border="blue", lwd=2,
         hatch=TRUE, hatchargs=list(col="blue"))
  par(opa)

  plot(cells %(+)% square(0.1))
</code></pre>

<hr>
<h2 id='multiplicity.ppp'>Count Multiplicity of Duplicate Points</h2><span id='topic+multiplicity'></span><span id='topic+multiplicity.default'></span><span id='topic+multiplicity.data.frame'></span><span id='topic+multiplicity.ppp'></span><span id='topic+multiplicity.ppx'></span>

<h3>Description</h3>

<p>Counts the number of duplicates for each point
in a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> multiplicity(x)

 ## S3 method for class 'ppp'
multiplicity(x)

 ## S3 method for class 'ppx'
multiplicity(x)

 ## S3 method for class 'data.frame'
multiplicity(x)

 ## Default S3 method:
multiplicity(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiplicity.ppp_+3A_x">x</code></td>
<td>

<p>A spatial point pattern
(object of class <code>"ppp"</code> or <code>"ppx"</code>)
or a vector, matrix or data frame.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two points in a point pattern are deemed to be identical
if their <code class="reqn">x,y</code> coordinates are the same,
and their marks are also the same (if they carry marks).
The Examples section illustrates how it is possible for
a point pattern to contain a pair of identical points.
</p>
<p>For each point in <code>x</code>, the function <code>multiplicity</code> counts how many
points are identical to it, and returns the vector of counts.
</p>
<p>The argument <code>x</code> can also be a vector, a matrix or a data frame.
When <code>x</code> is a vector, <code>m &lt;- multiplicity(x)</code> is a vector
of the same length as <code>x</code>, and <code>m[i]</code> is the
number of elements of <code>x</code> that are identical to <code>x[i]</code>.
When <code>x</code> is a matrix or data frame,
<code>m &lt;- multiplicity(x)</code> is a vector
of length equal to the number of rows of <code>x</code>, and <code>m[i]</code>
is the number of rows of <code>x</code> that are identical to
the <code>i</code>th row.
</p>


<h3>Value</h3>

<p>A vector of integers (multiplicities) of length equal to the
number of points in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Sebastian Meyer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+duplicated.ppp">duplicated.ppp</a></code>,
<code><a href="#topic+unique.ppp">unique.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- ppp(c(1,1,0.5,1), c(2,2,1,2), window=square(3), check=FALSE)
   m &lt;- multiplicity(X)

   # unique points in X, marked by their multiplicity
   first &lt;- !duplicated(X)
   Y &lt;- X[first] %mark% m[first]
</code></pre>

<hr>
<h2 id='nearest.raster.point'>Find Pixel Nearest to a Given Point</h2><span id='topic+nearest.raster.point'></span>

<h3>Description</h3>

<p>Given cartesian coordinates, find the nearest pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> nearest.raster.point(x,y,w, indices=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearest.raster.point_+3A_x">x</code></td>
<td>
<p>Numeric vector of <code class="reqn">x</code> coordinates of any points</p>
</td></tr>
<tr><td><code id="nearest.raster.point_+3A_y">y</code></td>
<td>
<p>Numeric vector of <code class="reqn">y</code> coordinates of any points</p>
</td></tr>
<tr><td><code id="nearest.raster.point_+3A_w">w</code></td>
<td>
<p>An image (object of class <code>"im"</code>)
or a binary mask window (an object of class <code>"owin"</code>
of type <code>"mask"</code>).
</p>
</td></tr>
<tr><td><code id="nearest.raster.point_+3A_indices">indices</code></td>
<td>
<p>Logical flag indicating whether to return the
row and column indices, or the actual <code class="reqn">x,y</code> coordinates.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>w</code> should be either a pixel image
(object of class <code>"im"</code>) or a window (an object of class
<code>"owin"</code>, see <code><a href="#topic+owin.object">owin.object</a></code> for details)
of type <code>"mask"</code>. 
</p>
<p>The arguments <code>x</code> and <code>y</code> should be numeric vectors
of equal length. They are interpreted as the coordinates of
points in space. For each point <code>(x[i], y[i])</code>, the function
finds the nearest pixel in the grid of pixels for <code>w</code>.
</p>
<p>If <code>indices=TRUE</code>,
this function returns a list containing two vectors <code>rr</code> and
<code>cc</code> giving row and column positions (in the image matrix).
For the location <code>(x[i],y[i])</code> the nearest
pixel is at row <code>rr[i]</code> and column <code>cc[i]</code> of
the image.
</p>
<p>If <code>indices=FALSE</code>, the function returns a list containing
two vectors <code>x</code> and <code>y</code> giving the actual coordinates
of the pixels.
</p>


<h3>Value</h3>

<p>If <code>indices=TRUE</code>, a 
list containing two vectors <code>rr</code> and <code>cc</code>
giving row and column positions (in the image matrix).
If <code>indices=FALSE</code>, a list containing
vectors <code>x</code> and <code>y</code> giving actual coordinates
of the pixels.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+as.mask">as.mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- owin(c(0,1), c(0,1), mask=matrix(TRUE, 100,100))  # 100 x 100 grid
  nearest.raster.point(0.5, 0.3, w)
  nearest.raster.point(0.5, 0.3, w, indices=FALSE)
</code></pre>

<hr>
<h2 id='nearestsegment'>Find Line Segment Nearest to Each Point</h2><span id='topic+nearestsegment'></span>

<h3>Description</h3>

<p>Given a point pattern and a line segment pattern,
this function finds the nearest line segment for each point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestsegment(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestsegment_+3A_x">X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="nearestsegment_+3A_y">Y</code></td>
<td>
<p>A line segment pattern (object of class <code>"psp"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance between a point <code>x</code> and a straight line segment <code>y</code> is
defined to be the shortest Euclidean distance between <code>x</code> and any
location on <code>y</code>. This algorithm first calculates the distance
from each point of <code>X</code> to
each segment of <code>Y</code>. Then it determines, for each point <code>x</code> in
<code>X</code>, which segment of <code>Y</code> is closest. The index of this
segment is returned.
</p>


<h3>Value</h3>

<p>Integer vector <code>v</code> (of length equal to the number of points in
<code>X</code>) identifying the nearest segment to each point.
If <code>v[i] = j</code>, then
<code>Y[j]</code> is the line segment lying closest to <code>X[i]</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+project2segment">project2segment</a></code> to project each point of <code>X</code> to
a point lying on one of the line segments.
</p>
<p>Use <code><a href="#topic+distmap.psp">distmap.psp</a></code> to 
identify the nearest line segment for each pixel in a grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runifrect(3)
  Y &lt;- as.psp(matrix(runif(20), 5, 4), window=owin())
  v &lt;- nearestsegment(X,Y)
  plot(Y)
  plot(X, add=TRUE)
  plot(X[1], add=TRUE, col="red")
  plot(Y[v[1]], add=TRUE, lwd=2, col="red") 
</code></pre>

<hr>
<h2 id='nearestValue'>
Image of Nearest Defined Pixel Value
</h2><span id='topic+nearestValue'></span>

<h3>Description</h3>

<p>Given a pixel image defined on a subset of a rectangle,
this function assigns a value to every pixel in the rectangle,
by looking up the value of the nearest pixel that has a value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestValue(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestValue_+3A_x">X</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pixel image in <span class="pkg">spatstat</span> is always stored on
a rectangular grid of pixels, but its value may be <code>NA</code>
on some pixels, indicating that the image is not defined at those
pixels.
</p>
<p>This function assigns a value to every pixel in the rectangular grid.
For each pixel <code>a</code> in the grid, if the value of <code>X</code> is not
defined at <code>a</code>, the function finds the nearest other pixel <code>b</code>
at which the value of <code>X</code> is defined, and takes the pixel value at
<code>b</code> as the new pixel value at <code>a</code>.
</p>


<h3>Value</h3>

<p>Another image of the same kind as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+blur">blur</a></code>, <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- as.im(function(x,y) { x + y }, letterR)
  Y &lt;- nearestValue(X)
  plot(solist("X"=X,"nearestValue(X)"=Y), main="", panel.end=letterR)
</code></pre>

<hr>
<h2 id='nestsplit'>
Nested Split
</h2><span id='topic+nestsplit'></span>

<h3>Description</h3>

<p>Applies two splitting operations to a point pattern,
producing a list of lists of patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nestsplit(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nestsplit_+3A_x">X</code></td>
<td>

<p>Point pattern to be split.
Object of class <code>"ppp"</code>.
</p>
</td></tr>
<tr><td><code id="nestsplit_+3A_...">...</code></td>
<td>

<p>Data determining the splitting factors or splitting regions.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function splits the point pattern <code>X</code> into several
sub-patterns using <code><a href="#topic+split.ppp">split.ppp</a></code>, then splits each of the
sub-patterns into sub-sub-patterns using <code><a href="#topic+split.ppp">split.ppp</a></code>
again.
The result is a hyperframe containing the sub-sub-patterns
and two factors indicating the grouping.
</p>
<p>The arguments <code>...</code> determine the two splitting factors
or splitting regions. Each argument may be:
</p>

<ul>
<li><p> a factor (of length equal to the number of points in <code>X</code>)
</p>
</li>
<li><p> the name of a column of marks of <code>X</code> (provided this
column contains factor values)
</p>
</li>
<li><p> a tessellation (class <code>"tess"</code>)
</p>
</li>
<li><p> a pixel image (class <code>"im"</code>) with factor values
</p>
</li>
<li><p> a window (class <code>"owin"</code>)
</p>
</li>
<li><p> identified by name (in the form <code>name=value</code>)
as one of the formal arguments of <code><a href="#topic+quadrats">quadrats</a></code> or
<code><a href="#topic+tess">tess</a></code>
</p>
</li></ul>

<p>The arguments will be processed to yield a list of two
splitting factors/tessellations. The splits will be applied
to <code>X</code> consecutively to produce the sub-sub-patterns.
</p>


<h3>Value</h3>

<p>A hyperframe with three columns. The first column contains the
sub-sub-patterns. The second and third columns are factors
which identify the grouping according to the two splitting factors.
</p>


<h3>Author(s)</h3>

<p>Original idea by Ute Hahn.
Code by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+split.ppp">split.ppp</a></code>,
<code><a href="#topic+quantess">quantess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # factor and tessellation
  Nft &lt;- nestsplit(amacrine, marks(amacrine), quadrats(amacrine, 3, 1))
  Ntf &lt;- nestsplit(amacrine, quadrats(amacrine, 3, 1), marks(amacrine))
  Ntf

  # two factors
  big &lt;- with(marks(betacells), area &gt; 300)
  Nff &lt;- nestsplit(betacells, "type", factor(big))

  # two tessellations
  Tx &lt;- quantess(redwood, "x", 4)
  Td &lt;- dirichlet(runifrect(5, Window(redwood)))
  Ntt &lt;- nestsplit(redwood, Td, Tx)
  Ntt2 &lt;- nestsplit(redwood, Td, ny=3)
</code></pre>

<hr>
<h2 id='nncross'>Nearest Neighbours Between Two Patterns</h2><span id='topic+nncross'></span><span id='topic+nncross.ppp'></span><span id='topic+nncross.default'></span>

<h3>Description</h3>

<p>Given two point patterns <code>X</code> and <code>Y</code>,
finds the nearest neighbour in <code>Y</code> of each point of <code>X</code>.
Alternatively <code>Y</code> may be a line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nncross(X, Y, ...)

  ## S3 method for class 'ppp'
nncross(X, Y,
          iX=NULL, iY=NULL,
          what = c("dist", "which"),
          ...,
          k = 1,
          sortby=c("range", "var", "x", "y"),
          is.sorted.X = FALSE,
          is.sorted.Y = FALSE,
          metric=NULL)

  ## Default S3 method:
nncross(X, Y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nncross_+3A_x">X</code></td>
<td>
<p>Point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="nncross_+3A_y">Y</code></td>
<td>
<p>Either a point pattern (object of class <code>"ppp"</code>)
or a line segment pattern (object of class <code>"psp"</code>).</p>
</td></tr>
<tr><td><code id="nncross_+3A_ix">iX</code>, <code id="nncross_+3A_iy">iY</code></td>
<td>
<p>Optional identifiers, applicable only in the case where
<code>Y</code> is a point pattern, used to determine whether a point in
<code>X</code> is identical to a point in <code>Y</code>. See Details.
</p>
</td></tr>
<tr><td><code id="nncross_+3A_what">what</code></td>
<td>

<p>Character string specifying what information should be returned.
Either the nearest neighbour distance (<code>"dist"</code>),
the identifier of the nearest neighbour (<code>"which"</code>),
or both.
</p>
</td></tr>
<tr><td><code id="nncross_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour.
</p>
</td></tr>
<tr><td><code id="nncross_+3A_sortby">sortby</code></td>
<td>

<p>Determines which coordinate to use to sort the point patterns.
See Details.
</p>
</td></tr>
<tr><td><code id="nncross_+3A_is.sorted.x">is.sorted.X</code>, <code id="nncross_+3A_is.sorted.y">is.sorted.Y</code></td>
<td>

<p>Logical values attesting whether the point patterns <code>X</code> and
<code>Y</code> have been sorted. See Details.
</p>
</td></tr>
<tr><td><code id="nncross_+3A_metric">metric</code></td>
<td>

<p>Optional. A distance metric
(object of class <code>"metric"</code>, see <code><a href="#topic+metric.object">metric.object</a></code>)
which will be used to compute the distances.
</p>
</td></tr>
<tr><td><code id="nncross_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two point patterns <code>X</code> and <code>Y</code> this
function finds, for each point of <code>X</code>, 
the nearest point of <code>Y</code>. The distance between these points
is also computed.
If the argument <code>k</code> is specified, then the <code>k</code>-th nearest
neighbours will be found.
</p>
<p>Alternatively if <code>X</code> is a point pattern and <code>Y</code> is a line
segment pattern, the function finds the nearest line segment to each point
of <code>X</code>, and computes the distance.
</p>
<p>The return value is a data frame, with rows corresponding to
the points of <code>X</code>.  The first column gives the nearest neighbour
distances (i.e. the <code>i</code>th entry is the distance 
from the <code>i</code>th point of <code>X</code> to the nearest element of
<code>Y</code>). The second column gives the indices of the nearest
neighbours (i.e.\ the <code>i</code>th entry is the index of
the nearest element in <code>Y</code>.)
If <code>what="dist"</code> then only the vector of distances is returned.
If <code>what="which"</code> then only the vector of indices is returned.
</p>
<p>The argument <code>k</code> may be an integer or an integer vector.
If it is a single integer, then the <code>k</code>-th nearest neighbours
are computed. If it is a vector, then the <code>k[i]</code>-th nearest
neighbours are computed for each entry <code>k[i]</code>. For example, setting
<code>k=1:3</code> will compute the nearest, second-nearest and
third-nearest neighbours. The result is a data frame.
</p>
<p>Note that this function is not symmetric in <code>X</code> and <code>Y</code>.
To find the nearest neighbour in <code>X</code> of each point in <code>Y</code>,
where <code>Y</code> is a point pattern, use <code>nncross(Y,X)</code>.
</p>
<p>The arguments <code>iX</code> and <code>iY</code> are used when
the two point patterns <code>X</code> and <code>Y</code> have some points in
common.  In this situation <code>nncross(X, Y)</code> would return some zero
distances. To avoid this, attach a unique integer identifier to
each point, such that two points are identical if their
identifying numbers are equal. Let <code>iX</code> be the vector of
identifier values for the points in <code>X</code>, and <code>iY</code>
the vector of identifiers for points in <code>Y</code>. Then the code
will only compare two points if they have different values of the
identifier. See the Examples.
</p>


<h3>Value</h3>

<p>A data frame, or a vector if the data frame would contain only one column.
</p>
<p>By default (if <code>what=c("dist", "which")</code> and <code>k=1</code>)
a data frame with two columns:
</p>
<table>
<tr><td><code>dist</code></td>
<td>
<p>Nearest neighbour distance</p>
</td></tr>
<tr><td><code>which</code></td>
<td>
<p>Nearest neighbour index in <code>Y</code></p>
</td></tr>
</table>
<p>If <code>what="dist"</code> and <code>k=1</code>, a vector of nearest neighbour distances.
</p>
<p>If <code>what="which"</code> and <code>k=1</code>, a vector of nearest neighbour
indices.
</p>
<p>If <code>k</code> is specified, the result is a data frame with
columns containing the <code>k</code>-th nearest neighbour distances
and/or nearest neighbour indices.
</p>


<h3>Efficiency, sorting data, and pre-sorted data</h3>

<p>Read this section if you care about the speed of computation.
</p>
<p>For efficiency, the algorithm sorts the point patterns <code>X</code> and <code>Y</code>
into increasing order of the <code class="reqn">x</code> coordinate
or increasing order of the the <code class="reqn">y</code> coordinate.
Sorting is only an intermediate step;
it does not affect the output, which is always given in the same
order as the original data.
</p>
<p>By default (if <code>sortby="range"</code>),
the sorting will occur on the coordinate that has the larger range of
values (according to the frame of the enclosing window of <code>Y</code>).
If <code>sortby = "var"</code>), sorting will occur on the coordinate that
has the greater variance (in the pattern <code>Y</code>).
Setting <code>sortby="x"</code> or <code>sortby = "y"</code> will specify that
sorting should occur on the <code class="reqn">x</code> or <code class="reqn">y</code> coordinate, respectively.
</p>
<p>If the point pattern <code>X</code> is already
sorted, then the corresponding argument <code>is.sorted.X</code>
should be set to <code>TRUE</code>, and <code>sortby</code> should be set
equal to <code>"x"</code> or <code>"y"</code> to indicate which coordinate
is sorted.
</p>
<p>Similarly if <code>Y</code> is already sorted, then <code>is.sorted.Y</code>
should be set to <code>TRUE</code>, and <code>sortby</code> should be set
equal to <code>"x"</code> or <code>"y"</code> to indicate which coordinate
is sorted.
</p>
<p>If both <code>X</code> and <code>Y</code> are sorted <em>on the same coordinate
axis</em> then both <code>is.sorted.X</code> and <code>is.sorted.Y</code>
should be set to <code>TRUE</code>, and <code>sortby</code> should be set
equal to <code>"x"</code> or <code>"y"</code> to indicate which coordinate
is sorted.  
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>,
and Jens Oehlschlaegel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndist">nndist</a></code> for nearest neighbour
distances in a single point pattern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # two different point patterns
  X &lt;- runifrect(15)
  Y &lt;- runifrect(20)
  N &lt;- nncross(X,Y)$which
  # note that length(N) = 15
  plot(superimpose(X=X,Y=Y), main="nncross", cols=c("red","blue"))
  arrows(X$x, X$y, Y[N]$x, Y[N]$y, length=0.15)

  # third-nearest neighbour
  NXY &lt;- nncross(X, Y, k=3)
  NXY[1:3,]
  # second and third nearest neighbours
  NXY &lt;- nncross(X, Y, k=2:3)
  NXY[1:3,]

  # two patterns with some points in common
  Z &lt;- runifrect(50)
  X &lt;- Z[1:30]
  Y &lt;- Z[20:50]
  iX &lt;- 1:30
  iY &lt;- 20:50
  N &lt;- nncross(X,Y, iX, iY)$which
  N &lt;- nncross(X,Y, iX, iY, what="which") #faster
  plot(superimpose(X=X, Y=Y), main="nncross", cols=c("red","blue"))
  arrows(X$x, X$y, Y[N]$x, Y[N]$y, length=0.15)

  # point pattern and line segment pattern
  X &lt;- runifrect(15)
  Y &lt;- psp(runif(10), runif(10), runif(10), runif(10), square(1))
  N &lt;- nncross(X,Y)
</code></pre>

<hr>
<h2 id='nncross.pp3'>Nearest Neighbours Between Two Patterns in 3D</h2><span id='topic+nncross.pp3'></span>

<h3>Description</h3>

<p>Given two point patterns <code>X</code> and <code>Y</code> in three dimensions,
finds the nearest neighbour in <code>Y</code> of each point of <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'pp3'
nncross(X, Y,
          iX=NULL, iY=NULL,
          what = c("dist", "which"),
          ...,
          k = 1,
          sortby=c("range", "var", "x", "y", "z"),
          is.sorted.X = FALSE,
          is.sorted.Y = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nncross.pp3_+3A_x">X</code>, <code id="nncross.pp3_+3A_y">Y</code></td>
<td>
<p>Point patterns in three dimensions
(objects of class <code>"pp3"</code>).</p>
</td></tr>
<tr><td><code id="nncross.pp3_+3A_ix">iX</code>, <code id="nncross.pp3_+3A_iy">iY</code></td>
<td>
<p>Optional identifiers, 
used to determine whether a point in
<code>X</code> is identical to a point in <code>Y</code>. See Details.
</p>
</td></tr>
<tr><td><code id="nncross.pp3_+3A_what">what</code></td>
<td>

<p>Character string specifying what information should be returned.
Either the nearest neighbour distance (<code>"dist"</code>),
the identifier of the nearest neighbour (<code>"which"</code>),
or both.
</p>
</td></tr>
<tr><td><code id="nncross.pp3_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour.
</p>
</td></tr>
<tr><td><code id="nncross.pp3_+3A_sortby">sortby</code></td>
<td>

<p>Determines which coordinate to use to sort the point patterns.
See Details.
</p>
</td></tr>
<tr><td><code id="nncross.pp3_+3A_is.sorted.x">is.sorted.X</code>, <code id="nncross.pp3_+3A_is.sorted.y">is.sorted.Y</code></td>
<td>

<p>Logical values attesting whether the point patterns <code>X</code> and
<code>Y</code> have been sorted. See Details.
</p>
</td></tr>
<tr><td><code id="nncross.pp3_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two point patterns <code>X</code> and <code>Y</code> in three dimensions,
this function finds, for each point of <code>X</code>, 
the nearest point of <code>Y</code>. The distance between these points
is also computed.
If the argument <code>k</code> is specified, then the <code>k</code>-th nearest
neighbours will be found.
</p>
<p>The return value is a data frame, with rows corresponding to
the points of <code>X</code>.  The first column gives the nearest neighbour
distances (i.e. the <code>i</code>th entry is the distance 
from the <code>i</code>th point of <code>X</code> to the nearest element of
<code>Y</code>). The second column gives the indices of the nearest
neighbours (i.e.\ the <code>i</code>th entry is the index of
the nearest element in <code>Y</code>.)
If <code>what="dist"</code> then only the vector of distances is returned.
If <code>what="which"</code> then only the vector of indices is returned.
</p>
<p>The argument <code>k</code> may be an integer or an integer vector.
If it is a single integer, then the <code>k</code>-th nearest neighbours
are computed. If it is a vector, then the <code>k[i]</code>-th nearest
neighbours are computed for each entry <code>k[i]</code>. For example, setting
<code>k=1:3</code> will compute the nearest, second-nearest and
third-nearest neighbours. The result is a data frame.
</p>
<p>Note that this function is not symmetric in <code>X</code> and <code>Y</code>.
To find the nearest neighbour in <code>X</code> of each point in <code>Y</code>,
use <code>nncross(Y,X)</code>.
</p>
<p>The arguments <code>iX</code> and <code>iY</code> are used when
the two point patterns <code>X</code> and <code>Y</code> have some points in
common.  In this situation <code>nncross(X, Y)</code> would return some zero
distances. To avoid this, attach a unique integer identifier to
each point, such that two points are identical if their
identifying numbers are equal. Let <code>iX</code> be the vector of
identifier values for the points in <code>X</code>, and <code>iY</code>
the vector of identifiers for points in <code>Y</code>. Then the code
will only compare two points if they have different values of the
identifier. See the Examples.
</p>


<h3>Value</h3>

<p>A data frame, or a vector if the data frame would contain only one column.
</p>
<p>By default (if <code>what=c("dist", "which")</code> and <code>k=1</code>)
a data frame with two columns:
</p>
<table>
<tr><td><code>dist</code></td>
<td>
<p>Nearest neighbour distance</p>
</td></tr>
<tr><td><code>which</code></td>
<td>
<p>Nearest neighbour index in <code>Y</code></p>
</td></tr>
</table>
<p>If <code>what="dist"</code> and <code>k=1</code>, a vector of nearest neighbour distances.
</p>
<p>If <code>what="which"</code> and <code>k=1</code>, a vector of nearest neighbour
indices.
</p>
<p>If <code>k</code> is specified, the result is a data frame with
columns containing the <code>k</code>-th nearest neighbour distances
and/or nearest neighbour indices.
</p>


<h3>Sorting data and pre-sorted data</h3>

<p>Read this section if you care about the speed of computation.
</p>
<p>For efficiency, the algorithm sorts both
the point patterns <code>X</code> and <code>Y</code>
into increasing order of the <code class="reqn">x</code> coordinate,
or both into increasing order of the <code class="reqn">y</code> coordinate,
or both into increasing order of the <code class="reqn">z</code> coordinate.
Sorting is only an intermediate step;
it does not affect the output, which is always given in the same
order as the original data.
</p>
<p>By default (if <code>sortby="range"</code>),
the sorting will occur on the coordinate that has the largest range of
values (according to the frame of the enclosing window of <code>Y</code>).
If <code>sortby = "var"</code>), sorting will occur on the coordinate that
has the greater variance (in the pattern <code>Y</code>).
Setting <code>sortby="x"</code> or <code>sortby = "y"</code>
or <code>sortby = "z"</code> will specify that
sorting should occur on the <code class="reqn">x</code>, <code class="reqn">y</code> or <code class="reqn">z</code> coordinate,
respectively.
</p>
<p>If the point pattern <code>X</code> is already
sorted, then the corresponding argument <code>is.sorted.X</code>
should be set to <code>TRUE</code>, and <code>sortby</code> should be set
equal to <code>"x"</code>, <code>"y"</code> or <code>"z"</code> to indicate which coordinate
is sorted.
</p>
<p>Similarly if <code>Y</code> is already sorted, then <code>is.sorted.Y</code>
should be set to <code>TRUE</code>, and <code>sortby</code> should be set
equal to <code>"x"</code>, <code>"y"</code> or <code>"z"</code> to indicate which coordinate
is sorted.
</p>
<p>If both <code>X</code> and <code>Y</code> are sorted <em>on the same coordinate
axis</em> then both <code>is.sorted.X</code> and <code>is.sorted.Y</code>
should be set to <code>TRUE</code>, and <code>sortby</code> should be set
equal to <code>"x"</code>, <code>"y"</code> or <code>"z"</code> to indicate which coordinate
is sorted.  
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
,
and Jens Oehlschlaegel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndist">nndist</a></code> for nearest neighbour
distances in a single point pattern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # two different point patterns
  X &lt;- pp3(runif(10), runif(10), runif(10), box3(c(0,1)))
  Y &lt;- pp3(runif(20), runif(20), runif(20), box3(c(0,1)))
  N &lt;- nncross(X,Y)$which
  N &lt;- nncross(X,Y, what="which") #faster
  # note that length(N) = 10

  # k-nearest neighbours
  N3 &lt;- nncross(X, Y, k=1:3)

  # two patterns with some points in common
  Z &lt;- pp3(runif(20), runif(20), runif(20), box3(c(0,1)))
  X &lt;- Z[1:15]
  Y &lt;- Z[10:20]
  iX &lt;- 1:15
  iY &lt;- 10:20
  N &lt;- nncross(X,Y, iX, iY, what="which")

</code></pre>

<hr>
<h2 id='nncross.ppx'>Nearest Neighbours Between Two Patterns in Any Dimensions</h2><span id='topic+nncross.ppx'></span>

<h3>Description</h3>

<p>Given two point patterns <code>X</code> and <code>Y</code> in
many dimensional space,
finds the nearest neighbour in <code>Y</code> of each point of <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppx'
nncross(X, Y,
          iX=NULL, iY=NULL,
          what = c("dist", "which"),
          ...,
          k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nncross.ppx_+3A_x">X</code>, <code id="nncross.ppx_+3A_y">Y</code></td>
<td>

<p>Point patterns in any number of spatial dimensions
(objects of class <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="nncross.ppx_+3A_ix">iX</code>, <code id="nncross.ppx_+3A_iy">iY</code></td>
<td>
<p>Optional identifiers, 
used to determine whether a point in
<code>X</code> is identical to a point in <code>Y</code>. See Details.
</p>
</td></tr>
<tr><td><code id="nncross.ppx_+3A_what">what</code></td>
<td>

<p>Character string specifying what information should be returned.
Either the nearest neighbour distance (<code>"dist"</code>),
the identifier of the nearest neighbour (<code>"which"</code>),
or both.
</p>
</td></tr>
<tr><td><code id="nncross.ppx_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour.
</p>
</td></tr>
<tr><td><code id="nncross.ppx_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two point patterns <code>X</code> and <code>Y</code> in
<code class="reqn">m</code>-dimensional space,
this function finds, for each point of <code>X</code>, 
the nearest point of <code>Y</code>. The distance between these points
is also computed.
If the argument <code>k</code> is specified, then the <code>k</code>-th nearest
neighbours will be found.
</p>
<p>The return value is a data frame, with rows corresponding to
the points of <code>X</code>.  The first column gives the nearest neighbour
distances (i.e. the <code>i</code>th entry is the distance 
from the <code>i</code>th point of <code>X</code> to the nearest element of
<code>Y</code>). The second column gives the indices of the nearest
neighbours (i.e.\ the <code>i</code>th entry is the index of
the nearest element in <code>Y</code>.)
If <code>what="dist"</code> then only the vector of distances is returned.
If <code>what="which"</code> then only the vector of indices is returned.
</p>
<p>The argument <code>k</code> may be an integer or an integer vector.
If it is a single integer, then the <code>k</code>-th nearest neighbours
are computed. If it is a vector, then the <code>k[i]</code>-th nearest
neighbours are computed for each entry <code>k[i]</code>. For example, setting
<code>k=1:3</code> will compute the nearest, second-nearest and
third-nearest neighbours. The result is a data frame.
</p>
<p>Note that this function is not symmetric in <code>X</code> and <code>Y</code>.
To find the nearest neighbour in <code>X</code> of each point in <code>Y</code>,
use <code>nncross(Y,X)</code>.
</p>
<p>The arguments <code>iX</code> and <code>iY</code> are used when
the two point patterns <code>X</code> and <code>Y</code> have some points in
common.  In this situation <code>nncross(X, Y)</code> would return some zero
distances. To avoid this, attach a unique integer identifier to
each point, such that two points are identical if their
identifying numbers are equal. Let <code>iX</code> be the vector of
identifier values for the points in <code>X</code>, and <code>iY</code>
the vector of identifiers for points in <code>Y</code>. Then the code
will only compare two points if they have different values of the
identifier. See the Examples.
</p>


<h3>Value</h3>

<p>A data frame, or a vector if the data frame would contain only one column.
</p>
<p>By default (if <code>what=c("dist", "which")</code> and <code>k=1</code>)
a data frame with two columns:
</p>
<table>
<tr><td><code>dist</code></td>
<td>
<p>Nearest neighbour distance</p>
</td></tr>
<tr><td><code>which</code></td>
<td>
<p>Nearest neighbour index in <code>Y</code></p>
</td></tr>
</table>
<p>If <code>what="dist"</code> and <code>k=1</code>, a vector of nearest neighbour distances.
</p>
<p>If <code>what="which"</code> and <code>k=1</code>, a vector of nearest neighbour
indices.
</p>
<p>If <code>k</code> is specified, the result is a data frame with
columns containing the <code>k</code>-th nearest neighbour distances
and/or nearest neighbour indices.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndist">nndist</a></code> for nearest neighbour
distances in a single point pattern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  XYZ &lt;- ppx(matrix(runif(80), 20, 4),
            boxx(c(0,1), c(0,1), c(0,1), c(0,1)))

  ## two different point patterns
  X &lt;- XYZ[1:5]
  Y &lt;- XYZ[10:20]
  nncross(X,Y)
  N23 &lt;- nncross(X,Y, k=2:3)

  ## two patterns with some points in common
  X &lt;- XYZ[1:15]
  Y &lt;- XYZ[10:20]
  iX &lt;- 1:15
  iY &lt;- 10:20
  N &lt;- nncross(X,Y, iX, iY, what="which")
  N4 &lt;- nncross(X,Y, iX, iY, k=4)
</code></pre>

<hr>
<h2 id='nndist'>Nearest neighbour distances</h2><span id='topic+nndist'></span><span id='topic+nndist.ppp'></span><span id='topic+nndist.default'></span>

<h3>Description</h3>

<p>Computes the distance from each point to its nearest neighbour
in a point pattern. Alternatively computes the distance to the
second nearest neighbour, or third nearest, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nndist(X, ...)
  ## S3 method for class 'ppp'
nndist(X, ..., k=1, by=NULL, method="C", metric=NULL)
  ## Default S3 method:
nndist(X, Y=NULL, ..., k=1, by=NULL, method="C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nndist_+3A_x">X</code>, <code id="nndist_+3A_y">Y</code></td>
<td>

<p>Arguments specifying the locations of
a set of points.
For <code>nndist.ppp</code>, the argument <code>X</code> should be a point
pattern (object of class <code>"ppp"</code>).
For <code>nndist.default</code>, typically <code>X</code> and <code>Y</code> would be
numeric vectors of equal length. Alternatively <code>Y</code> may be
omitted and <code>X</code> may be
a list with two components <code>x</code> and <code>y</code>,
or a matrix with two columns.
Alternatively <code>X</code> can be
a three-dimensional point pattern (class <code>"pp3"</code>),
a higher-dimensional point pattern (class <code>"ppx"</code>),
a point pattern on a linear network (class <code>"lpp"</code>),
or a spatial pattern of line segments (class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="nndist_+3A_...">...</code></td>
<td>

<p>Ignored by <code>nndist.ppp</code>
and <code>nndist.default</code>.
</p>
</td></tr>
<tr><td><code id="nndist_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour. 
</p>
</td></tr>
<tr><td><code id="nndist_+3A_by">by</code></td>
<td>

<p>Optional. A factor, which separates <code>X</code> into groups.
The algorithm will compute the distance to the nearest point in each
group. See Details.
</p>
</td></tr>
<tr><td><code id="nndist_+3A_method">method</code></td>
<td>
<p>String specifying which method of calculation to use.
Values are <code>"C"</code> and <code>"interpreted"</code>.
</p>
</td></tr>
<tr><td><code id="nndist_+3A_metric">metric</code></td>
<td>

<p>Optional. A metric (object of class <code>"metric"</code>)
that will be used to define and compute the distances.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the Euclidean distance from each point
in a point pattern to its nearest neighbour (the nearest other
point of the pattern). If <code>k</code> is specified, it computes the
distance to the <code>k</code>th nearest neighbour.
</p>
<p>The function <code>nndist</code> is generic, with
a method for point patterns (objects of class <code>"ppp"</code>),
and a default method for coordinate vectors.
</p>
<p>There are also methods for line segment patterns,
<code><a href="#topic+nndist.psp">nndist.psp</a></code>,
three-dimensional point patterns, <code><a href="#topic+nndist.pp3">nndist.pp3</a></code>,
higher-dimensional point patterns, <code><a href="#topic+nndist.ppx">nndist.ppx</a></code>
and point patterns on a linear network,
<code>nndist.lpp</code>;
these are described in their own help files.
Type <code>methods(nndist)</code> to see all available methods.
</p>
<p>The method for planar point patterns <code>nndist.ppp</code> expects a single
point pattern argument <code>X</code> and returns the vector of its
nearest neighbour distances.
</p>
<p>The default method expects that <code>X</code> and <code>Y</code> will determine
the coordinates of a set of points. Typically <code>X</code> and
<code>Y</code> would be numeric vectors of equal length. Alternatively
<code>Y</code> may be omitted and <code>X</code> may be a list with two components
named <code>x</code> and <code>y</code>, or a matrix or data frame with two columns.
</p>
<p>The argument <code>k</code> may be a single integer, or an integer vector.
If it is a vector, then the <code class="reqn">k</code>th nearest neighbour distances are
computed for each value of <code class="reqn">k</code> specified in the vector.
</p>
<p>If the argument <code>by</code> is given, it should be a <code>factor</code>,
of length equal to the number of points in <code>X</code>.
This factor effectively partitions <code>X</code> into subsets,
each subset associated with one of the levels of <code>X</code>.
The algorithm will then compute, for each point of <code>X</code>,
the distance to the nearest neighbour <em>in each subset</em>.
</p>
<p>The argument <code>method</code> is not normally used. It is
retained only for checking the validity of the software.
If <code>method = "interpreted"</code> then the distances are
computed using interpreted R code only. If <code>method="C"</code>
(the default) then C code is used. 
The C code is faster by two to three orders of magnitude
and uses much less memory.
</p>
<p>If there is only one point (if <code>x</code> has length 1),
then a nearest neighbour distance of <code>Inf</code> is returned.
If there are no points (if <code>x</code> has length zero)
a numeric vector of length zero is returned.
</p>
<p>To identify <em>which</em> point is the nearest neighbour of a given point,
use <code><a href="#topic+nnwhich">nnwhich</a></code>.
</p>
<p>To use the nearest neighbour distances for statistical inference,
it is often advisable to use the edge-corrected empirical distribution,
computed by <code><a href="spatstat.explore.html#topic+Gest">Gest</a></code>.
</p>
<p>To find the nearest neighbour distances from one point pattern
to another point pattern, use <code><a href="#topic+nncross">nncross</a></code>.
</p>


<h3>Value</h3>

<p>Numeric vector or matrix containing the 
nearest neighbour distances for each point.
</p>
<p>If <code>k = 1</code> (the default), the return value is a
numeric vector <code>v</code> such that <code>v[i]</code> is the
nearest neighbour distance for the <code>i</code>th data point.
</p>
<p>If <code>k</code> is a single integer, then the return value is a
numeric vector <code>v</code> such that <code>v[i]</code> is the
<code>k</code>th nearest neighbour distance for the
<code>i</code>th data point.
</p>
<p>If <code>k</code> is a vector, then the return value is a
matrix <code>m</code> such that <code>m[i,j]</code> is the
<code>k[j]</code>th nearest neighbour distance for the
<code>i</code>th data point.
</p>
<p>If the argument <code>by</code> is given, then it should be a <code>factor</code>
which separates <code>X</code> into groups (or any type of data acceptable to
<code><a href="#topic+split.ppp">split.ppp</a></code> that determines the grouping).
The result is a data frame containing the distances described above,
from each point of <code>X</code>,
to the nearest point in each subset of <code>X</code>
defined by the grouping factor <code>by</code>.
</p>


<h3>Nearest neighbours of each type</h3>

<p>If <code>X</code> is a multitype point pattern 
and <code>by=marks(X)</code>, then the algorithm will compute,
for each point of <code>X</code>, the distance to the nearest neighbour
of each type. See the Examples.
</p>
<p>To find the minimum distance from <em>any</em> point of type <code>i</code>
to the nearest point of type <code>j</code>, for all combinations of <code>i</code> and
<code>j</code>, use <code><a href="#topic+minnndist">minnndist</a></code>,
or the <span class="rlang"><b>R</b></span> function <code><a href="stats.html#topic+aggregate">aggregate</a></code> as
suggested in the Examples.
</p>


<h3>Warnings</h3>

<p>An infinite or <code>NA</code> value is returned if the
distance is not defined (e.g. if there is only one point
in the point pattern).
</p>


<h3>Author(s)</h3>

<p>Pavel Grabarnik <a href="mailto:pavel.grabar@issp.serpukhov.su">pavel.grabar@issp.serpukhov.su</a>
and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndist.psp">nndist.psp</a></code>,
<code><a href="#topic+nndist.pp3">nndist.pp3</a></code>,
<code><a href="#topic+nndist.ppx">nndist.ppx</a></code>,
<code><a href="#topic+pairdist">pairdist</a></code>,
<code><a href="spatstat.explore.html#topic+Gest">Gest</a></code>,
<code><a href="#topic+nnwhich">nnwhich</a></code>,
<code><a href="#topic+nncross">nncross</a></code>,
<code><a href="#topic+minnndist">minnndist</a></code>, <code><a href="#topic+maxnndist">maxnndist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # nearest neighbours
   d &lt;- nndist(cells)

   # second nearest neighbours
   d2 &lt;- nndist(cells, k=2)

   # first, second and third nearest
   d1to3 &lt;- nndist(cells, k=1:3)

   x &lt;- runif(100)
   y &lt;- runif(100)
   d &lt;- nndist(x, y)

   # Stienen diagram
   plot(cells %mark% nndist(cells), markscale=1)

   # distance to nearest neighbour of each type
   nnda &lt;- nndist(ants, by=marks(ants)) 
   head(nnda)
   # For nest number 1, the nearest Cataglyphis nest is 87.32125 units away

   # minimum distance between each pair of types
   minnndist(ants, by=marks(ants))

   # Use of 'aggregate':
   # _minimum_ distance between each pair of types
   aggregate(nnda, by=list(from=marks(ants)), min)
   # _mean_ nearest neighbour distances
   aggregate(nnda, by=list(from=marks(ants)), mean)
   # The mean distance from a Messor nest to
   # the nearest Cataglyphis nest is 59.02549 units
</code></pre>

<hr>
<h2 id='nndist.pp3'>Nearest neighbour distances in three dimensions</h2><span id='topic+nndist.pp3'></span>

<h3>Description</h3>

<p>Computes the distance from each point to its nearest neighbour
in a three-dimensional point pattern.
Alternatively computes the distance to the
second nearest neighbour, or third nearest, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'pp3'
nndist(X, ..., k=1, by=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nndist.pp3_+3A_x">X</code></td>
<td>

<p>Three-dimensional point pattern
(object of class <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="nndist.pp3_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="nndist.pp3_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour. 
</p>
</td></tr>
<tr><td><code id="nndist.pp3_+3A_by">by</code></td>
<td>

<p>Optional. A factor, which separates <code>X</code> into groups.
The algorithm will compute the distance to
the nearest point in each group. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the Euclidean distance from each point
in a three-dimensional
point pattern to its nearest neighbour (the nearest other
point of the pattern). If <code>k</code> is specified, it computes the
distance to the <code>k</code>th nearest neighbour.
</p>
<p>The function <code>nndist</code> is generic; this function
<code>nndist.pp3</code> is the method for the class <code>"pp3"</code>.
</p>
<p>The argument <code>k</code> may be a single integer, or an integer vector.
If it is a vector, then the <code class="reqn">k</code>th nearest neighbour distances are
computed for each value of <code class="reqn">k</code> specified in the vector.
</p>
<p>If there is only one point (if <code>x</code> has length 1),
then a nearest neighbour distance of <code>Inf</code> is returned.
If there are no points (if <code>x</code> has length zero)
a numeric vector of length zero is returned.
</p>
<p>If the argument <code>by</code> is given, it should be a <code>factor</code>,
of length equal to the number of points in <code>X</code>.
This factor effectively partitions <code>X</code> into subsets,
each subset associated with one of the levels of <code>X</code>.
The algorithm will then compute, for each point of <code>X</code>,
the distance to the nearest neighbour <em>in each subset</em>.
</p>
<p>To identify <em>which</em> point is the nearest neighbour of a given point,
use <code><a href="#topic+nnwhich">nnwhich</a></code>.
</p>
<p>To use the nearest neighbour distances for statistical inference,
it is often advisable to use the edge-corrected empirical distribution,
computed by <code><a href="spatstat.explore.html#topic+G3est">G3est</a></code>.
</p>
<p>To find the nearest neighbour distances from one point pattern
to another point pattern, use <code><a href="#topic+nncross">nncross</a></code>.
</p>


<h3>Value</h3>

<p>Numeric vector or matrix containing the 
nearest neighbour distances for each point.
</p>
<p>If <code>k = 1</code> (the default), the return value is a
numeric vector <code>v</code> such that <code>v[i]</code> is the
nearest neighbour distance for the <code>i</code>th data point.
</p>
<p>If <code>k</code> is a single integer, then the return value is a
numeric vector <code>v</code> such that <code>v[i]</code> is the
<code>k</code>th nearest neighbour distance for the
<code>i</code>th data point.
</p>
<p>If <code>k</code> is a vector, then the return value is a
matrix <code>m</code> such that <code>m[i,j]</code> is the
<code>k[j]</code>th nearest neighbour distance for the
<code>i</code>th data point.
</p>


<h3>Warnings</h3>

<p>An infinite or <code>NA</code> value is returned if the
distance is not defined (e.g. if there is only one point
in the point pattern).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
based on code for two dimensions by
Pavel Grabarnik <a href="mailto:pavel.grabar@issp.serpukhov.su">pavel.grabar@issp.serpukhov.su</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndist">nndist</a></code>,
<code><a href="#topic+pairdist">pairdist</a></code>,
<code><a href="spatstat.explore.html#topic+G3est">G3est</a></code>,
<code><a href="#topic+nnwhich">nnwhich</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- pp3(runif(40), runif(40), runif(40), box3(c(0,1)))

   # nearest neighbours
   d &lt;- nndist(X)

   # second nearest neighbours
   d2 &lt;- nndist(X, k=2)

   # first, second and third nearest
   d1to3 &lt;- nndist(X, k=1:3)

   # distance to nearest point in each group
   marks(X) &lt;- factor(rep(letters[1:4], 10))
   dby &lt;- nndist(X, by=marks(X))
</code></pre>

<hr>
<h2 id='nndist.ppx'>Nearest Neighbour Distances in Any Dimensions</h2><span id='topic+nndist.ppx'></span>

<h3>Description</h3>

<p>Computes the distance from each point to its nearest neighbour
in a multi-dimensional point pattern.
Alternatively computes the distance to the
second nearest neighbour, or third nearest, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppx'
nndist(X, ..., k=1, by=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nndist.ppx_+3A_x">X</code></td>
<td>

<p>Multi-dimensional point pattern
(object of class <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="nndist.ppx_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+coords.ppx">coords.ppx</a></code> to determine
which coordinates should be used.
</p>
</td></tr>
<tr><td><code id="nndist.ppx_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour. 
</p>
</td></tr>
<tr><td><code id="nndist.ppx_+3A_by">by</code></td>
<td>

<p>Optional. A factor, which separates <code>X</code> into groups.
The algorithm will compute the distance to
the nearest point in each group. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the Euclidean distance from each point
in a multi-dimensional
point pattern to its nearest neighbour (the nearest other
point of the pattern). If <code>k</code> is specified, it computes the
distance to the <code>k</code>th nearest neighbour.
</p>
<p>The function <code>nndist</code> is generic; this function
<code>nndist.ppx</code> is the method for the class <code>"ppx"</code>.
</p>
<p>The argument <code>k</code> may be a single integer, or an integer vector.
If it is a vector, then the <code class="reqn">k</code>th nearest neighbour distances are
computed for each value of <code class="reqn">k</code> specified in the vector.
</p>
<p>If there is only one point (if <code>x</code> has length 1),
then a nearest neighbour distance of <code>Inf</code> is returned.
If there are no points (if <code>x</code> has length zero)
a numeric vector of length zero is returned.
</p>
<p>If the argument <code>by</code> is given, it should be a <code>factor</code>,
of length equal to the number of points in <code>X</code>.
This factor effectively partitions <code>X</code> into subsets,
each subset associated with one of the levels of <code>X</code>.
The algorithm will then compute, for each point of <code>X</code>,
the distance to the nearest neighbour <em>in each subset</em>.
</p>
<p>To identify <em>which</em> point is the nearest neighbour of a given point,
use <code><a href="#topic+nnwhich">nnwhich</a></code>.
</p>
<p>To find the nearest neighbour distances from one point pattern
to another point pattern, use <code><a href="#topic+nncross">nncross</a></code>.
</p>
<p>By default, both spatial and temporal coordinates are extracted.
To obtain the spatial distance between points in a space-time point
pattern, set <code>temporal=FALSE</code>.
</p>


<h3>Value</h3>

<p>Numeric vector or matrix containing the 
nearest neighbour distances for each point.
</p>
<p>If <code>k = 1</code> (the default), the return value is a
numeric vector <code>v</code> such that <code>v[i]</code> is the
nearest neighbour distance for the <code>i</code>th data point.
</p>
<p>If <code>k</code> is a single integer, then the return value is a
numeric vector <code>v</code> such that <code>v[i]</code> is the
<code>k</code>th nearest neighbour distance for the
<code>i</code>th data point.
</p>
<p>If <code>k</code> is a vector, then the return value is a
matrix <code>m</code> such that <code>m[i,j]</code> is the
<code>k[j]</code>th nearest neighbour distance for the
<code>i</code>th data point.
</p>


<h3>Warnings</h3>

<p>An infinite or <code>NA</code> value is returned if the
distance is not defined (e.g. if there is only one point
in the point pattern).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndist">nndist</a></code>,
<code><a href="#topic+pairdist">pairdist</a></code>,
<code><a href="#topic+nnwhich">nnwhich</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   df &lt;- data.frame(x=runif(5),y=runif(5),z=runif(5),w=runif(5))
   X &lt;- ppx(data=df)

   # nearest neighbours
   d &lt;- nndist(X)

   # second nearest neighbours
   d2 &lt;- nndist(X, k=2)

   # first, second and third nearest
   d1to3 &lt;- nndist(X, k=1:3)

   # nearest neighbour distances to each group
   marks(X) &lt;- factor(c("a","a", "b", "b", "b"))
   nndist(X, by=marks(X))
   nndist(X, by=marks(X), k=1:2)
</code></pre>

<hr>
<h2 id='nndist.psp'>Nearest neighbour distances between line segments</h2><span id='topic+nndist.psp'></span>

<h3>Description</h3>

<p>Computes the distance from each line segment 
to its nearest neighbour in a line segment pattern.
Alternatively finds the distance to the second nearest,
third nearest etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'psp'
nndist(X, ..., k=1, method="C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nndist.psp_+3A_x">X</code></td>
<td>

<p>A line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="nndist.psp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="nndist.psp_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour. 
</p>
</td></tr>
<tr><td><code id="nndist.psp_+3A_method">method</code></td>
<td>

<p>String specifying which method of calculation to use.
Values are <code>"C"</code> and <code>"interpreted"</code>.
Usually not specified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+nndist">nndist</a></code>
for the class <code>"psp"</code>.
</p>
<p>If <code>k=1</code>, this function computes the distance from each line segment 
to the nearest other line segment in <code>X</code>.
In general it computes the distance from each line segment to the
<code>k</code>th nearest other line segment.
The argument <code>k</code> can also be a vector, and this computation will
be performed for each value of <code>k</code>.
</p>
<p>Distances are calculated using the Hausdorff metric. The Hausdorff
distance between two line segments is the maximum distance
from any point on one of the segments to the nearest point on
the other segment.   
</p>
<p>If there are fewer than <code>max(k)+1</code> line segments in the pattern,
some of the nearest neighbour distances will be infinite (<code>Inf</code>).
</p>
<p>The argument <code>method</code> is not normally used. It is
retained only for checking the validity of the software.
If <code>method = "interpreted"</code> then the distances are
computed using interpreted <span class="rlang"><b>R</b></span> code only. If <code>method="C"</code>
(the default) then compiled <code>C</code> code is used.
The <code>C</code> code is somewhat faster.
</p>


<h3>Value</h3>

<p>Numeric vector or matrix containing the 
nearest neighbour distances for each line segment.
</p>
<p>If <code>k = 1</code> (the default), the return value is a
numeric vector <code>v</code> such that <code>v[i]</code> is the
nearest neighbour distance for the <code>i</code>th segment.
</p>
<p>If <code>k</code> is a single integer, then the return value is a
numeric vector <code>v</code> such that <code>v[i]</code> is the
<code>k</code>th nearest neighbour distance for the
<code>i</code>th segment.
</p>
<p>If <code>k</code> is a vector, then the return value is a
matrix <code>m</code> such that <code>m[i,j]</code> is the
<code>k[j]</code>th nearest neighbour distance for the
<code>i</code>th segment.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndist">nndist</a></code>,
<code><a href="#topic+nndist.ppp">nndist.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   L &lt;- psp(runif(10), runif(10), runif(10), runif(10), owin())
   D &lt;- nndist(L)
   D &lt;- nndist(L, k=1:3)
</code></pre>

<hr>
<h2 id='nnfun'>
Nearest Neighbour Index Map as a Function 
</h2><span id='topic+nnfun'></span><span id='topic+nnfun.ppp'></span><span id='topic+nnfun.psp'></span>

<h3>Description</h3>

<p>Compute the nearest neighbour index map of an object,
and return it as a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nnfun(X, ...)

  ## S3 method for class 'ppp'
nnfun(X, ..., k=1, value=c("index", "mark"))

  ## S3 method for class 'psp'
nnfun(X, ..., value=c("index", "mark"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnfun_+3A_x">X</code></td>
<td>

<p>Any suitable dataset representing a two-dimensional
collection of objects,
such as a point pattern (object of class <code>"ppp"</code>)
or a line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="nnfun_+3A_k">k</code></td>
<td>

<p>A single integer. The <code>k</code>th nearest neighbour will be found.
</p>
</td></tr>
<tr><td><code id="nnfun_+3A_...">...</code></td>
<td>

<p>Extra arguments are ignored. 
</p>
</td></tr>
<tr><td><code id="nnfun_+3A_value">value</code></td>
<td>

<p>String (partially matched) specifying whether to return the
index of the neighbour (<code>value="index"</code>, the default)
or the mark value of the neighbour (<code>value="mark"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a collection <code class="reqn">X</code> of two dimensional objects
(such as a point pattern or a line segment pattern),
the &ldquo;nearest neighbour index function&rdquo;
of <code class="reqn">X</code> is the mathematical function <code class="reqn">f</code> such that, for any 
two-dimensional spatial location <code class="reqn">(x,y)</code>,
the function value <code>f(x,y)</code>
is the index <code class="reqn">i</code> identifying the closest member of <code class="reqn">X</code>.
That is, if <code class="reqn">i = f(x,y)</code> then <code class="reqn">X[i]</code> is the closest member of
the collection <code class="reqn">X</code> to the location <code class="reqn">(x,y)</code>.
</p>
<p>The command <code>f &lt;- nnfun(X)</code> returns a <em>function</em>
in the <span class="rlang"><b>R</b></span> language, with arguments <code>x,y</code>, that represents the
nearest neighbour index function of <code>X</code>. Evaluating the function <code>f</code>
in the form <code>v &lt;- f(x,y)</code>, where <code>x</code> and <code>y</code>
are any numeric vectors of equal length containing coordinates of
spatial locations, yields the indices of the nearest neighbours
to these locations.
</p>
<p>If the argument <code>k</code> is specified then the <code>k</code>-th nearest
neighbour will be found.
</p>
<p>The result of <code>f &lt;- nnfun(X)</code> also belongs to the class
<code>"funxy"</code> and to the special class <code>"nnfun"</code>.
It can be printed and plotted immediately as shown in the Examples.
</p>
<p>A <code>nnfun</code> object can be converted to a pixel image
using <code><a href="#topic+as.im">as.im</a></code>.
</p>


<h3>Value</h3>

<p>A <code>function</code> with arguments <code>x,y</code>.
The function also belongs to the class <code>"nnfun"</code> which has
a method for <code>print</code>.
It also belongs to the class <code>"funxy"</code> which has methods
for <code>plot</code>, <code>contour</code> and <code>persp</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distfun">distfun</a></code>,
<code><a href="#topic+plot.funxy">plot.funxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   f &lt;- nnfun(cells)
   f
   plot(f)
   f(0.2, 0.3)

   g &lt;- nnfun(cells, k=2)
   g(0.2, 0.3)

   plot(nnfun(amacrine, value="m"))

   L &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
   h &lt;- nnfun(L)
   h(0.2, 0.3)
</code></pre>

<hr>
<h2 id='nnmap'>
K-th Nearest Point Map
</h2><span id='topic+nnmap'></span>

<h3>Description</h3>

<p>Given a point pattern, this function constructs pixel images
giving the distance from each pixel to its <code class="reqn">k</code>-th nearest
neighbour in the point pattern, and the index of the <code class="reqn">k</code>-th nearest
neighbour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nnmap(X, k = 1, what = c("dist", "which"),
  ..., W = as.owin(X),
  is.sorted.X = FALSE, sortby = c("range", "var", "x", "y"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnmap_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="nnmap_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will find the 
<code>k</code>th nearest neighbour. 
</p>
</td></tr>
<tr><td><code id="nnmap_+3A_what">what</code></td>
<td>

<p>Character string specifying what information should be returned.
Either the nearest neighbour distance (<code>"dist"</code>),
the index of the nearest neighbour (<code>"which"</code>),
or both.
</p>
</td></tr>
<tr><td><code id="nnmap_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine the pixel
resolution of the result.
</p>
</td></tr>
<tr><td><code id="nnmap_+3A_w">W</code></td>
<td>

<p>Window (object of class <code>"owin"</code>) specifying the spatial domain
in which the distances will be computed.
Defaults to the window of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="nnmap_+3A_is.sorted.x">is.sorted.X</code></td>
<td>

<p>Logical value attesting whether the point pattern <code>X</code>
has been sorted. See Details.
</p>
</td></tr>
<tr><td><code id="nnmap_+3A_sortby">sortby</code></td>
<td>

<p>Determines which coordinate to use to sort the point pattern.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a point pattern <code>X</code>, this function constructs two pixel images:
</p>

<ul>
<li><p> a distance map giving, for each pixel,
the distance to the nearest point of <code>X</code>;
</p>
</li>
<li><p> a nearest neighbour map giving, for each pixel,
the identifier of the nearest point of <code>X</code>.
</p>
</li></ul>

<p>If the argument <code>k</code> is specified, then the <code>k</code>-th nearest
neighbours will be found.
</p>
<p>If <code>what="dist"</code> then only the distance map is returned.
If <code>what="which"</code> then only the nearest neighbour map
is returned.
</p>
<p>The argument <code>k</code> may be an integer or an integer vector.
If it is a single integer, then the <code>k</code>-th nearest neighbours
are computed. If it is a vector, then the <code>k[i]</code>-th nearest
neighbours are computed for each entry <code>k[i]</code>. For example, setting
<code>k=1:3</code> will compute the nearest, second-nearest and
third-nearest neighbours. 
</p>


<h3>Value</h3>

<p>A pixel image, or a list of pixel images.
</p>
<p>By default (if <code>what=c("dist", "which")</code>), the result is
a list with two components <code>dist</code> and <code>which</code>
containing the distance map and the nearest neighbour map.
</p>
<p>If <code>what="dist"</code> then the result is a real-valued pixel image
containing the distance map.
</p>
<p>If <code>what="which"</code> then the result is an integer-valued pixel image
containing the nearest neighbour map.
</p>
<p>If <code>k</code> is a vector of several integers, then the result is
similar except that each pixel image is replaced by a list of
pixel images, one for each entry of <code>k</code>.
</p>


<h3>Sorting data and pre-sorted data</h3>

<p>Read this section if you care about the speed of computation.
</p>
<p>For efficiency, the algorithm sorts the point pattern <code>X</code>
into increasing order of the <code class="reqn">x</code> coordinate
or increasing order of the the <code class="reqn">y</code> coordinate.
Sorting is only an intermediate step;
it does not affect the output, which is always given in the same
order as the original data.
</p>
<p>By default (if <code>sortby="range"</code>),
the sorting will occur on the coordinate that has the larger range of
values (according to the frame of the enclosing window of <code>X</code>).
If <code>sortby = "var"</code>), sorting will occur on the coordinate that
has the greater variance (in the pattern <code>X</code>).
Setting <code>sortby="x"</code> or <code>sortby = "y"</code> will specify that
sorting should occur on the <code class="reqn">x</code> or <code class="reqn">y</code> coordinate, respectively.
</p>
<p>If the point pattern <code>X</code> is already
sorted, then the argument <code>is.sorted.X</code>
should be set to <code>TRUE</code>, and <code>sortby</code> should be set
equal to <code>"x"</code> or <code>"y"</code> to indicate which coordinate
is sorted.
</p>


<h3>Warning About Ties</h3>

<p>Ties are possible: there may be two data points
which lie exactly the same distance away from a particular pixel.
This affects the results from <code>nnmap(what="which")</code>.
The handling of ties is not well-defined: it is not consistent
between different computers and different installations of <span class="rlang"><b>R</b></span>.
If there are ties, then different calls to <code>nnmap(what="which")</code>
may give inconsistent results. For example, you may get a different answer
from <code>nnmap(what="which",k=1)</code>
and <code>nnmap(what="which", k=1:2)[[1]]</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
,
and Jens Oehlschlaegel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmap">distmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(nnmap(cells, 2, what="which"))
</code></pre>

<hr>
<h2 id='nnmark'>
Mark of Nearest Neighbour 
</h2><span id='topic+nnmark'></span>

<h3>Description</h3>

<p>Given a marked point pattern dataset <code>X</code>
this function computes, for each desired location <code>y</code>,
the mark attached to the nearest neighbour of <code>y</code> in <code>X</code>.
The desired locations <code>y</code> can be either a pixel grid
or the point pattern <code>X</code> itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnmark(X, ..., k = 1, at=c("pixels", "points"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnmark_+3A_x">X</code></td>
<td>

<p>A marked point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="nnmark_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine the
pixel resolution.
</p>
</td></tr>
<tr><td><code id="nnmark_+3A_k">k</code></td>
<td>

<p>Single integer. The <code>k</code>th nearest data point will be used.
</p>
</td></tr>
<tr><td><code id="nnmark_+3A_at">at</code></td>
<td>

<p>String specifying whether to compute the values
at a grid of pixel locations (<code>at="pixels"</code>) or
only at the points of <code>X</code> (<code>at="points"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a marked point pattern dataset <code>X</code>
this function computes, for each desired location <code>y</code>,
the mark attached to the point of <code>X</code> that is nearest
to <code>y</code>. The desired locations <code>y</code> can be either a pixel grid
or the point pattern <code>X</code> itself.
</p>
<p>The argument <code>X</code> must be a marked point pattern (object
of class <code>"ppp"</code>, see <code><a href="#topic+ppp.object">ppp.object</a></code>).
The marks are allowed to be a vector or a data frame.
</p>

<ul>
<li>
<p>If <code>at="points"</code>, then for each point in <code>X</code>,
the algorithm finds the nearest <em>other</em> point in <code>X</code>,
and extracts the mark attached to it.
The result is a vector or data frame containing the marks
of the neighbours of each point.
</p>
</li>
<li>
<p>If <code>at="pixels"</code> (the default), then for each pixel
in a rectangular grid, the algorithm finds the nearest point in <code>X</code>,
and extracts the mark attached to it.
The result is an image or a list of images containing the marks
of the neighbours of each pixel.
The pixel resolution is controlled by the arguments <code>...</code>
passed to <code><a href="#topic+as.mask">as.mask</a></code>.
</p>
</li></ul>

<p>If the argument <code>k</code> is given, then the <code>k</code>-th nearest
neighbour will be used.
</p>


<h3>Value</h3>

<p><em>If <code>X</code> has a single column of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is
a pixel image (object of class <code>"im"</code>). 
The value at each pixel is the mark attached
to the nearest point of <code>X</code>.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a vector or factor
of length equal to the number of points in <code>X</code>.
Entries are the mark values of the
nearest neighbours of each point of <code>X</code>.
</p>
</li></ul>

<p><em>If <code>X</code> has a data frame of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is a named list of 
pixel images (object of class <code>"im"</code>). There is one
image for each column of marks. This list also belongs to
the class <code>"solist"</code>, for which there is a plot method.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a data frame
with one row for each point of <code>X</code>,
Entries are the mark values of the
nearest neighbours of each point of <code>X</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>,
<code><a href="spatstat.explore.html#topic+marktable">marktable</a></code>,
<code><a href="#topic+nnwhich">nnwhich</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(nnmark(ants))
  v &lt;- nnmark(ants, at="points")
  v[1:10]
  plot(nnmark(finpines))
  vf &lt;- nnmark(finpines, at="points")
  vf[1:5,]
</code></pre>

<hr>
<h2 id='nnwhich'>Nearest neighbour</h2><span id='topic+nnwhich'></span><span id='topic+nnwhich.ppp'></span><span id='topic+nnwhich.default'></span>

<h3>Description</h3>

<p>Finds the nearest neighbour of each point in a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nnwhich(X, ...)
  ## S3 method for class 'ppp'
nnwhich(X, ..., k=1, by=NULL, method="C", metric=NULL)
  ## Default S3 method:
nnwhich(X, Y=NULL, ..., k=1, by=NULL, method="C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnwhich_+3A_x">X</code>, <code id="nnwhich_+3A_y">Y</code></td>
<td>

<p>Arguments specifying the locations of
a set of points.
For <code>nnwhich.ppp</code>, the argument <code>X</code> should be a point
pattern (object of class <code>"ppp"</code>).
For <code>nnwhich.default</code>, typically <code>X</code> and <code>Y</code> would be
numeric vectors of equal length. Alternatively <code>Y</code> may be
omitted and <code>X</code> may be
a list with two components <code>x</code> and <code>y</code>,
or a matrix with two columns.
</p>
</td></tr>
<tr><td><code id="nnwhich_+3A_...">...</code></td>
<td>

<p>Ignored by <code>nnwhich.ppp</code>
and <code>nnwhich.default</code>.
</p>
</td></tr>
<tr><td><code id="nnwhich_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour. 
</p>
</td></tr>
<tr><td><code id="nnwhich_+3A_by">by</code></td>
<td>

<p>Optional. A factor, which separates <code>X</code> into groups.
The algorithm will find the nearest neighbour in each group.
See Details.
</p>
</td></tr>
<tr><td><code id="nnwhich_+3A_method">method</code></td>
<td>
<p>String specifying which method of calculation to use.
Values are <code>"C"</code> and <code>"interpreted"</code>.
</p>
</td></tr>
<tr><td><code id="nnwhich_+3A_metric">metric</code></td>
<td>

<p>Optional. A metric (object of class <code>"metric"</code>)
that will be used to define and compute the distances.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each point in the given point pattern, this function finds
its nearest neighbour (the nearest other point of the pattern).
By default it returns a vector giving, for each point,
the index of the point's
nearest neighbour. If <code>k</code> is specified, the algorithm finds
each point's <code>k</code>th nearest neighbour.
</p>
<p>The function <code>nnwhich</code> is generic, with
method for point patterns (objects of class <code>"ppp"</code>)
and a default method which are described here, as well as a method for
three-dimensional point patterns (objects of class <code>"pp3"</code>,
described in <code><a href="#topic+nnwhich.pp3">nnwhich.pp3</a></code>.
</p>
<p>The method <code>nnwhich.ppp</code> expects a single
point pattern argument <code>X</code>.
The default method expects that <code>X</code> and <code>Y</code> will determine
the coordinates of a set of points. Typically <code>X</code> and
<code>Y</code> would be numeric vectors of equal length. Alternatively
<code>Y</code> may be omitted and <code>X</code> may be a list with two components
named <code>x</code> and <code>y</code>, or a matrix or data frame with two columns.
</p>
<p>The argument <code>k</code> may be a single integer, or an integer vector.
If it is a vector, then the <code class="reqn">k</code>th nearest neighbour distances are
computed for each value of <code class="reqn">k</code> specified in the vector.
</p>
<p>If the argument <code>by</code> is given, it should be a <code>factor</code>,
of length equal to the number of points in <code>X</code>.
This factor effectively partitions <code>X</code> into subsets,
each subset associated with one of the levels of <code>X</code>.
The algorithm will then find, for each point of <code>X</code>,
the nearest neighbour <em>in each subset</em>.
</p>
<p>If there are no points (if <code>x</code> has length zero)
a numeric vector of length zero is returned.
If there is only one point (if <code>x</code> has length 1),
then the nearest neighbour is undefined, and a value of <code>NA</code>
is returned. In general if the number of points is less than or equal
to <code>k</code>, then a vector of <code>NA</code>'s is returned.
</p>
<p>The argument <code>method</code> is not normally used. It is
retained only for checking the validity of the software.
If <code>method = "interpreted"</code> then the distances are
computed using interpreted R code only. If <code>method="C"</code>
(the default) then C code is used. 
The C code is faster by two to three orders of magnitude
and uses much less memory.
</p>
<p>To evaluate the <em>distance</em> between a point and its nearest
neighbour, use <code><a href="#topic+nndist">nndist</a></code>.
</p>
<p>To find the nearest neighbours from one point pattern
to another point pattern, use <code><a href="#topic+nncross">nncross</a></code>.
</p>


<h3>Value</h3>

<p>Numeric vector or matrix giving, for each point,
the index of its nearest neighbour (or <code>k</code>th nearest neighbour).
</p>
<p>If <code>k = 1</code> (the default), the return value is a
numeric vector <code>v</code> giving the indices of the nearest neighbours
(the nearest neighbout of the <code>i</code>th point is
the <code>j</code>th point where <code>j = v[i]</code>).
</p>
<p>If <code>k</code> is a single integer, then the return value is a
numeric vector giving the indices of the
<code>k</code>th nearest neighbours.
</p>
<p>If <code>k</code> is a vector, then the return value is a
matrix <code>m</code> such that <code>m[i,j]</code> is the
index of the <code>k[j]</code>th nearest neighbour for the
<code>i</code>th data point.
</p>
<p>If the argument <code>by</code> is given, then it should be a <code>factor</code>
which separates <code>X</code> into groups (or any type of data acceptable to
<code><a href="#topic+split.ppp">split.ppp</a></code> that determines the grouping).
The result is a data frame
containing the indices described above, from each point of <code>X</code>,
to the nearest point in each subset of <code>X</code>
defined by the factor <code>by</code>.
</p>


<h3>Nearest neighbours of each type</h3>

<p>If <code>X</code> is a multitype point pattern 
and <code>by=marks(X)</code>, then the algorithm will find,
for each point of <code>X</code>, the nearest neighbour
of each type. See the Examples. 
</p>


<h3>Warnings</h3>

<p>A value of <code>NA</code> is returned if there is only one point
in the point pattern. 
</p>


<h3>Author(s)</h3>

<p>Pavel Grabarnik <a href="mailto:pavel.grabar@issp.serpukhov.su">pavel.grabar@issp.serpukhov.su</a>
and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndist">nndist</a></code>,
<code><a href="#topic+nncross">nncross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(cells)
   m &lt;- nnwhich(cells)
   m2 &lt;- nnwhich(cells, k=2)

   # plot nearest neighbour links
   b &lt;- cells[m]
   arrows(cells$x, cells$y, b$x, b$y, angle=15, length=0.15, col="red")

   # find points which are the neighbour of their neighbour
   self &lt;- (m[m] == seq(m))
   # plot them
   A &lt;- cells[self]
   B &lt;- cells[m[self]]
   plot(cells)
   segments(A$x, A$y, B$x, B$y)

   # nearest neighbours of each type
   head(nnwhich(ants, by=marks(ants)))
</code></pre>

<hr>
<h2 id='nnwhich.pp3'>Nearest neighbours in three dimensions</h2><span id='topic+nnwhich.pp3'></span>

<h3>Description</h3>

<p>Finds the nearest neighbour of each point in a three-dimensional
point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'pp3'
nnwhich(X, ..., k=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnwhich.pp3_+3A_x">X</code></td>
<td>

<p>Three-dimensional point pattern 
(object of class <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="nnwhich.pp3_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="nnwhich.pp3_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each point in the given three-dimensional
point pattern, this function finds
its nearest neighbour (the nearest other point of the pattern).
By default it returns a vector giving, for each point,
the index of the point's
nearest neighbour. If <code>k</code> is specified, the algorithm finds
each point's <code>k</code>th nearest neighbour.
</p>
<p>The function <code>nnwhich</code> is generic. This is the method
for the class <code>"pp3"</code>.
</p>
<p>If there are no points in the pattern,
a numeric vector of length zero is returned.
If there is only one point,
then the nearest neighbour is undefined, and a value of <code>NA</code>
is returned. In general if the number of points is less than or equal
to <code>k</code>, then a vector of <code>NA</code>'s is returned.
</p>
<p>To evaluate the <em>distance</em> between a point and its nearest
neighbour, use <code><a href="#topic+nndist">nndist</a></code>.
</p>
<p>To find the nearest neighbours from one point pattern
to another point pattern, use <code><a href="#topic+nncross">nncross</a></code>.
</p>


<h3>Value</h3>

<p>Numeric vector or matrix giving, for each point,
the index of its nearest neighbour (or <code>k</code>th nearest neighbour).
</p>
<p>If <code>k = 1</code> (the default), the return value is a
numeric vector <code>v</code> giving the indices of the nearest neighbours
(the nearest neighbout of the <code>i</code>th point is
the <code>j</code>th point where <code>j = v[i]</code>).
</p>
<p>If <code>k</code> is a single integer, then the return value is a
numeric vector giving the indices of the
<code>k</code>th nearest neighbours.
</p>
<p>If <code>k</code> is a vector, then the return value is a
matrix <code>m</code> such that <code>m[i,j]</code> is the
index of the <code>k[j]</code>th nearest neighbour for the
<code>i</code>th data point.
</p>


<h3>Warnings</h3>

<p>A value of <code>NA</code> is returned if there is only one point
in the point pattern. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
based on two-dimensional code by
Pavel Grabarnik <a href="mailto:pavel.grabar@issp.serpukhov.su">pavel.grabar@issp.serpukhov.su</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnwhich">nnwhich</a></code>,
<code><a href="#topic+nndist">nndist</a></code>,
<code><a href="#topic+nncross">nncross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(spatstat.random)) {
   X &lt;- runifpoint3(30)
} else {
   X &lt;- osteo$pts[[1]]
}
   m &lt;- nnwhich(X)
   m2 &lt;- nnwhich(X, k=2)
</code></pre>

<hr>
<h2 id='nnwhich.ppx'>Nearest Neighbours in Any Dimensions</h2><span id='topic+nnwhich.ppx'></span>

<h3>Description</h3>

<p>Finds the nearest neighbour of each point in a multi-dimensional
point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppx'
nnwhich(X, ..., k=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnwhich.ppx_+3A_x">X</code></td>
<td>

<p>Multi-dimensional point pattern 
(object of class <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="nnwhich.ppx_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+coords.ppx">coords.ppx</a></code> to determine
which coordinates should be used.
</p>
</td></tr>
<tr><td><code id="nnwhich.ppx_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each point in the given multi-dimensional
point pattern, this function finds
its nearest neighbour (the nearest other point of the pattern).
By default it returns a vector giving, for each point,
the index of the point's
nearest neighbour. If <code>k</code> is specified, the algorithm finds
each point's <code>k</code>th nearest neighbour.
</p>
<p>The function <code>nnwhich</code> is generic. This is the method
for the class <code>"ppx"</code>.
</p>
<p>If there are no points in the pattern,
a numeric vector of length zero is returned.
If there is only one point,
then the nearest neighbour is undefined, and a value of <code>NA</code>
is returned. In general if the number of points is less than or equal
to <code>k</code>, then a vector of <code>NA</code>'s is returned.
</p>
<p>To evaluate the <em>distance</em> between a point and its nearest
neighbour, use <code><a href="#topic+nndist">nndist</a></code>.
</p>
<p>To find the nearest neighbours from one point pattern
to another point pattern, use <code><a href="#topic+nncross">nncross</a></code>.
</p>
<p>By default, both spatial and temporal coordinates are extracted.
To obtain the spatial distance between points in a space-time point
pattern, set <code>temporal=FALSE</code>.
</p>


<h3>Value</h3>

<p>Numeric vector or matrix giving, for each point,
the index of its nearest neighbour (or <code>k</code>th nearest neighbour).
</p>
<p>If <code>k = 1</code> (the default), the return value is a
numeric vector <code>v</code> giving the indices of the nearest neighbours
(the nearest neighbout of the <code>i</code>th point is
the <code>j</code>th point where <code>j = v[i]</code>).
</p>
<p>If <code>k</code> is a single integer, then the return value is a
numeric vector giving the indices of the
<code>k</code>th nearest neighbours.
</p>
<p>If <code>k</code> is a vector, then the return value is a
matrix <code>m</code> such that <code>m[i,j]</code> is the
index of the <code>k[j]</code>th nearest neighbour for the
<code>i</code>th data point.
</p>


<h3>Warnings</h3>

<p>A value of <code>NA</code> is returned if there is only one point
in the point pattern. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnwhich">nnwhich</a></code>,
<code><a href="#topic+nndist">nndist</a></code>,
<code><a href="#topic+nncross">nncross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   df &lt;- data.frame(x=runif(5),y=runif(5),z=runif(5),w=runif(5))
   X &lt;- ppx(data=df)
   m &lt;- nnwhich(X)
   m2 &lt;- nnwhich(X, k=2)
</code></pre>

<hr>
<h2 id='nobjects'>
Count Number of Geometrical Objects in a Spatial Dataset
</h2><span id='topic+nobjects'></span><span id='topic+nobjects.ppp'></span><span id='topic+nobjects.ppx'></span><span id='topic+nobjects.psp'></span><span id='topic+nobjects.tess'></span>

<h3>Description</h3>

<p>A generic function to count the number of geometrical objects in a
spatial dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nobjects(x)

  ## S3 method for class 'ppp'
nobjects(x)

  ## S3 method for class 'ppx'
nobjects(x)

  ## S3 method for class 'psp'
nobjects(x)

  ## S3 method for class 'tess'
nobjects(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobjects_+3A_x">x</code></td>
<td>
<p>A dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic function <code>nobjects</code> counts the number of
geometrical objects in the spatial dataset <code>x</code>.
</p>
<p>The methods for point patterns (classes <code>"ppp"</code> and <code>"ppx"</code>,
embracing <code>"pp3"</code> and <code>"lpp"</code>)
count the number of points in the pattern.
</p>
<p>The method for line segment patterns (class <code>"psp"</code>)
counts the number of line segments in the pattern.
</p>
<p>The method for tessellations
(class <code>"tess"</code>)
counts the number of tiles of the tessellation.
</p>


<h3>Value</h3>

<p>A single integer.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npoints">npoints</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   nobjects(redwood)
   nobjects(edges(letterR))
   nobjects(dirichlet(cells))
</code></pre>

<hr>
<h2 id='npoints'>Number of Points in a Point Pattern</h2><span id='topic+npoints'></span><span id='topic+npoints.ppp'></span><span id='topic+npoints.pp3'></span><span id='topic+npoints.ppx'></span>

<h3>Description</h3>

<p>Returns the number of points in a point pattern of any kind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  npoints(x)
  ## S3 method for class 'ppp'
npoints(x)
  ## S3 method for class 'pp3'
npoints(x)
  ## S3 method for class 'ppx'
npoints(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npoints_+3A_x">x</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>,
<code>"pp3"</code>, <code>"ppx"</code> or some other suitable class).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the number of points in
a point pattern. The function <code>npoints</code> is generic
with methods for the classes <code>"ppp"</code>, <code>"pp3"</code>,
<code>"ppx"</code> and possibly other classes.
</p>


<h3>Value</h3>

<p>Integer.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+print.pp3">print.pp3</a></code>,
<code><a href="#topic+print.ppx">print.ppx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   npoints(cells)
</code></pre>

<hr>
<h2 id='nsegments'>
Number of Line Segments in a Line Segment Pattern
</h2><span id='topic+nsegments'></span><span id='topic+nsegments.psp'></span>

<h3>Description</h3>

<p>Returns the number of line segments in a line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   nsegments(x)

   ## S3 method for class 'psp'
nsegments(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsegments_+3A_x">x</code></td>
<td>

<p>A line segment pattern, i.e. an object of class <code>psp</code>,
or an object containing a linear network.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is generic, with methods for 
classes <code>psp</code>, <code>linnet</code> and <code>lpp</code>.
</p>


<h3>Value</h3>

<p>Integer.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npoints">npoints</a>()</code>, <code><a href="#topic+psp.object">psp.object</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nsegments(copper$Lines)
nsegments(copper$SouthLines)
</code></pre>

<hr>
<h2 id='nvertices'>
Count Number of Vertices
</h2><span id='topic+nvertices'></span><span id='topic+nvertices.owin'></span><span id='topic+nvertices.default'></span>

<h3>Description</h3>

<p>Count the number of vertices in an object for which vertices are well-defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nvertices(x, ...)

  ## S3 method for class 'owin'
nvertices(x, ...)

  ## Default S3 method:
nvertices(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nvertices_+3A_x">x</code></td>
<td>

<p>A window (object of class <code>"owin"</code>),
or some other object which has vertices.
</p>
</td></tr>
<tr><td><code id="nvertices_+3A_...">...</code></td>
<td>

<p>Currently ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function counts the number of vertices of <code>x</code>
as they would be returned by <code><a href="#topic+vertices">vertices</a>(x)</code>.
It is more efficient than executing <code>npoints(vertices(x))</code>.
</p>


<h3>Value</h3>

<p>A single integer.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
and Suman Rakshit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vertices">vertices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  nvertices(square(2))
  nvertices(letterR)
</code></pre>

<hr>
<h2 id='opening'>Morphological Opening</h2><span id='topic+opening'></span><span id='topic+opening.owin'></span><span id='topic+opening.psp'></span><span id='topic+opening.ppp'></span>

<h3>Description</h3>

<p>Perform morphological opening of a window, a line segment pattern
or a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> opening(w, r, ...)

 ## S3 method for class 'owin'
opening(w, r, ..., polygonal=NULL)

 ## S3 method for class 'ppp'
opening(w, r, ...)

 ## S3 method for class 'psp'
opening(w, r, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opening_+3A_w">w</code></td>
<td>

<p>A window (object of class <code>"owin"</code>
or a line segment pattern (object of class <code>"psp"</code>)
or a point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="opening_+3A_r">r</code></td>
<td>
<p>positive number: the radius of the opening.</p>
</td></tr>
<tr><td><code id="opening_+3A_...">...</code></td>
<td>

<p>extra arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
controlling the pixel resolution, if a pixel approximation is used
</p>
</td></tr>
<tr><td><code id="opening_+3A_polygonal">polygonal</code></td>
<td>

<p>Logical flag indicating whether to compute a polygonal
approximation to the erosion (<code>polygonal=TRUE</code>) or
a pixel grid approximation (<code>polygonal=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The morphological opening (Serra, 1982)
of a set <code class="reqn">W</code> by a distance <code class="reqn">r &gt; 0</code>
is the subset of points in <code class="reqn">W</code> that can be 
separated from the boundary of <code class="reqn">W</code> by a circle of radius <code class="reqn">r</code>.
That is, a point <code class="reqn">x</code> belongs to the opening 
if it is possible to draw a circle of radius <code class="reqn">r</code> (not necessarily
centred on <code class="reqn">x</code>) that has <code class="reqn">x</code> on the inside
and the boundary of <code class="reqn">W</code> on the outside.
The opened set is a subset of <code>W</code>.
</p>
<p>For a small radius <code class="reqn">r</code>, the opening operation
has the effect of smoothing out irregularities in the boundary of
<code class="reqn">W</code>. For larger radii, the opening operation removes promontories
in the boundary. For very large radii, the opened set is empty.
</p>
<p>The algorithm applies <code><a href="#topic+erosion">erosion</a></code> followed by
<code><a href="#topic+dilation">dilation</a></code>.
</p>


<h3>Value</h3>

<p>If <code>r &gt; 0</code>, an object of class <code>"owin"</code> representing the
opened region. If <code>r=0</code>, the result is identical to <code>w</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Serra, J. (1982)
Image analysis and mathematical morphology.
Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+closing">closing</a></code> for the opposite operation.
</p>
<p><code><a href="#topic+dilation">dilation</a></code>, <code><a href="#topic+erosion">erosion</a></code> for the basic
operations.  
</p>
<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code> for information about windows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  v &lt;- opening(letterR, 0.3)
  plot(letterR, type="n", main="opening")
  plot(v, add=TRUE, col="grey")
  plot(letterR, add=TRUE)
</code></pre>

<hr>
<h2 id='overlap.owin'>
Compute Area of Overlap
</h2><span id='topic+overlap.owin'></span>

<h3>Description</h3>

<p>Computes the area of the overlap (intersection) of
two windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap.owin(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap.owin_+3A_a">A</code>, <code id="overlap.owin_+3A_b">B</code></td>
<td>

<p>Windows (objects of class <code>"owin"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the area of the overlap between the two
windows <code>A</code> and <code>B</code>.
</p>
<p>If one of the windows is a binary mask, then both windows
are converted to masks on the same grid, and the area is
computed by counting pixels. Otherwise, the area is computed
analytically (using the discrete Stokes theorem).
</p>


<h3>Value</h3>

<p>A single numeric value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect.owin">intersect.owin</a></code>, 
<code><a href="#topic+area.owin">area.owin</a></code>,
<code><a href="#topic+setcov">setcov</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A &lt;- square(1)
  B &lt;- shift(A, c(0.3, 0.2))
  overlap.owin(A, B)
</code></pre>

<hr>
<h2 id='owin'>Create a Window</h2><span id='topic+owin'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"owin"</code> representing 
an observation window in the two-dimensional plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  owin(xrange=c(0,1), yrange=c(0,1), ..., poly=NULL, mask=NULL,
unitname=NULL, xy=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="owin_+3A_xrange">xrange</code></td>
<td>
<p><code class="reqn">x</code> coordinate limits of enclosing box</p>
</td></tr>
<tr><td><code id="owin_+3A_yrange">yrange</code></td>
<td>
<p><code class="reqn">y</code> coordinate limits of enclosing box</p>
</td></tr>
<tr><td><code id="owin_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="owin_+3A_poly">poly</code></td>
<td>

<p>Optional. Polygonal boundary of window.
Incompatible with <code>mask</code>.
</p>
</td></tr>
<tr><td><code id="owin_+3A_mask">mask</code></td>
<td>

<p>Optional. Logical matrix giving binary image of window.
Incompatible with <code>poly</code>.
</p>
</td></tr>
<tr><td><code id="owin_+3A_unitname">unitname</code></td>
<td>

<p>Optional. Name of unit of length. Either a single character string,
or a vector of two character strings giving the
singular and plural forms, respectively.
</p>
</td></tr>
<tr><td><code id="owin_+3A_xy">xy</code></td>
<td>

<p>Optional. List with components <code>x</code> and <code>y</code> specifying the
pixel coordinates for <code>mask</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the <span class="pkg">spatstat</span> library, a point pattern dataset must include
information about the window of observation. This is represented by
an object of class <code>"owin"</code>.
See <code><a href="#topic+owin.object">owin.object</a></code> for an overview.
</p>
<p>To create a window in its own right, 
users would normally invoke <code>owin</code>,
although sometimes <code><a href="#topic+as.owin">as.owin</a></code> may be convenient.
</p>
<p>A window may be rectangular, polygonal, or a mask (a binary image).
</p>

<ul>
<li>
<p><b>rectangular windows:</b>
If only <code>xrange</code> and <code>yrange</code> are given, then
the window will be rectangular, with its <code class="reqn">x</code> and <code class="reqn">y</code>
coordinate dimensions given by these two arguments
(which must be vectors of length 2).
If no arguments are given at all, the default is the unit square
with dimensions <code>xrange=c(0,1)</code> and <code>yrange=c(0,1)</code>.
</p>
</li>
<li>
<p><b>polygonal windows:</b>
If <code>poly</code> is given, then the window will be polygonal.
</p>

<ul>
<li>
<p><em>single polygon:</em>
If <code>poly</code> is a matrix or data frame with two columns, or
a structure with two component vectors <code>x</code> and <code>y</code>
of equal length,
then these values are interpreted as the cartesian coordinates
of the vertices of a polygon circumscribing the window.
The vertices must be listed <em>anticlockwise</em>.
No vertex should be repeated (i.e. do not repeat the first
vertex).
</p>
</li>
<li>
<p><em>multiple polygons or holes:</em>
If <code>poly</code> is a list, each entry <code>poly[[i]]</code>
of which is a matrix or data frame with two columns
or a structure with
two component vectors <code>x</code> and <code>y</code> of equal length,
then the successive list members <code>poly[[i]]</code>
are interpreted as separate polygons which together
make up the boundary of the window.
The vertices of each polygon must be listed <em>anticlockwise</em>
if the polygon is part of the external boundary,
but <em>clockwise</em>
if the polygon is the boundary of a hole in the window.
Again, do not repeat any vertex.
</p>
</li></ul>

</li>
<li>
<p><b>binary masks:</b>
If <code>mask</code> is given, then the window will be a binary image.
</p>

<ul>
<li>
<p><em>Specified by logical matrix:</em>
Normally the argument <code>mask</code> should be a logical matrix
such that <code>mask[i,j]</code> is <code>TRUE</code> if the point
<code>(x[j],y[i])</code> belongs to the window, and <code>FALSE</code> if it
does not (<code>NA</code> entries will be treated as <code>FALSE</code>).
Note carefully that rows of <code>mask</code> correspond to the
<code class="reqn">y</code> coordinate, and columns to the <code class="reqn">x</code> coordinate.
Here <code>x</code> and <code>y</code> are vectors of <code class="reqn">x</code> and <code class="reqn">y</code>
coordinates equally spaced over <code>xrange</code> and <code>yrange</code>
respectively. The pixel coordinate vectors <code>x</code> and <code>y</code>
may be specified explicitly using the argument <code>xy</code>, which
should be a list containing components <code>x</code> and <code>y</code>.
Alternatively there is a sensible default.
</p>
</li>
<li>
<p><em>Specified by list of pixel coordinates:</em>
Alternatively the argument <code>mask</code> can be a data frame
with 2 or 3 columns. If it has 2 columns, it is expected to
contain the spatial coordinates of all the
pixels which are inside the window.
If it has 3 columns,
it should contain the spatial coordinates <code class="reqn">(x,y)</code>
of every pixel in the grid, and the logical value associated
with each pixel. The pixels may be listed in any order.
</p>
</li></ul>

</li></ul>

<p>To create a window which is mathematically
defined by inequalities in the Cartesian coordinates, 
use <code><a href="#topic+raster.x">raster.x</a>()</code> and <code><a href="#topic+raster.y">raster.y</a>()</code>
as in the examples below.
</p>
<p>Functions <code><a href="#topic+square">square</a></code> and <code><a href="#topic+disc">disc</a></code>
will create square and circular windows, respectively.
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code> 
describing a window in the two-dimensional plane.
</p>


<h3>Validity of polygon data</h3>

<p>Polygon data may contain geometrical inconsistencies such as
self-intersections and overlaps. These inconsistencies must be
removed to prevent problems in other <span class="pkg">spatstat</span> functions.
By default, polygon data will be repaired automatically
using polygon-clipping code.
The repair process may change the number of vertices in a polygon
and the number of polygon components. 
To disable the repair process, set <code>spatstat.options(fixpolygons=FALSE)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+complement.owin">complement.owin</a></code>,
<code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+ppp">ppp</a></code>
</p>
<p><code><a href="#topic+square">square</a></code>,
<code><a href="#topic+hexagon">hexagon</a></code>,
<code><a href="#topic+regularpolygon">regularpolygon</a></code>, <code><a href="#topic+disc">disc</a></code>,
<code><a href="#topic+ellipse">ellipse</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- owin()
  w &lt;- owin(c(0,1), c(0,1))
  # the unit square

  w &lt;- owin(c(10,20), c(10,30), unitname=c("foot","feet"))
  # a rectangle of dimensions 10 x 20 feet
  # with lower left corner at (10,10)

  # polygon (diamond shape)
  w &lt;- owin(poly=list(x=c(0.5,1,0.5,0),y=c(0,1,2,1)))
  w &lt;- owin(c(0,1), c(0,2), poly=list(x=c(0.5,1,0.5,0),y=c(0,1,2,1)))

  # polygon with hole
  ho &lt;- owin(poly=list(list(x=c(0,1,1,0), y=c(0,0,1,1)),
                       list(x=c(0.6,0.4,0.4,0.6), y=c(0.2,0.2,0.4,0.4))))
  
  w &lt;- owin(c(-1,1), c(-1,1), mask=matrix(TRUE, 100,100))
          # 100 x 100 image, all TRUE
  X &lt;- raster.x(w)
  Y &lt;- raster.y(w)
  wm &lt;- owin(w$xrange, w$yrange, mask=(X^2 + Y^2 &lt;= 1))
          # discrete approximation to the unit disc

  # vertices of a polygon (listed anticlockwise)
  bdry &lt;- list(x=c(0.1,0.3,0.7,0.4,0.2),
               y=c(0.1,0.1,0.5,0.7,0.3))
  # vertices could alternatively be read from a file, or use locator()
  w &lt;- owin(poly=bdry)
 
 ## Not run: 
 # how to read in a binary mask from a file
 im &lt;- as.logical(matrix(scan("myfile"), nrow=128, ncol=128))
 # read in an arbitrary 128 x 128 digital image from text file
 rim &lt;- im[, 128:1]
 # Assuming it was given in row-major order in the file
 # i.e. scanning left-to-right in rows from top-to-bottom,
 # the use of matrix() has effectively transposed rows &amp; columns,
 # so to convert it to our format just reverse the column order.
 w &lt;- owin(mask=rim)
 plot(w)
 # display it to check!
 
## End(Not run)
</code></pre>

<hr>
<h2 id='owin.object'>Class owin</h2><span id='topic+owin.object'></span>

<h3>Description</h3>

<p>A class <code>owin</code> to define the &ldquo;observation window&rdquo; of a point pattern
</p>


<h3>Details</h3>

<p>In the <span class="pkg">spatstat</span> library, a point pattern dataset must include
information about the window or region in which the pattern was
observed. A window is described by an object of class <code>"owin"</code>.
Windows of arbitrary shape are supported.
</p>
<p>An object of class <code>"owin"</code> has one of three types:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>"rectangle"</code>: </td><td style="text-align: left;">
      a rectangle in the two-dimensional plane with edges parallel to the axes
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"polygonal"</code>: </td><td style="text-align: left;">
    a region whose boundary is a polygon or several polygons.
    The region may have holes and may consist of several disconnected pieces.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"mask"</code>: </td><td style="text-align: left;">
      a binary image (a logical matrix)
      set to <code>TRUE</code> for pixels inside the window and
      <code>FALSE</code> outside the window.
  </td>
</tr>

</table>

<p>Objects of class <code>"owin"</code> may be created by the function
<code><a href="#topic+owin">owin</a></code>
and converted from other types of data by the function
<code><a href="#topic+as.owin">as.owin</a></code>.
</p>
<p>They may be manipulated by the functions 
<code><a href="#topic+as.rectangle">as.rectangle</a></code>,
<code><a href="#topic+as.mask">as.mask</a></code>, 
<code><a href="#topic+complement.owin">complement.owin</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+shift">shift</a></code>,
<code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+erosion">erosion</a></code>,
<code><a href="#topic+dilation">dilation</a></code>,
<code><a href="#topic+opening">opening</a></code>
and
<code><a href="#topic+closing">closing</a></code>.
</p>
<p>Geometrical calculations available for windows include
<code><a href="#topic+area.owin">area.owin</a></code>,
<code><a href="#topic+perimeter">perimeter</a></code>,
<code><a href="#topic+diameter.owin">diameter.owin</a></code>,
<code><a href="#topic+boundingbox">boundingbox</a></code>,
<code><a href="#topic+eroded.areas">eroded.areas</a></code>,
<code><a href="#topic+bdist.points">bdist.points</a></code>,
<code><a href="#topic+bdist.pixels">bdist.pixels</a></code>,
and
<code>even.breaks.owin</code>.
The mapping between continuous coordinates and pixel raster indices
is facilitated by the functions
<code><a href="#topic+raster.x">raster.x</a></code>,
<code><a href="#topic+raster.y">raster.y</a></code> and
<code><a href="#topic+nearest.raster.point">nearest.raster.point</a></code>.
</p>
<p>There is a <code>plot</code> method for window objects,
<code><a href="#topic+plot.owin">plot.owin</a></code>. This may be useful if you wish to
plot a point pattern's window without the points for graphical
purposes.
</p>
<p>There are also methods for
<code>summary</code> and <code>print</code>. 
</p>


<h3>Warnings</h3>

<p>In a window of type <code>"mask"</code>, the 
row index corresponds to increasing <code class="reqn">y</code> coordinate,
and the column index corresponds to increasing <code class="reqn">x</code> coordinate.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+as.rectangle">as.rectangle</a></code>,
<code><a href="#topic+as.mask">as.mask</a></code>,
<code><a href="#topic+summary.owin">summary.owin</a></code>,
<code><a href="#topic+print.owin">print.owin</a></code>,
<code><a href="#topic+complement.owin">complement.owin</a></code>,
<code><a href="#topic+erosion">erosion</a></code>,
<code><a href="#topic+dilation">dilation</a></code>,
<code><a href="#topic+opening">opening</a></code>,
<code><a href="#topic+closing">closing</a></code>,
<code><a href="#topic+affine.owin">affine.owin</a></code>,
<code><a href="#topic+shift.owin">shift.owin</a></code>,
<code><a href="#topic+rotate.owin">rotate.owin</a></code>,
<code><a href="#topic+raster.x">raster.x</a></code>,
<code><a href="#topic+raster.y">raster.y</a></code>,
<code><a href="#topic+nearest.raster.point">nearest.raster.point</a></code>,
<code><a href="#topic+plot.owin">plot.owin</a></code>,
<code><a href="#topic+area.owin">area.owin</a></code>,
<code><a href="#topic+boundingbox">boundingbox</a></code>,
<code><a href="#topic+diameter">diameter</a></code>,
<code><a href="#topic+eroded.areas">eroded.areas</a></code>,
<code><a href="#topic+bdist.points">bdist.points</a></code>,
<code><a href="#topic+bdist.pixels">bdist.pixels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> w &lt;- owin()
 w &lt;- owin(c(0,1), c(0,1))
 # the unit square
  
 w &lt;- owin(c(0,1), c(0,2))
 if(FALSE) {
   plot(w)
   # plots edges of a box 1 unit x 2 units
   v &lt;- locator() 
   # click on points in the plot window
   # to be the vertices of a polygon 
   # traversed in anticlockwise order 
   u &lt;- owin(c(0,1), c(0,2), poly=v)
   plot(u)
   # plots polygonal boundary using polygon()
   plot(as.mask(u, eps=0.02))
   # plots discrete pixel approximation to polygon
 }
</code></pre>

<hr>
<h2 id='owin2mask'>
Convert Window to Binary Mask under Constraints 
</h2><span id='topic+owin2mask'></span>

<h3>Description</h3>

<p>Converts a window (object of class <code>"owin"</code>)
to a binary pixel mask, with options to require
that the inside, outside, and/or boundary of the window
should be completely covered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>owin2mask(W,
         op = c("sample", "notsample",
                "cover", "inside",
                "uncover", "outside",
                "boundary",
                "majority", "minority"),
         ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="owin2mask_+3A_w">W</code></td>
<td>

<p>A window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="owin2mask_+3A_op">op</code></td>
<td>

<p>Character string (partially matched) specifying how <code>W</code>
should be converted to a binary pixel mask.
</p>
</td></tr>
<tr><td><code id="owin2mask_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine
the pixel resolution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to, but more flexible than, <code><a href="#topic+as.mask">as.mask</a></code>.
It converts the interior, exterior, or boundary of the window <code>W</code>
to a binary pixel mask.
</p>

<ul>
<li>
<p>If <code>op="sample"</code> (the default), the mask consists of all pixels
whose <b>centres</b> lie inside the window <code>W</code>.
This is the same as using <code><a href="#topic+as.mask">as.mask</a></code>.
</p>
</li>
<li> 
<p>If <code>op="notsample"</code>, the mask consists of all pixels
whose <em>centres lie outside</em> the window <code>W</code>.
This is the same as using <code><a href="#topic+as.mask">as.mask</a></code> followed by
<code><a href="#topic+complement.owin">complement.owin</a></code>.
</p>
</li>
<li> 
<p>If <code>op="cover"</code>, the mask consists of all pixels
which overlap the window <code>W</code>, wholly or partially. 
</p>
</li>
<li> 
<p>If <code>op="inside"</code>, the mask consists of all pixels which
lie entirely inside the window <code>W</code>.
</p>
</li>
<li> 
<p>If <code>op="uncover"</code>, the mask consists of all pixels which
overlap the outside of the window <code>W</code>, wholly or partially.
</p>
</li>
<li> 
<p>If <code>op="outside"</code>, the mask consists of all pixels which
lie entirely outside the window <code>W</code>.
</p>
</li>
<li> 
<p>If <code>op="boundary"</code>, the mask consists of all pixels which
overlap the boundary of the window <code>W</code>.
</p>
</li>
<li> 
<p>If <code>op="majority"</code>, the mask consists of all pixels in which
at least half of the pixel area is covered by the window <code>W</code>.
</p>
</li>
<li> 
<p>If <code>op="minority"</code>, the mask consists of all pixels in which
less than half of the pixel area is covered by the window <code>W</code>.
</p>
</li></ul>

<p>These operations are complementary pairs as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>"notsample"</code> </td><td style="text-align: left;"> is the complement of </td><td style="text-align: left;"> <code>"sample"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"uncover"</code> </td><td style="text-align: left;"> is the complement of </td><td style="text-align: left;"> <code>"inside"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"outside"</code> </td><td style="text-align: left;"> is the complement of </td><td style="text-align: left;"> <code>"cover"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"minority"</code> </td><td style="text-align: left;"> is the complement of </td><td style="text-align: left;"> <code>"majority"</code>
  </td>
</tr>

</table>

<p>They also satisfy the following set relations:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>"inside"</code> </td><td style="text-align: left;"> is a subset of </td><td style="text-align: left;"> <code>"cover"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"outside"</code> </td><td style="text-align: left;"> is a subset of </td><td style="text-align: left;"> <code>"uncover"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"boundary"</code> </td><td style="text-align: left;"> is a subset of </td><td style="text-align: left;"> <code>"cover"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"boundary"</code> </td><td style="text-align: left;"> is a subset of </td><td style="text-align: left;"> <code>"uncover"</code>
  </td>
</tr>

</table>

<p>The results of <code>"inside"</code>, <code>"boundary"</code> and <code>"outside"</code>
are disjoint and their union is the entire frame.
</p>
<p>Theoretically <code>"sample"</code> should be a subset of <code>"cover"</code>,
<code>"notsample"</code> should be a subset of <code>"uncover"</code>,
<code>"inside"</code> should be a subset of <code>"majority"</code>
and <code>"outside"</code> should be a subset of <code>"minority"</code>,
but these could be false due to numerical error in computational geometry.
</p>


<h3>Value</h3>

<p>A mask (object of class <code>"owin"</code> of type <code>"mask"</code>
representing a binary pixel mask).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.mask">as.mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  W &lt;- Window(chorley)
  opa &lt;- par(mfrow=c(2,5))
  plot(as.mask(W, dimyx=10), col="grey", main="sample")
  plot(W, add=TRUE, lwd=3, border="red")  
  plot(owin2mask(W, "ma", dimyx=10), col="grey", main="majority")
  plot(W, add=TRUE, lwd=3, border="red")
  plot(owin2mask(W, "i", dimyx=10), col="grey", main="inside")
  plot(W, add=TRUE, lwd=3, border="red")
  plot(owin2mask(W, "c", dimyx=10), col="grey", main="cover")
  plot(W, add=TRUE, lwd=3, border="red")
  plot(owin2mask(W, "b", dimyx=10), col="grey", main="boundary")
  plot(W, add=TRUE, lwd=3, border="red")
  plot(as.mask(complement.owin(W), dimyx=10), col="grey",
       main="notsample")
  plot(W, add=TRUE, lwd=3, border="red")  
  plot(owin2mask(W, "mi", dimyx=10), col="grey", main="minority")
  plot(W, add=TRUE, lwd=3, border="red")
  plot(owin2mask(W, "o", dimyx=10), col="grey", main="outside")
  plot(W, add=TRUE, lwd=3, border="red")
  plot(owin2mask(W, "u", dimyx=10), col="grey", main="uncover")
  plot(W, add=TRUE, lwd=3, border="red")
  plot(owin2mask(W, "b", dimyx=10), col="grey", main="boundary")
  plot(W, add=TRUE, lwd=3, border="red")
  par(opa)
</code></pre>

<hr>
<h2 id='padimage'>
Pad the Border of a Pixel Image
</h2><span id='topic+padimage'></span>

<h3>Description</h3>

<p>Fills the border of a pixel image with a given value or values,
or extends a pixel image to fill a larger window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padimage(X, value=NA, n=1, W=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="padimage_+3A_x">X</code></td>
<td>

<p>Pixel image (object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="padimage_+3A_value">value</code></td>
<td>

<p>Single value to be placed around the border of <code>X</code>.    
</p>
</td></tr>
<tr><td><code id="padimage_+3A_n">n</code></td>
<td>

<p>Width of border, in pixels.
See Details.
</p>
</td></tr>
<tr><td><code id="padimage_+3A_w">W</code></td>
<td>

<p>Window for the resulting image.
Incompatible with <code>n</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The image <code>X</code> will be expanded by a margin of <code>n</code>
pixels, or extended to fill the window <code>W</code>,
with new pixel values set to <code>value</code>.
</p>
<p>The argument <code>value</code> should be a single value (a vector of length
1), normally a value of the same type as the pixel values of <code>X</code>.
It may be <code>NA</code>. Alternatively if <code>X</code> is a
factor-valued image, <code>value</code> can be one of the levels of
<code>X</code>.
</p>
<p>If <code>n</code> is given, it may be a single number, specifying the
width of the border in pixels. Alternatively it may be a vector
of length 2 or 4. It will be replicated to length 4, and these numbers
will be interpreted as the border widths for the
(left, right, top, bottom) margins respectively.
</p>
<p>Alternatively if <code>W</code> is given, the image will be extended to
the window <code>W</code>. 
</p>


<h3>Value</h3>

<p>Another object of class <code>"im"</code>, of the same type as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im">im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Z &lt;- setcov(owin())
 plot(padimage(Z, 1, 10))
</code></pre>

<hr>
<h2 id='pairdist'>Pairwise distances</h2><span id='topic+pairdist'></span>

<h3>Description</h3>

<p>Computes the matrix of distances between all pairs of &lsquo;things&rsquo;
in a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pairdist(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairdist_+3A_x">X</code></td>
<td>

<p>Object specifying the locations of a set of &lsquo;things&rsquo;
(such as a set of points or a set of line segments).
</p>
</td></tr>
<tr><td><code id="pairdist_+3A_...">...</code></td>
<td>

<p>Further arguments depending on the method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a dataset <code>X</code> and <code>Y</code>
(representing either a point pattern or
a line segment pattern)
<code>pairdist</code> computes the distance between each pair of
&lsquo;things&rsquo; in the dataset, and returns 
a matrix containing these distances.
</p>
<p>The function <code>pairdist</code> is generic, with
methods for point patterns (objects of class <code>"ppp"</code>),
line segment patterns (objects of class <code>"psp"</code>)
and a default method. See the documentation
for <code><a href="#topic+pairdist.ppp">pairdist.ppp</a></code>, <code><a href="#topic+pairdist.psp">pairdist.psp</a></code>
or <code><a href="#topic+pairdist.default">pairdist.default</a></code> for details.
</p>


<h3>Value</h3>

<p>A square matrix whose <code>[i,j]</code> entry is the distance
between the &lsquo;things&rsquo; numbered <code>i</code> and <code>j</code>.
</p>


<h3>Author(s)</h3>

<p>Pavel Grabarnik <a href="mailto:pavel.grabar@issp.serpukhov.su">pavel.grabar@issp.serpukhov.su</a>
and 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairdist.ppp">pairdist.ppp</a></code>,
<code><a href="#topic+pairdist.psp">pairdist.psp</a></code>,
<code><a href="#topic+pairdist.default">pairdist.default</a></code>,
<code><a href="#topic+crossdist">crossdist</a></code>,
<code><a href="#topic+nndist">nndist</a></code>,
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>
</p>

<hr>
<h2 id='pairdist.default'>Pairwise distances</h2><span id='topic+pairdist.default'></span>

<h3>Description</h3>

<p>Computes the matrix of distances between all pairs of points
in a set of points in two dimensional space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## Default S3 method:
pairdist(X, Y=NULL, ..., period=NULL, method="C", squared=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairdist.default_+3A_x">X</code>, <code id="pairdist.default_+3A_y">Y</code></td>
<td>

<p>Arguments specifying the coordinates of a set of points.
Typically <code>X</code> and <code>Y</code> would be
numeric vectors of equal length.
Alternatively <code>Y</code> may be omitted and <code>X</code> may be
a list with two components <code>x</code> and <code>y</code>,
or a matrix with two columns.
</p>
</td></tr>
<tr><td><code id="pairdist.default_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="pairdist.default_+3A_period">period</code></td>
<td>

<p>Optional. Dimensions for periodic edge correction.
</p>
</td></tr>
<tr><td><code id="pairdist.default_+3A_method">method</code></td>
<td>

<p>String specifying which method of calculation to use.
Values are <code>"C"</code> and <code>"interpreted"</code>.
Usually not specified.
</p>
</td></tr>
<tr><td><code id="pairdist.default_+3A_squared">squared</code></td>
<td>

<p>Logical. If <code>squared=TRUE</code>, the squared distances are
returned instead (this computation is faster).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the coordinates of a set of points in two dimensional space,
this function computes the Euclidean distances between all pairs of
points, and returns the matrix of distances.
It is a method for the generic function <code>pairdist</code>.
</p>
<p>Note: If only pairwise distances within some threshold value are
needed the low-level function <code><a href="#topic+closepairs">closepairs</a></code> may be much
faster to use.
</p>
<p>The arguments <code>X</code> and <code>Y</code> must determine
the coordinates of a set of points. Typically <code>X</code> and
<code>Y</code> would be numeric vectors of equal length. Alternatively
<code>Y</code> may be omitted and <code>X</code> may be a list with two components
named <code>x</code> and <code>y</code>, or a matrix or data frame with two columns.
</p>
<p>For typical input the result is numerically equivalent to
(but computationally faster than) <code>as.matrix(dist(x))</code> where
<code>x = cbind(X, Y)</code>, but that command is useful for calculating 
all pairwise distances between points in <code class="reqn">k</code>-dimensional space
when <code>x</code> has <code class="reqn">k</code> columns.
</p>
<p>Alternatively if <code>period</code> is given,
then the distances will be computed in the &lsquo;periodic&rsquo;
sense (also known as &lsquo;torus&rsquo; distance).
The points will be treated as if they are in a rectangle
of width <code>period[1]</code> and height <code>period[2]</code>.
Opposite edges of the rectangle are regarded as equivalent.
</p>
<p>If <code>squared=TRUE</code> then the <em>squared</em> Euclidean distances
<code class="reqn">d^2</code> are returned, instead of the Euclidean distances <code class="reqn">d</code>.
The squared distances are faster to calculate, and are sufficient for
many purposes (such as finding the nearest neighbour of a point).
</p>
<p>The argument <code>method</code> is not normally used. It is
retained only for checking the validity of the software.
If <code>method = "interpreted"</code> then the distances are
computed using interpreted R code only. If <code>method="C"</code>
(the default) then C code is used. The C code is somewhat faster.
</p>


<h3>Value</h3>

<p>A square matrix whose <code>[i,j]</code> entry is the distance
between the points numbered <code>i</code> and <code>j</code>.
</p>


<h3>Author(s)</h3>

<p>Pavel Grabarnik <a href="mailto:pavel.grabar@issp.serpukhov.su">pavel.grabar@issp.serpukhov.su</a>
and 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossdist">crossdist</a></code>,
<code><a href="#topic+nndist">nndist</a></code>,
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>,
<code><a href="#topic+closepairs">closepairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- runif(100)
   y &lt;- runif(100)
   d &lt;- pairdist(x, y)
   d &lt;- pairdist(cbind(x,y))
   d &lt;- pairdist(x, y, period=c(1,1))
   d &lt;- pairdist(x, y, squared=TRUE)
</code></pre>

<hr>
<h2 id='pairdist.pp3'>Pairwise distances in Three Dimensions</h2><span id='topic+pairdist.pp3'></span>

<h3>Description</h3>

<p>Computes the matrix of distances between all pairs of points
in a three-dimensional point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'pp3'
pairdist(X, ..., periodic=FALSE, squared=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairdist.pp3_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="pairdist.pp3_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="pairdist.pp3_+3A_periodic">periodic</code></td>
<td>

<p>Logical. Specifies whether to apply a periodic edge correction.
</p>
</td></tr>
<tr><td><code id="pairdist.pp3_+3A_squared">squared</code></td>
<td>

<p>Logical. If <code>squared=TRUE</code>, the squared distances are
returned instead (this computation is faster).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code>pairdist</code>.
</p>
<p>Given a three-dimensional point pattern <code>X</code>
(an object of class <code>"pp3"</code>),
this function computes the Euclidean distances between all pairs of
points in <code>X</code>, and returns the matrix of distances.
</p>
<p>Alternatively if <code>periodic=TRUE</code> and the window containing <code>X</code> is a
box, then the distances will be computed in the &lsquo;periodic&rsquo;
sense (also known as &lsquo;torus&rsquo; distance): opposite faces of the
box are regarded as equivalent.
This is meaningless if the window is not a box.
</p>
<p>If <code>squared=TRUE</code> then the <em>squared</em> Euclidean distances
<code class="reqn">d^2</code> are returned, instead of the Euclidean distances <code class="reqn">d</code>.
The squared distances are faster to calculate, and are sufficient for
many purposes (such as finding the nearest neighbour of a point).
</p>


<h3>Value</h3>

<p>A square matrix whose <code>[i,j]</code> entry is the distance
between the points numbered <code>i</code> and <code>j</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
based on two-dimensional code by 
Pavel Grabarnik <a href="mailto:pavel.grabar@issp.serpukhov.su">pavel.grabar@issp.serpukhov.su</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairdist">pairdist</a></code>,
<code><a href="#topic+crossdist">crossdist</a></code>,
<code><a href="#topic+nndist">nndist</a></code>,
<code><a href="spatstat.explore.html#topic+K3est">K3est</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(spatstat.random)) {
   X &lt;- runifpoint3(20)
} else {
   X &lt;- osteo$pts[[1]]
}
   d &lt;- pairdist(X)
   d &lt;- pairdist(X, periodic=TRUE)
   d &lt;- pairdist(X, squared=TRUE)
</code></pre>

<hr>
<h2 id='pairdist.ppp'>Pairwise distances</h2><span id='topic+pairdist.ppp'></span>

<h3>Description</h3>

<p>Computes the matrix of distances between all pairs of points
in a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
pairdist(X, ...,
                        periodic=FALSE, method="C", squared=FALSE, metric=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairdist.ppp_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="pairdist.ppp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="pairdist.ppp_+3A_periodic">periodic</code></td>
<td>

<p>Logical. Specifies whether to apply a periodic edge correction.
</p>
</td></tr>
<tr><td><code id="pairdist.ppp_+3A_method">method</code></td>
<td>

<p>String specifying which method of calculation to use.
Values are <code>"C"</code> and <code>"interpreted"</code>.
Usually not specified.
</p>
</td></tr>
<tr><td><code id="pairdist.ppp_+3A_squared">squared</code></td>
<td>

<p>Logical. If <code>squared=TRUE</code>, the squared distances are
returned instead (this computation is faster).
</p>
</td></tr>
<tr><td><code id="pairdist.ppp_+3A_metric">metric</code></td>
<td>

<p>Optional. A metric (object of class <code>"metric"</code>)
that will be used to define and compute the distances.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code>pairdist</code>.
</p>
<p>Given a point pattern <code>X</code> (an object of class <code>"ppp"</code>),
this function computes the Euclidean distances between all pairs of
points in <code>X</code>, and returns the matrix of distances.
</p>
<p>Alternatively if <code>periodic=TRUE</code> and the window containing <code>X</code> is a
rectangle, then the distances will be computed in the &lsquo;periodic&rsquo;
sense (also known as &lsquo;torus&rsquo; distance): opposite edges of the
rectangle are regarded as equivalent.
This is meaningless if the window is not a rectangle.
</p>
<p>If <code>squared=TRUE</code> then the <em>squared</em> Euclidean distances
<code class="reqn">d^2</code> are returned, instead of the Euclidean distances <code class="reqn">d</code>.
The squared distances are faster to calculate, and are sufficient for
many purposes (such as finding the nearest neighbour of a point).
</p>
<p>The argument <code>method</code> is not normally used. It is
retained only for checking the validity of the software.
If <code>method = "interpreted"</code> then the distances are
computed using interpreted R code only. If <code>method="C"</code>
(the default) then C code is used. The C code is somewhat faster.
</p>


<h3>Value</h3>

<p>A square matrix whose <code>[i,j]</code> entry is the distance
between the points numbered <code>i</code> and <code>j</code>.
</p>


<h3>Author(s)</h3>

<p>Pavel Grabarnik <a href="mailto:pavel.grabar@issp.serpukhov.su">pavel.grabar@issp.serpukhov.su</a>
and 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairdist">pairdist</a></code>,
<code><a href="#topic+pairdist.default">pairdist.default</a></code>,
<code><a href="#topic+pairdist.psp">pairdist.psp</a></code>,
<code><a href="#topic+crossdist">crossdist</a></code>,
<code><a href="#topic+nndist">nndist</a></code>,
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   d &lt;- pairdist(cells)
   d &lt;- pairdist(cells, periodic=TRUE)
   d &lt;- pairdist(cells, squared=TRUE)
</code></pre>

<hr>
<h2 id='pairdist.ppx'>Pairwise Distances in Any Dimensions</h2><span id='topic+pairdist.ppx'></span>

<h3>Description</h3>

<p>Computes the matrix of distances between all pairs of points
in a multi-dimensional point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppx'
pairdist(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairdist.ppx_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="pairdist.ppx_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+coords.ppx">coords.ppx</a></code> to determine
which coordinates should be used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code>pairdist</code>.
</p>
<p>Given a multi-dimensional point pattern <code>X</code>
(an object of class <code>"ppx"</code>),
this function computes the Euclidean distances between all pairs of
points in <code>X</code>, and returns the matrix of distances.
</p>
<p>By default, both spatial and temporal coordinates are extracted.
To obtain the spatial distance between points in a space-time point
pattern, set <code>temporal=FALSE</code>.
</p>


<h3>Value</h3>

<p>A square matrix whose <code>[i,j]</code> entry is the distance
between the points numbered <code>i</code> and <code>j</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairdist">pairdist</a></code>,
<code><a href="#topic+crossdist">crossdist</a></code>,
<code><a href="#topic+nndist">nndist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   df &lt;- data.frame(x=runif(4),y=runif(4),z=runif(4),w=runif(4))
   X &lt;- ppx(data=df)
   pairdist(X)
</code></pre>

<hr>
<h2 id='pairdist.psp'>Pairwise distances between line segments</h2><span id='topic+pairdist.psp'></span>

<h3>Description</h3>

<p>Computes the matrix of distances between all pairs of line segments
in a line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'psp'
pairdist(X, ..., method="C", type="Hausdorff")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairdist.psp_+3A_x">X</code></td>
<td>

<p>A line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="pairdist.psp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="pairdist.psp_+3A_method">method</code></td>
<td>

<p>String specifying which method of calculation to use.
Values are <code>"C"</code> and <code>"interpreted"</code>.
Usually not specified.
</p>
</td></tr>
<tr><td><code id="pairdist.psp_+3A_type">type</code></td>
<td>

<p>Type of distance to be computed. Options are
<code>"Hausdorff"</code> and <code>"separation"</code>. Partial matching is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the distance between each pair of
line segments in <code>X</code>, and returns the matrix of distances.
</p>
<p>This is a method for the generic function <code><a href="#topic+pairdist">pairdist</a></code>
for the class <code>"psp"</code>.
</p>
<p>The distances between line segments are measured in one of two ways:
</p>

<ul>
<li><p> if <code>type="Hausdorff"</code>, distances are computed
in the Hausdorff metric. The Hausdorff
distance between two line segments is the <em>maximum</em> distance
from any point on one of the segments to the nearest point on
the other segment.
</p>
</li>
<li><p> if <code>type="separation"</code>, distances are computed
as the <em>minimum</em> distance from a point on one line segment to
a point on the other line segment. For example, line segments which
cross over each other have separation zero.
</p>
</li></ul>

<p>The argument <code>method</code> is not normally used. It is
retained only for checking the validity of the software.
If <code>method = "interpreted"</code> then the distances are
computed using interpreted <span class="rlang"><b>R</b></span> code only. If <code>method="C"</code>
(the default) then compiled <code>C</code> code is used,
which is somewhat faster.
</p>


<h3>Value</h3>

<p>A square matrix whose <code>[i,j]</code> entry is the distance
between the line segments numbered <code>i</code> and <code>j</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossdist">crossdist</a></code>,
<code><a href="#topic+nndist">nndist</a></code>,
<code><a href="#topic+pairdist.ppp">pairdist.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   L &lt;- psp(runif(10), runif(10), runif(10), runif(10), owin())
   D &lt;- pairdist(L)
   S &lt;- pairdist(L, type="sep")
</code></pre>

<hr>
<h2 id='perimeter'>
Perimeter Length of Window
</h2><span id='topic+perimeter'></span>

<h3>Description</h3>

<p>Computes the perimeter length of a window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perimeter(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perimeter_+3A_w">w</code></td>
<td>

<p>A window (object of class <code>"owin"</code>)
or data that can be converted to a window by <code><a href="#topic+as.owin">as.owin</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the perimeter (length of the boundary) of the
window <code>w</code>. If <code>w</code> is a rectangle or a polygonal window,
the perimeter is the sum of the lengths of the edges of <code>w</code>.
If <code>w</code> is a mask, it is first converted to a polygonal window
using <code><a href="#topic+as.polygonal">as.polygonal</a></code>, then staircase edges are removed
using <code><a href="#topic+simplify.owin">simplify.owin</a></code>, and the perimeter of the resulting
polygon is computed.
</p>


<h3>Value</h3>

<p>A numeric value giving the perimeter length of the window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+area.owin">area.owin</a></code>
<code><a href="#topic+diameter.owin">diameter.owin</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  perimeter(square(3))
  perimeter(letterR)
  if(interactive()) print(perimeter(as.mask(letterR)))
</code></pre>

<hr>
<h2 id='periodify'>
Make Periodic Copies of a Spatial Pattern  
</h2><span id='topic+periodify'></span><span id='topic+periodify.owin'></span><span id='topic+periodify.ppp'></span><span id='topic+periodify.psp'></span>

<h3>Description</h3>

<p>Given a spatial pattern (point pattern, line segment pattern,
window, etc) make shifted copies of the pattern
and optionally combine them to make a periodic pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodify(X, ...)
## S3 method for class 'ppp'
periodify(X, nx = 1, ny = 1, ...,
           combine=TRUE, warn=TRUE, check=TRUE,
           ix=(-nx):nx, iy=(-ny):ny,
           ixy=expand.grid(ix=ix,iy=iy))
## S3 method for class 'psp'
periodify(X, nx = 1, ny = 1, ..., 
           combine=TRUE, warn=TRUE, check=TRUE,
           ix=(-nx):nx, iy=(-ny):ny, 
           ixy=expand.grid(ix=ix,iy=iy))
## S3 method for class 'owin'
periodify(X, nx = 1, ny = 1, ...,
           combine=TRUE, warn=TRUE, 
           ix=(-nx):nx, iy=(-ny):ny,
           ixy=expand.grid(ix=ix,iy=iy))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodify_+3A_x">X</code></td>
<td>

<p>An object representing a spatial pattern
(point pattern, line segment pattern or window).
</p>
</td></tr>
<tr><td><code id="periodify_+3A_nx">nx</code>, <code id="periodify_+3A_ny">ny</code></td>
<td>

<p>Integers.
Numbers of additional copies of <code>X</code> in each direction.
The result will be a grid of <code>2 * nx + 1</code> by <code>2 * ny + 1</code>
copies of the original object.
(Overruled by <code>ix, iy, ixy</code>).
</p>
</td></tr>
<tr><td><code id="periodify_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="periodify_+3A_combine">combine</code></td>
<td>

<p>Logical flag determining whether the copies should be superimposed
to make an object like <code>X</code> (if <code>combine=TRUE</code>) or
simply returned as a list of objects (<code>combine=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="periodify_+3A_warn">warn</code></td>
<td>

<p>Logical flag determining whether to issue warnings.
</p>
</td></tr>
<tr><td><code id="periodify_+3A_check">check</code></td>
<td>

<p>Logical flag determining whether to check the validity of the
combined pattern.
</p>
</td></tr>
<tr><td><code id="periodify_+3A_ix">ix</code>, <code id="periodify_+3A_iy">iy</code></td>
<td>

<p>Integer vectors determining the grid positions of the copies
of <code>X</code>. (Overruled by <code>ixy</code>).
</p>
</td></tr>
<tr><td><code id="periodify_+3A_ixy">ixy</code></td>
<td>

<p>Matrix or data frame with two columns, giving the 
grid positions of the copies of <code>X</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a spatial pattern (point pattern, line segment pattern, etc)
this function makes a number of shifted copies of the pattern
and optionally combines them. The function <code>periodify</code> is
generic, with methods for various kinds of spatial objects.
</p>
<p>The default is to make a 3 by 3 array of copies of <code>X</code> and
combine them into a single pattern of the same kind as <code>X</code>.
This can be used (for example) to compute toroidal or periodic
edge corrections for various operations on <code>X</code>.
</p>
<p>If the arguments <code>nx</code>, <code>ny</code> are given
and other arguments are missing,
the original object will be copied <code>nx</code> times to the right
and <code>nx</code> times to the left, then <code>ny</code> times upward and
<code>ny</code> times downward, making <code>(2 * nx + 1) * (2 * ny + 1)</code> 
copies altogether, arranged in a grid, centred on the original object.
</p>
<p>If the arguments <code>ix</code>, <code>iy</code> or <code>ixy</code> are specified,
then these determine the grid positions of the copies of <code>X</code>
that will be made. For example <code>(ix,iy) = (1, 2)</code> means a
copy of <code>X</code> shifted by the vector <code>(ix * w, iy * h)</code> where
<code>w,h</code> are the width and height of the bounding rectangle of <code>X</code>.
</p>
<p>If <code>combine=TRUE</code> (the default) the copies of <code>X</code> are
superimposed to create an object of the same kind as <code>X</code>.
If <code>combine=FALSE</code> the copies of <code>X</code> are returned as a list.
</p>


<h3>Value</h3>

<p>If <code>combine=TRUE</code>, an object of the same class as <code>X</code>.
If <code>combine=FALSE</code>, a list of objects of the same class as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(periodify(cells))
  a &lt;- lapply(periodify(Window(cells), combine=FALSE),
        plot, add=TRUE,lty=2)
</code></pre>

<hr>
<h2 id='persp.im'>Perspective Plot of Pixel Image</h2><span id='topic+persp.im'></span>

<h3>Description</h3>

<p>Displays a perspective plot of a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
persp(x, ...,
                     colmap=NULL, colin=x, apron=FALSE, visible=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persp.im_+3A_x">x</code></td>
<td>

<p>The pixel image to be plotted as a surface.
An object of class <code>"im"</code> (see <code><a href="#topic+im.object">im.object</a></code>).
</p>
</td></tr>
<tr><td><code id="persp.im_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="graphics.html#topic+persp.default">persp.default</a></code> to control the
display.
</p>
</td></tr>
<tr><td><code id="persp.im_+3A_colmap">colmap</code></td>
<td>

<p>Optional data controlling the colour map. See Details.
</p>
</td></tr>
<tr><td><code id="persp.im_+3A_colin">colin</code></td>
<td>

<p>Optional. Colour input. Another pixel image (of the same dimensions
as <code>x</code>) containing the values that will be mapped to colours. 
</p>
</td></tr>
<tr><td><code id="persp.im_+3A_apron">apron</code></td>
<td>

<p>Logical. If <code>TRUE</code>, a grey apron is placed
around the sides of the perspective plot.
</p>
</td></tr>
<tr><td><code id="persp.im_+3A_visible">visible</code></td>
<td>

<p>Logical value indicating whether to compute which pixels of <code>x</code>
are visible in the perspective view. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>persp</code> method for the class <code>"im"</code>.
</p>
<p>The pixel image <code>x</code> must have real or integer values.
These values are treated as heights of a surface, and the
surface is displayed as a perspective plot on the current plot device,
using equal scales on the <code>x</code> and <code>y</code> axes.
</p>
<p>The optional argument <code>colmap</code> gives an easy way to display
different altitudes in different colours (if this is what you
want).
</p>

<ul>
<li><p> If <code>colmap</code> is a colour map (object of class <code>"colourmap"</code>,
created by the function <code><a href="#topic+colourmap">colourmap</a></code>)
then this colour map will be used to associate
altitudes with colours.
</p>
</li>
<li><p> If <code>colmap</code> is a character vector, then the range of
altitudes in the perspective plot will be divided into
<code>length(colmap)</code> intervals, and those parts of the surface
which lie in a particular altitude range will be assigned
the corresponding colour from <code>colmap</code>.
</p>
</li>
<li><p> If <code>colmap</code> is a function in the <span class="rlang"><b>R</b></span> language
of the form <code>function(n, ...)</code>, this function will be called
with an appropriate value of <code>n</code> to generate a character
vector of <code>n</code> colours. 
Examples of such functions are
<code><a href="grDevices.html#topic+heat.colors">heat.colors</a></code>,
<code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code>,
<code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code> and
<code><a href="grDevices.html#topic+cm.colors">cm.colors</a></code>. 
</p>
</li>
<li><p> If <code>colmap</code> is a function in the <span class="rlang"><b>R</b></span> language of the
form <code>function(range, ...)</code> then it will be called
with <code>range</code> equal to the range of altitudes,
to determine the colour values or colour map.
Examples of such functions are <code><a href="#topic+beachcolours">beachcolours</a></code>
and <code><a href="#topic+beachcolourmap">beachcolourmap</a></code>.
</p>
</li>
<li><p> If <code>colmap</code> is a list with entries <code>breaks</code> and <code>col</code>,
then <code>colmap$breaks</code> determines the breakpoints of the altitude
intervals, and <code>colmap$col</code> provides the corresponding colours.
</p>
</li></ul>

<p>Alternatively, if the argument <code>colin</code> (<em>colour input</em>) is present,
then the colour map <code>colmap</code> will be applied to
the pixel values of <code>colin</code> instead of the pixel values of
<code>x</code>. The result is a perspective view of a surface with
heights determined by <code>x</code> and colours determined by <code>colin</code>
(mapped by <code>colmap</code>).  
</p>
<p>If <code>apron=TRUE</code>, vertical surface is drawn around the boundary
of the perspective plot, so that the terrain appears to have been
cut out of a solid material. If colour data were supplied, then
the apron is coloured light grey.
</p>
<p>Graphical parameters controlling the perspective plot
are passed through the <code>...</code> arguments
directly to the function <code><a href="graphics.html#topic+persp.default">persp.default</a></code>.
See the examples in <code><a href="graphics.html#topic+persp.default">persp.default</a></code> or in
<code>demo(persp)</code>.
</p>
<p>The vertical scale is controlled by the argument <code>expand</code>:
setting <code>expand=1</code> will interpret the pixel values as being in
the same units as the spatial coordinates <code class="reqn">x</code> and <code class="reqn">y</code> and
represent them at the same scale.
</p>
<p>If <code>visible=TRUE</code>, the algorithm also computes whether each pixel
in <code>x</code> is visible in the perspective view. In order to be
visible, a pixel must not be obscured by another pixel which lies
in front of it (as seen from the viewing direction), and the
three-dimensional vector normal to the surface must be pointing toward the
viewer. The return value of <code>persp.im</code> then has an attribute
<code>"visible"</code> which is a pixel image, compatible with <code>x</code>,
with pixel value equal to <code>TRUE</code> if the corresponding pixel in
<code>x</code> is visible, and <code>FALSE</code> if it is not visible.
</p>


<h3>Value</h3>

<p>(invisibly) the 3D transformation matrix
returned by <code><a href="graphics.html#topic+persp.default">persp.default</a></code>,
together with an attribute <code>"expand"</code> which gives the
relative scale of the <code class="reqn">z</code> coordinate.
</p>
<p>If argument <code>visible=TRUE</code> was given, the return value
also has an attribute <code>"visible"</code> which is a pixel image,
compatible with <code>x</code>, with logical values which are <em>TRUE</em>
when the corresponding pixel is visible in the perspective view,
and <code>FALSE</code> when it is obscured.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+perspPoints">perspPoints</a></code>,
<code><a href="#topic+perspLines">perspLines</a></code>
for drawing additional points or lines <em>on the surface</em>.
</p>
<p><code><a href="grDevices.html#topic+trans3d">trans3d</a></code> for mapping arbitrary
<code class="reqn">(x,y,z)</code> coordinate locations to the plotting coordinates.
</p>
<p><code><a href="#topic+im.object">im.object</a></code>,
<code><a href="#topic+plot.im">plot.im</a></code>,
<code><a href="#topic+contour.im">contour.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # an image
   Z &lt;- setcov(owin(), dimyx=32)
   persp(Z, colmap=terrain.colors(128))
   if(interactive()) {
     co &lt;- colourmap(range=c(0,1), col=rainbow(128))
     persp(Z, colmap=co, axes=FALSE, shade=0.3)
   }

   ## Terrain elevation
   persp(bei.extra$elev, colmap=terrain.colors(128),
         apron=TRUE, theta=-30, phi=20,
         zlab="Elevation", main="", ticktype="detailed",
         expand=6)
</code></pre>

<hr>
<h2 id='perspPoints'>
Draw Points or Lines on a Surface Viewed in Perspective
</h2><span id='topic+perspPoints'></span><span id='topic+perspSegments'></span><span id='topic+perspLines'></span><span id='topic+perspContour'></span>

<h3>Description</h3>

<p>After a surface has been plotted in a perspective view
using <code><a href="#topic+persp.im">persp.im</a></code>, these functions can be used to
draw points or lines on the surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perspPoints(x, y=NULL, ..., Z, M, occluded=TRUE)

perspLines(x, y = NULL, ..., Z, M, occluded=TRUE)

perspSegments(x0, y0 = NULL, x1 = NULL, y1 = NULL, ..., Z, M, occluded=TRUE)

perspContour(Z, M, ...,
             nlevels=10, levels=pretty(range(Z), nlevels),
             occluded=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perspPoints_+3A_x">x</code>, <code id="perspPoints_+3A_y">y</code></td>
<td>

<p>Spatial coordinates,
acceptable to <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>,
for the points or lines on the horizontal plane.
</p>
</td></tr>
<tr><td><code id="perspPoints_+3A_z">Z</code></td>
<td>

<p>Pixel image (object of class <code>"im"</code>)
specifying the surface heights.
</p>
</td></tr>
<tr><td><code id="perspPoints_+3A_m">M</code></td>
<td>

<p>Projection matrix returned from <code><a href="#topic+persp.im">persp.im</a></code>
when <code>Z</code> was plotted.
</p>
</td></tr>
<tr><td><code id="perspPoints_+3A_...">...</code></td>
<td>

<p>Graphical arguments passed to
<code><a href="graphics.html#topic+points">points</a></code>,
<code><a href="graphics.html#topic+lines">lines</a></code> or
<code><a href="graphics.html#topic+segments">segments</a></code>
to control the drawing.
</p>
</td></tr>
<tr><td><code id="perspPoints_+3A_x0">x0</code>, <code id="perspPoints_+3A_y0">y0</code>, <code id="perspPoints_+3A_x1">x1</code>, <code id="perspPoints_+3A_y1">y1</code></td>
<td>

<p>Spatial coordinates of the line segments, on the
horizontal plane. Alternatively <code>x0</code> can be a
line segment pattern (object of class <code>"psp"</code>)
and <code>y0,x1,y1</code> can be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="perspPoints_+3A_nlevels">nlevels</code></td>
<td>
<p>Number of contour levels</p>
</td></tr>
<tr><td><code id="perspPoints_+3A_levels">levels</code></td>
<td>
<p>Vector of heights of contours.</p>
</td></tr>
<tr><td><code id="perspPoints_+3A_occluded">occluded</code></td>
<td>

<p>Logical value specifying whether parts of the surface
can be obscured by other parts of the surface. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After a surface has been plotted in a perspective view,
these functions can be used to draw points or lines on the surface.
</p>
<p>The user should already have called <code><a href="#topic+persp.im">persp.im</a></code>
to display the perspective view of the surface <code>Z</code>
and to obtain the perspective matrix <code>M</code> by typing
<code>M &lt;- persp(Z, ...)</code>. The points and lines will be drawn in
their correct three-dimensional position according to the same
perspective.
</p>
<p>If <code>occluded=TRUE</code> (the default), then the surface is
treated as if it were opaque. The code will
draw only those points and lines which are visible
from the viewer's standpoint, and not obscured by other parts
of the surface lying closer to the viewer.
The user should already have called <code><a href="#topic+persp.im">persp.im</a></code>
in the form <code>M &lt;- persp(Z, visible=TRUE, ...)</code> 
to compute the visibility information.
</p>
<p>If <code>occluded=FALSE</code>, then the surface is treated
as if it were transparent. 
All the specified points and lines will be drawn on the
surface.
</p>


<h3>Value</h3>

<p>Same as the return value from
<code><a href="graphics.html#topic+points">points</a></code>
or <code><a href="graphics.html#topic+segments">segments</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+persp.im">persp.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  M &lt;- persp(bei.extra$elev, colmap=terrain.colors(128),
             apron=TRUE, theta=-30, phi=20,
             zlab="Elevation", main="", 
             expand=6, visible=TRUE, shade=0.3)

  perspContour(bei.extra$elev, M=M, col="pink", nlevels=12)
  perspPoints(bei, Z=bei.extra$elev, M=M, pch=16, cex=0.3, col="chartreuse")
</code></pre>

<hr>
<h2 id='pHcolourmap'>
Colour Map for pH Values
</h2><span id='topic+pHcolourmap'></span><span id='topic+pHcolour'></span>

<h3>Description</h3>

<p>Create a colour map for values of <code class="reqn">pH</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> pHcolourmap(range = c(0, 14), ..., n=256, step = FALSE)
 pHcolour(pH)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pHcolourmap_+3A_n">n</code></td>
<td>

<p>Number of different colour values to be used, when <code>step=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="pHcolourmap_+3A_range">range</code></td>
<td>

<p>Range of <code class="reqn">pH</code> values that will be accepted as inputs to the
colour map. A numeric vector of length 2 giving the minimum and
maximum values of <code class="reqn">pH</code>.
</p>
</td></tr>
<tr><td><code id="pHcolourmap_+3A_step">step</code></td>
<td>

<p>Logical value. If <code>step=FALSE</code> (the default) the colours change
continuously with increasing values of the input. If
<code>step=TRUE</code>, the colour is constant on each unit interval of
<code class="reqn">pH</code> values.
</p>
</td></tr>
<tr><td><code id="pHcolourmap_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="pHcolourmap_+3A_ph">pH</code></td>
<td>

<p>Numerical value or numeric vector of values of <code class="reqn">pH</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In chemistry the hydrogen potential <code class="reqn">pH</code> measures how acidic or basic
a solution is.
</p>
<p>The function <code>pHcolour</code> calculates the colour associated with
a given value of <code class="reqn">pH</code>, according to a standard mapping in which
neutral <code class="reqn">pH=7</code> is green,
acidic values <code class="reqn">pH &lt; 7</code> are yellow or red,
and basic values <code class="reqn">pH &gt; 7</code> are blue.
The function <code>pHcolour</code> takes a numerical value or vector of
values of <code class="reqn">pH</code> and returns a character vector containing the
corresponding colours.
</p>
<p>The function <code>pHcolourmap</code> produces a colour map for numerical values
of <code class="reqn">pH</code>, using the same consistent mapping of <code class="reqn">pH</code>
values to colours.
The argument <code>range</code> specifies the range of <code class="reqn">pH</code> values that
will be mapped by the resulting colour map. It should be a numeric
vector of length 2 giving the minimum and maximum values of <code class="reqn">pH</code>
that the colour map will handle. (Colour maps created with different
values of <code>range</code> use essentially the same mapping of colours,
but when plotted as colour ribbons, display only the specified range.)
</p>
<p>If <code>step=FALSE</code> (the default) the colours change
continuously with increasing values of the input. There will be
<code>n</code> different colour values in the colour map. Usually <code>n</code>
should be a large number.
</p>
<p>If <code>step=TRUE</code>, the colour is constant on each unit interval of
<code class="reqn">pH</code> values. That is, any value of <code class="reqn">pH</code> in the interval
<code class="reqn">[k, k+1]</code>, where <code class="reqn">k</code> is an integer, will be mapped to the
same colour.
</p>


<h3>Value</h3>

<p>The return value of <code>pHcolour</code> is a character string or
a vector of character strings representing colours.
</p>
<p>The return value of <code>pHcolourmap</code>
is a colour map (object of class <code>"colourmap"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colourmap">colourmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pHcolour(7)

  plot(pHcolourmap())
  plot(pHcolourmap(step=TRUE))
  plot(pHcolourmap(c(3, 8)))
</code></pre>

<hr>
<h2 id='pixelcentres'>
Extract Pixel Centres as Point Pattern
</h2><span id='topic+pixelcentres'></span>

<h3>Description</h3>

<p>Given a pixel image or binary mask window,
extract the centres of all pixels and return them as a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixelcentres(X, W = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pixelcentres_+3A_x">X</code></td>
<td>

<p>Pixel image (object of class <code>"im"</code>)
or window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="pixelcentres_+3A_w">W</code></td>
<td>

<p>Optional window to contain the resulting point pattern.
</p>
</td></tr>
<tr><td><code id="pixelcentres_+3A_...">...</code></td>
<td>

<p>Optional arguments defining the pixel resolution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the argument <code>X</code> is a pixel image, the result is a point
pattern, consisting of the centre of every pixel whose pixel value
is not <code>NA</code>. 
</p>
<p>If <code>X</code> is a window which is a binary mask, the result is a point
pattern consisting of the centre of every pixel inside the window
(i.e. every pixel for which the mask value is <code>TRUE</code>).
</p>
<p>Otherwise, <code>X</code> is first converted to a window, then
converted to a mask using <code><a href="#topic+as.mask">as.mask</a></code>, then handled as
above.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raster.xy">raster.xy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pixelcentres(letterR, dimyx=5)
</code></pre>

<hr>
<h2 id='pixellate'>
Convert Spatial Object to Pixel Image
</h2><span id='topic+pixellate'></span>

<h3>Description</h3>

<p>Convert a spatial object to 
a pixel image by measuring the amount of stuff
in each pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixellate(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pixellate_+3A_x">x</code></td>
<td>

<p>Spatial object to be converted.
A point pattern (object of class <code>"ppp"</code>),
a window (object of class <code>"owin"</code>),
a line segment pattern (object of class <code>"psp"</code>),
or some other suitable data.
</p>
</td></tr>
<tr><td><code id="pixellate_+3A_...">...</code></td>
<td>

<p>Arguments passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>pixellate</code> converts a geometrical object <code>x</code> into
a pixel image, by measuring the <em>amount</em> of <code>x</code> that is
inside each pixel.
</p>
<p>If <code>x</code> is a point pattern, <code>pixellate(x)</code> counts the
number of points of <code>x</code> falling in each pixel.
If <code>x</code> is a window, <code>pixellate(x)</code> measures the area
of intersection of each pixel with the window.
</p>
<p>The function <code>pixellate</code> is generic, with methods for
point patterns (<code><a href="#topic+pixellate.ppp">pixellate.ppp</a></code>),
windows (<code><a href="#topic+pixellate.owin">pixellate.owin</a></code>),
and 
line segment patterns (<code><a href="#topic+pixellate.psp">pixellate.psp</a></code>),
See the separate documentation for these methods.
</p>
<p>The related function <code><a href="#topic+as.im">as.im</a></code>
also converts <code>x</code> into a pixel image,
but typically measures only the presence or absence of
<code>x</code> inside each pixel.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pixellate.ppp">pixellate.ppp</a></code>,
<code><a href="#topic+pixellate.owin">pixellate.owin</a></code>,
<code><a href="#topic+pixellate.psp">pixellate.psp</a></code>,
<code><a href="#topic+as.im">as.im</a></code>
</p>

<hr>
<h2 id='pixellate.owin'>
Convert Window to Pixel Image
</h2><span id='topic+pixellate.owin'></span>

<h3>Description</h3>

<p>Convert a window to 
a pixel image by measuring the area of intersection
between the window and each pixel in a raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'owin'
pixellate(x, W = NULL, ..., DivideByPixelArea=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pixellate.owin_+3A_x">x</code></td>
<td>

<p>Window (object of class <code>"owin"</code>) to be converted.
</p>
</td></tr>
<tr><td><code id="pixellate.owin_+3A_w">W</code></td>
<td>

<p>Optional. Window determining the pixel raster on which the conversion
should occur. 
</p>
</td></tr>
<tr><td><code id="pixellate.owin_+3A_...">...</code></td>
<td>

<p>Optional. Extra arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
to determine the pixel raster.
</p>
</td></tr>
<tr><td><code id="pixellate.owin_+3A_dividebypixelarea">DivideByPixelArea</code></td>
<td>

<p>Logical value, indicating whether the resulting pixel values
should be divided by the pixel area.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code>pixellate</code>.
</p>
<p>It converts a window <code>x</code> into
a pixel image, by measuring the <em>amount</em> of <code>x</code> that is
inside each pixel.
</p>
<p>(The related function <code><a href="#topic+as.im">as.im</a></code>
also converts <code>x</code> into a pixel image,
but records only the presence or absence of
<code>x</code> in each pixel.)
</p>
<p>The pixel raster for the conversion is determined by the
argument <code>W</code> and the extra arguments <code>...</code>.
</p>

<ul>
<li> 
<p>If <code>W</code> is given, and it is a binary mask (a window
of type <code>"mask"</code>) then it determines the pixel raster.
</p>
</li>
<li>
<p>If <code>W</code> is given, but it is not a binary mask (it is a
window of another type) then it will be converted to a binary mask
using <code>as.mask(W, ...)</code>.
</p>
</li>
<li>
<p>If <code>W</code> is not given, it defaults to
<code>as.mask(as.rectangle(x), ...)</code>
</p>
</li></ul>

<p>In the second and third cases it would be common to use the
argument <code>dimyx</code> to control the number of pixels. See the Examples.
</p>
<p>The algorithm then computes the area
of intersection of each pixel with the window.
</p>
<p>The result is a pixel image with pixel entries equal to these
intersection areas.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pixellate.ppp">pixellate.ppp</a></code>,
<code><a href="#topic+pixellate">pixellate</a></code>,
<code><a href="#topic+as.im">as.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(pixellate(letterR, dimyx=15))
   W &lt;- grow.rectangle(as.rectangle(letterR), 0.2)
   plot(pixellate(letterR, W, dimyx=15))
</code></pre>

<hr>
<h2 id='pixellate.ppp'>Convert Point Pattern to Pixel Image</h2><span id='topic+pixellate.ppp'></span><span id='topic+as.im.ppp'></span>

<h3>Description</h3>

<p>Converts a point pattern to a pixel image. The value in each pixel
is the number of points falling in that pixel, and is typically
either 0 or 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
pixellate(x, W=NULL, ..., weights = NULL,
                        padzero=FALSE, fractional=FALSE, preserve=FALSE,
                        DivideByPixelArea=FALSE, savemap=FALSE)

## S3 method for class 'ppp'
as.im(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pixellate.ppp_+3A_x">x</code>, <code id="pixellate.ppp_+3A_x">X</code></td>
<td>
<p>Point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="pixellate.ppp_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine
the pixel resolution</p>
</td></tr>
<tr><td><code id="pixellate.ppp_+3A_w">W</code></td>
<td>
<p>Optional window mask (object of class <code>"owin"</code>) determining
the pixel raster.
</p>
</td></tr>
<tr><td><code id="pixellate.ppp_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights associated with the points.</p>
</td></tr>
<tr><td><code id="pixellate.ppp_+3A_padzero">padzero</code></td>
<td>

<p>Logical value indicating whether to set pixel values
to zero outside the window. 
</p>
</td></tr>
<tr><td><code id="pixellate.ppp_+3A_fractional">fractional</code>, <code id="pixellate.ppp_+3A_preserve">preserve</code></td>
<td>

<p>Logical values determining the type of discretisation.
See Details.
</p>
</td></tr>
<tr><td><code id="pixellate.ppp_+3A_dividebypixelarea">DivideByPixelArea</code></td>
<td>

<p>Logical value, indicating whether the resulting pixel values
should be divided by the pixel area.
</p>
</td></tr>
<tr><td><code id="pixellate.ppp_+3A_savemap">savemap</code></td>
<td>

<p>Logical value, indicating whether to save information
about the discretised coordinates of the points of <code>x</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>pixellate.ppp</code> and <code>as.im.ppp</code>
convert a spatial point pattern <code>x</code> into a pixel
image, by counting the number of points (or the total weight of
points) falling in each pixel. 
</p>
<p>Calling <code>as.im.ppp</code> is equivalent to
calling <code>pixellate.ppp</code> with its default arguments.
Note that <code>pixellate.ppp</code> is more general than <code>as.im.ppp</code>
(it has additional arguments for greater flexibility).
</p>
<p>The functions <code>as.im.ppp</code> and <code>pixellate.ppp</code>
are methods for the generic functions <code><a href="#topic+as.im">as.im</a></code>
and <code><a href="#topic+pixellate">pixellate</a></code> respectively,
for the class of point patterns.
</p>
<p>The pixel raster (in which points are counted) is determined
by the argument <code>W</code> if it is present (for <code>pixellate.ppp</code> only).
In this case <code>W</code> should be a binary mask (a window object of
class <code>"owin"</code> with type <code>"mask"</code>).
Otherwise the pixel raster is determined by
extracting the window containing <code>x</code> and converting it to a
binary pixel mask using <code><a href="#topic+as.mask">as.mask</a></code>. The arguments
<code>...</code> are passed to <code><a href="#topic+as.mask">as.mask</a></code> to
control the pixel resolution.
</p>
<p>If <code>weights</code> is <code>NULL</code>, then for each pixel
in the mask, the algorithm counts how many points in <code>x</code> fall
in the pixel. This count is usually either 0 (for a pixel with no data
points in it) or 1 (for a pixel containing one data point) but may be
greater than 1. The result is an image with these counts as its pixel values.
</p>
<p>If <code>weights</code> is given, it should be a numeric vector of the same
length as the number of points in <code>x</code>. For each pixel, the
algorithm finds the total weight associated with points in <code>x</code> that fall
in the given pixel. The result is an image with these total weights
as its pixel values.
</p>
<p>By default (if <code>zeropad=FALSE</code>) the resulting pixel image has the same
spatial domain as the window of the point pattern <code>x</code>. If
<code>zeropad=TRUE</code> then the resulting pixel image has a rectangular
domain; pixels outside the original window are assigned the value zero.
</p>
<p>The discretisation procedure is controlled by the arguments
<code>fractional</code> and <code>preserve</code>.
</p>

<ul>
<li> 
<p>The argument <code>fractional</code> specifies how data points are mapped to
pixels. If <code>fractional=FALSE</code> (the default),
each data point is allocated to the nearest pixel centre.
If <code>fractional=TRUE</code>, each data point is allocated
with fractional weight to four pixel centres
(the corners of a rectangle containing the data
point).
</p>
</li>
<li>
<p>The argument <code>preserve</code> specifies what to do with pixels
lying near the boundary of the window, if the window is not a rectangle.
If <code>preserve=FALSE</code> (the default), any contributions
that are attributed to pixel centres lying outside the window
are reset to zero. If <code>preserve=TRUE</code>, any such contributions
are shifted to the nearest pixel lying inside the window, so that
the total mass is preserved.
</p>
</li></ul>

<p>If <code>savemap=TRUE</code> then the result has an attribute
<code>"map"</code> which is a 2-column matrix containing the row and column
indices of the discretised positions of the points of <code>x</code>
in the pixel grid.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pixellate">pixellate</a></code>,
<code><a href="#topic+im">im</a></code>, <code><a href="#topic+as.im">as.im</a></code>,
<code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>, <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(pixellate(humberside))
  plot(pixellate(humberside, fractional=TRUE))
</code></pre>

<hr>
<h2 id='pixellate.psp'>
Convert Line Segment Pattern to Pixel Image
</h2><span id='topic+pixellate.psp'></span>

<h3>Description</h3>

<p>Converts a line segment pattern to a pixel image
by measuring the length or number of lines intersecting each pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'psp'
pixellate(x, W=NULL, ..., weights = NULL,
                        what=c("length", "number"),
                        DivideByPixelArea=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pixellate.psp_+3A_x">x</code></td>
<td>

<p>Line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="pixellate.psp_+3A_w">W</code></td>
<td>

<p>Optional window (object of class <code>"owin"</code>) determining
the pixel resolution.
</p>
</td></tr>
<tr><td><code id="pixellate.psp_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> to determine
the pixel resolution.
</p>
</td></tr>
<tr><td><code id="pixellate.psp_+3A_weights">weights</code></td>
<td>

<p>Optional vector of weights associated with each line segment.
</p>
</td></tr>
<tr><td><code id="pixellate.psp_+3A_what">what</code></td>
<td>

<p>String (partially matched) indicating whether to compute the
total length of intersection (<code>what="length"</code>, the default)
or the total number of segments intersecting each pixel
(<code>what="number"</code>).
</p>
</td></tr>
<tr><td><code id="pixellate.psp_+3A_dividebypixelarea">DivideByPixelArea</code></td>
<td>

<p>Logical value, indicating whether the resulting pixel values
should be divided by the pixel area.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a line segment pattern to a pixel image by computing,
for each pixel, the total length of
intersection between the pixel and the line segments.
Alternatively it can count the number of line segments intersecting
each pixel. 
</p>
<p>This is a method for the generic function
<code><a href="#topic+pixellate">pixellate</a></code> for the class of line segment patterns.
</p>
<p>The pixel raster is determined by <code>W</code>
and the optional arguments <code>...</code>.
If <code>W</code> is missing or <code>NULL</code>, it defaults to the window
containing <code>x</code>.
Then <code>W</code> is converted to a
binary pixel mask using <code><a href="#topic+as.mask">as.mask</a></code>. The arguments
<code>...</code> are passed to <code><a href="#topic+as.mask">as.mask</a></code> to
control the pixel resolution.
</p>
<p>If <code>weights</code> are given, then the length of the intersection
between line segment <code>i</code> and pixel <code>j</code> is multiplied by
<code>weights[i]</code> before the lengths are summed for each pixel.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) with numeric values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pixellate">pixellate</a></code>,
<code><a href="#topic+as.mask">as.mask</a></code>,
<code><a href="#topic+psp2mask">psp2mask</a></code>.
</p>
<p>Use <code><a href="#topic+psp2mask">psp2mask</a></code> if you only want to know
which pixels are intersected by lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- psp(runif(10),runif(10), runif(10), runif(10), window=owin())
  plot(pixellate(X))
  plot(X, add=TRUE)
  sum(lengths_psp(X))
  sum(pixellate(X))
  plot(pixellate(X, what="n"))
</code></pre>

<hr>
<h2 id='pixelquad'>Quadrature Scheme Based on Pixel Grid</h2><span id='topic+pixelquad'></span>

<h3>Description</h3>

<p>Makes a quadrature scheme with a dummy point at every pixel
of a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixelquad(X, W = as.owin(X))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pixelquad_+3A_x">X</code></td>
<td>
<p>Point pattern (object of class <code>"ppp"</code>) containing the
data points for the quadrature scheme.
</p>
</td></tr>
<tr><td><code id="pixelquad_+3A_w">W</code></td>
<td>

<p>Specifies the pixel grid.
A pixel image (object of class <code>"im"</code>),
a window (object of class <code>"owin"</code>), or anything that can
be converted to a window by <code><a href="#topic+as.owin">as.owin</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for producing a quadrature scheme
for use by <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>. It is an alternative to
<code><a href="#topic+quadscheme">quadscheme</a></code>.
</p>
<p>The function <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> fits a point process model to an
observed point pattern using 
the Berman-Turner quadrature approximation (Berman and Turner, 1992;
Baddeley and Turner, 2000) to the pseudolikelihood of the model. 
It requires a quadrature scheme consisting of 
the original data point pattern, an additional pattern of dummy points,
and a vector of quadrature weights for all these points.
Such quadrature schemes are represented by objects of class
<code>"quad"</code>. See <code><a href="#topic+quad.object">quad.object</a></code> for a description of this class.
</p>
<p>Given a grid of pixels, this function creates a quadrature scheme
in which there is one dummy point at the centre of each pixel. The
counting weights are used (the weight attached to each quadrature
point is 1 divided by the number of quadrature points falling
in the same pixel).
</p>
<p>The argument <code>X</code> specifies the locations of the data points
for the quadrature scheme. Typically this would be a point pattern
dataset.
</p>
<p>The argument <code>W</code> specifies the grid of pixels for the dummy
points of the quadrature scheme. It should be a pixel image
(object of class <code>"im"</code>), a window (object of class
<code>"owin"</code>), or anything that can
be converted to a window by <code><a href="#topic+as.owin">as.owin</a></code>. If <code>W</code> is a
pixel image or a binary mask (a window of type <code>"mask"</code>)
then the pixel grid of <code>W</code> will be used. If <code>W</code> is a
rectangular or polygonal window, then it will first be converted to a
binary mask using <code><a href="#topic+as.mask">as.mask</a></code> at the default pixel
resolution.
</p>


<h3>Value</h3>

<p>An object of class <code>"quad"</code> describing the quadrature scheme
(data points, dummy points, and quadrature weights)
suitable as the argument <code>Q</code> of the function <code><a href="spatstat.model.html#topic+ppm">ppm</a>()</code> for
fitting a point process model.
</p>
<p>The quadrature scheme can be inspected using the
<code>print</code> and <code>plot</code> methods for objects
of class <code>"quad"</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadscheme">quadscheme</a></code>,
<code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  W &lt;- owin(c(0,1),c(0,1))
  X &lt;- runifrect(42, W)
  W &lt;- as.mask(W,dimyx=128)
  pixelquad(X,W)
</code></pre>

<hr>
<h2 id='plot.anylist'>Plot a List of Things</h2><span id='topic+plot.anylist'></span>

<h3>Description</h3>

<p>Plots a list of things
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'anylist'
plot(x, ..., main, arrange=TRUE,
   nrows=NULL, ncols=NULL, main.panel=NULL,
   mar.panel=c(2,1,1,2), hsep=0, vsep=0,
   panel.begin=NULL, panel.end=NULL, panel.args=NULL,
   panel.begin.args=NULL, panel.end.args=NULL, panel.vpad=0.2,
   plotcommand="plot",
   adorn.left=NULL, adorn.right=NULL, adorn.top=NULL, adorn.bottom=NULL,
   adorn.size=0.2, equal.scales=FALSE, halign=FALSE, valign=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.anylist_+3A_x">x</code></td>
<td>

<p>An object of the class <code>"anylist"</code>.
Essentially a list of objects.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code> when generating each
plot panel.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_main">main</code></td>
<td>

<p>Overall heading for the plot.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_arrange">arrange</code></td>
<td>

<p>Logical flag indicating whether to plot the objects
side-by-side on a single page (<code>arrange=TRUE</code>)
or plot them individually in a succession of frames
(<code>arrange=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_nrows">nrows</code>, <code id="plot.anylist_+3A_ncols">ncols</code></td>
<td>

<p>Optional. The number of rows/columns in the plot layout
(assuming <code>arrange=TRUE</code>).
You can specify either or both of these numbers.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_main.panel">main.panel</code></td>
<td>

<p>Optional. A character string, or a vector of character strings,
giving the headings for each of the objects.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_mar.panel">mar.panel</code></td>
<td>

<p>Size of the margins outside each plot panel.
A numeric vector of length 4 giving the bottom, left, top,
and right margins in that order. (Alternatively the vector
may have length 1 or 2 and will be replicated to length 4).
See the section on <em>Spacing between plots</em>.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_hsep">hsep</code>, <code id="plot.anylist_+3A_vsep">vsep</code></td>
<td>

<p>Additional horizontal and vertical separation between plot panels,
expressed in the same units as <code>mar.panel</code>. 
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_panel.begin">panel.begin</code>, <code id="plot.anylist_+3A_panel.end">panel.end</code></td>
<td>

<p>Optional. Functions that will be executed before and after each panel is
plotted. See Details.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_panel.args">panel.args</code></td>
<td>

<p>Optional. Function that determines different plot arguments
for different panels. See Details.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_panel.begin.args">panel.begin.args</code></td>
<td>

<p>Optional. List of additional arguments for <code>panel.begin</code>
when it is a function.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_panel.end.args">panel.end.args</code></td>
<td>

<p>Optional. List of additional arguments for <code>panel.end</code>
when it is a function.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_panel.vpad">panel.vpad</code></td>
<td>

<p>Amount of extra vertical space that should be allowed for the
title of each panel, if a title will be displayed.
Expressed as a fraction of the height of the panel.
Applies only when <code>equal.scales=FALSE</code> (the default) and
requires that the height of each panel can be determined.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_plotcommand">plotcommand</code></td>
<td>

<p>Optional.
Character string containing the name of the command that should be
executed to plot each panel. 
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_adorn.left">adorn.left</code>, <code id="plot.anylist_+3A_adorn.right">adorn.right</code>, <code id="plot.anylist_+3A_adorn.top">adorn.top</code>, <code id="plot.anylist_+3A_adorn.bottom">adorn.bottom</code></td>
<td>

<p>Optional. Functions (with no arguments) that will be executed to
generate additional plots at the margins (left, right, top and/or
bottom, respectively) of the array of plots.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_adorn.size">adorn.size</code></td>
<td>

<p>Relative width (as a fraction of the other panels' widths)
of the margin plots.
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_equal.scales">equal.scales</code></td>
<td>

<p>Logical value indicating whether the components
should be plotted at (approximately) the same physical scale. 
</p>
</td></tr>
<tr><td><code id="plot.anylist_+3A_halign">halign</code>, <code id="plot.anylist_+3A_valign">valign</code></td>
<td>

<p>Logical values indicating whether panels in a column
should be aligned to the same <code class="reqn">x</code> coordinate system
(<code>halign=TRUE</code>) and whether panels in a row should
be aligned to the same <code class="reqn">y</code> coordinate system (<code>valign=TRUE</code>).
These are applicable only if <code>equal.scales=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"anylist"</code>.
</p>
<p>An object of class <code>"anylist"</code> represents
a list of objects intended to be treated in the same way.
This is the method for <code>plot</code>.
</p>
<p>In the <span class="pkg">spatstat</span> package, various functions produce
an object of class <code>"anylist"</code>, essentially a list of
objects of the same kind. 
These objects can be plotted in a nice arrangement
using <code>plot.anylist</code>. See the Examples.
</p>
<p>The argument <code>panel.args</code> determines extra graphics parameters
for each panel. It should be a function that will be called
as <code>panel.args(i)</code> where <code>i</code> is the panel number.
Its return value should be a list of graphics parameters that can
be passed to the relevant <code>plot</code> method. These parameters
override any parameters specified in the <code>...</code> arguments.
</p>
<p>The arguments <code>panel.begin</code> and <code>panel.end</code>
determine graphics that will be plotted before and after
each panel is plotted. They may be objects
of some class that can be plotted
with the generic <code>plot</code> command. Alternatively they
may be functions that will be
called as <code>panel.begin(i, y, main=main.panel[i])</code>
and <code>panel.end(i, y, add=TRUE)</code> where <code>i</code> is the panel
number and <code>y = x[[i]]</code>.
</p>
<p>If all entries of <code>x</code> are pixel images,
the function <code><a href="#topic+image.listof">image.listof</a></code> is called to control
the plotting. The arguments <code>equal.ribbon</code> and <code>col</code>
can be used to determine the colour map or maps applied.
</p>
<p>If <code>equal.scales=FALSE</code> (the default), then the 
plot panels will have equal height on the plot device
(unless there is only one column of panels, in which case
they will have equal width on the plot device). This means that the
objects are plotted at different physical scales, by default.
</p>
<p>If <code>equal.scales=TRUE</code>, then the dimensions of the
plot panels on the plot device will be proportional
to the spatial dimensions of the
corresponding components of <code>x</code>. This means that the
objects will be plotted at <em>approximately</em> equal physical scales.
If these objects have very different spatial sizes,
the plot command could fail (when it tries
to plot the smaller objects at a tiny scale), with an error
message that the figure margins are too large.
</p>
<p>The objects will be plotted at <em>exactly</em> equal
physical scales, and <em>exactly</em> aligned on the device,
under the following conditions:
</p>

<ul>
<li>
<p>every component of <code>x</code> is a spatial object
whose position can be shifted by <code><a href="#topic+shift">shift</a></code>;
</p>
</li>
<li>
<p><code>panel.begin</code> and <code>panel.end</code> are either
<code>NULL</code> or they are spatial objects 
whose position can be shifted by <code><a href="#topic+shift">shift</a></code>;
</p>
</li>
<li>
<p><code>adorn.left</code>, 
<code>adorn.right</code>, 
<code>adorn.top</code> and 
<code>adorn.bottom</code> are all <code>NULL</code>.
</p>
</li></ul>

<p>Another special case is when every component of <code>x</code> is an
object of class <code>"fv"</code> representing a function.
If <code>equal.scales=TRUE</code> then all these functions will 
be plotted with the same axis scales
(i.e. with the same <code>xlim</code> and the same <code>ylim</code>).
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Spacing between plots</h3>

<p>The spacing between individual plots is controlled by the parameters
<code>mar.panel</code>, <code>hsep</code> and <code>vsep</code>.
</p>
<p>If <code>equal.scales=FALSE</code>, the plot panels are
logically separate plots. The margins for each panel are
determined by the argument <code>mar.panel</code> which becomes 
the graphics parameter <code>mar</code>
described in the help file for <code><a href="graphics.html#topic+par">par</a></code>.
One unit of <code>mar</code> corresponds to one line of text in the margin.
If <code>hsep</code> or <code>vsep</code> are present, <code>mar.panel</code>
is augmented by <code>c(vsep, hsep, vsep, hsep)/2</code>.
</p>
<p>If <code>equal.scales=TRUE</code>, all the plot panels are drawn
in the same coordinate system which represents a physical scale.
The unit of measurement for <code>mar.panel[1,3]</code>
is one-sixth of the greatest height of any object plotted in the same row
of panels, and the unit for <code>mar.panel[2,4]</code> is one-sixth of the
greatest width of any object plotted in the same column of panels.
If <code>hsep</code> or <code>vsep</code> are present,
they are interpreted in the same units as <code>mar.panel[2]</code>
and <code>mar.panel[1]</code> respectively.
</p>


<h3>Error messages</h3>

<p>If the error message &lsquo;Figure margins too large&rsquo;
occurs, this generally means that one of the
objects had a much smaller physical scale than the others.
Ensure that <code>equal.scales=FALSE</code>
and increase the values of <code>mar.panel</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contour.listof">contour.listof</a></code>,
<code><a href="#topic+image.listof">image.listof</a></code>,
<code><a href="spatstat.explore.html#topic+density.splitppp">density.splitppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(spatstat.explore)) {
 trichotomy &lt;- list(regular=cells,
                    random=japanesepines,
                    clustered=redwood)
 K &lt;- lapply(trichotomy, Kest)
 K &lt;- as.anylist(K)
 plot(K, main="")
}

# list of 3D point patterns
 ape1 &lt;- osteo[osteo$shortid==4, "pts", drop=TRUE]
 class(ape1)
 plot(ape1, main.panel="", mar.panel=0.1, hsep=0.7, vsep=1,
      cex=1.5, pch=21, bg='white')
</code></pre>

<hr>
<h2 id='plot.colourmap'>Plot a Colour Map</h2><span id='topic+plot.colourmap'></span>

<h3>Description</h3>

<p>Displays a colour map as a colour ribbon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'colourmap'
plot(x, ...,
       main, xlim = NULL, ylim = NULL, vertical = FALSE, axis = TRUE,
       labelmap=NULL, gap=0.25, add=FALSE, increasing=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.colourmap_+3A_x">x</code></td>
<td>
<p>Colour map to be plotted. An object of class <code>"colourmap"</code>.</p>
</td></tr>
<tr><td><code id="plot.colourmap_+3A_...">...</code></td>
<td>

<p>Graphical arguments passed to <code><a href="graphics.html#topic+image.default">image.default</a></code>
or <code><a href="graphics.html#topic+axis">axis</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.colourmap_+3A_main">main</code></td>
<td>
<p>Main title for plot. A character string.</p>
</td></tr>
<tr><td><code id="plot.colourmap_+3A_xlim">xlim</code></td>
<td>

<p>Optional range of <code>x</code> values for the location of the
colour ribbon.
</p>
</td></tr>
<tr><td><code id="plot.colourmap_+3A_ylim">ylim</code></td>
<td>

<p>Optional range of <code>y</code> values for the location of the
colour ribbon.
</p>
</td></tr>
<tr><td><code id="plot.colourmap_+3A_vertical">vertical</code></td>
<td>
<p>Logical flag determining whether the colour ribbon
is plotted as a horizontal strip (<code>FALSE</code>) or a vertical strip
(<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.colourmap_+3A_axis">axis</code></td>
<td>
<p>Logical flag determining whether an axis should be plotted
showing the numerical values that are mapped to the colours.
</p>
</td></tr>
<tr><td><code id="plot.colourmap_+3A_labelmap">labelmap</code></td>
<td>

<p>Function. If this is present, then the labels on the plot,
which indicate the input values corresponding to particular colours,
will be transformed by <code>labelmap</code> before being displayed
on the plot. Typically used to simplify or shorten the
labels on the plot.
</p>
</td></tr>
<tr><td><code id="plot.colourmap_+3A_gap">gap</code></td>
<td>

<p>Distance between separate blocks of colour, as a fraction of
the width of one block, if the colourmap is discrete.
</p>
</td></tr>
<tr><td><code id="plot.colourmap_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether to add the colourmap to the
existing plot (<code>add=TRUE</code>), or to start a new plot
(<code>add=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="plot.colourmap_+3A_increasing">increasing</code></td>
<td>

<p>Logical value indicating whether to display the colour map
in increasing order. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the plot method for the class <code>"colourmap"</code>.
An object of this class
(created by the function <code><a href="#topic+colourmap">colourmap</a></code>)
represents a colour map or
colour lookup table associating colours with each data value.
</p>
<p>The command <code>plot.colourmap</code> displays the colour map as a colour
ribbon or as a colour legend (a sequence of blocks of colour).
This plot can be useful on its own to inspect the colour map.
</p>
<p>If the domain of the colourmap is an interval of real numbers,
the colourmap is displayed as a continuous ribbon of colour.
If the domain of the colourmap is a finite set of inputs,
the colours are displayed as separate blocks of colour.
The separation between blocks is equal to <code>gap</code> times
the width of one block. 
</p>
<p>To annotate an existing plot with an explanatory colour ribbon
or colour legend,
specify <code>add=TRUE</code> and use the arguments <code>xlim</code>
and/or <code>ylim</code> to control the physical position of the ribbon
on the plot.
</p>
<p>Labels explaining the colour map are
drawn by <code><a href="graphics.html#topic+axis">axis</a></code> and can be modified by
specifying arguments that will be passed to this function.
</p>
<p>The argument <code>increasing</code> indicates whether the
colourmap should be displayed so that the
input values are increasing with the spatial coordinate:
that is, increasing from left to right (if <code>vertical=FALSE</code>)
or increasing from bottom to top (if <code>vertical=TRUE</code>).
If <code>increasing=FALSE</code>, this ordering will be reversed.
The default is <code>increasing=TRUE</code> in all cases
except when <code>vertical=TRUE</code> and
the domain of the colourmap is a finite set of discrete inputs.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colourmap">colourmap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  co &lt;- colourmap(rainbow(100), breaks=seq(-1,1,length=101))
  plot(co)
  plot(co, col.ticks="pink")
  ca &lt;- colourmap(rainbow(8), inputs=letters[1:8])
  plot(ca, vertical=TRUE)
</code></pre>

<hr>
<h2 id='plot.hyperframe'>Plot Entries in a Hyperframe</h2><span id='topic+plot.hyperframe'></span>

<h3>Description</h3>

<p>Plots the entries in a hyperframe, in a series of
panels, one panel for each row of the hyperframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'hyperframe'
plot(x, e, ..., main, arrange=TRUE,
                            nrows=NULL, ncols=NULL,
                            parargs=list(mar=mar * marsize),
                            marsize=1, mar=c(1,1,3,1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hyperframe_+3A_x">x</code></td>
<td>

<p>Data to be plotted. A hyperframe (object of class <code>"hyperframe"</code>, see
<code><a href="#topic+hyperframe">hyperframe</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_e">e</code></td>
<td>

<p>How to plot each row. Optional. An <span class="rlang"><b>R</b></span> language call or expression
(typically enclosed in <code><a href="base.html#topic+quote">quote</a>()</code> that will be
evaluated in each row of the hyperframe to generate the plots.
</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_...">...</code></td>
<td>

<p>Extra arguments controlling the plot (when <code>e</code> is missing).
</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_main">main</code></td>
<td>
<p>Overall title for the array of plots.</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_arrange">arrange</code></td>
<td>

<p>Logical flag indicating whether to plot the objects
side-by-side on a single page (<code>arrange=TRUE</code>)
or plot them individually in a succession of frames
(<code>arrange=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_nrows">nrows</code>, <code id="plot.hyperframe_+3A_ncols">ncols</code></td>
<td>

<p>Optional. The number of rows/columns in the plot layout
(assuming <code>arrange=TRUE</code>).
You can specify either or both of these numbers.
</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_parargs">parargs</code></td>
<td>

<p>Optional list of arguments passed to <code><a href="graphics.html#topic+par">par</a></code> before
plotting each panel. Can be used to control margin sizes, etc.
</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_marsize">marsize</code></td>
<td>

<p>Optional scale parameter controlling the sizes of margins around
the panels. Incompatible with <code>parargs</code>.
</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_mar">mar</code></td>
<td>

<p>Optional numeric vector of length 1, 2 or 4
controlling the relative sizes of margins between
the panels. Incompatible with <code>parargs</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"hyperframe"</code>.
</p>
<p>The argument <code>x</code> must be a hyperframe (like a data frame,
except that the entries can be objects of any class; see
<code><a href="#topic+hyperframe">hyperframe</a></code>).
</p>
<p>This function generates a series of plots, one plot for each
row of the hyperframe. If <code>arrange=TRUE</code> (the default), then
these plots are arranged in a neat array of panels within a single
plot frame. If <code>arrange=FALSE</code>, the plots are simply executed
one after another.
</p>
<p>Exactly what is plotted, and how it is plotted, depends on the
argument <code>e</code>. The default (if <code>e</code> is missing) is to plot
only the first column of <code>x</code>. Each entry in the first column
is plotted using the generic <code><a href="graphics.html#topic+plot">plot</a></code> command, together with
any extra arguments given in <code>...</code>.
</p>
<p>If <code>e</code> is present, it should be an <span class="rlang"><b>R</b></span> language expression
involving the column names of <code>x</code>.
(It is typically created using <code><a href="base.html#topic+quote">quote</a></code> or
<code><a href="base.html#topic+expression">expression</a></code>.)
The expression will be evaluated once for each row of <code>x</code>.
It will be evaluated in an environment where each column name of
<code>x</code> is interpreted as meaning the object in that column
in the current row.
See the Examples.
</p>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyperframe">hyperframe</a></code>,
<code><a href="#topic+with.hyperframe">with.hyperframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   H &lt;- hyperframe(id=1:6)
   H$X &lt;- with(H, runifrect(100))
   H$D &lt;- with(H, distmap(X))
   # points only
   plot(H[,"X"])
   plot(H, quote(plot(X, main=id)))
   # points superimposed on images
   plot(H, quote({plot(D, main=id); plot(X, add=TRUE)}))
</code></pre>

<hr>
<h2 id='plot.im'>Plot a Pixel Image</h2><span id='topic+plot.im'></span><span id='topic+image.im'></span>

<h3>Description</h3>

<p>Plot a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
plot(x, ...,
                   main,
                   add=FALSE, clipwin=NULL,
                   col=NULL, valuesAreColours=NULL, log=FALSE,
                   ncolours=256, gamma=1, 
                   ribbon=show.all, show.all=!add,
                   ribside=c("right", "left", "bottom", "top"),
                   ribsep=0.15, ribwid=0.05, ribn=1024,
                   ribscale=1, ribargs=list(), riblab=NULL, colargs=list(),
                   useRaster=NULL, workaround=FALSE, zap=1,
                   do.plot=TRUE,
                   addcontour=FALSE, contourargs=list()) 

  ## S3 method for class 'im'
image(x, ...,
                   main,
                   add=FALSE, clipwin=NULL,
                   col=NULL, valuesAreColours=NULL, log=FALSE, 
                   ncolours=256, gamma=1, 
                   ribbon=show.all, show.all=!add,
                   ribside=c("right", "left", "bottom", "top"),
                   ribsep=0.15, ribwid=0.05, ribn=1024,
                   ribscale=1, ribargs=list(), riblab=NULL, colargs=list(),
                   useRaster=NULL, workaround=FALSE, zap=1,
                   do.plot=TRUE,
                   addcontour=FALSE, contourargs=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.im_+3A_x">x</code></td>
<td>

<p>The pixel image to be plotted.
An object of class <code>"im"</code> (see <code><a href="#topic+im.object">im.object</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="graphics.html#topic+image.default">image.default</a></code>
to control the plot. See Details.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_main">main</code></td>
<td>
<p>Main title for the plot.</p>
</td></tr>
<tr><td><code id="plot.im_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether to superimpose the image on the
existing plot (<code>add=TRUE</code>)
or to initialise a new plot (<code>add=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_clipwin">clipwin</code></td>
<td>

<p>Optional. A window (object of class <code>"owin"</code>).
Only this subset of the image will be displayed.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_col">col</code></td>
<td>

<p>Colours for displaying the pixel values.
Either a character vector of colour values,
an object of class <code><a href="#topic+colourmap">colourmap</a></code>,
or a <code>function</code> as described under Details.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_valuesarecolours">valuesAreColours</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, the pixel values of <code>x</code>
are to be interpreted as colour values.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_log">log</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, the colour map will be
evenly-spaced on a logarithmic scale.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_ncolours">ncolours</code></td>
<td>

<p>Integer. The default number of colours in the colour map
for a real-valued image.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_gamma">gamma</code></td>
<td>

<p>Exponent for the gamma correction of the colours.
A single positive number.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_ribbon">ribbon</code></td>
<td>

<p>Logical flag indicating whether to display a ribbon
showing the colour map. Default is <code>TRUE</code>
for new plots and <code>FALSE</code> for added plots.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_show.all">show.all</code></td>
<td>

<p>Logical value indicating whether to display all plot elements
including the main title and colour ribbon. Default is <code>TRUE</code>
for new plots and <code>FALSE</code> for added plots.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_ribside">ribside</code></td>
<td>

<p>Character string indicating where to display the ribbon
relative to the main image.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_ribsep">ribsep</code></td>
<td>

<p>Factor controlling the space between the ribbon and the image.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_ribwid">ribwid</code></td>
<td>

<p>Factor controlling the width of the ribbon.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_ribn">ribn</code></td>
<td>

<p>Number of different values to display in the ribbon.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_ribscale">ribscale</code></td>
<td>

<p>Rescaling factor for tick marks. The values on the numerical scale
printed beside the ribbon will be multiplied by this rescaling factor.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_ribargs">ribargs</code></td>
<td>

<p>List of additional arguments passed to
<code><a href="graphics.html#topic+image.default">image.default</a></code>, 
<code><a href="graphics.html#topic+axis">axis</a></code> and
<code><a href="grDevices.html#topic+axisTicks">axisTicks</a></code>
to control the display of the ribbon and its scale axis. These may override
the <code>...</code> arguments. 
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_riblab">riblab</code></td>
<td>

<p>Text to be plotted in the margin near the ribbon.
A character string or expression to be interpreted as text,
or a list of arguments to be passed to
<code><a href="graphics.html#topic+mtext">mtext</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_colargs">colargs</code></td>
<td>

<p>List of additional arguments passed to
<code>col</code> if it is a function.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_useraster">useRaster</code></td>
<td>

<p>Logical value, passed to <code><a href="graphics.html#topic+image.default">image.default</a></code>.
Images are plotted using a bitmap raster if <code>useRaster=TRUE</code>
or by drawing polygons if <code>useRaster=FALSE</code>.
Bitmap raster display tends to produce better results,
but is not supported on all graphics devices.
The default is to use bitmap raster display if it is supported.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_workaround">workaround</code></td>
<td>

<p>Logical value, specifying whether to use a workaround to avoid a bug
which occurs with some device drivers in <span class="rlang"><b>R</b></span>, in which the image
has the wrong spatial orientation. See the section on
<b>Image is Displayed in Wrong Spatial Orientation</b> below.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_zap">zap</code></td>
<td>

<p>Noise threshold factor. A numerical value greater than or equal to 1.
If the range of pixel values is less than
<code>zap * .Machine$double.eps</code>, the image will be treated as
constant. This avoids displaying images which should be constant
but contain small numerical errors.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value indicating whether to actually plot the image
and colour ribbon.
Setting <code>do.plot=FALSE</code> will simply return the
colour map and the bounding box that were chosen for the plot.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_addcontour">addcontour</code></td>
<td>

<p>Logical value specifying whether to add contour lines to the image
plot. The contour lines will also be drawn on the colour ribbon.
</p>
</td></tr>
<tr><td><code id="plot.im_+3A_contourargs">contourargs</code></td>
<td>

<p>Optional list of arguments to be passed to
<code><a href="graphics.html#topic+contour.default">contour.default</a></code> to control the contour plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"im"</code>.
[It is also the <code>image</code> method for <code>"im"</code>.]
</p>
<p>The pixel image <code>x</code> is displayed on the current plot device,
using equal scales on the <code>x</code> and <code>y</code> axes.
</p>
<p>If <code>ribbon=TRUE</code>, a legend will be plotted.
The legend consists of a colour ribbon and an axis with tick-marks,
showing the correspondence between the pixel values and the colour map.
</p>
<p>Arguments <code>ribside, ribsep, ribwid</code> control the placement
of the colour ribbon.
By default, the ribbon is placed at the right of the main image.
This can be changed using the argument <code>ribside</code>.
The width of the ribbon is <code>ribwid</code> times the size of the pixel
image, where &lsquo;size&rsquo; means the larger of the width and the height.
The distance separating the ribbon and the image is <code>ribsep</code> times
the size of the pixel image.
</p>
<p>The ribbon contains the colours representing <code>ribn</code>
different numerical values, evenly spaced between the minimum and
maximum pixel values in the image <code>x</code>, rendered according to
the chosen colour map.
</p>
<p>The argument <code>ribargs</code> controls the annotation of the
colour ribbon. It is a list of arguments to be passed to
<code><a href="graphics.html#topic+image.default">image.default</a></code>, 
<code><a href="graphics.html#topic+axis">axis</a></code> and
<code><a href="grDevices.html#topic+axisTicks">axisTicks</a></code>.
To plot the colour ribbon without the axis and
tick-marks, use <code>ribargs=list(axes=FALSE)</code>.
To ensure that the numerals or symbols printed next to the colour map
are oriented horizontally, use <code>ribargs=list(las=1)</code>.
To double the size of the numerals or symbols, 
use <code>ribargs=list(cex.axis=2)</code>.
To control the number of tick-marks, use <code>ribargs=list(nint=N)</code>
where <code>N</code> is the desired number of intervals (so there will
be <code>N+1</code> tickmarks, subject to the vagaries of <span class="rlang"><b>R</b></span> internal code). 
</p>
<p>The argument <code>riblab</code> contains text that will be displayed
in the margin next to the ribbon. 
</p>
<p>The argument <code>ribscale</code> is used
to rescale the numerical values printed next to the colour map,
for convenience. 
For example if the pixel values in <code>x</code> range between 1000 and
4000, it would be sensible to use <code>ribscale=1/1000</code> so that the
colour map tickmarks would be labelled 1 to 4. 
</p>
<p>Normally the pixel values are displayed using the colours given in the
argument <code>col</code>. This may be either
</p>

<ul>
<li><p> an explicit colour map (an object of class
<code>"colourmap"</code>, created by the command <code><a href="#topic+colourmap">colourmap</a></code>).
This is the best way to ensure
that when we plot different images, the colour maps are consistent.
</p>
</li>
<li><p> a character vector or integer vector
that specifies a set of colours.
The colour mapping will be stretched to match the range of
pixel values in the image <code>x</code>. The mapping of pixel values
to colours is determined as follows.
</p>

<dl>
<dt>logical-valued images:</dt><dd><p>the values <code>FALSE</code> and
<code>TRUE</code> are mapped to the colours <code>col[1]</code> and
<code>col[2]</code> respectively.
The vector <code>col</code> should have length 2.
</p>
</dd>
<dt>factor-valued images:</dt><dd><p>the factor levels <code>levels(x)</code>
are mapped to the entries of <code>col</code> in order. The vector
<code>col</code> should have the same length as <code>levels(x)</code>.
</p>
</dd>
<dt>numeric-valued images:</dt><dd>
<p>By default, the range of pixel values in <code>x</code>
is divided into <code>n = length(col)</code>
equal subintervals, which are mapped to the colours in <code>col</code>.
(If <code>col</code> was not specified, it defaults to a vector of 255
colours.)
</p>
<p>Alternatively if the argument <code>zlim</code> is given, it should be
a vector of length 2 specifying an interval of real numbers.
This interval will be used instead of the range of pixel
values. The interval from <code>zlim[1]</code> to <code>zlim[2]</code> will be
mapped to the colours in <code>col</code>. This facility enables the user to
plot several images using a consistent colour map.
</p>
<p>Alternatively if the argument <code>breaks</code> is given,
then this specifies
the endpoints of the subintervals that are mapped to each colour.
This is incompatible with <code>zlim</code>.
</p>
<p>The arguments <code>col</code> and <code>zlim</code> or <code>breaks</code>
are then passed to the function <code><a href="graphics.html#topic+image.default">image.default</a></code>.
For examples of the use of these arguments,
see <code><a href="graphics.html#topic+image.default">image.default</a></code>.
</p>
</dd>
</dl>

</li>
<li> 
<p>a <code>function</code> in the <span class="rlang"><b>R</b></span> language
with an argument named <code>range</code>
or <code>inputs</code>.
</p>
<p>If <code>col</code> is a function with an argument named <code>range</code>,
and if the pixel values of <code>x</code> are numeric values, 
then the colour values will be determined by evaluating
<code>col(range=range(x))</code>. The result of this evaluation
should be a character vector containing colour values, or
a <code>"colourmap"</code> object. Examples of such functions
are <code><a href="#topic+beachcolours">beachcolours</a></code> and <code><a href="#topic+beachcolourmap">beachcolourmap</a></code>.
</p>
<p>If <code>col</code> is a function with an argument named <code>inputs</code>,
and if the pixel values of <code>x</code> are discrete values (integer,
logical, factor or character), 
then the colour values will be determined by evaluating
<code>col(inputs=p)</code> where <code>p</code> is the set of possible pixel
values. The result should be a character vector 
containing colour values, or a <code>"colourmap"</code> object.

</p>
</li>
<li>
<p>a <code>function</code> in the <span class="rlang"><b>R</b></span> language with first argument
named <code>n</code>.
The colour values will be determined by evaluating
<code>col(n)</code> where <code>n</code> is the
number of distinct pixel values, up to a maximum of 128.
The result of this evaluation
should be a character vector containing color values.
Examples of such functions are
<code><a href="grDevices.html#topic+heat.colors">heat.colors</a></code>,
<code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code>,
<code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code> and
<code><a href="grDevices.html#topic+cm.colors">cm.colors</a></code>. 

</p>
</li></ul>

<p>If <code>spatstat.options("monochrome")</code> has been set to <code>TRUE</code>
then <b>all colours will be converted to grey scale values</b>.
</p>
<p>Other graphical parameters controlling the display of both the pixel image
and the ribbon can be passed through the <code>...</code> arguments
to the function <code><a href="graphics.html#topic+image.default">image.default</a></code>.
A parameter is handled only if it is one of the following:
</p>

<ul>
<li><p> a formal argument of <code><a href="graphics.html#topic+image.default">image.default</a></code>
that is operative when <code>add=TRUE</code>.
</p>
</li>
<li><p> one of the parameters
<code>"main", "asp", "sub", "axes", "xlab", "ylab"</code>
described in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</li>
<li><p> one of the parameters
<code>"ann", "cex", "font", "cex.axis", "cex.lab", "cex.main", "cex.sub",
      "col.axis", "col.lab", "col.main", "col.sub",
      "font.axis", "font.lab", "font.main", "font.sub"</code>
described in <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</li>
<li><p> the argument <code>box</code>, a logical value specifying whether
a box should be drawn.
</p>
</li></ul>

<p>Images are plotted using a bitmap raster if <code>useRaster=TRUE</code>
or by drawing polygons if <code>useRaster=FALSE</code>.
Bitmap raster display (performed by <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code>)
tends to produce better results, but is not supported on all graphics devices.
The default is to use bitmap raster display if it is
supported according to <code><a href="grDevices.html#topic+dev.capabilities">dev.capabilities</a></code>.
</p>
<p>Alternatively, the pixel values could be directly 
interpretable as colour values in <span class="rlang"><b>R</b></span>. That is, the pixel values
could be character strings that represent colours, or
values of a factor whose levels are character strings representing
colours.
</p>

<ul>
<li><p> If <code>valuesAreColours=TRUE</code>, then the pixel values will
be interpreted as colour values and displayed using these colours.
</p>
</li>
<li><p> If <code>valuesAreColours=FALSE</code>, then the pixel values will
<em>not</em> be interpreted as colour values, even if they could be.
</p>
</li>
<li><p> If <code>valuesAreColours=NULL</code>, the algorithm will guess
what it should do. If the argument <code>col</code> is given,
the pixel values will <em>not</em> be interpreted as colour values. Otherwise,
if all the pixel values are strings that represent colours, then
they will be interpreted and displayed as colours.
</p>
</li></ul>

<p>If pixel values are interpreted as colours, 
the arguments <code>col</code> and <code>ribbon</code> will be ignored,
and a ribbon will not be plotted.
</p>
<p>If <code>addcontour=TRUE</code>, contour lines will be superimposed on the
image. Lines will also be superimposed on the colour ribbon at the
corresponding positions. 
</p>


<h3>Value</h3>

<p>The colour map used. An object of class <code>"colourmap"</code>.
</p>
<p>Also has an attribute <code>"bbox"</code> giving a bounding box
for the plot (containing the main colour image and the
colour ribbon if plotted).
If a ribbon was plotted, there is also an attribute
<code>"bbox.legend"</code> giving a bounding box for the ribbon image.
Text annotation occurs outside these bounding boxes.
</p>


<h3>Complex-valued images</h3>

<p>If the pixel values in <code>x</code> are complex numbers,
they will be converted into four images containing the real and
imaginary parts and the modulus and argument, 
and plotted side-by-side using <code><a href="#topic+plot.imlist">plot.imlist</a></code>.
</p>


<h3>Monochrome colours</h3>

<p>If <code>spatstat.options("monochrome")</code> has been set to <code>TRUE</code>,
then <b>the image will be plotted in greyscale</b>.
The colours are converted to grey scale values using
<code><a href="#topic+to.grey">to.grey</a></code>.
The choice of colour map still has an effect, since it determines
the final grey scale values.
</p>
<p>Monochrome display can also be achieved by
setting the graphics device parameter <code>colormodel="grey"</code>
when starting a new graphics device, or in a call to
<code><a href="grDevices.html#topic+ps.options">ps.options</a></code> or <code><a href="grDevices.html#topic+pdf.options">pdf.options</a></code>.
</p>


<h3>Image Looks Like Noise</h3>

<p>An image plot which looks like digital noise
can be produced when the pixel values are almost exactly equal
but include a tiny amount of numerical error.
To check this, look at the numerals plotted next to the colour ribbon,
or compute <code>diff(range(x))</code>, to determine whether the range
of pixel values is almost zero. The behaviour can be suppressed
by picking a larger value of the argument <code>zap</code>.
</p>


<h3>Image Rendering Errors and Problems</h3>

<p>The help for <code><a href="graphics.html#topic+image.default">image.default</a></code>
and <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code> explains that
errors may occur, or images may be rendered incorrectly, on some
devices, depending on the availability of colours and other
device-specific constraints.
</p>
<p>If the image is not displayed at all,
try setting <code>useRaster=FALSE</code> in the call to <code>plot.im</code>.
If the ribbon colours are not displayed, set
<code>ribargs=list(useRaster=FALSE)</code>.
</p>
<p>Errors may occur on some graphics devices if the image is very
large. If this happens, try setting <code>useRaster=FALSE</code> in the
call to <code>plot.im</code>.
</p>
<p>The error message
<code>useRaster=TRUE can only be used with a regular grid</code>
means that the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates of the pixels in the
image are not perfectly equally spaced, due to numerical rounding.
This occurs with some images created by earlier versions of <span class="pkg">spatstat</span>.
To repair the coordinates in an image <code>X</code>, type
<code>X &lt;- as.im(X)</code>.
</p>


<h3>Image is Displayed in Wrong Spatial Orientation</h3>

<p>If the image is displayed in the wrong spatial orientation,
and you created the image data directly, 
please check that you understand the <span class="pkg">spatstat</span> convention for
the spatial orientation of pixel images. The row index of the matrix
of pixel values corresponds to the increasing <code class="reqn">y</code> coordinate; the
column index of the matrix corresponds to the increasing <code class="reqn">x</code> coordinate
(Baddeley, Rubak and Turner, 2015, section 3.6.3, pages 66&ndash;67).
</p>
<p>Images can be displayed in the wrong spatial orientation
on some devices, due to a bug in the device driver. This occurs only
when the plot coordinates are <em>reversed</em>, that is, when 
the plot was initialised with coordinate limits <code>xlim, ylim</code>
such that <code>xlim[1] &gt; xlim[2]</code> or <code>ylim[1] &gt; ylim[2]</code> or
both. This bug is reported to occur only when <code>useRaster=TRUE</code>.
To fix this, try setting <code>workaround=TRUE</code>, or if that is
unsuccessful, <code>useRaster=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im.object">im.object</a></code>,
<code><a href="#topic+colourmap">colourmap</a></code>,
<code><a href="#topic+contour.im">contour.im</a></code>,
<code><a href="#topic+persp.im">persp.im</a></code>,
<code><a href="#topic+hist.im">hist.im</a></code>,
<code><a href="graphics.html#topic+image.default">image.default</a></code>,
<code><a href="#topic+spatstat.options">spatstat.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # an image
   Z &lt;- setcov(owin())
   plot(Z)
   plot(Z, ribside="bottom")
   # stretchable colour map
   plot(Z, col=rainbow)
   plot(Z, col=terrain.colors(128), axes=FALSE)
   # fixed colour map
   tc &lt;- colourmap(rainbow(128), breaks=seq(-1,2,length=129))
   plot(Z, col=tc)
   # colour map function, with argument 'range'
   plot(Z, col=beachcolours, colargs=list(sealevel=0.5))
   # tweaking the plot
   plot(Z, main="La vie en bleu", col.main="blue", cex.main=1.5,
        box=FALSE,
        ribargs=list(col.axis="blue", col.ticks="blue", cex.axis=0.75))
   # add axes and axis labels
   plot(Z, axes=TRUE, ann=TRUE, xlab="Easting", ylab="Northing")
   # add contour lines
   plot(Z, addcontour=TRUE, contourargs=list(col="white", drawlabels=FALSE))
   # log scale
   V &lt;- eval.im(exp(exp(Z+2))/1e4)
   plot(V, log=TRUE, main="Log scale")
   # it's complex
   Y &lt;- exp(Z + V * 1i)
   plot(Y)
</code></pre>

<hr>
<h2 id='plot.imlist'>Plot a List of Images</h2><span id='topic+plot.imlist'></span><span id='topic+image.imlist'></span><span id='topic+image.listof'></span>

<h3>Description</h3>

<p>Plots an array of pixel images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'imlist'
plot(x, ..., plotcommand="image",
                          equal.ribbon=FALSE, ribmar=NULL)

  ## S3 method for class 'imlist'
image(x, ..., equal.ribbon=FALSE, ribmar=NULL)

  ## S3 method for class 'listof'
image(x, ..., equal.ribbon=FALSE, ribmar=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.imlist_+3A_x">x</code></td>
<td>

<p>An object of the class <code>"imlist"</code>
representing a list of pixel images.
Alternatively <code>x</code> may belong to the outdated class <code>"listof"</code>.
</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+plot.solist">plot.solist</a></code> to control the
spatial arrangement of panels, and arguments passed to <code><a href="#topic+plot.im">plot.im</a></code>
to control the display of each panel.
</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_equal.ribbon">equal.ribbon</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the colour maps of all the images will be
the same. If <code>FALSE</code>, the colour map of each
image is adjusted to the range of values of that image.
</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_ribmar">ribmar</code></td>
<td>

<p>Numeric vector of length 4 specifying the margins around the
colour ribbon, if <code>equal.ribbon=TRUE</code>. Entries in the vector
give the margin at the bottom, left, top, and right respectively,
as a multiple of the height of a line of text.
</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_plotcommand">plotcommand</code></td>
<td>

<p>Character string giving the name of a function
to be used to display each image.
Recognised by <code>plot.imlist</code> only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic plot commands
<code>plot</code> and <code>image</code> for the class <code>"imlist"</code>.
They are currently identical.
</p>
<p>An object of class <code>"imlist"</code> represents a list of pixel images.
(The outdated class <code>"listof"</code> is also handled.)
</p>
<p>Each entry in the list <code>x</code> will be displayed as a pixel image,
in an array of panels laid out on the same graphics display,
using <code><a href="#topic+plot.solist">plot.solist</a></code>. Individual panels are plotted by
<code><a href="#topic+plot.im">plot.im</a></code>.
</p>
<p>If <code>equal.ribbon=FALSE</code> (the default), 
the images are rendered using different colour maps,
which are displayed as colour ribbons beside each image.
If <code>equal.ribbon=TRUE</code>, the images are rendered using the
same colour map, and a single colour ribbon will be displayed at the right
side of the array. 
The colour maps and the placement of the colour ribbons are
controlled by arguments <code>...</code> passed to <code><a href="#topic+plot.im">plot.im</a></code>.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.solist">plot.solist</a></code>,
<code><a href="#topic+plot.im">plot.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## bei.extra is a list of pixel images
 Y &lt;- solapply(bei.extra, scaletointerval)
 image(Y, equal.ribbon=TRUE, main="", col.ticks="red", col.axis="red")
</code></pre>

<hr>
<h2 id='plot.layered'>
Layered Plot
</h2><span id='topic+plot.layered'></span>

<h3>Description</h3>

<p>Generates a layered plot.
The plot method for objects of class <code>"layered"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'layered'
plot(x, ..., which = NULL, plotargs = NULL,
                         add=FALSE, show.all=!add, main=NULL,
                         do.plot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.layered_+3A_x">x</code></td>
<td>

<p>An object of class <code>"layered"</code>
created by the function <code><a href="#topic+layered">layered</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.layered_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to the <code>plot</code> method
for <em>every</em> layer.
</p>
</td></tr>
<tr><td><code id="plot.layered_+3A_which">which</code></td>
<td>

<p>Subset index specifying which layers should be plotted. 
</p>
</td></tr>
<tr><td><code id="plot.layered_+3A_plotargs">plotargs</code></td>
<td>

<p>Arguments to be passed to the  <code>plot</code> methods
for individual layers. A list of lists of arguments of the
form <code>name=value</code>.
</p>
</td></tr>
<tr><td><code id="plot.layered_+3A_add">add</code></td>
<td>
<p>Logical value indicating whether to add the graphics
to an existing plot.
</p>
</td></tr>
<tr><td><code id="plot.layered_+3A_show.all">show.all</code></td>
<td>

<p>Logical value indicating whether the <em>first</em> layer should be
displayed in full (including the main title, bounding window,
coordinate axes, colour ribbon, and so on). 
</p>
</td></tr>
<tr><td><code id="plot.layered_+3A_main">main</code></td>
<td>
<p>Main title for the plot</p>
</td></tr>
<tr><td><code id="plot.layered_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value indicating whether to actually do the plotting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Layering is a simple mechanism for controlling
a high-level plot that is composed of
several successive plots, for example, a background and a foreground
plot. The layering mechanism makes it easier to plot,
to switch on or off the plotting of each individual layer,
to control the plotting arguments that are passed to each layer,
and to zoom in on a subregion.
</p>
<p>The layers of data to be plotted should first be converted
into a single object of class <code>"layered"</code> using the
function <code><a href="#topic+layered">layered</a></code>. Then the layers can be plotted using
the method <code>plot.layered</code>.
</p>
<p>To zoom in on a subregion,
apply the subset operator <code><a href="#topic++5B.layered">[.layered</a></code> to <code>x</code>
before plotting.
</p>
<p>Graphics parameters for each layer are determined by (in order of precedence)
<code>...</code>, <code>plotargs</code>, and <code><a href="#topic+layerplotargs">layerplotargs</a>(x)</code>.
</p>
<p>The graphics parameters may also include the special argument
<code>.plot</code> specifying (the name of) a function which will be used to
perform the plotting instead of the generic <code>plot</code>.
</p>
<p>The argument <code>show.all</code> is recognised by many plot methods
in <span class="pkg">spatstat</span>. It determines whether a plot is drawn
with all its additional components such as the main title, bounding window,
coordinate axes, colour ribbons and legends. The default is
<code>TRUE</code> for new plots and <code>FALSE</code> for added plots.
</p>
<p>In <code>plot.layered</code>, the argument <code>show.all</code> applies only to the
<b>first</b> layer. The subsequent layers are plotted
with <code>show.all=FALSE</code>. 
</p>
<p>To override this, that is, if you really want to draw all
the components of <b>all</b> layers of <code>x</code>,
insert the argument <code>show.all=TRUE</code> in each
entry of <code>plotargs</code> or <code><a href="#topic+layerplotargs">layerplotargs</a>(x)</code>.
</p>


<h3>Value</h3>

<p>(Invisibly) a list containing the return values from
the plot commands for each layer. This list has
an attribute <code>"bbox"</code> giving a bounding box for the entire plot.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layered">layered</a></code>,
<code><a href="#topic+layerplotargs">layerplotargs</a></code>,
<code><a href="#topic++5B.layered">[.layered</a></code>,
<code><a href="graphics.html#topic+plot">plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   D &lt;- distmap(cells)
   L &lt;- layered(D, cells)
   plot(L)
   plot(L, which = 2)
   plot(L, plotargs=list(list(ribbon=FALSE), list(pch=3, cols="white")))
   # plot a subregion
   plot(L[, square(0.5)])
</code></pre>

<hr>
<h2 id='plot.listof'>Plot a List of Things</h2><span id='topic+plot.listof'></span>

<h3>Description</h3>

<p>Plots a list of things
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'listof'
plot(x, ..., main, arrange=TRUE,
   nrows=NULL, ncols=NULL, main.panel=NULL,
   mar.panel=c(2,1,1,2), hsep=0, vsep=0,
   panel.begin=NULL, panel.end=NULL, panel.args=NULL,
   panel.begin.args=NULL, panel.end.args=NULL, panel.vpad=0.2, 
   plotcommand="plot",
   adorn.left=NULL, adorn.right=NULL, adorn.top=NULL, adorn.bottom=NULL,
   adorn.size=0.2, equal.scales=FALSE, halign=FALSE, valign=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.listof_+3A_x">x</code></td>
<td>

<p>An object of the class <code>"listof"</code>.
Essentially a list of objects.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code> when generating each
plot panel.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_main">main</code></td>
<td>

<p>Overall heading for the plot.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_arrange">arrange</code></td>
<td>

<p>Logical flag indicating whether to plot the objects
side-by-side on a single page (<code>arrange=TRUE</code>)
or plot them individually in a succession of frames
(<code>arrange=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_nrows">nrows</code>, <code id="plot.listof_+3A_ncols">ncols</code></td>
<td>

<p>Optional. The number of rows/columns in the plot layout
(assuming <code>arrange=TRUE</code>).
You can specify either or both of these numbers.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_main.panel">main.panel</code></td>
<td>

<p>Optional. A character string, or a vector of character strings,
giving the headings for each of the objects.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_mar.panel">mar.panel</code></td>
<td>

<p>Size of the margins outside each plot panel.
A numeric vector of length 4 giving the bottom, left, top,
and right margins in that order. (Alternatively the vector
may have length 1 or 2 and will be replicated to length 4).
See the section on <em>Spacing between plots</em>.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_hsep">hsep</code>, <code id="plot.listof_+3A_vsep">vsep</code></td>
<td>

<p>Additional horizontal and vertical separation between plot panels,
expressed in the same units as <code>mar.panel</code>. 
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_panel.begin">panel.begin</code>, <code id="plot.listof_+3A_panel.end">panel.end</code></td>
<td>

<p>Optional. Functions that will be executed before and after each panel is
plotted. See Details.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_panel.args">panel.args</code></td>
<td>

<p>Optional. Function that determines different plot arguments
for different panels. See Details.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_panel.begin.args">panel.begin.args</code></td>
<td>

<p>Optional. List of additional arguments for <code>panel.begin</code>
when it is a function.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_panel.end.args">panel.end.args</code></td>
<td>

<p>Optional. List of additional arguments for <code>panel.end</code>
when it is a function.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_panel.vpad">panel.vpad</code></td>
<td>

<p>Amount of extra vertical space that should be allowed for the
title of each panel, if a title will be displayed.
Expressed as a fraction of the height of the panel.
Applies only when <code>equal.scales=FALSE</code> (the default) and
requires that the height of each panel can be determined.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_plotcommand">plotcommand</code></td>
<td>

<p>Optional.
Character string containing the name of the command that should be
executed to plot each panel. 
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_adorn.left">adorn.left</code>, <code id="plot.listof_+3A_adorn.right">adorn.right</code>, <code id="plot.listof_+3A_adorn.top">adorn.top</code>, <code id="plot.listof_+3A_adorn.bottom">adorn.bottom</code></td>
<td>

<p>Optional. Functions (with no arguments) that will be executed to
generate additional plots at the margins (left, right, top and/or
bottom, respectively) of the array of plots.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_adorn.size">adorn.size</code></td>
<td>

<p>Relative width (as a fraction of the other panels' widths)
of the margin plots.
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_equal.scales">equal.scales</code></td>
<td>

<p>Logical value indicating whether the components
should be plotted at (approximately) the same physical scale. 
</p>
</td></tr>
<tr><td><code id="plot.listof_+3A_halign">halign</code>, <code id="plot.listof_+3A_valign">valign</code></td>
<td>

<p>Logical values indicating whether panels in a column
should be aligned to the same <code class="reqn">x</code> coordinate system
(<code>halign=TRUE</code>) and whether panels in a row should
be aligned to the same <code class="reqn">y</code> coordinate system (<code>valign=TRUE</code>).
These are applicable only if <code>equal.scales=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"listof"</code>.
</p>
<p>An object of class <code>"listof"</code> (defined in the base R package) represents
a list of objects, all belonging to a common class.
The base R package defines a method for printing these objects,
<code><a href="base.html#topic+print.listof">print.listof</a></code>,
but does not define a method for <code>plot</code>.
So here we have provided a method for <code>plot</code>.
</p>
<p>In the <span class="pkg">spatstat</span> package, various functions produce
an object of class <code>"listof"</code>, essentially a list of
spatial objects of the same kind. 
These objects can be plotted in a nice arrangement
using <code>plot.listof</code>. See the Examples.
</p>
<p>The argument <code>panel.args</code> determines extra graphics parameters
for each panel. It should be a function that will be called
as <code>panel.args(i)</code> where <code>i</code> is the panel number.
Its return value should be a list of graphics parameters that can
be passed to the relevant <code>plot</code> method. These parameters
override any parameters specified in the <code>...</code> arguments.
</p>
<p>The arguments <code>panel.begin</code> and <code>panel.end</code>
determine graphics that will be plotted before and after
each panel is plotted. They may be objects
of some class that can be plotted
with the generic <code>plot</code> command. Alternatively they
may be functions that will be
called as <code>panel.begin(i, y, main=main.panel[i])</code>
and <code>panel.end(i, y, add=TRUE)</code> where <code>i</code> is the panel
number and <code>y = x[[i]]</code>.
</p>
<p>If all entries of <code>x</code> are pixel images,
the function <code><a href="#topic+image.listof">image.listof</a></code> is called to control
the plotting. The arguments <code>equal.ribbon</code> and <code>col</code>
can be used to determine the colour map or maps applied.
</p>
<p>If <code>equal.scales=FALSE</code> (the default), then the 
plot panels will have equal height on the plot device
(unless there is only one column of panels, in which case
they will have equal width on the plot device). This means that the
objects are plotted at different physical scales, by default.
</p>
<p>If <code>equal.scales=TRUE</code>, then the dimensions of the
plot panels on the plot device will be proportional
to the spatial dimensions of the
corresponding components of <code>x</code>. This means that the
objects will be plotted at <em>approximately</em> equal physical scales.
If these objects have very different spatial sizes,
the plot command could fail (when it tries
to plot the smaller objects at a tiny scale), with an error
message that the figure margins are too large.
</p>
<p>The objects will be plotted at <em>exactly</em> equal
physical scales, and <em>exactly</em> aligned on the device,
under the following conditions:
</p>

<ul>
<li>
<p>every component of <code>x</code> is a spatial object
whose position can be shifted by <code><a href="#topic+shift">shift</a></code>;
</p>
</li>
<li>
<p><code>panel.begin</code> and <code>panel.end</code> are either
<code>NULL</code> or they are spatial objects 
whose position can be shifted by <code><a href="#topic+shift">shift</a></code>;
</p>
</li>
<li>
<p><code>adorn.left</code>, 
<code>adorn.right</code>, 
<code>adorn.top</code> and 
<code>adorn.bottom</code> are all <code>NULL</code>.
</p>
</li></ul>

<p>Another special case is when every component of <code>x</code> is an
object of class <code>"fv"</code> representing a function.
If <code>equal.scales=TRUE</code> then all these functions will 
be plotted with the same axis scales
(i.e. with the same <code>xlim</code> and the same <code>ylim</code>).
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Spacing between plots</h3>

<p>The spacing between individual plots is controlled by the parameters
<code>mar.panel</code>, <code>hsep</code> and <code>vsep</code>.
</p>
<p>If <code>equal.scales=FALSE</code>, the plot panels are
logically separate plots. The margins for each panel are
determined by the argument <code>mar.panel</code> which becomes 
the graphics parameter <code>mar</code>
described in the help file for <code><a href="graphics.html#topic+par">par</a></code>.
One unit of <code>mar</code> corresponds to one line of text in the margin.
If <code>hsep</code> or <code>vsep</code> are present, <code>mar.panel</code>
is augmented by <code>c(vsep, hsep, vsep, hsep)/2</code>.
</p>
<p>If <code>equal.scales=TRUE</code>, all the plot panels are drawn
in the same coordinate system which represents a physical scale.
The unit of measurement for <code>mar.panel[1,3]</code>
is one-sixth of the greatest height of any object plotted in the same row
of panels, and the unit for <code>mar.panel[2,4]</code> is one-sixth of the
greatest width of any object plotted in the same column of panels.
If <code>hsep</code> or <code>vsep</code> are present,
they are interpreted in the same units as <code>mar.panel[2]</code>
and <code>mar.panel[1]</code> respectively.
</p>


<h3>Error messages</h3>

<p>If the error message &lsquo;Figure margins too large&rsquo;
occurs, this generally means that one of the
objects had a much smaller physical scale than the others.
Ensure that <code>equal.scales=FALSE</code>
and increase the values of <code>mar.panel</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print.listof">print.listof</a></code>,
<code><a href="#topic+contour.listof">contour.listof</a></code>,
<code><a href="#topic+image.listof">image.listof</a></code>,
<code><a href="spatstat.explore.html#topic+density.splitppp">density.splitppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> D &lt;- solapply(split(mucosa), distfun)

 plot(D)
 plot(D, main="", equal.ribbon=TRUE,
      panel.end=function(i,y,...){contour(y, ..., drawlabels=FALSE)})

# list of 3D point patterns
 ape1 &lt;- osteo[osteo$shortid==4, "pts", drop=TRUE]
 class(ape1)
 plot(ape1, main.panel="", mar.panel=0.1, hsep=0.7, vsep=1,
      cex=1.5, pch=21, bg='white')
</code></pre>

<hr>
<h2 id='plot.onearrow'>Plot an Arrow</h2><span id='topic+plot.onearrow'></span>

<h3>Description</h3>

<p>Plots an object of class <code>"onearrow"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'onearrow'
plot(x, ...,
  add = FALSE, main = "",
  retract = 0.05, headfraction = 0.25, headangle = 12, headnick = 0.1,
  col.head = NA, lwd.head = lwd, lwd = 1, col = 1,
  zap = FALSE, zapfraction = 0.07,
  pch = 1, cex = 1, do.plot = TRUE, do.points = FALSE, show.all = !add)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.onearrow_+3A_x">x</code></td>
<td>

<p>Object of class <code>"onearrow"</code> to be plotted.
This object is created by the command <code><a href="#topic+onearrow">onearrow</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_...">...</code></td>
<td>

<p>Additional graphics arguments passed to
<code><a href="graphics.html#topic+segments">segments</a></code> to control the appearance of the line.
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_add">add</code></td>
<td>
<p>Logical value indicating whether to add graphics to the
existing plot (<code>add=TRUE</code>) or to start a new plot
(<code>add=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_main">main</code></td>
<td>
<p>Main title for the plot.</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_retract">retract</code></td>
<td>

<p>Fraction of length of arrow to remove at each end.
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_headfraction">headfraction</code></td>
<td>

<p>Length of arrow head as a fraction of overall length of arrow.
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_headangle">headangle</code></td>
<td>

<p>Angle (in degrees) between the outer edge of the arrow head
and the shaft of the arrow.
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_headnick">headnick</code></td>
<td>

<p>Size of the nick in the trailing edge of the arrow head
as a fraction of length of arrow head. 
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_col.head">col.head</code>, <code id="plot.onearrow_+3A_lwd.head">lwd.head</code></td>
<td>

<p>Colour and line style of the filled arrow head.
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_col">col</code>, <code id="plot.onearrow_+3A_lwd">lwd</code></td>
<td>

<p>Colour and line style of the arrow shaft.
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_zap">zap</code></td>
<td>

<p>Logical value indicating whether the arrow should
include a Z-shaped (lightning-bolt) feature in the
middle of the shaft.
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_zapfraction">zapfraction</code></td>
<td>

<p>Size of Z-shaped deviation as a fraction of total arrow length.
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_pch">pch</code>, <code id="plot.onearrow_+3A_cex">cex</code></td>
<td>

<p>Plot character and character size for the two end points of the arrow,
if <code>do.points=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical. Whether to actually perform the plot.
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_do.points">do.points</code></td>
<td>

<p>Logical. Whether to display the two end points of the arrow as well.
</p>
</td></tr>
<tr><td><code id="plot.onearrow_+3A_show.all">show.all</code></td>
<td>

<p>Internal use only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> should be an object of class <code>"onearrow"</code>
created by the command <code><a href="#topic+onearrow">onearrow</a></code>. 
</p>


<h3>Value</h3>

<p>A window (class <code>"owin"</code>) enclosing the plotted graphics.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+onearrow">onearrow</a></code>,
<code><a href="#topic+yardstick">yardstick</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  oa &lt;- onearrow(cells[c(1, 42)])
  oa
  plot(oa)
  plot(oa, zap=TRUE, do.points=TRUE, col.head="pink", col="red")
</code></pre>

<hr>
<h2 id='plot.owin'>Plot a Spatial Window</h2><span id='topic+plot.owin'></span>

<h3>Description</h3>

<p>Plot a two-dimensional window of observation for a spatial point pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'owin'
plot(x, main, add=FALSE, ..., box, edge=0.04,
                      type=c("w","n"), show.all=!add, 
                      hatch=FALSE,
                      hatchargs=list(), 
                      invert=FALSE, do.plot=TRUE,
                      claim.title.space=FALSE, use.polypath=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.owin_+3A_x">x</code></td>
<td>

<p>The window to be plotted.
An object of class <code><a href="#topic+owin">owin</a></code>,
or data which can be converted into 
this format by <code><a href="#topic+as.owin">as.owin</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_main">main</code></td>
<td>

<p>text to be displayed as a title above the plot.
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_add">add</code></td>
<td>

<p>logical flag: if <code>TRUE</code>, draw the window in 
the current plot; if <code>FALSE</code>, generate a new plot.
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_...">...</code></td>
<td>

<p>extra arguments controlling the appearance of the plot.
These arguments are passed to <code><a href="graphics.html#topic+polygon">polygon</a></code>
if <code>x</code> is a
polygonal or rectangular window, or passed to
<code><a href="graphics.html#topic+image.default">image.default</a></code>
if <code>x</code> is a binary mask.
Some arguments are passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
See Details.
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_box">box</code></td>
<td>

<p>logical flag; if <code>TRUE</code>, plot the enclosing rectangular box
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_edge">edge</code></td>
<td>

<p>nonnegative number; the plotting region will have coordinate limits
that are <code>1 + edge</code>
times as large as the limits of the rectangular box
that encloses the pattern.
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_type">type</code></td>
<td>

<p>Type of plot: either <code>"w"</code> or <code>"n"</code>.
If <code>type="w"</code> (the default), the window is plotted.
If <code>type="n"</code> and <code>add=TRUE</code>, a new plot is initialised
and the coordinate system is established, but nothing is drawn.
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_show.all">show.all</code></td>
<td>

<p>Logical value indicating whether to plot everything
including the main title.
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_hatch">hatch</code></td>
<td>

<p>logical flag; if <code>TRUE</code>, the interior of the window will
be shaded by texture, such as a grid of parallel lines.
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_hatchargs">hatchargs</code></td>
<td>

<p>List of arguments passed to <code><a href="#topic+add.texture">add.texture</a></code>
to control the texture shading when <code>hatch=TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_invert">invert</code></td>
<td>

<p>logical flag; when the window is a binary pixel mask,
the mask colours will be inverted if <code>invert=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value indicating whether to actually perform the plot.
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_claim.title.space">claim.title.space</code></td>
<td>

<p>Logical value indicating whether extra space for the main title
should be allocated when declaring the plot dimensions.
Should be set to <code>FALSE</code> under normal conditions.
</p>
</td></tr>
<tr><td><code id="plot.owin_+3A_use.polypath">use.polypath</code></td>
<td>

<p>Logical value indicating what graphics capabilities should be used
to draw a polygon filled with colour when the polygon has holes.
If <code>TRUE</code> (the default), then the polygon will be filled using
<code><a href="graphics.html#topic+polypath">polypath</a></code>, provided the graphics device
supports this function. If <code>FALSE</code>, the polygon will be
decomposed into simple closed polygons, which will be colour filled
using <code><a href="graphics.html#topic+polygon">polygon</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code><a href="#topic+owin">owin</a></code>.
The action is to plot the boundary of the window on the current plot device,
using equal scales on the <code>x</code> and <code>y</code> axes.
</p>
<p>If the window <code>x</code> is of type <code>"rectangle"</code> or <code>"polygonal"</code>,
the boundary of the window is plotted as a polygon or series of polygons.
If <code>x</code> is of type <code>"mask"</code> 
the discrete raster approximation of the window is displayed
as a binary image (white inside the window, black outside).
</p>
<p>Graphical parameters controlling the display (e.g. setting the
colours) may be passed directly via the <code>...</code> arguments,
or indirectly reset using 
<code><a href="#topic+spatstat.options">spatstat.options</a></code>.
</p>
<p>If <code>add=FALSE</code> (the default), the plot is initialised
by calling the base graphics function
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>
to create the plot area. By default, coordinate axes
and axis labels are not plotted. To plot coordinate axes,
use the argument <code>axes=TRUE</code>; 
to plot axis labels, use the argument <code>ann=TRUE</code>
and then specify the labels with <code>xlab</code> and <code>ylab</code>;
see the help file for <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for
information on these arguments, and for additional
arguments controlling the appearance of the axes.
See the Examples also.
</p>
<p>When <code>x</code> is of type <code>"rectangle"</code> or <code>"polygonal"</code>, it
is plotted by the <span class="rlang"><b>R</b></span> function <code><a href="graphics.html#topic+polygon">polygon</a></code>. To control the
appearance (colour, fill density, line density etc) of the polygon
plot, determine the required argument of <code><a href="graphics.html#topic+polygon">polygon</a></code> and
pass it through <code>...</code> For example, to paint the interior of the
polygon in red, use the argument <code>col="red"</code>. To draw the polygon
edges in green, use <code>border="green"</code>. To suppress the drawing of
polygon edges, use <code>border=NA</code>.
</p>
<p>When <code>x</code> is of type <code>"mask"</code>, it is plotted by
<code><a href="graphics.html#topic+image.default">image.default</a></code>. The appearance of the image plot
can be controlled by passing arguments to
<code><a href="graphics.html#topic+image.default">image.default</a></code>
through <code>...</code>. The default appearance can also be changed
by setting the parameter <code>par.binary</code> of
<code><a href="#topic+spatstat.options">spatstat.options</a></code>. 
</p>
<p>To zoom in (to view only a subset of the window at higher
magnification), use the graphical arguments
<code>xlim</code> and <code>ylim</code> to specify the desired rectangular field of
view. (The actual field of view may be larger, depending on the
graphics device).
</p>


<h3>Value</h3>

<p>none.
</p>


<h3>Notes on Filled Polygons with Holes</h3>

<p>The function <code><a href="graphics.html#topic+polygon">polygon</a></code> can only handle
polygons without holes. To plot polygons with holes in a solid colour,
we have implemented two workarounds.
</p>

<dl>
<dt>polypath function:</dt><dd>
<p>The first workaround uses
the relatively new function <code><a href="graphics.html#topic+polypath">polypath</a></code> which
<em>does</em> have the capability to handle polygons with holes.
However, not all graphics devices support
<code><a href="graphics.html#topic+polypath">polypath</a></code>.
The older devices <code><a href="grDevices.html#topic+xfig">xfig</a></code> and <code><a href="grDevices.html#topic+pictex">pictex</a></code>
do not support <code><a href="graphics.html#topic+polypath">polypath</a></code>.
On a Windows system, the default graphics device
<code>windows</code>
supports <code><a href="graphics.html#topic+polypath">polypath</a></code>.
On a Linux system, the default graphics device
<code>X11(type="Xlib")</code> does <em>not</em> support
<code><a href="graphics.html#topic+polypath">polypath</a></code>
but <code>X11(type="cairo")</code> does support it.
See <code><a href="grDevices.html#topic+X11">X11</a></code> and the section on Cairo below.
</p>
</dd>
<dt>polygon decomposition:</dt><dd>
<p>The other workaround involves decomposing the polygonal window
into pieces which do not have holes. This code is experimental
but works in all our test cases. If this code fails, a warning
will be issued, and the filled colours will not be plotted.
</p>
</dd>
</dl>



<h3>Cairo graphics on a Linux system</h3>

<p>Linux systems support
the graphics device <code>X11(type="cairo")</code> (see <code><a href="grDevices.html#topic+X11">X11</a></code>)
provided the external library <span class="pkg">cairo</span> is installed
on the computer. See <code>www.cairographics.org</code>
for instructions on obtaining and installing <span class="pkg">cairo</span>.  After having
installed <span class="pkg">cairo</span> one needs to re-install <span class="rlang"><b>R</b></span> from source so
that it has <span class="pkg">cairo</span> capabilites.  To check whether your
current installation of R has <span class="pkg">cairo</span> capabilities, type
(in <span class="rlang"><b>R</b></span>) <code>capabilities()["cairo"]</code>.
The default type for <code><a href="grDevices.html#topic+X11">X11</a></code> is controlled by
<code><a href="grDevices.html#topic+X11.options">X11.options</a></code>.
You may find it convenient to
make <span class="pkg">cairo</span> the default, e.g. via your <code>.Rprofile</code>.
The magic incantation to put into <code>.Rprofile</code> is
</p>
<pre>
    setHook(packageEvent("graphics", "onLoad"),
    function(...) grDevices::X11.options(type="cairo"))
  </pre>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+plot.ppp">plot.ppp</a></code>,
<code><a href="graphics.html#topic+polygon">polygon</a></code>,
<code><a href="graphics.html#topic+image.default">image.default</a></code>,
<code><a href="#topic+spatstat.options">spatstat.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # rectangular window
   plot(Window(nztrees))
   abline(v=148, lty=2)

  # polygonal window
  w &lt;- Window(demopat)
  plot(w)
  plot(w, col="red", border="green", lwd=2)
  plot(w, hatch=TRUE, lwd=2)

  # binary mask
  we &lt;- as.mask(w)
  plot(we)
  op &lt;- spatstat.options(par.binary=list(col=grey(c(0.5,1))))
  plot(we)
  spatstat.options(op)

  ## axis annotation
  plot(letterR, axes=TRUE, ann=TRUE, xlab="Easting", ylab="Northing")
  plot(letterR,            ann=TRUE, xlab="Declination", ylab="Right Ascension")
</code></pre>

<hr>
<h2 id='plot.pp3'>
Plot a Three-Dimensional Point Pattern
</h2><span id='topic+plot.pp3'></span>

<h3>Description</h3>

<p>Plots a three-dimensional point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'pp3'
plot(x, ..., eye=NULL, org=NULL, theta=25, phi=15,
                    type=c("p", "n", "h"),
                    box.back=list(col="pink"),
                    box.front=list(col="blue", lwd=2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pp3_+3A_x">x</code></td>
<td>

<p>Three-dimensional point pattern (object of class <code>"pp3"</code>).
</p>
</td></tr>
<tr><td><code id="plot.pp3_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+points">points</a></code>
controlling the appearance of the points.
</p>
</td></tr>
<tr><td><code id="plot.pp3_+3A_eye">eye</code></td>
<td>

<p>Optional. Eye position. A numeric vector of length 3 giving the
location from which the scene is viewed.
</p>
</td></tr>
<tr><td><code id="plot.pp3_+3A_org">org</code></td>
<td>

<p>Optional. Origin (centre) of the view. A numeric vector of length
3 which will be at the centre of the view.
</p>
</td></tr>
<tr><td><code id="plot.pp3_+3A_theta">theta</code>, <code id="plot.pp3_+3A_phi">phi</code></td>
<td>

<p>Optional angular coordinates (in degrees) specifying the direction
from which the scene is viewed: <code>theta</code> is the azimuth
and <code>phi</code> is the colatitude. Ignored if <code>eye</code> is given.
</p>
</td></tr>
<tr><td><code id="plot.pp3_+3A_type">type</code></td>
<td>

<p>Type of plot: <code>type="p"</code> for points,
<code>type="h"</code> for points on vertical lines,
<code>type="n"</code> for box only.
</p>
</td></tr>
<tr><td><code id="plot.pp3_+3A_box.front">box.front</code>, <code id="plot.pp3_+3A_box.back">box.back</code></td>
<td>

<p>How to plot the three-dimensional box that contains the points.
A list of graphical arguments passed to <code><a href="graphics.html#topic+segments">segments</a></code>,
or a logical value indicating whether or not to plot
the relevant part of the box. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the plot method for objects of class <code>"pp3"</code>.
It generates a two-dimensional plot of the point pattern <code>x</code>
and its containing box as if they had been viewed from the
location specified by <code>eye</code> (or from the direction
specified by <code>theta</code> and <code>phi</code>). 
</p>
<p>The edges of the box at the &lsquo;back&rsquo; of the scene (as viewed from the
eye position) are plotted first. Then the points are added. Finally the
remaining &lsquo;front&rsquo; edges are plotted. The arguments
<code>box.back</code> and <code>box.front</code> specify graphical parameters for
drawing the back and front edges, respectively. Alternatively
<code>box.back=FALSE</code> specifies that the back edges shall not be drawn.
</p>
<p>Note that default values of arguments to <code>plot.pp3</code>
can be set by <code><a href="#topic+spatstat.options">spatstat.options</a>("par.pp3")</code>.
</p>


<h3>Value</h3>

<p>Null.</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp3">pp3</a></code>,
<code><a href="#topic+spatstat.options">spatstat.options</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- osteo$pts[[1]]
  plot(X, main="Osteocyte lacunae, animal 1, brick 1",
       cex=1.5, pch=16)
  plot(X, type="h", main="", box.back=list(lty=3))
</code></pre>

<hr>
<h2 id='plot.ppp'>plot a Spatial Point Pattern</h2><span id='topic+plot.ppp'></span>

<h3>Description</h3>

<p>Plot a two-dimensional spatial point pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppp'
plot(x, main, ..., clipwin=NULL,
                    chars=NULL, cols=NULL,
                    use.marks=TRUE, which.marks=NULL,
                    add=FALSE, type=c("p","n"),
                    legend=TRUE,
                    leg.side=c("left", "bottom", "top", "right"),
                    leg.args=list(),
                    symap=NULL, maxsize=NULL, meansize=NULL, markscale=NULL,
                    minsize=NULL, zerosize=NULL,
                    zap=0.01,
                    show.window=show.all, show.all=!add, do.plot=TRUE,
                    multiplot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ppp_+3A_x">x</code></td>
<td>

<p>The spatial point pattern to be plotted.
An object of class <code>"ppp"</code>,
or data which can be converted into 
this format by <code><a href="#topic+as.ppp">as.ppp</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_main">main</code></td>
<td>

<p>text to be displayed as a title above the plot.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_...">...</code></td>
<td>

<p>extra arguments that will be passed to the plotting functions
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+points">points</a></code> and/or
<code><a href="graphics.html#topic+symbols">symbols</a></code>. Not all arguments will be recognised.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_clipwin">clipwin</code></td>
<td>

<p>Optional. A window (object of class <code>"owin"</code>).
Only this subset of the image will be displayed.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_chars">chars</code></td>
<td>

<p>the plotting character(s) used to plot points.
Either a single character, an integer,
or a vector of single characters or integers.
Ignored if <code>symap</code> is given.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_cols">cols</code></td>
<td>

<p>the colour(s) used to plot points.
Either an integer index from 1 to 8 (indexing the standard colour
palette), a character string giving the name of a colour,
or a string giving the hexadecimal representation of a colour,
or a vector of such integers or strings.
See the section on <em>Colour Specification</em> in the help for <code><a href="graphics.html#topic+par">par</a></code>.
Ignored if <code>symap</code> is given.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_use.marks">use.marks</code></td>
<td>

<p>logical flag; if <code>TRUE</code>, plot points using a different
plotting symbol for each mark;
if <code>FALSE</code>, only the locations of the points will be plotted,
using <code><a href="graphics.html#topic+points">points</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_which.marks">which.marks</code></td>
<td>

<p>Index determining which column of marks to use,
if the marks of <code>x</code> are a data frame.
A character or integer vector identifying one or more
columns of marks. 
If <code>add=FALSE</code> then
the default is to plot all columns of marks, in a series of separate
plots.
If <code>add=TRUE</code> then only one column of marks can be plotted,
and the default is <code>which.marks=1</code>
indicating the first column of marks.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_add">add</code></td>
<td>

<p>logical flag; if <code>TRUE</code>,
just the points are plotted, over the existing plot.
A new plot is not created, and
the window is not plotted.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_type">type</code></td>
<td>

<p>Type of plot: either <code>"p"</code> or <code>"n"</code>.
If <code>type="p"</code> (the default), both the points and the observation window
are plotted. If <code>type="n"</code>, only the window is plotted.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_legend">legend</code></td>
<td>

<p>Logical value indicating whether to add a legend showing the mapping
between mark values and graphical symbols (for a marked point pattern).
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_leg.side">leg.side</code></td>
<td>

<p>Position of legend relative to main plot.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_leg.args">leg.args</code></td>
<td>

<p>List of additional arguments passed to <code><a href="#topic+plot.symbolmap">plot.symbolmap</a></code>
or <code><a href="#topic+symbolmap">symbolmap</a></code> to control the legend.
In addition to arguments documented under
<code><a href="#topic+plot.symbolmap">plot.symbolmap</a></code>, and graphical arguments recognised
by <code><a href="#topic+symbolmap">symbolmap</a></code>, the list may also include the argument
<code>sep</code> giving the separation between the main plot and the
legend, or <code>sep.frac</code> giving the separation as a fraction
of the relevant dimension (width or height) of the main plot.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_symap">symap</code></td>
<td>

<p>The graphical symbol map to be applied to the marks.
An object of class <code>"symbolmap"</code>; see
<code><a href="#topic+symbolmap">symbolmap</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_maxsize">maxsize</code></td>
<td>

<p><em>Maximum</em> physical size of the circles/squares plotted
when <code>x</code> is a marked point pattern with 
numerical marks.
Incompatible with <code>meansize</code> and <code>markscale</code>.
Ignored if <code>symap</code> is given.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_meansize">meansize</code></td>
<td>

<p><em>Average</em> physical size of the circles/squares plotted
when <code>x</code> is a marked point pattern with 
numerical marks.
Incompatible with <code>maxsize</code> and <code>markscale</code>.
Ignored if <code>symap</code> is given.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_markscale">markscale</code></td>
<td>

<p>physical scale factor determining the sizes of the
circles/squares plotted when <code>x</code> is a marked point pattern with 
numerical marks. Mark value will be multiplied by <code>markscale</code>
to determine physical size.
Incompatible with <code>maxsize</code> and <code>meansize</code>.
Ignored if <code>symap</code> is given.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_minsize">minsize</code></td>
<td>

<p><em>Minimum</em> physical size of the circles/squares plotted
when <code>x</code> is a marked point pattern with 
numerical marks.
Incompatible with <code>zerosize</code>.
Ignored if <code>symap</code> is given.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_zerosize">zerosize</code></td>
<td>

<p>Physical size of the circle/square representing a mark value of zero,
when <code>x</code> is a marked point pattern with numerical marks.
Incompatible with <code>minsize</code>.
Defaults to zero.
Ignored if <code>symap</code> is given.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_zap">zap</code></td>
<td>

<p>Fraction between 0 and 1.
When <code>x</code> is a marked point pattern with numerical marks,
<code>zap</code> is the smallest mark value
(expressed as a fraction of the maximum possible mark) that will
be plotted. 
Any points which have marks smaller in absolute value
than <code>zap * max(abs(marks(x)))</code> will not be plotted.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_show.window">show.window</code></td>
<td>

<p>Logical value indicating whether to plot the observation
window of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_show.all">show.all</code></td>
<td>

<p>Logical value indicating whether to plot everything
including the main title and the observation window of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value determining whether to actually perform the plotting.
</p>
</td></tr>
<tr><td><code id="plot.ppp_+3A_multiplot">multiplot</code></td>
<td>

<p>Logical value giving permission to display multiple plots.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for 
point pattern datasets (of class <code>"ppp"</code>, see <code><a href="#topic+ppp.object">ppp.object</a></code>).
</p>
<p>First the observation window <code>Window(x)</code> is plotted
(if <code>show.window=TRUE</code>).
Then the points themselves are plotted,
in a fashion that depends on their marks,
as follows.
</p>

<dl>
<dt>unmarked point pattern:</dt><dd>
<p>If the point pattern does not have marks, or if <code>use.marks = FALSE</code>,
then the locations of all points will be plotted 
using a single plot character
</p>
</dd>
<dt>multitype point pattern:</dt><dd>
<p>If <code>x$marks</code> is a factor, then 
each level of the factor is 
represented by a different plot character.
</p>
</dd>
<dt>continuous marks:</dt><dd>
<p>If <code>x$marks</code> is a numeric vector,
the marks are rescaled to the unit interval and
each point is represented by a circle 
with <em>diameter</em> proportional to the rescaled mark
(if the value is positive) or a square with <em>side length</em>
proportional to the absolute value of the rescaled mark
(if the value is negative).
</p>
</dd>
<dt>other kinds of marks:</dt><dd>
<p>If <code>x$marks</code> is neither numeric nor a factor,
then each possible mark will be represented by a
different plotting character. The default is to
represent the <code class="reqn">i</code>th smallest mark value by
<code>points(..., pch=i)</code>.
</p>
</dd>
</dl>

<p>If there are several columns of marks, and if <code>which.marks</code> is
missing or <code>NULL</code>, then
</p>

<ul>
<li> 
<p>if <code>add=FALSE</code> and <code>multiplot=TRUE</code>
the default is to plot all columns of marks, in a series of separate
plots, placed side-by-side. The plotting is coordinated by
<code><a href="#topic+plot.listof">plot.listof</a></code>, which calls <code>plot.ppp</code> to make each of
the individual plots.
</p>
</li>
<li>
<p>Otherwise, only one column of marks can be plotted,
and the default is <code>which.marks=1</code>
indicating the first column of marks.
</p>
</li></ul>

<p>Plotting of the window <code>Window(x)</code> is performed by
<code><a href="#topic+plot.owin">plot.owin</a></code>. This plot may be modified 
through the <code>...</code> arguments. In particular the
extra argument <code>border</code> determines
the colour of the window, if the window is not a binary mask.
</p>
<p>Plotting of the points themselves is performed
by the function <code><a href="graphics.html#topic+points">points</a></code>, except for the case of
continuous marks, where it is performed by <code><a href="graphics.html#topic+symbols">symbols</a></code>.
Their plotting behaviour may be modified through the <code>...</code>
arguments.
</p>
<p>If the argument <code>symap</code> is given, then it determines the
graphical display of the points. It should be a symbol map
(object of class <code>"symbolmap"</code>) created by the function
<code><a href="#topic+symbolmap">symbolmap</a></code>.
</p>
<p>If <code>symap</code> is not given, then the
following arguments can be used to specify how the points are plotted:
</p>

<ul>
<li>
<p>The argument <code>chars</code> determines the plotting character
or characters used to display the points (in all cases except
for the case of continuous marks). For an unmarked point pattern,
this should be a single integer or character determining a
plotting character (see <code>par("pch")</code>).
For a multitype point pattern, <code>chars</code> should be a vector
of integers or characters, of the same length
as <code>levels(x$marks)</code>, and then the <code class="reqn">i</code>th level or type 
will be plotted using character <code>chars[i]</code>.
</p>
</li>
<li>
<p>If <code>chars</code> is absent, but there is an extra argument
<code>pch</code>, then this will determine the plotting character for
all points.
</p>
</li>
<li>
<p>The argument <code>cols</code> determines the colour or colours used to
display the points. For an unmarked point pattern,
<code>cols</code> should be a character string
determining a colour. For a multitype point pattern, <code>cols</code>
should be a character vector, of the same length
as <code>levels(marks(x))</code>: that is, there is one colour for each
possible mark value. The <code class="reqn">i</code>th level or type will
be plotted using colour <code>cols[i]</code>. For a point pattern with
continuous marks, <code>cols</code> can be either a character string
or a character vector specifying colour values: the range of mark
values will be mapped to the specified colours.
</p>
</li>
<li>
<p>If <code>cols</code> is absent, the colours used to plot the
points may be determined by the extra argument <code>fg</code>
(for multitype point patterns) or the extra argument <code>col</code>
(for all other cases). Note that specifying <code>col</code> will also
apply this colour to the window itself.
</p>
</li>
<li>
<p>The default colour for the points is a semi-transparent grey,
if this is supported by the plot device. This behaviour can be
suppressed (so that the default colour is non-transparent)
by setting <code>spatstat.options(transparent=FALSE)</code>.
</p>
</li>
<li> 
<p>The arguments <code>maxsize</code>, <code>meansize</code> and <code>markscale</code> 
are incompatible with each other (and incompatible with
<code>symap</code>).
The arguments <code>minsize</code> and <code>zerosize</code> are incompatible
with each other (and incompatible with <code>symap</code>).
Together, these arguments control the physical size of the circles and
squares which represent the marks in a point pattern with continuous
marks. The size of a circle is defined as its <em>diameter</em>;
the size of a square is its side length.
If <code>markscale</code> is given, then a mark value of <code>m</code>
is plotted as a circle of diameter <code>m * markscale + zerosize</code>
(if <code>m</code> is positive) or a square of side
<code>abs(m) * markscale + zerosize</code>
(if <code>m</code> is negative). If <code>maxsize</code> is given, then the
largest mark in absolute value, <code>mmax=max(abs(marks(x)))</code>,
will be scaled to have physical size <code>maxsize</code>.
If <code>meansize</code> is given, then the
average absolute mark value, <code>mmean=mean(abs(marks(x)))</code>,
will be scaled to have physical size <code>meansize</code>.
If <code>minsize</code> is given, then the
minimum mark value, <code>mmean=mean(abs(marks(x)))</code>,
will be scaled to have physical size <code>minsize</code>.
</p>
</li>
<li>
<p>The user can set the default values of these plotting parameters
using <code><a href="#topic+spatstat.options">spatstat.options</a>("par.points")</code>.
</p>
</li></ul>

<p>To zoom in (to view only a subset of the point pattern at higher
magnification), use the graphical arguments
<code>xlim</code> and <code>ylim</code> to specify the rectangular field of view.
</p>
<p>The value returned by this plot function is an object of
class <code>"symbolmap"</code> representing the mapping from mark values
to graphical symbols. See <code><a href="#topic+symbolmap">symbolmap</a></code>.
It can be used to make a suitable legend,
or to ensure that two plots use the same graphics map.
</p>


<h3>Value</h3>

<p>(Invisible) object of class <code>"symbolmap"</code>
giving the correspondence between 
mark values and plotting characters.
</p>


<h3>Removing White Space Around The Plot</h3>

<p>A frequently-asked question is: How do I remove the white space around
the plot? Currently <code>plot.ppp</code> uses the base graphics system of
<span class="rlang"><b>R</b></span>, so the space around the plot is controlled by parameters 
to <code><a href="graphics.html#topic+par">par</a></code>. To reduce the white space, change the
parameter <code>mar</code>. Typically, <code>par(mar=rep(0.5, 4))</code> is
adequate, if there are no annotations or titles outside the window.
</p>


<h3>Drawing coordinate axes and axis labels</h3>

<p>Coordinate axes and axis labels are not drawn, by default.
To draw coordinate axes, set <code>axes=TRUE</code>.
To draw axis labels, set <code>ann=TRUE</code> and give values to the
arguments <code>xlab</code> and <code>ylab</code>. See the Examples.
Only the default style of axis is supported;
for more control over the placement and style of axes,
use the graphics commands
<code><a href="graphics.html#topic+axis">axis</a></code> and <code><a href="graphics.html#topic+mtext">mtext</a></code>.
</p>


<h3>The Symbol Map</h3>

<p>The behaviour of <code>plot.ppp</code> is different from the
behaviour of the base <span class="rlang"><b>R</b></span> graphics functions
<code><a href="graphics.html#topic+points">points</a></code> and <code><a href="graphics.html#topic+symbols">symbols</a></code>.
</p>
<p>In the base graphics functions <code><a href="graphics.html#topic+points">points</a></code> and <code><a href="graphics.html#topic+symbols">symbols</a></code>,
arguments such as <code>col</code>, <code>pch</code> and <code>cex</code>
can be vectors which specify the <em>representation of each successive point</em>.
For example <code>col[3]</code> would specify the colour of the third point
in the sequence of points.  If there are 100 points then
<code>col</code> should be a vector of length 100.
</p>
<p>In the <span class="pkg">spatstat</span> function <code>plot.ppp</code>,
arguments such as <code>col</code>, <code>pch</code> and <code>cex</code> specify
the <em>mapping from point characteristics to graphical parameters</em>
(called the symbol map).
For example <code>col[3]</code> specifies the colour of the third <b>type of point</b> in a
pattern of points of different types. If there are 4 types of points
then <code>col</code> should be a vector of length 4.
</p>
<p>To modify a symbol map, for example to change the colours used
without changing anything else, use <code><a href="#topic+update.symbolmap">update.symbolmap</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="graphics.html#topic+points">points</a></code>,
<code><a href="#topic+text.ppp">text.ppp</a></code>,
<code><a href="#topic+plot.owin">plot.owin</a></code>,
<code><a href="graphics.html#topic+symbols">symbols</a></code>.
</p>
<p>See also the command <code>iplot</code> in the <span class="pkg">spatstat.gui</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(cells)

   plot(cells, pch=16)

   # make the plotting symbols larger (for publication at reduced scale)
   plot(cells, cex=2)

   # set it in spatstat.options
   oldopt &lt;- spatstat.options(par.points=list(cex=2))
   plot(cells)
   spatstat.options(oldopt)

   # multitype 
   plot(lansing)

   # marked by a real number
   plot(longleaf)

   # just plot the points
   plot(longleaf, use.marks=FALSE)
   plot(unmark(longleaf)) # equivalent

   # point pattern with multiple marks
   plot(finpines)
   plot(finpines, which.marks="height")

   # controlling COLOURS of points
   plot(cells, cols="blue")
   plot(lansing, cols=c("black", "yellow", "green", 
                        "blue","red","pink"))
   plot(longleaf, fg="blue")

   # make window purple
   plot(lansing, border="purple")
   # make everything purple
   plot(lansing, border="purple", cols="purple", col.main="purple",
                 leg.args=list(col.axis="purple"))
 
   # controlling PLOT CHARACTERS for multitype pattern
   plot(lansing, chars = 11:16)
   plot(lansing, chars = c("o","h","m",".","o","o"))

   ## multitype pattern mapped to symbols
   plot(amacrine, shape=c("circles", "squares"), size=0.04)
   plot(amacrine, shape="arrows", direction=c(0,90), size=0.07)

   ## plot trees as trees!
   plot(lansing, shape="arrows", direction=90, cols=1:6)

   # controlling MARK SCALE for pattern with numeric marks
   plot(longleaf, markscale=0.1)
   plot(longleaf, maxsize=5)
   plot(longleaf, meansize=2)
   plot(longleaf, minsize=2)

   # draw circles of diameter equal to nearest neighbour distance
   plot(cells %mark% nndist(cells), markscale=1, legend=FALSE)

   # inspecting the symbol map
   v &lt;- plot(amacrine)
   v

   ## variable colours ('cols' not 'col')
   plot(longleaf, cols=function(x) ifelse(x &lt; 30, "red", "black"))

   ## re-using the same mark scale
   a &lt;- plot(longleaf)
   juveniles &lt;- longleaf[marks(longleaf) &lt; 30]
   plot(juveniles, symap=a)

   ## numerical marks mapped to symbols of fixed size with variable colour
   ra &lt;- range(marks(longleaf))
   colmap &lt;- colourmap(terrain.colors(20), range=ra)
   ## filled plot characters are the codes 21-25
   ## fill colour is indicated by 'bg'
   sy &lt;- symbolmap(pch=21, bg=colmap, range=ra)
   plot(longleaf, symap=sy)

   ## or more compactly..
   plot(longleaf, bg=terrain.colors(20), pch=21, cex=1)

   ## clipping
   plot(humberside)
   B &lt;- owin(c(4810, 5190), c(4180, 4430))
   plot(B, add=TRUE, border="red")
   plot(humberside, clipwin=B, main="Humberside (clipped)")

   ## coordinate axes and labels
   plot(humberside, axes=TRUE)
   plot(humberside,            ann=TRUE, xlab="Easting", ylab="Northing")
   plot(humberside, axes=TRUE, ann=TRUE, xlab="Easting", ylab="Northing")
</code></pre>

<hr>
<h2 id='plot.pppmatching'>
Plot a Point Matching
</h2><span id='topic+plot.pppmatching'></span>

<h3>Description</h3>

<p>Plot an object of class <code>"pppmatching"</code> which represents
a matching of two planar point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pppmatching'
plot(x, addmatch = NULL, main = NULL, ..., adjust = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pppmatching_+3A_x">x</code></td>
<td>

<p>Point pattern matching object (class <code>"pppmatching"</code>)
to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.pppmatching_+3A_addmatch">addmatch</code></td>
<td>

<p>Optional. A matrix indicating additional pairs of points that
should be matched. See Details.
</p>
</td></tr>
<tr><td><code id="plot.pppmatching_+3A_main">main</code></td>
<td>

<p>Main title for the plot. 
</p>
</td></tr>
<tr><td><code id="plot.pppmatching_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to other plot methods.
</p>
</td></tr>
<tr><td><code id="plot.pppmatching_+3A_adjust">adjust</code></td>
<td>

<p>Adjustment factor for the widths of line segments.
A positive number.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object <code>x</code> represents a matching found between
two point patterns <code>X</code> and <code>Y</code>. The matching may be
incomplete. See <code><a href="#topic+pppmatching.object">pppmatching.object</a></code> for further
description.
</p>
<p>This function plots the matching by drawing the two point patterns
<code>X</code> and <code>Y</code> as red and blue dots respectively, and drawing
line segments between each pair of matched points. The width of the
line segments is proportional to the strength of matching. The
proportionality constant can be adjusted using the argument
<code>adjust</code>.
</p>
<p>Additional graphics arguments <code>...</code> control the
plotting of the window (and are passed to <code><a href="#topic+plot.owin">plot.owin</a></code>)
and the plotting of the line segments 
(and are passed to <code><a href="#topic+plot.psp">plot.psp</a></code>, 
and ultimately to the base graphics function
<code><a href="graphics.html#topic+polygon">polygon</a></code>).
</p>
<p>The argument <code>addmatch</code> is for use mainly by developers to
study algorithms which update the matching.
If <code>addmatch</code> is given, it should be a matrix with dimensions
<code>npoints(X) * npoints(Y)</code>. If <code>addmatch[i,j] &gt; 0</code> then
a light grey line segment will be drawn between <code>X[i]</code> and <code>Y[j</code>.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pppmatching.object">pppmatching.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runifrect(7)
  Y &lt;- runifrect(7)
  am &lt;- r2dtable(1, rep(10,7), rep(10,7))[[1]]/10
  m2 &lt;- pppmatching(X, Y, am)
  plot(m2, adjust=0.3)
</code></pre>

<hr>
<h2 id='plot.psp'>plot a Spatial Line Segment Pattern</h2><span id='topic+plot.psp'></span>

<h3>Description</h3>

<p>Plot a two-dimensional line segment pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'psp'
plot(x, ..., main, add=FALSE,
                     show.all=!add, show.window=show.all, do.plot=TRUE,
                     use.marks=TRUE,
                     which.marks=1,
                     style=c("colour", "width", "none"),
                     col=NULL, 
                     ribbon=show.all,
                     ribsep=0.15, ribwid=0.05, ribn=1024,
                     scale=NULL, adjust=1,
                     legend=TRUE,
                     leg.side=c("right", "left", "bottom", "top"),
                     leg.sep=0.1,
                     leg.wid=0.1,
                     leg.args=list(),
                     leg.scale=1,
                     negative.args=list(col=2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.psp_+3A_x">x</code></td>
<td>

<p>The line segment pattern to be plotted.
An object of class <code>"psp"</code>,
or data which can be converted into 
this format by <code><a href="#topic+as.psp">as.psp</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_...">...</code></td>
<td>

<p>extra arguments that will be passed to the plotting functions
<code><a href="graphics.html#topic+segments">segments</a></code> (to plot the segments)
and 
<code><a href="#topic+plot.owin">plot.owin</a></code> (to plot the observation window).
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_main">main</code></td>
<td>

<p>Character string giving a title for the plot.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_add">add</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the current plot is not erased;
the segments are plotted on top of the
current plot, and the window is not plotted (by default).
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_show.all">show.all</code></td>
<td>

<p>Logical value specifying whether to plot everything
including the window, main title, and colour ribbon.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_show.window">show.window</code></td>
<td>

<p>Logical value specifying whether to plot the window.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value indicating whether to actually perform the plot.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_use.marks">use.marks</code></td>
<td>

<p>Logical value specifying whether to use the marks
attached to the segments (<code>use.marks=TRUE</code>, the default)
or to ignore them (<code>use.marks=FALSE</code>). 
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_which.marks">which.marks</code></td>
<td>

<p>Index determining which column of marks to use,
if the marks of <code>x</code> are a data frame.
A character string or an integer.
Defaults to <code>1</code> indicating the first column of marks.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_style">style</code></td>
<td>

<p>Character string specifying how to represent the
mark value of each segment. If <code>style="colour"</code> (the default)
segments are coloured according to their mark value.
If <code>style="width"</code>, segments are drawn with a width
proportional to their mark value.
If <code>style="none"</code> the mark values are ignored.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_col">col</code></td>
<td>

<p>Colour information.
If <code>style="width"</code> or <code>style="none"</code>,
then <code>col</code> should be a single value,
interpretable as a colour; the line segments will be plotted
using this colour.
If <code>style="colour"</code> and <code>x</code> has marks,
then the mark values will be mapped
to colours using the information in <code>col</code>, which should be a 
colour map (object of class <code>"colourmap"</code>)
or a vector of colour values.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_ribbon">ribbon</code></td>
<td>

<p>Logical value indicating whether to display a ribbon
showing the colour map (in which mark values are associated with
colours) when <code>style="colour"</code>.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_ribsep">ribsep</code></td>
<td>

<p>Factor controlling the space between the colour ribbon and the image.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_ribwid">ribwid</code></td>
<td>

<p>Factor controlling the width of the colour ribbon.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_ribn">ribn</code></td>
<td>

<p>Number of different values to display in the colour ribbon.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_scale">scale</code></td>
<td>

<p>Optional. Physical scale for representing the mark values of
<code>x</code> as physical widths on the plot, when <code>style="width"</code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_adjust">adjust</code></td>
<td>

<p>Optional adjustment factor for <code>scale</code>.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_legend">legend</code></td>
<td>

<p>Logical value indicating whether to display a legend
showing the width map (in which mark values are associated with
segment widths) when <code>style="width"</code>.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_leg.side">leg.side</code></td>
<td>

<p>Character string (partially matched) specifying where the legend
should be plotted,
when <code>style="width"</code>.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_leg.sep">leg.sep</code></td>
<td>

<p>Factor controlling the space between the legend and the main plot,
when <code>style="width"</code>.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_leg.wid">leg.wid</code></td>
<td>

<p>Factor controlling the width of the legend,
when <code>style="width"</code>.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_leg.args">leg.args</code></td>
<td>

<p>Optional list of additional arguments passed to
<code><a href="graphics.html#topic+axis">axis</a></code> and
<code><a href="graphics.html#topic+text.default">text.default</a></code>
controlling the appearance of the legend,
when <code>style="width"</code>.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_leg.scale">leg.scale</code></td>
<td>

<p>Rescaling factor for labels, when <code>style="width"</code>.
The values on the numerical scale
printed beside the legend will be multiplied by this rescaling factor.
</p>
</td></tr>
<tr><td><code id="plot.psp_+3A_negative.args">negative.args</code></td>
<td>

<p>Optional list of arguments to <code><a href="graphics.html#topic+polygon">polygon</a></code>
to be used when the mark values are negative. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for 
line segment pattern datasets (of class <code>"psp"</code>,
see <code><a href="#topic+psp.object">psp.object</a></code>).
It plots both the observation window <code>Window(x)</code>
and the line segments themselves.
</p>
<p>Plotting of the window <code>Window(x)</code> is performed by
<code><a href="#topic+plot.owin">plot.owin</a></code>. This plot may be modified 
through the <code>...</code> arguments. 
</p>
<p>Plotting of the segments themselves is performed
by the standard R function <code><a href="graphics.html#topic+segments">segments</a></code>.
Its plotting behaviour may also be modified through the <code>...</code>
arguments.
</p>
<p>There are three different styles of plotting
which apply when the segments have marks
(i.e. when <code>marks(x)</code> is not null):
</p>

<dl>
<dt><code>style="colour"</code> (the default):</dt><dd>
<p>Segments are plotted with different colours depending on their
mark values.
The colour map, associating mark values with colours,
is determined by the argument <code>col</code>. The colour map will be
displayed as a vertical colour ribbon to the right of the plot, if
<code>ribbon=TRUE</code> (the default).
</p>
</dd>
<dt><code>style="width"</code>:</dt><dd>
<p>Segments are plotted with different widths depending on their
mark values. 
The expanded segments are plotted using the base graphics
function <code><a href="graphics.html#topic+polygon">polygon</a></code>.
The width map, associating mark values with line widths,
can be specified by giving the physical scale factor <code>scale</code>.
There is a sensible default scale, which can be adjusted using
the adjustment factor <code>adjust</code>.
The width map will be displayed as a vertical stack of lines
to the right of the plot, if <code>legend=TRUE</code> (the default).
</p>
</dd>
<dt><code>style="none"</code> or <code>use.marks=FALSE</code>:</dt><dd>
<p>Mark information is ignored and the
segments are plotted as thin lines using <code><a href="graphics.html#topic+segments">segments</a></code>.
</p>
</dd>
</dl>

<p>If <code>marks(x)</code> is a data frame, the default is to use the first
column of <code>marks(x)</code> to determine the colours or widths.
To specify another
column, use the argument <code>which.marks</code>.
</p>


<h3>Value</h3>

<p>If <code>style="colour"</code>, the result is a <code><a href="#topic+colourmap">colourmap</a></code>
object specifying the association between
marks and colours, if any.
</p>
<p>If <code>style="width"</code>, the result is a numeric value giving the
scaling between the mark values and the physical widths.
</p>
<p>In all cases, the return value also has an attribute
<code>"bbox"</code> giving a bounding box for the plot.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp.object">psp.object</a></code>,
<code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="#topic+plot.owin">plot.owin</a></code>,
<code><a href="#topic+text.psp">text.psp</a></code>,
<code><a href="graphics.html#topic+symbols">symbols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- psp(runif(20), runif(20), runif(20), runif(20), window=owin())
  plot(X)
  plot(X, lwd=3)
  lettuce &lt;- sample(letters[1:4], 20, replace=TRUE)
  marks(X) &lt;- data.frame(A=1:20, B=factor(lettuce))
  plot(X)
  plot(X, which.marks="B")
  plot(X, style="width", col="grey")
</code></pre>

<hr>
<h2 id='plot.quad'>Plot a Spatial Quadrature Scheme</h2><span id='topic+plot.quad'></span>

<h3>Description</h3>

<p>Plot a two-dimensional spatial quadrature scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'quad'
plot(x, ..., main, add=FALSE, dum=list(), tiles=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.quad_+3A_x">x</code></td>
<td>

<p>The spatial quadrature scheme to be plotted.
An object of class <code>"quad"</code>.
</p>
</td></tr>
<tr><td><code id="plot.quad_+3A_...">...</code></td>
<td>

<p>extra arguments controlling the plotting
of the data points of the quadrature scheme.
</p>
</td></tr>
<tr><td><code id="plot.quad_+3A_main">main</code></td>
<td>

<p>text to be displayed as a title above the plot.
</p>
</td></tr>
<tr><td><code id="plot.quad_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether the graphics should be added to the
current plot if there is one (<code>add=TRUE</code>)
or whether a new plot should be initialised (<code>add=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="plot.quad_+3A_dum">dum</code></td>
<td>

<p>list of extra arguments controlling the plotting of the dummy points of the
quadrature scheme. See below.
</p>
</td></tr>
<tr><td><code id="plot.quad_+3A_tiles">tiles</code></td>
<td>

<p>Logical value indicating whether to display the tiles used to
compute the quadrature weights.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for 
quadrature schemes (objects of class <code>"quad"</code>,
see <code><a href="#topic+quad.object">quad.object</a></code>).
</p>
<p>First the data points of the quadrature scheme
are plotted (in their observation window) using 
<code><a href="#topic+plot.ppp">plot.ppp</a></code> with any arguments specified in <code>...</code>
</p>
<p>Then the dummy points of the quadrature scheme are plotted
using <code><a href="#topic+plot.ppp">plot.ppp</a></code> with any arguments specified in
<code>dum</code>.
</p>
<p>By default the dummy points are superimposed onto the plot of data
points. This can be overridden by including the argument
<code>add=FALSE</code> in the list <code>dum</code> as shown in the examples.
In this case the data and dummy point patterns are plotted separately.
</p>
<p>See <code><a href="graphics.html#topic+par">par</a></code> and <code><a href="#topic+plot.ppp">plot.ppp</a></code>
for other possible arguments controlling the plots.
</p>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="#topic+plot.ppp">plot.ppp</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Q &lt;- quadscheme(nztrees)

   plot(Q, main="NZ trees: quadrature scheme")

   oldpar &lt;- par(mfrow=c(2,1))
   plot(Q, main="NZ trees", dum=list(add=FALSE))
   par(oldpar)
</code></pre>

<hr>
<h2 id='plot.quadratcount'>
Plot Quadrat Counts
</h2><span id='topic+plot.quadratcount'></span>

<h3>Description</h3>

<p>Given a table of quadrat counts for a spatial point pattern,
plot the quadrats which were used, and display the quadrat count
as text in the centre of each quadrat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'quadratcount'
plot(x, ..., add = FALSE,
              entries=as.integer(t(x)), 
              dx = 0, dy = 0, show.tiles = TRUE,
              textargs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.quadratcount_+3A_x">x</code></td>
<td>

<p>Object of class <code>"quadratcount"</code>
produced by the function <code><a href="#topic+quadratcount">quadratcount</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.quadratcount_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+plot.tess">plot.tess</a></code>
to plot the quadrats.
</p>
</td></tr>
<tr><td><code id="plot.quadratcount_+3A_add">add</code></td>
<td>

<p>Logical. Whether to add the graphics to an existing plot.
</p>
</td></tr>
<tr><td><code id="plot.quadratcount_+3A_entries">entries</code></td>
<td>

<p>Vector of numbers to be plotted in each quadrat.
The default is to plot the quadrat counts.
</p>
</td></tr>
<tr><td><code id="plot.quadratcount_+3A_dx">dx</code>, <code id="plot.quadratcount_+3A_dy">dy</code></td>
<td>

<p>Horizontal and vertical displacement of text
relative to centroid of quadrat.
</p>
</td></tr>
<tr><td><code id="plot.quadratcount_+3A_show.tiles">show.tiles</code></td>
<td>

<p>Logical value indicating whether to plot the quadrats.
</p>
</td></tr>
<tr><td><code id="plot.quadratcount_+3A_textargs">textargs</code></td>
<td>

<p>List containing extra arguments
passed to <code><a href="graphics.html#topic+text.default">text.default</a></code>
to control the annotation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the plot method for the objects 
of class <code>"quadratcount"</code> that are
produced by the function <code><a href="#topic+quadratcount">quadratcount</a></code>.
Given a spatial point pattern, <code><a href="#topic+quadratcount">quadratcount</a></code>
divides the observation window into disjoint tiles or quadrats,
counts the number of points in each quadrat, and stores the
result as a contingency table which also belongs to the
class <code>"quadratcount"</code>.
</p>
<p>First the quadrats are plotted
(provided <code>show.tiles=TRUE</code>, the default).
This display can be controlled by passing additional arguments <code>...</code>
to <code><a href="#topic+plot.tess">plot.tess</a></code>.
</p>
<p>Then the quadrat counts are printed using
<code><a href="graphics.html#topic+text.default">text.default</a></code>. This display can be controlled
using the arguments <code>dx,dy</code> and <code>textargs</code>.
</p>
<p>If <code>entries</code> is given, it should be a vector of length equal to
the number of quadrats (the number of tiles in the tessellation
<code>as.tess(x)</code>) containing integer or character values
to be displayed in each quadrat, in the same sequence
as <code>tiles(as.tess(x))</code> or <code>tilenames(as.tess(x))</code>
or the counts in the transposed table <code>t(x)</code>.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadratcount">quadratcount</a></code>,
<code><a href="#topic+plot.tess">plot.tess</a></code>,
<code><a href="graphics.html#topic+text.default">text.default</a></code>,
<code><a href="spatstat.explore.html#topic+plot.quadrattest">plot.quadrattest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(quadratcount(swedishpines, 5))
</code></pre>

<hr>
<h2 id='plot.solist'>Plot a List of Spatial Objects</h2><span id='topic+plot.solist'></span>

<h3>Description</h3>

<p>Plots a list of two-dimensional spatial objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'solist'
plot(x, ..., main, arrange=TRUE,
   nrows=NULL, ncols=NULL, main.panel=NULL,
   mar.panel=c(2,1,1,2), hsep=0, vsep=0,
   panel.begin=NULL, panel.end=NULL, panel.args=NULL,
   panel.begin.args=NULL, panel.end.args=NULL, panel.vpad = 0.2,
   plotcommand="plot",
   adorn.left=NULL, adorn.right=NULL, adorn.top=NULL, adorn.bottom=NULL,
   adorn.size=0.2, equal.scales=FALSE, halign=FALSE, valign=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.solist_+3A_x">x</code></td>
<td>

<p>An object of the class <code>"solist"</code>,
essentially a list of two-dimensional spatial datasets.
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code> when generating each
plot panel.
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_main">main</code></td>
<td>

<p>Overall heading for the plot.
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_arrange">arrange</code></td>
<td>

<p>Logical flag indicating whether to plot the objects
side-by-side on a single page (<code>arrange=TRUE</code>)
or plot them individually in a succession of frames
(<code>arrange=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_nrows">nrows</code>, <code id="plot.solist_+3A_ncols">ncols</code></td>
<td>

<p>Optional. The number of rows/columns in the plot layout
(assuming <code>arrange=TRUE</code>).
You can specify either or both of these numbers.
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_main.panel">main.panel</code></td>
<td>

<p>Optional. A character string, or a vector of character strings,
or a vector of expressions, giving the headings for each
plot panel.
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_mar.panel">mar.panel</code></td>
<td>

<p>Size of the margins outside each plot panel.
A numeric vector of length 4 giving the bottom, left, top,
and right margins in that order. (Alternatively the vector
may have length 1 or 2 and will be replicated to length 4).
See the section on <em>Spacing between plots</em>.
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_hsep">hsep</code>, <code id="plot.solist_+3A_vsep">vsep</code></td>
<td>

<p>Additional horizontal and vertical separation between plot panels,
expressed in the same units as <code>mar.panel</code>. 
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_panel.begin">panel.begin</code>, <code id="plot.solist_+3A_panel.end">panel.end</code></td>
<td>

<p>Optional. Functions that will be executed before and after each panel is
plotted. See Details.
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_panel.args">panel.args</code></td>
<td>

<p>Optional. Function that determines different plot arguments
for different panels. See Details.
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_panel.begin.args">panel.begin.args</code></td>
<td>

<p>Optional. List of additional arguments for <code>panel.begin</code>
when it is a function.
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_panel.end.args">panel.end.args</code></td>
<td>

<p>Optional. List of additional arguments for <code>panel.end</code>
when it is a function.
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_panel.vpad">panel.vpad</code></td>
<td>

<p>Amount of extra vertical space that should be allowed for the
title of each panel, if a title will be displayed.
Expressed as a fraction of the height of the panel.
Applies only when <code>equal.scales=FALSE</code> (the default).
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_plotcommand">plotcommand</code></td>
<td>

<p>Optional.
Character string containing the name of the command that should be
executed to plot each panel. 
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_adorn.left">adorn.left</code>, <code id="plot.solist_+3A_adorn.right">adorn.right</code>, <code id="plot.solist_+3A_adorn.top">adorn.top</code>, <code id="plot.solist_+3A_adorn.bottom">adorn.bottom</code></td>
<td>

<p>Optional. Functions (with no arguments) that will be executed to
generate additional plots at the margins (left, right, top and/or
bottom, respectively) of the array of plots.
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_adorn.size">adorn.size</code></td>
<td>

<p>Relative width (as a fraction of the other panels' widths)
of the margin plots.
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_equal.scales">equal.scales</code></td>
<td>

<p>Logical value indicating whether the components
should be plotted at (approximately) the same physical scale. 
</p>
</td></tr>
<tr><td><code id="plot.solist_+3A_halign">halign</code>, <code id="plot.solist_+3A_valign">valign</code></td>
<td>

<p>Logical values indicating whether panels in a column
should be aligned to the same <code class="reqn">x</code> coordinate system
(<code>halign=TRUE</code>) and whether panels in a row should
be aligned to the same <code class="reqn">y</code> coordinate system (<code>valign=TRUE</code>).
These are applicable only if <code>equal.scales=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"solist"</code>.
</p>
<p>An object of class <code>"solist"</code> represents a 
list of two-dimensional spatial datasets.
This is the <code>plot</code> method for such objects.
</p>
<p>In the <span class="pkg">spatstat</span> package, various functions produce
an object of class <code>"solist"</code>.
These objects can be plotted in a nice arrangement
using <code>plot.solist</code>. See the Examples.
</p>
<p>The argument <code>panel.args</code> determines extra graphics parameters
for each panel. It should be a function that will be called
as <code>panel.args(i)</code> where <code>i</code> is the panel number.
Its return value should be a list of graphics parameters that can
be passed to the relevant <code>plot</code> method. These parameters
override any parameters specified in the <code>...</code> arguments.
</p>
<p>The arguments <code>panel.begin</code> and <code>panel.end</code>
determine graphics that will be plotted before and after
each panel is plotted. They may be objects
of some class that can be plotted
with the generic <code>plot</code> command. Alternatively they
may be functions that will be
called as <code>panel.begin(i, y, main=main.panel[i])</code>
and <code>panel.end(i, y, add=TRUE)</code> where <code>i</code> is the panel
number and <code>y = x[[i]]</code>.
</p>
<p>If all entries of <code>x</code> are pixel images,
the function <code><a href="#topic+image.listof">image.listof</a></code> is called to control
the plotting. The arguments <code>equal.ribbon</code> and <code>col</code>
can be used to determine the colour map or maps applied.
</p>
<p>If <code>equal.scales=FALSE</code> (the default), then the 
plot panels will have equal height on the plot device
(unless there is only one column of panels, in which case
they will have equal width on the plot device). This means that the
objects are plotted at different physical scales, by default.
</p>
<p>If <code>equal.scales=TRUE</code>, then the dimensions of the
plot panels on the plot device will be proportional
to the spatial dimensions of the
corresponding components of <code>x</code>. This means that the
objects will be plotted at <em>approximately</em> equal physical scales.
If these objects have very different spatial sizes,
the plot command could fail (when it tries
to plot the smaller objects at a tiny scale), with an error
message that the figure margins are too large.
</p>
<p>The objects will be plotted at <em>exactly</em> equal
physical scales, and <em>exactly</em> aligned on the device,
under the following conditions:
</p>

<ul>
<li>
<p>every component of <code>x</code> is a spatial object
whose position can be shifted by <code><a href="#topic+shift">shift</a></code>;
</p>
</li>
<li>
<p><code>panel.begin</code> and <code>panel.end</code> are either
<code>NULL</code> or they are spatial objects 
whose position can be shifted by <code><a href="#topic+shift">shift</a></code>;
</p>
</li>
<li>
<p><code>adorn.left</code>, 
<code>adorn.right</code>, 
<code>adorn.top</code> and 
<code>adorn.bottom</code> are all <code>NULL</code>.
</p>
</li></ul>

<p>Another special case is when every component of <code>x</code> is an
object of class <code>"fv"</code> representing a function.
If <code>equal.scales=TRUE</code> then all these functions will 
be plotted with the same axis scales
(i.e. with the same <code>xlim</code> and the same <code>ylim</code>).
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Spacing between plots</h3>

<p>The spacing between individual plots is controlled by the parameters
<code>mar.panel</code>, <code>hsep</code> and <code>vsep</code>.
</p>
<p>If <code>equal.scales=FALSE</code>, the plot panels are
logically separate plots. The margins for each panel are
determined by the argument <code>mar.panel</code> which becomes 
the graphics parameter <code>mar</code>
described in the help file for <code><a href="graphics.html#topic+par">par</a></code>.
One unit of <code>mar</code> corresponds to one line of text in the margin.
If <code>hsep</code> or <code>vsep</code> are present, <code>mar.panel</code>
is augmented by <code>c(vsep, hsep, vsep, hsep)/2</code>.
</p>
<p>If <code>equal.scales=TRUE</code>, all the plot panels are drawn
in the same coordinate system which represents a physical scale.
The unit of measurement for <code>mar.panel[1,3]</code>
is one-sixth of the greatest height of any object plotted in the same row
of panels, and the unit for <code>mar.panel[2,4]</code> is one-sixth of the
greatest width of any object plotted in the same column of panels.
If <code>hsep</code> or <code>vsep</code> are present,
they are interpreted in the same units as <code>mar.panel[2]</code>
and <code>mar.panel[1]</code> respectively.
</p>


<h3>Error messages</h3>

<p>If the error message &lsquo;Figure margins too large&rsquo;
occurs, this generally means that one of the
objects had a much smaller physical scale than the others.
Ensure that <code>equal.scales=FALSE</code>
and increase the values of <code>mar.panel</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.anylist">plot.anylist</a></code>,
<code><a href="#topic+contour.listof">contour.listof</a></code>,
<code><a href="#topic+image.listof">image.listof</a></code>,
<code><a href="spatstat.explore.html#topic+density.splitppp">density.splitppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> D &lt;- solapply(split(amacrine), distmap)
 plot(D)
 plot(D, main="", equal.ribbon=TRUE,
      panel.end=function(i,y,...){contour(y, ...)})
</code></pre>

<hr>
<h2 id='plot.splitppp'>Plot a List of Point Patterns</h2><span id='topic+plot.splitppp'></span>

<h3>Description</h3>

<p>Plots a list of point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'splitppp'
plot(x, ..., main)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.splitppp_+3A_x">x</code></td>
<td>

<p>A named list of point patterns,
typically obtained from <code><a href="#topic+split.ppp">split.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.splitppp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+plot.listof">plot.listof</a></code> which control the
layout of the plot panels, their appearance, and the
plot behaviour in individual plot panels.
</p>
</td></tr>
<tr><td><code id="plot.splitppp_+3A_main">main</code></td>
<td>

<p>Optional main title for the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"splitppp"</code>.
It is typically used to plot the result of the function
<code><a href="#topic+split.ppp">split.ppp</a></code>.
</p>
<p>The argument <code>x</code> should be a named list of point patterns
(objects of class <code>"ppp"</code>, see <code><a href="#topic+ppp.object">ppp.object</a></code>).
Each of these point patterns will be plotted in turn
using <code><a href="#topic+plot.ppp">plot.ppp</a></code>.
</p>
<p>Plotting is performed by <code><a href="#topic+plot.listof">plot.listof</a></code>.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Error messages</h3>

<p>If the error message &lsquo;Figure margins too large&rsquo;
occurs, ensure that <code>equal.scales=FALSE</code>
and increase the values of <code>mar.panel</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.listof">plot.listof</a></code> for arguments controlling the plot.
</p>
<p><code><a href="#topic+split.ppp">split.ppp</a></code>,
<code><a href="#topic+plot.ppp">plot.ppp</a></code>,
<code><a href="#topic+ppp.object">ppp.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Multitype point pattern
 plot(split(amacrine))
 plot(split(amacrine), main="", 
     panel.begin=function(i, y, ...) { plot(distmap(y), ribbon=FALSE, ...) })
</code></pre>

<hr>
<h2 id='plot.symbolmap'>
Plot a Graphics Symbol Map
</h2><span id='topic+plot.symbolmap'></span>

<h3>Description</h3>

<p>Plot a representation of a graphics symbol map,
similar to a plot legend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'symbolmap'
plot(x, ..., main, xlim = NULL, ylim = NULL,
                         vertical = FALSE,
                         side = c("bottom", "left", "top", "right"),
                         annotate = TRUE, labelmap = NULL, add = FALSE,
                         nsymbols = NULL, warn = TRUE,
                         colour.only=FALSE,
                         representatives=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.symbolmap_+3A_x">x</code></td>
<td>

<p>Graphics symbol map (object of class <code>"symbolmap"</code>).
</p>
</td></tr>
<tr><td><code id="plot.symbolmap_+3A_...">...</code></td>
<td>

<p>Additional graphics arguments passed to
<code><a href="graphics.html#topic+points">points</a></code>, <code><a href="graphics.html#topic+symbols">symbols</a></code> or <code><a href="graphics.html#topic+axis">axis</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.symbolmap_+3A_main">main</code></td>
<td>

<p>Main title for the plot. A character string.
</p>
</td></tr>
<tr><td><code id="plot.symbolmap_+3A_xlim">xlim</code>, <code id="plot.symbolmap_+3A_ylim">ylim</code></td>
<td>

<p>Coordinate limits for the plot.
Numeric vectors of length 2.
</p>
</td></tr>
<tr><td><code id="plot.symbolmap_+3A_vertical">vertical</code></td>
<td>

<p>Logical. Whether to plot the symbol map in a vertical orientation.
</p>
</td></tr>
<tr><td><code id="plot.symbolmap_+3A_side">side</code></td>
<td>

<p>Character string specifying the position of the text
that annotates the symbols.
</p>
</td></tr>
<tr><td><code id="plot.symbolmap_+3A_annotate">annotate</code></td>
<td>

<p>Logical. Whether to annotate the symbols with labels.
</p>
</td></tr>
<tr><td><code id="plot.symbolmap_+3A_labelmap">labelmap</code></td>
<td>

<p>Transformation of the labels.
A function or a scale factor which will be applied to
the data values corresponding to the plotted symbols.
</p>
</td></tr>
<tr><td><code id="plot.symbolmap_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether to add the plot to the
current plot (<code>add=TRUE</code>) or to initialise a new plot.
</p>
</td></tr>
<tr><td><code id="plot.symbolmap_+3A_nsymbols">nsymbols</code></td>
<td>

<p>Optional. The maximum number of symbols that should be displayed.
Ignored if <code>representatives</code> are given.
</p>
</td></tr>
<tr><td><code id="plot.symbolmap_+3A_warn">warn</code></td>
<td>

<p>Logical value specifying whether to issue a warning
when the plotted symbol map does not represent every possible
discrete value.
</p>
</td></tr>
<tr><td><code id="plot.symbolmap_+3A_colour.only">colour.only</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, the colour map information will be
extracted from the symbol map, and only this colour map will be
plotted. If <code>FALSE</code> (the default) the entire symbol map is
plotted, including information about symbol shape and size as well
as colour.
</p>
</td></tr>
<tr><td><code id="plot.symbolmap_+3A_representatives">representatives</code></td>
<td>

<p>Optional. Vector containing the values of the input data
which should be shown on the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A graphics symbol map (object of class <code>"symbolmap"</code>)
is an association between data values and graphical symbols. 
</p>
<p>This command plots the graphics symbol map itself,
in the style of a plot legend.
</p>
<p>For a map of continuous values (a symbol map which represents a range
of numerical values) the plot will select about <code>nsymbols</code>
different values within this range, and plot their graphical
representations.
</p>
<p>For a map of discrete inputs (a symbol map which represents a finite
set of elements, such as categorical values) the plot will try to
display the graphical representation of every possible input,
up to a maximum of <code>nsymbols</code> items. If there are more than
<code>nsymbols</code> possible inputs, a warning will be issued (if
<code>warn=TRUE</code>, the default).
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+symbolmap">symbolmap</a></code> to create a symbol map.
</p>
<p><code><a href="#topic+invoke.symbolmap">invoke.symbolmap</a></code> to apply the symbol map to some data
and plot the resulting symbols.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  g &lt;- symbolmap(inputs=letters[1:10], pch=11:20)
  plot(g)

  g2 &lt;- symbolmap(range=c(-1,1),
                    shape=function(x) ifelse(x &gt; 0, "circles", "squares"),
                    size=function(x) sqrt(ifelse(x &gt; 0, x/pi, -x)),
                    bg = function(x) ifelse(abs(x) &lt; 1, "red", "black"))
  plot(g2, vertical=TRUE, side="left", col.axis="blue", cex.axis=2)
  plot(g2, representatives=c(-1,0,1))
</code></pre>

<hr>
<h2 id='plot.tess'>Plot a Tessellation</h2><span id='topic+plot.tess'></span>

<h3>Description</h3>

<p>Plots a tessellation, with optional labels for the tiles, and optional
filled colour in each tile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'tess'
plot(x, ..., main, add=FALSE,
                      show.all=!add,
                      border=NULL,
                      do.plot=TRUE,
                      do.labels=FALSE,
                      labels=tilenames(x), labelargs=list(),
                      do.col=FALSE,
                      values=marks(x),
                      multiplot=TRUE, 
                      col=NULL, ribargs=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tess_+3A_x">x</code></td>
<td>
<p>Tessellation (object of class <code>"tess"</code>) to be plotted.</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_...">...</code></td>
<td>
<p>Arguments controlling the appearance of the plot.</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_main">main</code></td>
<td>
<p>Heading for the plot. A character string.</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_add">add</code></td>
<td>
<p>Logical. Determines whether the tessellation plot is added
to the existing plot.
</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_show.all">show.all</code></td>
<td>

<p>Logical value indicating whether to plot everything
including the main title and the observation window of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_border">border</code></td>
<td>

<p>Colour of the tile boundaries. A character string or other value
specifying a single colour. 
Ignored for pixel tessellations.
</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value indicating whether to actually perform the plot.
</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_do.labels">do.labels</code></td>
<td>

<p>Logical value indicating whether to show a text label for each tile
of the tessellation.
</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_labels">labels</code></td>
<td>
<p>Character vector of labels for the tiles.</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_labelargs">labelargs</code></td>
<td>

<p>List of arguments passed to
<code><a href="graphics.html#topic+text.default">text.default</a></code> to control display of the text labels.
</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_do.col">do.col</code></td>
<td>

<p>Logical value indicating whether tiles should be filled with
colour. Always <code>TRUE</code> for pixel tessellations.
</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_values">values</code></td>
<td>

<p>A vector of numerical values (or a factor, or vector of character
strings) that will be associated with each tile of the tessellation
and which determine the colour of the tile. The default is
the marks of <code>x</code>. If the tessellation is not marked,
or if the argument <code>values=NULL</code> is given, the default is
a factor giving the tile identifier.
</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_multiplot">multiplot</code></td>
<td>

<p>Logical value giving permission to display multiple plot panels.
This applies when <code>do.col=TRUE</code> and <code>ncol(values) &gt; 1</code>.
</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_col">col</code></td>
<td>

<p>A vector of colours for each of the <code>values</code>,
or a <code><a href="#topic+colourmap">colourmap</a></code> that maps these values to colours.
</p>
</td></tr>
<tr><td><code id="plot.tess_+3A_ribargs">ribargs</code></td>
<td>

<p>List of additional arguments to control the plot of the colour map,
if <code>do.col=TRUE</code>. See explanation in <code><a href="#topic+plot.im">plot.im</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic <code><a href="graphics.html#topic+plot">plot</a></code> function
for the class <code>"tess"</code> of tessellations (see <code><a href="#topic+tess">tess</a></code>).
</p>
<p>The window of the tessellation is plotted, and then the tiles of the
tessellation are plotted in their correct positions in the window.
</p>
<p>Rectangular or polygonal tiles are plotted individually
using <code><a href="#topic+plot.owin">plot.owin</a></code>, while a
tessellation represented by a pixel image
is plotted using <code><a href="#topic+plot.im">plot.im</a></code>.
The arguments <code>...</code> control the appearance of the plot,
and are passed to <code><a href="graphics.html#topic+segments">segments</a></code>,
<code><a href="#topic+plot.owin">plot.owin</a></code> or <code><a href="#topic+plot.im">plot.im</a></code> as appropriate.
</p>
<p>If <code>do.col=TRUE</code>, then the tiles of the tessellation are filled
with colours determined by the argument <code>values</code>.
By default, these values are the marks associated with each of the tiles.
If there is more than one column of marks or values,
then the default behaviour (if <code>multiplot=TRUE</code>)
is to display several plot panels, one for
each column of mark values. Then the arguments <code>...</code> are
passed to <code><a href="#topic+plot.solist">plot.solist</a></code> to determine the arrangement of
the panels. 
</p>


<h3>Value</h3>

<p>(Invisible) window of class <code>"owin"</code> specifying a bounding box
for the plot, or an object of class <code>"colourmap"</code> specifying the
colour map. (In the latter case, the bounding box information is
available as an attribute, and can be extracted
using <code><a href="#topic+as.owin">as.owin</a></code>.)
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Rect &lt;- tess(xgrid=0:4,ygrid=0:4)
  Diri &lt;- dirichlet(runifrect(7))
  plot(Diri)
  plot(Rect, border="blue", lwd=2, lty=2)
  plot(Rect, do.col=TRUE, border="white")
  plot(Rect, do.col=TRUE, values=runif(16), border="white")
  B &lt;- Rect[c(1, 2, 5, 7, 9)]
  plot(B, hatch=TRUE)
  plot(Diri, do.col=TRUE)
  plot(Diri, do.col=TRUE, do.labels=TRUE, labelargs=list(col="white"),
             ribbon=FALSE)
  v &lt;- as.im(function(x,y){factor(round(5 * (x^2 + y^2)))}, W=owin())
  levels(v) &lt;- letters[seq(length(levels(v)))]
  Img &lt;- tess(image=v)
  plot(Img)
  plot(Img, col=rainbow(11), ribargs=list(las=1))
  a &lt;- tile.areas(Diri)
  marks(Diri) &lt;- data.frame(area=a, random=runif(7, max=max(a)))
  plot(Diri, do.col=TRUE, equal.ribbon=TRUE)
</code></pre>

<hr>
<h2 id='plot.textstring'>Plot a Text String</h2><span id='topic+plot.textstring'></span>

<h3>Description</h3>

<p>Plots an object of class <code>"textstring"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'textstring'
plot(x, ..., do.plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.textstring_+3A_x">x</code></td>
<td>

<p>Object of class <code>"textstring"</code> to be plotted.
This object is created by the command <code><a href="#topic+textstring">textstring</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.textstring_+3A_...">...</code></td>
<td>

<p>Additional graphics arguments passed to
<code><a href="graphics.html#topic+text">text</a></code> to control the plotting of text.
</p>
</td></tr>
<tr><td><code id="plot.textstring_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value indicating whether to actually plot the text.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> should be an object of class <code>"textstring"</code> 
created by the command <code><a href="#topic+textstring">textstring</a></code>. 
</p>
<p>This function displays the text using 
<code><a href="graphics.html#topic+text">text</a></code>.
</p>


<h3>Value</h3>

<p>A window (class <code>"owin"</code>) enclosing the plotted graphics.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+onearrow">onearrow</a></code>,
<code><a href="#topic+yardstick">yardstick</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  W &lt;- Window(humberside)
  te &lt;- textstring(centroid.owin(W), txt="Humberside", cex=2.5)
  te
  plot(layered(W, te), main="")
</code></pre>

<hr>
<h2 id='plot.texturemap'>
Plot a Texture Map
</h2><span id='topic+plot.texturemap'></span>

<h3>Description</h3>

<p>Plot a representation of a texture map,
similar to a plot legend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'texturemap'
plot(x, ..., main, xlim = NULL, ylim = NULL,
                           vertical = FALSE, axis = TRUE,
                           labelmap = NULL, gap = 0.25,
                           spacing = NULL, add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.texturemap_+3A_x">x</code></td>
<td>

<p>Texture map object (class <code>"texturemap"</code>).
</p>
</td></tr>
<tr><td><code id="plot.texturemap_+3A_...">...</code></td>
<td>

<p>Additional graphics arguments passed to
<code><a href="#topic+add.texture">add.texture</a></code> or <code><a href="lattice.html#topic+axis.default">axis.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.texturemap_+3A_main">main</code></td>
<td>

<p>Main title for plot.
</p>
</td></tr>
<tr><td><code id="plot.texturemap_+3A_xlim">xlim</code>, <code id="plot.texturemap_+3A_ylim">ylim</code></td>
<td>

<p>Optional vectors of length 2 giving the <code class="reqn">x</code> and <code class="reqn">y</code> limits
of the plot.
</p>
</td></tr>
<tr><td><code id="plot.texturemap_+3A_vertical">vertical</code></td>
<td>

<p>Logical value indicating whether to arrange the texture boxes
in a vertical column (<code>vertical=TRUE</code> or a horizontal row
(<code>vertical=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="plot.texturemap_+3A_axis">axis</code></td>
<td>

<p>Logical value indicating whether to plot an axis line
joining the texture boxes.
</p>
</td></tr>
<tr><td><code id="plot.texturemap_+3A_labelmap">labelmap</code></td>
<td>

<p>Optional. A <code>function</code> which will be applied to the
data values (the inputs of the texture map) before they are
displayed on the plot.
</p>
</td></tr>
<tr><td><code id="plot.texturemap_+3A_gap">gap</code></td>
<td>

<p>Separation between texture boxes, as a fraction of the
width or height of a box.
</p>
</td></tr>
<tr><td><code id="plot.texturemap_+3A_spacing">spacing</code></td>
<td>

<p>Argument passed to <code><a href="#topic+add.texture">add.texture</a></code> controlling the density
of lines in a texture. Expressed in spatial coordinate units.
</p>
</td></tr>
<tr><td><code id="plot.texturemap_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether to add the graphics to an existing
plot (<code>add=TRUE</code>) or to initialise a new plot
(<code>add=FALSE</code>, the default).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A texture map is an association between data values and graphical
textures. An object of class <code>"texturemap"</code> represents a texture
map. Such objects are returned from the plotting function
<code><a href="#topic+textureplot">textureplot</a></code>, and can be created directly by the function
<code><a href="#topic+texturemap">texturemap</a></code>.
</p>
<p>This function <code>plot.texturemap</code> is a method for the generic
<code><a href="graphics.html#topic+plot">plot</a></code> for the class <code>"texturemap"</code>. It displays
a sample of each of the textures in the texture map, in a separate
box, annotated by the data value which is mapped to that texture.
</p>
<p>The arrangement and position of the boxes is controlled by
the arguments <code>vertical</code>, <code>xlim</code>, <code>ylim</code> and
<code>gap</code>.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+texturemap">texturemap</a></code>,
<code><a href="#topic+textureplot">textureplot</a></code>,
<code><a href="#topic+add.texture">add.texture</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   tm &lt;- texturemap(c("First", "Second", "Third"), 2:4, col=2:4)
   plot(tm, vertical=FALSE)
   ## abbreviate the labels
   plot(tm, labelmap=function(x) substr(x, 1, 2))
</code></pre>

<hr>
<h2 id='plot.yardstick'>
Plot a Yardstick or Scale Bar
</h2><span id='topic+plot.yardstick'></span>

<h3>Description</h3>

<p>Plots an object of class <code>"yardstick"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'yardstick'
plot(x, ...,
        angle = 20, frac = 1/8, 
        split = FALSE, shrink = 1/4,
        pos = NULL,
        txt.args=list(),
        txt.shift=c(0,0),
        do.plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.yardstick_+3A_x">x</code></td>
<td>

<p>Object of class <code>"yardstick"</code> to be plotted.
This object is created by the command <code><a href="#topic+yardstick">yardstick</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.yardstick_+3A_...">...</code></td>
<td>

<p>Additional graphics arguments passed to
<code><a href="graphics.html#topic+segments">segments</a></code> to control the appearance of the line.
</p>
</td></tr>
<tr><td><code id="plot.yardstick_+3A_angle">angle</code></td>
<td>

<p>Angle between the arrows and the line segment, in degrees. 
</p>
</td></tr>
<tr><td><code id="plot.yardstick_+3A_frac">frac</code></td>
<td>

<p>Length of arrow as a fraction of total length of the line segment.
</p>
</td></tr>
<tr><td><code id="plot.yardstick_+3A_split">split</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the line will be broken in the
middle, and the text will be placed in this gap. If <code>FALSE</code>,
the line will be unbroken, and the text will be placed beside
the line.
</p>
</td></tr>
<tr><td><code id="plot.yardstick_+3A_shrink">shrink</code></td>
<td>

<p>Fraction of total length to be removed from the middle of the
line segment, if <code>split=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.yardstick_+3A_pos">pos</code></td>
<td>

<p>Integer (passed to <code><a href="graphics.html#topic+text">text</a></code>) determining the
position of the annotation text relative to the line segment,
if <code>split=FALSE</code>. Values of 1, 2, 3 and 4
indicate positions below, to the left of,
above and to the right of the line, respectively.
</p>
</td></tr>
<tr><td><code id="plot.yardstick_+3A_txt.args">txt.args</code></td>
<td>

<p>Optional list of additional arguments passed to
<code><a href="graphics.html#topic+text">text</a></code> controlling the appearance of the text.
Examples include <code>adj</code>, <code>srt</code>, <code>col</code>, <code>cex</code>,
<code>font</code>.
</p>
</td></tr>
<tr><td><code id="plot.yardstick_+3A_txt.shift">txt.shift</code></td>
<td>

<p>Optional numeric vector of length 2 specifying displacement
of the text position relative to the centre of the yardstick.
</p>
</td></tr>
<tr><td><code id="plot.yardstick_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical. Whether to actually perform the plot (<code>do.plot=TRUE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A yardstick or scale bar is a line segment, drawn on any spatial
graphics display, indicating the scale of the plot. 
</p>
<p>The argument <code>x</code> should be an object of class <code>"yardstick"</code>
created by the command <code><a href="#topic+yardstick">yardstick</a></code>. 
</p>


<h3>Value</h3>

<p>A window (class <code>"owin"</code>) enclosing the plotted graphics.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+yardstick">yardstick</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(owin(), main="Yardsticks")
  ys &lt;- yardstick(as.psp(list(xmid=0.5, ymid=0.1, length=0.4, angle=0),
                         window=owin(c(0.2, 0.8), c(0, 0.2))),
                  txt="1 km")
  plot(ys)
  ys &lt;- shift(ys, c(0, 0.3))
  plot(ys, angle=90, frac=0.08)
  ys &lt;- shift(ys, c(0, 0.3))
  plot(ys, split=TRUE)
</code></pre>

<hr>
<h2 id='pointsOnLines'>Place Points Evenly Along Specified Lines</h2><span id='topic+pointsOnLines'></span>

<h3>Description</h3>

<p>Given a line segment pattern, place a series of points
at equal distances along each line segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointsOnLines(X, eps = NULL, np = 1000, shortok=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointsOnLines_+3A_x">X</code></td>
<td>
<p>A line segment pattern (object of class <code>"psp"</code>).</p>
</td></tr>
<tr><td><code id="pointsOnLines_+3A_eps">eps</code></td>
<td>
<p>Spacing between successive points.</p>
</td></tr>
<tr><td><code id="pointsOnLines_+3A_np">np</code></td>
<td>
<p>Approximate total number of points (incompatible with
<code>eps</code>).</p>
</td></tr>
<tr><td><code id="pointsOnLines_+3A_shortok">shortok</code></td>
<td>

<p>Logical. If <code>FALSE</code>, very short segments
(of length shorter than <code>eps</code>) will not generate any points.
If <code>TRUE</code>, a very short segment will be represented by its
midpoint.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each line segment in the pattern <code>X</code>, a succession of points
is placed along the line segment. These points are equally spaced at
a distance <code>eps</code>, except for the first and last points
in the sequence. 
</p>
<p>The spacing <code>eps</code> is measured in coordinate units of <code>X</code>.
</p>
<p>If <code>eps</code> is not given, then it is determined by
<code>eps = len/np</code> where <code>len</code> is the total length of the
segments in <code>X</code>. The actual number of points will then be slightly
larger than <code>np</code>.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>) in the same window
as <code>X</code>. The result also has an attribute called <code>"map"</code> which
maps the points to their parent line segments.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp">psp</a></code>,
<code><a href="#topic+ppp">ppp</a></code>,
<code><a href="spatstat.random.html#topic+runifpointOnLines">runifpointOnLines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- psp(runif(20), runif(20), runif(20), runif(20),  window=owin())
  Y &lt;- pointsOnLines(X, eps=0.05)
  plot(X, main="")
  plot(Y, add=TRUE, pch="+")
</code></pre>

<hr>
<h2 id='polartess'>
Tessellation Using Polar Coordinates
</h2><span id='topic+polartess'></span>

<h3>Description</h3>

<p>Create a tessellation with tiles defined by polar coordinates
(radius and angle).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polartess(W, ..., nradial = NULL, nangular = NULL,
          radii = NULL, angles = NULL,
          origin = NULL, sep = "x")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polartess_+3A_w">W</code></td>
<td>

<p>A window (object of class <code>"owin"</code>)
or anything that can be coerced to a window using
<code><a href="#topic+as.owin">as.owin</a></code>, such as a point pattern.
</p>
</td></tr>
<tr><td><code id="polartess_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="polartess_+3A_nradial">nradial</code></td>
<td>

<p>Number of <em>tiles</em> in the radial direction.
A single integer.
Ignored if <code>radii</code> is given.
</p>
</td></tr>
<tr><td><code id="polartess_+3A_nangular">nangular</code></td>
<td>

<p>Number of <em>tiles</em> in the angular coordinate.
A single integer.
Ignored if <code>angles</code> is given.
</p>
</td></tr>
<tr><td><code id="polartess_+3A_radii">radii</code></td>
<td>

<p>The numeric values of the radii, defining the tiles in the radial
direction. A numeric vector, of length at least 2, containing
nonnegative numbers in increasing order. The value <code>Inf</code> is permitted.
</p>
</td></tr>
<tr><td><code id="polartess_+3A_angles">angles</code></td>
<td>

<p>The numeric values of the angles defining the tiles in the
angular coordinate. A numeric vector, of length at least 2,
in increasing order, containing angles in radians.
</p>
</td></tr>
<tr><td><code id="polartess_+3A_origin">origin</code></td>
<td>

<p>Location to be used as the origin of the polar coordinates.
Either a numeric vector of length 2 giving the spatial location
of the origin, or one of the strings
<code>"centroid"</code>, <code>"midpoint"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code>,
<code>"topleft"</code>, <code>"bottomleft"</code>, <code>"topright"</code> or
<code>"bottomright"</code> indicating the location in the window.
</p>
</td></tr>
<tr><td><code id="polartess_+3A_sep">sep</code></td>
<td>

<p>Argument passed to <code><a href="#topic+intersect.tess">intersect.tess</a></code>
specifying the character string to be used as a separator
when forming the names of the tiles.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation will be formed from tiles defined by
intervals in the polar coordinates <code class="reqn">r</code> (radial distance
from the origin) or <code class="reqn">\theta</code> (angle from the horizontal axis)
or both. These tiles look like the cells on a dartboard.
</p>
<p>If the argument <code>radii</code> is given, tiles will be demarcated
by circles centred at the origin, with the specified radii.
If <code>radii</code> is absent but <code>nradial</code> is given,
then <code>radii</code> will default to a sequence
of <code>nradial+1</code> radii equally spaced from zero to the maximum
possible radius. If neither <code>radii</code> nor <code>nradial</code> are given,
the tessellation will not include circular arc boundaries.
</p>
<p>If the argument <code>angles</code> is given, tiles will be demarcated
by lines emanating from the origin at the specified angles.
The angular values can be any real numbers; they will be interpreted
as angles in radians modulo <code>2*pi</code>,
but they must be an increasing sequence of numbers.
If <code>angles</code> is absent but <code>nangular</code> is given,
then <code>angles</code> will default to a sequence
of <code>nangular+1</code> angles equally spaced from 0 to <code>2*pi</code>.
If neither <code>angles</code> nor <code>nangular</code> are given,
the tessellation will not include linear boundaries.
</p>


<h3>Value</h3>

<p>A tessellation (object of class <code>"tess"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect.tess">intersect.tess</a></code>
</p>
<p>To construct other kinds of tessellations, see
<code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+quadrats">quadrats</a></code>, <code><a href="#topic+hextess">hextess</a></code>,
<code><a href="#topic+venn.tess">venn.tess</a></code>,
<code><a href="#topic+dirichlet">dirichlet</a></code>, <code><a href="#topic+delaunay">delaunay</a></code>,
<code><a href="#topic+quantess">quantess</a></code>,
<code><a href="#topic+bufftess">bufftess</a></code>
and <code><a href="spatstat.random.html#topic+rpoislinetess">rpoislinetess</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Y &lt;- c(2.8, 1.5)
  plot(polartess(letterR, nangular=6, radii=(0:4)/2, origin=Y),
       do.col=TRUE)
</code></pre>

<hr>
<h2 id='pp3'>
Three Dimensional Point Pattern
</h2><span id='topic+pp3'></span>

<h3>Description</h3>

<p>Create a three-dimensional point pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp3(x, y, z, ..., marks=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp3_+3A_x">x</code>, <code id="pp3_+3A_y">y</code>, <code id="pp3_+3A_z">z</code></td>
<td>

<p>Numeric vectors of equal length, containing Cartesian coordinates
of points in three-dimensional space.
</p>
</td></tr>
<tr><td><code id="pp3_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.box3">as.box3</a></code> to determine
the three-dimensional box in which the points have been observed.
</p>
</td></tr>
<tr><td><code id="pp3_+3A_marks">marks</code></td>
<td>

<p>Optional.
Vector, data frame, or hyperframe of mark values associated with the points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"pp3"</code> represents a pattern of points in
three-dimensional space. The points are assumed to have been observed
by exhaustively inspecting a three-dimensional rectangular box. The
boundaries of the box are included as part of the dataset.
</p>


<h3>Value</h3>

<p>Object of class <code>"pp3"</code> representing a three dimensional
point pattern. Also belongs to class <code>"ppx"</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+box3">box3</a></code>, 
<code><a href="#topic+print.pp3">print.pp3</a></code>, 
<code><a href="#topic+ppx">ppx</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- pp3(runif(10), runif(10), runif(10),
            box3(c(0,1)),
            marks=rnorm(10))
   X
</code></pre>

<hr>
<h2 id='ppp'>Create a Point Pattern</h2><span id='topic+ppp'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"ppp"</code> representing 
a point pattern dataset in the two-dimensional plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ppp(x,y, ..., window, marks,
      check=TRUE, checkdup=check, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppp_+3A_x">x</code></td>
<td>
<p>Vector of <code class="reqn">x</code> coordinates of data points</p>
</td></tr>
<tr><td><code id="ppp_+3A_y">y</code></td>
<td>
<p>Vector of <code class="reqn">y</code> coordinates of data points</p>
</td></tr>
<tr><td><code id="ppp_+3A_window">window</code></td>
<td>
<p>window of observation,
an object of class <code>"owin"</code></p>
</td></tr>
<tr><td><code id="ppp_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+owin">owin</a></code> to create the
window, if <code>window</code> is missing</p>
</td></tr>
<tr><td><code id="ppp_+3A_marks">marks</code></td>
<td>
<p>(optional) mark values for the points.
A vector or data frame.</p>
</td></tr>
<tr><td><code id="ppp_+3A_check">check</code></td>
<td>

<p>Logical value indicating whether to check
that all the <code class="reqn">(x,y)</code> points lie inside the specified window.
Do not set this to <code>FALSE</code> unless you are absolutely sure that this
check is unnecessary. See Warnings below.
</p>
</td></tr>
<tr><td><code id="ppp_+3A_checkdup">checkdup</code></td>
<td>

<p>Logical value indicating whether to check for duplicated
coordinates. See Warnings below.
</p>
</td></tr>
<tr><td><code id="ppp_+3A_drop">drop</code></td>
<td>

<p>Logical flag indicating whether to simplify data frames of marks.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the <span class="pkg">spatstat</span> library, a point pattern dataset is
described by an object of class <code>"ppp"</code>. This function
creates such objects.
</p>
<p>The vectors <code>x</code> and <code>y</code> must be numeric vectors of
equal length. They are interpreted as the cartesian coordinates
of the points in the pattern. Note that <code>x</code> and <code>y</code> are
permitted to have length zero, corresponding to an empty point
pattern; this is the default if these arguments are missing.
</p>
<p>A point pattern dataset is assumed to have been observed within a specific
region of the plane called the observation window.
An object of class <code>"ppp"</code> representing a point pattern
contains information specifying the observation window.
This window must always be specified when creating a point pattern dataset;
there is intentionally no default action of &ldquo;guessing&rdquo; the window
dimensions from the data points alone. 
</p>
<p>You can specify the observation window in several
(mutually exclusive) ways:
</p>

<ul>
<li>
<p><code>xrange, yrange</code> specify a rectangle
with these dimensions;
</p>
</li>
<li>
<p><code>poly</code> specifies a polygonal boundary.
If the boundary is a single polygon then <code>poly</code>
must be a list with components <code>x,y</code>
giving the coordinates of the vertices.
If the boundary consists of several disjoint polygons
then <code>poly</code> must be a list of such lists
so that <code>poly[[i]]$x</code> gives the <code class="reqn">x</code> coordinates
of the vertices of the <code class="reqn">i</code>th boundary polygon.
</p>
</li>
<li>
<p><code>mask</code> specifies a binary pixel image with entries
that are <code>TRUE</code> if the corresponding pixel is inside
the window.
</p>
</li>
<li>
<p><code>window</code> is an object of class <code>"owin"</code>
specifying the window. A window object can be created
by <code><a href="#topic+owin">owin</a></code> from raw coordinate data. Special shapes
of windows can be created by the functions
<code><a href="#topic+square">square</a></code>, <code><a href="#topic+hexagon">hexagon</a></code>,
<code><a href="#topic+regularpolygon">regularpolygon</a></code>, <code><a href="#topic+disc">disc</a></code>
and <code><a href="#topic+ellipse">ellipse</a></code>. See the Examples.
</p>
</li></ul>

<p>The arguments <code>xrange, yrange</code> or <code>poly</code>
or <code>mask</code> are passed to the window creator function
<code><a href="#topic+owin">owin</a></code> for interpretation. See
<code><a href="#topic+owin">owin</a></code> for further details.
</p>
<p>The argument <code>window</code>, if given, must be an object of class
<code>"owin"</code>. It is a full description of the window geometry,
and could have been obtained from <code><a href="#topic+owin">owin</a></code> or
<code><a href="#topic+as.owin">as.owin</a></code>, or by just extracting the observation window
of another point pattern, or by manipulating such windows.
See <code><a href="#topic+owin">owin</a></code> or the Examples below.
</p>
<p>The points with coordinates <code>x</code> and <code>y</code>
<b>must</b> lie inside the specified window, in order to
define a valid object of this class. 
Any points which do not lie inside the window will be
removed from the point pattern, and a warning will be issued.
See the section on Rejected Points.
</p>
<p>The name of the unit of length for the <code>x</code> and <code>y</code> coordinates
can be specified in the dataset, using the argument <code>unitname</code>, which is
passed to <code><a href="#topic+owin">owin</a></code>. See the examples below, or the help file
for <code><a href="#topic+owin">owin</a></code>.
</p>
<p>The optional argument <code>marks</code> is given if the point pattern
is marked, i.e. if each data point carries additional information.
For example, points which are classified into two or more different
types, or colours, may be regarded as having a mark which identifies
which colour they are. Data recording the locations and heights of
trees in a forest can be regarded as a marked point pattern where the
mark is the tree height.
</p>
<p>The argument <code>marks</code> can be either
</p>

<ul>
<li><p> a vector, of
the same length as <code>x</code> and <code>y</code>, which is interpreted so
that <code>marks[i]</code> is the mark attached to the point
<code>(x[i],y[i])</code>. If the mark is a real number then <code>marks</code>
should be a numeric vector, while if the mark takes only a finite
number of possible values (e.g. colours or types) then
<code>marks</code> should be a <code>factor</code>.
</p>
</li>
<li>
<p>a data frame, with the number of rows equal to the number of points
in the point pattern. The <code>i</code>th row of the data frame is interpreted
as containing the mark values for the <code>i</code>th point in the point
pattern. The columns of the data frame correspond to different
mark variables (e.g. tree species and tree diameter).
</p>
</li></ul>

<p>If <code>drop=TRUE</code> (the default), then 
a data frame with only one column will be
converted to a vector, and a data frame with no columns will be
converted to <code>NULL</code>.
</p>
<p>See <code><a href="#topic+ppp.object">ppp.object</a></code> for a description of the
class <code>"ppp"</code>.
</p>
<p>Users would normally invoke <code>ppp</code> to create a point pattern,
but the functions <code><a href="#topic+as.ppp">as.ppp</a></code> and 
<code>scanpp</code> may sometimes be convenient.
</p>


<h3>Value</h3>

<p>An object of class <code>"ppp"</code> 
describing a point pattern in the two-dimensional plane
(see <code><a href="#topic+ppp.object">ppp.object</a></code>).
</p>


<h3>Invalid coordinate values</h3>

<p>The coordinate vectors <code>x</code> and <code>y</code> must contain only
finite numerical values. If the coordinates include
any of the values <code>NA</code>, <code>NaN</code>, <code>Inf</code> or <code>-Inf</code>,
these will be removed. 
</p>


<h3>Rejected points</h3>

<p>The points with coordinates <code>x</code> and <code>y</code>
<b>must</b> lie inside the specified window, in order to
define a valid object of class <code>"ppp"</code>.
Any points which do not lie inside the window will be
removed from the point pattern, and a warning will be issued.
</p>
<p>The rejected points are still accessible: they are stored
as an attribute of the point pattern called <code>"rejects"</code>
(which is an object of class <code>"ppp"</code> containing the rejected points
in a large window). However, rejected points in a point pattern
will be ignored by all other functions except
<code><a href="#topic+plot.ppp">plot.ppp</a></code>.
</p>
<p>To remove the rejected points altogether,
use <code><a href="#topic+as.ppp">as.ppp</a></code>. To include the rejected points,
you will need to find a larger window that contains them,
and use this larger window in a call to <code>ppp</code>.
</p>


<h3>Warnings</h3>

<p>The code will check for problems with the data,
and issue a warning if any problems are found.
The checks and warnings can be switched off, for efficiency's sake,
but this should only be done if you are confident that the data
do not have these problems. 
</p>
<p>Setting <code>check=FALSE</code> will disable all the checking procedures:
the check for points outside the window, and the check for
duplicated points. This is extremely dangerous, because points lying
outside the window will break many of the procedures in
<span class="pkg">spatstat</span>, causing crashes and strange errors.
Set <code>check=FALSE</code> only if you are absolutely
sure that there are no points outside the window.
</p>
<p>If duplicated points are found, a warning is issued, but no action is
taken. Duplicated points are not illegal, but may cause unexpected problems
later. Setting <code>checkdup=FALSE</code> will disable the check for duplicated
points. Do this only if you already know the answer.
</p>
<p>Methodology and software for spatial point patterns often assume
that all points are distinct so that there are no duplicated points.
If duplicated points are present, the consequence could be
an incorrect result or a software crash. To the best of our knowledge,
all <span class="pkg">spatstat</span> code handles duplicated points correctly.
However, if duplicated points are present, we advise using
<code><a href="#topic+unique.ppp">unique.ppp</a></code> or <code><a href="#topic+multiplicity.ppp">multiplicity.ppp</a></code>
to eliminate duplicated points and re-analyse the data.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+as.ppp">as.ppp</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # some arbitrary coordinates in [0,1]
  x &lt;- runif(20)
  y &lt;- runif(20)

  # the following are equivalent
  X &lt;- ppp(x, y, c(0,1), c(0,1))
  X &lt;- ppp(x, y)
  X &lt;- ppp(x, y, window=owin(c(0,1),c(0,1)))

  # specify that the coordinates are given in metres
  X &lt;- ppp(x, y, c(0,1), c(0,1), unitname=c("metre","metres"))

  # plot(X)

  # marks
  m &lt;- sample(1:2, 20, replace=TRUE)
  m &lt;- factor(m, levels=1:2)
  X &lt;- ppp(x, y, c(0,1), c(0,1), marks=m)

  # polygonal window
  X &lt;- ppp(x, y, poly=list(x=c(0,10,0), y=c(0,0,10)))

  # circular window of radius 2
  X &lt;- ppp(x, y, window=disc(2))

  # copy the window from another pattern
  X &lt;- ppp(x, y, window=Window(cells))
</code></pre>

<hr>
<h2 id='ppp.object'>Class of Point Patterns</h2><span id='topic+ppp.object'></span>

<h3>Description</h3>

<p>A class <code>"ppp"</code> to represent a two-dimensional point
pattern. Includes information about the window in which the
pattern was observed. Optionally includes marks.
</p>


<h3>Details</h3>

<p>This class represents
a two-dimensional point pattern dataset. It specifies
</p>

<ul>
<li><p> the locations of the points
</p>
</li>
<li><p> the window in which the pattern was observed
</p>
</li>
<li><p> optionally, &ldquo;marks&rdquo; attached to each point
(extra information such as a type label).
</p>
</li></ul>

<p>If <code>X</code> is an object of type <code>ppp</code>,
it contains the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>x</code> </td><td style="text-align: left;"> vector of <code class="reqn">x</code> coordinates of data points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>y</code> </td><td style="text-align: left;"> vector of <code class="reqn">y</code> coordinates of data points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>n</code> </td><td style="text-align: left;"> number of points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>window</code> </td><td style="text-align: left;"> window of observation </td>
</tr>
<tr>
 <td style="text-align: left;">
                  </td><td style="text-align: left;"> (an object of class <code><a href="#topic+owin">owin</a></code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>marks</code> </td><td style="text-align: left;"> optional vector or data frame of marks
  </td>
</tr>

</table>

<p>Users are strongly advised not to manipulate these entries
directly.
</p>
<p>Objects of class <code>"ppp"</code>
may be created by the function
<code><a href="#topic+ppp">ppp</a></code>
and converted from other types of data by the function
<code><a href="#topic+as.ppp">as.ppp</a></code>.
Note that you must always specify the window of observation;
there is intentionally no default action of &ldquo;guessing&rdquo; the window
dimensions from the data points alone.
</p>
<p>Standard point pattern datasets provided with the package
include
<code><a href="spatstat.data.html#topic+amacrine">amacrine</a></code>,
<code><a href="spatstat.data.html#topic+betacells">betacells</a></code>,
<code><a href="spatstat.data.html#topic+bramblecanes">bramblecanes</a></code>,
<code><a href="spatstat.data.html#topic+cells">cells</a></code>,
<code><a href="spatstat.data.html#topic+demopat">demopat</a></code>,
<code><a href="spatstat.data.html#topic+ganglia">ganglia</a></code>,
<code><a href="spatstat.data.html#topic+lansing">lansing</a></code>,
<code><a href="spatstat.data.html#topic+longleaf">longleaf</a></code>,
<code><a href="spatstat.data.html#topic+nztrees">nztrees</a></code>,
<code><a href="spatstat.data.html#topic+redwood">redwood</a></code>,
<code><a href="spatstat.data.html#topic+simdat">simdat</a></code> and
<code><a href="spatstat.data.html#topic+swedishpines">swedishpines</a></code>.
</p>
<p>Point patterns may be scanned from your own data files by
<code><a href="#topic+scanpp">scanpp</a></code> or by using <code><a href="utils.html#topic+read.table">read.table</a></code> and
<code><a href="#topic+as.ppp">as.ppp</a></code>.
</p>
<p>They may be manipulated by the functions 
<code><a href="#topic++5B.ppp">[.ppp</a></code> and
<code><a href="#topic+superimpose">superimpose</a></code>.
</p>
<p>Point pattern objects can be plotted just by typing <code>plot(X)</code>
which invokes the <code>plot</code> method for point pattern objects,
<code><a href="#topic+plot.ppp">plot.ppp</a></code>. See <code><a href="#topic+plot.ppp">plot.ppp</a></code> for further information.
</p>
<p>There are also methods for <code>summary</code> and <code>print</code>
for point patterns. Use <code>summary(X)</code> to see a useful description
of the data.
</p>
<p>Patterns may be generated at random by
<code><a href="spatstat.random.html#topic+runifpoint">runifpoint</a></code>,
<code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>,
<code><a href="spatstat.random.html#topic+rMaternI">rMaternI</a></code>,
<code><a href="spatstat.random.html#topic+rMaternII">rMaternII</a></code>,
<code><a href="spatstat.random.html#topic+rSSI">rSSI</a></code>,
<code><a href="spatstat.random.html#topic+rNeymanScott">rNeymanScott</a></code>,
<code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code>,
and
<code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code>.
</p>
<p>Most functions which are intended to operate on a window
(of class <code><a href="#topic+owin">owin</a></code>)
will, if presented with a <code><a href="#topic+ppp">ppp</a></code> object instead,
automatically extract the window information from the point pattern.
</p>


<h3>Warnings</h3>

<p>The internal representation of marks is likely to change in the
next release of this package.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+ppp">ppp</a></code>,
<code><a href="#topic+as.ppp">as.ppp</a></code>,
<code><a href="#topic++5B.ppp">[.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- runif(100)
  y &lt;- runif(100)
  X &lt;- ppp(x, y, c(0,1),c(0,1))
  X
  if(human &lt;- interactive()) plot(X)
  mar &lt;- sample(1:3, 100, replace=TRUE)
  mm &lt;- ppp(x, y, c(0,1), c(0,1), marks=mar)
  if(human) plot(mm)
  # points with mark equal to 2
  ss &lt;- mm[ mm$marks == 2 , ]
  if(human) plot(ss)
  # left half of pattern 'mm'
  lu &lt;- owin(c(0,0.5),c(0,1))
  mmleft &lt;- mm[ , lu]
  if(human) plot(mmleft)
  if(FALSE) {
  # input data from file
  qq &lt;- scanpp("my.table", unit.square())
  # interactively build a point pattern
  plot(unit.square())
  X &lt;- as.ppp(locator(10), unit.square())
  plot(X)
  }
</code></pre>

<hr>
<h2 id='pppdist'>Distance Between Two Point Patterns</h2><span id='topic+pppdist'></span>

<h3>Description</h3>

<p>Given two point patterns, find the distance between them based on
optimal point matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pppdist(X, Y, type = "spa", cutoff = 1, q = 1, matching = TRUE,
    ccode = TRUE, auction = TRUE, precision = NULL, approximation = 10,
    show.rprimal = FALSE, timelag = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pppdist_+3A_x">X</code>, <code id="pppdist_+3A_y">Y</code></td>
<td>
<p>Two point patterns (objects of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="pppdist_+3A_type">type</code></td>
<td>

<p>A character string giving the type of distance to be computed.
One of <code>"spa"</code> (default), <code>"ace"</code> or <code>"mat"</code>, indicating
whether the algorithm should find the optimal matching based on
&ldquo;subpattern assignment&rdquo;,
&ldquo;assignment only if cardinalities are equal&rdquo;
or &ldquo;mass transfer&rdquo;. See Details. 
</p>
</td></tr>
<tr><td><code id="pppdist_+3A_cutoff">cutoff</code></td>
<td>

<p>The value <code class="reqn">&gt; 0</code> at which interpoint distances are cut off.
</p>
</td></tr>
<tr><td><code id="pppdist_+3A_q">q</code></td>
<td>

<p>The order of the average that is applied to the interpoint distances.
May be <code>Inf</code>, in which case the maximum of the interpoint
distances is taken.
</p>
</td></tr>
<tr><td><code id="pppdist_+3A_matching">matching</code></td>
<td>

<p>Logical. Whether to return the optimal matching or only the
associated distance.
</p>
</td></tr>
<tr><td><code id="pppdist_+3A_ccode">ccode</code></td>
<td>

<p>Logical. If <code>FALSE</code>, <span class="rlang"><b>R</b></span> code is used which allows for higher
precision, but is much slower.
</p>
</td></tr>
<tr><td><code id="pppdist_+3A_auction">auction</code></td>
<td>

<p>Logical. By default a version of Bertsekas' auction algorithm
is used to compute an optimal point matching if <code>type</code> is
either <code>"spa"</code> or <code>"ace"</code>.
If <code>auction</code> is <code>FALSE</code> (or <code>type</code> is <code>"mat"</code>)
a specialized primal-dual algorithm is used instead.
This was the standard in earlier versions
of <span class="pkg">spatstat</span>, but is several orders of magnitudes slower. 
</p>
</td></tr>
<tr><td><code id="pppdist_+3A_precision">precision</code></td>
<td>

<p>Index controlling accuracy of algorithm. The <code>q</code>-th powers of
interpoint distances will be rounded to the nearest multiple of
<code>10^(-precision)</code>. There is a sensible default which depends
on <code>ccode</code>.
</p>
</td></tr>
<tr><td><code id="pppdist_+3A_approximation">approximation</code></td>
<td>

<p>If <code>q = Inf</code>, compute distance based on the optimal matching for the
corresponding distance of order <code>approximation</code>. Can be
<code>Inf</code>, but this makes computations extremely slow.
</p>
</td></tr>
<tr><td><code id="pppdist_+3A_show.rprimal">show.rprimal</code></td>
<td>

<p>Logical. Whether to plot the progress of the primal-dual
algorithm. If <code>TRUE</code>, slow primal-dual <span class="rlang"><b>R</b></span> code is used,
regardless of the arguments <code>ccode</code> and <code>auction</code>.
</p>
</td></tr>
<tr><td><code id="pppdist_+3A_timelag">timelag</code></td>
<td>

<p>Time lag, in seconds, between successive displays of the
iterative solution of the restricted primal problem.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the distance between point patterns <code>X</code> and <code>Y</code> based
on finding the matching between them which minimizes the average of
the distances between matched points
(if <code>q=1</code>), the maximum distance between matched points
(if <code>q=Inf</code>), and in general the <code>q</code>-th order average
(i.e. the <code>1/q</code>th power of the sum of
the <code>q</code>th powers) of the distances between matched points.
Distances between matched points are Euclidean distances cut off at
the value of <code>cutoff</code>.
</p>
<p>The parameter <code>type</code> controls the behaviour of the algorithm if
the cardinalities of the point patterns are different. For the type
<code>"spa"</code> (subpattern assignment) the subpattern of the point pattern
with the larger cardinality <code class="reqn">n</code> that is closest to the point pattern
with the smaller cardinality <code class="reqn">m</code> is determined; then the <code>q</code>-th order
average is taken over <code class="reqn">n</code> values: the <code class="reqn">m</code> distances of matched points
and <code class="reqn">n-m</code> &quot;penalty distances&quot; of value <code>cutoff</code> for
the unmatched points. For the type <code>"ace"</code> (assignment only if 
cardinalities equal) the matching is empty and the distance returned is equal
to <code>cutoff</code> if the cardinalities differ. For the
type <code>"mat"</code> (mass transfer) each point pattern is assumed
to have total mass <code class="reqn">m</code> (= the smaller cardinality) distributed evenly
among its points; the algorithm finds then the &quot;mass transfer plan&quot; that
minimizes the <code>q</code>-th order weighted average of the distances, where 
the weights are given by the transferred mass divided by <code class="reqn">m</code>. The
result is a fractional matching (each match of two points has a weight
in <code class="reqn">(0,1]</code>) with the minimized quantity as the associated distance.
</p>
<p>The central problem to be solved is the assignment problem (for types
<code>"spa"</code> and <code>"ace"</code>) or the more general transport problem
(for type <code>"mat"</code>). Both are well-known problems in discrete
optimization, see e.g. Luenberger (2003). 
</p>
<p>For the assignment problem <code>pppdist</code> uses by default the
forward/backward version of Bertsekas' auction algorithm with
automated epsilon scaling; see Bertsekas (1992). The implemented
version gives good overall performance and can handle point patterns
with several thousand points. 
</p>
<p>For the transport problem a specialized primal-dual algorithm is
employed; see Luenberger (2003), Section 5.9. The C implementation
used by default can handle patterns with a few hundreds of points, but
should not be used with thousands of points. By setting
<code>show.rprimal = TRUE</code>, some insight in the working of the
algorithm can be gained. 
</p>
<p>For a broader selection of optimal transport algorithms that are not
restricted to spatial point patterns and allow for additional fine
tuning, we recommend the <span class="rlang"><b>R</b></span> package <span class="pkg">transport</span>. 
</p>
<p>For moderate and large values of <code>q</code> there can be numerical
issues based on the fact that the <code>q</code>-th powers of distances are
taken and some positive values enter the optimization algorithm as
zeroes because they are too small in comparison with the larger
values. In this case the number of zeroes introduced is given in a
warning message, and it is possible then that the matching obtained is
not optimal and the associated distance is only a strict upper bound
of the true distance. As a general guideline (which can be very wrong
in special situations) a small number of zeroes (up to about 50% of
the smaller point pattern cardinality <code class="reqn">m</code>) usually still results
in the right matching, and the number can even be quite a bit higher
and usually still provides a highly accurate upper bound for the
distance. These numerical problems can be reduced by enforcing (much
slower) <span class="rlang"><b>R</b></span> code via the argument <code>ccode = FALSE</code>. 
</p>
<p>For <code>q = Inf</code> there is no fast algorithm available, which is why
approximation is normally used: for finding the optimal matching,
<code>q</code> is set to the value of <code>approximation</code>. The
resulting distance is still given as the maximum rather than the
<code>q</code>-th order average in the corresponding distance computation.
If <code>approximation = Inf</code>, approximation is suppressed and a very
inefficient exhaustive search for the best matching is performed.
</p>
<p>The value of <code>precision</code> should normally not be supplied by the
user. If <code>ccode = TRUE</code>, this value is preset to the highest
exponent of 10 that the C code still can handle (usually <code class="reqn">9</code>). If
<code>ccode = FALSE</code>, the value is preset according to <code>q</code>
(usually <code class="reqn">15</code> if <code>q</code> is small), which can sometimes be
changed to obtain less severe warning messages. 
</p>


<h3>Value</h3>

<p>Normally an object of class <code>pppmatching</code> that contains detailed
information about the parameters used and the resulting distance.
See <code><a href="#topic+pppmatching.object">pppmatching.object</a></code> for details.
If <code>matching = FALSE</code>, only the numerical value of the distance
is returned.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a>, URL <code>http://dominic.schuhmacher.name/</code>.
</p>


<h3>References</h3>

<p>Bertsekas, D.P. (1992).
Auction algorithms for network flow problems: a tutorial introduction.
Computational Optimization and Applications 1, 7-66.
</p>
<p>Luenberger, D.G. (2003). <em>Linear and nonlinear programming.</em>
Second edition. Kluwer.
</p>
<p>Schuhmacher, D. (2014).
<em>transport: optimal transport in various forms.</em>
R package version 0.6-2 (or later)
</p>
<p>Schuhmacher, D. and Xia, A. (2008).
A new metric between distributions of point processes.
<em>Advances in Applied Probability</em> <b>40</b>, 651&ndash;672
</p>
<p>Schuhmacher, D., Vo, B.-T. and Vo, B.-N. (2008).
A consistent metric for performance evaluation of multi-object
filters.
<em>IEEE Transactions on Signal Processing</em> <b>56</b>, 3447&ndash;3457.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pppmatching.object">pppmatching.object</a></code>, <code><a href="#topic+matchingdist">matchingdist</a></code>,
<code><a href="#topic+plot.pppmatching">plot.pppmatching</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># equal cardinalities
set.seed(140627)
X &lt;- runifrect(500)
Y &lt;- runifrect(500)
m &lt;- pppdist(X, Y)
m
if(interactive()) {
plot(m)}
  
# differing cardinalities
X &lt;- runifrect(14)
Y &lt;- runifrect(10)
m1 &lt;- pppdist(X, Y, type="spa")
m2 &lt;- pppdist(X, Y, type="ace")
m3 &lt;- pppdist(X, Y, type="mat", auction=FALSE)
summary(m1)
summary(m2)
summary(m3)
if(interactive()) {
m1$matrix
m2$matrix
m3$matrix}

# q = Inf
X &lt;- runifrect(10)
Y &lt;- runifrect(10)
mx1 &lt;- pppdist(X, Y, q=Inf, matching=FALSE)
mx2 &lt;- pppdist(X, Y, q=Inf, matching=FALSE, ccode=FALSE, approximation=50)
mx3 &lt;- pppdist(X, Y, q=Inf, matching=FALSE, approximation=Inf)
all.equal(mx1,mx2,mx3)
# sometimes TRUE
all.equal(mx2,mx3)
# very often TRUE
</code></pre>

<hr>
<h2 id='pppmatching'>Create a Point Matching</h2><span id='topic+pppmatching'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"pppmatching"</code> representing
a matching of two planar point patterns (objects of class <code>"ppp"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pppmatching(X, Y, am, type = NULL, cutoff = NULL, q = NULL,
    mdist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pppmatching_+3A_x">X</code>, <code id="pppmatching_+3A_y">Y</code></td>
<td>
<p>Two point patterns (objects of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="pppmatching_+3A_am">am</code></td>
<td>

<p>An <code>npoints(X)</code> by <code>npoints(Y)</code> matrix with entries <code class="reqn">\geq 0</code> 
that specifies which points are matched and with what weight;
alternatively, an object that can be coerced to this form
by <code>as.matrix</code>.
</p>
</td></tr>
<tr><td><code id="pppmatching_+3A_type">type</code></td>
<td>

<p>A character string giving the type of the matching.
One of <code>"spa"</code>, <code>"ace"</code> or <code>"mat"</code>, or <code>NULL</code>
for a generic or unknown matching.
</p>
</td></tr>
<tr><td><code id="pppmatching_+3A_cutoff">cutoff</code>, <code id="pppmatching_+3A_q">q</code></td>
<td>

<p>Numerical values specifying the cutoff value <code class="reqn">&gt; 0</code> for interpoint distances and
the order <code class="reqn">q \in [1,\infty]</code> of the average that is applied to them.
<code>NULL</code> if not applicable or unknown.
</p>
</td></tr>
<tr><td><code id="pppmatching_+3A_mdist">mdist</code></td>
<td>

<p>Numerical value for the distance to be associated with the matching.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>am</code> is interpreted as a &quot;generalized adjacency matrix&quot;:
if the <code>[i,j]</code>-th entry is positive, then the <code>i</code>-th point
of <code>X</code> and the <code>j</code>-th point of <code>Y</code> are matched and the
value of the entry gives the corresponding weight of the match. For
an unweighted matching all the weights should be set to <code class="reqn">1</code>.
</p>
<p>The remaining arguments are optional and allow to save
additional information about the matching. See the help files for
<code><a href="#topic+pppdist">pppdist</a></code> and <code><a href="#topic+matchingdist">matchingdist</a></code> for details on
the meaning of these parameters.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a>, URL <code>http://dominic.schuhmacher.name/</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pppmatching.object">pppmatching.object</a></code>
<code><a href="#topic+matchingdist">matchingdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # a random unweighted complete matching
  X &lt;- runifrect(10)
  Y &lt;- runifrect(10)
  am &lt;- r2dtable(1, rep(1,10), rep(1,10))[[1]]
        # generates a random permutation matrix
  m &lt;- pppmatching(X, Y, am)
  summary(m)
  m$matrix
  plot(m)

  # a random weighted complete matching
  X &lt;- runifrect(7)
  Y &lt;- runifrect(7)
  am &lt;- r2dtable(1, rep(10,7), rep(10,7))[[1]]/10
        # generates a random doubly stochastic matrix
  m2 &lt;- pppmatching(X, Y, am)
  summary(m2)
  m2$matrix
  plot(m2)
  m3 &lt;- pppmatching(X, Y, am, "ace")
  m4 &lt;- pppmatching(X, Y, am, "mat")
</code></pre>

<hr>
<h2 id='pppmatching.object'>Class of Point Matchings</h2><span id='topic+pppmatching.object'></span>

<h3>Description</h3>

<p>A class <code>"pppmatching"</code> to represent a matching of two planar
point patterns.
Optionally includes information about the construction of the matching
and its associated distance between the point patterns.
</p>


<h3>Details</h3>

<p>This class represents a (possibly weighted and incomplete) matching
between two planar point patterns (objects of class <code>"ppp"</code>).
</p>
<p>A matching can be thought of as a bipartite weighted graph where
the vertices are given by the two point patterns and edges of positive
weights are drawn each time a point of the first point pattern is
&quot;matched&quot; with a point of the second point pattern.
</p>
<p>If <code>m</code> is an object of type <code>pppmatching</code>, it contains the
following elements
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>pp1, pp2</code> </td><td style="text-align: left;"> the two point patterns to be matched (vertices) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>matrix</code> </td><td style="text-align: left;"> a matrix specifying which points are matched </td>
</tr>
<tr>
 <td style="text-align: left;">
                  </td><td style="text-align: left;"> and with what weights (edges) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>type</code> </td><td style="text-align: left;"> (optional) a character string for the type of </td>
</tr>
<tr>
 <td style="text-align: left;">
                 </td><td style="text-align: left;"> the matching (one of <code>"spa"</code>, <code>"ace"</code> or <code>"mat"</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>cutoff</code> </td><td style="text-align: left;"> (optional) cutoff value for interpoint distances </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>q</code> </td><td style="text-align: left;"> (optional) the order for taking averages of </td>
</tr>
<tr>
 <td style="text-align: left;">
             </td><td style="text-align: left;"> interpoint distances </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>distance</code> </td><td style="text-align: left;"> (optional) the distance associated with the matching
  </td>
</tr>

</table>

<p>The element <code>matrix</code> is a &quot;generalized adjacency matrix&quot;.
The numbers of rows
and columns match the cardinalities of the first and second point
patterns, respectively. The <code>[i,j]</code>-th entry is positive if
the <code>i</code>-th point of <code>X</code> and the <code>j</code>-th point of
<code>Y</code> are matched (zero otherwise) and its value then gives
the corresponding weight of the match. For an unweighted matching
all the weights are set to <code class="reqn">1</code>.
</p>
<p>The optional elements are for saving details about matchings in the context of
optimal point matching techniques. <code>type</code> can be one of <code>"spa"</code> (for
&quot;subpattern assignment&quot;), <code>"ace"</code> (for &quot;assignment only if
cardinalities differ&quot;) or <code>"mat"</code> (for &quot;mass transfer&quot;). <code>cutoff</code>
is a positive numerical value that specifies the maximal interpoint distance and
<code>q</code> is a value in <code class="reqn">[1,\infty]</code> that gives the order of the average
applied to the interpoint distances. See the help files for <code><a href="#topic+pppdist">pppdist</a></code>
and <code><a href="#topic+matchingdist">matchingdist</a></code> for detailed information about these elements.
</p>
<p>Objects of class <code>"pppmatching"</code> may be created by the function 
<code><a href="#topic+pppmatching">pppmatching</a></code>, and are most commonly obtained as output of the
function <code><a href="#topic+pppdist">pppdist</a></code>. There are methods <code>plot</code>, <code>print</code> and
<code>summary</code> for this class.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a>, URL <code>http://dominic.schuhmacher.name/</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchingdist">matchingdist</a></code>,
<code><a href="#topic+pppmatching">pppmatching</a></code>,
<code><a href="#topic+plot.pppmatching">plot.pppmatching</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # a random complete unweighted matching
  X &lt;- runifrect(10)
  Y &lt;- runifrect(10)
  am &lt;- r2dtable(1, rep(1,10), rep(1,10))[[1]]
        # generates a random permutation matrix
  m &lt;- pppmatching(X, Y, am)
  summary(m)
  m$matrix
  if(interactive()) {
    plot(m)
  }

  # an optimal complete unweighted matching
  m2 &lt;- pppdist(X,Y)
  summary(m2)
  m2$matrix
  if(interactive()) {
    plot(m2)
  }
</code></pre>

<hr>
<h2 id='ppx'>
Multidimensional Space-Time Point Pattern
</h2><span id='topic+ppx'></span>

<h3>Description</h3>

<p>Creates a multidimensional space-time point pattern
with any kind of coordinates and marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppx(data, domain=NULL, coord.type=NULL, simplify=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppx_+3A_data">data</code></td>
<td>

<p>The coordinates and marks of the points.
A <code>data.frame</code> or <code>hyperframe</code>.
</p>
</td></tr>
<tr><td><code id="ppx_+3A_domain">domain</code></td>
<td>

<p>Optional. The space-time domain containing the points.
An object in some appropriate format, or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="ppx_+3A_coord.type">coord.type</code></td>
<td>

<p>Character vector specifying how each column of
<code>data</code> should be interpreted: as a spatial coordinate,
a temporal coordinate, a local coordinate or a mark.
Entries are partially matched to the values
<code>"spatial"</code>,
<code>"temporal"</code>,
<code>"local"</code> and
<code>"mark"</code>.
</p>
</td></tr>
<tr><td><code id="ppx_+3A_simplify">simplify</code></td>
<td>

<p>Logical value indicating whether to simplify the result
in special cases.
If <code>simplify=TRUE</code>, a two-dimensional point pattern
will be returned as an object of class <code>"ppp"</code>,
and a three-dimensional point pattern will be returned as
an object of class <code>"pp3"</code>.
If <code>simplify=FALSE</code> (the default) then the result is always
an object of class <code>"ppx"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"ppx"</code>
represents a marked point pattern
in multidimensional space and/or time. There may be any
number of spatial coordinates, any number of temporal coordinates,
any number of local coordinates,
and any number of mark variables. The individual marks may be
atomic (numeric values, factor values, etc) or objects of any kind.
</p>
<p>The argument <code>data</code> should contain the coordinates and marks of
the points. It should be a <code>data.frame</code> or more generally a
<code>hyperframe</code> (see <code><a href="#topic+hyperframe">hyperframe</a></code>) with
one row of data for each point.
</p>
<p>Each column of <code>data</code> is either
a spatial coordinate, a temporal coordinate,
a local coordinate, or a mark variable.
The argument <code>coord.type</code> determines how each column is interpreted.
It should be a character vector, of length equal to the number of
columns of <code>data</code>. It should contain strings that partially match
the values <code>"spatial"</code>, <code>"temporal"</code>, <code>"local"</code> and
<code>"mark"</code>. (The first letters will be sufficient.)
</p>
<p>By default (if <code>coord.type</code> is missing or <code>NULL</code>),
columns of numerical data are assumed to represent
spatial coordinates, while other columns are assumed to be marks.
</p>


<h3>Value</h3>

<p>Usually an object of class <code>"ppx"</code>.
If <code>simplify=TRUE</code> the result may be an object of
class <code>"ppp"</code> or <code>"pp3"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp3">pp3</a></code>,
<code><a href="#topic+print.ppx">print.ppx</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   df &lt;- data.frame(x=runif(4),y=runif(4),t=runif(4),
                    age=rep(c("old", "new"), 2),
                    size=runif(4))
   X &lt;- ppx(data=df, coord.type=c("s","s","t","m","m"))
   X

   #' one-dimensional points
   #' with marks which are two-dimensional point patterns
   val &lt;- sample(10:20, 4)
   E &lt;- lapply(val, runifrect)
   E
   hf &lt;- hyperframe(num=val, e=as.listof(E))
   Z &lt;- ppx(data=hf, domain=c(10,20))
   Z
</code></pre>

<hr>
<h2 id='print.im'>Print Brief Details of an Image</h2><span id='topic+print.im'></span>

<h3>Description</h3>

<p>Prints a very brief description of a pixel image object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.im_+3A_x">x</code></td>
<td>
<p>Pixel image (object of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="print.im_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A very brief description of the pixel image <code>x</code> is printed.
</p>
<p>This is a method for the generic function <code><a href="base.html#topic+print">print</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>,
<code><a href="#topic+im.object">im.object</a></code>,
<code><a href="#topic+summary.im">summary.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  U &lt;- as.im(letterR)
  U
</code></pre>

<hr>
<h2 id='print.owin'>Print Brief Details of a Spatial Window</h2><span id='topic+print.owin'></span>

<h3>Description</h3>

<p>Prints a very brief description of a window object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'owin'
print(x, ..., prefix="window: ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.owin_+3A_x">x</code></td>
<td>
<p>Window (object of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="print.owin_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="print.owin_+3A_prefix">prefix</code></td>
<td>
<p>Character string to be printed at the start of the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A very brief description of the window <code>x</code> is printed.
</p>
<p>This is a method for the generic function <code><a href="base.html#topic+print">print</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>,
<code><a href="#topic+print.ppp">print.ppp</a></code>,
<code><a href="#topic+summary.owin">summary.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  owin()  # the unit square

  W &lt;- Window(demopat)
  W                    # just says it is polygonal
  as.mask(W)           # just says it is a binary image 

</code></pre>

<hr>
<h2 id='print.ppp'>Print Brief Details of a Point Pattern Dataset</h2><span id='topic+print.ppp'></span>

<h3>Description</h3>

<p>Prints a very brief description of a point pattern dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ppp_+3A_x">x</code></td>
<td>
<p>Point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="print.ppp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A very brief description of the point pattern <code>x</code> is printed.
</p>
<p>This is a method for the generic function <code><a href="base.html#topic+print">print</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>,
<code><a href="#topic+print.owin">print.owin</a></code>,
<code><a href="#topic+summary.ppp">summary.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  cells      # plain vanilla point pattern

  lansing    # multitype point pattern
  
  longleaf    # numeric marks

  demopat     # weird polygonal window
</code></pre>

<hr>
<h2 id='print.psp'>Print Brief Details of a Line Segment Pattern Dataset</h2><span id='topic+print.psp'></span>

<h3>Description</h3>

<p>Prints a very brief description of a line segment pattern dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'psp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.psp_+3A_x">x</code></td>
<td>
<p>Line segment pattern (object of class <code>"psp"</code>).</p>
</td></tr>
<tr><td><code id="print.psp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A very brief description of the line segment pattern <code>x</code> is printed.
</p>
<p>This is a method for the generic function <code><a href="base.html#topic+print">print</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>,
<code><a href="#topic+print.owin">print.owin</a></code>,
<code><a href="#topic+summary.psp">summary.psp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  a
</code></pre>

<hr>
<h2 id='print.quad'>Print a Quadrature Scheme</h2><span id='topic+print.quad'></span>

<h3>Description</h3>

<p><code>print</code> method for a quadrature scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'quad'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.quad_+3A_x">x</code></td>
<td>

<p>A quadrature scheme object, typically obtained from
<code><a href="#topic+quadscheme">quadscheme</a></code>.
An object of class <code>"quad"</code>.
</p>
</td></tr>
<tr><td><code id="print.quad_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>print</code> method for the class <code>"quad"</code>.
It prints simple information about the quadrature scheme.
</p>
<p>See <code><a href="#topic+quad.object">quad.object</a></code> for details of the class <code>"quad"</code>.
</p>


<h3>Value</h3>

<p>none.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadscheme">quadscheme</a></code>,
<code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="#topic+plot.quad">plot.quad</a></code>,
<code><a href="#topic+summary.quad">summary.quad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Q &lt;- quadscheme(cells)
 Q
</code></pre>

<hr>
<h2 id='progressreport'>Print Progress Reports</h2><span id='topic+progressreport'></span>

<h3>Description</h3>

<p>Prints Progress Reports during a loop or iterative calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progressreport(i, n,
               every = min(100,max(1, ceiling(n/100))),
               tick = 1,
               nperline = NULL,
               charsperline = getOption("width"),
               style = spatstat.options("progress"),
               showtime = NULL,
               state=NULL,
               formula = (time ~ i),
               savehistory=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="progressreport_+3A_i">i</code></td>
<td>

<p>Integer. The current iteration number (from 1 to <code>n</code>).
</p>
</td></tr>
<tr><td><code id="progressreport_+3A_n">n</code></td>
<td>

<p>Integer. The (maximum) number of iterations to be computed.
</p>
</td></tr>
<tr><td><code id="progressreport_+3A_every">every</code></td>
<td>

<p>Optional integer. Iteration number will be printed 
when <code>i</code> is a multiple of <code>every</code>.
</p>
</td></tr>
<tr><td><code id="progressreport_+3A_tick">tick</code></td>
<td>

<p>Optional integer. A tick mark or dot will be printed
when <code>i</code> is a multiple of <code>tick</code>.
</p>
</td></tr>
<tr><td><code id="progressreport_+3A_nperline">nperline</code></td>
<td>

<p>Optional integer. Number of iterations per line of output.
</p>
</td></tr>
<tr><td><code id="progressreport_+3A_charsperline">charsperline</code></td>
<td>

<p>Optional integer. The number of characters in a line of output.
</p>
</td></tr>
<tr><td><code id="progressreport_+3A_style">style</code></td>
<td>

<p>Character string determining the style of display.
Options are <code>"tty"</code> (the default), <code>"tk"</code> and <code>"txtbar"</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="progressreport_+3A_showtime">showtime</code></td>
<td>

<p>Optional. Logical value indicating whether to print the estimated
time remaining. Applies only when <code>style="tty"</code>.
</p>
</td></tr>
<tr><td><code id="progressreport_+3A_state">state</code></td>
<td>

<p>Optional. A list containing the internal data.
</p>
</td></tr>
<tr><td><code id="progressreport_+3A_formula">formula</code></td>
<td>

<p>Optional. A model formula expressing the expected relationship between
the iteration number <code>i</code> and the clock time <code>time</code>. Used for
predicting the time remaining. 
</p>
</td></tr>
<tr><td><code id="progressreport_+3A_savehistory">savehistory</code></td>
<td>

<p>Optional. Logical value indicating whether to save the 
elapsed times at which <code>progressreport</code> was called.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenient function for reporting progress
during an iterative sequence of calculations
or a suite of simulations.
</p>

<ul>
<li> 
<p>If <code>style="tk"</code> then <code>tcltk::tkProgressBar</code> is
used to pop-up a new graphics window showing a progress bar.
This requires the package <span class="pkg">tcltk</span>.
As <code>i</code> increases from 1 to <code>n</code>, the bar will lengthen.
The arguments <code>every, tick, nperline, showtime</code> are ignored.
</p>
</li>
<li> 
<p>If <code>style="txtbar"</code> then <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> is
used to represent progress as a bar made of text characters in the
<span class="rlang"><b>R</b></span> interpreter window.
As <code>i</code> increases from 1 to <code>n</code>, the bar will lengthen.
The arguments <code>every, tick, nperline, showtime</code> are ignored.
</p>
</li>
<li> 
<p>If <code>style="tty"</code> (the default),
then progress reports are printed to the
console. This only seems to work well under Linux.
As <code>i</code> increases from 1 to <code>n</code>, 
the output will be a sequence of dots (one dot for every <code>tick</code>
iterations), iteration numbers (printed when iteration number is
a multiple of <code>every</code> or is less than 4),
and optionally the estimated time remaining
and the estimated completion time.
</p>
<p>The estimated time remaining will be printed only if
<code>style="tty"</code>, and the argument <code>state</code> is given,
and either <code>showtime=TRUE</code>, or <code>showtime=NULL</code> and the
iterations are slow (defined as: the estimated time remaining
is longer than 3 minutes, or the average time per iteration is
longer than 20 seconds).
</p>
<p>The estimated completion time will be printed only if the
estimated time remaining is printed and the remaining time is
longer than 10 minutes.
</p>
<p>By default, the estimated time remaining is calculated 
by assuming that each iteration takes the same amount of time,
and extrapolating.
Alternatively, if the argument <code>formula</code> is given,
then it should be a model formula, stating the expected relationship
between the iteration number <code>i</code> and the clock time
<code>time</code>. This model will be fitted to the history of clock times
recorded so far, and used to predict the time remaining.
(The default formula states that clock time is a linear function of the
iteration number, which is equivalent to assuming that each
iteration takes the same amount of time.)
</p>
</li></ul>

<p>It is optional, but strongly advisable, to use the argument <code>state</code>
to store and update the internal data for the progress reports
(such as the cumulative time taken for computation)
as shown in the last example below.
This avoids conflicts with other programs that might be
calling <code>progressreport</code> at the same time.
</p>


<h3>Value</h3>

<p>If <code>state</code> was <code>NULL</code>, the result is <code>NULL</code>.
Otherwise the result is the updated value of <code>state</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  for(i in 1:40) {
     #
     # code that does something...
     # 
     progressreport(i, 40)
  }

  # saving internal state: *recommended*
  sta &lt;- list()
  for(i in 1:20) {
     # some code ...
     sta &lt;- progressreport(i, 20, state=sta)
  }

  #' use text progress bar
  sta &lt;- list()
  for(i in 1:10) {
     # some code ...
     sta &lt;- progressreport(i, 10, state=sta, style="txtbar")
  }

</code></pre>

<hr>
<h2 id='project2segment'>Move Point To Nearest Line</h2><span id='topic+project2segment'></span>

<h3>Description</h3>

<p>Given a point pattern and a line segment pattern,
this function moves each point to the closest location
on a line segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project2segment(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project2segment_+3A_x">X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="project2segment_+3A_y">Y</code></td>
<td>
<p>A line segment pattern (object of class <code>"psp"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each point <code>x</code> in the point pattern <code>X</code>, this function
finds the closest line segment <code>y</code> in the line segment pattern
<code>Y</code>. It then &lsquo;projects&rsquo; the point <code>x</code> onto the line segment
<code>y</code> by finding the position <code>z</code> along <code>y</code>
which is closest to <code>x</code>. This position <code>z</code> is returned,
along with supplementary information.
</p>


<h3>Value</h3>

<p>A list with the following components. Each component has length equal to
the number of points in <code>X</code>, and its entries correspond to the
points of <code>X</code>.
</p>
<table>
<tr><td><code>Xproj</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>
containing the projected points.
</p>
</td></tr>
<tr><td><code>mapXY</code></td>
<td>

<p>Integer vector identifying the nearest segment to each point.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>Numeric vector of distances from each point of <code>X</code> to
the corresponding projected point.
</p>
</td></tr>
<tr><td><code>tp</code></td>
<td>

<p>Numeric vector giving the scaled parametric coordinate 
<code class="reqn">0 \le t_p \le 1</code> of the position of the projected point
along the segment.
</p>
</td></tr>
</table>
<p>For example suppose <code>mapXY[2] = 5</code> and <code>tp[2] = 0.33</code>.
Then <code>Y[5]</code> is the line segment lying closest to <code>X[2]</code>.
The projection of the point <code>X[2]</code> onto the segment <code>Y[5]</code>
is the point <code>Xproj[2]</code>, which lies one-third of the way
between the first and second endpoints of the line segment <code>Y[5]</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nearestsegment">nearestsegment</a></code> for a faster way to determine
which segment is closest to each point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rsyst(square(1), nx=5)
  Y &lt;- as.psp(matrix(runif(20), 5, 4), window=owin())
  plot(Y, lwd=3, col="green")
  plot(X, add=TRUE, col="red", pch=16)
  v &lt;- project2segment(X,Y)
  Xproj &lt;- v$Xproj
  plot(Xproj, add=TRUE, pch=16)
  arrows(X$x, X$y, Xproj$x, Xproj$y, angle=10, length=0.15, col="red")
</code></pre>

<hr>
<h2 id='project2set'>
Find Nearest Point in a Region
</h2><span id='topic+project2set'></span>

<h3>Description</h3>

<p>For each data point in a point pattern <code>X</code>,
find the nearest location in a given spatial region <code>W</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  project2set(X, W, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project2set_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="project2set_+3A_w">W</code></td>
<td>

<p>Window (object of class <code>"owin"</code>)
or something acceptable to <code><a href="#topic+as.owin">as.owin</a></code>.
</p>
</td></tr>
<tr><td><code id="project2set_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> controlling the
pixel resolution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The window <code>W</code> is first discretised as a binary mask
using <code><a href="#topic+as.mask">as.mask</a></code>.
</p>
<p>For each data point <code>X[i]</code> in the point pattern <code>X</code>,
the algorithm finds the nearest pixel in <code>W</code>.
</p>
<p>The result is a point pattern <code>Y</code> containing these nearest points,
that is, <code>Y[i]</code> is the nearest point in <code>W</code> to the
point <code>X[i]</code>.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>) with the same
number of points as <code>X</code> in the window <code>W</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+project2segment">project2segment</a></code>,
<code><a href="#topic+nncross">nncross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  He &lt;- heather$fine[owin(c(2.8, 7.4), c(4.0, 7.8))]
  plot(He, main="project2set")
  W &lt;- erosion(complement.owin(He), 0.2)
if(require(spatstat.random)) {
  X &lt;- runifpoint(4, W)
} else {
  X &lt;- ppp(c(6.1, 4.3, 5.7, 4.7), c(5.0, 6.6, 7.5, 4.9), window=W)
}
  points(X, col="red")
  Y &lt;- project2set(X, He)
  points(Y, col="green")
  arrows(X$x, X$y, Y$x, Y$y, angle=15, length=0.2)
</code></pre>

<hr>
<h2 id='psp'>Create a Line Segment Pattern</h2><span id='topic+psp'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"psp"</code> representing 
a line segment pattern in the two-dimensional plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  psp(x0,y0, x1, y1, window, marks=NULL,
        check=spatstat.options("checksegments"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psp_+3A_x0">x0</code></td>
<td>
<p>Vector of <code class="reqn">x</code> coordinates of first endpoint of each segment</p>
</td></tr>
<tr><td><code id="psp_+3A_y0">y0</code></td>
<td>
<p>Vector of <code class="reqn">y</code> coordinates of first endpoint of each segment</p>
</td></tr>
<tr><td><code id="psp_+3A_x1">x1</code></td>
<td>
<p>Vector of <code class="reqn">x</code> coordinates of second endpoint of each segment</p>
</td></tr>
<tr><td><code id="psp_+3A_y1">y1</code></td>
<td>
<p>Vector of <code class="reqn">y</code> coordinates of second endpoint of each segment</p>
</td></tr>
<tr><td><code id="psp_+3A_window">window</code></td>
<td>
<p>window of observation,
an object of class <code>"owin"</code></p>
</td></tr>
<tr><td><code id="psp_+3A_marks">marks</code></td>
<td>
<p>(optional) vector or data frame of mark values</p>
</td></tr>
<tr><td><code id="psp_+3A_check">check</code></td>
<td>
<p>Logical value indicating whether to check that the line segments
lie inside the window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the <span class="pkg">spatstat</span> library, a spatial pattern of line segments is
described by an object of class <code>"psp"</code>. This function
creates such objects.
</p>
<p>The vectors <code>x0</code>, <code>y0</code>, <code>x1</code> and <code>y1</code> must be
numeric vectors of equal length. They are interpreted as the cartesian
coordinates of the endpoints of the line segments.
</p>
<p>A line segment pattern is assumed to have been observed within a specific
region of the plane called the observation window.
An object of class <code>"psp"</code> representing a point pattern
contains information specifying the observation window.
This window must always be specified when creating a point pattern dataset;
there is intentionally no default action of &ldquo;guessing&rdquo; the window
dimensions from the data points alone. 
</p>
<p>The argument <code>window</code> must be an object of class
<code>"owin"</code>. It is a full description of the window geometry,
and could have been obtained from <code><a href="#topic+owin">owin</a></code> or
<code><a href="#topic+as.owin">as.owin</a></code>, or by just extracting the observation window
of another dataset, or by manipulating such windows.
See <code><a href="#topic+owin">owin</a></code> or the Examples below.
</p>
<p>The optional argument <code>marks</code> is given if the line segment pattern
is marked, i.e. if each line segment carries additional information.
For example, line segments which are classified into two or more different
types, or colours, may be regarded as having a mark which identifies
which colour they are. 
</p>
<p>The object <code>marks</code> must be a vector of the same length
as <code>x0</code>, or a data frame with number of rows equal to the
length of <code>x0</code>.  The interpretation is that <code>marks[i]</code>
or <code>marks[i,]</code> is the mark attached to the <code class="reqn">i</code>th line
segment.  If the marks are real numbers then <code>marks</code> should
be a numeric vector, while if the marks takes only a finite number
of possible values (e.g. colours or types) then <code>marks</code>
should be a <code>factor</code>.
</p>
<p>See <code><a href="#topic+psp.object">psp.object</a></code> for a description of the class
<code>"psp"</code>.
</p>
<p>Users would normally invoke <code>psp</code> to create a line segment pattern,
and the function <code><a href="#topic+as.psp">as.psp</a></code> to convert data in another
format into a line segment pattern.
</p>


<h3>Value</h3>

<p>An object of class <code>"psp"</code> 
describing a line segment pattern in the two-dimensional plane
(see <code><a href="#topic+psp.object">psp.object</a></code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp.object">psp.object</a></code>,
<code><a href="#topic+as.psp">as.psp</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>.
</p>
<p>Function for extracting information from a segment pattern:
<code><a href="#topic+marks.psp">marks.psp</a></code>,
<code><a href="#topic+summary.psp">summary.psp</a></code>,
<code><a href="#topic+midpoints.psp">midpoints.psp</a></code>,
<code><a href="#topic+lengths_psp">lengths_psp</a></code>
<code><a href="#topic+angles.psp">angles.psp</a></code>,
<code><a href="#topic+endpoints.psp">endpoints.psp</a></code>
</p>
<p>Convert line segments to infinite lines: <code><a href="#topic+extrapolate.psp">extrapolate.psp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  m &lt;- data.frame(A=1:10, B=letters[1:10])
  X &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin(), marks=m)
</code></pre>

<hr>
<h2 id='psp.object'>Class of Line Segment Patterns</h2><span id='topic+psp.object'></span>

<h3>Description</h3>

<p>A class <code>"psp"</code> to represent a spatial pattern of
line segments in the plane.
Includes information about the window in which the
pattern was observed. Optionally includes marks.
</p>


<h3>Details</h3>

<p>An object of this class represents 
a two-dimensional pattern of line segments. It specifies
</p>

<ul>
<li><p> the locations of the line segments (both endpoints)
</p>
</li>
<li><p> the window in which the pattern was observed
</p>
</li>
<li><p> optionally, a &ldquo;mark&rdquo; attached to each line segment
(extra information such as a type label).
</p>
</li></ul>

<p>If <code>X</code> is an object of type <code>psp</code>,
it contains the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>ends</code> </td><td style="text-align: left;"> data frame with entries <code>x0, y0, x1, y1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
                </td><td style="text-align: left;"> giving coordinates of segment endpoints </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>window</code> </td><td style="text-align: left;"> window of observation </td>
</tr>
<tr>
 <td style="text-align: left;">
                  </td><td style="text-align: left;"> (an object of class <code><a href="#topic+owin">owin</a></code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>n</code> </td><td style="text-align: left;"> number of line segments </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>marks</code> </td><td style="text-align: left;"> optional vector or data frame of marks </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>markformat</code> </td><td style="text-align: left;"> character string specifying the format of the </td>
</tr>
<tr>
 <td style="text-align: left;">
                      </td><td style="text-align: left;"> marks; &ldquo;none&rdquo;, &ldquo;vector&rdquo;, or
                      &ldquo;dataframe&rdquo;
  </td>
</tr>

</table>

<p>Users are strongly advised not to manipulate these entries
directly.
</p>
<p>Objects of class <code>"psp"</code>
may be created by the function
<code><a href="#topic+psp">psp</a></code>
and converted from other types of data by the function
<code><a href="#topic+as.psp">as.psp</a></code>.
Note that you must always specify the window of observation;
there is intentionally no default action of &ldquo;guessing&rdquo; the window
dimensions from the line segments alone.
</p>
<p>Subsets of a line segment pattern may be obtained by the functions
<code><a href="#topic++5B.psp">[.psp</a></code> and <code><a href="#topic+clip.psp">clip.psp</a></code>.
</p>
<p>Line segment pattern objects can be plotted just by typing <code>plot(X)</code>
which invokes the <code>plot</code> method for line segment pattern objects,
<code><a href="#topic+plot.psp">plot.psp</a></code>. See <code><a href="#topic+plot.psp">plot.psp</a></code> for further information.
</p>
<p>There are also methods for <code>summary</code> and <code>print</code>
for line segment patterns. Use <code>summary(X)</code> to see a useful description
of the data.
</p>
<p>Utilities for line segment patterns include
<code><a href="#topic+midpoints.psp">midpoints.psp</a></code> (to compute the midpoints of each segment),
<code><a href="#topic+lengths_psp">lengths_psp</a></code>, (to compute the length of each segment),
<code><a href="#topic+angles.psp">angles.psp</a></code>, (to compute the angle of orientation of
each segment), and 
<code><a href="#topic+distmap.psp">distmap.psp</a></code> to compute the distance map of a
line segment pattern.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp">psp</a></code>,
<code><a href="#topic+as.psp">as.psp</a></code>,
<code><a href="#topic++5B.psp">[.psp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating 
    a &lt;- psp(runif(20),runif(20),runif(20),runif(20), window=owin())
# converting from other formats
    a &lt;- as.psp(matrix(runif(80), ncol=4), window=owin())
    a &lt;- as.psp(data.frame(x0=runif(20), y0=runif(20),
                            x1=runif(20), y1=runif(20)), window=owin())
# clipping
    w &lt;- owin(c(0.1,0.7), c(0.2, 0.8))
    b &lt;- clip.psp(a, w)
    b &lt;- a[w]
# the last two lines are equivalent.
</code></pre>

<hr>
<h2 id='psp2mask'>
Convert Line Segment Pattern to Binary Pixel Mask
</h2><span id='topic+psp2mask'></span><span id='topic+as.mask.psp'></span>

<h3>Description</h3>

<p>Converts a line segment pattern to a binary pixel mask
by determining which pixels intersect the lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psp2mask(x, W=NULL, ...)
as.mask.psp(x, W=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psp2mask_+3A_x">x</code></td>
<td>

<p>Line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="psp2mask_+3A_w">W</code></td>
<td>

<p>Optional window (object of class <code>"owin"</code>)
determining the pixel raster.
</p>
</td></tr>
<tr><td><code id="psp2mask_+3A_...">...</code></td>
<td>

<p>Optional extra arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
to determine the pixel resolution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>psp2mask</code> and <code>as.mask.psp</code> are currently
identical. In future versions of the package, <code>as.mask.psp</code>
will be deprecated, and then removed. 
</p>
<p>This function converts a line segment pattern to a binary
pixel mask by determining which pixels intersect the lines.
</p>
<p>The pixel raster is determined by <code>W</code>
and the optional arguments <code>...</code>.
If <code>W</code> is missing or <code>NULL</code>, it defaults to the window
containing <code>x</code>.
Then <code>W</code> is converted to a
binary pixel mask using <code><a href="#topic+as.mask">as.mask</a></code>. The arguments
<code>...</code> are passed to <code><a href="#topic+as.mask">as.mask</a></code> to
control the pixel resolution.
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>)
which is a binary pixel mask (type <code>"mask"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pixellate.psp">pixellate.psp</a></code>,
<code><a href="#topic+as.mask">as.mask</a></code>.
</p>
<p>Use <code><a href="#topic+pixellate.psp">pixellate.psp</a></code> if you want to measure the
length of line in each pixel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  plot(psp2mask(X))
  plot(X, add=TRUE, col="red")
</code></pre>

<hr>
<h2 id='quad.object'>Class of Quadrature Schemes</h2><span id='topic+quad.object'></span>

<h3>Description</h3>

<p>A class <code>"quad"</code> to represent a quadrature scheme.
</p>


<h3>Details</h3>

<p>A (finite) quadrature scheme is a list of quadrature points
<code class="reqn">u_j</code> and associated weights <code class="reqn">w_j</code>
which is used to approximate an integral by a finite sum:
</p>
<p style="text-align: center;"><code class="reqn">
    \int f(x) dx \approx \sum_j f(u_j) w_j
  </code>
</p>

<p>Given a point pattern dataset, a <em>Berman-Turner</em>
quadrature scheme is one which includes all these data points,
as well as a nonzero number of other (&ldquo;dummy&rdquo;) points.
</p>
<p>These quadrature schemes are used to approximate the
pseudolikelihood of a point process, in the method of
Baddeley and Turner (2000) (see Berman and Turner (1992)).
Accuracy and computation time both increase with the number of
points in the quadrature scheme.
</p>
<p>An object of class <code>"quad"</code> represents a Berman-Turner
quadrature scheme. It can be passed as an argument to
the model-fitting function <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>, which
requires a quadrature scheme.
</p>
<p>An object of this class contains at least the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>data</code>: </td><td style="text-align: left;"> an object of class <code>"ppp"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
                 </td><td style="text-align: left;"> giving the locations (and marks) of the data points.</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>dummy</code>: </td><td style="text-align: left;"> an object of class <code>"ppp"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
                 </td><td style="text-align: left;"> giving the locations (and marks) of the dummy points.</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>w</code>: </td><td style="text-align: left;"> vector of nonnegative weights for the quadrature points</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Users are strongly advised not to manipulate these entries
directly.
</p>
<p>The domain of quadrature is specified by <code>Window(dummy)</code>
while the observation window (if this needs to be specified
separately) is taken to be <code>Window(data)</code>. 
</p>
<p>The weights vector <code>w</code> may also have an attribute
<code>attr(w, "zeroes")</code> equivalent to the logical vector
<code>(w == 0)</code>. If this is absent then all points are known to
have positive weights.
</p>
<p>To create an object of class <code>"quad"</code>,
users would typically call the
high level function <code><a href="#topic+quadscheme">quadscheme</a></code>.
(They are actually
created by the low level function <code>quad</code>.)
</p>
<p>Entries are extracted from a <code>"quad"</code> object by the functions
<code>x.quad</code>,
<code>y.quad</code>,
<code>w.quad</code> and
<code>marks.quad</code>,
which extract the <code class="reqn">x</code> coordinates, <code class="reqn">y</code> coordinates,
weights, and marks, respectively. The function
<code>n.quad</code> returns the total number of quadrature points
(dummy plus data).
</p>
<p>An object of class <code>"quad"</code> can be converted into an ordinary
point pattern by the function <code><a href="#topic+union.quad">union.quad</a></code> which simply
takes the union of the data and dummy points.
</p>
<p>Quadrature schemes can be plotted using <code><a href="#topic+plot.quad">plot.quad</a></code>
(a method for the generic <code><a href="graphics.html#topic+plot">plot</a></code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadscheme">quadscheme</a></code>,
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>
</p>

<hr>
<h2 id='quadratcount'>Quadrat counting for a point pattern</h2><span id='topic+quadratcount'></span><span id='topic+quadratcount.ppp'></span><span id='topic+quadratcount.splitppp'></span>

<h3>Description</h3>

<p>Divides window into quadrats and 
counts the numbers of points in each quadrat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  quadratcount(X, ...)

  ## S3 method for class 'ppp'
quadratcount(X, nx=5, ny=nx, ...,
               xbreaks=NULL, ybreaks=NULL, tess=NULL)

  ## S3 method for class 'splitppp'
quadratcount(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadratcount_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>)
or a split point pattern (object of class <code>"splitppp"</code>).
</p>
</td></tr>
<tr><td><code id="quadratcount_+3A_nx">nx</code>, <code id="quadratcount_+3A_ny">ny</code></td>
<td>

<p>Numbers of rectangular quadrats in the <code class="reqn">x</code> and <code class="reqn">y</code> directions.
Incompatible with <code>xbreaks</code> and <code>ybreaks</code>.
</p>
</td></tr>
<tr><td><code id="quadratcount_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>quadratcount.ppp</code>.</p>
</td></tr>
<tr><td><code id="quadratcount_+3A_xbreaks">xbreaks</code></td>
<td>

<p>Numeric vector giving the <code class="reqn">x</code> coordinates of the
boundaries of the rectangular quadrats. Incompatible with <code>nx</code>.
</p>
</td></tr>
<tr><td><code id="quadratcount_+3A_ybreaks">ybreaks</code></td>
<td>

<p>Numeric vector giving the <code class="reqn">y</code> coordinates of the
boundaries of the rectangular quadrats. Incompatible with <code>ny</code>.
</p>
</td></tr>
<tr><td><code id="quadratcount_+3A_tess">tess</code></td>
<td>

<p>Tessellation (object of class <code>"tess"</code> or something acceptable
to <code><a href="#topic+as.tess">as.tess</a></code>) determining the quadrats. Incompatible
with <code>nx,ny,xbreaks,ybreaks</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quadrat counting is an elementary technique for analysing spatial
point patterns. See Diggle (2003).
</p>
<p><b>If <code>X</code> is a point pattern</b>, then 
by default, the window containing the point pattern <code>X</code> is divided into
an <code>nx * ny</code> grid of rectangular tiles or &lsquo;quadrats&rsquo;.
(If the window is not a rectangle, then these tiles are intersected
with the window.)
The number of points of <code>X</code> falling in each quadrat is
counted. These numbers are returned as a contingency table.
</p>
<p>If <code>xbreaks</code> is given, it should be a numeric vector
giving the <code class="reqn">x</code> coordinates of the quadrat boundaries.
If it is not given, it defaults to a
sequence of <code>nx+1</code> values equally spaced
over the range of <code class="reqn">x</code> coordinates in the window <code>Window(X)</code>.
</p>
<p>Similarly if <code>ybreaks</code> is given, it should be a numeric
vector giving the <code class="reqn">y</code> coordinates of the quadrat boundaries.
It defaults to a vector of <code>ny+1</code> values
equally spaced over the range of <code class="reqn">y</code> coordinates in the window.
The lengths of <code>xbreaks</code> and <code>ybreaks</code> may be different.
</p>
<p>Alternatively, quadrats of any shape may be used.
The argument <code>tess</code> can be a tessellation (object of class
<code>"tess"</code>) whose tiles will serve as the quadrats.
</p>
<p>The algorithm counts the number of points of <code>X</code>
falling in each quadrat, and returns these counts as a
contingency table. 
</p>
<p>The return value is a <code>table</code> which can be printed neatly.
The return value is also a member of the special class
<code>"quadratcount"</code>. Plotting the object will display the
quadrats, annotated by their counts. See the examples.
</p>
<p>To perform a chi-squared test based on the quadrat counts,
use <code><a href="spatstat.explore.html#topic+quadrat.test">quadrat.test</a></code>.
</p>
<p>To calculate an estimate of intensity based on the quadrat counts,
use <code><a href="#topic+intensity.quadratcount">intensity.quadratcount</a></code>.
</p>
<p>To extract the quadrats used in a <code>quadratcount</code> object,
use <code><a href="#topic+as.tess">as.tess</a></code>.
</p>
<p><b>If <code>X</code> is a split point pattern</b> (object of class
<code>"splitppp"</code> then quadrat counting will be performed on
each of the components point patterns, and the resulting
contingency tables will be returned in a list. This list can be
printed or plotted.
</p>
<p>Marks attached to the points are ignored by <code>quadratcount.ppp</code>.
To obtain a separate contingency table for each type of point
in a multitype point pattern,
first separate the different points using <code><a href="#topic+split.ppp">split.ppp</a></code>,
then apply <code>quadratcount.splitppp</code>. See the Examples.
</p>


<h3>Value</h3>

<p>The value of <code>quadratcount.ppp</code> is a 
contingency table containing the number of points in each
quadrat. The table is also an object of the
special class <code>"quadratcount"</code>
and there is a plot method for this class.
</p>
<p>The value of <code>quadratcount.splitppp</code> is a list of such
contingency tables, each containing the quadrat counts for one of the
component point patterns in <code>X</code>.
This list also has the class <code>"solist"</code> which has
print and plot methods.
</p>


<h3>Warning</h3>

<p>If <code>Q</code> is a <code>quadratcount</code> object,
the ordering of entries in the table <code>Q</code> 
<b>may be different from</b> the ordering of quadrats (tiles
in the tessellation <code>as.tess(Q)</code>).
</p>
<p>To obtain the entries of the table in the same order
as the quadrats, use
<code>counts &lt;- as.numeric(t(Q))</code> or <code>counts &lt;- marks(as.tess(Q))</code>.
</p>


<h3>Note</h3>

<p>To perform a chi-squared test based on the quadrat counts,
use <code><a href="spatstat.explore.html#topic+quadrat.test">quadrat.test</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Academic Press, 2003.
</p>
<p>Stoyan, D. and Stoyan, H. (1994)
<em>Fractals, random shapes and point fields:
methods of geometrical statistics.</em>
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.quadratcount">plot.quadratcount</a></code>,
<code><a href="#topic+intensity.quadratcount">intensity.quadratcount</a></code>,
<code><a href="#topic+quadrats">quadrats</a></code>,
<code><a href="spatstat.explore.html#topic+quadrat.test">quadrat.test</a></code>,
<code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+hextess">hextess</a></code>,
<code><a href="spatstat.random.html#topic+quadratresample">quadratresample</a></code>,
<code><a href="spatstat.explore.html#topic+miplot">miplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> X &lt;- runifrect(50)
 quadratcount(X)
 quadratcount(X, 4, 5)
 quadratcount(X, xbreaks=c(0, 0.3, 1), ybreaks=c(0, 0.4, 0.8, 1))
 qX &lt;-  quadratcount(X, 4, 5)

 # plotting:
 plot(X, pch="+")
 plot(qX, add=TRUE, col="red", cex=1.5, lty=2)

 # irregular window
 plot(humberside)
 qH &lt;- quadratcount(humberside, 2, 3)
 plot(qH, add=TRUE, col="blue", cex=1.5, lwd=2)

 # multitype - split
 plot(quadratcount(split(humberside), 2, 3))
 
 # quadrats determined by tessellation:
 B &lt;- dirichlet(runifrect(6))
 qX &lt;- quadratcount(X, tess=B)
 plot(X, pch="+")
 plot(qX, add=TRUE, col="red", cex=1.5, lty=2)
</code></pre>

<hr>
<h2 id='quadrats'>Divide Region into Quadrats</h2><span id='topic+quadrats'></span>

<h3>Description</h3>

<p>Divides window into rectangular quadrats and 
returns the quadrats as a tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadrats(X, nx = 5, ny = nx, xbreaks = NULL, ybreaks = NULL, keepempty=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadrats_+3A_x">X</code></td>
<td>

<p>A window (object of class <code>"owin"</code>)
or anything that can be coerced to a window using
<code><a href="#topic+as.owin">as.owin</a></code>, such as a point pattern.
</p>
</td></tr>
<tr><td><code id="quadrats_+3A_nx">nx</code>, <code id="quadrats_+3A_ny">ny</code></td>
<td>

<p>Numbers of quadrats in the <code class="reqn">x</code> and <code class="reqn">y</code> directions.
Incompatible with <code>xbreaks</code> and <code>ybreaks</code>.
</p>
</td></tr>
<tr><td><code id="quadrats_+3A_xbreaks">xbreaks</code></td>
<td>

<p>Numeric vector giving the <code class="reqn">x</code> coordinates of the
boundaries of the quadrats. Incompatible with <code>nx</code>.
</p>
</td></tr>
<tr><td><code id="quadrats_+3A_ybreaks">ybreaks</code></td>
<td>

<p>Numeric vector giving the <code class="reqn">y</code> coordinates of the
boundaries of the quadrats. Incompatible with <code>ny</code>.
</p>
</td></tr>
<tr><td><code id="quadrats_+3A_keepempty">keepempty</code></td>
<td>

<p>Logical value indicating whether to delete or retain
empty quadrats. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the window <code>X</code> is a rectangle, it is divided into
an <code>nx * ny</code> grid of rectangular tiles or &lsquo;quadrats&rsquo;.
</p>
<p>If <code>X</code> is not a rectangle, then the bounding rectangle of
<code>X</code> is first divided into an <code>nx * ny</code> grid of rectangular
tiles, and these tiles are then intersected with the window <code>X</code>.
</p>
<p>The resulting tiles are returned as a tessellation (object of class
<code>"tess"</code>) which can be plotted and used in other analyses.
</p>
<p>If <code>xbreaks</code> is given, it should be a numeric vector
giving the <code class="reqn">x</code> coordinates of the quadrat boundaries.
If it is not given, it defaults to a
sequence of <code>nx+1</code> values equally spaced
over the range of <code class="reqn">x</code> coordinates in the window <code>Window(X)</code>.
</p>
<p>Similarly if <code>ybreaks</code> is given, it should be a numeric
vector giving the <code class="reqn">y</code> coordinates of the quadrat boundaries.
It defaults to a vector of <code>ny+1</code> values
equally spaced over the range of <code class="reqn">y</code> coordinates in the window.
The lengths of <code>xbreaks</code> and <code>ybreaks</code> may be different.
</p>
<p>By default (if <code>keepempty=FALSE</code>), any rectangular tile which
does not intersect the window <code>X</code> is
ignored, and only the non-empty intersections are treated as quadrats,
so the tessellation may consist of fewer than <code>nx * ny</code> tiles.
If <code>keepempty=TRUE</code>, empty intersections are retained,
and the tessellation always contains exactly <code>nx * ny</code> tiles,
some of which may be empty.
</p>


<h3>Value</h3>

<p>A tessellation (object of class <code>"tess"</code>) as described under
<code><a href="#topic+tess">tess</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p>For calculations using quadrats, see
<code><a href="#topic+quadratcount">quadratcount</a></code>,
<code><a href="spatstat.explore.html#topic+quadrat.test">quadrat.test</a></code>,
<code><a href="spatstat.random.html#topic+quadratresample">quadratresample</a></code>
</p>
<p>For other kinds of tessellations, see 
<code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+hextess">hextess</a></code>,
<code><a href="#topic+venn.tess">venn.tess</a></code>,
<code><a href="#topic+polartess">polartess</a></code>,
<code><a href="#topic+dirichlet">dirichlet</a></code>, <code><a href="#topic+delaunay">delaunay</a></code>,
<code><a href="#topic+quantess">quantess</a></code>, <code><a href="#topic+bufftess">bufftess</a></code>
and 
<code><a href="spatstat.random.html#topic+rpoislinetess">rpoislinetess</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> W &lt;- square(10)
 Z &lt;- quadrats(W, 4, 5)
 plot(Z)

 plot(quadrats(letterR, 5, 7))
</code></pre>

<hr>
<h2 id='quadscheme'>Generate a Quadrature Scheme from a Point Pattern</h2><span id='topic+quadscheme'></span>

<h3>Description</h3>

<p>Generates a quadrature scheme (an object of class <code>"quad"</code>)
from point patterns of data and dummy points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> quadscheme(data, dummy, method="grid", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadscheme_+3A_data">data</code></td>
<td>

<p>The observed data point pattern.
An object of class <code>"ppp"</code>
or in a format recognised by <code><a href="#topic+as.ppp">as.ppp</a>()</code>
</p>
</td></tr>
<tr><td><code id="quadscheme_+3A_dummy">dummy</code></td>
<td>

<p>The pattern of dummy points for the quadrature. 
An object of class <code>"ppp"</code>
or in a format recognised by <code><a href="#topic+as.ppp">as.ppp</a>()</code>
Defaults to <code>default.dummy(data, ...)</code>
</p>
</td></tr>
<tr><td><code id="quadscheme_+3A_method">method</code></td>
<td>

<p>The name of the method for calculating quadrature weights: either
<code>"grid"</code> or <code>"dirichlet"</code>.
</p>
</td></tr>
<tr><td><code id="quadscheme_+3A_...">...</code></td>
<td>

<p>Parameters of the weighting method (see below)
and parameters for constructing the dummy points if necessary.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the primary method for producing a quadrature schemes
for use by <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>.
</p>
<p>The function <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> fits a point process model to an
observed point pattern using 
the Berman-Turner quadrature approximation (Berman and Turner, 1992;
Baddeley and Turner, 2000) to the pseudolikelihood of the model. 
It requires a quadrature scheme consisting of 
the original data point pattern, an additional pattern of dummy points,
and a vector of quadrature weights for all these points.
Such quadrature schemes are represented by objects of class
<code>"quad"</code>. See <code><a href="#topic+quad.object">quad.object</a></code> for a description of this class.
</p>
<p>Quadrature schemes are created by the function
<code>quadscheme</code>.
The arguments <code>data</code> and <code>dummy</code> specify the data and dummy
points, respectively. There is a sensible default for the dummy 
points (provided by <code><a href="#topic+default.dummy">default.dummy</a></code>).
Alternatively the dummy points
may be specified arbitrarily and given in any format recognised by
<code><a href="#topic+as.ppp">as.ppp</a></code>.
There are also functions for creating dummy patterns
including <code><a href="#topic+corners">corners</a></code>,
<code><a href="#topic+gridcentres">gridcentres</a></code>,
<code><a href="#topic+stratrand">stratrand</a></code> and
<code><a href="#topic+spokes">spokes</a></code>.
</p>
<p>The quadrature region is the region over which we are
integrating, and approximating integrals by finite sums.
If <code>dummy</code> is a point pattern object (class <code>"ppp"</code>)
then the quadrature region is taken to be <code>Window(dummy)</code>.
If <code>dummy</code> is just a list of <code class="reqn">x, y</code> coordinates
then the quadrature region defaults to the observation window
of the data pattern, <code>Window(data)</code>.
</p>
<p>If <code>dummy</code> is missing, then a pattern of dummy points
will be generated using <code><a href="#topic+default.dummy">default.dummy</a></code>, taking account
of the optional arguments <code>...</code>.
By default, the dummy points are arranged in a
rectangular grid; recognised arguments
include <code>nd</code> (the number of grid points
in the horizontal and vertical directions)
and <code>eps</code> (the spacing between dummy points).
If <code>random=TRUE</code>, a systematic random pattern
of dummy points is generated instead.
See <code><a href="#topic+default.dummy">default.dummy</a></code> for details. 
</p>
<p>If <code>method = "grid"</code> then the optional arguments (for <code>...</code>) are 
<code>(nd, ntile, eps)</code>.
The quadrature region (defined above) is divided into
an <code>ntile[1]</code> by <code>ntile[2]</code> grid of rectangular tiles.
The weight for each
quadrature point is the area of a tile divided by the number of
quadrature points in that tile. 
</p>
<p>If <code>method="dirichlet"</code> then the optional arguments are
<code>(exact=TRUE, nd, eps)</code>.
The quadrature points (both data and dummy) are used to construct the
Dirichlet tessellation. The quadrature weight of each point is the
area of its Dirichlet tile inside the quadrature region.
If <code>exact == TRUE</code> then this area is computed exactly
using the package <code>deldir</code>; otherwise it is computed
approximately by discretisation.
</p>


<h3>Value</h3>

<p>An object of class <code>"quad"</code> describing the quadrature scheme
(data points, dummy points, and quadrature weights)
suitable as the argument <code>Q</code> of the function <code><a href="spatstat.model.html#topic+ppm">ppm</a>()</code> for
fitting a point process model.
</p>
<p>The quadrature scheme can be inspected using the
<code>print</code> and <code>plot</code> methods for objects
of class <code>"quad"</code>. 
</p>


<h3>Error Messages</h3>

<p>The following error messages need some explanation.
(See also the list of error messages in <code><a href="spatstat.model.html#topic+ppm.ppp">ppm.ppp</a></code>).
</p>

<dl>
<dt>&ldquo;Some tiles with positive area do not contain any
quadrature points: relative error = X%&rdquo;</dt><dd>
<p>This is not important unless the relative error is large.
In the default rule for computing the
quadrature weights, space is divided into rectangular tiles,
and the number of quadrature points (data and dummy points) in
each tile is counted. It is possible for a tile with non-zero area
to contain no quadrature points; in this case, the quadrature
scheme will contribute a bias to the model-fitting procedure.
<b>A small relative error (less than 2 percent) is not	important.</b>
Relative errors of a few percent can occur because of the shape of
the window.
If the relative error is greater than about 5 percent, we
recommend trying different parameters for the quadrature scheme,
perhaps setting a larger value of <code>nd</code> to increase the number
of dummy points. A relative error greater than 10 percent
indicates a major problem with the input data. The quadrature
scheme should be inspected by plotting and printing it.
(The most likely cause of this problem is that the spatial coordinates
of the original data were not handled correctly, for example,
coordinates of the locations and the window boundary were incompatible.)
</p>
</dd>
<dt>&ldquo;Some tiles with zero area contain quadrature points&rdquo;</dt><dd>
<p>This error message is rare, and has no consequences.
It is mainly of interest to
programmers. It occurs when the area of a
tile is calculated to be equal to zero, but a quadrature point
has been placed in the tile. 
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R.
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b> (2000) 283&ndash;322.
</p>
<p>Berman, M. and Turner, T.R. 
Approximating point process likelihoods with GLIM.
<em>Applied Statistics</em> <b>41</b> (1992) 31&ndash;38.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+ppm">ppm</a></code>,
<code><a href="#topic+as.ppp">as.ppp</a></code>,
<code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="#topic+gridweights">gridweights</a></code>,
<code><a href="#topic+dirichletWeights">dirichletWeights</a></code>,
<code><a href="#topic+corners">corners</a></code>,
<code><a href="#topic+gridcentres">gridcentres</a></code>,
<code><a href="#topic+stratrand">stratrand</a></code>,
<code><a href="#topic+spokes">spokes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # grid weights
  Q &lt;- quadscheme(simdat)
  Q &lt;- quadscheme(simdat, method="grid")
  Q &lt;- quadscheme(simdat, eps=0.5)         # dummy point spacing 0.5 units

  Q &lt;- quadscheme(simdat, nd=50)           # 1 dummy point per tile
  Q &lt;- quadscheme(simdat, ntile=25, nd=50) # 4 dummy points per tile

  # Dirichlet weights
  Q &lt;- quadscheme(simdat, method="dirichlet", exact=FALSE)

  # random dummy pattern
  # D &lt;- runifrect(250, Window(simdat))
  # Q &lt;- quadscheme(simdat, D, method="dirichlet", exact=FALSE)

  # polygonal window
  data(demopat)
  X &lt;- unmark(demopat)
  Q &lt;- quadscheme(X)

  # mask window
  Window(X) &lt;- as.mask(Window(X))
  Q &lt;- quadscheme(X)
  
</code></pre>

<hr>
<h2 id='quadscheme.logi'>Generate a Logistic Regression Quadrature Scheme from a Point Pattern</h2><span id='topic+quadscheme.logi'></span>

<h3>Description</h3>

<p>Generates a logistic regression quadrature scheme (an object of class
<code>"logiquad"</code> inheriting from <code>"quad"</code>)
from point patterns of data and dummy points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> quadscheme.logi(data, dummy, dummytype = "stratrand",
                 nd = NULL, mark.repeat = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadscheme.logi_+3A_data">data</code></td>
<td>

<p>The observed data point pattern.
An object of class <code>"ppp"</code>
or in a format recognised by <code><a href="#topic+as.ppp">as.ppp</a>()</code>
</p>
</td></tr>
<tr><td><code id="quadscheme.logi_+3A_dummy">dummy</code></td>
<td>

<p>The pattern of dummy points for the quadrature. 
An object of class <code>"ppp"</code>
or in a format recognised by <code><a href="#topic+as.ppp">as.ppp</a>()</code>.
If missing a sensible default is generated.
</p>
</td></tr>
<tr><td><code id="quadscheme.logi_+3A_dummytype">dummytype</code></td>
<td>

<p>The name of the type of dummy points to use when <code>"dummy"</code>
is missing. Currently available
options are: <code>"stratrand"</code> (default), <code>"binomial"</code>,
<code>"poisson"</code>, <code>"grid"</code> and <code>"transgrid"</code>.
</p>
</td></tr>
<tr><td><code id="quadscheme.logi_+3A_nd">nd</code></td>
<td>

<p>Integer, or integer vector of length 2 controlling the intensity of
dummy points when <code>"dummy"</code> is missing.
</p>
</td></tr>
<tr><td><code id="quadscheme.logi_+3A_mark.repeat">mark.repeat</code></td>
<td>

<p>Repeating the dummy points for each level of a marked data pattern
when <code>"dummy"</code> is missing. (See details.)
</p>
</td></tr>
<tr><td><code id="quadscheme.logi_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the primary method for producing a quadrature schemes
for use by <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> when the logistic regression
approximation (Baddeley et al. 2013) to the pseudolikelihood of the
model is applied (i.e. when <code>method="logi"</code> in <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>).
</p>
<p>The function <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> fits a point process model to an
observed point pattern. When used with the option <code>method="logi"</code>
it requires a quadrature scheme consisting of 
the original data point pattern and an additional pattern of dummy points.
Such quadrature schemes are represented by objects of class
<code>"logiquad"</code>.
</p>
<p>Quadrature schemes are created by the function
<code>quadscheme.logi</code>.
The arguments <code>data</code> and <code>dummy</code> specify the data and dummy
points, respectively. There is a sensible default for the dummy 
points.
Alternatively the dummy points
may be specified arbitrarily and given in any format recognised by
<code><a href="#topic+as.ppp">as.ppp</a></code>.
</p>
<p>The quadrature region is the region over which we are
integrating, and approximating integrals by finite sums.
If <code>dummy</code> is a point pattern object (class <code>"ppp"</code>)
then the quadrature region is taken to be <code>Window(dummy)</code>.
If <code>dummy</code> is just a list of <code class="reqn">x, y</code> coordinates
then the quadrature region defaults to the observation window
of the data pattern, <code>Window(data)</code>.
</p>
<p>If <code>dummy</code> is missing, then a pattern of dummy points will be
generated, taking account of the optional arguments <code>dummytype</code>,
<code>nd</code>, and <code>mark.repeat</code>.
</p>
<p>The currently accepted values for <code>dummytype</code> are:
</p>

<ul>
<li> <p><code>"grid"</code> where the frame of the window
is divided into a <code>nd * nd</code> or <code>nd[1] * nd[2]</code> regular grid
of tiles and the centers constitutes the dummy points.
</p>
</li>
<li> <p><code>"transgrid"</code> where a regular grid as above is translated
by a random vector.
</p>
</li>
<li> <p><code>"stratrand"</code> where each point of a regular grid as above
is randomly translated within its tile.
</p>
</li>
<li> <p><code>"binomial"</code> where <code>nd * nd</code> or <code>nd[1] * nd[2]</code>
points are generated uniformly in the frame of the
window.
<code>"poisson"</code> where a homogeneous Poisson point process with
intensity <code>nd * nd</code> or <code>nd[1] * nd[2]</code> is
generated within the frame of observation window.
</p>
</li></ul>

<p>Then if the window is not rectangular, any dummy points
lying outside it are deleted. 
</p>
<p>If <code>data</code> is a multitype point pattern the dummy points should also
be marked (with the same levels of the marks as <code>data</code>). If
<code>dummy</code> is missing and the dummy pattern is generated by
<code>quadscheme.logi</code> the default behaviour is to attach a uniformly
distributed mark (from the levels of the marks) to each dummy
point. Alternatively, if <code>mark.repeat=TRUE</code> each dummy point is
repeated as many times as there are levels of the marks with a distinct
mark value attached to it.
</p>
<p>Finally, each point (data and dummy) is assigned the weight 1. The
weights are never used and only appear to be compatible with the class
<code>"quad"</code> from which the <code>"logiquad"</code> object inherits.
</p>


<h3>Value</h3>

<p>An object of class <code>"logiquad"</code> inheriting from <code>"quad"</code>
describing the quadrature scheme 
(data points, dummy points, and quadrature weights)
suitable as the argument <code>Q</code> of the function <code><a href="spatstat.model.html#topic+ppm">ppm</a>()</code> for
fitting a point process model.
</p>
<p>The quadrature scheme can be inspected using the
<code>print</code> and <code>plot</code> methods for objects
of class <code>"quad"</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.</p>


<h3>References</h3>

<p>Baddeley, A., Coeurjolly, J.-F., Rubak, E. and Waagepetersen, R. (2014)
Logistic regression for spatial Gibbs point processes.
<em>Biometrika</em> <b>101</b> (2) 377&ndash;392.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+ppm">ppm</a></code>,
<code><a href="#topic+as.ppp">as.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Q &lt;- quadscheme.logi(simdat)
</code></pre>

<hr>
<h2 id='quantess'>Quantile Tessellation</h2><span id='topic+quantess'></span><span id='topic+quantess.owin'></span><span id='topic+quantess.ppp'></span><span id='topic+quantess.im'></span>

<h3>Description</h3>

<p>Divide space into tiles which contain equal amounts of stuff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantess(M, Z, n, ...)

## S3 method for class 'owin'
quantess(M, Z, n, ..., type=2, origin=c(0,0), eps=NULL)

## S3 method for class 'ppp'
quantess(M, Z, n, ..., type=2, origin=c(0,0), eps=NULL)

## S3 method for class 'im'
quantess(M, Z, n, ..., type=2, origin=c(0,0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantess_+3A_m">M</code></td>
<td>

<p>A spatial object (such as a window, point pattern
or pixel image) determining the weight or amount of stuff
at each location.
</p>
</td></tr>
<tr><td><code id="quantess_+3A_z">Z</code></td>
<td>

<p>A spatial covariate (a pixel image or a <code>function(x,y)</code>)
or one of the strings <code>"x"</code> or <code>"y"</code> indicating the
Cartesian coordinates <code class="reqn">x</code> or <code class="reqn">y</code>, or one of the strings
<code>"rad"</code> or <code>"ang"</code> indicating polar coordinates.
The range of values of <code>Z</code> will be broken into <code>n</code>
bands containing equal amounts of stuff.
</p>
</td></tr>
<tr><td><code id="quantess_+3A_n">n</code></td>
<td>

<p>Number of bands. A positive integer.
</p>
</td></tr>
<tr><td><code id="quantess_+3A_type">type</code></td>
<td>

<p>Integer specifying the rule for calculating quantiles.
Passed to <code><a href="stats.html#topic+quantile.default">quantile.default</a></code>.
</p>
</td></tr>
<tr><td><code id="quantess_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+quadrats">quadrats</a></code> or
<code><a href="#topic+tess">tess</a></code> defining another tessellation
which should be intersected with the quantile tessellation.
</p>
</td></tr>
<tr><td><code id="quantess_+3A_origin">origin</code></td>
<td>

<p>Location of the origin of polar coordinates,
if <code>Z="rad"</code> or <code>Z="ang"</code>.
Either a numeric vector of length 2 giving the location,
or a point pattern containing only one point,
or a list with two entries named <code>x</code> and <code>y</code>,
or one of the character strings
<code>"centroid"</code>, <code>"midpoint"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code>,
<code>"topleft"</code>, <code>"bottomleft"</code>, <code>"topright"</code> or
<code>"bottomright"</code> (partially matched).
</p>
</td></tr>
<tr><td><code id="quantess_+3A_eps">eps</code></td>
<td>

<p>Optional. The size of pixels in the approximation which is used
to compute the quantiles. A positive numeric value, or vector of two
positive numeric values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <em>quantile tessellation</em> is a division of space into
pieces which contain equal amounts of stuff.
</p>
<p>The function <code>quantess</code> 
computes a quantile tessellation and 
returns the tessellation itself.  
The function <code>quantess</code> is generic, with methods for
windows (class <code>"owin"</code>), point patterns (<code>"ppp"</code>)
and pixel images (<code>"im"</code>). 
</p>
<p>The first argument <code>M</code> (for mass) specifies the spatial
distribution of stuff that is to be divided. If <code>M</code> is a window,
the <em>area</em> of the window is to be divided into <code>n</code> equal pieces.
If <code>M</code> is a point pattern, the <em>number of points</em> in the
pattern is to be divided into <code>n</code> equal parts, as far as
possible. If <code>M</code> is a pixel image, the pixel values are
interpreted as weights, and the <em>total weight</em> is to be divided
into <code>n</code> equal parts.  
</p>
<p>The second argument
<code>Z</code> is a spatial covariate. The range of values of <code>Z</code>
will be divided into <code>n</code> bands, each containing
the same total weight. That is, we determine the quantiles of <code>Z</code>
with weights given by <code>M</code>.
</p>
<p>For convenience, additional arguments <code>...</code> can be given,
to further subdivide the tiles of the tessellation. These arguments
should be recognised by one of the functions
<code><a href="#topic+quadrats">quadrats</a></code> or <code><a href="#topic+tess">tess</a></code>. The tessellation
determined by these arguments is intersected with the quantile tessellation.
</p>
<p>The result of <code>quantess</code> is a tessellation of <code>as.owin(M)</code>
determined by the quantiles of <code>Z</code>.
</p>


<h3>Value</h3>

<p>A tessellation (object of class <code>"tess"</code>).
</p>


<h3>Author(s)</h3>

<p>Original idea by Ute Hahn.
Implemented in <code>spatstat</code> by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>, <code><a href="#topic+quadrats">quadrats</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>,
<code><a href="#topic+tilenames">tilenames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(quantess(letterR, "x", 5))

  plot(quantess(bronzefilter, "x", 6))
  points(unmark(bronzefilter))

  plot(quantess(letterR, "rad", 7, origin=c(2.8, 1.5)))
  plot(quantess(letterR, "ang", 7, origin=c(2.8, 1.5)))

  opa &lt;- par(mar=c(0,0,2,5))
  A &lt;- quantess(Window(bei), bei.extra$elev, 4)
  plot(A, ribargs=list(las=1))
  
  B &lt;- quantess(bei, bei.extra$elev, 4)
  tilenames(B) &lt;- paste(spatstat.utils::ordinal(1:4), "quartile")
  plot(B, ribargs=list(las=1))
  points(bei, pch=".", cex=2, col="white")
  par(opa)
</code></pre>

<hr>
<h2 id='quantile.ewcdf'>
Quantiles of Weighted Empirical Cumulative Distribution Function
</h2><span id='topic+quantile.ewcdf'></span>

<h3>Description</h3>

<p>Compute quantiles of a weighted empirical cumulative distribution function.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ewcdf'
quantile(x, probs = seq(0, 1, 0.25),
                 names = TRUE, ...,
                 normalise = TRUE, type=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.ewcdf_+3A_x">x</code></td>
<td>

<p>A weighted empirical cumulative distribution function
(object of class <code>"ewcdf"</code>, produced by <code><a href="#topic+ewcdf">ewcdf</a></code>)
for which the quantiles are desired.
</p>
</td></tr>
<tr><td><code id="quantile.ewcdf_+3A_probs">probs</code></td>
<td>

<p>probabilities for which the quantiles are desired.
A numeric vector of values between 0 and 1.
</p>
</td></tr>
<tr><td><code id="quantile.ewcdf_+3A_names">names</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the resulting vector of quantiles is
annotated with names corresponding to <code>probs</code>.
</p>
</td></tr>
<tr><td><code id="quantile.ewcdf_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="quantile.ewcdf_+3A_normalise">normalise</code></td>
<td>

<p>Logical value indicating whether <code>x</code> should first be normalised
so that it ranges between 0 and 1. 
</p>
</td></tr>
<tr><td><code id="quantile.ewcdf_+3A_type">type</code></td>
<td>

<p>Integer specifying the type of quantile to be calculated,
as explained in <code><a href="stats.html#topic+quantile.default">quantile.default</a></code>.
Only types 1 and 2 are currently implemented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic <code><a href="stats.html#topic+quantile">quantile</a></code>
function for the class <code>ewcdf</code> of empirical weighted cumulative
distribution functions.
</p>
<p>The quantile for a probability <code>p</code> is computed
as the right-continuous inverse of the cumulative
distribution function <code>x</code> (assuming <code>type=1</code>, the default).
</p>
<p>If <code>normalise=TRUE</code> (the default),
the weighted cumulative function <code>x</code> is first normalised to
have total mass <code>1</code> so that it can be interpreted as a
cumulative probability distribution function. 
</p>


<h3>Value</h3>

<p>Numeric vector of quantiles, of the same length as <code>probs</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
and Kevin Ummel.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ewcdf">ewcdf</a></code>, 
<code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  z &lt;- rnorm(50)
  w &lt;- runif(50)
  Fun &lt;- ewcdf(z, w)
  quantile(Fun, c(0.95,0.99))
</code></pre>

<hr>
<h2 id='quantile.im'>Sample Quantiles of Pixel Image</h2><span id='topic+quantile.im'></span>

<h3>Description</h3>

<p>Compute the sample quantiles of the pixel values of a
given pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im'
quantile(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.im_+3A_x">x</code></td>
<td>

<p>A pixel image.
An object of class <code>"im"</code>.
</p>
</td></tr>
<tr><td><code id="quantile.im_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+quantile.default">quantile.default</a></code>.
They determine the probabilities for which quantiles should be
computed. See <code><a href="stats.html#topic+quantile.default">quantile.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simple function applies the generic <code><a href="stats.html#topic+quantile">quantile</a></code> operation
to the pixel values of the image <code>x</code>. 
</p>
<p>This function is a convenient
way to inspect an image and to obtain summary statistics.
See the examples.
</p>


<h3>Value</h3>

<p>A vector of quantiles. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code>,
<code><a href="#topic+cut.im">cut.im</a></code>,
<code><a href="#topic+im.object">im.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># artificial image data
Z &lt;- setcov(square(1))

# find the quartiles
quantile(Z)

# find the deciles
quantile(Z, probs=(0:10)/10)
</code></pre>

<hr>
<h2 id='quantilefun'>
Quantile Function
</h2><span id='topic+quantilefun'></span><span id='topic+quantilefun.ecdf'></span><span id='topic+quantilefun.ewcdf'></span>

<h3>Description</h3>

<p>Return the inverse function of a cumulative distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  quantilefun(x, ...)

  ## S3 method for class 'ecdf'
quantilefun(x, ..., type=1)

  ## S3 method for class 'ewcdf'
quantilefun(x, ..., type=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantilefun_+3A_x">x</code></td>
<td>

<p>Data for which the quantile function should be calculated.
Either an object containing data (such as a pixel image)
or an object representing a cumulative distribution function
(of class <code>"ecdf"</code> or <code>"ewcdf"</code>).
</p>
</td></tr>
<tr><td><code id="quantilefun_+3A_...">...</code></td>
<td>

<p>Other arguments passed to methods.
</p>
</td></tr>
<tr><td><code id="quantilefun_+3A_type">type</code></td>
<td>

<p>Integer specifying the type of quantiles,
as explained in <code><a href="stats.html#topic+quantile.default">quantile.default</a></code>.
Only types 1 and 2 are currently implemented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whereas the command <code><a href="stats.html#topic+quantile">quantile</a></code> calculates
the quantiles of a dataset corresponding to desired probabilities
<code class="reqn">p</code>, the command <code>quantilefun</code>
returns a function which can be used to compute any quantiles of the
dataset. 
</p>
<p>If <code>f &lt;- quantilefun(x)</code> then <code>f</code> is a function such that
<code>f(p)</code> is the quantile associated with any given probability <code>p</code>.
For example <code>f(0.5)</code> is the median of the original data, and
<code>f(0.99)</code> is the 99th percentile of the original data.
</p>
<p>If <code>x</code> is a pixel image (object of class <code>"im"</code>)
then the pixel values of <code>x</code> will be extracted
and the quantile function of the pixel values is constructed.
</p>
<p>If <code>x</code> is an object representing a cumulative distribution
function (object of class <code>"ecdf"</code> or <code>"ewcdf"</code>) then the
quantile function of the original data is constructed.
</p>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span> language.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+ewcdf">ewcdf</a></code>, 
<code><a href="#topic+quantile.ewcdf">quantile.ewcdf</a></code>, 
<code><a href="stats.html#topic+ecdf">ecdf</a></code>,
<code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## numeric data
  z &lt;- rnorm(50)
  FZ &lt;- ecdf(z)
  QZ &lt;- quantilefun(FZ)
  QZ(0.5) # median value of z
  if(interactive()) plot(QZ, xlim=c(0,1), xlab="probability",
                     ylab="quantile of z")
</code></pre>

<hr>
<h2 id='quantilefun.im'>
Quantile Function for Images
</h2><span id='topic+quantilefun.im'></span>

<h3>Description</h3>

<p>Return the inverse function of the cumulative distribution function
of pixel values in an image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
quantilefun(x, ..., type=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantilefun.im_+3A_x">x</code></td>
<td>

<p>Pixel image (object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="quantilefun.im_+3A_...">...</code></td>
<td>

<p>Other arguments passed to methods.
</p>
</td></tr>
<tr><td><code id="quantilefun.im_+3A_type">type</code></td>
<td>

<p>Integer specifying the type of quantiles,
as explained in <code><a href="stats.html#topic+quantile.default">quantile.default</a></code>.
Only types 1 and 2 are currently implemented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whereas the command <code><a href="stats.html#topic+quantile">quantile</a></code> calculates
the quantiles of a dataset corresponding to desired probabilities
<code class="reqn">p</code>, the command <code>quantilefun</code>
returns a function which can be used to compute any quantiles of the
dataset. 
</p>
<p>If <code>f &lt;- quantilefun(x)</code> then <code>f</code> is a function such that
<code>f(p)</code> is the quantile associated with any given probability <code>p</code>.
For example <code>f(0.5)</code> is the median of the original data, and
<code>f(0.99)</code> is the 99th percentile of the original data.
</p>
<p>If <code>x</code> is a pixel image (object of class <code>"im"</code>)
then the pixel values of <code>x</code> will be extracted
and the quantile function of the pixel values is constructed.
</p>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span> language.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantilefun">quantilefun</a></code>,
</p>
<p><code><a href="#topic+ewcdf">ewcdf</a></code>, 
<code><a href="#topic+quantile.ewcdf">quantile.ewcdf</a></code>, 
<code><a href="stats.html#topic+ecdf">ecdf</a></code>,
<code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## image data: terrain elevation
  Z &lt;- bei.extra$elev
  if(require(spatstat.explore)) {
    FE &lt;- spatialcdf(Z, normalise=TRUE)
  } else {
    FE &lt;- ecdf(Z[])
  }
  QE &lt;- quantilefun(FE)
  QE(0.5) # median elevation
  if(interactive()) plot(QE, xlim=c(0,1),
     xlab="probability", ylab="quantile of elevation")
</code></pre>

<hr>
<h2 id='quasirandom'>
Quasirandom Patterns
</h2><span id='topic+quasirandom'></span><span id='topic+vdCorput'></span><span id='topic+Halton'></span><span id='topic+Hammersley'></span>

<h3>Description</h3>

<p>Generates quasirandom sequences of numbers and
quasirandom spatial patterns of points in any dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdCorput(n, base)

Halton(n, bases = c(2, 3), raw = FALSE, simplify = TRUE)

Hammersley(n, bases = 2, raw = FALSE, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quasirandom_+3A_n">n</code></td>
<td>

<p>Number of points to generate.
</p>
</td></tr>
<tr><td><code id="quasirandom_+3A_base">base</code></td>
<td>

<p>A prime number giving the base of the sequence.
</p>
</td></tr>
<tr><td><code id="quasirandom_+3A_bases">bases</code></td>
<td>

<p>Vector of prime numbers giving the bases of the sequences
for each coordinate axis.
</p>
</td></tr>
<tr><td><code id="quasirandom_+3A_raw">raw</code></td>
<td>

<p>Logical value indicating whether to return the coordinates
as a matrix (<code>raw=TRUE</code>) or as a spatial point
pattern (<code>raw=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="quasirandom_+3A_simplify">simplify</code></td>
<td>

<p>Argument passed to <code><a href="#topic+ppx">ppx</a></code> indicating whether
point patterns of dimension 2 or 3 should be
returned as objects of class <code>"ppp"</code> or <code>"pp3"</code>
respectively (<code>simplify=TRUE</code>, the default)
or as objects of class <code>"ppx"</code> (<code>simplify=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>vdCorput</code> generates the quasirandom sequence
of Van der Corput (1935) of length <code>n</code> with the given
<code>base</code>. These are numbers between 0 and 1 which are in
some sense uniformly distributed over the interval.
</p>
<p>The function <code>Halton</code> generates the Halton quasirandom sequence
of points in <code>d</code>-dimensional space, where
<code>d = length(bases)</code>. The values of the <code class="reqn">i</code>-th coordinate
of the points are generated using the van der Corput sequence with
base equal to <code>bases[i]</code>.
</p>
<p>The function <code>Hammersley</code> generates the Hammersley set
of points in <code>d+1</code>-dimensional space, where 
<code>d = length(bases)</code>. The first <code>d</code> coordinates
of the points are generated using the van der Corput sequence with
base equal to <code>bases[i]</code>. The <code>d+1</code>-th coordinate
is the sequence <code>1/n, 2/n, ..., 1</code>.
</p>
<p>If <code>raw=FALSE</code> (the default) then the Halton and Hammersley
sets are interpreted as spatial point patterns of the
appropriate dimension. They are returned as objects of
class <code>"ppx"</code> (multidimensional point patterns)
unless <code>simplify=TRUE</code> and <code>d=2</code> or <code>d=3</code>
when they are returned as objects of class <code>"ppp"</code>
or <code>"pp3"</code>.
If <code>raw=TRUE</code>, the coordinates are returned as a matrix
with <code>n</code> rows and <code>D</code> columns where <code>D</code> is the spatial
dimension.
</p>


<h3>Value</h3>

<p>For <code>vdCorput</code>, a numeric vector.
</p>
<p>For <code>Halton</code> and <code>Hammersley</code>,
an object of class <code>"ppp"</code>, <code>"pp3"</code> or
<code>"ppx"</code>; or if <code>raw=TRUE</code>, a numeric matrix.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Van der Corput, J. G. (1935) Verteilungsfunktionen.
<em>Proc. Ned. Akad. v. Wetensch.</em> <b>38</b>: 813&ndash;821.
</p>
<p>Kuipers, L. and Niederreiter, H. (2005)
<em>Uniform distribution of sequences</em>,
Dover Publications.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rQuasi">rQuasi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   vdCorput(10, 2)

   plot(Halton(256, c(2,3)))

   plot(Hammersley(256, 3))
</code></pre>

<hr>
<h2 id='raster.x'>Cartesian Coordinates for a Pixel Raster</h2><span id='topic+raster.x'></span><span id='topic+raster.y'></span><span id='topic+raster.xy'></span>

<h3>Description</h3>

<p>Return the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates
of each pixel in a pixel image or binary mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> raster.x(w, drop=FALSE)
 raster.y(w, drop=FALSE)
 raster.xy(w, drop=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster.x_+3A_w">w</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>) or a 
mask window (object of class <code>"owin"</code>
of type <code>"mask"</code>).
</p>
</td></tr>
<tr><td><code id="raster.x_+3A_drop">drop</code></td>
<td>

<p>Logical.
If <code>TRUE</code>, then coordinates of pixels that lie outside the
window are removed.
If <code>FALSE</code> (the default) then the coordinates of every
pixel in the containing rectangle are retained.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>w</code> should be either
a pixel image (object of class <code>"im"</code>)
or a mask window (an object of class
<code>"owin"</code> of type <code>"mask"</code>).
</p>
<p>If <code>drop=FALSE</code> (the default), the 
functions <code>raster.x</code> and <code>raster.y</code> return
a matrix of the same dimensions as the
pixel image or mask itself, with entries giving the <code class="reqn">x</code> coordinate
(for <code>raster.x</code>) or <code class="reqn">y</code> coordinate (for <code>raster.y</code>)
of each pixel in the pixel grid.
</p>
<p>If <code>drop=TRUE</code>, pixels that lie outside the
window <code>w</code> (or outside the domain of the image <code>w</code>)
are removed, and <code>raster.x</code> and <code>raster.y</code> 
return numeric vectors containing the coordinates of the
pixels that are inside the window <code>w</code>.
</p>
<p>The function <code>raster.xy</code> returns a list
with components <code>x</code> and <code>y</code>
which are numeric vectors of equal length containing the pixel coordinates.
</p>


<h3>Value</h3>

<p><code>raster.xy</code> returns a list with components <code>x</code> and <code>y</code>
which are numeric vectors of equal length containing the pixel coordinates.
</p>
<p>If <code>drop=FALSE</code>, 
<code>raster.x</code> and <code>raster.y</code> return 
a matrix of the same dimensions as the pixel grid in <code>w</code>,
and giving the value of the <code class="reqn">x</code> (or <code class="reqn">y</code>) coordinate
of each pixel in the raster.
</p>
<p>If <code>drop=TRUE</code>, 
<code>raster.x</code> and <code>raster.y</code> return numeric vectors.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.mask">as.mask</a></code>,
<code><a href="#topic+pixelcentres">pixelcentres</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  u &lt;- owin(c(-1,1),c(-1,1)) # square of side 2
  w &lt;- as.mask(u, eps=0.01) # 200 x 200 grid
  X &lt;- raster.x(w)
  Y &lt;- raster.y(w)
  disc &lt;- owin(c(-1,1), c(-1,1), mask=(X^2 + Y^2 &lt;= 1))
  # plot(disc)
  # approximation to the unit disc
</code></pre>

<hr>
<h2 id='rectdistmap'>
Distance Map Using Rectangular Distance Metric
</h2><span id='topic+rectdistmap'></span>

<h3>Description</h3>

<p>Computes the distance map of a spatial region
based on the rectangular distance metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectdistmap(X, asp = 1, npasses=1, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rectdistmap_+3A_x">X</code></td>
<td>

<p>A window (object of class <code>"owin"</code>).
</p>
</td></tr>
<tr><td><code id="rectdistmap_+3A_asp">asp</code></td>
<td>

<p>Aspect ratio for the metric.
See Details.
</p>
</td></tr>
<tr><td><code id="rectdistmap_+3A_npasses">npasses</code></td>
<td>

<p>Experimental. 
</p>
</td></tr>
<tr><td><code id="rectdistmap_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print trace information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the distance map of the
spatial region <code>X</code> using the rectangular distance metric
with aspect ratio <code>asp</code>. This metric is defined so that
the set of all points lying at most 1 unit away from the origin
(according to the metric) form a rectangle of width 1
and height <code>asp</code>.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmap">distmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  V &lt;- letterR
  Frame(V) &lt;- grow.rectangle(Frame(V), 0.5)
  plot(rectdistmap(V))
</code></pre>

<hr>
<h2 id='reflect'>Reflect In Origin</h2><span id='topic+reflect'></span><span id='topic+reflect.im'></span><span id='topic+reflect.default'></span>

<h3>Description</h3>

<p>Reflects a geometrical object through the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  reflect(X)

  ## S3 method for class 'im'
reflect(X)

  ## Default S3 method:
reflect(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reflect_+3A_x">X</code></td>
<td>
<p>Any suitable dataset representing a two-dimensional
object, such as a point pattern (object of class <code>"ppp"</code>),
or a window (object of class <code>"owin"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object <code>X</code> is reflected through the origin.
That is, each point in <code>X</code> with coordinates
<code class="reqn">(x,y)</code> is mapped to the position <code class="reqn">(-x, -y)</code>.
</p>
<p>This is equivalent to applying the affine transformation with matrix
<code>diag(c(-1,-1))</code>. It is also equivalent to rotation about the origin
by 180 degrees.
</p>
<p>The command <code>reflect</code> is generic, with a method for
pixel images and a default method.
</p>


<h3>Value</h3>

<p>Another object of the same type, representing the
result of reflection.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+flipxy">flipxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(reflect(as.im(letterR)))
  plot(reflect(letterR), add=TRUE)
</code></pre>

<hr>
<h2 id='regularpolygon'>
Create A Regular Polygon
</h2><span id='topic+regularpolygon'></span><span id='topic+hexagon'></span>

<h3>Description</h3>

<p>Create a window object representing a regular (equal-sided) polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regularpolygon(n, edge = 1, centre = c(0, 0), ...,
               align = c("bottom", "top", "left", "right", "no"))

hexagon(edge = 1, centre = c(0,0), ...,
        align = c("bottom", "top", "left", "right", "no"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regularpolygon_+3A_n">n</code></td>
<td>

<p>Number of edges in the polygon.
</p>
</td></tr>
<tr><td><code id="regularpolygon_+3A_edge">edge</code></td>
<td>

<p>Length of each edge in the polygon. A single positive number.
</p>
</td></tr>
<tr><td><code id="regularpolygon_+3A_centre">centre</code></td>
<td>

<p>Coordinates of the centre of the polygon.
A numeric vector of length 2,
or a <code>list(x,y)</code> giving the coordinates of exactly one point, or a
point pattern (object of class <code>"ppp"</code>) containing exactly one point.
</p>
</td></tr>
<tr><td><code id="regularpolygon_+3A_align">align</code></td>
<td>

<p>Character string specifying whether to align one of the edges with
a vertical or horizontal boundary.
</p>
</td></tr>
<tr><td><code id="regularpolygon_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>regularpolygon</code> creates a regular (equal-sided)
polygon with <code>n</code> sides, centred at <code>centre</code>,
with sides of equal length <code>edge</code>.
The function <code>hexagon</code> is the special case <code>n=6</code>.
</p>
<p>The orientation of the polygon is determined by the argument <code>align</code>.
If <code>align="no"</code>, one vertex of the polygon is placed on the
<code class="reqn">x</code>-axis.
Otherwise, an edge of the polygon is aligned with one side of
the frame, specified by the value of <code>align</code>.
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+disc">disc</a></code>, <code><a href="#topic+ellipse">ellipse</a></code>,
<code><a href="#topic+owin">owin</a></code>.
</p>
<p><code><a href="#topic+hextess">hextess</a></code> for hexagonal tessellations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(hexagon())
  plot(regularpolygon(7))
  plot(regularpolygon(7, align="left"))
</code></pre>

<hr>
<h2 id='relevel.im'>
Reorder Levels of a Factor-Valued Image or Pattern
</h2><span id='topic+relevel.im'></span><span id='topic+relevel.ppp'></span><span id='topic+relevel.ppx'></span>

<h3>Description</h3>

<p>For a pixel image with factor values, or a point pattern with
factor-valued marks, the levels of the factor are re-ordered so that
the level <code>ref</code> is first and the others are moved down.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
relevel(x, ref, ...)

  ## S3 method for class 'ppp'
relevel(x, ref, ...)

  ## S3 method for class 'ppx'
relevel(x, ref, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relevel.im_+3A_x">x</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>) with factor values,
or a point pattern (object of class <code>"ppp"</code>, <code>"ppx"</code>,
<code>"lpp"</code> or <code>"pp3"</code>) with
factor-valued marks.
</p>
</td></tr>
<tr><td><code id="relevel.im_+3A_ref">ref</code></td>
<td>

<p>The reference level.
</p>
</td></tr>
<tr><td><code id="relevel.im_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic
<code><a href="stats.html#topic+relevel">relevel</a></code>.
</p>
<p>If <code>x</code> is a pixel image (object of class <code>"im"</code>) with
factor values, or a point pattern (object of class <code>"ppp"</code>,
<code>"ppx"</code>, <code>"lpp"</code> or <code>"pp3"</code>)
with factor-valued marks, the levels of the factor are changed so
that the level specified by <code>ref</code> comes first. 
</p>


<h3>Value</h3>

<p>Object of the same kind as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mergeLevels">mergeLevels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  amacrine
  relevel(amacrine, "on")
</code></pre>

<hr>
<h2 id='Replace.im'>Reset Values in Subset of Image</h2><span id='topic++5B+3C-.im'></span>

<h3>Description</h3>

<p>Reset the values in a subset of a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 replacement method for class 'im'
x[i, j, ..., drop=TRUE] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Replace.im_+3A_x">x</code></td>
<td>

<p>A two-dimensional pixel image.
An object of class <code>"im"</code>.
</p>
</td></tr>
<tr><td><code id="Replace.im_+3A_i">i</code></td>
<td>

<p>Object defining the subregion or subset to be replaced.
Either a spatial window (an object of class <code>"owin"</code>), or a
pixel image with logical values, or a point pattern (an object
of class <code>"ppp"</code>), or any type of index that applies to a
matrix, or something that can be converted to a point pattern
by <code><a href="#topic+as.ppp">as.ppp</a></code> (using the window of <code>x</code>).
</p>
</td></tr>
<tr><td><code id="Replace.im_+3A_j">j</code></td>
<td>

<p>An integer or logical vector serving as the column index
if matrix indexing is being used.  Ignored if <code>i</code> is
appropriate to some sort of replacement <em>other than</em>
matrix indexing.
</p>
</td></tr>
<tr><td><code id="Replace.im_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Replace.im_+3A_drop">drop</code></td>
<td>

<p>Logical value specifying what happens when <code>i</code> and <code>j</code>
are both missing. See Details.
</p>
</td></tr>
<tr><td><code id="Replace.im_+3A_value">value</code></td>
<td>

<p>Vector, matrix, factor or pixel image
containing the replacement values.
Short vectors will be recycled.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function changes some of the pixel values in a
pixel image. The image <code>x</code> must be an object of class
<code>"im"</code> representing a pixel image defined inside a
rectangle in two-dimensional space (see <code><a href="#topic+im.object">im.object</a></code>).
</p>
<p>The subset to be changed is determined by the arguments <code>i,j</code>
according to the following rules (which are checked in this order):
</p>

<ol>
<li>
<p><code>i</code> is a spatial object such as a window,
a pixel image with logical values, or a point pattern;  or
</p>
</li>
<li>
<p><code>i,j</code> are indices for the matrix <code>as.matrix(x)</code>; or
</p>
</li>
<li>
<p><code>i</code> can be converted to a point pattern
by <code><a href="#topic+as.ppp">as.ppp</a>(i, W=Window(x))</code>,
and <code>i</code> is not a matrix.
</p>
</li></ol>

<p>If <code>i</code> is a spatial window (an object of class <code>"owin"</code>),
the values of the image inside this window are changed.
</p>
<p>If <code>i</code> is a point pattern (an object of class
<code>"ppp"</code>), then the values of the pixel image at the points of
this pattern are changed.
</p>
<p>If <code>i</code> does not satisfy any of the conditions above, then
the algorithm tries to interpret <code>i,j</code> as indices for the matrix
<code>as.matrix(x)</code>. Either <code>i</code> or <code>j</code> may be missing or blank.
</p>
<p>If none of the conditions above are met, and if <code>i</code> is not
a matrix, then <code>i</code> is converted into a point pattern
by <code><a href="#topic+as.ppp">as.ppp</a>(i, W=Window(x))</code>.
Again the values of the pixel image at the points of
this pattern are changed.
</p>
<p>If <code>i</code> and <code>j</code> are both missing, as in the call
<code>x[] &lt;- value</code>, then all pixel values in <code>x</code>
are replaced by <code>value</code>:
</p>

<ul>
<li>
<p>If <code>drop=TRUE</code> (the default), then
this replacement applies only to pixels whose values are currently defined
(i.e. where the current pixel value is not <code>NA</code>).
If <code>value</code> is a vector, then its length must equal
the number of pixels whose values are currently defined.
</p>
</li>
<li>
<p>If <code>drop=FALSE</code> then the replacement applies to all
pixels inside the rectangle <code>Frame(x)</code>.
If <code>value</code> is a vector, then its length 
must equal the number of pixels in the entire rectangle.
</p>
</li></ul>



<h3>Value</h3>

<p>The image <code>x</code> with the values replaced.
</p>


<h3>Warning</h3>

<p>If you have a 2-column matrix containing the <code class="reqn">x,y</code> coordinates
of point locations, then to prevent this being interpreted as an
array index, you should convert it to a <code>data.frame</code>
or to a point pattern.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im.object">im.object</a></code>,
<code><a href="#topic++5B.im">[.im</a></code>,
<code><a href="Matrix.html#topic++5B">[</a></code>,
<code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+as.ppp">as.ppp</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # make up an image
 X &lt;- setcov(unit.square())
 plot(X)

 # a rectangular subset
 W &lt;- owin(c(0,0.5),c(0.2,0.8))
 X[W] &lt;- 2
 plot(X)

 # a polygonal subset
 R &lt;- affine(letterR, diag(c(1,1)/2), c(-2,-0.7))
 X[R] &lt;- 3
 plot(X)

 # a point pattern
 X[cells] &lt;- 10
 plot(X)

 # change pixel value at a specific location
 X[list(x=0.1,y=0.2)] &lt;- 7

 # matrix indexing --- single vector index
 X[1:2570] &lt;- 10
 plot(X)

 # matrix indexing using double indices
 X[1:257,1:10] &lt;- 5
 plot(X)

 # matrix indexing using a matrix of indices
 X[cbind(1:257,1:257)] &lt;- 10
 X[cbind(257:1,1:257)] &lt;- 10
 plot(X)

 # Blank indices
 Y &lt;- as.im(letterR)
 plot(Y)
 Y[] &lt;- 42  # replace values only inside the window 'R'
 plot(Y)
 Y[drop=FALSE] &lt;- 7 # replace all values in the rectangle
 plot(Y)

 Z &lt;- as.im(letterR)
 Z[] &lt;- raster.x(Z, drop=TRUE) # excludes NA
 plot(Z)
 Z[drop=FALSE] &lt;- raster.y(Z, drop=FALSE) # includes NA
 plot(Z)
</code></pre>

<hr>
<h2 id='requireversion'>
Require a Specific Version of a Package
</h2><span id='topic+requireversion'></span>

<h3>Description</h3>

<p>Checks that the version number of a specified package is greater than or
equal to the specified version number.
For use in stand-alone <span class="rlang"><b>R</b></span> scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireversion(pkg, ver, fatal=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireversion_+3A_pkg">pkg</code></td>
<td>

<p>Package name.
</p>
</td></tr>
<tr><td><code id="requireversion_+3A_ver">ver</code></td>
<td>

<p>Character string containing version number.
</p>
</td></tr>
<tr><td><code id="requireversion_+3A_fatal">fatal</code></td>
<td>

<p>Logical value indicating whether an error should occur
when the package version is less than <code>ver</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks whether the installed version of the
package <code>pkg</code> is greater than or equal to <code>ver</code>.
By default, an error occurs if this condition is not met.
</p>
<p>It is useful in stand-alone <span class="rlang"><b>R</b></span> scripts, which often require
a particular version of a package in order to work correctly.
</p>
<p><b>This function should not be used inside a package</b>:
for that purpose, the dependence on packages and versions
should be specified in the package description file.
</p>


<h3>Value</h3>

<p>A logical value. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  requireversion(spatstat.geom, "1.42-0")
  requireversion(spatstat.data, "999.999-999", fatal=FALSE)
</code></pre>

<hr>
<h2 id='rescale'>Convert dataset to another unit of length</h2><span id='topic+rescale'></span>

<h3>Description</h3>

<p>Converts between different units of length
in a spatial dataset, such as a point pattern or a window. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rescale(X, s, unitname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_+3A_x">X</code></td>
<td>
<p>Any suitable dataset representing a two-dimensional
object, such as a point pattern (object of class <code>"ppp"</code>),
or a window (object of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="rescale_+3A_s">s</code></td>
<td>
<p>Conversion factor: the new units are <code>s</code> times the old
units.</p>
</td></tr>
<tr><td><code id="rescale_+3A_unitname">unitname</code></td>
<td>

<p>Optional. New name for the unit of length.
See <code><a href="#topic+unitname">unitname</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is generic. Methods are provided for many spatial objects.
</p>
<p>The spatial coordinates in the dataset <code>X</code> will be re-expressed
in terms of a new unit of length that is <code>s</code> times the current
unit of length given in <code>X</code>. The name of the unit of length
will also be adjusted. The result is an object of the same type,
representing the same data, but expressed in the new units.
</p>
<p>For example if <code>X</code> is a dataset giving coordinates in metres,
then <code>rescale(X,1000)</code> will take the new unit of length
to be 1000 metres.
To do this, it will divide the old coordinate values by 1000
to obtain coordinates expressed in kilometres, and change the
name of the unit of length from <code>"metres"</code> to <code>"1000 metres"</code>.
</p>
<p>If <code>unitname</code> is given, it will be taken as the new name of the unit
of length. It should be a valid name for the
unit of length, as described in the help for <code><a href="#topic+unitname">unitname</a></code>.
For example if <code>X</code> is a dataset giving coordinates in metres,
<code>rescale(X, 1000, "km")</code> will divide the coordinate
values by 1000 to obtain coordinates in
kilometres, and the unit name will be changed to <code>"km"</code>.
</p>


<h3>Value</h3>

<p>Another object of the same type, representing the same
data, but expressed in the new units.
</p>


<h3>Note</h3>

<p>The result of this operation is equivalent to the original dataset.
If you want to actually change the coordinates by
a linear transformation, producing a dataset that is not equivalent
to the original one, use <code><a href="#topic+affine">affine</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>Available methods:
<code><a href="#topic+rescale.im">rescale.im</a></code>,
<code><a href="#topic+rescale.layered">rescale.layered</a></code>,
<code><a href="#topic+rescale.owin">rescale.owin</a></code>,
<code><a href="#topic+rescale.ppp">rescale.ppp</a></code>,
<code><a href="#topic+rescale.psp">rescale.psp</a></code>
and <code><a href="#topic+rescale.unitname">rescale.unitname</a></code>.
</p>
<p>Other generics: 
<code><a href="#topic+unitname">unitname</a></code>,
<code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+shift">shift</a></code>.
</p>

<hr>
<h2 id='rescale.im'>Convert Pixel Image to Another Unit of Length</h2><span id='topic+rescale.im'></span>

<h3>Description</h3>

<p>Converts a pixel image to 
another unit of length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'im'
rescale(X, s, unitname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale.im_+3A_x">X</code></td>
<td>
<p>Pixel image (object of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="rescale.im_+3A_s">s</code></td>
<td>
<p>Conversion factor: the new units are <code>s</code> times the old units.</p>
</td></tr>
<tr><td><code id="rescale.im_+3A_unitname">unitname</code></td>
<td>

<p>Optional. New name for the unit of length.
See <code><a href="#topic+unitname">unitname</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+rescale">rescale</a></code>.
</p>
<p>The spatial coordinates of the pixels in <code>X</code>
will be re-expressed
in terms of a new unit of length that is <code>s</code> times the current
unit of length given in <code>X</code>.
(Thus, the coordinate values are <em>divided</em> by <code>s</code>,
while the unit value is multiplied by <code>s</code>).
</p>
<p>If <code>s</code> is missing, then the coordinates will be re-expressed
in &lsquo;native&rsquo; units; for example if the current unit is
equal to 0.1 metres, then the coordinates will be re-expressed in metres.
</p>
<p>The result is a pixel image representing the <em>same</em> data
but re-expressed in a different unit.
</p>
<p>Pixel values are unchanged. This may not be what you intended!
</p>


<h3>Value</h3>

<p>Another pixel image (of class <code>"im"</code>),
containing the same pixel values, but with pixel coordinates
expressed in the new units.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im">im</a></code>,
<code><a href="#topic+rescale">rescale</a></code>,
<code><a href="#topic+unitname">unitname</a></code>,
<code><a href="#topic+eval.im">eval.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bramble Canes data: 1 unit = 9 metres
  bramblecanes
# distance transform
  Z &lt;- distmap(bramblecanes)
# convert to metres
# first alter the pixel values
  Zm &lt;- eval.im(9 * Z)
# now rescale the pixel coordinates
  Z &lt;- rescale(Zm, 1/9)
# or equivalently
  Z &lt;- rescale(Zm)
</code></pre>

<hr>
<h2 id='rescale.owin'>Convert Window to Another Unit of Length</h2><span id='topic+rescale.owin'></span>

<h3>Description</h3>

<p>Converts a window to another unit of length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'owin'
rescale(X, s, unitname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale.owin_+3A_x">X</code></td>
<td>
<p>Window (object of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="rescale.owin_+3A_s">s</code></td>
<td>
<p>Conversion factor: the new units are <code>s</code> times the old units.</p>
</td></tr>
<tr><td><code id="rescale.owin_+3A_unitname">unitname</code></td>
<td>

<p>Optional. New name for the unit of length.
See <code><a href="#topic+unitname">unitname</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+rescale">rescale</a></code>.
</p>
<p>The spatial coordinates in the window <code>X</code>
(and its window) will be re-expressed
in terms of a new unit of length that is <code>s</code> times the current
unit of length given in <code>X</code>.
(Thus, the coordinate values are <em>divided</em> by <code>s</code>,
while the unit value is multiplied by <code>s</code>).
</p>
<p>The result is a window representing the <em>same</em> region of space,
but re-expressed in a different unit.
</p>
<p>If <code>s</code> is missing, then the coordinates will be re-expressed
in &lsquo;native&rsquo; units; for example if the current unit is
equal to 0.1 metres, then the coordinates will be re-expressed in metres.
</p>


<h3>Value</h3>

<p>Another window object (of class <code>"owin"</code>) representing the same
window, but expressed in the new units.
</p>


<h3>Note</h3>

<p>The result of this operation is equivalent to the original window.
If you want to actually change the coordinates by
a linear transformation, producing a window that is larger or smaller
than the original one, use <code><a href="#topic+affine">affine</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unitname">unitname</a></code>,
<code><a href="#topic+rescale">rescale</a></code>,
<code><a href="#topic+rescale.owin">rescale.owin</a></code>,
<code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  W &lt;- Window(swedishpines)
  W
# coordinates are in decimetres (0.1 metre)
# convert to metres:
  rescale(W, 10)
# or equivalently
  rescale(W)
</code></pre>

<hr>
<h2 id='rescale.ppp'>Convert Point Pattern to Another Unit of Length</h2><span id='topic+rescale.ppp'></span>

<h3>Description</h3>

<p>Converts a point pattern dataset to 
another unit of length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppp'
rescale(X, s, unitname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale.ppp_+3A_x">X</code></td>
<td>
<p>Point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="rescale.ppp_+3A_s">s</code></td>
<td>
<p>Conversion factor: the new units are <code>s</code> times the old units.</p>
</td></tr>
<tr><td><code id="rescale.ppp_+3A_unitname">unitname</code></td>
<td>

<p>Optional. New name for the unit of length.
See <code><a href="#topic+unitname">unitname</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+rescale">rescale</a></code>.
</p>
<p>The spatial coordinates in the point pattern <code>X</code>
(and its window) will be re-expressed
in terms of a new unit of length that is <code>s</code> times the current
unit of length given in <code>X</code>.
(Thus, the coordinate values are <em>divided</em> by <code>s</code>,
while the unit value is multiplied by <code>s</code>).
</p>
<p>The result is a point pattern representing the <em>same</em> data
but re-expressed in a different unit.
</p>
<p>Mark values are unchanged.
</p>
<p>If <code>s</code> is missing, then the coordinates will be re-expressed
in &lsquo;native&rsquo; units; for example if the current unit is
equal to 0.1 metres, then the coordinates will be re-expressed in metres.
</p>


<h3>Value</h3>

<p>Another point pattern (of class <code>"ppp"</code>),
representing the same data, but expressed in the new units.
</p>


<h3>Note</h3>

<p>The result of this operation is equivalent to the original point pattern.
If you want to actually change the coordinates by
a linear transformation, producing a point pattern that is not
equivalent to the original one, use <code><a href="#topic+affine">affine</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unitname">unitname</a></code>,
<code><a href="#topic+rescale">rescale</a></code>,
<code><a href="#topic+rescale.owin">rescale.owin</a></code>,
<code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bramble Canes data: 1 unit = 9 metres
# convert to metres
  bram &lt;- rescale(bramblecanes, 1/9)
# or equivalently
  bram &lt;- rescale(bramblecanes)
</code></pre>

<hr>
<h2 id='rescale.psp'>Convert Line Segment Pattern to Another Unit of Length</h2><span id='topic+rescale.psp'></span>

<h3>Description</h3>

<p>Converts a line segment pattern dataset to 
another unit of length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'psp'
rescale(X, s, unitname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale.psp_+3A_x">X</code></td>
<td>
<p>Line segment pattern (object of class <code>"psp"</code>).</p>
</td></tr>
<tr><td><code id="rescale.psp_+3A_s">s</code></td>
<td>
<p>Conversion factor: the new units are <code>s</code> times the old units.</p>
</td></tr>
<tr><td><code id="rescale.psp_+3A_unitname">unitname</code></td>
<td>

<p>Optional. New name for the unit of length.
See <code><a href="#topic+unitname">unitname</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+rescale">rescale</a></code>.
</p>
<p>The spatial coordinates in the line segment pattern <code>X</code>
(and its window) will be re-expressed
in terms of a new unit of length that is <code>s</code> times the current
unit of length given in <code>X</code>.
(Thus, the coordinate values are <em>divided</em> by <code>s</code>,
while the unit value is multiplied by <code>s</code>).
</p>
<p>The result is a line segment pattern representing the <em>same</em> data
but re-expressed in a different unit.
</p>
<p>Mark values are unchanged.
</p>
<p>If <code>s</code> is missing, then the coordinates will be re-expressed
in &lsquo;native&rsquo; units; for example if the current unit is
equal to 0.1 metres, then the coordinates will be re-expressed in metres.
</p>


<h3>Value</h3>

<p>Another line segment pattern (of class <code>"psp"</code>),
representing the same data, but expressed in the new units.
</p>


<h3>Note</h3>

<p>The result of this operation is equivalent to the original segment pattern.
If you want to actually change the coordinates by
a linear transformation, producing a segment pattern that is not
equivalent to the original one, use <code><a href="#topic+affine">affine</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+units">units</a></code>,
<code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- copper$Lines
   X
   # data are in km
   # convert to metres
   rescale(X, 1/1000)

   # convert data and rename unit
   rescale(X, 1/1000, c("metre", "metres"))
</code></pre>

<hr>
<h2 id='rescue.rectangle'>Convert Window Back To Rectangle</h2><span id='topic+rescue.rectangle'></span>

<h3>Description</h3>

<p>Determines whether the given window is really a rectangle
aligned with the coordinate axes, and if so, converts it to
a rectangle object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rescue.rectangle(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescue.rectangle_+3A_w">W</code></td>
<td>
<p>A window (object of class <code>"owin"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function decides whether the window <code>W</code> is actually a rectangle
aligned with the coordinate axes. This will be true if
<code>W</code> is 
</p>

<ul>
<li><p> a rectangle (window object of type <code>"rectangle"</code>);
</p>
</li>
<li><p> a polygon (window object of type <code>"polygonal"</code>
with a single polygonal boundary) that is a rectangle aligned with
the coordinate axes;
</p>
</li>
<li><p> a binary mask (window object of type <code>"mask"</code>) in which
all the pixel entries are <code>TRUE</code>.
</p>
</li></ul>

<p>If so, the function returns
this rectangle, a window object of type <code>"rectangle"</code>.
If not, the function returns <code>W</code>.
</p>


<h3>Value</h3>

<p>Another object of class <code>"owin"</code> representing the
same window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- owin(poly=list(x=c(0,1,1,0),y=c(0,0,1,1)))
  rw &lt;- rescue.rectangle(w)

  w &lt;- as.mask(unit.square())
  rw &lt;- rescue.rectangle(w)
</code></pre>

<hr>
<h2 id='restrict.colourmap'>
Restrict a Colour Map to a Subset of Values
</h2><span id='topic+restrict.colourmap'></span>

<h3>Description</h3>

<p>Given a colour map defined on a range of numerical values or a set of
discrete inputs, the command restricts the range of values to a narrower range,
or restricts the set of inputs to a subset, and returns the associated
colour map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrict.colourmap(x, ..., range = NULL, breaks = NULL, inputs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrict.colourmap_+3A_x">x</code></td>
<td>

<p>Colour map (object of class <code>"colourmap"</code>).
</p>
</td></tr>
<tr><td><code id="restrict.colourmap_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="restrict.colourmap_+3A_range">range</code></td>
<td>

<p>New, restricted range of numerical values to which the
colour map will apply. A numeric vector of length 2 giving the
minimum and maximum values of the input.
Incompatible with <code>breaks</code> and <code>inputs</code>.
</p>
</td></tr>
<tr><td><code id="restrict.colourmap_+3A_breaks">breaks</code></td>
<td>

<p>Vector of breakpoints for the new colour map.
A numeric vector with increasing entries.
Incompatible with <code>range</code> and <code>inputs</code>.
</p>
</td></tr>
<tr><td><code id="restrict.colourmap_+3A_inputs">inputs</code></td>
<td>

<p>Values accepted as inputs for the new colour map.
A factor or vector.
Incompatible with <code>breaks</code> and <code>range</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command produces a new colour map <code>y</code> which is consistent with the
original colour map <code>x</code>, except that <code>y</code> is defined on a
narrower interval of numeric values, or a smaller set of discrete
input values, than <code>x</code>.
</p>


<h3>Value</h3>

<p>Colour map (object of class <code>"colourmap"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colourmap">colourmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(a &lt;- colourmap(topo.colors(128), range=c(-1,1)))
  plot(b &lt;- restrict.colourmap(a, range=c(0,1)))
</code></pre>

<hr>
<h2 id='rexplode'>
Explode a Point Pattern by Displacing Duplicated Points
</h2><span id='topic+rexplode'></span><span id='topic+rexplode.ppp'></span>

<h3>Description</h3>

<p>Given a point pattern which contains duplicated points,
separate the duplicated points from each other by
slightly perturbing their positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rexplode(X, ...)

## S3 method for class 'ppp'
rexplode(X, radius, ..., nsim = 1, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rexplode_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="rexplode_+3A_radius">radius</code></td>
<td>

<p>Scale of perturbations. A positive numerical value.
The displacement vectors will be uniformly
distributed in a circle of this radius.
There is a sensible default.
Alternatively, <code>radius</code> may be a numeric vector of length
equal to the number of points in <code>X</code>, giving a different
displacement radius for each data point.
Radii will be restricted to be less than or equal to the distance
to the boundary of the window.
</p>
</td></tr>
<tr><td><code id="rexplode_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="rexplode_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rexplode_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Duplicated points in the point pattern <code>X</code> are identified.
Each group of duplicated points is then &lsquo;exploded&rsquo; by
randomly displacing the point locations to form a circular arrangement
around the original position.
</p>
<p>This function is an alternative to <code><a href="#topic+rjitter.ppp">rjitter.ppp</a></code>.
Whereas <code><a href="#topic+rjitter.ppp">rjitter.ppp</a></code>
applies independent random displacements to each data point,
<code>rexplode.ppp</code> applies displacements only to the points
that are duplicated, and the displacements are mutually dependent
within each group of duplicates, to ensure that the displaced points
are visually separated from each other.
</p>
<p>First the code ensures that the displacement radius for each
data point is less than or equal to the distance to the boundary
of the window. Then each group of duplicated points (or data points
with the same location but possibly different mark values) is
taken in turn. The first element of the group is randomly displaced
by a vector uniformly distributed in a circle of radius <code>radius</code>.
The remaining elements of the group are then positioned around the
original location, at the same distance from the orginal location,
with equal angular spacing from the first point.
The result is that each group of duplicated points becomes
a circular pattern centred around the original location.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
or a list of point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rjitter.ppp">rjitter.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## create a pattern containing duplicated points
   X &lt;- runifrect(5) %mark% letters[1:5]
   X &lt;- X[rep(1:5, 1 + rpois(5, 2))]
   ## explode it
   Y &lt;- rexplode(X, 0.05)
   ## display
   if(interactive()) {
       plot(solist(X=X, 'explode(X)'=Y),
       main="", cols=2:6, cex=1.25, leg.side="bottom")
   }
</code></pre>

<hr>
<h2 id='rgbim'>Create Colour-Valued Pixel Image</h2><span id='topic+rgbim'></span><span id='topic+hsvim'></span>

<h3>Description</h3>

<p>Creates an object of
class <code>"im"</code> representing a two-dimensional pixel image
whose pixel values are colours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rgbim(R, G, B, A, maxColorValue=255, autoscale=FALSE)
  hsvim(H, S, V, A, autoscale=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgbim_+3A_r">R</code>, <code id="rgbim_+3A_g">G</code>, <code id="rgbim_+3A_b">B</code></td>
<td>

<p>Pixel images (objects of class <code>"im"</code>) or constants
giving the red, green, and blue components of a colour, respectively.
</p>
</td></tr>
<tr><td><code id="rgbim_+3A_a">A</code></td>
<td>

<p>Optional. Pixel image or constant value
giving the alpha (transparency) component of a colour.
</p>
</td></tr>
<tr><td><code id="rgbim_+3A_maxcolorvalue">maxColorValue</code></td>
<td>

<p>Maximum colour channel value for <code>R,G,B,A</code>.
</p>
</td></tr>
<tr><td><code id="rgbim_+3A_h">H</code>, <code id="rgbim_+3A_s">S</code>, <code id="rgbim_+3A_v">V</code></td>
<td>

<p>Pixel images (objects of class <code>"im"</code>) or constants
giving the hue, saturation, and value components of
a colour, respectively.
</p>
</td></tr>
<tr><td><code id="rgbim_+3A_autoscale">autoscale</code></td>
<td>

<p>Logical. If <code>TRUE</code>, input values are automatically rescaled
to fit the permitted range. RGB values are scaled to lie between
0 and <code>maxColorValue</code>. HSV values are scaled to lie between 0
and 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions take three pixel images, with real or integer pixel values,
and create a single pixel image whose pixel values are colours
recognisable to <span class="rlang"><b>R</b></span>.
</p>
<p>Some of the arguments may be constant numeric values, but
at least one of the arguments must be a pixel image.
The image arguments should be compatible (in array dimension
and in spatial position).
</p>
<p><code>rgbim</code> calls <code><a href="grDevices.html#topic+rgb">rgb</a></code> to compute the colours,
while <code>hsvim</code> calls <code><a href="grDevices.html#topic+hsv">hsv</a></code>. See the help for the relevant
function for more information about the meaning of the colour
channels.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im.object">im.object</a></code>,
<code><a href="grDevices.html#topic+rgb">rgb</a></code>,
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.
</p>
<p>See <code><a href="#topic+colourtools">colourtools</a></code>
for additional colour tools.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # create three images with values in [0,1]
  X &lt;- setcov(owin())
  X &lt;- eval.im(pmin(1,X))
  M &lt;- Window(X)
  Y &lt;- as.im(function(x,y){(x+1)/2}, W=M)
  Z &lt;- as.im(function(x,y){(y+1)/2}, W=M)
  # convert 
  RGB &lt;- rgbim(X, Y, Z, maxColorValue=1)
  HSV &lt;- hsvim(X, Y, Z)
  opa &lt;- par(mfrow=c(1,2))
  plot(RGB, valuesAreColours=TRUE)
  plot(HSV, valuesAreColours=TRUE)
  par(opa)
  
</code></pre>

<hr>
<h2 id='ripras'>Estimate window from points alone</h2><span id='topic+ripras'></span>

<h3>Description</h3>

<p>Given an observed pattern of points,
computes the Ripley-Rasson estimate of 
the spatial domain from which they came.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ripras(x, y=NULL, shape="convex", f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ripras_+3A_x">x</code></td>
<td>

<p>vector of <code>x</code> coordinates of observed points,
or a 2-column matrix giving <code>x,y</code> coordinates,
or a list with components <code>x,y</code> giving coordinates
(such as a point pattern object of class <code>"ppp"</code>.)
</p>
</td></tr>
<tr><td><code id="ripras_+3A_y">y</code></td>
<td>
<p>(optional) vector of <code>y</code> coordinates of observed points,
if <code>x</code> is a vector.</p>
</td></tr>
<tr><td><code id="ripras_+3A_shape">shape</code></td>
<td>
<p>String indicating the type of window to be estimated:
either <code>"convex"</code> or <code>"rectangle"</code>.
</p>
</td></tr>
<tr><td><code id="ripras_+3A_f">f</code></td>
<td>

<p>(optional) scaling factor. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an observed pattern of points with coordinates 
given by <code>x</code> and <code>y</code>, this function computes 
an estimate due to Ripley and Rasson (1977) of the
spatial domain from which the points came. 
</p>
<p>The points are
assumed to have been generated independently and uniformly
distributed inside an unknown domain <code class="reqn">D</code>.
</p>
<p>If <code>shape="convex"</code> (the default), the domain <code class="reqn">D</code> is assumed
to be a convex set. The maximum
likelihood estimate of <code class="reqn">D</code> is the convex hull of the 
points (computed by <code><a href="#topic+convexhull.xy">convexhull.xy</a></code>).
Analogously to the problems of estimating the endpoint
of a uniform distribution, the MLE is not optimal.
Ripley and Rasson's estimator is a rescaled copy of the convex hull,
centred at the centroid of the convex hull.
The scaling factor is 
<code class="reqn">1/sqrt(1 - m/n)</code>
where <code class="reqn">n</code> is the number of data points and 
<code class="reqn">m</code> the number of vertices of the convex hull.
The scaling factor may be overridden using the argument <code>f</code>.
</p>
<p>If <code>shape="rectangle"</code>, the domain <code class="reqn">D</code> is assumed
to be a rectangle with sides parallel to the coordinate axes. The maximum
likelihood estimate of <code class="reqn">D</code> is the bounding box of the points
(computed by <code><a href="#topic+bounding.box.xy">bounding.box.xy</a></code>). The Ripley-Rasson
estimator is a rescaled copy of the bounding box,
with scaling factor <code class="reqn">(n+1)/(n-1)</code>
where <code class="reqn">n</code> is the number of data points,
centred at the centroid of the bounding box.
The scaling factor may be overridden using the argument <code>f</code>.
</p>


<h3>Value</h3>

<p>A window (an object of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Ripley, B.D. and Rasson, J.-P. (1977)
Finding the edge of a Poisson forest.
<em>Journal of Applied Probability</em>,
<b>14</b>, 483 &ndash; 491.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+bounding.box.xy">bounding.box.xy</a></code>,
<code><a href="#topic+convexhull.xy">convexhull.xy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- runif(30)
  y &lt;- runif(30)
  w &lt;- ripras(x,y)
  plot(owin(), main="ripras(x,y)")
  plot(w, add=TRUE)
  points(x,y)

  X &lt;- runifrect(15)
  plot(X, main="ripras(X)")
  plot(ripras(X), add=TRUE)

  # two points insufficient
  ripras(c(0,1),c(0,0))
  # triangle
  ripras(c(0,1,0.5), c(0,0,1))
  # three collinear points
  ripras(c(0,0,0), c(0,1,2))
</code></pre>

<hr>
<h2 id='rjitter'>Random Perturbation of a Point Pattern</h2><span id='topic+rjitter'></span><span id='topic+rjitter.ppp'></span>

<h3>Description</h3>

<p>Applies independent random displacements to each point in a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
rjitter(X, ...)

## S3 method for class 'ppp'
rjitter(X, radius, retry=TRUE, giveup = 10000, trim=FALSE,
        ..., nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rjitter_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="rjitter_+3A_radius">radius</code></td>
<td>

<p>Scale of perturbations. A positive numerical value.
The displacement vectors will be uniformly
distributed in a circle of this radius.
There is a sensible default.
Alternatively, <code>radius</code> may be a numeric vector of length
equal to the number of points in <code>X</code>, giving a different
displacement radius for each data point.
</p>
</td></tr>
<tr><td><code id="rjitter_+3A_retry">retry</code></td>
<td>

<p>What to do when a perturbed point lies outside the window
of the original point pattern. If <code>retry=FALSE</code>,
the point will be lost; if <code>retry=TRUE</code>,
the algorithm will try again.
</p>
</td></tr>
<tr><td><code id="rjitter_+3A_giveup">giveup</code></td>
<td>

<p>Maximum number of unsuccessful attempts.
</p>
</td></tr>
<tr><td><code id="rjitter_+3A_trim">trim</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, the displacement radius
for each data point will be constrained to be less than or equal to
the distance from the data point to the window boundary.
This ensures that all displaced points will fall inside the window.
</p>
</td></tr>
<tr><td><code id="rjitter_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="rjitter_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rjitter_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>rjitter</code> is generic, with methods for point
patterns (described here) and for some other types of geometrical objects.
</p>
<p>Each of the points in the point pattern <code>X</code> is subjected to
an independent random displacement. The displacement vectors are
uniformly distributed in a circle of radius <code>radius</code>.
</p>
<p>If a displaced point lies outside the window, then if
<code>retry=FALSE</code> the point will be lost. 
</p>
<p>However if <code>retry=TRUE</code>, the algorithm will try again: each time a
perturbed point lies outside the window, the algorithm will reject it and
generate another proposed perturbation of the original point,
until one lies inside the window, or until <code>giveup</code> unsuccessful
attempts have been made. In the latter case, any unresolved points
will be included without any perturbation. The return value will
always be a point pattern with the same number of points as <code>X</code>.
</p>
<p>If <code>trim=TRUE</code>, then the displacement radius for each data point
will be constrained to be less than or equal to 
the distance from the data point to the window boundary.
This ensures that the randomly displaced points will
always fall inside the window; no displaced points will be lost and no
retrying will be required.
</p>


<h3>Value</h3>

<p>The result of <code>rjitter.ppp</code> is
a point pattern (an object of class <code>"ppp"</code>)
or a list of point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rexplode">rexplode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rsyst(owin(), 10, 10)
   Y &lt;- rjitter(X, 0.02)
   plot(Y)
   Z &lt;- rjitter(X)
   U &lt;- rjitter(X, 0.025, trim=TRUE)
</code></pre>

<hr>
<h2 id='rlinegrid'>Generate grid of parallel lines with random displacement</h2><span id='topic+rlinegrid'></span>

<h3>Description</h3>

<p>Generates a grid of parallel lines, equally spaced, inside the
specified window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rlinegrid(angle = 45, spacing = 0.1, win = owin())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlinegrid_+3A_angle">angle</code></td>
<td>
<p>Common orientation of the lines, in degrees anticlockwise
from the x axis.
</p>
</td></tr>
<tr><td><code id="rlinegrid_+3A_spacing">spacing</code></td>
<td>
<p>Spacing between successive lines.</p>
</td></tr>
<tr><td><code id="rlinegrid_+3A_win">win</code></td>
<td>
<p>Window in which to generate the lines. An object of
class <code>"owin"</code> or something acceptable to
<code><a href="#topic+as.owin">as.owin</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The grid is randomly displaced from the origin.
</p>


<h3>Value</h3>

<p>A line segment pattern (object of class <code>"psp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp">psp</a></code>,
<code><a href="spatstat.random.html#topic+rpoisline">rpoisline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(rlinegrid(30, 0.05))
</code></pre>

<hr>
<h2 id='rotate'>Rotate</h2><span id='topic+rotate'></span>

<h3>Description</h3>

<p>Applies a rotation to any two-dimensional object,
such as a point pattern or a window. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rotate(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_+3A_x">X</code></td>
<td>
<p>Any suitable dataset representing a two-dimensional
object, such as a point pattern (object of class <code>"ppp"</code>),
or a window (object of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="rotate_+3A_...">...</code></td>
<td>
<p>Data specifying the rotation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is generic. Methods are provided for
point patterns (<code><a href="#topic+rotate.ppp">rotate.ppp</a></code>)
and windows (<code><a href="#topic+rotate.owin">rotate.owin</a></code>).
</p>


<h3>Value</h3>

<p>Another object of the same type, representing the
result of rotating <code>X</code> through the specified angle.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotate.ppp">rotate.ppp</a></code>,
<code><a href="#topic+rotate.owin">rotate.owin</a></code>
</p>

<hr>
<h2 id='rotate.im'>Rotate a Pixel Image</h2><span id='topic+rotate.im'></span>

<h3>Description</h3>

<p>Rotates a pixel image
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'im'
rotate(X, angle=pi/2, ..., centre=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate.im_+3A_x">X</code></td>
<td>
<p>A pixel image (object of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="rotate.im_+3A_angle">angle</code></td>
<td>
<p>Angle of rotation, in radians.</p>
</td></tr>
<tr><td><code id="rotate.im_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="rotate.im_+3A_centre">centre</code></td>
<td>

<p>Centre of rotation.
Either a vector of length 2, or a character string
(partially matched to <code>"centroid"</code>, <code>"midpoint"</code>
or <code>"bottomleft"</code>).
The default is the coordinate origin <code>c(0,0)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The image is rotated by the angle specified.
Angles are measured in radians, anticlockwise.
The default is to rotate the image 90 degrees anticlockwise. 
</p>


<h3>Value</h3>

<p>Another object of class <code>"im"</code> representing the
rotated pixel image.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+affine.im">affine.im</a></code>,
<code><a href="#topic+shift.im">shift.im</a></code>,
<code><a href="#topic+rotate">rotate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Z &lt;- distmap(letterR)
  X &lt;- rotate(Z)
  # plot(X)
  Y &lt;- rotate(X, centre="midpoint")
</code></pre>

<hr>
<h2 id='rotate.infline'>
Rotate or Shift Infinite Lines
</h2><span id='topic+rotate.infline'></span><span id='topic+shift.infline'></span><span id='topic+reflect.infline'></span><span id='topic+flipxy.infline'></span>

<h3>Description</h3>

<p>Given the coordinates of one or more infinite straight lines in the
plane, apply a rotation or shift.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'infline'
rotate(X, angle = pi/2, ...)

## S3 method for class 'infline'
shift(X, vec = c(0,0), ...)

## S3 method for class 'infline'
reflect(X)

## S3 method for class 'infline'
flipxy(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate.infline_+3A_x">X</code></td>
<td>

<p>Object of class <code>"infline"</code> representing one or more
infinite straight lines in the plane.
</p>
</td></tr>
<tr><td><code id="rotate.infline_+3A_angle">angle</code></td>
<td>

<p>Angle of rotation, in radians.
</p>
</td></tr>
<tr><td><code id="rotate.infline_+3A_vec">vec</code></td>
<td>

<p>Translation (shift) vector: a numeric vector of length 2,
or a <code>list(x,y)</code>, or a point pattern containing one point.
</p>
</td></tr>
<tr><td><code id="rotate.infline_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic
<code><a href="#topic+shift">shift</a></code>, <code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+reflect">reflect</a></code> and <code><a href="#topic+flipxy">flipxy</a></code>
for the class <code>"infline"</code>.
</p>
<p>An object of class <code>"infline"</code> represents one or more
infinite lines in the plane.
</p>


<h3>Value</h3>

<p>Another <code>"infline"</code> object representing the
result of the transformation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+infline">infline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  L &lt;- infline(v=0.5)

  plot(square(c(-1,1)), main="rotate lines", type="n")
  points(0, 0, pch=3)
  plot(L, col="green")
  plot(rotate(L, pi/12), col="red")
  plot(rotate(L, pi/6), col="red")
  plot(rotate(L, pi/4), col="red")

  L &lt;- infline(p=c(0.4, 0.9), theta=pi* c(0.2, 0.6))

  plot(square(c(-1,1)), main="shift lines", type="n")
  L &lt;- infline(p=c(0.7, 0.8), theta=pi* c(0.2, 0.6))
  plot(L, col="green")
  plot(shift(L, c(-0.5, -0.4)), col="red")

  plot(square(c(-1,1)), main="reflect lines", type="n")
  points(0, 0, pch=3)
  L &lt;- infline(p=c(0.7, 0.8), theta=pi* c(0.2, 0.6))
  plot(L, col="green")
  plot(reflect(L), col="red")

</code></pre>

<hr>
<h2 id='rotate.owin'>Rotate a Window</h2><span id='topic+rotate.owin'></span>

<h3>Description</h3>

<p>Rotates a window
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'owin'
rotate(X, angle=pi/2, ..., rescue=TRUE, centre=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate.owin_+3A_x">X</code></td>
<td>
<p>A window (object of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="rotate.owin_+3A_angle">angle</code></td>
<td>
<p>Angle of rotation.</p>
</td></tr>
<tr><td><code id="rotate.owin_+3A_rescue">rescue</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the rotated window
will be processed by <code><a href="#topic+rescue.rectangle">rescue.rectangle</a></code>.
</p>
</td></tr>
<tr><td><code id="rotate.owin_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
controlling the resolution of the rotated window, if <code>X</code> is a
binary pixel mask. Ignored if <code>X</code> is not a binary mask.
</p>
</td></tr>
<tr><td><code id="rotate.owin_+3A_centre">centre</code></td>
<td>

<p>Centre of rotation.
Either a vector of length 2, or a character string
(partially matched to <code>"centroid"</code>, <code>"midpoint"</code>
or <code>"bottomleft"</code>).
The default is the coordinate origin <code>c(0,0)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rotates the window by the specified angle. Angles are measured in
radians, anticlockwise. The default is to rotate the window 90 degrees
anticlockwise. The centre of rotation is the origin, by default,
unless <code>centre</code> is specified.
</p>


<h3>Value</h3>

<p>Another object of class <code>"owin"</code> representing the
rotated window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin.object">owin.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- owin(c(0,1),c(0,1))
  v &lt;- rotate(w, pi/3)
  e &lt;- rotate(w, pi/2, centre="midpoint")
  # plot(v)
  w &lt;- as.mask(letterR)
  v &lt;- rotate(w, pi/5)
</code></pre>

<hr>
<h2 id='rotate.ppp'>Rotate a Point Pattern</h2><span id='topic+rotate.ppp'></span>

<h3>Description</h3>

<p>Rotates a point pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppp'
rotate(X, angle=pi/2, ..., centre=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate.ppp_+3A_x">X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="rotate.ppp_+3A_angle">angle</code></td>
<td>
<p>Angle of rotation.</p>
</td></tr>
<tr><td><code id="rotate.ppp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+rotate.owin">rotate.owin</a></code> affecting
the handling of the observation window, if it is a binary pixel mask.
</p>
</td></tr>
<tr><td><code id="rotate.ppp_+3A_centre">centre</code></td>
<td>

<p>Centre of rotation.
Either a vector of length 2, or a character string
(partially matched to <code>"centroid"</code>, <code>"midpoint"</code>
or <code>"bottomleft"</code>).
The default is the coordinate origin <code>c(0,0)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The points of the pattern, and the window of observation, 
are rotated about the origin by the angle specified.
Angles are measured in
radians, anticlockwise. The default is to rotate the pattern 90 degrees
anticlockwise. If the points carry marks, these are preserved.
</p>


<h3>Value</h3>

<p>Another object of class <code>"ppp"</code> representing the
rotated point pattern.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+rotate.owin">rotate.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rotate(cells, pi/3)
  # plot(X)
</code></pre>

<hr>
<h2 id='rotate.psp'>Rotate a Line Segment Pattern</h2><span id='topic+rotate.psp'></span>

<h3>Description</h3>

<p>Rotates a line segment pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'psp'
rotate(X, angle=pi/2, ..., centre=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate.psp_+3A_x">X</code></td>
<td>
<p>A line segment pattern (object of class <code>"psp"</code>).</p>
</td></tr>
<tr><td><code id="rotate.psp_+3A_angle">angle</code></td>
<td>
<p>Angle of rotation.</p>
</td></tr>
<tr><td><code id="rotate.psp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+rotate.owin">rotate.owin</a></code> affecting
the handling of the observation window, if it is a binary pixel
mask.
</p>
</td></tr>
<tr><td><code id="rotate.psp_+3A_centre">centre</code></td>
<td>

<p>Centre of rotation.
Either a vector of length 2, or a character string
(partially matched to <code>"centroid"</code>, <code>"midpoint"</code>
or <code>"bottomleft"</code>).
The default is the coordinate origin <code>c(0,0)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The line segments of the pattern, and the window of observation, 
are rotated about the origin by the angle specified.
Angles are measured in
radians, anticlockwise. The default is to rotate the pattern 90 degrees
anticlockwise. If the line segments carry marks, these are preserved.
</p>


<h3>Value</h3>

<p>Another object of class <code>"psp"</code> representing the
rotated line segment pattern.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp.object">psp.object</a></code>,
<code><a href="#topic+rotate.owin">rotate.owin</a></code>,
<code><a href="#topic+rotate.ppp">rotate.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  oldpar &lt;- par(mfrow=c(2,1))
  X &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  plot(X, main="original")
  Y &lt;- rotate(X, pi/4)
  plot(Y, main="rotated")
  par(oldpar)
</code></pre>

<hr>
<h2 id='round.ppp'>
Apply Numerical Rounding to Spatial Coordinates
</h2><span id='topic+round.ppp'></span><span id='topic+round.pp3'></span><span id='topic+round.ppx'></span>

<h3>Description</h3>

<p>Apply numerical rounding
to the spatial coordinates of a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
round(x, digits = 0, ...)

## S3 method for class 'pp3'
round(x, digits = 0, ...)

## S3 method for class 'ppx'
round(x, digits = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round.ppp_+3A_x">x</code></td>
<td>

<p>A spatial point pattern in any dimension
(object of class <code>"ppp"</code>, <code>"pp3"</code> or <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="round.ppp_+3A_digits">digits</code></td>
<td>

<p>integer indicating the number of decimal places. 
</p>
</td></tr>
<tr><td><code id="round.ppp_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the default method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic function
<code><a href="base.html#topic+round">round</a></code>.
They apply numerical rounding to the spatial coordinates of the
point pattern <code>x</code>. 
</p>


<h3>Value</h3>

<p>A point pattern object, of the same class as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rounding">rounding</a></code> to determine whether numbers have been
rounded.
</p>
<p><code><a href="base.html#topic+round">round</a></code> in the Base package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  round(cells, 1)
</code></pre>

<hr>
<h2 id='rounding'>
Detect Numerical Rounding 
</h2><span id='topic+rounding'></span><span id='topic+rounding.default'></span><span id='topic+rounding.ppp'></span><span id='topic+rounding.pp3'></span><span id='topic+rounding.ppx'></span>

<h3>Description</h3>

<p>Given a numeric vector, or an object containing numeric spatial
coordinates, determine whether the values have been rounded
to a certain number of decimal places.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rounding(x)

## Default S3 method:
rounding(x)

## S3 method for class 'ppp'
rounding(x)

## S3 method for class 'pp3'
rounding(x)

## S3 method for class 'ppx'
rounding(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rounding_+3A_x">x</code></td>
<td>

<p>A numeric vector, or an object containing numeric spatial coordinates.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a numeric vector <code>x</code>,
this function determines whether the values have been rounded
to a certain number of decimal places.
</p>

<ul>
<li> 
<p>If the entries of <code>x</code> are not all integers, then
<code>rounding(x)</code> returns the smallest number of digits <code>d</code>
after the decimal point
such that <code><a href="base.html#topic+round">round</a>(x, digits=d)</code> is identical to
<code>x</code>.
For example if <code>rounding(x) = 2</code> then the entries of
<code>x</code> are rounded to 2 decimal places, and are multiples of 0.01.
</p>
</li>
<li> 
<p>If all the entries of <code>x</code> are integers, then
<code>rounding(x)</code> returns <code>-d</code>, where
<code>d</code> is the smallest number of digits <em>before</em> the decimal point
such that <code><a href="base.html#topic+round">round</a>(x, digits=-d)</code> is identical to
<code>x</code>.
For example if <code>rounding(x) = -3</code> then the entries of
<code>x</code> are multiples of 1000.
If <code>rounding(x) = 0</code> then the entries of <code>x</code> are integers
but not multiples of 10.
</p>
</li>
<li>
<p>If all entries of <code>x</code> are equal to 0, the rounding is
not determined, and a value of <code>NULL</code> is returned.
</p>
</li></ul>

<p>For a point pattern (object of class <code>"ppp"</code>)
or similar object <code>x</code> containing numeric spatial
coordinates, this procedure is applied to the spatial coordinates.
</p>


<h3>Value</h3>

<p>An integer.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+round.ppp">round.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   rounding(c(0.1, 0.3, 1.2))
   rounding(c(1940, 1880, 2010))
   rounding(0)
   rounding(cells)
</code></pre>

<hr>
<h2 id='rQuasi'>
Generate Quasirandom Point Pattern in Given Window
</h2><span id='topic+rQuasi'></span>

<h3>Description</h3>

<p>Generates a quasirandom pattern of points in any two-dimensional window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rQuasi(n, W, type = c("Halton", "Hammersley"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rQuasi_+3A_n">n</code></td>
<td>

<p>Maximum number of points to be generated.
</p>
</td></tr>
<tr><td><code id="rQuasi_+3A_w">W</code></td>
<td>

<p>Window (object of class <code>"owin"</code>) in which to generate
the points.
</p>
</td></tr>
<tr><td><code id="rQuasi_+3A_type">type</code></td>
<td>

<p>String identifying the quasirandom generator.
</p>
</td></tr>
<tr><td><code id="rQuasi_+3A_...">...</code></td>
<td>

<p>Arguments passed to the quasirandom generator.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a quasirandom point pattern,
using the quasirandom sequence generator
<code><a href="#topic+Halton">Halton</a></code> or <code><a href="#topic+Hammersley">Hammersley</a></code>
as specified.
</p>
<p>If <code>W</code> is a rectangle, 
exactly <code>n</code> points will be generated.
</p>
<p>If <code>W</code> is not a rectangle, <code>n</code> points will be generated in the
containing rectangle <code>as.rectangle(W)</code>,
and only the points lying inside <code>W</code> will be retained.
</p>


<h3>Value</h3>

<p>Point pattern (object of class <code>"ppp"</code>) inside the window <code>W</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Halton">Halton</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(rQuasi(256, letterR))
</code></pre>

<hr>
<h2 id='rsyst'>Simulate systematic random point pattern</h2><span id='topic+rsyst'></span>

<h3>Description</h3>

<p>Generates a &ldquo;systematic random&rdquo; pattern of points in a window,
consisting of a grid of equally-spaced points with a random common
displacement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rsyst(win=square(1), nx=NULL, ny=nx, ..., dx=NULL, dy=dx,
       nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsyst_+3A_win">win</code></td>
<td>

<p>A window. 
An object of class <code><a href="#topic+owin">owin</a></code>,
or data in any format acceptable to <code><a href="#topic+as.owin">as.owin</a>()</code>.
</p>
</td></tr>
<tr><td><code id="rsyst_+3A_nx">nx</code></td>
<td>
<p>Number of columns of grid points in the window.
Incompatible with <code>dx</code>.
</p>
</td></tr>
<tr><td><code id="rsyst_+3A_ny">ny</code></td>
<td>
<p>Number of rows of grid points in the window.
Incompatible with <code>dy</code>.
</p>
</td></tr>
<tr><td><code id="rsyst_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="rsyst_+3A_dx">dx</code></td>
<td>
<p>Spacing of grid points in <code class="reqn">x</code> direction.
Incompatible with <code>nx</code>.
</p>
</td></tr>
<tr><td><code id="rsyst_+3A_dy">dy</code></td>
<td>
<p>Spacing of grid points in <code class="reqn">y</code> direction.
Incompatible with <code>ny</code>.
</p>
</td></tr>
<tr><td><code id="rsyst_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rsyst_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a &ldquo;systematic random&rdquo; pattern
of points in the window <code>win</code>. The pattern consists of a
rectangular grid of points with a random common displacement.
</p>
<p>The grid spacing in the <code class="reqn">x</code> direction is determined
either by the number of columns <code>nx</code> or by the
horizontal spacing <code>dx</code>.
The grid spacing in the <code class="reqn">y</code> direction is determined
either by the number of rows <code>ny</code> or by the
vertical spacing <code>dy</code>. 
</p>
<p>The grid is then given a random displacement (the common displacement
of the grid points is a uniformly distributed random vector in the
tile of dimensions <code>dx, dy</code>).
</p>
<p>Some of the resulting grid points may lie outside the window
<code>win</code>: if they do, they are deleted.  The result is a point
pattern inside the window <code>win</code>.
</p>
<p>This function is useful in creating dummy points for quadrature
schemes (see <code><a href="#topic+quadscheme">quadscheme</a></code>) as well as in simulating
random point patterns.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
if <code>nsim=1</code>, or a list of point patterns if <code>nsim &gt; 1</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.random.html#topic+rstrat">rstrat</a></code>,
<code><a href="spatstat.random.html#topic+runifpoint">runifpoint</a></code>,
<code><a href="#topic+quadscheme">quadscheme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rsyst(nx=10)
  plot(X)

  # polygonal boundary
  X &lt;- rsyst(letterR, 5, 10)
  plot(X)
</code></pre>

<hr>
<h2 id='run.simplepanel'>
Run Point-and-Click Interface
</h2><span id='topic+clear.simplepanel'></span><span id='topic+redraw.simplepanel'></span><span id='topic+run.simplepanel'></span>

<h3>Description</h3>

<p>Execute various operations in a simple
point-and-click user interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.simplepanel(P, popup=TRUE, verbose = FALSE)
clear.simplepanel(P)
redraw.simplepanel(P, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.simplepanel_+3A_p">P</code></td>
<td>

<p>An interaction panel (object of class <code>"simplepanel"</code>,
created by <code><a href="#topic+simplepanel">simplepanel</a></code> or <code><a href="#topic+grow.simplepanel">grow.simplepanel</a></code>).
</p>
</td></tr>
<tr><td><code id="run.simplepanel_+3A_popup">popup</code></td>
<td>

<p>Logical. If <code>popup=TRUE</code> (the default),
the panel will be displayed in a
new popup window. If <code>popup=FALSE</code>,
the panel will be displayed on the current graphics
window if it already exists, and on a new window otherwise.
</p>
</td></tr>
<tr><td><code id="run.simplepanel_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, debugging information will be printed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These commands enable the user to run a simple, robust,
point-and-click interface to any <span class="rlang"><b>R</b></span> code.
The interface is implemented
using only the basic graphics package in <span class="rlang"><b>R</b></span>.
</p>
<p>The argument <code>P</code> is an object of class <code>"simplepanel"</code>,
created by <code><a href="#topic+simplepanel">simplepanel</a></code> or <code><a href="#topic+grow.simplepanel">grow.simplepanel</a></code>,  
which specifies the graphics to be displayed and the actions to be performed
when the user interacts with the panel.
</p>
<p>The command <code>run.simplepanel(P)</code> activates the panel:
the display is initialised and the graphics system waits for the
user to click the panel. 
While the panel is active, the user can only interact with the panel;
the <span class="rlang"><b>R</b></span> command line interface and the <span class="rlang"><b>R</b></span> GUI cannot be used.
When the panel terminates (typically because the user
clicked a button labelled Exit), control returns to the <span class="rlang"><b>R</b></span> command line
interface and the <span class="rlang"><b>R</b></span> GUI. 
</p>
<p>The command <code>clear.simplepanel(P)</code> clears all the display
elements in the panel, resulting in a blank display except for the
title of the panel.
</p>
<p>The command <code>redraw.simplepanel(P)</code> redraws all the buttons
of the panel, according to the <code>redraw</code> functions contained
in the panel.
</p>
<p>If <code>popup=TRUE</code> (the default), <code>run.simplepanel</code> begins by
calling <code><a href="grDevices.html#topic+dev.new">dev.new</a></code> so that a new popup window
is created; this window is closed using
<code><a href="grDevices.html#topic+dev.off">dev.off</a></code> when <code>run.simplepanel</code> terminates.
If <code>popup=FALSE</code>, the panel will be displayed on the current graphics
window if it already exists, and on a new window otherwise;
this window is not closed when <code>run.simplepanel</code> terminates.
</p>
<p>For more sophisticated control of the graphics focus (for example, to
use the panel to control the display on another window),
initialise the graphics devices yourself using
<code><a href="grDevices.html#topic+dev.new">dev.new</a></code> or similar commands; save these devices
in the shared environment <code>env</code> of the panel <code>P</code>;
and write the click/redraw functions of <code>P</code> in such a way that
they access these devices using <code><a href="grDevices.html#topic+dev.set">dev.set</a></code>.
Then use <code>run.simplepanel</code> with <code>popup=FALSE</code>.
</p>


<h3>Value</h3>

<p>The return value of <code>run.simplepanel(P)</code> is the value returned
by the <code>exit</code> function of <code>P</code>. See <code><a href="#topic+simplepanel">simplepanel</a></code>.
</p>
<p>The functions <code>clear.simplepanel</code> and <code>redraw.simplepanel</code>
return <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simplepanel">simplepanel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) {
    # make boxes (alternatively use layout.boxes())
    Bminus &lt;- square(1)
    Bvalue &lt;- shift(Bminus, c(1.2, 0))
    Bplus &lt;- shift(Bvalue, c(1.2, 0))
    Bdone &lt;- shift(Bplus, c(1.2, 0))
    myboxes &lt;- list(Bminus, Bvalue, Bplus, Bdone)
    myB &lt;- do.call(boundingbox,myboxes)

    # make environment containing an integer count
    myenv &lt;- new.env()
    assign("answer", 0, envir=myenv)

    # what to do when finished: return the count.
    myexit &lt;- function(e) { return(get("answer", envir=e)) }

    # button clicks
    # decrement the count
    Cminus &lt;- function(e, xy) {
     ans &lt;- get("answer", envir=e)
     assign("answer", ans - 1, envir=e)
     return(TRUE)
   }
   # display the count (clicking does nothing)
   Cvalue &lt;- function(...) { TRUE }
   # increment the count
   Cplus &lt;- function(e, xy) {
    ans &lt;- get("answer", envir=e)
    assign("answer", ans + 1, envir=e)
    return(TRUE)
   }
   # quit button
   Cdone &lt;- function(e, xy) { return(FALSE) }

   myclicks &lt;- list("-"=Cminus,
                    value=Cvalue,
                    "+"=Cplus,
                    done=Cdone)

   # redraw the button that displays the current value of the count
   Rvalue &lt;- function(button, nam, e) {
     plot(button, add=TRUE)
     ans &lt;- get("answer", envir=e)
     text(centroid.owin(button), labels=ans)
     return(TRUE)
  }

  # make the panel
  P &lt;- simplepanel("Counter",
                   B=myB, boxes=myboxes,
                   clicks=myclicks,
                   redraws = list(NULL, Rvalue, NULL, NULL),
                   exit=myexit, env=myenv)
  P

  run.simplepanel(P)
  }
</code></pre>

<hr>
<h2 id='runifrect'>Generate N Uniform Random Points in a Rectangle</h2><span id='topic+runifrect'></span>

<h3>Description</h3>

<p>Generate a random point pattern,
containing <code class="reqn">n</code> independent uniform random points,
inside a specified rectangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runifrect(n, win = owin(c(0, 1), c(0, 1)), nsim = 1, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifrect_+3A_n">n</code></td>
<td>

<p>Number of points.
</p>
</td></tr>
<tr><td><code id="runifrect_+3A_win">win</code></td>
<td>

<p>Rectangular window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code><a href="#topic+as.owin">as.owin</a></code>,
which must specify a rectangle.
</p>
</td></tr>
<tr><td><code id="runifrect_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="runifrect_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a slightly faster version of
<code><a href="spatstat.random.html#topic+runifpoint">runifpoint</a></code>
for the special case where the window is a rectangle.
</p>
<p>The function generates <code>n</code> independent random points,
uniformly distributed in the window <code>win</code>,
by assigning uniform random values to the cartesian coordinates.
</p>
<p>For normal usage we recommend <code><a href="spatstat.random.html#topic+runifpoint">runifpoint</a></code>
because it is more flexible.
However, <code>runifrect</code> is slightly faster (when the window is a rectangle),
and may be preferable in very computationally-demanding tasks.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
if <code>nsim=1</code> and <code>drop=TRUE</code>,
otherwise a list of point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="spatstat.random.html#topic+runifpoint">runifpoint</a></code>,
<code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>,
<code><a href="spatstat.random.html#topic+rpoint">rpoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # 42 random points in the unit square
 pp &lt;- runifrect(42)
</code></pre>

<hr>
<h2 id='scalardilate'>Apply Scalar Dilation</h2><span id='topic+scalardilate'></span><span id='topic+scalardilate.im'></span><span id='topic+scalardilate.owin'></span><span id='topic+scalardilate.ppp'></span><span id='topic+scalardilate.psp'></span><span id='topic+scalardilate.default'></span>

<h3>Description</h3>

<p>Applies scalar dilation to a plane geometrical object,
such as a point pattern or a window,
relative to a specified origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  scalardilate(X, f, ...)

  ## S3 method for class 'im'
scalardilate(X, f, ..., origin=NULL)

  ## S3 method for class 'owin'
scalardilate(X, f, ..., origin=NULL)

  ## S3 method for class 'ppp'
scalardilate(X, f, ..., origin=NULL)

  ## S3 method for class 'psp'
scalardilate(X, f, ..., origin=NULL)

  ## Default S3 method:
scalardilate(X, f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalardilate_+3A_x">X</code></td>
<td>
<p>Any suitable dataset representing a two-dimensional
object, such as a point pattern (object of class <code>"ppp"</code>),
a window (object of class <code>"owin"</code>), a pixel image
(class <code>"im"</code>) and so on.
</p>
</td></tr>
<tr><td><code id="scalardilate_+3A_f">f</code></td>
<td>

<p>Scalar dilation factor. A finite number greater than zero.
</p>
</td></tr>
<tr><td><code id="scalardilate_+3A_...">...</code></td>
<td>
<p>Ignored by the methods.</p>
</td></tr>
<tr><td><code id="scalardilate_+3A_origin">origin</code></td>
<td>

<p>Origin for the scalar dilation. Either a vector of 2 numbers,
or one of the character strings
<code>"centroid"</code>, <code>"midpoint"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code>,
<code>"topleft"</code>, <code>"bottomleft"</code>, <code>"topright"</code> or
<code>"bottomright"</code> (partially matched).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command performs scalar dilation of the object <code>X</code>
by the factor <code>f</code> relative to the origin specified by
<code>origin</code>. 
</p>
<p>The function <code>scalardilate</code> is generic, with methods for
windows (class <code>"owin"</code>), point patterns (class <code>"ppp"</code>),
pixel images (class <code>"im"</code>), line segment patterns (class <code>"psp"</code>)
and a default method.
</p>
<p>If the argument <code>origin</code> is not given,
then every spatial coordinate is multiplied by the factor <code>f</code>.
</p>
<p>If <code>origin</code> is given, then scalar dilation is performed
relative to the specified origin. Effectively, <code>X</code> is shifted
so that <code>origin</code> is moved to <code>c(0,0)</code>, then scalar dilation
is performed, then the result is shifted so that <code>c(0,0)</code> is
moved to <code>origin</code>.
</p>
<p>This command is a special case of an affine transformation:
see <code><a href="#topic+affine">affine</a></code>.
</p>


<h3>Value</h3>

<p>Another object of the same type, representing the
result of applying the scalar dilation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(letterR)
plot(scalardilate(letterR, 0.7, origin="left"), col="red", add=TRUE)
</code></pre>

<hr>
<h2 id='scaletointerval'>Rescale Data to Lie Between Specified Limits</h2><span id='topic+scaletointerval'></span><span id='topic+scaletointerval.default'></span><span id='topic+scaletointerval.im'></span>

<h3>Description</h3>

<p>Rescales a dataset so that the values range exactly between the
specified limits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  scaletointerval(x, from=0, to=1, xrange=range(x))
  ## Default S3 method:
scaletointerval(x, from=0, to=1, xrange=range(x))
  ## S3 method for class 'im'
scaletointerval(x, from=0, to=1, xrange=range(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaletointerval_+3A_x">x</code></td>
<td>
<p>Data to be rescaled.</p>
</td></tr>
<tr><td><code id="scaletointerval_+3A_from">from</code>, <code id="scaletointerval_+3A_to">to</code></td>
<td>
<p>Lower and upper endpoints of the interval
to which the values of <code>x</code> should be rescaled.
</p>
</td></tr>
<tr><td><code id="scaletointerval_+3A_xrange">xrange</code></td>
<td>

<p>Optional range of values of <code>x</code> that should be mapped
to the new interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions rescale a dataset <code>x</code>
so that its values range exactly between the limits
<code>from</code> and <code>to</code>.
</p>
<p>The method for pixel images (objects of class <code>"im"</code>)
applies this scaling to the pixel values of <code>x</code>.
</p>
<p>Rescaling cannot be performed if the values in <code>x</code> are not
interpretable as numeric, or if the values in <code>x</code> are all equal.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- as.im(function(x,y) {x+y+3}, unit.square())
  summary(X)
  Y &lt;- scaletointerval(X)
  summary(Y)
</code></pre>

<hr>
<h2 id='scanpp'>Read Point Pattern From Data File</h2><span id='topic+scanpp'></span>

<h3>Description</h3>

<p>Reads a point pattern dataset from a text file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   scanpp(filename, window, header=TRUE, dir="", factor.marks=NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scanpp_+3A_filename">filename</code></td>
<td>

<p>String name of the file containing
the coordinates of the points in the point pattern,
and their marks if any.
</p>
</td></tr>
<tr><td><code id="scanpp_+3A_window">window</code></td>
<td>

<p>Window for the point pattern. An object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="scanpp_+3A_header">header</code></td>
<td>

<p>Logical flag indicating whether the first line of the
file contains headings for the columns.
Passed to <code><a href="utils.html#topic+read.table">read.table</a></code>.
</p>
</td></tr>
<tr><td><code id="scanpp_+3A_dir">dir</code></td>
<td>

<p>String containing the path name of the directory
in which <code>filename</code> is to be found.
Default is the current directory.
</p>
</td></tr>
<tr><td><code id="scanpp_+3A_factor.marks">factor.marks</code></td>
<td>

<p>Logical vector (or NULL) indicating whether marks are to be
interpreted as factors. Defaults to <code>NULL</code> which means that
strings will be interpreted as factors while numeric variables
will not. See details.
</p>
</td></tr>
<tr><td><code id="scanpp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simple function reads a point pattern dataset from a file
containing the cartesian coordinates of its points,
and optionally the mark values for these points.
</p>
<p>The file identified by <code>filename</code> in directory <code>dir</code>
should be a text file that can be read using <code><a href="utils.html#topic+read.table">read.table</a></code>.
Thus, each line of the file (except possibly the first line)
contains data for one point in the
point pattern. Data are arranged in columns. There should be either
two columns (for an unmarked point pattern) or more columns (for a
marked point pattern).
</p>
<p>If <code>header=FALSE</code> then the first two columns of data
will be interpreted as the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates
of points. Remaining columns, if present, will be interpreted as
containing the marks for these points.
</p>
<p>If <code>header=TRUE</code> then the first line of the file should contain
string names for each of the columns of data. If there are columns
named <code>x</code> and <code>y</code> then these will be taken as the
cartesian coordinates, and any remaining columns will be taken as
the marks. If there are no columns named <code>x</code> and <code>y</code>
then the first and second columns will be taken as the cartesian
coordinates.
</p>
<p>If a logical vector is provided for <code>factor.marks</code> the length
should equal the number of mark columns (a shorter <code>factor.marks</code>
is recycled to this length). This vector is then used to determine
which mark columns should be interpreted as factors. Note: Strings will
not be interpreted as factors if the corresponding entry in
<code>factor.marks</code> is <code>FALSE</code>.
</p>
<p>Note that there is intentionally no default for <code>window</code>.
The window of observation should be specified.
If you really need to estimate the window, use the
Ripley-Rasson estimator <code><a href="#topic+ripras">ripras</a></code>.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>,
see <code><a href="#topic+ppp.object">ppp.object</a></code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+ppp">ppp</a></code>,
<code><a href="#topic+as.ppp">as.ppp</a></code>,
<code><a href="#topic+ripras">ripras</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ##  files installed with spatstat, for demonstration
  d &lt;- system.file("rawdata", "finpines", package="spatstat.data")
  if(nzchar(d)) {
    W &lt;- owin(c(-5,5), c(-8,2))
    X &lt;- scanpp("finpines.txt", dir=d, window=W)
    print(X)
  }
  d &lt;- system.file("rawdata", "amacrine", package="spatstat.data")
  if(nzchar(d)) {
    W &lt;- owin(c(0, 1060/662), c(0, 1))
    Y &lt;- scanpp("amacrine.txt", dir=d, window=W, factor.marks=TRUE)
    print(Y)
  }
</code></pre>

<hr>
<h2 id='selfcrossing.psp'>Crossing Points in a Line Segment Pattern</h2><span id='topic+selfcrossing.psp'></span>

<h3>Description</h3>

<p>Finds any crossing points between the line segments in a 
line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  selfcrossing.psp(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selfcrossing.psp_+3A_a">A</code></td>
<td>

<p>Line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds any crossing points between
different line segments in the line segment pattern <code>A</code>.
</p>
<p>A crossing point occurs whenever one of the line segments in <code>A</code>
intersects another line segment in <code>A</code>, at a nonzero
angle of intersection.
</p>


<h3>Value</h3>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossing.psp">crossing.psp</a></code>,
<code><a href="#topic+psp.object">psp.object</a></code>,
<code><a href="#topic+ppp.object">ppp.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  plot(a, col="green", main="selfcrossing.psp")
  P &lt;- selfcrossing.psp(a)
  plot(P, add=TRUE, col="red")
</code></pre>

<hr>
<h2 id='selfcut.psp'>Cut Line Segments Where They Intersect</h2><span id='topic+selfcut.psp'></span>

<h3>Description</h3>

<p>Finds any crossing points between the line segments in a 
line segment pattern, and cuts the segments into pieces
at these crossing-points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selfcut.psp(A, ..., eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selfcut.psp_+3A_a">A</code></td>
<td>

<p>Line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="selfcut.psp_+3A_eps">eps</code></td>
<td>

<p>Optional. Smallest permissible length of the resulting
line segments. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="selfcut.psp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds any crossing points between
different line segments in the line segment pattern <code>A</code>,
and cuts the line segments into pieces at these intersection points.
</p>
<p>A crossing point occurs whenever one of the line segments in <code>A</code>
intersects another line segment in <code>A</code>, at a nonzero
angle of intersection.
</p>


<h3>Value</h3>

<p>Another line segment pattern (object of class <code>"psp"</code>)
in the same window as <code>A</code> with the same kind of marks as
<code>A</code>.
</p>
<p>The result also has an attribute <code>"camefrom"</code> indicating
the provenance of each segment in the result.
For example <code>camefrom[3]=2</code> means that the third segment in the
result is a piece of the second segment of <code>A</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selfcrossing.psp">selfcrossing.psp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  Y &lt;- selfcut.psp(X)
  n &lt;- nsegments(Y)
  plot(Y %mark% factor(sample(seq_len(n), n, replace=TRUE)))
</code></pre>

<hr>
<h2 id='sessionLibs'>
Print Names and Version Numbers of Libraries Loaded
</h2><span id='topic+sessionLibs'></span>

<h3>Description</h3>

<p>Prints the names and version numbers
of libraries currently loaded by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sessionLibs()
</code></pre>


<h3>Details</h3>

<p>This function prints a list of the libraries loaded by the user
in the current session, giving just their name and version number.
It obtains this information from <code><a href="utils.html#topic+sessionInfo">sessionInfo</a></code>.
</p>
<p>This function is not needed in an interactive <span class="rlang"><b>R</b></span> session
because the package startup messages will usually provide this
information.
</p>
<p>Its main use is in an <code><a href="utils.html#topic+Sweave">Sweave</a></code> script, where it is needed
because the package startup messages are not printed. 
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+sessionInfo">sessionInfo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  sessionLibs()
</code></pre>

<hr>
<h2 id='setcov'>Set Covariance of a Window</h2><span id='topic+setcov'></span>

<h3>Description</h3>

<p>Computes the set covariance function of a window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> setcov(W, V=W, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setcov_+3A_w">W</code></td>
<td>

<p>A window (object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="setcov_+3A_v">V</code></td>
<td>

<p>Optional. Another window.
</p>
</td></tr>
<tr><td><code id="setcov_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+as.mask">as.mask</a></code>
to control the pixel resolution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The set covariance function of a region <code class="reqn">W</code> in the plane
is the function <code class="reqn">C(v)</code> defined for each vector <code class="reqn">v</code>
as the area of the intersection between <code class="reqn">W</code> and <code class="reqn">W+v</code>,
where <code class="reqn">W+v</code> is the set obtained by shifting (translating)
<code class="reqn">W</code> by <code class="reqn">v</code>.
</p>
<p>We may interpret <code class="reqn">C(v)</code> as the area of the set of
all points <code class="reqn">x</code> in <code class="reqn">W</code> such that <code class="reqn">x+v</code> also lies in
<code class="reqn">W</code>.
</p>
<p>This command computes a discretised approximation to
the set covariance function of any
plane region <code class="reqn">W</code> represented as a window object (of class
<code>"owin"</code>, see <code><a href="#topic+owin.object">owin.object</a></code>). The return value is
a pixel image (object of class <code>"im"</code>) whose greyscale values
are values of the set covariance function.
</p>
<p>The set covariance is computed using the Fast Fourier Transform,
unless <code>W</code> is a rectangle, when an exact formula is used.
</p>
<p>If the argument <code>V</code> is present, then <code>setcov(W,V)</code>
computes the set <em>cross-covariance</em> function <code class="reqn">C(x)</code>
defined for each vector <code class="reqn">x</code>
as the area of the intersection between <code class="reqn">W</code> and <code class="reqn">V+x</code>.
</p>


<h3>Value</h3>

<p>A pixel image (an object of class <code>"im"</code>) representing the
set covariance function of <code>W</code>,
or the cross-covariance of <code>W</code> and <code>V</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+imcov">imcov</a></code>,
<code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+erosion">erosion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- owin(c(0,1),c(0,1))
  v &lt;- setcov(w)
  plot(v)
</code></pre>

<hr>
<h2 id='shift'>Apply Vector Translation</h2><span id='topic+shift'></span>

<h3>Description</h3>

<p>Applies a vector shift of the plane 
to a geometrical object,
such as a point pattern or a window. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  shift(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_+3A_x">X</code></td>
<td>
<p>Any suitable dataset representing a two-dimensional
object, such as a point pattern (object of class <code>"ppp"</code>),
or a window (object of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="shift_+3A_...">...</code></td>
<td>
<p>Arguments determining the shift vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is generic. Methods are provided for
point patterns (<code><a href="#topic+shift.ppp">shift.ppp</a></code>)
and windows (<code><a href="#topic+shift.owin">shift.owin</a></code>).
</p>
<p>The object is translated by the vector <code>vec</code>.
</p>


<h3>Value</h3>

<p>Another object of the same type, representing the
result of applying the shift.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shift.ppp">shift.ppp</a></code>,
<code><a href="#topic+shift.owin">shift.owin</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+periodify">periodify</a></code>
</p>

<hr>
<h2 id='shift.im'>Apply Vector Translation To Pixel Image</h2><span id='topic+shift.im'></span>

<h3>Description</h3>

<p>Applies a vector shift to a pixel image
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'im'
shift(X, vec=c(0,0), ..., origin=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.im_+3A_x">X</code></td>
<td>
<p>Pixel image (object of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="shift.im_+3A_vec">vec</code></td>
<td>
<p>Vector of length 2 representing a translation.</p>
</td></tr>
<tr><td><code id="shift.im_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="shift.im_+3A_origin">origin</code></td>
<td>

<p>Location that will be shifted to the origin.
Either a numeric vector of length 2 giving the location,
or a point pattern containing only one point,
or a list with two entries named <code>x</code> and <code>y</code>,
or one of the character strings
<code>"centroid"</code>, <code>"midpoint"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code>,
<code>"topleft"</code>, <code>"bottomleft"</code>, <code>"topright"</code> or
<code>"bottomright"</code> (partially matched).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial location of each pixel in the image
is translated by the vector <code>vec</code>.
This is a method for the generic function <code><a href="#topic+shift">shift</a></code>.
</p>
<p>If <code>origin</code> is given,
the argument <code>vec</code> will be ignored; instead the shift will be performed
so that the specified geometric location is shifted to the
coordinate origin <code class="reqn">(0,0)</code>.
The argument <code>origin</code> should be either a numeric vector of length
2 giving the spatial coordinates of a location, or one of the character
strings <code>"centroid"</code>, <code>"midpoint"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code>,
<code>"topleft"</code>, <code>"bottomleft"</code>, <code>"topright"</code> or
<code>"bottomright"</code> (partially matched).
If <code>origin="centroid"</code> then the centroid of the window will be
shifted to the origin. If <code>origin="midpoint"</code> then the centre of
the bounding rectangle of the window will be shifted to the origin.
If <code>origin="bottomleft"</code> then the bottom left corner of the
bounding rectangle of the window will be shifted to the origin,
and so on.
</p>


<h3>Value</h3>

<p>Another pixel image (of class <code>"im"</code>) representing the
result of applying the vector shift.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # make up an image
 X &lt;- setcov(unit.square())
 plot(X)

 Y &lt;- shift(X, c(10,10))
 plot(Y)
 # no discernible difference except coordinates are different

 shift(X, origin="c")
</code></pre>

<hr>
<h2 id='shift.owin'>Apply Vector Translation To Window</h2><span id='topic+shift.owin'></span>

<h3>Description</h3>

<p>Applies a vector shift to a window
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'owin'
shift(X, vec=c(0,0), ..., origin=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.owin_+3A_x">X</code></td>
<td>
<p>Window (object of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="shift.owin_+3A_vec">vec</code></td>
<td>
<p>Vector of length 2 representing a translation.</p>
</td></tr>
<tr><td><code id="shift.owin_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="shift.owin_+3A_origin">origin</code></td>
<td>

<p>Location that will be shifted to the origin.
Either a numeric vector of length 2 giving the location,
or a point pattern containing only one point,
or a list with two entries named <code>x</code> and <code>y</code>,
or one of the character strings
<code>"centroid"</code>, <code>"midpoint"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code>,
<code>"topleft"</code>, <code>"bottomleft"</code>, <code>"topright"</code> or
<code>"bottomright"</code> (partially matched).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The window is translated by the vector <code>vec</code>.
This is a method for the generic function <code><a href="#topic+shift">shift</a></code>.
</p>
<p>If <code>origin</code> is given,
the argument <code>vec</code> will be ignored; instead the shift will be performed
so that the specified geometric location is shifted to the
coordinate origin <code class="reqn">(0,0)</code>.
The argument <code>origin</code> should be either a numeric vector of length
2 giving the spatial coordinates of a location, or one of the character
strings <code>"centroid"</code>, <code>"midpoint"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code>,
<code>"topleft"</code>, <code>"bottomleft"</code>, <code>"topright"</code> or
<code>"bottomright"</code> (partially matched).
If <code>origin="centroid"</code> then the centroid of the window will be
shifted to the origin. If <code>origin="midpoint"</code> then the centre of
the bounding rectangle of the window will be shifted to the origin.
If <code>origin="bottomleft"</code> then the bottom left corner of the
bounding rectangle of the window will be shifted to the origin,
and so on.
</p>


<h3>Value</h3>

<p>Another window (of class <code>"owin"</code>) representing the
result of applying the vector shift.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shift">shift</a></code>,
<code><a href="#topic+shift.ppp">shift.ppp</a></code>,
<code><a href="#topic+periodify">periodify</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+affine">affine</a></code>,
<code><a href="#topic+centroid.owin">centroid.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  W &lt;- owin(c(0,1),c(0,1))
  X &lt;- shift(W, c(2,3))
  # plot(W)
  # no discernible difference except coordinates are different
  shift(W, origin="top")
</code></pre>

<hr>
<h2 id='shift.ppp'>Apply Vector Translation To Point Pattern</h2><span id='topic+shift.ppp'></span>

<h3>Description</h3>

<p>Applies a vector shift to a point pattern. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppp'
shift(X, vec=c(0,0), ..., origin=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.ppp_+3A_x">X</code></td>
<td>
<p>Point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="shift.ppp_+3A_vec">vec</code></td>
<td>
<p>Vector of length 2 representing a translation.</p>
</td></tr>
<tr><td><code id="shift.ppp_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="shift.ppp_+3A_origin">origin</code></td>
<td>

<p>Location that will be shifted to the origin.
Either a numeric vector of length 2 giving the location,
or a point pattern containing only one point,
or a list with two entries named <code>x</code> and <code>y</code>,
or one of the character strings
<code>"centroid"</code>, <code>"midpoint"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code>,
<code>"topleft"</code>, <code>"bottomleft"</code>, <code>"topright"</code> or
<code>"bottomright"</code> (partially matched).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The point pattern, and its window, are
translated by the vector <code>vec</code>.
</p>
<p>This is a method for the generic function <code><a href="#topic+shift">shift</a></code>.
</p>
<p>If <code>origin</code> is given,
the argument <code>vec</code> will be ignored; instead the shift will be performed
so that the specified geometric location is shifted to the
coordinate origin <code class="reqn">(0,0)</code>.
The argument <code>origin</code> should be either a numeric vector of length
2 giving the spatial coordinates of a location, or one of the character
strings <code>"centroid"</code>, <code>"midpoint"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code>,
<code>"topleft"</code>, <code>"bottomleft"</code>, <code>"topright"</code> or
<code>"bottomright"</code> (partially matched).
If <code>origin="centroid"</code> then the centroid of the window will be
shifted to the origin. If <code>origin="midpoint"</code> then the centre of
the bounding rectangle of the window will be shifted to the origin.
If <code>origin="bottomleft"</code> then the bottom left corner of the
bounding rectangle of the window will be shifted to the origin,
and so on.
</p>


<h3>Value</h3>

<p>Another point pattern (of class <code>"ppp"</code>) representing the
result of applying the vector shift.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shift">shift</a></code>,
<code><a href="#topic+shift.owin">shift.owin</a></code>,
<code><a href="#topic+periodify">periodify</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+affine">affine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- shift(cells, c(2,3))
  # plot(X)
  # no discernible difference except coordinates are different
  plot(cells, pch=16)
  plot(shift(cells, c(0.03,0.03)), add=TRUE)

  shift(cells, origin="mid")
</code></pre>

<hr>
<h2 id='shift.ppx'>Apply Vector Translation To Box Or Point Pattern In Arbitrary Dimension</h2><span id='topic+shift.ppx'></span><span id='topic+shift.boxx'></span>

<h3>Description</h3>

<p>Applies a vector shift to a box or point pattern in arbitrary dimension
(object of class <code>"boxx"</code> or <code>"ppx"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'boxx'
shift(X, vec= 0, ...)
 ## S3 method for class 'ppx'
shift(X, vec = 0, ..., spatial = TRUE, temporal = TRUE, local = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.ppx_+3A_x">X</code></td>
<td>
<p>Box or point pattern in arbitrary dimension (object of class <code>"boxx"</code> or <code>"ppx"</code>).</p>
</td></tr>
<tr><td><code id="shift.ppx_+3A_vec">vec</code></td>
<td>
<p>Either a single numeric or a vector of the same length as the 
dimension of the spatial and/or temporal and/or local domain.</p>
</td></tr>
<tr><td><code id="shift.ppx_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="shift.ppx_+3A_spatial">spatial</code>, <code id="shift.ppx_+3A_temporal">temporal</code>, <code id="shift.ppx_+3A_local">local</code></td>
<td>

<p>Logical to indicate whether or not to shift this type of coordinates for the
<code>ppx</code> method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+shift">shift</a></code>.
</p>


<h3>Value</h3>

<p>For <code>shift.boxx</code>, another <code>"boxx"</code> object and for <code>shift.ppx</code>
another <code>"ppx"</code> object. In both cases the new object represents the
result of applying the vector shift.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shift">shift</a></code>,
<code><a href="#topic+boxx">boxx</a></code>,
<code><a href="#topic+ppx">ppx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  vec &lt;- c(2,3)
  dom &lt;- boxx(c(0,1), c(0,1))
  X &lt;- ppx(coords(cells), domain = dom)
  shift(dom, vec)
  Xs &lt;- shift(X, vec)
  Xs
  head(coords(X), n = 3)
  head(coords(Xs), n = 3)
</code></pre>

<hr>
<h2 id='shift.psp'>Apply Vector Translation To Line Segment Pattern</h2><span id='topic+shift.psp'></span>

<h3>Description</h3>

<p>Applies a vector shift to a line segment pattern. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'psp'
shift(X, vec=c(0,0), ..., origin=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.psp_+3A_x">X</code></td>
<td>
<p>Line Segment pattern (object of class <code>"psp"</code>).</p>
</td></tr>
<tr><td><code id="shift.psp_+3A_vec">vec</code></td>
<td>
<p>Vector of length 2 representing a translation.</p>
</td></tr>
<tr><td><code id="shift.psp_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="shift.psp_+3A_origin">origin</code></td>
<td>

<p>Location that will be shifted to the origin.
Either a numeric vector of length 2 giving the location,
or a point pattern containing only one point,
or a list with two entries named <code>x</code> and <code>y</code>,
or one of the character strings
<code>"centroid"</code>, <code>"midpoint"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code>,
<code>"topleft"</code>, <code>"bottomleft"</code>, <code>"topright"</code> or
<code>"bottomright"</code> (partially matched).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The line segment pattern, and its window, are
translated by the vector <code>vec</code>.
</p>
<p>This is a method for the generic function <code><a href="#topic+shift">shift</a></code>.
</p>
<p>If <code>origin</code> is given,
the argument <code>vec</code> will be ignored; instead the shift will be performed
so that the specified geometric location is shifted to the
coordinate origin <code class="reqn">(0,0)</code>.
The argument <code>origin</code> should be either a numeric vector of length
2 giving the spatial coordinates of a location, or one of the character
strings <code>"centroid"</code>, <code>"midpoint"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code>,
<code>"topleft"</code>, <code>"bottomleft"</code>, <code>"topright"</code> or
<code>"bottomright"</code> (partially matched).
If <code>origin="centroid"</code> then the centroid of the window will be
shifted to the origin. If <code>origin="midpoint"</code> then the centre of
the bounding rectangle of the window will be shifted to the origin.
If <code>origin="bottomleft"</code> then the bottom left corner of the
bounding rectangle of the window will be shifted to the origin,
and so on.
</p>


<h3>Value</h3>

<p>Another line segment pattern (of class <code>"psp"</code>) representing the
result of applying the vector shift.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shift">shift</a></code>,
<code><a href="#topic+shift.owin">shift.owin</a></code>,
<code><a href="#topic+shift.ppp">shift.ppp</a></code>,
<code><a href="#topic+periodify">periodify</a></code>,
<code><a href="#topic+rotate">rotate</a></code>,
<code><a href="#topic+affine">affine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  plot(X, col="red")
  Y &lt;- shift(X, c(0.05,0.05))
  plot(Y, add=TRUE, col="blue")

  shift(Y, origin="mid")
</code></pre>

<hr>
<h2 id='sidelengths.owin'>Side Lengths of Enclosing Rectangle of a Window</h2><span id='topic+sidelengths.owin'></span><span id='topic+shortside.owin'></span>

<h3>Description</h3>

<p>Computes the side lengths of the (enclosing rectangle of) a window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'owin'
sidelengths(x)

 ## S3 method for class 'owin'
shortside(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sidelengths.owin_+3A_x">x</code></td>
<td>

<p>A window whose side lengths will be computed.
Object of class <code>"owin"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>shortside</code> and <code>sidelengths</code> are generic.
The functions documented here are the methods for the class <code>"owin"</code>.
</p>
<p><code>sidelengths.owin</code> computes the 
side-lengths of the enclosing rectangle of the window <code>x</code>.
</p>
<p>For safety, both functions give a warning if the window is not a rectangle.
To suppress the warning, first convert the window to a rectangle
using <code><a href="#topic+as.rectangle">as.rectangle</a></code>.
</p>
<p><code>shortside.owin</code> computes the minimum of the two side-lengths.
</p>


<h3>Value</h3>

<p>For <code>sidelengths.owin</code>, a numeric vector of length 2
giving the side-lengths (<code class="reqn">x</code> then <code class="reqn">y</code>) of the enclosing rectangle.
For <code>shortside.owin</code>, a numeric value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shortside">shortside</a></code>,   <code><a href="#topic+sidelengths">sidelengths</a></code>
for the generic functions.
</p>
<p><code><a href="#topic+area.owin">area.owin</a></code>,
<code><a href="#topic+diameter.owin">diameter.owin</a></code>,
<code><a href="#topic+perimeter">perimeter</a></code>
for other geometric calculations on <code>"owin"</code> objects.
</p>
<p><code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+as.owin">as.owin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- owin(c(0,2),c(-1,3))
  sidelengths(w)
  shortside(as.rectangle(letterR))
</code></pre>

<hr>
<h2 id='simplepanel'>Simple Point-and-Click Interface Panels</h2><span id='topic+simplepanel'></span><span id='topic+grow.simplepanel'></span>

<h3>Description</h3>

<p>These functions enable the user to create a simple, robust, 
point-and-click interface to any <span class="rlang"><b>R</b></span> code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   simplepanel(title, B, boxes, clicks,
      redraws=NULL, exit = NULL, env)

   grow.simplepanel(P, side = c("right", "left", "top", "bottom"),
      len = NULL, new.clicks, new.redraws=NULL, ..., aspect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplepanel_+3A_title">title</code></td>
<td>

<p>Character string giving the title of the interface panel.
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_b">B</code></td>
<td>

<p>Bounding box of the panel coordinates.
A rectangular window (object of class <code>"owin"</code>)
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_boxes">boxes</code></td>
<td>

<p>A list of rectangular windows (objects of class <code>"owin"</code>)
specifying the placement of the buttons
and other interactive components of the panel.
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_clicks">clicks</code></td>
<td>

<p>A list of <span class="rlang"><b>R</b></span> functions, of the same length as <code>boxes</code>,
specifying the operations to be performed when each button
is clicked. Entries can also be <code>NULL</code> indicating that no
action should occur. See Details.
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_redraws">redraws</code></td>
<td>

<p>Optional list of <span class="rlang"><b>R</b></span> functions, of the same length as <code>boxes</code>,
specifying how to redraw each button. Entries can also be
<code>NULL</code> indicating a simple default. See Details.
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_exit">exit</code></td>
<td>

<p>An <span class="rlang"><b>R</b></span> function specifying actions to be taken when the
interactive panel terminates.
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_env">env</code></td>
<td>

<p>An <code>environment</code> that will be passed as an argument
to all the functions in <code>clicks</code>, <code>redraws</code> and
<code>exit</code>.
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_p">P</code></td>
<td>

<p>An existing interaction panel (object of class <code>"simplepanel"</code>).
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_side">side</code></td>
<td>

<p>Character string identifying which side of the panel <code>P</code>
should be grown to accommodate the new buttons.
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_len">len</code></td>
<td>

<p>Optional. Thickness of the new panel area that should be grown
to accommodate the new buttons. A single number in the same units
as the coordinate system of <code>P</code>.
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_new.clicks">new.clicks</code></td>
<td>

<p>List of <span class="rlang"><b>R</b></span> functions defining the operations to be performed
when each of the new buttons is clicked.
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_new.redraws">new.redraws</code></td>
<td>

<p>Optional. List of <span class="rlang"><b>R</b></span> functions, of the same length as
<code>new.clicks</code>, defining how to redraw each of the new buttons.
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+layout.boxes">layout.boxes</a></code> to determine the
layout of the new buttons.
</p>
</td></tr>
<tr><td><code id="simplepanel_+3A_aspect">aspect</code></td>
<td>

<p>Optional. Aspect ratio (height/width) of the new buttons.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions enable the user to create a simple, robust,
point-and-click interface to any <span class="rlang"><b>R</b></span> code.
</p>
<p>The functions <code>simplepanel</code> and <code>grow.simplepanel</code>
create an object of class <code>"simplepanel"</code>. Such an object defines
the graphics to be displayed and the actions to be performed
when the user interacts with the panel.
</p>
<p>The panel is activated by calling <code><a href="#topic+run.simplepanel">run.simplepanel</a></code>.
</p>
<p>The function <code>simplepanel</code> creates a panel object
from basic data.
The function <code>grow.simplepanel</code> modifies an existing
panel object <code>P</code> by growing an additional row or column
of buttons. 
</p>
<p>For <code>simplepanel</code>,
</p>

<ul>
<li> 
<p>The spatial layout of the panel is determined by the rectangles
<code>B</code> and <code>boxes</code>.
</p>
</li>
<li> 
<p>The argument <code>clicks</code> must be a list of functions
specifying the action to be taken when each button is clicked
(or <code>NULL</code> to indicate that no action should be taken).
The list entries should have names (but there are sensible defaults).
Each function should be of the form <code>function(env, xy)</code> where
<code>env</code> is an <code>environment</code> that may contain shared data,
and <code>xy</code> gives the coordinates of the mouse click, in the format
<code>list(x, y)</code>.
The function returns <code>TRUE</code> if the
panel should continue running, and <code>FALSE</code> if the panel
should terminate.
</p>
</li>
<li> 
<p>The argument <code>redraws</code>, if given, must be a list of functions
specifying the action to be taken when each button is to be redrawn.
Each function should be of the form <code>function(button, name, env)</code> where
<code>button</code> is a rectangle specifying the location of the button
in the current coordinate system; <code>name</code> is a character string
giving the name of the button; and <code>env</code> is the
<code>environment</code> that may contain shared data.
The function returns <code>TRUE</code> if the
panel should continue running, and <code>FALSE</code> if the panel
should terminate. 
If <code>redraws</code> is not given (or if one of the entries in
<code>redraws</code> is <code>NULL</code>), the default action is to draw a pink
rectangle showing the button position,
draw the name of the button in the middle of this rectangle,
and return <code>TRUE</code>. 
</p>
</li>
<li>
<p>The argument <code>exit</code>, if given, must be a function
specifying the action to be taken when the panel terminates.
(Termination occurs when one of the <code>clicks</code> functions
returns <code>FALSE</code>).
The <code>exit</code> function should be of the form <code>function(env)</code> where
<code>env</code> is the <code>environment</code> that may contain shared data.
Its return value will be used as the return value
of <code><a href="#topic+run.simplepanel">run.simplepanel</a></code>.
</p>
</li>
<li>
<p>The argument <code>env</code> should be an <span class="rlang"><b>R</b></span> environment.
The panel buttons will have access to this environment,
and will be able to read and write data in it. This mechanism is used
to exchange data between the panel and other <span class="rlang"><b>R</b></span> code.
</p>
</li></ul>

<p>For <code>grow.simplepanel</code>,
</p>

<ul>
<li><p> the spatial layout of the new boxes
is determined by the arguments <code>side</code>, <code>len</code>,
<code>aspect</code> and by the additional <code>...</code> arguments passed to
<code><a href="#topic+layout.boxes">layout.boxes</a></code>.
</p>
</li>
<li><p> the argument <code>new.clicks</code> 
should have the same format as <code>clicks</code>.
It implicitly specifies the number of new buttons to be added,
and the actions to be performed when they are clicked.
</p>
</li>
<li><p> the optional argument <code>new.redraws</code>, if given,
should have the same format as <code>redraws</code>.
It specifies the actions to be performed when the
new buttons are clicked.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"simplepanel"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.simplepanel">run.simplepanel</a></code>,
<code><a href="#topic+layout.boxes">layout.boxes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # make boxes (alternatively use layout.boxes())
  Bminus &lt;- square(1)
  Bvalue &lt;- shift(Bminus, c(1.2, 0))
  Bplus &lt;- shift(Bvalue, c(1.2, 0))
  Bdone &lt;- shift(Bplus, c(1.2, 0))
  myboxes &lt;- list(Bminus, Bvalue, Bplus, Bdone)
  myB &lt;- do.call(boundingbox,myboxes)

  # make environment containing an integer count
  myenv &lt;- new.env()
  assign("answer", 0, envir=myenv)

  # what to do when finished: return the count.
  myexit &lt;- function(e) { return(get("answer", envir=e)) }

  # button clicks
  # decrement the count
  Cminus &lt;- function(e, xy) {
    ans &lt;- get("answer", envir=e)
    assign("answer", ans - 1, envir=e)
    return(TRUE)
  }
  # display the count (clicking does nothing)
  Cvalue &lt;- function(...) { TRUE }
  # increment the count
  Cplus &lt;- function(e, xy) {
    ans &lt;- get("answer", envir=e)
    assign("answer", ans + 1, envir=e)
    return(TRUE)
  }
  # 'Clear' button
  Cclear &lt;- function(e, xy) {
    assign("answer", 0, envir=e)
    return(TRUE)
  }
  # quit button
  Cdone &lt;- function(e, xy) { return(FALSE) }

  myclicks &lt;- list("-"=Cminus,
                   value=Cvalue,
                   "+"=Cplus,
                   done=Cdone)

  # redraw the button that displays the current value of the count
  Rvalue &lt;- function(button, nam, e) {
     plot(button, add=TRUE)
     ans &lt;- get("answer", envir=e)
     text(centroid.owin(button), labels=ans)
     return(TRUE)
  }

  # make the panel
  P &lt;- simplepanel("Counter",
                   B=myB, boxes=myboxes,
                   clicks=myclicks,
                   redraws = list(NULL, Rvalue, NULL, NULL),
                   exit=myexit, env=myenv)
  # print it
  P
  # show what it looks like
  redraw.simplepanel(P)

  # ( type run.simplepanel(P) to run the panel interactively )

  # add another button to right
  Pplus &lt;- grow.simplepanel(P, "right", new.clicks=list(clear=Cclear))
</code></pre>

<hr>
<h2 id='simplify.owin'>
Approximate a Polygon by a Simpler Polygon
</h2><span id='topic+simplify.owin'></span>

<h3>Description</h3>

<p>Given a polygonal window, this function finds a simpler polygon
that approximates it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify.owin(W, dmin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify.owin_+3A_w">W</code></td>
<td>

<p>The polygon which is to be simplied.
An object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="simplify.owin_+3A_dmin">dmin</code></td>
<td>

<p>Numeric value. The smallest permissible length of an edge.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simplifies a polygon <code>W</code>
by recursively deleting the shortest edge of <code>W</code>
until all remaining edges are longer than the specified
minimum length <code>dmin</code>, or until there are only three edges left.
</p>
<p>The argument <code>W</code> must be a window (object of class
<code>"owin"</code>). It should be of type <code>"polygonal"</code>.
If <code>W</code> is a rectangle, it is returned without alteration.
</p>
<p>The simplification algorithm is not yet implemented for
binary masks. If <code>W</code> is a mask, an error is generated.
</p>


<h3>Value</h3>

<p>Another window (object of class <code>"owin"</code>)
of type <code>"polygonal"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin">owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(letterR, col="red")
  plot(simplify.owin(letterR, 0.3), col="blue", add=TRUE)

  W &lt;- Window(chorley)
  plot(W)
  WS &lt;- simplify.owin(W, 2)
  plot(WS, add=TRUE, border="green")
  points(vertices(WS))
</code></pre>

<hr>
<h2 id='solapply'>
Apply a Function Over a List and Obtain a List of Objects
</h2><span id='topic+solapply'></span><span id='topic+anylapply'></span>

<h3>Description</h3>

<p>Applies the function <code>FUN</code> to each element of the list <code>X</code>,
and returns the result as a list of class <code>"solist"</code>
or <code>"anylist"</code> as appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  anylapply(X, FUN, ...)

  solapply(X, FUN, ..., check = TRUE, promote = TRUE, demote = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solapply_+3A_x">X</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="solapply_+3A_fun">FUN</code></td>
<td>

<p>Function to be applied to each element of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="solapply_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code>FUN</code>.
</p>
</td></tr>
<tr><td><code id="solapply_+3A_check">check</code>, <code id="solapply_+3A_promote">promote</code>, <code id="solapply_+3A_demote">demote</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+solist">solist</a></code> which determine
how to handle different classes of objects.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These convenience functions are similar to <code><a href="base.html#topic+lapply">lapply</a></code>
except that they return a list of class <code>"solist"</code> or
<code>"anylist"</code>.
</p>
<p>In both functions, the result is computed by 
<code>lapply(X, FUN, ...)</code>.
</p>
<p>In <code>anylapply</code> the result is converted to a list of class
<code>"anylist"</code> and returned.
</p>
<p>In <code>solapply</code> the result is converted to
a list of class <code>"solist"</code> <b>if possible</b>, using 
<code><a href="#topic+as.solist">as.solist</a></code>. If this is not possible,
then the behaviour depends on the argument <code>demote</code>.
If <code>demote=TRUE</code> the result will be returned as a
list of class <code>"anylist"</code>. If <code>demote=FALSE</code> (the default),
an error occurs.
</p>


<h3>Value</h3>

<p>A list, usually of class <code>"solist"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+solist">solist</a></code>, 
<code><a href="#topic+anylist">anylist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  solapply(waterstriders, distmap)
</code></pre>

<hr>
<h2 id='solist'>
List of Two-Dimensional Spatial Objects
</h2><span id='topic+solist'></span>

<h3>Description</h3>

<p>Make a list of two-dimensional spatial objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solist(..., check=TRUE, promote=TRUE, demote=FALSE, .NameBase)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solist_+3A_...">...</code></td>
<td>

<p>Any number of objects, each representing a two-dimensional
spatial dataset.
</p>
</td></tr>
<tr><td><code id="solist_+3A_check">check</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, check that each of the
objects is a 2D spatial object.
</p>
</td></tr>
<tr><td><code id="solist_+3A_promote">promote</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, test whether all objects belong to
the <em>same</em> class, and if so, promote the list of objects
to the appropriate class of list.
</p>
</td></tr>
<tr><td><code id="solist_+3A_demote">demote</code></td>
<td>

<p>Logical value determining what should happen if any of the
objects is not a 2D spatial object: if <code>demote=FALSE</code> (the
default), a fatal error occurs; if <code>demote=TRUE</code>,
a list of class <code>"anylist"</code> is returned.
</p>
</td></tr>
<tr><td><code id="solist_+3A_.namebase">.NameBase</code></td>
<td>

<p>Optional. Character string. If the <code>...</code> arguments have no
names, then the entries of the resulting list will be given
names that start with <code>.NameBase</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command creates an object of class <code>"solist"</code>
(spatial object list)
which represents a list of two-dimensional spatial datasets.
The datasets do not necessarily belong to the same class.
</p>
<p>Typically the intention is that the datasets in the list
should be treated in the same way, for example, they should
be plotted side-by-side. The <span class="pkg">spatstat</span> package
provides a plotting function, <code><a href="#topic+plot.solist">plot.solist</a></code>,
and many other functions for this class.
</p>
<p>In the <span class="pkg">spatstat</span> package, various functions produce
an object of class <code>"solist"</code>. For example, when
a point pattern is split into several point patterns by
<code><a href="#topic+split.ppp">split.ppp</a></code>, or an image is split into several
images by <code><a href="#topic+split.im">split.im</a></code>, the result is of
class <code>"solist"</code>.
</p>
<p>If <code>check=TRUE</code> then the code will check whether all
objects in <code>...</code> belong to the classes
of two-dimensional spatial objects defined in the
<span class="pkg">spatstat</span> package. They do not have to belong to the
<em>same</em> class. Set <code>check=FALSE</code>
for efficiency, but only if you are sure that all the objects are valid.
</p>
<p>If some of the objects in <code>...</code> are
not two-dimensional spatial objects,
the action taken depends on the argument <code>demote</code>.
If <code>demote=TRUE</code>, the result will belong to the more general
class <code>"anylist"</code> instead of <code>"solist"</code>.
If <code>demote=FALSE</code> (the default), an error occurs.
</p>
<p>If <code>promote=TRUE</code> then the code will check whether all
the objects <code>...</code> belong to the same class.
If they are all point patterns (class <code>"ppp"</code>),
the result will also belong to the class <code>"ppplist"</code>.
If they are all pixel images (class <code>"im"</code>), the result
will also belong to the class <code>"imlist"</code>.
</p>
<p>Use <code><a href="#topic+as.solist">as.solist</a></code> to convert a list to a <code>"solist"</code>.
</p>


<h3>Value</h3>

<p>A list, usually belonging to the class <code>"solist"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.solist">as.solist</a></code>,
<code><a href="#topic+anylist">anylist</a></code>,
<code><a href="#topic+solapply">solapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  solist(cells, distmap(cells), quadratcount(cells))
  solist(cells, japanesepines, redwood, .NameBase="Pattern")
</code></pre>

<hr>
<h2 id='solutionset'>Evaluate Logical Expression Involving Pixel Images and Return
Region Where Expression is True</h2><span id='topic+solutionset'></span>

<h3>Description</h3>

<p>Given a logical expression involving one or more pixel images,
find all pixels where the expression is true,
and assemble these pixels into a window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  solutionset(..., envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solutionset_+3A_...">...</code></td>
<td>
<p>An expression in the <span class="rlang"><b>R</b></span> language, involving one or more
pixel images.</p>
</td></tr>
<tr><td><code id="solutionset_+3A_envir">envir</code></td>
<td>
<p>Optional. The environment in which to evaluate the
expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a logical expression involving one or more pixel images,
this function will find all pixels where the expression is true,
and assemble these pixels into a spatial window.
</p>
<p>Pixel images in <code>spatstat</code>
are represented by objects of class <code>"im"</code>
(see <code><a href="#topic+im.object">im.object</a></code>). These are essentially matrices of
pixel values, with extra attributes recording the pixel dimensions,
etc.
</p>
<p>Suppose <code>X</code> is a pixel image. Then <code>solutionset(abs(X) &gt; 3)</code>
will find all the pixels in <code>X</code> for which the pixel value
is greater than 3 in absolute value, and return a window containing
all these pixels.
</p>
<p>If <code>X</code> and <code>Y</code> are two pixel images,
<code>solutionset(X &gt; Y)</code> will find all pixels for which the
pixel value of <code>X</code> is greater than the corresponding pixel value
of <code>Y</code>, and return a window containing these pixels.
</p>
<p>In general, <code>...</code> can be any logical expression involving
pixel images.
</p>
<p>The code first tries to evaluate the expression using
<code><a href="#topic+eval.im">eval.im</a></code>.
This is successful if the expression involves only
(a) the <em>names</em> of pixel images, (b) scalar
constants, and (c) functions which are vectorised.
There must be at least one pixel image in the expression.
The expression <code>expr</code> must be vectorised.
See the Examples.
</p>
<p>If this is unsuccessful, the code then tries to evaluate the
expression using pixel arithmetic. This is successful if all the
arithmetic operations in the expression are listed
in <code><a href="#topic+Math.im">Math.im</a></code>. 
</p>


<h3>Value</h3>

<p>A spatial window
(object of class <code>"owin"</code>, see <code><a href="#topic+owin.object">owin.object</a></code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im.object">im.object</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+eval.im">eval.im</a></code>,
<code><a href="#topic+levelset">levelset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # test images
  X &lt;- as.im(function(x,y) { x^2 - y^2 }, unit.square())
  Y &lt;- as.im(function(x,y) { 3 * x + y  - 1}, unit.square())

  W &lt;- solutionset(abs(X) &gt; 0.1)
  W &lt;- solutionset(X &gt; Y)
  W &lt;- solutionset(X + Y &gt;= 1)

  area(solutionset(X &lt; Y))

  solutionset(distmap(cells) &lt; 0.05)
</code></pre>

<hr>
<h2 id='spatdim'>Spatial Dimension of a Dataset</h2><span id='topic+spatdim'></span>

<h3>Description</h3>

<p>Extracts the spatial dimension of an object in the
<span class="pkg">spatstat</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatdim(X, intrinsic=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatdim_+3A_x">X</code></td>
<td>

<p>Object belonging to any class defined in the
<span class="pkg">spatstat</span> package.
</p>
</td></tr>
<tr><td><code id="spatdim_+3A_intrinsic">intrinsic</code></td>
<td>

<p>Logical value indicating whether to return the
number of intrinsic dimensions. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the number of spatial coordinate dimensions
of the dataset <code>X</code>. The results for some of the more common
types of objects are as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>object class</b> </td><td style="text-align: left;"> <b>dimension</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"ppp"</code> </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"lpp"</code> </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"pp3"</code> </td><td style="text-align: left;"> 3 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"ppx"</code> </td><td style="text-align: left;"> number of <em>spatial</em> dimensions </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"owin"</code> </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"psp"</code> </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"ppm"</code> </td><td style="text-align: left;"> 2
  </td>
</tr>

</table>

<p>Note that time dimensions are not counted.
</p>
<p>Some spatial objects are lower-dimensional subsets of the
space in which they live. This lower number of dimensions
is returned if <code>intrinsic=TRUE</code>. For example, a dataset
on a linear network
(an object <code>X</code> of class <code>"linnet", "lpp", "linim", "linfun"</code>
or <code>"lintess"</code>) returns <code>spatdim(X) = 2</code> but
<code>spatdim(X, intrinsic=TRUE) = 1</code>.
</p>
<p>If <code>X</code> is not a recognised spatial object, the result is <code>NA</code>.
</p>


<h3>Value</h3>

<p>An integer, or <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  spatdim(lansing)
  A &lt;- osteo$pts[[1]]
  spatdim(A)
  spatdim(domain(A))
</code></pre>

<hr>
<h2 id='spatstat.geom-deprecated'>Deprecated spatstat.geom functions</h2><span id='topic+as.psp.owin'></span><span id='topic+circumradius'></span><span id='topic+circumradius.owin'></span><span id='topic+circumradius.ppp'></span>

<h3>Description</h3>

<p>Deprecated spatstat.geom functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'owin'
as.psp(x, ..., window=NULL, 
       check=spatstat.options("checksegments"), fatal=TRUE)
circumradius(x, ...)
## S3 method for class 'owin'
circumradius(x, ...)
## S3 method for class 'ppp'
circumradius(x, ...)
</code></pre>


<h3>Details</h3>

<p>These functions are deprecated, and will eventually be deleted from
the <span class="pkg">spatstat.geom</span> package.
</p>
<p><code>as.psp.owin</code> has been replaced by <code><a href="#topic+edges">edges</a></code>.
</p>
<p><code>circumradius</code> is replaced by the more appropriately named
<code>boundingradius</code>.
</p>


<h3>Value</h3>

<p><code>as.psp.owin</code> returns a window (object of class <code>"owin"</code>).
</p>
<p><code>circumradius</code> returns a numeric value.
</p>

<hr>
<h2 id='spatstat.geom-internal'>Internal spatstat.geom functions</h2><span id='topic++5B.diagramobj'></span><span id='topic++5B.pp3'></span><span id='topic++5B.splitppx'></span><span id='topic++5B+3C-.splitppx'></span><span id='topic+acedist.show'></span><span id='topic+acedist.noshow'></span><span id='topic+affinexy'></span><span id='topic+affinexypolygon'></span><span id='topic+allElementsIdentical'></span><span id='topic+anycrossing.psp'></span><span id='topic+applytolayers'></span><span id='topic+applyPolyclipArgs'></span><span id='topic+areaGain.diri'></span><span id='topic+areaGain.grid'></span><span id='topic+areaLoss.diri'></span><span id='topic+areaLoss.grid'></span><span id='topic+areaLoss.poly'></span><span id='topic+AsymmDistance.psp'></span><span id='topic+as.breakpts'></span><span id='topic+as.character.unitname'></span><span id='topic+as.data.frame.ppplist'></span><span id='topic+as.double.im'></span><span id='topic+as.imlist'></span><span id='topic+as.linimlist'></span><span id='topic+as.list.hyperframe'></span><span id='topic+as.listof'></span><span id='topic+as.ppplist'></span><span id='topic+as.unitname'></span><span id='topic+avenndist'></span><span id='topic+bbEngine'></span><span id='topic+bdry.mask'></span><span id='topic+boundingbox.list'></span><span id='topic+bounding.box3'></span><span id='topic+break.holes'></span><span id='topic+breakpts'></span><span id='topic+breakpts.from.r'></span><span id='topic+cartesian'></span><span id='topic+cellmiddles'></span><span id='topic+checkbigmatrix'></span><span id='topic+checkfields'></span><span id='topic+check.arc'></span><span id='topic+check.finespacing'></span><span id='topic+check.hist.lengths'></span><span id='topic+circunion'></span><span id='topic+clip.psp'></span><span id='topic+cliprect.psp'></span><span id='topic+clippoly.psp'></span><span id='topic+closethresh'></span><span id='topic+cocoEngine'></span><span id='topic+coerce.marks.numeric'></span><span id='topic+crosspairquad'></span><span id='topic+cobble.xy'></span><span id='topic+codetime'></span><span id='topic+col.args.to.grey'></span><span id='topic+commonPolyclipArgs'></span><span id='topic+conform.imagelist'></span><span id='topic+countingweights'></span><span id='topic+default.n.tiling'></span><span id='topic+default.ntile'></span><span id='topic+dimnames.hyperframe'></span><span id='topic+dimnames+3C-.hyperframe'></span><span id='topic+dflt.redraw'></span><span id='topic+diagramobj'></span><span id='topic+dim.hyperframe'></span><span id='topic+dim.im'></span><span id='topic+dim.owin'></span><span id='topic+dist2dpath'></span><span id='topic+do.as.im'></span><span id='topic+do.call.plotfun'></span><span id='topic+drawSignedPoly'></span><span id='topic+emptywindow'></span><span id='topic+equalpairs.quad'></span><span id='topic+equals.quad'></span><span id='topic+equalsfun.quad'></span><span id='topic+erodemask'></span><span id='topic+even.breaks.owin'></span><span id='topic+exactdt'></span><span id='topic+exactPdt'></span><span id='topic+existsSpatstatVariable'></span><span id='topic+expandSpecialLists'></span><span id='topic+fakemaintitle'></span><span id='topic+fft2D'></span><span id='topic+fftwAvailable'></span><span id='topic+fillNA'></span><span id='topic+flipxypolygon'></span><span id='topic+format.numberwithunit'></span><span id='topic+framebottomleft'></span><span id='topic+gammabreaks'></span><span id='topic+genericNNdistBy'></span><span id='topic+getfields'></span><span id='topic+getlastshift'></span><span id='topic+getSpatstatVariable'></span><span id='topic+gridindex'></span><span id='topic+grid1index'></span><span id='topic+grow.mask'></span><span id='topic+handle.r.b.args'></span><span id='topic+head.hyperframe'></span><span id='topic+hsvNA'></span><span id='topic+IdenticalRowPair'></span><span id='topic+IdenticalRows'></span><span id='topic+idorempty'></span><span id='topic+imageOp'></span><span id='topic+imagelistOp'></span><span id='topic+inpoint'></span><span id='topic+inside.arc'></span><span id='topic+interpretAsOrigin'></span><span id='topic+intX.owin'></span><span id='topic+intX.xypolygon'></span><span id='topic+intY.owin'></span><span id='topic+intY.xypolygon'></span><span id='topic+invokeColourmapRule'></span><span id='topic+is.col.argname'></span><span id='topic+is.data'></span><span id='topic+is.fv'></span><span id='topic+is.hyperframe'></span><span id='topic+is.imlist'></span><span id='topic+is.infline'></span><span id='topic+is.marked.default'></span><span id='topic+is.marked.psp'></span><span id='topic+is.marked.quad'></span><span id='topic+is.multitype.default'></span><span id='topic+is.multitype.quad'></span><span id='topic+is.ppplist'></span><span id='topic+is.pp3'></span><span id='topic+is.ppx'></span><span id='topic+is.psp'></span><span id='topic+is.quad'></span><span id='topic+is.sob'></span><span id='topic+is.solist'></span><span id='topic+is.tess'></span><span id='topic+is.vanilla'></span><span id='topic+levels.im'></span><span id='topic+levels+3C-.im'></span><span id='topic+levelsAsFactor'></span><span id='topic+listof'></span><span id='topic+logi.dummy'></span><span id='topic+markvaluetype'></span><span id='topic+packupNNdata'></span><span id='topic+parbreak'></span><span id='topic+perspVisible'></span><span id='topic+plan.legend.layout'></span><span id='topic+pointweights'></span><span id='topic+polytileareaEngine'></span><span id='topic+putSpatstatVariable'></span><span id='topic+lookup.im'></span><span id='topic+majorminorversion'></span><span id='topic+make.even.breaks'></span><span id='topic+makeunitname'></span><span id='topic+markappend'></span><span id='topic+markcbind'></span><span id='topic+markformat'></span><span id='topic+markformat.ppp'></span><span id='topic+markformat.ppx'></span><span id='topic+markformat.psp'></span><span id='topic+markformat.default'></span><span id='topic+mark.scale.default'></span><span id='topic+markspace.integral'></span><span id='topic+marks.default'></span><span id='topic+marks.quad'></span><span id='topic++25mapp+25'></span><span id='topic+markappendop'></span><span id='topic+marksubset'></span><span id='topic+markreplicateop'></span><span id='topic++25mrep+25'></span><span id='topic+marksubsetop'></span><span id='topic++25msub+25'></span><span id='topic+mask2df'></span><span id='topic+maxflow'></span><span id='topic+meanX.owin'></span><span id='topic+meanY.owin'></span><span id='topic+MinimalTess'></span><span id='topic+multiplicityNumeric'></span><span id='topic+multiply.only.finite.entries'></span><span id='topic+na.handle.im'></span><span id='topic+names.hyperframe'></span><span id='topic+names+3C-.hyperframe'></span><span id='topic+nearest.pixel'></span><span id='topic+nearest.valid.pixel'></span><span id='topic+n.quad'></span><span id='topic+numberwithunit'></span><span id='topic+numeric.columns'></span><span id='topic+onecolumn'></span><span id='topic+owinInternalRect'></span><span id='topic+owinInternalMask'></span><span id='topic+owinInternalPoly'></span><span id='topic+owinpolycheck'></span><span id='topic+owinpoly2mask'></span><span id='topic+owin2polypath'></span><span id='topic+param.quad'></span><span id='topic+PDtoNN'></span><span id='topic+pickoption'></span><span id='topic+plotEachLayer'></span><span id='topic+plot3Dpoints'></span><span id='topic+plotPolygonBdry'></span><span id='topic+plotWidthMap'></span><span id='topic+plot.barplotdata'></span><span id='topic+plot.indicfun'></span><span id='topic+ppllengine'></span><span id='topic+pppdist.mat'></span><span id='topic+pppdist.prohorov'></span><span id='topic+ppsubset'></span><span id='topic+prepareTitle'></span><span id='topic+print.anylist'></span><span id='topic+print.colourmap'></span><span id='topic+print.distfun'></span><span id='topic+print.ewcdf'></span><span id='topic+print.funxy'></span><span id='topic+print.hyperframe'></span><span id='topic+print.indicfun'></span><span id='topic+print.layered'></span><span id='topic+print.lut'></span><span id='topic+print.metric'></span><span id='topic+print.metricfun'></span><span id='topic+print.nnfun'></span><span id='topic+print.numberwithunit'></span><span id='topic+print.onearrow'></span><span id='topic+print.pppmatching'></span><span id='topic+print.simplepanel'></span><span id='topic+print.solist'></span><span id='topic+print.splitppp'></span><span id='topic+print.splitppx'></span><span id='topic+print.summary.distfun'></span><span id='topic+print.summary.funxy'></span><span id='topic+print.summary.hyperframe'></span><span id='topic+print.summary.listof'></span><span id='topic+print.summary.logiquad'></span><span id='topic+print.summary.lut'></span><span id='topic+print.summary.owin'></span><span id='topic+print.summary.ppp'></span><span id='topic+print.summary.psp'></span><span id='topic+print.summary.solist'></span><span id='topic+print.summary.splitppp'></span><span id='topic+print.summary.splitppx'></span><span id='topic+print.summary.symbolmap'></span><span id='topic+print.summary.unitname'></span><span id='topic+print.symbolmap'></span><span id='topic+print.textstring'></span><span id='topic+print.texturemap'></span><span id='topic+print.tess'></span><span id='topic+print.timed'></span><span id='topic+print.yardstick'></span><span id='topic+project3Dhom'></span><span id='topic+putlastshift'></span><span id='topic+qtPrepareCoordinate'></span><span id='topic+quad'></span><span id='topic+quantilefun.interpolatedCDF'></span><span id='topic+rasterfilter'></span><span id='topic+recognise.spatstat.type'></span><span id='topic+rectquadrat.breaks'></span><span id='topic+rectquadrat.countEngine'></span><span id='topic+remove.identical.pairs'></span><span id='topic+repair.image.xycoords'></span><span id='topic+resolve.stringsAsFactors'></span><span id='topic+rgbNA'></span><span id='topic+ruletextline'></span><span id='topic+quadscheme.replicated'></span><span id='topic+quadscheme.spatial'></span><span id='topic+pointgrid'></span><span id='topic+rastersample'></span><span id='topic+rasterx.mask'></span><span id='topic+rastery.mask'></span><span id='topic+rasterxy.mask'></span><span id='topic+rasterx.im'></span><span id='topic+rastery.im'></span><span id='topic+rasterxy.im'></span><span id='topic+rebound'></span><span id='topic+rebound.im'></span><span id='topic+rebound.ppp'></span><span id='topic+rebound.psp'></span><span id='topic+rebound.owin'></span><span id='topic+repair.old.factor.image'></span><span id='topic+restrict.mask'></span><span id='topic+reversePolyclipArgs'></span><span id='topic+rotxy'></span><span id='topic+rotxypolygon'></span><span id='topic+row.names.hyperframe'></span><span id='topic+row.names+3C-.hyperframe'></span><span id='topic+safedeldir'></span><span id='topic+safeDevCapabilities'></span><span id='topic+safelookup'></span><span id='topic+scalardilate.breakpts'></span><span id='topic+scalardilate.diagramobj'></span><span id='topic+shift.diagramobj'></span><span id='topic+shift.quadratcount'></span><span id='topic+shiftxy'></span><span id='topic+shiftxypolygon'></span><span id='topic+simulationresult'></span><span id='topic+smudge'></span><span id='topic+sort.im'></span><span id='topic+spatstatDiagnostic'></span><span id='topic+spatstat.deldir.setopt'></span><span id='topic+spatstat.xy.coords'></span><span id='topic+store.versionstring.spatstat'></span><span id='topic+str.hyperframe'></span><span id='topic+summary.hyperframe'></span><span id='topic+summary.logiquad'></span><span id='topic+summary.lut'></span><span id='topic+summary.metric'></span><span id='topic+summary.pppmatching'></span><span id='topic+summary.ppx'></span><span id='topic+summary.splitppx'></span><span id='topic+summary.symbolmap'></span><span id='topic+superimposeMarks'></span><span id='topic+symbolmapdomain'></span><span id='topic+symbolmapparnames'></span><span id='topic+symbolmaptype'></span><span id='topic+symbol.sizes.default'></span><span id='topic+tail.hyperframe'></span><span id='topic+thickSegments'></span><span id='topic+tilecentroids'></span><span id='topic+trianglediameters'></span><span id='topic+trim.mask'></span><span id='topic+tweak.closepairs'></span><span id='topic++25unit+25'></span><span id='topic+unitname.default'></span><span id='topic+unitname+3C-.default'></span><span id='topic+unstackFilter'></span><span id='topic+update.im'></span><span id='topic+validradius'></span><span id='topic+validate.mask'></span><span id='topic+validate.quad'></span><span id='topic+versioncurrency.spatstat'></span><span id='topic+versionstring.spatstat'></span><span id='topic+verifyclass'></span><span id='topic+veryunique'></span><span id='topic+warn.once'></span><span id='topic+warn.no.metric.support'></span><span id='topic+warn.unsupported.args'></span><span id='topic+waxlyrical'></span><span id='topic+wrangle2image'></span><span id='topic+w.quad'></span><span id='topic+x.quad'></span><span id='topic+y.quad'></span><span id='topic+xy.grid'></span><span id='topic+xtfrm.im'></span><span id='topic+XDtoNN'></span><span id='topic+xypolygon2psp'></span><span id='topic+xypolyselfint'></span><span id='topic+ZeroValue'></span><span id='topic+ZeroValue.im'></span>

<h3>Description</h3>

<p>Internal spatstat.geom functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diagramobj'
x[...]
## S3 method for class 'pp3'
x[i, drop, ...]
## S3 method for class 'splitppx'
x[...]
## S3 replacement method for class 'splitppx'
x[...] &lt;- value
acedist.show(X, Y, n, d, timelag)
acedist.noshow(X, Y, n, d)
affinexy(X, mat, vec, invert)
affinexypolygon(p, mat, vec, detmat)
allElementsIdentical(x, entry)
anycrossing.psp(A,B)
applytolayers(L, FUN, ...)
applyPolyclipArgs(x, p)
areaGain.diri(u, X, r, ..., W, verbose)
areaGain.grid(u, X, r, ..., W, ngrid)
areaLoss.diri(X, r, ..., W, subset)
areaLoss.grid(X, r, ..., W, subset,
                         method = c("count", "distmap"),
                         ngrid = spatstat.options("ngrid.disc"),
                         exact = FALSE)
areaLoss.poly(X, r, ..., W, subset, splitem)
AsymmDistance.psp(X, Y, metric, method)
as.breakpts(...)
## S3 method for class 'unitname'
as.character(x, ...)
## S3 method for class 'ppplist'
as.data.frame(x, row.names, ...)
## S3 method for class 'im'
as.double(x, ...)
as.imlist(x, check)
as.linimlist(x, check)
## S3 method for class 'hyperframe'
as.list(x, ...)
as.listof(x)
as.ppplist(x, check)
as.unitname(s)
avenndist(X)
bbEngine(...)
bdry.mask(W)
## S3 method for class 'list'
boundingbox(...)
bounding.box3(...)
break.holes(x, splitby, depth, maxdepth)
breakpts(val, maxi, even = FALSE, npos = NULL, step = NULL)
breakpts.from.r(r)
cartesian(pp, markset, fac = TRUE)
cellmiddles(W, nx, ny, npix, distances)
checkbigmatrix(n, m, fatal, silent)
checkfields(X,L)
check.arc(arc, fatal)
check.finespacing(r, eps, win, rmaxdefault, context, action, rname)
check.hist.lengths(hist,breaks)
circunion(arcs)
clip.psp(x, window, check, fragments)
cliprect.psp(x, window, fragments)
clippoly.psp(s, window, fragments)
closethresh(X,R,S,twice,...)
cocoEngine(nv, ie, je, algoname)
coerce.marks.numeric(X, warn)
crosspairquad(Q,rmax,what)
cobble.xy(x, y, f, fatal, ...)
codetime(x, hms, what)
col.args.to.grey(x, ...)
commonPolyclipArgs(..., p)
conform.imagelist(X, Zlist)
countingweights(id, areas, check = TRUE)
default.n.tiling(X, nd, ntile, npix, eps, random, quasi, verbose)
default.ntile(X)
## S3 method for class 'hyperframe'
dimnames(x)
## S3 replacement method for class 'hyperframe'
dimnames(x) &lt;- value
dflt.redraw(button, name, env)
diagramobj(X, ...)
## S3 method for class 'hyperframe'
dim(x)
## S3 method for class 'im'
dim(x)
## S3 method for class 'owin'
dim(x)
dist2dpath(dist, method="C")
do.as.im(x, action, ..., W, eps, dimyx, xy, rule.eps, na.replace)
do.call.plotfun(fun, arglist, ..., envir)
drawSignedPoly(x,y,pars,sgn)
emptywindow(w)
equalpairs.quad(Q)
equals.quad(Q)          
equalsfun.quad(Q)
erodemask(w,r,strict)
even.breaks.owin(w)
exactdt(X, ...)              
exactPdt(w)
existsSpatstatVariable(name)
expandSpecialLists(x, special)
fakemaintitle(bb, main, ...)
fft2D(z, inverse, west)
fftwAvailable()
fillNA(x, value)
flipxypolygon(p)
## S3 method for class 'numberwithunit'
format(x, ..., collapse, modifier)
framebottomleft(w)
gammabreaks(ra, n, gamma)
genericNNdistBy(X, by, k)
getfields(X, L, fatal = TRUE)
getlastshift(X)
getSpatstatVariable(name, default)
gridindex(x, y, xrange, yrange, nx, ny)            
grid1index(x, xrange, nx)
grow.mask(M, xmargin=0, ymargin=xmargin)
handle.r.b.args(r = NULL, breaks = NULL, window, pixeps = NULL, rmaxdefault)
## S3 method for class 'hyperframe'
head(x,n,...)
hsvNA(h, s, v, alpha)
IdenticalRowPair(i,j,a,b)
IdenticalRows(i,j,a,b)
idorempty(w, r, caller)
imageOp(e1, e2, op)
imagelistOp(e1, e2, op)
inpoint(W)
inside.arc(theta, arc)
interpretAsOrigin(x, W)
intX.owin(w)
intX.xypolygon(polly)
intY.owin(w)
intY.xypolygon(polly)
invokeColourmapRule(colfun, x, ..., zlim, colargs)
is.col.argname(x)
is.data(Q)
is.fv(x)
is.hyperframe(x)
is.imlist(x)
is.infline(x)
## Default S3 method:
is.marked(...)  
## S3 method for class 'psp'
is.marked(X, ...)
## S3 method for class 'quad'
is.marked(X, na.action="warn", ...)
## Default S3 method:
is.multitype(X, ...)  
## S3 method for class 'quad'
is.multitype(X, na.action="warn", ...)
is.ppplist(x)
is.pp3(x)
is.ppx(x)
is.psp(x)
is.quad(x)
is.solist(x)
is.sob(x)
is.tess(x)
is.vanilla(u)
## S3 method for class 'im'
levels(x)
## S3 replacement method for class 'im'
levels(x) &lt;- value
levelsAsFactor(x)
listof(...)
logi.dummy(X, dummytype, nd, mark.repeat, ...)
markvaluetype(x)
packupNNdata(NND, NNW, what, k)
parbreak(terse)
perspVisible(x, y, z, M)
plan.legend.layout(B, ..., side, sep, size, sep.frac, size.frac,
                   started, map)
pointweights(X, ..., weights, parent, dfok)
polytileareaEngine(P, xrange, yrange, nx, ny, DivideByPixelArea)
putSpatstatVariable(name, value)
lookup.im(Z, x, y, naok, strict)
majorminorversion(v)
make.even.breaks(bmax, npos, bstep)
makeunitname(sing, plur, mul)
markappend(...)
markcbind(...)
markformat(x)
## S3 method for class 'ppp'
markformat(x) 
## S3 method for class 'ppx'
markformat(x) 
## S3 method for class 'psp'
markformat(x) 
## Default S3 method:
markformat(x) 
mark.scale.default(marx, w, ...,
                   markrange,
                   markscale, maxsize, meansize,
                   minsize, zerosize, characters)
markspace.integral(X)
## Default S3 method:
marks(x, ...)
## S3 method for class 'quad'
marks(x, dfok=FALSE, ...)
markappendop(x, y)
x %mapp% y
marksubset(x, index, format)
marksubsetop(x, i)
x %msub% i
markreplicateop(x, n)
x %mrep% n
mask2df(w)
maxflow(costm)
meanX.owin(w)            
meanY.owin(w)
MinimalTess(W, ...)
multiplicityNumeric(x)
multiply.only.finite.entries(x, a)
na.handle.im(X, na.replace)
## S3 method for class 'hyperframe'
names(x)
## S3 replacement method for class 'hyperframe'
names(x) &lt;- value
nearest.pixel(x, y, Z)
nearest.valid.pixel(x, y, Z, method, nsearch)
n.quad(Q)
numberwithunit(x, u)
numeric.columns(M, logical, others)
onecolumn(m)
owinInternalRect(xrange, yrange, ..., unitname,
                 check)
owinInternalMask(xrange, yrange, ..., mask, unitname, xy,
                 check)
owinInternalPoly(xrange, yrange, ..., poly, unitname,
                 check, calculate, strict, fix)
owinpolycheck(W, verbose=TRUE)
owinpoly2mask(w, rasta, check=TRUE)
owin2polypath(w)
param.quad(Q)
PDtoNN(d, what, k, ...)
pickoption(what="option", key, keymap, ...,
           exact=FALSE, list.on.err=TRUE, die=TRUE, multi=FALSE,
           allow.all=TRUE)
plotEachLayer(x, ..., main, plotargs, add, show.all, do.plot)
plot3Dpoints(xyz, eye, org,
             ...,
             type, xlim, ylim, zlim,
             add, box, main, cex, box.back, box.front)
plotPolygonBdry(x, ...)
plotWidthMap(bb.leg, zlim, phys.scale, leg.scale, leg.side, leg.args, grafpar)
## S3 method for class 'barplotdata'
plot(x, ...)
## S3 method for class 'indicfun'
plot(x, W, ..., main)
ppllengine(X, Y, action="project", check=FALSE)
pppdist.mat(X, Y, cutoff = 1, q = 1, matching = TRUE,
            precision = 9, approximation = 10)
pppdist.prohorov(X, Y, n, dfix, type, cutoff, matching,
            ccode, auction, precision, approximation) 
ppsubset(X, I, Iname, fatal)
prepareTitle(main)
## S3 method for class 'anylist'
print(x, ...)
## S3 method for class 'colourmap'
print(x, ...)
## S3 method for class 'distfun'
print(x, ...)
## S3 method for class 'ewcdf'
print(x, digits, ...)
## S3 method for class 'funxy'
print(x, ...)
## S3 method for class 'hyperframe'
print(x, ...)
## S3 method for class 'indicfun'
print(x, ...)
## S3 method for class 'layered'
print(x, ...)
## S3 method for class 'lut'
print(x, ...)
## S3 method for class 'metric'
print(x, ...)
## S3 method for class 'metricfun'
print(x, ...)
## S3 method for class 'nnfun'
print(x, ...)
## S3 method for class 'numberwithunit'
print(x, ...)
## S3 method for class 'onearrow'
print(x, ...)
## S3 method for class 'pppmatching'
print(x, ...)
## S3 method for class 'simplepanel'
print(x, ...)
## S3 method for class 'solist'
print(x, ...)
## S3 method for class 'splitppp'
print(x, ...)
## S3 method for class 'splitppx'
print(x, ...)
## S3 method for class 'summary.distfun'
print(x, ...)
## S3 method for class 'summary.funxy'
print(x, ...)
## S3 method for class 'summary.hyperframe'
print(x, ...)
## S3 method for class 'summary.listof'
print(x, ...)
## S3 method for class 'summary.logiquad'
print(x, ..., dp=3)
## S3 method for class 'summary.lut'
print(x, ...)
## S3 method for class 'summary.owin'
print(x, ...)
## S3 method for class 'summary.ppp'
print(x, ..., dp)
## S3 method for class 'summary.psp'
print(x, ...)
## S3 method for class 'summary.splitppp'
print(x, ...)
## S3 method for class 'summary.solist'
print(x, ...)
## S3 method for class 'summary.splitppx'
print(x, ...)
## S3 method for class 'summary.symbolmap'
print(x, ...)
## S3 method for class 'summary.unitname'
print(x, ...)
## S3 method for class 'symbolmap'
print(x, ...)
## S3 method for class 'textstring'
print(x, ...)
## S3 method for class 'texturemap'
print(x, ...)
## S3 method for class 'tess'
print(x, ..., brief=FALSE)
## S3 method for class 'timed'
print(x, ...)
## S3 method for class 'yardstick'
print(x, ...)
project3Dhom(xyz, eye, org, vert)
putlastshift(X, vec)
qtPrepareCoordinate(covname, W, origin)
quad(data, dummy, w, param)
## S3 method for class 'interpolatedCDF'
quantilefun(x, ..., type)
rasterfilter(X, f)
recognise.spatstat.type(x)
rectquadrat.breaks(xr, yr, nx = 5, ny = nx, xbreaks = NULL, ybreaks = NULL)
rectquadrat.countEngine(x, y, xbreaks, ybreaks, weights)
remove.identical.pairs(cl, imap, jmap)
repair.image.xycoords(x)
resolve.stringsAsFactors(stringsAsFactors)
rgbNA(red, green, blue, alpha, maxColorValue)
ruletextline(ch, n, terse)
quadscheme.replicated(data, dummy, method, ...)
quadscheme.spatial(data, dummy, method, ...)
pointgrid(W, ngrid)
rastersample(X, Y)
rasterx.mask(w, drop)
rastery.mask(w, drop)
rasterxy.mask(w, drop)
rasterx.im(x)
rastery.im(x)
rasterxy.im(x, drop)
rebound(x, rect)
## S3 method for class 'im'
rebound(x, rect)  
## S3 method for class 'ppp'
rebound(x, rect) 
## S3 method for class 'psp'
rebound(x, rect) 
## S3 method for class 'owin'
rebound(x, rect)
repair.old.factor.image(x)
restrict.mask(M, W)
reversePolyclipArgs(x, p)
rotxy(X, angle = pi/2)
rotxypolygon(p, angle = pi/2)
## S3 method for class 'hyperframe'
row.names(x)
## S3 replacement method for class 'hyperframe'
row.names(x) &lt;- value
safedeldir(X)
safeDevCapabilities()
safelookup(Z, x, factor, warn)
## S3 method for class 'breakpts'
scalardilate(X, f, ...)
## S3 method for class 'diagramobj'
scalardilate(X, f, ...)
## S3 method for class 'diagramobj'
shift(X, ...)
## S3 method for class 'quadratcount'
shift(X, ...)
shiftxy(X, vec = c(0, 0))
shiftxypolygon(p, vec = c(0, 0))
simulationresult(resultlist, nsim, drop, NameBase)
smudge(X)
## S3 method for class 'im'
sort(x, ...)
spatstatDiagnostic(msg)
spatstat.deldir.setopt(use.trigrafS, use.trigraf, debug.delaunay)
spatstat.xy.coords(x, y)
store.versionstring.spatstat()
## S3 method for class 'hyperframe'
str(object, ...)
## S3 method for class 'hyperframe'
summary(object, ..., brief=FALSE)
## S3 method for class 'logiquad'
summary(object, ..., checkdup=FALSE)
## S3 method for class 'lut'
summary(object, ...)
## S3 method for class 'metric'
summary(object, ...)
## S3 method for class 'pppmatching'
summary(object, ...)
## S3 method for class 'ppx'
summary(object, ...)
## S3 method for class 'splitppx'
summary(object, ...)
## S3 method for class 'symbolmap'
summary(object, ...)
superimposeMarks(arglist, nobj)
symbolmapdomain(x)
symbolmapparnames(x)
symbolmaptype(x)
symbol.sizes.default(markvalues, ...)
## S3 method for class 'hyperframe'
tail(x,n,...)
thickSegments(x, widths, ...,
             add, main, do.plot, show.all, show.window,
             scale, adjust, negative.args,
             legend, leg.side, leg.sep, leg.wid, leg.args, leg.scale,
             zlim, box)
tilecentroids(W, nx, ny)
trianglediameters(iedge, jedge, edgelength, ...,
                  nvert, dmax, check)
trim.mask(M, R, tolerant)
tweak.closepairs(cl, rmax, i, deltax, deltay, deltaz)
x %unit% u
## Default S3 method:
unitname(x) 
## Default S3 replacement method:
unitname(x) &lt;- value 
unstackFilter(x)
## S3 method for class 'im'
update(object, ...) 
validradius(r, caller)
validate.mask(w, fatal=TRUE)        
validate.quad(Q, fatal, repair, announce)
versioncurrency.spatstat(today, checkR)
versionstring.spatstat()
veryunique(z)
verifyclass(X, C, N = deparse(substitute(X)), fatal = TRUE)
warn.once(key, ...)
warn.no.metric.support(caller, ..., metric)
warn.unsupported.args(unsup, ...)
waxlyrical(type, terse)
wrangle2image(values, template)
w.quad(Q)               
x.quad(Q)
y.quad(Q)
xy.grid(xr, yr, nx, ny, dx, dy)
## S3 method for class 'im'
xtfrm(x)
xypolyselfint(p, eps, proper, yesorno, checkinternal)
XDtoNN(d, what, iX, iY, k, ...)
xypolygon2psp(p, w, check)
ZeroValue(x)
## S3 method for class 'im'
ZeroValue(x)





</code></pre>


<h3>Details</h3>

<p>These internal <span class="pkg">spatstat.geom</span> functions should not be called
directly by the user. Their names and capabilities may change
without warning from one version of <span class="pkg">spatstat.geom</span> to the next.
</p>


<h3>Value</h3>

<p>The return values of these functions are not documented,
and may change without warning.
</p>

<hr>
<h2 id='spatstat.geom-package'>The spatstat.geom Package</h2><span id='topic+spatstat.geom-package'></span><span id='topic+spatstat.geom'></span>

<h3>Description</h3>

<p>The <span class="pkg">spatstat.geom</span> package
belongs to the <span class="pkg">spatstat</span> family of packages.
It defines classes of geometrical objects such as windows
and point patterns, and provides functionality for geometrical
operations on them.
</p>


<h3>Details</h3>

<p><span class="pkg">spatstat</span> is
a family of <span class="rlang"><b>R</b></span> packages
for the statistical analysis of spatial data.
Its main focus is the analysis of
spatial patterns of points in two-dimensional space.
</p>
<p>The original <span class="pkg">spatstat</span> package
has now been split into several
sub-packages.
</p>
<p>This sub-package <span class="pkg">spatstat.geom</span> defines the main classes
of geometrical objects (such as windows, point patterns, 
line segment patterns, pixel images) and supports geometrical
operations (such as shifting and rotating, measuring areas and
distances, finding nearest neighbours in a point pattern).
</p>
<p>Functions for performing statistical analysis and modelling
are in the separate sub-packages <span class="pkg">spatstat.explore</span> and <span class="pkg">spatstat.model</span>.
</p>
<p>Functions for linear networks
are in the separate sub-package <span class="pkg">spatstat.linnet</span>.
</p>
<p>For an overview of all the functions available in the <span class="pkg">spatstat</span> family,
see the help file for <span class="pkg">spatstat</span> in the <span class="pkg">spatstat</span> package.
</p>


<h3>Structure of the spatstat family</h3>

  
<p>The original <span class="pkg">spatstat</span> package grew to be very large,
and CRAN requested that the package be divided 
into several <b>sub-packages</b>.
Currently the sub-packages are:
</p>

<ul>
<li> <p><span class="pkg">spatstat.utils</span> containing basic utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.data</span> containing datasets
</p>
</li>
<li> <p><span class="pkg">spatstat.sparse</span> containing linear algebra utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.geom</span> containing geometrical objects
and geometrical operations
</p>
</li>
<li> <p><span class="pkg">spatstat.random</span> containing code for generating
random spatial patterns
</p>
</li>
<li> <p><span class="pkg">spatstat.explore</span> containing the main functionality
for exploratory and non-parametric analysis of spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.model</span> containing the main functionality
for statistical modelling and inference for spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.linnet</span> containing functions for
spatial data on a linear network
</p>
</li>
<li> <p><span class="pkg">spatstat</span>, which simply loads the other sub-packages
listed above, and provides documentation.
</p>
</li></ul>

<p>When you install <span class="pkg">spatstat</span>, these sub-packages are also
installed. Then if you load the <span class="pkg">spatstat</span> package by typing
<code>library(spatstat)</code>, the other sub-packages listed above will
automatically be loaded or imported.
For an overview of all the functions available in these sub-packages,
see the help file for <span class="pkg">spatstat</span> in the <span class="pkg">spatstat</span> package,
</p>
<p>Additionally there are several <b>extension packages:</b>
</p>

<ul>
<li> <p><span class="pkg">spatstat.gui</span> for interactive graphics
</p>
</li>
<li> <p><span class="pkg">spatstat.local</span> for local likelihood
(including geographically weighted regression)
</p>
</li>
<li> <p><span class="pkg">spatstat.Knet</span> for additional, computationally efficient code
for linear networks
</p>
</li>
<li> <p><span class="pkg">spatstat.sphere</span> (under development) for spatial data
on a sphere, including spatial data on the earth's surface
</p>
</li></ul>

<p>The extension packages must be installed separately
and loaded explicitly if needed. They also have separate documentation.
</p>


<h3>OVERVIEW OF CAPABILITIES</h3>

<p>Following is an overview of the capabilities of
the <span class="pkg">spatstat.geom</span> sub-package.
</p>
<p><b>Types of spatial data:</b>
</p>
<p>The main types of spatial data supported by <span class="pkg">spatstat.geom</span> are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ppp">ppp</a></code> </td><td style="text-align: left;"> point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+owin">owin</a></code> </td><td style="text-align: left;"> window (spatial region) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+im">im</a></code> </td><td style="text-align: left;"> pixel image </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+psp">psp</a></code> </td><td style="text-align: left;"> line segment pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+tess">tess</a></code> </td><td style="text-align: left;"> tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pp3">pp3</a></code> </td><td style="text-align: left;"> three-dimensional point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ppx">ppx</a></code> </td><td style="text-align: left;"> point pattern in any number of dimensions </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Additional data types are supported in <span class="pkg">spatstat.linnet</span>.
</p>
<p><b>To create a point pattern:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ppp">ppp</a></code> </td><td style="text-align: left;">
    create a point pattern from <code class="reqn">(x,y)</code> and window information
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">
    <code>ppp(x, y, xlim, ylim)</code> for rectangular window</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">
    <code>ppp(x, y, poly)</code> for polygonal window </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">
    <code>ppp(x, y, mask)</code> for binary image window </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.ppp">as.ppp</a></code> </td><td style="text-align: left;">
    convert other types of data to a <code>ppp</code> object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+clickppp">clickppp</a></code> </td><td style="text-align: left;">
    interactively add points to a plot </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+marks+3C-">marks&lt;-</a></code>, <code>%mark%</code>  </td><td style="text-align: left;">
    attach/reassign marks to a point pattern
  </td>
</tr>

</table>

<p><b>To simulate a random point pattern:</b>
</p>
<p>Most of the methods for generating random data are
provided in <span class="pkg">spatstat.random</span>. The following basic methods
are supplied in <span class="pkg">spatstat.geom</span>:
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+runifrect">runifrect</a></code> </td><td style="text-align: left;">
	generate <code class="reqn">n</code> independent uniform random points in a	rectangle </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rsyst">rsyst</a></code> </td><td style="text-align: left;">
	systematic random sample of points </td>
</tr>
<tr>
 <td style="text-align: left;">
        <code><a href="#topic+rjitter">rjitter</a></code> </td><td style="text-align: left;">
	apply random displacements to points in a pattern</td>
</tr>
<tr>
 <td style="text-align: left;">
      </td>
</tr>

</table>

<p><b>Standard point pattern datasets:</b>
</p>
<p>Datasets installed in the <span class="pkg">spatstat</span> family are provided
in the sub-package <code>spatstat.data</code>. 
</p>
<p><b>To manipulate a point pattern:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+plot.ppp">plot.ppp</a></code> </td><td style="text-align: left;">
	plot a point pattern (e.g. <code>plot(X)</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>spatstat.gui::iplot</code> </td><td style="text-align: left;">
	plot a point pattern interactively </td>
</tr>
<tr>
 <td style="text-align: left;"> 
	<code><a href="#topic+edit.ppp">edit.ppp</a></code> </td><td style="text-align: left;"> interactive text editor </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic++5B.ppp">[.ppp</a></code> </td><td style="text-align: left;"> 
	extract or replace a subset of a point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
        </td><td style="text-align: left;"> <code>pp[subset]</code> or <code>pp[subwindow]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+subset.ppp">subset.ppp</a></code> </td><td style="text-align: left;">
	extract subset of point pattern satisfying a condition </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+superimpose">superimpose</a></code> </td><td style="text-align: left;">
	combine several point patterns  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+by.ppp">by.ppp</a></code> </td><td style="text-align: left;">
	apply a function to sub-patterns of a point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+cut.ppp">cut.ppp</a></code> </td><td style="text-align: left;">
	classify the points in a point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+split.ppp">split.ppp</a></code> </td><td style="text-align: left;">
	divide pattern into sub-patterns </td>
</tr>
<tr>
 <td style="text-align: left;"> 
	<code><a href="#topic+unmark">unmark</a></code> </td><td style="text-align: left;">
	remove marks  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+npoints">npoints</a></code> </td><td style="text-align: left;">
	count the number of points  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+coords">coords</a></code> </td><td style="text-align: left;">
	extract coordinates, change coordinates  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+marks">marks</a></code> </td><td style="text-align: left;">
	extract marks, change marks or attach marks  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rotate">rotate</a></code> </td><td style="text-align: left;">
	rotate pattern  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+shift">shift</a> </code> </td><td style="text-align: left;">
	translate pattern  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+flipxy">flipxy</a> </code> </td><td style="text-align: left;">
	swap <code class="reqn">x</code> and <code class="reqn">y</code> coordinates  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+reflect">reflect</a> </code> </td><td style="text-align: left;">
	reflect in the origin  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+periodify">periodify</a> </code> </td><td style="text-align: left;">
	make several translated copies  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+affine">affine</a></code> </td><td style="text-align: left;">
	apply affine transformation</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+scalardilate">scalardilate</a></code> </td><td style="text-align: left;">
	apply scalar dilation</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+nnmark">nnmark</a></code> </td><td style="text-align: left;">
	mark value of nearest data point</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+identify.ppp">identify.ppp</a></code> </td><td style="text-align: left;">
	interactively identify points </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+unique.ppp">unique.ppp</a></code> </td><td style="text-align: left;">
	remove duplicate points </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+duplicated.ppp">duplicated.ppp</a></code> </td><td style="text-align: left;">
	determine which points are duplicates </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+uniquemap.ppp">uniquemap.ppp</a></code> </td><td style="text-align: left;">
	map duplicated points to unique points </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+connected.ppp">connected.ppp</a></code> </td><td style="text-align: left;"> find clumps of points </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+dirichlet">dirichlet</a></code> </td><td style="text-align: left;">
	compute Dirichlet-Voronoi tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+delaunay">delaunay</a></code> </td><td style="text-align: left;">
	compute Delaunay triangulation </td>
</tr>
<tr>
 <td style="text-align: left;"> 
	<code><a href="#topic+delaunayDistance">delaunayDistance</a></code> </td><td style="text-align: left;">
	graph distance in Delaunay triangulation </td>
</tr>
<tr>
 <td style="text-align: left;"> 
	<code><a href="#topic+convexhull">convexhull</a></code> </td><td style="text-align: left;"> compute convex hull </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+discretise">discretise</a></code> </td><td style="text-align: left;"> discretise coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+pixellate.ppp">pixellate.ppp</a></code> </td><td style="text-align: left;"> approximate point pattern by 
	pixel image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+as.im.ppp">as.im.ppp</a></code> </td><td style="text-align: left;"> approximate point pattern by 
	pixel image 
      </td>
</tr>

</table>

<p>See <code><a href="#topic+spatstat.options">spatstat.options</a></code> to control plotting behaviour.
</p>
<p><b>To create a window:</b>
</p>
<p>An object of class <code>"owin"</code> describes a spatial region
(a window of observation).
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+owin">owin</a></code>	</td><td style="text-align: left;">	Create a window object </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td><td style="text-align: left;"> <code>owin(xlim, ylim)</code> for rectangular window </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td><td style="text-align: left;"> <code>owin(poly)</code> for polygonal window </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td><td style="text-align: left;"> <code>owin(mask)</code> for binary image window </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+Window">Window</a></code>	</td><td style="text-align: left;">
	Extract window of another object </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+Frame">Frame</a></code>	</td><td style="text-align: left;">
	Extract the containing rectangle ('frame') of another object </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+as.owin">as.owin</a></code>	</td><td style="text-align: left;">
	Convert other data to a window object </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+square">square</a></code>    </td><td style="text-align: left;">	make a square window </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+disc">disc</a></code>    </td><td style="text-align: left;">	make a circular window </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+ellipse">ellipse</a></code>    </td><td style="text-align: left;">	make an elliptical window </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+ripras">ripras</a></code>    </td><td style="text-align: left;">
	Ripley-Rasson estimator of window, given only the points </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+convexhull">convexhull</a></code> </td><td style="text-align: left;"> compute convex hull of something </td>
</tr>
<tr>
 <td style="text-align: left;"> 
	<code><a href="spatstat.data.html#topic+letterR">letterR</a></code>    </td><td style="text-align: left;">
	polygonal window in the shape of the <span class="rlang"><b>R</b></span> logo </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+clickpoly">clickpoly</a></code>    </td><td style="text-align: left;">
	interactively draw a polygonal window  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+clickbox">clickbox</a></code>    </td><td style="text-align: left;">
	interactively draw a rectangle  
      </td>
</tr>

</table>

<p><b>To manipulate a window:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+plot.owin">plot.owin</a></code>	</td><td style="text-align: left;">	plot a window. </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td><td style="text-align: left;">		<code>plot(W)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+boundingbox">boundingbox</a></code> </td><td style="text-align: left;">
	Find a tight bounding box for the window </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+erosion">erosion</a></code>	</td><td style="text-align: left;">
	erode window by a distance r</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+dilation">dilation</a></code>	</td><td style="text-align: left;">
	dilate window by a distance r</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+closing">closing</a></code>	</td><td style="text-align: left;">
	close window by a distance r</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+opening">opening</a></code>	</td><td style="text-align: left;">
	open window by a distance r</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+border">border</a></code>	</td><td style="text-align: left;">
	difference between window and its erosion/dilation </td>
</tr>
<tr>
 <td style="text-align: left;"> 
	<code><a href="#topic+complement.owin">complement.owin</a></code>	</td><td style="text-align: left;">
	invert (swap inside and outside)</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+simplify.owin">simplify.owin</a></code>	</td><td style="text-align: left;">
	approximate a window by a simple polygon  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rotate">rotate</a></code> </td><td style="text-align: left;"> rotate window  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+flipxy">flipxy</a></code> </td><td style="text-align: left;"> swap <code class="reqn">x</code> and <code class="reqn">y</code> coordinates  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+shift">shift</a> </code> </td><td style="text-align: left;"> translate window  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+periodify">periodify</a> </code> </td><td style="text-align: left;"> make several translated copies  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+affine">affine</a></code> </td><td style="text-align: left;"> apply affine transformation </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+as.data.frame.owin">as.data.frame.owin</a></code> </td><td style="text-align: left;">
	convert window to data frame 
      </td>
</tr>

</table>

<p><b>Digital approximations:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+as.mask">as.mask</a></code>	</td><td style="text-align: left;">
	Make a discrete pixel approximation of a given window </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+as.im.owin">as.im.owin</a></code> </td><td style="text-align: left;"> convert window to pixel image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+pixellate.owin">pixellate.owin</a></code> </td><td style="text-align: left;"> convert window to pixel image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+commonGrid">commonGrid</a></code> </td><td style="text-align: left;"> find common pixel grid for windows </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+nearest.raster.point">nearest.raster.point</a></code> </td><td style="text-align: left;">
	map continuous coordinates to raster locations</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+raster.x">raster.x</a></code> </td><td style="text-align: left;">
	raster x coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+raster.y">raster.y</a></code> </td><td style="text-align: left;">
	raster y coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+raster.xy">raster.xy</a></code> </td><td style="text-align: left;">
	raster x and y coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+as.polygonal">as.polygonal</a></code> </td><td style="text-align: left;">
	convert pixel mask to polygonal window 
      </td>
</tr>

</table>

<p>See <code><a href="#topic+spatstat.options">spatstat.options</a></code> to control the approximation
</p>
<p><b>Geometrical computations with windows:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+edges">edges</a></code>	</td><td style="text-align: left;">	extract boundary edges </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+intersect.owin">intersect.owin</a></code>	</td><td style="text-align: left;">	intersection of two windows</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+union.owin">union.owin</a></code>	</td><td style="text-align: left;">	union of two windows</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+setminus.owin">setminus.owin</a></code>	</td><td style="text-align: left;">	set subtraction of two windows</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+inside.owin">inside.owin</a></code>	</td><td style="text-align: left;">	determine whether a point is inside a window</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+area.owin">area.owin</a></code>	</td><td style="text-align: left;">	compute area </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+perimeter">perimeter</a></code>	</td><td style="text-align: left;">	compute perimeter length </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+diameter.owin">diameter.owin</a></code>	</td><td style="text-align: left;">	compute diameter</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+incircle">incircle</a></code>	</td><td style="text-align: left;">	find largest circle inside a window </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+inradius">inradius</a></code>	</td><td style="text-align: left;">	radius of incircle </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+connected.owin">connected.owin</a></code>    </td><td style="text-align: left;"> find connected components of window </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+eroded.areas">eroded.areas</a></code>	</td><td style="text-align: left;">	compute areas of eroded windows</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+dilated.areas">dilated.areas</a></code>	</td><td style="text-align: left;">	compute areas of dilated windows</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+bdist.points">bdist.points</a></code>	</td><td style="text-align: left;">	compute distances from data points to window boundary </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+bdist.pixels">bdist.pixels</a></code>	</td><td style="text-align: left;">	compute distances from all pixels to window boundary </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+bdist.tiles">bdist.tiles</a></code>	</td><td style="text-align: left;">
	boundary distance for each tile in tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+distmap.owin">distmap.owin</a></code>	</td><td style="text-align: left;">	distance transform image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+distfun.owin">distfun.owin</a></code>	</td><td style="text-align: left;">	distance transform </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+centroid.owin">centroid.owin</a></code>	</td><td style="text-align: left;"> compute centroid (centre of mass) of window</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+is.subset.owin">is.subset.owin</a></code>    </td><td style="text-align: left;"> determine whether one
	window contains another </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+is.convex">is.convex</a></code> </td><td style="text-align: left;"> determine whether a window is convex </td>
</tr>
<tr>
 <td style="text-align: left;"> 
	<code><a href="#topic+convexhull">convexhull</a></code> </td><td style="text-align: left;"> compute convex hull </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+triangulate.owin">triangulate.owin</a></code> </td><td style="text-align: left;"> decompose into triangles </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+as.mask">as.mask</a></code> </td><td style="text-align: left;"> pixel approximation of window </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+as.polygonal">as.polygonal</a></code> </td><td style="text-align: left;"> polygonal approximation of window </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+is.rectangle">is.rectangle</a></code> </td><td style="text-align: left;"> test whether window is a rectangle </td>
</tr>
<tr>
 <td style="text-align: left;"> 
	<code><a href="#topic+is.polygonal">is.polygonal</a></code> </td><td style="text-align: left;"> test whether window is polygonal </td>
</tr>
<tr>
 <td style="text-align: left;"> 
	<code><a href="#topic+is.mask">is.mask</a></code> </td><td style="text-align: left;"> test whether window is a mask </td>
</tr>
<tr>
 <td style="text-align: left;"> 
	<code><a href="#topic+setcov">setcov</a></code> </td><td style="text-align: left;"> spatial covariance function of window </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+pixelcentres">pixelcentres</a></code> </td><td style="text-align: left;"> extract centres of pixels in mask </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+clickdist">clickdist</a></code>    </td><td style="text-align: left;">
	measure distance between two points clicked by user
      </td>
</tr>

</table>

<p><b>Pixel images:</b>
An object of class <code>"im"</code> represents a pixel image. 
Such objects are returned by some of the functions in
<span class="pkg">spatstat</span> including <code><a href="spatstat.explore.html#topic+Kmeasure">Kmeasure</a></code>,
<code><a href="#topic+setcov">setcov</a></code> and <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>. 
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+im">im</a></code> </td><td style="text-align: left;"> create a pixel image</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+as.im">as.im</a></code> </td><td style="text-align: left;"> convert other data to a pixel image</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+pixellate">pixellate</a></code> </td><td style="text-align: left;"> convert other data to a pixel image</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+as.matrix.im">as.matrix.im</a></code> </td><td style="text-align: left;"> convert pixel image to matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+as.data.frame.im">as.data.frame.im</a></code> </td><td style="text-align: left;"> convert pixel image to data frame</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+as.function.im">as.function.im</a></code> </td><td style="text-align: left;"> convert pixel image to function</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+plot.im">plot.im</a></code>	</td><td style="text-align: left;">	plot a pixel image on screen as a digital image</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+contour.im">contour.im</a></code>	</td><td style="text-align: left;"> draw contours of a pixel image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+persp.im">persp.im</a></code>	</td><td style="text-align: left;"> draw perspective plot of a pixel image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rgbim">rgbim</a></code>	</td><td style="text-align: left;"> create colour-valued pixel image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+hsvim">hsvim</a></code>	</td><td style="text-align: left;"> create colour-valued pixel image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic++5B.im">[.im</a></code> 	</td><td style="text-align: left;"> extract a subset of a pixel image</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic++5B+3C-.im">[&lt;-.im</a></code> 	</td><td style="text-align: left;"> replace a subset of a pixel image</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rotate.im">rotate.im</a></code> </td><td style="text-align: left;"> rotate pixel image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+shift.im">shift.im</a></code> </td><td style="text-align: left;"> apply vector shift to pixel image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+affine.im">affine.im</a></code> </td><td style="text-align: left;"> apply affine transformation to image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>X</code>	</td><td style="text-align: left;">	print very basic information about image <code>X</code></td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="base.html#topic+summary">summary</a>(X)</code> </td><td style="text-align: left;">	summary of image <code>X</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+hist.im">hist.im</a></code> </td><td style="text-align: left;">	histogram of image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+mean.im">mean.im</a></code> </td><td style="text-align: left;">	mean pixel value of image  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+integral.im">integral.im</a></code> </td><td style="text-align: left;">	integral of pixel values  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+quantile.im">quantile.im</a></code> </td><td style="text-align: left;">	quantiles of image  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+cut.im">cut.im</a></code> </td><td style="text-align: left;">	convert numeric image to factor image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+is.im">is.im</a></code> </td><td style="text-align: left;"> test whether an object is a pixel image</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+interp.im">interp.im</a></code> </td><td style="text-align: left;"> interpolate a pixel image</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+connected.im">connected.im</a></code> </td><td style="text-align: left;"> find connected components </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+compatible.im">compatible.im</a></code> </td><td style="text-align: left;"> test whether two images have
	compatible dimensions </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+harmonise.im">harmonise.im</a></code> </td><td style="text-align: left;"> make images compatible </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+commonGrid">commonGrid</a></code> </td><td style="text-align: left;"> find a common pixel grid for images </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+eval.im">eval.im</a></code> </td><td style="text-align: left;"> evaluate any expression involving images</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+im.apply">im.apply</a></code> </td><td style="text-align: left;"> evaluate a function of several images </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+scaletointerval">scaletointerval</a></code> </td><td style="text-align: left;"> rescale pixel values </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+zapsmall.im">zapsmall.im</a></code> </td><td style="text-align: left;"> set very small pixel values to zero </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+levelset">levelset</a></code> </td><td style="text-align: left;"> level set of an image</td>
</tr>
<tr>
 <td style="text-align: left;"> 
	<code><a href="#topic+solutionset">solutionset</a></code> </td><td style="text-align: left;"> region where an expression is true </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+imcov">imcov</a></code> </td><td style="text-align: left;"> spatial covariance function of image </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+convolve.im">convolve.im</a></code> </td><td style="text-align: left;"> spatial convolution of images </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+pixelcentres">pixelcentres</a></code> </td><td style="text-align: left;"> extract centres of pixels </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+transmat">transmat</a></code> </td><td style="text-align: left;"> convert matrix of pixel values </td>
</tr>
<tr>
 <td style="text-align: left;">
	                       </td><td style="text-align: left;"> to a different indexing convention
     </td>
</tr>

</table>

<p><b>Line segment patterns</b>
</p>
<p>An object of class <code>"psp"</code> represents a pattern of straight line
segments.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+psp">psp</a></code> </td><td style="text-align: left;"> create a line segment pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.psp">as.psp</a></code> </td><td style="text-align: left;"> convert other data into a line segment pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+edges">edges</a></code> </td><td style="text-align: left;"> extract edges of a window </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+is.psp">is.psp</a></code> </td><td style="text-align: left;"> determine whether a dataset has class <code>"psp"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+plot.psp">plot.psp</a></code> </td><td style="text-align: left;"> plot a line segment pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+print.psp">print.psp</a></code> </td><td style="text-align: left;"> print basic information </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+summary.psp">summary.psp</a></code> </td><td style="text-align: left;"> print summary information </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic++5B.psp">[.psp</a></code> </td><td style="text-align: left;"> extract a subset of a line segment pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+subset.psp">subset.psp</a></code> </td><td style="text-align: left;"> extract subset of line segment pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.data.frame.psp">as.data.frame.psp</a></code> </td><td style="text-align: left;">
      convert line segment pattern to data frame </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+marks.psp">marks.psp</a></code> </td><td style="text-align: left;"> extract marks of line segments </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+marks+3C-.psp">marks&lt;-.psp</a></code> </td><td style="text-align: left;"> assign new marks to line segments </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+unmark.psp">unmark.psp</a></code> </td><td style="text-align: left;"> delete marks from line segments </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+midpoints.psp">midpoints.psp</a></code> </td><td style="text-align: left;">
      compute the midpoints of line segments </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+endpoints.psp">endpoints.psp</a></code> </td><td style="text-align: left;"> extract the endpoints of line segments </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+lengths_psp">lengths_psp</a></code> </td><td style="text-align: left;"> compute the lengths of line segments </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+angles.psp">angles.psp</a></code> </td><td style="text-align: left;"> compute the orientation angles of line segments </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+superimpose">superimpose</a></code> </td><td style="text-align: left;"> combine several line segment patterns  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+flipxy">flipxy</a></code> </td><td style="text-align: left;"> swap <code class="reqn">x</code> and <code class="reqn">y</code> coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">      
      <code><a href="#topic+rotate.psp">rotate.psp</a></code> </td><td style="text-align: left;"> rotate a line segment pattern </td>
</tr>
<tr>
 <td style="text-align: left;">      
      <code><a href="#topic+shift.psp">shift.psp</a></code> </td><td style="text-align: left;"> shift a line segment pattern </td>
</tr>
<tr>
 <td style="text-align: left;">      
      <code><a href="#topic+periodify">periodify</a></code> </td><td style="text-align: left;"> make several shifted copies </td>
</tr>
<tr>
 <td style="text-align: left;">      
      <code><a href="#topic+affine.psp">affine.psp</a></code> </td><td style="text-align: left;"> apply an affine transformation </td>
</tr>
<tr>
 <td style="text-align: left;">      
      <code><a href="#topic+pixellate.psp">pixellate.psp</a></code> </td><td style="text-align: left;"> approximate line segment pattern
    by pixel image </td>
</tr>
<tr>
 <td style="text-align: left;">      
      <code><a href="#topic+as.mask.psp">as.mask.psp</a></code> </td><td style="text-align: left;"> approximate line segment pattern
    by binary mask </td>
</tr>
<tr>
 <td style="text-align: left;">      
      <code><a href="#topic+distmap.psp">distmap.psp</a></code> </td><td style="text-align: left;"> compute the distance map of a line
      segment pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+distfun.psp">distfun.psp</a></code> </td><td style="text-align: left;"> compute the distance map of a line
      segment pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+selfcrossing.psp">selfcrossing.psp</a></code> </td><td style="text-align: left;"> find crossing points between
      line segments </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+selfcut.psp">selfcut.psp</a></code> </td><td style="text-align: left;"> cut segments where they cross </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+crossing.psp">crossing.psp</a></code> </td><td style="text-align: left;"> find crossing points between
      two line segment patterns </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+extrapolate.psp">extrapolate.psp</a></code> </td><td style="text-align: left;"> extrapolate line segments to
      infinite lines </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+nncross">nncross</a></code> </td><td style="text-align: left;"> find distance to nearest line segment
      from a given point</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+nearestsegment">nearestsegment</a></code> </td><td style="text-align: left;"> find line segment closest to a
      given point </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+project2segment">project2segment</a></code> </td><td style="text-align: left;"> find location along a line segment
      closest to a given point </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+pointsOnLines">pointsOnLines</a></code> </td><td style="text-align: left;"> generate points evenly spaced
      along line segment </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rlinegrid">rlinegrid</a></code> </td><td style="text-align: left;"> generate a random array of parallel
      lines through a window
    </td>
</tr>

</table>

<p><b>Tessellations</b>
</p>
<p>An object of class <code>"tess"</code> represents a tessellation.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+tess">tess</a></code> </td><td style="text-align: left;"> create a tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+quadrats">quadrats</a></code> </td><td style="text-align: left;"> create a tessellation of rectangles</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+hextess">hextess</a></code> </td><td style="text-align: left;"> create a tessellation of hexagons </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+polartess">polartess</a></code> </td><td style="text-align: left;"> tessellation using polar coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+quantess">quantess</a></code> </td><td style="text-align: left;"> quantile tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+venn.tess">venn.tess</a></code> </td><td style="text-align: left;"> Venn diagram tessellation </td>
</tr>
<tr>
 <td style="text-align: left;"> 
      <code><a href="#topic+dirichlet">dirichlet</a></code> </td><td style="text-align: left;"> compute Dirichlet-Voronoi tessellation of points</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+delaunay">delaunay</a></code> </td><td style="text-align: left;"> compute Delaunay triangulation of points</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.tess">as.tess</a></code> </td><td style="text-align: left;"> convert other data to a tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+plot.tess">plot.tess</a></code> </td><td style="text-align: left;"> plot a tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+tiles">tiles</a></code> </td><td style="text-align: left;"> extract all the tiles of a tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic++5B.tess">[.tess</a></code> </td><td style="text-align: left;"> extract some tiles of a tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic++5B+3C-.tess">[&lt;-.tess</a></code> </td><td style="text-align: left;"> change some tiles of a tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+intersect.tess">intersect.tess</a></code> </td><td style="text-align: left;"> intersect two tessellations </td>
</tr>
<tr>
 <td style="text-align: left;">
                              </td><td style="text-align: left;"> or restrict a tessellation to a window </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+chop.tess">chop.tess</a></code> </td><td style="text-align: left;"> subdivide a tessellation by a line </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+tile.areas">tile.areas</a></code>	</td><td style="text-align: left;">
      area of each tile in tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+bdist.tiles">bdist.tiles</a></code>	</td><td style="text-align: left;">
      boundary distance for each tile in tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+connected.tess">connected.tess</a></code> </td><td style="text-align: left;"> find connected components of tiles </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+shift.tess">shift.tess</a></code> </td><td style="text-align: left;"> shift a tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rotate.tess">rotate.tess</a></code> </td><td style="text-align: left;"> rotate a tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+reflect.tess">reflect.tess</a></code> </td><td style="text-align: left;"> reflect about the origin </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+flipxy.tess">flipxy.tess</a></code> </td><td style="text-align: left;"> reflect about the diagonal </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+affine.tess">affine.tess</a></code> </td><td style="text-align: left;"> apply affine transformation 
    </td>
</tr>

</table>

<p><b>Three-dimensional point patterns</b>
</p>
<p>An object of class <code>"pp3"</code> represents a three-dimensional
point pattern in a rectangular box. The box is represented by
an object of class <code>"box3"</code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+pp3">pp3</a></code> </td><td style="text-align: left;"> create a 3-D point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+plot.pp3">plot.pp3</a></code> </td><td style="text-align: left;"> plot a 3-D point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+coords">coords</a></code> </td><td style="text-align: left;"> extract coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.hyperframe">as.hyperframe</a></code> </td><td style="text-align: left;"> extract coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+subset.pp3">subset.pp3</a></code> </td><td style="text-align: left;"> extract subset of 3-D point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+unitname.pp3">unitname.pp3</a></code> </td><td style="text-align: left;"> name of unit of length </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+npoints">npoints</a></code> </td><td style="text-align: left;"> count the number of points  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+box3">box3</a></code> </td><td style="text-align: left;"> create a 3-D rectangular box </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.box3">as.box3</a></code> </td><td style="text-align: left;"> convert data to 3-D rectangular box </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+unitname.box3">unitname.box3</a></code> </td><td style="text-align: left;"> name of unit of length </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+diameter.box3">diameter.box3</a></code> </td><td style="text-align: left;"> diameter of box </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+volume.box3">volume.box3</a></code> </td><td style="text-align: left;"> volume of box </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+shortside.box3">shortside.box3</a></code> </td><td style="text-align: left;"> shortest side of box </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+eroded.volumes">eroded.volumes</a></code> </td><td style="text-align: left;"> volumes of erosions of box 
    </td>
</tr>

</table>

<p><b>Multi-dimensional space-time point patterns</b>
</p>
<p>An object of class <code>"ppx"</code> represents a 
point pattern in multi-dimensional space and/or time.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+ppx">ppx</a></code> </td><td style="text-align: left;"> create a multidimensional space-time point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+coords">coords</a></code> </td><td style="text-align: left;"> extract coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.hyperframe">as.hyperframe</a></code> </td><td style="text-align: left;"> extract coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+subset.ppx">subset.ppx</a></code> </td><td style="text-align: left;"> extract subset </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+unitname.ppx">unitname.ppx</a></code> </td><td style="text-align: left;"> name of unit of length </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+npoints">npoints</a></code> </td><td style="text-align: left;"> count the number of points  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+boxx">boxx</a></code> </td><td style="text-align: left;"> define multidimensional box  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+diameter.boxx">diameter.boxx</a></code> </td><td style="text-align: left;"> diameter of box </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+volume.boxx">volume.boxx</a></code> </td><td style="text-align: left;"> volume of box </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+shortside.boxx">shortside.boxx</a></code> </td><td style="text-align: left;"> shortest side of box </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+eroded.volumes.boxx">eroded.volumes.boxx</a></code> </td><td style="text-align: left;"> volumes of erosions of box 
    </td>
</tr>

</table>

<p><b>Linear networks</b>
</p>
<p>An object of class <code>"linnet"</code> represents a linear network
(for example, a road network). This is supported in the
sub-package <span class="pkg">spatstat.linnet</span>.
</p>
<p>An object of class <code>"lpp"</code> represents a 
point pattern on a linear network (for example,
road accidents on a road network).
</p>
<p><b>Hyperframes</b>
</p>
<p>A hyperframe is like a data frame, except that the entries
may be objects of any kind.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+hyperframe">hyperframe</a></code> </td><td style="text-align: left;"> create a hyperframe </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.hyperframe">as.hyperframe</a></code> </td><td style="text-align: left;"> convert data to hyperframe </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+plot.hyperframe">plot.hyperframe</a></code> </td><td style="text-align: left;"> plot hyperframe </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+with.hyperframe">with.hyperframe</a></code> </td><td style="text-align: left;"> evaluate expression using each row
      of hyperframe </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+cbind.hyperframe">cbind.hyperframe</a></code> </td><td style="text-align: left;"> combine hyperframes by columns</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rbind.hyperframe">rbind.hyperframe</a></code> </td><td style="text-align: left;"> combine hyperframes by rows</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.data.frame.hyperframe">as.data.frame.hyperframe</a></code> </td><td style="text-align: left;"> convert hyperframe to
      data frame </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+subset.hyperframe">subset.hyperframe</a></code> </td><td style="text-align: left;"> method for <code>subset</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+head.hyperframe">head.hyperframe</a></code> </td><td style="text-align: left;"> first few rows of hyperframe </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+tail.hyperframe">tail.hyperframe</a></code> </td><td style="text-align: left;"> last few rows of hyperframe
    </td>
</tr>

</table>

<p><b>Layered objects</b>
</p>
<p>A layered object represents data that should be plotted in
successive layers, for example, a background and a foreground.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+layered">layered</a></code> </td><td style="text-align: left;"> create layered object </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+plot.layered">plot.layered</a></code> </td><td style="text-align: left;"> plot layered object</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic++5B.layered">[.layered</a></code> </td><td style="text-align: left;"> extract subset of layered object
    </td>
</tr>

</table>

<p><b>Colour maps</b>
</p>
<p>A colour map is a mechanism for associating colours with data.
It can be regarded as a function, mapping data to colours.
Using a <code>colourmap</code> object in a plot command
ensures that the mapping from numbers to colours is
the same in different plots. 
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+colourmap">colourmap</a></code> </td><td style="text-align: left;"> create a colour map  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+plot.colourmap">plot.colourmap</a></code> </td><td style="text-align: left;"> plot the colour map only</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+tweak.colourmap">tweak.colourmap</a></code> </td><td style="text-align: left;"> alter individual colour values </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+interp.colourmap">interp.colourmap</a></code> </td><td style="text-align: left;"> make a smooth transition
      between colours </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+beachcolourmap">beachcolourmap</a></code> </td><td style="text-align: left;"> one special colour map
    </td>
</tr>

</table>

<p><b>Inspection of data:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="base.html#topic+summary">summary</a>(X)</code> </td><td style="text-align: left;">
    print useful summary of point pattern <code>X</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>X</code> </td><td style="text-align: left;">
    print basic description of point pattern <code>X</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>any(duplicated(X))</code> </td><td style="text-align: left;">
    check for duplicated points in pattern <code>X</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+intensity">intensity</a></code> </td><td style="text-align: left;"> Mean intensity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+quadratcount">quadratcount</a></code> </td><td style="text-align: left;"> Quadrat counts </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p><b>Distances in a point pattern:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nndist">nndist</a></code> </td><td style="text-align: left;"> nearest neighbour distances </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nnwhich">nnwhich</a></code> </td><td style="text-align: left;"> find nearest neighbours </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pairdist">pairdist</a></code> </td><td style="text-align: left;"> distances between all pairs of points</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+crossdist">crossdist</a></code> </td><td style="text-align: left;"> distances between points in two patterns</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nncross">nncross</a></code> </td><td style="text-align: left;"> nearest neighbours between two point patterns </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+exactdt">exactdt</a></code> </td><td style="text-align: left;"> distance from any location to nearest data point</td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code><a href="#topic+distmap">distmap</a></code> </td><td style="text-align: left;"> distance map image</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+distfun">distfun</a></code> </td><td style="text-align: left;"> distance map function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nnmap">nnmap</a></code> </td><td style="text-align: left;"> nearest point image </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nnfun">nnfun</a></code> </td><td style="text-align: left;"> nearest point function 
 </td>
</tr>

</table>

<p><b>Programming tools:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+applynbd">applynbd</a></code> </td><td style="text-align: left;"> apply function to every neighbourhood
    in a point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+markstat">markstat</a></code> </td><td style="text-align: left;"> apply function to the marks of neighbours
    in a point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pppdist">pppdist</a></code> </td><td style="text-align: left;"> find the optimal match between two point
    patterns
  </td>
</tr>

</table>

<p><b>Distances in a three-dimensional point pattern:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pairdist.pp3">pairdist.pp3</a></code> </td><td style="text-align: left;"> distances between all pairs of
    points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+crossdist.pp3">crossdist.pp3</a></code> </td><td style="text-align: left;"> distances between points in
    two patterns </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nndist.pp3">nndist.pp3</a></code> </td><td style="text-align: left;"> nearest neighbour distances </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nnwhich.pp3">nnwhich.pp3</a></code> </td><td style="text-align: left;"> find nearest neighbours </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nncross.pp3">nncross.pp3</a></code> </td><td style="text-align: left;"> find nearest neighbours in another pattern
  </td>
</tr>

</table>

<p><b>Distances in multi-dimensional point pattern:</b>
</p>
<p>These are for multi-dimensional space-time
point pattern objects (class <code>ppx</code>).
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pairdist.ppx">pairdist.ppx</a></code> </td><td style="text-align: left;"> distances between all pairs of
    points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+crossdist.ppx">crossdist.ppx</a></code> </td><td style="text-align: left;"> distances between points in
    two patterns </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nndist.ppx">nndist.ppx</a></code> </td><td style="text-align: left;"> nearest neighbour distances </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nnwhich.ppx">nnwhich.ppx</a></code> </td><td style="text-align: left;"> find nearest neighbours
  </td>
</tr>

</table>



<h3>Licence</h3>

<p>This library and its documentation are usable under the terms of the &quot;GNU 
General Public License&quot;, a copy of which is distributed with the package.
</p>


<h3>Acknowledgements</h3>

<p>Kasper Klitgaard Berthelsen,
Ottmar Cronie,
Tilman Davies,
Yongtao Guan,
Ute Hahn,
Abdollah Jalilian,
Marie-Colette van Lieshout,
Greg McSwiggan,
Tuomas Rajala,
Suman Rakshit,
Dominic Schuhmacher,
Rasmus Waagepetersen
and
Hangsheng Wang
made substantial contributions of code.
</p>
<p>Additional contributions and suggestions from
Monsuru Adepeju,
Corey Anderson,
Ang Qi Wei,
Ryan Arellano,
Jens Astrom,
Robert Aue,
Marcel Austenfeld,
Sandro Azaele,
Malissa Baddeley,
Guy Bayegnak,
Colin Beale,
Melanie Bell,
Thomas Bendtsen,
Ricardo Bernhardt,
Andrew Bevan,
Brad Biggerstaff,
Anders Bilgrau,
Leanne Bischof,
Christophe Biscio,
Roger Bivand,
Jose M. Blanco Moreno,
Florent Bonneu,
Jordan Brown,
Ian Buller,
Julian Burgos,
Simon Byers,
Ya-Mei Chang,
Jianbao Chen,
Igor Chernayavsky,
Y.C. Chin,
Bjarke Christensen,
Lucia Cobo Sanchez,
Jean-Francois Coeurjolly,
Kim Colyvas,
Hadrien Commenges,
Rochelle Constantine,
Robin Corria Ainslie,
Richard Cotton,
Marcelino de la Cruz,
Peter Dalgaard,
Mario D'Antuono,
Sourav Das,
Peter Diggle,
Patrick Donnelly,
Ian Dryden,
Stephen Eglen,
Ahmed El-Gabbas,
Belarmain Fandohan,
Olivier Flores,
David Ford,
Peter Forbes,
Shane Frank,
Janet Franklin,
Funwi-Gabga Neba,
Oscar Garcia,
Agnes Gault,
Jonas Geldmann,
Marc Genton,
Shaaban Ghalandarayeshi,
Julian Gilbey,
Jason Goldstick,
Pavel Grabarnik,
C. Graf,
Ute Hahn,
Andrew Hardegen,
Martin Bogsted Hansen,
Martin Hazelton,
Juha Heikkinen,
Mandy Hering,
Markus Herrmann,
Maximilian Hesselbarth,
Paul Hewson,
Hamidreza Heydarian,
Kassel Hingee,
Kurt Hornik,
Philipp Hunziker,
Jack Hywood,
Ross Ihaka,
Cenk Icos,
Aruna Jammalamadaka,
Robert John-Chandran,
Devin Johnson,
Mahdieh Khanmohammadi,
Bob Klaver,
Lily Kozmian-Ledward,
Peter Kovesi,
Mike Kuhn,
Jeff Laake,
Robert Lamb,
Frederic Lavancier,
Tom Lawrence,
Tomas Lazauskas,
Jonathan Lee,
George Leser,
Angela Li,
Li Haitao,
George Limitsios,
Andrew Lister,
Nestor Luambua,
Ben Madin,
Martin Maechler,
Kiran Marchikanti,
Jeff Marcus,
Robert Mark,
Peter McCullagh,
Monia Mahling,
Jorge Mateu Mahiques,
Ulf Mehlig,
Frederico Mestre,
Sebastian Wastl Meyer,
Mi Xiangcheng,
Lore De Middeleer,
Robin Milne,
Enrique Miranda,
Jesper Moller,
Annie Mollie,
Ines Moncada,
Mehdi Moradi,
Virginia Morera Pujol,
Erika Mudrak,
Gopalan Nair,
Nader Najari,
Nicoletta Nava,
Linda Stougaard Nielsen,
Felipe Nunes,
Jens Randel Nyengaard,
Jens Oehlschlaegel,
Thierry Onkelinx,
Sean O'Riordan,
Evgeni Parilov,
Jeff Picka,
Nicolas Picard,
Tim Pollington,
Mike Porter,
Sergiy Protsiv,
Adrian Raftery,
Suman Rakshit,
Ben Ramage,
Pablo Ramon,
Xavier Raynaud,
Nicholas Read,
Matt Reiter,
Ian Renner,
Tom Richardson,
Brian Ripley,
Ted Rosenbaum,
Barry Rowlingson,
Jason Rudokas,
Tyler Rudolph,
John Rudge,
Christopher Ryan,
Farzaneh Safavimanesh,
Aila Sarkka,
Cody Schank,
Katja Schladitz,
Sebastian Schutte,
Bryan Scott,
Olivia Semboli,
Francois Semecurbe,
Vadim Shcherbakov,
Shen Guochun,
Shi Peijian,
Harold-Jeffrey Ship,
Tammy L Silva,
Ida-Maria Sintorn,
Yong Song, 
Malte Spiess,
Mark Stevenson,
Kaspar Stucki,
Jan Sulavik,
Michael Sumner,
P. Surovy,
Ben Taylor,
Thordis Linda Thorarinsdottir,
Leigh Torres,
Berwin Turlach,
Torben Tvedebrink,
Kevin Ummer,
Medha Uppala,
Andrew van Burgel,
Tobias Verbeke,
Mikko Vihtakari,
Alexendre Villers,
Fabrice Vinatier,
Maximilian Vogtland,
Sasha Voss,
Sven Wagner,
Hao Wang,
H. Wendrock,
Jan Wild,
Carl G. Witthoft,
Selene Wong,
Maxime Woringer,
Luke Yates,
Mike Zamboni
and
Achim Zeileis.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>

<hr>
<h2 id='spatstat.options'>Internal Options in Spatstat Package</h2><span id='topic+spatstat.options'></span><span id='topic+reset.spatstat.options'></span>

<h3>Description</h3>

<p>Allows the user to examine and reset the values
of global parameters which control actions in the
<span class="pkg">spatstat</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  spatstat.options(...)
  reset.spatstat.options()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatstat.options_+3A_...">...</code></td>
<td>

<p>Either empty,
or a succession of parameter names in quotes,
or a succession of <code>name=value</code> pairs.
See below for the parameter names.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>spatstat.options</code>
allows the user to examine and reset the values
of global parameters which control actions in the
<span class="pkg">spatstat</span> package.
It is analogous to the system function <code><a href="base.html#topic+options">options</a></code>.
</p>
<p>The function <code>reset.spatstat.options</code> resets all the
global parameters in <span class="pkg">spatstat</span> to their original,
default values.
</p>
<p>The global parameters of interest to the user are:
</p>

<dl>
<dt>checkpolygons</dt><dd>
<p>Logical flag indicating whether the functions
<code><a href="#topic+owin">owin</a></code> and <code><a href="#topic+as.owin">as.owin</a></code> should
apply very strict checks on the validity of polygon data. 
These strict checks are no longer necessary, and the default is
<code>checkpolygons=FALSE</code>.
See also <code>fixpolygons</code> below.
</p>
</dd>
<dt>checksegments</dt><dd>
<p>Logical flag indicating whether the functions
<code><a href="#topic+psp">psp</a></code> and <code><a href="#topic+as.psp">as.psp</a></code> should check
the validity of line segment data (in particular, checking that
the endpoints of the line segments are inside the specified
window). It is advisable to leave this flag set to <code>TRUE</code>. 
</p>
</dd>
<dt>dpp.maxmatrix</dt><dd>
<p>Integer specifying the maximum size of matrices
generated by <code><a href="spatstat.model.html#topic+dppeigen">dppeigen</a></code>. Defaults to <code>2^24</code>.
</p>
</dd>
<dt>eroded.intensity</dt><dd>
<p>Logical flag affecting the behaviour of the
score and pseudo-score residual functions
<code><a href="spatstat.model.html#topic+Gcom">Gcom</a></code>, <code><a href="spatstat.model.html#topic+Gres">Gres</a></code>
<code><a href="spatstat.model.html#topic+Kcom">Kcom</a></code>, <code><a href="spatstat.model.html#topic+Kres">Kres</a></code>, 
<code><a href="spatstat.model.html#topic+psstA">psstA</a></code>, 
<code><a href="spatstat.model.html#topic+psstG">psstG</a></code>, 
<code><a href="spatstat.model.html#topic+psst">psst</a></code>.
The flag indicates whether to compute intensity estimates
on an eroded window (<code>eroded.intensity=TRUE</code>)
or on the original data window
(<code>eroded.intensity=FALSE</code>, the default). 
</p>
</dd>
<dt>expand</dt><dd>
<p>The default expansion factor (area inflation factor)
for expansion of the simulation window in
<code><a href="spatstat.random.html#topic+rmh">rmh</a></code> (see <code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code>).
Initialised to <code>2</code>.
</p>
</dd>
<dt>expand.polynom</dt><dd>
<p>Logical. Whether expressions involving <code><a href="spatstat.model.html#topic+polynom">polynom</a></code>
in a model formula should be expanded, so that
<code>polynom(x,2)</code> is replaced by <code>x + I(x^2)</code> and so on.
Initialised to <code>TRUE</code>.
</p>
</dd>
<dt>fastpois</dt><dd>
<p>Logical. Whether to use a fast algorithm
(introduced in <span class="pkg">spatstat 1.42-3</span>) for
simulating the Poisson point process in <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>
when the argument <code>lambda</code> is a pixel image.
Initialised to <code>TRUE</code>.
Should be set to <code>FALSE</code> if needed to guarantee repeatability
of results computed using earlier versions of <span class="pkg">spatstat</span>.
</p>
</dd>
<dt>fastthin</dt><dd>
<p>Logical. Whether to use a fast C language algorithm
(introduced in <span class="pkg">spatstat 1.42-3</span>) for
random thinning in <code><a href="spatstat.random.html#topic+rthin">rthin</a></code> when the argument
<code>P</code> is a single number.
Initialised to <code>TRUE</code>.
Should be set to <code>FALSE</code> if needed to guarantee repeatability
of results computed using earlier versions of <span class="pkg">spatstat</span>.
</p>
</dd>
<dt>fastK.lgcp</dt><dd>
<p>Logical. Whether to use fast or slow algorithm to compute the
(theoretical) <code class="reqn">K</code>-function of a log-Gaussian Cox process
for use in <code><a href="spatstat.model.html#topic+lgcp.estK">lgcp.estK</a></code> or <code><a href="spatstat.model.html#topic+Kmodel">Kmodel</a></code>.
The slow algorithm uses accurate numerical integration; the
fast algorithm uses Simpson's Rule for numerical integration,
and is about two orders of magnitude faster.
Initialised to <code>FALSE</code>. 
</p>
</dd>
<dt>fixpolygons</dt><dd>
<p>Logical flag indicating whether the functions
<code><a href="#topic+owin">owin</a></code> and <code><a href="#topic+as.owin">as.owin</a></code> should
repair errors in polygon data. For example,
self-intersecting polygons and overlapping polygons will
be repaired. The default is <code>fixpolygons=TRUE</code>.
</p>
</dd>
<dt>fftw</dt><dd>
<p>Logical value indicating whether the two-dimensional
Fast Fourier Transform
should be computed using the package <span class="pkg">fftwtools</span>,
instead of the <code>fft</code> function in the <span class="pkg">stats</span> package.
This affects the speed of <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>,
<code><a href="spatstat.explore.html#topic+density.psp">density.psp</a></code>, <code><a href="spatstat.explore.html#topic+blur">blur</a></code>
<code><a href="#topic+setcov">setcov</a></code> and <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>.
</p>
</dd>
<dt>gpclib</dt><dd>
<p>Defunct. This parameter was used to permit or forbid the use of the
package <span class="pkg">gpclib</span>, because of its restricted software licence.
This package is no longer needed.
</p>
</dd>
<dt>huge.npoints</dt><dd>
<p>The maximum value of <code>n</code> for which <code>runif(n)</code> will
not generate an error (possible errors include failure to allocate
sufficient memory, and integer overflow of <code>n</code>).
An attempt to generate more than this number of random points
triggers a warning from <code><a href="spatstat.random.html#topic+runifpoint">runifpoint</a></code> and other
functions. Defaults to <code>1e6</code>.
</p>
</dd>
<dt>image.colfun</dt><dd>
<p>Function determining the default colour map for
<code><a href="#topic+plot.im">plot.im</a></code>. When called with one integer argument
<code>n</code>, this function should return a character vector of length
<code>n</code> specifying <code>n</code> different colours.
</p>
</dd>
<dt>Kcom.remove.zeroes</dt><dd>
<p>Logical value, determining whether the algorithm in
<code><a href="spatstat.model.html#topic+Kcom">Kcom</a></code> and <code><a href="spatstat.model.html#topic+Kres">Kres</a></code>
removes or retains the contributions to the function
from pairs of points that are identical. If these are
retained then the function has a jump at <code class="reqn">r=0</code>.
Initialised to <code>TRUE</code>.
</p>
</dd>
<dt>maxedgewt</dt><dd>
<p>Edge correction weights will be trimmed
so as not to exceed this value.
This applies to the weights computed by
<code><a href="spatstat.explore.html#topic+edge.Trans">edge.Trans</a></code> or <code><a href="spatstat.explore.html#topic+edge.Ripley">edge.Ripley</a></code>
and used in <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> and its relatives.
</p>
</dd>
<dt>maxmatrix</dt><dd>
<p>The maximum permitted size (rows times columns)
of matrices generated by <span class="pkg">spatstat</span>'s internal code.
Used by <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> and <code><a href="spatstat.model.html#topic+predict.ppm">predict.ppm</a></code>
(for example) to decide when to
split a large calculation into blocks.
Defaults to <code>2^24=16777216</code>. 
</p>
</dd>
<dt>monochrome</dt><dd>
<p>Logical flag indicating whether graphics should be
plotted in grey scale (<code>monochrome=TRUE</code>) or
in colour (<code>monochrome=FALSE</code>, the default).
</p>
</dd>
<dt>n.bandwidth</dt><dd>
<p>Integer. Number of trial values of smoothing bandwidth to use for
cross-validation in <code><a href="spatstat.explore.html#topic+bw.relrisk">bw.relrisk</a></code> and similar
functions.
</p>
</dd>
<dt>ndummy.min</dt><dd>
<p>The minimum number of dummy points in a quadrature scheme
created by <code><a href="#topic+default.dummy">default.dummy</a></code>.
Either an integer or a pair of integers
giving the minimum number of dummy points in the <code>x</code> and <code>y</code>
directions respectively. 
</p>
</dd>
<dt>ngrid.disc</dt><dd>
<p>Number of points in the square grid used to compute
a discrete approximation to the areas of discs
in <code><a href="#topic+areaLoss">areaLoss</a></code> and <code><a href="#topic+areaGain">areaGain</a></code>
when exact calculation is not available.
A single integer.
</p>
</dd>
<dt>npixel</dt><dd>
<p>Default number of pixels in a binary mask or pixel image.
Either an integer, or a pair of integers,
giving the number of pixels in the <code>x</code> and <code>y</code>
directions respectively.
</p>
</dd>
<dt>nvoxel</dt><dd>
<p>Default number of voxels in a 3D image,
typically for calculating the distance transform in <code><a href="spatstat.explore.html#topic+F3est">F3est</a></code>.
Initialised to 4 megavoxels: <code>nvoxel = 2^22 = 4194304</code>.
</p>
</dd>
<dt>par.binary</dt><dd>
<p>List of arguments to be passed to the function
<code><a href="graphics.html#topic+image">image</a></code>
when displaying a binary image mask (in <code><a href="#topic+plot.owin">plot.owin</a></code>
or <code><a href="#topic+plot.ppp">plot.ppp</a></code>).
Typically used to reset the colours of foreground and background.
</p>
</dd>
<dt>par.contour</dt><dd>
<p>List of arguments controlling contour plots of pixel images
by <code><a href="#topic+contour.im">contour.im</a></code>.
</p>
</dd>
<dt>par.fv</dt><dd>
<p>List of arguments controlling the plotting of functions 
by <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code> and its relatives.
</p>
</dd>
<dt>par.persp</dt><dd>
<p>List of arguments to be passed to the function
<code><a href="graphics.html#topic+persp">persp</a></code>
when displaying a real-valued image, such as the fitted surfaces
in <code><a href="spatstat.model.html#topic+plot.ppm">plot.ppm</a></code>.
</p>
</dd>
<dt>par.points</dt><dd>
<p>List of arguments controlling the plotting of point patterns
by <code><a href="#topic+plot.ppp">plot.ppp</a></code>.
</p>
</dd>
<dt>par.pp3</dt><dd>
<p>List of arguments controlling the plotting of three-dimensional
point patterns by <code><a href="#topic+plot.pp3">plot.pp3</a></code>.
</p>
</dd>
<dt>print.ppm.SE</dt><dd>
<p>Default rule used by <code><a href="spatstat.model.html#topic+print.ppm">print.ppm</a></code>
to decide whether to calculate and print standard errors
of the estimated coefficients of the model.
One of the strings <code>"always"</code>, <code>"never"</code> or
<code>"poisson"</code> (the latter indicating that standard errors
will be calculated only for Poisson models). The default is
<code>"poisson"</code> because the calculation for non-Poisson models
can take a long time.
</p>
</dd>
<dt>progress</dt><dd>
<p>Character string determining the style of progress reports
printed by <code><a href="#topic+progressreport">progressreport</a></code>. Either
<code>"tty"</code>, <code>"tk"</code> or <code>"txtbar"</code>.
For explanation of these options, see <code><a href="#topic+progressreport">progressreport</a></code>.
</p>
</dd>
<dt>project.fast</dt><dd>
<p>Logical. If <code>TRUE</code>, the algorithm of
<code><a href="spatstat.model.html#topic+project.ppm">project.ppm</a></code>
will be accelerated using a shorcut.
Initialised to <code>FALSE</code>.
</p>
</dd>
<dt>psstA.ngrid</dt><dd>
<p>Single integer, 
controlling the accuracy of the discrete approximation
of areas computed in the function <code><a href="spatstat.model.html#topic+psstA">psstA</a></code>.
The area of a disc is approximated by counting points on
an <code class="reqn">n \times n</code> grid.
Initialised to 32.
</p>
</dd>
<dt>psstA.nr</dt><dd>
<p>Single integer,
determining the number of distances <code class="reqn">r</code>
at which the function <code><a href="spatstat.model.html#topic+psstA">psstA</a></code> will be evaluated
(in the default case where argument <code>r</code> is absent).
Initialised to 30.
</p>
</dd>
<dt>psstG.remove.zeroes</dt><dd>
<p>Logical value, determining whether the algorithm in
<code><a href="spatstat.model.html#topic+psstG">psstG</a></code> 
removes or retains the contributions to the function
from pairs of points that are identical. If these are
retained then the function has a jump at <code class="reqn">r=0</code>.
Initialised to <code>TRUE</code>.
</p>
</dd>
<dt>rmh.p, rmh.q, rmh.nrep</dt><dd>
<p>New default values for the parameters <code>p</code>, <code>q</code>
and <code>nrep</code> in the Metropolis-Hastings simulation
algorithm. These override the defaults
in <code><a href="spatstat.random.html#topic+rmhcontrol.default">rmhcontrol.default</a></code>.
</p>
</dd>
<dt>scalable</dt><dd>
<p>Logical flag indicating whether the new code in <code><a href="spatstat.random.html#topic+rmh.default">rmh.default</a></code>
which makes the results scalable (invariant to change of units)
should be used.  In order to recover former behaviour (so that
previous results can be reproduced) set this option equal to
<code>FALSE</code>.  See the &ldquo;Warning&rdquo; section in the help for
<code><a href="spatstat.random.html#topic+rmh">rmh</a>()</code> for more detail.
</p>
</dd>
<dt>terse</dt><dd>
<p>Integer between 0 and 4.
The level of terseness (brevity) in printed output
from many functions in <span class="pkg">spatstat</span>.
Higher values mean shorter output.
A rough guide is the following:
</p>

<table>
<tr>
 <td style="text-align: left;">
	0 </td><td style="text-align: left;"> Full output</td>
</tr>
<tr>
 <td style="text-align: left;">
        1 </td><td style="text-align: left;"> Avoid wasteful output </td>
</tr>
<tr>
 <td style="text-align: left;">
        2 </td><td style="text-align: left;"> Remove space between paragraphs</td>
</tr>
<tr>
 <td style="text-align: left;">
        3 </td><td style="text-align: left;"> Suppress extras such as standard errors </td>
</tr>
<tr>
 <td style="text-align: left;">
        4 </td><td style="text-align: left;"> Compress text, suppress internal warnings
      </td>
</tr>

</table>

<p>The value of <code>terse</code> is initialised to 0.
</p>
</dd>
<dt>transparent</dt><dd>
<p>Logical value indicating whether default colour maps
are allowed to include semi-transparent colours, where possible.
Default is <code>TRUE</code>.
Currently this only affects <code><a href="#topic+plot.ppp">plot.ppp</a></code>. 
</p>
</dd>
<dt>units.paren</dt><dd>
<p>The kind of parenthesis which encloses the text that
explains a <code>unitname</code>. This text is seen in
the text output of functions like <code><a href="#topic+print.ppp">print.ppp</a></code> and
in the graphics generated by <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
The value should be one of the character strings <code>'('</code>, <code>'['</code>,
<code>'{'</code> or <code>''</code>. The default is <code>'('</code>.
</p>
</dd>
</dl>

<p>If no arguments are given, 
the current values of all parameters are returned,
in a list.
</p>
<p>If one parameter name is given, the current value of this
parameter is returned (<b>not</b> in a list, just the value).
</p>
<p>If several parameter names are given,
the current values of these parameters are returned, in a list.
</p>
<p>If <code>name=value</code> pairs are given, the named parameters
are reset to the given values, and the <b>previous</b> values of
these parameters are returned, in a list.
</p>


<h3>Value</h3>

<p>Either a list of parameters and their values,
or a single value. See Details.
</p>


<h3>Internal parameters</h3>

<p>The following parameters may also be specified to
<code>spatstat.options</code> but are intended for
software development or testing purposes.
</p>

<dl>
<dt>closepairs.newcode</dt><dd>
<p>Logical. Whether to use new version of the
code for <code><a href="#topic+closepairs">closepairs</a></code>.
Initialised to <code>TRUE</code>.
</p>
</dd>
<dt>crossing.psp.useCall</dt><dd>
<p>Logical. Whether to use new version of the
code for <code><a href="#topic+crossing.psp">crossing.psp</a></code>.
Initialised to <code>TRUE</code>.
</p>
</dd>
<dt>crosspairs.newcode</dt><dd>
<p>Logical. Whether to use new version of the
code for <code><a href="#topic+crosspairs">crosspairs</a></code>.
Initialised to <code>TRUE</code>.
</p>
</dd>
<dt>densityC</dt><dd>
<p>Logical. 
Indicates whether to use accelerated C code
(<code>densityC=TRUE</code>) or interpreted R code (<code>densityC=FALSE</code>)
to evaluate <code>density.ppp(X, at="points")</code>.
Initialised to <code>TRUE</code>.
</p>
</dd>
<dt>exactdt.checks.data</dt><dd>
<p>Logical.
Do not change this value, unless you are
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>. 
</p>
</dd>
<dt>fasteval</dt><dd>
<p>One of the strings <code>'off'</code>, <code>'on'</code> or
<code>'test'</code> determining whether to use accelerated C code
to evaluate the conditional intensity of a Gibbs model.
Initialised to <code>'on'</code>.
</p>
</dd>
<dt>old.morpho.psp</dt><dd>
<p>Logical. Whether to use old R code for
morphological operations.
Initialise to <code>FALSE</code>.
</p>
</dd>
<dt>selfcrossing.psp.useCall</dt><dd>
<p>Logical. Whether to use new version of the
code for <code><a href="#topic+selfcrossing.psp">selfcrossing.psp</a></code>.
Initialised to <code>TRUE</code>.
</p>
</dd>
<dt>use.Krect</dt><dd>
<p>Logical. Whether to use specialised code for the
K-function in a rectangular window.
Initialised to <code>TRUE</code>.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # save current values whatever they are
  oldopt &lt;- spatstat.options()

  spatstat.options("npixel")
  spatstat.options(npixel=150)
  spatstat.options(npixel=c(100,200))

  spatstat.options(par.binary=list(col=grey(c(0.5,1))))

  spatstat.options(par.persp=list(theta=-30,phi=40,d=4))
  # see help(persp.default) for other options

  # revert to the state at the beginning of these examples
  spatstat.options(oldopt)

  # revert to 'factory defaults'
  reset.spatstat.options()
</code></pre>

<hr>
<h2 id='split.hyperframe'>
Divide Hyperframe Into Subsets and Reassemble
</h2><span id='topic+split.hyperframe'></span><span id='topic+split+3C-.hyperframe'></span>

<h3>Description</h3>

<p><code>split</code> divides the data <code>x</code> into subsets defined
by <code>f</code>. The replacement form replaces values corresponding to
such a division. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'hyperframe'
split(x, f, drop = FALSE, ...)

  ## S3 replacement method for class 'hyperframe'
split(x, f, drop = FALSE, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.hyperframe_+3A_x">x</code></td>
<td>

<p>Hyperframe (object of class <code>"hyperframe"</code>).
</p>
</td></tr>
<tr><td><code id="split.hyperframe_+3A_f">f</code></td>
<td>

<p>a <code>factor</code> in the sense that <code>as.factor(f)</code> defines the
grouping, or a list of such factors in which case their
interaction is used for the grouping.
</p>
</td></tr>
<tr><td><code id="split.hyperframe_+3A_drop">drop</code></td>
<td>

<p>logical value, indicating whether levels that do not occur should be
dropped from the result.
</p>
</td></tr>
<tr><td><code id="split.hyperframe_+3A_value">value</code></td>
<td>

<p>a list of hyperframes which arose (or could have arisen)
from the command <code>split(x,f,drop=drop)</code>.
</p>
</td></tr>
<tr><td><code id="split.hyperframe_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="base.html#topic+split">split</a></code> and <code><a href="base.html#topic+split+3C-">split&lt;-</a></code>
for hyperframes (objects of class <code>"hyperframe"</code>).
</p>
<p>A hyperframe is like a data frame, except that its entries
can be objects of any kind. The behaviour of these methods
is analogous to the corresponding methods for data frames.
</p>


<h3>Value</h3>

<p>The value returned from <code>split.hyperframe</code> is a list of
hyperframe containing
the values for the groups.  The components of the list are named
by the levels of <code>f</code> (after converting to a factor, or if already
a factor and <code>drop = TRUE</code>, dropping unused levels).
</p>
<p>The replacement method <code>split&lt;-.hyperframe</code> returns
a new hyperframe <code>x</code> for which <code>split(x,f)</code> equals <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyperframe">hyperframe</a></code>, <code><a href="#topic++5B.hyperframe">[.hyperframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   split(pyramidal, pyramidal$group)
</code></pre>

<hr>
<h2 id='split.im'>Divide Image Into Sub-images</h2><span id='topic+split.im'></span>

<h3>Description</h3>

<p>Divides a pixel image into several sub-images according to the
value of a factor, or according to the tiles of a tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im'
split(x, f, ..., drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.im_+3A_x">x</code></td>
<td>
<p>Pixel image (object of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="split.im_+3A_f">f</code></td>
<td>

<p>Splitting criterion. Either a tessellation (object of class
<code>"tess"</code>) or a pixel image with factor values.
</p>
</td></tr>
<tr><td><code id="split.im_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="split.im_+3A_drop">drop</code></td>
<td>
<p>Logical value determining whether each subset should
be returned as a pixel images (<code>drop=FALSE</code>) or 
as a one-dimensional vector of pixel values (<code>drop=TRUE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+split">split</a></code>
for the class of pixel images. The image <code>x</code> will be divided
into subsets determined by the data <code>f</code>. The result is a list
of these subsets.
</p>
<p>The splitting criterion may be either
</p>

<ul>
<li><p> a tessellation (object of class <code>"tess"</code>). Each tile of
the tessellation delineates a subset of the spatial domain.
</p>
</li>
<li><p> a pixel image (object of class <code>"im"</code>) with factor
values. The levels of the factor determine subsets of the spatial
domain.
</p>
</li></ul>

<p>If <code>drop=FALSE</code> (the default), the result is a list of pixel
images, each one a subset of the pixel image <code>x</code>,
obtained by restricting the pixel domain to one of the subsets.
If <code>drop=TRUE</code>, then the pixel values are returned as
numeric vectors. 
</p>


<h3>Value</h3>

<p>If <code>drop=FALSE</code>, a list of pixel images (objects of class
<code>"im"</code>). It is also of class <code>"solist"</code> so that it can be
plotted immediately.
</p>
<p>If <code>drop=TRUE</code>, a list of numeric vectors.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+by.im">by.im</a></code>,
<code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+im">im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  W &lt;- square(1)
  X &lt;- as.im(function(x,y){sqrt(x^2+y^2)}, W)
  Y &lt;- dirichlet(runifrect(12, W))
  plot(split(X,Y))
</code></pre>

<hr>
<h2 id='split.ppp'>Divide Point Pattern into Sub-patterns</h2><span id='topic+split.ppp'></span><span id='topic+split+3C-.ppp'></span>

<h3>Description</h3>

<p>Divides a point pattern into several sub-patterns,
according to their marks, or according to any user-specified grouping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppp'
split(x, f = marks(x), drop=FALSE, un=NULL, reduce=FALSE, ...)
  ## S3 replacement method for class 'ppp'
split(x, f = marks(x), drop=FALSE, un=NULL, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.ppp_+3A_x">x</code></td>
<td>

<p>A two-dimensional point pattern.
An object of class <code>"ppp"</code>.
</p>
</td></tr>
<tr><td><code id="split.ppp_+3A_f">f</code></td>
<td>

<p>Data determining the grouping. Either a factor,
a logical vector,
a pixel image with factor values, a tessellation, a window,
or the name of one of the columns of marks.
</p>
</td></tr>
<tr><td><code id="split.ppp_+3A_drop">drop</code></td>
<td>

<p>Logical. Determines whether empty groups will
be deleted.
</p>
</td></tr>
<tr><td><code id="split.ppp_+3A_un">un</code></td>
<td>

<p>Logical. Determines whether the resulting subpatterns will be unmarked
(i.e. whether marks will be removed	from the points in each
subpattern). 
</p>
</td></tr>
<tr><td><code id="split.ppp_+3A_reduce">reduce</code></td>
<td>

<p>Logical. Determines whether to delete the column of marks used to split the
pattern, when the marks are a data frame.
</p>
</td></tr>
<tr><td><code id="split.ppp_+3A_...">...</code></td>
<td>

<p>Other arguments are ignored.
</p>
</td></tr>
<tr><td><code id="split.ppp_+3A_value">value</code></td>
<td>

<p>List of point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>split.ppp</code>
divides up the points of the point pattern <code>x</code>
into several sub-patterns according to the values of <code>f</code>.
The result is a list of point patterns.
</p>
<p>The argument <code>f</code> may be
</p>

<ul>
<li>
<p>a factor, of length equal to the number of points in <code>x</code>.
The levels of <code>f</code>
determine the destination of each point in <code>x</code>.
The <code>i</code>th point of <code>x</code> will be placed in the sub-pattern
<code>split.ppp(x)$l</code> where <code>l = f[i]</code>.
</p>
</li>
<li>
<p>a pixel image (object of class <code>"im"</code>) with factor values.
The pixel value of <code>f</code>
at each point of <code>x</code> will be used as the classifying variable.
</p>
</li>
<li>
<p>a tessellation (object of class <code>"tess"</code>).
Each point of <code>x</code> will be classified according to
the tile of the tessellation into which it falls.
</p>
</li>
<li>
<p>a window (object of class <code>"owin"</code>).
Each point of <code>x</code> will be classified according to
whether it falls inside or outside this window.
</p>
</li>
<li>
<p>the character string <code>"marks"</code>, if <code>marks(x)</code> is a factor.
</p>
</li>
<li>
<p>a character string, matching the name of one of the columns of
marks, if <code>marks(x)</code> is a data frame. This column should
be a factor.
</p>
</li></ul>

<p>If <code>f</code> is missing, then it will be determined by the
marks of the point pattern. The pattern <code>x</code> can be either
</p>

<ul>
<li> 
<p>a multitype point pattern
(a marked point pattern whose marks vector is a factor).
Then <code>f</code> is taken to be the marks vector.
The effect is that the points of each type
are separated into different point patterns.
</p>
</li>
<li> 
<p>a marked point pattern with a data frame of marks, containing at least one
column that is a factor. The first such column will be used to
determine the splitting factor <code>f</code>.
</p>
</li></ul>

<p>Some of the sub-patterns created by the split
may be empty. If <code>drop=TRUE</code>, then empty sub-patterns will
be deleted from the list. If <code>drop=FALSE</code> then they are retained.
</p>
<p>The argument <code>un</code> determines how to handle marks 
in the case where <code>x</code> is a marked point pattern.
If <code>un=TRUE</code> then the marks of the 
points will be discarded when they are split into groups,
while if <code>un=FALSE</code> then the marks will be retained.
</p>
<p>If <code>f</code> and <code>un</code> are both missing,
then the default is <code>un=TRUE</code> for multitype point patterns
and <code>un=FALSE</code> for marked point patterns with a data frame of
marks.
</p>
<p>If the marks of <code>x</code> are a data frame, then 
<code>split(x, reduce=TRUE)</code> will discard only the column of marks
that was used to split the pattern. This applies only when
the argument <code>f</code> is missing.
</p>
<p>The result of <code>split.ppp</code> has class <code>"splitppp"</code>
and can be plotted using <code><a href="#topic+plot.splitppp">plot.splitppp</a></code>.
</p>
<p>The assignment function <code>split&lt;-.ppp</code> 
updates the point pattern <code>x</code> so that
it satisfies <code>split(x, f, drop, un) = value</code>. The argument <code>value</code>
is expected to be a list of point patterns, one for each level of
<code>f</code>. These point patterns are expected to be compatible with the
type of data in the original pattern <code>x</code>.
</p>
<p>Splitting can also be undone by the function
<code><a href="#topic+superimpose">superimpose</a></code>,
but this typically changes the ordering of the data.
</p>


<h3>Value</h3>

<p>The value of <code>split.ppp</code> is a list of point patterns.
The components of the list are named by the levels of <code>f</code>.
The list also has the class <code>"splitppp"</code>.
</p>
<p>The assignment form <code>split&lt;-.ppp</code> returns the updated
point pattern <code>x</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cut.ppp">cut.ppp</a></code>,
<code><a href="#topic+plot.splitppp">plot.splitppp</a></code>,
<code><a href="#topic+superimpose">superimpose</a></code>,
<code><a href="#topic+im">im</a></code>,
<code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+ppp.object">ppp.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) Splitting by marks

# Multitype point pattern: separate into types
 u &lt;- split(amacrine)

# plot them
 plot(split(amacrine))

# the following are equivalent:
 amon &lt;- split(amacrine)$on
 amon &lt;- unmark(amacrine[amacrine$marks == "on"])
 amon &lt;- subset(amacrine, marks == "on", -marks)
   
# the following are equivalent:
 amon &lt;- split(amacrine, un=FALSE)$on
 amon &lt;- amacrine[amacrine$marks == "on"]
   
# Scramble the locations of the 'on' cells
 X &lt;- amacrine
 u &lt;- split(X)
 u$on &lt;- runifrect(npoints(amon), Window(amon))
 split(X) &lt;- u

# Point pattern with continuous marks
 trees &lt;- longleaf
 
 # cut the range of tree diameters into three intervals
 # using cut.ppp
 long3 &lt;- cut(trees, breaks=3)
 # now split them
 long3split &lt;- split(long3)

# (2) Splitting by a factor

# Unmarked point pattern
  swedishpines
# cut &amp; split according to nearest neighbour distance
  f &lt;- cut(nndist(swedishpines), 3)
  u &lt;- split(swedishpines, f)

# (3) Splitting over a tessellation
   tes &lt;- tess(xgrid=seq(0,96,length=5),ygrid=seq(0,100,length=5))
   v &lt;- split(swedishpines, tes)


# (4) how to apply an operation to selected points:
#  split into components, transform desired component, then un-split
#  e.g. apply random jitter to 'on' points only
  X &lt;- amacrine
  Y &lt;- split(X)
  Y$on &lt;- rjitter(Y$on, 0.1)
  split(X) &lt;- Y
</code></pre>

<hr>
<h2 id='split.ppx'>Divide Multidimensional Point Pattern into Sub-patterns</h2><span id='topic+split.ppx'></span>

<h3>Description</h3>

<p>Divides a multidimensional point pattern into several sub-patterns,
according to their marks, or according to any user-specified grouping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppx'
split(x, f = marks(x), drop=FALSE, un=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.ppx_+3A_x">x</code></td>
<td>

<p>A multi-dimensional point pattern.
An object of class <code>"ppx"</code>.
</p>
</td></tr>
<tr><td><code id="split.ppx_+3A_f">f</code></td>
<td>

<p>Data determining the grouping. Either a factor, a logical vector,
or the name of one of the columns of marks.
</p>
</td></tr>
<tr><td><code id="split.ppx_+3A_drop">drop</code></td>
<td>

<p>Logical. Determines whether empty groups will
be deleted.
</p>
</td></tr>
<tr><td><code id="split.ppx_+3A_un">un</code></td>
<td>

<p>Logical. Determines whether the resulting subpatterns will be unmarked
(i.e. whether marks will be removed	from the points in each
subpattern). 
</p>
</td></tr>
<tr><td><code id="split.ppx_+3A_...">...</code></td>
<td>

<p>Other arguments are ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic command <code><a href="base.html#topic+split">split</a></code> allows a dataset to be separated
into subsets according to the value of a grouping variable.
</p>
<p>The function <code>split.ppx</code> is a method for the generic
<code><a href="base.html#topic+split">split</a></code> for the class <code>"ppx"</code> of multidimensional
point patterns. It divides up the points of the point pattern <code>x</code>
into several sub-patterns according to the values of <code>f</code>.
The result is a list of point patterns.
</p>
<p>The argument <code>f</code> may be
</p>

<ul>
<li>
<p>a factor, of length equal to the number of points in <code>x</code>.
The levels of <code>f</code>
determine the destination of each point in <code>x</code>.
The <code>i</code>th point of <code>x</code> will be placed in the sub-pattern
<code>split.ppx(x)$l</code> where <code>l = f[i]</code>.
</p>
</li>
<li>
<p>the character string <code>"marks"</code>, if <code>marks(x)</code> is a factor.
</p>
</li>
<li>
<p>a character string, matching the name of one of the columns of
marks, if <code>marks(x)</code> is a data frame or hyperframe. This column should
be a factor.
</p>
</li></ul>

<p>If <code>f</code> is missing, then it will be determined by the
marks of the point pattern. The pattern <code>x</code> can be either
</p>

<ul>
<li> 
<p>a multitype point pattern
(a marked point pattern whose marks vector is a factor).
Then <code>f</code> is taken to be the marks vector.
The effect is that the points of each type
are separated into different point patterns.
</p>
</li>
<li> 
<p>a marked point pattern with a data frame or hyperframe
of marks, containing at least one
column that is a factor. The first such column will be used to
determine the splitting factor <code>f</code>.
</p>
</li></ul>

<p>Some of the sub-patterns created by the split
may be empty. If <code>drop=TRUE</code>, then empty sub-patterns will
be deleted from the list. If <code>drop=FALSE</code> then they are retained.
</p>
<p>The argument <code>un</code> determines how to handle marks 
in the case where <code>x</code> is a marked point pattern.
If <code>un=TRUE</code> then the marks of the 
points will be discarded when they are split into groups,
while if <code>un=FALSE</code> then the marks will be retained.
</p>
<p>If <code>f</code> and <code>un</code> are both missing,
then the default is <code>un=TRUE</code> for multitype point patterns
and <code>un=FALSE</code> for marked point patterns with a data frame of
marks.
</p>
<p>The result of <code>split.ppx</code> has class <code>"splitppx"</code>
and <code>"anylist"</code>. There are methods for <code>print</code>,
<code>summary</code> and <code>plot</code>.
</p>


<h3>Value</h3>

<p>A list of point patterns.
The components of the list are named by the levels of <code>f</code>.
The list also has the class <code>"splitppx"</code> and <code>"anylist"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppx">ppx</a></code>,
<code><a href="#topic+plot.anylist">plot.anylist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   df &lt;- data.frame(x=runif(4),y=runif(4),t=runif(4),
                    age=factor(rep(c("old", "new"), 2)),
                    size=runif(4))
   X &lt;- ppx(data=df, coord.type=c("s","s","t","m","m"))
   X
   split(X)
</code></pre>

<hr>
<h2 id='spokes'>Spokes pattern of dummy points</h2><span id='topic+spokes'></span>

<h3>Description</h3>

<p>Generates a pattern of dummy points in a window,
given a data point pattern.
The dummy points lie on the radii of circles emanating from each
data point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> spokes(x, y, nrad = 3, nper = 3, fctr = 1.5, Mdefault = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spokes_+3A_x">x</code></td>
<td>

<p>Vector of <code class="reqn">x</code> coordinates of data points, or a list
with components <code>x</code> and <code>y</code>, or a point pattern
(an object of class <code>ppp</code>).
</p>
</td></tr>
<tr><td><code id="spokes_+3A_y">y</code></td>
<td>

<p>Vector of <code class="reqn">y</code> coordinates of data points.  Ignored
unless <code>x</code> is a vector.
</p>
</td></tr>
<tr><td><code id="spokes_+3A_nrad">nrad</code></td>
<td>

<p>Number of radii emanating from each data point.
</p>
</td></tr>
<tr><td><code id="spokes_+3A_nper">nper</code></td>
<td>

<p>Number of dummy points per radius.
</p>
</td></tr>
<tr><td><code id="spokes_+3A_fctr">fctr</code></td>
<td>

<p>Scale factor.
Length of largest spoke radius is <code>fctr * M</code>
where <code>M</code> is the mean nearest neighbour distance
for the data points.
</p>
</td></tr>
<tr><td><code id="spokes_+3A_mdefault">Mdefault</code></td>
<td>

<p>Value of <code>M</code> to be used if <code>x</code> has length 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful in creating dummy points for quadrature
schemes (see <code><a href="#topic+quadscheme">quadscheme</a></code>).
</p>
<p>Given the data points, the function creates a collection of
<code>nrad * nper * length(x)</code> dummy points.
</p>
<p>Around each data point <code>(x[i],y[i])</code> there are
<code>nrad * nper</code> dummy points, lying on <code>nrad</code> radii
emanating from <code>(x[i],y[i])</code>, with <code>nper</code> dummy points
equally spaced along each radius.
</p>
<p>The (equal) spacing of dummy points along each radius is
controlled by the factor <code>fctr</code>. 
The distance from a data point to the furthest of its associated
dummy points is <code>fctr * M</code>
where <code>M</code> is the mean nearest neighbour distance
for the data points.
</p>
<p>If there is only one data point the nearest neighbour distance
is infinite, so the value <code>Mdefault</code> will be used in place
of <code>M</code>.
</p>
<p>If <code>x</code> is a point pattern, then the value returned is
also a point pattern, which is clipped to the window
of <code>x</code>.  Hence there may be fewer than
<code>nrad * nper * length(x)</code> dummy points in the pattern
returned.
</p>


<h3>Value</h3>

<p>If argument <code>x</code> is a point pattern, a point pattern with
window equal to that of <code>x</code>.  Otherwise a list with two
components <code>x</code> and <code>y</code>.  In either case the components
<code>x</code> and <code>y</code> of the value are numeric vectors giving
the coordinates of the dummy points.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="#topic+quadscheme">quadscheme</a></code>,
<code><a href="#topic+inside.owin">inside.owin</a></code>,
<code><a href="#topic+gridcentres">gridcentres</a></code>,
<code><a href="#topic+stratrand">stratrand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- runifrect(10)
  dum &lt;- spokes(dat$x, dat$y, 5, 3, 0.7)
  plot(dum)
  Q &lt;- quadscheme(dat, dum, method="dirichlet")
  plot(Q, tiles=TRUE)
</code></pre>

<hr>
<h2 id='square'>Square Window</h2><span id='topic+square'></span><span id='topic+unit.square'></span>

<h3>Description</h3>

<p>Creates a square window
</p>


<h3>Usage</h3>

<pre><code class='language-R'> square(r=1, unitname=NULL)
 unit.square()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="square_+3A_r">r</code></td>
<td>
<p>Numeric. The side length of the square,
or a vector giving the minimum and maximum coordinate values.
</p>
</td></tr>
<tr><td><code id="square_+3A_unitname">unitname</code></td>
<td>

<p>Optional. Name of unit of length. Either a single character string,
or a vector of two character strings giving the
singular and plural forms, respectively.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>r</code> is a number, <code>square(r)</code>
is a shortcut for creating a window object
representing the square 
<code class="reqn">[0,r] \times [0,r]</code>.
It is equivalent to the command
<code>owin(c(0,r),c(0,r))</code>.
</p>
<p>If <code>r</code> is a vector of length 2, then
<code>square(r)</code> creates the square with <code>x</code> and <code>y</code> coordinates
ranging from <code>r[1]</code> to <code>r[2]</code>.
</p>
<p><code>unit.square</code> creates the unit square
<code class="reqn">[0,1] \times [0,1]</code>.
It is equivalent to
<code>square(1)</code> or <code>square()</code> or <code>owin(c(0,1),c(0,1))</code>.
</p>
<p>These commands are included for convenience,
and to improve the readability of some code.
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code> (see <code><a href="#topic+owin.object">owin.object</a></code>)
specifying a window. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin.object">owin.object</a></code>,
<code><a href="#topic+owin">owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> W &lt;- square(10)
 W &lt;- square(c(-1,1))
</code></pre>

<hr>
<h2 id='stratrand'>Stratified random point pattern</h2><span id='topic+stratrand'></span>

<h3>Description</h3>

<p>Generates a &ldquo;stratified random&rdquo; pattern of points in a window,
by dividing the window into rectangular tiles and placing
<code>k</code> random points in each tile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> stratrand(window, nx, ny, k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratrand_+3A_window">window</code></td>
<td>
<p>A window. 
An object of class <code><a href="#topic+owin">owin</a></code>,
or data in any format acceptable to <code><a href="#topic+as.owin">as.owin</a>()</code>.
</p>
</td></tr>
<tr><td><code id="stratrand_+3A_nx">nx</code></td>
<td>
<p>Number of tiles in each row.
</p>
</td></tr>
<tr><td><code id="stratrand_+3A_ny">ny</code></td>
<td>
<p>Number of tiles in each column.
</p>
</td></tr>
<tr><td><code id="stratrand_+3A_k">k</code></td>
<td>
<p>Number of random points to generate in each tile.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bounding rectangle of <code>window</code> is divided into
a regular <code class="reqn">nx \times ny</code> grid of rectangular tiles.
In each tile, <code>k</code> random points are generated independently
with a uniform distribution in that tile. 
</p>
<p>Note that some of these grid points may lie outside the window,
if <code>window</code> is not of type <code>"rectangle"</code>. The function
<code><a href="#topic+inside.owin">inside.owin</a></code> can be used to select those grid points
which do lie inside the window. See the examples.
</p>
<p>This function is useful in creating dummy points for quadrature
schemes (see <code><a href="#topic+quadscheme">quadscheme</a></code>) as well as in simulating
random point patterns.
</p>


<h3>Value</h3>

<p>A list with two components <code>x</code> and <code>y</code>, which are numeric
vectors giving the coordinates of the random points.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="#topic+quadscheme">quadscheme</a></code>,
<code><a href="#topic+inside.owin">inside.owin</a></code>,
<code><a href="#topic+gridcentres">gridcentres</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- unit.square()
  xy &lt;- stratrand(w, 10, 10)
  # plot(w)
  # points(xy)

  # polygonal boundary
  bdry &lt;- list(x=c(0.1,0.3,0.7,0.4,0.2),
               y=c(0.1,0.1,0.5,0.7,0.3))
  w &lt;- owin(c(0,1), c(0,1), poly=bdry)
  xy &lt;- stratrand(w, 10, 10, 3)
  # plot(w)
  # points(xy)

  # determine which grid points are inside polygon
  ok &lt;- inside.owin(xy$x, xy$y, w)
  # plot(w)
  # points(xy$x[ok], xy$y[ok])
</code></pre>

<hr>
<h2 id='subset.hyperframe'>
Subset of Hyperframe Satisfying A Condition
</h2><span id='topic+subset.hyperframe'></span>

<h3>Description</h3>

<p>Given a hyperframe, return the subset specified by
imposing a condition on each row, and optionally by choosing
only some of the columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyperframe'
subset(x, subset, select, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.hyperframe_+3A_x">x</code></td>
<td>

<p>A hyperframe pattern (object of class <code>"hyperframe"</code>.
</p>
</td></tr>
<tr><td><code id="subset.hyperframe_+3A_subset">subset</code></td>
<td>

<p>Logical expression indicating which points are to be kept.
The expression may involve the names of columns of <code>x</code>
and will be evaluated by <code><a href="#topic+with.hyperframe">with.hyperframe</a></code>.
</p>
</td></tr>
<tr><td><code id="subset.hyperframe_+3A_select">select</code></td>
<td>

<p>Expression indicating which columns of marks should be kept.
</p>
</td></tr>
<tr><td><code id="subset.hyperframe_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic++5B.hyperframe">[.hyperframe</a></code>
such as <code>drop</code> and <code>strip</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+subset">subset</a></code>.
It extracts the subset of rows of <code>x</code>
that satisfy the logical expression
<code>subset</code>, and retains only the columns of <code>x</code> that are
specified by the expression <code>select</code>. The result is always a
hyperframe.
</p>
<p>The argument <code>subset</code> determines the subset of rows that
will be extracted. It should be a logical expression.
It may involve the names of columns of <code>x</code>.
The default is to keep all points.
</p>
<p>The argument <code>select</code> determines which columns of <code>x</code>
will be retained.
It should be an expression involving the names of columns
(which will be interpreted as integers representing the positions of
these columns). For example if there are columns named
<code>A</code> to <code>Z</code>, then <code>select=D:F</code> is a valid expression
and means that columns <code>D</code>, <code>E</code> and <code>F</code> will be
retained. Similarly <code>select=-(A:C)</code> is valid and means that columns
<code>A</code> to <code>C</code> will be deleted.  
The default is to retain all columns.
</p>
<p>Setting <code>subset=FALSE</code> will remove all the rows.
Setting <code>select=FALSE</code> will remove all the columns.
</p>
<p>The result is always a hyperframe.
</p>


<h3>Value</h3>

<p>A hyperframe.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code>,
<code><a href="#topic++5B.hyperframe">[.hyperframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> a &lt;- subset(flu, virustype=="wt")

 aa &lt;- subset(flu, minnndist(pattern) &gt; 10)

 aaa &lt;- subset(flu, virustype=="wt", select = -pattern)
</code></pre>

<hr>
<h2 id='subset.ppp'>
Subset of Point Pattern Satisfying A Condition
</h2><span id='topic+subset.ppp'></span><span id='topic+subset.pp3'></span><span id='topic+subset.ppx'></span>

<h3>Description</h3>

<p>Given a point pattern, return the subset of points which satisfy
a specified condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
subset(x, subset, select, drop=FALSE, ...)

## S3 method for class 'pp3'
subset(x, subset, select, drop=FALSE, ...)


## S3 method for class 'ppx'
subset(x, subset, select, drop=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.ppp_+3A_x">x</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>,
<code>"lpp"</code>, <code>"pp3"</code> or <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="subset.ppp_+3A_subset">subset</code></td>
<td>

<p>Logical expression indicating which points are to be kept.
The expression may involve the names of spatial coordinates
(<code>x</code>, <code>y</code>, etc), the <code>marks</code>, and
(if there is more than one column of marks)
the names of individual columns of marks.
Missing values are taken as false. See Details.
</p>
</td></tr>
<tr><td><code id="subset.ppp_+3A_select">select</code></td>
<td>

<p>Expression indicating which columns of marks should be kept.
The <em>names</em> of columns of marks can be used in this expression,
and will be treated as if they were column indices.
See Details.
</p>
</td></tr>
<tr><td><code id="subset.ppp_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating whether to remove unused levels
of the marks, if the marks are a factor.
</p>
</td></tr>
<tr><td><code id="subset.ppp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+subset">subset</a></code>.
It extracts the subset of points of <code>x</code>
that satisfy the logical expression
<code>subset</code>, and retains only the columns of marks that are
specified by the expression <code>select</code>. The result is always a point
pattern, with the same window as <code>x</code>.
</p>
<p>The argument <code>subset</code> determines the subset of points that
will be extracted. It should be a logical expression.
It may involve the variable names
<code>x</code> and <code>y</code> representing the Cartesian coordinates;
the names of other spatial coordinates or local coordinates;
the name <code>marks</code> representing the marks;
and (if there is more than one column of marks)
the names of individual columns of marks.
The default is to keep all points.
</p>
<p>The argument <code>select</code> determines which columns of marks
will be retained (if there are several columns of marks).
It should be an expression involving the names of columns of marks
(which will be interpreted as integers representing the positions of
these columns). For example if there are columns of marks named
<code>A</code> to <code>Z</code>, then <code>select=D:F</code> is a valid expression
and means that columns <code>D</code>, <code>E</code> and <code>F</code> will be
retained. Similarly <code>select=-(A:C)</code> is valid and means that columns
<code>A</code> to <code>C</code> will be deleted.  
The default is to retain all columns.
</p>
<p>Setting <code>subset=FALSE</code> will produce an empty point pattern
(i.e. containing zero points) in the same window as <code>x</code>.
Setting <code>select=FALSE</code> or <code>select= -marks</code> will
remove all the marks from <code>x</code>.
</p>
<p>The argument <code>drop</code> determines whether to remove
unused levels of a factor, if the resulting point pattern is multitype
(i.e. the marks are a factor) or if the marks are a data frame
in which some of the columns are factors.
</p>
<p>The result is always a point pattern, of the same class as <code>x</code>.
Spatial coordinates (and local
coordinates) are always retained. To extract only some
columns of marks or coordinates as a data frame,
use <code>subset(as.data.frame(x), ...)</code>
</p>


<h3>Value</h3>

<p>A point pattern of the same class as <code>x</code>, in the same
spatial window as <code>x</code>. The result is a subset of <code>x</code>,
possibly with some columns of marks removed.
</p>


<h3>Other kinds of subset arguments</h3>

<p>Alternatively the argument <code>subset</code> can be any kind of subset index
acceptable to <code><a href="#topic++5B.ppp">[.ppp</a></code>, <code><a href="#topic++5B.pp3">[.pp3</a></code>,
<code><a href="#topic++5B.ppx">[.ppx</a></code>. This argument selects which points of <code>x</code>
will be retained.
</p>
<p><b>Warning:</b> if the argument <code>subset</code> is
a window, this is interpreted as specifying the subset of points that fall
inside that window, but the resulting point pattern has the same window
as the original pattern <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code>,
</p>
<p><code><a href="#topic++5B.ppp">[.ppp</a></code>,
<code><a href="#topic++5B.pp3">[.pp3</a></code>,
<code><a href="#topic++5B.ppx">[.ppx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> plot(subset(cells, x &gt; 0.5))

 subset(amacrine, marks == "on")

 subset(amacrine, marks == "on", drop=TRUE)

 subset(redwood, nndist(redwood) &gt; 0.04)

 subset(finpines, select=height)

 subset(finpines, diameter &gt; 2, height)

 subset(nbfires, year==1999 &amp; ign.src == "campfire",
                 select=cause:fnl.size)


if(require(spatstat.random)) {
 a &lt;- subset(rpoispp3(40), z &gt; 0.5)
}

</code></pre>

<hr>
<h2 id='subset.psp'>
Subset of Line Segment Satisfying A Condition
</h2><span id='topic+subset.psp'></span>

<h3>Description</h3>

<p>Given a line segment pattern, return the subset
of segments which satisfy a specified condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'psp'
subset(x, subset, select, drop=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.psp_+3A_x">x</code></td>
<td>

<p>A line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="subset.psp_+3A_subset">subset</code></td>
<td>

<p>Logical expression indicating which points are to be kept.
The expression may involve the names of spatial coordinates
of the segment endpoints
(<code>x0</code>, <code>y0</code>, <code>x1</code>, <code>y1</code>), the <code>marks</code>, and
(if there is more than one column of marks)
the names of individual columns of marks.
Missing values are taken as false. See Details.
</p>
</td></tr>
<tr><td><code id="subset.psp_+3A_select">select</code></td>
<td>

<p>Expression indicating which columns of marks should be kept.
The <em>names</em> of columns of marks can be used in this expression,
and will be treated as if they were column indices.
See Details.
</p>
</td></tr>
<tr><td><code id="subset.psp_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating whether to remove unused levels
of the marks, if the marks are a factor.
</p>
</td></tr>
<tr><td><code id="subset.psp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+subset">subset</a></code>.
It extracts the subset of <code>x</code> consisting of those segments
that satisfy the logical expression
<code>subset</code>, and retains only the columns of marks that are
specified by the expression <code>select</code>. The result is
always a line segment pattern, with the same window as <code>x</code>.
</p>
<p>The argument <code>subset</code> determines the subset that
will be extracted. It should be a logical expression.
It may involve the variable names
<code>x0</code>, <code>y0</code>, <code>x1</code>, <code>y1</code>
representing the Cartesian coordinates of the segment endpoints;
the name <code>marks</code> representing the marks;
and (if there is more than one column of marks)
the names of individual columns of marks.
The default is to keep all segments.
</p>
<p>The argument <code>select</code> determines which columns of marks
will be retained (if there are several columns of marks).
It should be an expression involving the names of columns of marks
(which will be interpreted as integers representing the positions of
these columns). For example if there are columns of marks named
<code>A</code> to <code>Z</code>, then <code>select=D:F</code> is a valid expression
and means that columns <code>D</code>, <code>E</code> and <code>F</code> will be
retained. Similarly <code>select=-(A:C)</code> is valid and means that columns
<code>A</code> to <code>C</code> will be deleted.  
The default is to retain all columns.
</p>
<p>Setting <code>subset=FALSE</code> will produce an empty point pattern
(i.e. containing zero points) in the same window as <code>x</code>.
Setting <code>select=FALSE</code> or <code>select= -marks</code> will
remove all the marks from <code>x</code>.
</p>
<p>The argument <code>drop</code> determines whether to remove
unused levels of a factor, if the resulting point pattern is multitype
(i.e. the marks are a factor) or if the marks are a data frame
in which some of the columns are factors.
</p>
<p>The result is always a line segment pattern.
To extract only some columns of marks as a data frame,
use <code>subset(as.data.frame(x), ...)</code>
</p>


<h3>Value</h3>

<p>A line segment pattern (object of class <code>"psp"</code>)
in the same spatial window as <code>x</code>. The result is a subset of <code>x</code>,
possibly with some columns of marks removed.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code>,
<code><a href="#topic++5B.psp">[.psp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> plot(nbw.seg)
 plot(subset(nbw.seg, x0 &lt; 500 &amp; y0 &lt; 800), add=TRUE, lwd=6)
 subset(nbw.seg, type == "island")
 subset(nbw.seg, type == "coast", select= -type)
 subset(nbw.seg, type %in% c("island", "coast"), select= FALSE)
</code></pre>

<hr>
<h2 id='summary.anylist'>Summary of a List of Things</h2><span id='topic+summary.anylist'></span>

<h3>Description</h3>

<p>Prints a useful summary of each item in a list of things.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'anylist'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.anylist_+3A_object">object</code></td>
<td>

<p>An object of class <code>"anylist"</code>.
</p>
</td></tr>
<tr><td><code id="summary.anylist_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+summary">summary</a></code>.
</p>
<p>An object of the class <code>"anylist"</code> is effectively a list
of things which are intended to be treated in a similar way.
See <code><a href="#topic+anylist">anylist</a></code>.
</p>
<p>This function extracts a useful summary of each of the items in the list.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anylist">anylist</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="#topic+plot.anylist">plot.anylist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- anylist(A=runif(10), B=runif(10), C=runif(10))
  summary(x)
</code></pre>

<hr>
<h2 id='summary.distfun'>
Summarizing a Function of Spatial Location
</h2><span id='topic+summary.distfun'></span><span id='topic+summary.funxy'></span>

<h3>Description</h3>

<p>Prints a useful summary of a function of spatial location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'distfun'
summary(object, ...)

  ## S3 method for class 'funxy'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.distfun_+3A_object">object</code></td>
<td>

<p>An object of class <code>"distfun"</code> or <code>"funxy"</code>
representing a function of spatial coordinates.
</p>
</td></tr>
<tr><td><code id="summary.distfun_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.mask">as.mask</a></code> controlling the
pixel resolution used to compute the summary.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are the <code><a href="base.html#topic+summary">summary</a></code> methods
for the classes <code>"funxy"</code> and <code>"distfun"</code>.
</p>
<p>An object of class <code>"funxy"</code> represents a function
of spatial location, defined in a particular region of space.
This includes objects of the special class <code>"distfun"</code> which represent
distance functions.
</p>
<p>The <code>summary</code> method computes a summary of the function values.
The function is evaluated on a grid of locations using
<code><a href="#topic+as.im">as.im</a></code> and numerical values at these locations
are summarised using <code><a href="#topic+summary.im">summary.im</a></code>. The pixel resolution
for the grid of locations is determined by the arguments
<code>...</code> which are passed to <code><a href="#topic+as.mask">as.mask</a></code>.
</p>


<h3>Value</h3>

<p>For <code>summary.funxy</code> the result is
an object of class <code>"summary.funxy"</code>.
For <code>summary.distfun</code> the result is
an object of class <code>"summary.distfun"</code>.
There are <code>print</code> methods for these classes.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distfun">distfun</a></code>, <code><a href="#topic+funxy">funxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   f &lt;- function(x,y) { x^2 + y^2 - 1} 
   g &lt;- funxy(f, square(2))
   summary(g)

   summary(distfun(cells))
   summary(distfun(cells), dimyx=256)
</code></pre>

<hr>
<h2 id='summary.im'>Summarizing a Pixel Image</h2><span id='topic+summary.im'></span><span id='topic+print.summary.im'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"im"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'im'
summary(object, ...)
  ## S3 method for class 'summary.im'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.im_+3A_object">object</code></td>
<td>
<p>A pixel image.</p>
</td></tr>
<tr><td><code id="summary.im_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="summary.im_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.im"</code> as returned by
<code>summary.im</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic <code><a href="base.html#topic+summary">summary</a></code>
for the class <code>"im"</code>. An object of class <code>"im"</code>
describes a pixel image. See <code><a href="#topic+im.object">im.object</a></code>)
for details of this class. 
</p>
<p><code>summary.im</code> extracts information about the pixel image,
and <code>print.summary.im</code> prints this information in a
comprehensible format.
</p>
<p>In normal usage, <code>print.summary.im</code> is invoked implicitly
when the user calls <code>summary.im</code> without assigning its value
to anything. See the examples.
</p>
<p>The information extracted by <code>summary.im</code> includes
</p>

<dl>
<dt>range</dt><dd><p>The range of the image values.</p>
</dd>
<dt>mean</dt><dd><p>The mean of the image values.</p>
</dd>
<dt>integral</dt><dd><p>The &ldquo;integral&rdquo; of the image values,
calculated as the sum of the image values
multiplied by the area of one pixel.</p>
</dd>
<dt>dim</dt><dd><p>The dimensions of the pixel array:
<code>dim[1]</code> is the number of rows in the array,
corresponding to the <b>y</b> coordinate.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>summary.im</code> returns an object of class <code>"summary.im"</code>,
while <code>print.summary.im</code> returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.im">mean.im</a></code>, <code><a href="#topic+integral.im">integral.im</a></code>, <code><a href="#topic+anyNA.im">anyNA.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # make an image
  X &lt;- as.im(function(x,y) {x^2}, unit.square())
  # summarize it
  summary(X)
  # save the summary
  s &lt;- summary(X)
  # print it
  print(X)
  s
  # extract stuff
  X$dim
  X$range
  X$integral
</code></pre>

<hr>
<h2 id='summary.listof'>Summary of a List of Things</h2><span id='topic+summary.listof'></span>

<h3>Description</h3>

<p>Prints a useful summary of each item in a list of things.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'listof'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.listof_+3A_object">object</code></td>
<td>

<p>An object of class <code>"listof"</code>.
</p>
</td></tr>
<tr><td><code id="summary.listof_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+summary">summary</a></code>.
</p>
<p>An object of the class <code>"listof"</code> is effectively a list
of things which are all of the same class.
</p>
<p>This function extracts a useful summary of each of the items in the list.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="#topic+plot.listof">plot.listof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- list(A=runif(10), B=runif(10), C=runif(10))
  class(x) &lt;- c("listof", class(x))
  summary(x)
</code></pre>

<hr>
<h2 id='summary.owin'>Summary of a Spatial Window</h2><span id='topic+summary.owin'></span>

<h3>Description</h3>

<p>Prints a useful description of a window object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'owin'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.owin_+3A_object">object</code></td>
<td>
<p>Window (object of class <code>"owin"</code>).</p>
</td></tr>
<tr><td><code id="summary.owin_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A useful description of the window <code>object</code> is printed.
</p>
<p>This is a method for the generic function <code><a href="base.html#topic+summary">summary</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="#topic+summary.ppp">summary.ppp</a></code>,
<code><a href="#topic+print.owin">print.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  summary(owin())  # the unit square

  W &lt;- Window(demopat)  # weird polygonal window
  summary(W)           # describes it

  summary(as.mask(W))  # demonstrates current pixel resolution
</code></pre>

<hr>
<h2 id='summary.ppp'>Summary of a Point Pattern Dataset</h2><span id='topic+summary.ppp'></span>

<h3>Description</h3>

<p>Prints a useful summary of a point pattern dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppp'
summary(object, ..., checkdup=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ppp_+3A_object">object</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="summary.ppp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="summary.ppp_+3A_checkdup">checkdup</code></td>
<td>

<p>Logical value indicating whether to check
for the presence of duplicate points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A useful summary of the point pattern <code>object</code> is printed.
</p>
<p>This is a method for the generic function <code><a href="base.html#topic+summary">summary</a></code>.
</p>
<p>If <code>checkdup=TRUE</code>, the pattern will be checked for the
presence of duplicate points, using <code><a href="#topic+duplicated.ppp">duplicated.ppp</a></code>.
This can be time-consuming if the pattern contains many points,
so the checking can be disabled by setting <code>checkdup=FALSE</code>.
</p>
<p>If the point pattern was generated by simulation
using <code><a href="spatstat.random.html#topic+rmh">rmh</a></code>, the parameters of the algorithm
are printed.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="#topic+summary.owin">summary.owin</a></code>,
<code><a href="#topic+print.ppp">print.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  summary(cells)  # plain vanilla point pattern

  # multitype point pattern
  woods &lt;- lansing
  
  summary(woods) # tabulates frequencies of each mark
  
  # numeric marks
  trees &lt;- longleaf
  
  summary(trees) # prints summary.default(marks(trees))

  # weird polygonal window
  summary(demopat)  # describes it
</code></pre>

<hr>
<h2 id='summary.psp'>Summary of a Line Segment Pattern Dataset</h2><span id='topic+summary.psp'></span>

<h3>Description</h3>

<p>Prints a useful summary of a line segment pattern dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'psp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.psp_+3A_object">object</code></td>
<td>
<p>Line segment pattern (object of class <code>"psp"</code>).</p>
</td></tr>
<tr><td><code id="summary.psp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A useful summary of the line segment pattern <code>object</code> is printed.
</p>
<p>This is a method for the generic function <code><a href="base.html#topic+summary">summary</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="#topic+summary.owin">summary.owin</a></code>,
<code><a href="#topic+print.psp">print.psp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
  summary(a)  # describes it
</code></pre>

<hr>
<h2 id='summary.quad'>Summarizing a Quadrature Scheme</h2><span id='topic+summary.quad'></span><span id='topic+print.summary.quad'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"quad"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'quad'
summary(object, ..., checkdup=FALSE)
  ## S3 method for class 'summary.quad'
print(x, ..., dp=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.quad_+3A_object">object</code></td>
<td>
<p>A quadrature scheme.</p>
</td></tr>
<tr><td><code id="summary.quad_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="summary.quad_+3A_checkdup">checkdup</code></td>
<td>

<p>Logical value indicating whether to test for duplicated points.
</p>
</td></tr>
<tr><td><code id="summary.quad_+3A_dp">dp</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr> 
<tr><td><code id="summary.quad_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.quad"</code> returned by
<code>summary.quad</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic <code><a href="base.html#topic+summary">summary</a></code>
for the class <code>"quad"</code>. An object of class <code>"quad"</code>
describes a quadrature scheme, used to fit a point process model.
See <code><a href="#topic+quad.object">quad.object</a></code>) for details of this class. 
</p>
<p><code>summary.quad</code> extracts information about the
quadrature scheme,
and <code>print.summary.quad</code> prints this information in a
comprehensible format.
</p>
<p>In normal usage, <code>print.summary.quad</code> is invoked implicitly
when the user calls <code>summary.quad</code> without assigning its value
to anything. See the examples.
</p>


<h3>Value</h3>

<p><code>summary.quad</code> returns an object of class <code>"summary.quad"</code>,
while <code>print.summary.quad</code> returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # make a quadrature scheme
  Q &lt;- quadscheme(runifrect(42))
  # summarize it
  summary(Q)
  # save the summary
  s &lt;- summary(Q)
  # print it
  print(s)
  s
  # extract total quadrature weight
  s$w$all$sum
</code></pre>

<hr>
<h2 id='summary.solist'>Summary of a List of Spatial Objects</h2><span id='topic+summary.solist'></span>

<h3>Description</h3>

<p>Prints a useful summary of each entry in a list of two-dimensional
spatial objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'solist'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.solist_+3A_object">object</code></td>
<td>

<p>An object of class <code>"solist"</code>.
</p>
</td></tr>
<tr><td><code id="summary.solist_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+summary">summary</a></code>.
</p>
<p>An object of the class <code>"solist"</code> is effectively a list
of two-dimensional spatial datasets.
See <code><a href="#topic+solist">solist</a></code>.
</p>
<p>This function extracts a useful summary of each of the datasets.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+solist">solist</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="#topic+plot.solist">plot.solist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- solist(cells, japanesepines, redwood)
  summary(x)
</code></pre>

<hr>
<h2 id='summary.splitppp'>Summary of a Split Point Pattern</h2><span id='topic+summary.splitppp'></span>

<h3>Description</h3>

<p>Prints a useful summary of a split point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'splitppp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.splitppp_+3A_object">object</code></td>
<td>

<p>Split point pattern (object of class <code>"splitppp"</code>, effectively a
list of point patterns, usually created by <code><a href="#topic+split.ppp">split.ppp</a></code>).
</p>
</td></tr>
<tr><td><code id="summary.splitppp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+summary">summary</a></code>.
</p>
<p>An object of the class <code>"splitppp"</code> is effectively a list
of point patterns (objects of class <code>"ppp"</code>) representing
different sub-patterns of an original point pattern.
</p>
<p>This function extracts a useful summary of each of the sub-patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="base.html#topic+split">split</a></code>,
<code><a href="#topic+split.ppp">split.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  summary(split(amacrine))
</code></pre>

<hr>
<h2 id='superimpose'>Superimpose Several Geometric Patterns</h2><span id='topic+superimpose'></span><span id='topic+superimpose.ppp'></span><span id='topic+superimpose.splitppp'></span><span id='topic+superimpose.ppplist'></span><span id='topic+superimpose.psp'></span><span id='topic+superimpose.default'></span>

<h3>Description</h3>

<p>Superimpose any number of point patterns or line segment patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  superimpose(...)

  ## S3 method for class 'ppp'
superimpose(..., W=NULL, check=TRUE)

  ## S3 method for class 'psp'
superimpose(..., W=NULL, check=TRUE)

  ## S3 method for class 'splitppp'
superimpose(..., W=NULL, check=TRUE)

  ## S3 method for class 'ppplist'
superimpose(..., W=NULL, check=TRUE)

  ## Default S3 method:
superimpose(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superimpose_+3A_...">...</code></td>
<td>

<p>Any number of arguments, each of which represents either a point
pattern or a line segment pattern or a list of point patterns.
</p>
</td></tr>
<tr><td><code id="superimpose_+3A_w">W</code></td>
<td>

<p>Optional. Data determining the window for the resulting pattern.
Either a window (object of class <code>"owin"</code>, or something
acceptable to <code><a href="#topic+as.owin">as.owin</a></code>), or a function
which returns a window, or one of the strings
<code>"convex"</code>, <code>"rectangle"</code>, <code>"bbox"</code> or <code>"none"</code>.
</p>
</td></tr>
<tr><td><code id="superimpose_+3A_check">check</code></td>
<td>

<p>Logical value (passed to <code><a href="#topic+ppp">ppp</a></code> or <code><a href="#topic+psp">psp</a></code>
as appropriate) determining whether to check the geometrical
validity of the resulting pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to superimpose several geometric patterns
of the same kind, producing a single pattern of the same kind.
</p>
<p>The function <code>superimpose</code> is generic, with methods
for the class <code>ppp</code> of point patterns, the class <code>psp</code>
of line segment patterns, and a default method. There is also
a method for <code>lpp</code>, described separately in
<code>superimpose.lpp</code>.
</p>
<p>The dispatch to a method is initially determined
by the class of the <em>first</em> argument in <code>...</code>.
</p>

<ul>
<li> <p><code>default</code>:  If the first argument is 
<em>not</em> an object of class <code>ppp</code> or <code>psp</code>, then the
default method <code>superimpose.default</code> is executed.
This checks the class of all arguments, and dispatches to the
appropriate method. Arguments of class <code>ppplist</code> can be handled.
</p>
</li>
<li> <p><code>ppp</code>:
If the first <code>...</code> argument is an object of
class <code>ppp</code> then the method <code>superimpose.ppp</code>
is executed. All arguments in <code>...</code>
must be either <code>ppp</code> objects or lists
with components <code>x</code> and <code>y</code>. The result will
be an object of class <code>ppp</code>.
</p>
</li>
<li><p> psp:
If the first <code>...</code> argument is an object of
class <code>psp</code> then the <code>psp</code> method is dispatched and all
<code>...</code> arguments must be <code>psp</code> objects.
The result is a <code>psp</code> object.
</p>
</li></ul>

<p>The patterns are <em>not</em> required to have the same window
of observation. 
</p>
<p>The window for the superimposed pattern is controlled
by the argument <code>W</code>.
</p>

<ul>
<li>
<p>If <code>W</code> is a window (object of class <code>"W"</code>
or something acceptable to <code><a href="#topic+as.owin">as.owin</a></code>)
then this determines the window for the superimposed pattern.
</p>
</li>
<li>
<p>If <code>W</code> is <code>NULL</code>, or the character string <code>"none"</code>,
then windows are extracted from the geometric patterns,
as follows. 
For <code>superimpose.psp</code>, all arguments <code>...</code>
are line segment patterns (objects of class <code>"psp"</code>);
their observation windows are extracted; the union of these
windows is computed; and this union is taken to be the
window for the superimposed pattern.
For <code>superimpose.ppp</code> and <code>superimpose.default</code>,
the arguments <code>...</code> are inspected, and 
any arguments which are point patterns (objects of class
<code>"ppp"</code>) are selected; their observation windows
are extracted, and the union of these windows
is taken to be the window for the superimposed point pattern.
For <code>superimpose.default</code> if none of the arguments
is of class <code>"ppp"</code> then no window is computed
and the result of <code>superimpose</code> is a <code>list(x,y)</code>.
</p>
</li>
<li>
<p>If <code>W</code> is one of the strings
<code>"convex"</code>, <code>"rectangle"</code> or <code>"bbox"</code>
then a window for the superimposed pattern
is computed from the coordinates of the
points or the line segments as follows.
</p>

<dl>
<dt><code>"bbox"</code>:</dt><dd><p>the bounding box of the
points or line segments (see <code><a href="#topic+bounding.box.xy">bounding.box.xy</a></code>);</p>
</dd>
<dt><code>"convex"</code>:</dt><dd><p>the Ripley-Rasson estimator
of a convex window (see <code><a href="#topic+ripras">ripras</a></code>);</p>
</dd>
<dt><code>"rectangle"</code>:</dt><dd><p>the Ripley-Rasson estimator
of a rectangular window
(using <code><a href="#topic+ripras">ripras</a></code> with argument
<code>shape="rectangle"</code>).</p>
</dd>
</dl>

</li>
<li>
<p>If <code>W</code> is a function,
then this function is used to compute
a window for the superimposed pattern
from the coordinates of the
points or the line segments.
The function should accept input of the form <code>list(x,y)</code>
and is expected to return an object of class <code>"owin"</code>.
Examples of such functions are
<code><a href="#topic+ripras">ripras</a></code> and <code><a href="#topic+bounding.box.xy">bounding.box.xy</a></code>.
</p>
</li></ul>

<p>The arguments <code>...</code> may be <em>marked</em> patterns.
The marks of each component pattern must have the same format.
Numeric and character marks may be &ldquo;mixed&rdquo;.  If there is such
mixing then the numeric marks are coerced to character in the
combining process. If the mark structures are all data frames,
then these data frames must have the same number of columns and
identical column names.
</p>
<p>If the arguments <code>...</code> are given in the form <code>name=value</code>,
then the <code>name</code>s will be used as an extra column of marks
attached to the elements of the corresponding patterns.
</p>


<h3>Value</h3>

<p>For <code>superimpose.ppp</code>, a point pattern (object of class <code>"ppp"</code>).
For <code>superimpose.default</code>, either a point pattern
(object of class <code>"ppp"</code>) or a <code>list(x,y)</code>.
For <code>superimpose.psp</code>, a line segment pattern (object of class
<code>"psp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+concatxy">concatxy</a></code>, <code><a href="#topic+quadscheme">quadscheme</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # superimposing point patterns
  p1  &lt;- runifrect(30)
  p2  &lt;- runifrect(42)
  s1  &lt;- superimpose(p1,p2) # Unmarked pattern.
  p3  &lt;- list(x=rnorm(20),y=rnorm(20))
  s2  &lt;- superimpose(p3,p2,p1) # Default method gets called.
  s2a &lt;- superimpose(p1,p2,p3) # Same as s2 except for order of points.
  s3  &lt;- superimpose(clyde=p1,irving=p2) # Marked pattern; marks a factor
                                         # with levels "clyde" and "irving";
                                         # warning given.
  marks(p1) &lt;- factor(sample(LETTERS[1:3],30,TRUE))
  marks(p2) &lt;- factor(sample(LETTERS[1:3],42,TRUE))
  s5  &lt;- superimpose(clyde=p1,irving=p2) # Marked pattern with extra column
  marks(p2) &lt;- data.frame(a=marks(p2),b=runif(42))
  s6  &lt;- try(superimpose(p1,p2)) # Gives an error.
  marks(p1) &lt;- data.frame(a=marks(p1),b=1:30)
  s7  &lt;- superimpose(p1,p2) # O.K.

  # how to make a 2-type point pattern with types "a" and "b"
  u &lt;- superimpose(a = runifrect(10), b = runifrect(20))

  # how to make a 2-type point pattern with types 1 and 2
  u &lt;- superimpose("1" = runifrect(10), "2" = runifrect(20))
 
  # superimposing line segment patterns
  X &lt;- as.psp(matrix(runif(20), 5, 4), window=owin())
  Y &lt;- as.psp(matrix(runif(40), 10, 4), window=owin())
  Z &lt;- superimpose(X, Y)

  # being unreasonable
  ## Not run: 
   if(FALSE) {
    crud &lt;- try(superimpose(p1,p2,X,Y)) # Gives an error, of course!
   }
  
## End(Not run)
</code></pre>

<hr>
<h2 id='symbolmap'>
Graphics Symbol Map
</h2><span id='topic+symbolmap'></span>

<h3>Description</h3>

<p>Create a graphics symbol map that associates data values with
graphical symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbolmap(..., range = NULL, inputs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbolmap_+3A_...">...</code></td>
<td>

<p>Named arguments specifying the graphical parameters.
See Details.
</p>
</td></tr>
<tr><td><code id="symbolmap_+3A_range">range</code></td>
<td>

<p>Optional. Range of numbers that are mapped.
A numeric vector of length 2 giving the minimum and maximum
values that will be mapped.
Incompatible with <code>inputs</code>.
</p>
</td></tr>
<tr><td><code id="symbolmap_+3A_inputs">inputs</code></td>
<td>

<p>Optional. A vector containing all the data values
that will be mapped to symbols.
Incompatible with <code>range</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A graphical symbol map is an association between
data values and graphical symbols. 
The command <code>symbolmap</code> creates an object of class
<code>"symbolmap"</code> that represents a graphical symbol map.
</p>
<p>Once a symbol map has been created, it can be applied to any
suitable data to generate a plot of those data.
This makes it easy to ensure that
the <em>same</em> symbol map is used in two different plots.
The symbol map can be plotted as a legend to the plots,
and can also be plotted in its own right.
</p>
<p>The possible values of data that will be mapped
are specified by <code>range</code> or <code>inputs</code>.
</p>

<ul>
<li><p> if <code>range</code> is given, it should be a numeric vector
of length 2 giving the minimum and maximum values of the range
of numbers that will be mapped. These limits must be finite.
</p>
</li>
<li><p> if <code>inputs</code> is given, it should be a vector
of any atomic type (e.g. numeric, character, logical, factor).
This vector contains all the possible data values
that will be mapped.
</p>
</li>
<li><p> If neither <code>range</code> nor <code>inputs</code> is given,
it is assumed that the possible values are real numbers.
</p>
</li></ul>

<p>The association of data values with graphical symbols
is specified by the other arguments <code>...</code>
which are given in <code>name=value</code> form.
These arguments specify the kinds of symbols that will be
used, the sizes of the symbols, and graphics parameters for
drawing the symbols.
</p>
<p>Each graphics parameter can be either a single
value, for example <code>shape="circles"</code>,
or a <code>function(x)</code> which determines the value
of the graphics parameter as a function of the data <code>x</code>,
for example <code>shape=function(x) ifelse(x &gt; 0, "circles", "squares")</code>.
Colourmaps (see <code><a href="#topic+colourmap">colourmap</a></code>) are also acceptable
because they are functions.
</p>
<p>Currently recognised graphics parameters, and their
allowed values, are:
</p>

<dl>
<dt>shape</dt><dd>
<p>The shape of the symbol: currently
either <code>"circles"</code>, <code>"squares"</code>, <code>"arrows"</code>,
<code>"crossticks"</code> or <code>NA</code>.
This parameter takes precedence over <code>pch</code>.
(Crossticks are used only for point patterns on a linear network).
</p>
</dd>
<dt>size</dt><dd>
<p>The size of the symbol: a positive number or zero.
</p>
</dd>
<dt>pch</dt><dd>
<p>Graphics character code:
a positive integer, or a single character.
See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</dd>
<dt>cex</dt><dd>
<p>Graphics character expansion factor.
</p>
</dd>
<dt>cols</dt><dd>
<p>Colour of plotting characters.
</p>
</dd>
<dt>fg,bg</dt><dd>
<p>Colour of foreground (or symbol border) and background
(or symbol interior).
</p>
</dd>
<dt>col,lwd,lty</dt><dd>
<p>Colour, width and style of lines.
</p>
</dd>
<dt>etch</dt><dd>
<p>Logical. If <code>TRUE</code>, each symbol is surrounded
by a border drawn in the opposite colour,
which improves its visibility against the background.
Default is <code>FALSE</code>.
</p>
</dd>
<dt>direction,headlength,headangle,arrowtype</dt><dd>
<p>Numeric parameters of arrow symbols, applicable when
<code>shape="arrows"</code>. Here <code>direction</code> is the direction
of the arrow in degrees anticlockwise from the <code class="reqn">x</code> axis;
<code>headlength</code> is the length of the head of the arrow in
coordinate units; <code>headangle</code> is the angle subtended by the point
of the arrow; and <code>arrowtype</code> is an integer code
specifying which ends of the shaft have arrowheads
attached (0 means no arrowheads, 1 is an arrowhead at the start
of the shaft, 2 is an arrowhead at the end of the shaft, and
3 is arrowheads at both ends).
</p>
</dd>
</dl>

<p>A vector of colour values is also acceptable for the arguments
<code>col,cols,fg,bg</code> if
<code>range</code> is specified.
</p>


<h3>Value</h3>

<p>An object of class <code>"symbolmap"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.symbolmap">plot.symbolmap</a></code> to plot the symbol map itself.
</p>
<p><code><a href="#topic+invoke.symbolmap">invoke.symbolmap</a></code> to apply the symbol map to some data
and plot the resulting symbols.
</p>
<p><code><a href="#topic+update.symbolmap">update.symbolmap</a></code> to change the symbol map.
</p>
<p>There are methods for <code>print</code> and <code>summary</code> for symbol maps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  g &lt;- symbolmap(inputs=letters[1:10], pch=11:20)

  g1 &lt;- symbolmap(range=c(0,100), size=function(x) x/50)

  g2 &lt;- symbolmap(shape=function(x) ifelse(x &gt; 0, "circles", "squares"),
                    size=function(x) sqrt(ifelse(x &gt; 0, x/pi, -x)),
                    bg = function(x) ifelse(abs(x) &lt; 1, "red", "black"))

  colmap &lt;- colourmap(topo.colors(20), range=c(0,10))
  g3 &lt;- symbolmap(pch=21, bg=colmap, range=c(0,10))
  plot(g3)
</code></pre>

<hr>
<h2 id='tess'>Create a Tessellation</h2><span id='topic+tess'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"tess"</code> representing a tessellation
of a spatial region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tess(..., xgrid = NULL, ygrid = NULL, tiles = NULL, image = NULL,
            window=NULL, marks=NULL, keepempty=FALSE, unitname=NULL, check=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tess_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="tess_+3A_xgrid">xgrid</code>, <code id="tess_+3A_ygrid">ygrid</code></td>
<td>
<p>Cartesian coordinates of vertical and
horizontal lines determining a grid of rectangles.
Incompatible with other arguments.
</p>
</td></tr>
<tr><td><code id="tess_+3A_tiles">tiles</code></td>
<td>
<p>List of tiles in the tessellation.
A list, each of whose elements is a window
(object of class <code>"owin"</code>). Incompatible with other arguments.
</p>
</td></tr>
<tr><td><code id="tess_+3A_image">image</code></td>
<td>

<p>Pixel image
(object of class <code>"im"</code>)
which specifies the tessellation.
Incompatible with other arguments.
</p>
</td></tr>
<tr><td><code id="tess_+3A_window">window</code></td>
<td>

<p>Optional.
The spatial region which is tessellated (i.e. the union of all the tiles).
An object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="tess_+3A_marks">marks</code></td>
<td>

<p>Optional vector or data frame of marks associated with the tiles.
</p>
</td></tr>
<tr><td><code id="tess_+3A_keepempty">keepempty</code></td>
<td>

<p>Logical flag indicating whether empty tiles should be retained
or deleted.
</p>
</td></tr>
<tr><td><code id="tess_+3A_unitname">unitname</code></td>
<td>

<p>Optional. Name of unit of length. Either a single character string,
or a vector of two character strings giving the
singular and plural forms, respectively.
If this argument is missing or <code>NULL</code>,
information about the unitname will be
extracted from the other arguments.
If this argument is given, it overrides any other information
about the unitname.
</p>
</td></tr>
<tr><td><code id="tess_+3A_check">check</code></td>
<td>

<p>Logical value indicating whether to check the validity of the
input data. It is strongly recommended to use the default
value <code>check=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation is a collection of disjoint spatial regions
(called <em>tiles</em>) that fit together to form a larger spatial
region. This command creates an object of class <code>"tess"</code> that
represents a tessellation.
</p>
<p>Three types of tessellation are supported:
</p>

<dl>
<dt>rectangular:</dt><dd>
<p>tiles are rectangles, with sides parallel to the <code>x</code> and
<code>y</code> axes. They may or may not have equal size and shape.
The arguments <code>xgrid</code> and <code>ygrid</code> determine
the positions of the vertical and horizontal grid lines,
respectively. (See <code><a href="#topic+quadrats">quadrats</a></code> for another way to do this.)
</p>
</dd>
<dt>tile list:</dt><dd>
<p>tiles are arbitrary spatial regions.
The argument <code>tiles</code> is a list of these tiles,
which are objects of class <code>"owin"</code>.
</p>
</dd>
<dt>pixel image:</dt><dd>
<p>Tiles are subsets of a fine grid of pixels.
The argument <code>image</code> is a pixel image (object of class
<code>"im"</code>) with factor values. Each level of the factor
represents a different tile of the tessellation. The pixels that
have a particular value of the factor constitute a tile. 
</p>
</dd>
</dl>

<p>The optional argument <code>window</code> specifies the spatial region
formed by the union of all the tiles. In other words it specifies the
spatial region that is divided into tiles by the tessellation.
If this argument is missing or <code>NULL</code>, it will be determined by
computing the set union of all the tiles. This is a time-consuming
computation. For efficiency it is advisable to specify the window.
Note that the validity of the window will not be checked.
</p>
<p>Empty tiles may occur, either because one of the entries in the list
<code>tiles</code> is an empty window, or because one of the levels of the
factor-valued pixel image <code>image</code> does not occur in the pixel data.
When <code>keepempty=TRUE</code>, empty tiles are permitted. 
When <code>keepempty=FALSE</code> (the default), tiles are not allowed to be
empty, and any empty tiles will be removed from the tessellation.
</p>
<p>There are methods for <code>print</code>, <code>plot</code>, <code>[</code> and <code>[&lt;-</code>
for tessellations. Use <code><a href="#topic+tiles">tiles</a></code> to extract the list of
tiles in a tessellation, <code><a href="#topic+tilenames">tilenames</a></code> to extract the names
of the tiles, and <code><a href="#topic+tile.areas">tile.areas</a></code> to compute their
areas.
</p>
<p>The tiles may have marks, which can be extracted by
<code><a href="#topic+marks.tess">marks.tess</a></code> and changed by <code><a href="#topic+marks+3C-.tess">marks&lt;-.tess</a></code>.
</p>
<p>Tessellations can be used to classify the points of
a point pattern, in <code><a href="#topic+split.ppp">split.ppp</a></code>, <code><a href="#topic+cut.ppp">cut.ppp</a></code> and
<code><a href="#topic+by.ppp">by.ppp</a></code>.
</p>
<p>To construct particular tessellations, see
<code><a href="#topic+quadrats">quadrats</a></code>, <code><a href="#topic+hextess">hextess</a></code>, 
<code><a href="#topic+dirichlet">dirichlet</a></code>, <code><a href="#topic+delaunay">delaunay</a></code>,
<code><a href="#topic+venn.tess">venn.tess</a></code>,
<code><a href="#topic+polartess">polartess</a></code>,
<code><a href="#topic+quantess">quantess</a></code>,
<code><a href="#topic+bufftess">bufftess</a></code>
and <code><a href="spatstat.random.html#topic+rpoislinetess">rpoislinetess</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"tess"</code> representing the tessellation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marks.tess">marks.tess</a></code>,
<code><a href="#topic+plot.tess">plot.tess</a></code>,
<code><a href="#topic++5B.tess">[.tess</a></code>,
<code><a href="#topic+as.tess">as.tess</a></code>,
<code><a href="#topic+tiles">tiles</a></code>,
<code><a href="#topic+intersect.tess">intersect.tess</a></code>,
<code><a href="#topic+split.ppp">split.ppp</a></code>,
<code><a href="#topic+cut.ppp">cut.ppp</a></code>,
<code><a href="#topic+by.ppp">by.ppp</a></code>,
<code><a href="#topic+bdist.tiles">bdist.tiles</a></code>,
<code><a href="#topic+tile.areas">tile.areas</a></code>,
<code><a href="#topic+as.function.tess">as.function.tess</a></code>.
</p>
<p>To construct particular tessellations, see
<code><a href="#topic+quadrats">quadrats</a></code>, <code><a href="#topic+hextess">hextess</a></code>,
<code><a href="#topic+venn.tess">venn.tess</a></code>,
<code><a href="#topic+polartess">polartess</a></code>,
<code><a href="#topic+dirichlet">dirichlet</a></code>, <code><a href="#topic+delaunay">delaunay</a></code>, <code><a href="#topic+quantess">quantess</a></code>
and <code><a href="spatstat.random.html#topic+rpoislinetess">rpoislinetess</a></code>.
</p>
<p>To divide space into pieces containing equal
amounts of stuff, use <code><a href="#topic+quantess">quantess</a></code>.
</p>
<p>To convert a tessellation to a function, for use as a spatial covariate
(associating a numerical value with each tile of the tessellation) use
<code><a href="#topic+as.function.tess">as.function.tess</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A &lt;- tess(xgrid=0:4,ygrid=0:4)
  A
  plot(A)
  B &lt;- A[c(1, 2, 5, 7, 9)]
  B
  v &lt;- as.im(function(x,y){factor(round(5 * (x^2 + y^2)))}, W=owin())
  levels(v) &lt;- letters[seq(length(levels(v)))]
  E &lt;- tess(image=v)
  plot(E)
  G &lt;- tess(image=v, marks=toupper(levels(v)), unitname="km")
  G
</code></pre>

<hr>
<h2 id='test.crossing.psp'>
Check Whether Segments Cross
</h2><span id='topic+test.crossing.psp'></span><span id='topic+test.selfcrossing.psp'></span>

<h3>Description</h3>

<p>Determine whether there is a crossing (intersection) between
each pair of line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.crossing.psp(A, B)
test.selfcrossing.psp(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.crossing.psp_+3A_a">A</code>, <code id="test.crossing.psp_+3A_b">B</code></td>
<td>

<p>Line segment patterns (objects of class <code>"psp"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions decide whether the given line segments intersect
each other.
</p>
<p>If <code>A</code> and <code>B</code> are two spatial patterns of line segments,
<code>test.crossing.psp(A, B)</code>
returns a logical matrix in which the entry on row <code>i</code>, column
<code>j</code> is equal to <code>TRUE</code> if segment <code>A[i]</code>
has an intersection with segment <code>B[j]</code>.
</p>
<p>If <code>A</code> is a pattern of line segments, <code>test.selfcross.psp(A)</code>
returns a symmetric logical matrix in which the entry on row <code>i</code>, column
<code>j</code> is equal to <code>TRUE</code> if segment <code>A[i]</code>
has an intersection with segment <code>A[j]</code>.
</p>


<h3>Value</h3>

<p>A logical matrix.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psp">psp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  B &lt;- edges(letterR)
if(require(spatstat.random)) {
  A &lt;- rpoisline(5, Frame(B))
} else {
  FB &lt;- Frame(B)
  A &lt;- as.psp(from=runifrect(5, FB), to=runifrect(5, FB))
}
  MA &lt;- test.selfcrossing.psp(A)
  MAB &lt;- test.crossing.psp(A, B)
</code></pre>

<hr>
<h2 id='text.ppp'>
Add Text Labels to Spatial Pattern 
</h2><span id='topic+text.ppp'></span><span id='topic+text.psp'></span>

<h3>Description</h3>

<p>Plots a text label at the location of each point in a spatial point
pattern, or each object in a spatial pattern of objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
text(x, ...)


## S3 method for class 'psp'
text(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text.ppp_+3A_x">x</code></td>
<td>

<p>A spatial point pattern (object of class <code>"ppp"</code>),
or a spatial pattern of line segments (class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="text.ppp_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="graphics.html#topic+text.default">text.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic <code><a href="graphics.html#topic+text">text</a></code>.
A text label is added to the existing plot,
at the location of each point in the point pattern <code>x</code>,
or near the location of the midpoint of each segment
in the segment pattern <code>x</code>.
</p>
<p>Additional arguments <code>...</code> are passed to
<code><a href="graphics.html#topic+text.default">text.default</a></code> and may be used to control the
placement of the labels relative to the point locations, and
the size and colour of the labels.
</p>
<p>By default, the labels are the serial numbers 1 to <code>n</code>, where
<code>n</code> is the number of points or segments in <code>x</code>. This can
be changed by specifying the argument <code>labels</code>, which should be
a vector of length <code>n</code>.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+text.default">text.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(cells)
  text(cells, pos=2)

  plot(Frame(cells))
  text(cells, cex=1.5)

</code></pre>

<hr>
<h2 id='texturemap'>
Texture Map
</h2><span id='topic+texturemap'></span>

<h3>Description</h3>

<p>Create a map that associates data values with graphical textures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>texturemap(inputs, textures, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="texturemap_+3A_inputs">inputs</code></td>
<td>

<p>A vector containing all the data values
that will be mapped to textures.
</p>
</td></tr>
<tr><td><code id="texturemap_+3A_textures">textures</code></td>
<td>

<p>Optional. A vector of integer codes specifying the textures
to which the <code>inputs</code> will be mapped.
</p>
</td></tr>
<tr><td><code id="texturemap_+3A_...">...</code></td>
<td>

<p>Other graphics parameters such as <code>col</code>, <code>lwd</code>, <code>lty</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A texture map is an association between data values and graphical
textures. The command <code>texturemap</code> creates an object of class
<code>"texturemap"</code> that represents a texture map.
</p>
<p>Once a texture map has been created, it can be applied to any
suitable data to generate a texture plot of those data
using <code><a href="#topic+textureplot">textureplot</a></code>.
This makes it easy to ensure that
the <em>same</em> texture map is used in two different plots.
The texture map can also be plotted in its own right.
</p>
<p>The argument <code>inputs</code> should be a vector containing all the
possible data values (such as the levels of a factor) that are to be
mapped.
</p>
<p>The <code>textures</code> should be integer values between 1 and 8,
representing the eight possible textures
described in the help for <code><a href="#topic+add.texture">add.texture</a></code>.
The default is <code>textures = 1:n</code> where
<code>n</code> is the length of <code>inputs</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"texturemap"</code> representing the texture map.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+textureplot">textureplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   texturemap(letters[1:4], 2:5, col=1:4, lwd=2)
</code></pre>

<hr>
<h2 id='textureplot'>
Plot Image or Tessellation Using Texture Fill
</h2><span id='topic+textureplot'></span>

<h3>Description</h3>

<p>For a factor-valued pixel image, this command plots each level
of the factor using a different texture.
For a tessellation, each tile is plotted using a different texture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textureplot(x, ...,
            main, add=FALSE, clipwin=NULL, do.plot = TRUE,
            border=NULL, col = NULL, lwd = NULL, lty = NULL, spacing = NULL,
            textures=1:8,
            legend=TRUE,
            leg.side=c("right", "left", "bottom", "top"),
            legsep=0.1, legwid=0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textureplot_+3A_x">x</code></td>
<td>

<p>A tessellation (object of class <code>"tess"</code> or something
acceptable to <code><a href="#topic+as.tess">as.tess</a></code>) with at most 8 tiles,
or a pixel image (object of class <code>"im"</code> or something
acceptable to <code><a href="#topic+as.im">as.im</a></code>) whose pixel values
are a <code>factor</code> with at most 8 levels.
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="#topic+add.texture">add.texture</a></code>.
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_main">main</code></td>
<td>

<p>Character string giving a main title for the plot.
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether to draw on
the current plot (<code>add=TRUE</code>) or to initialise a new plot
(<code>add=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_clipwin">clipwin</code></td>
<td>

<p>Optional. A window (object of class <code>"owin"</code>).
Only this subset of the image will be displayed.
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical. Whether to actually do the plot.
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_border">border</code></td>
<td>

<p>Colour for drawing the boundaries between the different regions.
The default (<code>border=NULL</code>) means to use <code>par("fg")</code>.
Use <code>border=NA</code> to omit borders.
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_col">col</code></td>
<td>

<p>Numeric value or vector giving the colour or colours in which
the textures should be plotted.
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_lwd">lwd</code></td>
<td>

<p>Numeric value or vector giving the line width or widths to be used.
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_lty">lty</code></td>
<td>

<p>Numeric value or vector giving the line type or types to be used.
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_spacing">spacing</code></td>
<td>

<p>Numeric value or vector giving the <code>spacing</code> parameter
for the textures.
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_textures">textures</code></td>
<td>

<p>Textures to be used for each level. Either a texture map (object of
class <code>"texturemap"</code>) or a vector of integer codes
(to be interpreted by <code><a href="#topic+add.texture">add.texture</a></code>).
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_legend">legend</code></td>
<td>

<p>Logical. Whether to display an explanatory legend.
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_leg.side">leg.side</code></td>
<td>
<p>Position of legend relative to main plot.</p>
</td></tr>
<tr><td><code id="textureplot_+3A_legsep">legsep</code></td>
<td>

<p>Separation between legend and main plot, as a fraction
of the shortest side length of the main plot.
</p>
</td></tr>
<tr><td><code id="textureplot_+3A_legwid">legwid</code></td>
<td>

<p>Width (if vertical) or height (if horizontal) of the legend
as a fraction of the shortest side length of the main plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a tessellation, then each tile of the tessellation is
plotted and filled with a texture using <a href="#topic+add.texture">add.texture</a>.
</p>
<p>If <code>x</code> is a factor-valued pixel image, then
for each level of the factor, the algorithm finds the region where the image
takes this value, and fills the region with a texture using
<code><a href="#topic+add.texture">add.texture</a></code>.
</p>


<h3>Value</h3>

<p>(Invisible) A texture map (object of class <code>"texturemap"</code>)
associating a texture with each level of the factor.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im">im</a></code>, 
<code><a href="#topic+plot.im">plot.im</a></code>,
<code><a href="#topic+add.texture">add.texture</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  nd &lt;- if(interactive()) 128 else 32
  Z &lt;- setcov(owin(), dimyx=nd)
  Zcut &lt;- cut(Z, 3, labels=c("Lo", "Med", "Hi"))
  textureplot(Zcut)
  textureplot(dirichlet(runifrect(6)))
</code></pre>

<hr>
<h2 id='tile.areas'>Compute Areas of Tiles in a Tessellation</h2><span id='topic+tile.areas'></span>

<h3>Description</h3>

<p>Computes the area of each tile in a tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tile.areas(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tile.areas_+3A_x">x</code></td>
<td>
<p>A tessellation (object of class <code>"tess"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation is a collection of disjoint spatial regions
(called <em>tiles</em>) that fit together to form a larger spatial
region. See <code><a href="#topic+tess">tess</a></code>.
</p>
<p>This command computes the area of each of the tiles 
that make up the tessellation <code>x</code>.
The result is a numeric vector
in the same order as the tiles would be listed by <code>tiles(x)</code>.
</p>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+tiles">tiles</a></code>,
<code><a href="#topic+tilenames">tilenames</a></code>,
<code><a href="#topic+tiles.empty">tiles.empty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A &lt;- tess(xgrid=0:2,ygrid=0:2)
  tile.areas(A)
  v &lt;- as.im(function(x,y){factor(round(x^2 + y^2))}, W=owin())
  E &lt;- tess(image=v)
  tile.areas(E)
</code></pre>

<hr>
<h2 id='tileindex'>
Determine Which Tile Contains Each Given Point
</h2><span id='topic+tileindex'></span>

<h3>Description</h3>

<p>Given a tessellation and a list of spatial points,
determine which tile of the tessellation contains each of the
given points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tileindex(x, y, Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tileindex_+3A_x">x</code>, <code id="tileindex_+3A_y">y</code></td>
<td>

<p>Spatial coordinates.
Numeric vectors of equal length.
(Alternatively <code>y</code> may be missing
and <code>x</code> may be an object containing
spatial coordinates).
</p>
</td></tr>
<tr><td><code id="tileindex_+3A_z">Z</code></td>
<td>

<p>A tessellation (object of class <code>"tess"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determines which tile of the tessellation <code>Z</code>
contains each of the spatial points
with coordinates <code>(x[i],y[i])</code>.
</p>
<p>The result is a factor, of the same length as <code>x</code> and <code>y</code>,
indicating which tile contains each point. The levels of the factor
are the names of the tiles of <code>Z</code>.
Values are <code>NA</code> if the corresponding point lies outside the tessellation.
</p>


<h3>Value</h3>

<p>A factor, of the same length as <code>x</code> and <code>y</code>,
whose levels are the names of the tiles of <code>Z</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cut.ppp">cut.ppp</a></code> and <code><a href="#topic+split.ppp">split.ppp</a></code> to
divide up the points of a point pattern according to
a tessellation.
</p>
<p><code><a href="#topic+as.function.tess">as.function.tess</a></code> to create a function whose
value is the tile index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runifrect(7)
  V &lt;- dirichlet(X)
  tileindex(0.1, 0.4, V)
  tileindex(list(x=0.1, y=0.4), Z=V)
  tileindex(X, Z=V)
</code></pre>

<hr>
<h2 id='tilenames'>Names of Tiles in a Tessellation</h2><span id='topic+tilenames'></span><span id='topic+tilenames+3C-'></span><span id='topic+tilenames.tess'></span><span id='topic+tilenames+3C-.tess'></span>

<h3>Description</h3>

<p>Extract or Change the Names of the Tiles in a Tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tilenames(x)
tilenames(x) &lt;- value

## S3 method for class 'tess'
tilenames(x)

## S3 replacement method for class 'tess'
tilenames(x) &lt;- value

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tilenames_+3A_x">x</code></td>
<td>

<p>A tessellation 
(object of class <code>"tess"</code>).
</p>
</td></tr>
<tr><td><code id="tilenames_+3A_value">value</code></td>
<td>
<p>Character vector giving new names for the tiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract or change the names of the 
tiles that make up the tessellation <code>x</code>.
</p>
<p>If the tessellation is a regular grid, the tile names
cannot be changed.
</p>


<h3>Value</h3>

<p><code>tilenames</code> returns a character vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+tiles">tiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  D &lt;- dirichlet(runifrect(10))
  tilenames(D)
  tilenames(D) &lt;- paste("Cell", 1:10)
  tilenames(D)

</code></pre>

<hr>
<h2 id='tiles'>Extract List of Tiles in a Tessellation</h2><span id='topic+tiles'></span>

<h3>Description</h3>

<p>Extracts a list of the tiles that make up a tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiles(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tiles_+3A_x">x</code></td>
<td>
<p>A tessellation (object of class <code>"tess"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation is a collection of disjoint spatial regions
(called <em>tiles</em>) that fit together to form a larger spatial
region. See <code><a href="#topic+tess">tess</a></code>.
</p>
<p>The tiles that make up the tessellation <code>x</code>
are returned in a list.
</p>


<h3>Value</h3>

<p>A list of windows (objects of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+tilenames">tilenames</a></code>,
<code><a href="#topic+tile.areas">tile.areas</a></code>,
<code><a href="#topic+tiles.empty">tiles.empty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A &lt;- tess(xgrid=0:2,ygrid=0:2)
  tiles(A)
  v &lt;- as.im(function(x,y){factor(round(x^2 + y^2))}, W=owin())
  E &lt;- tess(image=v)
  tiles(E)
</code></pre>

<hr>
<h2 id='tiles.empty'>Check For Empty Tiles in a Tessellation</h2><span id='topic+tiles.empty'></span>

<h3>Description</h3>

<p>Checks whether each tile in a tessellation is empty or non-empty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiles.empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tiles.empty_+3A_x">x</code></td>
<td>
<p>A tessellation (object of class <code>"tess"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation is a collection of disjoint spatial regions
(called <em>tiles</em>) that fit together to form a larger spatial
region. See <code><a href="#topic+tess">tess</a></code>.
</p>
<p>It is possible for some tiles of a tessellation to be empty.
For example, this can happen
when the tessellation <code>x</code> is obtained by restricting
another tessellation <code>y</code> to a smaller spatial domain <code>w</code>.
</p>
<p>The function <code>tiles.empty</code> checks whether each tile is empty
or non-empty. The result is a logical vector,
with entries equal to <code>TRUE</code> when the corresponding tile is
empty. Results are given in the same order
as the tiles would be listed by <code>tiles(x)</code>.
</p>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+tiles">tiles</a></code>,
<code><a href="#topic+tilenames">tilenames</a></code>,
<code><a href="#topic+tile.areas">tile.areas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A &lt;- tess(xgrid=0:2,ygrid=0:2)
  tiles.empty(A)
  v &lt;- as.im(function(x,y){factor(round(x^2 + y^2))}, W=owin())
  E &lt;- tess(image=v)
  tiles.empty(E)
</code></pre>

<hr>
<h2 id='timed'>
Record the Computation Time
</h2><span id='topic+timed'></span>

<h3>Description</h3>

<p>Saves the result of a calculation as an object of class <code>"timed"</code>
which includes information about the time taken to compute the result.
The computation time is printed when the object is printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timed(x, ..., starttime = NULL, timetaken = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timed_+3A_x">x</code></td>
<td>

<p>An expression to be evaluated, or an object that has already
been evaluated.
</p>
</td></tr>
<tr><td><code id="timed_+3A_starttime">starttime</code></td>
<td>

<p>The time at which the computation is defined to have started.
The default is the current time.
Ignored if <code>timetaken</code> is given.
</p>
</td></tr>
<tr><td><code id="timed_+3A_timetaken">timetaken</code></td>
<td>

<p>The length of time taken to perform the computation.
The default is the time taken to evaluate <code>x</code>.
</p>
</td></tr>
<tr><td><code id="timed_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple mechanism for recording how long it takes to
perform complicated calculations (usually for the purposes of
reporting in a publication).
</p>
<p>If <code>x</code> is an expression to be evaluated, <code>timed(x)</code>
evaluates the expression and measures the
time taken to evaluate it.
The result is saved as an object of the class
<code>"timed"</code>. Printing this object displays the computation time.
</p>
<p>If <code>x</code> is an object which has already been computed,
then the time taken to compute the object can be specified either directly
by the argument <code>timetaken</code>, or indirectly by the argument
<code>starttime</code>.
</p>

<ul>
<li>
<p><code>timetaken</code> is the duration of time taken to perform
the computation. It should be the difference of two clock times
returned by <code><a href="base.html#topic+proc.time">proc.time</a></code>. Typically the user
sets <code>begin &lt;- proc.time()</code> before commencing the calculations,
then <code>end &lt;- proc.time()</code> after completing the calculations,
and then sets <code>timetaken &lt;- end - begin</code>.
</p>
</li>
<li>
<p><code>starttime</code> is the clock time at which the computation started.
It should be a value that was returned by <code><a href="base.html#topic+proc.time">proc.time</a></code>
at some earlier time when the calculations commenced.
When <code>timed</code> is called, the computation time will be taken
as the difference between the current clock time and
<code>starttime</code>. Typically the user
sets <code>begin &lt;- proc.time()</code> before commencing the calculations,
and when the calculations are completed, the user calls
<code>result &lt;- timed(result, starttime=begin)</code>. 
</p>
</li></ul>

<p>If the result of evaluating <code>x</code> belongs to other S3 classes,
then the result of <code>timed(x, ...)</code> also inherits these classes,
and printing the object will display the appropriate information for these
classes as well.
</p>


<h3>Value</h3>

<p>An object inheriting the class <code>"timed"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+timeTaken">timeTaken</a></code> to extract the time taken.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  timed(minnndist(cells))

  answer &lt;- timed(42, timetaken=4.1e17)
  answer
</code></pre>

<hr>
<h2 id='timeTaken'>
Extract the Total Computation Time
</h2><span id='topic+timeTaken'></span>

<h3>Description</h3>

<p>Given an object or objects that contain timing information
(reporting the amount of computer time taken to compute each object),
this function extracts the timing data and evaluates the total time taken.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeTaken(..., warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeTaken_+3A_...">...</code></td>
<td>

<p>One or more objects of class <code>"timed"</code> containing
timing data. 
</p>
</td></tr>
<tr><td><code id="timeTaken_+3A_warn">warn</code></td>
<td>

<p>Logical value indicating whether a warning should be issued if
some of the arguments do not contain timing information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"timed"</code> contains information on
the amount of computer time that was taken to compute the object.
See <code><a href="#topic+timed">timed</a></code>.
</p>
<p>This function extracts the timing information from one or more
such objects, and calculates the total time.
</p>


<h3>Value</h3>

<p>An object inheriting the class <code>"timed"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+timed">timed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A &lt;- timed(minnndist(bei))
  B &lt;- timed(minnndist(redwood))
  A
  B
  timeTaken(A,B)
</code></pre>

<hr>
<h2 id='transformquantiles'>
Transform the Quantiles
</h2><span id='topic+transformquantiles'></span>

<h3>Description</h3>

<p>Apply a transformation to the quantiles of a vector,
or to the quantiles of the pixel values in a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformquantiles(X, uniform = FALSE, reverse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformquantiles_+3A_x">X</code></td>
<td>

<p>A numeric vector, matrix, array, or a pixel image
(object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="transformquantiles_+3A_uniform">uniform</code></td>
<td>

<p>Logical value specifying whether each quantile value should be
replaced by the corresponding cumulative probability
(called <em>histogram equalisation</em>, <em>transformation to uniformity</em>
or <em>probability integral transformation</em>).
</p>
</td></tr>
<tr><td><code id="transformquantiles_+3A_reverse">reverse</code></td>
<td>

<p>Logical value specifying whether to swap the
upper and lower quantiles. 
</p>
</td></tr>
<tr><td><code id="transformquantiles_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>X</code> may be a vector, matrix,
array, or a pixel image (object of class <code>"im"</code>).
</p>
<p>The algorithm will first extract the entries or pixel values of
<code>X</code> as a vector, and sort the values into ascending order.
</p>
<p>If <code>uniform=TRUE</code>, the entries in this vector will be replaced by the
corresponding cumulative probabilities (the <code>k</code>th
smallest value will be replaced by the
number <code>(k-0.5)/n</code> where <code>n</code> is the total number of values).
</p>
<p>If <code>reverse=TRUE</code>, the resulting vector will be reversed
so that it is in descending order (so that the <code>k</code>th smallest
value will be swapped with the <code>k</code>th largest value).
</p>
<p>Finally the transformed values will be replaced into the original
positions in the vector, matrix, array, or pixel image.
</p>
<p>The case <code>uniform=TRUE, reverse=FALSE</code> is called
<em>transformation to uniformity</em>, the
<em>probability integral transformation</em>,
<em>histogram equalisation</em>, or <em>quantile transformation</em>.
The resulting values are uniformly distributed between 0 and 1;
a histogram of the values in <code>X</code> is flat.
</p>


<h3>Value</h3>

<p>Another object of the same type as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>To apply an arbitrary function <code>f</code> to the pixel values in an image,
use the idiom <code>X[] &lt;- f(X[])</code>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- c(3, 5, 1, 2, 4)
  transformquantiles(X, reverse=TRUE)
  transformquantiles(X, uniform=TRUE)
  transformquantiles(X, uniform=TRUE, reverse=TRUE)











</code></pre>

<hr>
<h2 id='transmat'>
Convert Pixel Array Between Different Conventions
</h2><span id='topic+transmat'></span>

<h3>Description</h3>

<p>This function provides a simple way to convert arrays of pixel data
between different display conventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transmat(m, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transmat_+3A_m">m</code></td>
<td>

<p>A matrix.
</p>
</td></tr>
<tr><td><code id="transmat_+3A_from">from</code>, <code id="transmat_+3A_to">to</code></td>
<td>

<p>Specifications of the spatial arrangement of the pixels.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pixel images are handled by many different software packages.
In virtually all of these, the pixel values are stored in a matrix,
and are accessed using the row and column indices of the matrix.
However, different pieces of software use different conventions for
mapping the matrix indices <code class="reqn">[i,j]</code> to the spatial coordinates
<code class="reqn">(x,y)</code>.
</p>

<ul>
<li>
<p>In the <em>Cartesian</em> convention, the first matrix index <code class="reqn">i</code>
is associated with the first Cartesian coordinate <code class="reqn">x</code>, 
and <code class="reqn">j</code> is associated with <code class="reqn">y</code>. This convention is used in
<code><a href="graphics.html#topic+image.default">image.default</a></code>.
</p>
</li>
<li>
<p>In the <em>European reading order</em> convention, a matrix is displayed
in the spatial coordinate system as it would be printed in a page of text:
<code class="reqn">i</code> is effectively associated with the negative <code class="reqn">y</code> coordinate, 
and <code class="reqn">j</code> is associated with <code class="reqn">x</code>. This convention is used in some
image file formats.
</p>
</li>
<li>
<p>In the <code>spatstat</code> convention, <code class="reqn">i</code>
is associated with the increasing <code class="reqn">y</code> coordinate, 
and <code class="reqn">j</code> is associated with <code class="reqn">x</code>. This is also used in some
image file formats.
</p>
</li></ul>

<p>To convert between these conventions, use the function
<code>transmat</code>. If a matrix <code>m</code> contains pixel image data
that is correctly displayed by software that uses the Cartesian convention,
and we wish to convert it to the European reading convention, we can type
<code>mm &lt;- transmat(m, from="Cartesian", to="European")</code>.
The transformed matrix <code>mm</code> will then be correctly displayed by
software that uses the European convention. 
</p>
<p>Each of the arguments <code>from</code> and <code>to</code> can be one of the names
<code>"Cartesian"</code>, <code>"European"</code> or <code>"spatstat"</code> (partially matched)
or it can be a list specifying another convention. For example
<code>to=list(x="-i", y="-j")!</code> specifies that rows of the output matrix 
are expected to be displayed as vertical columns in the plot, 
starting at the right side of the plot, as in the traditional 
Chinese, Japanese and Korean writing order.
</p>


<h3>Value</h3>

<p>Another matrix obtained by rearranging the entries of <code>m</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  opa &lt;- par(mfrow=c(1,2))
  # image in spatstat format
  Z &lt;- bei.extra$elev
  plot(Z, main="plot.im", ribbon=FALSE)
  m &lt;- as.matrix(Z)
  # convert matrix to format suitable for display by image.default
  Y &lt;- transmat(m, from="spatstat", to="Cartesian")
  image(Y, asp=0.5, main="image.default", axes=FALSE)
  par(opa)
</code></pre>

<hr>
<h2 id='triangulate.owin'>
Decompose Window into Triangles
</h2><span id='topic+triangulate.owin'></span>

<h3>Description</h3>

<p>Given a spatial window, this function decomposes the window
into disjoint triangles. 
The result is a tessellation of the window
in which each tile is a triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangulate.owin(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangulate.owin_+3A_w">W</code></td>
<td>
<p>Window (object of class <code>"owin"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The window <code>W</code> will be decomposed into disjoint triangles.
The result is a tessellation of <code>W</code> in which each tile is a
triangle. All triangle vertices lie on the boundary
of the original polygon.
</p>
<p>The window is first converted to a polygonal window using
<code><a href="#topic+as.polygonal">as.polygonal</a></code>. The vertices of the polygonal window
are extracted, and the Delaunay triangulation of these vertices
is computed using <code><a href="#topic+delaunay">delaunay</a></code>. Each Delaunay triangle
is intersected with the window: if the result is not a triangle, 
the triangulation procedure is applied recursively to this smaller polygon. 
</p>


<h3>Value</h3>

<p>Tessellation (object of class <code>"tess"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+delaunay">delaunay</a></code>,
<code><a href="#topic+as.polygonal">as.polygonal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(triangulate.owin(letterR))
</code></pre>

<hr>
<h2 id='trim.rectangle'>Cut margins from rectangle</h2><span id='topic+trim.rectangle'></span>

<h3>Description</h3>

<p>Trims a margin from a rectangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> trim.rectangle(W, xmargin=0, ymargin=xmargin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim.rectangle_+3A_w">W</code></td>
<td>

<p>A window (object of class <code>"owin"</code>).
Must be of type <code>"rectangle"</code>.
</p>
</td></tr>
<tr><td><code id="trim.rectangle_+3A_xmargin">xmargin</code></td>
<td>
<p>Width of horizontal margin to be trimmed.
A single nonnegative number, or a vector of length 2
indicating margins of unequal width at left and right.
</p>
</td></tr>
<tr><td><code id="trim.rectangle_+3A_ymargin">ymargin</code></td>
<td>
<p>Height of vertical margin to be trimmed.
A single nonnegative number, or a vector of length 2
indicating margins of unequal width at bottom and top.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple convenience function to trim off a
margin of specified width and height from each side of a
rectangular window. Unequal margins can also be trimmed.
</p>


<h3>Value</h3>

<p>Another object of class <code>"owin"</code> representing the
window after margins are trimmed.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grow.rectangle">grow.rectangle</a></code>,
<code><a href="#topic+erosion">erosion</a></code>,
<code><a href="#topic+owin.object">owin.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- square(10)
  # trim a margin of width 1 from all four sides
  square9 &lt;- trim.rectangle(w, 1)

  # trim margin of width 3 from the right side
  # and margin of height 4 from top edge.
  v &lt;- trim.rectangle(w, c(0,3), c(0,4))
</code></pre>

<hr>
<h2 id='tweak.colourmap'>
Change Colour Values in a Colour Map
</h2><span id='topic+tweak.colourmap'></span>

<h3>Description</h3>

<p>Assign new colour values to some of the entries in a colour map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tweak.colourmap(m, col, ..., inputs=NULL, range=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tweak.colourmap_+3A_m">m</code></td>
<td>

<p>A colour map (object of class <code>"colourmap"</code>).
</p>
</td></tr>
<tr><td><code id="tweak.colourmap_+3A_inputs">inputs</code></td>
<td>

<p>Input values to the colour map, to be assigned new colours.
Incompatible with <code>range</code>.
</p>
</td></tr>
<tr><td><code id="tweak.colourmap_+3A_range">range</code></td>
<td>

<p>Numeric vector of length 2 specifying a range of numerical values
which should be assigned a new colour.
Incompatible with <code>inputs</code>.
</p>
</td></tr>
<tr><td><code id="tweak.colourmap_+3A_col">col</code></td>
<td>

<p>Replacement colours for the specified <code>inputs</code> or
the specified <code>range</code> of values.
</p>
</td></tr>
<tr><td><code id="tweak.colourmap_+3A_...">...</code></td>
<td>
<p>Other arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function changes the colour map <code>m</code>
by assigning new colours to each of the
input values specified by <code>inputs</code>,
or by assigning a single new colour
to the range of input values specified by <code>range</code>.
</p>
<p>The modified colour map is returned.
</p>


<h3>Value</h3>

<p>Another colour map (object of class <code>"colourmap"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colourmap">colourmap</a></code>, 
<code><a href="#topic+interp.colourmap">interp.colourmap</a></code>, 
<code><a href="#topic+colouroutputs">colouroutputs</a></code>, 
<code><a href="#topic+colourtools">colourtools</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  co &lt;- colourmap(rainbow(32), range=c(0,1))
  plot(tweak.colourmap(co, inputs=c(0.5, 0.6), "white"))
  plot(tweak.colourmap(co, range=c(0.5,0.6), "white"))
</code></pre>

<hr>
<h2 id='union.quad'>Union of Data and Dummy Points</h2><span id='topic+union.quad'></span>

<h3>Description</h3>

<p>Combines the data and dummy points of a quadrature scheme
into a single point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> union.quad(Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="union.quad_+3A_q">Q</code></td>
<td>
<p>A quadrature scheme (an object of class <code>"quad"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>Q</code> should be a quadrature scheme (an object of class
<code>"quad"</code>, see <code><a href="#topic+quad.object">quad.object</a></code> for details).
</p>
<p>This function combines the data and dummy points of <code>Q</code>
into a single point pattern. If either the data or the dummy points
are marked, the result is a marked point pattern.
</p>
<p>The function <code><a href="#topic+as.ppp">as.ppp</a></code> will perform the same task.
</p>


<h3>Value</h3>

<p>A point pattern (of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quad.object">quad.object</a></code>,
<code><a href="#topic+as.ppp">as.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Q &lt;- quadscheme(simdat, default.dummy(simdat))
  U &lt;- union.quad(Q)
  # plot(U)

  # equivalent:
  U &lt;- as.ppp(Q)
</code></pre>

<hr>
<h2 id='unique.ppp'>Extract Unique Points from a Spatial Point Pattern</h2><span id='topic+unique.ppp'></span><span id='topic+unique.ppx'></span>

<h3>Description</h3>

<p>Removes any points that are identical to other points
in a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppp'
unique(x, ..., warn=FALSE)

 ## S3 method for class 'ppx'
unique(x, ..., warn=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique.ppp_+3A_x">x</code></td>
<td>

<p>A spatial point pattern
(object of class <code>"ppp"</code> or <code>"ppx"</code>).
</p>
</td></tr>
<tr><td><code id="unique.ppp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+duplicated.ppp">duplicated.ppp</a></code>
or <code><a href="base.html#topic+duplicated.data.frame">duplicated.data.frame</a></code>.
</p>
</td></tr>
<tr><td><code id="unique.ppp_+3A_warn">warn</code></td>
<td>

<p>Logical. If <code>TRUE</code>, issue a warning message if any
duplicated points were found.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic function <code>unique</code> for 
point pattern datasets (of class <code>"ppp"</code>, see
<code><a href="#topic+ppp.object">ppp.object</a></code>, or class <code>"ppx"</code>).
</p>
<p>This function removes duplicate points in <code>x</code>,
and returns a point pattern.
</p>
<p>Two points in a point pattern are deemed to be identical
if their <code class="reqn">x,y</code> coordinates are the same,
<em>and</em> their marks are the same (if they carry marks).
This is the default rule: see <code><a href="#topic+duplicated.ppp">duplicated.ppp</a></code>
for other options. 
</p>


<h3>Value</h3>

<p>Another point pattern object.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+duplicated.ppp">duplicated.ppp</a></code>,
<code><a href="#topic+multiplicity.ppp">multiplicity.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- ppp(c(1,1,0.5), c(2,2,1), window=square(3))
   unique(X)
   unique(X, rule="deldir")
</code></pre>

<hr>
<h2 id='uniquemap.default'>
Map Duplicate Entries to Unique Entries
</h2><span id='topic+uniquemap.default'></span><span id='topic+uniquemap.data.frame'></span><span id='topic+uniquemap.matrix'></span>

<h3>Description</h3>

<p>Determine whether entries in a vector
(or rows in a matrix or data frame)
are duplicated,
choose a unique representative for each set of duplicates,
and map the duplicates to the unique representative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
uniquemap(x)

## S3 method for class 'data.frame'
uniquemap(x)

## S3 method for class 'matrix'
uniquemap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniquemap.default_+3A_x">x</code></td>
<td>

<p>A vector, data frame or matrix,
or another type of data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+uniquemap">uniquemap</a></code> is generic, with methods
for point patterns, data frames, and a default method.
</p>
<p>The default method expects a vector. It determines whether any entries
of the vector <code>x</code> are duplicated,
and constructs a mapping of the indices of <code>x</code>
so that all duplicates are mapped to a unique representative index.
</p>
<p>The result is an integer vector <code>u</code> such that
<code>u[j] = i</code> if
the entries <code>x[i]</code> and <code>x[j]</code> are identical and
point <code>i</code> has been chosen as the unique representative.
The entry <code>u[i] = i</code> means either that point <code>i</code> is
unique, or that it has been chosen as the unique representative
of its equivalence class.
</p>
<p>The method for <code>data.frame</code> determines whether any rows of the
data frame <code>x</code> are duplicated, and constructs a mapping of the
row indices so that all duplicate rows are mapped to a unique
representative row.
</p>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uniquemap">uniquemap</a></code>,
<code><a href="#topic+uniquemap.ppp">uniquemap.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- c(3, 5, 2, 4, 2, 3)
  uniquemap(x)

  df &lt;- data.frame(A=x, B=42)
  uniquemap(df)

  z &lt;- cbind(x, 10-x)
  uniquemap(z)
</code></pre>

<hr>
<h2 id='uniquemap.ppp'>
Map Duplicate Entries to Unique Entries
</h2><span id='topic+uniquemap'></span><span id='topic+uniquemap.ppp'></span><span id='topic+uniquemap.lpp'></span><span id='topic+uniquemap.ppx'></span>

<h3>Description</h3>

<p>Determine whether points in a point pattern are duplicated,
choose a unique representative for each set of duplicates,
and map the duplicates to the unique representative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniquemap(x)

## S3 method for class 'ppp'
uniquemap(x)

## S3 method for class 'lpp'
uniquemap(x)

## S3 method for class 'ppx'
uniquemap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniquemap.ppp_+3A_x">x</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>, <code>"lpp"</code>,
<code>"pp3"</code> or <code>"ppx"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>uniquemap</code> is generic, with methods for
point patterns and data frames.
</p>
<p>This function determines whether any points of <code>x</code> are
duplicated, and constructs a mapping of the indices of <code>x</code>
so that all duplicates are mapped to a unique representative index.
</p>
<p>The result is an integer vector <code>u</code> such that
<code>u[j] = i</code> if
the points <code>x[i]</code> and <code>x[j]</code> are identical and
point <code>i</code> has been chosen as the unique representative.
The entry <code>u[i] = i</code> means either that point <code>i</code> is
unique, or that it has been chosen as the unique representative
of its equivalence class.
</p>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unique.ppp">unique.ppp</a></code>, <code><a href="#topic+duplicated.ppp">duplicated.ppp</a></code>,
<code><a href="#topic+uniquemap.default">uniquemap.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Y &lt;- runifrect(4)
  X &lt;- Y[c(1,2,3,4,2,1)]
  uniquemap(X)
</code></pre>

<hr>
<h2 id='unitname'>Name for Unit of Length</h2><span id='topic+unitname'></span><span id='topic+unitname.im'></span><span id='topic+unitname.owin'></span><span id='topic+unitname.ppp'></span><span id='topic+unitname.psp'></span><span id='topic+unitname.quad'></span><span id='topic+unitname.tess'></span><span id='topic+unitname+3C-'></span><span id='topic+unitname+3C-.im'></span><span id='topic+unitname+3C-.owin'></span><span id='topic+unitname+3C-.ppp'></span><span id='topic+unitname+3C-.psp'></span><span id='topic+unitname+3C-.quad'></span><span id='topic+unitname+3C-.tess'></span>

<h3>Description</h3>

<p>Inspect or change the name of the unit of length
in a spatial dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitname(x)
unitname(x) &lt;- value
## S3 method for class 'im'
unitname(x)
## S3 method for class 'owin'
unitname(x)
## S3 method for class 'ppp'
unitname(x)
## S3 method for class 'psp'
unitname(x)
## S3 method for class 'quad'
unitname(x)
## S3 method for class 'tess'
unitname(x)
## S3 replacement method for class 'im'
unitname(x) &lt;- value
## S3 replacement method for class 'owin'
unitname(x) &lt;- value
## S3 replacement method for class 'ppp'
unitname(x) &lt;- value
## S3 replacement method for class 'psp'
unitname(x) &lt;- value
## S3 replacement method for class 'quad'
unitname(x) &lt;- value
## S3 replacement method for class 'tess'
unitname(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitname_+3A_x">x</code></td>
<td>
<p>A spatial dataset.
Either a point pattern (object of class <code>"ppp"</code>),
a line segment pattern (object of class <code>"psp"</code>),
a window (object of class <code>"owin"</code>),
a pixel image (object of class <code>"im"</code>),
a tessellation (object of class <code>"tess"</code>),
a quadrature scheme (object of class <code>"quad"</code>),
or a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"slrm"</code>
or <code>"dppm"</code> or <code>"minconfit"</code>).
</p>
</td></tr>
<tr><td><code id="unitname_+3A_value">value</code></td>
<td>

<p>Name of the unit of length. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spatial datasets in the <span class="pkg">spatstat</span> package
may include the name of the unit of length. This name is used
when printing or plotting the dataset, and in some other
applications. 
</p>
<p><code>unitname(x)</code> extracts this name,
and <code>unitname(x) &lt;- value</code> sets the name to <code>value</code>.
</p>
<p>A valid name is either
</p>

<ul>
<li><p> a single character string
</p>
</li>
<li><p> a vector of two character strings giving the
singular and plural forms of the unit name
</p>
</li>
<li><p> a list of length 3, containing two character strings
giving the singular and plural forms of the basic unit,
and a number specifying the multiple of this unit.
</p>
</li></ul>

<p>Note that re-setting the name of the unit of length <em>does not</em>
affect the numerical values in <code>x</code>. It changes only the string
containing the name of the unit of length. To rescale the numerical
values, use <code><a href="#topic+rescale">rescale</a></code>.
</p>


<h3>Value</h3>

<p>The return value of <code>unitname</code> is an object of class <code>"unitname"</code>
containing the name of the unit of length in <code>x</code>. There are
methods for <code>print</code>, <code>summary</code>, <code>as.character</code>,
<code><a href="#topic+rescale">rescale</a></code> and <code><a href="#topic+compatible">compatible</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rescale">rescale</a></code>,
<code><a href="#topic+owin">owin</a></code>,
<code><a href="#topic+ppp">ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runifrect(20)

  # if the unit of length is 1 metre:
  unitname(X) &lt;- c("metre", "metres")

  # if the unit of length is 6 inches:
  unitname(X) &lt;- list("inch", "inches", 6)
</code></pre>

<hr>
<h2 id='unmark'>Remove Marks</h2><span id='topic+unmark'></span><span id='topic+unmark.ppp'></span><span id='topic+unmark.splitppp'></span><span id='topic+unmark.psp'></span><span id='topic+unmark.ppx'></span>

<h3>Description</h3>

<p>Remove the mark information from a spatial dataset. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> unmark(X)
 ## S3 method for class 'ppp'
unmark(X)
 ## S3 method for class 'splitppp'
unmark(X)
 ## S3 method for class 'psp'
unmark(X)
 ## S3 method for class 'ppx'
unmark(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmark_+3A_x">X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>),
a split point pattern (object of class <code>"splitppp"</code>),
a line segment pattern (object of class <code>"psp"</code>)
or a multidimensional space-time point pattern
(object of class <code>"ppx"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A &lsquo;mark&rsquo; is a value attached to each point in a spatial point pattern,
or attached to each line segment in a line segment pattern, etc.
</p>
<p>The function <code>unmark</code> is a simple way to 
remove the marks from such a dataset.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>X</code>
with any mark information deleted.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+psp.object">psp.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  hicks &lt;- lansing[lansing$marks == "hickory", ]

  # plot(hicks)  # still a marked point pattern, but only 1 value of marks
  # plot(unmark(hicks)) # unmarked
</code></pre>

<hr>
<h2 id='unnormdensity'>
Weighted kernel smoother
</h2><span id='topic+unnormdensity'></span>

<h3>Description</h3>

<p>An unnormalised version of kernel density estimation
where the weights are not required to sum to 1.
The weights may be positive, negative or zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnormdensity(x, ..., weights = NULL, defaults)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unnormdensity_+3A_x">x</code></td>
<td>

<p>Numeric vector of data
</p>
</td></tr>
<tr><td><code id="unnormdensity_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
Arguments must be <em>named</em>.
</p>
</td></tr></table>
<p>'
</p>
<table>
<tr><td><code id="unnormdensity_+3A_weights">weights</code></td>
<td>

<p>Optional numeric vector of weights for the data.
The default is equivalent to assuming a weight of 1 for each observation.
</p>
</td></tr>
<tr><td><code id="unnormdensity_+3A_defaults">defaults</code></td>
<td>

<p>Optional, named list of arguments passed to
<code><a href="stats.html#topic+density.default">density.default</a></code>. These will be overridden by
arguments in <code>...</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an alternative to the standard <span class="rlang"><b>R</b></span> kernel density estimation function
<code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
<p>The standard <code><a href="stats.html#topic+density.default">density.default</a></code>
requires the <code>weights</code> to be nonnegative numbers that add up to 1,
and returns a probability density (a function that integrates to 1).
</p>
<p>This function <code>unnormdensity</code> does not impose any requirement
on the <code>weights</code> except that they be finite. Individual weights may be
positive, negative or zero. The result is a function that does not
necessarily integrate to 1 and may be negative. The result is
the convolution of the kernel <code class="reqn">k</code> with the weighted data,
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \sum_i w_i k(x- x_i)
  </code>
</p>

<p>where <code class="reqn">x_i</code> are the data points and <code class="reqn">w_i</code> are the
weights.
</p>
<p>The argument <code>weights</code> should be a numeric vector of the same
length as <code>x</code>, or a single numeric value. The default is to
assume a weight of 1 for each observation in <code>x</code>.
</p>
<p>The algorithm first selects the kernel bandwidth by
applying <code><a href="stats.html#topic+density.default">density.default</a></code> to the data
<code>x</code> with normalised, positive weight vector
<code>w = abs(weights)/sum(abs(weights))</code> and
extracting the selected bandwidth.
Then the result is computed by applying
applying <code><a href="stats.html#topic+density.default">density.default</a></code> to <code>x</code> twice
using the normalised positive and negative parts of the weights.
</p>
<p>Note that the arguments <code>...</code> must be passed by name,
i.e. in the form (<code>name=value</code>). Arguments that do not match
an argument of <code><a href="stats.html#topic+density.default">density.default</a></code> will be ignored
<em>silently</em>.
</p>


<h3>Value</h3>

<p>Object of class <code>"density"</code> as described in
<code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>


<h3>Warning</h3>

<p>If <code>weights</code> is not specified,
the default is to assign a weight <code class="reqn">w_i=1</code> to each
observation <code class="reqn">x_i</code>.
</p>
<p>This is not the same behaviour as in <code><a href="stats.html#topic+density.default">density.default</a></code> which
effectively assumes a weight of <code class="reqn">1/n</code> for each observation <code class="reqn">x_i</code>
where <code>n=length(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- unnormdensity(1:3, weights=c(-1,0,1), bw=0.3)
  if(interactive()) plot(d)
</code></pre>

<hr>
<h2 id='unstack.ppp'>
Separate Multiple Columns of Marks 
</h2><span id='topic+unstack.ppp'></span><span id='topic+unstack.psp'></span><span id='topic+unstack.tess'></span>

<h3>Description</h3>

<p>Given a spatial pattern with several columns of marks,
take one column at a time, and return a list of spatial patterns
each having only one column of marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
unstack(x, ...)

## S3 method for class 'psp'
unstack(x, ...)

## S3 method for class 'tess'
unstack(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unstack.ppp_+3A_x">x</code></td>
<td>

<p>A spatial point pattern
(object of class <code>"ppp"</code>)
or a spatial pattern of line segments (object of class <code>"psp"</code>)
or a spatial tessellation (object of class <code>"tess"</code>).
</p>
</td></tr>
<tr><td><code id="unstack.ppp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions defined here are methods for the generic
<code><a href="utils.html#topic+unstack">unstack</a></code>. The functions expect a spatial object
<code>x</code> which has several columns of marks; they separate the columns,
and return a list of spatial objects, each having only one column of marks.
</p>
<p>If <code>x</code> has several columns of marks (i.e. <code>marks(x)</code> is a
matrix, data frame or hyperframe with several columns),
then <code>y &lt;- unstack(x)</code> is a list of spatial objects, each of the same
kind as <code>x</code>. The <code>j</code>th entry <code>y[[j]]</code> is equivalent to
<code>x</code> except that it only includes
the <code>j</code>th column of <code>marks(x)</code>.
</p>
<p>If <code>x</code> has no marks, or has only a single column of marks,
the result is a list consisting of one entry, which is <code>x</code>.
</p>


<h3>Value</h3>

<p>A list, of class <code>"solist"</code>, whose entries are objects of the
same type as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+unstack">unstack</a></code>
</p>
<p><code><a href="spatstat.model.html#topic+unstack.msr">unstack.msr</a></code>
</p>
<p>See also methods for the generic <code><a href="base.html#topic+split">split</a></code> such as
<code><a href="#topic+split.ppp">split.ppp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   finpines
   unstack(finpines)
</code></pre>

<hr>
<h2 id='unstack.solist'>
Unstack Each Spatial Object in a List of Objects
</h2><span id='topic+unstack.solist'></span><span id='topic+unstack.layered'></span>

<h3>Description</h3>

<p>Given a list of two-dimensional spatial objects,
apply 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'solist'
unstack(x, ...)

## S3 method for class 'layered'
unstack(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unstack.solist_+3A_x">x</code></td>
<td>

<p>An object of class <code>"solist"</code> or <code>"layered"</code>
representing a list of two-dimensional spatial objects.
</p>
</td></tr>
<tr><td><code id="unstack.solist_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions defined here are methods for the generic
<code><a href="utils.html#topic+unstack">unstack</a></code>. They expect the argument <code>x</code>
to be a list of spatial objects, of class <code>"solist"</code>
or <code>"layered"</code>.
</p>
<p>Each spatial object in the list <code>x</code>
will be unstacked by applying the relevant method for
<code><a href="utils.html#topic+unstack">unstack</a></code>. This means that
</p>

<ul>
<li><p> a marked point pattern with several columns of marks
will be separated into several point patterns, each having
a single column of marks
</p>
</li>
<li><p> a measure with <code class="reqn">k</code>-dimensional vector values
will be separated into <code class="reqn">k</code> measures with scalar values
</p>
</li></ul>

<p>The resulting unstacked objects
will be collected into a list of the same kind as <code>x</code>.
Typically the length of <code>unstack(x)</code> is greater than
the length of <code>x</code>.
</p>


<h3>Value</h3>

<p>A list belonging to the same class as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+unstack">unstack</a></code>
</p>
<p><code><a href="spatstat.model.html#topic+unstack.msr">unstack.msr</a></code>,
<code><a href="#topic+unstack.ppp">unstack.ppp</a></code>,
<code><a href="#topic+unstack.psp">unstack.psp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A &lt;- solist(finpines=finpines, cells=cells)
  A
  unstack(A)
  B &lt;- layered(fin=finpines, loc=unmark(finpines),
              plotargs=list(list(), list(pch=16)))
  B
  plot(B)
  unstack(B)
  plot(unstack(B))
</code></pre>

<hr>
<h2 id='update.symbolmap'>
Update a Graphics Symbol Map.
</h2><span id='topic+update.symbolmap'></span>

<h3>Description</h3>

<p>This command updates the <code>object</code> using the
arguments given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'symbolmap'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.symbolmap_+3A_object">object</code></td>
<td>

<p>Graphics symbol map (object of class <code>"symbolmap"</code>).
</p>
</td></tr>
<tr><td><code id="update.symbolmap_+3A_...">...</code></td>
<td>

<p>Additional or replacement arguments to <code><a href="#topic+symbolmap">symbolmap</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="stats.html#topic+update">update</a></code>
for the class <code>"symbolmap"</code> of graphics symbol maps.
It updates the <code>object</code> using the parameters given in the
extra arguments <code>...</code>.
</p>
<p>The extra arguments must be given in
the form <code>name=value</code> and must be recognisable to
<code><a href="#topic+symbolmap">symbolmap</a></code>. They override any parameters
of the same name in <code>object</code>.
</p>


<h3>Value</h3>

<p>Another object of class <code>"symbolmap"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+symbolmap">symbolmap</a></code> to create a graphics symbol map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  g &lt;- symbolmap(size=function(x) x/50)
  g
  update(g, range=c(0,1))
  update(g, size=42)
  update(g, shape="squares", range=c(0,1))
</code></pre>

<hr>
<h2 id='venn.tess'>
Tessellation Delimited by Several Sets
</h2><span id='topic+venn.tess'></span>

<h3>Description</h3>

<p>Given a list of windows, construct the tessellation
formed by all combinations of inclusion/exclusion of these
windows. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>venn.tess(..., window = NULL, labels=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="venn.tess_+3A_...">...</code></td>
<td>

<p>Sets which delimit the tessellation.
Any number of windows (objects of class <code>"owin"</code>)
or tessellations (objects of class <code>"tess"</code>).
</p>
</td></tr>
<tr><td><code id="venn.tess_+3A_window">window</code></td>
<td>

<p>Optional. The bounding window of the resulting tessellation.
If not specified, the default is the union of all the
arguments <code>...</code>.
</p>
</td></tr>
<tr><td><code id="venn.tess_+3A_labels">labels</code></td>
<td>

<p>Logical value, specifying whether to attach marks to each tile
that reveal how it was formed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>...</code> may be any number of windows.
This function constructs a tessellation, like a Venn diagram,
whose boundaries are made up of the boundaries of these sets.
Each tile of the tessellation is defined by one of the 
possible combinations in which each set is either included or
excluded. 
</p>
<p>If the arguments <code>...</code> are named, then the resulting tiles
will also have tile names, which identify the inclusion/exclusion
combinations defining each tile. See the Examples.
</p>
<p>If <code>labels=TRUE</code> then the tiles have marks which indicate the
inclusion/exclusion combinations defining each tile.
See the Examples.
</p>


<h3>Value</h3>

<p>A tessellation (object of class <code>"tess"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect.tess">intersect.tess</a></code>.
</p>
<p>To construct other kinds of tessellations, see
<code><a href="#topic+tess">tess</a></code>,
<code><a href="#topic+quadrats">quadrats</a></code>, <code><a href="#topic+hextess">hextess</a></code>,
<code><a href="#topic+polartess">polartess</a></code>,
<code><a href="#topic+dirichlet">dirichlet</a></code>, <code><a href="#topic+delaunay">delaunay</a></code>, <code><a href="#topic+quantess">quantess</a></code>
and <code><a href="spatstat.random.html#topic+rpoislinetess">rpoislinetess</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   A &lt;- square(1)
   B &lt;- square(c(-0.5,0.5))
   W &lt;- square(c(-1, 1.5))
   V &lt;- venn.tess(A=A, B=B, window=W)
   V
   plot(V, do.labels=TRUE)
   Vlab &lt;- venn.tess(A=A, B=B, window=W, labels=TRUE)
   marks(Vlab)
</code></pre>

<hr>
<h2 id='vertices'>Vertices of a Window</h2><span id='topic+vertices'></span><span id='topic+vertices.owin'></span>

<h3>Description</h3>

<p>Finds the vertices of a window, or similar object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> vertices(w)

 ## S3 method for class 'owin'
vertices(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertices_+3A_w">w</code></td>
<td>
<p>A window (object of class <code>"owin"</code>) or similar object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the vertices (&lsquo;corners&rsquo;) of a spatial window
or other object.
</p>
<p>For <code>vertices.owin</code>,
the argument <code>w</code> should be a window (an object of class
<code>"owin"</code>, see <code><a href="#topic+owin.object">owin.object</a></code> for details).
</p>
<p>If <code>w</code> is a rectangle, the coordinates of the
four corner points are returned.
</p>
<p>If <code>w</code> is a polygonal window (consisting of one or more
polygons), the coordinates of the vertices of all polygons are
returned.
</p>
<p>If <code>w</code> is a binary mask, then a &lsquo;boundary pixel&rsquo; is defined to be
a pixel inside the window
which has at least one neighbour outside the window. The coordinates
of the centres of all boundary pixels are returned.
</p>


<h3>Value</h3>

<p>A list with components <code>x</code> and <code>y</code> giving the coordinates
of the vertices.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owin.object">owin.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  vert &lt;- vertices(letterR)

  plot(letterR, main="Polygonal vertices")
  points(vert)
  plot(letterR, main="Boundary pixels")
  points(vertices(as.mask(letterR)))
</code></pre>

<hr>
<h2 id='volume'>Volume of an Object</h2><span id='topic+volume'></span>

<h3>Description</h3>

<p>Computes the volume of a spatial object such as a three-dimensional box. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> volume(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volume_+3A_x">x</code></td>
<td>

<p>An object whose volume will be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the volume of an object
such as a three-dimensional box. 
</p>
<p>The function <code>volume</code> is generic, with methods for
the classes <code>"box3"</code> (three-dimensional boxes) and
<code>"boxx"</code> (multi-dimensional boxes).
</p>
<p>There is also a method for the class <code>"owin"</code>
(two-dimensional windows), which is identical to
<code><a href="#topic+area.owin">area.owin</a></code>,
and a method for the class <code>"linnet"</code> of linear networks,
which returns the length of the network.
</p>


<h3>Value</h3>

<p>The numerical value of the volume of the object.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+area.owin">area.owin</a></code>,
<code><a href="#topic+volume.box3">volume.box3</a></code>,
<code><a href="#topic+volume.boxx">volume.boxx</a></code>.
</p>

<hr>
<h2 id='weighted.median'>
Weighted Median, Quantiles or Variance
</h2><span id='topic+weighted.median'></span><span id='topic+weighted.quantile'></span><span id='topic+weighted.var'></span>

<h3>Description</h3>

<p>Compute the median, quantiles or variance of a set of numbers which have
weights associated with them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.median(x, w, na.rm = TRUE, type=2, collapse=TRUE)

weighted.quantile(x, w, probs=seq(0,1,0.25), na.rm = TRUE, type=4, collapse=TRUE)

weighted.var(x, w, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.median_+3A_x">x</code></td>
<td>

<p>Data values.
A vector of numeric values, for which the median or quantiles are required.
</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_w">w</code></td>
<td>

<p>Weights.
A vector of nonnegative numbers, of the same length as <code>x</code>.
</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_probs">probs</code></td>
<td>

<p>Probabilities for which the quantiles should be computed.
A numeric vector of values between 0 and 1.
</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_na.rm">na.rm</code></td>
<td>

<p>Logical. Whether to ignore <code>NA</code> values.
</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_type">type</code></td>
<td>

<p>Integer specifying the rule for calculating the median or quantile,
corresponding to the rules available for
<code><a href="stats.html#topic+quantile">quantile</a></code>.
The only valid choices are <code>type=1</code>, <code>2</code> or <code>4</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_collapse">collapse</code></td>
<td>
<p>Research use only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>i</code>th observation <code>x[i]</code> is treated as having
a weight proportional to <code>w[i]</code>.
</p>
<p>The weighted median is a value <code>m</code>
such that the total weight of data less than or equal to <code>m</code>
is equal to half the total weight. More generally, the weighted quantile with
probability <code>p</code> is a value <code>q</code> 
such that the total weight of data less than or equal to <code>q</code>
is equal to <code>p</code> times the total weight.
</p>
<p>If there is no such value, then
</p>

<ul>
<li><p> if <code>type=1</code>, the next largest value is returned
(this is the right-continuous inverse of the left-continuous
cumulative distribution function);
</p>
</li>
<li><p> if <code>type=2</code>, the average of the two surrounding values is
returned (the average of the right-continuous and left-continuous
inverses);
</p>
</li>
<li><p> if <code>type=4</code>, linear interpolation is performed.
</p>
</li></ul>

<p>Note that the default rule for <code>weighted.median</code> is
<code>type=2</code>, consistent with the traditional definition of the median, 
while the default for <code>weighted.quantile</code> is <code>type=4</code>.
</p>


<h3>Value</h3>

<p>A numeric value or vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code>, <code><a href="stats.html#topic+median">median</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- 1:20
  w &lt;- runif(20)
  weighted.median(x, w)
  weighted.quantile(x, w)
  weighted.var(x, w)
</code></pre>

<hr>
<h2 id='where.max'>
Find Location of Maximum in a Pixel Image
</h2><span id='topic+where.max'></span><span id='topic+where.min'></span>

<h3>Description</h3>

<p>Finds the spatial location(s) where a given pixel image
attains its maximum or minimum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  where.max(x, first = TRUE)
  where.min(x, first = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="where.max_+3A_x">x</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>)
or data that can be converted to a pixel image by <code><a href="#topic+as.im">as.im</a></code>.
</p>
</td></tr>
<tr><td><code id="where.max_+3A_first">first</code></td>
<td>

<p>Logical value. If <code>TRUE</code> (the default), then only one location
will be returned. If <code>FALSE</code>, then all locations where the
maximum is achieved will be returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the spatial location or locations where the
pixel image <code>x</code> attains its maximum or minimum value.
The result is a point pattern giving the locations.
</p>
<p>If <code>first=TRUE</code> (the default), then only one location will
be returned, namely the location with the smallest <code class="reqn">y</code> coordinate
value which attains the maximum or minimum.
This behaviour is analogous to the functions
<code><a href="base.html#topic+which.min">which.min</a></code> and
<code><a href="base.html#topic+which.min">which.max</a></code>.
</p>
<p>If <code>first=FALSE</code>, then the function returns
the locations of all pixels where the
maximum (or minimum) value is attained. This could be a large
number of points.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Summary.im">Summary.im</a></code> for computing the minimum and maximum
of pixel values;
<code><a href="#topic+eval.im">eval.im</a></code> and <code><a href="#topic+Math.im">Math.im</a></code> for mathematical
expressions involving images; <code><a href="#topic+solutionset">solutionset</a></code> for finding
the set of pixels where a statement is true.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   D &lt;- distmap(letterR, invert=TRUE)
   plot(D)
   plot(where.max(D), add=TRUE, pch=16, cols="green")
</code></pre>

<hr>
<h2 id='whichhalfplane'>
Test Which Side of Infinite Line a Point Falls On
</h2><span id='topic+whichhalfplane'></span>

<h3>Description</h3>

<p>Given an infinite line
and a spatial point location,
determine which side of the line the point falls on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whichhalfplane(L, x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whichhalfplane_+3A_l">L</code></td>
<td>

<p>Object of class <code>"infline"</code> specifying one or more
infinite straight lines in two dimensions.
</p>
</td></tr>
<tr><td><code id="whichhalfplane_+3A_x">x</code>, <code id="whichhalfplane_+3A_y">y</code></td>
<td>

<p>Arguments acceptable to <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>
specifying the locations of the points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An infinite line <code class="reqn">L</code> divides the two-dimensional plane into
two half-planes. This function returns a matrix <code>M</code> of logical values
in which <code>M[i,j] = TRUE</code> if the <code>j</code>th spatial point
lies below or to the left of the <code>i</code>th line.
</p>


<h3>Value</h3>

<p>A logical matrix.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+infline">infline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  L &lt;- infline(p=runif(3), theta=runif(3, max=2*pi))
  X &lt;- runifrect(4)
  whichhalfplane(L, X)
</code></pre>

<hr>
<h2 id='whist'>
Weighted Histogram
</h2><span id='topic+whist'></span>

<h3>Description</h3>

<p>Computes the weighted histogram of a set of observations
with a given set of weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whist(x, breaks, weights = NULL, method=c("C", "interpreted"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whist_+3A_x">x</code></td>
<td>

<p>Numeric vector of observed values.
</p>
</td></tr>
<tr><td><code id="whist_+3A_breaks">breaks</code></td>
<td>

<p>Vector of breakpoints for the histogram. 
</p>
</td></tr>
<tr><td><code id="whist_+3A_weights">weights</code></td>
<td>

<p>Numeric vector of weights for the observed values. 
</p>
</td></tr>
<tr><td><code id="whist_+3A_method">method</code></td>
<td>

<p>Developer use only.
A character string specifying whether to use internal C code
(<code>method="C"</code>, the default) or interpreted <span class="rlang"><b>R</b></span> code
(<code>method="interpreted"</code>). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This low-level function computes (but does not plot) the weighted
histogram of a vector of observations <code>x</code> using a given
vector of <code>weights</code>.
</p>
<p>The arguments <code>x</code> and <code>weights</code> should be numeric vectors of
equal length. They may include <code>NA</code> or infinite values.
</p>
<p>The argument <code>breaks</code> should be a numeric vector whose entries
are strictly increasing. These values define the boundaries between the
successive histogram cells.
The breaks <em>do not</em> have to span the range
of the observations.
</p>
<p>There are <code>N-1</code> histogram cells, where <code>N = length(breaks)</code>.
An observation <code>x[i]</code> falls in the <code>j</code>th cell if
<code>breaks[j] &lt;= x[i] &lt; breaks[j+1]</code> (for <code>j &lt; N-1</code>)
or
<code>breaks[j] &lt;= x[i] &lt;= breaks[j+1]</code> (for <code>j = N-1</code>).
The weighted histogram value <code>h[j]</code> for the <code>j</code>th cell is
the sum of <code>weights[i]</code> for all observations <code>x[i]</code> that
fall in the cell.
</p>
<p>Note that, in contrast to the function <code><a href="graphics.html#topic+hist">hist</a></code>,
the function <code>whist</code> does not require the breakpoints to span the
range of the observations <code>x</code>. Values of <code>x</code> that fall outside the
range of <code>breaks</code> are handled separately; their total weight
is returned as an attribute of the histogram. 
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>N-1</code> containing the
histogram values, where <code>N = length(breaks)</code>.
</p>
<p>The return value also has attributes <code>"low"</code> and <code>"high"</code>
giving the total weight of all observations that are less than
the lowest breakpoint, or greater than the highest breakpoint,
respectively.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>with thanks to Peter Dalgaard.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(100)
  b &lt;- seq(-1,1,length=21)
  w &lt;- runif(100)
  whist(x,b,w)
</code></pre>

<hr>
<h2 id='Window'>
Extract or Change the Window of a Spatial Object
</h2><span id='topic+Window'></span><span id='topic+Window+3C-'></span><span id='topic+Window.ppp'></span><span id='topic+Window+3C-.ppp'></span><span id='topic+Window.quad'></span><span id='topic+Window+3C-.quad'></span><span id='topic+Window.psp'></span><span id='topic+Window+3C-.psp'></span><span id='topic+Window.im'></span><span id='topic+Window+3C-.im'></span>

<h3>Description</h3>

<p>Given a spatial object (such as a point pattern or pixel image)
in two dimensions, these functions extract or change the window
in which the object is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   Window(X, ...)

   Window(X, ...) &lt;- value

   ## S3 method for class 'ppp'
Window(X, ...)

   ## S3 replacement method for class 'ppp'
Window(X, ...) &lt;- value

   ## S3 method for class 'quad'
Window(X, ...)

   ## S3 replacement method for class 'quad'
Window(X, ...) &lt;- value

   ## S3 method for class 'psp'
Window(X, ...)

   ## S3 replacement method for class 'psp'
Window(X, ...) &lt;- value

   ## S3 method for class 'im'
Window(X, ...)

   ## S3 replacement method for class 'im'
Window(X, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Window_+3A_x">X</code></td>
<td>

<p>A spatial object such as a point pattern, line segment pattern
or pixel image.
</p>
</td></tr>
<tr><td><code id="Window_+3A_...">...</code></td>
<td>

<p>Extra arguments. They are ignored by all the methods listed here.
</p>
</td></tr>
<tr><td><code id="Window_+3A_value">value</code></td>
<td>

<p>Another window (object of class <code>"owin"</code>) to be used as the
window for <code>X</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>Window</code> and <code>Window&lt;-</code> are generic.
</p>
<p><code>Window(X)</code> extracts the spatial window in which <code>X</code> is
defined.
</p>
<p><code>Window(X) &lt;- W</code> changes the window in which <code>X</code> is defined
to the new window <code>W</code>, and <em>discards any data outside</em> <code>W</code>.
In particular:
</p>

<ul>
<li>
<p>If <code>X</code> is a point pattern (object of class <code>"ppp"</code>)
then <code>Window(X) &lt;- W</code> discards any points of <code>X</code> which
fall outside <code>W</code>.
</p>
</li>
<li>
<p>If <code>X</code> is a quadrature scheme (object of class <code>"quad"</code>)
then <code>Window(X) &lt;- W</code> discards any points of <code>X</code> which
fall outside <code>W</code>, and discards the corresponding quadrature
weights.
</p>
</li>
<li>
<p>If <code>X</code> is a line segment pattern (object of class
<code>"psp"</code>) then <code>Window(X) &lt;- W</code> clips the segments of <code>X</code>
to the boundaries of <code>W</code>.
</p>
</li>
<li>
<p>If <code>X</code> is a pixel image (object of class <code>"im"</code>)
then <code>Window(X) &lt;- W</code> has the effect that pixels
lying outside <code>W</code> are retained but their pixel values
are set to <code>NA</code>.
</p>
</li></ul>

<p>Many other classes of spatial object have a method
for <code>Window</code>, but not <code>Window&lt;-</code>.
See <code><a href="#topic+Window.tess">Window.tess</a></code>.
</p>


<h3>Value</h3>

<p>The result of <code>Window</code> is a window (object of class
<code>"owin"</code>).
</p>
<p>The result of <code>Window&lt;-</code> is the updated object <code>X</code>,
of the same class as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+Window.ppm">Window.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## point patterns
   Window(cells)
   X &lt;- demopat
   Window(X)
   Window(X) &lt;- as.rectangle(Window(X))

   ## line segment patterns
   X &lt;- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
   Window(X)
   Window(X) &lt;- square(0.5)

   ## images
   Z &lt;- setcov(owin())
   Window(Z)
   Window(Z) &lt;- square(0.5)
</code></pre>

<hr>
<h2 id='Window.tess'>Extract Window of Spatial Object</h2><span id='topic+Window.quadratcount'></span><span id='topic+Window.tess'></span><span id='topic+Window.layered'></span><span id='topic+Window.distfun'></span><span id='topic+Window.nnfun'></span><span id='topic+Window.funxy'></span>

<h3>Description</h3>

<p>Given a spatial object (such as a point pattern or pixel image)
in two dimensions, these functions extract the window
in which the object is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>


 ## S3 method for class 'quadratcount'
Window(X, ...)

 ## S3 method for class 'tess'
Window(X, ...)

 ## S3 method for class 'layered'
Window(X, ...)

 ## S3 method for class 'distfun'
Window(X, ...)

 ## S3 method for class 'nnfun'
Window(X, ...)

 ## S3 method for class 'funxy'
Window(X, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Window.tess_+3A_x">X</code></td>
<td>
<p>A spatial object.</p>
</td></tr>
<tr><td><code id="Window.tess_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic function <code><a href="#topic+Window">Window</a></code>
which extract the spatial window in which the object <code>X</code>
is defined. 
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code> (see <code><a href="#topic+owin.object">owin.object</a></code>)
specifying an observation window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Window">Window</a></code>,
<code><a href="#topic+Window.ppp">Window.ppp</a></code>,
<code><a href="#topic+Window.psp">Window.psp</a></code>.
</p>
<p><code><a href="#topic+owin.object">owin.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   A &lt;- quadratcount(cells, 4)
   Window(A)
</code></pre>

<hr>
<h2 id='with.hyperframe'>Evaluate an Expression in Each Row of a Hyperframe</h2><span id='topic+with.hyperframe'></span>

<h3>Description</h3>

<p>An expression, involving the names of columns in a hyperframe,
is evaluated separately for each row of the hyperframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyperframe'
with(data, expr, ...,
                         simplify = TRUE,
                         ee = NULL, enclos=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with.hyperframe_+3A_data">data</code></td>
<td>
<p>A hyperframe (object of class <code>"hyperframe"</code>)
containing data.
</p>
</td></tr>
<tr><td><code id="with.hyperframe_+3A_expr">expr</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> language expression to be evaluated.</p>
</td></tr>
<tr><td><code id="with.hyperframe_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="with.hyperframe_+3A_simplify">simplify</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the return value
will be simplified to a vector whenever possible.
</p>
</td></tr>
<tr><td><code id="with.hyperframe_+3A_ee">ee</code></td>
<td>

<p>Alternative form of <code>expr</code>, as an object of class
<code>"expression"</code>.
</p>
</td></tr>
<tr><td><code id="with.hyperframe_+3A_enclos">enclos</code></td>
<td>

<p>An environment in which to search for objects that are
not found in the hyperframe. Defaults to <code><a href="base.html#topic+parent.frame">parent.frame</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the expression <code>expr</code> in each row
of the hyperframe <code>data</code>. It is a method for the generic
function <code><a href="base.html#topic+with">with</a></code>.
</p>
<p>The argument <code>expr</code> should be an <span class="rlang"><b>R</b></span> language expression
in which each variable name is either the name of a column in the
hyperframe <code>data</code>, or the name of an object in the parent frame
(the environment in which <code>with</code> was called.)
The argument <code>ee</code> can be used as an alternative
to <code>expr</code> and should be an expression object (of
class <code>"expression"</code>).
</p>
<p>For each row of <code>data</code>, the expression will be evaluated
so that variables which are column names of <code>data</code> are
interpreted as the entries for those columns in the current row.
</p>
<p>For example, if a hyperframe <code>h</code> has columns
called <code>A</code> and <code>B</code>, then <code>with(h, A != B)</code> inspects
each row of <code>data</code> in turn,
tests whether the entries in columns <code>A</code> and <code>B</code> are
equal, and returns the <code class="reqn">n</code> logical values.
</p>


<h3>Value</h3>

<p>Normally a list of length
<code class="reqn">n</code> (where <code class="reqn">n</code> is the number of rows) containing the results
of evaluating the expression for each row. 
If <code>simplify=TRUE</code> and each result is a single atomic value,
then the result is a vector or factor 
containing the same values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyperframe">hyperframe</a></code>,
<code><a href="#topic+plot.hyperframe">plot.hyperframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # generate Poisson point patterns with intensities 10 to 100
   H &lt;- hyperframe(L=seq(10,100, by=10))
if(require(spatstat.random)) {
   X &lt;- with(H, rpoispp(L))
} else {
   X &lt;- with(H, runifrect(rpois(1, L)))
}
</code></pre>

<hr>
<h2 id='yardstick'>
Text, Arrow or Scale Bar in a Diagram
</h2><span id='topic+textstring'></span><span id='topic+onearrow'></span><span id='topic+yardstick'></span>

<h3>Description</h3>

<p>Create spatial objects that represent a text string,
an arrow, or a yardstick (scale bar).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textstring(x, y, txt = NULL, ...)

onearrow(x0, y0, x1, y1, txt = NULL, ...)

yardstick(x0, y0, x1, y1, txt = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yardstick_+3A_x">x</code>, <code id="yardstick_+3A_y">y</code></td>
<td>

<p>Coordinates where the text should be placed.
</p>
</td></tr>
<tr><td><code id="yardstick_+3A_x0">x0</code>, <code id="yardstick_+3A_y0">y0</code>, <code id="yardstick_+3A_x1">x1</code>, <code id="yardstick_+3A_y1">y1</code></td>
<td>

<p>Spatial coordinates of both ends of the arrow or yardstick.
Alternatively <code>x0</code> can be a point pattern (class <code>"ppp"</code>)
containing exactly two points, or a line segment pattern
(class <code>"psp"</code>) consisting of exactly one line segment.
</p>
</td></tr>
<tr><td><code id="yardstick_+3A_txt">txt</code></td>
<td>

<p>The text to be displayed beside the line segment.
Either a character string or an expression.
</p>
</td></tr>
<tr><td><code id="yardstick_+3A_...">...</code></td>
<td>

<p>Additional named arguments for plotting the object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These commands create objects that represent components of a
diagram:
</p>

<ul>
<li> <p><code>textstring</code> creates an object that represents a string
of text at a particular spatial location.
</p>
</li>
<li> <p><code>onearrow</code> creates an object that represents an arrow
between two locations.
</p>
</li>
<li> <p><code>yardstick</code> creates an object that represents
a scale bar: a line segment indicating the scale of the plot.
</p>
</li></ul>

<p>To display the relevant object, it should be plotted, using
<code>plot</code>. See the help files for the plot methods
<code><a href="#topic+plot.textstring">plot.textstring</a></code>, <code><a href="#topic+plot.onearrow">plot.onearrow</a></code>
and <code><a href="#topic+plot.yardstick">plot.yardstick</a></code>.
</p>
<p>These objects are designed to be included as components in a
<code><a href="#topic+layered">layered</a></code> object or a <code><a href="#topic+solist">solist</a></code>. This makes it
possible to build up a diagram consisting of many spatial objects,
and to annotate the diagram with arrows, text and so on, so that
ultimately the entire diagram is plotted using <code>plot</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"diagramobj"</code> which also
belongs to one of the special classes <code>"textstring"</code>, <code>"onearrow"</code>
or <code>"yardstick"</code>. There are methods for <code>plot</code>,
<code>print</code>, <code>"["</code> and <code><a href="#topic+shift">shift</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.textstring">plot.textstring</a></code>,
<code><a href="#topic+plot.onearrow">plot.onearrow</a></code>,
<code><a href="#topic+plot.yardstick">plot.yardstick</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rescale(swedishpines)
  plot(X, pch=16, main="")
  yd &lt;- yardstick(0,0,1,1, "diagonal")
  yy &lt;- yardstick(X[1:2])
  ys &lt;- yardstick(as.psp(list(xmid=4, ymid=0.5, length=1, angle=0),
                         window=Window(X)),
                  txt="1 m")
  ys
  plot(ys, angle=90)
  scalardilate(ys, 2)
</code></pre>

<hr>
<h2 id='zapsmall.im'>Rounding of Pixel Values</h2><span id='topic+zapsmall.im'></span>

<h3>Description</h3>

<p>Modifies a pixel image, identifying those pixels that have values 
very close to zero, and replacing the value by zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  zapsmall.im(x, digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zapsmall.im_+3A_x">x</code></td>
<td>
<p>Pixel image (object of class <code>"im"</code>).</p>
</td></tr>
<tr><td><code id="zapsmall.im_+3A_digits">digits</code></td>
<td>

<p>Argument passed to <code><a href="base.html#topic+zapsmall">zapsmall</a></code>
indicating the precision to be used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="base.html#topic+zapsmall">zapsmall</a></code> is applied to each pixel value
of the image <code>x</code>.
</p>


<h3>Value</h3>

<p>Another pixel image.
</p>


<h3>Author(s)</h3>

<p>Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+zapsmall">zapsmall</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Z &lt;- as.im(function(x,y) { exp(-40*(x+y)) }, square(1), dimyx=32)
  zapsmall.im(Z)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
