<!DOCTYPE html><html lang="en"><head><title>Help for package phenopix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phenopix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#phenopix-package'>
<p>A package for the processing of images of a vegetation cover</p></a></li>
<li><a href='#autoFilter'>
<p>A multiple-approach filtering procedure</p></a></li>
<li><a href='#bartlett2009'>
<p>Bartlett 2009 raw data</p></a></li>
<li><a href='#bartlett2009.filtered'>
<p>Bartlett 2009 dataset filtered</p></a></li>
<li><a href='#bartlett2009.fitted'>
<p>Bartlett 2009 dataset with computed fitting and uncertainty estimation</p></a></li>
<li><a href='#bartlett2009.processed'>
<p>Bartlett 2009 dataset processed by greenExplore function</p></a></li>
<li><a href='#BeckFit'>
<p>Fit a double logistic equation to a time series according to Beck et al. (2006)</p></a></li>
<li><a href='#combineUncertainty'>
<p>An evolution of <code>greenProcess</code> for the combination of uncertainty after processing</p></a></li>
<li><a href='#convert'>
<p>Convert in data.frame a <code>zoo</code> or <code>ts</code> object</p></a></li>
<li><a href='#convertROI'>
<p>Convert a region of interest object from the old structure to the new (phenopix &gt; 2.4)</p></a></li>
<li><a href='#CutSeason'>
<p>Cut time series by visual estimation</p></a></li>
<li><a href='#DrawMULTIROI'>
<p>Draw a Region of Interest</p></a></li>
<li><a href='#editExposure'>
<p>Change erroneous exposure values by hand</p></a></li>
<li><a href='#ElmoreFit'>
<p>Fit a double logistic equation to a time series according to Elmore et al. (2012)</p></a></li>
<li><a href='#extract'>
<p>Extract items from an object of class phenopix</p></a></li>
<li><a href='#extractDateFilename'>
<p>Estract dates from filenames</p></a></li>
<li><a href='#extractParameters'>
<p>Extract fitting parameters from a pixel-based analysis</p></a></li>
<li><a href='#extractVIs'>
<p>Extracts various vegetation indexes in a ROI</p></a></li>
<li><a href='#FitDoubleLogBeck'>
<p>A fit</p></a></li>
<li><a href='#FitDoubleLogElmore'>
<p>A fit</p></a></li>
<li><a href='#FitDoubleLogGu'>
<p>Fit a double logistic equation to a vector according to Gu et al. (2003)</p></a></li>
<li><a href='#FitDoubleLogKlHeavy'>
<p>Fit a double logistic function to a vector according to</p>
Klosterman et al. (2014)</a></li>
<li><a href='#FitDoubleLogKlLight'>
<p>Fit a double logistic equation to a vector according</p>
to Klosterman et al. (2014)</a></li>
<li><a href='#fitted.phenopix'>
<p>Returns predicted values from <code>phenopix</code> objects.</p></a></li>
<li><a href='#get.options'>
<p>Returns default options for function <code>autoFilter</code>.</p></a></li>
<li><a href='#getCoords'>
<p>Extract coordinates (in pixels) of the exposure string from a given JPEG image</p></a></li>
<li><a href='#getExposure'>
<p>Extract exposure from stardot (or similar) images</p></a></li>
<li><a href='#greenClusters'>
<p>Performs a cluster analysis on data in output from pixel-based phenology</p></a></li>
<li><a href='#greenExplore'>
<p>Explore all possible fitting and theshold methods from the package phenopix</p></a></li>
<li><a href='#greenProcess'>
<p>Fit a curve and extract thresholds from vegetation index time series</p></a></li>
<li><a href='#GuFit'>
<p>Fit a double logistic equation to a time series according to Gu et al. (2003)</p></a></li>
<li><a href='#hydrodoy'>
<p>Converts from and to hydrological day of year</p></a></li>
<li><a href='#KlostermanFit'>
<p>Fit a double logistic equation to a vector according to</p>
Klosterman et al. (2014)</a></li>
<li><a href='#matchExposure'>
<p>Match exposures retrieved from the header of (stardot) digital images</p></a></li>
<li><a href='#NDVI'>
<p>Compute NDVI from Phenocam color indices</p></a></li>
<li><a href='#PasteSeason'>
<p>A plotting facility for seasonal data with multiple cycles</p></a></li>
<li><a href='#PhenoBP'>
<p>Extract breakpoints on a time series</p></a></li>
<li><a href='#PhenoDeriv'>
<p>Extract phenophases from a fitted equation with method Derivatives</p></a></li>
<li><a href='#PhenoExtract'>
<p>Generic function for the extraction of phenological thresholds</p></a></li>
<li><a href='#PhenoGu'>
<p>Extract phenophases from a fitted equation according to Gu et al. 2009</p></a></li>
<li><a href='#PhenoKl'>
<p>Extract phenophases from a fitted equation according to Klosterman et al. 2014</p></a></li>
<li><a href='#PhenoPlot'>
<p>A plotting function for phenological thresholds</p></a></li>
<li><a href='#PhenoTrs'>
<p>A phenophase method based on fixed thresholds</p></a></li>
<li><a href='#plot.phenopix'>
<p>Plotting <code>phenopix</code> objects.</p></a></li>
<li><a href='#plotBP'>
<p>A function to plot results of function <code>PhenoBP</code></p></a></li>
<li><a href='#plotExplore'>
<p>Plot an object in output from the greenExplore function</p></a></li>
<li><a href='#plotSpatial'>
<p>Plot pixel-based analysis results from spatialGreen and extractParameters functions</p></a></li>
<li><a href='#plotSum'>
<p>A plotting facility to show the combination of uncertainty</p></a></li>
<li><a href='#plotVI'>
<p>Plot RGB DN, RGB indices and brightness</p></a></li>
<li><a href='#print.phenopix'>
<p>Print <code>phenopix</code> objects.</p></a></li>
<li><a href='#PrintROI'>
<p>Print an already drawn region of interest</p></a></li>
<li><a href='#resizeImage'>
<p>Resize an image (and a tROI) to a given pixel resolution</p></a></li>
<li><a href='#spatialFilter'>
<p>Explore all possible fitting and theshold methods from the package phenopix</p></a></li>
<li><a href='#spatialGreen'>
<p>Process pixel-based greenness indexes</p></a></li>
<li><a href='#SplineFit'>
<p>A function to fit a smoothed spline to Phenological Data</p></a></li>
<li><a href='#splitROI'>
<p>Splits a ROI into multiple subrois for spatial analysis</p></a></li>
<li><a href='#structureFolder'>
<p>Fast structuration of a folder for phenopix process</p></a></li>
<li><a href='#summarizePhases'>
<p>An evolution of <code>greenProcess</code> for the combination of uncertainty after processing</p></a></li>
<li><a href='#summary.phenopix'>
<p>Summary of <code>phenopix</code> objects.</p></a></li>
<li><a href='#trainOCR'>
<p>Extract a training dataset for OCR procedure</p></a></li>
<li><a href='#update.phenopix'>
<p>Update <code>phenopix</code> objects.</p></a></li>
<li><a href='#updateROI'>
<p>Update pixels included in a ROI of different pixel size</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Process Digital Images of a Vegetation Cover</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to process digital images, depict greenness index trajectories and extract relevant phenological stages. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>zoo, plyr, jpeg, stringr (&ge; 1.0.0), strucchange, parallel,
foreach, doParallel, iterators, gtools, raster, sp, terra (&ge;
1.8.21)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-13 15:59:06 UTC; gian</td>
</tr>
<tr>
<td>Author:</td>
<td>Gianluca Filippa [aut, cre],
  Edoardo Cremonese [aut],
  Mirco Migliavacca [aut],
  Marta Galvagno [aut],
  Matthias Folker [aut],
  Andrew D. Richardson [aut],
  Enrico Tomelleri [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-13 16:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='phenopix-package'>
A package for the processing of images of a vegetation cover   
</h2><span id='topic+phenopix-package'></span><span id='topic+phenopix'></span>

<h3>Description</h3>

<p>The package provides functions to process digital images, depict greennes index (and a number of other indices) 
trajectories and extract relevant phenological stages. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> phenopix</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.4.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-09</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package provides functions to process digital images, depict greennes index 
trajectories and extract relevant phenological stages. 
</p>
<p>The first step of the work is to set a region of interest on the images. The function <code>DrawROI</code> does the work. 
More than one ROI can be specified. 
</p>
<p>Second step is extracting information from the ROI(s). The function <code>extractVIs</code>
computes several vegetation indexes on image pixels falling within the ROI(s). 
The function works recursively within a folder so that all images can be processed 
and a time series of the computed indexes is extracted. A specific function 
<code>extractDateFilename</code> retrives a timestamp from the filename of the images. 
Time series of green, red and blue chromatic coordinates and brightenss are returned 
for each ROI of the image. 
</p>
<p>Third step is data filtering. The function <code>autoFilter</code> provides several filtering 
methods that can be used one at a time or in sequence.
</p>
<p>Fourth step is fitting a curve to the data. Five methods have been included in the package. 
The function <code>SplineFit</code> fits a smoothed cubic spline to the data. The remaining four 
methods are based on the optimization of different double logistic equations retrieved 
from the recent literature. An uncertainty calculation is provided, based on the residuals between
observed and predicted values. The variability in the residuals is used to generate random noise, 
that is then added to raw data in a bootstrap procedure. From this procedure an ensemble of equation 
parameters and/or of curves are generated. 
</p>
<p>Fifth step is the extraction of phenological thresholds. Five methods have been 
included to extract phenological dates. One is based on thresholds on the spline 
curve and one on breakpoints analysis, whereas other methods work on inflection points 
of the derivatives in various ways.  
Uncertainty on curve fitting is extended to threshold extraction, so that also 
for this step uncertainty is easily estimated.
</p>
<p>The package offers a variety of fittings and phenophase methods so to be as flexible 
as possible in order to apply to very different boreal (sofar) ecosystems, ranging 
from high latitude/altitude grasslands to tropical forests. 
Ecosystems that show multiple seasonal peaks can be splitted in subseason with 
the <code>CutSeason</code> function and processed separately. 
Dedicated plotting functions provide an easy way to look at fitting and thresholding 
with annotated graphs. 
The package is being tested on the PHENOCAM dataset (http://phenocam.sr.unh.edu/webcam/), 
and constantly debugged. 
</p>
<p>Detailed vignettes are available in my researchGate page, specifically a base vignette (https://www.researchgate.net/publication/289374477_phenopix_R_package_vignettes_13_base_vignette) and one dedicated to the spatial analysis (https://www.researchgate.net/publication/289355121_phenopix_R_package_vignettes_23_spatial_pixel-based_analysis_vignette). 
Here the user can find a walk-through to understand main functions, and procede step-by-step trough the ananlysis.
</p>
<p>Recent changes:
</p>
<p>As from version 2.4 the function drawROI was substituted by the function drawMULTIROI.
This implies few changes: the object roi.data is no longer structured as before. 
Now it is a list with an element for each ROI. For each element, there is an item 
named &lsquo;mask&rsquo; containing  the binary raster mask (dimensions and resolution as pixel 
size of the original image where ROI was drawn) and polygons (an object of class 
SpatialPolygons). The relevant changes in a processing chain that may occur due to 
these changes are partially accommodated with the new function <code>convertROI</code>. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa, Edoardo Cremonese, Mirco Migliavacca, Jeroen Staab 
</p>
<p>Maintainer: Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Gu L, Post WM, Baldocchi D, Black TA, Suyker AE, Verma SB, Vesala T, 
Wofsy SC. (2009) Characterizing the Seasonal Dynamics of Plant Community 
Photosynthesis Across a Range of Vegetation Types. In: Phenology of Ecosystem 
Processes (Ed: Noormets A, Springer New York), pp 35-58. 
</p>
<p>Klosterman ST, Hufkens K, Gray JM, Melaas E, Sonnentag O, Lavine I, Mitchell L, 
Norman R, Friedl MA, Richardson A D (2014) Evaluating remote sensing of deciduous 
forest phenology at multiple spatial scales using PhenoCam imagery, Biogeosciences, 
11, 4305-4320, doi:10.5194/bg-11-4305-2014.
</p>
<p>Migliavacca, M., Galvagno, M., Cremonese, E., Rossini, M., Meroni, M., Sonnentag, O., Cogliati, S., Manca, G., Diotri, F., Busetto, L., Cescatti, A., Colombo, R., Fava, F., Morra di Cella, U., Pari, E., Siniscalco, C., Richardson, A.D., 2011. Using digital repeat photography and eddy covariance data to model grassland phenology and photosynthetic CO2 uptake. Agric. Forest Meteorol. 151, 1325-1337.
</p>
<p>Papale, D., Reichstein, M., Aubinet, M., Canfora, E., Bernhofer, C., Kutsch, W., Longdoz, B., Rambal, S., Valentini, R., Vesala, T., Yakir, D., 2006. Towards a standardized processing of Net Ecosystem Exchange measured with eddy covariance technique: algorithms and uncertainty estimation. Biogeosciences 3, 571-583.
</p>
<p>Sonnentag, O., Hufkens, K., Teshera-Sterne, C., Young, A.M., Friedl, M., Braswell, B.H., Milliman, T., O'Keefe, J., Richardson, A.D., 2012. Digital repeat photography for phenological research in forest ecosystems. Agric. Forest Meteorol. 152, 159-177.
</p>
<p>Zhang X, Friedl MA, Schaaf CB, Strahler AH, Hodges JCF, Gao F, Reed BC, Huete A (2003) 
Monitoring vegetation phenology using MODIS, Remote Sens. Environ., 84, 471-475.
</p>


<h3>See Also</h3>

<p>greenbrown.r-forge.r-project.org
</p>

<hr>
<h2 id='autoFilter'>
A multiple-approach filtering procedure
</h2><span id='topic+autoFilter'></span>

<h3>Description</h3>

<p>5 different filters can be applied to raw green coordinate
values. Filters can be applied alone or in sequence, in this case order
matters. Available filters are 'night', 'max', 'spline', 'blue' and
'mad'. See details for further explaination. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoFilter(data, dn=c('ri.av', 'gi.av', 'bi.av'), raw.dn = FALSE, 
  brt = 'bri.av', na.fill = TRUE, filter = c("night", "spline", "max"), 
  filter.options = NULL, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoFilter_+3A_data">data</code></td>
<td>

<p>A data.frame containing a POSIX vector 
</p>
</td></tr>
<tr><td><code id="autoFilter_+3A_dn">dn</code></td>
<td>

<p>The column positions or colnames for red, green and blue digital numbers, in this order. The default is 
suited to work with a dataframe in output from <code>ExtractVIs</code>
</p>
</td></tr>
<tr><td><code id="autoFilter_+3A_raw.dn">raw.dn</code></td>
<td>

<p>If TRUE you must provide raw digital numbers (range 0-255), for which position or colnames must be
provided in <code>dn</code>. In this case gcc is calculated as g/brt where g is raw green digital number 
and brt is brightness computed as the sum of r + g + b. 
If FALSE (default) the function expects that in dn you provide colnames or col positions of relative
red green and blue, respectively. 
</p>
</td></tr>
<tr><td><code id="autoFilter_+3A_brt">brt</code></td>
<td>

<p>The column position for brightness. Used in the filtering procedure. If you provide
raw digital numbers and brt=NULL, it will be calculated from raw red green and blue dn.   
</p>
</td></tr>
<tr><td><code id="autoFilter_+3A_na.fill">na.fill</code></td>
<td>

<p>If FALSE, discarded data are filled with NA. If TRUE a call to <code>na.approx</code> from 
package zoo linearly interpolates between existing records up to a gap of 10 missing values. 
</p>
</td></tr>
<tr><td><code id="autoFilter_+3A_filter">filter</code></td>
<td>

<p>Character names for filters. Chose one (or more) between 'night',
'max', 'spline', 'blue' and 'mad'. The order provided in this argument
determines the order of application of filters. See details for further information on filters.
</p>
</td></tr>
<tr><td><code id="autoFilter_+3A_filter.options">filter.options</code></td>
<td>

<p>If NULL filter.options defaults to set values, otherwise they must be
specified in a named list. Filter options are designed to work with a wide range of data, 
the user must change them with caution. See <code>get.options</code> to change default filter options.  
</p>
</td></tr>
<tr><td><code id="autoFilter_+3A_plot">plot</code></td>
<td>

<p>If TRUE a dignostic plot of the different filtering effects is
returned. 
</p>
</td></tr>
<tr><td><code id="autoFilter_+3A_...">...</code></td>
<td>

<p>Further options, currenlty not used 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a data.frame with raw digital numbers of red green and blue found in <code>dn</code>, 
converts them in the respective coordinates (example for red: rcc=r/(r+g+b)). If <code>raw.dn</code>=FALSE, 
the function takes directly color's chromatic coordinates provided in <code>dn</code>, i.e. realtive values. 
In the dataframe a POSIX vector must be provided, which will subsequently be converted in numeric 
day of year (doy). Afterwards, the filtering procedure starts.  
Filters are applied in the order provided in <code>filter</code>.
Night filter removes records under a certain gcc
value (as specified in filter.options). The default is 0.2.
Blue filter is intended to remove bad images and is very aggressive.
It is suggested only for very low quality images. The daily mean and standard deviation 
on bcc is computed and a sd threshold is computed as the quantile of standard 
deviations with prob = 0.05. An envelope is then computed as daily mean bcc +/- 
the calculated threshold. Raw data outside this envelope are discarded. 
The mad filter is applied according to Papale et al 2006 (biogeosciences) created 
to remove spikes on FLUXNET data. 
The max filter is based on Sonnentag et al (2012) and computes the 90% of the 
curve based on a three days moving window. 
The spline filter is based on Migliavacca et al (2011).  
Default values in function's arguments are suited to data in output from the function
<code>ExtractVIs</code>. Note that computing relative greenness index within the function <code>autoFilter</code>, i.e., 
providing raw dn and with <code>raw.dn</code> set to TRUE will produce slightly different values than 'gi.av' in output 
from <code>ExtractVIs</code>. This results from the difference between computing pixel based brightness (and color indices) 
or ROI average brightness as it happens in <code>autoFilter</code> with raw.dn = TRUE.  
</p>


<h3>Value</h3>

<p>A multivariate zoo object with raw data and a column with gcc values after
filtering. Colnames for filtered data have the same name as the
applied filter. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Sonnentag et al. 
</p>
<p>Migliavacca et al. 
</p>
<p>Papale et al.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009)
## with raw.dn ==TRUE and column position for chromatic coordinates
par(mfrow=c(3,1), oma=c(5,4,4,2), mar=rep(0,4))
filtered.data &lt;- autoFilter(bartlett2009, dn=c(5:7), 
  filter=c('night', 'spline', 'max'),
  filter.options=NULL, raw.dn=TRUE)
## same as before but returning unfilled data 
filtered.data &lt;- autoFilter(bartlett2009, dn=c(5:7), 
  filter=c('night', 'spline', 'max'),
  filter.options=NULL, na.fill=FALSE, raw.dn=TRUE)
## all filters in action (check the plot)
filtered.data &lt;- autoFilter(bartlett2009, dn=c(5:7), 
  filter=c('night','blue', 'mad','spline', 'max'),
  filter.options=NULL, raw.dn=TRUE)
## check filter names
names(filtered.data)

## End(Not run)
</code></pre>

<hr>
<h2 id='bartlett2009'>
Bartlett 2009 raw data
</h2><span id='topic+bartlett2009'></span>

<h3>Description</h3>

<p>Raw data from the PHENOCAM database, site: Bartlett, year:2009. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bartlett2009)</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(bartlett2009)
## maybe str(bartlett2009) ; plot(bartlett2009) ...
</code></pre>

<hr>
<h2 id='bartlett2009.filtered'>
Bartlett 2009 dataset filtered
</h2><span id='topic+bartlett2009.filtered'></span>

<h3>Description</h3>

<p>A yearly time series of filtered green chromatic coordinates 
from the PHENOCAM database, site Bartlett, year 2009 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bartlett2009.filtered)</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(bartlett2009.filtered)
## maybe str(bartlett2009.filtered) ; plot(bartlett2009.filtered) ...
</code></pre>

<hr>
<h2 id='bartlett2009.fitted'>
Bartlett 2009 dataset with computed fitting and uncertainty estimation
</h2><span id='topic+bartlett2009.fitted'></span>

<h3>Description</h3>

<p>A list of predicted values, equation parameters and their uncertainty from 
fitting the Klosterman equation to Bartlett 2009 filtered data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bartlett2009.fitted)</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(bartlett2009.fitted)
## maybe str(bartlett2009.fitted) ; plot(bartlett2009.fitted) ...
</code></pre>

<hr>
<h2 id='bartlett2009.processed'>
Bartlett 2009 dataset processed by greenExplore function 
</h2><span id='topic+bartlett2009.processed'></span>

<h3>Description</h3>

<p>A complex list accessible via multiple generic functions like <code>plot</code>, <code>print</code>, 
<code>summary</code>, <code>extract</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bartlett2009.processed)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.processed)
plot(bartlett2009.processed)
## maybe str(bartlett2009.fitted) ; plot(bartlett2009.fitted) ...

## End(Not run)
</code></pre>

<hr>
<h2 id='BeckFit'>
Fit a double logistic equation to a time series according to Beck et al. (2006)  
</h2><span id='topic+BeckFit'></span>

<h3>Description</h3>

<p>This function fits a double logistic curve to observed values using the
function as described in Beck et al. (2006) (equation 3). It can also
provide and uncertainty estimation. Rather internal function. 
See <code>greenProcess</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BeckFit(ts, uncert = FALSE, nrep = 100, ncores='all', 
sf=quantile(ts, probs=c(0.05, 0.95), na.rm=TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BeckFit_+3A_ts">ts</code></td>
<td>

<p>A ts or zoo object with gcc data. index(ts) must be numeric days of
year (doys) or a POSIXct vector
</p>
</td></tr>
<tr><td><code id="BeckFit_+3A_uncert">uncert</code></td>
<td>

<p>Should uncertainty be estimated?
</p>
</td></tr>
<tr><td><code id="BeckFit_+3A_nrep">nrep</code></td>
<td>

<p>Number of relications to estimate uncertainty, defaults to 1000. 
</p>
</td></tr>
<tr><td><code id="BeckFit_+3A_ncores">ncores</code></td>
<td>

<p>Number of processors to be used in parallel computation, defaults to 'all' which will accidentally slow down any other activity on your computer. Otherwise set the number of processors you want to use in parallelization. 
</p>
</td></tr>
<tr><td><code id="BeckFit_+3A_sf">sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code><a href="#topic+greenProcess">greenProcess</a></code> sf is automatically calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates parameters of the double logistic equation from
Beck et al. 2006 and provides an uncertainty estimation. Parameters are
estimated by a call to the function <code><a href="#topic+FitDoubleLogBeck">FitDoubleLogBeck</a></code> from the 
<code>greenbrown</code> package. Uncertainty is computed by adding noise to the raw
data and by estimating again the parameters. Noise is added according
to the standard deviation of the residuals (fitted - observed).
The procedure is repeated nrep times.  
</p>


<h3>Value</h3>

<p>A list containing the following items. 
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>A list as returned by the function FitDoubleLogBeck</p>
</td></tr>
<tr><td><code>uncertainty</code></td>
<td>
<p>A list containing a zoo data.frame with the
uncertainty predicted values, and a dataframe containing the
respective uncertainty curve parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Beck, P.S.A., C. Atzberger, K.A. Hodga, B. Johansen, A. Skidmore (2006): 
Improved monitoring of vegetation dynamics at very high latitudes: A new 
method using MODIS NDVI. - Remote Sensing of Environment 100:321-334.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(zoo)
data(bartlett2009.filtered)
## fit without uncertainty estimation
fitted.beck &lt;- BeckFit(bartlett2009.filtered)
days &lt;- as.numeric(format(index(bartlett2009.filtered), '
plot(days, bartlett2009.filtered)
lines(fitted.beck$fit$predicted, col='red')
## look at fitting parameters
fitted.beck$fit$params
## look at fitting equation, where t is time
fitted.beck$fit$formula

## End(Not run)
</code></pre>

<hr>
<h2 id='combineUncertainty'>
An evolution of <code><a href="#topic+greenProcess">greenProcess</a></code> for the combination of uncertainty after processing 
</h2><span id='topic+combineUncertainty'></span>

<h3>Description</h3>

<p>The <code>combineUncertainty</code> uses <code><a href="#topic+greenProcess">greenProcess</a></code> to fit all available double logistic equations in the phenopix package and extracts thresholds with all available methods. Then uncertainties can be combined and returned by using <code><a href="#topic+summarizePhases">summarizePhases</a></code> and plotted with <code><a href="#topic+plotSum">plotSum</a></code>. 
See <code><a href="#topic+greenProcess">greenProcess</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineUncertainty(ts, which='all', nrep=50, ncores='all')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combineUncertainty_+3A_ts">ts</code></td>
<td>

<p>A ts or zoo object with gcc data. index(ts) must be numeric days of
year (doys) or a POSIXct vector
</p>
</td></tr>
<tr><td><code id="combineUncertainty_+3A_which">which</code></td>
<td>

<p>It can be 'all' (default) and all 4 double logistic fits will be calculated (beck, elmore, elosterman, gu), or a vector of subsets of the four fits
</p>
</td></tr>
<tr><td><code id="combineUncertainty_+3A_nrep">nrep</code></td>
<td>

<p>Number of relications to estimate uncertainty for each single fitting, defaults to 50. 
</p>
</td></tr>
<tr><td><code id="combineUncertainty_+3A_ncores">ncores</code></td>
<td>

<p>Number of processors to be used in parallel computation, defaults to 'all' which will accidentally slow down any other activity on your computer. Otherwise set the number of processors you want to use in parallelization. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code><a href="#topic+greenProcess">greenProcess</a></code> to fit all available double logistic equations in the phenopix package and extracts thresholds with all available methods. Then uncertainties can be combined and returned by using <code><a href="#topic+summarizePhases">summarizePhases</a></code> and plotted with <code><a href="#topic+plotSum">plotSum</a></code>. 
See <code><a href="#topic+greenProcess">greenProcess</a></code>, <code><a href="#topic+summarizePhases">summarizePhases</a></code>, <code><a href="#topic+plotSum">plotSum</a></code>. This function uses a modellistic approach to combine all uncertainties from all available phenopix fittings, as to get an ensemble of phases with different methods, without necessarily choosing any of them. 
</p>


<h3>Value</h3>

<p>A named list with dataframes for each phenophase method with all replication for each of the included fitting methods. These data can then be combined with the companion functions <code><a href="#topic+summarizePhases">summarizePhases</a></code> and <code><a href="#topic+plotSum">plotSum</a></code>. See examples for details. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  require(zoo) 
  data(bartlett2009.filtered)
  combined.fit &lt;- combineUncertainty(na.approx(bartlett2009.filtered), nrep=100)
# 100 replications for each fitting
  names(combined.fit) # a dataframe for each phenoMethod + a list with all fittings
  fit.summary &lt;- summarizePhases(combined.fit, across.methods=TRUE)
## again a list with one element for each fitting method + two additional items 
## if across.methods is TRUE, which combines gu + klosterman phenophase methods 
## in a single method, and the same happens for trs and derivatives
  plotSum(bartlett2009.filtered, fit.summary, which='klosterman')
## a plot with original timeseries + phenophases and their uncertainty
  
## End(Not run)
  </code></pre>

<hr>
<h2 id='convert'>
Convert in data.frame a <code>zoo</code> or <code>ts</code> object  
</h2><span id='topic+convert'></span>

<h3>Description</h3>

<p>This function converts an object of class <code>ts</code> or <code>zoo</code> in a data.frame with a column 
named <code>time</code> retrieved from <code>index(x)</code>. It is designed for those unfamiliar with time series
objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert(x, year=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_+3A_x">x</code></td>
<td>

<p>An object of class <code>ts</code> or <code>zoo</code>
</p>
</td></tr>
<tr><td><code id="convert_+3A_year">year</code></td>
<td>

<p>A vector of length one with year of observation. If provided, a column with time in POSIX format is also returned
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>data.frame</code> is returned with a column <code>doy</code> and optionally <code>time</code> at the end of the table.  
</p>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='convertROI'>
Convert a region of interest object from the old structure to the new (phenopix &gt; 2.4)
</h2><span id='topic+convertROI'></span>

<h3>Description</h3>

<p>This function allows to convert the <code>roi.data</code> stored  in the <code>roi.data.Rdata</code> object built with 
<code>phenopix</code> older than version 2.4 into the new structure better described in the details section. The 
changed was needed because a new method for drawing a region of interest was conceived, which includes the 
possibility to draw multiple polygons for a single ROI. The new function that does the job is 
<code><a href="#topic+DrawMULTIROI">DrawMULTIROI</a></code>, which fully substitutes the old <code>DrawROI</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertROI(path_img_ref, path_ROIs, file.type='.jpg')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertROI_+3A_path_img_ref">path_img_ref</code></td>
<td>

<p>Path in your folder for the reference image
</p>
</td></tr>
<tr><td><code id="convertROI_+3A_path_rois">path_ROIs</code></td>
<td>

<p>Path where <code>roi.data</code> object created with <code>phenopix</code> &lt; 2.4 was built.
</p>
</td></tr>
<tr><td><code id="convertROI_+3A_file.type">file.type</code></td>
<td>

<p>It must match the syntax of your file extension (e.g. .jpg, .JPG, .JPEG). Multiple types are allowed by concatenation with c().  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to convert the <code>roi.data</code> stored  in the <code>roi.data.Rdata</code> object built with 
phenopix older than version 2.4 into the new structure better described in the details section. The changed 
was needed because a new method for drawing a region of interest was conceived, which includes the possibility 
of drawing multiple polygons for a single ROI. There is a second reason why DrawROI had to disappear: it 
included C++ code from the package SDMTools which is currently orphaned.  The new function that allows multiple 
polygons in a single ROI is <code>DrawMULTIROI</code>, which fully substitutes the old <code>DrawROI</code>.
</p>


<h3>Value</h3>

<p>A list containing the following: 
</p>
<table role = "presentation">
<tr><td><code>mask</code></td>
<td>
<p>A binary mask (a raster object)</p>
</td></tr>
<tr><td><code>polygons</code></td>
<td>
<p>An object of class SpatialPolygons</p>
</td></tr>
</table>
<p>Additionally, a jpeg image is returned with the ROI(s) drawn. 
The same object that is returned is saved in the path specified in <code>path_ROIs</code>
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='CutSeason'>
Cut time series by visual estimation 
</h2><span id='topic+CutSeason'></span>

<h3>Description</h3>

<p>This function allows to cut a yearly time series where multiple
cycles are apparent into separated time series. This is done by visual
estimation using <code>locator</code> function.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CutSeason(data, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CutSeason_+3A_data">data</code></td>
<td>

<p>A data.frame, ideally a yearly time series of daily values. 
</p>
</td></tr>
<tr><td><code id="CutSeason_+3A_plot">plot</code></td>
<td>

<p>Should a plot be returned? If so different colors for different splits
are returned. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to split a season of data according to visual
estimation. The required time series is plotted and a call to <code>locator</code>
enables the user to click on the split. A list is returned with a number
of <code>data.frame</code>s. See <code>locator</code> for details on how to switch off the
on-screen locator, which depends upon the graphic device. Note that all breaks must 
be provided, i.e. at the beginning and end of the sub-seasonal cycle(s).     
</p>


<h3>Value</h3>

<p>A list with n <code>data.frame</code>s, where n is the number of splits
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PasteSeason">PasteSeason</a></code>
</p>

<hr>
<h2 id='DrawMULTIROI'>
Draw a Region of Interest
</h2><span id='topic+DrawMULTIROI'></span>

<h3>Description</h3>

<p>This function allows to draw one (or more) region(s) of interest (ROI) 
on a jpeg image. After <code>phenopix</code> version 2.4 this function allows 
to draw a region of interest potentially consisting of different polygons.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DrawMULTIROI(path_img_ref, path_ROIs, nroi = 1, 
	roi.names, file.type='.jpg')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DrawMULTIROI_+3A_path_img_ref">path_img_ref</code></td>
<td>

<p>Path in your folder for the reference image
</p>
</td></tr>
<tr><td><code id="DrawMULTIROI_+3A_path_rois">path_ROIs</code></td>
<td>

<p>Path where to store image with ROI and ROI coordinates.
</p>
</td></tr>
<tr><td><code id="DrawMULTIROI_+3A_nroi">nroi</code></td>
<td>

<p>The number of ROIs you want to draw. 
</p>
</td></tr>
<tr><td><code id="DrawMULTIROI_+3A_roi.names">roi.names</code></td>
<td>

<p>A character vector with ROI names.
</p>
</td></tr>
<tr><td><code id="DrawMULTIROI_+3A_file.type">file.type</code></td>
<td>

<p>It must match the syntax of your file extension (e.g. .jpg, .JPG, .JPEG). Multiple types are allowed by concatenation with c().  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows to draw one or more ROIs on an image or to load saved ROIs. 
The function uses <code>locator</code> to locate points, closes the polygon and stores an RData with coordinates. 
The use of locator is restricted to only some graphic devices. The function attempts to open an <code>X11()</code> device. 
In Mac OS the polygon is closed by typing ESC key. 
See <code>locator</code> for details. 
After package version 2.4, this function allows to build a ROI based on multiple polygons. As from this version 
of the package the way the roi.data object is structured changes substantially compared to previous versions. The old drawROI() 
function is no longer present. The new function <code><a href="#topic+convertROI">convertROI</a></code> allows to convert <code>roi.data</code> objects generated with 
former <code>DrawROI</code> function (phenopix &lt; 2.4) into the new roi.data structure.  
</p>


<h3>Value</h3>

<p>A list containing the following: 
</p>
<table role = "presentation">
<tr><td><code>mask</code></td>
<td>
<p>A binary mask (a raster object)</p>
</td></tr>
<tr><td><code>polygons</code></td>
<td>
<p>An object of class SpatialPolygons</p>
</td></tr>
</table>
<p>Additionally, a jpeg image is returned with the ROI(s) drawn. 
The same object that is returned is saved in the path specified in <code>path_ROIs</code>
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='editExposure'>
Change erroneous exposure values by hand  
</h2><span id='topic+editExposure'></span>

<h3>Description</h3>

<p>This function allows to fix wrong exposure values by hand. Use in combination with <code><a href="#topic+getExposure">getExposure</a></code>.  
See <code><a href="#topic+getExposure">getExposure</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editExposure(exposures, image.path, which)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="editExposure_+3A_exposures">exposures</code></td>
<td>

<p>A <code>data.frame</code> with the exposures as in output from <code><a href="#topic+getExposure">getExposure</a></code>
</p>
</td></tr>
<tr><td><code id="editExposure_+3A_image.path">image.path</code></td>
<td>

<p>The path to the folder where the images are stored, from which exposures were extracted
</p>
</td></tr>
<tr><td><code id="editExposure_+3A_which">which</code></td>
<td>

<p>A vector with row positions in your <code>data.frame</code> where exposures must be converted. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After the extraction of exposure via the <code><a href="#topic+getExposure">getExposure</a></code> function, some of them will likely require manual correction. This function makes this process easy by plotting on screen the actual exposure and the estimated. If they don't agree you can manually correct it by typing into the R console.   
</p>


<h3>Value</h3>

<p>The corrected exposures <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='ElmoreFit'>
Fit a double logistic equation to a time series according to Elmore et al. (2012)  
</h2><span id='topic+ElmoreFit'></span>

<h3>Description</h3>

<p>This function fits a double logistic curve to observed values using the
function as described in Elmore et al. (2012) (equation 4). It can also
provide and uncertainty estimation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ElmoreFit(ts, uncert = FALSE, nrep = 100, ncores='all', 
sf=quantile(ts, probs=c(0.05, 0.95), na.rm=TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ElmoreFit_+3A_ts">ts</code></td>
<td>

<p>A ts or zoo object with gcc data. index(ts) must be numeric days of
year (doys) or a POSIXct vector
</p>
</td></tr>
<tr><td><code id="ElmoreFit_+3A_uncert">uncert</code></td>
<td>

<p>Should uncertainty be estimated?
</p>
</td></tr>
<tr><td><code id="ElmoreFit_+3A_nrep">nrep</code></td>
<td>

<p>Number of relications to estimate uncertainty, defaults to 100. 
</p>
</td></tr>
<tr><td><code id="ElmoreFit_+3A_ncores">ncores</code></td>
<td>

<p>Number of processors to be used in parallel computation, defaults to 'all' which will accidentally slow down any other activity on your computer. Otherwise set the number of processors you want to use in parallelization. 
</p>
</td></tr>
<tr><td><code id="ElmoreFit_+3A_sf">sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code><a href="#topic+greenProcess">greenProcess</a></code> sf is automatically calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates parameters of the double logistic equation from
Elmore et al. 2012 and provides an uncertainty estimation. Parameters are
estimated by a call to the function <code><a href="#topic+FitDoubleLogElmore">FitDoubleLogElmore</a></code> from the 
greenbrown package. Uncertainty is computed by adding noise to the raw
data and by estimating again the parameters. Noise is added according
to the standard deviation of the residuals (fitted - observed).
The procedure is repeated nrep times.    
</p>


<h3>Value</h3>

<p>A list containing the following items. 
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>A list as returned by the function FitDoubleLogElmore</p>
</td></tr>
<tr><td><code>uncertainty</code></td>
<td>
<p>A list containing a zoo data.frame with the
uncertainty predicted values, and a dataframe containing the
respective uncertainty curve parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Elmore, A.J., S.M. Guinn, B.J. Minsley and A.D. Richardson (2012): 
Landscape controls on the timing of spring, autumn, and growing season 
length in mid-Atlantic forests. - Global Change Biology 18, 656-674.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FitDoubleLogElmore">FitDoubleLogElmore</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(zoo)
data(bartlett2009.filtered)
## fit without uncertainty estimation
fitted.elmore &lt;- ElmoreFit(bartlett2009.filtered)
days &lt;- as.numeric(format(index(bartlett2009.filtered), '
plot(days, bartlett2009.filtered)
lines(fitted.elmore$fit$predicted, col='red')
## look at fitting parameters
fitted.elmore$fit$params
## look at fitting equation, where t is time
fitted.elmore$fit$formula

## End(Not run)
</code></pre>

<hr>
<h2 id='extract'>
Extract items from an object of class phenopix  
</h2><span id='topic+extract'></span>

<h3>Description</h3>

<p>This function allows to extract items from an object of class phenopix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract(x, what)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_+3A_x">x</code></td>
<td>

<p>An object of class <code>phenopix</code>
</p>
</td></tr> 
<tr><td><code id="extract_+3A_what">what</code></td>
<td>

<p>One between &quot;data&quot;, &quot;fitted&quot;, &quot;metrics&quot;, &quot;metrics.uncert&quot;, &quot;curve.params&quot;, 
&quot;curve.uncert&quot;, &quot;curve.params.uncert&quot;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to extract items from an object of class phenopix. 
&quot;data&quot; extracts row data
&quot;fitted&quot; extracts fitted data
&quot;metrics&quot; extracts metrics data.frame
&quot;metrics.uncert&quot; extracts metrics uncertainty dataframe 
&quot;curve.params&quot; extracts curve parameters 
&quot;curve.uncert&quot; extracts a family of fitted curves estimated by the uncertainty procedure
&quot;curve.params.uncert&quot; extracts a family of curve parameters estimated by the uncertainty procedure 
</p>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='extractDateFilename'>
Estract dates from filenames 
</h2><span id='topic+extractDateFilename'></span>

<h3>Description</h3>

<p>This function extracts dates from filenames. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractDateFilename(filename, date.code)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractDateFilename_+3A_filename">filename</code></td>
<td>

<p>The filename where to retrieve time stamp 
</p>
</td></tr>
<tr><td><code id="extractDateFilename_+3A_date.code">date.code</code></td>
<td>

<p>The format of your date in filename, see details.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the extraction of the date (hour, doy, dayfract) 
from the filename. The only mandatory rules are (1) that site name come 
first and date after and (2) sitename and date must be separated by an underscore. 
In date.code provide the format of your date, using lower letters for year (y) 
month (m) and day (d) and upper letters for hour (H) and minute (M). As an example: 
If your file is named: 'sitename_2012_03_03_15-30.jpg' than your 
date.code is &quot;yyyy_mm_dd_HH-MM&quot;.
If your file is named 'sitename_12.03.03.1530.jpg' than your date.code is 
&quot;yy.mm.dd.HHMM&quot;
If hours and minutes are missing in your filename, convertion defaults to 12:00. 
</p>


<h3>Value</h3>

<p>A POSIX string containing date,Hour,DOY,DOY.dayfract of the entire images time series
</p>


<h3>Author(s)</h3>

<p>Edoardo Cremonese &lt;e.cremonese@arpa.vda.it&gt;
</p>

<hr>
<h2 id='extractParameters'>
Extract fitting parameters from a pixel-based analysis 
</h2><span id='topic+extractParameters'></span>

<h3>Description</h3>

<p>This function allows to extract fitting parameters from pixel-based analysis of a 
seasonal ensemble of images in one or multiple rois.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractParameters(list, update=NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractParameters_+3A_list">list</code></td>
<td>

<p>A list as in output from <code>spatialGreen</code>.  
</p>
</td></tr>
<tr><td><code id="extractParameters_+3A_update">update</code></td>
<td>

<p>One between 'trs', 'derivatives', 'klosterman', 'gu' or NULL (the default). 
See <code>update</code> from this package for further details. 
</p>
</td></tr>
<tr><td><code id="extractParameters_+3A_...">...</code></td>
<td>

<p>Further arguments to the update function. Currently, you can specify a <code>trs</code> argument for update method <code>trs</code> for specific thresholds. See <code>PhenoExtract</code> for further details.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to extract curve parameters and thresholds from pixel based analyisis. Depending on how you have 
run <code>spatialGreen</code> function, <code>extractParameters</code> behaves differently (but returns the same results!). In case you haven't 
saved each pixel's fit with <code>spatialGreen</code> (i.e., with <code>save</code> == FALSE and <code>assign</code> == TRUE), this function will
extract parameters from a list as in output from <code>spatialGreen</code>. IN case you HAVE saved each pixel's fit (i.e. <code>save</code> == TRUE in function <code>spatialGreen</code>) <code>extractParameters</code> loads recursively in a folder (<code>path</code>) and builds a data.frame 
with extracted curve parameters and thresholds. 
In both cases a <code>data.frame</code> is returned, with all curve parameters and thresholds for each pixel (one row for each pixel). Additionally, RMSE (root mean square error) for each fitting is computed and returned as well. The dataframe in output is suitable 
to be passed to the function <code>plotSpatial</code>.  
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='extractVIs'>
Extracts various vegetation indexes in a ROI
</h2><span id='topic+extractVIs'></span>

<h3>Description</h3>

<p>This function allows to extract various vegetation indexes in a 
region of interest of a jpeg image. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractVIs(img.path, roi.path, vi.path = NULL, roi.name = NULL, 
  plot = TRUE, begin = NULL, spatial = FALSE, date.code, 
  npixels=1, file.type='.jpg', bind=FALSE, shift.matrix=NULL, ncores='all', log.file=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractVIs_+3A_img.path">img.path</code></td>
<td>

<p>Path to image folder, or a vector with all image files (full path mandatory) 
</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_roi.path">roi.path</code></td>
<td>

<p>Path to stored RData with ROI, see <code>DrawROI</code>
</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_vi.path">vi.path</code></td>
<td>

<p>Where to save the output. If NULL data are saved in the working directory. 
</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_roi.name">roi.name</code></td>
<td>

<p>The name of the ROI
</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_plot">plot</code></td>
<td>

<p>Should a diagnostic plot with red, green and blue indexes be returned?
</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_begin">begin</code></td>
<td>

<p>The user can provide a beginning date as a character string in the form 'YYYY-MM-DD'. Images 
with a time stamp earlier than the provided date will be discarded. Default is NULL and the whole
time series will be processed. Useful when updating an existing time series.
</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_spatial">spatial</code></td>
<td>

<p>If spatial = FALSE (the default) vegetation indexes are averaged over the entire ROI. If set to FALSE 
red green and blue digital numbers are extracted for each pixel in the ROI. Since this option builds large 
objects, it is recommended to use it on resized images, so to have to more than 10k pixels in the ROI.  

</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_date.code">date.code</code></td>
<td>

<p>Provide the (quoted) exact format of the date embedded in your image names. Example: your image file picked on June 14th, 2012 at 12 pm is named 
&quot;site_12.06_14.1200.png&quot;, than your date.code will be &quot;yy.mm_dd.HHMM&quot;. 

</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_npixels">npixels</code></td>
<td>

<p>This argument allows to sample the images at lower resolution. Specify by an integer the number of pixels you want to aggregate (e.g. if npixels=2), a square of 2 pixels per side is aggregated in one pixel.  
</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_file.type">file.type</code></td>
<td>

<p>It must match the syntax of your file extension (e.g. .jpg, .JPG, .JPEG). Multiple types are allowed by concatenation with c().  
</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_bind">bind</code></td>
<td>

<p>If TRUE and argument begin is defined, then new VI.data are binded to already existing data and overwritten, after checking for duplicated records 
(and returning a warning in case there are).  
</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_shift.matrix">shift.matrix</code></td>
<td>

<p>If non NULL a matrix of two-dimentional shifts to adjust ROI masks to accommodate for field-of-view shifts. This subject will be soon implemented in the package.  
</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_ncores">ncores</code></td>
<td>

<p>Number of processors to be used in parallel computation, defaults to 'all' which will accidentally slow down any other activity on your computer. Otherwise set the number of processors you want to use in parallelization. 
</p>
</td></tr>
<tr><td><code id="extractVIs_+3A_log.file">log.file</code></td>
<td>

<p>It can be NULL or a path where to generate and refresh a txt file which logs the progress of the filtering procedure  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the pixels contained in a ROI (which are loaded from the given folder), 
various vegetation indexes are calculated. Raw red, green and blue dn are averaged 
over the roi. The standard deviation is also calculated. For each pixel the 
brightness is computed as the sum of r + g + b. Then, for each pixel red, green 
and blue chromatic coordinates (aka relative indices) are calculated as 
r/brightness. After the calculation, all pixel data are averaged over the ROI. 
ExtractDateFilename is then called to get a time vector and a doy. The function 
applies recursively for all images in a folder and allows to get a multivariate 
time series of the various indexes. 
A plot is also generated and saved as .png if plot=TRUE
Option <code>begin</code> allows to update the process from a given date without reprocessing
the whole time series of images. In this case a separate Rdata will be saved (and not overwritten
to an already existing one) with the date of begin in the filename. 
Option <code>spatial</code> allows to compute digital numbers for each pixel instead of averaging them 
over the entire ROI.    
Note: Brightness and relative color indices are calculated for each pixel and THEN 
averaged over the ROI. This is different from averaging the brightness and raw colors 
over the entire ROI and THEN calculate a ROI-based relative color index. This second 
approach is used within the function <code>autoFilter</code> in the case when ROI aggregated 
raw dn are provided and brightness is calculated from them. 
</p>


<h3>Value</h3>

<p>A list with one data.frame for each ROI containing the multivariate time series 
of various vegetation indices if <code>spatial</code> = FALSE. Else, a list with one list for each ROI. Each 
sublist will be a named list that can be handled with appropriate functions, different from the one used 
if <code>spatial</code> = FALSE. 
</p>


<h3>Author(s)</h3>

<p>Edoardo Cremonese &lt;e.cremonese@arpa.vda.it&gt;, Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='FitDoubleLogBeck'>
A fit
</h2><span id='topic+FitDoubleLogBeck'></span>

<h3>Description</h3>

<p>See FitDoubleLogBeck from package greenbrown
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitDoubleLogBeck(x, t = index(x), tout = t, weighting = TRUE, 
    return.par = FALSE, plot = FALSE, hessian=FALSE, 
    sf=quantile(x, probs=c(0.05, 0.95), na.rm=TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FitDoubleLogBeck_+3A_x">x</code></td>
<td>

<p>A vector or, better, an univariate ts or zoo object. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogBeck_+3A_t">t</code></td>
<td>

<p>A vector of time (in numeric doys), if not provided index(x) is
retrieved. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogBeck_+3A_tout">tout</code></td>
<td>

<p>For gapfilling pourposes, a vector of time steps at which the function
can be predicted. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogBeck_+3A_weighting">weighting</code></td>
<td>

<p>Should fit be weighted? 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogBeck_+3A_return.par">return.par</code></td>
<td>

<p>Currently unused. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogBeck_+3A_plot">plot</code></td>
<td>

<p>Currently unused. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogBeck_+3A_hessian">hessian</code></td>
<td>

<p>Currently unimplemented. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogBeck_+3A_sf">sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code><a href="#topic+greenProcess">greenProcess</a></code> sf is automatically calculated.
</p>
</td></tr>
<tr><td><code id="FitDoubleLogBeck_+3A_...">...</code></td>
<td>

<p>Further arguments currenlty unused. 
</p>
</td></tr>
</table>

<hr>
<h2 id='FitDoubleLogElmore'>
A fit
</h2><span id='topic+FitDoubleLogElmore'></span>

<h3>Description</h3>

<p>See FitDoubleLogElmore from package greenbrown
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitDoubleLogElmore(x, t = index(x), tout = t, 
    return.par = FALSE, plot = FALSE, hessian=FALSE, 
    sf=quantile(x, probs=c(0.05, 0.95), na.rm=TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FitDoubleLogElmore_+3A_x">x</code></td>
<td>

<p>A vector or, better, an univariate ts or zoo object. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogElmore_+3A_t">t</code></td>
<td>

<p>A vector of time (in numeric doys), if not provided index(x) is
retrieved. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogElmore_+3A_tout">tout</code></td>
<td>

<p>For gapfilling pourposes, a vector of time steps at which the function
can be predicted. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogElmore_+3A_return.par">return.par</code></td>
<td>

<p>Currenlty unused. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogElmore_+3A_plot">plot</code></td>
<td>

<p>Currenlty unused. 
</p>
</td></tr>  
<tr><td><code id="FitDoubleLogElmore_+3A_hessian">hessian</code></td>
<td>

<p>Currently unimplemented. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogElmore_+3A_sf">sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code><a href="#topic+greenProcess">greenProcess</a></code> sf is automatically calculated.
</p>
</td></tr>
<tr><td><code id="FitDoubleLogElmore_+3A_...">...</code></td>
<td>

<p>Further arguments currenlty unused. 
</p>
</td></tr>
</table>

<hr>
<h2 id='FitDoubleLogGu'>
Fit a double logistic equation to a vector according to Gu et al. (2003)  
</h2><span id='topic+FitDoubleLogGu'></span>

<h3>Description</h3>

<p>This function fits a double logistic curve to observed values using the
function as described in Gu et al. (2003). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitDoubleLogGu(x, t = index(x), tout = t, hessian=FALSE, 
sf=quantile(x, probs=c(0.05, 0.95), na.rm=TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FitDoubleLogGu_+3A_x">x</code></td>
<td>

<p>A vector or, better, an univariate ts or zoo object. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogGu_+3A_t">t</code></td>
<td>

<p>A vector of time (in numeric doys), if not provided index(x) is
retrieved. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogGu_+3A_tout">tout</code></td>
<td>

<p>For gapfilling pourposes, a vector of time steps at which the function
can be predicted. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogGu_+3A_hessian">hessian</code></td>
<td>

<p>Currently unimplemented. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogGu_+3A_sf">sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code><a href="#topic+greenProcess">greenProcess</a></code> sf is automatically calculated.
</p>
</td></tr>
<tr><td><code id="FitDoubleLogGu_+3A_...">...</code></td>
<td>

<p>Further arguments currenlty unused. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates parameters of the double logistic equation from
Gu et al. 2003. The wrapper function <code>GuFit</code> calls this function and 
additionally allows the calculation of uncertainty. So better use <code>GuFit</code>. 
</p>


<h3>Value</h3>

<p>A list containing the following items. 
</p>
<table role = "presentation">
<tr><td><code>predicted</code></td>
<td>
<p>Predicted values from the equation</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>Equation parameters</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The equation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Gu L, Post WM, Baldocchi D, Black TA, Suyker AE, Verma SB, Vesala T, 
Wofsy SC. (2009) Characterizing the Seasonal Dynamics of Plant Community 
Photosynthesis Across a Range of Vegetation Types. In: Phenology of Ecosystem 
Processes (Ed: Noormets A, Springer New York), pp 35-58. 
</p>

<hr>
<h2 id='FitDoubleLogKlHeavy'>
Fit a double logistic function to a vector according to 
Klosterman et al. (2014) 
</h2><span id='topic+FitDoubleLogKlHeavy'></span>

<h3>Description</h3>

<p>This function fits a double logistic curve to observed values using the
function as described in Klosterman et al. (2014), equation 7. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitDoubleLogKlHeavy(x, t = index(x), tout = t, max.iter = 200, 
sf=quantile(x, probs=c(0.05, 0.95), na.rm=TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FitDoubleLogKlHeavy_+3A_x">x</code></td>
<td>

<p>A vector or, better, an univariate ts or zoo object. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogKlHeavy_+3A_t">t</code></td>
<td>

<p>A vector of time (in numeric doys), if not provided index(x) is
retrieved. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogKlHeavy_+3A_tout">tout</code></td>
<td>

<p>For gapfilling pourposes, a vector of time steps at which the function
can be predicted. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogKlHeavy_+3A_max.iter">max.iter</code></td>
<td>

<p>Maximum number of iteraction for a single optimization process. See details. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogKlHeavy_+3A_sf">sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code><a href="#topic+greenProcess">greenProcess</a></code> sf is automatically calculated.
</p>
</td></tr>
<tr><td><code id="FitDoubleLogKlHeavy_+3A_...">...</code></td>
<td>

<p>Further arguments currenlty unused. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates parameters of the double logistic equation from
Klosterman et al. 2014. The wrapper function <code>KlostermanFit</code> calls 
this function and additionally allows the calculation of uncertainty. 
So better use <code>KlostermanFit</code>. This function performs an optimization 
similar in concept to the one performed in <code>FitDoubleLogKlLight</code> but 
with additional recursive optimization which is about 10 times more time 
consuming but allows for a better representation of the data. It it suggested 
to fit the light version of the equation and if the fit is not good enought, 
check this function out.  
</p>


<h3>Value</h3>

<p>A list containing the following items. 
</p>
<table role = "presentation">
<tr><td><code>predicted</code></td>
<td>
<p>Predicted values from the equation</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>Equation parameters</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The equation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Klosterman ST, Hufkens K, Gray JM, Melaas E, Sonnentag O, Lavine I, Mitchell L, 
Norman R, Friedl MA, Richardson A D (2014) Evaluating remote sensing of deciduous 
forest phenology at multiple spatial scales using PhenoCam imagery, Biogeosciences, 
11, 4305-4320, doi:10.5194/bg-11-4305-2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KlostermanFit">KlostermanFit</a></code>
</p>

<hr>
<h2 id='FitDoubleLogKlLight'>
Fit a double logistic equation to a vector according 
to Klosterman et al. (2014) 
</h2><span id='topic+FitDoubleLogKlLight'></span>

<h3>Description</h3>

<p>This function fits a double logistic curve to observed values using the
function as described in Klosterman et al. (2014), equation 7. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitDoubleLogKlLight(x, t = index(x), tout = t, hessian=FALSE, 
sf=quantile(x, probs=c(0.05, 0.95), na.rm=TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FitDoubleLogKlLight_+3A_x">x</code></td>
<td>

<p>A vector or, better, an univariate ts or zoo object. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogKlLight_+3A_t">t</code></td>
<td>

<p>A vector of time (in numeric doys), if not provided index(x) is
retrieved. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogKlLight_+3A_tout">tout</code></td>
<td>

<p>For gapfilling pourposes, a vector of time steps at which the function
can be predicted. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogKlLight_+3A_hessian">hessian</code></td>
<td>

<p>Currently unimplemented. 
</p>
</td></tr>
<tr><td><code id="FitDoubleLogKlLight_+3A_sf">sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code><a href="#topic+greenProcess">greenProcess</a></code> sf is automatically calculated.
</p>
</td></tr>
<tr><td><code id="FitDoubleLogKlLight_+3A_...">...</code></td>
<td>

<p>Further arguments currenlty unused. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates parameters of the double logistic equation from
Klosterman et al. 2014. The wrapper function <code>KlostermanFit</code> calls 
this function and  additionally allows the calculation of uncertainty. 
So better use  <code>KlostermanFit</code>. This function performs an optimization 
similar in concept to the one performed in <code>FitDoubleLogKlHeavy</code> but 
faster and in a less accurate manner. It it suggested to fit the light version 
of the equation and if the fit is not good enought, check out <code>FitDoubleLogKlHeavy</code>.
</p>


<h3>Value</h3>

<p>A list containing the following items. 
</p>
<table role = "presentation">
<tr><td><code>predicted</code></td>
<td>
<p>Predicted values from the equation</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>Equation parameters</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The equation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Klosterman ST, Hufkens K, Gray JM, Melaas E, Sonnentag O, Lavine I, Mitchell L, 
Norman R, Friedl MA, Richardson A D (2014) Evaluating remote sensing of deciduous 
forest phenology at multiple spatial scales using PhenoCam imagery, Biogeosciences, 
11, 4305-4320, doi:10.5194/bg-11-4305-2014.
</p>

<hr>
<h2 id='fitted.phenopix'>
Returns predicted values from <code>phenopix</code> objects. 
</h2><span id='topic+fitted.phenopix'></span>

<h3>Description</h3>

<p>Returns predicted values from <code>phenopix</code> objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phenopix'
fitted(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.phenopix_+3A_object">object</code></td>
<td>

<p>An object of class <code>phenopix</code>
</p>
</td></tr>
<tr><td><code id="fitted.phenopix_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns predicted values from <code>phenopix</code> objects. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(zoo)
data(bartlett2009.filtered)
fitted &lt;- greenProcess(bartlett2009.filtered, 'klosterman', 
  'klosterman', plot=FALSE)
plot(fitted$data, type='p')
lines(index(fitted$data), fitted(fitted), col='red')

## End(Not run)
</code></pre>

<hr>
<h2 id='get.options'>
Returns default options for function <code>autoFilter</code>. 
</h2><span id='topic+get.options'></span>

<h3>Description</h3>

<p>Returns default options for function <code>autoFilter</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.options()
</code></pre>


<h3>Details</h3>

<p>Returns default options for function <code>autoFilter</code>.
It can be assigned, changed and used within the function <code>autoFilter</code>. 
In night filter the user can change the <code>threshold</code> of GCC value below which records are discarded. 
In blue filter the user can change the <code>threshold</code> on daily standard deviation in blue channel 
above which records are discarded.
In mad filter the user can change the <code>z</code> parameter. Increasing z means discarding more data.    
In max filter the user can change <code>w</code>, i.e. the time window (in days) on which the moving maximum
quantile is computed, and <code>qt</code>, the quantile that is used (default 0.9). 
In spline filter the user can change <code>stdup</code> and <code>stddown</code>, upper and lower standard deviation thresholds, 
respectively and <code>loop_spline</code>, the number of spline iteractions.  
See examples for details.
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009)
## with raw.dn ==TRUE and column position for chromatic coordinates
filtered.data &lt;- autoFilter(bartlett2009, dn=c(5:7), 
	filter=c('night', 'spline', 'max'),
    filter.options=NULL, raw.dn=TRUE)
my.options &lt;- get.options()
## change time window for max filter
my.options$max.filter$w &lt;- 5
filtered.data2 &lt;- autoFilter(bartlett2009, dn=c(5:7), 
	filter=c('night', 'spline', 'max'),
    filter.options=my.options, raw.dn=TRUE)
plot(filtered.data$max.filtered)
lines(filtered.data2$max.filtered, col='red')

## End(Not run)
</code></pre>

<hr>
<h2 id='getCoords'>
Extract coordinates (in pixels) of the exposure string from a given JPEG image
</h2><span id='topic+getCoords'></span>

<h3>Description</h3>

<p>This function allows to extract coordinates (in pixels) of the exposure string from a given JPEG image   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCoords(image)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCoords_+3A_image">image</code></td>
<td>

<p>The absolute path to the JPEG image you want to use.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will first plot the JPEG image on screen and call <code>locator()</code>. You then have to click first on bottomright corner of the rectangle you want to extract, and then close the polygon (see ?locator() for details). A second plot with the cropped image is then printed on screen, where you have to click on topleft and bottomright corner around the string &quot;Exposure: xxx&quot;, where xxx is the value of exposure. Be also sure to make your rectangle large enough to include possibly four digits exposure values (keep the right margin larger than the actual number). Coords will be returned in x and y pixel positions counted from the topleft corner of the image. These coords will be used to crop the image to extract exactly the Exposure string within the function <code>getExposure()</code>. Based on the results of <code>getExposure()</code> run on the images, you will evaluate whether to adjust the coordinates and run getExposure again, based on how well exposure was recognised from the OCR procedure.   
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getExposure">getExposure</a></code>
</p>

<hr>
<h2 id='getExposure'>
Extract exposure from stardot (or similar) images
</h2><span id='topic+getExposure'></span>

<h3>Description</h3>

<p>This function allows to extract exposure from a set of binary images. It is currently optimized for stardot cameras.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExposure(ipath, coords, train.data=FALSE, date.code, sample=NULL, begin=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getExposure_+3A_ipath">ipath</code></td>
<td>

<p>The absolute path to a folder of JPEG binary images, as converted from RGB with the function <code>binaryConvert()</code>  
</p>
</td></tr>
<tr><td><code id="getExposure_+3A_coords">coords</code></td>
<td>

<p>A named vector with 4 coordinates (x1, x2, y1, y2), as obtained from 
<code>getCoords()</code>.  
</p>
</td></tr>
<tr><td><code id="getExposure_+3A_train.data">train.data</code></td>
<td>

<p>A named list with ten sample numbers and letter E, as obtained from <code>trainOCR()</code>.  
</p>
</td></tr>
<tr><td><code id="getExposure_+3A_date.code">date.code</code></td>
<td>

<p>As in function <code>extractDateFilename()</code> in this package, to convert image names in POSIX vector.  
</p>
</td></tr>
<tr><td><code id="getExposure_+3A_sample">sample</code></td>
<td>

<p>If NULL (default) all images in the folder are processed, otherwise an integer specifying how many files must be processed. 
This is useful if you want to check some extractions without processing the whole folder.   
</p>
</td></tr>
<tr><td><code id="getExposure_+3A_begin">begin</code></td>
<td>

<p>The user can provide a beginning date as a character string in the form 'YYYY-MM-DD'. Images 
with a time stamp earlier than the provided date will be discarded. Default is NULL and the whole
time series will be processed. Useful when updating an existing time series.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a simplified OCR procedure to recognize numbers in a binary image. To do so, a full RGB image is first converted in binary (b/w) internally. Then the coordinates to crop the Exposure record are retrieved with <code>getCoords()</code> and, finally, the computation is done with <code>getExposure</code>. Before doing so you have to train the OCR with sample numbers. See <code>trainOCR()</code> for details. The procedure is based on simple matrix matching. The Exposure string is splitted into the digits that constitute it and then each digit is compared to the samples from the training. Finally, a dataframe is extracted with filenames in the first column, exposure in the second one and a POSIX vector in the third. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCoords">getCoords</a></code>
</p>

<hr>
<h2 id='greenClusters'>
Performs a cluster analysis on data in output from pixel-based phenology
</h2><span id='topic+greenClusters'></span>

<h3>Description</h3>

<p>A function to perform a cluster analysis using function <code>kmeans</code> on data in output from pixel-based phenology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greenClusters(data.clusters, data.curve=NULL, nclusters, formula=NULL, 
	plot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="greenClusters_+3A_data.clusters">data.clusters</code></td>
<td>

<p>A numeric data.frame on which the k-means clustering has to be run. Each row stores a various number of phenophases for 
a given pixel.       
</p>
</td></tr>
<tr><td><code id="greenClusters_+3A_data.curve">data.curve</code></td>
<td>

<p>A numeric data.frame with nrows equal to nrows of data.clusters and ncol equal to the number of parameters in the eaquation in formula. 
Each row contains the set of parameters to fit the equation in formula, for a given pixel. Or NULL in case of processing with method 'spline'
</p>
</td></tr>
<tr><td><code id="greenClusters_+3A_nclusters">nclusters</code></td>
<td>

<p>The number of clusters, as in <code>centers</code> in function <code>kmeans</code>. 
</p>
</td></tr>
<tr><td><code id="greenClusters_+3A_formula">formula</code></td>
<td>

<p>An expression of the equation used to fit the data in your spatial analysis. It can be retrieved from the object in output from greenProcess() function. Or NULL in case of processing with method 'spline'
</p>
</td></tr>
<tr><td><code id="greenClusters_+3A_plot">plot</code></td>
<td>

<p>If true a plot with the average trajectories for each cluster is returned. Avaiable only with fitted curves
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to perform a k-means clustering based on an input data.frame containing one or more phenophases extracted from a pixel-based analysis (in the columns) for each pixel analysed by the spatial analysis (each row must have phenophases for each pixel). A number of clusters is identified and each pixel is assigned to one cluster. An approximate average curve for each of the identified clusters is also built by averaging all curve parameters belonging to the same cluster. 
</p>


<h3>Value</h3>

<p>A named list with components curves, napos and clusters. 
&quot;curves&quot; contains a zoo object with the average curves, one curve for each of the identified clusters, or NA for spline fitting. 
&quot;napos&quot; is a vector with na positions, i.e. pixels where the phenophases in the input matrix are missing. 
&quot;clusters&quot; is a numeric vector of length equal to the number of pixels indicating to which cluster each pixel belongs.  
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='greenExplore'>
Explore all possible fitting and theshold methods from the package phenopix
</h2><span id='topic+greenExplore'></span>

<h3>Description</h3>

<p>This function allows to fast compute all fitting and thresholding methods on a given greenness time series.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greenExplore(x, ...) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="greenExplore_+3A_x">x</code></td>
<td>

<p>A zoo object with a season of filtered greeneess data
</p>
</td></tr>
<tr><td><code id="greenExplore_+3A_...">...</code></td>
<td>

<p>additional arguments passed to <code>greenProcess</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs all possible fitting and thresholding methods. It must be used in combination with <code>plotExplore</code>. The two functions were designed to give a preliminary indication of what would be the best combination of fitting curve and thresholds for your set of data. The function returns also the root mean squared error (RMSE) of the various fits, that can be used as a discriminant to choose the fit.  
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotExplore">plotExplore</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.filtered)
explored.data &lt;- greenExplore(bartlett2009.filtered)
explored.data$rmse # chech fit RMSES
plotExplore(explored.data) ## an annotated plot

## End(Not run)
</code></pre>

<hr>
<h2 id='greenProcess'>
Fit a curve and extract thresholds from vegetation index time series
</h2><span id='topic+greenProcess'></span>

<h3>Description</h3>

<p>This is a wrapper function that calls fitting functions and threshold functions 
and returns an object of class <code>phenopix</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greenProcess(ts, fit, threshold=NULL, plot=TRUE, which='light', 
  uncert=FALSE, nrep=100, 
  envelope='quantiles', quantiles=c(0.1, 0.9), hydro=FALSE, 
  sf=quantile(ts, na.rm=TRUE, prob=c(0.05, 0.95)), ncores='all', ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="greenProcess_+3A_ts">ts</code></td>
<td>

<p>A vector or, better, an univariate ts or zoo object. 
</p>
</td></tr>
<tr><td><code id="greenProcess_+3A_fit">fit</code></td>
<td>

<p>A character vector of length 1. Available options are: <code>spline</code>, <code>beck</code>, <code>elmore</code>,
<code>klosterman</code>, <code>gu</code>. 
</p>
</td></tr>
<tr><td><code id="greenProcess_+3A_threshold">threshold</code></td>
<td>

<p>A character vector of length 1. Available options are: <code>trs</code>, <code>derivatives</code>, 
<code>klosterman</code>, <code>gu</code>.  
</p>
</td></tr>
<tr><td><code id="greenProcess_+3A_plot">plot</code></td>
<td>

<p>If TRUE a call to <code>PhenoPlot</code> returns fitted values and thresholds. 
</p>
</td></tr>
<tr><td><code id="greenProcess_+3A_which">which</code></td>
<td>

<p>Only relevant if fit == <code>klosterman</code>, available options are <code>light</code> or <code>heavy</code>. 
See <code>FitDoubleLogKlHeavy</code> and <code>FitDoubleLogKlLight</code> for details. 
</p>
</td></tr>
<tr><td><code id="greenProcess_+3A_uncert">uncert</code></td>
<td>

<p>Should uncertainty be estimated?
</p>
</td></tr>
<tr><td><code id="greenProcess_+3A_nrep">nrep</code></td>
<td>

<p>Number of replications for the uncertainty estimation. 
</p>
</td></tr>
<tr><td><code id="greenProcess_+3A_envelope">envelope</code></td>
<td>

<p>One between <code>quantiles</code> and <code>min-max</code>. If <code>quantiles</code>, the uncertainty envelope 
will be computed as quantiles. Quantiles reported in <code>quantiles</code> will be 
computed togheter with the median. If <code>min-max</code> is choosen, min, max and mean of 
the uncertainty envelope will be returned. </p>
</td></tr>
<tr><td><code id="greenProcess_+3A_quantiles">quantiles</code></td>
<td>

<p>Quantiles to be calculated if envelope='quantiles'. The notation is the same as 
to specify quantiles in the <code>quantile</code> function, i.e. to get 10th and 90th 
percentile, use c(0.1, 0.9).  
</p>
</td></tr>
<tr><td><code id="greenProcess_+3A_hydro">hydro</code></td>
<td>

<p>Hydro determines how days of the year are computed. If hydro = FALSE (default) January 1st is DOY 1. 
If hydro = TRUE October 1st is day 1. This option has been introduced for two purposes. 
First, for water limited or high temperature limited boreal ecosystems (with summer 
dormant season) to process a seasonal trajectory with winter peak. Second, for ecosystems 
in the australian emisphere. If hydro = TRUE all metrics concerned with a day of year must be back 
converted in order to get actual day of year. Conversions and back conversions can be performed 
with the function <code>doy2hydrodoy</code>.    
</p>
</td></tr>
<tr><td><code id="greenProcess_+3A_sf">sf</code></td>
<td>

<p>Scaling factors used instead of min and max for data normalization.
</p>
</td></tr>
<tr><td><code id="greenProcess_+3A_ncores">ncores</code></td>
<td>

<p>Number of processors to be used in parallel computation, defaults to 'all' which will accidentally slow down any other activity on your computer. Otherwise set the number of processors you want to use in parallelization. 
</p>
</td></tr>
<tr><td><code id="greenProcess_+3A_...">...</code></td>
<td>

<p>For the plotting function, a number of parameters from generic <code>plot</code> 
can be specified. See examples. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper function that allows to fit a curve to a yearly trajectories of greeneess 
and extract phenological thresholds according to a given criterion. Handeling this main function may 
allow the user to forget learning other, rather internal functions. The combination of <code>greenProcess</code> 
and <code>extract</code> allows to use main capabilities of this package. Virtually all other functions included
are called at some points within this function. The object of class <code>phenopix</code> which is created is a rather 
complex list that can be explored via the <code>extract</code> function. Check it out for further details.    
</p>


<h3>Value</h3>

<p>An object of class <code>phenopix</code> with dedicated functions: plot(), print(), summary() and fitted(). 
The structure is actually a list. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Gu L, Post WM, Baldocchi D, Black TA, Suyker AE, Verma SB, Vesala T, 
Wofsy SC. (2009) Characterizing the Seasonal Dynamics of Plant Community 
Photosynthesis Across a Range of Vegetation Types. In: Phenology of Ecosystem 
Processes (Ed: Noormets A, Springer New York), pp 35-58. 
</p>
<p>Klosterman ST, Hufkens K, Gray JM, Melaas E, Sonnentag O, Lavine I, Mitchell L, 
Norman R, Friedl MA, Richardson A D (2014) Evaluating remote sensing of deciduous 
forest phenology at multiple spatial scales using PhenoCam imagery, Biogeosciences, 
11, 4305-4320, doi:10.5194/bg-11-4305-2014.
</p>
<p>Zhang X, Friedl MA, Schaaf CB, Strahler AH, Hodges JCF, Gao F, Reed BC, Huete A (2003) 
Monitoring vegetation phenology using MODIS, Remote Sens. Environ., 84, 471-475.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.filtered)
fitted &lt;- greenProcess(bartlett2009.filtered, 'klosterman', 
  'klosterman', uncert=TRUE, nrep=5, ncores=2)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='GuFit'>
Fit a double logistic equation to a time series according to Gu et al. (2003) 
</h2><span id='topic+GuFit'></span>

<h3>Description</h3>

<p>This function fits a double logistic curve to observed values using the
function as described in Gu et al. (2003). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GuFit(ts, uncert = FALSE, nrep = 100, ncores='all', 
sf=quantile(ts, probs=c(0.05, 0.95), na.rm=TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GuFit_+3A_ts">ts</code></td>
<td>

<p>A ts or zoo object with gcc data. index(ts) must be numeric days of
year (doys) or a POSIXct vector
</p>
</td></tr>
<tr><td><code id="GuFit_+3A_uncert">uncert</code></td>
<td>

<p>Should uncertainty be estimated?
</p>
</td></tr>
<tr><td><code id="GuFit_+3A_nrep">nrep</code></td>
<td>

<p>Number of relications to estimate uncertainty, defaults to 100. 
</p>
</td></tr>
<tr><td><code id="GuFit_+3A_ncores">ncores</code></td>
<td>

<p>Number of processors to be used in parallel computation, defaults to 'all' which will accidentally slow down any other activity on your computer. Otherwise set the number of processors you want to use in parallelization. 
</p>
</td></tr>
<tr><td><code id="GuFit_+3A_sf">sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code><a href="#topic+greenProcess">greenProcess</a></code> sf is automatically calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates parameters of the double logistic equation from
Gu et al. 2009 and provides an uncertainty estimation. Parameters are
estimated by a call to the function <code><a href="#topic+FitDoubleLogGu">FitDoubleLogGu</a></code>. Uncertainty 
is computed by adding noise to the raw
data and by estimating again the parameters. Noise is added according
to the standard deviation of the residuals (fitted - observed).
The procedure is repeated nrep times.  
</p>


<h3>Value</h3>

<p>A list containing the following items. 
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>A list as returned by the function FitDoubleLogGu</p>
</td></tr>
<tr><td><code>uncertainty</code></td>
<td>
<p>A list containing a zoo data.frame with the
uncertainty predicted values, and a dataframe containing the
respective uncertainty curve parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Gu L, Post WM, Baldocchi D, Black TA, Suyker AE, Verma SB, Vesala T, 
Wofsy SC. (2009) Characterizing the Seasonal Dynamics of Plant Community 
Photosynthesis Across a Range of Vegetation Types. In: Phenology of Ecosystem 
Processes (Ed: Noormets A, Springer New York), pp 35-58. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FitDoubleLogGu">FitDoubleLogGu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(zoo)
data(bartlett2009.filtered)
## fit without uncertainty estimation
fitted.gu &lt;- GuFit(bartlett2009.filtered)
## convert 
plot(bartlett2009.filtered)
lines(fitted.gu$fit$predicted, col='red')
## look at fitting parameters
fitted.gu$fit$params
## look at fitting equation, where t is time
fitted.gu$fit$formula

## End(Not run)
</code></pre>

<hr>
<h2 id='hydrodoy'>
Converts from and to hydrological day of year 
</h2><span id='topic+hydrodoy'></span>

<h3>Description</h3>

<p>Converts from and to hydrological day of year, i.e. setting Oct 1st as doy 1. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hydrodoy(x, year, reverse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hydrodoy_+3A_x">x</code></td>
<td>

<p>A numeric vector of doys (if reverse = FALSE) or hydrodoys
</p>
</td></tr>
<tr><td><code id="hydrodoy_+3A_year">year</code></td>
<td>

<p>A character or numeric with a year  
</p>
</td></tr>
<tr><td><code id="hydrodoy_+3A_reverse">reverse</code></td>
<td>

<p>If FALSE (default) a doy vector is expected and an hydrodoy vector is returned, if TRUE, the other way around.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a vector of doys into hydrodoys, i.e. setting Oct 1st as doy 1. The argument year is used to understand if you are computing hydrodoys in a leap year or not. The back conversion is also possible by setting reverse = TRUE. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='KlostermanFit'>
Fit a double logistic equation to a vector according to 
Klosterman et al. (2014) 
</h2><span id='topic+KlostermanFit'></span>

<h3>Description</h3>

<p>This function fits a double logistic curve to observed values using the
function as described in klosterman et al. (2014), eq 7. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KlostermanFit(ts, which = "light", uncert = FALSE, nrep = 100, 
ncores='all', sf=quantile(ts, probs=c(0.05, 0.95), na.rm=TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KlostermanFit_+3A_ts">ts</code></td>
<td>

<p>A ts or zoo object with gcc data. index(ts) must be numeric days of
year (doys) or a POSIXct vector
</p>
</td></tr>
<tr><td><code id="KlostermanFit_+3A_which">which</code></td>
<td>

<p>A character to be chosen between 'light' (default) and 'heavy'. See details. 
</p>
</td></tr>
<tr><td><code id="KlostermanFit_+3A_uncert">uncert</code></td>
<td>

<p>Should uncertainty be estimated?
</p>
</td></tr>
<tr><td><code id="KlostermanFit_+3A_nrep">nrep</code></td>
<td>

<p>Number of relications to estimate uncertainty, defaults to 100. 
</p>
</td></tr>
<tr><td><code id="KlostermanFit_+3A_ncores">ncores</code></td>
<td>

<p>Number of processors to be used in parallel computation, defaults to 'all' which will accidentally slow down any other activity on your computer. Otherwise set the number of processors you want to use in parallelization. 
</p>
</td></tr>
<tr><td><code id="KlostermanFit_+3A_sf">sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code><a href="#topic+greenProcess">greenProcess</a></code> sf is automatically calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates parameters of the double logistic equation from
Klosterman et al. 2014. Two optimization procedures are available. If 
which='light' (the default) equation parameters are optimized using the 
function <code>optim</code> and computation is faster, whereas if which='heavy' 
the optimization procedure calls the function <code>nsl</code> and is based on 
a greater number of iteractions with different first guesses for parameters. 
This option is about ten times slower than the light one.  
</p>


<h3>Value</h3>

<p>A list containing the following items. 
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>A list as returned by the function FitDoubleLogGu</p>
</td></tr>
<tr><td><code>uncertainty</code></td>
<td>
<p>A list containing a zoo data.frame with the
uncertainty predicted values, and a dataframe containing the
respective uncertainty curve parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Klosterman ST, Hufkens K, Gray JM, Melaas E, Sonnentag O, Lavine I, Mitchell L, 
Norman R, Friedl MA, Richardson A D (2014) Evaluating remote sensing of deciduous 
forest phenology at multiple spatial scales using PhenoCam imagery, Biogeosciences, 
11, 4305-4320, doi:10.5194/bg-11-4305-2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FitDoubleLogKlLight">FitDoubleLogKlLight</a></code>
<code><a href="#topic+FitDoubleLogKlHeavy">FitDoubleLogKlHeavy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(zoo)
data(bartlett2009.filtered)
## fit without uncertainty estimation
fitted.kl1 &lt;- KlostermanFit(bartlett2009.filtered, which='light')
fitted.kl2 &lt;- KlostermanFit(bartlett2009.filtered, which='heavy')
## check fitting
plot(bartlett2009.filtered)
lines(fitted.kl1$fit$predicted, col='red')
lines(fitted.kl2$fit$predicted, col='blue')
legend('topleft',col=c('red', 'blue'), lty=1, 
  legend=c('light', 'heavy'), bty='n')

## End(Not run)
</code></pre>

<hr>
<h2 id='matchExposure'>
Match exposures retrieved from the header of (stardot) digital images
</h2><span id='topic+matchExposure'></span>

<h3>Description</h3>

<p>This function allows to match exposure values extracted from RGB and IR images based on image timestamp  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchExposure(exposure.df=NULL, 
  exposure.RGB=NULL, exposure.IR=NULL, pattern.RGB="RGB", 
  pattern.IR="IR", tol=1, 
  matching.column='timestamp')
  </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matchExposure_+3A_exposure.df">exposure.df</code></td>
<td>

<p>A dataframe where exposures from RGB and IR images are in the same data.frame. It is however suggested to provide separate data.frames for RGB and IR images. The format of the data.frame must be as in output from the <code>getExposure()</code> function. 
</p>
</td></tr>
<tr><td><code id="matchExposure_+3A_exposure.rgb">exposure.RGB</code></td>
<td>

<p>When <code>exposure.df</code> is NULL, this data.frame, as in output from the function <code>getExposure()</code>, will be used to retrieve RGB exposures 
</p>
</td></tr>
<tr><td><code id="matchExposure_+3A_exposure.ir">exposure.IR</code></td>
<td>

<p>When <code>exposure.df</code> is NULL, this data.frame, as in output from the function <code>getExposure()</code>, will be used to retrieve IR exposures 
</p>
</td></tr>
<tr><td><code id="matchExposure_+3A_pattern.rgb">pattern.RGB</code></td>
<td>

<p>When <code>exposure.df</code> is non NULL the pattern to be matched in order to subset RGB image rows. The pattern is matched by a call to <code>grepl()</code> 
</p>
</td></tr>
<tr><td><code id="matchExposure_+3A_pattern.ir">pattern.IR</code></td>
<td>

<p>When <code>exposure.df</code> is non NULL the pattern to be matched in order to subset IR image rows. The pattern is matched by a call to <code>grepl()</code> 
</p>
</td></tr>
<tr><td><code id="matchExposure_+3A_tol">tol</code></td>
<td>

<p>A tolerance value to be used to match timestamps of RGB and IR images. Available values include 1 (the default; perfect matching, i.e. the RGB image and the associated IR image has the same timestamp in the filename, rounded to minutes), 10, which means that images recorded within 10 minutes between each other are considered as matched. Higher values are allowed but it is suggested to avoid them 
</p>
</td></tr>
<tr><td><code id="matchExposure_+3A_matching.column">matching.column</code></td>
<td>

<p>A character giving the name of the column that must be used for the matching. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to receive in input two data.frames as in output from <code>getExposure()</code>, one with RGB exposures and one with IR exposures. Alternatively, one can provide a single data.frame with both RGB and IR exposures, and specify patterns of the image name (column 'images' as output from <code>getExposure()</code>) to match the two image types. Duplicates in image names are removed prior to the matching. 
</p>


<h3>Value</h3>

<p>A data.frame with exposure values for both RGB and IR images, the original timestamps and the rounded time.stamp. 
The format is suited to enter <code>NDVI()</code> function.  
</p>


<h3>Author(s)</h3>

<p>Jeroen Staab &lt;jeroen.staab@posteo.de&gt;, Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getExposure">getExposure</a></code>
<code><a href="#topic+NDVI">NDVI</a></code>
</p>

<hr>
<h2 id='NDVI'>
Compute NDVI from Phenocam color indices 
</h2><span id='topic+NDVI'></span>

<h3>Description</h3>

<p>This function computes camera NDVI as in Petach et al. (2014)  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NDVI(exposure.matched, RGB.VI, IR.VI, spatial=FALSE)
  </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NDVI_+3A_exposure.matched">exposure.matched</code></td>
<td>

<p>A dataframe as in output from <code>matchExposure()</code> 
</p>
</td></tr>
<tr><td><code id="NDVI_+3A_rgb.vi">RGB.VI</code></td>
<td>

<p>A dataframe for RGB VI extracted as in output from <code>extractVIs()</code>
</p>
</td></tr>
<tr><td><code id="NDVI_+3A_ir.vi">IR.VI</code></td>
<td>

<p>A dataframe for IR VI extracted as in output from <code>extractVIs()</code>
</p>
</td></tr>
<tr><td><code id="NDVI_+3A_spatial">spatial</code></td>
<td>

<p>Set this flag to TRUE if you have extracted VIs with spatial == TRUE. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute NDVI as in Petach et al. (2014)
</p>


<h3>Value</h3>

<p>A data.frame with NDVI computed after Petach et al. (2014).  
</p>


<h3>Author(s)</h3>

<p>Jeroen Staab &lt;jeroen.staab@posteo.de&gt;, Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getExposure">getExposure</a></code>
<code><a href="#topic+NDVI">NDVI</a></code>
</p>

<hr>
<h2 id='PasteSeason'>
A plotting facility for seasonal data with multiple cycles 
</h2><span id='topic+PasteSeason'></span>

<h3>Description</h3>

<p>After cutting and processing a timeseries with <code>CutSeason</code>, this function allows
to plot the extracted thresholds in a single plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PasteSeason(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PasteSeason_+3A_x">x</code></td>
<td>

<p>A list of objects as in output from 
<code><a href="#topic+greenProcess">greenProcess</a></code>. All subseasonal fittings 
must be listed in a list and passed to the present function. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a plotting facility which allows to plot in a single graph multiple fitting
output from <code><a href="#topic+greenProcess">greenProcess</a></code>.  
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CutSeason">CutSeason</a></code>
</p>

<hr>
<h2 id='PhenoBP'>
Extract breakpoints on a time series
</h2><span id='topic+PhenoBP'></span>

<h3>Description</h3>

<p>A function to extract breakpoints and confidence intervals on a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoBP(x, breaks=3, confidence=0.95, plot=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhenoBP_+3A_x">x</code></td>
<td>

<p>An univariate ts or zoo object 
</p>
</td></tr>
<tr><td><code id="PhenoBP_+3A_breaks">breaks</code></td>
<td>

<p>Maximum number of breaks to be detected
</p>
</td></tr>
<tr><td><code id="PhenoBP_+3A_confidence">confidence</code></td>
<td>

<p>The confidence level for the uncertainty computation. Defaults to 0.95, i.e. 
95% confidence interval (two-tails). 
</p>
</td></tr>
<tr><td><code id="PhenoBP_+3A_plot">plot</code></td>
<td>

<p>Should a diagnostic plot be returned?
</p>
</td></tr>
<tr><td><code id="PhenoBP_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>plot</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Threshold extraction is performed according to breakpoint analysis. 
The function used is breakpoints from package <code>strucchange</code>. 
The function also computes a confidence interval by a call to <code><a href="stats.html#topic+confint">confint</a></code>. 
Uncertainty analysis is therefore different from the approach used for other 
thresholds (see e.g. <code><a href="#topic+PhenoGu">PhenoGu</a></code>). Unlike the other thresholding approaches, 
PhenoBP is born to work with raw data. It therefore does not require fitting 
an equation. However, the function can also be used with fitted data. See example.   
</p>


<h3>Value</h3>

<p>A named vector with extracted breakpoints
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PhenoExtract">PhenoExtract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.filtered)
breaks &lt;- PhenoBP(bartlett2009.filtered, breaks=4)
mean.breaks.doy &lt;- as.numeric(format(as.POSIXct(t(breaks[2,]), 
	origin='1970-01-01'), '
mean.breaks.doy

## End(Not run)
</code></pre>

<hr>
<h2 id='PhenoDeriv'>
Extract phenophases from a fitted equation with method Derivatives
</h2><span id='topic+PhenoDeriv'></span>

<h3>Description</h3>

<p>Extract phenophases from a fitted equation with method Derivatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoDeriv(x, formula = NULL, uncert = FALSE, 
	params = NULL, breaks, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhenoDeriv_+3A_x">x</code></td>
<td>

<p>A named vector with the parameters of the equation used to fit the data. 
</p>
</td></tr>
<tr><td><code id="PhenoDeriv_+3A_formula">formula</code></td>
<td>

<p>Inherited from previous steps of the process.
</p>
</td></tr>
<tr><td><code id="PhenoDeriv_+3A_uncert">uncert</code></td>
<td>

<p>Currently unused
</p>
</td></tr>
<tr><td><code id="PhenoDeriv_+3A_params">params</code></td>
<td>

<p>Inherited from previous steps of the process.  
</p>
</td></tr>
<tr><td><code id="PhenoDeriv_+3A_breaks">breaks</code></td>
<td>

<p>Currently unused
</p>
</td></tr>
<tr><td><code id="PhenoDeriv_+3A_...">...</code></td>
<td>

<p>Further arguments, currently not used
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.fitted)
derivatives.phenophases &lt;- PhenoDeriv(
	x=bartlett2009.fitted$fit$predicted, fit=bartlett2009.fitted$fit
	)
plot(bartlett2009.fitted$fit$predicted)
abline(v=derivatives.phenophases[c(1:2,4)], col=palette())
mtext(names(derivatives.phenophases[c(1:2,4)]), 
	at=derivatives.phenophases[c(1:2,4)], 
	line=-2, 
	col=palette()[1:3])

## End(Not run)
</code></pre>

<hr>
<h2 id='PhenoExtract'>
Generic function for the extraction of phenological thresholds
</h2><span id='topic+PhenoExtract'></span>

<h3>Description</h3>

<p>This function extracts phenological thresholds according to different methods. 
Methods include 'trs', 'derivatives', 'klosterman', 'gu'. See details for the 
computation of each method.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoExtract(data, method = "trs", uncert = FALSE, 
  breaks = 3, envelope = "quantiles", 
  quantiles = c(0.1, 0.9), plot = TRUE, sf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhenoExtract_+3A_data">data</code></td>
<td>

<p>A list structured as in output from the fitting procedures, such as GuFit, 
KlostermanFit, ElmoreFit, BeckFit. 
</p>
</td></tr>
<tr><td><code id="PhenoExtract_+3A_method">method</code></td>
<td>

<p>One between 'trs', 'derivatives', 'klosterman', 'gu'.
</p>
</td></tr>
<tr><td><code id="PhenoExtract_+3A_uncert">uncert</code></td>
<td>

<p>Should uncertainty on thresholds be computed? It requires that uncertainty 
be computed in the fitting function. I.e. The function requires the element 
'uncertainty' in data beeing non NULL. If is.null(uncertainty) in the data or 
this item is set to FALSE, uncertainty won't be computed.  
</p>
</td></tr>
<tr><td><code id="PhenoExtract_+3A_breaks">breaks</code></td>
<td>

<p>Currently unused
</p>
</td></tr>
<tr><td><code id="PhenoExtract_+3A_envelope">envelope</code></td>
<td>

<p>One between 'quantiles' and 'min-max'. If 'quantiles', the uncertainty envelope 
will be computed as quantiles. Quantiles reported in <code>quantiles</code> will be 
computed togheter with the median. If 'min-max' is choosen, min, max and mean of 
the uncertainty envelope will be returned. 
</p>
</td></tr>
<tr><td><code id="PhenoExtract_+3A_quantiles">quantiles</code></td>
<td>

<p>Quantiles to be calculated if envelope='quantiles'. The notation is the same as 
to specify quantiles in the <code>quantile</code> function, i.e. to get 10th and 90th 
percentile, use c(0.1, 0.9).  
</p>
</td></tr>
<tr><td><code id="PhenoExtract_+3A_plot">plot</code></td>
<td>

<p>Should a diagnostic plot be returned with annotated thresholds? It calls the 
function <code>PhenoPlot</code>
</p>
</td></tr>
<tr><td><code id="PhenoExtract_+3A_sf">sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code><a href="#topic+greenProcess">greenProcess</a></code> sf is automatically calculated. We suggest using quantile(ts, probs=c(0.05, 0.5)) if you need to compute it. 
</p>
</td></tr>
<tr><td><code id="PhenoExtract_+3A_...">...</code></td>
<td>

<p>For the plotting function, a number of parameters from generic <code>plot</code> 
can be specified.  
Additionally, a further option to 'trs' method calling <code>PhenoTrs</code> is provided: by setting a trs argument. 
The default for trs is 0.5, meaning that the phases sos (start of season) and eos (end of season) will be set when gcc reaches 50% of maximum on the increasing (sos) and decreasing (eos) seasonal trajectory.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function that calls <code><a href="#topic+PhenoTrs">PhenoTrs</a></code> for method='trs', <code><a href="#topic+PhenoDeriv">PhenoDeriv</a></code> 
for method='derivatives', (from package <code>greenbrown</code>) or <code><a href="#topic+PhenoGu">PhenoGu</a></code> for method='Gu',
and <code><a href="#topic+PhenoKl">PhenoKl</a></code> for method='klosterman' from this package. Please see help of the 
single functions for details on the calculation of thresholds.  
</p>


<h3>Value</h3>

<p>If uncertainty=FALSE a vector of phenology metrics, otherwise a dataframe. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Klosterman ST, Hufkens K, Gray JM, Melaas E, Sonnentag O, Lavine I, Mitchell L, 
Norman R, Friedl MA, Richardson A D (2014) Evaluating remote sensing of deciduous 
forest phenology at multiple spatial scales using PhenoCam imagery, Biogeosciences, 
11, 4305-4320, doi:10.5194/bg-11-4305-2014.
</p>
<p>Gu L, Post WM, Baldocchi D, Black TA, Suyker AE, Verma SB, Vesala T, Wofsy SC. (2009) 
Characterizing the Seasonal Dynamics of Plant Community Photosynthesis Across a Range 
of Vegetation Types. In: Phenology of Ecosystem Processes (Ed: Noormets A, 
Springer New York), pp 35-58.
</p>
<p>Zhang X, Friedl MA, Schaaf CB, Strahler AH, Hodges JCF, Gao F, Reed BC, Huete A (2003) 
Monitoring vegetation phenology using MODIS, Remote Sens. Environ., 84, 471-475.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PhenoGu">PhenoGu</a></code>,
<code><a href="#topic+PhenoKl">PhenoKl</a></code>,
<code><a href="#topic+PhenoDeriv">PhenoDeriv</a></code>,
<code><a href="#topic+PhenoTrs">PhenoTrs</a></code>,
<code><a href="#topic+PhenoPlot">PhenoPlot</a></code>,
<code><a href="#topic+PhenoGu">PhenoGu</a></code>
</p>

<hr>
<h2 id='PhenoGu'>
Extract phenophases from a fitted equation according to Gu et al. 2009
</h2><span id='topic+PhenoGu'></span>

<h3>Description</h3>

<p>A function for the extraction of phenological thresholds according to Gu et al. 2009. 
This is a rather internal function. Use PhenoExtract with method='gu' instead. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoGu(x, fit, uncert = FALSE, breaks, sf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhenoGu_+3A_x">x</code></td>
<td>

<p>A named vector with the parameters of the equation used to fit the data. 
</p>
</td></tr>
<tr><td><code id="PhenoGu_+3A_fit">fit</code></td>
<td>

<p>A list structured as in output from the fitting procedures, such as GuFit, 
KlostermanFit, ElmoreFit, BeckFit.
</p>
</td></tr>
<tr><td><code id="PhenoGu_+3A_uncert">uncert</code></td>
<td>

<p>Currently unused
</p>
</td></tr>
<tr><td><code id="PhenoGu_+3A_breaks">breaks</code></td>
<td>

<p>Currently unused
</p>
</td></tr>
<tr><td><code id="PhenoGu_+3A_sf">sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code><a href="#topic+greenProcess">greenProcess</a></code> sf is automatically calculated.
</p>
</td></tr>
<tr><td><code id="PhenoGu_+3A_...">...</code></td>
<td>

<p>Further arguments, currently not used
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Threshold extraction is performed according to Gu et al (2009). Briefly, from 
the fitting equation (be it from Klosterman, Elmore, Beck or Gu fitting) and 
the correspondent parameters, the first derivative is extracted. Peak recovery 
rate (prr) is defined as the maximum of the first derivative and represent the 
maximum slope of the increasing part of the curve. Correspondingly peak 
senescence rate (psr) is the minimum of the first derivative. The recovery line 
and the senscence line are tangent to the fitting curve with slope equal to prr 
and psr respectively. Baseline and maxline are further defined as the horizontal 
lines corresponding to the minimum and the maximum of the curve. The intersection 
between recovery line and baseline defines the beginning of the growing season, 
i.e upturn date (UD). The intersection between recovery line and maxline defines 
the reacing of the plateau, i.e. stabilization date (SD). The intersection between 
senescence line and baseline defines the end of the growing season, i.e. recession 
date (RD). In the original implementation by Gu et al. the intersection between 
senescence line and maxline would define the downturn date (oldDD). To account 
for decreasing plateau typical of a number of seasonal trajectories, we have 
further defined a plateau line, which is a linear fit between SD and oldDD. 
The plateau line would roughly correspond to the maxline if the plateau is 
horizontal, whereas it will be a decreasing line in case of a decreasing plateau. 
Therefore, in our implementatio DD is defined as the intersection between the 
plateau line and the senescence line.     
</p>


<h3>Value</h3>

<p>A named vector of length 9 with upturn date (UD), stabilizazion date (SD), 
downturn date (DD), recession date (RD), maximum of the fitting curve (maxline),
minimum of the fitting curve (baseline), peack recovery rate (prr), 
peack senescence rate (psr) and the slope of the plateau line (plateau.slope).  
</p>


<h3>Note</h3>

<p>Since this threshold extraction is based on a derivable function, it cannot 
be performed on raw data. Uncertainty estimation with this method on a fitted 
curve from SplineFit is currently not implemented. Instead you can use 
PhenoGu in a for loop cycling in the uncertainty dataframe columns. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Gu L, Post WM, Baldocchi D, Black TA, Suyker AE, Verma SB, Vesala T, 
Wofsy SC. (2009) Characterizing the Seasonal Dynamics of Plant Community 
Photosynthesis Across a Range of Vegetation Types. In: Phenology of 
Ecosystem Processes (Ed: Noormets A, Springer New York), pp 35-58.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PhenoExtract">PhenoExtract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.fitted)
gu.phenophases &lt;- PhenoGu(x=bartlett2009.fitted$fit$params, 
	fit=bartlett2009.fitted$fit, sf=quantile(bartlett2009.fitted$fit$predicted, c(0.1, 0.9)))
plot(bartlett2009.fitted$fit$predicted)
abline(v=gu.phenophases[1:4], col=palette())
mtext(names(gu.phenophases[1:4]), at=gu.phenophases[1:4], 
	line=-2:-5, col=palette()[1:4])

## End(Not run)
</code></pre>

<hr>
<h2 id='PhenoKl'>
Extract phenophases from a fitted equation according to Klosterman et al. 2014
</h2><span id='topic+PhenoKl'></span>

<h3>Description</h3>

<p>A function for the extraction of phenological thresholds according to Klosterman et al. 2014. 
This is a rather internal function. Use PhenoExtract with method='klosterman' instead. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoKl(x, uncert = FALSE, fit, breaks, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhenoKl_+3A_x">x</code></td>
<td>

<p>A named vector with the parameters of the equation used to fit the data. 
</p>
</td></tr>
<tr><td><code id="PhenoKl_+3A_uncert">uncert</code></td>
<td>

<p>Currently unused
</p>
</td></tr>
<tr><td><code id="PhenoKl_+3A_fit">fit</code></td>
<td>

<p>A list structured as in output from the fitting procedures, such as GuFit, 
KlostermanFit, ElmoreFit, BeckFit.
</p>
</td></tr>
<tr><td><code id="PhenoKl_+3A_breaks">breaks</code></td>
<td>

<p>Currently unused
</p>
</td></tr>
<tr><td><code id="PhenoKl_+3A_...">...</code></td>
<td>

<p>Further arguments, currently not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Threshold extraction is performed according to Klosterman et al (2014) with a 
modification derived from Zhang et al (2003). Briefly, the rate of curvature 
(k) as defined in Klosterman et al (2014) is computed and inflection points 
are evaluated on its derivative (derK). The growing season is splitted in 
its increasing and decreasing parts around the maximum. The same happens to 
derK. Greenup date is defined as the day of maximum derK (a local maximum) 
before the first minimum in derK in the increasing part of the curve. 
Maturity is defined as the maximum in derK between the minimum of derK 
and mid season. Senescence is defined as the first local minimum in the 
decreasing part of derK. Dormancy is defined as the last local minimum 
in derK. Phases are named after Zhang et al (2003).     
</p>


<h3>Value</h3>

<p>A named vector of length 4 with the extracted thresholds: Greenup, 
Maturity, Senescence, Dormancy.  
</p>


<h3>Note</h3>

<p>Since this threshold extraction is based on a derivable function, 
it cannot be performed on raw data. 
Uncertainty estimation with this method on a fitted curve from 
SplineFit is currently not implemented. Instead you can use PhenoKl 
in a for loop cycling in  the uncertainty dataframe columns. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>References</h3>

<p>Klosterman ST, Hufkens K, Gray JM, Melaas E, Sonnentag O, Lavine I, 
Mitchell L, Norman R, Friedl MA, Richardson A D (2014) Evaluating 
remote sensing of deciduous forest phenology at multiple spatial 
scales using PhenoCam imagery, Biogeosciences, 11, 4305-4320, 
doi:10.5194/bg-11-4305-2014.
</p>
<p>Zhang X, Friedl MA, Schaaf CB, Strahler AH, Hodges JCF, Gao F, Reed BC, 
Huete A (2003) Monitoring vegetation phenology using MODIS, Remote 
Sens. Environ., 84, 471-475.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PhenoExtract">PhenoExtract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.fitted)
klosterman.phenophases &lt;- PhenoKl(
	x=bartlett2009.fitted$fit$params, 
	fit=bartlett2009.fitted$fit)
plot(bartlett2009.fitted$fit$predicted)
abline(v=klosterman.phenophases[1:4], col=palette())
mtext(names(klosterman.phenophases[1:4]), 
	at=klosterman.phenophases[1:4], line=-2:-5, 
	col=palette()[1:4])

## End(Not run)
</code></pre>

<hr>
<h2 id='PhenoPlot'>
A plotting function for phenological thresholds
</h2><span id='topic+PhenoPlot'></span>

<h3>Description</h3>

<p>This function uses data from a fitted phenological model, the extracted 
metrics and plots them in an annotated graph. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoPlot(data, metrics, add = FALSE, show.uncert = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhenoPlot_+3A_data">data</code></td>
<td>

<p>Fitted data from a fitting function such as GuFit, SplineFit, KlostermanFit, 
ElmoreFit, BeckFit
</p>
</td></tr>
<tr><td><code id="PhenoPlot_+3A_metrics">metrics</code></td>
<td>

<p>A named vector or a dataframe, depending on the presence or absence of 
uncertainty estimation 
</p>
</td></tr>
<tr><td><code id="PhenoPlot_+3A_add">add</code></td>
<td>

<p>If TRUE the plot is superimposed to an existing one
</p>
</td></tr>
<tr><td><code id="PhenoPlot_+3A_show.uncert">show.uncert</code></td>
<td>

<p>Should uncertainty be shown as error bars around the extracted thresholds? 
It requires that data in imput incorporate the uncertainty estimation.   
</p>
</td></tr>
<tr><td><code id="PhenoPlot_+3A_...">...</code></td>
<td>

<p>Several argument as in <code>plot</code> can be specified here, see example.   
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to plot fitting and thresholding on a season of gcc 
data. Uncertainty can be also shown
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PhenoExtract">PhenoExtract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.fitted)
klosterman.phenophases &lt;- PhenoExtract(bartlett2009.fitted, 
	method='klosterman', uncert=TRUE, plot=FALSE)
PhenoPlot(bartlett2009.fitted, klosterman.phenophases$unc.df)

## End(Not run)
</code></pre>

<hr>
<h2 id='PhenoTrs'>
A phenophase method based on fixed thresholds
</h2><span id='topic+PhenoTrs'></span>

<h3>Description</h3>

<p>See PhenoTrs from package greenbrown for details. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoTrs(x, approach = c("White", "Trs"), trs = 0.5, min.mean = 0.1, 
  formula = NULL, uncert = FALSE, params = NULL, breaks, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhenoTrs_+3A_x">x</code></td>
<td>
<p>seasonal cycle of one year</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_approach">approach</code></td>
<td>
<p>approach to be used to calculate phenology metrics. 'White' (White et al. 1997) or 'Trs' for simple threshold.</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_trs">trs</code></td>
<td>
<p>threshold to be used for approach &quot;Trs&quot;</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_min.mean">min.mean</code></td>
<td>
<p>minimum mean annual value in order to calculate phenology metrics. Use this threshold to suppress the calculation of metrics in grid cells with low average values  </p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_formula">formula</code></td>
<td>
<p>Returned from previous steps of the process</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_uncert">uncert</code></td>
<td>
<p>Currently unused</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_params">params</code></td>
<td>
<p>Returned from previous steps of the process</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_breaks">breaks</code></td>
<td>
<p>Currently unused</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_...">...</code></td>
<td>
<p>further arguments (currently not used)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.fitted)
trs.phenophases &lt;- PhenoTrs(
  x=bartlett2009.fitted$fit$predicted, 
  fit=bartlett2009.fitted$fit)
plot(bartlett2009.fitted$fit$predicted)
abline(v=trs.phenophases[c(1:2,4)], col=palette())

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.phenopix'>
Plotting <code>phenopix</code> objects. 
</h2><span id='topic+plot.phenopix'></span>

<h3>Description</h3>

<p>Plotting method for objects of class <code>phenopix</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phenopix'
plot(x, y, what, main, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.phenopix_+3A_x">x</code></td>
<td>

<p>An object of class <code>phenopix</code>
</p>
</td></tr>
<tr><td><code id="plot.phenopix_+3A_y">y</code></td>
<td>

<p>It must be <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="plot.phenopix_+3A_what">what</code></td>
<td>

<p>A character vector of length 1. Available options are: <code>all</code> (showing both fitting curve and thresholds), <code>fitting</code> (showing only fitting curve) <code>thresholds</code>, and <code>params</code> to show boxplots of thresholds and curve parameters (if appropriate) when the uncertainty is computed.  
</p>
</td></tr>
<tr><td><code id="plot.phenopix_+3A_main">main</code></td>
<td>

<p>A main title for the plot. If not specified the title will be build with fit name and threshold name. 
</p>
</td></tr>
<tr><td><code id="plot.phenopix_+3A_...">...</code></td>
<td>

<p>For the plotting function, a number of parameters from generic <code>plot</code> 
can be specified. Note that graphic properties of fitted lines and thresholds
cannot be modified. See examples. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A dedicated plotting function for objects of class <code>phenopix</code>. The default shows observed 
values as a grey line, the fitted function in black and extracted thresholds in <code>palette()</code> 
colors. If available, uncertainty is also shown with a family of lightgrey curves and as error 
bars on the extracted thresholds.    
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.filtered)
fitted &lt;- greenProcess(bartlett2009.filtered, 'klosterman', 
  'gu', plot=FALSE, uncert=TRUE, nrep=5, ncores=2)
plot(fitted) ## default
## slightly more elaborated, with suppression of default title 
plot(fitted, type='p', pch=20, ylab='GCC', xlab='DOY', col='grey', 
  what='all', main='Fit + thresholds')
## only with the fitting curve
plot(fitted, type='p', pch=20, ylab='GCC', xlab='DOY', col='grey', 
  what='fitting', main='Fit only')
## show a boxplot of thresholds extracted from the uncertainty estimation
plot(fitted, what='thresholds')

## End(Not run)
</code></pre>

<hr>
<h2 id='plotBP'>
A function to plot results of function <code>PhenoBP</code>
</h2><span id='topic+plotBP'></span>

<h3>Description</h3>

<p>A function to plot results of function <code>PhenoBP</code>, with confidence intervals and annotated break points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBP(ts, breaks, bp.y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotBP_+3A_ts">ts</code></td>
<td>

<p>An univariate zoo series with measured or modelled Gcc data  
</p>
</td></tr>
<tr><td><code id="plotBP_+3A_breaks">breaks</code></td>
<td>

<p>An object as in output from PhenoBP function. 
</p>
</td></tr>
<tr><td><code id="plotBP_+3A_bp.y">bp.y</code></td>
<td>

<p>Optional argument indicating the y coordinate where break point names are written, defaults to quantile(ts, 0.005) 
</p>
</td></tr>
<tr><td><code id="plotBP_+3A_...">...</code></td>
<td>

<p>Further arguments of <code>plot</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function to rapidly plot results from <code>PhenoBP</code> function
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='plotExplore'>
Plot an object in output from the greenExplore function
</h2><span id='topic+plotExplore'></span>

<h3>Description</h3>

<p>This function allows to plot the object in output from the <code>greenExplore()</code> function.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotExplore(x) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotExplore_+3A_x">x</code></td>
<td>

<p>An object (a list) in output from <code>greenExplore</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The combination of functions <code>greenExplore</code> and <code>plotExplore</code> are intended to provide a first view of all possible fitting and thresholding methods on a season of greenness data. In particular plotExplore combines all fittings and threhsolding methods (20 plots) on an annotaded graph.   
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+greenExplore">greenExplore</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.filtered)
explored.data &lt;- greenExplore(bartlett2009.filtered)
explored.data$rmse # chech fit RMSES
plotExplore(explored.data) ## an annotated plot

## End(Not run)
</code></pre>

<hr>
<h2 id='plotSpatial'>
Plot pixel-based analysis results from spatialGreen and extractParameters functions 
</h2><span id='topic+plotSpatial'></span>

<h3>Description</h3>

<p>This function allows to plot results from pixel-based analysis of a seasonal ensemble of images in one or multiple rois.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSpatial(data, param, roi.data.path, image.path, 
  probs=c(0.01, 0.99), ...) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSpatial_+3A_data">data</code></td>
<td>

<p>Either a data.frame or a list of dataframes
</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_param">param</code></td>
<td>

<p>Character string of length 1 with name of the parameter you want to plot. It must match one of names(data)
</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_roi.data.path">roi.data.path</code></td>
<td>

<p>The complete path where to find roi data (e.g. '/home/me/folderROI/roi.data.RData')
</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_image.path">image.path</code></td>
<td>

<p>A complete path of an image you want to use as background for plotting your data. E.g. 
'/home/me/images/my_site201406061200.jpg'
</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_probs">probs</code></td>
<td>

<p>Two numbers in the range [0,1] passed to <code>quantile()</code> function to remove tails of the distribution for the plot.  
</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to the function <code>plot</code>
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function allows to plot on a reference image results from the pixel based extraction of thresholds and other relevant parameters from pixel based fitting. Multiple ROIs are allowed and handled as well. On  top of the plot the density distribution of value for each pixel is shown, if desired. Values are plotted in a black to green scale, with a legend. Data in entrance to this function can be stored in a data.frame (single ROI data) as in output from <code>extractParameters</code>. If you have analyised more than one ROI and you want them to be shown together, put individual data.frames in output from <code>extractParameters</code> in a list and pass the list as data to <code>plotSpatial</code>.   
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='plotSum'>
A plotting facility to show the combination of uncertainty
</h2><span id='topic+plotSum'></span>

<h3>Description</h3>

<p>The <code>combineUncertainty</code> uses <code><a href="#topic+greenProcess">greenProcess</a></code> to fit all available double logistic equations in the phenopix package and extracts thresholds with all available methods. Then uncertainties can be combined and returned by using <code><a href="#topic+summarizePhases">summarizePhases</a></code> and plotted with <code><a href="#topic+plotSum">plotSum</a></code>. 
See <code><a href="#topic+greenProcess">greenProcess</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSum(ts, sum, which, v=NULL, quantile=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSum_+3A_ts">ts</code></td>
<td>

<p>A ts or zoo object with gcc data. index(ts) must be numeric days of
year (doys) or a POSIXct vector
</p>
</td></tr>
<tr><td><code id="plotSum_+3A_sum">sum</code></td>
<td>

<p>An object in output from <code>summarizePhases</code>
</p>
</td></tr>
<tr><td><code id="plotSum_+3A_which">which</code></td>
<td>

<p>One between trs, derivatives, klosterman, gu
</p>
</td></tr>
<tr><td><code id="plotSum_+3A_v">v</code></td>
<td>

<p>An optional vector of vertical coordinates (in y-axis unit for plot annotation of phase names)
</p>
</td></tr>
<tr><td><code id="plotSum_+3A_quantile">quantile</code></td>
<td>

<p>If TRUE, the plotted uncertainty envelope is based on the quantiles, and not min-max, otherwise min-max envelope is plotted 
</p>
</td></tr>
<tr><td><code id="plotSum_+3A_...">...</code></td>
<td>

<p>For the plotting function, a number of parameters from generic <code>plot</code> 
can be specified. Note that graphic properties of fitted lines and thresholds
cannot be modified. See examples. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the last step of a processing chain. It uses <code><a href="#topic+greenProcess">greenProcess</a></code> to fit all available double logistic equations in the phenopix package and extracts thresholds with all available methods. Then uncertainties can be combined and returned by using <code><a href="#topic+summarizePhases">summarizePhases</a></code> and plotted with <code><a href="#topic+plotSum">plotSum</a></code>. 
See <code><a href="#topic+greenProcess">greenProcess</a></code>, <code><a href="#topic+summarizePhases">summarizePhases</a></code>, <code><a href="#topic+plotSum">plotSum</a></code>. This function uses a model approach to combine all uncertainties from all available phenopix fittings, as to get an ensemble of phases with different methods, without necessarily choosing any of them. 
</p>


<h3>Value</h3>

<p>A named list with dataframes for each phenophase method with all replication for each of the included fitting methods. These data can then be combined with the companion functions <code><a href="#topic+summarizePhases">summarizePhases</a></code> and <code><a href="#topic+plotSum">plotSum</a></code>. See examples for details. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  require(zoo) 
  data(bartlett2009.filtered)
  combined.fit &lt;- combineUncertainty(na.approx(filtered.tmp$max.filtered), nrep=100)
# 100 replications for each fitting
  names(combined.fit) # a dataframe for each phenoMethod + a list with all fittings
  fit.summary &lt;- summarizePhases(combined.fit, across.methods=TRUE)
## again a list with one element for each fitting method + two additional items 
## if across.methods is TRUE, which combines gu + klosterman phenophase methods 
## in a single method, and the same happens for trs and derivatives
  plotSum(bartlett2009.filtered, fit.summary, which='klosterman')
## a plot with original timeseries + phenophases and their uncertainty
  
## End(Not run)
  </code></pre>

<hr>
<h2 id='plotVI'>
Plot RGB DN, RGB indices and brightness
</h2><span id='topic+plotVI'></span>

<h3>Description</h3>

<p>This function allows to reproduce the same plot as returned from <code>extractVIs</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVI(VI.data, VI.path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotVI_+3A_vi.data">VI.data</code></td>
<td>

<p>An object as in output from extractVIs (with spatial == FALSE)
</p>
</td></tr>
<tr><td><code id="plotVI_+3A_vi.path">VI.path</code></td>
<td>

<p>The path where plots will be saved
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using in input a VI.data object as in output from extractVIs, this function returns a plot similar to the default plot of extractVIs. This function makes it easy to update VI plots after using extractVIs with option begin==TRUE. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='print.phenopix'>
Print <code>phenopix</code> objects. 
</h2><span id='topic+print.phenopix'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>phenopix</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phenopix'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.phenopix_+3A_x">x</code></td>
<td>

<p>An object of class <code>phenopix</code>
</p>
</td></tr>
<tr><td><code id="print.phenopix_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints a sintetic summary of the object.
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.filtered)
fitted &lt;- greenProcess(bartlett2009.filtered, 'klosterman', 
  'klosterman', plot=FALSE)
print(fitted)

## End(Not run)
</code></pre>

<hr>
<h2 id='PrintROI'>
Print an already drawn region of interest
</h2><span id='topic+PrintROI'></span>

<h3>Description</h3>

<p>This function allows to re-draw one (or more) region(s) of interest (ROI) 
on a jpeg image. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrintROI(path_img_ref,path_ROIs,which='all',col, file.type='.jpg')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PrintROI_+3A_path_img_ref">path_img_ref</code></td>
<td>

<p>Path in your folder for the reference image
</p>
</td></tr>
<tr><td><code id="PrintROI_+3A_path_rois">path_ROIs</code></td>
<td>

<p>Path where ROI coordinates are stored in a structured list called ROI.Rdata.
</p>
</td></tr>
<tr><td><code id="PrintROI_+3A_which">which</code></td>
<td>

<p>Which one of your ROIs you want to draw, defaults to ''all' and draws all rois.    
</p>
</td></tr>
<tr><td><code id="PrintROI_+3A_col">col</code></td>
<td>

<p>A character vector with colors. If missing it defaults to color <code>palette</code>
</p>
</td></tr>
<tr><td><code id="PrintROI_+3A_file.type">file.type</code></td>
<td>

<p>It must match the syntax of your file extension (e.g. .jpg, .JPG, .JPEG). Multiple types are allowed by concatenation with c().  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility allows to draw your ROIs on your reference image, with different colors for different ROIS and 
a dedicated legend
See <code>DrawROI</code> for details. 
</p>


<h3>Value</h3>

<p>It returns a plot that can be saved with your favorite device.
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;g.filippa@arpa.vda.it&gt;
</p>

<hr>
<h2 id='resizeImage'>
Resize an image (and a tROI) to a given pixel resolution
</h2><span id='topic+resizeImage'></span>

<h3>Description</h3>

<p>This function allows to resize a sample image and a correspondent ROI to a given pixel resolution to be used as background to spatila analysis plots. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resizeImage(image.in, image.out, roi.in, roi.out, npixels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resizeImage_+3A_image.in">image.in</code></td>
<td>

<p>The complete path to your original image
</p>
</td></tr>
<tr><td><code id="resizeImage_+3A_image.out">image.out</code></td>
<td>

<p>The complete path (filename with extension included) where the new, resized image will be saved. 
</p>
</td></tr>
<tr><td><code id="resizeImage_+3A_roi.in">roi.in</code></td>
<td>

<p>The complete path to your original roi.data
</p>
</td></tr>
<tr><td><code id="resizeImage_+3A_roi.out">roi.out</code></td>
<td>

<p>The complete path (filename with extension included) where the new, resized roi.data.RData will be saved
</p>
</td></tr>
<tr><td><code id="resizeImage_+3A_npixels">npixels</code></td>
<td>

<p>As in <code>extractVIs</code> to aggregate more than one pixel
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coupled with spatial analysis and image resize (see <code>extractVIs()</code> and specifically argument <code>npixels</code> for details), this function allows to update a selected image and the correspondent ROI to a smaller size. This is exactly what is done internally when <code>extractVIs()</code> is called with npixels different from 1. The resized image can be used (together with the roi.data object) to plot results from spatially explicit phase extraction. See the vignette &lsquo;spatial&rsquo; for illustrated examples.  
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='spatialFilter'>
Explore all possible fitting and theshold methods from the package phenopix
</h2><span id='topic+spatialFilter'></span>

<h3>Description</h3>

<p>This function allows to fast compute all fitting and thresholding methods on a given greennes time series.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialFilter(spatial.list, filter=c('night','spline', 'max'), 
  filter.options=NULL, 
    ncores='all',log.file=NULL, NDVI=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatialFilter_+3A_spatial.list">spatial.list</code></td>
<td>

<p>An object in output from function <code>extractVIs()</code> with <code>spatial = TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="spatialFilter_+3A_filter">filter</code></td>
<td>

<p>Character names for filters. Chose one (or more) between 'night',
'max', 'spline', 'blue' and 'mad'. The order provided in this argument
determines the order of application of filters. See details for further information on filters.
</p>
</td></tr>
<tr><td><code id="spatialFilter_+3A_filter.options">filter.options</code></td>
<td>

<p>If NULL filter.options defaults to set values, otherwise they must be
specified in a named list. Filter options are designed to work with a wide range of data, 
the user must change them with caution.  
</p>
</td></tr>
<tr><td><code id="spatialFilter_+3A_ncores">ncores</code></td>
<td>

<p>Number of processors to be used in parallel computation, defaults to 'all' which will accidentally slow down any other activity on your computer. Otherwise set the number of processors you want to use in parallelization. 
</p>
</td></tr>
<tr><td><code id="spatialFilter_+3A_log.file">log.file</code></td>
<td>

<p>It can be NULL or a path where to generate and refresh a txt file which logs the progress of the filtering procedure  
</p>
</td></tr>
<tr><td><code id="spatialFilter_+3A_ndvi">NDVI</code></td>
<td>

<p>If TRUE filter is applied to NDVI values, data must be formatted differently from usual filtering. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the same task of <code>autoFilter</code> but in a pixel-by-pixel analysis
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autoFilter">autoFilter</a></code>
</p>

<hr>
<h2 id='spatialGreen'>
Process pixel-based greenness indexes
</h2><span id='topic+spatialGreen'></span>

<h3>Description</h3>

<p>This function allows to filter, fit a curve and extract thresholds in a 
pixel-based analysis exactly as <code>autoFilter</code> and <code>greenProcess</code> 
do in a ROI-based analysis, except that uncertainty cannot be estimated 
(since it would be too computationally intense)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialGreen(filtered.data, fit, threshold, ncores='all', 
  log.file=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatialGreen_+3A_filtered.data">filtered.data</code></td>
<td>

<p>A list as in output from <code>spatialFilter()</code>.   
</p>
</td></tr>
<tr><td><code id="spatialGreen_+3A_fit">fit</code></td>
<td>

<p>A character vector of length 1. Available options are: <code>spline</code>, <code>beck</code>, <code>elmore</code>,
<code>klosterman</code>, <code>gu</code>. 
</p>
</td></tr>
<tr><td><code id="spatialGreen_+3A_threshold">threshold</code></td>
<td>

<p>A character vector of length 1. Available options are: <code>spline</code>, <code>derivatives</code>, 
<code>klosterman</code>, <code>gu</code>.  
</p>
</td></tr>
<tr><td><code id="spatialGreen_+3A_ncores">ncores</code></td>
<td>

<p>Number of processors to be used in parallel computation, defaults to 'all' which will accidentally slow down any other activity on your computer. Otherwise set the number of processors you want to use in parallelization. 
</p>
</td></tr>
<tr><td><code id="spatialGreen_+3A_log.file">log.file</code></td>
<td>

<p>It can be NULL or a path where to generate and refresh a txt file which logs the progress of the filtering procedure   
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to fit a curve and extract thresholds in a 
pixel-based analysis exactly as <code>greenProcess</code> 
does in a ROI-based analysis, except that uncertainty cannot be estimated 
(since it would be too computationally intense). This function takes as first argument 
a list as in output from spatialFilter. For each pixel 
in the ROI the function fits a curve (according to options specified in <code>fit</code>) and 
extracts thresholds (as defined in <code>threshold</code>). This function performs the same task 
that <code>greenProcess</code> does in a ROI-based analysis, except that uncertainty cannot be estimated 
(since it would be too computationally intense). For pixel-based analysis, it is recommended to use 
rather low resolution images or split your region of interest into multiple subROIs (function <code>splitROI</code>. 
A specific vignette for spatial analysis is stored as pdf in the package folder. The user is adviced to carefully read it before
starting a spatial analysis.   
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='SplineFit'>
A function to fit a smoothed spline to Phenological Data
</h2><span id='topic+SplineFit'></span>

<h3>Description</h3>

<p>A function to fit a smoothed spline to Phenological Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplineFit(ts, uncert = FALSE, nrep = 100, df.factor = 0.05, 
ncores='all', sf=quantile(ts, probs=c(0.05, 0.95), na.rm=TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SplineFit_+3A_ts">ts</code></td>
<td>

<p>A ts or zoo object with gcc data. index(ts) must be numeric days of
year (doys)
</p>
</td></tr>
<tr><td><code id="SplineFit_+3A_uncert">uncert</code></td>
<td>

<p>Should uncertainty be estimated?
</p>
</td></tr>
<tr><td><code id="SplineFit_+3A_nrep">nrep</code></td>
<td>

<p>Number of relications to estimate uncertainty, defaults to 100. 
</p>
</td></tr>
<tr><td><code id="SplineFit_+3A_df.factor">df.factor</code></td>
<td>

<p>Defaults to 0.05, it is multiplied by length(ts) to generate degrees 
of freedom for the spline fitting. The higher the number of data, the 
higher should be df factor. For a complete year of data 
(i.e. length(ts)=365) the default value is optimum.</p>
</td></tr>
<tr><td><code id="SplineFit_+3A_ncores">ncores</code></td>
<td>

<p>Unused argument for compatibility
</p>
</td></tr>
<tr><td><code id="SplineFit_+3A_sf">sf</code></td>
<td>

<p>Scaling factors required to normalize the data prior to the fitting. If the function is called by e.g. <code><a href="#topic+greenProcess">greenProcess</a></code> sf is automatically calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a smoothed spline to the data. Df for smoothing are set 
at 0.05*length(ts) by default and df.factor can be modified. 
Uncertainty is estimated by changing the degrees of freedom of the spline. 
In particular a sequence from 0.01 and df.factor, of length nrep is used as 
varying degrees of freedom for the spline fitting. 
</p>


<h3>Value</h3>

<p>A list containing the following items. 
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>A list with fitted values and an object named 'params' set to 
NULL, for simmetry with other fittings</p>
</td></tr>
<tr><td><code>uncertainty</code></td>
<td>
<p>A list containing a zoo data.frame with the
uncertainty predicted values, and an object  named 'params' set to 
NULL, for simmetry with other fittings</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.filtered)
fitted &lt;- SplineFit(bartlett2009.filtered, uncert=TRUE, nrep=50)

## End(Not run)
</code></pre>

<hr>
<h2 id='splitROI'>
Splits a ROI into multiple subrois for spatial analysis
</h2><span id='topic+splitROI'></span>

<h3>Description</h3>

<p>This function allows to split a roi into different subrois for a pixel-based analysis.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitROI(roi.data, nsplit, names=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitROI_+3A_roi.data">roi.data</code></td>
<td>

<p>An object with roi data as in output from DrawROI() function 
</p>
</td></tr>
<tr><td><code id="splitROI_+3A_nsplit">nsplit</code></td>
<td>

<p>The number of sub-rois in which your ROI must be divided into
</p>
</td></tr>
<tr><td><code id="splitROI_+3A_names">names</code></td>
<td>

<p>Optional names for roi. If omitted rois will be progressively numbered (i.e, roi1, roi2, roi3, etc.) 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to split a large ROI into smaller ones. This is needed to make computationally 
feasible the pixel-based analysis with large ROIs and/or high resolution images. As a general indication, 
approx 10000 pixels per sub-ROI is the upper limit for a computationally feasible spatial analysis, 
so set nsplit argument accordingly. The number of pixels in a ROI essentially controls the dimension of the VI.data
object you generate with <code>extractVIs</code> function. A large VI.data object (typically larger than 200 Mb) will fast 
saturate your RAM and slow down the spatial analysis.
</p>


<h3>Value</h3>

<p>A names list of length = nsplit and where each element has the same structure as a roi.data extracted by <code>DrawROI</code>. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='structureFolder'>
Fast structuration of a folder for phenopix process
</h2><span id='topic+structureFolder'></span>

<h3>Description</h3>

<p>This function allows to create subfolders to a folder optimized for the 
phenopix processing. If assigned to an object, all subfolders can be 
accessed in a simple and straightforward way.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structureFolder(path, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="structureFolder_+3A_path">path</code></td>
<td>

<p>The main path where the subdirectories will be created 
</p>
</td></tr>
<tr><td><code id="structureFolder_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code>dir.create</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates 4 subfolders to a given folder. In IMG you will store images to be processed. 
In REF you will put your reference image, i.e. the one that you will use to draw your ROI(s). 
In ROI the RData containing ROI data and one plot for each ROI will be saved. In folder VI
you can save your VI.data.Rdata after have run <code>extractVIs</code>.   
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

<hr>
<h2 id='summarizePhases'>
An evolution of <code><a href="#topic+greenProcess">greenProcess</a></code> for the combination of uncertainty after processing 
</h2><span id='topic+summarizePhases'></span>

<h3>Description</h3>

<p>The <code>combineUncertainty</code> uses <code><a href="#topic+greenProcess">greenProcess</a></code> to fit all available double logistic equations in the phenopix package and extracts thresholds with all available methods. Then uncertainties can be combined and returned by using <code><a href="#topic+summarizePhases">summarizePhases</a></code> and plotted with <code><a href="#topic+plotSum">plotSum</a></code>. 
See <code><a href="#topic+greenProcess">greenProcess</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizePhases(list, quantiles=c(0.25, 0.75), across.methods=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarizePhases_+3A_list">list</code></td>
<td>

<p>An object in output from <code>combineUncertainty</code>
</p>
</td></tr>
<tr><td><code id="summarizePhases_+3A_quantiles">quantiles</code></td>
<td>

<p>The envelope used for the uncertainty
</p>
</td></tr>
<tr><td><code id="summarizePhases_+3A_across.methods">across.methods</code></td>
<td>

<p>If TRUE, gu and klosterman phenophase methods are combined in a single phenophase estimation, and the same happens for derivatives and trs. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code><a href="#topic+greenProcess">greenProcess</a></code> to fit all available double logistic equations in the phenopix package and extracts thresholds with all available methods. Then uncertainties can be combined and returned by using <code><a href="#topic+summarizePhases">summarizePhases</a></code> and plotted with <code><a href="#topic+plotSum">plotSum</a></code>. 
See <code><a href="#topic+greenProcess">greenProcess</a></code>, <code><a href="#topic+summarizePhases">summarizePhases</a></code>, <code><a href="#topic+plotSum">plotSum</a></code>. This function uses a modellistic approach to combine all uncertainties from all available phenopix fittings, as to get an ensemble of phases with different methods, without necessarily choosing any of them. 
</p>


<h3>Value</h3>

<p>A named list with dataframes for each phenophase method with all replication for each of the included fitting methods. These data can then be combined with the companion functions <code><a href="#topic+summarizePhases">summarizePhases</a></code> and <code><a href="#topic+plotSum">plotSum</a></code>. See examples for details. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  require(zoo) 
  data(bartlett2009.filtered)
  combined.fit &lt;- combineUncertainty(na.approx(filtered.tmp$max.filtered), nrep=100)
# 100 replications for each fitting
  names(combined.fit) # a dataframe for each phenoMethod + a list with all fittings
  fit.summary &lt;- summarizePhases(combined.fit, across.methods=TRUE)
## again a list with one element for each fitting method + two additional items 
## if across.methods is TRUE, which combines gu + klosterman phenophase methods 
## in a single method, and the same happens for trs and derivatives
  plotSum(bartlett2009.filtered, fit.summary, which='klosterman')
## a plot with original timeseries + phenophases and their uncertainty
  
## End(Not run)
  </code></pre>

<hr>
<h2 id='summary.phenopix'>
Summary of <code>phenopix</code> objects. 
</h2><span id='topic+summary.phenopix'></span>

<h3>Description</h3>

<p>Summary method for objects of class <code>phenopix</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phenopix'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.phenopix_+3A_object">object</code></td>
<td>

<p>An object of class <code>phenopix</code>
</p>
</td></tr>
<tr><td><code id="summary.phenopix_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints a sintetic summary of the object.
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.filtered)
fitted &lt;- greenProcess(bartlett2009.filtered, 'klosterman', 
  'klosterman', uncert=TRUE, plot=FALSE, nrep=5, ncores=2)
summary(fitted)

## End(Not run)
</code></pre>

<hr>
<h2 id='trainOCR'>
Extract a training dataset for OCR procedure
</h2><span id='topic+trainOCR'></span>

<h3>Description</h3>

<p>This function allows to extract a training dataset for OCR procedure performed by <code>getExposure</code>. It is currently optimized for stardot cameras.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trainOCR(image.path, nsamples=100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trainOCR_+3A_image.path">image.path</code></td>
<td>

<p>The absolute path to a folder of JPEG binary images, as converted from RGB with the function <code>binaryConvert()</code>  
</p>
</td></tr>
<tr><td><code id="trainOCR_+3A_nsamples">nsamples</code></td>
<td>

<p>The maximum number of sampled images to be used. No need to change it.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to prepare a training dataset that will be used in function <code>getExposure()</code>. You need to identify 0-9 numbers and the capital letter E (Exposure), which are then used in <code>getExposure()</code>. 
The procedure makes use of locator to subsequently crop your image, so make sure you know how this function works in your OS. When you run the function a first image pops up on your graphic device. You have to click with the mouse on topleft and bottom right of the rectangle you want to crop. I suggest to crop to the entire string of text with all picture information, so to have the largest sample of numbers in it. When you close locator (right-click in Linux-OS, but likely also GUI-dependent), the cropped image will show up providing a zoom to the selection. The title in the plot helps you to remember which numbers you still have to define. Choose a number (the order you choose numbers does not matter) and make a second crop around it (always topleft, bottomright). Close locator. A third zoom will show up, gridded pixel by pixel. Again, crop your number topleft bottomright with a rectangle that exactly includes all pixels of your number. Close locator. In R command line you will be asked to type the number you have just drawn, or letter E. Type the number and press Enter. You will be prompted to a new image where you follow the procedure again to identify other numbers. When you will ne done with all numbers and E letter, you will get a named list with 11 elements. Each element will be a binary matrix for each of your numbers, and letter E.   
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCoords">getCoords</a></code>
</p>

<hr>
<h2 id='update.phenopix'>
Update <code>phenopix</code> objects. 
</h2><span id='topic+update.phenopix'></span>

<h3>Description</h3>

<p>Update method for objects of class <code>phenopix</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phenopix'
update(object, threshold, envelope, quantiles, uncert, plot, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.phenopix_+3A_object">object</code></td>
<td>

<p>An object of class <code>phenopix</code>
</p>
</td></tr>
<tr><td><code id="update.phenopix_+3A_threshold">threshold</code></td>
<td>

<p>One between 'spline', 'derivatives', 'klosterman', 'gu' 
</p>
</td></tr>
<tr><td><code id="update.phenopix_+3A_envelope">envelope</code></td>
<td>

<p>If left blank is recicled from original fitting. See <code>PhenoExtract</code>
</p>
</td></tr>
<tr><td><code id="update.phenopix_+3A_quantiles">quantiles</code></td>
<td>

<p>If left blank is recicled from original fitting. See <code>PhenoExtract</code>
</p>
</td></tr>
<tr><td><code id="update.phenopix_+3A_uncert">uncert</code></td>
<td>

<p>If left blank is recicled from original fitting. See <code>PhenoExtract</code>
</p>
</td></tr>
<tr><td><code id="update.phenopix_+3A_plot">plot</code></td>
<td>

<p>If left blank is recicled from original fitting. See <code>PhenoExtract</code>
</p>
</td></tr>
<tr><td><code id="update.phenopix_+3A_...">...</code></td>
<td>
  
<p>Plotting arguments. See <code>PhenoExtract</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to update a phenopix object in output from <code>greenProcess</code> to extract
different thresholds withoud refitting the data (which is highly time-consuming when uncertainty
is computed). All arguments except threshold may be left blank and will be recycled from the 
original fit. But the can also be changed. See <code>PhenoExtract</code> where arguments are described 
in detail.
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bartlett2009.filtered)
fitted &lt;- greenProcess(bartlett2009.filtered, 'klosterman', 
  'klosterman', plot=FALSE)
fitted.gu &lt;- update(fitted, 'gu')

## End(Not run)
</code></pre>

<hr>
<h2 id='updateROI'>
Update pixels included in a ROI of different pixel size
</h2><span id='topic+updateROI'></span>

<h3>Description</h3>

<p>This function allows to apply an already drawn ROI to the same image but with different resolution.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateROI(old.roi, new.img)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateROI_+3A_old.roi">old.roi</code></td>
<td>

<p>The roi object
</p>
</td></tr>
<tr><td><code id="updateROI_+3A_new.img">new.img</code></td>
<td>

<p>An image array as read by <code>readJPEG</code> 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to extract pixel information in a ROI on images of different 
quality with respect to the one where the ROI was first drawn. The typical use of 
this function is to work on resized (smaller) images. Typically you draw a ROI on 
your best quality image (say 640 x 480 pixels) and process your images to extract 
vegetation indexes. But if you then want to use the function <code>spatialGreen</code> to 
perform a pixel based analysis you have to reduce image size because the analysis is 
computationally extremely intense. See <code>spatialGreen</code> for more details on 
computation time. Hence, you typically degradate your image (say to 320 x 240 pixels). 
The function applies ROI vertices to the new, resized image and returns pixels in the 
ROI of the new image size. 
</p>


<h3>Author(s)</h3>

<p>Gianluca Filippa &lt;gian.filippa@gmail.com&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
