<!DOCTYPE html><html><head><title>Help for package ctmle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ctmle}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bound'><p>set outliers to min/max allowable values. It assumes x contains only numerical data</p></a></li>
<li><a href='#build_gn_seq'><p>Help function to build the sequence of gn candidates in ctmleGeneral</p></a></li>
<li><a href='#ctmleDiscrete'><p>Discrete Collaborative Targeted Minimum-loss based Estimation</p></a></li>
<li><a href='#ctmleGeneral'><p>General Template for Collaborative Targeted Maximum Likelihood Estimation</p></a></li>
<li><a href='#ctmleGlmnet'><p>Collaborative Targeted Maximum Likelihood Estimation for hyper-parameter tuning of LASSO</p></a></li>
<li><a href='#print.ctmle'><p>print a ctmle object</p></a></li>
<li><a href='#print.summary.ctmle'><p>print the summary of a ctmle object</p></a></li>
<li><a href='#summary.ctmle'><p>Summarise a ctmle object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Collaborative Targeted Maximum Likelihood Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cheng Ju &lt;jucheng1992@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the general template for collaborative targeted maximum likelihood estimation. It also provides several commonly used C-TMLE instantiation, like the vanilla/scalable variable-selection C-TMLE (Ju et al. (2017) &lt;<a href="https://doi.org/10.1177%2F0962280217729845">doi:10.1177/0962280217729845</a>&gt;) and the glmnet-C-TMLE algorithm (Ju et al. (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1706.10029">doi:10.48550/arXiv.1706.10029</a>&gt;). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0), SuperLearner, tmle, glmnet, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, dplyr</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-13 05:53:26 UTC; jucheng</td>
</tr>
<tr>
<td>Author:</td>
<td>Cheng Ju [aut, cre],
  Susan Gruber [aut],
  Richard Wyss [ctb],
  Jenny Haggstrom [ctb],
  Mark van der Laan [aut, ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-13 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bound'>set outliers to min/max allowable values. It assumes x contains only numerical data</h2><span id='topic+bound'></span>

<h3>Description</h3>

<p>set outliers to min/max allowable values. It assumes x contains only numerical data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bound(x, bounds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bound_+3A_x">x</code></td>
<td>
<p>input data</p>
</td></tr>
<tr><td><code id="bound_+3A_bounds">bounds</code></td>
<td>
<p>a vector with length 2, contains the min and max of the bound</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x truncated input x by min/max in bounds
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)
x &lt;- bound(x, c(-1, 1))
</code></pre>

<hr>
<h2 id='build_gn_seq'>Help function to build the sequence of gn candidates in ctmleGeneral</h2><span id='topic+build_gn_seq'></span>

<h3>Description</h3>

<p>This function helps building gn candidates for ctmleGeneral. It returns gn_candidates_cv,
gn_candidates, and folds, which could be directly applied to ctmleGeneral.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_gn_seq(A, W, SL.library, folds, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_gn_seq_+3A_a">A</code></td>
<td>
<p>binary treatment indicator, 1 - treatment, 0 - control</p>
</td></tr>
<tr><td><code id="build_gn_seq_+3A_w">W</code></td>
<td>
<p>vector, matrix, or dataframe containing baseline covariates for Q bar</p>
</td></tr>
<tr><td><code id="build_gn_seq_+3A_sl.library">SL.library</code></td>
<td>
<p>a vector of the names of the estimators for ctmle
(need to be prepared in the format for SL, see more details in SuperLearner package),
The theory of ctmle requires the estimators are ordered by the model complexity,
with the last one be a consistent estimator.</p>
</td></tr>
<tr><td><code id="build_gn_seq_+3A_folds">folds</code></td>
<td>
<p>The list of indices for the ctmle cross-validation step</p>
</td></tr>
<tr><td><code id="build_gn_seq_+3A_verbose">verbose</code></td>
<td>
<p>A boolean. If print out the training log for Super Learne</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gn_candidates_cv matrix or dataframe, each column stand for a estimate of
propensity score. Estimate in the column with larger index should have smaller empirical loss
</p>
<p>gn_candidates matrix or dataframe, each column stand for a the cross-validated estimate.
For example, the (i,j)-th element is the predicted propensity score by j-th estimator,
for i-th observation, when it is in the validation set
</p>
<p>folds The list of indices for the ctmle cross-validation step
</p>
<p>details The SuperLearner object used to generate gn_candidates_cv
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000
p = 100
V = 5
Wmat &lt;- matrix(rnorm(N * p), ncol = p)
gcoef &lt;- matrix(c(-1,-1,rep(-(3/((p)-2)),(p)-2)),ncol=1)

W &lt;- as.data.frame(Wmat)
g &lt;- 1/(1+exp(Wmat%*%gcoef / 3))
A &lt;- rbinom(N, 1, prob = g)

folds &lt;-by(sample(1:N,N), rep(1:V, length=N), list)

lasso_fit &lt;- cv.glmnet(x = as.matrix(W), y = A, alpha = 1, nlambda = 100, nfolds = 10)
lasso_lambdas &lt;- lasso_fit$lambda[lasso_fit$lambda &lt;= lasso_fit$lambda.min][1:5]
# Build template for glmnet
SL.glmnet_new &lt;- function (Y, X, newX, family, obsWeights, id, alpha = 1,
                          nlambda = 100, lambda = 0,...)
{
    # browser()
    if (!is.matrix(X)) {
          X &lt;- model.matrix(~-1 + ., X)
         newX &lt;- model.matrix(~-1 + ., newX)
   }
   fit &lt;- glmnet::glmnet(x = X, y = Y,
                         lambda = lambda,
                         family = family$family, alpha = alpha)
   pred &lt;- predict(fit, newx = newX, type = "response")
     fit &lt;- list(object = fit)
   class(fit) &lt;- "SL.glmnet"
   out &lt;- list(pred = pred, fit = fit)
   return(out)
}

# Use a sequence of estimator to build gn sequence:
SL.cv1lasso &lt;- function (... , alpha = 1, lambda = lasso_lambdas[1]){
   SL.glmnet_new(... , alpha = alpha, lambda = lambda)
}

SL.cv2lasso &lt;- function (... , alpha = 1, lambda = lasso_lambdas[2]){
    SL.glmnet_new(... , alpha = alpha, lambda = lambda)
}

SL.cv3lasso &lt;- function (... , alpha = 1, lambda = lasso_lambdas[3]){
    SL.glmnet_new(... , alpha = alpha, lambda = lambda)
}

SL.cv4lasso &lt;- function (... , alpha = 1, lambda = lasso_lambdas[4]){
     SL.glmnet_new(... , alpha = alpha, lambda = lambda)
}

SL.library = c('SL.cv1lasso', 'SL.cv2lasso', 'SL.cv3lasso', 'SL.cv4lasso', 'SL.glm')

gn_seq &lt;- build_gn_seq(A = A, W = W, SL.library = SL.library, folds = folds)

gn_seq$gn_candidates_cv
gn_seq$gn_candidates
</code></pre>

<hr>
<h2 id='ctmleDiscrete'>Discrete Collaborative Targeted Minimum-loss based Estimation</h2><span id='topic+ctmleDiscrete'></span>

<h3>Description</h3>

<p>This function computes the discrete Collaborative Targeted Minimum-loss based Estimator for variable selection.
It includes the greedy C-TMLE algorithm (Gruber and van der Laan 2010), and scalable C-TMLE algorithm
(Ju, Gruber, and Lendle et al. 2016) with a user-specified order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctmleDiscrete(Y, A, W, Wg = W, Q = NULL, preOrder = FALSE, order = NULL,
  patience = FALSE, Qbounds = NULL, cvQinit = FALSE, Qform = NULL,
  SL.library = NULL, alpha = 0.995, family = "gaussian", gbound = 0.025,
  like_type = "RSS", fluctuation = "logistic", verbose = FALSE,
  detailed = FALSE, PEN = FALSE, V = 5, folds = NULL,
  stopFactor = 10^6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctmleDiscrete_+3A_y">Y</code></td>
<td>
<p>continuous or binary outcome variable</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_a">A</code></td>
<td>
<p>binary treatment indicator, 1 for treatment, 0 for control</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_w">W</code></td>
<td>
<p>vector, matrix, or dataframe containing baseline covariates for Q bar</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_wg">Wg</code></td>
<td>
<p>vector, matrix, or dataframe containing baseline covariates for propensity score model (defaults to W if not supplied by user)</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_q">Q</code></td>
<td>
<p>n by 2 matrix of initial values for Q0W, Q1W in columns 1 and 2, respectively. Current version does not support SL for automatic initial estimation of Q bar</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_preorder">preOrder</code></td>
<td>
<p>boolean indicator for using scalable C-TMLE algorithm or not</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_order">order</code></td>
<td>
<p>the use-specified order of covariables. Only used when (preOrder = TRUE). If not supplied by user,
it would automatically order covariates from W_1 to W_p</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_patience">patience</code></td>
<td>
<p>a number to stop early when the score in the CV function does not improve after so many covariates. Used only when (preOrder = TRUE)</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_qbounds">Qbounds</code></td>
<td>
<p>bound on initial Y and predicted values for Q.</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_cvqinit">cvQinit</code></td>
<td>
<p>if TRUE, cross-validate initial values for Q to avoid overfits</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_qform">Qform</code></td>
<td>
<p>optional regression formula for estimating initial Q</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_sl.library">SL.library</code></td>
<td>
<p>optional vector of prediction algorithms for data adaptive estimation of Q, defaults to glm, and glmnet</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_alpha">alpha</code></td>
<td>
<p>used to keep predicted initial values bounded away from (0,1) for logistic fluctuation, 0.995 (default)</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_family">family</code></td>
<td>
<p>family specification for working regression models, generally 'gaussian' for continuous outcomes (default), 'binomial' for binary outcomes</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_gbound">gbound</code></td>
<td>
<p>bound on P(A=1|W), defaults to 0.025</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_like_type">like_type</code></td>
<td>
<p>'RSS' or 'loglike'. The metric to use for forward selection and cross-validation</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_fluctuation">fluctuation</code></td>
<td>
<p>'logistic' (default) or 'linear', for targeting step</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_verbose">verbose</code></td>
<td>
<p>print status messages if TRUE</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_detailed">detailed</code></td>
<td>
<p>boolean number. If it is TRUE, return more detailed results</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_pen">PEN</code></td>
<td>
<p>boolean. If true, penalized loss is used in cross-validation step</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_v">V</code></td>
<td>
<p>Number of folds. Only used if folds is not specified</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_folds">folds</code></td>
<td>
<p>The list of indices for cross-validation step. We recommend the cv-splits in C-TMLE matchs that in gn_candidate_cv</p>
</td></tr>
<tr><td><code id="ctmleDiscrete_+3A_stopfactor">stopFactor</code></td>
<td>
<p>Numerical value with default 1e6. If the current empirical likelihood is stopFactor times larger than the best previous one, the construction would stop</p>
</td></tr>
</table>


<h3>Value</h3>

<p>best_k  the index of estimate that selected by cross-validation
</p>
<p>est estimate of psi_0
</p>
<p>CI  IC-based 95
</p>
<p>pvalue pvalue for the null hypothesis that Psi = 0
</p>
<p>likelihood sum of squared residuals, based on selected estimator evaluated on all obs or, logistic loglikelihood if like_type != 'RSS'
</p>
<p>varIC empirical variance of the influence curve adjusted for estimation of g
</p>
<p>varDstar empirical variance of the influence curve
</p>
<p>var.psi variance of the estimate
</p>
<p>varIC.cv cross-validated variance of the influence curve
</p>
<p>penlikelihood.cv penalized cross-validated likelihood
</p>
<p>cv.res all cross-validation results for each fold
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
N &lt;- 1000
p = 10
Wmat &lt;- matrix(rnorm(N * p), ncol = p)
beta1 &lt;- 4+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
beta0 &lt;- 2+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
tauW &lt;- 2
tau &lt;- 2
gcoef &lt;- matrix(c(-1,-1,rep(-(3/((p)-2)),(p)-2)),ncol=1)
Wm &lt;- as.matrix(Wmat)
g &lt;- 1/(1+exp(Wm%*%gcoef))
A &lt;- rbinom(N, 1, prob = g)
sigma &lt;- 1
epsilon &lt;-rnorm(N,0,sigma)
Y  &lt;- beta0 + tauW*A + epsilon

# Initial estimate of Q
Q &lt;- cbind(rep(mean(Y[A == 0]), N), rep(mean(Y[A == 1]), N))

# User-suplied initial estimate
time_greedy &lt;- system.time(
ctmle_discrete_fit1 &lt;- ctmleDiscrete(Y = Y, A = A, W = data.frame(Wmat), Q = Q,
                                    preOrder = FALSE)
)

# If there is no input Q, then intial Q would be estimated by SL with Sl.library
ctmle_discrete_fit2 &lt;- ctmleDiscrete(Y = Y, A = A, W = data.frame(Wmat),
                                    preOrder = FALSE, detailed = TRUE)

# scalable C-TMLE with pre-order option; order is user-specified,
# If 'order' is  not specified takes order from W1 to Wp.
time_preorder &lt;- system.time(
ctmle_discrete_fit3 &lt;- ctmleDiscrete(Y = Y, A = A, W = data.frame(Wmat), Q = Q,
                                    preOrder = TRUE,
                                    order = rev(1:p), detailed = TRUE)
)

# Compare the running time
time_greedy
time_preorder

## End(Not run)
</code></pre>

<hr>
<h2 id='ctmleGeneral'>General Template for Collaborative Targeted Maximum Likelihood Estimation</h2><span id='topic+ctmleGeneral'></span>

<h3>Description</h3>

<p>This function computes the Collaborative Targeted Maximum Likelihood Estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctmleGeneral(Y, A, W, Wg = W, Q, ctmletype, gn_candidates,
  gn_candidates_cv = NULL, alpha = 0.995, family = "gaussian",
  gbound = 0.025, like_type = "RSS", fluctuation = "logistic",
  verbose = FALSE, detailed = FALSE, PEN = FALSE, g1W = NULL,
  g1WPrev = NULL, V = 5, folds = NULL, stopFactor = 10^6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctmleGeneral_+3A_y">Y</code></td>
<td>
<p>continuous or binary outcome variable</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_a">A</code></td>
<td>
<p>binary treatment indicator, 1 for treatment, 0 for control</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_w">W</code></td>
<td>
<p>vector, matrix, or dataframe containing baseline covariates for Q bar</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_wg">Wg</code></td>
<td>
<p>vector, matrix, or dataframe containing baseline covariates for propensity score model
(defaults to W if not supplied by user)</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_q">Q</code></td>
<td>
<p>n by 2 matrix of initial values for Q0W, Q1W in columns 1 and 2, respectively.
Current version does not support SL for automatic initial estimation of Q bar</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_ctmletype">ctmletype</code></td>
<td>
<p>1 or 3. Type of general C-TMLE. Type 1 uses cross-validation to select best gn,
while Type 3 directly solves extra clever covariates.</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_gn_candidates">gn_candidates</code></td>
<td>
<p>matrix or dataframe, each column stand for a estimate of propensity score.
Estimate in the column with larger index should have smaller empirical loss</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_gn_candidates_cv">gn_candidates_cv</code></td>
<td>
<p>matrix or dataframe, each column stand for a the cross-validated estimate.
For example, the (i,j)-th element is the predicted propensity score by j-th estimator,
for i-th observation, when it is in the validation set</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_alpha">alpha</code></td>
<td>
<p>used to keep predicted initial values bounded away from (0,1) for logistic fluctuation,
0.995 (default)</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_family">family</code></td>
<td>
<p>family specification for working regression models, generally 'gaussian' for continuous
outcomes (default), 'binomial' for binary outcomes</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_gbound">gbound</code></td>
<td>
<p>bound on P(A=1|W), defaults to 0.025</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_like_type">like_type</code></td>
<td>
<p>'RSS' or 'loglike'. The metric to use for forward selection and cross-validation</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_fluctuation">fluctuation</code></td>
<td>
<p>'logistic' (default) or 'linear', for targeting step</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_verbose">verbose</code></td>
<td>
<p>print status messages if TRUE</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_detailed">detailed</code></td>
<td>
<p>boolean number. If it is TRUE, return more detailed results</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_pen">PEN</code></td>
<td>
<p>boolean. If true, penalized loss is used in cross-validation step</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_g1w">g1W</code></td>
<td>
<p>Only used when type is 3. a user-supplied propensity score estimate.</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_g1wprev">g1WPrev</code></td>
<td>
<p>Only used when type is 3. a user-supplied propensity score estimate,
with small fluctuation compared to g1W.</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_v">V</code></td>
<td>
<p>Number of folds. Only used if folds is not specified</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_folds">folds</code></td>
<td>
<p>The list of indices for cross-validation step. We recommend the cv-splits in C-TMLE matchs that in gn_candidate_cv</p>
</td></tr>
<tr><td><code id="ctmleGeneral_+3A_stopfactor">stopFactor</code></td>
<td>
<p>Numerical value with default 1e6.
If the current empirical likelihood is stopFactor times larger than the best previous one,
the construction would stop</p>
</td></tr>
</table>


<h3>Value</h3>

<p>best_k  the index of estimate that selected by cross-validation
</p>
<p>est estimate of psi_0
</p>
<p>CI  IC-based 95
</p>
<p>pvalue pvalue for the null hypothesis that Psi = 0
</p>
<p>likelihood sum of squared residuals, based on selected estimator evaluated on all obs or, logistic loglikelihood if like_type != &quot;RSS&quot;
</p>
<p>varIC empirical variance of the influence curve adjusted for estimation of g
</p>
<p>varDstar empirical variance of the influence curve
</p>
<p>var.psi variance of the estimate
</p>
<p>varIC.cv cross-validated variance of the influence curve
</p>
<p>penlikelihood.cv penalized cross-validatedlikelihood
</p>
<p>cv.res all cross-validation results for each fold
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000
p = 100
V = 5
Wmat &lt;- matrix(rnorm(N * p), ncol = p)
gcoef &lt;- matrix(c(-1,-1,rep(-(3/((p)-2)),(p)-2)),ncol=1)

W &lt;- as.data.frame(Wmat)
g &lt;- 1/(1+exp(Wmat%*%gcoef / 3))
A &lt;- rbinom(N, 1, prob = g)

# Build potential outcome pairs, and the observed outcome Y
beta1 &lt;- 4+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
beta0 &lt;- 2+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]

tau = 2
sigma &lt;- 1
epsilon &lt;-rnorm(N,0,sigma)
Y  &lt;- beta0 + tau * A + epsilon
# Initial estimate of Q
Q &lt;- cbind(rep(mean(Y[A == 1]), N), rep(mean(Y[A == 0]), N))

folds &lt;-by(sample(1:N,N), rep(1:V, length=N), list)

lasso_fit &lt;- cv.glmnet(x = as.matrix(W), y = A, alpha = 1, nlambda = 100, nfolds = 10)
lasso_lambdas &lt;- lasso_fit$lambda[lasso_fit$lambda &lt;= lasso_fit$lambda.min][1:5]
# Build template for glmnet
SL.glmnet_new &lt;- function (Y, X, newX, family, obsWeights, id, alpha = 1,
                          nlambda = 100, lambda = 0,...)
{
    # browser()
    if (!is.matrix(X)) {
          X &lt;- model.matrix(~-1 + ., X)
         newX &lt;- model.matrix(~-1 + ., newX)
   }
   fit &lt;- glmnet::glmnet(x = X, y = Y,
                         lambda = lambda,
                         family = family$family, alpha = alpha)
   pred &lt;- predict(fit, newx = newX, type = "response")
     fit &lt;- list(object = fit)
   class(fit) &lt;- "SL.glmnet"
   out &lt;- list(pred = pred, fit = fit)
   return(out)
}

# Use a sequence of LASSO estimators to build gn sequence:
SL.cv1lasso &lt;- function (... , alpha = 1, lambda = lasso_lambdas[1]){
   SL.glmnet_new(... , alpha = alpha, lambda = lambda)
}

SL.cv2lasso &lt;- function (... , alpha = 1, lambda = lasso_lambdas[2]){
    SL.glmnet_new(... , alpha = alpha, lambda = lambda)
}

SL.cv3lasso &lt;- function (... , alpha = 1, lambda = lasso_lambdas[3]){
    SL.glmnet_new(... , alpha = alpha, lambda = lambda)
}

SL.cv4lasso &lt;- function (... , alpha = 1, lambda = lasso_lambdas[4]){
     SL.glmnet_new(... , alpha = alpha, lambda = lambda)
}

SL.library = c('SL.cv1lasso', 'SL.cv2lasso', 'SL.cv3lasso', 'SL.cv4lasso', 'SL.glm')

# Build the sequence. See more details in the function build_gn_seq, and package SuperLearner
gn_seq &lt;- build_gn_seq(A = A, W = W, SL.library = SL.library, folds = folds)


# Use the output of build_gn_seq for ctmle general templates
ctmle_fit &lt;- ctmleGeneral(Y = Y, A = A, W = W, Q = Q, ctmletype = 1,
                     gn_candidates = gn_seq$gn_candidates,
                     gn_candidates_cv = gn_seq$gn_candidates_cv,
                     folds = gn_seq$folds, V = length(folds))
</code></pre>

<hr>
<h2 id='ctmleGlmnet'>Collaborative Targeted Maximum Likelihood Estimation for hyper-parameter tuning of LASSO</h2><span id='topic+ctmleGlmnet'></span>

<h3>Description</h3>

<p>This function computes the Collaborative Maximum Likelihood Estimation for hyper-parameter tuning of LASSO.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctmleGlmnet(Y, A, W, Wg = W, Q, lambdas = NULL, ctmletype, V = 5,
  folds = NULL, alpha = 0.995, family = "gaussian", gbound = 0.025,
  like_type = "RSS", fluctuation = "logistic", verbose = FALSE,
  detailed = FALSE, PEN = FALSE, g1W = NULL, g1WPrev = NULL,
  stopFactor = 10^6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctmleGlmnet_+3A_y">Y</code></td>
<td>
<p>continuous or binary outcome variable</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_a">A</code></td>
<td>
<p>binary treatment indicator, 1 for treatment, 0 for control</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_w">W</code></td>
<td>
<p>vector, matrix, or dataframe containing baseline covariates for Q bar</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_wg">Wg</code></td>
<td>
<p>vector, matrix, or dataframe containing baseline covariates for propensity score model (defaults to W if not supplied by user)</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_q">Q</code></td>
<td>
<p>n by 2 matrix of initial values for Q0W, Q1W in columns 1 and 2, respectively. Current version does not support SL for automatic initial estimation of Q bar</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_lambdas">lambdas</code></td>
<td>
<p>numeric vector of lambdas (regularization parameter) for glmnet estimation of propensity score, with decreasing order. We recommend the
first lambda is selected by external cross-validation.</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_ctmletype">ctmletype</code></td>
<td>
<p>1, 2 or 3. Type of general C-TMLE. Type 1 uses cross-validation to select best gn, Type 3 directly solves extra clever covariates,
and Type 2 uses both cross-validation and extra covariate. See more details in !!!</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_v">V</code></td>
<td>
<p>Number of folds. Only used if folds is not specified</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_folds">folds</code></td>
<td>
<p>The list of indices for cross-validation step. We recommend the cv-splits in C-TMLE matchs that in gn_candidate_cv</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_alpha">alpha</code></td>
<td>
<p>used to keep predicted initial values bounded away from (0,1) for logistic fluctuation, 0.995 (default)</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_family">family</code></td>
<td>
<p>family specification for working regression models,
generally 'gaussian' for continuous outcomes (default), 'binomial' for binary outcomes</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_gbound">gbound</code></td>
<td>
<p>bound on P(A=1|W), defaults to 0.025</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_like_type">like_type</code></td>
<td>
<p>'RSS' or 'loglike'. The metric to use for forward selection and cross-validation</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_fluctuation">fluctuation</code></td>
<td>
<p>'logistic' (default) or 'linear', for targeting step</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_verbose">verbose</code></td>
<td>
<p>print status messages if TRUE</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_detailed">detailed</code></td>
<td>
<p>boolean number. If it is TRUE, return more detailed results</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_pen">PEN</code></td>
<td>
<p>boolean. If true, penalized loss is used in cross-validation step</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_g1w">g1W</code></td>
<td>
<p>Only used when type is 3. a user-supplied propensity score estimate.</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_g1wprev">g1WPrev</code></td>
<td>
<p>Only used when type is 3. a user-supplied propensity score estimate, with small fluctuation compared to g1W.</p>
</td></tr>
<tr><td><code id="ctmleGlmnet_+3A_stopfactor">stopFactor</code></td>
<td>
<p>Numerical value with default 1e6. If the current empirical likelihood is stopFactor times larger than the best previous one, the construction would stop</p>
</td></tr>
</table>


<h3>Value</h3>

<p>best_k  the index of estimate that selected by cross-validation
</p>
<p>est estimate of psi_0
</p>
<p>CI  IC-based 95
</p>
<p>pvalue pvalue for the null hypothesis that Psi = 0
</p>
<p>likelihood sum of squared residuals, based on selected estimator evaluated on all obs or,
logistic loglikelihood if like_type != 'RSS'
</p>
<p>varIC empirical variance of the influence curve adjusted for estimation of g
</p>
<p>varDstar empirical variance of the influence curve
</p>
<p>var.psi variance of the estimate
</p>
<p>varIC.cv cross-validated variance of the influence curve
</p>
<p>penlikelihood.cv penalized cross-validatedlikelihood
</p>
<p>cv.res all cross-validation results for each fold
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
N &lt;- 1000
p = 10
Wmat &lt;- matrix(rnorm(N * p), ncol = p)
beta1 &lt;- 4+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
beta0 &lt;- 2+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
tau &lt;- 2
gcoef &lt;- matrix(c(-1,-1,rep(0,(p)-2)),ncol=1)
Wm &lt;- as.matrix(Wmat)
g &lt;- 1/(1+exp(Wm%*%gcoef / 3))
A &lt;- rbinom(N, 1, prob = g)
sigma &lt;- 1
epsilon &lt;-rnorm(N,0,sigma)
Y  &lt;- beta0 + tau * A + epsilon
# ctmleGlmnet must provide user-specified Q
W_tmp &lt;- data.frame(Wm[,1:3])
treated&lt;- W_tmp[which(A==1),]
untreated&lt;-W_tmp[which(A==0),]
Y1&lt;-Y[which(A==1)]
Y0&lt;-Y[which(A==0)]
# Initial Q-estimate
beta1hat &lt;- predict(lm(Y1~.,data=treated),newdata=W_tmp)
beta0hat &lt;- predict(lm(Y0~., data=untreated),newdata=W_tmp)
Q &lt;- matrix(c(beta0hat,beta1hat),ncol=2)
W = Wm
glmnet_fit &lt;- cv.glmnet(y = A, x = Wm,
                       family = 'binomial', nlambda = 40)
start = which(glmnet_fit$lambda==glmnet_fit$lambda.min))
end = length(glmnet_fit$lambda)
lambdas &lt;-glmnet_fit$lambda[start:end]
ctmle_fit1 &lt;- ctmleGlmnet(Y=Y, A=A,
                         W=data.frame(W=W),
                         Q = Q, lambdas = lambdas,
                         ctmletype=1, alpha=.995,
                         family="gaussian",
                         gbound=0.025,like_type="loglik" ,
                         fluctuation="logistic",
                         verbose=FALSE,
                         detailed=FALSE, PEN=FALSE,
                         V=5, stopFactor=10^6)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.ctmle'>print a ctmle object</h2><span id='topic+print.ctmle'></span>

<h3>Description</h3>

<p>print a ctmle object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmle'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ctmle_+3A_x">x</code></td>
<td>
<p>a ctmle object</p>
</td></tr>
<tr><td><code id="print.ctmle_+3A_...">...</code></td>
<td>
<p>other parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
N &lt;- 1000
p = 10
Wmat &lt;- matrix(rnorm(N * p), ncol = p)
beta1 &lt;- 4+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
beta0 &lt;- 2+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
tauW &lt;- 2
tau &lt;- 2
gcoef &lt;- matrix(c(-1,-1,rep(-(3/((p)-2)),(p)-2)),ncol=1)
Wm &lt;- as.matrix(Wmat)
g &lt;- 1/(1+exp(Wm%*%gcoef))
A &lt;- rbinom(N, 1, prob = g)
sigma &lt;- 1
epsilon &lt;-rnorm(N,0,sigma)
Y  &lt;- beta0 + tauW*A + epsilon

# Initial estimate of Q
Q &lt;- cbind(rep(mean(Y[A == 0]), N), rep(mean(Y[A == 1]), N))

# User-suplied initial estimate
time_greedy &lt;- system.time(
ctmle_discrete_fit1 &lt;- ctmleDiscrete(Y = Y, A = A, W = data.frame(Wmat), Q = Q,
                                    preOrder = FALSE)
)
ctmle_summary = summary(ctmle_discrete_fit1)
ctmle_summary
ctmle_discrete_fit1

## End(Not run)
</code></pre>

<hr>
<h2 id='print.summary.ctmle'>print the summary of a ctmle object</h2><span id='topic+print.summary.ctmle'></span>

<h3>Description</h3>

<p>print the summary of a ctmle object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.ctmle'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.ctmle_+3A_x">x</code></td>
<td>
<p>a summary.ctmle object</p>
</td></tr>
<tr><td><code id="print.summary.ctmle_+3A_...">...</code></td>
<td>
<p>other parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
N &lt;- 1000
p = 10
Wmat &lt;- matrix(rnorm(N * p), ncol = p)
beta1 &lt;- 4+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
beta0 &lt;- 2+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
tauW &lt;- 2
tau &lt;- 2
gcoef &lt;- matrix(c(-1,-1,rep(-(3/((p)-2)),(p)-2)),ncol=1)
Wm &lt;- as.matrix(Wmat)
g &lt;- 1/(1+exp(Wm%*%gcoef))
A &lt;- rbinom(N, 1, prob = g)
sigma &lt;- 1
epsilon &lt;-rnorm(N,0,sigma)
Y  &lt;- beta0 + tauW*A + epsilon

# Initial estimate of Q
Q &lt;- cbind(rep(mean(Y[A == 0]), N), rep(mean(Y[A == 1]), N))

# User-suplied initial estimate
time_greedy &lt;- system.time(
ctmle_discrete_fit1 &lt;- ctmleDiscrete(Y = Y, A = A, W = data.frame(Wmat), Q = Q,
                                    preOrder = FALSE)
)
ctmle_summary = summary(ctmle_discrete_fit1)
ctmle_summary
ctmle_discrete_fit1

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.ctmle'>Summarise a ctmle object</h2><span id='topic+summary.ctmle'></span>

<h3>Description</h3>

<p>Summarise a ctmle object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmle'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ctmle_+3A_object">object</code></td>
<td>
<p>a ctmle object</p>
</td></tr>
<tr><td><code id="summary.ctmle_+3A_...">...</code></td>
<td>
<p>other parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
N &lt;- 1000
p = 10
Wmat &lt;- matrix(rnorm(N * p), ncol = p)
beta1 &lt;- 4+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
beta0 &lt;- 2+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
tauW &lt;- 2
tau &lt;- 2
gcoef &lt;- matrix(c(-1,-1,rep(-(3/((p)-2)),(p)-2)),ncol=1)
Wm &lt;- as.matrix(Wmat)
g &lt;- 1/(1+exp(Wm%*%gcoef))
A &lt;- rbinom(N, 1, prob = g)
sigma &lt;- 1
epsilon &lt;-rnorm(N,0,sigma)
Y  &lt;- beta0 + tauW*A + epsilon

# Initial estimate of Q
Q &lt;- cbind(rep(mean(Y[A == 0]), N), rep(mean(Y[A == 1]), N))

# User-suplied initial estimate
time_greedy &lt;- system.time(
ctmle_discrete_fit1 &lt;- ctmleDiscrete(Y = Y, A = A, W = data.frame(Wmat), Q = Q,
                                    preOrder = FALSE)
)
ctmle_summary = summary(ctmle_discrete_fit1)
ctmle_summary
ctmle_discrete_fit1

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
