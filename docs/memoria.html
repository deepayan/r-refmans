<!DOCTYPE html><html lang="en"><head><title>Help for package memoria</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {memoria}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#climate'><p>Dataframe with palaeoclimatic data.</p></a></li>
<li><a href='#computeMemory'><p>Quantifies ecological memory with Random Forest.</p></a></li>
<li><a href='#experimentToTable'><p>Turns the outcome of <code>runExperiment</code> into a long table.</p></a></li>
<li><a href='#extractMemoryFeatures'><p>Extracts ecological memory features on the output of <code>computeMemory</code>.</p></a></li>
<li><a href='#mergePalaeoData'><p>Merges palaeoecological datasets with different time resolution.</p></a></li>
<li><a href='#palaeodata'><p>Dataframe with pollen and climate data.</p></a></li>
<li><a href='#palaeodataLagged'><p>Lagged data generated by <code>prepareLaggedData</code>.</p></a></li>
<li><a href='#palaeodataMemory'><p>Output of <code>computeMemory</code></p></a></li>
<li><a href='#plotExperiment'><p>Plots the output of  <code>runExperiment</code>.</p></a></li>
<li><a href='#plotInteraction'><p>Plots response surfaces for tree-based models.</p></a></li>
<li><a href='#plotMemory'><p>Plots output of <code>computeMemory</code></p></a></li>
<li><a href='#pollen'><p>Dataframe with pollen counts.</p></a></li>
<li><a href='#prepareLaggedData'><p>Organizes time series data into lags.</p></a></li>
<li><a href='#runExperiment'><p>Computes ecological memory patterns on simulated pollen curves produced by the <code>virtualPollen</code> library.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantifying Ecological Memory in Palaeoecological Datasets and
Other Long Time-Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Blas M. Benito</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Blas M. Benito &lt;blasbenito@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to quantify ecological memory in long time-series with Random Forest models (Breiman 2001 &lt;<a href="https://doi.org/10.1023%2FA%3A1010933404324">doi:10.1023/A:1010933404324</a>&gt;) fitted with the 'ranger' library (Wright and Ziegler 2017 &lt;<a href="https://doi.org/10.18637%2Fjss.v077.i01">doi:10.18637/jss.v077.i01</a>&gt;). Particularly oriented to palaeoecological datasets and simulated pollen curves produced by the 'virtualPollen' package, but also applicable to other long time-series involving a set of environmental drivers and a biotic response.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, ranger, cowplot, viridis, viridisLite, zoo, stringr,
HH, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, formatR, kableExtra, magrittr, knitr, rmarkdown,
rpart, rpart.plot, randomForest, virtualPollen</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-05-16 21:43:51 UTC; blas</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-05-17 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='climate'>Dataframe with palaeoclimatic data.</h2><span id='topic+climate'></span>

<h3>Description</h3>

<p>A dataframe containing palaeoclimate data at 1 ky temporal resolution with the following columns:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(climate)
</code></pre>


<h3>Format</h3>

<p>dataframe with 6 columns and 800 rows.</p>


<h3>Details</h3>


<ul>
<li> <p><em>age</em> in kiloyears before present (ky BP).
</p>
</li>
<li> <p><em>temperatureAverage</em> average annual temperature in Celsius degrees.
</p>
</li>
<li> <p><em>rainfallAverage</em> average annual precipitation in milimetres per day (mm/day).
</p>
</li>
<li> <p><em>temperatureWarmestMonth</em> average temperature of the warmest month, in Celsius degrees.
</p>
</li>
<li> <p><em>temperatureColdestMonth</em> average temperature of the coldest month, in Celsius degrees.
</p>
</li>
<li> <p><em>oxigenIsotope</em> delta O18, global ratio of stable isotopes in the sea floor, see <a href="http://lorraine-lisiecki.com/stack.html">http://lorraine-lisiecki.com/stack.html</a> for further details.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>

<hr>
<h2 id='computeMemory'>Quantifies ecological memory with Random Forest.</h2><span id='topic+computeMemory'></span>

<h3>Description</h3>

<p>Takes the oputput of <code><a href="#topic+prepareLaggedData">prepareLaggedData</a></code> to fit the following model with Random Forest:
</p>
<p><code class="reqn">p_{t} = p_{t-1} +...+ p_{t-n} + d_{t} + d_{t-1} +...+ d_{t-n} + r</code>
</p>
<p>where:
</p>

<ul>
<li> <p><code class="reqn">d</code> is a driver (several drivers can be added).
</p>
</li>
<li> <p><code class="reqn">t</code> is the time of any given value of the response <em>p</em>.
</p>
</li>
<li> <p><code class="reqn">t-1</code> is the lag number 1 (in time units).
</p>
</li>
<li> <p><code class="reqn">p_{t-1} +...+ p_{t-n}</code>  represents the endogenous component of ecological memory.
</p>
</li>
<li> <p><code class="reqn">d_{t-1} +...+ d_{t-n}</code>  represents the exogenous component of ecological memory.
</p>
</li>
<li> <p><code class="reqn">d_{t}</code> represents the concurrent effect of the driver over the response.
</p>
</li>
<li> <p><code class="reqn">r</code> represents a column of random values, used to test the significance of the variable importance scores returned by Random Forest.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>computeMemory(
 lagged.data = NULL,
 drivers = NULL,
 response = "Response",
 add.random = TRUE,
 random.mode = "autocorrelated",
 repetitions = 10,
 subset.response = "none",
 min.node.size = 5,
 num.trees = 2000,
 mtry = 2
 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeMemory_+3A_lagged.data">lagged.data</code></td>
<td>
<p>a lagged dataset resulting from <code><a href="#topic+prepareLaggedData">prepareLaggedData</a></code>. See <code><a href="#topic+palaeodataLagged">palaeodataLagged</a></code> as example.</p>
</td></tr>
<tr><td><code id="computeMemory_+3A_drivers">drivers</code></td>
<td>
<p>a character string or vector of character strings with variables to be used as predictors in the model (i.e. c(&quot;Suitability&quot;, &quot;Driver.A&quot;)). <strong>Important:</strong> <code>drivers</code> names must not have the character &quot;_&quot;.</p>
</td></tr>
<tr><td><code id="computeMemory_+3A_response">response</code></td>
<td>
<p>character string, name of the response variable (typically, &quot;Response_0&quot;).</p>
</td></tr>
<tr><td><code id="computeMemory_+3A_add.random">add.random</code></td>
<td>
<p>if TRUE, adds a random term to the model, useful to assess the significance of the variable importance scores.</p>
</td></tr>
<tr><td><code id="computeMemory_+3A_random.mode">random.mode</code></td>
<td>
<p>either &quot;white.noise&quot; or &quot;autocorrelated&quot;. See details.</p>
</td></tr>
<tr><td><code id="computeMemory_+3A_repetitions">repetitions</code></td>
<td>
<p>integer, number of random forest models to fit.</p>
</td></tr>
<tr><td><code id="computeMemory_+3A_subset.response">subset.response</code></td>
<td>
<p>character string with values &quot;up&quot;, &quot;down&quot; or &quot;none&quot;, triggers the subsetting of the input dataset. &quot;up&quot; only models memory on cases where the response's trend is positive, &quot;down&quot; selectes cases with negative trends, and &quot;none&quot; selects all cases.</p>
</td></tr>
<tr><td><code id="computeMemory_+3A_min.node.size">min.node.size</code></td>
<td>
<p>integer, argument of the <a href="ranger.html#topic+ranger">ranger</a> function. Minimal number of samples to be allocated in a terminal node. Default is 5.</p>
</td></tr>
<tr><td><code id="computeMemory_+3A_num.trees">num.trees</code></td>
<td>
<p>integer, argument of the <a href="ranger.html#topic+ranger">ranger</a> function. Number of regression trees to be fitted (size of the forest). Default is 2000.</p>
</td></tr>
<tr><td><code id="computeMemory_+3A_mtry">mtry</code></td>
<td>
<p>integer, argument of the <a href="ranger.html#topic+ranger">ranger</a> function. Number of variables to possibly split at in each node. Default is 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <a href="ranger.html#topic+ranger">ranger</a> package to fit Random Forest models. Please, check the help of the <a href="ranger.html#topic+ranger">ranger</a> function to better understand how Random Forest is parameterized in this library. This function fits the model explained above as many times as defined in the argument <code>repetitions</code>. To test the statistical significance of the variable importance scores returned by random forest, on each repetition the model is fitted with a different <code>r</code> (random) term. If <code>random.mode</code> equals &quot;autocorrelated&quot;, the random term will have a temporal autocorrelation, and if it equals &quot;white.noise&quot;, it will be a pseudo-random sequence of numbers generated with <code><a href="stats.html#topic+rnorm">rnorm</a></code>, with no temporal autocorrelation. The importance of the random sequence (as computed by random forest) is stored for each model run, and used as a benchmark to assess the importance of the other predictors used in the models. Importance values of other predictors that are above the median of the importance of the random term should be interpreted as non-random, and therefore, significant.
</p>


<h3>Value</h3>

<p>A list with 4 slots:
</p>

<ul>
<li> <p><code>memory</code> dataframe with five columns:
</p>

<ul>
<li> <p><code>Variable</code> character, names and lags of the different variables used to model ecological memory.
</p>
</li>
<li> <p><code>median</code> numeric, median importance across <code>repetitions</code> of the given <code>Variable</code> according to Random Forest.
</p>
</li>
<li> <p><code>sd</code> numeric, standard deviation of the importance values of the given <code>Variable</code> across <code>repetitions</code>.
</p>
</li>
<li> <p><code>min</code> and <code>max</code> numeric, percentiles 0.05 and 0.95 of importance values of the given <code>Variable</code> across <code>repetitions</code>.
</p>
</li></ul>

</li>
<li> <p><code>R2</code> vector, values of pseudo R-squared value obtained for the Random Forest model fitted on each repetition. Pseudo R-squared is the Pearson correlation beteween the observed and predicted data.
</p>
</li>
<li> <p><code>prediction</code> dataframe, with the same columns as the dataframe in the slot <code>memory</code>, with the median and confidence intervals of the predictions of all random forest models fitted.
</p>
</li>
<li> <p><code>multicollinearity</code> multicollinearity analysis on the input data performed with <a href="HH.html#topic+vif">vif</a>. A vif value higher than 5 indicates that the given variable is highly correlated with other variables.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotMemory">plotMemory</a></code>, <code><a href="#topic+extractMemoryFeatures">extractMemoryFeatures</a></code>
</p>
<p>##' </p>

<ul>
<li><p> Wright, M. N. &amp; Ziegler, A. (2017). ranger: A fast implementation of random forests for high dimensional data in C++ and R. J Stat Softw 77:1-17. <a href="https://doi.org/10.18637/jss.v077.i01">https://doi.org/10.18637/jss.v077.i01</a>.
</p>
</li>
<li><p> Breiman, L. (2001). Random forests. Mach Learn, 45:5-32. <a href="https://doi.org/10.1023/A:1010933404324">https://doi.org/10.1023/A:1010933404324</a>.
</p>
</li>
<li><p> Hastie, T., Tibshirani, R., Friedman, J. (2009). The Elements of Statistical Learning. Springer, New York. 2nd edition.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#loading data
data(palaeodataLagged)

memory.output &lt;- computeMemory(
 lagged.data = palaeodataLagged,
 drivers = c("climate.temperatureAverage", "climate.rainfallAverage"),
 response = "Response",
 add.random = TRUE,
 random.mode = "autocorrelated",
 repetitions = 10,
 subset.response = "none"
)

str(memory.output)
str(memory.output$memory)

#plotting output
plotMemory(memory.output = memory.output)


</code></pre>

<hr>
<h2 id='experimentToTable'>Turns the outcome of <code><a href="#topic+runExperiment">runExperiment</a></code> into a long table.</h2><span id='topic+experimentToTable'></span>

<h3>Description</h3>

<p>Takes the output of <code><a href="#topic+runExperiment">runExperiment</a></code>, extracts the dataframes containing the ecological memory patterns generated by <code><a href="#topic+computeMemory">computeMemory</a></code>, and binds them together into a single dataframe ready for further analyses or plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>experimentToTable(
 experiment.output = NULL,
 parameters.file = NULL,
 sampling.names = NULL,
 R2 = TRUE
 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="experimentToTable_+3A_experiment.output">experiment.output</code></td>
<td>
<p>list, output of  <code><a href="#topic+runExperiment">runExperiment</a></code>.</p>
</td></tr>
<tr><td><code id="experimentToTable_+3A_parameters.file">parameters.file</code></td>
<td>
<p>dataframe of simulation parameters.</p>
</td></tr>
<tr><td><code id="experimentToTable_+3A_sampling.names">sampling.names</code></td>
<td>
<p>vector of character strings with the names of the columns of <code>simulations.file</code>.</p>
</td></tr>
<tr><td><code id="experimentToTable_+3A_r2">R2</code></td>
<td>
<p>boolean. If TRUE, the average pseudo R-squared of the random forest models used to analyze the ecological memory pattern of the virtual taxa are shown with the taxon traits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally by <code><a href="#topic+plotExperiment">plotExperiment</a></code>, but it is also available to users in case they want to do other kinds of analyses or plots with the data.
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runExperiment">runExperiment</a></code>, <code><a href="#topic+plotExperiment">plotExperiment</a></code>
</p>

<hr>
<h2 id='extractMemoryFeatures'>Extracts ecological memory features on the output of <code><a href="#topic+computeMemory">computeMemory</a></code>.</h2><span id='topic+extractMemoryFeatures'></span>

<h3>Description</h3>

<p>It computes the following features of the ecological memory patterns returned by <code><a href="#topic+computeMemory">computeMemory</a></code>:
</p>

<ul>
<li> <p><code>memory strength</code> maximum difference in relative importance between each component (endogenous, exogenous, and concurrent) and the median of the random component. This is computed for exogenous, endogenous, and concurrent effect.
</p>
</li>
<li> <p><code>memory length</code> proportion of lags over which the importance of a memory component is above the median of the random component. This is only computed for endogenous and exogenous memory.
</p>
</li>
<li> <p><code>dominance</code> proportion of the lags above the median of the random term over which a memory component has a higher importance than the other component. This is only computed for endogenous and exogenous memory.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>extractMemoryFeatures(
 memory.pattern = NULL,
 exogenous.component = NULL,
 endogenous.component = NULL,
 sampling.subset = NULL,
 scale.strength = TRUE
 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractMemoryFeatures_+3A_memory.pattern">memory.pattern</code></td>
<td>
<p>either a list resulting from <code><a href="#topic+computeMemory">computeMemory</a></code>, or a dataframe with memory patterns of several taxa generated by <code><a href="#topic+experimentToTable">experimentToTable</a></code>.</p>
</td></tr>
<tr><td><code id="extractMemoryFeatures_+3A_exogenous.component">exogenous.component</code></td>
<td>
<p>character string or vector of character strings, name of the variable or variables defining the exogenous component.</p>
</td></tr>
<tr><td><code id="extractMemoryFeatures_+3A_endogenous.component">endogenous.component</code></td>
<td>
<p>character string, string, name of the variable defining the endogenous component. If the data was generated by <code><a href="#topic+prepareLaggedData">prepareLaggedData</a></code>, <code>endogenous.component</code> would usually be <code>"Response"</code>.</p>
</td></tr>
<tr><td><code id="extractMemoryFeatures_+3A_sampling.subset">sampling.subset</code></td>
<td>
<p>only relevant when <code>analysis.output</code> is the result of <code>runExperiment</code>. Character string with the name of the column of the list with the simulation outcomes.</p>
</td></tr>
<tr><td><code id="extractMemoryFeatures_+3A_scale.strength">scale.strength</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the strength of the ecological memory components, which has the same units as the importance scores yielded by Random Forest (percentage of increment in mean squared error when a variable is permuted), is scaled between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Warning:</strong> this function only works when only one exogenous component (driver) is used to define the model in <code><a href="#topic+computeMemory">computeMemory</a></code>. If more than one driver is provided throught the argument <code>exogenous.component</code>, the maximum importance scores of all exogenous variables is considered. In other words, the importance of exogenous variables is not additive.
</p>


<h3>Value</h3>

<p>A dataframe with 8 columns and 1 row if <code>memory.pattern</code> is the output of <code><a href="#topic+computeMemory">computeMemory</a></code> and 13 columns and as many rows as taxa are in the input if it is the output of <code><a href="#topic+experimentToTable">experimentToTable</a></code>. The columns are:
</p>

<ul>
<li> <p><em>label</em> character string to identify the taxon. It either inherits its values from <code><a href="#topic+experimentToTable">experimentToTable</a></code>, or sets the default ID as &quot;1&quot;.
</p>
</li>
<li> <p><em>strength.endogenous</em> numeric in the range [0, 100], in importance units (percentage of increment in the mean squared error of the random forest model if the variable is permuted) difference between the maximum importance of the endogenous component at any lag and the median of the random component (see details in <code><a href="#topic+computeMemory">computeMemory</a></code>)
</p>
</li>
<li> <p><em>strength.exogenous</em> numeric in the range [0, 100], same as above, but for the exogenous component.
</p>
</li>
<li> <p><em>strenght.concurrent</em> numeric in the range [0, 100], same as above, but for the concurrent component (driver at lag 0).
</p>
</li>
<li> <p><em>length.endogenous</em> numeric in the range [0, 100], proportion of lags over which the importance of the endogenous memory component is above the median of the random component.
</p>
</li>
<li> <p><em>length.exogenous</em> numeric in the range [0, 1], same as above but for the exogenous memory component.
</p>
</li>
<li> <p><em>dominance.endogenous</em> numeric in the range [0, 1], proportion of the lags above the median of the random term over which a the endogenous memory component has a higher importance than the exogenous component.
</p>
</li>
<li> <p><em>dominance.exogenous</em>, opposite as above.
</p>
</li>
<li> <p><em>maximum.age</em>, numeric. As every column after this one, only provided if <code>memory.pattern</code> is the output of <code><a href="#topic+experimentToTable">experimentToTable</a></code>. Trait of the given taxon.
</p>
</li>
<li> <p><em>fecundity</em> numeric, trait of the given taxon.
</p>
</li>
<li> <p><em>niche.A.mean</em> numeric, trait of the given taxon.
</p>
</li>
<li> <p><em>niche.A.sd</em> numeric, trait of the given taxon.
</p>
</li>
<li> <p><em>sampling</em> numeric, trait of the given taxon.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeMemory">computeMemory</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#loading example data
data(palaeodataMemory)

#computing ecological memory features
memory.features &lt;- extractMemoryFeatures(
  memory.pattern = palaeodataMemory,
  exogenous.component = c(
  "climate.temperatureAverage",
  "climate.rainfallAverage"
  ),
  endogenous.component = "Response",
  sampling.subset = NULL,
  scale.strength = TRUE
  )


</code></pre>

<hr>
<h2 id='mergePalaeoData'>Merges palaeoecological datasets with different time resolution.</h2><span id='topic+mergePalaeoData'></span>

<h3>Description</h3>

<p>It merges palaeoecological datasets with different time intervals between consecutive samples into a single dataset with samples separated by regular time intervals defined by the user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergePalaeoData(
 datasets.list = NULL,
 time.column = NULL,
 interpolation.interval = NULL
 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergePalaeoData_+3A_datasets.list">datasets.list</code></td>
<td>
<p>list of dataframes, as in <code>datasets.list = list(climate = climate.dataframe, pollen = pollen.dataframe)</code>. The provided dataframes must have an age/time column with the same column name and the same units of time. Non-numeric columns in these dataframes are ignored.</p>
</td></tr>
<tr><td><code id="mergePalaeoData_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the time/age column of the datasets provided in <code>datasets.list</code>.</p>
</td></tr>
<tr><td><code id="mergePalaeoData_+3A_interpolation.interval">interpolation.interval</code></td>
<td>
<p>temporal resolution of the output data, in the same units as the age/time columns of the input data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a <code><a href="stats.html#topic+loess">loess</a></code> model of the form <code>y ~ x</code>, where <code>y</code> is any column given by <code>columns.to.interpolate</code> and <code>x</code> is the column given by the <code>time.column</code> argument. The model is used to interpolate column <code>y</code> on a regular time series of intervals equal to <code>interpolation.interval</code>. All columns in every provided dataset go through this process to generate the final data with samples separated by regular time intervals. Non-numeric columns are ignored, and absent from the output dataframe.
</p>


<h3>Value</h3>

<p>A dataframe with every column of the initial dataset interpolated to a regular time grid of resolution defined by <code>interpolation.interval</code>. Column names follow the form datasetName.columnName, so the origin of columns can be tracked.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#loading data
data(pollen)
data(climate)

x &lt;- mergePalaeoData(
 datasets.list = list(
   pollen=pollen,
   climate=climate
 ),
 time.column = "age",
 interpolation.interval = 0.2
 )

 

</code></pre>

<hr>
<h2 id='palaeodata'>Dataframe with pollen and climate data.</h2><span id='topic+palaeodata'></span>

<h3>Description</h3>

<p>A dataframe with a regular time grid of 0.2 ky resolution resulting from applying <code><a href="#topic+mergePalaeoData">mergePalaeoData</a></code> to the datasets <code><a href="#topic+climate">climate</a></code> and <code><a href="#topic+pollen">pollen</a></code>:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(palaeodata)
</code></pre>


<h3>Format</h3>

<p>dataframe with 10 columns and 7986 rows.</p>


<h3>Details</h3>


<ul>
<li> <p><em>age</em> in ky before present (ky BP).
</p>
</li>
<li> <p><em>pinus</em> pollen counts of Pinus.
</p>
</li>
<li> <p><em>quercus</em> pollen counts of Quercus.
</p>
</li>
<li> <p><em>poaceae</em> pollen counts of Poaceae.
</p>
</li>
<li> <p><em>artemisia</em> pollen counts of Artemisia.
</p>
</li>
<li> <p><em>temperatureAverage</em> average annual temperature in Celsius degrees.
</p>
</li>
<li> <p><em>rainfallAverage</em> average annual precipitation in milimetres per day (mm/day).
</p>
</li>
<li> <p><em>temperatureWarmestMonth</em> average temperature of the warmest month, in Celsius degrees.
</p>
</li>
<li> <p><em>temperatureColdestMonth</em> average temperature of the coldest month, in Celsius degrees.
</p>
</li>
<li> <p><em>oxigenIsotope</em> delta O18, global ratio of stable isotopes in the sea floor, see <a href="http://lorraine-lisiecki.com/stack.html">http://lorraine-lisiecki.com/stack.html</a> for further details.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>

<hr>
<h2 id='palaeodataLagged'>Lagged data generated by <code><a href="#topic+prepareLaggedData">prepareLaggedData</a></code>.</h2><span id='topic+palaeodataLagged'></span>

<h3>Description</h3>

<p>A dataframe resulting from the application of <code><a href="#topic+prepareLaggedData">prepareLaggedData</a></code> to the dataset <code><a href="#topic+palaeodata">palaeodata</a></code>. The dataframe columns are:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(palaeodataLagged)
</code></pre>


<h3>Format</h3>

<p>dataframe with 13 columns and 3988 rows.</p>


<h3>Details</h3>


<ul>
<li> <p><em>Response_0</em> numeric, values of the response variable selected by the user in the argument <code>response</code> of the function <code><a href="#topic+prepareLaggedData">prepareLaggedData</a></code>. This column is used as response variable by the function <code><a href="#topic+computeMemory">computeMemory</a></code>. In this case, Response represent pollen counts of Pinus.
</p>
</li>
<li> <p><em>Response_0.2-1</em> numeric, time delayed values of the response for different lags (in ky). Considered together these columns represent the endogenous ecological memory.
</p>
</li>
<li> <p><em>climate.temperatureAverage_0</em> numeric, values of the variable temperatureAverage for the lag 0 (no lag). This column represents the concurrent effect of the temperature over the response.
#'   </p>
</li>
<li> <p><em>climate.rainfallAverage_0</em> numeric, values of the variable rainfallAverage for the lag 0 (no lag). This column represents the concurrent effect of rainfall over the response.
</p>
</li>
<li> <p><em>climate.temperatureAverage_0.2-1</em> numeric, time delayed values of temperatureAverage for lags 0.2 to 1 (in ky).
#'   </p>
</li>
<li> <p><em>climate.rainfallAverage_0.2-1</em> numeric, time delayed values of rainfallAverage for lags 0.2 to 1 (in ky).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>

<hr>
<h2 id='palaeodataMemory'>Output of <code><a href="#topic+computeMemory">computeMemory</a></code></h2><span id='topic+palaeodataMemory'></span>

<h3>Description</h3>

<p>List containing the output of <code><a href="#topic+computeMemory">computeMemory</a></code> applied to <code><a href="#topic+palaeodataLagged">palaeodataLagged</a></code>. Its slots are:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(palaeodataMemory)
</code></pre>


<h3>Format</h3>

<p>List with four slots.</p>


<h3>Details</h3>


<ul>
<li> <p><code>memory</code> dataframe with five columns:
</p>

<ul>
<li> <p><code>Variable</code> character, names and lags of the different variables used to model ecological memory.
</p>
</li>
<li> <p><code>median</code> numeric, median importance across <code>repetitions</code> of the given <code>Variable</code> according to Random Forest.
</p>
</li>
<li> <p><code>sd</code> numeric, standard deviation of the importance values of the given <code>Variable</code> across <code>repetitions</code>.
</p>
</li>
<li> <p><code>min</code> and <code>max</code> numeric, percentiles 0.05 and 0.95 of importance values of the given <code>Variable</code> across <code>repetitions</code>.
</p>
</li></ul>

</li>
<li> <p><code>R2</code> vector, values of pseudo R-squared value obtained for the Random Forest model fitted on each repetition. Pseudo R-squared is the Pearson correlation beteween the observed and predicted data.
</p>
</li>
<li> <p><code>prediction</code> dataframe, with the same columns as the dataframe in the slot <code>memory</code>, with the median and confidence intervals of the predictions of all random forest models fitted.
</p>
</li>
<li> <p><code>multicollinearity</code> multicollinearity analysis on the input data performed with <a href="HH.html#topic+vif">vif</a>. A vif value higher than 5 indicates that the given variable is highly correlated with other variables.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>

<hr>
<h2 id='plotExperiment'>Plots the output of  <code><a href="#topic+runExperiment">runExperiment</a></code>.</h2><span id='topic+plotExperiment'></span>

<h3>Description</h3>

<p>It takes the output of <code><a href="#topic+runExperiment">runExperiment</a></code>, and generates plots of ecological memory patterns for a large number of simulated pollen curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotExperiment(
 experiment.output = NULL,
 parameters.file = NULL,
 experiment.title = NULL,
 sampling.names = NULL,
 legend.position = "bottom",
 R2 = NULL,
 filename = NULL,
 strip.text.size = 12,
 axis.x.text.size = 8,
 axis.y.text.size = 12,
 axis.x.title.size = 14,
 axis.y.title.size = 14,
 title.size = 18,
 caption = ""
 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotExperiment_+3A_experiment.output">experiment.output</code></td>
<td>
<p>list, output of  <code><a href="#topic+runExperiment">runExperiment</a></code>.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_parameters.file">parameters.file</code></td>
<td>
<p>dataframe of simulation parameters.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_experiment.title">experiment.title</code></td>
<td>
<p>character string, title of the plot.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_sampling.names">sampling.names</code></td>
<td>
<p>vector of character strings with the names of the columns used in the argument <code>simulations.file</code> of <code><a href="#topic+runExperiment">runExperiment</a></code>. If <code>NULL</code>, no pdf plot is produced.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_legend.position">legend.position</code></td>
<td>
<p>legend position in ggplot object. One of &quot;bottom&quot;, &quot;right&quot;, &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_r2">R2</code></td>
<td>
<p>boolean. If <code>TRUE</code>, pseudo R-squared values are printed along with the traits of the virtual taxa.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_filename">filename</code></td>
<td>
<p>character string, path and name (without extension) of the output pdf file.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_strip.text.size">strip.text.size</code></td>
<td>
<p>size of the facet's labels.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_axis.x.text.size">axis.x.text.size</code></td>
<td>
<p>size of the labels in x axis.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_axis.y.text.size">axis.y.text.size</code></td>
<td>
<p>size of the labels in y axis.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_axis.x.title.size">axis.x.title.size</code></td>
<td>
<p>size of the title of the x axis.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_axis.y.title.size">axis.y.title.size</code></td>
<td>
<p>size of the title of the y axis.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_title.size">title.size</code></td>
<td>
<p>size of the plot title.</p>
</td></tr>
<tr><td><code id="plotExperiment_+3A_caption">caption</code></td>
<td>
<p>character string, caption of the output figure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotMemory">plotMemory</a></code>, <code><a href="#topic+runExperiment">runExperiment</a></code>
</p>

<hr>
<h2 id='plotInteraction'>Plots response surfaces for tree-based models.</h2><span id='topic+plotInteraction'></span>

<h3>Description</h3>

<p>Plots a response surface plot or interaction plot (2 predictors and a model response) for models of the functions <code><a href="ranger.html#topic+ranger">ranger</a></code>, <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>, and <code><a href="rpart.html#topic+rpart">rpart</a></code>. It also plots the observed data on top of the predicted surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotInteraction(
  model = NULL,
  data = NULL,
  x = NULL,
  y = NULL,
  z = NULL,
  grid = 100,
  point.size.range = c(0.1, 1)
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotInteraction_+3A_model">model</code></td>
<td>
<p>a model object produced by the functions <code><a href="ranger.html#topic+ranger">ranger</a></code>, <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>, or <code><a href="rpart.html#topic+rpart">rpart</a></code>.</p>
</td></tr>
<tr><td><code id="plotInteraction_+3A_data">data</code></td>
<td>
<p>dataframe used to fit the model.</p>
</td></tr>
<tr><td><code id="plotInteraction_+3A_x">x</code></td>
<td>
<p>character string, name of column in <code>data</code> to be plotted in the x axis.</p>
</td></tr>
<tr><td><code id="plotInteraction_+3A_y">y</code></td>
<td>
<p>character string, name of column in <code>data</code> to be plotted in the y axis.</p>
</td></tr>
<tr><td><code id="plotInteraction_+3A_z">z</code></td>
<td>
<p>character string, name of column in <code>data</code> to be plotted as a surface. Generally, the name of the response variable in <code>model</code>.</p>
</td></tr>
<tr><td><code id="plotInteraction_+3A_grid">grid</code></td>
<td>
<p>numeric, resolution of the x and y axes.</p>
</td></tr>
<tr><td><code id="plotInteraction_+3A_point.size.range">point.size.range</code></td>
<td>
<p>numeric vector with two values defining the range size of the points representing the observed data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>

<hr>
<h2 id='plotMemory'>Plots output of <code><a href="#topic+computeMemory">computeMemory</a></code></h2><span id='topic+plotMemory'></span>

<h3>Description</h3>

<p>Plots the ecological memory pattern yielded by <code><a href="#topic+computeMemory">computeMemory</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMemory(
  memory.output = NULL,
  title = "Ecological memory pattern",
  legend.position = "right",
  filename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMemory_+3A_memory.output">memory.output</code></td>
<td>
<p>a dataframe with one time series per column.</p>
</td></tr>
<tr><td><code id="plotMemory_+3A_title">title</code></td>
<td>
<p>character string, name of the numeric column to be used as response in the model.</p>
</td></tr>
<tr><td><code id="plotMemory_+3A_legend.position">legend.position</code></td>
<td>
<p>character vector, names of the numeric columns to be used as predictors in the model.</p>
</td></tr>
<tr><td><code id="plotMemory_+3A_filename">filename</code></td>
<td>
<p>character string, name of output pdf file. If NULL or empty, no pdf is produced. It shouldn't include the extension of the output file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeMemory">computeMemory</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#loading data
data(palaeodataMemory)

#plotting memory pattern
plotMemory(memory.output = palaeodataMemory)


</code></pre>

<hr>
<h2 id='pollen'>Dataframe with pollen counts.</h2><span id='topic+pollen'></span>

<h3>Description</h3>

<p>A dataframe with the following columns:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pollen)
</code></pre>


<h3>Format</h3>

<p>dataframe with 5 columns and 639 rows.</p>


<h3>Details</h3>


<ul>
<li> <p><em>age</em> in kiloyears before present (ky BP).
</p>
</li>
<li> <p><em>pinus</em> pollen counts of Pinus.
</p>
</li>
<li> <p><em>quercus</em> pollen counts of Quercus.
</p>
</li>
<li> <p><em>poaceae</em> pollen counts of Poaceae.
</p>
</li>
<li> <p><em>artemisia</em> pollen counts of Artemisia.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>

<hr>
<h2 id='prepareLaggedData'>Organizes time series data into lags.</h2><span id='topic+prepareLaggedData'></span>

<h3>Description</h3>

<p>Takes a multivariate time series, where at least one variable is meant to be used as a response while the others are meant to be used as predictors in a model, and organizes it in time lags, generating one new column per lag and variable in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareLaggedData(
  input.data = NULL,
  response = NULL,
  drivers = NULL,
  time = NULL,
  oldest.sample = "first",
  lags = NULL,
  time.zoom = NULL,
  scale = FALSE
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepareLaggedData_+3A_input.data">input.data</code></td>
<td>
<p>a dataframe with one time series per column.</p>
</td></tr>
<tr><td><code id="prepareLaggedData_+3A_response">response</code></td>
<td>
<p>character string, name of the numeric column to be used as response in the model.</p>
</td></tr>
<tr><td><code id="prepareLaggedData_+3A_drivers">drivers</code></td>
<td>
<p>character vector, names of the numeric columns to be used as predictors in the model.</p>
</td></tr>
<tr><td><code id="prepareLaggedData_+3A_time">time</code></td>
<td>
<p>character vector, name of the numeric column with the time/age.</p>
</td></tr>
<tr><td><code id="prepareLaggedData_+3A_oldest.sample">oldest.sample</code></td>
<td>
<p>character string, either &quot;first&quot; or &quot;last&quot;. When &quot;first&quot;, the first row taken as the oldest case of the time series and the last row is taken as the newest case, so ecological memory flows from the first to the last row of <code>input.data</code>. When &quot;last&quot;, the last row is taken as the oldest sample, and this is the mode that should be used when <code>input.data</code> represents a palaeoecological dataset. Default behavior is &quot;first&quot;.</p>
</td></tr>
<tr><td><code id="prepareLaggedData_+3A_lags">lags</code></td>
<td>
<p>numeric vector of positive integers, lags to be used in the equation. Generally, a regular sequence of numbers, in the same units as <code>time</code>. The use <code><a href="base.html#topic+seq">seq</a></code> to define it is highly recommended. If 0 is absent from lags, it is added automatically to allow the consideration of a concurrent effect. Lags should take into account the temporal resolution of the data, and be aligned to it. For example, if the interval between consecutive samples is 100 years, lags should be something like <code>0, 100, 200, 300</code>. Lags can also be multiples of the time resolution, such as <code>0, 200, 400, 600</code> (in the case time resolution is 100 years).</p>
</td></tr>
<tr><td><code id="prepareLaggedData_+3A_time.zoom">time.zoom</code></td>
<td>
<p>numeric vector of two numbers of the <code>time</code> column used to subset the data if desired.</p>
</td></tr>
<tr><td><code id="prepareLaggedData_+3A_scale">scale</code></td>
<td>
<p>boolean, if TRUE, applies the <code><a href="base.html#topic+scale">scale</a></code> function to normalize the data. Required if the lagged data is going to be used to fit linear models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function interprets the <code>time</code> column as an index representing the
</p>


<h3>Value</h3>

<p>A dataframe with columns representing time-delayed values of the drivers and the response. Column names have the lag number as a suffix. The response variable is identified in the output as &quot;Response_0&quot;.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeMemory">computeMemory</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#loading data
data(palaeodata)

#adding lags
lagged.data &lt;- prepareLaggedData(
 input.data = palaeodata,
 response = "pollen.pinus",
 drivers = c("climate.temperatureAverage", "climate.rainfallAverage"),
 time = "age",
 oldest.sample = "last",
 lags = seq(0.2, 1, by=0.2),
 time.zoom=NULL,
 scale=FALSE
)
str(lagged.data)

</code></pre>

<hr>
<h2 id='runExperiment'>Computes ecological memory patterns on simulated pollen curves produced by the <code>virtualPollen</code> library.</h2><span id='topic+runExperiment'></span>

<h3>Description</h3>

<p>Applies <code><a href="#topic+computeMemory">computeMemory</a></code> to assess ecological memory on a large set of virtual pollen curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runExperiment(
 simulations.file = NULL,
 selected.rows = 1,
 selected.columns = 1,
 parameters.file = NULL,
 parameters.names = NULL,
 sampling.names = NULL,
 driver.column = NULL,
 response.column = "Response_0",
 subset.response = "none",
 time.column = "Time",
 time.zoom = NULL,
 lags = NULL,
 repetitions = 10
 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runExperiment_+3A_simulations.file">simulations.file</code></td>
<td>
<p>list of dataframes, output of  the function <code>simulatePopulation</code> of the <code>virtualPollen</code> library.</p>
</td></tr>
<tr><td><code id="runExperiment_+3A_selected.rows">selected.rows</code></td>
<td>
<p>numeric vector, rows (virtual taxa) of <code>simulations.file</code> to be analyzed.</p>
</td></tr>
<tr><td><code id="runExperiment_+3A_selected.columns">selected.columns</code></td>
<td>
<p>numeric.vector, columns (experiment treatments) of <code>simulations.file</code> to be analyzed.</p>
</td></tr>
<tr><td><code id="runExperiment_+3A_parameters.file">parameters.file</code></td>
<td>
<p>dataframe of simulation parameters.</p>
</td></tr>
<tr><td><code id="runExperiment_+3A_parameters.names">parameters.names</code></td>
<td>
<p>vector of character strings with names of traits and niche features from <code>parameters.file</code> to be included in the analysis (i.e. c(&quot;maximum.age&quot;, &quot;fecundity&quot;, &quot;niche.A.mean&quot;, &quot;niche.A.sd&quot;))</p>
</td></tr>
<tr><td><code id="runExperiment_+3A_sampling.names">sampling.names</code></td>
<td>
<p>vector of character strings with the names of the columns of <code>simulations.file</code>.</p>
</td></tr>
<tr><td><code id="runExperiment_+3A_driver.column">driver.column</code></td>
<td>
<p>vector of character strings, names of the columns to be considered as drivers (generally, one of &quot;Suitability&quot;, &quot;Driver.A&quot;, &quot;Driver.B).</p>
</td></tr>
<tr><td><code id="runExperiment_+3A_response.column">response.column</code></td>
<td>
<p>character string defining the response variable, typically &quot;Response_0&quot;.</p>
</td></tr>
<tr><td><code id="runExperiment_+3A_subset.response">subset.response</code></td>
<td>
<p>character string, one of &quot;up&quot;, &quot;down&quot; or &quot;none&quot;, triggers the subsetting of the input dataset. &quot;up&quot; only models ecological memory on cases where the response's trend is positive, &quot;down&quot; selectes cases with negative trends, and &quot;none&quot; selects all cases.</p>
</td></tr>
<tr><td><code id="runExperiment_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the time/age column. Usually, &quot;Time&quot;.</p>
</td></tr>
<tr><td><code id="runExperiment_+3A_time.zoom">time.zoom</code></td>
<td>
<p>numeric vector with two numbers defining the time/age extremes of the time interval of interest.</p>
</td></tr>
<tr><td><code id="runExperiment_+3A_lags">lags</code></td>
<td>
<p>ags numeric vector of positive integers, lags to be used in the equation. Generally, a regular sequence of numbers, in the same units as <code>time</code>. The use <code><a href="base.html#topic+seq">seq</a></code> to define it is highly recommended. If 0 is absent from lags, it is added automatically to allow the consideration of a concurrent effect. Lags should take into account the temporal resolution of the data, and be aligned to it. For example, if the interval between consecutive samples is 100 years, lags should be something like <code>0, 100, 200, 300</code>. Lags can also be multiples of the time resolution, such as <code>0, 200, 400, 600</code> (in the case time resolution is 100 years).</p>
</td></tr>
<tr><td><code id="runExperiment_+3A_repetitions">repetitions</code></td>
<td>
<p>integer, number of random forest models to fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 slots:
</p>

<ul>
<li> <p><code>names</code> matrix of character strings, with as many rows and columns as <code>simulations.file</code>. Each cell holds a simulation name to be used afterwards, when plotting the results of the ecological memory analysis.
</p>
</li>
<li> <p><code>output</code> a list with as many columns and columns as <code>simulations.file</code>. Each slot holds a an output of <code><a href="#topic+computeMemory">computeMemory</a></code>.
</p>

<ul>
<li> <p><code>memory</code> dataframe with five columns:
</p>

<ul>
<li> <p><code>Variable</code> character, names and lags of the different variables used to model ecological memory.
</p>
</li>
<li> <p><code>median</code> numeric, median importance across <code>repetitions</code> of the given <code>Variable</code> according to Random Forest.
</p>
</li>
<li> <p><code>sd</code> numeric, standard deviation of the importance values of the given <code>Variable</code> across <code>repetitions</code>.
</p>
</li>
<li> <p><code>min</code> and <code>max</code> numeric, percentiles 0.05 and 0.95 of importance values of the given <code>Variable</code> across <code>repetitions</code>.
</p>
</li></ul>

</li>
<li> <p><code>R2</code> vector, values of pseudo R-squared value obtained for the Random Forest model fitted on each repetition. Pseudo R-squared is the Pearson correlation beteween the observed and predicted data.
</p>
</li>
<li> <p><code>prediction</code> dataframe, with the same columns as the dataframe in the slot <code>memory</code>, with the median and confidence intervals of the predictions of all random forest models fitted.
</p>
</li>
<li> <p><code>multicollinearity</code> multicollinearity analysis on the input data performed with <code><a href="HH.html#topic+vif">vif</a></code>. A vif value higher than 5 indicates that the given variable is highly correlated with other variables.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeMemory">computeMemory</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
