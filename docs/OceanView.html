<!DOCTYPE html><html><head><title>Help for package OceanView</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OceanView}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#OceanView-package'>
<p>Functions for visualising oceanic data sets and model output.</p></a></li>
<li><a href='#Chesapeake data set'>
<p>Particle transport in Chesapeake Bay</p></a></li>
<li><a href='#Map and extract data'>
<p>Functions for remapping, changing the resolution, and extracting from 2-D or 3-D data.</p></a></li>
<li><a href='#Matrix plotting'>
<p>Functions for plotting matrices, or for splitting them and for maing suitable summaries</p></a></li>
<li><a href='#Moving slices in 3D'>
<p>Plotting volumetric data as moving slices in 3D using rgl</p></a></li>
<li><a href='#Moving surfaces in 3D'>
<p>Plotting moving surfaces in 3D using rgl</p></a></li>
<li><a href='#NIOZ Westerschelde monitoring'>
<p>NIOZ monitoring data of Westerschelde estuary.</p></a></li>
<li><a href='#Profile data set'>
<p>Temperature profiles made along a ship track.</p></a></li>
<li><a href='#Quiver and flow paths'>
<p>Plots velocities as arrows or as trajectory plots.</p></a></li>
<li><a href='#Reshaping to a crosstable'>
<p>Converts a dataset from database-format to a cross table</p></a></li>
<li><a href='#Sylt data set'>
<p>Hydrodynamic model output (getm) of Sylt-Romo Bight</p></a></li>
<li><a href='#Tracers in 2D'>
<p>Plots tracer distributions in 2-D.</p></a></li>
<li><a href='#Tracers in 3D'>
<p>Plotting tracer distributions in 3D</p></a></li>
<li><a href='#vector plots'>
<p>Vector velocity plot.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Title:</td>
<td>Visualisation of Oceanographic Data and Model Output</td>
</tr>
<tr>
<td>Author:</td>
<td>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>plot3D, plot3Drgl, R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, graphics, grDevices, stats, rgl, shape</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for transforming and viewing 2-D and 3-D (oceanographic) data and model output.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3.0)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 13:36:17 UTC; karlines</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-06 13:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='OceanView-package'>
Functions for visualising oceanic data sets and model output.
</h2><span id='topic+OceanView-package'></span><span id='topic+OceanView'></span>

<h3>Description</h3>

<p>Visualisation of oceanic data.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert
</p>


<h3>References</h3>

<p><a href="https://www.rforscience.com/oceanview.html">https://www.rforscience.com/oceanview.html</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+db2cross">db2cross</a>, converts a dataset from database format to cross table.
</p>
<p><a href="#topic+flowpath">flowpath</a>, plots velocities as trajectory plot.
</p>
<p><a href="#topic+remap">remap</a>, <a href="#topic+transect">transect</a>, 
<a href="#topic+extract">extract</a>, <a href="#topic+mapsigma">mapsigma</a>, <a href="#topic+transectsigma">transectsigma</a>, 
mapping and extracting from 2-D or 3-D data.
</p>
<p><a href="#topic+Mcommon">Mcommon</a>, <a href="#topic+Mplot">Mplot</a>, <a href="#topic+Msplit">Msplit</a>,
functions for plotting matrices.
</p>
<p><a href="#topic+quiver2D">quiver2D</a>, velocities plotted as arrows. 
</p>
<p><a href="#topic+vectorplot">vectorplot</a>, vector velocity plot.
</p>

<hr>
<h2 id='Chesapeake+20data+20set'>
Particle transport in Chesapeake Bay
</h2><span id='topic+Chesapeake'></span><span id='topic+Ltrans'></span>

<h3>Description</h3>

<p><code>Chesapeake</code> is a <code>list</code> with the bathymetry of Chesapeake Bay, Mid-Atlantic Bight
and the initial position of the particles.
</p>
<p><code>Ltrans</code> is an <code>array</code> with output of the Lagrangian Transport model (Ltrans v.2) from
Chesapeake Bay mouth, at 37 dgN in the Mid-Atlantic Bight (Schlag and North, 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Chesapeake)
data(Ltrans)
</code></pre>


<h3>Format</h3>


<ul>
<li> <p><code>Chesapeake</code> is a <code>list</code> with the bathymetry of the area. 
There are 154 x-values, at 77 y-values. 
</p>
<p>It contains:
</p>

<ul>
<li> <p><code>lon</code>, the longitude, (154 x 77), dg East.
</p>
</li>
<li> <p><code>lat</code>, the latitude, (154 x 77), dg North.
</p>
</li>
<li> <p><code>depth</code>, the bathymetry (154 x 77), metres.  
</p>
</li>
<li> <p><code>init</code>, the initial condition of the particles, a (608 x 4) matrix
with (<code>lon, lat, depth, source</code>) values.
</p>
</li></ul>

</li>
<li> <p><code>Ltrans</code> contains output of the Lagrangian particle transport model, 
in the Chesapeake mouth area. 608 particles were released in two square regions, 
and their positions followed over 108 output steps. It is an array of dimension
(608 x 4 x 108), and which contains for each of the 608 particles, and at each 
of the 108 output steps the following:
</p>

<ul>
<li> <p><code>lon</code>, the longitude of each particle.
</p>
</li>
<li> <p><code>lat</code>, the latitude of each particle.
</p>
</li>
<li> <p><code>depth</code>, the depth of each particle.
</p>
</li>
<li> <p><code>source</code>, the square region of release, either <code>1</code> or <code>2</code>.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Schlag, Z. R., and E. W. North. 2012. Lagrangian TRANSport model (LTRANS v.2) User's Guide. 
University of Maryland Center for Environmental Science, Horn Point Laboratory. Cambridge, MD. 183 pp.
</p>
<p>North, E. W., E. E. Adams, S. Schlag, C. R. Sherwood, R. He, S. Socolofsky. 2011. 
Simulating oil droplet dispersal from the Deepwater Horizon spill with a Lagrangian approach. 
AGU Book Series: Monitoring and Modeling the Deepwater Horizon Oil Spill: A Record Breaking Enterprise.
</p>


<h3>See Also</h3>

<p><a href="#topic+Sylt3D">Sylt3D</a> for output of a 3-D hydrodynamical model, GETM.
</p>
<p><a href="plot3D.html#topic+Oxsat">Oxsat</a> for a 3-D data set, package <code>plot3D</code>.
</p>
<p><a href="#topic+tracers2D">tracers2D</a> for plotting time series of tracer distributions in 2D
</p>
<p><a href="#topic+tracers3D">tracers3D</a> for plotting time series of tracer distributions in 3D
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")
 mar &lt;- par("mar")
   
## =============================================================================
## Show bathymetry and initial distribution of particles
## =============================================================================  

 par(mfrow = c(1, 1))

 lon &lt;- Chesapeake$lon
 lat &lt;- Chesapeake$lat
 depth &lt;- Chesapeake$depth
 init  &lt;- Chesapeake$init
 
 image2D(z = depth, x = lon, y = lat, clab = c("depth", "m"), 
   xlab = "lon", ylab = "lat")

# position of particles 
 with (init, scatter2D(lon, lat, colvar = source, pch = 16, cex = 0.5, 
   col =  c("green", "orange"), add = TRUE, colkey = FALSE))

 par (mar = c(2, 2, 2, 2))
# same, as persp plot
 persp3D(x = lon, y = lat, z = -depth, scale = FALSE, 
   expand = 0.02, main = "initial particle distribution", 
   plot = FALSE)

 points3D(x = init$lon, y = init$lat, z = -init$depth, 
  colvar = init$source, col = c("green", "orange"), 
  pch = 16, cex = 0.5, 
  add = TRUE, colkey = FALSE, plot = FALSE)

## Not run: 
   plotdev(lighting = TRUE, lphi = 45)

## End(Not run) 
 plotrgl(lighting = TRUE, smooth = TRUE)

## =============================================================================
## Tracer output in 3D, traditional device
## =============================================================================  
## Not run: 
 par(mfrow = c(2, 1), mar = c(2, 2, 2, 2)) 
 for (i in c(50, 100))
   tracers3D(Ltrans[, 1, i], Ltrans[, 2, i], Ltrans[, 3, i], 
             colvar = Ltrans[ ,4, i], col = c("green", "orange"),
             pch = 16, cex = 0.5, 
             surf = list(x = lon, y = lat, z = -depth, scale = FALSE, 
               expand = 0.02, colkey = FALSE, shade = 0.3, 
               colvar = depth), colkey = FALSE,
             main = paste("time ", i))

## End(Not run)

## =============================================================================
## Tracer output in 3D, using rgl
## =============================================================================  

 persp3D(x = lon, y = lat, z = -depth, colvar = depth, scale = FALSE, 
   expand = 0.02, main = "particle distribution", plot = FALSE)

 plotrgl(lighting = TRUE, smooth = TRUE) 
 
# you may zoom to the relevant region, or cut a region
# cutrgl()  
 for (i in seq(1, 108, by = 4)) {
   tracers3Drgl(Ltrans[, 1, i], Ltrans[, 2, i], Ltrans[, 3, i], 
             colvar = Ltrans[ ,4, i], col = c("green", "orange"),
             main = paste("time ", i))
# remove # to slow down
#   Sys.sleep(0.1)  
 }  

# using function moviepoints3D
## Not run: 
 persp3Drgl(x = lon, y = lat, z = -depth, colvar = depth, scale = FALSE, 
   expand = 0.02, main = "particle distribution", 
   lighting = TRUE, smooth = TRUE) 

 nt &lt;- dim(Ltrans)[3]  # number of time points
 np &lt;- dim(Ltrans)[1]  # number of particles
 
 times &lt;- rep(1:nt, each = np)
 
 moviepoints3D(x = Ltrans[, 1, ], y = Ltrans[, 2, ], z = Ltrans[, 3, ], 
               t = times, colvar = Ltrans[ ,4, ], col = c("green", "orange"),
               cex = 5, ask = TRUE)


## End(Not run)
## =============================================================================
## Tracer output in 2D, traditional device
## =============================================================================  

 par(mfrow = c(2, 2)) 
 for (i in seq(10, 106, length.out = 4)) 
   tracers2D(Ltrans[, 1, i], Ltrans[, 2, i],  
             colvar = Ltrans[ ,4, i], col = c("green", "orange"),
             pch = 16, cex = 0.5, 
             image = list(x = lon, y = lat, z = depth), colkey = FALSE,
             main = paste("time ", i))

## =============================================================================
## Tracer output in 2D, rgl
## =============================================================================  
 
 image2Drgl (x = lon, y = lat, z = depth)
 for (i in seq(1, 108, by = 3)) {
   tracers2Drgl(Ltrans[, 1, i], Ltrans[, 2, i],  
             colvar = Ltrans[ ,4, i], col = c("green", "orange"))
# remove # to slow down
#   Sys.sleep(0.1)  
 }  

# reset plotting parameters
 par(mar = mar)
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='Map+20and+20extract+20data'>
Functions for remapping, changing the resolution, and extracting from 2-D or 3-D data.
</h2><span id='topic+remap'></span><span id='topic+remap.matrix'></span><span id='topic+remap.array'></span><span id='topic+changeres'></span><span id='topic+changeres.matrix'></span><span id='topic+changeres.array'></span><span id='topic+extract'></span><span id='topic+extract.matrix'></span><span id='topic+extract.array'></span><span id='topic+transect'></span><span id='topic+mapsigma'></span><span id='topic+mapsigma.matrix'></span><span id='topic+mapsigma.array'></span><span id='topic+transectsigma'></span>

<h3>Description</h3>

<p>S3 functions <code>remap</code> maps a variable (<code>var</code>) (a <code>matrix</code> or <code>array</code>)
with <code>x</code>, <code>y</code> (and <code>z</code>) coordinates 
to a <code>matrix</code> or <code>array</code> with coordinates given by <code>xto</code>, <code>yto</code> (and <code>zto</code>).
<code>x, y, z, xto, yto</code> and <code>zto</code> are all vectors.
The functions interpolate to all combinations of <code>xto, yto</code> and <code>zto</code>. 
Simple 2-D linear interpolation is used. 
Result is a <code>matrix</code> or <code>array</code>.
</p>
<p>Function <code>changeres</code> changes the resolution of a variable (<code>var</code>) (a <code>matrix</code> or <code>array</code>)
with <code>x</code>, <code>y</code> (and <code>z</code>) coordinates.
If <code>var</code> is a matrix, then <code>x, y</code> can be either a vector or a matrix; if 
<code>var</code> is an array, then <code>x, y, z</code> should all be vectors.
Simple 2-D linear interpolation is used. 
Result is a <code>matrix</code> or <code>array</code>.
</p>
<p>S3-functions <code>extract</code> map a variable (<code>var</code>) from a matrix with (x, y) coordinates
or from an array with (x, y, z) coordinates to the xy 
coordinate <em>pair</em> <code>xyto</code> or xyz coordinate <em>triplets</em> <code>xyzto</code>
by linear interpolation. Result is a vector.
</p>
<p><code>transect</code> takes a cross section across an array (<code>var</code>). 
Result is a matrix.
</p>
<p><code>mapsigma</code> maps a matrix or array <code>var</code> containing values defined at (x, sigma) (or (x, y, sigma)) coordinates 
to (x, depth) (or (x, y, depth)) coordinates.
The depths corresponding to the sigma values in <code>var</code> are in an input matrix or array called <code>sigma</code> with same dimensions as <code>var</code>.
The result is a matrix or array which will contain <code>NA</code>s where the depth-coordinates
extend beyond the sigma values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remap        (var, ...)
  
## S3 method for class 'matrix'
remap(var, x, y, xto = NULL, yto = NULL, 
          na.rm = TRUE, ...)

## S3 method for class 'array'
remap(var, x, y, z, xto = NULL, yto = NULL, zto = NULL, 
          na.rm = TRUE, ...)

changeres    (var, ...)
  
## S3 method for class 'matrix'
changeres(var, x, y, resfac, na.rm = TRUE, ...)

## S3 method for class 'array'
changeres(var, x, y, z, resfac, na.rm = TRUE, ...)

extract    (var, ...)

## S3 method for class 'matrix'
extract(var, x, y, xyto, ...)

## S3 method for class 'array'
extract(var, x, y, z, xyzto, ...)

transect(var, x, y, z, to, margin = "xy", ...)

mapsigma   (var, ...)
  
## S3 method for class 'matrix'
mapsigma(var = NULL, sigma, signr = 2, x = NULL,  
    depth = NULL, numdepth = NULL, xto = NULL, resfac = 1, ...)
    
## S3 method for class 'array'
mapsigma(var = NULL, sigma, signr = 3, x = NULL, y = NULL, 
    depth = NULL, numdepth = NULL, xto = NULL, yto = NULL, 
    resfac = 1, ...)

transectsigma(var = NULL, sigma, x, y, to, depth = NULL, 
                numdepth = NULL, resfac = 1, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_var">var</code></td>
<td>
<p>Matrix or array with values to be mapped to other coordinates (<code>remap</code>),
or to lower or higher resolution (<code>changeres</code>), 
or whose values have to be extracted (<code>extract</code>, <code>transect</code>),
or which has to be mapped from sigma to depth coordinates (<code>mapsigma</code>).
For <code>transect</code> and <code>transectsigma</code>, <code>var</code> has to be an array.
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_x">x</code></td>
<td>
<p>Vector with original x-coordinates of the matrix or array <code>var</code> to be mapped.
Length should be = first dimension of <code>var</code>.  
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_y">y</code></td>
<td>
<p>Vector with original y-coordinates of the matrix or array <code>var</code> to be mapped. 
Length should be = second dimension of <code>var</code>.  
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_z">z</code></td>
<td>
<p>Vector with original z-coordinates of the array <code>var</code> to be mapped. 
Length should be = third dimension of <code>var</code>.  
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_xto">xto</code></td>
<td>
<p>Vector with x-coordinates to which <code>var</code> should be mapped.
The elements in <code>xto</code> should be embraced by the elements in <code>x</code>
(it is not allowed to extrapolate outside of the region).
If <code>NULL</code> then the range of <code>x</code> is covered, with the same number of points.
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_yto">yto</code></td>
<td>
<p>Vector with y-coordinates to which <code>var</code> should be mapped. 
The elements in <code>yto</code> should be embraced by the elements in <code>y</code>
(it is not allowed to extrapolate outside of the region).
If <code>NULL</code> then the range of <code>y</code> is covered, with the same number of points.
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_zto">zto</code></td>
<td>
<p>Vector with z-coordinates to which <code>var</code> should be mapped.
The elements in <code>zto</code> should be embraced by the elements in <code>z</code>
(it is not allowed to extrapolate outside of the region).
If <code>NULL</code> then the range of <code>z</code> is covered, with the same number of points.
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_xyto">xyto</code></td>
<td>
<p>Two-columned matrix, with first and second column specifying the 
x- respectively y-coordinates to which the matrix <code>var</code> should be mapped. 
The elements should be embraced by the elements in <code>x</code> (first column)
and <code>y</code> (second column)
(it is not allowed to extrapolate outside of the region).
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_xyzto">xyzto</code></td>
<td>
<p>Three-columned matrix, specifying the x-, y- and z-coordinates 
to which the array <code>var</code> should be mapped. 
The elements should be embraced by the elements in <code>x</code>, <code>y</code> 
and <code>z</code>
(it is not allowed to extrapolate outside of the region).
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_to">to</code></td>
<td>
<p>Two-columned matrix, specifying the values along the <code>margin</code> coordinates
of the transect to be taken on the array <code>var</code>. 
The elements should be embraced by the elements in <code>x</code>, <code>y</code> 
and <code>z</code>
(it is not allowed to extrapolate outside of the region).
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_margin">margin</code></td>
<td>
<p>String with the names of the coordinates in the matrix <code>to</code>, 
and along which the transect is to be taken on the array <code>var</code>. 
One of <code>"xy", "xz", "yz"</code>. If <code>"xy"</code>, then the first and second 
column in input <code>to</code> represent <code>x</code> and <code>y</code> values respectively,
and the transect will select all <code>z</code> values corresponding with these
inputs.
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_sigma">sigma</code></td>
<td>
<p>The sigma coordinates, a matrix or array with the same dimension 
as <code>var</code>. The sigma coordinates should 
refer to the column as defined by <code>signr</code>.
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_signr">signr</code></td>
<td>
<p>The position of the sigma coordinates, in the matrix or array. 
The default is the second or third dimension in <code>var</code> for a <code>matrix</code>
and <code>array</code> respectively.
</p>
</td></tr>    
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_depth">depth</code></td>
<td>
<p>The depth (often referred to as 'z') coordinates to which matrix 
<code>var</code> has to be mapped. 
If <code>NULL</code> then <code>seq(min(sigma), max(sigma), length.out = numdepth)</code>. 
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_numdepth">numdepth</code></td>
<td>
<p>Only used when <code>depth= NULL</code>, the length of the <code>depth</code> vector to 
which the matrix <code>var</code> has to be mapped. 
If <code>NULL</code> then the length will be equal to <code>ncol(var)</code> (if <code>var</code> is a matrix),
or <code>dim(var)[3]</code> in case <code>var</code> is an array. 
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_resfac">resfac</code></td>
<td>
<p>Resolution factor, one value or a vector of two or three numbers, 
for the x, y- and z- values respectively. 
A value &gt; 1 will increase the resolution. For instance, if <code>resfac</code> 
equals <code>3</code> then for each adjacent pair of x- and y- values, 
<code>var</code> will be interpolated to two intermediary points. 
This uses simple linear interpolation. 
If <code>resfac</code> is one number then the resolution will be increased similarly 
in x, y- and z-direction. 
In case of <code>mapsigma</code>, <code>resfac</code> is overruled if <code>xto</code>, <code>yto</code> or <code>zto</code> is specified.
</p>
</td></tr>
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_na.rm">na.rm</code></td>
<td>
<p>How to treat <code>NA</code>s in the matrix or array <code>var</code>.
If <code>TRUE</code>, they are ignored while interpolating; this will make the 
size of <code>NA</code> regions smaller; if <code>FALSE</code>, the size of the <code>NA</code> 
region will increase.
</p>
</td></tr>  
<tr><td><code id="Map+2B20and+2B20extract+2B20data_+3A_...">...</code></td>
<td>
<p>any other arguments.
</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>S3-function <code>remap</code> can be used to increase or decrease 
the resolution of a matrix or array <code>var</code>, or to zoom in on a certain area. 
It returns an object of the same class as <code>var</code> (i.e. a matrix or array).
</p>
<p>S3-function <code>transect</code> takes a slice from an array; it returns a matrix.
</p>
<p>S3-function <code>extract</code> returns a vector with one value
corresponding to each row in <code>xyto</code> or <code>xyzto</code>.
</p>
<p><code>mapsigma</code> should be used to make images from data that are in sigma 
coordinates.
</p>


<h3>Value</h3>

<p><code>remap.matrix</code>: 
</p>
<table>
<tr><td><code>var</code></td>
<td>
<p>The higher or lower resolution matrix 
with dimension = c(length(xto), length(yto)).
</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The x coordinates, corresponding to first dimension of <code>var</code>
(input argument <code>xto</code>).
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The y coordinates, corresponding to second dimension of <code>var</code>
(input argument <code>yto</code>).
</p>
</td></tr>
</table>
<p><code>remap.array</code>: 
</p>
<table>
<tr><td><code>var</code></td>
<td>
<p>The higher or lower resolution array, 
with dimension = c(length(xto), length(yto), length(zto)).
</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The x coordinates, corresponding to first dimension of <code>var</code>
(input argument <code>xto</code>).
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The y coordinates, corresponding to second dimension of <code>var</code>
(input argument <code>yto</code>).
</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>The z coordinates, corresponding to third dimension of <code>var</code>
(input argument <code>zto</code>).
</p>
</td></tr>
</table>
<p><code>extract.matrix</code>:
</p>
<table>
<tr><td><code>var</code></td>
<td>
<p>The higher or lower resolution object, 
with dimension = c(nrow(xyto), dim(var)[3]).
</p>
</td></tr>
<tr><td><code>xy</code></td>
<td>
<p>The pairs of (x,y) coordinates
(input argument <code>xyto</code>).
</p>
</td></tr>
</table>
<p><code>extract.array</code>:
</p>
<table>
<tr><td><code>var</code></td>
<td>
<p>The higher or lower resolution object, 
with dimension = c(nrow(xyzto), dim(var)[3]).
</p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p>The triplets of (x,y,z) coordinates
(input argument <code>xyzto</code>).
</p>
</td></tr>
</table>
<p><code>mapsigma</code>: 
</p>
<table>
<tr><td><code>var</code></td>
<td>
<p>A matrix with columns in depth-coordinates.
</p>
</td></tr>
<tr><td><code>depth</code></td>
<td>
<p>The depth-coordinates, also known as 'z'-coordinates, 
referring to the dimension of <code>var</code> as specified by <code>signr</code>.
</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The 'x'-coordinates referring to the first dimension of <code>var</code>, except for the depth.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Only if <code>var</code> is an array, the 'y'-coordinates referring to the second dimension of <code>var</code>, except for the depth.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+Sylt3D">Sylt3D</a> for other examples of mapping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")

## =======================================================================
## Simple examples
## =======================================================================
 M &lt;- matrix(nrow = 2, data = 1:4)
 remap(M, x = 1:2, y = 1:2, 
   xto = seq(1, 2, length.out = 3), yto = 1:2) 
 
 changeres(M, x = 1:2, y = 1:2, resfac = c(2, 1))
 changeres(M, x = 1:2, y = 1:2, resfac = 2)

# x and or y are a matrix.
 changeres(var = M, x = M, y = 1:2, resfac = c(2, 1))
 changeres(M, x = M, y = 1:2, resfac = 2)

  
## =======================================================================
## Use remap to add more detail to a slice3D plot
## =======================================================================

 par(mfrow = c(1, 1))
 x &lt;- y &lt;- z &lt;- seq(-4, 4, by = 0.5)
 M &lt;- mesh(x, y, z)

 R &lt;- with (M, sqrt(x^2 + y^2 + z^2))
 p &lt;- sin(2*R) /(R+1e-3)

 slice3D(x, y, z, ys = seq(-4, 4, by = 2), theta = 85, 
   colvar = p, pch = ".", clim = range(p))

 xto &lt;- yto &lt;- zto &lt;- seq(-1.2, 1.2, 0.3)
 Res &lt;- remap (p, x, y, z, xto, yto, zto)

# expand grid for scatterplot
 Mt  &lt;- mesh(Res$x, Res$y, Res$z)

 scatter3D(x = Mt$x, y = Mt$y, z = Mt$z, colvar = Res$var, 
   pch = ".", add = TRUE, cex = 3, clim = range(p))

# same in rgl:
 ## Not run: 
   plotrgl()
 
## End(Not run)

# extract specific values from 3-D data
 xyzto &lt;- matrix(nrow = 2, ncol = 3, data = c(1,1,1,2,2,2), byrow = TRUE)
 extract(var = p, x, y, z, xyzto = xyzto)

# a transect
 to &lt;- cbind(seq(-4, 4, length.out = 20), seq(-4, 4, length.out = 20))
 image2D( transect(p, x, y, z, to = to)$var)

## =======================================================================
## change the resolution of a 2-D image
## =======================================================================

 par(mfrow = c(2, 2))
 nr &lt;- nrow(volcano)
 nc &lt;- ncol(volcano)

 x  &lt;- 1 : nr
 y  &lt;- 1 : nc
 image2D(x = x, y = y, volcano, main = "original")

# increasing the resolution
 x2 &lt;- seq(from = 1, to = nr, by = 0.5)
 y2 &lt;- seq(from = 1, to = nc, by = 0.5)

 VOLC1 &lt;- remap(volcano, x = x, y = y, xto = x2, yto = y2)$var
 image2D(x = x2, y = y2, z = VOLC1, main = "high resolution")

# low resolution
 xb &lt;- seq(from = 1, to = nr, by = 2)
 yb &lt;- seq(from = 1, to = nc, by = 3)
 VOLC2 &lt;- remap(volcano, x, y, xb, yb)$var
 image2D(VOLC2, main = "low resolution")

# zooming in high resolution
 xc &lt;- seq(10, 40, 0.1)
 yc &lt;- seq(10, 40, 0.1)

 VOLC3 &lt;- remap(volcano,x, y, xc, yc)$var
 image2D(VOLC3, main = "zoom")

# Get one value or a grid of values
 remap(volcano, x, y, xto = 2.5,     yto = 5)
 remap(volcano, x, y, xto = c(2, 5), yto = c(5, 10))

# Specific values
 extract(volcano, x, y, xyto = cbind(c(2, 5), c(5, 10)))
 
## =======================================================================
## take a cross section or transect of volcano
## =======================================================================
 
 par(mfrow = c(2, 1)) 
 image2D(volcano, x = 1:nr, y = 1:nc)
 xyto &lt;- cbind(seq(from = 1,  to = nr, length.out = 20),
               seq(from = 20, to = nc, length.out = 20))
 points(xyto[,1], xyto[,2], pch = 16)

 (Crossection &lt;- extract (volcano, x = 1:nr, y = 1:nc,
                             xyto = xyto))

 scatter2D(xyto[, 1], Crossection$var, colvar = Crossection$var, 
   type = "b", cex = 2, pch = 16)

## =======================================================================
##  mapsigma: changing from sigma coordinates into depth-coordinates
## =======================================================================

 par(mfrow = c(2, 2))
 var &lt;- t(matrix (nrow = 10, ncol = 10, data = rep(1:10, times = 10)))
 image2D(var, ylab = "sigma", main = "values in sigma coordinates",
       clab = "var")

 # The depth at each 'column' 
 Depth &lt;- approx(x = 1:5, y = c(10, 4, 5, 6, 4), 
                 xout = seq(1,5, length.out = 10))$y
 Depth &lt;- rep(Depth, times = 10)
 
# Sigma coordinates
 sigma &lt;- t(matrix(nrow = 10, ncol = 10, data = Depth, byrow = TRUE) * 
                seq(from = 0, to = 1, length = 10))
 matplot(sigma, type = "l", main = "sigma coordinates", 
         xlab = "sigma", ylab = "depth", ylim = c(10, 0))

# Mapping to the default depth coordinates
 varz &lt;- mapsigma(var = var, sigma = sigma)
 image2D(varz$var, y = varz$depth, NAcol = "black", ylim = c(10, 0), 
       clab = "var", ylab = "depth", 
       main = "depth-coord, low resolution")

# Mapping at higher resolution of depth coordinates
 varz &lt;- mapsigma(var, sigma = sigma, resfac = 10)
 image2D(varz$var, y = varz$depth, NAcol = "black", ylim = c(10, 0), 
       clab = "var", ylab = "depth", 
       main = "depth-coord, high resolution")

## =======================================================================
##  mapsigma: mapping to depth for data Sylttran (x, sigma, time)
## =======================================================================

# depth values 
 D &lt;- seq(-1, 20, by = 0.5)
 dim(Sylttran$visc)

# sigma coordinates are the second dimension (signr)
# resolution is increased for 'x' and decreased for 'time'
 
 visc &lt;- mapsigma(Sylttran$visc, x = Sylttran$x, y = Sylttran$time,
  sigma = Sylttran$sigma, signr = 2, depth = D, resfac = c(2, 1, 0.4))

# changed dimensions 
 dim(visc$var)

 image2D(visc$var, x = visc$x, y = -visc$depth, ylim = c(-20, 1), 
  main = paste("eddy visc,", format(visc$y, digits = 2), " hr"), 
  ylab = "m", xlab = "x", clab = c("","m2/s"), 
  clim = range(visc$var, na.rm = TRUE))
  
 par(mfrow = c(1, 1))
# make depth the last dimension
 cv &lt;- aperm(visc$var, c(1, 3, 2))

# visualise as slices
 slice3D(colvar = cv, x = visc$x, y = visc$y, z = -visc$depth, 
   phi = 10, theta = 60, ylab = "time",
   xs = NULL, zs = NULL, ys = visc$y, NAcol = "transparent")

# restore plotting parameters
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='Matrix+20plotting'>
Functions for plotting matrices, or for splitting them and for maing suitable summaries
</h2><span id='topic+Mplot'></span><span id='topic+Msplit'></span><span id='topic+Mcommon'></span><span id='topic+Msummary'></span><span id='topic+Mdescribe'></span>

<h3>Description</h3>

<p><code>Mplot</code> plots data from (a list of) matrices. 
</p>
<p><code>Msplit</code> splits a matrix in a list according to factors (or unique values).
</p>
<p><code>Mcommon</code> creates a list of matrices that have only common variables.
</p>
<p><code>Msummary</code> and <code>Mdescribe</code> create suitable summaries of all columns of a matrix or list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Mplot (M, ..., x = 1, select = NULL, which = select, 
         subset = NULL, ask = NULL, 
         legend = list(x = "center"), pos.legend = NULL,
         xyswap = FALSE, rev = "") 

  Msummary (M, ..., 
         select = NULL, which = select, 
         subset = NULL) 

  Mdescribe (M, ..., 
         select = NULL, which = select, 
         subset = NULL) 

  Msplit (M, split = 1, subset = NULL) 

  Mcommon (M, ..., verbose = FALSE)      


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matrix+2B20plotting_+3A_m">M</code></td>
<td>
<p>Matrix or data.frame to be plotted, or treated. For <code>Mplot</code>, <code>M</code> can be
a list with matrices or data.frames. 
</p>
</td></tr>
<tr><td><code id="Matrix+2B20plotting_+3A_x">x</code></td>
<td>
<p>Name or number of the column to be used as the x-values. 
</p>
</td></tr>
<tr><td><code id="Matrix+2B20plotting_+3A_select">select</code></td>
<td>
<p>Which variable/columns to be selected.  This is added for
consistency with the R-function <code>subset</code>.
</p>
</td></tr>
<tr><td><code id="Matrix+2B20plotting_+3A_which">which</code></td>
<td>
<p>The name(s) or the index to the variables that should be
plotted or selected.  Default = all variables, except <code>time</code>. 
</p>
</td></tr>
<tr><td><code id="Matrix+2B20plotting_+3A_subset">subset</code></td>
<td>
<p>Logical expression indicating elements or rows to keep in 
<code>select</code>: missing values are taken as <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="Matrix+2B20plotting_+3A_ask">ask</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the user is <em>ask</em>ed before
each plot, if <code>NULL</code> the user is only asked if more than one
page of plots is necessary and the current graphics device is set
interactive, see <code><a href="graphics.html#topic+par">par</a>(ask)</code> and
<code><a href="grDevices.html#topic+dev.interactive">dev.interactive</a></code>.
</p>
</td></tr>
<tr><td><code id="Matrix+2B20plotting_+3A_legend">legend</code></td>
<td>
<p>A <code>list</code> with parameters for the legend 
to be added. If <code>FALSE</code>, then no legend will be drawn.
</p>
</td></tr> 
<tr><td><code id="Matrix+2B20plotting_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The position of the legend, a number. The default
is to put the legend in the last figure. 
Also allowed is <code>pos.legend = 0</code>, 
which will create a new figure with only the legend.
</p>
</td></tr> 
<tr><td><code id="Matrix+2B20plotting_+3A_xyswap">xyswap</code></td>
<td>
<p>If <code>TRUE</code>, then the x- and y-values will be swapped.
</p>
</td></tr> 
<tr><td><code id="Matrix+2B20plotting_+3A_rev">rev</code></td>
<td>
<p>a character string which contains &quot;x&quot; if the x axis is to be 
reversed, &quot;y&quot; if the y axis is to be reversed and &quot;xy&quot; or &quot;yx&quot; 
if both axes are to be reversed.
</p>
</td></tr> 
<tr><td><code id="Matrix+2B20plotting_+3A_split">split</code></td>
<td>
<p>The name or number of the column with the factor 
according to which the matrix will be split. 
</p>
</td></tr> 
<tr><td><code id="Matrix+2B20plotting_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> will write output to the screen. 
</p>
</td></tr> 
<tr><td><code id="Matrix+2B20plotting_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the methods. For <code>Mplot</code>:
can also be extra matrices to plot. 
The arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>Msplit</code> returns a list with the matrices, split according to 
the factors; the names of the elements is set by the factor's name. 
It is similar to the R-function <a href="base.html#topic+split">split</a>.
</p>
<p>Function <code>Mcommon</code> returns a list with the matrices, which only have
the common variables.
</p>
<p>Function <code>Msummary</code> returns a data.frame with summary values (minimum,
first quantile, median, mean, 3rd quantile, maximum) for each 
column of the input (variable). If there are more than one object to be summarised, or
if M is a list of objects, the name of the object is in the second column.
</p>
<p>Function <code>Mdescribe</code> returns a data.frame with summary values (number of data, 
number of missing values, number of unique values, mean value, the standard deviation,
the minimum, the p = 0.05, 0.1, 0.5, 0.9, 0.95 quantiles, and the maximum) for each 
column of the input (variable). If there are more than one object to be summarised, or
if M is a list of objects, the name of the object is in the second column.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")

## =======================================================================
## Create three dummy matrices
## =======================================================================

 M1 &lt;- matrix(nrow = 10, ncol = 5, data = 1:50)
 colnames(M1) &lt;- LETTERS[1:5]

 M2 &lt;- M1[, c(1, 3, 4, 5, 2)] 
 M2[ ,-1] &lt;- M2[,-1] /2
 colnames(M2)[3] &lt;- "CC"  # Different name

 M3 &lt;- matrix(nrow = 5, ncol = 4, data = runif(20)*10) 
 M3[,1] &lt;- sort(M3[,1])
 colnames(M3) &lt;- colnames(M1)[-3]

# show them
 head(M1); head(M2); head(M3)
 Msummary(M1)
 Msummary(M1, M2, M3)

# plot all columns of M3 -  will change mfrow 
 Mplot(M3, type = "b", pch = 18, col = "red")

# plot results of all three data sets
 Mplot(M1, M2, M3, lwd = 2, mtext = "All variables versus 1st column",
       legend = list(x = "top", legend = c("M1", "M2", "M3")))


## =======================================================================
## Plot a selection or only common elements
## =======================================================================

 Mplot(M1, M2, M3, x = "B", select = c("A", "E"), pch = c(NA, 16, 1), 
       type = c("l", "p", "b"), col = c("black", "red", "blue"),  
       legend = list(x = "right", legend = c("M1", "M2", "M3")))

 Mplot(Mcommon(M1, M2, M3), lwd = 2, mtext = "common variables", 
       legend = list(x = "top", legend = c("M1", "M2", "M3")))

 Mdescribe(Mcommon(M1, M2, M3))
 
## =======================================================================
## The iris and Orange data set
## =======================================================================

# Split the matrix according to the species
 Irislist &lt;- Msplit(iris, split = "Species")
 names(Irislist)
 
 Mdescribe(Irislist, which = "Sepal.Length")
 Mdescribe(iris, which = "Sepal.Length", subset = Species == "setosa")

# legend in a separate plot
 Mplot(Irislist, type = "p", pos.legend = 0,
       legend = list(x = "center", title = "species"))

 Mplot(Msplit(Orange,1), lwd = 2,
       legend = list(x = "topleft", title = "tree nr"))
 Msummary(Msplit(Orange,1))

# reset plotting parameters
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='Moving+20slices+20in+203D'>
Plotting volumetric data as moving slices in 3D using rgl
</h2><span id='topic+movieslice3D'></span>

<h3>Description</h3>

<p><code>movieslice3D</code> plots 3D volumetric data as slices moving in one direction
in open-GL graphics. 
</p>
<p>It is based on the <code>plot3Drgl</code> function <a href="plot3Drgl.html#topic+slice3Drgl">slice3Drgl</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movieslice3D (x, y, z, colvar = NULL, xs = NULL,
  ys = NULL, zs = NULL, along = NULL,
  col = jet.col(100), NAcol = "white", breaks = NULL,
  colkey = FALSE, clim = NULL, clab = NULL,
  wait  = NULL, ask = FALSE, add = FALSE, basename = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_x">x</code>, <code id="Moving+2B20slices+2B20in+2B203D_+3A_y">y</code>, <code id="Moving+2B20slices+2B20in+2B203D_+3A_z">z</code></td>
<td>
<p>Vectors with x, y and z-values. 
They should be of length equal to the first, second and 
third dimension of <code>colvar</code> respectively.
</p>
</td></tr>
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring. 
It should be an array of dimension equal to 
<code>c(length(x), length(y), length(z))</code>.
It must be present.
</p>
</td></tr>
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_col">col</code></td>
<td>
<p>Colors to be used for coloring the <code>colvar</code> variable. 
If <code>col</code> is <code>NULL</code> 
then a red-yellow-blue colorscheme (<a href="plot3D.html#topic+jet.col">jet.col</a>) will be used.
</p>
</td></tr>
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_nacol">NAcol</code></td>
<td>
<p>Colors to be used for <code>colvar</code> values that are <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters
for the color key (legend).
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr>
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the color variable values.
Values of <code>colvar</code> that extend the range will be put to <code>NA</code> and colored
as specified with <code>NAcol</code>.
</p>
</td></tr> 
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey</code> is not <code>NULL</code> or <code>FALSE</code>,
the label to be written on top of the color key.
The label will be written at the same level as the main title.
To lower it, <code>clab</code> can be made a vector, with the first values empty
strings.
</p>
</td></tr>
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_xs">xs</code>, <code id="Moving+2B20slices+2B20in+2B203D_+3A_ys">ys</code>, <code id="Moving+2B20slices+2B20in+2B203D_+3A_zs">zs</code></td>
<td>
<p>Vectors specify the positions in x, y or z where the slices (planes) are to be drawn consecutively.
The movie will loop over the slices, each time projecting the values of <code>colvar</code> on them.
If all <code>xs, ys, zs</code> are <code>NULL</code>, then <code>xs</code> will be taken equal to <code>x</code>.
</p>
</td></tr> 
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_along">along</code></td>
<td>
<p>A number 1, 2, 3 denoting the dimension over which the slices are to be moved. 
If <code>NULL</code>, then the dimension will be the one corresponding to the longest vector <code>xs, ys, zs</code>. 
</p>
</td></tr>     
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the slices will be added to the current plot.
If <code>FALSE</code> a new plot is started. 
</p>
</td></tr>     
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_ask">ask</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the new slice will only be drawn after a key has been struck. If <code>FALSE</code>, redrawing will depend on <code>wait</code> 
</p>
</td></tr>     
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_wait">wait</code></td>
<td>
<p>The time interval inbetween drawing of a new slice, in seconds. 
If <code>NULL</code>, the drawing will not be suspended. 
</p>
</td></tr>     
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_basename">basename</code></td>
<td>
<p>The base name of a <code>png</code> file to be produced for each movieframe. 
</p>
</td></tr>     
<tr><td><code id="Moving+2B20slices+2B20in+2B203D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <a href="plot3D.html#topic+slice3D">slice3D</a> from package 
<code>plot3D</code> or to <code>plotrgl</code> from package <code>plot3Drgl</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns nothing
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+Sylt3D">Sylt3D</a> for a data set that can be displayed with <code>movieslice3D</code>
</p>
<p><a href="#topic+moviepoints3D">moviepoints3D</a> for plotting moving points in 3D
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- y &lt;- z &lt;- seq(-1, 1, by = 0.1)
 grid   &lt;- mesh(x, y, z)
 colvar &lt;- with(grid, x*exp(-x^2 - y^2 - z^2))

 movieslice3D  (x, y, z, colvar = colvar, ticktype = "detailed")

</code></pre>

<hr>
<h2 id='Moving+20surfaces+20in+203D'>
Plotting moving surfaces in 3D using rgl
</h2><span id='topic+moviepersp3D'></span>

<h3>Description</h3>

<p><code>moviepersp3D</code> plots moving perspective plots of a surface in open-GL.
</p>
<p>It is based on the <code>plot3Drgl</code> function <a href="plot3Drgl.html#topic+persp3Drgl">persp3Drgl</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moviepersp3D (z, x = NULL, y = NULL, t = NULL, colvar = z, tdim = 1,
  col = jet.col(100), NAcol = "white", breaks = NULL,
  colkey = FALSE, clim = NULL, clab = NULL,
  wait  = NULL, ask = FALSE, add = FALSE, basename = NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_x">x</code>, <code id="Moving+2B20surfaces+2B20in+2B203D_+3A_y">y</code>, <code id="Moving+2B20surfaces+2B20in+2B203D_+3A_t">t</code></td>
<td>
<p>Vectors with x, y and t-values.
Their position in the z-array depends on <code>tdim</code>.
</p>
</td></tr>
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_z">z</code></td>
<td>
<p>Three-dimensional array with the z-values to be plotted.
</p>
</td></tr>
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_tdim">tdim</code></td>
<td>
<p>Index to where the <code>time</code> variable (over which the plot will loop)
is to be found in <code>z</code> and <code>colvar</code>. The default is the first position,
so that <code>z</code> and <code>colvar</code> are of dimension <code>(length(t), length(x), (length(y)</code>.
</p>
</td></tr>
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring.
It should be an array of dimension equal to the dimension of <code>z</code>.
It need not be present.
</p>
</td></tr>
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_col">col</code></td>
<td>
<p>Colors to be used for coloring the <code>colvar</code> variable. 
If <code>col</code> is <code>NULL</code> 
then a red-yellow-blue colorscheme (<a href="plot3D.html#topic+jet.col">jet.col</a>) will be used.
</p>
</td></tr>
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_nacol">NAcol</code></td>
<td>
<p>Colors to be used for <code>colvar</code> values that are <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_breaks">breaks</code></td>
<td>
<p>A set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters
for the color key (legend).
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr>
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the color variable values.
Values of <code>colvar</code> that extend the range will be put to <code>NA</code> and colored
as specified with <code>NAcol</code>.
</p>
</td></tr> 
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey</code> is not <code>NULL</code> or <code>FALSE</code>,
the label to be written on top of the color key.
The label will be written at the same level as the main title.
To lower it, <code>clab</code> can be made a vector, with the first values empty
strings.
</p>
</td></tr>
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the slices will be added to the current plot.
If <code>FALSE</code> a new plot is started. 
</p>
</td></tr>     
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_ask">ask</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the new slice will only be drawn after a key has been struck. If <code>FALSE</code>, redrawing will depend on <code>wait</code> 
</p>
</td></tr>     
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_wait">wait</code></td>
<td>
<p>The time interval inbetween drawing of a new slice, in seconds. 
If <code>NULL</code>, the drawing will not be suspended. 
</p>
</td></tr>     
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_basename">basename</code></td>
<td>
<p>The base name of a <code>png</code> file to be produced for each movieframe. 
</p>
</td></tr>     
<tr><td><code id="Moving+2B20surfaces+2B20in+2B203D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <a href="plot3Drgl.html#topic+persp3Drgl">persp3Drgl</a> from package
<code>plot3Drgl</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns nothing
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+Sylt3D">Sylt3D</a> for a data set that can be displayed with <code>moviepersp3D</code>
</p>
<p><a href="#topic+moviepoints3D">moviepoints3D</a> for plotting moving points in 3D
</p>
<p><a href="#topic+movieslice3D">movieslice3D</a> for plotting moving slices in 3D
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- y &lt;- t &lt;- seq(-1, 1, by = 0.1)
 grid   &lt;- mesh(x, y, t)
 z &lt;- with(grid, x*exp(-x^2 - y^2 - z^2))

 moviepersp3D  (x, y, z = z, colvar = z, colkey = TRUE,
   ticktype = "detailed", wait = 0.1, main = "t = ")

## Not run: 
 moviepersp3D (x, y, z = z, colvar = z, colkey = TRUE,
   aspect = TRUE, bty = "n", ask = FALSE, main = "t = ")

## End(Not run)

</code></pre>

<hr>
<h2 id='NIOZ+20Westerschelde+20monitoring'>
NIOZ monitoring data of Westerschelde estuary.
</h2><span id='topic+WSnioz'></span><span id='topic+WSnioz.table'></span>

<h3>Description</h3>

<p>Part of the long-term monitoring data of the Westerschelde estuary, from 
1996 till 2004.
</p>
<p>A total of 17 stations were monitored on a monthly basis. 
</p>
<p>The dataset <code>WSnioz</code> is in long format and contains the following variables: 
oxygen, temperature, salinity, nitrate, ammonium, nitrite, phosphate, 
silicate and chlorophyll.
</p>
<p>The dataset <code>WSnioz.table</code> is in tabular format.
</p>
<p>The full dataset can be downloaded from:
<code>https://www.nioz.nl/monitoring-data-downloads</code>  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(WSnioz)
data(WSnioz.table)
</code></pre>


<h3>Format</h3>

<p><code>WSnioz</code> is a <code>data.frame</code> with the following columns: 
</p>

<ul>
<li> <p><code>SamplingDateTime</code>, a string with the date and time of sampling.
</p>
</li>
<li> <p><code>SamplingDateTimeREAL</code>, a numeric value with day as per 1900.
</p>
</li>
<li> <p><code>Station</code>, the station number.
</p>
</li>
<li> <p><code>Latitude</code>, <code>Longitude</code>, the station position.
</p>
</li>
<li> <p><code>VariableName</code>, the variable acronym.
</p>
</li>
<li> <p><code>VariableDesc</code>, description of the variable.
</p>
</li>
<li> <p><code>VariableUnits</code>, units of measurement.
</p>
</li>
<li> <p><code>DataValue</code>, the actual measurement.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Soetaert, K., Middelburg, JJ, Heip, C, Meire, P., Van Damme, S., Maris, T., 2006. Long-term change in dissolved inorganic nutrients in the heterotrophic Scheldt estuary (Belgium, the Netherlands). Limnology and Oceanography 51: 409-423.   DOI: 10.4319/lo.2006.51.1_part_2.0409
</p>
<p><code>http://aslo.org/lo/toc/vol_51/issue_1_part_2/0409.pdf</code>
</p>


<h3>See Also</h3>

<p><a href="plot3D.html#topic+image2D">image2D</a> for plotting images, package <code>plot3D</code>.
</p>
<p><a href="plot3D.html#topic+ImageOcean">ImageOcean</a> for an image of the ocean's bathymetry, package <code>plot3D</code>.
</p>
<p><a href="plot3D.html#topic+scatter2D">scatter2D</a> for making scatterplots, package <code>plot3D</code>.
</p>
<p><a href="plot3D.html#topic+Oxsat">Oxsat</a> for a 3-D data set, package <code>plot3D</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")
 mar &lt;- par("mar")
   
## =============================================================================
## Show stations and measured variables
## =============================================================================  
 unique(WSnioz[,c("Station", "Latitude", "Longitude")])
 unique(WSnioz[,c("VariableName", "VariableDesc")])
                                  
## =============================================================================
## An image for Nitrate:
## =============================================================================

# 1. use db2cross to make a cross table of the nitrate data
# assume that samples that were taken within 5 days belong to the same
# monitoring campaign (df.row).

 NO3 &lt;- db2cross(WSnioz, row = "SamplingDateTimeREAL", 
       col = "Station", val = "DataValue", 
       subset = (VariableName == "WNO3"), df.row = 5)

# 2. plot the list using image2D; increase resolution
 image2D(NO3, resfac = 3)   

## =============================================================================
## All timeseries for one station
## =============================================================================

 st1 &lt;- db2cross(WSnioz, row = "SamplingDateTimeREAL", 
       col = "VariableName", val = "DataValue", 
       subset = (WSnioz$Station == 1), df.row = 5)

 Mplot(cbind(st1$x/365+1900,st1$z))

## =============================================================================
## All timeseries for multiple stations
## =============================================================================

 dat &lt;- NULL
 for (st in 1:17) {
   dd &lt;- db2cross(WSnioz, row = "SamplingDateTimeREAL", 
          col = "VariableName", val = "DataValue", 
          subset = (WSnioz$Station == st), df.row = 5)
   dat &lt;- rbind(dat,  cbind(st, time = dd$x/365+1900, dd$z))
 }

# select data for station 1, 17
 dat2 &lt;- Msplit(dat, split = "st", subset = st %in% c(1, 17))
 names(dat2)
  
 Mplot(dat2, lty = 1)

## =============================================================================
## tabular format of the same data
## =============================================================================
 head(WSnioz.table)

# plot all data from station 1:
 Mplot(WSnioz.table, select = 3:11, subset = Station == 1, legend = FALSE)

 Mplot(Msplit(WSnioz.table, "Station", subset = Station %in% c(1, 13)) , 
   select = c("WNO3", "WNO2", "WNH4", "WO2"), lty = 1, lwd = 2,
   xlab = "Daynr", log = c("y", "y", "y", ""), 
   legend = list(x = "left", title = "Station")) 



# reset plotting parameters
 par(mar = mar)
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='Profile+20data+20set'>
Temperature profiles made along a ship track.
</h2><span id='topic+TrackProf'></span>

<h3>Description</h3>

<p>Profiles of temperature made along a ship track, originally made available by US NOAA NODC.
</p>
<p>The data were merged from 29 input files named <code>gtspp_103799_xb_111.nc</code>
till <code>gtspp_103827_xb_111.nc</code>.
</p>
<p>These data were acquired from the US NOAA National Oceanographic Data Center 
(NODC) on 9/06/2012 from <a href="https://www.nodc.noaa.gov/gtspp/">https://www.nodc.noaa.gov/gtspp/</a>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TrackProf)
</code></pre>


<h3>Format</h3>

<p>list with 
</p>

<ul>
<li> <p><code>meta</code>, a <code>data.frame</code> with the metadata, containing for each of the 
29 profiles the following:
</p>

<ul>
<li> <p><code>station</code>, the number of the station (part of the original filename).
</p>
</li>
<li> <p><code>filename</code>, the original name of the NetCDF file.
</p>
</li>
<li> <p><code>date</code>, the date of sampling.
</p>
</li>
<li> <p><code>time</code>, the time of sampling, a number relative to 1-1-1900 0 hours.
</p>
</li>
<li> <p><code>longitude</code>, dg E. 
</p>
</li>
<li> <p><code>latitutde</code>, dg N.
</p>
</li></ul>

</li>
<li> <p><code>temp</code>, the seawater temperature, at the <code>depth</code> of the 
measurement in dg C. A matrix of dimension <code>(29, 93)</code> for the 
29 profiles and (at most) 93 depth values; <code>NA</code> means no measurement.
</p>
</li>
<li> <p><code>depth</code>, the depth of the measurement in <code>temp</code>, in metres, 
positive downward. A matrix of dimension <code>(29, 93)</code> for the 
29 profiles and (at most) 93 depth values; <code>NA</code> means no measurement.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p><a href="https://www.nodc.noaa.gov/gtspp/">https://www.nodc.noaa.gov/gtspp/</a>
</p>
<p>U.S. National Oceanographic Data Center: Global Temperature-Salinity Profile Programme.
June 2006. U.S. Department of Commerce, National Oceanic and Atmosphere Administration,
National Oceanographic Data Center, Silver Spring, Maryland, 20910. Date of Access: 9/06/2012.
</p>


<h3>See Also</h3>

<p><a href="plot3D.html#topic+image2D">image2D</a> for plotting images, package <code>plot3D</code>.
</p>
<p><a href="plot3D.html#topic+ImageOcean">ImageOcean</a> for an image of the ocean bathymetry, package <code>plot3D</code>.
</p>
<p><a href="plot3D.html#topic+scatter2D">scatter2D</a> for making scatterplots, package <code>plot3D</code>.
</p>
<p><a href="plot3D.html#topic+Oxsat">Oxsat</a> for a 3-D data set, package <code>plot3D</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par(mfrow = c(2, 2))
 mar &lt;- par("mar")
   
## =============================================================================
## show the metadata
## =============================================================================
 print(TrackProf$meta)

## =============================================================================
## display the cruisetrack on the Ocean Bathymetry data  
## =============================================================================  
 # 1. plots the ocean's bathymetry and add sampling positions
 ImageOcean(xlim = c(-50, 50), ylim = c(-50, 50), 
            main = "cruise track")  
 points(TrackProf$meta$longitude, TrackProf$meta$latitude, pch = "+")

# mark starting point
 points(TrackProf$meta$longitude[1], TrackProf$meta$latitude[1], 
        pch = 18, cex = 2, col = "purple")

## =============================================================================    
## image plots of raw data
## =============================================================================    

 image2D(z = TrackProf$depth, main = "raw depth values",  
       xlab = "station nr", ylab = "sample nr", clab = "depth")
 image2D(z = TrackProf$temp, main = "raw temperature values",  
       xlab = "station nr", ylab = "sample nr", clab = "dgC")

## =============================================================================    
## image plots of temperatures at correct depth
## =============================================================================    
  
# water depths to which data set is interpolated
 depth &lt;- 0 : 809    

# map from "sigma" to "depth" coordinates
 Temp_Depth &lt;- mapsigma (TrackProf$temp, sigma = TrackProf$depth, 
   depth = depth)$var

# image with depth increasing downward and increased resolution (resfac)  
 image2D(z = Temp_Depth, main = "Temperature-depth",
       ylim = c(809, 0), y = depth, NAcol ="black", resfac = 2, 
       xlab = "station nr", ylab = "depth, m", clab = "dgC")
   
## =============================================================================    
## scatterplot of surface values on ocean bathymetry
## =============================================================================    

 par(mar = mar + c(0, 0, 0, 2))
 par(mfrow = c(1, 1))
  
# No colors, but add contours
 ImageOcean(xlim = c(-30, 30), ylim = c(-40, 40), 
          main = "cruise track", col = "white", contour = TRUE) 
  
# use data set TrackProf to add measured temperature, with color key
 with (TrackProf, 
   scatter2D(colvar = temp[,1], x = meta[ ,"longitude"],
         y = meta[ ,"latitude"], clab = "temp", 
         add = TRUE, pch = 18, cex = 2))
  
# reset plotting parameters
 par(mar = mar)
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='Quiver+20and+20flow+20paths'>
Plots velocities as arrows or as trajectory plots.
</h2><span id='topic+quiver2D'></span><span id='topic+quiver2D.matrix'></span><span id='topic+quiver2D.array'></span><span id='topic+quiver2Drgl'></span><span id='topic+flowpath'></span>

<h3>Description</h3>

<p>Function <code>quiver2D</code> displays velocity vectors as arrows, using ordinary graphics.
</p>
<p>Function <code>quiver2Drgl</code> displays velocity vectors as arrows using rgl. 
</p>
<p>Function <code>flowpath</code> displays the flow paths of particles, based on 
velocity vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quiver2D(u, ...)

## S3 method for class 'matrix'
quiver2D(u, v, x = NULL, y = NULL, 
           colvar = NULL, ..., 
           scale = 1, arr.max = 0.2, arr.min = 0, speed.max = NULL,  
           by = NULL, type = "triangle", col = NULL, NAcol = "white", 
           breaks = NULL, colkey = NULL, mask = NULL,
           image = FALSE, contour = FALSE, 
           clim = NULL, clab = NULL, 
           add = FALSE, plot = TRUE) 

## S3 method for class 'array'
 quiver2D(u, v, margin = c(1, 2), subset, ask = NULL, ...)
                    
quiver2Drgl (u, v, x = NULL, y = NULL, colvar = NULL, ..., 
           scale = 1, arr.max = 0.2, arr.min = 0, speed.max = NULL, 
           by = NULL, type = "triangle", 
           col = NULL, NAcol = "white", breaks = NULL,
           mask = NULL, image = FALSE, contour = FALSE,
           colkey = NULL, clim = NULL, clab = NULL, add = FALSE, plot = TRUE)

flowpath(u, v, x = NULL, y = NULL, startx = NULL, starty = NULL, ...,
           scale = 1, numarr = 0, arr.length = 0.2, maxstep = 1000, 
           add = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_u">u</code></td>
<td>
<p>A matrix (<code>quiver2D</code>) or array (<code>quiver2D.array</code>)
with velocities in x-direction. 
For <code>quiver2D</code> 
the number of rows should be = Nx or Nx+1 (Nx = length(x), if x given),  
the number of columns should be = Ny or Ny+1 (Ny = length(y), if y given). 
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_v">v</code></td>
<td>
<p>A matrix (<code>quiver2D</code>) or array (<code>quiver2D.array</code>)
with velocities in y-direction. 
For <code>quiver2D</code> the number of rows should be = Nx or Nx+1,  
the number of columns should be = Ny or Ny+1.  
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_x">x</code></td>
<td>
<p>Vector with x-coordinates of the velocities. 
If <code>NULL</code>, it is taken to be a sequence between (0, 1), and with 
length = <code>nrow(u)</code>. 
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_y">y</code></td>
<td>
<p>Vector with y-coordinates of the velocities. If <code>NULL</code>, it
is taken to be a sequence between (0, 1), and with 
length = <code>ncol(v)</code>.  
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_startx">startx</code></td>
<td>
<p>Vector with the start position in x-direction of the flow paths. 
Length &gt; =1. If not specified, then all combinations of <code>x</code> and <code>y</code> at 
the outer margins will be used as starting point.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_starty">starty</code></td>
<td>
<p>Vector with start position in y-direction of flow paths. 
Length = length of <code>startx</code>. 
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring. It need
not be present, but if specified, it should be a vector of 
dimension equal to <code>c(nrow(u), ncol(v))</code>.
Values of <code>NULL</code>, <code>NA</code>, or <code>FALSE</code>
will toggle off coloration according to <code>colvar</code>. 
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_col">col</code></td>
<td>
<p>Colors to be used for coloring the arrows as specified by the 
<code>colvar</code> variable. 
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is specified, 
then a red-yellow-blue colorscheme (<a href="plot3D.html#topic+jet.col">jet.col</a>) will be used.
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is not specified, then 
<code>col</code> will be &quot;black&quot;. 
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_nacol">NAcol</code></td>
<td>
<p>Colors to be used for <code>colvar</code> values that are <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_scale">scale</code></td>
<td>
<p>Scaling factor for the arrows.
When <code>scale = 1</code>, the longest arrow will fill a grid cell in 
x- and y- direction. When <code>scale = 2</code>, it will be twice as long.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_arr.max">arr.max</code></td>
<td>
<p>Maximal size of the arrowhead, in cm (approximately). 
The arrows are scaled according to the velocity (<code>sqrt(u^2 + v^2)</code>). 
<code>arr.max</code> is associated with the maximal velocity.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_arr.min">arr.min</code></td>
<td>
<p>Minimal size of the arrowhead, in cm (approximately). 
Set <code>arr.min</code> = <code>arr.max</code> for constant size.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_speed.max">speed.max</code></td>
<td>
<p>Speed that corresponds to <code>arr.max</code>. 
Everything with speed larger than <code>speed.max</code> will be depicted with 
size equal to <code>arr.max</code>.
If unspecified (<code>max(sqrt(u^2 + v^2))</code>). 
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_by">by</code></td>
<td>
<p>Number increment for plotting the vectors; one value or two (x, y) values. 
For example, setting <code>by = 2</code> will plot every second velocity value in 
<code>x</code> and in <code>y</code> direction.  Setting <code>by = c(1, 2)</code> will
plot all vectors in <code>x</code> and every second vector in <code>y</code>.
Useful if the vector density is too high. 
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters 
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="plot3D.html#topic+colkey">colkey</a> from package <code>plot3D</code>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr> 
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_type">type</code></td>
<td>
<p>The type of the arrow head, one of <code>"triangle"</code> (the default) or
<code>"simple"</code>, which uses R-function <a href="graphics.html#topic+arrows">arrows</a>.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_contour">contour</code>, <code id="Quiver+2B20and+2B20flow+2B20paths_+3A_image">image</code></td>
<td>
<p>If present, then a <a href="plot3D.html#topic+contour2D">contour2D</a> or <a href="plot3D.html#topic+image2D">image2D</a> 
plot will be added to the quiver plot. 
They should be a <code>list</code> with arguments for the 
<a href="plot3D.html#topic+contour2D">contour2D</a> or <code>image2D</code> function. 
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the colors, used
for the color key. 
</p>
</td></tr> 
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey</code> is not <code>NULL</code> or <code>FALSE</code>, 
the label to be written on top of the color key. 
The label will be written at the same level as the main title.
To lower it, <code>clab</code> can be made a vector, with the first values empty 
strings. 
</p>
</td></tr> 
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_margin">margin</code></td>
<td>
<p>A vector giving the subscripts which the plotting 
function will be applied over.   
The plotting function will loop over the index that is not in <code>margin</code>.
For instance, <code>c(1, 2)</code>, indicates to plot rows(x) and columns(y) and to 
loop over index <code>3</code>;  
<code>c(2, 1)</code> will do the same but transposed.
<code>margin</code> should be a vector with two numbers inbetween <code>1</code>, and <code>3</code>.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_ask">ask</code></td>
<td>
<p>A logical; if <code>TRUE</code>, the user is asked before each plot, 
if <code>NULL</code> the user is only asked if more than one page of plots is 
necessary and the current graphics device is set interactive, 
see <a href="graphics.html#topic+par">par</a>(ask) and <a href="grDevices.html#topic+dev.interactive">dev.interactive</a>.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, will add to current plot. 
Else will start a new plot. Note: to use this in a consistent way, the 
previous plot should have been done with one of the <code>plot3D</code> functions.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_mask">mask</code></td>
<td>
<p>A <code>matrix</code> or <code>list</code> defining the grid cells outside 
the domain as <code>NA</code>.  
Use a list with argument <code>NAcol</code> to specify the color that the masked cells 
(that are <code>NA</code>) should get; the default is
<code>"black"</code>. The unmasked cells are left <code>"white"</code>. 
</p>
<p>If <code>x</code> and <code>y</code> are a vector, then <code>mask</code> can be a <code>matrix</code> with 
dimension equal to <code>length(x), length(y)</code>. If either <code>x</code> or <code>y</code> 
is itself a <code>matrix</code>, 
then <code>mask</code> should be a <code>list</code> that contains the 
<code>x</code>, <code>y</code>, and <code>z</code> values (and that are named 'x', 'y', 'z'). 
A <code>mask</code> cannot be combined with <code>add = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_plot">plot</code></td>
<td>
<p>If <code>FALSE</code>, will not plot the flow paths, 
but will return the matrix with path values instead.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_numarr">numarr</code></td>
<td>
<p>The number of arrows added on the flow paths. 
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_arr.length">arr.length</code></td>
<td>
<p>Constant size of the arrowhead, in cm (approximately). 
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_maxstep">maxstep</code></td>
<td>
<p>Maximum number of steps for calculating the flow paths.  
</p>
</td></tr> 
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plotting methods (<a href="plot3D.html#topic+arrows2D">arrows2D</a>),
The arguments after ... must be matched exactly.
</p>
</td></tr>
<tr><td><code id="Quiver+2B20and+2B20flow+2B20paths_+3A_subset">subset</code></td>
<td>
<p>A logical expression indicating over which elements to loop;
missing values are taken as <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>S3 function <code>quiver2D</code> plots vectors specified by <code>u, v</code> at the coordinates
<code>x, y</code>.
</p>
<p><code>flowpath</code> uses the velocities <code>u, v</code> at the coordinates
<code>x, y</code> to create trajectories, starting at points 
<code>startx, starty</code>. It can also be used to return the flow path 
points by setting <code>plot</code> equal to <code>FALSE</code>.
It uses very simple Euler integration and may not be very accurate.
</p>


<h3>Value</h3>

<p><code>flowpath</code> returns (as <code>invisible</code>) a 2-column 
matrix with the x-y coordinates of the flow paths. 
Separate flow paths are separated with <code>NA</code>.
</p>
<p><code>quiver2D</code> returns  (as <code>invisible</code>) a <code>list</code> containing the 
coordinates of the arrows (<code>x0</code>, <code>x1</code>, <code>y0</code>, <code>y1</code>), 
the color of each arrow (<code>col</code>), the length of the arrowhead
(<code>length</code>) and the maximal speed corresponding to <code>arr.max</code> (<code>speed.max</code>). 
This output can be used e.g. with function <a href="graphics.html#topic+arrows">arrows</a>.
</p>


<h3>Note</h3>

<p>There was a slight error in the scaling of the arrows in versions previous to
1.0.3, which has been corrected. See last example.
</p>


<h3>See Also</h3>

<p><a href="plot3D.html#topic+arrows3D">arrows3D</a> for an arrows function from package <code>plot3D</code>.
</p>
<p><a href="#topic+vectorplot">vectorplot</a> for plotting velocity vectors as spikes.
</p>
<p><a href="shape.html#topic+Arrows">Arrows</a> for the arrow function from package <code>shape</code> on which quiver2D is based.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
##  EXAMPLE 1: 
## =======================================================================
 pm &lt;- par("mfrow")
 par(mfrow = c(2, 2))

# generate velocities
 x  &lt;- seq(-1, 1, by = 0.2)
 y  &lt;- seq(-1, 1, by = 0.2)
 dx &lt;- outer(x, y , function(x, y) -y)
 dy &lt;- outer(x, y , function(x, y) x)

# velocity plot, with legend
 F &lt;- quiver2D(u = dx, v = dy, x = x, y = y)
 legend("topright", bg = "white", 
   legend = paste("max = ", format(F$speed.max, digits = 2))) 

# different color for up/downward pointing arrows
 quiver2D(u = dx, v = dy, x = x, y = y, colvar = dx &gt; 0, 
        col = c("red", "blue"), colkey = FALSE,
        arr.max = 0.4, arr.min = 0.1)

# different scale
 quiver2D(u = dx, v = dy, x = x, y = y, by = 2, scale = 2)

# three flow paths
 flowpath(u = dx, v = dy, x = x, y = y, startx = 0.1, starty = 0.1)
 flowpath(u = dx, v = dy, x = x, y = y, 
          startx = c(0.9, -0.9), starty = c(0.0, 0.0), col = "red",
          numarr = 2, add = TRUE)

## =======================================================================
##  EXAMPLE 2: note: has changed in version 1.0.3 - uses contour2D!
## =======================================================================
 par(mfrow = c(1, 1))
 x &lt;- seq(-2, 2, by = 0.2)
 y &lt;- seq(-1, 1, by = 0.2)
 z &lt;- outer (x, y, function(x, y) x^3 - 3*x -2*y^2)
 contour2D(x, y, z = z, col = jet.col(10))

# gradients in x- and y-direction (analytical)
 dX &lt;- outer(x, y, function(x,y) 3*x^2 - 3)
 dY &lt;- outer(x, y, function(x,y) -4*y)

 quiver2D(u = dX, v = dY, x = x, y = y, scale = 1, add = TRUE, by = 1)
 flowpath(u = dX, v = dY, x = x, y = y, startx = c(-2, 1.1), 
            starty = c(-1, -1), add = TRUE, arr.length = 0.5,
            col = "darkgreen", lwd = 3, numarr = 1)

## =======================================================================
##  EXAMPLE 3: 
## =======================================================================
 
 x &lt;- y &lt;- 1:20
 u &lt;- outer (x, y, function (x, y) cos(2*pi*y/10))
 v &lt;- outer (x, y, function (x, y) cos(2*pi*x/10))

 quiver2D(x = x, y = y, u = u, v = v, col = "grey")

# flowpaths using all combinations of x and y at edges
 flowpath(x = x, y = y, u = u, v = v, add = TRUE, 
          lwd = 2, col = "orange")

## =======================================================================
##  EXAMPLE 4: quiver of an array.. 
## =======================================================================
 
 x &lt;- y &lt;- 1:20
 u2 &lt;- outer (x, y, function (x, y) sin(2*pi*y/10))
 v2 &lt;- outer (x, y, function (x, y) sin(2*pi*x/10))

# merge u, u2 and v, v2 to create an "array"
 U &lt;- array(dim = c(dim(u2), 2), data = c(u, u2))
 V &lt;- array(dim = c(dim(v2), 2), data = c(v, v2))

 quiver2D(u = U, v = V, x = x, y = y, main = c("time 1", "time 2"))

# quiver over x and time, for a subset of y-values:
 quiver2D(u = U, v = V, x = x, y = 1:2, 
        margin = c(1, 3), main = paste("y ", y), 
        subset = y &lt;= 4)

## Not run: 
 quiver2D(u = U, v = V, x = x, y = y, ask = TRUE, 
        mfrow = c(1, 1))

 quiver2D(u = U, v = V, x = x, y = 1:2, ask = TRUE, 
        margin = c(1, 3), main = paste("y ", y),
        mfrow = c(1, 1))


## End(Not run)

## =======================================================================
##  EXAMPLE 5: 
## =======================================================================
 par(mfrow = c(1, 1))

 image2D(x = 1:nrow(volcano), y = 1:ncol(volcano), 
       z = volcano, contour = TRUE)

# Assume these are streamfunctions, we calculate the velocity field as:
 dx &lt;- dy &lt;- 1
 v &lt;-   (volcano[-1, ] - volcano[-nrow(volcano), ] )/dx
 u &lt;- - (volcano[, -1] - volcano[ ,-ncol(volcano)] )/dy

 quiver2D(x = 1:nrow(u), y = 1:ncol(v), 
        u = u, v = v, add = TRUE, by = 3)
 
 flowpath(x = 1:nrow(u), y = 1:ncol(v), numarr = 10,
          u = u, v = v, add = TRUE, lwd = 2, col = "grey", 
          startx = 20, starty = 30)
 
## =======================================================================
##  EXAMPLE 6: boundary mask, images, contours
## =======================================================================
 par (mfrow = c(2, 2))
 
 mask &lt;- volcano; mask[volcano &lt; 120]  &lt;- NA
 quiver2D(by = c(3, 2), u = u, v = v, mask = mask)

 quiver2D(by = c(3, 2), u = u, v = v,  
        image = list(z = mask, NAcol = "black"))

 quiver2D(by = c(4, 3), u = u, v = v,
        contour = list(z = volcano, lwd = 2))

 quiver2D(by = c(4, 3), u = u, v = v, 
        contour = list(z = volcano, col = "black"), 
        image = list(z = volcano, NAcol = "black"))

## =======================================================================
##  Same in rgl
## =======================================================================
## Not run: 
 quiver2Drgl(by = c(3, 2), u = u, v = v, mask = mask, NAcol = "black")

 quiver2Drgl(by = c(3, 2), u = u, v = v,  
        image = list(z = volcano, NAcol = "black"))

 quiver2Drgl(by = c(4, 3), u = u, v = v, scale = 2,
        contour = list(z = volcano, lwd = 2))

 quiver2Drgl(by = c(4, 3), u = u, v = v, 
        contour = list(z = volcano, col = "black"), 
        image = list(z = volcano, NAcol = "black"))
 cutrgl()
 uncutrgl()

## End(Not run)

## =============================================================================
## 2-D Data set SyltSurf
## =============================================================================

 par(mfrow = c(1, 1))
 with (Syltsurf,
   quiver2D(x = x, y = y, u = u[ , ,2], v = v[ , ,2], 
     xlim = c(5, 20), ylim = c(10, 25), by = 3, 
     main = paste(formatC(time[1]), " hr"), scale = 1.5, 
     image = list(z = depth, x = x, y = y, NAcol = "black", 
                  colkey = TRUE), 
     contour = list(z = depth, x = x, y = y, col = "black",
       drawlabels = FALSE)
     )
  )

## =============================================================================
## 2-D Data set SyltSurf, several time points
## =============================================================================

# now for an array (first and 4th time point only)
 ii &lt;- c(1, 4)
 with (Syltsurf,
   quiver2D(x = x, y = y, u = u[ ,,ii], v = v[ ,,ii], 
     xlim = c(5, 20), ylim = c(10, 25), by = 4, 
     mask = list(z = depth, x = x, y = y, NAcol = "blue"),
     main = paste(formatC(time[ii]), " hr"), scale = 1.5,
     contour = list(z = depth, x = x, y = y, drawlabels = FALSE)
     )
  )



## =============================================================================
## Adding quivers ...
## =============================================================================
x &lt;- 1:2
y &lt;- 1:3
u &lt;- matrix(data = 1:6, nrow = 2, ncol = 3)
v &lt;- matrix(data = 6:1, nrow = 2, ncol = 3)

par(mfrow = c(1, 1))
A &lt;- quiver2D(x = x, y = y, u = u, v = v)
B &lt;- quiver2D(x = x, y = y[-1], u = u[,-1], v = v[,-1], col = 2, add = TRUE)
C &lt;- quiver2D(x = x, y = y[-3], u = u[,-3], v = v[,-3], col = 3, add = TRUE)

# restore parameter settings
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='Reshaping+20to+20a+20crosstable'>
Converts a dataset from database-format to a cross table
</h2><span id='topic+db2cross'></span>

<h3>Description</h3>

<p>Reshapes data arranged in 3 columns to a &ldquo;crosstable&rdquo; matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db2cross (input, row = 1, col = 2, value = 3, subset = NULL,
  df.row = NA, df.col = NA, out.row = NA, out.col = NA, 
  full.out = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Reshaping+2B20to+2B20a+2B20crosstable_+3A_input">input</code></td>
<td>
<p>A <code>matrix</code> in <em>database</em> format, (x,y,z) .
</p>
</td></tr>
<tr><td><code id="Reshaping+2B20to+2B20a+2B20crosstable_+3A_row">row</code></td>
<td>
<p>Number or name of the column in <code>input</code>, to be used as 
rows in the result.
</p>
</td></tr>
<tr><td><code id="Reshaping+2B20to+2B20a+2B20crosstable_+3A_col">col</code></td>
<td>
<p>Number or name of the column in <code>input</code>, to be used as 
columns in the result.
</p>
</td></tr>
<tr><td><code id="Reshaping+2B20to+2B20a+2B20crosstable_+3A_value">value</code></td>
<td>
<p>Number or name of the column in <code>input</code>, to be used as 
values in the result.
</p>
</td></tr>
<tr><td><code id="Reshaping+2B20to+2B20a+2B20crosstable_+3A_subset">subset</code></td>
<td>
<p>Logical expression indicating elements or rows to keep; 
missing values are taken as <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="Reshaping+2B20to+2B20a+2B20crosstable_+3A_df.row">df.row</code>, <code id="Reshaping+2B20to+2B20a+2B20crosstable_+3A_df.col">df.col</code></td>
<td>
<p>Maximal distance in row and column values that should 
be considered the same. The default is to use each unique row or column 
value in <code>input</code> as a row or column value in the crosstable.
Overrruled when <code>out.row</code> or <code>out.col</code> are defined.
</p>
</td></tr>
<tr><td><code id="Reshaping+2B20to+2B20a+2B20crosstable_+3A_out.row">out.row</code>, <code id="Reshaping+2B20to+2B20a+2B20crosstable_+3A_out.col">out.col</code></td>
<td>
<p>Values of rows and columns to be used in the cross table. 
The default is to use each unique row or column value in <code>input</code> as a 
row or column value in the crosstable. Each value in <code>input</code> is mapped to
<code>out.row</code> and <code>out.col</code> to which it is closest.
Overrrules <code>df.row</code> or <code>df.col</code>.
</p>
</td></tr>
<tr><td><code id="Reshaping+2B20to+2B20a+2B20crosstable_+3A_full.out">full.out</code></td>
<td>
<p>If <code>TRUE</code>, will also output how the input values were
mapped to the output values. This is only relevant if either of <code>df.row</code>, 
<code>df.col</code>, <code>out.row</code> or <code>out.col</code> is not <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a simple fortran function.
</p>
<p>rows and columns are generated by the <code>unique values</code> in each 
x- and y-column.
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p> The values of the <em>rows</em>.    </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> The values of the <em>columns</em>. </p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p> The crosstable, a matrix.</p>
</td></tr> 
</table>
<p>and if <code>full.out = TRUE</code> also 
</p>
<table>
<tr><td><code>map</code></td>
<td>
<p> The mapping of the <em>x</em>  and <em>y</em> values, consisting of 
<code>var.input</code>, <code>factor</code>, <code>var.output</code>, with the original values, 
how they are mapped, and the resulting values respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+reshape">reshape</a>, the official (slow) R-function
</p>
<p><a href="#topic+remap">remap</a> to remap a matrix or array to higher or lower resolution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## test the function on a small data set
## =======================================================================

 df3 &lt;- data.frame(school = rep(c("a","b","c"), each = 4), 
                   class = rep(9:10, 6),
                   time = rep(c(1,1,2,2), 3),  
                   score = rnorm(12))
 head(df3)
 db2cross(df3, val = 4)

## =======================================================================
## Defining the output rows
## =======================================================================
Samples &lt;- data.frame(time = c(1, 1.1, 1.2, 2, 2.1, 2.2, 4, 4.1, 4.2),
                      var = rep(c("O2", "NO3", "NH3"), 3), 
                      val = 1:9)
Samples

db2cross(Samples)
db2cross(Samples, df.row = 0.5)
db2cross(Samples, out.row = c(1, 2, 4))
db2cross(Samples, out.row = 1:4)

## =======================================================================
## A larger dataset; requires OceanView.Data
## =======================================================================
## Not run: 
 data (pp.aug2009.db)
 crosstab &lt;- db2cross(pp.aug2009.db)
 crosstab$z[crosstab$z&gt;1000] &lt;- 1000
 crosstab$z[crosstab$z&lt;0]    &lt;- NA

 image2D(z = crosstab$z, x = crosstab$x, y = crosstab$y,
       main = "primary production august 2009 mgC/m2/d", 
       NAcol = "black")
 
## End(Not run)
</code></pre>

<hr>
<h2 id='Sylt+20data+20set'>
Hydrodynamic model output (getm) of Sylt-Romo Bight
</h2><span id='topic+Syltsurf'></span><span id='topic+Sylttran'></span><span id='topic+Sylt3D'></span>

<h3>Description</h3>

<p>3D Sylt-tidal simulation model output generated by the GETM model version 2.2.2. 
</p>
<p>The Sylt-Romo bight is a Wadden Sea embayment in the North Sea, between 
the Danish island Romo and the German island Sylt at about 55 dg N and 8 dg E, 
an area of approximately 300 km^2.
</p>

<ul>
<li> <p><code>Sylttran</code> contains (x, sigma, time) data from 
an E-W transect. 
</p>
</li>
<li> <p><code>Syltsurf</code> contains 2-D surface data, at 5 time intervals. 
</p>
</li>
<li> <p><code>Sylt3D</code> contains 3-D (x, y, z) data, at 2 time intervals. 
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(Sylttran)
data(Syltsurf)
data(Sylt3D)
</code></pre>


<h3>Format</h3>


<ul>
<li> <p><code>Sylttran</code> is a <code>data.frame</code> with (x, sigma, time) data from an E-W transect 
(8.1 - 17.9 km) taken at km 18.5. There are 50 x-values, 21 sigma levels and 21 model output times. 
</p>
<p>It contains:
</p>

<ul>
<li> <p><code>x, y</code>, the positions in km, of length 50 and 1 respectively.
</p>
</li>
<li> <p><code>time</code>, the model output time in hours, of length 21.
</p>
</li>
<li> <p><code>visc</code>, the viscosity (getm variable <code>num</code>), (50 x 21 x 21), m2/s. 
</p>
</li>
<li> <p><code>tke</code>, the turbulent kinetic energy (getm variable <code>tke</code>), (50 x 21 x 21), m2/s2. 
</p>
</li>
<li> <p><code>u, v</code>, the zonal and meridional velocity, (50 x 21 x 21), m/s. 
</p>
</li>
<li> <p><code>sigma</code>, the depth of the sigma coordinates (50 x 21 x 21), metres.  
</p>
</li></ul>

</li>
<li> <p><code>Syltsurf</code> contains 2-D surface data of the entire model domain, 
at 5 time intervals (hour 24.7 to 37.1).                                                 
It is a <code>data.frame</code> with:
</p>

<ul>
<li> <p><code>x, y</code>, the positions in km, of length 135 and 160 respectively.
</p>
</li>
<li> <p><code>time</code>, the output time in hours, of length 5.
</p>
</li>
<li> <p><code>u, v</code>, the vertically averaged zonal and meridional velocity (135 x 160 x 5), m/s. 
</p>
</li>
<li> <p><code>elev</code>, tidal elevation (135 x 160 x 5), metres.
</p>
</li>
<li> <p><code>depth</code>, the bathymetry (135 x 160), metres.  
</p>
</li></ul>

</li>
<li> <p><code>Sylt3D</code> contains 3-D (x, y, z) data, at 2 time intervals (hour 0 and 9.94). 
The box extends from x inbetween [12.1, 14.9] and from y inbetween [12.7 - 16.3];
there are 21 sigma levels. 
</p>
<p>It is a <code>data.frame</code> with:
</p>

<ul>
<li> <p><code>x, y</code>, the positions in km, of length 15 and 19 respectively.
</p>
</li>
<li> <p><code>time</code>, the output time in hours, of length 2.
</p>
</li>
<li> <p><code>visc</code>, the viscosity (getm model variable num), (55 x 19 x 21 x 2), m2/s.  
</p>
</li>
<li> <p><code>sigma</code>, the sigma depth levels, (55 x 19 x 21 x 2), m2/s.  metres.
</p>
</li>
<li> <p><code>depth</code>, the bathymetry (15 x 19), metres.  
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Hans Burchard and Karsten Bolding, 2002. GETM, A General Estuarine Transport
Model, Scientific Documentation. EUR 20253 EN. 
</p>
<p><a href="https://getm.eu">https://getm.eu</a>
</p>


<h3>See Also</h3>

<p><a href="plot3D.html#topic+image2D">image2D</a> for plotting images, package <code>plot3D</code>.
</p>
<p><a href="plot3D.html#topic+ImageOcean">ImageOcean</a> for an image of the ocean's bathymetry, package <code>plot3D</code>.
</p>
<p><a href="plot3D.html#topic+scatter2D">scatter2D</a> for making scatterplots, package <code>plot3D</code>.
</p>
<p><a href="plot3D.html#topic+Oxsat">Oxsat</a> for a 3-D data set, package <code>plot3D</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")
 mar &lt;- par("mar")
   
## =============================================================================
## Show position of transect and 3D box in bathymetry
## =============================================================================  

 par(mfrow = c(2, 2))
 par(mar = c(4, 4, 4, 4))

 x &lt;- Syltsurf$x ; y &lt;- Syltsurf$y ; depth &lt;- Syltsurf$depth
 image2D(z = depth, x = x, y = y, clab = c("depth", "m"))

# position of transect 
 with (Sylttran, points (x, rep(y, length(x)), 
         pch = 16, col = "grey"))
# position of 3-D area
 with (Sylt3D, rect(x[1], y[1], x[length(x)], y[length(y)], lwd = 3))
         
 image2D(z = depth, x = x, y = y, clab = c("depth", "m"), log = "z")

# sigma coordinates of the transect (at time = 10)
 matplot(Sylttran$x, Sylttran$sigma[,,10], type = "l", 
         main = "sigma", ylim = c(25, -2), col = "black", lty = 1)

# perspective view - reduce resolution for speed
 ix &lt;- seq(1, length(x), by = 3)
 iy &lt;- seq(1, length(y), by = 3)
 
 par(mar = c(1, 1, 1, 2))
 persp3D(z = -depth[ix, iy], x = x[ix], y = y[iy], 
   scale = FALSE, expand = 0.2, ticktype = "detailed", 
   col = "grey", shade = 0.6, bty = "f",
   plot = FALSE)

# add 3-D region; small amount added to z so that it is visible in rgl   
 persp3D(z = -Sylt3D$depth + 1e-3, x = Sylt3D$x, y = Sylt3D$y, 
   col = alpha.col("red", alpha = 0.4), add = TRUE,
   plot = FALSE)

# transect
 with (Sylttran, points3D(x = x, y = rep(y, length(x)), 
   z = rep(0, length(x)), pch = 16, add = TRUE, colkey = FALSE))

## Not run: 
 plotrgl()
 plotrgl(lighting = TRUE, new = FALSE, smooth = TRUE)

## End(Not run)

## =============================================================================
## Data Syltsurf: Surface elevation
## =============================================================================  

 par(mfrow = c(2, 2), mar = c(0, 0, 1, 0))
# reduce resolution for speed
 ix &lt;- seq(1, length(x), by = 3)
 iy &lt;- seq(1, length(y), by = 3)

 clim &lt;- range(Syltsurf$elev, na.rm = TRUE)
 for (i in 1:3) 
   persp3D(z = -depth[ix, iy], colvar = Syltsurf$elev[ix,iy,i], 
     x = x[ix], y = y[iy], clim = clim, inttype = 2,  d = 2, 
     scale = FALSE, expand = 0.1, colkey = FALSE, shade = 0.5, 
       main = paste(format(Syltsurf$time[i], digits = 3), " hr"))
 par(mar = c(3, 3, 3, 3))
 colkey(clim = clim, clab = c("elevation", "m")) 
  
# can also be done using shaded image2D plots, faster
 par(mfrow = c(2, 2), mar = c(3, 3, 3, 3))
 clim &lt;- range(Syltsurf$elev, na.rm = TRUE)
 for (i in 1:3) 
   image2D(z = -depth[ix, iy], colvar = Syltsurf$elev[ix,iy,i], 
     x = x[ix], y = y[iy], clim = clim, 
     colkey = FALSE, shade = 0.3, resfac = 2,
       main = paste(format(Syltsurf$time[i], digits = 3), " hr"))
 colkey(clim = clim, clab = c("elevation", "m")) 

## =============================================================================
## Data Syltsurf: Surface currents
## =============================================================================  
 
 par(mfrow = c(1, 1))
 Speed &lt;- sqrt(Syltsurf$u[,,2]^2 + Syltsurf$v[,,2]^2)

 with (Syltsurf,
   quiver2D(x = x, y = y, u = u[,,2], v = v[,,2], col = gg.col(100),
     xlim = c(5, 20), ylim = c(10, 25), by = 3, 
     colvar = Speed, clab = c("speed", "m/s"), 
     main = paste(formatC(time[1]), " hr"), scale = 1.5, 
     image = list(z = depth, x = x, y = y, col = "white",  #background
       NAcol = "darkblue"),
     contour = list(z = depth, x = x, y = y, col = "black",#depth 
       lwd = 2)
     )
  )

## =============================================================================
## Data Sylttran: plot a transect
## =============================================================================

 par(mfrow = c(1, 1), mar = c(4, 4, 4, 2))
 D   &lt;- seq(-1, 20, by = 0.02)

 visc &lt;- mapsigma (Sylttran$visc [ , ,1], x = Sylttran$x, 
     sigma = Sylttran$sigma[ , ,1], depth = D, resfac = 2)

 image2D(visc$var, x = visc$x, y = -visc$depth, ylim = c(-20, 1),
     main = "eddy viscosity", ylab = "m", xlab = "hour", 
     clab = "m2/s")
     
# show position of timeseries in next example
 abline(v = visc$x[45])  

## =============================================================================
## Data Sylttran: plot a time-series
## =============================================================================

 par(mfrow = c(1, 1), mar = c(5, 4, 4, 3))
 ix &lt;- 45 

 visct &lt;-  Sylttran$visc  [ix, ,]
 sig   &lt;-  Sylttran$sigma [ix, ,]  

# sigma coordinates are first dimension (signr)
 visc &lt;- mapsigma(visct, sigma = sig, signr = 1, 
   x = Sylttran$time, numdepth = 100, resfac = 3)
 D    &lt;- -visc$depth

 image2D(t(visc$var), x = visc$x, y = D, NAcol = "black", 
   ylim = range(D), main = "eddy viscosity", 
   ylab = "m", xlab = "hour", clab = "m2/s")

## =============================================================================
## Data Sylt3D: increase resolution and map from sigma to depth
## =============================================================================

# select a time series point
 it &lt;- 1
 par(mfrow = c(1, 1))
 sigma  &lt;- Sylt3D$sigma[,,,it]
 visc   &lt;- Sylt3D$visc [,,,it]  
 (D &lt;- dim(sigma))     # x, y, z
 
# remap the data from sigma coordinates to depth coordinates
# depth from max in first box to max in last box
 depth &lt;- seq(max(sigma[,,D[3]], na.rm = TRUE), 
              max(sigma[,,1   ], na.rm = TRUE), length.out = 20)

# Step-bystep mapping, increasing the resolution
 z    &lt;- 1:21
 x    &lt;- Sylt3D$x
 y    &lt;- Sylt3D$y

 xto &lt;- seq(min(x), max(x), length.out = 30)
 yto &lt;- seq(min(y), max(y), length.out = 30)

# higher resolution 
 Sigma &lt;- remap(sigma, x, y, z, xto, yto, zto = z)$var
 Visc  &lt;- remap(visc, x, y, z, xto, yto, zto = z)$var

# viscosity in sigma coordinates
 visc_sig &lt;- mapsigma(Visc, sigma = Sigma, depth = depth)

## =============================================================================
## The 3-D data set - plotted as slices
## =============================================================================

 slice3D(xto, yto, -visc_sig$depth, colvar = visc_sig$var, 
   scale = FALSE, expand = 0.1, NAcol = "transparent", 
   ys = yto[seq(1, length(yto), length.out = 10)], plot = FALSE, 
   colkey = list(side = 1))
 persp3D(x = x, y = y, z = -Sylt3D$depth, add = TRUE, 
   border = "black", facets = NA, colkey = FALSE)

# visualise it in rgl window
 plotrgl()

## the same, as a movie

 persp3Drgl(x = x, y = y, z = -Sylt3D$depth, smooth = TRUE, 
   col = "grey", lighting = TRUE)

 movieslice3D(xto, yto, -visc_sig$depth, colvar = visc_sig$var, 
   add = TRUE, ys = yto)

# in order to wait inbetween slice drawings until a key is hit:
## Not run: 
 persp3Drgl(x = x, y = y, z = -Sylt3D$depth, smooth = TRUE, 
   col = "grey", lighting = TRUE)
 movieslice3D(xto, yto, -visc_sig$depth, colvar = visc_sig$var, add = TRUE, 
   ask = TRUE, ys = yto)

## End(Not run)

## =============================================================================
## The 3-D data set - plotted as isosurfaces
## =============================================================================

 isosurf3D(xto, yto, -visc_sig$depth, colvar = visc_sig$var, 
   level = c(0.005, 0.01, 0.015), col = c("red", "blue", "green"), 
   scale = FALSE, expand = 0.1, ticktype = "detailed", 
   main = "viscosity", clab = "m2/s", 
   plot = FALSE, colkey = list(side = 1))
 persp3D(x = x, y = y, z = -Sylt3D$depth, border = "black", 
   col = "white", add = TRUE, plot = FALSE)


## Not run: 
 plotdev(alpha = 0.3, phi = 30)         # this is slow

## End(Not run)
 plotrgl(alpha = 0.3)

# reset plotting parameters
 par(mar = mar)
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='Tracers+20in+202D'>
Plots tracer distributions in 2-D.
</h2><span id='topic+tracers2D'></span><span id='topic+tracers2Drgl'></span>

<h3>Description</h3>

<p><code>tracers2D</code> plots a tracer distribution using traditional R graphics.
The topography can be defined when calling this function. 
</p>
<p><code>tracers2Drgl</code> plots a tracer distribution in open-GL graphics. 
A suitable topography has to be created before calling this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracers2D(x, y, colvar = NULL, ..., 
          col = NULL, NAcol = "white", colkey = NULL, 
          mask = NULL, image = FALSE, contour = FALSE, 
          clim = NULL, clab = NULL) 

tracers2Drgl(x, y, colvar = NULL, ...,
          col = NULL, NAcol = "white", breaks = NULL,
          colkey = FALSE, clim = NULL, clab = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tracers+2B20in+2B202D_+3A_x">x</code>, <code id="Tracers+2B20in+2B202D_+3A_y">y</code></td>
<td>
<p>Vectors with x- and y-coordinates of the tracers. 
Should be of equal length.
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B202D_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring. It need
not be present, but if specified, it should be a vector of 
dimension equal to <code>x</code>.
Values of <code>NULL</code>, <code>NA</code>, or <code>FALSE</code>
will toggle off coloration according to <code>colvar</code>. 
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B202D_+3A_col">col</code></td>
<td>
<p>Colors to be used for coloring each individual point (if colvar not
specified) or that define the colors as specified by the 
<code>colvar</code> variable. 
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is specified, 
then a red-yellow-blue colorscheme (<code>jet.col</code>) will be used.
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is not specified, then 
<code>col</code> will be &quot;black&quot;. 
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B202D_+3A_nacol">NAcol</code></td>
<td>
<p>Colors to be used for <code>colvar</code> values that are <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B202D_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B202D_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters 
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="plot3D.html#topic+colkey">colkey</a> from package <code>plot3D</code>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B202D_+3A_contour">contour</code>, <code id="Tracers+2B20in+2B202D_+3A_image">image</code></td>
<td>
<p>If <code>TRUE</code>, then a <a href="plot3D.html#topic+contour2D">contour2D</a> or <code>image2D</code> 
plot will be added to the quiver plot. 
Also allowed is to pass a <code>list</code> with arguments for the 
<a href="plot3D.html#topic+contour2D">contour2D</a> or <a href="plot3D.html#topic+image2D">image2D</a> function. 
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B202D_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the colors, used
for the color key. 
</p>
</td></tr> 
<tr><td><code id="Tracers+2B20in+2B202D_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey</code> is not <code>NULL</code> or <code>FALSE</code>, 
the label to be written on top of the color key. 
The label will be written at the same level as the main title.
To lower it, <code>clab</code> can be made a vector, with the first values empty 
strings. 
</p>
</td></tr> 
<tr><td><code id="Tracers+2B20in+2B202D_+3A_mask">mask</code></td>
<td>
<p>A <code>list</code> defining the grid cells outside 
the domain as <code>NA</code>.  
Use a list with argument <code>NAcol</code> to specify the color that the masked cells 
(that are <code>NA</code>) should get; the default is
<code>"black"</code>. The unmasked cells are left <code>"white"</code>. 
</p>
<p><code>mask</code> should be a <code>list</code> that contains the 
<code>x</code>, <code>y</code>, and <code>z</code> values (and that are named 'x', 'y', 'z'). 
A <code>mask</code> cannot be combined with <code>add = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B202D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plotting method <a href="plot3D.html#topic+scatter2D">scatter2D</a>. 
The arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns nothing
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+tracers3D">tracers3D</a> for plotting time series of tracer distributions in 3D
</p>
<p><a href="#topic+Ltrans">Ltrans</a> for the output of a particle tracking model
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")

## =======================================================================
## Create topography, data
## =======================================================================

# The topographic surface
 x &lt;-  seq(-pi, pi, by = 0.2)
 y &lt;-  seq(0, pi, by = 0.1)
 M &lt;- mesh(x, y)
 z &lt;- with(M, sin(x)*sin(y))

# Initial condition
 xi &lt;- c(0.125 * rnorm(100) - pi/2, 0.125 * rnorm(100) - pi/4)
 yi &lt;- 0.25 * rnorm(200) + pi/2

# the species
 species &lt;- c(rep(1, 100), rep(2, 100))   

# set initial conditions 
 xp &lt;- xi; yp &lt;- yi

## =======================================================================
## using a mask and contour
## =======================================================================

 Z &lt;- z; Z[abs(Z) &lt; 0.1] &lt;- NA
 par(mfrow = c(2, 2))

 for (i in 1:4) {
  # update tracer distribution
   xp &lt;- xp + 0.25 * rnorm(200)
   yp &lt;- yp + 0.025 * rnorm(200) 
  
  # plot new tracer distribution
   tracers2D(xp, yp, colvar = species, pch = ".", cex = 5, 
     main = paste("timestep ", i), col = c("orange", "blue"), 
     colkey = list(side = 1, length = 0.5, labels = c("sp1","sp2"),
     at = c(1.25, 1.75), dist = 0.075), NAcol = "black", 
     mask = list(x = x, y = y, z = Z), 
     contour = list(x = x, y = y, z = Z) )
 }

## =======================================================================
## using image and contour
## =======================================================================

 for (i in 1:4) {
  # update tracer distribution
   xp &lt;- xp + 0.25 * rnorm(200)
   yp &lt;- yp + 0.025 * rnorm(200) 
  
  # plot new tracer distribution
   tracers2D(xp, yp, colvar = species, pch = ".", cex = 5, 
     main = paste("timestep ", i), col = c("orange", "blue"), 
     colkey = list(side = 1, length = 0.5, labels = c("sp1","sp2"),
     at = c(1.25, 1.75), dist = 0.075), NAcol = "black", 
     contour = list(x = x, y = y, z = z),
     image = list(x = x, y = y, z = z, colkey = TRUE))
 }

## =======================================================================
## rgl tracer plot
## =======================================================================

# here the image has to be drawn first
 image2Drgl(x = x, y = y, z = z)

# set initial conditions 
 xp &lt;- xi; yp &lt;- yi
 nstep &lt;- 40
 for (i in 1:nstep) {
  # update tracer distribution
   xp &lt;- xp + 0.25 * rnorm(200)
   yp &lt;- yp + 0.025 * rnorm(200) 
  
  # plot new tracer distribution                                                              n
   tracers2Drgl(xp, yp, colvar = species,  cex = 1,
     main = paste("timestep ", i), col = c("orange", "blue"))

 }

# reset plotting parameters
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='Tracers+20in+203D'>
Plotting tracer distributions in 3D
</h2><span id='topic+tracers3D'></span><span id='topic+tracers3Drgl'></span><span id='topic+moviepoints3D'></span>

<h3>Description</h3>

<p><code>tracers3D</code> plots 3D tracer distributions in traditional graphics. 
The topography can be defined when calling this function or created before
calling this function. 
</p>
<p><code>tracers3Drgl</code> plots 3D tracer distributions in open-GL graphics. 
A suitable topography has to be created before calling this function.
It does not create a movie.  
</p>
<p><code>moviepoints3D</code> creates a movie of tracer distributions
in open-GL graphics. 
</p>
<p>It is based on the <code>plot3Drgl</code> function <a href="plot3Drgl.html#topic+points3Drgl">points3Drgl</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tracers3D (x, y, z, colvar = NULL, ..., 
      col = NULL, NAcol = "white", breaks = NULL,
      colkey = FALSE, clim = NULL, clab = NULL, surf = NULL) 

  tracers3Drgl (x, y, z, colvar = NULL, ..., 
      col = NULL, NAcol = "white", breaks = NULL,
      colkey = FALSE, clim = NULL, clab = NULL)

  moviepoints3D (x, y, z, colvar, t, by = 1, 
    col = jet.col(100), NAcol = "white", breaks = NULL,
    clim = NULL, wait  = NULL, ask = FALSE, add = FALSE,
    basename = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tracers+2B20in+2B203D_+3A_x">x</code>, <code id="Tracers+2B20in+2B203D_+3A_y">y</code>, <code id="Tracers+2B20in+2B203D_+3A_z">z</code></td>
<td>
<p>Vectors with (x, y, z) positions of tracers. 
Should be of equal length.
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B203D_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring. It need
not be present, but if specified, it should be a vector of 
dimension equal to <code>x, y, z</code>.
Values of <code>NULL</code>, <code>NA</code>, or <code>FALSE</code>
will toggle off coloration according to <code>colvar</code>. 
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B203D_+3A_t">t</code></td>
<td>
<p>Vectors with time points of tracers. 
Should be of length equal to length of <code>x, y ,z, colvar</code>.
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B203D_+3A_by">by</code></td>
<td>
<p>Number increment of the time sequence.
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B203D_+3A_col">col</code></td>
<td>
<p>Colors to be used for coloring each individual point (if colvar not
specified) or that define the colors as specified by the 
<code>colvar</code> variable. 
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is specified, 
then a red-yellow-blue colorscheme (<code>jet.col</code>) will be used.
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is not specified, then 
<code>col</code> will be &quot;black&quot;. 
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B203D_+3A_nacol">NAcol</code></td>
<td>
<p>Colors to be used for <code>colvar</code> values that are <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B203D_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B203D_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="plot3D.html#topic+colkey">colkey</a> from package <code>plot3D</code>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr> 
<tr><td><code id="Tracers+2B20in+2B203D_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the colors, used
for the color key. 
</p>
</td></tr> 
<tr><td><code id="Tracers+2B20in+2B203D_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey</code> is not <code>NULL</code> or <code>FALSE</code>, 
the label to be written on top of the color key. 
The label will be written at the same level as the main title.
To lower it, <code>clab</code> can be made a vector, with the first values empty 
strings. 
</p>
</td></tr> 
<tr><td><code id="Tracers+2B20in+2B203D_+3A_surf">surf</code></td>
<td>
<p>If not <code>NULL</code>, a list specifying a surface to be added on 
the scatterplot. 
They should include at least <code>x</code>, <code>y</code>, <code>z</code>, equal sized
matrices, and optional: <code>colvar, col, NAcol, border, facets, 
    lwd, resfac, clim, ltheta, lphi, shade, lighting</code>. Note that the default is 
that <code>colvar</code> is not specified.
</p>
</td></tr>
<tr><td><code id="Tracers+2B20in+2B203D_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the points will be added to the current plot.
If <code>FALSE</code> a new plot is started. 
</p>
</td></tr>     
<tr><td><code id="Tracers+2B20in+2B203D_+3A_ask">ask</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then new points will only be drawn after a key has been struck. If <code>FALSE</code>, redrawing will depend on <code>wait</code> 
</p>
</td></tr>     
<tr><td><code id="Tracers+2B20in+2B203D_+3A_wait">wait</code></td>
<td>
<p>The time interval inbetween drawing of a set of new points, in seconds. 
If <code>NULL</code>, the drawing will not be suspended. 
</p>
</td></tr>     
<tr><td><code id="Tracers+2B20in+2B203D_+3A_basename">basename</code></td>
<td>
<p>The base name of a <code>png</code> file to be produced for each movieframe. 
</p>
</td></tr>     
<tr><td><code id="Tracers+2B20in+2B203D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <a href="plot3D.html#topic+scatter3D">scatter3D</a> from package 
<code>plot3D</code>.  Typical arguments are <code>cex, main</code> (both functions), 
and <code>pch, ...</code> for <code>tracers3D</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns nothing
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+tracers2D">tracers2D</a> for plotting time series of tracer distributions in 2D
</p>
<p><a href="#topic+movieslice3D">movieslice3D</a> for plotting slices in 3D
</p>
<p><a href="#topic+Ltrans">Ltrans</a> for 3-D output of a particle tracking model
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")

## =======================================================================
## Create topography, data
## =======================================================================

# The topographic surface
 x &lt;- seq(-pi, pi, by = 0.2)
 y &lt;- seq(0, pi, by = 0.1)
 M &lt;- mesh(x, y)
 z &lt;- with(M, sin(x)*sin(y))

# Initial condition
 xi &lt;- c(0.25 * rnorm(100) - pi/2, 0.25 * rnorm(100) - pi/4)
 yi &lt;- 0.25 * rnorm(200) + pi/2
 zi &lt;- 0.005*rnorm(200) + 0.5

# the species
 species &lt;- c(rep(1, 100), rep(2, 100))   

# set initial conditions 
 xp &lt;- xi; yp &lt;- yi; zp &lt;- zi

## =======================================================================
## Traditional graphics
## =======================================================================

 par(mfrow = c(2, 2))

# Topography is defined by argument surf
 for (i in 1:4) {
  # update tracer distribution
   xp &lt;- xp + 0.25 * rnorm(200)
   yp &lt;- yp + 0.025 * rnorm(200) 
   zp &lt;- zp + 0.25 *rnorm(200)
  
  # plot new tracer distribution
   tracers3D(xp, yp, zp, colvar = species, pch = ".", cex = 5, 
     main = paste("timestep ", i), col = c("orange", "blue"), 
     surf = list(x, y, z = z, theta = 0, facets = FALSE),
     colkey = list(side = 1, length = 0.5, labels = c("sp1","sp2"),
                   at = c(1.25, 1.75), dist = 0.075))
 }

# same, but creating topography first
## Not run: 
# create the topography on which to add points 
 persp3D(x, y, z = z, theta = 0, facets = FALSE, plot = FALSE)

 for (i in 1:4) {
  # update tracer distribution
   xp &lt;- xp + 0.25 * rnorm(200)
   yp &lt;- yp + 0.025 * rnorm(200) 
   zp &lt;- zp + 0.25 *rnorm(200)
  
  # plot new tracer distribution
   tracers3D(xp, yp, zp, colvar = species, pch = ".", cex = 5, 
     main = paste("timestep ", i), col = c("orange", "blue"), 
     colkey = list(side = 1, length = 0.5, labels = c("sp1","sp2"),
                    at = c(1.25, 1.75), dist = 0.075))
 }

## End(Not run)

## =======================================================================
## rgl graphics
## =======================================================================

# pause &lt;- 0.05
# create a suitable topography
 persp3D(x, y, z = z, theta = 0, facets = NA, plot = FALSE)

 plotrgl( )
 xp &lt;- xi; yp &lt;- yi; zp &lt;- zi
 
 nstep &lt;- 10
 for (i in 1:nstep) {
   xp &lt;- xp + 0.05 * rnorm(200) + 0.05
   yp &lt;- yp + 0.0025 * (rnorm(200) + 0.0025)
   zp &lt;- zp + 0.05 *rnorm(200)

#   tracers3Drgl(xp, yp, zp, col = c(rep("orange", 100), rep("blue", 100)),
#     main = paste("timestep ", i))
# or:
   tracers3Drgl(xp, yp, zp, colvar = species, col = c("orange", "blue"),
     main = paste("timestep ", i))
#   Sys.sleep(pause)
# or:  readline("hit enter for next")
 }

# using function moviepoints3D

## Not run: 
# first create the data in matrices
 xp &lt;- matrix(nrow = 200, ncol = nstep, data = rep(xi, times=nstep)) 
 yp &lt;- matrix(nrow = 200, ncol = nstep, data = rep(yi, times=nstep)) 
 zp &lt;- matrix(nrow = 200, ncol = nstep, data = rep(zi, times=nstep))
 tp &lt;- matrix(nrow = 200, ncol = nstep, data = 0)
 cv &lt;- matrix(nrow = 200, ncol = nstep, data = rep(species, times=nstep))
 nstep &lt;- 10
 for (i in 2:nstep) {
   xp[,i] &lt;- xp[,i-1] + 0.05 * rnorm(200) + 0.05
   yp[,i] &lt;- yp[,i-1] + 0.0025 * (rnorm(200) + 0.0025)
   zp[,i] &lt;- zp[,i-1] + 0.05 *rnorm(200)
   tp[,i] &lt;- i
 }
# create the topography
 persp3Drgl(x, y, z = z, theta = 0, lighting = TRUE, smooth = TRUE)

# add moviepoints:
  moviepoints3D (xp, yp, zp, colvar = cv, t = tp, 
    wait = 0.05, cex = 10, col = c("red", "orange")) 
 

## End(Not run)

# reset plotting parameters
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='vector+20plots'>
Vector velocity plot.
</h2><span id='topic+vectorplot'></span>

<h3>Description</h3>

<p>Displays (velocity) vectors as segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectorplot(u, v, x = 0, y = 0, colvar = NULL, ...,
           col = NULL, NAcol = "white", breaks = NULL, colkey = NULL,
           by = 1, arr = FALSE, xfac = NULL, 
           clim = NULL, clab = NULL, add = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector+2B20plots_+3A_u">u</code></td>
<td>
<p>A vector with quantities (velocities) in x-direction. 
</p>
</td></tr>
<tr><td><code id="vector+2B20plots_+3A_v">v</code></td>
<td>
<p>A vector with quantities (velocities) in y-direction. 
Should have the same length as <code>u</code>
</p>
</td></tr>
<tr><td><code id="vector+2B20plots_+3A_x">x</code></td>
<td>
<p>A vector with x-axis values. If <code>0</code>, everything will 
be radiating from the origin. Usually <code>x</code> will be equal to <code>time</code>.
</p>
</td></tr>
<tr><td><code id="vector+2B20plots_+3A_y">y</code></td>
<td>
<p>The y-axis value. One number, or a vector of length = u.
</p>
</td></tr>
<tr><td><code id="vector+2B20plots_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring. It need
not be present, but if specified, it should be a vector of 
dimension equal to <code>c(nrow(u), ncol(v))</code>.
Values of <code>NULL</code>, <code>NA</code>, or <code>FALSE</code>
will toggle off coloration according to <code>colvar</code>. 
</p>
</td></tr>
<tr><td><code id="vector+2B20plots_+3A_col">col</code></td>
<td>
<p>Colors to be used for coloring the arrows as specified by the 
<code>colvar</code> variable. 
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is specified, 
then a red-yellow-blue colorscheme (<a href="plot3D.html#topic+jet.col">jet.col</a>) will be used.
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is not specified, then 
<code>col</code> will be &quot;black&quot;. 
</p>
</td></tr>
<tr><td><code id="vector+2B20plots_+3A_nacol">NAcol</code></td>
<td>
<p>Colors to be used for <code>colvar</code> values that are <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="vector+2B20plots_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="vector+2B20plots_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="plot3D.html#topic+colkey">colkey</a> from package <code>plot3D</code>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr> 
<tr><td><code id="vector+2B20plots_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the colors, used
for the color key. 
</p>
</td></tr> 
<tr><td><code id="vector+2B20plots_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey</code> is not <code>NULL</code> or <code>FALSE</code>, 
the label to be written on top of the color key. 
The label will be written at the same level as the main title.
To lower it, <code>clab</code> can be made a vector, with the first values empty 
strings. 
</p>
</td></tr> 
<tr><td><code id="vector+2B20plots_+3A_by">by</code></td>
<td>
<p>Number increment for plotting vectors. 
Set this to an integer &gt; <code>1</code> if the vector density is too high. 
</p>
</td></tr>
<tr><td><code id="vector+2B20plots_+3A_xfac">xfac</code></td>
<td>
<p>Only for <code>x</code> not <code>NULL</code>, the proportionality
factor with which the vectors on the x-axis must be drawn. A value of <code>1</code>
means that the distance of one will be drawn as one x-unit on the x-axis.
For a value of <code>2</code> a distance of 1 will appear as 2 x-units on the x-axis. 
if <code>NULL</code>, the range on the y-axis is used. In that case, it may be
necessary to manually set the <code>xlim</code> of the figure.
</p>
</td></tr>
<tr><td><code id="vector+2B20plots_+3A_arr">arr</code></td>
<td>
<p>If <code>TRUE</code>, then <a href="shape.html#topic+Arrows">Arrows</a> will be drawn; 
if <code>FALSE</code>, <a href="graphics.html#topic+segments">segments</a> will be drawn. 
</p>
</td></tr>
<tr><td><code id="vector+2B20plots_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, will add to the current plot. 
</p>
</td></tr>
<tr><td><code id="vector+2B20plots_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plotting methods. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>See Also</h3>

<p><a href="#topic+quiver2D">quiver2D</a>, <a href="#topic+flowpath">flowpath</a>, for other functions to plot velocities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 mf &lt;- par("mfrow")

## =======================================================================
##  EXAMPLE 1: 
## =======================================================================

 par(mfrow = c(2, 2))

 u &lt;- cos(seq(0, 2*pi, 0.1))
 v &lt;- sin(seq(0, 2*pi, 0.1)+ 1)

 vectorplot(u = u, v = v)
 vectorplot(u = u, v = v, col = 1:10)

 x &lt;- seq(0, 1, length.out = length(u))
 vectorplot(u = u, v = v, x = x, xfac = 3)
 points(x, rep(0, length(u)), pch = "+", col = "red")

 vectorplot(u = u, v = v, x = 1:length(u), xfac = 10)

## =======================================================================
##  EXAMPLE 2:  adding to a plot
## =======================================================================

 par(mfrow = c(2, 2))
 x &lt;- 1:length(u)
 plot(x, u)
 vectorplot(u = u, v = v, x = x, xfac = 10, 
            add = TRUE, col = "red")
 
 vectorplot(u = u, v = v, x = x, xfac = 10, 
   colvar = sqrt(u^2+v^2), clab = "m/s")
 
 vectorplot(u = u, v = v, x = x, xfac = 10, 
   colvar = sqrt(u^2+v^2), clab = "m/s", log = "c")

# reset plotting parameters
 par(mfrow = mf)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
