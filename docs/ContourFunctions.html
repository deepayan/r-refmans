<!DOCTYPE html><html><head><title>Help for package ContourFunctions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ContourFunctions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cf'><p>Make contour plot from data or function</p></a></li>
<li><a href='#cf_4dim'><p>Plot 2D contour slices of four dimensional functions</p></a></li>
<li><a href='#cf_data'><p>Contour plot from data</p></a></li>
<li><a href='#cf_func'><p>Makes filled contour plot from function</p></a></li>
<li><a href='#cf_grid'><p>Create a contour plot from a grid of data</p></a></li>
<li><a href='#cf_highdim'><p>Plot 2D contour slices of higher dimensional functions</p></a></li>
<li><a href='#cm.colors.strong'><p>Strong version of cm.colors color palette</p></a></li>
<li><a href='#csa'><p>Close all open screens</p></a></li>
<li><a href='#eval_over_grid_with_batch'><p>Evaluate function over grid of points</p></a></li>
<li><a href='#gcf'><p>Make contour plot from data or function using ggplot2</p></a></li>
<li><a href='#gcf_data'><p>Contour plot from data</p></a></li>
<li><a href='#gcf_func'><p>Makes filled contour plot from function</p></a></li>
<li><a href='#gcf_grid'><p>Create contour plot from grid data using ggplot2</p></a></li>
<li><a href='#multicolor.title'><p>Makes plot title using specified colors for the text</p></a></li>
<li><a href='#text_plot'><p>Make a plot with only text</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Create Contour Plots from Data or a Function</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for making contour plots.
  The contour plot can be created from grid data, a function,
  or a data set. If non-grid data is given, then a Gaussian
  process is fit to the data and used to create the contour plot.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, lhs, mlegp, ggplot2, laGP, covr, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CollinErickson/contour">https://github.com/CollinErickson/contour</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-05-20 02:47:59 UTC; cbe117</td>
</tr>
<tr>
<td>Author:</td>
<td>Collin Erickson [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Collin Erickson &lt;collinberickson@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-05-20 04:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='cf'>Make contour plot from data or function</h2><span id='topic+cf'></span>

<h3>Description</h3>

<p>Simpler function for making contours with cf package.
Won't give argument completion, so all must be specified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf(..., gg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cf_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to cf_func or cf_data based on 
data type of first argument. If D is given as argument, then it
is passed to cf_highdim.</p>
</td></tr>
<tr><td><code id="cf_+3A_gg">gg</code></td>
<td>
<p>Should ggplot2 be used instead of base graphics?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Whatever is returned from other function, probably nothing.
Will be a ggplot2 object if using gg=TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cf(function(x){x[1]^2 - x[2]})
x &lt;- runif(20)
y &lt;- runif(20)
z &lt;- exp(-(x-.5)^2-5*(y-.5)^2)# + rnorm(20,0,.05)
cf(x,y,z)
cf(function(x){x[1]^2 - x[2]}, D=3)
</code></pre>

<hr>
<h2 id='cf_4dim'>Plot 2D contour slices of four dimensional functions</h2><span id='topic+cf_4dim'></span>

<h3>Description</h3>

<p>Plots a grid of contour plots.
Each contour plot is a contour over two dimensions with the remaining
two dimensions set to a value.
See cf_highdim for functions with more than 4 dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf_4dim(func, over = c(1, 2), nover = 5, nover1 = nover,
  nover2 = nover, low = rep(0, 4), high = rep(1, 4),
  same_scale = TRUE, n = 20, batchmax = 1,
  var_names = c(expression(), lapply(1:4, function(ti)
  bquote(x[.(ti)]))), pts = NULL, axes = TRUE, key.axes, key.title,
  nlevels = 20, color.palette = cm.colors.strong, edge_width = 0.04,
  cex.var_names = 1.3, bar = TRUE, bar_width = 0.2, over_srt = c(0,
  90), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cf_4dim_+3A_func">func</code></td>
<td>
<p>A four-dimensional function to plot contours of</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_over">over</code></td>
<td>
<p>Indices of the dimensions used for the outer grid</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_nover">nover</code></td>
<td>
<p>Number of grid points for the outer grid dimensions</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_nover1">nover1</code></td>
<td>
<p>Number of grid points for the first outer grid dimension</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_nover2">nover2</code></td>
<td>
<p>Number of grid points for the second outer grid dimension</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_low">low</code></td>
<td>
<p>Low input value for each dimension</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_high">high</code></td>
<td>
<p>High input value for each dimension</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_same_scale">same_scale</code></td>
<td>
<p>Should all contour plots be on the same scale?
Takes longer since it has to precalculate range of outputs.</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_n">n</code></td>
<td>
<p>Number of points in grid on each dimension</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_batchmax">batchmax</code></td>
<td>
<p>number of datapoints that can be computed at a time</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_var_names">var_names</code></td>
<td>
<p>Variable names to add to plot</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_pts">pts</code></td>
<td>
<p>Matrix of points to show on plot</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_axes">axes</code></td>
<td>
<p>axes</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_key.axes">key.axes</code></td>
<td>
<p>key for bar plot</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_key.title">key.title</code></td>
<td>
<p>statements which add titles for the plot key.</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_nlevels">nlevels</code></td>
<td>
<p>Number of levels in contour scale</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_color.palette">color.palette</code></td>
<td>
<p>Color palette used for contour plots</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_edge_width">edge_width</code></td>
<td>
<p>How wide should edges with variable names be?
As proportion of screen section to left of bar.
Either single value for both edges, or length two vector.</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_cex.var_names">cex.var_names</code></td>
<td>
<p>Size of var_names printed on edges.</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_bar">bar</code></td>
<td>
<p>Should a bar be added on right when all on same_scale?</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_bar_width">bar_width</code></td>
<td>
<p>How wide should bar section of plot be?</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_over_srt">over_srt</code></td>
<td>
<p>Degrees of rotation for the axis labels. Vector of length two.</p>
</td></tr>
<tr><td><code id="cf_4dim_+3A_...">...</code></td>
<td>
<p>Arguments passed to cf_func, and then probably through to cf_grid</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cf_4dim(
  function(x) {x[1] + x[2]^2 + sin(2*pi*x[3])}
)

cf_4dim(function(x) x[1]*x[3] + sin(x[2]*x[4]), color.palette=heat.colors,
        nover1=3, nover2=8, cex.var_names = .5)
        
cf_4dim(function(x) x[1]*x[3] + sin(x[2]*x[4]), color.palette=topo.colors,
        nover1=3, nover2=8, cex.var_names = 1, over_srt = c(90,0),
        edge_width=c(.1, .2), nlevels = 5)
</code></pre>

<hr>
<h2 id='cf_data'>Contour plot from data</h2><span id='topic+cf_data'></span>

<h3>Description</h3>

<p>Makes filled contour plot from data without sidebar by interpolating 
with a Gaussian process model.
The model is passed to cf_func to make the contour plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf_data(x, y = NULL, z = NULL, xlim = NULL, ylim = NULL,
  xylim = NULL, fit = "", gg = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cf_data_+3A_x">x</code></td>
<td>
<p>either just x data, x and y data, or x, y and z data</p>
</td></tr>
<tr><td><code id="cf_data_+3A_y">y</code></td>
<td>
<p>either y data, z data, or null</p>
</td></tr>
<tr><td><code id="cf_data_+3A_z">z</code></td>
<td>
<p>either z data or null</p>
</td></tr>
<tr><td><code id="cf_data_+3A_xlim">xlim</code></td>
<td>
<p>x limits for the contour plot, will be set to data limits +- 5% if not specified</p>
</td></tr>
<tr><td><code id="cf_data_+3A_ylim">ylim</code></td>
<td>
<p>y limits for the contour plot, will be set to data limits +- 5% if not specified</p>
</td></tr>
<tr><td><code id="cf_data_+3A_xylim">xylim</code></td>
<td>
<p>x and y limits for the contour plot</p>
</td></tr>
<tr><td><code id="cf_data_+3A_fit">fit</code></td>
<td>
<p>Method to fit a model with. Current options are laGP (default)
and mlegp. laGP is faster but might cause trouble.</p>
</td></tr>
<tr><td><code id="cf_data_+3A_gg">gg</code></td>
<td>
<p>If TRUE, will use ggplot2 by calling gcf_func</p>
</td></tr>
<tr><td><code id="cf_data_+3A_...">...</code></td>
<td>
<p>passed to cf_func</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
y &lt;- runif(20)
z &lt;- exp(-(x-.5)^2-5*(y-.5)^2)
cf_data(x,y,z)
</code></pre>

<hr>
<h2 id='cf_func'>Makes filled contour plot from function</h2><span id='topic+cf_func'></span>

<h3>Description</h3>

<p>A contour plot of the given function without sidebar by default.
It calls the function 'cf_grid' to make the actual plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf_func(fn0, n = 100, xlim = c(0, 1), ylim = c(0, 1), xylim = NULL,
  batchmax = 1, out.col.name = NULL, out.name = NULL, pts = NULL,
  gg = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cf_func_+3A_fn0">fn0</code></td>
<td>
<p>function to plot, first argument must be two-dimensional</p>
</td></tr>
<tr><td><code id="cf_func_+3A_n">n</code></td>
<td>
<p>number of points in each dimension</p>
</td></tr>
<tr><td><code id="cf_func_+3A_xlim">xlim</code></td>
<td>
<p>x limits for the contour plot</p>
</td></tr>
<tr><td><code id="cf_func_+3A_ylim">ylim</code></td>
<td>
<p>y limits for the contour plot</p>
</td></tr>
<tr><td><code id="cf_func_+3A_xylim">xylim</code></td>
<td>
<p>x and y limits for the contour plot, use when both are same
#@param mainminmax  whether the min and max values should be shown in the title of plot</p>
</td></tr>
<tr><td><code id="cf_func_+3A_batchmax">batchmax</code></td>
<td>
<p>number of datapoints that can be computed at a time</p>
</td></tr>
<tr><td><code id="cf_func_+3A_out.col.name">out.col.name</code></td>
<td>
<p>if a column needs to be selected from the function, specify it</p>
</td></tr>
<tr><td><code id="cf_func_+3A_out.name">out.name</code></td>
<td>
<p>Selects with a $ the name from output to be used, for lists and data frames
#@param pretitle Text to be preappended to end of plot title
#@param posttitle Text to be appended to end of plot title
#@param title Title for the plot
#@param mainminmax_minmax Whether [min,max]= should be shown in title or just the numbers</p>
</td></tr>
<tr><td><code id="cf_func_+3A_pts">pts</code></td>
<td>
<p>Points to plot on top of contour</p>
</td></tr>
<tr><td><code id="cf_func_+3A_gg">gg</code></td>
<td>
<p>Should ggplot2 be used? Will use gcf_grid() instead of cf_grid().</p>
</td></tr>
<tr><td><code id="cf_func_+3A_...">...</code></td>
<td>
<p>Passed to cf_grid</p>
</td></tr>
</table>


<h3>References</h3>

<p>[1] filled.contour R function, copied function but removed part for sidebar
</p>
<p>[2] http://stackoverflow.com/questions/16774928/removing-part-of-a-graphic-in-r, answer by P Lapointe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cf_func(function(x){x[1]*x[2]})
cf_func(function(x)(exp(-(x[1]-.5)^2-5*(x[2]-.5)^2)))
cf_func(function(xx){exp(-sum((xx-.5)^2/.1))}, bar=TRUE)
cf_func(function(xx){exp(-sum((xx-.5)^2/.1))}, bar=TRUE, mainminmax=TRUE)
cf_func(function(x)(exp(-(x[1]-.5)^2-5*(x[2]-.5)^2)), with_lines=TRUE)
</code></pre>

<hr>
<h2 id='cf_grid'>Create a contour plot from a grid of data</h2><span id='topic+cf_grid'></span>

<h3>Description</h3>

<p>Makes filled contour plot with an optional sidebar, essentially filled.contour function.
This version uses the split.screen() function to add the sidebar if bar is TRUE.
By default it won't show the bar but will show the min and max values in the plot title
along with their colors.
Using this function will make other functions such as points() called afterwards not put points
where you expect. Pass anything you want added to the plot area to afterplotfunc
as a function to get it to work properly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf_grid(x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, length.out =
  ncol(z)), z, xlim = range(x, finite = TRUE), ylim = range(y, finite =
  TRUE), zlim = range(z, finite = TRUE), levels = pretty(zlim,
  nlevels), nlevels = 20, color.palette = cm.colors.strong,
  col = color.palette(length(levels) - 1), plot.title, plot.axes,
  key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1,
  axes = TRUE, frame.plot = axes, bar = F, pts = NULL,
  reset.par = TRUE, pretitle = "", posttitle = "", main = NULL,
  mainminmax = !bar, mainminmax_minmax = TRUE, afterplotfunc = NULL,
  cex.main = par()$cex.main, par.list = NULL, xaxis = TRUE,
  yaxis = TRUE, with_lines = FALSE, lines_only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cf_grid_+3A_x">x</code></td>
<td>
<p>x values, must form grid with y. If not given, it is assumed to be from 0 to 1.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_y">y</code></td>
<td>
<p>y values, must form grid with x. If not given, it is assumed to be from 0 to 1.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_z">z</code></td>
<td>
<p>z values at grid locations</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_xlim">xlim</code></td>
<td>
<p>x limits for the plot.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_ylim">ylim</code></td>
<td>
<p>y limits for the plot.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_zlim">zlim</code></td>
<td>
<p>z limits for the plot.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_levels">levels</code></td>
<td>
<p>a set of levels which are used to partition the range of z. Must be strictly increasing (and finite). Areas with z values between consecutive levels are painted with the same color.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_nlevels">nlevels</code></td>
<td>
<p>if levels is not specified, the range of z, values is divided into approximately this many levels.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_color.palette">color.palette</code></td>
<td>
<p>A color palette function to be used to assign colors
in the plot. Defaults to cm.colors.strong. Other options include rainbow,
heat.colors, terrain.colors, topo.colors, and function(x) gray((1:x)/x).</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_col">col</code></td>
<td>
<p>an explicit set of colors to be used in the plot. This argument overrides any palette function specification. There should be one less color than levels</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_plot.title">plot.title</code></td>
<td>
<p>statements which add titles to the main plot.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_plot.axes">plot.axes</code></td>
<td>
<p>statements which draw axes (and a box) on the main plot. This overrides the default axes.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_key.title">key.title</code></td>
<td>
<p>statements which add titles for the plot key.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_key.axes">key.axes</code></td>
<td>
<p>statements which draw axes on the plot key. This overrides the default axis.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_asp">asp</code></td>
<td>
<p>the y/x aspect ratio, see plot.window.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_xaxs">xaxs</code></td>
<td>
<p>the x axis style. The default is to use internal labeling.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_yaxs">yaxs</code></td>
<td>
<p>the y axis style. The default is to use internal labeling.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_las">las</code></td>
<td>
<p>the style of labeling to be used. The default is to use horizontal labeling.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_axes">axes</code></td>
<td>
<p>logical indicating if axes should be drawn, as in plot.default.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_frame.plot">frame.plot</code></td>
<td>
<p>logical indicating if a box should be drawn, as in plot.default.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_bar">bar</code></td>
<td>
<p>Should a bar showing the output range and colors be shown on the right?</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_pts">pts</code></td>
<td>
<p>Points to plot on top of contour</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_reset.par">reset.par</code></td>
<td>
<p>Should the graphical parameters be reset before exiting? Usually should be
unless you need to add something to the plot afterwards and bar is TRUE.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_pretitle">pretitle</code></td>
<td>
<p>Text to be preappended to end of plot title</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_posttitle">posttitle</code></td>
<td>
<p>Text to be appended to end of plot title</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_main">main</code></td>
<td>
<p>Title for the plot</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_mainminmax">mainminmax</code></td>
<td>
<p>whether the min and max values should be shown in the title of plot</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_mainminmax_minmax">mainminmax_minmax</code></td>
<td>
<p>Whether [min,max]= should be shown in title or just the numbers</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_afterplotfunc">afterplotfunc</code></td>
<td>
<p>Function to call after plotting, such as adding points or lines.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_cex.main">cex.main</code></td>
<td>
<p>The size of the main title. 1.2 is default.</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_par.list">par.list</code></td>
<td>
<p>List of options to pass to par</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_xaxis">xaxis</code></td>
<td>
<p>Should x axis be added?</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_yaxis">yaxis</code></td>
<td>
<p>Should y axis be added?</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_with_lines">with_lines</code></td>
<td>
<p>Should lines be added on top of 
contour to show contours?</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_lines_only">lines_only</code></td>
<td>
<p>Should no fill be used, only contour lines?</p>
</td></tr>
<tr><td><code id="cf_grid_+3A_...">...</code></td>
<td>
<p>additional graphical parameters, currently only passed to title().</p>
</td></tr>
</table>


<h3>References</h3>

<p>[1] filled.contour R function, copied function but removed part for sidebar
</p>
<p>[2] http://stackoverflow.com/questions/16774928/removing-part-of-a-graphic-in-r, answer by P Lapointe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- y &lt;- seq(-4*pi, 4*pi, len = 27)
r &lt;- sqrt(outer(x^2, y^2, "+"))
cf_grid(cos(r^2)*exp(-r/(2*pi)))
cf_grid(r, color.palette=heat.colors, bar=TRUE)
cf_grid(r, color.palette=function(x) {gray((1:x)/x)}, bar=TRUE)
</code></pre>

<hr>
<h2 id='cf_highdim'>Plot 2D contour slices of higher dimensional functions</h2><span id='topic+cf_highdim'></span>

<h3>Description</h3>

<p>Plots a grid of contour plots.
Each contour plot is a contour over two dimensions with the remaining
dimensions set to the baseline value.
Similar to plots created in Hwang et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf_highdim(func, D, low = rep(0, D), high = rep(1, D),
  baseline = (low + high)/2, same_scale = TRUE, n = 20,
  batchmax = 1, var_names = c(expression(), lapply(1:D, function(ti)
  bquote(x[.(ti)]))), pts = NULL, average = FALSE,
  average_reps = 10000, axes = TRUE, key.axes, key.title,
  nlevels = 20, levels = pretty(zlim, nlevels),
  color.palette = cm.colors.strong, col = color.palette(length(levels)
  - 1), edge_width = 0.04, cex.var_names = 1.3, bar = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cf_highdim_+3A_func">func</code></td>
<td>
<p>Function to plot contours of</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_d">D</code></td>
<td>
<p>Input dimension of function</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_low">low</code></td>
<td>
<p>Low input value for each dimension</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_high">high</code></td>
<td>
<p>High input value for each dimension</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_baseline">baseline</code></td>
<td>
<p>Baseline input value for each dimension</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_same_scale">same_scale</code></td>
<td>
<p>Should all contour plots be on the same scale?</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_n">n</code></td>
<td>
<p>Number of points in grid on each dimension</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_batchmax">batchmax</code></td>
<td>
<p>number of datapoints that can be computed at a time</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_var_names">var_names</code></td>
<td>
<p>Variable names to add to plot
Takes longer since it has to precalculate range of outputs.</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_pts">pts</code></td>
<td>
<p>Matrix of points to show on plot</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_average">average</code></td>
<td>
<p>Should the background dimensions be averaged over instead of
set to baseline value? Much slower.</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_average_reps">average_reps</code></td>
<td>
<p>Number of points to average over when using average</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_axes">axes</code></td>
<td>
<p>logical indicating if axes should be drawn, as in plot.default.</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_key.axes">key.axes</code></td>
<td>
<p>statements which draw axes on the plot key. This overrides the default axis.</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_key.title">key.title</code></td>
<td>
<p>statements which add titles for the plot key.</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_nlevels">nlevels</code></td>
<td>
<p>if levels is not specified, the range of z, values is
divided into approximately this many levels.</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_levels">levels</code></td>
<td>
<p>a set of levels which are used to partition the range of z.
Must be strictly increasing (and finite). Areas with z values between
consecutive levels are painted with the same color.</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_color.palette">color.palette</code></td>
<td>
<p>A color palette function to be used to assign colors
in the plot. Defaults to cm.colors.strong. Other options include rainbow,
heat.colors, terrain.colors, topo.colors, and function(x) gray((1:x)/x).</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_col">col</code></td>
<td>
<p>an explicit set of colors to be used in the plot.
This argument overrides any palette function specification.
There should be one less color than levels.</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_edge_width">edge_width</code></td>
<td>
<p>How wide should edges with variable names be? As proportion of full screen.</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_cex.var_names">cex.var_names</code></td>
<td>
<p>Size of var_names printed on edges.</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_bar">bar</code></td>
<td>
<p>Should a bar showing the output range and colors be shown on the top right?</p>
</td></tr>
<tr><td><code id="cf_highdim_+3A_...">...</code></td>
<td>
<p>Arguments passed to cf_func, and then probably through to cf_grid</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hwang, Yongmoon, Sang-Lyul Cha, Sehoon Kim, Seung-Seop Jin,
and Hyung-Jo Jung. &quot;The Multiple-Update-Infill Sampling Method Using
Minimum Energy Design for Sequential Surrogate Modeling.&quot;
Applied Sciences 8, no. 4 (2018): 481.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Only use 4 dims of 8 for borehole function
cf_highdim(function(x) TestFunctions::borehole(c(x,.5,.5,.5,.5)), 4)
# Add points
cf_highdim(function(x) TestFunctions::borehole(c(x,.5,.5,.5,.5)), 4,
           pts=matrix(c(.1,.3,.6,.9),1,4))

# Full 8D borehole function
cf_highdim(TestFunctions::borehole, 8)

# Putting each plot on separate scale
cf_highdim(TestFunctions::borehole, 8, n=10, same_scale = FALSE)

## End(Not run)

cf_highdim(function(x) {x[1]^2 + exp(x[2])}, D=3)

friedman &lt;- function(x) {
  10*sin(pi*x[1]*x[2]) + 20*(x[3]-.5)^2 + 10*x[4] + 5*x[5]
}
cf_highdim(friedman, 5, color.palette=topo.colors)
cf_highdim(friedman, 5, 
           color.palette=function(x) {gray((1:x)/x)},
           nlevels=10)
           
## Not run: 
# Recreate Plate 1 or Figure 1.1 from Engineering Design via Surrogate
# Modelling by Forrester, Sobester, and Keane (2008).
cf_highdim(function(x)TestFunctions::wingweight(x, scale_it=FALSE),
  D=10, low = c(150,220,6,-10,16,.5,.08,2.5,1700,.025),
  high = c(200,300,10,10,45,1,.18,6,2500,.08),
  baseline=c(174,252,7.52,0,34,.672,.12,3.8,2000,.064),
  color.palette=topo.colors, 
  var_names=c('SW', 'Wtw', 'A', 'Lambda', 'q', 'lambda', 'tc', 'Nz', 'Wdg'))

## End(Not run)

# Average over background dimensions, use higher reps to reduce noise.
f1 &lt;- function(x) {x[1] + x[2]^2 + x[3]^3}
cf_highdim(f1, 4, average=TRUE, average_reps=1e2, n=10)
f1b &lt;- function(x) {x[,1] + x[,2]^2 + x[,3]^3}
cf_highdim(f1b, 4, average=TRUE, average_reps=1e2, n=10, batchmax=Inf)
cf_highdim(f1b, 4, average_reps=1e2, n=10, batchmax=Inf,
           color.palette = topo.colors, nlevels=3)

# This was giving bad result
csa()
split.screen(c(2,1))
screen(2)
cf_highdim(f1b, 4, n=10, batchmax=Inf)
csa()
</code></pre>

<hr>
<h2 id='cm.colors.strong'>Strong version of cm.colors color palette</h2><span id='topic+cm.colors.strong'></span>

<h3>Description</h3>

<p>Altered version of cm.colors that uses
full saturation to get stronger colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cm.colors.strong(n, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cm.colors.strong_+3A_n">n</code></td>
<td>
<p>Number of color groups</p>
</td></tr>
<tr><td><code id="cm.colors.strong_+3A_alpha">alpha</code></td>
<td>
<p>Alpha level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of colors
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Character string output
cm.colors.strong(5)

# Plot to show these
sl &lt;- 21
sx &lt;- seq(0,1,l=sl)
plot(sx,sin(2*pi*sx), cex=5, col=cm.colors.strong(sl), pch=19);points(sx,sin(2*pi*sx), cex=5)
plot(sx,sin(2*pi*sx), cex=5, col=cm.colors(sl),        pch=19);points(sx,sin(2*pi*sx), cex=5)
</code></pre>

<hr>
<h2 id='csa'>Close all open screens</h2><span id='topic+csa'></span>

<h3>Description</h3>

<p>Closes the screens open, which happens
when plotting with 'split.screen' is interrupted.
It often happens when there is a error while plotting.
When you try to plot
the next thing it gives an error.
Running this function will reset the plot screen.
It just does 'close.screen(all.screens=TRUE)' but is faster to type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csa(silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csa_+3A_silent">silent</code></td>
<td>
<p>Should the output of 'close.screen' not be returned?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Split screen into fourths
split.screen(c(2,2))
hist(rnorm(100))
screen(2)
hist(runif(100))
# Use csa() to go back to normal plotting
csa()
hist(rexp(100))
</code></pre>

<hr>
<h2 id='eval_over_grid_with_batch'>Evaluate function over grid of points</h2><span id='topic+eval_over_grid_with_batch'></span>

<h3>Description</h3>

<p>'batchmax' gives how many can be evaluated at a time.
If more than 1, then the input is given to the function
as rows of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_over_grid_with_batch(x, y, fn, batchmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_over_grid_with_batch_+3A_x">x</code></td>
<td>
<p>Vector of x values to evaluate</p>
</td></tr>
<tr><td><code id="eval_over_grid_with_batch_+3A_y">y</code></td>
<td>
<p>Vector of y values to evaluate</p>
</td></tr>
<tr><td><code id="eval_over_grid_with_batch_+3A_fn">fn</code></td>
<td>
<p>Function that takes in a length two vector if 'batchmax' is 1
or a matrix with two columns if greater than 1.</p>
</td></tr>
<tr><td><code id="eval_over_grid_with_batch_+3A_batchmax">batchmax</code></td>
<td>
<p>Number of points that can evaluated simultaneously.
If 1, points are passed to 'fn' as a vector of length two.
If greater than 1, points are passed to 'fn' as rows of a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of size 'length(x)' by 'length(y)'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eval_over_grid_with_batch(c(0,.5,1), c(10,20,30), function(a)a[1]+a[2], batchmax=1)
eval_over_grid_with_batch(c(0,.5,1), c(10,20,30), function(a)a[,1]+a[,2], batchmax=Inf)
</code></pre>

<hr>
<h2 id='gcf'>Make contour plot from data or function using ggplot2</h2><span id='topic+gcf'></span>

<h3>Description</h3>

<p>Simpler function for making contours with cf package.
Won't give argument completion, so all must be specified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcf(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcf_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to cf_func or cf_data based on 
data type of first argument. If D is given as argument, then it
is passed to cf_highdim.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Whatever is returned from other function, probably nothing.
Will be a ggplot2 object if using gg=TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gcf(function(x){x[1]^2 - x[2]})
x &lt;- runif(20)
y &lt;- runif(20)
z &lt;- exp(-(x-.5)^2-5*(y-.5)^2)# + rnorm(20,0,.05)
gcf(x,y,z)
gcf(function(x){x[1]^2 - x[2]}, D=3)
</code></pre>

<hr>
<h2 id='gcf_data'>Contour plot from data</h2><span id='topic+gcf_data'></span>

<h3>Description</h3>

<p>Makes filled contour plot from data without sidebar by interpolating 
with a Gaussian process model.
This is the same as 'cf_data' except it will use ggplot2 to
make the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcf_data(x, y = NULL, z = NULL, xlim = NULL, ylim = NULL,
  xylim = NULL, fit = "", gg = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcf_data_+3A_x">x</code></td>
<td>
<p>either just x data, x and y data, or x, y and z data</p>
</td></tr>
<tr><td><code id="gcf_data_+3A_y">y</code></td>
<td>
<p>either y data, z data, or null</p>
</td></tr>
<tr><td><code id="gcf_data_+3A_z">z</code></td>
<td>
<p>either z data or null</p>
</td></tr>
<tr><td><code id="gcf_data_+3A_xlim">xlim</code></td>
<td>
<p>x limits for the contour plot, will be set to data limits +- 5% if not specified</p>
</td></tr>
<tr><td><code id="gcf_data_+3A_ylim">ylim</code></td>
<td>
<p>y limits for the contour plot, will be set to data limits +- 5% if not specified</p>
</td></tr>
<tr><td><code id="gcf_data_+3A_xylim">xylim</code></td>
<td>
<p>x and y limits for the contour plot</p>
</td></tr>
<tr><td><code id="gcf_data_+3A_fit">fit</code></td>
<td>
<p>Method to fit a model with. Current options are laGP (default)
and mlegp. laGP is faster but might cause trouble.</p>
</td></tr>
<tr><td><code id="gcf_data_+3A_gg">gg</code></td>
<td>
<p>If FALSE, will use base graphics by calling cf_func()</p>
</td></tr>
<tr><td><code id="gcf_data_+3A_...">...</code></td>
<td>
<p>passed to cf_func</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
y &lt;- runif(20)
z &lt;- exp(-(x-.5)^2-5*(y-.5)^2)
gcf_data(x,y,z)
</code></pre>

<hr>
<h2 id='gcf_func'>Makes filled contour plot from function</h2><span id='topic+gcf_func'></span>

<h3>Description</h3>

<p>A contour plot of the given function without sidebar by default.
It calls the function 'cf_grid' to make the actual plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcf_func(fn0, n = 100, xlim = c(0, 1), ylim = c(0, 1),
  xylim = NULL, batchmax = 1, out.col.name = NULL, out.name = NULL,
  pts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcf_func_+3A_fn0">fn0</code></td>
<td>
<p>function to plot, first argument must be two-dimensional</p>
</td></tr>
<tr><td><code id="gcf_func_+3A_n">n</code></td>
<td>
<p>number of points in each dimension</p>
</td></tr>
<tr><td><code id="gcf_func_+3A_xlim">xlim</code></td>
<td>
<p>x limits for the contour plot</p>
</td></tr>
<tr><td><code id="gcf_func_+3A_ylim">ylim</code></td>
<td>
<p>y limits for the contour plot</p>
</td></tr>
<tr><td><code id="gcf_func_+3A_xylim">xylim</code></td>
<td>
<p>x and y limits for the contour plot, use when both are same
#@param mainminmax  whether the min and max values should be shown in the title of plot</p>
</td></tr>
<tr><td><code id="gcf_func_+3A_batchmax">batchmax</code></td>
<td>
<p>number of datapoints that can be computed at a time</p>
</td></tr>
<tr><td><code id="gcf_func_+3A_out.col.name">out.col.name</code></td>
<td>
<p>if a column needs to be selected from the function, specify it</p>
</td></tr>
<tr><td><code id="gcf_func_+3A_out.name">out.name</code></td>
<td>
<p>Selects with a $ the name from output to be used, for lists and data frames
#@param pretitle Text to be preappended to end of plot title
#@param posttitle Text to be appended to end of plot title
#@param title Title for the plot
#@param mainminmax_minmax Whether [min,max]= should be shown in title or just the numbers</p>
</td></tr>
<tr><td><code id="gcf_func_+3A_pts">pts</code></td>
<td>
<p>Points to plot on top of contour</p>
</td></tr>
<tr><td><code id="gcf_func_+3A_...">...</code></td>
<td>
<p>Passed to cf_grid</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>gcf_func(function(x){x[1]*x[2]})
gcf_func(function(x)(exp(-(x[1]-.5)^2-5*(x[2]-.5)^2)))
gcf_func(function(xx){exp(-sum((xx-.5)^2/.1))}, bar=TRUE, color.palette=terrain.colors)
gcf_func(function(xx){exp(-sum((xx-.5)^2/.1))}, bar=TRUE, mainminmax=TRUE)
gcf_func(function(x)(exp(-(x[1]-.5)^2-5*(x[2]-.5)^2)))
</code></pre>

<hr>
<h2 id='gcf_grid'>Create contour plot from grid data using ggplot2</h2><span id='topic+gcf_grid'></span>

<h3>Description</h3>

<p>The same as cf_grid_screen but uses ggplot2 for the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcf_grid(x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, length.out
  = ncol(z)), z, xlim = range(x, finite = TRUE), ylim = range(y, finite
  = TRUE), zlim = range(z, finite = TRUE), with_lines = FALSE,
  lines_only = FALSE, bins = 8, interpolate = TRUE,
  levels = pretty(zlim, nlevels), nlevels = 20,
  color.palette = cm.colors.strong, col = color.palette(length(levels)
  - 1), asp = NA, las = 1, bar = F, pts = NULL, reset.par = TRUE,
  pretitle = "", posttitle = "", main = NULL, mainminmax = !bar,
  mainminmax_minmax = TRUE, afterplotfunc = NULL,
  cex.main = par()$cex.main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcf_grid_+3A_x">x</code></td>
<td>
<p>x values, must form grid with y.
If not given, it is assumed to be from 0 to 1.</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_y">y</code></td>
<td>
<p>y values, must form grid with x.
If not given, it is assumed to be from 0 to 1.</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_z">z</code></td>
<td>
<p>z values at grid locations</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_xlim">xlim</code></td>
<td>
<p>x limits for the plot.</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_ylim">ylim</code></td>
<td>
<p>y limits for the plot.</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_zlim">zlim</code></td>
<td>
<p>z limits for the plot.</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_with_lines">with_lines</code></td>
<td>
<p>Should lines be added on top of 
contour to show contours?</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_lines_only">lines_only</code></td>
<td>
<p>Should no fill be used, only contour lines?</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_bins">bins</code></td>
<td>
<p>Number of lines used when using 'with_lines' or 'lines_only'</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_interpolate">interpolate</code></td>
<td>
<p>Will smooth out contours</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_levels">levels</code></td>
<td>
<p>a set of levels which are used to partition the range of z.
Must be strictly increasing (and finite). Areas with z values between
consecutive levels are painted with the same color.</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_nlevels">nlevels</code></td>
<td>
<p>if levels is not specified, the range of z, values is
divided into approximately this many levels.</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_color.palette">color.palette</code></td>
<td>
<p>a color palette function to be used to assign colors
in the plot. Defaults to cm.colors. Other options include rainbow,
heat.colors, terrain.colors, topo.colors, and function(x) gray((1:x)/x).</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_col">col</code></td>
<td>
<p>an explicit set of colors to be used in the plot. This argument
overrides any palette function specification. There should be one less
color than levels</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_asp">asp</code></td>
<td>
<p>the y/x aspect ratio, see plot.window.</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_las">las</code></td>
<td>
<p>the style of labeling to be used. The default is to use
horizontal labeling.</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_bar">bar</code></td>
<td>
<p>Should a bar showing the output range and colors be shown on the right?</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_pts">pts</code></td>
<td>
<p>Points to plot on top of contour</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_reset.par">reset.par</code></td>
<td>
<p>Should the graphical parameters be reset before exiting?
Usually should be unless you need to add something to the plot
afterwards and bar is TRUE.</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_pretitle">pretitle</code></td>
<td>
<p>Text to be preappended to end of plot title</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_posttitle">posttitle</code></td>
<td>
<p>Text to be appended to end of plot title</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_main">main</code></td>
<td>
<p>Title for the plot</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_mainminmax">mainminmax</code></td>
<td>
<p>whether the min and max values should be shown
in the title of plot</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_mainminmax_minmax">mainminmax_minmax</code></td>
<td>
<p>Whether [min,max]= should be shown in title
or just the numbers</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_afterplotfunc">afterplotfunc</code></td>
<td>
<p>Function to call after plotting, such as adding
points or lines.</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_cex.main">cex.main</code></td>
<td>
<p>The size of the main title. 1.2 is default.</p>
</td></tr>
<tr><td><code id="gcf_grid_+3A_...">...</code></td>
<td>
<p>additional graphical parameters, currently only passed to title().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- y &lt;- seq(-4*pi, 4*pi, len = 27)
r &lt;- sqrt(outer(x^2, y^2, "+"))
gcf_grid(cos(r^2)*exp(-r/(2*pi)))
gcf_grid(r, color.palette=heat.colors, bar=TRUE)
gcf_grid(r, color.palette=function(x) {gray((1:x)/x)}, bar=TRUE)
</code></pre>

<hr>
<h2 id='multicolor.title'>Makes plot title using specified colors for the text</h2><span id='topic+multicolor.title'></span>

<h3>Description</h3>

<p>Makes plot title using specified colors for the text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multicolor.title(main, col.main, collapse = "",
  cex.main = par()$cex.main)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multicolor.title_+3A_main">main</code></td>
<td>
<p>Text to put in main title of plot</p>
</td></tr>
<tr><td><code id="multicolor.title_+3A_col.main">col.main</code></td>
<td>
<p>Colors to use for the text</p>
</td></tr>
<tr><td><code id="multicolor.title_+3A_collapse">collapse</code></td>
<td>
<p>What to put between elements of main, defaults to &quot;&quot; but &quot; &quot; might be appropriate</p>
</td></tr>
<tr><td><code id="multicolor.title_+3A_cex.main">cex.main</code></td>
<td>
<p>The size of the main title. 1.2 is default.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plot(1:4)
multicolor.title(c('Black, ','red, ','green'),c(1,2,3))
</code></pre>

<hr>
<h2 id='text_plot'>Make a plot with only text</h2><span id='topic+text_plot'></span>

<h3>Description</h3>

<p>Make a plot with only text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_plot(p, x = 0.5, y = 0.5, cex = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_plot_+3A_p">p</code></td>
<td>
<p>Text to put on a plot</p>
</td></tr>
<tr><td><code id="text_plot_+3A_x">x</code></td>
<td>
<p>x-value of center of text, defaults to center</p>
</td></tr>
<tr><td><code id="text_plot_+3A_y">y</code></td>
<td>
<p>y-value of center of text, defaults to center</p>
</td></tr>
<tr><td><code id="text_plot_+3A_cex">cex</code></td>
<td>
<p>Size of text</p>
</td></tr>
<tr><td><code id="text_plot_+3A_...">...</code></td>
<td>
<p>Arguments passed to plot</p>
</td></tr>
</table>


<h3>References</h3>

<p>ZNK's answer on https://stackoverflow.com/questions/19918985/r-plot-only-text, retrieved 5/25/2018
</p>


<h3>Examples</h3>

<pre><code class='language-R'>text_plot("Useful?", cex=5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
