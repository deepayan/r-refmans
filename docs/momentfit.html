<!DOCTYPE html><html><head><title>Help for package momentfit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {momentfit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[-methods'><p>Subsetting methods</p></a></li>
<li><a href='#allNLModel-class'><p>Class <code>"allNLModel"</code></p></a></li>
<li><a href='#bread-methods'><p> ~~ Methods for Function <code>bread</code> in Package <span class="pkg">sandwich</span> ~~</p></a></li>
<li><a href='#CigarettesSW'><p>Cigarette Consumption Panel Data</p></a></li>
<li><a href='#coef-methods'><p> ~~ Methods for Function <code>coef</code> in Package <span class="pkg">stats</span> ~~</p></a></li>
<li><a href='#confint-class'><p>Class <code>"confint"</code></p></a></li>
<li><a href='#confint-methods'><p> ~~ Methods for Function <code>confint</code> in Package <span class="pkg">stats</span> ~~</p></a></li>
<li><a href='#ConsumptionG'>
<p>Consumption data from Greene (2012) applications.</p></a></li>
<li><a href='#Dresiduals-methods'><p> ~~ Methods for Function <code>Dresiduals</code> in Package <span class="pkg">Gmm</span> ~~</p></a></li>
<li><a href='#DWH-methods'><p> ~~ Methods for Function <code>DWH</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#estfun-methods'><p> ~~ Methods for Function <code>estfun</code> in Package <span class="pkg">sandwich</span> ~~</p></a></li>
<li><a href='#evalDMoment-methods'><p> ~~ Methods for Function <code>evalDMoment</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#evalGel-methods'><p> ~~ Methods for Function <code>evalGel</code> in Package <span class="pkg">modelfit</span> ~~</p></a></li>
<li><a href='#evalGelObj-methods'><p> ~~ Methods for Function <code>evalGelObj</code> in Package <span class="pkg">Gmm</span> ~~</p></a></li>
<li><a href='#evalGmm-methods'><p> ~~ Methods for Function <code>evalGmm</code> in Package <span class="pkg">modelfit</span> ~~</p></a></li>
<li><a href='#evalGmmObj-methods'><p> ~~ Methods for Function <code>evalGmmObj</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#evalMoment-methods'><p> ~~ Methods for Function <code>evalMoment</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#evalWeights-methods'><p>Methods for Function <code>evalWeights</code> in Package <span class="pkg">Gmm</span></p></a></li>
<li><a href='#formulaModel-class'><p>Class <code>"formulaModel"</code></p></a></li>
<li><a href='#functionModel-class'><p>Class <code>"functionModel"</code></p></a></li>
<li><a href='#gel4'><p>GEL estimation</p></a></li>
<li><a href='#gelfit-class'><p>Class <code>"gelfit"</code></p></a></li>
<li><a href='#gelFit-methods'><p> ~~ Methods for Function <code>gelFit</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#getImpProb-methods'><p> ~~ Methods for Function <code>getImpProb</code> in Package <span class="pkg">momenfit</span> ~~</p></a></li>
<li><a href='#getRestrict-methods'><p> ~~ Methods for Function <code>getRestrict</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#gmm4'><p>GMM estimation</p></a></li>
<li><a href='#gmmfit-class'><p>Class <code>"gmmfit"</code></p></a></li>
<li><a href='#gmmFit-methods'><p> ~~ Methods for Function <code>gmmFit</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#Griliches'><p>Return to Education Data</p></a></li>
<li><a href='#HealthRWM'>
<p>Health data from Greene (2012) applications.</p></a></li>
<li><a href='#hypothesisTest-class'><p>Class <code>"hypothesisTest"</code></p></a></li>
<li><a href='#hypothesisTest-methods'><p> ~~ Methods for Function <code>hypothesisTest</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#kernapply-methods'><p>A kernel smoothing utility for <code>"momentModel"</code> classes</p></a></li>
<li><a href='#Klein'>
<p>Klein (1950) macro data.</p></a></li>
<li><a href='#LabourCR'>
<p>Labour data from Greene (2012) applications,</p></a></li>
<li><a href='#lambdaAlgo'><p>Algorithms to solve for the Lagrange multiplier</p></a></li>
<li><a href='#linearModel-class'><p>Class <code>"linearModel"</code></p></a></li>
<li><a href='#ManufactCost'>
<p>Manufacturing Costs data from Bernt and Wood (1975)</p></a></li>
<li><a href='#mconfint-class'><p>Class <code>"mconfint"</code></p></a></li>
<li><a href='#meatGmm-methods'><p> ~~ Methods for Function <code>meatGmm</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#merge-methods'><p> ~~ Methods for Function <code>merge</code> in Package <span class="pkg">base</span> ~~</p></a></li>
<li><a href='#model.matrix-methods'><p> ~~ Methods for Function <code>model.matrix</code> in Package <span class="pkg">stats</span> ~~</p></a></li>
<li><a href='#modelDims-methods'><p>Methods for Function <code>modelDims</code></p></a></li>
<li><a href='#modelResponse-methods'><p> ~~ Methods for Function <code>modelResponse</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#momentModel'><p>Constructor for <code>"momentModel"</code> classes</p></a></li>
<li><a href='#momentModel-class'><p>Class <code>"momentModel"</code></p></a></li>
<li><a href='#momentStrength-methods'><p> ~~ Methods for Function <code>momentStrength</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#momentWeights-class'><p>Class <code>"momentWeights"</code></p></a></li>
<li><a href='#momFct-methods'><p>Methods for Function <code>momFct</code> in Package <span class="pkg">momentfit</span></p></a></li>
<li><a href='#Mroz'>
<p>Labour data on married women</p></a></li>
<li><a href='#nonlinearModel-class'><p>Class <code>"nonlinearModel"</code></p></a></li>
<li><a href='#plot-methods'><p> ~~ Methods for Function <code>plot</code> from package <span class="pkg">graphics</span> ~~</p></a></li>
<li><a href='#print-methods'><p> Methods for Function <code>print</code> in Package <span class="pkg">base</span></p></a></li>
<li><a href='#printRestrict-methods'><p> ~~ Methods for Function <code>printRestrict</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#quadra-methods'><p> ~~ Methods for Function <code>quadra</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#regModel-class'><p>Class <code>"regModel"</code></p></a></li>
<li><a href='#residuals-methods'><p> ~~ Methods for Function <code>residuals</code> in Package <span class="pkg">stats</span> ~~</p></a></li>
<li><a href='#restModel-methods'><p> ~~ Methods for Function <code>restModel</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#rformulaModel-class'><p>Class <code>"rformulaModel"</code></p></a></li>
<li><a href='#rfunctionModel-class'><p>Class <code>"rfunctionModel"</code></p></a></li>
<li><a href='#rhoFct'><p>GEL objective functions</p></a></li>
<li><a href='#rlinearModel-class'><p>Class <code>"rlinearModel"</code></p></a></li>
<li><a href='#rmomentModel-class'><p>Class <code>"rmomentModel"</code></p></a></li>
<li><a href='#rnonlinearModel-class'><p>Class <code>"rnonlinearModel"</code></p></a></li>
<li><a href='#rslinearModel-class'><p>Class <code>"rslinearModel"</code></p></a></li>
<li><a href='#rsnonlinearModel-class'><p>Class <code>"rsnonlinearModel"</code></p></a></li>
<li><a href='#rsysModel-class'><p>Class <code>"rsysModel"</code></p></a></li>
<li><a href='#setCoef-methods'><p>Methods for Function <code>setCoef</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#sfunctionModel-class'><p>Class <code>"sfunctionModel"</code></p></a></li>
<li><a href='#sgmmfit-class'><p>Class <code>"sgmmfit"</code></p></a></li>
<li><a href='#show-methods'><p> ~~ Methods for Function <code>show</code> in Package <span class="pkg">methods</span> ~~</p></a></li>
<li><a href='#simData'>
<p>Simulated data.</p></a></li>
<li><a href='#slinearModel-class'><p>Class <code>"slinearModel"</code></p></a></li>
<li><a href='#snonlinearModel-class'><p>Class <code>"snonlinearModel"</code></p></a></li>
<li><a href='#solveGel-methods'><p> ~~ Methods for Function <code>solveGel</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#solveGmm-methods'><p> ~~ Methods for Function <code>solveGmm</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#specTest-class'><p>Class <code>"specTest"</code></p></a></li>
<li><a href='#specTest-methods'><p> ~~ Methods for Function <code>specTest</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#sSpec-class'><p>Class <code>"sSpec"</code></p></a></li>
<li><a href='#stsls-class'><p>Class <code>"stsls"</code></p></a></li>
<li><a href='#summary-methods'><p> ~~ Methods for Function <code>summary</code> in Package <span class="pkg">base</span> ~~</p></a></li>
<li><a href='#summaryGel-class'><p>Class <code>"summaryGel"</code></p></a></li>
<li><a href='#summaryGmm-class'><p>Class <code>"summaryGmm"</code></p></a></li>
<li><a href='#summarySysGmm-class'><p>Class <code>"summarySysGmm"</code></p></a></li>
<li><a href='#sysModel-class'><p>Class <code>"sysModel"</code></p></a></li>
<li><a href='#sysMomentModel'><p>Constructor for <code>"sysMomentModel"</code> classes</p></a></li>
<li><a href='#sysMomentWeights-class'><p>Class <code>"sysMomentWeights"</code></p></a></li>
<li><a href='#systemGmm-doc'><p>A guide to estimating systems of equations</p></a></li>
<li><a href='#ThreeSLS-methods'><p> ~~ Methods for Function <code>ThreeSLS</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#tsls-class'><p>Class <code>"tsls"</code></p></a></li>
<li><a href='#tsls-methods'><p> ~~ Methods for Function <code>tsls</code> in Package <span class="pkg">momentfit</span> ~~</p></a></li>
<li><a href='#update-methods'><p> ~~ Methods for Function <code>update</code> in Package <span class="pkg">stats</span> ~~</p></a></li>
<li><a href='#vcov-methods'><p> ~~ Methods for Function <code>vcov</code> in Package <span class="pkg">stats</span> ~~</p></a></li>
<li><a href='#vcovHAC-methods'><p> ~~ Methods for Function <code>vcovHAC</code> in Package <span class="pkg">sandwich</span> ~~</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods of Moments</td>
</tr>
<tr>
<td>Author:</td>
<td>Pierre Chausse &lt;pchausse@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierre Chausse &lt;pchausse@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Several classes for moment-based models are defined. The classes are defined for moment conditions derived from a single equation or a system of equations. The conditions can also be expressed as functions or formulas. Several methods are also offered to facilitate the development of different estimation techniques. The methods that are currently provided are the Generalized method of moments (Hansen 1982; &lt;<a href="https://doi.org/10.2307%2F1912775">doi:10.2307/1912775</a>&gt;), for single equations and systems of equation, and  the Generalized Empirical Likelihood (Smith 1997; &lt;<a href="https://doi.org/10.1111%2Fj.0013-0133.1997.174.x">doi:10.1111/j.0013-0133.1997.174.x</a>&gt;, Kitamura 1997; &lt;<a href="https://doi.org/10.1214%2Faos%2F1069362388">doi:10.1214/aos/1069362388</a>&gt;, Newey and Smith 2004; &lt;<a href="https://doi.org/10.1111%2Fj.1468-0262.2004.00482.x">doi:10.1111/j.1468-0262.2004.00482.x</a>&gt;, and Anatolyev 2005 &lt;<a href="https://doi.org/10.1111%2Fj.1468-0262.2005.00601.x">doi:10.1111/j.1468-0262.2005.00601.x</a>&gt;). </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), sandwich</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lmtest, knitr, texreg</td>
</tr>
<tr>
<td>Collate:</td>
<td>'allClasses.R' 'validity.R' 'momentData.R'
'momentModel-methods.R' 'momentModel.R'
'momentWeights-methods.R' 'gmmfit-methods.R'
'specTest-methods.R' 'summary-methods.R' 'rModel-methods.R'
'hypothesisTest-methods.R' 'sysMomentModel.R'
'sysMomentModel-methods.R' 'rsysMomentModel-methods.R'
'sgmmfit-methods.R' 'gmm4.R' 'gel.R' 'gelfit-methods.R'
'gel4.R'</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-05 14:51:08 UTC; pierrechausse</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-05 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B-methods'>Subsetting methods</h2><span id='topic++5B-methods'></span><span id='topic+subset'></span><span id='topic+subset+2CregModel-method'></span><span id='topic+subset+2CfunctionModel-method'></span><span id='topic+subset+2CformulaModel-method'></span><span id='topic+subset+2CsysModel-method'></span><span id='topic++5B+2CmomentWeights+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CmomentWeights+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CsysMomentWeights+2Cnumeric+2Clist-method'></span><span id='topic++5B+2CsysMomentWeights+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CsysMomentWeights+2Cmissing+2Clist-method'></span><span id='topic++5B+2CmomentModel+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CregModel+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CfunctionModel+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CformulaModel+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CrfunctionModel+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CsysModel+2Cmissing+2Clist-method'></span><span id='topic++5B+2CsnonlinearModel+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CsfunctionModel+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CslinearModel+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CrsnonlinearModel+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CrslinearModel+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CsysModel+2Cnumeric+2Clist-method'></span><span id='topic++5B+2CsysModel+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Different subsetting methods for S4 class objects of the package. The
subset method returns an new object with observations selected by the
second argument. See example.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "momentWeights", i = "integer", j = "missing")</code></dt><dd>
<p>It creates a partition from the weighting matrix. 
</p>
</dd>
<dt><code>signature(x = "momentWeights", i = "missing", j = "missing")</code></dt><dd>  
<p>It generates the whole weighting matrix. 
</p>
</dd>
<dt><code>signature(x = "sysMomentWeights", i = "missing", j = "list")</code></dt><dd>
<p>It creates a partition from the weighting matrix. j has no effect
here.  It creates a partition from the weighting matrix in a systemof  
equations. i selects the equation and the list j the moments in each
equation. Missing i means all equations.
</p>
</dd>
<dt><code>signature(x = "sysMomentWeights", i = "numeric", j =
    "missing")</code></dt><dd>
<p>It creates a partition from the weighting matrix. j has no effect
here.  It creates a partition from the weighting matrix in a systemof  
equations. i selects the equation and the list j the moments in each
equation. Missing j means all moments.
</p>
</dd>
<dt><code>signature(x = "sysMomentWeights", i = "missing", j = "missing")</code></dt><dd>
<p>No effect. It returns x.
</p>
</dd>
<dt><code>signature(x = "snonlinearModel", i = "numeric", j="missing")</code></dt><dd>
<p>It generates a system of equations with a subset of equations selected
by i. If the number of remaining equations is one, it returns an
object of class <code>"nonlinearGmm"</code>.
</p>
</dd>
<dt><code>signature(x = "slinearModel", i = "numeric", j="missing")</code></dt><dd>
<p>It generates a system of equations with a subset of equations selected
by i. If the number of remaining equations is one, it returns an
object of class <code>"linearModel"</code>.
</p>
</dd>
<dt><code>signature(x = "rslinearModel", i = "numeric", j="missing")</code></dt><dd>
<p>It is only use to select one equation when no cross-equation
restrictions are imposed. Only one equation can be selected. 
</p>
</dd>
<dt><code>signature(x = "rsnonlinearModel", i = "numeric", j="missing")</code></dt><dd>
<p>It is only use to select one equation when no cross-equation
restrictions are imposed. Only one equation can be selected. 
</p>
</dd>
<dt><code>signature(x = "sysMomentModel", i = "numeric", j="list")</code></dt><dd>
<p>It generates a system of equations with a subset of equations selected
by i and a subset of moment conditions selected by j. If the number of
remaining equations is one, it returns an object of class <code>"linearGmm"</code>.
</p>
</dd>
<dt><code>signature(x = "sysMomentModel", i = "missing", j="missing")</code></dt><dd>
<p>No effect. It returns x.
</p>
</dd>
<dt><code>signature(x = "momentModel", i = "missing", j = "missing")</code></dt><dd>
<p>Returns the model without any change.
</p>
</dd>
<dt><code>signature(x = "functionModel", i = "numeric", j = "missing")</code></dt><dd>
<p>It generates the same model with a subset of the moment conditions.
</p>
</dd>
<dt><code>signature(x = "formulaModel", i = "numeric", j = "missing")</code></dt><dd>
<p>It generates the same model with a subset of the moment conditions.
</p>
</dd>
<dt><code>signature(x = "rfuncionModel", i = "numeric", j = "missing")</code></dt><dd>
<p>It generates the same model with a subset of the moment conditions. j
has no effect here.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
model1 &lt;- momentModel(y~x1+x2, ~x2+x3+z1+z2+z3, data=simData, vcov="MDS")
w &lt;- evalWeights(model1, theta=1:3)
w[]
w[1:3]

## A model with a subset of the instruments
model1[1:4]

## Selecting the observations:

subset(model1, simData[["x1"]]&lt;3)
subset(model1, 1:25)

</code></pre>

<hr>
<h2 id='allNLModel-class'>Class <code>"allNLModel"</code></h2><span id='topic+allNLModel-class'></span>

<h3>Description</h3>

<p>A union class for all nonlinear models. It includes
<code>"nonlinearModel"</code>, <code>"formulaModel"</code>, and
<code>"functionModel"</code>. 
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>solveGmm</dt><dd><p><code>signature(object = "allNLModel", wObj = "momentWeights")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("allNLModel")
</code></pre>

<hr>
<h2 id='bread-methods'> ~~ Methods for Function <code>bread</code> in Package <span class="pkg">sandwich</span> ~~</h2><span id='topic+bread'></span><span id='topic+bread-methods'></span><span id='topic+bread+2Cgmmfit-method'></span><span id='topic+bread+2Csgmmfit-method'></span><span id='topic+bread+2Ctsls-method'></span>

<h3>Description</h3>

<p>It computes the bread in the sandwich representation of the covariance
matrix of the GMM estimator.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gmmfit'
bread(x, ...)

## S4 method for signature 'sgmmfit'
bread(x, ...)

## S4 method for signature 'tsls'
bread(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bread-methods_+3A_x">x</code></td>
<td>
<p>GMM fit object</p>
</td></tr>
<tr><td><code id="bread-methods_+3A_...">...</code></td>
<td>
<p>Arguments to pass to other methods</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "gmmfit")</code></dt><dd>
</dd>
<dt><code>signature(x = "sgmmfit")</code></dt><dd>
</dd>
<dt><code>signature(x = "tsls")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

res &lt;- gmmFit(model1)
m &lt;- meatGmm(res)
b &lt;- bread(res)

## Sandwich vcov
b

## TSLS
model2 &lt;- momentModel(y~x1, ~z1+z2, data=simData, vcov="iid")
res &lt;- tsls(model2)
bread(res)


</code></pre>

<hr>
<h2 id='CigarettesSW'>Cigarette Consumption Panel Data</h2><span id='topic+CigarettesSW'></span>

<h3>Description</h3>

<p>Panel data on cigarette consumption for the 48 continental US States from 1985&ndash;1995.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("CigarettesSW")</code></pre>


<h3>Format</h3>

<p>A data frame containing 48 observations on 7 variables for 2 periods. 
</p>

<dl>
<dt>state</dt><dd><p>Factor indicating state.</p>
</dd>
<dt>year</dt><dd><p>Factor indicating year.</p>
</dd>
<dt>cpi</dt><dd><p>Consumer price index.</p>
</dd>
<dt>population</dt><dd><p>State population.</p>
</dd>
<dt>packs</dt><dd><p>Number of packs per capita.</p>
</dd>
<dt>income</dt><dd><p>State personal income (total, nominal).</p>
</dd>
<dt>tax</dt><dd><p>Average state, federal and average local excise taxes for fiscal year.</p>
</dd>
<dt>price</dt><dd><p>Average price during fiscal year, including sales tax.</p>
</dd>
<dt>taxs</dt><dd><p>Average excise taxes for fiscal year, including sales tax.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Online complements to Stock and Watson (2007). The dataset and this help file comes from
the AER package.
</p>


<h3>References</h3>

<p>Stock, J.H. and Watson, M.W. (2007). <em>Introduction to Econometrics</em>,
2nd ed. Boston: Addison Wesley.
</p>
<p>Christian Kleiber and Achim Zeileis (2008). Applied Econometrics with
R. New York: Springer-Verlag. ISBN 978-0-387-77316-2. URL
https://CRAN.R-project.org/package=AER
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Stock and Watson (2007)
## data and transformations
data(CigarettesSW)
CigarettesSW$rprice &lt;- with(CigarettesSW, price/cpi)
CigarettesSW$rincome &lt;- with(CigarettesSW, income/population/cpi)
CigarettesSW$tdiff &lt;- with(CigarettesSW, (taxs - tax)/cpi)
c1985 &lt;- subset(CigarettesSW, year == "1985")
c1995 &lt;- subset(CigarettesSW, year == "1995")

## Equation 12.15
model1 &lt;- momentModel(log(packs)~log(rprice)+log(rincome),
                   ~log(rincome)+tdiff, data = c1995, vcov="MDS")
res1 &lt;- gmmFit(model1)

## HC0 robust se (different from the textbook)
summary(res1, sandwich=TRUE)

## HC1 robust se (like in the textbook)
## A little harder to get, but is it really worth it
## in the case of GMM?

summary(res1, sandwich=TRUE, df.adj=TRUE)@coef

## Equation 12.16
model2&lt;- momentModel(log(packs)~log(rprice)+log(rincome),
                  ~log(rincome)+tdiff+I(tax/cpi), data = c1995,
                  centeredVcov=FALSE, vcov="MDS")
res2&lt;- tsls(model2)
summary(res2, sandwich=TRUE, df.adj=TRUE)

## Table 12.1
data &lt;- data.frame(dQ=log(c1995$pack/c1985$pack),
                   dP=log(c1995$rprice/c1985$rprice),
                   dTs=c1995$tdiff-c1985$tdiff,
                   dT=c1995$tax/c1995$cpi-c1985$tax/c1985$cpi,
                   dInc=log(c1995$rincome/c1985$rincome))
model1 &lt;- momentModel(dQ~dP+dInc, ~dInc+dTs, vcov="MDS", data=data)
model2 &lt;- momentModel(dQ~dP+dInc, ~dInc+dT, vcov="MDS", data=data)
model3 &lt;- momentModel(dQ~dP+dInc, ~dInc+dTs+dT, vcov="MDS", data=data)

res1 &lt;- tsls(model1)
summary(res1, TRUE, TRUE)
res2 &lt;- tsls(model2)
summary(res2, TRUE, TRUE)
res3 &lt;- tsls(model3)
summary(res3, TRUE, TRUE)
</code></pre>

<hr>
<h2 id='coef-methods'> ~~ Methods for Function <code>coef</code> in Package <span class="pkg">stats</span> ~~</h2><span id='topic+coef-methods'></span><span id='topic+coef+2Cgmmfit-method'></span><span id='topic+coef+2Cgelfit-method'></span><span id='topic+coef+2Csgmmfit-method'></span><span id='topic+coef+2CrlinearModel-method'></span><span id='topic+coef+2CrslinearModel-method'></span><span id='topic+coef+2CrsnonlinearModel-method'></span><span id='topic+coef+2CrfunctionModel-method'></span><span id='topic+coef+2CrformulaModel-method'></span><span id='topic+coef+2CmomentModel-method'></span><span id='topic+coef+2CrnonlinearModel-method'></span>

<h3>Description</h3>

<p>It extract the coefficient estimates of some moment-based models.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "gmmfit")</code></dt><dd>
</dd>
<dt><code>signature(object = "gelfit")</code></dt><dd>
</dd>
<dt><code>signature(object = "sgmmfit")</code></dt><dd>
</dd>
<dt><code>signature(object = "momentModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rlinearModel")</code></dt><dd>
<p>It gives the unrestricted representation of a restricted model. See examples.  
</p>
</dd>
<dt><code>signature(object = "rslinearModel")</code></dt><dd>
<p>It gives the unrestricted representation of a restricted model.  
</p>
</dd>
<dt><code>signature(object = "rsnonlinearModel")</code></dt><dd>
<p>It gives the unrestricted representation of a restricted model.  
</p>
</dd>
<dt><code>signature(object = "rfunctionModel")</code></dt><dd>
<p>It gives the unrestricted representation of a restricted model. See examples.  
</p>
</dd>
<dt><code>signature(object = "rformulaModel")</code></dt><dd>
<p>It gives the unrestricted representation of a restricted model. See examples.  
</p>
</dd>
<dt><code>signature(object = "rnonlinearModel")</code></dt><dd>
<p>It gives the unrestricted representation of a restricted nonlinear
model. 
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
model1 &lt;- momentModel(y~x1+x2+x3+z1, ~x1+x2+z1+z2+z3+z4, data=simData)
res1 &lt;- gmmFit(model1)
coef(res1)

### Restricted models
rmodel1 &lt;- restModel(model1, R=c("x1=1", "x2=2*x3"))
res2 &lt;- gmmFit(rmodel1)
res2
coef(rmodel1, coef(res2))
</code></pre>

<hr>
<h2 id='confint-class'>Class <code>"confint"</code></h2><span id='topic+confint-class'></span>

<h3>Description</h3>

<p>A class to store a confidence interval result. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("confint", ...)</code>.
It is generated by the <code>"confint"</code> method (see
<code><a href="#topic+confint-methods">confint-methods</a></code>).
</p>


<h3>Slots</h3>


<dl>
<dt><code>interval</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>level</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>theta</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "confint")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "confint")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("confint")
</code></pre>

<hr>
<h2 id='confint-methods'> ~~ Methods for Function <code>confint</code> in Package <span class="pkg">stats</span> ~~</h2><span id='topic+confint-methods'></span><span id='topic+confint+2CANY-method'></span><span id='topic+confint+2Cgelfit-method'></span><span id='topic+confint+2Cgmmfit-method'></span><span id='topic+confint+2Cnumeric-method'></span><span id='topic+confint+2Cdata.frame-method'></span><span id='topic+confint+2Cmatrix-method'></span><span id='topic+confint+2CANY-method'></span>

<h3>Description</h3>

<p>Method to contruct confidence intervals for objects of class
<code>"gmmfit"</code> and <code>"gelfit"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gmmfit'
confint(object, parm, level = 0.95, vcov=NULL,
                    area=FALSE, npoints=50, ...)

## S4 method for signature 'gelfit'
confint(object, parm, level = 0.95, lambda = FALSE,
                    type = c("Wald", "invLR", "invLM", "invJ"),
                    fact = 3, corr = NULL, vcov=NULL,
                    area = FALSE, npoints = 20, cores=4, ...)

## S4 method for signature 'numeric'
confint(object, parm, level = 0.95, gelType="EL", 
                    type = c("Wald", "invLR", "invLM", "invJ"),
                    fact = 3, vcov="iid") 

## S4 method for signature 'data.frame'
confint(object, parm, level = 0.95, gelType="EL", 
                    type = c("Wald", "invLR", "invLM", "invJ"),
                    fact = 3, vcov="iid", npoints=10, 
                    cores=4) 

## S4 method for signature 'matrix'
confint(object, parm, level = 0.95, gelType="EL", 
                    type = c("Wald", "invLR", "invLM", "invJ"),
                    fact = 3, vcov="iid", npoints=10, 
                    cores=4) 

## S4 method for signature 'ANY'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint-methods_+3A_object">object</code></td>
<td>
<p>Object of class <code>"gmmfit"</code>,
<code>"gelfit"</code>, <code>"numeric"</code> or  <code>"data.frame"</code>.</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_parm">parm</code></td>
<td>
<p>Vector of integers or characters for selecting the
elements for which the intervals should be computed.</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_level">level</code></td>
<td>
<p>The confidence level.</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_lambda">lambda</code></td>
<td>
<p>Should be compute intervals for the Lagrange
multipliers?</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_type">type</code></td>
<td>
<p>The type of confidence intervals. The default is the Wald
interval, and the others are computed by inverting the LR, LM or J
specification test.</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_fact">fact</code></td>
<td>
<p>For the inversion of the specification tests,
<code><a href="stats.html#topic+uniroot">uniroot</a></code> searches within <code>fact</code> standard error of
the coefficient estimates</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_corr">corr</code></td>
<td>
<p>Correction to apply to the specification tests</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_vcov">vcov</code></td>
<td>
<p>For Wald intervals, an optional covariance matrix can be
provided. For <code>"numeric"</code> or <code>"data.frame"</code>, it specifies
the type of observations.</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_cores">cores</code></td>
<td>
<p>The number of cores for <code><a href="parallel.html#topic+mclapply">mclapply</a></code>. It is set
to 1 for Windows OS.</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_geltype">gelType</code></td>
<td>
<p>Type of GEL confidence interval.</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_npoints">npoints</code></td>
<td>
<p>Number of equally spaced points for the confidence
region</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_area">area</code></td>
<td>
<p>If TRUE, a cnnfidence region is computed. The length of
<code>"parm"</code> must be 2 in that case.</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+gmmFit">gmmFit</a></code> or
<code><a href="#topic+gelFit">gelFit</a></code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd>
<p>The method from the <span class="pkg">stats</span> in used in that case.
</p>
</dd>
<dt><code>signature(object = "gelfit")</code></dt><dd>
<p>Method for any GEL fit class.
</p>
</dd>
<dt><code>signature(object = "gmmfit")</code></dt><dd>
<p>Method for any GMM fit class.
</p>
</dd>
<dt><code>signature(object = "numeric")</code></dt><dd>
<p>It computes the GEL confidence interval for the mean.
</p>
</dd>
<dt><code>signature(object = "data.frame")</code></dt><dd>
<p>It computes the 2D GEL confidence region for the means of two
variables.
</p>
</dd>
<dt><code>signature(object = "matrix")</code></dt><dd>
<p>It converts the object into a data.frame and call its method.
</p>
</dd>
</dl>

<hr>
<h2 id='ConsumptionG'>
Consumption data from Greene (2012) applications.
</h2><span id='topic+ConsumptionG'></span>

<h3>Description</h3>

<p>Quarterly macroeconomic US data from 1950 to 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ConsumptionG")</code></pre>


<h3>Format</h3>

<p>A data frame with 204 observations on the following 14 variables.
</p>

<dl>
<dt><code>YEAR</code></dt><dd><p>Year</p>
</dd>
<dt><code>QTR</code></dt><dd><p>Quarter</p>
</dd>
<dt><code>REALGDP</code></dt><dd><p>Read GDP</p>
</dd>
<dt><code>REALCONS</code></dt><dd><p>Real Consumption</p>
</dd>
<dt><code>REALINVS</code></dt><dd><p>Real Investment</p>
</dd>
<dt><code>REALGOVT</code></dt><dd><p>Real public expenditure</p>
</dd>
<dt><code>REALDPI</code></dt><dd><p>ector</p>
</dd>
<dt><code>CPI_U</code></dt><dd><p>CPI</p>
</dd>
<dt><code>M1</code></dt><dd><p>Money stock</p>
</dd>
<dt><code>TBILRATE</code></dt><dd><p>Interest rate</p>
</dd>
<dt><code>UNEMP</code></dt><dd><p>Unemployment rate</p>
</dd>
<dt><code>POP</code></dt><dd><p>Population</p>
</dd>
<dt><code>INFL</code></dt><dd><p>Inflation</p>
</dd>
<dt><code>REALINT</code></dt><dd><p>Real interest rate.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Greene (2012) online resources:
(http://pages.stern.nyu.edu/~wgreene/Text/Edition7/tablelist8new.htm)  
</p>


<h3>References</h3>

<p>Green, W.H.. (2012). <em>Econometric Analysis, 7th edition</em>, Prentice Hall.    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ConsumptionG)
## Get the data ready for Table 8.2 of Greene (2012)
Y &lt;- ConsumptionG$REALDPI
C &lt;- ConsumptionG$REALCONS
n &lt;- nrow(ConsumptionG)
Y1 &lt;- Y[-c(1,n)]; Y2 &lt;- Y[-c(n-1,n)]; Y &lt;- Y[-c(1:2)]
C1 &lt;- C[-c(1,n)]; C &lt;- C[-(1:2)]
dat &lt;- data.frame(Y=Y,Y1=Y1,Y2=Y2,C=C,C1=C1)

## Starting at the NLS estimates (from the table)
theta0=c(alpha=468, beta=0.0971, gamma=1.24)

## Greene (2012) seems to assume iid errors (probably wrong assumption here)
model &lt;- momentModel(C~alpha+beta*Y^gamma, ~C1+Y1+Y2, data=dat, theta0=theta0, vcov="iid")

### Scaling the parameters increase the speed of convergence
res &lt;- gmmFit(model, control=list(parscale=c(1000,.1,1)))

### It also seems that there is a degree of freedom adjustment for the
### estimate of the variance of the error term.
summary(res, df.adj=TRUE)@coef



</code></pre>

<hr>
<h2 id='Dresiduals-methods'> ~~ Methods for Function <code>Dresiduals</code> in Package <span class="pkg">Gmm</span> ~~</h2><span id='topic+Dresiduals'></span><span id='topic+Dresiduals-methods'></span><span id='topic+Dresiduals+2ClinearModel-method'></span><span id='topic+Dresiduals+2CnonlinearModel-method'></span><span id='topic+Dresiduals+2CsysModel-method'></span><span id='topic+Dresiduals+2CrsnonlinearModel-method'></span>

<h3>Description</h3>

<p>It returns the matrix of derivatives of the residuals with respect to
the coefficients.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "linearModel")</code></dt><dd>

</dd>
<dt><code>signature(object = "nonlinearModel")</code></dt><dd>

</dd>
<dt><code>signature(object = "rsnonlinearModel")</code></dt><dd>

</dd>
<dt><code>signature(object = "sysMomentModel")</code></dt><dd>

</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

Dresiduals(model1, theta)[1:3,]
</code></pre>

<hr>
<h2 id='DWH-methods'> ~~ Methods for Function <code>DWH</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+DWH'></span><span id='topic+DWH-methods'></span><span id='topic+DWH+2Cgmmfit+2Clm-method'></span><span id='topic+DWH+2Cgmmfit+2Cmissing-method'></span><span id='topic+DWH+2Cgmmfit+2Cgmmfit-method'></span>

<h3>Description</h3>

<p>It performs the Durbin-Wu-Hausman test on GMM fit models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gmmfit,missing'
DWH(object1, object2)

## S4 method for signature 'gmmfit,lm'
DWH(object1, object2,
tol=sqrt(.Machine$double.eps), v1=NULL, v2=NULL, ...)

## S4 method for signature 'gmmfit,gmmfit'
DWH(object1, object2,
tol=sqrt(.Machine$double.eps), v1=NULL, v2=NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DWH-methods_+3A_object1">object1</code></td>
<td>
<p>Object of class <code>"gmmfit"</code>.</p>
</td></tr>
<tr><td><code id="DWH-methods_+3A_object2">object2</code></td>
<td>
<p>Object of class <code>"gmmfit"</code> or <code>"lm"</code>. If
missing, the DWH test is a two step test in which the fitted
endogenous variables from the first step are added to the
regression. In that case, the test a a test of significance of the
coefficients of the fitted endogenous variables.</p>
</td></tr>
<tr><td><code id="DWH-methods_+3A_v1">v1</code></td>
<td>
<p>Alternatively, we can provide a different covariance
matrix for object1</p>
</td></tr>
<tr><td><code id="DWH-methods_+3A_v2">v2</code></td>
<td>
<p>Alternatively, we can provide a different covariance
matrix for object2</p>
</td></tr>
<tr><td><code id="DWH-methods_+3A_tol">tol</code></td>
<td>
<p>Tolerance for the Moore-Penrose generalized inverse</p>
</td></tr>
<tr><td><code id="DWH-methods_+3A_...">...</code></td>
<td>
<p>Argument to pass to <code><a href="stats.html#topic+vcov">vcov</a></code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object1 = "gmmfit", object2 = "lm")</code></dt><dd>

</dd>
<dt><code>signature(object1 = "gmmfit", object2 = "gmmfit")</code></dt><dd>

</dd>
<dt><code>signature(object1 = "gmmfit", object2 = "missing")</code></dt><dd>

</dd>
</dl>


<h3>References</h3>

<p>Green, W.H.. (2012). <em>Econometric Analysis, 7th edition</em>, Prentice Hall.    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Exampe 8.7 of Greene (2012)
data(ConsumptionG)
Y &lt;- ConsumptionG$REALDPI
C &lt;- ConsumptionG$REALCONS
n &lt;- nrow(ConsumptionG)
Y1 &lt;- Y[-n]; Y &lt;- Y[-1]
C1 &lt;- C[-n]; C &lt;- C[-1]
dat &lt;- data.frame(Y=Y,Y1=Y1,C=C,C1=C1)



model1 &lt;- momentModel(C~Y, ~Y, data=dat, vcov="iid")
model2 &lt;- momentModel(C~Y, ~Y1+C1, data=dat, vcov="iid")
res1 &lt;- tsls(model1)
res2 &lt;- tsls(model2)
res &lt;- lm(C~Y)

## Exampke 8.7-2. The difference is explained by the rounding
## error in Greene. Only the first the 3 digits of the t-test are used.
DWH(res2)

## Example 8.7-1. Not quite the same.
DWH(res2, res1)

## using lm object to compare OLS and 2SLS:
## The same adjustment on the vcov must be done (it is by default in lm)
## otherwise the different in the covariance matrices is mostly caused by the
## different ways to compute them.
DWH(res2, res, df.adj=TRUE)

## To reproduce the same results as Exampke 8.7-1,
## we need to specify the variance.
## But it is not necessary as the above way is
## asymptotically equivalent
X &lt;- model.matrix(model1)
Xhat &lt;- qr.fitted(res2@wObj@w, X)
s2 &lt;- sum(residuals(res)^2)/(res$df.residual)
v1 &lt;-  solve(crossprod(Xhat))*s2
v2 &lt;- solve(crossprod(X))*s2
DWH(res2, res, v1=v1, v2=v2)


</code></pre>

<hr>
<h2 id='estfun-methods'> ~~ Methods for Function <code>estfun</code> in Package <span class="pkg">sandwich</span> ~~</h2><span id='topic+estfun-methods'></span><span id='topic+estfun+2CmomentModel-method'></span>

<h3>Description</h3>

<p>Estimating equations for moment models. 
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "momentModel")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='evalDMoment-methods'> ~~ Methods for Function <code>evalDMoment</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+evalDMoment'></span><span id='topic+evalDMoment-methods'></span><span id='topic+evalDMoment+2CfunctionModel-method'></span><span id='topic+evalDMoment+2CrfunctionModel-method'></span><span id='topic+evalDMoment+2CformulaModel-method'></span><span id='topic+evalDMoment+2CrformulaModel-method'></span><span id='topic+evalDMoment+2CrnonlinearModel-method'></span><span id='topic+evalDMoment+2CsysModel-method'></span><span id='topic+evalDMoment+2CrslinearModel-method'></span><span id='topic+evalDMoment+2CrsnonlinearModel-method'></span><span id='topic+evalDMoment+2CregModel-method'></span>

<h3>Description</h3>

<p>It computes the matrix of derivatives of the sample moments with respect
to the coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'functionModel'
evalDMoment(object, theta, impProb=NULL,
lambda=NULL)

## S4 method for signature 'rfunctionModel'
evalDMoment(object, theta, impProb=NULL,
lambda=NULL)

## S4 method for signature 'rnonlinearModel'
evalDMoment(object, theta, impProb=NULL,
lambda=NULL)

## S4 method for signature 'formulaModel'
evalDMoment(object, theta, impProb=NULL,
lambda=NULL)

## S4 method for signature 'rformulaModel'
evalDMoment(object, theta, impProb=NULL,
lambda=NULL)

## S4 method for signature 'regModel'
evalDMoment(object, theta, impProb=NULL,
lambda=NULL)

## S4 method for signature 'sysModel'
evalDMoment(object, theta)

## S4 method for signature 'rslinearModel'
evalDMoment(object, theta)

## S4 method for signature 'rsnonlinearModel'
evalDMoment(object, theta, impProb=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalDMoment-methods_+3A_object">object</code></td>
<td>
<p>An model object</p>
</td></tr>
<tr><td><code id="evalDMoment-methods_+3A_theta">theta</code></td>
<td>
<p>A numerical vector of coefficients</p>
</td></tr> 
<tr><td><code id="evalDMoment-methods_+3A_impprob">impProb</code></td>
<td>
<p>If a vector of implied probablities is provided, the
sample means are computed using them. If not provided, the means are
computed using the uniform weight</p>
</td></tr>
<tr><td><code id="evalDMoment-methods_+3A_lambda">lambda</code></td>
<td>
<p>A vector of Lagrange multipliers associated with the
moment conditions. Its length must therefore match the number of
conditions. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without the argument <code>lambda</code>, the method returns a <code class="reqn">q \times
  k</code> matrix, where <code class="reqn">k</code> is the number of coefficients, and <code class="reqn">q</code> is
the number of moment conditions. That matrix is the derivative of the
sample mean of the moments with respect to the coefficient. 
</p>
<p>If <code>lambda</code> is provided, the method returns an <code class="reqn">n \times k</code>
matrix, where <code class="reqn">n</code> is the sample size. The ith row is
<code class="reqn">G_i'\lambda</code>, where $G_i$ is the derivative of the moment
function evaluated at the ith observation. For now, this option is
used to compute robust-to-misspecified standard errors of GEL
estimators.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "functionModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rfunctionModel")</code></dt><dd>
<p>The theta vector must match the number of coefficients in the restricted
model.
</p>
</dd>
<dt><code>signature(object = "formulaModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rformulaModel")</code></dt><dd>
<p>The theta vector must match the number of coefficients in the restricted
model.
</p>
</dd>
<dt><code>signature(object = "regModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "sysModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rslinearModel")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(1,1)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)
G &lt;- evalDMoment(model1, theta)

## A nonlinearModel
g &lt;- y~beta0+x1^beta1
h &lt;- ~z1+z2
model2 &lt;- momentModel(g, h, c(beta0=1, beta1=2), data=simData)
G &lt;- evalDMoment(model2, c(beta0=1, beta1=2))

## A functionModel
fct &lt;- function(tet, x)
    {
        m1 &lt;- (tet[1] - x)
        m2 &lt;- (tet[2]^2 - (x - tet[1])^2)
        m3 &lt;- x^3 - tet[1]*(tet[1]^2 + 3*tet[2]^2)
        f &lt;- cbind(m1, m2, m3)
        return(f)
    }
dfct &lt;- function(tet, x)
        {
        jacobian &lt;- matrix(c( 1, 2*(-tet[1]+mean(x)), -3*tet[1]^2-3*tet[2]^2,0, 2*tet[2],
			   -6*tet[1]*tet[2]), nrow=3,ncol=2)
        return(jacobian)
        }
X &lt;- rnorm(200)
model3 &lt;- momentModel(fct, X, theta0=c(beta0=1, beta1=2), grad=dfct)
G &lt;- evalDMoment(model3, c(beta0=1, beta1=2))
</code></pre>

<hr>
<h2 id='evalGel-methods'> ~~ Methods for Function <code>evalGel</code> in Package <span class="pkg">modelfit</span> ~~</h2><span id='topic+evalGel'></span><span id='topic+evalGel-methods'></span><span id='topic+evalGel+2CmomentModel-method'></span>

<h3>Description</h3>

<p>Method to simply evaluate a GEL model at a fixed coefficient vector. It
creates a <code>"gelfit"</code> object using that fixed vector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'momentModel'
evalGel(model, theta, lambda=NULL,
                                gelType="EL", rhoFct=NULL,
                                lamSlv=NULL, lControl=list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalGel-methods_+3A_model">model</code></td>
<td>
<p>An object of class <code>"momentModel"</code>.</p>
</td></tr>
<tr><td><code id="evalGel-methods_+3A_theta">theta</code></td>
<td>
<p>A vector of coefficients at which the model is estimated</p>
</td></tr>
<tr><td><code id="evalGel-methods_+3A_lambda">lambda</code></td>
<td>
<p>The Lagrange multiplier vector. If not provided, the
optimal vector is obtained for the given theta</p>
</td></tr>
<tr><td><code id="evalGel-methods_+3A_geltype">gelType</code></td>
<td>
<p>The type of GEL. It is either <code>"EL"</code>,
<code>"ET"</code>,  <code>"EEL"</code>,  <code>"HD"</code>,  <code>"ETEL"</code> or
<code>"ETHD"</code>.</p>
</td></tr>
<tr><td><code id="evalGel-methods_+3A_rhofct">rhoFct</code></td>
<td>
<p>An alternative objective function for GEL. This argument
is only used if we want to fit the model with a different GEL
method. see <code><a href="#topic+rhoFct">rhoFct</a></code>.</p>
</td></tr> 
<tr><td><code id="evalGel-methods_+3A_lamslv">lamSlv</code></td>
<td>
<p>An alternative solver for the Lagrange multiplier. By
default, either <code><a href="#topic+Wu_lam">Wu_lam</a></code>, <code><a href="#topic+EEL_lam">EEL_lam</a></code>,
<code><a href="#topic+REEL_lam">REEL_lam</a></code> or <code><a href="#topic+getLambda">getLambda</a></code> is
used.</p>
</td></tr>
<tr><td><code id="evalGel-methods_+3A_lcontrol">lControl</code></td>
<td>
<p>A list of controls for the Lagrange multiplier
algorithm.</p>
</td></tr>
<tr><td><code id="evalGel-methods_+3A_...">...</code></td>
<td>
<p>Other arguments to pass. Not used for the moment.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "momentModel")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)

## A linear model with optimal lambda
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)
evalGel(model1, c(1,1))

## A nonlinear model with fixed lambda
g &lt;- y~beta0+x1^beta1
h &lt;- ~z1+z2
model2 &lt;- momentModel(g, h, c(beta0=1, beta1=2), data=simData)
evalGel(model2, theta=c(beta1=2, beta0=0.5), lambda=c(.1,.2,.3), gelType="ET")

</code></pre>

<hr>
<h2 id='evalGelObj-methods'> ~~ Methods for Function <code>evalGelObj</code> in Package <span class="pkg">Gmm</span> ~~</h2><span id='topic+evalGelObj'></span><span id='topic+evalGelObj-methods'></span><span id='topic+evalGelObj+2CmomentModel+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>~~ Methods to compute the GEL objective function. ~~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'momentModel,numeric,numeric'
evalGelObj(object, theta,
                                                   lambda, gelType,
                                                   rhoFct=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalGelObj-methods_+3A_object">object</code></td>
<td>
<p>An object of class <code>"momentModel"</code></p>
</td></tr>
<tr><td><code id="evalGelObj-methods_+3A_theta">theta</code></td>
<td>
<p>The vector for coefficients.</p>
</td></tr>
<tr><td><code id="evalGelObj-methods_+3A_lambda">lambda</code></td>
<td>
<p>Vector of Lagrange multiplier.</p>
</td></tr>
<tr><td><code id="evalGelObj-methods_+3A_geltype">gelType</code></td>
<td>
<p>The type of GEL. It is either <code>"EL"</code>,
<code>"ET"</code>,  <code>"EEL"</code>,  <code>"HD"</code>,  <code>"ETEL"</code> or
<code>"ETHD"</code>.</p>
</td></tr>
<tr><td><code id="evalGelObj-methods_+3A_rhofct">rhoFct</code></td>
<td>
<p>An alternative objective function for GEL. This argument
is only used if we want to fit the model with a different GEL
method. see <code><a href="#topic+rhoFct">rhoFct</a></code>.</p>
</td></tr> 
<tr><td><code id="evalGelObj-methods_+3A_...">...</code></td>
<td>
<p>Arguments to pass to other methods</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "momentModel", theta = "numeric",
    lambda = "numeric")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)
evalGelObj(model1, theta, c(.2,.3,.4), gelType="EL")

</code></pre>

<hr>
<h2 id='evalGmm-methods'> ~~ Methods for Function <code>evalGmm</code> in Package <span class="pkg">modelfit</span> ~~</h2><span id='topic+evalGmm'></span><span id='topic+evalGmm-methods'></span><span id='topic+evalGmm+2CmomentModel-method'></span><span id='topic+evalGmm+2CsysModel-method'></span>

<h3>Description</h3>

<p>Method to simply evaluate a GMM model at a fixed coefficient vector. It
creates a <code>"gmmfit"</code> object using that fixed vector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'momentModel'
evalGmm(model, theta, wObj=NULL, ...)
## S4 method for signature 'sysModel'
evalGmm(model, theta, wObj=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalGmm-methods_+3A_model">model</code></td>
<td>
<p>An object of class <code>"momentModel"</code>.</p>
</td></tr>
<tr><td><code id="evalGmm-methods_+3A_theta">theta</code></td>
<td>
<p>A vector of coefficients at which the model is estimated</p>
</td></tr>
<tr><td><code id="evalGmm-methods_+3A_wobj">wObj</code></td>
<td>
<p>An object of class <code>"momentWeights"</code>. If not provided,
the optimal weights based on the specification of the model
evaluated at <code>theta</code> will be computed. </p>
</td></tr>
<tr><td><code id="evalGmm-methods_+3A_...">...</code></td>
<td>
<p>Other arguments to pass. Not used for the moment.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "momentModel")</code></dt><dd>
</dd>
<dt><code>signature(model = "sysModel")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)

## A linear model
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)
evalGmm(model1, c(1,1))

## A nonlinear model
g &lt;- y~beta0+x1^beta1
h &lt;- ~z1+z2
model2 &lt;- momentModel(g, h, c(beta0=1, beta1=2), data=simData)
evalGmm(model2, theta=c(beta1=2, beta0=0.5))

## A function model
fct &lt;- function(tet, x)
    {
        m1 &lt;- (tet[1] - x)
        m2 &lt;- (tet[2]^2 - (x - tet[1])^2)
        m3 &lt;- x^3 - tet[1]*(tet[1]^2 + 3*tet[2]^2)
        f &lt;- cbind(m1, m2, m3)
        return(f)
    }
dfct &lt;- function(tet, x)
        {
        jacobian &lt;- matrix(c( 1, 2*(-tet[1]+mean(x)), -3*tet[1]^2-3*tet[2]^2,0, 2*tet[2],
			   -6*tet[1]*tet[2]), nrow=3,ncol=2)
        return(jacobian)
        }
model3 &lt;- momentModel(fct, simData$x3, theta0=c(beta0=1, beta1=2), grad=dfct)
evalGmm(model3, theta=c(beta1=.1, beta0=0.3))
</code></pre>

<hr>
<h2 id='evalGmmObj-methods'> ~~ Methods for Function <code>evalGmmObj</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+evalGmmObj'></span><span id='topic+evalGmmObj-methods'></span><span id='topic+evalGmmObj+2CmomentModel+2Cnumeric+2CmomentWeights-method'></span><span id='topic+evalGmmObj+2CsysModel+2Clist+2CsysMomentWeights-method'></span>

<h3>Description</h3>

<p>~~ Methods to compute the GMM objective function. ~~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'momentModel,numeric,momentWeights'
evalGmmObj(object, theta,
wObj, ...)

## S4 method for signature 'sysModel,list,sysMomentWeights'
evalGmmObj(object, theta,
wObj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalGmmObj-methods_+3A_object">object</code></td>
<td>
<p>An object of class <code>"momentModel"</code>,
or <code>"sysMomentModels"</code>.</p>
</td></tr>
<tr><td><code id="evalGmmObj-methods_+3A_theta">theta</code></td>
<td>
<p>The vector for coefficients for single equation, or a
list of vector for system of equations.</p>
</td></tr>
<tr><td><code id="evalGmmObj-methods_+3A_wobj">wObj</code></td>
<td>
<p>An object of class <code>"momentWeights"</code> or
<code>"sysMomentWeights"</code>.</p>
</td></tr>
<tr><td><code id="evalGmmObj-methods_+3A_...">...</code></td>
<td>
<p>Arguments to pass to other methods</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "momentModel", theta = "numeric",
    wObj = "momentWeights")</code></dt><dd>
</dd>
<dt><code>signature(object = "sysModel", theta = "list",
    wObj = "sysMomentWeights")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)
w &lt;- evalWeights(model1, theta)
evalGmmObj(model1, theta, w)

</code></pre>

<hr>
<h2 id='evalMoment-methods'> ~~ Methods for Function <code>evalMoment</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+evalMoment'></span><span id='topic+evalMoment-methods'></span><span id='topic+evalMoment+2CfunctionModel-method'></span><span id='topic+evalMoment+2CformulaModel-method'></span><span id='topic+evalMoment+2CregModel-method'></span><span id='topic+evalMoment+2CsysModel-method'></span><span id='topic+evalMoment+2CrsysModel-method'></span>

<h3>Description</h3>

<p>Method to evaluate the moment matrix at a given coefficient vector.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "functionModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "formulaModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "regModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "sysModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rsysModel")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(1,1)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)
gt &lt;- evalMoment(model1, theta)

## A nonlinearGmm
g &lt;- y~beta0+x1^beta1
h &lt;- ~z1+z2
model2 &lt;- momentModel(g, h, c(beta0=1, beta1=2), data=simData)
gt &lt;- evalMoment(model2, c(beta0=1, beta1=2))

## A functionGmm
fct &lt;- function(tet, x)
    {
        m1 &lt;- (tet[1] - x)
        m2 &lt;- (tet[2]^2 - (x - tet[1])^2)
        m3 &lt;- x^3 - tet[1]*(tet[1]^2 + 3*tet[2]^2)
        f &lt;- cbind(m1, m2, m3)
        return(f)
    }
dfct &lt;- function(tet, x)
        {
        jacobian &lt;- matrix(c( 1, 2*(-tet[1]+mean(x)), -3*tet[1]^2-3*tet[2]^2,0, 2*tet[2],
			   -6*tet[1]*tet[2]), nrow=3,ncol=2)
        return(jacobian)
        }
X &lt;- rnorm(200)
model3 &lt;- momentModel(fct, X, theta0=c(beta0=1, beta1=2), grad=dfct)
gt &lt;- evalMoment(model3, c(beta0=1, beta1=2))
</code></pre>

<hr>
<h2 id='evalWeights-methods'>Methods for Function <code>evalWeights</code> in Package <span class="pkg">Gmm</span></h2><span id='topic+evalWeights'></span><span id='topic+evalWeights-methods'></span><span id='topic+evalWeights+2CmomentModel-method'></span><span id='topic+evalWeights+2CsysModel-method'></span><span id='topic+evalWeights+2CrslinearModel-method'></span>

<h3>Description</h3>

<p>This is a constructor for objects of class <code>momentWeights</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'momentModel'
evalWeights(object, theta=NULL, w="optimal",
...)

## S4 method for signature 'sysModel'
evalWeights(object, theta = NULL, w="optimal",
wObj=NULL)

## S4 method for signature 'rslinearModel'
evalWeights(object, theta = NULL, w="optimal",
wObj=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalWeights-methods_+3A_object">object</code></td>
<td>
<p>Object of class <code>momentModel</code></p>
</td></tr>
<tr><td><code id="evalWeights-methods_+3A_theta">theta</code></td>
<td>
<p>The vector of coefficients to compute the optimal
weights. If <code>NULL</code>, <code>theta0</code> for the object is used.</p>
</td></tr>
<tr><td><code id="evalWeights-methods_+3A_w">w</code></td>
<td>
<p>A matrix for fixed weights, one of <code>"optimal"</code> or
<code>"ident"</code></p>
</td></tr>
<tr><td><code id="evalWeights-methods_+3A_wobj">wObj</code></td>
<td>
<p>An object of class <code>"sysMomentWeights"</code>. Providing it
avoid having to recompute Z'Z.</p>
</td></tr>
<tr><td><code id="evalWeights-methods_+3A_...">...</code></td>
<td>
<p>Arguments to pass to other methods</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "momentModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "sysModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rslinearModel")</code></dt><dd>
<p>System of equations with restrictions on the coefficients. It only
affects the computation of the weights when there are cross-equation
restrictions.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

## Identity weights object
wObj1 &lt;- evalWeights(model1, w="ident")

## Identity weights object (an alternative way less efficient)
wObj1 &lt;- evalWeights(model1, w=diag(3))

## Optimal weights 
wObj1 &lt;- evalWeights(model1, theta, w="optimal")


</code></pre>

<hr>
<h2 id='formulaModel-class'>Class <code>"formulaModel"</code></h2><span id='topic+formulaModel-class'></span>

<h3>Description</h3>

<p>Class for moment-based models for which moments are expressed using 
formulas.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("formulaModel", ...)</code>.
It is generated my <code><a href="#topic+momentModel">momentModel</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>modelF</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>theta0</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>fRHS</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>fLHS</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>isEndo</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>isMDE</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+allNLModel-class">allNLModel</a>"</code>, directly.
Class <code>"<a href="#topic+momentModel-class">momentModel</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "formulaModel", i = "numeric", j = "missing")</code>: ... </p>
</dd>
<dt>evalDMoment</dt><dd><p><code>signature(object = "formulaModel")</code>: ... </p>
</dd>
<dt>evalMoment</dt><dd><p><code>signature(object = "formulaModel")</code>: ... </p>
</dd>
<dt>gmmFit</dt><dd><p><code>signature(model = "formulaModel")</code>: ... </p>
</dd>
<dt>modelDims</dt><dd><p><code>signature(object = "formulaModel")</code>: ... </p>
</dd>
<dt>momentStrength</dt><dd><p><code>signature(object = "formulaModel")</code>: ... </p>
</dd>
<dt>restModel</dt><dd><p><code>signature(object = "formulaModel")</code>: ... </p>
</dd>
<dt>subset</dt><dd><p><code>signature(x = "formulaModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("formulaModel")
</code></pre>

<hr>
<h2 id='functionModel-class'>Class <code>"functionModel"</code></h2><span id='topic+functionModel-class'></span>

<h3>Description</h3>

<p>Class for moment-based models for which moment conditions are defined
using a function.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("functionModel", ...)</code>.
It is generated my <code><a href="#topic+momentModel">momentModel</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>X</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
<dt><code>fct</code>:</dt><dd><p>Object of class <code>"function"</code> ~~ </p>
</dd>
<dt><code>dfct</code>:</dt><dd><p>Object of class <code>"functionORNULL"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>theta0</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>isEndo</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+allNLModel-class">allNLModel</a>"</code>, directly.
Class <code>"<a href="#topic+momentModel-class">momentModel</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "functionModel", i = "numeric", j = "missing")</code>: ... </p>
</dd>
<dt>evalDMoment</dt><dd><p><code>signature(object = "functionModel")</code>: ... </p>
</dd>
<dt>evalMoment</dt><dd><p><code>signature(object = "functionModel")</code>: ... </p>
</dd>
<dt>modelDims</dt><dd><p><code>signature(object = "functionModel")</code>: ... </p>
</dd>
<dt>momentStrength</dt><dd><p><code>signature(object = "functionModel")</code>: ... </p>
</dd>
<dt>restModel</dt><dd><p><code>signature(object = "functionModel")</code>: ... </p>
</dd>
<dt>subset</dt><dd><p><code>signature(x = "functionModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("functionModel")
</code></pre>

<hr>
<h2 id='gel4'>GEL estimation</h2><span id='topic+gel4'></span>

<h3>Description</h3>

<p>The main functions and methods to fit any model with GEL. As opposed to
<code><a href="#topic+gelFit">gelFit</a></code>, models don't need to be created. It is all done by
the functions. It is meant to be more user friendly. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
gel4(g, x=NULL, theta0=NULL,lambda0=NULL, getVcov=FALSE, 
     gelType = c("EL","ET","EEL","HD", "REEL","ETEL","ETHD"),
     vcov = c("MDS","iid","HAC"), grad=NULL,
     vcovOptions=list(), centeredVcov = TRUE,
     cstLHS=NULL, cstRHS=NULL, lamSlv=NULL,
     rhoFct=NULL, initTheta=c("gmm", "theta0"),
     data = parent.frame(),
     coefSlv=c("optim","nlminb","constrOptim"),
     smooth=FALSE, 
     lControl=list(), tControl=list())

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gel4_+3A_g">g</code></td>
<td>
<p>A function of the form <code class="reqn">g(\theta,x)</code> and which returns a
<code class="reqn">n \times q</code> matrix with typical element <code class="reqn">g_i(\theta,x_t)</code> for
<code class="reqn">i=1,...q</code> and <code class="reqn">t=1,...,n</code>. This matrix is then used to build
the q sample moment conditions. It can also be a formula if the model
is linear (see detailsbelow).</p>
</td></tr>
<tr><td><code id="gel4_+3A_x">x</code></td>
<td>
<p>The matrix or vector of data from which the function
<code class="reqn">g(\theta,x)</code> is computed. If &quot;g&quot; is a formula, it is an <code class="reqn">n
    \times Nh</code> matrix of instruments or a formula (see details below).</p>
</td></tr>
<tr><td><code id="gel4_+3A_theta0">theta0</code></td>
<td>
<p>A <code class="reqn">k \times 1</code> vector of starting values. It is required
only when &quot;g&quot; is a function, a formula or a list of formulas. For
these cases, they are needed to create the <code>"momentModel"</code> object.</p>
</td></tr>
<tr><td><code id="gel4_+3A_lambda0">lambda0</code></td>
<td>
<p>The <code class="reqn">q \times 1</code> vector of starting values for the
Lagrange multipliers. By default a zero vector is used.</p>
</td></tr>
<tr><td><code id="gel4_+3A_getvcov">getVcov</code></td>
<td>
<p>Should the method computes the covariance matrices of the
coefficients and Lagrange multipliers.</p>
</td></tr>
<tr><td><code id="gel4_+3A_geltype">gelType</code></td>
<td>
<p>A character string specifying the type of GEL.</p>
</td></tr>
<tr><td><code id="gel4_+3A_vcov">vcov</code></td>
<td>
<p>Assumption on the properties of the moment conditions.</p>
</td></tr>
<tr><td><code id="gel4_+3A_grad">grad</code></td>
<td>
<p>A function of the form <code class="reqn">G(\theta,x)</code> which returns a
<code class="reqn">q\times k</code> matrix of derivatives of <code class="reqn">\bar{g}(\theta)</code> with
respect to <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code id="gel4_+3A_vcovoptions">vcovOptions</code></td>
<td>
<p>A list of options for the covariance matrix of the
moment conditions. See <code><a href="sandwich.html#topic+vcovHAC">vcovHAC</a></code> for the default values.</p>
</td></tr>
<tr><td><code id="gel4_+3A_centeredvcov">centeredVcov</code></td>
<td>
<p>Should the moment function be centered when
computing its covariance matrix. Doing so may improve inference.</p>
</td></tr>
<tr><td><code id="gel4_+3A_cstlhs">cstLHS</code></td>
<td>
<p>The left hand side of the constraints to impose on the
coefficients. See <code><a href="#topic+restModel">restModel</a></code> for more details.</p>
</td></tr>
<tr><td><code id="gel4_+3A_cstrhs">cstRHS</code></td>
<td>
<p>The right hand side of the constraints to impose on the
coefficients. See <code><a href="#topic+restModel">restModel</a></code> for more details.</p>
</td></tr>
<tr><td><code id="gel4_+3A_lamslv">lamSlv</code></td>
<td>
<p>An alternative solver for the Lagrange multiplier. By
default, either <code><a href="#topic+Wu_lam">Wu_lam</a></code>, <code><a href="#topic+EEL_lam">EEL_lam</a></code>,
<code><a href="#topic+REEL_lam">REEL_lam</a></code> or <code><a href="#topic+getLambda">getLambda</a></code> is
used. See the vignette for the required format.</p>
</td></tr>
<tr><td><code id="gel4_+3A_rhofct">rhoFct</code></td>
<td>
<p>An optional function that return <code class="reqn">\rho(v)</code>. This is
for users who want a GEL model that is not built in the package. The
four arguments of the function must be <code>"gmat"</code>, the matrix of
moments, <code>"lambda"</code>, the vector of Lagrange multipliers,
<code>"derive"</code>, which specify the order of derivative to return, and
<code>k</code> a numeric scale factor required for time series and kernel
smoothed moments.</p>
</td></tr>
<tr><td><code id="gel4_+3A_inittheta">initTheta</code></td>
<td>
<p>Method to obtain the starting values for the
coefficient vector. By default the GMM estimate with identity matrix
is used. The second argument means that <code>"theta0"</code> is used
instead. </p>
</td></tr>
<tr><td><code id="gel4_+3A_data">data</code></td>
<td>
<p>A required data.frame, in which all variables in g and x can
be found.</p>
</td></tr>
<tr><td><code id="gel4_+3A_smooth">smooth</code></td>
<td>
<p>If TRUE, <code>"vcov"</code> is set to <code>"MDS"</code> and the
moment conditions are smoothed using a kernel. See the vignette for
more details.</p>
</td></tr>
<tr><td><code id="gel4_+3A_coefslv">coefSlv</code></td>
<td>
<p>Minimization solver for the coefficient vector.</p>
</td></tr>
<tr><td><code id="gel4_+3A_lcontrol">lControl</code></td>
<td>
<p>A list of controls for the Lagrange multiplier
algorithm.</p>
</td></tr>
<tr><td><code id="gel4_+3A_tcontrol">tControl</code></td>
<td>
<p>A list of controls for the coefficient algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an object of class <code>"gelfit"</code>  
</p>


<h3>References</h3>

<p>Anatolyev, S. (2005), GMM, GEL, Serial Correlation, and Asymptotic Bias. <em>Econometrica</em>, <b>73</b>, 983-1002.
</p>
<p>Andrews DWK (1991), Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.
<em>Econometrica</em>, <b>59</b>, 817&ndash;858.
</p>
<p>Kitamura, Yuichi (1997), Empirical Likelihood Methods With Weakly Dependent Processes.
<em>The Annals of Statistics</em>, <b>25</b>, 2084-2102.
</p>
<p>Kitamura, Y. and Otsu, T. and Evdokimov, K. (2013), Robustness,
Infinitesimal Neighborhoods and Moment Restrictions.
<em>Econometrica</em>, <b>81</b>, 1185-1201.
</p>
<p>Newey, W.K. and Smith, R.J. (2004), Higher Order Properties of GMM and 
Generalized Empirical Likelihood Estimators. <em>Econometrica</em>, <b>72</b>, 219-255.
</p>
<p>Smith, R.J. (2004), GEL Criteria for Moment Condition Models. <em>Working paper, CEMMAP</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gelFit">gelFit</a></code>, <code><a href="#topic+momentModel">momentModel</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
res &lt;- gel4(y~x1, ~z1+z2, vcov="MDS", gelType="ET", data=simData)
res
</code></pre>

<hr>
<h2 id='gelfit-class'>Class <code>"gelfit"</code></h2><span id='topic+gelfit-class'></span>

<h3>Description</h3>

<p>A class to store fitted models obtained using a GEL method.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("gelfit", ...)</code>.
It is created by <code><a href="#topic+gelFit">gelFit</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>theta</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>convergence</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>lambda</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>lconvergence</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"callORNULL"</code> ~~ </p>
</dd>
<dt><code>gelType</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"momentModel"</code> ~~ </p>
</dd>
<dt><code>restrictedLam</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "gelfit")</code>: ... </p>
</dd>
<dt>confint</dt><dd><p><code>signature(object = "gelfit")</code>: ... </p>
</dd>
<dt>getImpProb</dt><dd><p><code>signature(object = "gelfit")</code>: ... </p>
</dd>
<dt>momFct</dt><dd><p><code>signature(eta = "numeric", object = "gelfit")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "gelfit")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "gelfit")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "gelfit")</code>: ... </p>
</dd>
<dt>specTest</dt><dd><p><code>signature(object = "gelfit", which = "missing")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "gelfit")</code>: ... </p>
</dd>
<dt>update</dt><dd><p><code>signature(object = "gelfit")</code>: ... </p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "gelfit")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("gelfit")
</code></pre>

<hr>
<h2 id='gelFit-methods'> ~~ Methods for Function <code>gelFit</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+gelFit'></span><span id='topic+gelFit-methods'></span><span id='topic+gelFit+2CmomentModel-method'></span><span id='topic+gelFit+2CrmomentModel-method'></span>

<h3>Description</h3>

<p>Method to fit a model using GEL, from an object of class
<code>"momentModel"</code> or its restricted counterpart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'momentModel'
gelFit(model, gelType="EL", rhoFct=NULL,
              initTheta=c("gmm", "modelTheta0"), theta0=NULL,
              lambda0=NULL, vcov=FALSE, ...)

## S4 method for signature 'rmomentModel'
gelFit(model, gelType="EL", rhoFct=NULL,
              initTheta=c("gmm", "modelTheta0"), theta0=NULL,
              lambda0=NULL, vcov=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gelFit-methods_+3A_model">model</code></td>
<td>
<p>A model class object</p>
</td></tr>
<tr><td><code id="gelFit-methods_+3A_geltype">gelType</code></td>
<td>
<p>The type of GEL. It is either <code>"EL"</code>,
<code>"ET"</code>,  <code>"EEL"</code>,  <code>"HD"</code>,  <code>"ETEL"</code> or
<code>"ETHD"</code>.</p>
</td></tr>
<tr><td><code id="gelFit-methods_+3A_rhofct">rhoFct</code></td>
<td>
<p>An alternative objective function for GEL. This argument
is only used if we want to fit the model with a different GEL
method. see <code><a href="#topic+rhoFct">rhoFct</a></code>.</p>
</td></tr>
<tr><td><code id="gelFit-methods_+3A_inittheta">initTheta</code></td>
<td>
<p>Method to obtain the starting values for the
coefficient vector. By default the GMM estimate with identity matrix
is used. The second argument means that the theta0 of the
object, if any, should be used.</p>
</td></tr>  
<tr><td><code id="gelFit-methods_+3A_theta0">theta0</code></td>
<td>
<p>An optional initial vector for <code><a href="stats.html#topic+optim">optim</a></code> when
the model is nonlinear. If provided, the argument <code>"initTheta"</code>
is ignored.</p>
</td></tr>
<tr><td><code id="gelFit-methods_+3A_lambda0">lambda0</code></td>
<td>
<p>Manual starting values for the Lagrange
multiplier. By default, it is a vector of zeros.</p>
</td></tr>
<tr><td><code id="gelFit-methods_+3A_vcov">vcov</code></td>
<td>
<p>Should the method computes the covariance matrices of the
coefficients and Lagrange multipliers.</p>
</td></tr>
<tr><td><code id="gelFit-methods_+3A_...">...</code></td>
<td>
<p>Arguments to pass to other methods (mostly the
optimization algorithm)</p>
</td></tr>  
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "momentModel")</code></dt><dd>
<p>The main method for all moment-based  models.
</p>
</dd>
<dt><code>signature(model = "rmomentModel")</code></dt><dd>
<p>The main method for all restricted moment-based  models.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

## EL estimate
res1 &lt;- gelFit(model1)
res1

## ET estimate
res2 &lt;- gelFit(model1, gelType="ET")
res2

## Restricted models by EL
## using the Brent method
R &lt;- matrix(c(0,1), ncol=2)
q &lt;- 2
rmodel1 &lt;- restModel(model1, R, q)
gelFit(rmodel1, tControl=list(method="Brent", lower=-10, upper=10))

</code></pre>

<hr>
<h2 id='getImpProb-methods'> ~~ Methods for Function <code>getImpProb</code> in Package <span class="pkg">momenfit</span> ~~</h2><span id='topic+getImpProb'></span><span id='topic+getImpProb+2Cgelfit-method'></span>

<h3>Description</h3>

<p>Method to evaluate the implied probabilities of GEL.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "gelfit")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='getRestrict-methods'> ~~ Methods for Function <code>getRestrict</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+getRestrict'></span><span id='topic+getRestrict-methods'></span><span id='topic+getRestrict+2CmomentModel-method'></span><span id='topic+getRestrict+2CrlinearModel-method'></span><span id='topic+getRestrict+2CrformulaModel-method'></span><span id='topic+getRestrict+2CrslinearModel-method'></span><span id='topic+getRestrict+2CrsnonlinearModel-method'></span><span id='topic+getRestrict+2CsysModel-method'></span><span id='topic+getRestrict+2CrnonlinearModel-method'></span><span id='topic+getRestrict+2CrfunctionModel-method'></span>

<h3>Description</h3>

<p>It computes the matrices related to linear and nonlinear
contraints. Those matrices are used to perform hypothesis tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'rlinearModel'
getRestrict(object, theta)

## S4 method for signature 'rslinearModel'
getRestrict(object, theta)

## S4 method for signature 'rsnonlinearModel'
getRestrict(object, theta)

## S4 method for signature 'rnonlinearModel'
getRestrict(object, theta)

## S4 method for signature 'rformulaModel'
getRestrict(object, theta)

## S4 method for signature 'momentModel'
getRestrict(object, theta, R, rhs=NULL)

## S4 method for signature 'sysModel'
getRestrict(object, theta, R, rhs=NULL)

## S4 method for signature 'rfunctionModel'
getRestrict(object, theta)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRestrict-methods_+3A_object">object</code></td>
<td>
<p>Object of class included in <code>momentModel</code>,
<code>rmomentModel</code>, and <code>rsysModel</code>.</p>
</td></tr>
<tr><td><code id="getRestrict-methods_+3A_theta">theta</code></td>
<td>
<p>A vector of coefficients for the unrestricted model (see
examples).</p>
</td></tr>
<tr><td><code id="getRestrict-methods_+3A_r">R</code></td>
<td>
<p>A matrix, character or list of formulas that specifies the
contraints to impose on the coefficients. See
<code><a href="#topic+restModel">restModel</a></code> for more details.</p>
</td></tr>
<tr><td><code id="getRestrict-methods_+3A_rhs">rhs</code></td>
<td>
<p>The right hand side for the restriction on the
coefficients. See <code><a href="#topic+restModel">restModel</a></code> for more details. It is
ignored for objects of class <code>"nonlinearModel"</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "momentModel")</code></dt><dd>
<p>A restricted model is created from the constraints, and the
restriction matrices are returned. The methods is applied to linear
and nonlinear models in a regression form.
</p>
</dd>
<dt><code>signature(object = "sysModel")</code></dt><dd>
<p>A restricted model is created from the constraints, and the
restriction matrices are returned. The methods is applied to systems
of linear and nonlinear models.
</p>
</dd>
<dt><code>signature(object = "rlinearModel")</code></dt><dd>
<p>The restriction matrices are evaluated at the coefficient vector
<code>theta</code> of the unrestricted representation.
</p>
</dd>
<dt><code>signature(object = "rslinearModel")</code></dt><dd>
<p>The restriction matrices are evaluated at the coefficient vector
<code>theta</code> of the unrestricted representation.
</p>
</dd>
<dt><code>signature(object = "rsnonlinearModel")</code></dt><dd>
<p>The restriction matrices are evaluated at the coefficient vector
<code>theta</code> of the unrestricted representation.
</p>
</dd>
<dt><code>signature(object = "rnonlinearModel")</code></dt><dd>
<p>The restriction matrices are evaluated at the coefficient vector
<code>theta</code> of the unrestricted representation.  
</p>
</dd>
<dt><code>signature(object = "rfunctionModel")</code></dt><dd>
<p>The restriction matrices are evaluated at the coefficient vector
<code>theta</code> of the unrestricted representation.  
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)

## Unrestricted model
model1 &lt;- momentModel(y~x1+x2+x3+z1, ~x1+x2+z1+z2+z3+z4, data=simData)

## The restricted model
R1 &lt;- c("x1","2*x2+z1=2", "4+x3*5=3")
res &lt;- gmmFit(model1)
rest &lt;- getRestrict(model1, coef(res), R1)

## it allows to test the restriction
g &lt;- rest$R-rest$q
v &lt;- rest$dR%*%vcov(res)%*%t(rest$dR)
(test &lt;- crossprod(g, solve(v, g)))
(pv &lt;- 1-pchisq(test, length(rest$R)))


## Delta Method:
## To impose nonlinear restrictions, we need to convert
## the linear model into a nonlinear one
NLmodel &lt;- as(model1, "nonlinearModel")
R1 &lt;- c("theta2=2", "theta3=theta4^2")
res &lt;- gmmFit(NLmodel)
rest &lt;- getRestrict(NLmodel, coef(res), R1)

g &lt;- rest$R-rest$q
v &lt;- rest$dR%*%vcov(res)%*%t(rest$dR)
(test &lt;- crossprod(g, solve(v, g)))
(pv &lt;- 1-pchisq(test, length(rest$R)))

## See hypothesisTest method for an easier approach.

</code></pre>

<hr>
<h2 id='gmm4'>GMM estimation
</h2><span id='topic+gmm4'></span><span id='topic+tsls+2Cformula-method'></span><span id='topic+tsls+2Clist-method'></span><span id='topic+ThreeSLS+2Clist-method'></span>

<h3>Description</h3>

<p>The main functions and methods to fit any model with GMM. As opposed to
<code><a href="#topic+gmmFit">gmmFit</a></code>, models don't need to be created. It is all done by
the functions. It is meant to be more user friendly. This document
needs to changed. It is just a copy and paste from the gmm package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmm4(g, x, theta0 = NULL, grad = NULL, 
     type = c("twostep", "iter", "cue", "onestep"),
     vcov = c("iid", "HAC", "MDS", "TrueFixed", "CL"),
     initW = c("ident", "tsls", "EbyE"), weights = "optimal", 
     itermaxit = 50, cstLHS=NULL, cstRHS=NULL,
     vcovOptions=list(), survOptions=list(),
     itertol = 1e-07, centeredVcov = TRUE,
     data = parent.frame(), ...)

## S4 method for signature 'formula'
tsls(model, x, vcov = c("iid", "HAC", "MDS", "CL"),
         vcovOptions=list(), survOptions=list(), centeredVcov = TRUE,
         data = parent.frame())

## S4 method for signature 'list'
tsls(model, x=NULL, vcov = c("iid", "HAC", "MDS",
          "CL"), vcovOptions=list(), survOptions=list(),
          centeredVcov = TRUE, data = parent.frame())

## S4 method for signature 'list'
ThreeSLS(model, x=NULL, vcov = c("iid", "HAC", "MDS",
          "CL"), vcovOptions=list(), survOptions=list(),
          centeredVcov = TRUE, data = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmm4_+3A_model">model</code></td>
<td>
<p>A formula or a list of formulas.</p>
</td></tr>  
<tr><td><code id="gmm4_+3A_g">g</code></td>
<td>
<p>A function of the form <code class="reqn">g(\theta,x)</code> and which returns a
<code class="reqn">n \times q</code> matrix with typical element <code class="reqn">g_i(\theta,x_t)</code> for
<code class="reqn">i=1,...q</code> and <code class="reqn">t=1,...,n</code>. This matrix is then used to build
the q sample moment conditions. It can also be a formula if the model
is linear or nonlinear, or a list of formulas for systems of equations.</p>
</td></tr>
<tr><td><code id="gmm4_+3A_x">x</code></td>
<td>
<p>The matrix or vector of data from which the function
<code class="reqn">g(\theta,x)</code> is computed. If &quot;g&quot; is a formula, it is an <code class="reqn">n
    \times Nh</code> matrix of instruments or a formula (see details below).</p>
</td></tr>
<tr><td><code id="gmm4_+3A_theta0">theta0</code></td>
<td>
<p>A <code class="reqn">k \times 1</code> vector of starting values. It is required
only when &quot;g&quot; is a function or a nonlinear equation defined by a
formula, in which case, it must be a named vector</p>
</td></tr>
<tr><td><code id="gmm4_+3A_grad">grad</code></td>
<td>
<p>A function of the form <code class="reqn">G(\theta,x)</code> which returns a
<code class="reqn">q\times k</code> matrix of derivatives of <code class="reqn">\bar{g}(\theta)</code> with
respect to <code class="reqn">\theta</code>. By default, the numerical algorithm
<code>numericDeriv</code> is used. It is of course strongly suggested to
provide this function when it is possible. This gradient is used to
compute the asymptotic covariance matrix of <code class="reqn">\hat{\theta}</code> and to
obtain the analytical gradient of the objective function if the method
is set to &quot;CG&quot; or &quot;BFGS&quot; in <code><a href="stats.html#topic+optim">optim</a></code> and if &quot;type&quot; is not
set to &quot;cue&quot;. If &quot;g&quot; is a formula, the gradiant is not required (see
the details below).</p>
</td></tr>
<tr><td><code id="gmm4_+3A_type">type</code></td>
<td>
<p>What GMM methods should we use? for
<code>type=="onestep"</code>, if <code>"weights"</code> is not a matrix, the
model will be estimated with the weights equals to the identity
matrix</p>
</td></tr>
<tr><td><code id="gmm4_+3A_vcov">vcov</code></td>
<td>
<p>Assumption on the properties of the random vector x. By
default, x is a weakly dependant process. The &quot;iid&quot; option will avoid
using the HAC matrix which will accelerate the estimation if one is
ready to make that assumption. The option &quot;TrueFixed&quot; is used only
when the matrix of weights is provided and it is the optimal one. For
type <code>CL</code>, clustered covariance matrix is computed. The options
are then included in <code>vcovOptions</code> (see <code><a href="sandwich.html#topic+meatCL">meatCL</a></code>).</p>
</td></tr>
<tr><td><code id="gmm4_+3A_initw">initW</code></td>
<td>
<p>How should be compute the initial coefficient vector in
the first. It only makes a difference for linear models for which
the choice is GMM with identity matrix or two-stage least quares.</p>
</td></tr>
<tr><td><code id="gmm4_+3A_weights">weights</code></td>
<td>
<p>What weighting matrix to use? The
choices are <code>"optimal"</code>, in which case it is the inverse of the
moment vovariance matrix, <code>"ident"</code> for the identity matrix, or
a fixed matrix.</p>
</td></tr>
<tr><td><code id="gmm4_+3A_itermaxit">itermaxit</code></td>
<td>
<p>Maximum iterations for iterative GMM</p>
</td></tr>
<tr><td><code id="gmm4_+3A_itertol">itertol</code></td>
<td>
<p>Tolance for the stopping rule in iterative GMM</p>
</td></tr>
<tr><td><code id="gmm4_+3A_centeredvcov">centeredVcov</code></td>
<td>
<p>Should the moment function be centered when
computing its covariance matrix. Doing so may improve inference.</p>
</td></tr>
<tr><td><code id="gmm4_+3A_data">data</code></td>
<td>
<p>A data.frame or a matrix with column names (Optional). </p>
</td></tr>
<tr><td><code id="gmm4_+3A_cstlhs">cstLHS</code></td>
<td>
<p>The left hand side of the constraints to impose on the
coefficients. See <code><a href="#topic+restModel">restModel</a></code> for more details.</p>
</td></tr>
<tr><td><code id="gmm4_+3A_cstrhs">cstRHS</code></td>
<td>
<p>The right hand side of the constraints to impose on the
coefficients. See <code><a href="#topic+restModel">restModel</a></code> for more details.</p>
</td></tr>
<tr><td><code id="gmm4_+3A_vcovoptions">vcovOptions</code></td>
<td>
<p>A list of options for the covariance matrix of the
moment conditions. See <code><a href="sandwich.html#topic+vcovHAC">vcovHAC</a></code> for the default values.</p>
</td></tr>
<tr><td><code id="gmm4_+3A_survoptions">survOptions</code></td>
<td>
<p>If needed, a list with the type of survey weights and
the weights as a numeric vector, data.frame or formula. The type is either
<code>"sampling"</code> or <code>"fequency"</code>.</p>
</td></tr>  
<tr><td><code id="gmm4_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="stats.html#topic+optim">optim</a></code> when the model
is nonlinear.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an object of class <code>"gmmfit"</code>  
</p>


<h3>References</h3>

<p>Zeileis A (2006), Object-oriented Computation of Sandwich Estimators.
<em>Journal of Statistical Software</em>, <b>16</b>(9), 1&ndash;16.
URL doi: <a href="https://doi.org/10.18637/jss.v016.i09">10.18637/jss.v016.i09</a>.
</p>
<p>Andrews DWK (1991),
Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.
<em>Econometrica</em>, <b>59</b>,
817&ndash;858.
</p>
<p>Newey WK &amp; West KD (1987), A Simple, Positive Semi-Definite,
Heteroskedasticity and Autocorrelation Consistent Covariance
Matrix. <em>Econometrica</em>, <b>55</b>, 703&ndash;708.
</p>
<p>Newey WK &amp; West KD (1994), Automatic Lag Selection in Covariance
Matrix Estimation. <em>Review of Economic Studies</em>, <b>61</b>, 631-653.
</p>
<p>Hansen, L.P. (1982),
Large Sample Properties of Generalized Method of Moments Estimators.
<em>Econometrica</em>, <b>50</b>,
1029-1054,
</p>
<p>Hansen, L.P. and Heaton, J. and Yaron, A.(1996),
Finite-Sample Properties of Some Alternative GMM Estimators.
<em>Journal of Business and Economic Statistics</em>, <b>14</b>
262-280.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gmmFit">gmmFit</a></code>, <code><a href="#topic+momentModel">momentModel</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

res &lt;- gmm4(y~x1, ~z1+z2, vcov="MDS", type="iter", data=simData)
res
</code></pre>

<hr>
<h2 id='gmmfit-class'>Class <code>"gmmfit"</code></h2><span id='topic+gmmfit-class'></span>

<h3>Description</h3>

<p>A class to store a fitted model obtained using GMM.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("gmmfit", ...)</code>.
Generated by <code><a href="#topic+gmmFit">gmmFit</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>theta</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>convergence</code>:</dt><dd><p>Object of class <code>"numericORNULL"</code> ~~ </p>
</dd>
<dt><code>convIter</code>:</dt><dd><p>Object of class <code>"numericORNULL"</code> ~~ </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"callORNULL"</code> ~~ </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>wObj</code>:</dt><dd><p>Object of class <code>"momentWeights"</code> ~~ </p>
</dd>
<dt><code>niter</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>efficientGmm</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"momentModel"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>bread</dt><dd><p><code>signature(x = "gmmfit")</code>: ... </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "gmmfit")</code>: ... </p>
</dd>
<dt>confint</dt><dd><p><code>signature(object = "gmmfit")</code>: ... </p>
</dd>
<dt>DWH</dt><dd><p><code>signature(object1 = "gmmfit", object2 = "gmmfit")</code>: ... </p>
</dd>
<dt>DWH</dt><dd><p><code>signature(object1 = "gmmfit", object2 = "lm")</code>: ... </p>
</dd>
<dt>DWH</dt><dd><p><code>signature(object1 = "gmmfit", object2 = "missing")</code>: ... </p>
</dd>
<dt>hypothesisTest</dt><dd><p><code>signature(object.u = "gmmfit", object.r = "gmmfit")</code>: ... </p>
</dd>
<dt>hypothesisTest</dt><dd><p><code>signature(object.u = "gmmfit", object.r = "missing")</code>: ... </p>
</dd>
<dt>hypothesisTest</dt><dd><p><code>signature(object.u = "missing", object.r = "gmmfit")</code>: ... </p>
</dd>
<dt>meatGmm</dt><dd><p><code>signature(object = "gmmfit")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "gmmfit")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "gmmfit")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "gmmfit")</code>: ... </p>
</dd>
<dt>specTest</dt><dd><p><code>signature(object = "gmmfit", which = "missing")</code>: ... </p>
</dd>
<dt>specTest</dt><dd><p><code>signature(object = "gmmfit", which = "numeric")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "gmmfit")</code>: ... </p>
</dd>
<dt>update</dt><dd><p><code>signature(object = "gmmfit")</code>: ... </p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "gmmfit")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("gmmfit")
</code></pre>

<hr>
<h2 id='gmmFit-methods'> ~~ Methods for Function <code>gmmFit</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+gmmFit'></span><span id='topic+gmmFit-methods'></span><span id='topic+gmmFit+2CmomentModel-method'></span><span id='topic+gmmFit+2CformulaModel-method'></span><span id='topic+gmmFit+2CsysModel-method'></span><span id='topic+gmmFit+2CrlinearModel-method'></span><span id='topic+gmmFit+2CrformulaModel-method'></span><span id='topic+gmmFit+2CrslinearModel-method'></span><span id='topic+gmmFit+2CrnonlinearModel-method'></span>

<h3>Description</h3>

<p>Method to fit a model using GMM, from an object of class
<code>"momentModel"</code> or <code>"sysModel"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'momentModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, theta0=NULL, ...)

## S4 method for signature 'formulaModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, theta0=NULL, ...)

## S4 method for signature 'sysModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls", "EbyE"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, theta0=NULL, EbyE=FALSE, ...)

## S4 method for signature 'rnonlinearModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, theta0=NULL, ...)

## S4 method for signature 'rlinearModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, ...)

## S4 method for signature 'rformulaModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, theta0=NULL, ...)

## S4 method for signature 'rslinearModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls", "EbyE"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, theta0=NULL, EbyE=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmmFit-methods_+3A_model">model</code></td>
<td>
<p>A model class object.</p>
</td></tr>
<tr><td><code id="gmmFit-methods_+3A_type">type</code></td>
<td>
<p>What GMM methods should we use? for
<code>type=="onestep"</code>, if <code>"weights"</code> is not a matrix, the
model will be estimated with the weights equals to the identity
matrix. For restricted </p>
</td></tr>
<tr><td><code id="gmmFit-methods_+3A_itertol">itertol</code></td>
<td>
<p>Tolance for the stopping rule in iterative GMM</p>
</td></tr>
<tr><td><code id="gmmFit-methods_+3A_initw">initW</code></td>
<td>
<p>How should be compute the initial coefficient vector in
the first. For single equation GMM, it only makes a difference for
linear models for which the choice is GMM with identity matrix or
two-stage least quares. For system of equations, <code>"tsls"</code>,
refers to equation by equation two-stage least squares. It is also
possible to start at the equation by equation estimate using the
same GMM type as specified by <code>"type"</code>.</p>
</td></tr>    
<tr><td><code id="gmmFit-methods_+3A_weights">weights</code></td>
<td>
<p>What weighting matrix to use? The choices are
<code>"optimal"</code>, in which case it is the inverse of the moment
vovariance matrix, <code>"ident"</code> for the identity matrix, or a
fixed matrix. It is also possible for weights to be an object of
class <code>gmmWeights</code>.</p>
</td></tr>
<tr><td><code id="gmmFit-methods_+3A_itermaxit">itermaxit</code></td>
<td>
<p>Maximum iterations for iterative GMM</p>
</td></tr>
<tr><td><code id="gmmFit-methods_+3A_ebye">EbyE</code></td>
<td>
<p>Should the system be estimated equation by equation?</p>
</td></tr>
<tr><td><code id="gmmFit-methods_+3A_efficientweights">efficientWeights</code></td>
<td>
<p>If <code>weights</code> is a matrix or a
<code>gmmWeights</code> class object, setting <code>efficientWeights</code> to
<code>TRUE</code> implies that the resulting one-step GMM is
efficient. As a result, the default covariance matrix for the
coefficient estimates will not be a sandwich type.</p>
</td></tr>
<tr><td><code id="gmmFit-methods_+3A_theta0">theta0</code></td>
<td>
<p>An optional initial vector for <code><a href="stats.html#topic+optim">optim</a></code> when
the model is nonlinear. By default, the theta0 argument of the model
is used</p>
</td></tr>
<tr><td><code id="gmmFit-methods_+3A_...">...</code></td>
<td>
<p>Arguments to pass to other methods (mostly the
optimization algorithm)</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "momentModel")</code></dt><dd>
<p>The main method for all moment-based models.
</p>
</dd>
<dt><code>signature(model = "rnonlinearModel")</code></dt><dd>
<p>It makes a difference only if the number of contraints is equal to the
number of coefficients, in which case, the method <code><a href="#topic+evalGmm">evalGmm</a></code>
is called at the contrained vector. If not, the next method is called.
</p>
</dd>
<dt><code>signature(model = "rformulaModel")</code></dt><dd>
<p>It makes a difference only if the number of contraints is equal to the
number of coefficients, in which case, the method <code><a href="#topic+evalGmm">evalGmm</a></code>
is called at the contrained vector. If not, the next method is called.
</p>
</dd>
<dt><code>signature(model = "rlinearModel")</code></dt><dd>
<p>It makes a difference only if the number of contraints is equal to the
number of coefficients, in which case, the method <code><a href="#topic+evalGmm">evalGmm</a></code>
is called at the contrained vector. If not, the next method is called.
</p>
</dd>
<dt><code>signature(model = "sysModel")</code></dt><dd>
<p>Method to estimate system of equations using GMM methods.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

## Efficient GMM with HAC vcov and tsls as first step.
res1 &lt;- gmmFit(model1, init="tsls")

## GMM with identity. Two ways.
res2 &lt;- gmmFit(model1, type="onestep")
res3 &lt;- gmmFit(model1, weights=diag(3))

## nonlinear regression with iterative GMM.
g &lt;- y~beta0+x1^beta1
h &lt;- ~z1+z2
model2 &lt;- momentModel(g, h, c(beta0=1, beta1=2), data=simData)
res4 &lt;- gmmFit(model2, type="iter")

## GMM for with no endogenous vaiables is
## OLS with Robust standard error

library(lmtest)
model3 &lt;- momentModel(y~x1, ~x1, data=simData, vcov="MDS")
resGmm &lt;- gmmFit(model3)
resLm &lt;- lm(y~x1, simData)
summary(resGmm)
coeftest(resLm, vcov=vcovHC(resLm, "HC0"))
summary(resGmm, df.adj=TRUE)
coeftest(resLm, vcov=vcovHC(resLm, "HC1"))

### All constrained
R &lt;- diag(2)
q &lt;- c(1,2)
rmodel1 &lt;- restModel(model1, R, q)
gmmFit(rmodel1)

## Only one constraint
R &lt;- matrix(c(0,1), ncol=2)
q &lt;- 2
rmodel1 &lt;- restModel(model1, R, q)
gmmFit(rmodel1)

</code></pre>

<hr>
<h2 id='Griliches'>Return to Education Data
</h2><span id='topic+Griliches'></span>

<h3>Description</h3>

<p>Labour data on 758 young workers between 16 and 30 years hold. Each
observation provides information on one individual at two points in
time: in 1980 (variable with 80) and in the year given be the
YEAR (variable without 80). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Griliches")</code></pre>


<h3>Format</h3>

<p>A data.frame with 758 observations and 20 variables.
</p>

<dl>
<dt>RNS, RNS80</dt><dd><p>Dummy for residency in the southern states</p>
</dd>
<dt>MRT, MRT80</dt><dd><p>Dummy for marital status (1 if married)</p>
</dd>
<dt>SMSA, SMSA80</dt><dd><p>Dummy for residency in metropolitan areas</p>
</dd>
<dt>MED</dt><dd><p>Mother's education in years</p>
</dd>
<dt>IQ</dt><dd><p>IQ score</p>
</dd>
<dt>KWW</dt><dd><p>&quot;Knowledge of the World of Work&quot; test score</p>
</dd>
<dt>Year</dt><dd><p>The year of the first observation</p>
</dd>
<dt>AGE, AGE80</dt><dd><p>Age in years</p>
</dd>
<dt>S, S80</dt><dd><p>Completed years of schooling</p>
</dd>
<dt>EXPR, EXPR80</dt><dd><p>Experience in years</p>
</dd>
<dt>TENURE, TENURE80</dt><dd><p>Tenure im years</p>
</dd>
<dt>LW, LW80</dt><dd><p>log wage</p>
</dd>
</dl>


<h3>Source</h3>

<p>Online complements of Fumio Hayashi (2000)
</p>


<h3>References</h3>

<p>Griliches, Z. (1976). Wages of Very Young Men.
<em>Journal of Political Economy</em>, <b>84</b>, S69&ndash;S85.
</p>
<p>Blackburn, M. and Neumark, D. (1992). Unobserved Ability, Efficiency
Wages, and Interindustry Wage Differentials.
<em>Quarterly Journal of Economics</em>, <b>107</b>, 1421&ndash;1436.
</p>
<p>Hayashi, F. (2000). <em>Econometrics</em>, New Jersey: Princeton
University Press.
</p>

<hr>
<h2 id='HealthRWM'>
Health data from Greene (2012) applications.
</h2><span id='topic+HealthRWM'></span>

<h3>Description</h3>

<p>The dataset is used in Greene (2012) and is taken from Riphahn, Wambach,
Million (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HealthRWM")</code></pre>


<h3>Format</h3>

<p>A data frame with 27326 observations on the following 25 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>Person-identification number</p>
</dd>
<dt><code>female</code></dt><dd><p>Female=1; male=0</p>
</dd>
<dt><code>year</code></dt><dd><p>Calendar year of the observation</p>
</dd>
<dt><code>age</code></dt><dd><p>Age in years</p>
</dd>
<dt><code>hsat</code></dt><dd><p>Health satisfaction, coded 0 (low) to 10 (high)</p>
</dd>
<dt><code>handdum</code></dt><dd><p>Handicapped=1; otherwise=0</p>
</dd>
<dt><code>handper</code></dt><dd><p>Degree of handicap in percent (0 to 100)</p>
</dd>
<dt><code>hhninc</code></dt><dd><p>Household nominal monthly net income in German
marks/10,000</p>
</dd>
<dt><code>hhkids</code></dt><dd><p>Children under age 16 in the household=1;
otherwise=0</p>
</dd>
<dt><code>educ</code></dt><dd><p>Years of schooling</p>
</dd>
<dt><code>married</code></dt><dd><p>Married=1; otherwise=0</p>
</dd>
<dt><code>haupts</code></dt><dd><p>Highest schooling degree is Hauptschul
degree=1; otherwise=0</p>
</dd>    
<dt><code>reals</code></dt><dd><p>Highest schooling degree is Realschul degree=1;
otherwise=0</p>
</dd>
<dt><code>fachhs</code></dt><dd><p>Highest schooling degree is Polytechnical
degree=1; otherwise=0</p>
</dd>
<dt><code>abitur</code></dt><dd><p>Highest schooling degree is Abitur=1;
otherwise=0</p>
</dd>    
<dt><code>univ</code></dt><dd><p>Highest schooling degree is university degree=1;
otherwise=0</p>
</dd>
<dt><code>working</code></dt><dd><p>Employed=1; otherwise=0</p>
</dd>
<dt><code>bluec</code></dt><dd><p>Blue-collar employee=1; otherwise=0</p>
</dd>
<dt><code>whitec</code></dt><dd><p>White-collar employee=1; otherwise=0</p>
</dd>
<dt><code>self</code></dt><dd><p>Self-employed=1; otherwise=0</p>
</dd>
<dt><code>beamt</code></dt><dd><p>Civil servant=1; otherwise=0</p>
</dd>
<dt><code>docvis</code></dt><dd><p>Number of doctor visits in last three months,</p>
</dd>
<dt><code>hospvis</code></dt><dd><p>Number of hospital visits in last calendar year,</p>
</dd>
<dt><code>public</code></dt><dd><p>Insured in public health insurance=1; otherwise=0</p>
</dd>
<dt><code>addon</code></dt><dd><p>Insured by add-on insurance=1; otherwise=0</p>
</dd>
</dl>



<h3>Source</h3>

<p>On Greene (2012) online resources, and on the Journal of Applied
Econometrics website
(http://qed.econ.queensu.ca/jae/2003-v18.4/riphahn-wambach-million/).
</p>


<h3>References</h3>

<p>Riphahn, R.T. and Wambach, A. and Million, A. (2003), <em>Incentive
Effects in the Demand for Health Care: A Bivariate Panel Count Data
Estimation</em>, Journal of Applied Econometrics, Vol. 18, No. 4,
387&ndash;405.
</p>
<p>Green, W.H.. (2012). <em>Econometric Analysis, 7th edition</em>, Prentice Hall.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example 13.7 of Greene (2012)
####################################

## Selecting the same data point and scaling income
##########
data(HealthRWM)
dat88 &lt;- subset(HealthRWM, year==1988 &amp; hhninc&gt;0)
dat88$hhninc &lt;- dat88$hhninc/10000

### A guess start
thet0 &lt;- c(b0=log(mean(dat88$hhninc)),b1=0,b2=0,b3=0)

## Table 13.2 First column
g &lt;- hhninc~exp(b0+b1*age+b2*educ+b3*female)
res0 &lt;- nls(g, dat88, start=thet0, control=list(maxiter=100))
summary(res0)$coef

## Table 13.2 Second column
## Trying very hard to reproduce the results, 
## Who is right?
h1 &lt;- ~age+educ+female
model1 &lt;- momentModel(g, h1, thet0, vcov="MDS", data=dat88)
res1 &lt;- gmmFit(model1, control=list(reltol=1e-10, abstol=1e-10))
summary(res1)@coef

## Table 13.2 third column (close enough)
## Here a sandwich vcov is required because it is not
## efficient GMM
h2 &lt;- ~age+educ+female+hsat+married
model2 &lt;- momentModel(g, h2, thet0, vcov="MDS", data=dat88)
res2 &lt;- gmmFit(model2, type="onestep")
summary(res2, sandwich=TRUE)@coef

## Table 13.2 fourth column (Can't get closer than that)
res3 &lt;- gmmFit(model2)
summary(res3)@coef

# Lets see what happens if we start on Greene solution
             
update(res3, theta0=c(b0=-1.61192, b1=.00092, b2=.04647, b3=-.01517))

## No...
</code></pre>

<hr>
<h2 id='hypothesisTest-class'>Class <code>"hypothesisTest"</code></h2><span id='topic+hypothesisTest-class'></span>

<h3>Description</h3>

<p>A class to store results form an hypothesis test. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("hypothesisTest", ...)</code>.
It is created by <code><a href="#topic+hypothesisTest">hypothesisTest</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>test</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>hypothesis</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>dist</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>df</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>pvalue</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "hypothesisTest")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "hypothesisTest")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("hypothesisTest")
</code></pre>

<hr>
<h2 id='hypothesisTest-methods'> ~~ Methods for Function <code>hypothesisTest</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+hypothesisTest'></span><span id='topic+hypothesisTest-methods'></span><span id='topic+hypothesisTest+2Cgmmfit+2Cgmmfit-method'></span><span id='topic+hypothesisTest+2Cmissing+2Cgmmfit-method'></span><span id='topic+hypothesisTest+2Cgmmfit+2Cmissing-method'></span><span id='topic+hypothesisTest+2Csgmmfit+2Cmissing-method'></span><span id='topic+hypothesisTest+2Csgmmfit+2Csgmmfit-method'></span><span id='topic+hypothesisTest+2Cmissing+2Csgmmfit-method'></span>

<h3>Description</h3>

<p>Performs hypothesis tests on the coefficients estimated by any GMM fit method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gmmfit,missing'
hypothesisTest(object.u, object.r, R,
rhs=NULL, vcov=NULL, ...)

## S4 method for signature 'sgmmfit,missing'
hypothesisTest(object.u, object.r, R,
rhs=NULL, vcov=NULL, ...)

## S4 method for signature 'gmmfit,gmmfit'
hypothesisTest(object.u, object.r,
type=c("Wald", "LR", "LM"), sameVcov=TRUE, vcov=NULL,
firstStepWeight=FALSE, wObj=NULL, ...)

## S4 method for signature 'sgmmfit,sgmmfit'
hypothesisTest(object.u, object.r,
type=c("Wald", "LR", "LM"), sameVcov=TRUE, vcov=NULL,
firstStepWeight=FALSE, wObj=NULL, ...)

## S4 method for signature 'missing,gmmfit'
hypothesisTest(object.u, object.r, wObj=NULL)

## S4 method for signature 'missing,sgmmfit'
hypothesisTest(object.u, object.r, wObj=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypothesisTest-methods_+3A_object.u">object.u</code></td>
<td>
<p>An object of class <code>gmmfit</code> or <code>sgmmfit</code>
obtained using an unrestricted <code>"momentModel"</code> or
<code>"sysModel"</code>.</p>
</td></tr>
<tr><td><code id="hypothesisTest-methods_+3A_object.r">object.r</code></td>
<td>
<p>An object of class <code>gmmfit</code> obtained using a
restricted <code>"momentModel"</code> or <code>"sysModel"</code>.</p>
</td></tr>
<tr><td><code id="hypothesisTest-methods_+3A_r">R</code></td>
<td>
<p>If it is an object of class <code>gmmfit</code>, one of the model
fit must be the restricted version of the other. The restrictions are
then tested. If <code>R</code> is a <code>character</code> type, it expresses
the restrictions using the coefficient names. If it <code>numeric</code>, it
must be a matrix and the restrictions are <code class="reqn">R\theta=0</code> for
<code>NULL</code> rhs, or <code class="reqn">R\theta=rhs</code> otherwise. If missing, the
<code>gmmfit</code> must be a fitted restricted model, in which case, a LM
test is performed.</p>
</td></tr>
<tr><td><code id="hypothesisTest-methods_+3A_rhs">rhs</code></td>
<td>
<p>A vector of right hand sides if <code>R</code> is <code>numeric</code></p>
</td></tr>
<tr><td><code id="hypothesisTest-methods_+3A_type">type</code></td>
<td>
<p>Should we perform a Wald,  LR or LM test?</p>
</td></tr>
<tr><td><code id="hypothesisTest-methods_+3A_samevcov">sameVcov</code></td>
<td>
<p>For the LR test, should we use the same estimate of
the covariance matrix of the moment conditions? See details below.</p>
</td></tr>
<tr><td><code id="hypothesisTest-methods_+3A_vcov">vcov</code></td>
<td>
<p>For the Wald test, it is possible to provide the method
with the covariance matrix of the coefficients.</p>
</td></tr>
<tr><td><code id="hypothesisTest-methods_+3A_wobj">wObj</code></td>
<td>
<p>For the LR test, it is possible to provide the
<code>gmmWeights</code> object. In that case, the provided gmm weights
object if used for the restricted and unrestricted models.</p>
</td></tr>
<tr><td><code id="hypothesisTest-methods_+3A_...">...</code></td>
<td>
<p>Other argument to pass to <code><a href="#topic+specTest">specTest</a></code>.</p>
</td></tr>
<tr><td><code id="hypothesisTest-methods_+3A_firststepweight">firstStepWeight</code></td>
<td>
<p>Should we use the first step weighting matrix
to compute the test (By default, the optimal weighting matrix is
recomputed using the final vector of coefficient estimates). See
details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LR test is the difference between the J-tests of the restricted
and unrestricted models. It is therefore <code class="reqn">n\bar{g}_r'W_r\bar{g}_r
    - n\bar{g}_u'W_u\bar{g}_u</code>, where <code class="reqn">\bar{g}_r</code> and
<code class="reqn">\bar{g}_u</code> are respectively the restricted and unrestricted
sample mean of the moment conditions, and <code class="reqn">W_r</code> and <code class="reqn">W_u</code>
their respective optimal weigthing matrix. The test is therefore
invalid if either of the weighting matrices does not converge to the
inverse of the covariance matrix of the moment conditions. The
restricted and unrestricted models must therefore be estimated by
efficient GMM. This is not required for the Wald test.
</p>
<p>Asymptotically, it makes no difference which consistent estimate of
<code class="reqn">W_u</code> or <code class="reqn">W_r</code> is used. However, it will make a difference in
finite samples.
</p>
<p>If <code>sameVcov=TRUE</code>, both <code class="reqn">W_r</code> and <code class="reqn">W_u</code> are equal to the
the optimal weighting matrix from the unrestricted model if
<code>firstStepWeight=FALSE</code>, and they are equal to the first step
weighting matrix (or the last step for iteratice GMM) of the
unrestricted model if it is <code>TRUE</code>. For CUE, the value of
<code>firstStepWeight</code> makes no difference since the weighting matrix
and coefficients are computed simultaneously. Having <code class="reqn">W_r=W_u</code>
prevents the test to be negative in small samples.
</p>
<p>If <code>wObj</code> is provided, both <code class="reqn">W_r</code> and <code class="reqn">W_u</code> are equal to
it. Of cource, <code>wObj</code> must be a consistent estimate of the
optimal weighting matrix for the test to be valid.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object.u = "gmmfit", object.r = "gmmfit")</code></dt><dd>
<p>Used to test a restricted model against an unrestricted one.
</p>
</dd>
<dt><code>signature(object.u = "sgmmfit", object.r = "sgmmfit")</code></dt><dd>
<p>Used to test a restricted model against an unrestricted one (for systems
of equations).
</p>
</dd>
<dt><code>signature(object.u = "missing",  object.r= "gmmfit")</code></dt><dd>
<p>Used to test a restricted model using the LM test.
</p>
</dd>
<dt><code>signature(object.u = "missing",  object.r= "sgmmfit")</code></dt><dd>
<p>Used to test a restricted model using the LM test (for systems of
equations).
</p>
</dd>
<dt><code>signature(object.u = "gmmfit", object.r = "missing")</code></dt><dd>
<p>Perform a Wald test using an unrestricted model and a restriction matrix
or vector.
</p>
</dd>
<dt><code>signature(object.u = "sgmmfit", object.r = "missing")</code></dt><dd>
<p>Perform a Wald test using an unrestricted model and a restriction matrix
or vector in systems of linear equations.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

## Unrestricted model
model1 &lt;- momentModel(y~x1+x2+x3, ~x2+x3+z1+z2+z3, data=simData, vcov="MDS")
res1 &lt;- gmmFit(model1)

## Wald test 
R &lt;- c("x1=0.5","x2=x3")
hypothesisTest(object.u=res1, R=R)

## LR tests

rmodel1 &lt;- restModel(model1, R)
res2 &lt;- gmmFit(rmodel1)
hypothesisTest(object.u=res1, object.r=res2, type="LR")

### LR and Wald should be the same as long as the same weighting
### matrix if used for both GMM fits, for the LR and Wald as well

# Unrestricted model and save the weights
res1 &lt;- gmmFit(model1)
w &lt;- res1@wObj
# estimate models with the same weights
res2 &lt;- gmmFit(rmodel1, weights=w)

# LR test with the same weights
hypothesisTest(res1, res2, type="LR", wObj=w)

# Wald test with vcov based on the same weights (or the bread)
hypothesisTest(object.u=res1, R=R, breadOnly=TRUE)

### Another example with real data
data(Mroz)
model &lt;- momentModel(log(wage)~educ+exper+I(exper^2),
                  ~exper+I(exper^2)+fatheduc+motheduc, vcov="MDS",
                  data=Mroz, centeredVcov=FALSE)
R &lt;- c("educ=0","I(exper^2)=0")
rmodel &lt;- restModel(model, R)

res1 &lt;- gmmFit(model)
res2 &lt;- gmmFit(rmodel, weights=res1@wObj)

hypothesisTest(object.u=res1, object.r=res2, type="LR", wObj=res1@wObj)
hypothesisTest(object.u=res1, object.r=res2, type="Wald",
vcov=vcov(res1, breadOnly=TRUE))

## LM test (identical to the other two tests as well)

hypothesisTest(object.r=res2)
# or 
hypothesisTest(object.u=res1, object.r=res2, type="LM")

## Wald with the Delta Method:
## To impose nonlinear restrictions, we need to convert
## the linear model into a nonlinear one
NLmodel &lt;- as(model1, "nonlinearModel")
R1 &lt;- c("theta2=2", "theta3=theta4^2")
rNLmodel &lt;- restModel(NLmodel, R1)
res.u &lt;- gmmFit(NLmodel)
res.r &lt;- gmmFit(rNLmodel)
hypothesisTest(object.u=res.u, R=R1)

## LM

hypothesisTest(object.r=res.r)

## LR

hypothesisTest(object.r=res.r, object.u=res.u, type="LR")




</code></pre>

<hr>
<h2 id='kernapply-methods'>A kernel smoothing utility for <code>"momentModel"</code> classes</h2><span id='topic+kernapply'></span><span id='topic+kernapply-methods'></span><span id='topic+kernapply+2CmomentModel-method'></span>

<h3>Description</h3>

<p>It either generates the optimal bandwidth and kernel
weights or the smoothed moments of moment based models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'momentModel'
kernapply(x, theta=NULL, smooth=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernapply-methods_+3A_x">x</code></td>
<td>
<p>An object of class <code>"momentModel"</code>.</p>
</td></tr>
<tr><td><code id="kernapply-methods_+3A_theta">theta</code></td>
<td>
<p>An optional vector of coefficients. For
<code>smooth=FALSE</code>, it is used to obtain the optimal bandwidth. If
<code>NULL</code>, the bandwidth is obtained using one step GMM with the
identity matrix as weights. For <code>smooth=TRUE</code>, the coefficient is
required since the function returns the smoothed moments at a given
vector of coefficients.</p>
</td></tr>
<tr><td><code id="kernapply-methods_+3A_smooth">smooth</code></td>
<td>
<p>By default, it returns the smoothed moment matrix. If
<code>FALSE</code>, it computes the optimal bandwidth and kernel weights.</p>
</td></tr>
<tr><td><code id="kernapply-methods_+3A_...">...</code></td>
<td>
<p>Other arguments to pass. Currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It return an object of class <code>"sSpec"</code>.
</p>


<h3>References</h3>

<p> Anatolyev, S. (2005), GMM, GEL, Serial Correlation, and
Asymptotic Bias. <em>Econometrica</em>, <b>73</b>, 983-1002.
</p>
<p>Kitamura, Yuichi (1997), Empirical Likelihood Methods With Weakly Dependent Processes.
<em>The Annals of Statistics</em>, <b>25</b>, 2084-2102.
</p>
<p>Smith, R.J. (2011), GEL Criteria for Moment Condition Models.
<em>Econometric Theory</em>, <b>27</b>(6), 1192&ndash;1235.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)

## A linearModel
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData,vcov="HAC",vcovOptions=list(kernel="Bartlett"))

### get the bandwidth
### Notice that the kernel name is the not the same
### That's because a Truncated kernel for smoothing
### lead to a Bartlett kernel for the HAC of the moments
### See Smith (2011)
kernapply(model1, smooth=FALSE)


### Adding the kernel option to the model

model2 &lt;- momentModel(y~x1, ~z1+z2,
data=simData,vcov="HAC",vcovOptions=list(kernel="Bartlett"), smooth=TRUE)

kernapply(model2, theta)$smoothx[1:5,]

</code></pre>

<hr>
<h2 id='Klein'>
Klein (1950) macro data. 
</h2><span id='topic+Klein'></span>

<h3>Description</h3>

<p>The data is used to reproduce examples of Greene (2012)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Klein")</code></pre>


<h3>Format</h3>

<p>A data frame with 22 observations on the following 10 variables.
</p>

<dl>
<dt><code>YEAR</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>P</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>WP</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>I</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>K1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>WG</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>G</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>On Greene (2012) online resources.
</p>


<h3>References</h3>

<p>Klein, L. (1950), <em>Economic Fluctuations in the United-States
1921-1941</em>, New York: John Wiley and Sons.
</p>
<p>Green, W.H.. (2012). <em>Econometric Analysis, 7th edition</em>, Prentice Hall.    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Klein)
</code></pre>

<hr>
<h2 id='LabourCR'>
Labour data from Greene (2012) applications,
</h2><span id='topic+LabourCR'></span>

<h3>Description</h3>

<p>A panel data set of 565 individuals from 1976 to 1982 used by Cornwell
and Rupert (1988)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("LabourCR")</code></pre>


<h3>Format</h3>

<p>A data frame with 4165 observations on the following 12 variables.
</p>

<dl>
<dt><code>EXP</code></dt><dd><p>Year of full time experience.</p>
</dd>
<dt><code>WKS</code></dt><dd><p>Weeks worked.</p>
</dd>
<dt><code>OCC</code></dt><dd><p>1 if blue-collar occupation, 0 otherwise.</p>
</dd>
<dt><code>IND</code></dt><dd><p>1 if works in a manufacture industry, 0 otherwise.</p>
</dd>
<dt><code>SOUTH</code></dt><dd><p>1 if resides in the south, 0 otherwise.</p>
</dd>
<dt><code>SMSA</code></dt><dd><p>1 if resides in an SMSA, 0 otherwise.</p>
</dd>
<dt><code>MS</code></dt><dd><p>1 if married, 0 otherwise.</p>
</dd>
<dt><code>FEM</code></dt><dd><p>1 if the individual is a female and 0 otherwise.</p>
</dd>
<dt><code>UNION</code></dt><dd><p>1 if wage is set by a union contract and 0 otherwise.</p>
</dd>
<dt><code>ED</code></dt><dd><p>Years of education.</p>
</dd>
<dt><code>BLK</code></dt><dd><p>1 if the individual is black and 0 otherwise.</p>
</dd>
<dt><code>LWAGE</code></dt><dd><p>Log wage.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Greene (2012) online resources:
(http://pages.stern.nyu.edu/~wgreene/Text/Edition7/tablelist8new.htm)
</p>


<h3>References</h3>

<p>Green, W.H.. (2012). <em>Econometric Analysis, 7th edition</em>, Prentice Hall.  
</p>
<p>Cornwell, C. and Rupert, P. (1988), <em>Efficient Estimation with
Panel Data: An Empirical Comparision of Instrumental Variable
Estimators</em>, Journal of Applied Econometrics, No.3, 149&ndash;155.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LabourCR)
## Table 8.1 of Greene (2012)
## Model with Z2 (iid is assumed in Table 8.1 given the s.e.)
model2 &lt;- momentModel(WKS~LWAGE+ED+UNION+FEM, ~IND+ED+UNION+FEM+SMSA, vcov="iid",
                   data=LabourCR)
## Model with Z1 using the subsetting method '['
model1 &lt;- model2[-6L]

# Second column
res1 &lt;- tsls(model1)
summary(res1)@coef

# Third column
res2 &lt;- tsls(model2)
summary(res2)@coef

</code></pre>

<hr>
<h2 id='lambdaAlgo'>Algorithms to solve for the Lagrange multiplier</h2><span id='topic+Wu_lam'></span><span id='topic+EEL_lam'></span><span id='topic+REEL_lam'></span><span id='topic+ETXX_lam'></span><span id='topic+getLambda'></span>

<h3>Description</h3>

<p>The algorithms finds the vector or Lagrange multipliers that maximizes
the GEL objective function for a given vector of coefficient <code class="reqn">\theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wu_lam(gmat, tol=1e-8, maxiter=50, k=1)

EEL_lam(gmat, k=1) 

REEL_lam(gmat, tol=NULL, maxiter=50, k=1)

ETXX_lam(gmat, lambda0, k, gelType, algo, method, control)

getLambda(gmat, lambda0=NULL, gelType=NULL, rhoFct=NULL, 
          tol = 1e-07, maxiter = 100, k = 1, method="BFGS", 
          algo = c("nlminb", "optim", "Wu"), control = list(),
          restrictedLam=integer()) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdaAlgo_+3A_gmat">gmat</code></td>
<td>
<p>The <code class="reqn">n \times q</code> matrix of moments</p>
</td></tr>
<tr><td><code id="lambdaAlgo_+3A_lambda0">lambda0</code></td>
<td>
<p>The <code class="reqn">q \times 1</code> vector of starting values for the
Lagrange multipliers.</p>
</td></tr> 
<tr><td><code id="lambdaAlgo_+3A_tol">tol</code></td>
<td>
<p>A tolerance level for the stopping rule in the Wu algorithm</p>
</td></tr>
<tr><td><code id="lambdaAlgo_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iteration in the Wu algorithm</p>
</td></tr>
<tr><td><code id="lambdaAlgo_+3A_geltype">gelType</code></td>
<td>
<p>A character string specifying the type of GEL. The
available types are <code>"EL"</code>, <code>"ET"</code>, <code>"EEL"</code>,
<code>"HD"</code> and &quot;REEL&quot;. For the latter, the algorithm restricts the
implied probabilities to be non negative.</p>
</td></tr> 
<tr><td><code id="lambdaAlgo_+3A_rhofct">rhoFct</code></td>
<td>
<p>An optional function that return <code class="reqn">\rho(v)</code>. This is
for users who want a GEL model that is not built in the package. The
four arguments of the function must be <code>"gmat"</code>, the matrix of
moments, <code>"lambda"</code>, the vector of Lagrange multipliers,
<code>"derive"</code>, which specify the order of derivative to return, and
<code>k</code> a numeric scale factor required for time series and kernel
smoothed moments.</p>
</td></tr>
<tr><td><code id="lambdaAlgo_+3A_k">k</code></td>
<td>
<p>A numeric scaling factor that is required when <code>"gmat"</code> is
a matrix of time series which require smoothing. The value depends on
the kernel and is automatically set when the <code>"gelModels"</code> is
created.</p>
</td></tr>
<tr><td><code id="lambdaAlgo_+3A_method">method</code></td>
<td>
<p>This is the method for <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="lambdaAlgo_+3A_algo">algo</code></td>
<td>
<p>Which algorithm should be used to maximize the GEL objective
function. If set to <code>"Wu"</code>, which is only for <code>"EL"</code>, the Wu
(2005) algorithm is used.</p>
</td></tr>
<tr><td><code id="lambdaAlgo_+3A_control">control</code></td>
<td>
<p>A list of control to pass to either <code><a href="stats.html#topic+optim">optim</a></code>
or <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="lambdaAlgo_+3A_restrictedlam">restrictedLam</code></td>
<td>
<p>A vector of integers indicating which
<code>"lambda"</code> are restricted to be equal to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ETXX_lam</code> is used for ETEL and ETHD. In general, it
computes lambda using ET, and returns the value of the objective
function determined by the <code>gelType</code>.  </p>


<h3>Value</h3>

<p>It returns the vector <code class="reqn">\rho(gmat \lambda)</code> when <code>derive=0</code>,
<code class="reqn">\rho'(gmat \lambda)</code> when <code>derive=1</code> and <code class="reqn">\rho''(gmat
  \lambda)</code> when <code>derive=2</code>.
</p>


<h3>References</h3>

<p>Anatolyev, S. (2005), GMM, GEL, Serial Correlation, and Asymptotic Bias. <em>Econometrica</em>, <b>73</b>, 983-1002.
</p>
<p>Kitamura, Yuichi (1997), Empirical Likelihood Methods With Weakly Dependent Processes.
<em>The Annals of Statistics</em>, <b>25</b>, 2084-2102.
</p>
<p>Kitamura, Y. and Otsu, T. and Evdokimov, K. (2013), Robustness,
Infinitesimal Neighborhoods and Moment Restrictions.
<em>Econometrica</em>, <b>81</b>, 1185-1201.
</p>
<p>Newey, W.K. and Smith, R.J. (2004), Higher Order Properties of GMM and 
Generalized Empirical Likelihood Estimators. <em>Econometrica</em>, <b>72</b>, 219-255.
</p>
<p>Smith, R.J. (2011), GEL Criteria for Moment Condition Models.
<em>Econometric Theory</em>, <b>27</b>(6), 1192&ndash;1235.
</p>
<p>Wu, C. (2005), Algorithms and R codes for the pseudo empirical
likelihood method in survey sampling.
<em>Survey Methodology</em>, <b>31</b>(2), page 239.
</p>

<hr>
<h2 id='linearModel-class'>Class <code>"linearModel"</code></h2><span id='topic+linearModel-class'></span>

<h3>Description</h3>

<p>Class for moment-based models for which moment conditions are linear and
expressed by a formula.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("linearModel",
  ...)</code>.
It is generated my <code><a href="#topic+momentModel">momentModel</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>modelF</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>instF</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>isEndo</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+regModel-class">regModel</a>"</code>, directly.
Class <code>"<a href="#topic+momentModel-class">momentModel</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>Dresiduals</dt><dd><p><code>signature(object = "linearModel")</code>: ... </p>
</dd>
<dt>merge</dt><dd><p><code>signature(x = "linearModel", y = "linearModel")</code>: ... </p>
</dd>
<dt>merge</dt><dd><p><code>signature(x = "slinearModel", y = "linearModel")</code>: ... </p>
</dd>
<dt>model.matrix</dt><dd><p><code>signature(object = "linearModel")</code>: ... </p>
</dd>
<dt>modelDims</dt><dd><p><code>signature(object = "linearModel")</code>: ... </p>
</dd>
<dt>modelResponse</dt><dd><p><code>signature(object = "linearModel")</code>: ... </p>
</dd>
<dt>momentStrength</dt><dd><p><code>signature(object = "linearModel")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "linearModel")</code>: ... </p>
</dd>
<dt>restModel</dt><dd><p><code>signature(object = "linearModel")</code>: ... </p>
</dd>
<dt>solveGmm</dt><dd><p><code>signature(object = "linearModel", wObj = "momentWeights")</code>: ... </p>
</dd>
<dt>tsls</dt><dd><p><code>signature(model = "linearModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("linearModel")
</code></pre>

<hr>
<h2 id='ManufactCost'>
Manufacturing Costs data from Bernt and Wood (1975)
</h2><span id='topic+ManufactCost'></span>

<h3>Description</h3>

<p>The data is used to reproduce examples of Greene (2012)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ManufactCost")</code></pre>


<h3>Format</h3>

<p>A data frame with 25 observations on the following 10 variables.
</p>

<dl>
<dt><code>Year</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Cost</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>K</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>L</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>E</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Pk</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Pl</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Pe</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Pm</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>On Greene (2012) online resources.
</p>


<h3>References</h3>

<p>Berndt, E. and Wood, D. (1975), <em>Technology, Prices, and the
Derived Demand for Energy</em>, Review of Economics and Statistics,
Vol. 57, 376&ndash;384.
</p>
<p>Green, W.H.. (2012). <em>Econometric Analysis, 7th edition</em>, Prentice Hall.    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ManufactCost)
</code></pre>

<hr>
<h2 id='mconfint-class'>Class <code>"mconfint"</code></h2><span id='topic+mconfint-class'></span>

<h3>Description</h3>

<p>A class to store confidence region.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("mconfint", ...)</code>.
It is created by the <code>"confint"</code> method with the option
<code>area=TRUE</code> (see <code><a href="#topic+confint-methods">confint-methods</a></code>).
</p>


<h3>Slots</h3>


<dl>
<dt><code>areaPoints</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>level</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>theta</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "mconfint")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "mconfint")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "mconfint")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("mconfint")
</code></pre>

<hr>
<h2 id='meatGmm-methods'> ~~ Methods for Function <code>meatGmm</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+meatGmm'></span><span id='topic+meatGmm-methods'></span><span id='topic+meatGmm+2Cgmmfit-method'></span><span id='topic+meatGmm+2Csgmmfit-method'></span><span id='topic+meatGmm+2Ctsls-method'></span>

<h3>Description</h3>

<p>It computes the meat in the sandwich representation of the covariance
matrix of the GMM estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gmmfit'
meatGmm(object, robust=FALSE)

## S4 method for signature 'sgmmfit'
meatGmm(object, robust=FALSE)

## S4 method for signature 'tsls'
meatGmm(object, robust=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meatGmm-methods_+3A_object">object</code></td>
<td>
<p>GMM fit object</p>
</td></tr>
<tr><td><code id="meatGmm-methods_+3A_robust">robust</code></td>
<td>
<p>If <code>TRUE</code>, the meat is robust to the failure of the
assumption that the weighting matrix is the inverse of the
covariance matrix of the moment conditions. (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>robust=FALSE</code>, then the meat is <code class="reqn">G'V^{-1}G</code>, where
<code class="reqn">G</code> and <code class="reqn">V</code> are respectively the sample mean of the derivatives
and the covariance matrix of the moment conditions. If it is
<code>TRUE</code>, the meat is <code class="reqn">G'WVWG</code>, where <code class="reqn">W</code> is the weighting
matrix.
</p>
<p>For <code>tsls</code> objects, the function makes use of the QR representation
of the weighting matrix. It is simply possible to get the meat in a more
stable way. In that case, <code class="reqn">W=(\sigma^2Z'Z/n)^{-1}</code>. If <code>robust</code>
is FALSE, <code>V</code> is assumed to be <code class="reqn">\sigma^2Z'Z/n</code> which is the
inverse of the <code>bread</code>. Therefore, a sandwich covariance matrix
with <code>robust=FALSE</code> will result in a non-sandwich matrix.
</p>
<p>For <code>sgmmfit</code>, the covariance is for the vectorized coefficient
vector of all equations. 
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "gmmfit")</code></dt><dd>
<p>General GMM fit.
</p>
</dd>
<dt><code>signature(object = "tsls")</code></dt><dd>
<p>For model estimated by two-stage least squares.
</p>
</dd>
<dt><code>signature(object = "sgmmfit")</code></dt><dd>
<p>For system of equations.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

res &lt;- gmmFit(model1)
meatGmm(res)

## It is a slightly different because the weighting matrix
## is computed using the first step estimate and the covariance
## matrix of the moment conditions is based on the final estimate.
## They should, however, be asymptotically equivalent.

meatGmm(res, robust=TRUE)

## TSLS
res2 &lt;- tsls(model1)

## Robust meat
meatGmm(res2, TRUE)

## It makes no difference is the model is assumed iid
model2 &lt;- momentModel(y~x1, ~z1+z2, data=simData, vcov="iid")
res2 &lt;- tsls(model2)
meatGmm(res2, FALSE)
meatGmm(res2, TRUE)


</code></pre>

<hr>
<h2 id='merge-methods'> ~~ Methods for Function <code>merge</code> in Package <span class="pkg">base</span> ~~</h2><span id='topic+merge'></span><span id='topic+merge-methods'></span><span id='topic+merge+2CANY+2CANY-method'></span><span id='topic+merge+2ClinearModel+2ClinearModel-method'></span><span id='topic+merge+2CnonlinearModel+2CnonlinearModel-method'></span><span id='topic+merge+2CslinearModel+2ClinearModel-method'></span><span id='topic+merge+2CsnonlinearModel+2CnonlinearModel-method'></span>

<h3>Description</h3>

<p>It allows to merge <code>momentModel</code> classes into system objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'linearModel,linearModel'
merge(x, y, ...)

## S4 method for signature 'nonlinearModel,nonlinearModel'
merge(x, y, ...)

## S4 method for signature 'slinearModel,linearModel'
merge(x, y, ...)

## S4 method for signature 'snonlinearModel,nonlinearModel'
merge(x, y, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge-methods_+3A_x">x</code></td>
<td>
<p>An object on which the other objects are merged to.</p>
</td></tr>
<tr><td><code id="merge-methods_+3A_y">y</code></td>
<td>
<p>An object to be merged to <code>x</code>.</p>
</td></tr>
<tr><td><code id="merge-methods_+3A_...">...</code></td>
<td>
<p>Other objects of the same class as <code>y</code> to be merged
to <code>x</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "linearModel", y = "linearModel")</code></dt><dd>
<p>Merging linear models into a system of equations.
</p>
</dd>
<dt><code>signature(x = "nonlinearModel", y = "nonlinearModel")</code></dt><dd>
<p>Merging nonlinear models into a system of equations.
</p>
</dd>
<dt><code>signature(x = "slinearModel", y = "linearModel")</code></dt><dd>
<p>Adding linear equations to a system of linear equations.
</p>
</dd>
<dt><code>signature(x = "snonlinearModel", y = "nonlinearModel")</code></dt><dd>
<p>Adding nonlinear equations to a system of nonlinear equations.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
g1 &lt;- y1~x1+x4; h1 &lt;- ~z1+z2+z3+z4+x4
g2 &lt;- y2~x1+x2+x3; h2 &lt;- ~z1+z2+z3+z4+x3
g3 &lt;- y3~x2+x3+x4; h3 &lt;- ~z2+z3+z4+x3+x4
## Linear models
m1 &lt;- momentModel(g1, h1, data=simData)
m2 &lt;- momentModel(g2, h2, data=simData)
m3 &lt;- momentModel(g3, h3, data=simData)

##
(sys1 &lt;- merge(m1, m2))

## add an equation to the model

(sys2 &lt;- merge(sys1, m3))

## want to get back the first?

sys2[1:2]

## Nonlinear (not really, just written as nonlinear)

nlg &lt;- list(y1~theta0+theta1*x1+theta2*x4,
            y2~alpha0+alpha1*x1+alpha2*x2+alpha3*x3,
            y3~beta0+beta1*x2+beta2*x3+beta3*x4)
theta0 &lt;- list(c(theta0=1,theta1=2,theta2=3),
              c(alpha0=1,alpha1=2,alpha2=3, alpha3=4),
              c(beta0=1,beta1=2,beta2=3,beta3=4))

nm1 &lt;- momentModel(nlg[[1]], h1, theta0[[1]], data=simData)
nm2 &lt;- momentModel(nlg[[2]], h2, theta0[[2]], data=simData)
nm3 &lt;- momentModel(nlg[[3]], h3, theta0[[3]], data=simData)

merge(nm1, nm2, nm3)


</code></pre>

<hr>
<h2 id='model.matrix-methods'> ~~ Methods for Function <code>model.matrix</code> in Package <span class="pkg">stats</span> ~~</h2><span id='topic+model.matrix'></span><span id='topic+model.matrix-methods'></span><span id='topic+model.matrix+2ClinearModel-method'></span><span id='topic+model.matrix+2CnonlinearModel-method'></span><span id='topic+model.matrix+2CrlinearModel-method'></span><span id='topic+model.matrix+2CslinearModel-method'></span><span id='topic+model.matrix+2CrslinearModel-method'></span><span id='topic+model.matrix+2CrsnonlinearModel-method'></span><span id='topic+model.matrix+2CsnonlinearModel-method'></span>

<h3>Description</h3>

<p>Model matrix form <code>momentModel</code>. It returns the matrix of regressors
or the instruments. In restricted models, it returns the reduced matrix
of regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'linearModel'
model.matrix(object,
type=c("regressors","instruments"))
## S4 method for signature 'rlinearModel'
model.matrix(object,
type=c("regressors","instruments"))
## S4 method for signature 'nonlinearModel'
model.matrix(object,
type=c("regressors","instruments"))
## S4 method for signature 'slinearModel'
model.matrix(object,
type=c("regressors","instruments"))
## S4 method for signature 'rslinearModel'
model.matrix(object,
type=c("regressors","instruments"))
## S4 method for signature 'rsnonlinearModel'
model.matrix(object,
type=c("regressors","instruments"))
## S4 method for signature 'snonlinearModel'
model.matrix(object,
type=c("regressors","instruments"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix-methods_+3A_object">object</code></td>
<td>
<p>Object of class <code>linearModel</code>, <code>rlinearModel</code> or any
system of equations class.</p>
</td></tr>
<tr><td><code id="model.matrix-methods_+3A_type">type</code></td>
<td>
<p>Should the function returns the matrix of instruments or the
matrix of regressors. For <code>nonlinearModel</code> classes, type='regressors'
will produce an error message, because there is no such model matrix in
this case, at least not for now.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "linearModel")</code></dt><dd>
<p>Linear models with not restrictions.
</p>
</dd>
<dt><code>signature(object = "nonlinearModel")</code></dt><dd>
<p>Nonlinear models with not restrictions.
</p>
</dd>
<dt><code>signature(object = "rlinearModel")</code></dt><dd>
<p>linear models with restrictions.
</p>
</dd>
<dt><code>signature(object = "slinearModel")</code></dt><dd>
<p>System of linear equations with no restrictions. 
</p>
</dd>
<dt><code>signature(object = "rslinearModel")</code></dt><dd>
<p>System of linear equations with restrictions. 
</p>
</dd>
<dt><code>signature(object = "rsnonlinearModel")</code></dt><dd>
<p>System of nonlinear equations with restrictions. 
</p>
</dd>
<dt><code>signature(object = "snonlinearModel")</code></dt><dd>
<p>System of nonlinear equations with no restrictions. 
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

## Unrestricted model
model1 &lt;- momentModel(y~x1+x2+x3, ~x2+x3+z1+z2, data=simData)
model.matrix(model1)[1:3,]

## Restrictions change the response
R &lt;- c("x2=2","x3+x1=3")
rmodel1 &lt;- restModel(model1, R)
rmodel1
model.matrix(rmodel1)[1:3,]
</code></pre>

<hr>
<h2 id='modelDims-methods'>Methods for Function <code>modelDims</code></h2><span id='topic+modelDims'></span><span id='topic+modelDims-methods'></span><span id='topic+modelDims+2ClinearModel-method'></span><span id='topic+modelDims+2CrslinearModel-method'></span><span id='topic+modelDims+2CrsnonlinearModel-method'></span><span id='topic+modelDims+2CsysMomentModel-method'></span><span id='topic+modelDims+2CslinearModel-method'></span><span id='topic+modelDims+2CsnonlinearModel-method'></span><span id='topic+modelDims+2CsfunctionModel-method'></span><span id='topic+modelDims+2CnonlinearModel-method'></span><span id='topic+modelDims+2CfunctionModel-method'></span><span id='topic+modelDims+2CformulaModel-method'></span><span id='topic+modelDims+2CrformulaModel-method'></span><span id='topic+modelDims+2CrlinearModel-method'></span><span id='topic+modelDims+2CrfunctionModel-method'></span><span id='topic+modelDims+2CrnonlinearModel-method'></span>

<h3>Description</h3>

<p>It extracts important information from the model. It is mostly used by
other methods when a <code>modelModel</code> has been modifed. An example is
when restrictions have been imposed on coefficients.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "rlinearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rnonlinearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rfunctionModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "linearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "nonlinearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "functionModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "formulaModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rformulaModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "slinearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rslinearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rsnonlinearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "snonlinearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "sfunctionModel")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

model1 &lt;- momentModel(y~x1+x2, ~x2+z1+z2, data=simData)
modelDims(model1)

## Unrestricted model

rmodel1 &lt;- restModel(model1, R=c("x1+x2=4"))
modelDims(rmodel1)


</code></pre>

<hr>
<h2 id='modelResponse-methods'> ~~ Methods for Function <code>modelResponse</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+modelResponse'></span><span id='topic+modelResponse-methods'></span><span id='topic+modelResponse+2ClinearModel-method'></span><span id='topic+modelResponse+2CslinearModel-method'></span><span id='topic+modelResponse+2CrslinearModel-method'></span><span id='topic+modelResponse+2CrlinearModel-method'></span>

<h3>Description</h3>

<p>Return the response vector in models with and without restrictions
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "linearModel")</code></dt><dd>
<p>For linear models without restrictions on the coefficients.
</p>
</dd>
<dt><code>signature(object = "slinearModel")</code></dt><dd>
<p>For system of linear models without restrictions on the coefficients.
</p>
</dd>
<dt><code>signature(object = "rslinearModel")</code></dt><dd>
<p>For system of linear models with restrictions on the coefficients.
</p>
</dd>
<dt><code>signature(object = "rlinearModel")</code></dt><dd>
<p>For linear models with restrictions on the coefficients.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

## Unrestricted model
model1 &lt;- momentModel(y~x1+x2+x3, ~x2+x3+z1+z2, data=simData)
y &lt;- modelResponse(model1)

## Restrictions change the response
R &lt;- c("x2=2","x3=3")
rmodel1 &lt;- restModel(model1, R)
rmodel1
restY &lt;- modelResponse(rmodel1)

</code></pre>

<hr>
<h2 id='momentModel'>Constructor for <code>"momentModel"</code> classes</h2><span id='topic+momentModel'></span>

<h3>Description</h3>

<p>It builds an object class <code>"momentModel"</code>, which is a
union class for <code>"linearModel"</code>,  <code>"nonlinearModel"</code>,
<code>"formulaModel"</code> and <code>"functionModel"</code> classes. These are
classes for moment based models. This is the first step before running
any estimation algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentModel(g, x=NULL, theta0=NULL,grad=NULL,
            vcov = c("iid", "HAC", "MDS", "CL"),
            vcovOptions=list(), centeredVcov = TRUE, data=parent.frame(),
            na.action="na.omit", survOptions=list(), smooth=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="momentModel_+3A_g">g</code></td>
<td>
<p>A function of the form <code class="reqn">g(\theta,x)</code> and which returns a
<code class="reqn">n \times q</code> matrix with typical element <code class="reqn">g_i(\theta,x_t)</code> for
<code class="reqn">i=1,...q</code> and <code class="reqn">t=1,...,n</code>. This matrix is then used to build
the q sample moment conditions. It can also be a formula if the model
is linear (see detailsbelow).</p>
</td></tr>
<tr><td><code id="momentModel_+3A_x">x</code></td>
<td>
<p>The matrix or vector of data from which the function
<code class="reqn">g(\theta,x)</code> is computed. If &quot;g&quot; is a formula, it is an <code class="reqn">n
    \times Nh</code> matrix of instruments or a formula (see details below).</p>
</td></tr>
<tr><td><code id="momentModel_+3A_theta0">theta0</code></td>
<td>
<p>A <code class="reqn">k \times 1</code> vector of starting values. It is required
only when &quot;g&quot; is a function because only then a numerical algorithm is
used to minimize the objective function. If the dimension of
<code class="reqn">\theta</code> is one, see the argument &quot;optfct&quot;.</p>
</td></tr>
<tr><td><code id="momentModel_+3A_grad">grad</code></td>
<td>
<p>A function of the form <code class="reqn">G(\theta,x)</code> which returns a
<code class="reqn">q\times k</code> matrix of derivatives of <code class="reqn">\bar{g}(\theta)</code> with
respect to <code class="reqn">\theta</code>. By default, the numerical algorithm
<code>numericDeriv</code> is used. It is of course strongly suggested to
provide this function when it is possible. This gradient is used to
compute the asymptotic covariance matrix of <code class="reqn">\hat{\theta}</code> and to
obtain the analytical gradient of the objective function if the method
is set to &quot;CG&quot; or &quot;BFGS&quot; in <code><a href="stats.html#topic+optim">optim</a></code> and if &quot;type&quot; is not
set to &quot;cue&quot;. If &quot;g&quot; is a formula, the gradiant is not required (see
the details below).</p>
</td></tr>
<tr><td><code id="momentModel_+3A_vcov">vcov</code></td>
<td>
<p>Assumption on the properties of the moment conditions. By
default, they are weakly dependant processes. For <code>MDS</code>, we
assume that the conditions are martingale difference sequences, which
implies they are serially uncorrelated, but may be
heteroscedastic. There is a difference between <code>iid</code> and
<code>MDS</code> only when <code>g</code> is a formula. In that case, residuals
are assumed homoscedastic as well as serially uncorrelated. For type
<code>CL</code>, clustered covariance matrix is computed. The options are
then included in <code>vcovOptions</code> (see <code><a href="sandwich.html#topic+meatCL">meatCL</a></code>). </p>
</td></tr>
<tr><td><code id="momentModel_+3A_vcovoptions">vcovOptions</code></td>
<td>
<p>A list of options for the covariance matrix of the
moment conditions. See <code><a href="sandwich.html#topic+vcovHAC">vcovHAC</a></code> for the default values.</p>
</td></tr>
<tr><td><code id="momentModel_+3A_centeredvcov">centeredVcov</code></td>
<td>
<p>Should the moment function be centered when
computing its covariance matrix. Doing so may improve inference.</p>
</td></tr>
<tr><td><code id="momentModel_+3A_data">data</code></td>
<td>
<p>A data.frame or a matrix with column names (Optional). </p>
</td></tr>
<tr><td><code id="momentModel_+3A_na.action">na.action</code></td>
<td>
<p>Action to take for missing values. If missing values
are present and the option is set to <code>"na.pass"</code>, the model won't
be estimable.</p>
</td></tr>
<tr><td><code id="momentModel_+3A_survoptions">survOptions</code></td>
<td>
<p>If needed, a list with the type of survey weights and
the weights as a numeric vector, data.frame or formula. The type is either
<code>"sampling"</code> or <code>"fequency"</code>.</p>
</td></tr>
<tr><td><code id="momentModel_+3A_smooth">smooth</code></td>
<td>
<p>If <code>TRUE</code>, the moment function is smoothed using a
kernel method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'momentModel' returns an object of one of the subclasses of <code>"momentModel"</code>.
</p>


<h3>References</h3>

<p>Andrews DWK (1991),
Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.
<em>Econometrica</em>, <b>59</b>,
817&ndash;858.
</p>
<p>Newey WK &amp; West KD (1987), A Simple, Positive Semi-Definite,
Heteroskedasticity and Autocorrelation Consistent Covariance
Matrix. <em>Econometrica</em>, <b>55</b>, 703&ndash;708.
</p>
<p>Newey WK &amp; West KD (1994), Automatic Lag Selection in Covariance
Matrix Estimation. <em>Review of Economic Studies</em>, <b>61</b>, 631-653.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)

## A linearModel
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

## A nonlinearModel
g &lt;- y~beta0+x1^beta1
h &lt;- ~z1+z2
model2 &lt;- momentModel(g, h, c(beta0=1, beta1=2), data=simData)

## A functionModel
fct &lt;- function(tet, x)
    {
        m1 &lt;- (tet[1] - x)
        m2 &lt;- (tet[2]^2 - (x - tet[1])^2)
        m3 &lt;- x^3 - tet[1]*(tet[1]^2 + 3*tet[2]^2)
        f &lt;- cbind(m1, m2, m3)
        return(f)
    }
dfct &lt;- function(tet, x)
        {
        jacobian &lt;- matrix(c( 1, 2*(-tet[1]+mean(x)), -3*tet[1]^2-3*tet[2]^2,0, 2*tet[2],
			   -6*tet[1]*tet[2]), nrow=3,ncol=2)
        return(jacobian)
        }
model3 &lt;- momentModel(fct, simData$x3, theta0=c(beta0=1, beta1=2), grad=dfct)
</code></pre>

<hr>
<h2 id='momentModel-class'>Class <code>"momentModel"</code></h2><span id='topic+momentModel-class'></span>

<h3>Description</h3>

<p>A union class for all moment based models. It is created by
<code><a href="#topic+momentModel">momentModel</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "momentModel", i = "missing", j = "missing")</code>: ... </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "momentModel")</code>: ... </p>
</dd>
<dt>evalGel</dt><dd><p><code>signature(model = "momentModel")</code>: ... </p>
</dd>
<dt>evalGelObj</dt><dd><p><code>signature(object = "momentModel", theta = "numeric", lambda = "numeric")</code>: ... </p>
</dd>
<dt>evalGmm</dt><dd><p><code>signature(model = "momentModel")</code>: ... </p>
</dd>
<dt>evalGmmObj</dt><dd><p><code>signature(object = "momentModel", theta = "numeric", wObj = "momentWeights")</code>: ... </p>
</dd>
<dt>evalWeights</dt><dd><p><code>signature(object = "momentModel")</code>: ... </p>
</dd>
<dt>gelFit</dt><dd><p><code>signature(model = "momentModel")</code>: ... </p>
</dd>
<dt>getRestrict</dt><dd><p><code>signature(object = "momentModel")</code>: ... </p>
</dd>
<dt>gmmFit</dt><dd><p><code>signature(model = "momentModel")</code>: ... </p>
</dd>
<dt>kernapply</dt><dd><p><code>signature(x = "momentModel")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "momentModel")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "momentModel")</code>: ... </p>
</dd>
<dt>solveGel</dt><dd><p><code>signature(object = "momentModel")</code>: ... </p>
</dd>
<dt>update</dt><dd><p><code>signature(object = "momentModel")</code>: ... </p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "momentModel")</code>: ... </p>
</dd>
<dt>vcovHAC</dt><dd><p><code>signature(x = "momentModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("momentModel")
</code></pre>

<hr>
<h2 id='momentStrength-methods'> ~~ Methods for Function <code>momentStrength</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+momentStrength'></span><span id='topic+momentStrength-methods'></span><span id='topic+momentStrength+2CfunctionModel-method'></span><span id='topic+momentStrength+2CformulaModel-method'></span><span id='topic+momentStrength+2ClinearModel-method'></span><span id='topic+momentStrength+2CrlinearModel-method'></span><span id='topic+momentStrength+2CnonlinearModel-method'></span>

<h3>Description</h3>

<p>It produces measures of the strength of the moment conditons. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'linearModel'
momentStrength(object, theta,
vcovType=c("OLS","HC","HAC","CL"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="momentStrength-methods_+3A_object">object</code></td>
<td>
<p>An object of class <code>"linearModel"</code></p>
</td></tr>
<tr><td><code id="momentStrength-methods_+3A_theta">theta</code></td>
<td>
<p>Coefficient vector at which the strength must be
measured. It does not impact the measure for objects of class
<code>linearModel</code>.</p>
</td></tr>
<tr><td><code id="momentStrength-methods_+3A_vcovtype">vcovType</code></td>
<td>
<p>Type of covariance matrix used to
compute the F-test of the first-stage regression. For <code>HC</code>,
the function <code><a href="sandwich.html#topic+vcovHC">vcovHC</a></code> is used with &quot;HC1&quot;, and
<code><a href="sandwich.html#topic+vcovHAC">vcovHAC</a></code> is used with the default setup is &quot;HAC&quot; is
chosen. In <code>summary</code> for <code>gmmfit</code> objects, it is adjusted
to the type of covariance that is set in the object. For type
<code>CL</code>, clustered covariance matrix is computed. The options are
the one included in the <code>vcovOptions</code> slot of the object (see
<code><a href="sandwich.html#topic+meatCL">meatCL</a></code>). The object must have be defined with clusters
for that to work. See <code><a href="#topic+momentModel">momentModel</a></code>.</p>
</td></tr> 
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "functionModel")</code></dt><dd>
<p>Not implemented yet. In that case, we want some measure of the rank of
the matrix of derivatives. 
</p>
</dd>
<dt><code>signature(object = "formulaModel")</code></dt><dd>
<p>Not implemented yet. In that case, we want some measure of the rank of
the matrix of derivatives. 
</p>
</dd>
<dt><code>signature(object = "linearModel")</code></dt><dd>
<p>It returns the F-test of the first stage regression. It is a measure of
the strength of the instruments.
</p>
</dd>
<dt><code>signature(object = "rlinearModel")</code></dt><dd>
<p>Returns nothing for now.
</p>
</dd>
<dt><code>signature(object = "nonlinearModel")</code></dt><dd>
<p>Not implemented yet. 
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)
momentStrength(model1)
</code></pre>

<hr>
<h2 id='momentWeights-class'>Class <code>"momentWeights"</code></h2><span id='topic+momentWeights-class'></span><span id='topic+momentWeights'></span>

<h3>Description</h3>

<p>A class to store the weighting matrix of a set of moment conditions.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("momentWeights", ...)</code>.
It is created my <code><a href="#topic+evalWeights">evalWeights</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>w</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>wSpec</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "momentWeights", i = "missing", j = "missing")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "momentWeights", i = "numeric", j = "missing")</code>: ... </p>
</dd>
<dt>evalGmmObj</dt><dd><p><code>signature(object = "momentModel", theta = "numeric", wObj = "momentWeights")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "momentWeights")</code>: ... </p>
</dd>
<dt>quadra</dt><dd><p><code>signature(w = "momentWeights", x = "matrixORnumeric", y = "matrixORnumeric")</code>: ... </p>
</dd>
<dt>quadra</dt><dd><p><code>signature(w = "momentWeights", x = "matrixORnumeric", y = "missing")</code>: ... </p>
</dd>
<dt>quadra</dt><dd><p><code>signature(w = "momentWeights", x = "missing", y = "missing")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "momentWeights")</code>: ... </p>
</dd>
<dt>solveGmm</dt><dd><p><code>signature(object = "allNLModel", wObj = "momentWeights")</code>: ... </p>
</dd>
<dt>solveGmm</dt><dd><p><code>signature(object = "linearModel", wObj = "momentWeights")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("momentWeights")
</code></pre>

<hr>
<h2 id='momFct-methods'>Methods for Function <code>momFct</code> in Package <span class="pkg">momentfit</span></h2><span id='topic+momFct-methods'></span><span id='topic+momFct'></span><span id='topic+momFct+2Cnumeric+2Cgelfit-method'></span>

<h3>Description</h3>

<p>The methods computes the moment matrix. It is use to create special
moment functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,gelfit'
momFct(eta, object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="momFct-methods_+3A_eta">eta</code></td>
<td>
<p>A vector that includes the coefficient and the Lagrange multipliers</p>
</td></tr>
<tr><td><code id="momFct-methods_+3A_object">object</code></td>
<td>
<p>An object of class <code>"gmmfit"</code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(eta = "numeric", object = "gelfit")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='Mroz'>
Labour data on married women
</h2><span id='topic+Mroz'></span>

<h3>Description</h3>

<p>The dataset was used by Mroz (1987) and in examples in Wooldridge (2016)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Mroz")</code></pre>


<h3>Format</h3>

<p>A data frame with 753 observations on the following 22 variables.
</p>

<dl>
<dt><code>inlf</code></dt><dd><p>=1 if in lab frce, 1975</p>
</dd>
<dt><code>hours</code></dt><dd><p>hours worked, 1975</p>
</dd>
<dt><code>kidslt6</code></dt><dd><p>number of kids &lt; 6 years</p>
</dd>
<dt><code>kidsge6</code></dt><dd><p>number of kids 6-18</p>
</dd>
<dt><code>age</code></dt><dd><p>woman's age in years</p>
</dd>
<dt><code>educ</code></dt><dd><p>years of schooling</p>
</dd>
<dt><code>wage</code></dt><dd><p>Estimated wage from earnings and hours</p>
</dd>
<dt><code>repwage</code></dt><dd><p>reported wage at interview in 1976</p>
</dd>
<dt><code>hushrs</code></dt><dd><p>hours worked by husband, 1975</p>
</dd>
<dt><code>husage</code></dt><dd><p>husband's age</p>
</dd>
<dt><code>huseduc</code></dt><dd><p>husband's years of schooling</p>
</dd>
<dt><code>huswage</code></dt><dd><p>husband's hourly wage, 1975</p>
</dd>
<dt><code>faminc</code></dt><dd><p>family income, 1975</p>
</dd>
<dt><code>mtr</code></dt><dd><p>federal marginal tax rate facing woman</p>
</dd>
<dt><code>motheduc</code></dt><dd><p>mother's years of schooling</p>
</dd>
<dt><code>fatheduc</code></dt><dd><p>father's years of schooling</p>
</dd>
<dt><code>unem</code></dt><dd><p>unemployment rate in county of residence</p>
</dd>
<dt><code>city</code></dt><dd><p>=1 if live in SMSA</p>
</dd>
<dt><code>exper</code></dt><dd><p>actual labor market experience</p>
</dd>
<dt><code>nwifeinc</code></dt><dd><p>(<code class="reqn">faminc - wage*hours)/1000</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>From Wooldridge (2016) online resources.
</p>


<h3>References</h3>

<p>Mroz, T.A. (1987), <em>The Sensitivity of an Empirical Model of
Married Women's Hours of Work to Economic and Statistical Assumptions</em>,
Econometrica, <b>55</b>, 657&ndash;678.
387&ndash;405.
</p>
<p>Wooldridge, J.M. (2016). <em>Introductory Econometrics, A Modern
Approach, 6th edition</em>, Cengage Learning.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 15.1 of Wooldridge (2016)

data(Mroz)
Mroz &lt;- subset(Mroz, hours&gt;0)
## I guess IID is assumed (That's how we get the same s.e.)
## By default a sandwich vcov is computed because it is 
## a just-identified model.
res4 &lt;- gmm4(log(wage)~educ, ~fatheduc, vcov="iid", data=Mroz)
summary(res4)

## If we adjust the variance of the residuals, however,
## we are a little off (very little)

summary(res4, df.adj=TRUE)


## Example 15.5 of Wooldridge (2016)
## Need to adjust for degrees of freedom in order
## to get the same s.e.
## The first stage F-test is very different though
## Cannot get the same even if do it manually
## with the linearHypothesis from the car package
model &lt;- momentModel(log(wage)~educ+exper+I(exper^2),
~exper+I(exper^2)+fatheduc+motheduc, vcov="iid", data=Mroz)
res &lt;- tsls(model)
summary(res, df.adj=TRUE)

</code></pre>

<hr>
<h2 id='nonlinearModel-class'>Class <code>"nonlinearModel"</code></h2><span id='topic+nonlinearModel-class'></span>

<h3>Description</h3>

<p>Class for moment-based models for which moment conditions are
orthogonality conditions between instruments and the residuals from a
nonlinear regression. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("nonlinearModel",
  ...)</code>.
It is generated my <code><a href="#topic+momentModel">momentModel</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>modelF</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>instF</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>theta0</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>fRHS</code>:</dt><dd><p>Object of class <code>"expression"</code> ~~ </p>
</dd>
<dt><code>fLHS</code>:</dt><dd><p>Object of class <code>"expressionORNULL"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>isEndo</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+regModel-class">regModel</a>"</code>, directly.
Class <code>"<a href="#topic+allNLModel-class">allNLModel</a>"</code>, directly.
Class <code>"<a href="#topic+momentModel-class">momentModel</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>Dresiduals</dt><dd><p><code>signature(object = "nonlinearModel")</code>: ... </p>
</dd>
<dt>merge</dt><dd><p><code>signature(x = "nonlinearModel", y = "nonlinearModel")</code>: ... </p>
</dd>
<dt>merge</dt><dd><p><code>signature(x = "snonlinearModel", y = "nonlinearModel")</code>: ... </p>
</dd>
<dt>model.matrix</dt><dd><p><code>signature(object = "nonlinearModel")</code>: ... </p>
</dd>
<dt>modelDims</dt><dd><p><code>signature(object = "nonlinearModel")</code>: ... </p>
</dd>
<dt>momentStrength</dt><dd><p><code>signature(object = "nonlinearModel")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "nonlinearModel")</code>: ... </p>
</dd>
<dt>restModel</dt><dd><p><code>signature(object = "nonlinearModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("nonlinearModel")
</code></pre>

<hr>
<h2 id='plot-methods'> ~~ Methods for Function <code>plot</code> from package <span class="pkg">graphics</span> ~~</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CANY-method'></span><span id='topic+plot+2Cmconfint-method'></span>

<h3>Description</h3>

<p>It plots the confidence region. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'ANY'
plot(x, y, ...) 

## S4 method for signature 'mconfint'
plot(x, y, main=NULL, xlab=NULL, ylab=NULL, 
                          pch=21, bg=1, Pcol=1, ylim=NULL, xlim=NULL,
                          add=FALSE, addEstimates=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>An object to plot</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p>On used for <code>"ANY"</code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_main">main</code></td>
<td>
<p>Optional title</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_xlab">xlab</code></td>
<td>
<p>Optional label for the x-axis.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ylab">ylab</code></td>
<td>
<p>Optional label for the y-axis.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_pch">pch</code></td>
<td>
<p>Type of points (see <code><a href="graphics.html#topic+points">points</a></code>).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_bg">bg</code></td>
<td>
<p>Background color for points.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_pcol">Pcol</code></td>
<td>
<p>The color for the points. If col is used, it is passed to
<code><a href="graphics.html#topic+polygon">polygon</a></code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_xlim">xlim</code></td>
<td>
<p>Optional range for the x-axis.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ylim">ylim</code></td>
<td>
<p>Optional range for the y-axis.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_add">add</code></td>
<td>
<p>If TRUE, the region is added to an existing plot.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_addestimates">addEstimates</code></td>
<td>
<p>Should we add the point estimate to the confidence
region? This option is only used when add is FALSE.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="graphics.html#topic+polygon">polygon</a></code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd>
<p>It uses the <code>plot</code> from package <span class="pkg">graphics</span>
</p>
</dd>
<dt><code>signature(object = "mconfint")</code></dt><dd>
<p>Plot the 2D confidence region.
</p>
</dd>
</dl>

<hr>
<h2 id='print-methods'> Methods for Function <code>print</code> in Package <span class="pkg">base</span></h2><span id='topic+print-methods'></span><span id='topic+print+2Cconfint-method'></span><span id='topic+print+2Cmconfint-method'></span><span id='topic+print+2CANY-method'></span><span id='topic+print+2CmomentModel-method'></span><span id='topic+print+2Cgmmfit-method'></span><span id='topic+print+2Cgelfit-method'></span><span id='topic+print+2Csgmmfit-method'></span><span id='topic+print+2CrlinearModel-method'></span><span id='topic+print+2CrslinearModel-method'></span><span id='topic+print+2CrsnonlinearModel-method'></span><span id='topic+print+2CrfunctionModel-method'></span><span id='topic+print+2CrformulaModel-method'></span><span id='topic+print+2CrnonlinearModel-method'></span><span id='topic+print+2CsummaryGmm-method'></span><span id='topic+print+2CsummaryGel-method'></span><span id='topic+print+2CsummarySysGmm-method'></span><span id='topic+print+2CspecTest-method'></span><span id='topic+print+2CmomentWeights-method'></span><span id='topic+print+2CsysMomentWeights-method'></span><span id='topic+print+2CsysModel-method'></span><span id='topic+print+2ChypothesisTest-method'></span><span id='topic+print+2CsSpec-method'></span>

<h3>Description</h3>

<p>Print method for all <code>"momentModel"</code>, <code>"gmmfit"</code>,
<code>"summaryGmm"</code> <code>"hypothesisTest"</code> and <code>"specTest"</code>  objects. 
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY")</code></dt><dd>
</dd>
<dt><code>signature(x = "momentModel")</code></dt><dd>
</dd>
<dt><code>signature(x = "sSpec")</code></dt><dd>
</dd>
<dt><code>signature(x = "confint")</code></dt><dd>
</dd>
<dt><code>signature(x = "mconfint")</code></dt><dd>
</dd>
<dt><code>signature(x = "sysModel")</code></dt><dd>
</dd>
<dt><code>signature(x = "sysMomentWeights")</code></dt><dd>
</dd>
<dt><code>signature(x = "gmmfit")</code></dt><dd>
</dd>
<dt><code>signature(x = "gelfit")</code></dt><dd>
</dd>
<dt><code>signature(x = "sgmmfit")</code></dt><dd>
</dd>
<dt><code>signature(x = "summaryGmm")</code></dt><dd>
</dd>
<dt><code>signature(x = "summaryGel")</code></dt><dd>
</dd>
<dt><code>signature(x = "summarySysGmm")</code></dt><dd>
</dd>
<dt><code>signature(x = "specTest")</code></dt><dd>
</dd>
<dt><code>signature(x = "rlinearModel")</code></dt><dd>
</dd>
<dt><code>signature(x = "rformulaModel")</code></dt><dd>
</dd>
<dt><code>signature(x = "rslinearModel")</code></dt><dd>
</dd>
<dt><code>signature(x = "rsnonlinearModel")</code></dt><dd>
</dd>
<dt><code>signature(x = "rnonlinearModel")</code></dt><dd>
</dd>
<dt><code>signature(x = "rfunctionModel")</code></dt><dd>
</dd>
<dt><code>signature(x = "hypothesisTest")</code></dt><dd>
</dd>
<dt><code>signature(x = "momentWeights")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='printRestrict-methods'> ~~ Methods for Function <code>printRestrict</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+printRestrict'></span><span id='topic+printRestrict-methods'></span><span id='topic+printRestrict+2CrlinearModel-method'></span><span id='topic+printRestrict+2CrformulaModel-method'></span><span id='topic+printRestrict+2CrslinearModel-method'></span><span id='topic+printRestrict+2CrnonlinearModel-method'></span><span id='topic+printRestrict+2CrsnonlinearModel-method'></span><span id='topic+printRestrict+2CrfunctionModel-method'></span>

<h3>Description</h3>

<p>It prints the detailed restrictions imposed on <code>"momentModel"</code> classes.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "rgelModels")</code></dt><dd>
</dd>  
<dt><code>signature(object = "rlinearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rnonlinearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rfunctionModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rformulaModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rslinearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "rsnonlinearModel")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)

## Unrestricted model
model1 &lt;- momentModel(y~x1+x2+x3+z1, ~x1+x2+z1+z2+z3+z4, data=simData)

## restricted model
R &lt;- matrix(c(1,1,0,0,0,0,0,2,0,0,0,0,0,1,-1),3,5, byrow=TRUE)
q &lt;- c(0,1,3)
rmodel1 &lt;- restModel(model1, R, q)
printRestrict(rmodel1)
</code></pre>

<hr>
<h2 id='quadra-methods'> ~~ Methods for Function <code>quadra</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+quadra'></span><span id='topic+quadra-methods'></span><span id='topic+quadra+2CmomentWeights+2CmatrixORnumeric+2CmatrixORnumeric-method'></span><span id='topic+quadra+2CmomentWeights+2CmatrixORnumeric+2Cmissing-method'></span><span id='topic+quadra+2CmomentWeights+2Cmissing+2Cmissing-method'></span><span id='topic+quadra+2CsysMomentWeights+2CmatrixORnumeric+2CmatrixORnumeric-method'></span><span id='topic+quadra+2CsysMomentWeights+2CmatrixORnumeric+2Cmissing-method'></span><span id='topic+quadra+2CsysMomentWeights+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>~~ Computes the quadratic form, where the center matrix is a class
<code>momentWeights</code> object ~~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'momentWeights,missing,missing'
quadra(w, x, y)

## S4 method for signature 'momentWeights,matrixORnumeric,missing'
quadra(w, x, y)

## S4 method for signature 'momentWeights,matrixORnumeric,matrixORnumeric'
quadra(w, x,
y)

## S4 method for signature 'sysMomentWeights,matrixORnumeric,matrixORnumeric'
quadra(w, x,
y)

## S4 method for signature 'sysMomentWeights,matrixORnumeric,missing'
quadra(w, x, y)

## S4 method for signature 'sysMomentWeights,missing,missing'
quadra(w, x, y)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadra-methods_+3A_w">w</code></td>
<td>
<p>An object of class <code>"momentWeights"</code></p>
</td></tr>
<tr><td><code id="quadra-methods_+3A_x">x</code></td>
<td>
<p>A matrix or numeric vector</p>
</td></tr>
<tr><td><code id="quadra-methods_+3A_y">y</code></td>
<td>
<p>A matrix or numeric vector</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(w = "momentWeights", x = "matrixORnumeric",  y =
    "matrixORnumeric")</code></dt><dd>
<p>It computes <code class="reqn">x'Wy</code>, where <code class="reqn">W</code> is the weighting matrix.
</p>
</dd>
<dt><code>signature(w = "momentWeights", x = "matrixORnumeric",  y =
    "missing")</code></dt><dd>
<p>It computes <code class="reqn">x'Wx</code>, where <code class="reqn">W</code> is the weighting matrix.  
</p>
</dd>
<dt><code>signature(w = "momentWeights", x = "missing",  y =
    "missing")</code></dt><dd>
<p>It computes <code class="reqn">W</code>, where <code class="reqn">W</code> is the weighting matrix.  When
<code class="reqn">W</code> is the inverse of the covariance matrix of the moment
conditions, it is saved as either a QR decompisition, a Cholesky
decomposition or a covariance matrix into the <code><a href="#topic+momentWeights">momentWeights</a></code>
object. The <code>quadra</code> method with no <code>y</code> and <code>x</code> is
therefore a way to invert it. The same applies to system of equations
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

gbar &lt;- evalMoment(model1, theta)
gbar &lt;- colMeans(gbar)

### Onjective function of GMM with identity matrix
wObj &lt;- evalWeights(model1, w="ident")
quadra(wObj, gbar)

### Onjective function of GMM with efficient weights
wObj &lt;- evalWeights(model1, theta)
quadra(wObj, gbar)

</code></pre>

<hr>
<h2 id='regModel-class'>Class <code>"regModel"</code></h2><span id='topic+regModel-class'></span>

<h3>Description</h3>

<p>A union class for <code>"linearModel"</code> and <code>"nonlinearModel"</code>
classes.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "regModel", i = "numeric", j = "missing")</code>: ... </p>
</dd>
<dt>evalDMoment</dt><dd><p><code>signature(object = "regModel")</code>: ... </p>
</dd>
<dt>evalMoment</dt><dd><p><code>signature(object = "regModel")</code>: ... </p>
</dd>
<dt>subset</dt><dd><p><code>signature(x = "regModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("regModel")
</code></pre>

<hr>
<h2 id='residuals-methods'> ~~ Methods for Function <code>residuals</code> in Package <span class="pkg">stats</span> ~~</h2><span id='topic+residuals-methods'></span><span id='topic+residuals+2CANY-method'></span><span id='topic+residuals+2ClinearModel-method'></span><span id='topic+residuals+2CnonlinearModel-method'></span><span id='topic+residuals+2CsysModel-method'></span><span id='topic+residuals+2CrsysModel-method'></span><span id='topic+residuals+2Cgmmfit-method'></span><span id='topic+residuals+2Cgelfit-method'></span><span id='topic+residuals+2Csgmmfit-method'></span>

<h3>Description</h3>

<p>It computes the residual for a given coefficient vector, when the model
is a linear of nonlinear regression with instruments. The method can be
called on a <code>momentModel</code> class for a given coefficient theta or on a
<code>gmmfit</code> object.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "rsysModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "linearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "nonlinearModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "gmmfit")</code></dt><dd>
</dd>
<dt><code>signature(object = "gelfit")</code></dt><dd>
</dd>
<dt><code>signature(object = "sgmmfit")</code></dt><dd>
</dd>
<dt><code>signature(object = "sysModel")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rchisq(200,5)
z1 &lt;- rnorm(200)
z2 &lt;- .2*x+rnorm(200)
y &lt;- x+rnorm(200)
dat &lt;- data.frame(y=y,z1=z1,x=x,z2=z2)
theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x, ~z1+z2, data=dat)

## residuals for a given theta
e &lt;- residuals(model1, theta)

## residuals of the fit
res &lt;- gmmFit(model1)
e &lt;- residuals(res)

</code></pre>

<hr>
<h2 id='restModel-methods'> ~~ Methods for Function <code>restModel</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+restModel'></span><span id='topic+restModel-methods'></span><span id='topic+restModel+2ClinearModel-method'></span><span id='topic+restModel+2CformulaModel-method'></span><span id='topic+restModel+2CslinearModel-method'></span><span id='topic+restModel+2CsnonlinearModel-method'></span><span id='topic+restModel+2CnonlinearModel-method'></span><span id='topic+restModel+2CfunctionModel-method'></span>

<h3>Description</h3>

<p>It converts <code>momentModel</code> objects into its restricted
counterpart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'linearModel'
restModel(object, R, rhs=NULL)

## S4 method for signature 'slinearModel'
restModel(object, R, rhs=NULL)

## S4 method for signature 'snonlinearModel'
restModel(object, R, rhs=NULL)

## S4 method for signature 'nonlinearModel'
restModel(object, R, rhs=NULL)

## S4 method for signature 'formulaModel'
restModel(object, R, rhs=NULL)

## S4 method for signature 'functionModel'
restModel(object, R, rhs=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restModel-methods_+3A_object">object</code></td>
<td>
<p>An object of class <code>"momentModel"</code> or
<code>"sysModel"</code>.</p>
</td></tr>  
<tr><td><code id="restModel-methods_+3A_r">R</code></td>
<td>
<p>Either a matrix or a vector of characters for
linear models and a list of formulas for nonlinear models</p>
</td></tr>
<tr><td><code id="restModel-methods_+3A_rhs">rhs</code></td>
<td>
<p>The right hand side of the linear restrictions. It is
ignored for nonlinear models.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "linearModel")</code></dt><dd>
<p>Method for object of class <code>linearModel</code>.
</p>
</dd>
<dt><code>signature(object = "linearGel")</code></dt><dd>
<p>Method for all classes related to <code>linearGel</code>.
</p>
</dd>
<dt><code>signature(object = "slinearModel")</code></dt><dd>
<p>Method for object of class <code>slinearModel</code>.
</p>
</dd>
<dt><code>signature(object = "snonlinearModel")</code></dt><dd>
<p>Method for object of class <code>snonlinearModel</code>.
</p>
</dd>
<dt><code>signature(object = "nonlinearModel")</code></dt><dd>
<p>Method for object of class <code>nonlinearModel</code>.
</p>
</dd>
<dt><code>signature(object = "nonlinearGel")</code></dt><dd>
<p>Method for object of class <code>nonlinearGel</code>.
</p>
</dd>
<dt><code>signature(object = "functionModel")</code></dt><dd>
<p>Method for object of class <code>functionModel</code>.
</p>
</dd>
<dt><code>signature(object = "functionGel")</code></dt><dd>
<p>Method for object of class <code>functionGel</code>.
</p>
</dd>
<dt><code>signature(object = "formulaModel")</code></dt><dd>
<p>Method for object of class <code>formulaModel</code>.
</p>
</dd>
<dt><code>signature(object = "formulaGel")</code></dt><dd>
<p>Method for object of class <code>formulaGel</code>.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)

## Unrestricted model
model1 &lt;- momentModel(y~x1+x2+x3+z1, ~x1+x2+z1+z2+z3+z4, data=simData)

## Using matrix R
R &lt;- matrix(c(1,1,0,0,0,0,0,2,0,0,0,0,0,1,-1),3,5, byrow=TRUE)
q &lt;- c(0,1,3)

rmodel1 &lt;- restModel(model1, R, q)
rmodel1

## Using character
## Many ways to write the constraints

R1 &lt;- c("x1","2*x2+z1=2", "4+x3*5=3")
rmodel1 &lt;- restModel(model1, R1)
rmodel1

## Works with interaction and identity function I()

model1 &lt;- momentModel(y~x1*x2+exp(x3)+I(z1^2), ~x1+x2+z1+z2+z3+z4, data=simData)
R1 &lt;- c("x1","exp(x3)+2*x1:x2", "I(z1^2)=3")
rmodel1 &lt;- restModel(model1, R1)
rmodel1

## nonlinear constraints on a linear model
## we need to convert the linear model into a nonlinear one

model &lt;- momentModel(y~x1+x2+x3+z1, ~x1+x2+z1+z2+z3+z4, data=simData)
NLmodel &lt;- as(model, "nonlinearModel")

## To avoid having unconventional parameter names, which happens
## when I() is used or with interaction, the X's and coefficients are
## renamed

NLmodel@parNames

## Restriction can be a list of formula or vector of characters
## For the latter, it will be converted into a list of formulas

R1 &lt;- c("theta2=2", "theta3=theta4^2")
rmod1 &lt;- restModel(NLmodel, R1)
res1 &lt;- gmmFit(rmod1)
res1
## recover the orignial form
coef(rmod1, coef(res1))

## with formulas

R2 &lt;- list(theta2~2, theta3~1/theta4)
rmod2 &lt;- restModel(NLmodel, R2)
res2 &lt;- gmmFit(rmod2)
res2
coef(rmod2, coef(res2))

## The same can be done with function based models

</code></pre>

<hr>
<h2 id='rformulaModel-class'>Class <code>"rformulaModel"</code></h2><span id='topic+rformulaModel-class'></span>

<h3>Description</h3>

<p>A class for restricted moment-based models for which moment conditions
are expressed using a list of formulas.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("rformulaModel", ...)</code>.
It is created by <code><a href="#topic+restModel-methods">restModel-methods</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>R</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>cstSpec</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>modelF</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>theta0</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>fRHS</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>fLHS</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>isEndo</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>isMDE</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+formulaModel-class">formulaModel</a>"</code>, directly.
Class <code>"<a href="#topic+rmomentModel-class">rmomentModel</a>"</code>, directly.
Class <code>"<a href="#topic+allNLModel-class">allNLModel</a>"</code>, by class &quot;formulaModel&quot;, distance 2.
Class <code>"<a href="#topic+momentModel-class">momentModel</a>"</code>, by class &quot;formulaModel&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "rformulaModel")</code>: ... </p>
</dd>
<dt>evalDMoment</dt><dd><p><code>signature(object = "rformulaModel")</code>: ... </p>
</dd>
<dt>getRestrict</dt><dd><p><code>signature(object = "rformulaModel")</code>: ... </p>
</dd>
<dt>gmmFit</dt><dd><p><code>signature(model = "rformulaModel")</code>: ... </p>
</dd>
<dt>modelDims</dt><dd><p><code>signature(object = "rformulaModel")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "rformulaModel")</code>: ... </p>
</dd>
<dt>printRestrict</dt><dd><p><code>signature(object = "rformulaModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("rformulaModel")
</code></pre>

<hr>
<h2 id='rfunctionModel-class'>Class <code>"rfunctionModel"</code></h2><span id='topic+rfunctionModel-class'></span>

<h3>Description</h3>

<p>A restricted moment-based model for which moment conditions are defined
by a function. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("rfunctionModel", ...)</code>.
It is created by <code><a href="#topic+restModel-methods">restModel-methods</a></code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>R</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>cstSpec</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>X</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
<dt><code>fct</code>:</dt><dd><p>Object of class <code>"function"</code> ~~ </p>
</dd>
<dt><code>dfct</code>:</dt><dd><p>Object of class <code>"functionORNULL"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>theta0</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>isEndo</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+functionModel-class">functionModel</a>"</code>, directly.
Class <code>"<a href="#topic+rmomentModel-class">rmomentModel</a>"</code>, directly.
Class <code>"<a href="#topic+allNLModel-class">allNLModel</a>"</code>, by class &quot;functionModel&quot;, distance 2.
Class <code>"<a href="#topic+momentModel-class">momentModel</a>"</code>, by class &quot;functionModel&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "rfunctionModel", i = "numeric", j = "missing")</code>: ... </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "rfunctionModel")</code>: ... </p>
</dd>
<dt>evalDMoment</dt><dd><p><code>signature(object = "rfunctionModel")</code>: ... </p>
</dd>
<dt>getRestrict</dt><dd><p><code>signature(object = "rfunctionModel")</code>: ... </p>
</dd>
<dt>modelDims</dt><dd><p><code>signature(object = "rfunctionModel")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "rfunctionModel")</code>: ... </p>
</dd>
<dt>printRestrict</dt><dd><p><code>signature(object = "rfunctionModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("rfunctionModel")
</code></pre>

<hr>
<h2 id='rhoFct'>GEL objective functions</h2><span id='topic+rhoFct'></span><span id='topic+rhoEL'></span><span id='topic+rhoET'></span><span id='topic+rhoEEL'></span><span id='topic+rhoREEL'></span><span id='topic+rhoHD'></span><span id='topic+rhoETHD'></span><span id='topic+rhoETEL'></span>

<h3>Description</h3>

<p>Functions that returns the GEL function <code class="reqn">\rho(g(\theta,x)'\lambda)</code>
and its derivatives. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhoET(gmat, lambda, derive = 0, k = 1)

rhoETEL(gmat, lambda, derive = 0, k = 1)

rhoEL(gmat, lambda, derive = 0, k = 1)

rhoEEL(gmat, lambda, derive = 0, k = 1)

rhoREEL(gmat, lambda, derive = 0, k = 1)

rhoHD(gmat, lambda, derive = 0, k = 1)

rhoETHD(gmat, lambda, derive = 0, k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhoFct_+3A_gmat">gmat</code></td>
<td>
<p>The <code class="reqn">n \times q</code> matrix of moments</p>
</td></tr>
<tr><td><code id="rhoFct_+3A_lambda">lambda</code></td>
<td>
<p>The <code class="reqn">q \times 1</code> vector of Lagrange multipliers.</p>
</td></tr> 
<tr><td><code id="rhoFct_+3A_derive">derive</code></td>
<td>
<p>An integer which indicates which derivative to return</p>
</td></tr>
<tr><td><code id="rhoFct_+3A_k">k</code></td>
<td>
<p>A numeric scaling factor that is required when <code>"gmat"</code> is
a matrix of time series which require smoothing. The value depends on
the kernel and is automatically set when the <code>"gelModels"</code> is
created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns the vector <code class="reqn">\rho(gmat \lambda)</code> when <code>derive=0</code>,
<code class="reqn">\rho'(gmat \lambda)</code> when <code>derive=1</code> and <code class="reqn">\rho''(gmat
  \lambda)</code> when <code>derive=2</code>.
</p>


<h3>References</h3>

<p>Anatolyev, S. (2005), GMM, GEL, Serial Correlation, and Asymptotic Bias. <em>Econometrica</em>, <b>73</b>, 983-1002.
</p>
<p>Kitamura, Yuichi (1997), Empirical Likelihood Methods With Weakly Dependent Processes.
<em>The Annals of Statistics</em>, <b>25</b>, 2084-2102.
</p>
<p>Kitamura, Y. and Otsu, T. and Evdokimov, K. (2013), Robustness,
Infinitesimal Neighborhoods and Moment Restrictions.
<em>Econometrica</em>, <b>81</b>, 1185-1201.
</p>
<p>Newey, W.K. and Smith, R.J. (2004), Higher Order Properties of GMM and 
Generalized Empirical Likelihood Estimators. <em>Econometrica</em>, <b>72</b>, 219-255.
</p>
<p>Smith, R.J. (2011), GEL Criteria for Moment Condition Models.
<em>Econometric Theory</em>, <b>27</b>(6), 1192&ndash;1235.
</p>

<hr>
<h2 id='rlinearModel-class'>Class <code>"rlinearModel"</code></h2><span id='topic+rlinearModel-class'></span>

<h3>Description</h3>

<p>A class for restricted moment-based models for which moment conditions
are orthogonality conditions between instruments and the residuals from
a linear regression. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("rlinearModel", ...)</code>.  
It is created by <code><a href="#topic+restModel-methods">restModel-methods</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cstLHS</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>cstRHS</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>cstSpec</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>modelF</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>instF</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>isEndo</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+linearModel-class">linearModel</a>"</code>, directly.
Class <code>"<a href="#topic+rmomentModel-class">rmomentModel</a>"</code>, directly.
Class <code>"<a href="#topic+regModel-class">regModel</a>"</code>, by class &quot;linearModel&quot;, distance 2.
Class <code>"<a href="#topic+momentModel-class">momentModel</a>"</code>, by class &quot;linearModel&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "rlinearModel")</code>: ... </p>
</dd>
<dt>getRestrict</dt><dd><p><code>signature(object = "rlinearModel")</code>: ... </p>
</dd>
<dt>gmmFit</dt><dd><p><code>signature(model = "rlinearModel")</code>: ... </p>
</dd>
<dt>model.matrix</dt><dd><p><code>signature(object = "rlinearModel")</code>: ... </p>
</dd>
<dt>modelDims</dt><dd><p><code>signature(object = "rlinearModel")</code>: ... </p>
</dd>
<dt>modelResponse</dt><dd><p><code>signature(object = "rlinearModel")</code>: ... </p>
</dd>
<dt>momentStrength</dt><dd><p><code>signature(object = "rlinearModel")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "rlinearModel")</code>: ... </p>
</dd>
<dt>printRestrict</dt><dd><p><code>signature(object = "rlinearModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("rlinearModel")
</code></pre>

<hr>
<h2 id='rmomentModel-class'>Class <code>"rmomentModel"</code></h2><span id='topic+rmomentModel-class'></span>

<h3>Description</h3>

<p>A union class for all restricted moment-based models.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>gelFit</dt><dd><p><code>signature(model = "rmomentModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("rmomentModel")
</code></pre>

<hr>
<h2 id='rnonlinearModel-class'>Class <code>"rnonlinearModel"</code></h2><span id='topic+rnonlinearModel-class'></span>

<h3>Description</h3>

<p>A class for restricted moment-based models for which moment conditions
are orthogonality conditions between instruments and the residuals from
a nonlinear regression.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("rnonlinearModel",
  ...)</code>.
It is created by <code><a href="#topic+restModel-methods">restModel-methods</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>R</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>cstSpec</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>modelF</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>instF</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>theta0</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>fRHS</code>:</dt><dd><p>Object of class <code>"expression"</code> ~~ </p>
</dd>
<dt><code>fLHS</code>:</dt><dd><p>Object of class <code>"expressionORNULL"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>isEndo</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+nonlinearModel-class">nonlinearModel</a>"</code>, directly.
Class <code>"<a href="#topic+rmomentModel-class">rmomentModel</a>"</code>, directly.
Class <code>"<a href="#topic+regModel-class">regModel</a>"</code>, by class &quot;nonlinearModel&quot;, distance 2.
Class <code>"<a href="#topic+allNLModel-class">allNLModel</a>"</code>, by class &quot;nonlinearModel&quot;, distance 2.
Class <code>"<a href="#topic+momentModel-class">momentModel</a>"</code>, by class &quot;nonlinearModel&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "rnonlinearModel")</code>: ... </p>
</dd>
<dt>evalDMoment</dt><dd><p><code>signature(object = "rnonlinearModel")</code>: ... </p>
</dd>
<dt>getRestrict</dt><dd><p><code>signature(object = "rnonlinearModel")</code>: ... </p>
</dd>
<dt>gmmFit</dt><dd><p><code>signature(model = "rnonlinearModel")</code>: ... </p>
</dd>
<dt>modelDims</dt><dd><p><code>signature(object = "rnonlinearModel")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "rnonlinearModel")</code>: ... </p>
</dd>
<dt>printRestrict</dt><dd><p><code>signature(object = "rnonlinearModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("rnonlinearModel")
</code></pre>

<hr>
<h2 id='rslinearModel-class'>Class <code>"rslinearModel"</code></h2><span id='topic+rslinearModel-class'></span>

<h3>Description</h3>

<p>A class for restricted system of linear equations.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("rslinearModel",
  ...)</code>.
It is created by <code><a href="#topic+restModel-methods">restModel-methods</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cstLHS</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>cstRHS</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>cstSpec</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>modelT</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>instT</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>eqnNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>sameMom</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>SUR</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>isEndo</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+slinearModel-class">slinearModel</a>"</code>, directly.
Class <code>"<a href="#topic+rsysModel-class">rsysModel</a>"</code>, directly.
Class <code>"<a href="#topic+sysModel-class">sysModel</a>"</code>, by class &quot;slinearModel&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "rslinearModel", i = "numeric", j = "missing")</code>: ... </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "rslinearModel")</code>: ... </p>
</dd>
<dt>evalDMoment</dt><dd><p><code>signature(object = "rslinearModel")</code>: ... </p>
</dd>
<dt>evalMoment</dt><dd><p><code>signature(object = "rslinearModel")</code>: ... </p>
</dd>
<dt>evalWeights</dt><dd><p><code>signature(object = "rslinearModel")</code>: ... </p>
</dd>
<dt>getRestrict</dt><dd><p><code>signature(object = "rslinearModel")</code>: ... </p>
</dd>
<dt>gmmFit</dt><dd><p><code>signature(model = "rslinearModel")</code>: ... </p>
</dd>
<dt>model.matrix</dt><dd><p><code>signature(object = "rslinearModel")</code>: ... </p>
</dd>
<dt>modelDims</dt><dd><p><code>signature(object = "rslinearModel")</code>: ... </p>
</dd>
<dt>modelResponse</dt><dd><p><code>signature(object = "rslinearModel")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "rslinearModel")</code>: ... </p>
</dd>
<dt>printRestrict</dt><dd><p><code>signature(object = "rslinearModel")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "rslinearModel")</code>: ... </p>
</dd>
<dt>solveGmm</dt><dd><p><code>signature(object = "rslinearModel", wObj = "sysMomentWeights")</code>: ... </p>
</dd>
<dt>ThreeSLS</dt><dd><p><code>signature(model = "rslinearModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("rslinearModel")
</code></pre>

<hr>
<h2 id='rsnonlinearModel-class'>Class <code>"rsnonlinearModel"</code></h2><span id='topic+rsnonlinearModel-class'></span>

<h3>Description</h3>

<p>A class for restricted systems of nonlinear equations.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("rsnonlinearModel", ...)</code>.
It is created by <code><a href="#topic+restModel-methods">restModel-methods</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>R</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>cstSpec</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>instT</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>theta0</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>fRHS</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>fLHS</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>eqnNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>sameMom</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>SUR</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>isEndo</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+snonlinearModel-class">snonlinearModel</a>"</code>, directly.
Class <code>"<a href="#topic+rsysModel-class">rsysModel</a>"</code>, directly.
Class <code>"<a href="#topic+sysModel-class">sysModel</a>"</code>, by class &quot;snonlinearModel&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;rsnonlinearModel&quot; in the signature.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("rsnonlinearModel")
</code></pre>

<hr>
<h2 id='rsysModel-class'>Class <code>"rsysModel"</code></h2><span id='topic+rsysModel-class'></span>

<h3>Description</h3>

<p>A union class for all systems of equations. (see <code>link{systemGmm}</code>)
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;rsysModel&quot; in the signature.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("rsysModel")
</code></pre>

<hr>
<h2 id='setCoef-methods'>Methods for Function <code>setCoef</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+setCoef'></span><span id='topic+setCoef-methods'></span><span id='topic+setCoef+2CmomentModel-method'></span><span id='topic+setCoef+2CsysModel-method'></span>

<h3>Description</h3>

<p>The method validates the coefficient theta and returns a coefficient
object in a format that satisfies the moment model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'momentModel'
setCoef(model, theta)
## S4 method for signature 'sysModel'
setCoef(model, theta)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setCoef-methods_+3A_model">model</code></td>
<td>
<p>A moment model object.</p>
</td></tr>  
<tr><td><code id="setCoef-methods_+3A_theta">theta</code></td>
<td>
<p>A coefficient object. The type depends on the model
object. See the examples below.</p>
</td></tr> 
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "momentModel")</code></dt><dd>
<p>Methods for all single equation models including the restricted
ones.    
</p>
</dd>
<dt><code>signature(object = "sysModel")</code></dt><dd>
<p>Methods for all system of equations models including the restricted
ones.  
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>### A few system of equation models:
data(simData)
h &lt;- list(~z1+z2+z3, ~x3+z1+z2+z3+z4, ~x3+x4+z1+z2+z3)
nlg &lt;- list(Supply=y1~theta0+theta1*x1+theta2*z2,
            Demand1=y2~alpha0+alpha1*x1+alpha2*x2+alpha3*x3,
            Demand2=y3~beta0+beta1*x3+beta2*x4+beta3*z1)
g &lt;- list(Supply=y1~x1+z2, Demand1=y2~x1+x2+x3, Demand2=y3~x3+x4+z1)
theta0 &lt;- list(c(theta0=1,theta1=2,theta2=3),
               c(alpha0=1,alpha1=2,alpha2=3, alpha3=4),
               c(beta0=1,beta1=2,beta2=3,beta3=4))
nlin &lt;- sysMomentModel(nlg, h, theta0, data=simData)
lin &lt;- sysMomentModel(g, h, data=simData)

### from numeric vector to the proper format with names:
setCoef(nlin, 1:11)

### reorder the equation and name the coefficients
setCoef(nlin, list(Demand1=1:4, Supply=1:3, Demand2=1:4))

### reorder the coefficint to match the order in the model
tet &lt;- do.call("c", theta0)
set.seed(112233)
setCoef(nlin, tet[sample(11)])

### It validates length and names and provide source of errors
## Not run: 
setCoef(nlin, list(Demand1=1:4, Supply=1:2, Demand2=1:4))
names(tet)[4] &lt;- "gamma3"
setCoef(nlin, tet)
setCoef(nlin, list(Demand1=1:4, Supply=1:3, Demand4=1:4))

## End(Not run)

### a single equation model
single &lt;- momentModel(nlg[[1]], h[[1]], theta0[[1]], data=simData)
setCoef(single, c(theta1=4, theta0=6, theta2=8))
setCoef(single, 1:3)
</code></pre>

<hr>
<h2 id='sfunctionModel-class'>Class <code>"sfunctionModel"</code></h2><span id='topic+sfunctionModel-class'></span>

<h3>Description</h3>

<p>A class for systems of nonlinear equations. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("sfunctionModel", ...)</code>.
It is created by <code><a href="#topic+momentModel">momentModel</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>X</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
<dt><code>fct</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>dfct</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>    
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>theta0</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>eqnNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>sameMom</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>SUR</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+sysModel-class">sysModel</a>"</code>, directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("sfunctionModel")
</code></pre>

<hr>
<h2 id='sgmmfit-class'>Class <code>"sgmmfit"</code></h2><span id='topic+sgmmfit-class'></span>

<h3>Description</h3>

<p>Class to store fitted system of equations obtained using the GMM method.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("sgmmfit", ...)</code>.
It is created by <code><a href="#topic+gmmFit">gmmFit</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>theta</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>convergence</code>:</dt><dd><p>Object of class <code>"numericORNULL"</code> ~~ </p>
</dd>
<dt><code>convIter</code>:</dt><dd><p>Object of class <code>"numericORNULL"</code> ~~ </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"callORNULL"</code> ~~ </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>wObj</code>:</dt><dd><p>Object of class <code>"sysMomentWeights"</code> ~~ </p>
</dd>
<dt><code>niter</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>efficientGmm</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"sysModel"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>bread</dt><dd><p><code>signature(x = "sgmmfit")</code>: ... </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "sgmmfit")</code>: ... </p>
</dd>
<dt>hypothesisTest</dt><dd><p><code>signature(object.u = "missing", object.r = "sgmmfit")</code>: ... </p>
</dd>
<dt>hypothesisTest</dt><dd><p><code>signature(object.u = "sgmmfit", object.r = "missing")</code>: ... </p>
</dd>
<dt>hypothesisTest</dt><dd><p><code>signature(object.u = "sgmmfit", object.r = "sgmmfit")</code>: ... </p>
</dd>
<dt>meatGmm</dt><dd><p><code>signature(object = "sgmmfit")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "sgmmfit")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "sgmmfit")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "sgmmfit")</code>: ... </p>
</dd>
<dt>specTest</dt><dd><p><code>signature(object = "sgmmfit", which = "missing")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "sgmmfit")</code>: ... </p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "sgmmfit")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("sgmmfit")
</code></pre>

<hr>
<h2 id='show-methods'> ~~ Methods for Function <code>show</code> in Package <span class="pkg">methods</span> ~~</h2><span id='topic+show-methods'></span><span id='topic+show+2CANY-method'></span><span id='topic+show+2Cconfint-method'></span><span id='topic+show+2Cmconfint-method'></span><span id='topic+show+2CmomentModel-method'></span><span id='topic+show+2CsysModel-method'></span><span id='topic+show+2Cgmmfit-method'></span><span id='topic+show+2Cgelfit-method'></span><span id='topic+show+2Csgmmfit-method'></span><span id='topic+show+2CspecTest-method'></span><span id='topic+show+2CsummaryGmm-method'></span><span id='topic+show+2CsummaryGel-method'></span><span id='topic+show+2CsummarySysGmm-method'></span><span id='topic+show+2CmomentWeights-method'></span><span id='topic+show+2CsysMomentWeights-method'></span><span id='topic+show+2CsSpec-method'></span><span id='topic+show+2ChypothesisTest-method'></span>

<h3>Description</h3>

<p>Display method for all objects.   
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd>
</dd>
<dt><code>signature(object = "confint")</code></dt><dd>
</dd>
<dt><code>signature(object = "mconfint")</code></dt><dd> 
</dd>
<dt><code>signature(object = "sSpec")</code></dt><dd> 
</dd>
<dt><code>signature(object = "momentModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "sysModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "gmmfit")</code></dt><dd>
</dd>
<dt><code>signature(object = "gelfit")</code></dt><dd>
</dd>
<dt><code>signature(object = "sgmmfit")</code></dt><dd>
</dd>
<dt><code>signature(object = "specTest")</code></dt><dd>
</dd>
<dt><code>signature(object = "summarySysGmm")</code></dt><dd>
</dd>
<dt><code>signature(object = "summaryGmm")</code></dt><dd>
</dd>
<dt><code>signature(object = "summaryGel")</code></dt><dd>
</dd>
<dt><code>signature(object = "hypothesisTest")</code></dt><dd>
</dd>
<dt><code>signature(object = "momentWeights")</code></dt><dd>
</dd>
<dt><code>signature(object = "sysMomentWeights")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='simData'>
Simulated data.
</h2><span id='topic+simData'></span>

<h3>Description</h3>

<p>This dataset is used in several documentation files to illustrate the
different functionality of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("simData")</code></pre>


<h3>Format</h3>

<p>A data frame with 50 observations on the following 12 variables. See
the examples for the method used to generate them.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>z1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>x1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>z2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>x2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>z3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>x3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>x4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>z4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>z5</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Here is how the data was simulated
set.seed(1122)
n &lt;- 50
x1 &lt;- rchisq(n,5)
x2 &lt;- rchisq(n,5)
x3 &lt;- rnorm(n)
x4 &lt;- rnorm(n)
z1 &lt;- .2*x1+rnorm(n)
z2 &lt;- .2*x2+rnorm(n)
z3 &lt;- rnorm(n)
z4 &lt;- rnorm(n)
z5 &lt;- rnorm(n)
y &lt;- y1 &lt;- x1+rnorm(n)
y2 &lt;- 2*x1+rnorm(n)
y3 &lt;- 0.5*x2+rnorm(n)
simData &lt;- data.frame(y=y, y1=y1,y3=y3,y2=y2, z1=z1,x1=x1,z2=z2,x2=x2,z3=z3,x3=x3,
                  x4=x4,z4=z4,z5=z5)
</code></pre>

<hr>
<h2 id='slinearModel-class'>Class <code>"slinearModel"</code></h2><span id='topic+slinearModel-class'></span>

<h3>Description</h3>

<p>A class for systems of linear equations.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("slinearModel", ...)</code>.
It is created by <code><a href="#topic+momentModel">momentModel</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>modelT</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>instT</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>eqnNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>sameMom</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>SUR</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>isEndo</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+sysModel-class">sysModel</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "slinearModel", i = "numeric", j = "missing")</code>: ... </p>
</dd>
<dt>merge</dt><dd><p><code>signature(x = "slinearModel", y = "linearModel")</code>: ... </p>
</dd>
<dt>model.matrix</dt><dd><p><code>signature(object = "slinearModel")</code>: ... </p>
</dd>
<dt>modelDims</dt><dd><p><code>signature(object = "slinearModel")</code>: ... </p>
</dd>
<dt>modelResponse</dt><dd><p><code>signature(object = "slinearModel")</code>: ... </p>
</dd>
<dt>restModel</dt><dd><p><code>signature(object = "slinearModel")</code>: ... </p>
</dd>
<dt>solveGmm</dt><dd><p><code>signature(object = "slinearModel", wObj = "sysMomentWeights")</code>: ... </p>
</dd>
<dt>ThreeSLS</dt><dd><p><code>signature(model = "slinearModel")</code>: ... </p>
</dd>
<dt>tsls</dt><dd><p><code>signature(model = "slinearModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("slinearModel")
</code></pre>

<hr>
<h2 id='snonlinearModel-class'>Class <code>"snonlinearModel"</code></h2><span id='topic+snonlinearModel-class'></span>

<h3>Description</h3>

<p>A class for systems of nonlinear equations. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("snonlinearModel", ...)</code>.
It is created by <code><a href="#topic+momentModel">momentModel</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code> ~~ </p>
</dd>
<dt><code>instT</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>theta0</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>parNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>fRHS</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>fLHS</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>eqnNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>vcovOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>centeredVcov</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>sameMom</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>SUR</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>varNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>isEndo</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>omit</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>survOptions</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>sSpec</code>:</dt><dd><p>Object of class <code>"sSpec"</code> ~~ </p>
</dd>
<dt><code>smooth</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+sysModel-class">sysModel</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "snonlinearModel", i = "numeric", j = "missing")</code>: ... </p>
</dd>
<dt>merge</dt><dd><p><code>signature(x = "snonlinearModel", y = "nonlinearModel")</code>: ... </p>
</dd>
<dt>model.matrix</dt><dd><p><code>signature(object = "snonlinearModel")</code>: ... </p>
</dd>
<dt>modelDims</dt><dd><p><code>signature(object = "snonlinearModel")</code>: ... </p>
</dd>
<dt>solveGmm</dt><dd><p><code>signature(object = "snonlinearModel", wObj = "sysMomentWeights")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("snonlinearModel")
</code></pre>

<hr>
<h2 id='solveGel-methods'> ~~ Methods for Function <code>solveGel</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+solveGel'></span><span id='topic+solveGel-methods'></span><span id='topic+solveGel+2CmomentModel-method'></span>

<h3>Description</h3>

<p>It fits a moment-based model using GEL methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'momentModel'
solveGel(object, gelType="EL", theta0=NULL,
                                  lambda0=NULL, lamSlv=NULL,
                                  coefSlv=c("optim","nlminb","constrOptim"),
                                  rhoFct=NULL, 
                                  lControl=list(), tControl=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveGel-methods_+3A_object">object</code></td>
<td>
<p>An object of class <code>"gelModels"</code></p>
</td></tr>
<tr><td><code id="solveGel-methods_+3A_geltype">gelType</code></td>
<td>
<p>The type of GEL. It is either <code>"EL"</code>,
<code>"ET"</code>,  <code>"EEL"</code>,  <code>"HD"</code>,  <code>"ETEL"</code> or
<code>"ETHD"</code>.</p>
</td></tr>
<tr><td><code id="solveGel-methods_+3A_theta0">theta0</code></td>
<td>
<p>The vector of coefficients for the starting values used
in minimization algorithm. If NULL, the starting values in the object is
used. For linear models, it must be provided because
<code>"linearGel"</code> objects do not have a theta0 slot.</p>
</td></tr>
<tr><td><code id="solveGel-methods_+3A_lambda0">lambda0</code></td>
<td>
<p>The <code class="reqn">q \times 1</code> vector of starting values for the
Lagrange multipliers. By default a zero vector is used.</p>
</td></tr>
<tr><td><code id="solveGel-methods_+3A_lamslv">lamSlv</code></td>
<td>
<p>An alternative solver for the Lagrange multiplier. By
default, either <code><a href="#topic+Wu_lam">Wu_lam</a></code>, <code><a href="#topic+EEL_lam">EEL_lam</a></code>,
<code><a href="#topic+REEL_lam">REEL_lam</a></code> or <code><a href="#topic+getLambda">getLambda</a></code> is
used.</p>
</td></tr>
<tr><td><code id="solveGel-methods_+3A_coefslv">coefSlv</code></td>
<td>
<p>Minimization solver for the coefficient vector.</p>
</td></tr>	    
<tr><td><code id="solveGel-methods_+3A_rhofct">rhoFct</code></td>
<td>
<p>An alternative objective function for GEL. This argument
is only used if we want to fit the model with a different GEL
method. see <code><a href="#topic+rhoFct">rhoFct</a></code>.</p>
</td></tr> 
<tr><td><code id="solveGel-methods_+3A_lcontrol">lControl</code></td>
<td>
<p>A list of controls for the Lagrange multiplier
algorithm.</p>
</td></tr>
<tr><td><code id="solveGel-methods_+3A_tcontrol">tControl</code></td>
<td>
<p>A list of controls for the coefficient algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following:
</p>
<table>
<tr><td><code>theta</code></td>
<td>
<p>The vector of solution</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The vector of Lagrange multiplier</p>
</td></tr>
<tr><td><code>lconvergence</code></td>
<td>
<p>convergence code for the Lagrange multiplier. 0
means normal convergence.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>convergence code for the coefficients. 0 means
normal convergence. For higher numbers, see <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="stats.html#topic+constrOptim">constrOptim</a></code> or  <code><a href="stats.html#topic+nlminb">nlminb</a></code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "momentModel")</code></dt><dd>
<p>The method applies to all GEL classes.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

## Get a good starting value
theta0 &lt;- gmmFit(model1)@theta

## EL by default, with Wu algorithm
res2 &lt;- solveGel(model1, theta0=theta0)

## Change solver parameters
res3 &lt;- solveGel(model1, theta0=theta0,
                 tControl=list(method="Nelder", control=list(maxit=2000)))

</code></pre>

<hr>
<h2 id='solveGmm-methods'> ~~ Methods for Function <code>solveGmm</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+solveGmm'></span><span id='topic+solveGmm-methods'></span><span id='topic+solveGmm+2CallNLModel+2CmomentWeights-method'></span><span id='topic+solveGmm+2ClinearModel+2CmomentWeights-method'></span><span id='topic+solveGmm+2CslinearModel+2CsysMomentWeights-method'></span><span id='topic+solveGmm+2CrslinearModel+2CsysMomentWeights-method'></span><span id='topic+solveGmm+2CsnonlinearModel+2CsysMomentWeights-method'></span><span id='topic+solveGmm+2CsfunctionModel+2CsysMomentWeights-method'></span><span id='topic+solveGmm+2CrnonlinearModel+2CmomentWeights-method'></span>

<h3>Description</h3>

<p>The main function to get the GMM solution for a given weighting matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'linearModel,momentWeights'
solveGmm(object, wObj, theta0=NULL,
...)

## S4 method for signature 'allNLModel,momentWeights'
solveGmm(object, wObj, theta0=NULL,
algo=c("optim","nlminb"), ...)

## S4 method for signature 'rnonlinearModel,momentWeights'
solveGmm(object, wObj, theta0=NULL,
...)

## S4 method for signature 'slinearModel,sysMomentWeights'
solveGmm(object, wObj, theta0=NULL)

## S4 method for signature 'rslinearModel,sysMomentWeights'
solveGmm(object, wObj, theta0=NULL)

## S4 method for signature 'snonlinearModel,sysMomentWeights'
solveGmm(object, wObj,
theta0=NULL, ...)

## S4 method for signature 'sfunctionModel,sysMomentWeights'
solveGmm(object, wObj,
theta0=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveGmm-methods_+3A_object">object</code></td>
<td>
<p>A moment-based model</p>
</td></tr>
<tr><td><code id="solveGmm-methods_+3A_theta0">theta0</code></td>
<td>
<p>The vector of coefficients for the starting values used
in <code><a href="stats.html#topic+optim">optim</a></code>. If NULL, the starting values in the object if
used. For system of equations, it is a list of vectors.</p>
</td></tr>
<tr><td><code id="solveGmm-methods_+3A_wobj">wObj</code></td>
<td>
<p>An object of class <code>"momentWeights"</code> or
<code>"sysMomentWeights"</code>.</p>
</td></tr>
<tr><td><code id="solveGmm-methods_+3A_algo">algo</code></td>
<td>
<p>The numerical algorithm to minimize the objective function.</p>
</td></tr>
<tr><td><code id="solveGmm-methods_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following:
</p>
<table>
<tr><td><code>theta</code></td>
<td>
<p>The vector of solution</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>convergence code. 0 means normal convergence. For
higher numbers, see <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "allNLMoment", wObj = "momentWeights")</code></dt><dd>
<p>Method to solve either nonlinear regressions or models in which moments
are computed with a function. The objective is minimized using optim.
</p>
</dd>
<dt><code>signature(object = "rnonlinearModel", wObj = "momentWeights")</code></dt><dd>
<p>Method to solve restricted nonlinear models. It computes the analytical
solution.
</p>
</dd>
<dt><code>signature(object = "linearModel", wObj = "momentWeights")</code></dt><dd>
<p>Method to solve linear models. It computes the analytical solution.
</p>
</dd>
<dt><code>signature(object = "slinearModel", wObj = "sysMomentWeights")</code></dt><dd>
<p>Method to solve system of linear models. It computes the analytical solution.
</p>
</dd>
<dt><code>signature(object = "rslinearModel", wObj = "sysMomentWeights")</code></dt><dd>
<p>Method to solve system of linear models in which restrictions have been
imposed on the coefficients. It computes the analytical solution.
</p>
</dd>
<dt><code>signature(object = "slinearModel", wObj = "sysMomentWeights")</code></dt><dd>
<p>Method to solve system of nonlinear models. The solution is obtained
with optim using the analytical derivatives.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

## A manual two-step GMM
w0 &lt;- evalWeights(model1, w="ident")
theta0 &lt;- solveGmm(model1, w0)$theta
w &lt;- evalWeights(model1, theta0)
theta1 &lt;- solveGmm(model1, w)$theta 
</code></pre>

<hr>
<h2 id='specTest-class'>Class <code>"specTest"</code></h2><span id='topic+specTest-class'></span>

<h3>Description</h3>

<p>A class to store results from a specification test.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("specTest", ...)</code>.
It is created my <code><a href="#topic+specTest-methods">specTest-methods</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>test</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>testname</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "specTest")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "specTest")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("specTest")
</code></pre>

<hr>
<h2 id='specTest-methods'> ~~ Methods for Function <code>specTest</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+specTest'></span><span id='topic+specTest-methods'></span><span id='topic+specTest+2Cgmmfit+2Cmissing-method'></span><span id='topic+specTest+2Cgelfit+2Cmissing-method'></span><span id='topic+specTest+2Csgmmfit+2Cmissing-method'></span><span id='topic+specTest+2Cgmmfit+2Cnumeric-method'></span>

<h3>Description</h3>

<p>It computes tests of specification for GMM fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gmmfit,missing'
specTest(object, which, df.adj=FALSE, wObj=NULL)

## S4 method for signature 'sgmmfit,missing'
specTest(object, which, df.adj=FALSE, wObj=NULL)

## S4 method for signature 'gmmfit,numeric'
specTest(object, which)

## S4 method for signature 'gelfit,missing'
specTest(object, which,
                    type = c("All", "LR", "LM", "J"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specTest-methods_+3A_object">object</code></td>
<td>
<p>GMM or GEL fit object</p>
</td></tr>
<tr><td><code id="specTest-methods_+3A_which">which</code></td>
<td>
<p>Which sub-moment conditions to test.</p>
</td></tr>
<tr><td><code id="specTest-methods_+3A_df.adj">df.adj</code></td>
<td>
<p>Should we adjust the covariance matrix of the moment
conditions for degrees of freedom. If <code>TRUE</code>
the covariance matrix is multiplied by <code>n/(n-k)</code>, where
<code>n</code> is the sample size and <code>k</code> is the number of
coefficients. For heteroscedastic robust covariance matrix,
adjusting is equivalent to computing HC1 while not adjusting is
HC0.</p>
</td></tr>
<tr><td><code id="specTest-methods_+3A_wobj">wObj</code></td>
<td>
<p>An object of class <code>gmmWeights</code>. If NULL (the
recommended value), the optimal weights is computed at the
fitted coefficient estimates. It is used by
<code><a href="#topic+hypothesisTest">hypothesisTest</a></code> if one wants the LR statistics to be
computed using the same weights for the restricted and unrestricted
model.</p>
</td></tr>
<tr><td><code id="specTest-methods_+3A_type">type</code></td>
<td>
<p>For GEL, three specification tests are available</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "gmmfit", which="missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "sgmmfit", which="missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "gmmfit", which="numeric")</code></dt><dd>
</dd>
</dl>


<h3>References</h3>

<p>Eichenbaum, M. and Hansen L. and Singleton, K. (1985). A time Series
Analysis of Representative Agent Models of Consumption and Leisure
Choise under Uncertainty. <em>Quarterly Journal of Economics</em>,
<b>103</b>, 51&ndash;78.
</p>
<p>Hayashi, F. (2000). <em>Econometrics</em>, New Jersey: Princeton
University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

res &lt;- gmmFit(model1)
specTest(res)

## Hayashi Example 3.3 (there is not result in the book but
## that's how we would do it for YEAR=1967
data(Griliches)
dat &lt;- subset(Griliches, YEAR==67)
model &lt;- momentModel(LW~S+EXPR+IQ, ~S+EXPR+AGE+MED, data=dat, vcov="MDS")
res &lt;- gmmFit(model)
## testing the orthogonality conditions of S
specTest(res, 2)

</code></pre>

<hr>
<h2 id='sSpec-class'>Class <code>"sSpec"</code></h2><span id='topic+sSpec-class'></span>

<h3>Description</h3>

<p>A class to store the specifications of the kernel used to smooth moment
conditions. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("sSpec", ...)</code>.
It is created by <code><a href="#topic+kernapply-methods">kernapply-methods</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>kernel</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>bw</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>w</code>:</dt><dd><p>Object of class <code>"tskernel"</code> ~~ </p>
</dd>
<dt><code>bwMet</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "sSpec")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "sSpec")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("sSpec")
</code></pre>

<hr>
<h2 id='stsls-class'>Class <code>"stsls"</code></h2><span id='topic+stsls-class'></span>

<h3>Description</h3>

<p>A class to store a fitted system of equations obtained using the
two-stage least squares method.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("stsls", ...)</code>.
It is created my <code><a href="#topic+tsls-methods">tsls-methods</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>theta</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>convergence</code>:</dt><dd><p>Object of class <code>"numericORNULL"</code> ~~ </p>
</dd>
<dt><code>convIter</code>:</dt><dd><p>Object of class <code>"numericORNULL"</code> ~~ </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"callORNULL"</code> ~~ </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>wObj</code>:</dt><dd><p>Object of class <code>"sysMomentWeights"</code> ~~ </p>
</dd>
<dt><code>niter</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>efficientGmm</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"sysModel"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+sgmmfit-class">sgmmfit</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;stsls&quot; in the signature.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("stsls")
</code></pre>

<hr>
<h2 id='summary-methods'> ~~ Methods for Function <code>summary</code> in Package <span class="pkg">base</span> ~~</h2><span id='topic+summary'></span><span id='topic+summary-methods'></span><span id='topic+summary+2Cgmmfit-method'></span><span id='topic+summary+2Cgelfit-method'></span><span id='topic+summary+2Csgmmfit-method'></span>

<h3>Description</h3>

<p>Compute several results from a moment based model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gmmfit'
summary(object, testStrength=TRUE, ...)

## S4 method for signature 'gelfit'
summary(object, ...)

## S4 method for signature 'sgmmfit'
summary(object, testStrength=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>
<p>A fit object from the package (GMM and GEL are the only
methods for now)</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_teststrength">testStrength</code></td>
<td>
<p>Should the first stage F-statistics be computed?</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+vcov-methods">vcov-methods</a></code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "gmmfit")</code></dt><dd>
</dd>
<dt><code>signature(object = "gmmfit")</code></dt><dd>
</dd>
<dt><code>signature(object = "sgmmfit")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

res &lt;- gmmFit(model1)
summary(res)

## Fixed and True Weights matrix
## Consider the moment of a normal distribution:
## Using the first three non centered moments

g &lt;- function(theta, x)
{
mu &lt;- theta[1]
sig2 &lt;- theta[2]
m1 &lt;- x-mu
m2 &lt;- x^2-mu^2-sig2
m3 &lt;- x^3-mu^3-3*mu*sig2
cbind(m1,m2,m3)
}

dg &lt;- function(theta, x)
{
mu &lt;- theta[1]
sig2 &lt;- theta[2]
G &lt;- matrix(c(-1,-2*mu,-3*mu^2-3*sig2, 0, -1, -3*mu),3,2)
}

x &lt;- simData$x3
model &lt;- momentModel(g, x, c(mu=.1, sig2=1.5), vcov="iid")
res1 &lt;- gmmFit(model)
summary(res1)
## Same results (that's because the moment vcov is centered by default)
W &lt;- solve(var(cbind(x,x^2,x^3)))
res2 &lt;- gmmFit(model, weights=W)
res2
## If is therefore more efficient in this case to do the following:
summary(res2, breadOnly=TRUE)

</code></pre>

<hr>
<h2 id='summaryGel-class'>Class <code>"summaryGel"</code></h2><span id='topic+summaryGel-class'></span>

<h3>Description</h3>

<p>Class to store the summary of a model fitted by GEL.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("summaryGel", ...)</code>.
It is created by <code>link{summary-methods}</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coef</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>specTest</code>:</dt><dd><p>Object of class <code>"specTest"</code> ~~ </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"momentModel"</code> ~~ </p>
</dd>
<dt><code>lambda</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>convergence</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>lconvergence</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>impProb</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>gelType</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>restrictedLam</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "summaryGel")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "summaryGel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("summaryGel")
</code></pre>

<hr>
<h2 id='summaryGmm-class'>Class <code>"summaryGmm"</code></h2><span id='topic+summaryGmm-class'></span>

<h3>Description</h3>

<p>A class to store the summary of a model fitted by GMM.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("summaryGmm", ...)</code>.
It is created by <code>link{summary-methods}</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coef</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>specTest</code>:</dt><dd><p>Object of class <code>"specTest"</code> ~~ </p>
</dd>
<dt><code>strength</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"momentModel"</code> ~~ </p>
</dd>
<dt><code>sandwich</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>convergence</code>:</dt><dd><p>Object of class <code>"numericORNULL"</code> ~~ </p>
</dd>
<dt><code>convIter</code>:</dt><dd><p>Object of class <code>"numericORNULL"</code> ~~ </p>
</dd>
<dt><code>wSpec</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>niter</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>df.adj</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>breadOnly</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "summaryGmm")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "summaryGmm")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("summaryGmm")
</code></pre>

<hr>
<h2 id='summarySysGmm-class'>Class <code>"summarySysGmm"</code></h2><span id='topic+summarySysGmm-class'></span>

<h3>Description</h3>

<p>A class to store the summary of a system of equations fitted by GMM.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("summarySysGmm", ...)</code>.
It is created by <code><a href="#topic+summary-methods">summary-methods</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coef</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>specTest</code>:</dt><dd><p>Object of class <code>"specTest"</code> ~~ </p>
</dd>
<dt><code>strength</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"sysModel"</code> ~~ </p>
</dd>
<dt><code>sandwich</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>convergence</code>:</dt><dd><p>Object of class <code>"numericORNULL"</code> ~~ </p>
</dd>
<dt><code>convIter</code>:</dt><dd><p>Object of class <code>"numericORNULL"</code> ~~ </p>
</dd>
<dt><code>wSpec</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>niter</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>df.adj</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>breadOnly</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "summarySysGmm")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "summarySysGmm")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("summarySysGmm")
</code></pre>

<hr>
<h2 id='sysModel-class'>Class <code>"sysModel"</code></h2><span id='topic+sysModel-class'></span>

<h3>Description</h3>

<p>A union class for all systems of equations.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "sysModel", i = "missing", j = "list")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "sysModel", i = "missing", j = "missing")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "sysModel", i = "numeric", j = "list")</code>: ... </p>
</dd>
<dt>Dresiduals</dt><dd><p><code>signature(object = "sysModel")</code>: ... </p>
</dd>
<dt>evalDMoment</dt><dd><p><code>signature(object = "sysModel")</code>: ... </p>
</dd>
<dt>evalGmmObj</dt><dd><p><code>signature(object = "sysModel", theta = "list", wObj = "sysMomentWeights")</code>: ... </p>
</dd>
<dt>evalMoment</dt><dd><p><code>signature(object = "sysModel")</code>: ... </p>
</dd>
<dt>evalWeights</dt><dd><p><code>signature(object = "sysModel")</code>: ... </p>
</dd>
<dt>getRestrict</dt><dd><p><code>signature(object = "sysModel")</code>: ... </p>
</dd>
<dt>gmmFit</dt><dd><p><code>signature(model = "sysModel")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "sysModel")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "sysModel")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "sysModel")</code>: ... </p>
</dd>
<dt>subset</dt><dd><p><code>signature(x = "sysModel")</code>: ... </p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "sysModel")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("sysModel")
</code></pre>

<hr>
<h2 id='sysMomentModel'>Constructor for <code>"sysMomentModel"</code> classes</h2><span id='topic+sysMomentModel'></span>

<h3>Description</h3>

<p>It builds the object of either class <code>"slinearModel"</code> or
<code>"snonlinearModel"</code>, which are system of equations based on moment
conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sysMomentModel(g, h=NULL, theta0=NULL, grad=NULL, 
            vcov = c("iid", "HAC", "MDS", "CL"),
            vcovOptions=list(), centeredVcov = TRUE,
            data=parent.frame(),na.action="na.omit",
            survOptions=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sysMomentModel_+3A_g">g</code></td>
<td>
<p>A list of linear or nonlinear regression formulas for each
equation in the system.</p>
</td></tr>
<tr><td><code id="sysMomentModel_+3A_h">h</code></td>
<td>
<p>A list of linear formulas for the instruments in each
equation in the system.</p>
</td></tr>
<tr><td><code id="sysMomentModel_+3A_theta0">theta0</code></td>
<td>
<p>A list of vectors of starting values. It is required
only when the equations are nonlinear, in which case, it must be a
list of named vector, with the names corresponding to the coefficient
names in the regression formulas.</p>
</td></tr>
<tr><td><code id="sysMomentModel_+3A_grad">grad</code></td>
<td>
<p>A list of functions that returns the derivative of the
moment functions. Only used if <code>g</code> is a list of functions.</p>
</td></tr>
<tr><td><code id="sysMomentModel_+3A_vcov">vcov</code></td>
<td>
<p>Assumption on the properties of the moment conditions. By
default, they are weakly dependant processes. For <code>MDS</code>, we
assume that the conditions are martingale difference sequences, which
implies they are serially uncorrelated, but may be
heteroscedastic. There is a difference between <code>iid</code> and
<code>MDS</code> only when <code>g</code> is a formula. In that case, residuals
are assumed homoscedastic as well as serially uncorrelated. For type
<code>CL</code>, clustered covariance matrix is computed. The options are
then included in <code>vcovOptions</code> (see <code><a href="sandwich.html#topic+meatCL">meatCL</a></code>).</p>
</td></tr>
<tr><td><code id="sysMomentModel_+3A_vcovoptions">vcovOptions</code></td>
<td>
<p>A list of options for the covariance matrix of the
moment conditions. See <code><a href="sandwich.html#topic+vcovHAC">vcovHAC</a></code> for the default values.</p>
</td></tr>
<tr><td><code id="sysMomentModel_+3A_centeredvcov">centeredVcov</code></td>
<td>
<p>Should the moment function be centered when
computing its covariance matrix. Doing so may improve inference.</p>
</td></tr>
<tr><td><code id="sysMomentModel_+3A_data">data</code></td>
<td>
<p>A data.frame or a matrix with column names (Optional). </p>
</td></tr>
<tr><td><code id="sysMomentModel_+3A_na.action">na.action</code></td>
<td>
<p>Action to take for missing values. If missing values
are present and the option is set to <code>"na.pass"</code>, the model won't
be estimable.</p>
</td></tr>
<tr><td><code id="sysMomentModel_+3A_survoptions">survOptions</code></td>
<td>
<p>If needed, a list with the type of survey weights and
the weights as a numeric vector, data.frame or formula. The type is either
<code>"sampling"</code> or <code>"fequency"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'sysMomentModel' returns an object of one of the subclasses of
<code>"sysMomentModel"</code>.
</p>


<h3>References</h3>

<p>Hayashi, F. (2000). <em>Econometrics</em>, New Jersey: Princeton
University Press.
</p>
<p>Andrews DWK (1991),
Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.
<em>Econometrica</em>, <b>59</b>,
817&ndash;858.
</p>
<p>Newey WK &amp; West KD (1987), A Simple, Positive Semi-Definite,
Heteroskedasticity and Autocorrelation Consistent Covariance
Matrix. <em>Econometrica</em>, <b>55</b>, 703&ndash;708.
</p>
<p>Newey WK &amp; West KD (1994), Automatic Lag Selection in Covariance
Matrix Estimation. <em>Review of Economic Studies</em>, <b>61</b>, 631-653.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1122)
x1 &lt;- rchisq(50,5)
x2 &lt;- rchisq(50,5)
x3 &lt;- rnorm(50)
x4 &lt;- rnorm(50)
z1 &lt;- .2*x1+rnorm(50)
z2 &lt;- .2*x2+rnorm(50)
z3 &lt;- rnorm(50)
z4 &lt;- rnorm(50)
z5 &lt;- rnorm(50)
y1 &lt;- x1+rnorm(50)
y2 &lt;- 2*x1+rnorm(50)
y3 &lt;- 0.5*x2+rnorm(50)
dat &lt;- data.frame(y1=y1,y3=y3,y2=y2, z1=z1,x1=x1,z2=z2,x2=x2,z3=z3,x3=x3,
                  x4=x4,z4=z4,z5=z5)

g1 &lt;- y1~x1+x4; h1 &lt;- ~z1+z2+z3+z4+x4
g2 &lt;- y2~x1+x2+x3; h2 &lt;- ~z1+z2+z3+z4+x3
g3 &lt;- y3~x2+x3+x4; h3 &lt;- ~z2+z3+z4+x3+x4
g &lt;- list(g1,g2,g3)
h &lt;- list(h1,h2,h3)

smodel &lt;- sysMomentModel(g, h, data=dat)

## not really nonlinear
nlg &lt;- list(y1~theta0+theta1*x1+theta2*x4,
            y2~alpha0+alpha1*x1+alpha2*x2+alpha3*x3,
            y3~beta0+beta1*x2+beta2*x3+beta3*x4)
theta0 &lt;- list(c(theta0=1,theta1=2,theta2=3),
              c(alpha0=1,alpha1=2,alpha2=3, alpha3=4),
              c(beta0=1,beta1=2,beta2=3,beta3=4))
snmodel &lt;- sysMomentModel(nlg, h, theta0, data=dat)


</code></pre>

<hr>
<h2 id='sysMomentWeights-class'>Class <code>"sysMomentWeights"</code></h2><span id='topic+sysMomentWeights-class'></span>

<h3>Description</h3>

<p>A class to store the weighting matrix of the moment conditions from a
system of equations.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("sysMomentWeights", ...)</code>.
It is created by the <code><a href="#topic+evalWeights">evalWeights</a></code> method.
</p>


<h3>Slots</h3>


<dl>
<dt><code>w</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>wSpec</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>Sigma</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
<dt><code>momNames</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>eqnNames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>sameMom</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "sysMomentWeights", i = "missing", j = "list")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "sysMomentWeights", i = "numeric", j = "list")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "sysMomentWeights", i = "numeric", j = "missing")</code>: ... </p>
</dd>
<dt>evalGmmObj</dt><dd><p><code>signature(object = "sysModel", theta = "list", wObj = "sysMomentWeights")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "sysMomentWeights")</code>: ... </p>
</dd>
<dt>quadra</dt><dd><p><code>signature(w = "sysMomentWeights", x = "matrixORnumeric", y = "matrixORnumeric")</code>: ... </p>
</dd>
<dt>quadra</dt><dd><p><code>signature(w = "sysMomentWeights", x = "matrixORnumeric", y = "missing")</code>: ... </p>
</dd>
<dt>quadra</dt><dd><p><code>signature(w = "sysMomentWeights", x = "missing", y = "missing")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "sysMomentWeights")</code>: ... </p>
</dd>
<dt>solveGmm</dt><dd><p><code>signature(object = "rslinearModel", wObj = "sysMomentWeights")</code>: ... </p>
</dd>
<dt>solveGmm</dt><dd><p><code>signature(object = "slinearModel", wObj = "sysMomentWeights")</code>: ... </p>
</dd>
<dt>solveGmm</dt><dd><p><code>signature(object = "snonlinearModel", wObj = "sysMomentWeights")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("sysMomentWeights")
</code></pre>

<hr>
<h2 id='systemGmm-doc'>A guide to estimating systems of equations</h2><span id='topic+systemGmm'></span>

<h3>Description</h3>

<p>This document is meant to describe how to create system of equations
objects, estimating them and peforming hypothesis tests.
</p>


<h3>Details</h3>

<p>Instread of repeating the same example for each method, we are going
through all methods and classes for systems of equations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)

## first, we create an sysGmm object
g1 &lt;- y1~x1+x4; h1 &lt;- ~x4+z1+z2+z3+z4
g2 &lt;- y2~x1+x2+x3; h2 &lt;- ~x3+z1+z2+z3+z4
g3 &lt;- y3~x2+x3+x4; h3 &lt;- ~x3+x4+z1+z2+z3+z4
g &lt;- list(g1,g2,g3)
h &lt;- list(h1,h2,h3)
smodel &lt;- sysMomentModel(g, h, data=simData, vcov="MDS")

## The show or print method
smodel

## The ']' method
smodel[1:2]
smodel[1] ## becomes a one equation model

## equation by equation 2SLS
tsls(smodel)

## or manually
lapply(1:3, function(i) coef(tsls(smodel[i])))

## Fitting the model by two-step GMM
res &lt;- gmmFit(smodel)

## testing Overidentifying restrictions
specTest(res)

## All info using the summary method
## which includes equation by equation measures of
## the instrument stengths
summary(res)

### When the error id iid (homoscedastic), we have a
### FIVE estimator with 2SLS  as the first step
smodel &lt;- sysMomentModel(g, h, data=simData, vcov="iid")
gmmFit(smodel)

### When the error is iid (homoscedastic), 
### all instruments are the same, and the first step is 2SLS,
### we have 3SLS
smodel &lt;- sysMomentModel(g, ~x4+z1+z2+z3+z4, data=simData, vcov="iid")
gmmFit(smodel, initW='tsls')

### When the error is iid (homoscedastic), 
### the instruments are the same and are the union of all regressors,
### we have SUR
smodel &lt;- sysMomentModel(g, NULL, data=simData, vcov="iid")
gmmFit(smodel, initW='tsls')

############ Restricted models ##################

## unrestricted
smodel &lt;- sysMomentModel(g, h, data=simData, vcov="MDS")
res &lt;- gmmFit(smodel)

## no cross-equation restrictions
R1 &lt;- list(c("x1=-12*x4"), character(), c("x2=0.8", "x4=0.3"))
rm1 &lt;- restModel(smodel, R1)
(res1 &lt;- gmmFit(rm1))

## Cross equation restrictions
R2&lt;- c("Eqn1.x1=1", "Eqn2.x1=Eqn3.x2")
rm2 &lt;- restModel(smodel, R2)
(es2 &lt;- gmmFit(rm2))## no longer expressed as a system

## testing the restriction

hypothesisTest(res, res1, type="LR")
hypothesisTest(res, res1, type="LM")
hypothesisTest(res, res1, type="Wald")

</code></pre>

<hr>
<h2 id='ThreeSLS-methods'> ~~ Methods for Function <code>ThreeSLS</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+ThreeSLS'></span><span id='topic+ThreeSLS-methods'></span><span id='topic+ThreeSLS+2CslinearModel-method'></span><span id='topic+ThreeSLS+2CrslinearModel-method'></span>

<h3>Description</h3>

<p>Method to estimate system of equations by Three-Stage least squares
(3SLS) or, as a special case, by Seemingly Unrelatd Regressions (SUR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'slinearModel'
ThreeSLS(model, coefOnly=FALSE, qrZ=NULL,
Sigma=NULL)
## S4 method for signature 'rslinearModel'
ThreeSLS(model, coefOnly=FALSE, qrZ=NULL,
Sigma=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThreeSLS-methods_+3A_model">model</code></td>
<td>
<p>An object of class <code>"slinearModel"</code> in which
instruments are the same in each equation and the error terms are
homoscedastic.</p>
</td></tr>
<tr><td><code id="ThreeSLS-methods_+3A_coefonly">coefOnly</code></td>
<td>
<p>Should the method return the only the coefficients or
create an object of class <code>"sgmmfit"</code>.</p>
</td></tr>
<tr><td><code id="ThreeSLS-methods_+3A_qrz">qrZ</code></td>
<td>
<p>The qr decomposition of the common instruments. It is
mostly used by <code><a href="#topic+gmmFit">gmmFit</a></code> to avoid recomputing it in
iterative GMM or CUE. It should not be used directly unless the user
knows what he is doing.</p>
</td></tr>
<tr><td><code id="ThreeSLS-methods_+3A_sigma">Sigma</code></td>
<td>
<p>The covariance matrix of the residuals. If not provided,
it is computed using the residuals of the equation by equation
two-stage least squares. It should not be used directly unless the
user knows what he is doing.</p>
</td></tr> 
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "slinearModel")</code></dt><dd>
<p>The method is specifically for system of linear models with the same
instruments and homoscedastic errors. It becomes SUR as a special case
when the instruments are the union of all regressors.
</p>
</dd>
<dt><code>signature(model = "rslinearModel")</code></dt><dd>
<p>This method is for restricted models that does not impose cross-equation
restrictions. With such restrictions 3SLS is not possible as we can
no longer write the model as a system of equations.
</p>
</dd>
</dl>

<hr>
<h2 id='tsls-class'>Class <code>"tsls"</code></h2><span id='topic+tsls-class'></span>

<h3>Description</h3>

<p>Class that contains a fitted model using two-stage least squares
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("tsls", ...)</code>.
It is created my the 
</p>


<h3>Slots</h3>


<dl>
<dt><code>theta</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>convergence</code>:</dt><dd><p>Object of class <code>"numericORNULL"</code> ~~ </p>
</dd>
<dt><code>convIter</code>:</dt><dd><p>Object of class <code>"numericORNULL"</code> ~~ </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"callORNULL"</code> ~~ </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>wObj</code>:</dt><dd><p>Object of class <code>"momentWeights"</code> ~~ </p>
</dd>
<dt><code>niter</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>efficientGmm</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"momentModel"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+gmmfit-class">gmmfit</a>"</code>, directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("tsls")
</code></pre>

<hr>
<h2 id='tsls-methods'> ~~ Methods for Function <code>tsls</code> in Package <span class="pkg">momentfit</span> ~~</h2><span id='topic+tsls'></span><span id='topic+tsls-methods'></span><span id='topic+tsls+2ClinearModel-method'></span><span id='topic+tsls+2CslinearModel-method'></span>

<h3>Description</h3>

<p>It estimates a linear model using two-stage least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'linearModel'
tsls(model)

## S4 method for signature 'slinearModel'
tsls(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsls-methods_+3A_model">model</code></td>
<td>
<p>An object of class <code>linearModel</code> or
<code>slinearModel</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "linearModel")</code></dt><dd>
</dd>
<dt><code>signature(model = "slinearModel")</code></dt><dd>
<p>2SLS for equation by equation estimation of a system of equations.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)
res &lt;- tsls(model1)
summary(res)

## Econometrics, Fumio Hayashi (2000)
## Empirical exercises (b) and (c)
data(Griliches)
Griliches$YEAR &lt;- as.factor(Griliches$YEAR)
model1  &lt;- momentModel(LW~S+IQ+EXPR+TENURE+RNS+SMSA+YEAR-1,
                   ~S+EXPR+TENURE+RNS+SMSA+YEAR+MED+KWW+MRT+AGE-1,
                   data=Griliches, vcov="MDS")
res &lt;- tsls(model1)
summary(res)
</code></pre>

<hr>
<h2 id='update-methods'> ~~ Methods for Function <code>update</code> in Package <span class="pkg">stats</span> ~~</h2><span id='topic+update-methods'></span><span id='topic+update+2CANY-method'></span><span id='topic+update+2Clist-method'></span><span id='topic+update+2Cgmmfit-method'></span><span id='topic+update+2CmomentModel-method'></span><span id='topic+update+2Cgelfit-method'></span>

<h3>Description</h3>

<p>The method is used to refit a model with either a different
method or with modifications to the <code>momentModel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gmmfit'
update(object, ..., evaluate=TRUE)

## S4 method for signature 'momentModel'
update(object, ...)

## S4 method for signature 'gelfit'
update(object, newModel=NULL, ...,
evaluate=TRUE)

## S4 method for signature 'list'
update(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update-methods_+3A_object">object</code></td>
<td>
<p>An object produced by <code>"gelFit"</code>, <code>"gmmFit"</code>
or a model. It can also be a list, in which case, it is used to
change elements of a list. </p>
</td></tr>  
<tr><td><code id="update-methods_+3A_...">...</code></td>
<td>
<p>Arguments to modify the model or the GMM method</p>
</td></tr>
<tr><td><code id="update-methods_+3A_newmodel">newModel</code></td>
<td>
<p>When provided, the new model is estimated using the
same specification. For example, it is particularly useful to
estimate the restricted model using the same optim specification as
the unrestricted model.</p>
</td></tr>
<tr><td><code id="update-methods_+3A_evaluate">evaluate</code></td>
<td>
<p>The modified <code>call</code> argument is only evaluated
when evaluate is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd>
<p>That just calls <code>"update"</code> from the <code>"stats"</code> package.
</p>
</dd>
<dt><code>signature(object = "gmmfit")</code></dt><dd>
</dd>
<dt><code>signature(object = "momentModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "list")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rchisq(200,5)
z1 &lt;- rnorm(200)
z2 &lt;- .2*x+rnorm(200)
y &lt;- x+rnorm(200)
dat &lt;- data.frame(y=y,z1=z1,x=x,z2=z2)
theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x, ~z1+z2, data=dat)

(res &lt;- gmmFit(model1))

## lets change to iterative
update(res, type="iter")

## Let change the HAC specification in the model1 object
## to MDS
update(res, vcov="MDS")


</code></pre>

<hr>
<h2 id='vcov-methods'> ~~ Methods for Function <code>vcov</code> in Package <span class="pkg">stats</span> ~~</h2><span id='topic+vcov-methods'></span><span id='topic+vcov+2Cgmmfit-method'></span><span id='topic+vcov+2CmomentModel-method'></span><span id='topic+vcov+2CsysModel-method'></span><span id='topic+vcov+2Cgelfit-method'></span><span id='topic+vcov+2Csgmmfit-method'></span><span id='topic+vcov+2Ctsls-method'></span>

<h3>Description</h3>

<p>Computes the covariance matrix of the coefficient estimated by GMM or GEL. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gmmfit'
vcov(object, sandwich=NULL, df.adj=FALSE,
breadOnly=FALSE, modelVcov=NULL)

## S4 method for signature 'sgmmfit'
vcov(object, sandwich=NULL, df.adj=FALSE,
breadOnly=FALSE, modelVcov=NULL)

## S4 method for signature 'tsls'
vcov(object, sandwich=TRUE, df.adj=FALSE)

## S4 method for signature 'gelfit'
vcov(object, withImpProb=FALSE, tol=1e-10,
                        robToMiss=FALSE)

## S4 method for signature 'momentModel'
vcov(object, theta)

## S4 method for signature 'sysModel'
vcov(object, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov-methods_+3A_object">object</code></td>
<td>
<p>A fitted model or a model, For fitted models, it
computes the covariance matrix of the estimators. For models, it
computes the covariance matrix of the moment conditions, in which
case, the coefficient vector must be provided. </p>
</td></tr>
<tr><td><code id="vcov-methods_+3A_theta">theta</code></td>
<td>
<p>Coefficient vector to compute the covariance matrix of
the moment conditions.</p>
</td></tr>
<tr><td><code id="vcov-methods_+3A_sandwich">sandwich</code></td>
<td>
<p>Should we compute the sandwich covariance matrix. This is
only necessary if the weighting matrix is not the optimal one, or if
we think it is a bad estimate of it. If <code>NULL</code>, it will be set
to &quot;TRUE&quot; for One-Step GMM, which includes just-identified GMM like
IV, and &quot;FALSE&quot; otherwise. </p>
</td></tr>
<tr><td><code id="vcov-methods_+3A_df.adj">df.adj</code></td>
<td>
<p>Should we adjust for degrees of freedom. If <code>TRUE</code>
the covariance matrix is multiplied by <code>n/(n-k)</code>, where
<code>n</code> is the sample size and <code>k</code> is the number of
coefficients. For heteroscedastic robust covariance matrix,
adjusting is equivalent to computing HC1 while not adjusting is
HC0.</p>
</td></tr>
<tr><td><code id="vcov-methods_+3A_breadonly">breadOnly</code></td>
<td>
<p>If <code>TRUE</code>, the covariance matrix is set to the
bread (see details below).</p>
</td></tr>
<tr><td><code id="vcov-methods_+3A_modelvcov">modelVcov</code></td>
<td>
<p>Should be one of &quot;iid&quot;, &quot;MDS&quot; or &quot;HAC&quot;. It is meant
to change the way the variance of the moments is computed. If it is
set to a different specification included in the model,
<code>sandwich</code> is set to <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="vcov-methods_+3A_withimpprob">withImpProb</code></td>
<td>
<p>Should we compute the moments with the implied
probabilities</p>
</td></tr>
<tr><td><code id="vcov-methods_+3A_tol">tol</code></td>
<td>
<p>Any diagonal less than <code>"tol"</code> is set to tol</p>
</td></tr>
<tr><td><code id="vcov-methods_+3A_robtomiss">robToMiss</code></td>
<td>
<p>Should we compute a covariance matrix that is robust
to misspecification?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>sandwich=FALSE</code>, then it returns <code class="reqn">(G'V^{-1}G)^{-1}/n</code>, where
<code class="reqn">G</code> and <code class="reqn">V</code> are respectively the matrix of average derivatives
and the covariance matrix of the moment conditions. If it is
<code>TRUE</code>, it returns <code class="reqn">(G'WG)^{-1}G'WVWG(G'WG)^{-1}/n</code>,
where <code class="reqn">W</code> is the weighting matrix used to obtain the vector of
estimates.
</p>
<p>If <code>breadOnly=TRUE</code>, it returns <code class="reqn">(G'WG)^{-1}/n</code>,
where the value of <code class="reqn">W</code> depends on the type of GMM. For two-step GMM,
it is the first step weighting matrix, for one-step GMM, it is either
the identity matrix or the fixed weighting matrix that was provided when
<code><a href="#topic+gmmFit">gmmFit</a></code> was called, for iterative GMM, it is the weighting
matrix used in the last step. For CUE, the result is identical to
<code>sandwich=FALSE</code> and <code>beadOnly=FALSE</code>, because the
weighting and coefficient estimates are obtained simultaneously, which
makes <code class="reqn">W</code> identical to <code class="reqn">V</code>.
</p>
<p><code>breadOnly=TRUE</code> should therefore be used with caution because it
will produce valid standard errors only if the weighting matrix
converges to the the inverse of the covariance matrix of the moment
conditions.
</p>
<p>For <code>"tsls"</code> objects, <code>sandwich</code> is TRUE by default. If we
assume that the error term is iid, then setting it to FALSE to result in
the usual <code class="reqn">\sigma^2(\hat{X}'\hat{X})^{-1}</code> covariance matrix. If
<code>FALSE</code>, it returns a robust covariance matrix determined by the
value of <code>vcov</code> in the <code>momentModel</code>. 
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "gmmfit")</code></dt><dd>
<p>For any model estimated by any GMM methods.  
</p>
</dd>
<dt><code>signature(object = "gelfit")</code></dt><dd>
<p>For any model estimated by any GMM methods.  
</p>
</dd>
<dt><code>signature(object = "sgmmfit")</code></dt><dd>
<p>For any system of equations estimated by any GMM methods.  
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

## optimal matrix
res &lt;- gmmFit(model1)
vcov(res)

## not the optimal matrix
res &lt;- gmmFit(model1, weights=diag(3))
vcov(res, TRUE)

## Model with heteroscedasticity
## MDS is for models with no autocorrelation.
## No restrictions are imposed on the structure of the
## variance of the moment conditions
model2 &lt;- momentModel(y~x1, ~z1+z2, data=simData, vcov="MDS")
res &lt;- tsls(model2)

## HC0 type of robust variance
vcov(res, sandwich=TRUE)
## HC1 type of robust variance
vcov(res, sandwich=TRUE, df.adj=TRUE)

## Fixed and True Weights matrix
## Consider the moment of a normal distribution:
## Using the first three non centered moments

g &lt;- function(theta, x)
{
mu &lt;- theta[1]
sig2 &lt;- theta[2]
m1 &lt;- x-mu
m2 &lt;- x^2-mu^2-sig2
m3 &lt;- x^3-mu^3-3*mu*sig2
cbind(m1,m2,m3)
}

dg &lt;- function(theta, x)
{
mu &lt;- theta[1]
sig2 &lt;- theta[2]
G &lt;- matrix(c(-1,-2*mu,-3*mu^2-3*sig2, 0, -1, -3*mu),3,2)
}

x &lt;- simData$x3

model &lt;- momentModel(g, x, c(mu=.1, sig2=1.5), vcov="iid")
res1 &lt;- gmmFit(model)
summary(res1)
## Same results (that's because the moment vcov is centered by default)
W &lt;- solve(var(cbind(x,x^2,x^3)))
res2 &lt;- gmmFit(model, weights=W)
res2
## If is therefore more efficient in this case to do the following:
## the option breadOnly of summary() is passed to vcov()
summary(res2, breadOnly=TRUE)
</code></pre>

<hr>
<h2 id='vcovHAC-methods'> ~~ Methods for Function <code>vcovHAC</code> in Package <span class="pkg">sandwich</span> ~~</h2><span id='topic+vcovHAC-methods'></span><span id='topic+vcovHAC+2CmomentModel-method'></span>

<h3>Description</h3>

<p>Methods to compute the HAC covariance matrix of the moment matrix ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "momentModel")</code></dt><dd>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(simData)
theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

# a warning is given if the model is not set as being HAC
vcovHAC(model1, theta)

model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData, vcov="HAC",vcovOptions=list(kernel="B"))
vcovHAC(model1, theta)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
