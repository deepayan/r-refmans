<!DOCTYPE html><html lang="en"><head><title>Help for package hamlet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hamlet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hamlet-package'>
<p>Hierarchical Optimal Matching and Machine Learning Toolbox</p></a></li>
<li><a href='#extendsymrange'>
<p>Extend range of variable limits while retaining a point of symmetricity</p></a></li>
<li><a href='#hmap'>
<p>Plot-region based heatmap</p></a></li>
<li><a href='#hmap.annotate'>
<p>Add a row and column annotations to a plot-region based heatmap built with 'hmap'</p></a></li>
<li><a href='#hmap.key'>
<p>Add a color key to a plot-region based heatmap built with 'hmap'</p></a></li>
<li><a href='#match.allocate'>
<p>Allocation of matched units to intervention arms</p></a></li>
<li><a href='#match.bb'>
<p>Branch and Bound algorithm implementation for performing multigroup non-bipartite matching</p></a></li>
<li><a href='#match.dummy'>
<p>Create dummy individuals or sinks to a data matrix or a distance/dissimilarity matrix</p></a></li>
<li><a href='#match.ga'>
<p>Non-bipartite matching using the Genetic Algorithm (GA)</p></a></li>
<li><a href='#match.mat2vec'>
<p>Transform a binary matching matrix to a matching vector</p></a></li>
<li><a href='#match.vec2mat'>
<p>Transform a matching vector to a binary matching matrix</p></a></li>
<li><a href='#mem.getcomp'>
<p>Extract per-observation components for fixed and random effects of a mixed-effects model</p></a></li>
<li><a href='#mem.plotran'>
<p>Plot random effects histograms for a fitted mixed-effects model</p></a></li>
<li><a href='#mem.plotresid'>
<p>Plot residuals of a mixed-effects model along with trend lines</p></a></li>
<li><a href='#mem.powersimu'>
<p>Power simulations for the fixed effects of a mixed-effects model through</p>
structured bootstrapping of the data and re-fitting of the model</a></li>
<li><a href='#mix.binary'>
<p>Binary coding of categorical variables</p></a></li>
<li><a href='#mix.fun'>
<p>Apply function to numerical columns of a mixed data.frame while ignoring non-numeric fields</p></a></li>
<li><a href='#mixplot'>
<p>Scatterplot for mixed type data</p></a></li>
<li><a href='#orxlong'>
<p>Long-format longitudinal data for the ORX study</p></a></li>
<li><a href='#orxwide'>
<p>Wide-format baseline data for the ORX study</p></a></li>
<li><a href='#smartjitter'>
<p>Smart jittering function for deterministic shifting of overlapping values</p></a></li>
<li><a href='#vcaplong'>
<p>Long-format data of the Castration-resistant Prostate Cancer experiment using the VCaP cell line.</p></a></li>
<li><a href='#vcapwide'>
<p>Wide-format data of the Castration-resistant Prostate Cancer experiment using the VCaP cell line.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical Optimal Matching and Machine Learning Toolbox</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-05-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lme4, nlme, amap, nbpMatching, lattice, lmerTest, xtable,
Cairo, Matrix, MASS</td>
</tr>
<tr>
<td>Description:</td>
<td>Various functions and algorithms are provided here for solving optimal matching tasks in the context of preclinical cancer studies. Further, various helper and plotting functions are provided for unsupervised and supervised machine learning as well as longitudinal mixed-effects modeling of tumor growth response patterns.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-26 15:26:03 UTC; teelaa</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-26 22:01:24 UTC</td>
</tr>
</table>
<hr>
<h2 id='hamlet-package'>
Hierarchical Optimal Matching and Machine Learning Toolbox
</h2><span id='topic+hamlet-package'></span><span id='topic+hamlet'></span>

<h3>Description</h3>

<p>This package provides functions and algorithms for solving optimal matching tasks in the context of preclinical cancer studies. Further, various help and plotting functions are provided for unsupervised and supervised machine learning as well as longitudinal modeling of tumor growth response patterns.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> hamlet</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.9.5-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-09-21</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package 'hamlet' offers functions for optimal matching, randomization, and mixed-effects modeling in preclinical cancer studies. The functions are divided to 'match'-prefix indicating optimal matching intended functions, 'mem' indicating mixed-effects modeling, 'mix' for mixed type (numerical and categorical) data analysis, and rest that are various plotting and helper functions for various tasks.
</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala
</p>
<p>Maintainer: Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>References</h3>

<p>Laajala TD, Jumppanen M, Huhtaniemi R, Fey V, Kaur A, et al. (2016) Optimized design and analysis of preclinical intervention studies in vivo. Sci Rep. 2016 Aug 2;6:30723. doi: 10.1038/srep30723.
</p>
<p>Knuuttila M, Yatkin E, Kallio J, Savolainen S, Laajala TD, et al. (2014) Castration induces upregulation of intratumoral androgen biosynthesis and androgen receptor expression in orthotopic VCaP human prostate cancer xenograft model.  Am J Pathol. 2014 Aug;184(8):2163-73. doi: 10.1016/j.ajpath.2014.04.010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
## Exploring the VCaP dataset provided alongside the 'hamlet' package
##

data(vcapwide)
data(vcaplong)

# VCaP Castration-resistant prostate cancer (CRPC) PSA-measurements (and body weight) in wide-format
mixplot(vcapwide[,c("PSAWeek10", "PSAWeek14", "BWWeek10", "Group")], pch=16)
anv &lt;- aov(PSA ~ Group, data.frame(PSA = vcapwide[,"PSAWeek14"], Group = vcapwide[,"Group"]))
summary(anv)
TukeyHSD(anv)
summary(aov(BW ~ Group, data.frame(BW = vcapwide[,"BWWeek14"], Group = vcapwide[,"Group"])))

# VCaP Castration-resistant prostate cancer (CRPC) PSA-measurements (and body weight) in long-format
library(lattice)
xyplot(log2PSA ~ DrugWeek | Group, data = vcaplong, type="l", group=ID, layout=c(3,1))
xyplot(BW ~ DrugWeek | Group, data = vcaplong, type="l", group=ID, layout=c(3,1))

##
## Example multigroup (g=3) nbp-matching using the branch and bound algorithm, 
## and subsequent random allocation of submatches to 3 arms
##

# Construct an Euclidean distance example distance matrix using 15 observations from the VCaP study
d &lt;- as.matrix(dist(vcapwide[1:15,c("PSAWeek10", "BWWeek10")]))
# Matching using the b&amp;b algorithm to submatches of size 3 
# (which will result in 3 intervention groups)
bb3 &lt;- match.bb(d, g=3)
str(bb3)

solvec &lt;- bb3$solution 
# matching vector, where each element indicates to which submatch each observation belongs to

# Perform an example random allocation of the above submatches, 
# these will be randomly allocated to 3 arms based on the submatches
set.seed(1)
groups &lt;- match.allocate(solvec)

# Illustrate randomization, no baseline differences in these three artificial groups
by(vcapwide[1:15,c("PSAWeek10", "BWWeek10")], INDICES=groups, FUN=function(x) x)

summary(aov(PSAWeek10 ~ groups, data = data.frame(PSAWeek10 = vcapwide[1:15,"PSAWeek10"], groups)))
summary(aov(BWWeek10 ~ groups, data = data.frame(BWWeek10 = vcapwide[1:15,"BWWeek10"], groups)))

##
## Example mixed-effects modeling of the longitudinal PSA profiles using 
## the actual experimental groups
##

exdat &lt;- vcaplong[vcaplong[,"Group"] %in% c("Vehicle", "ARN"),]

library(lme4)
# Model fitting using lme4-package
f1 &lt;- lmer(log2PSA ~ 1 + DrugWeek + DrugWeek:ARN + (1 + DrugWeek|ID), data = exdat)

mem.getcomp(f1)

library(lmerTest)
# Model term testing using the lmerTest-package
summary(f1) 

</code></pre>

<hr>
<h2 id='extendsymrange'>
Extend range of variable limits while retaining a point of symmetricity
</h2><span id='topic+extendsymrange'></span>

<h3>Description</h3>

<p>This function serves as an alternative to the R function 'extendrange', when user wishes to conserve a point of symmetricity for the range. For example, this might be desired when the plot should be symmetric around the origin x=0, but that the sides need to extend beyond the actual range of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extendsymrange(x, r = range(x, na.rm = T), f = 0.05, sym = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extendsymrange_+3A_x">x</code></td>
<td>

<p>Vector of values to compute the range for
</p>
</td></tr>
<tr><td><code id="extendsymrange_+3A_r">r</code></td>
<td>

<p>The range of values
</p>
</td></tr>
<tr><td><code id="extendsymrange_+3A_f">f</code></td>
<td>

<p>The factor by which the range is extended beyond the extremes
</p>
</td></tr>
<tr><td><code id="extendsymrange_+3A_sym">sym</code></td>
<td>

<p>The defined point of symmetricity
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 2 values for the lower and higher limit of the symmetric extended range
</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+extendrange">extendrange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
ex &lt;- rnorm(10)+2

hist(ex, xlim=extendsymrange(ex, sym=0), breaks=100)
</code></pre>

<hr>
<h2 id='hmap'>
Plot-region based heatmap
</h2><span id='topic+hmap'></span>

<h3>Description</h3>

<p>This function plots heatmap figure based on the normal plot-region. This is useful if the image-based function 'heatmap' is not suitable, i.e. when multiple heatmaps should be placed in a single device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmap(x, add = F, 
	xlim = c(0.2, 0.8), 
	ylim = c(0.2, 0.8),
	col = heat.colors(10), 
	border = matrix(NA, nrow = nrow(x), ncol = ncol(x)), 
	lty = matrix("solid", nrow = nrow(x), ncol = ncol(x)), 
	lwd = matrix(1, nrow = nrow(x), ncol = ncol(x)), 
	hclustfun = hclust, 
	distfun = dist, 
	reorderfun = function(d, w) reorder(d, w), 
	textfun = function(xseq, yseq, labels, type = "row", ...) 
		{ if (type == "col") par(srt = 90); 
		text(x = xseq, y = yseq, labels = labels, ...);  
		if (type == "col") par(srt = 0)}, 
	symm = F, 
	Rowv = NULL, 
	Colv = if (symm) Rowv else NULL, 
	leftlim = c(0, 0.2), toplim = c(0.8, 1), 
	rightlim = c(0.8, 1), bottomlim = c(0, 0.2), 
	type = "rect", 
	scale = c("none", "row", "column"), 
	na.rm = T, 
	nbins = length(col), 
	valseq = 
		seq(from = min(x, na.rm = na.rm), 
		to = max(x, na.rm = na.rm), length.out = nbins), 
	namerows = T, 
	namecols = T, 
	...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmap_+3A_x">x</code></td>
<td>

<p>Matrix to be plotted
</p>
</td></tr>
<tr><td><code id="hmap_+3A_add">add</code></td>
<td>

<p>Should the figure be added to the plotting region of an already existing figure
</p>
</td></tr>
<tr><td><code id="hmap_+3A_xlim">xlim</code></td>
<td>

<p>The x limits in which the heatmap is placed horizontally in the plotting region
</p>
</td></tr>
<tr><td><code id="hmap_+3A_ylim">ylim</code></td>
<td>

<p>The y limits in which the heatmap is placed vertically in the plotting region
</p>
</td></tr>
<tr><td><code id="hmap_+3A_col">col</code></td>
<td>

<p>Color palette for the heatmap colors
</p>
</td></tr>
<tr><td><code id="hmap_+3A_border">border</code></td>
<td>

<p>A matrix of border color definitions (rectangles in the heatmap)
</p>
</td></tr>
<tr><td><code id="hmap_+3A_lty">lty</code></td>
<td>

<p>A matrix of line type definitions (rectangles in the heatmap)
</p>
</td></tr>
<tr><td><code id="hmap_+3A_lwd">lwd</code></td>
<td>

<p>A matrix of line width definitions (rectangles in the heatmap)
</p>
</td></tr>
<tr><td><code id="hmap_+3A_hclustfun">hclustfun</code></td>
<td>

<p>The hierarchical clustering function similar to 'stats::heatmap' implementation. Should yield a valid 'hclust' object for a given distance/dissimilarity matrix.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_distfun">distfun</code></td>
<td>

<p>The distance/dissimilarity function similar to 'stats::heatmap' implementation. Should yield a valid 'dist' object for a given data matrix.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_reorderfun">reorderfun</code></td>
<td>

<p>The function to use to reorder branches of the clustering (notice that same-level branches in a hierarchical clustering may be permutated without violating the solution). The default approach from 'stats::heatmap' is utilized here.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_textfun">textfun</code></td>
<td>

<p>A text function that is used to plot the names of the rows and columns, if desired. The default implementation shows how user could tailor the columns and rows differently, by turning the column labels around 90-degrees. The parameter 'type' is used to distinguish between rows and columns. 
</p>
</td></tr>
<tr><td><code id="hmap_+3A_symm">symm</code></td>
<td>

<p>Should the given data matrix be treated as symmetric (has to be a square matrix if so), by default 'FALSE'.  
</p>
</td></tr>
<tr><td><code id="hmap_+3A_rowv">Rowv</code></td>
<td>

<p>The row clustering parameter. If 'NA' the row hierarchical clustering is completely omitted. Alternatively, if a numeric vector of ranks, the ordering of branches is tried to be permutated according to the desired order. This can also be a pre-computed dendrogram-object.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_colv">Colv</code></td>
<td>

<p>The column clustering parameter. If 'NA' the column hierarchical clustering is completely omitted. Alternatively, if a numeric vector of ranks, the ordering of branches is tried to be permutated according to the desired order. This can also be a pre-computed dendrogram-object.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_leftlim">leftlim</code></td>
<td>

<p>The horizontal limits of the row hierarchical clustering. The horizontal limits of the heatmap are a=leftlim[1], b=leftlim[2], c=xlim[1], d=xlim[2] where the 'a' is where the row dendrogram begins, 'b' is where the row dendrogram ends, 'c' is where the heatmap itself begins, and 'd' is where the heatmap itself ends.
The vertical limits are computed according to 'ylim' to align correctly with the heatmap rectangles.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_toplim">toplim</code></td>
<td>

<p>The vertical limits of the row hierarchical clustering. The horizontal limits of the heatmap are a=ylim[1], b=ylim[2], c=toplim[1], d=toplim[2] where the 'a' is where the heatmap begins, 'b' is where the heatmap ends, 'c' is where the column dendrogram begins, and 'd' is where the column dendrogram ends.
The horizontal limits are computed according to 'xlim' to align correctly with the heatmap rectangles.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_rightlim">rightlim</code></td>
<td>

<p>The horizontal limits for the row texts.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_bottomlim">bottomlim</code></td>
<td>

<p>The vertical limits for the column texts.  
</p>
</td></tr>
<tr><td><code id="hmap_+3A_type">type</code></td>
<td>

<p>Type of clustering visualization; while default &quot;rect&quot; provides a rectangular-angled tree, the alternate option &quot;tri&quot; provides triangular-angled tree.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_scale">scale</code></td>
<td>

<p>Should data be scaled according to 'row' or 'column' (or 'col') similarly to 'stats::heatmap'.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_na.rm">na.rm</code></td>
<td>

<p>Should missing values be removed, by default TRUE.  
</p>
</td></tr>
<tr><td><code id="hmap_+3A_nbins">nbins</code></td>
<td>

<p>Number of discrete bins the data is divided into using 'seq(from=min(x), to=max(x), length.out=nbins)'.  
</p>
</td></tr>
<tr><td><code id="hmap_+3A_valseq">valseq</code></td>
<td>

<p>The sequence of values by which the data is binned, typically corresponding to the above 'nbins' parameter.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_namerows">namerows</code></td>
<td>

<p>If a single boolean value TRUE, then the default 'rownames(x)' are plotted to the right of the rows with the 'textfun'. If it is a vector of length 'nrow(x)', then this vector is used for plotting the row names instead.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_namecols">namecols</code></td>
<td>

<p>If a single boolean value TRUE, then the default 'colnames(x)' are plotted below the columns with the 'textfun'. If it is a vector of length 'nrow(x)', then this vector is used for plotting the column names instead.
</p>
</td></tr>
<tr><td><code id="hmap_+3A_...">...</code></td>
<td>

<p>Additional parameters provided to the rectangle plotting function
</p>
</td></tr>
</table>
<p><img src="../help/figures/hmapex.png" width="35%" alt="Figure: mai.png" />

</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+heatmap">heatmap</a></code>
<code><a href="#topic+hmap.key">hmap.key</a></code>
<code><a href="#topic+hmap.annotate">hmap.annotate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate some data
set.seed(1)
r1 &lt;- replicate(30, rnorm(20))
lab &lt;- sample(letters[1:2], 20, replace=TRUE)
r1[lab==lab[1],] &lt;- r1[lab==lab[1],] + 2
r2a &lt;- replicate(10, rnorm(10))
r2b &lt;- replicate(10, rnorm(10))

# Set up a new plot region, notice we have a 2-fold wider x-axis
plot.new()
plot.window(xlim=c(0,2), ylim=c(0,1))

# Plot an example plot along with the color key and annotations for our 'lab' vector
h1 &lt;- hmap(r1, add = TRUE)
hmap.key(h1, x1=0.18)
hmap.annotate(h1, rw = lab, rw.wid=c(0.82,0.90))

# Plot the rest to show how the coordinates are adjusted to place the heatmap(s) differently
h2a &lt;- hmap(r2a, add = TRUE, xlim=c(1.2, 1.8), leftlim=c(1.0, 1.2), 
	rightlim=c(1.8,2.0), ylim=c(0.6, 1.0), bottomlim=c(0.5,0.6), Colv=NA)
h2b &lt;- hmap(r2b, add = TRUE, xlim=c(1.2, 1.8), leftlim=c(1.0, 1.2), 
	rightlim=c(1.8,2.0), ylim=c(0.1, 0.5), bottomlim=c(0.0,0.1), Colv=NA)

# Show the normal plot region axes 
axis(1, at=c(0.5,1.5), c("A", "B"))

## Not run: 
	# Heatmap used as base for the help documentation figure
	set.seed(1)
	hmap(matrix(rnorm(100), nrow=10), xlim=c(0.2,0.8), ylim=c(0.2,0.8), 
		leftlim=c(0.0,0.2), rightlim=c(0.8,1.0), 
		bottomlim=c(0.0,0.2), toplim=c(0.8,1.0))
	axis(1); axis(2); title(xlab="x", ylab="y")

## End(Not run)
</code></pre>

<hr>
<h2 id='hmap.annotate'>
Add a row and column annotations to a plot-region based heatmap built with 'hmap'
</h2><span id='topic+hmap.annotate'></span>

<h3>Description</h3>

<p>Annotation of rows or columns in a 'hmap'-plot. By default, rectangles aligned with either rows or columns are plotted to the right-side or lower-side of the heatmap respectively. User-specified customizations may be given to change these annotations in positioning or type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmap.annotate(h, rw, rw.n = length(unique(rw)), rw.col = rainbow(rw.n,
                 start = 0.05, end = 0.5), rw.wid, rw.hei, rw.pch,
                 rw.x = rep(min(h$rightlim), times =
                 length(h$rowtext$xseq)), rw.y = h$rowtext$yseq, rw.shift
                 = c(0.02, 0), cl, cl.n
                 = length(unique(cl)), cl.col = rainbow(cl.n, start =
                 0.55, end = 1), cl.wid, cl.hei, cl.pch, cl.x =
                 h$coltext$xseq, cl.y = rep(max(h$bottomlim), times =
                 length(h$coltext$yseq)), cl.shift = c(0, -0.02), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmap.annotate_+3A_h">h</code></td>
<td>

<p>The list of heatmap parameters returned invisibly by the original 'hmap'-call.
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_rw">rw</code></td>
<td>

<p>Annotation vector for rows 'r', each unique instance is given a different color (or pch) and plotted right-side of the corresponding heatmap rows
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_rw.n">rw.n</code></td>
<td>

<p>Number of unique colors (or pch) to give each annotated row
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_rw.col">rw.col</code></td>
<td>

<p>A vector for color values for unique instances in 'r' for annotating rows
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_rw.wid">rw.wid</code></td>
<td>

<p>The widths for annotation boxes for each row 'r'
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_rw.hei">rw.hei</code></td>
<td>

<p>The heights for annotation boxes for each row 'r'
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_rw.pch">rw.pch</code></td>
<td>

<p>Alternatively, instead of widths and heights user may specify a symbol 'pch' to use for annotating each row
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_rw.x">rw.x</code></td>
<td>

<p>The x-coordinate locations for the row annotations, by default right side of heatmap itself
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_rw.y">rw.y</code></td>
<td>

<p>The y-coordinate locations for the row annotations, by default same vertical locations as for the heatmap rows
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_rw.shift">rw.shift</code></td>
<td>

<p>Row annotation shift: a vector of 2 values, where first indicates the amount of x-axis shift desired and the second indicates the amount of y-axis shift
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_cl">cl</code></td>
<td>

<p>Annotation vector for columns 'r', each unique instance is given a different color (or pch) and plotted lower-side of the corresponding heatmap columns
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_cl.n">cl.n</code></td>
<td>

<p>Number of unique colors (or pch) to give each annotated column
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_cl.col">cl.col</code></td>
<td>

<p>A vector for color values for unique instances in 'c' for annotating columns
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_cl.wid">cl.wid</code></td>
<td>

<p>The widths for annotation boxes for each column 'c'
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_cl.hei">cl.hei</code></td>
<td>

<p>The heights for annotation boxes for each column 'c'
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_cl.pch">cl.pch</code></td>
<td>

<p>Alternatively, instead of widths and heights user may specify a symbol 'pch' to use for annotating each column
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_cl.x">cl.x</code></td>
<td>

<p>The x-coordinate locations for the column annotations, by default same horizontal locations as for the heatmap columns
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_cl.y">cl.y</code></td>
<td>

<p>The y-coordinate locations for the column annotations, by default lower side of heatmap itself
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_cl.shift">cl.shift</code></td>
<td>

<p>Column annotation shift: a vector of 2 values, where first indicates the amount of x-axis shift desired and the second indicates the amount of y-axis shift
</p>
</td></tr>
<tr><td><code id="hmap.annotate_+3A_...">...</code></td>
<td>

<p>Additional parameters supplied either to 'rect' or 'points' function if user desired rectangles or 'pch'-based points respectively
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+heatmap">heatmap</a></code>
<code><a href="#topic+hmap.key">hmap.key</a></code>
<code><a href="#topic+hmap">hmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data
set.seed(1)
r1 &lt;- replicate(30, rnorm(20))
lab &lt;- sample(letters[1:2], 20, replace=TRUE)
r1[lab==lab[1],] &lt;- r1[lab==lab[1],] + 2
r2a &lt;- replicate(10, rnorm(10))
r2b &lt;- replicate(10, rnorm(10))

# Set up a new plot region, notice we have a 2-fold wider x-axis
plot.new()
plot.window(xlim=c(0,2), ylim=c(0,1))

# Plot an example plot along with the color key and annotations for our 'lab' vector
h1 &lt;- hmap(r1, add = TRUE)
hmap.key(h1, x1=0.18)
hmap.annotate(h1, rw = lab, rw.wid=c(0.82,0.90))

# Plot the rest to show how the coordinates are adjusted to place the heatmap(s) differently
h2a &lt;- hmap(r2a, add = TRUE, xlim=c(1.2, 1.8), leftlim=c(1.0, 1.2), 
	rightlim=c(1.8,2.0), ylim=c(0.6, 1.0), bottomlim=c(0.5,0.6), Colv=NA)
h2b &lt;- hmap(r2b, add = TRUE, xlim=c(1.2, 1.8), leftlim=c(1.0, 1.2), 
	rightlim=c(1.8,2.0), ylim=c(0.1, 0.5), bottomlim=c(0.0,0.1), Colv=NA)

# Show the normal plot region axes 
axis(1, at=c(0.5,1.5), c("A", "B"))


</code></pre>

<hr>
<h2 id='hmap.key'>
Add a color key to a plot-region based heatmap built with 'hmap'
</h2><span id='topic+hmap.key'></span>

<h3>Description</h3>

<p>A continuous color scale key for a heatmap. By default the key is constructed according to the 'h'-object which is invisibly returned by the original 'hmap'-call. Some customization may be supplied to position the legend or to customize ticks and style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmap.key(h, x0 = h$leftlim[1], x1 = h$leftlim[2], y0 =
                 h$toplim[1], y1 = h$toplim[2], xlim = range(h$valseq),
                 ratio = 0.5, tick = 0.1, at = seq(from =
                 min(h$valseq), to = max(h$valseq), length.out = 5),
                 bty = "c", cex = 0.5, pos = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmap.key_+3A_h">h</code></td>
<td>

<p>The list of heatmap parameters returned invisibly by the original 'hmap'-call.
</p>
</td></tr>
<tr><td><code id="hmap.key_+3A_x0">x0</code></td>
<td>

<p>Coordinates for the color key; left border
</p>
</td></tr>
<tr><td><code id="hmap.key_+3A_x1">x1</code></td>
<td>

<p>Coordinates for the color key; right border
</p>
</td></tr>
<tr><td><code id="hmap.key_+3A_y0">y0</code></td>
<td>

<p>Coordinates for the color key; lower border
</p>
</td></tr>
<tr><td><code id="hmap.key_+3A_y1">y1</code></td>
<td>

<p>Coordinates for the color key; upper border
</p>
</td></tr>
<tr><td><code id="hmap.key_+3A_xlim">xlim</code></td>
<td>

<p>Value range for the x-axis within the key itself, by default extracted from the h-object
</p>
</td></tr>
<tr><td><code id="hmap.key_+3A_ratio">ratio</code></td>
<td>

<p>Ratio between y-axis coordinates to separate the key box to upper color key box and lower tick and values
</p>
</td></tr>
<tr><td><code id="hmap.key_+3A_tick">tick</code></td>
<td>

<p>The vertical length in value ticks
</p>
</td></tr>
<tr><td><code id="hmap.key_+3A_at">at</code></td>
<td>

<p>The values in color key at which to plot ticks and the values at ticks
</p>
</td></tr>
<tr><td><code id="hmap.key_+3A_bty">bty</code></td>
<td>

<p>Type of box to plot around the color key
</p>
</td></tr>
<tr><td><code id="hmap.key_+3A_cex">cex</code></td>
<td>

<p>The zooming factor for plotting the text and other objects affected by the 'cex' parameter in 'par'
</p>
</td></tr>
<tr><td><code id="hmap.key_+3A_pos">pos</code></td>
<td>

<p>The text alignment and position parameter given to the 'text' function in the key
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+heatmap">heatmap</a></code>
<code><a href="#topic+hmap">hmap</a></code>
<code><a href="#topic+hmap.annotate">hmap.annotate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data
set.seed(1)
r1 &lt;- replicate(30, rnorm(20))
lab &lt;- sample(letters[1:2], 20, replace=TRUE)
r1[lab==lab[1],] &lt;- r1[lab==lab[1],] + 2
r2a &lt;- replicate(10, rnorm(10))
r2b &lt;- replicate(10, rnorm(10))

# Set up a new plot region, notice we have a 2-fold wider x-axis
plot.new()
plot.window(xlim=c(0,2), ylim=c(0,1))

# Plot an example plot along with the color key and annotations for our 'lab' vector
h1 &lt;- hmap(r1, add = TRUE)
hmap.key(h1, x1=0.18)
hmap.annotate(h1, rw = lab, rw.wid=c(0.82,0.90))

# Plot the rest to show how the coordinates are adjusted to place the heatmap(s) differently
h2a &lt;- hmap(r2a, add = TRUE, xlim=c(1.2, 1.8), leftlim=c(1.0, 1.2), 
	rightlim=c(1.8,2.0), ylim=c(0.6, 1.0), bottomlim=c(0.5,0.6), Colv=NA)
h2b &lt;- hmap(r2b, add = TRUE, xlim=c(1.2, 1.8), leftlim=c(1.0, 1.2), 
	rightlim=c(1.8,2.0), ylim=c(0.1, 0.5), bottomlim=c(0.0,0.1), Colv=NA)

# Show the normal plot region axes 
axis(1, at=c(0.5,1.5), c("A", "B"))

</code></pre>

<hr>
<h2 id='match.allocate'>
Allocation of matched units to intervention arms
</h2><span id='topic+match.allocate'></span>

<h3>Description</h3>

<p>This function allocates units belonging to a single submatch to separate intervention arms. This ensures that the resulting intervention groups are homogeneous in respect to the variables that were used to construct the distance/dissimilarity matrix for the non-bipartite matching. The number of resulting intervention groups is equal to the 'g' (i.e. submatch size) used in the multigroup non-bipartite matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.allocate(xmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.allocate_+3A_xmat">xmat</code></td>
<td>

<p>A binary matching matrix or a matching vector given by match.bb-function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector where each element indicates to which group the observation was randomized to. The group names are &quot;Group_A&quot;, &quot;Group_B&quot;, &quot;Group_C&quot;, ... until 'g' letters, where 'g' was the size of submatches.
</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match.bb">match.bb</a></code>
<code><a href="#topic+match.mat2vec">match.mat2vec</a></code>
<code><a href="#topic+match.vec2mat">match.vec2mat</a></code>
<code><a href="#topic+match.dummy">match.dummy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcapwide)

# Construct an Euclidean distance example distance matrix using 15 observations from the VCaP study
d &lt;- as.matrix(dist(vcapwide[1:15,c("PSAWeek10", "BWWeek10")]))
# Matching using the b&amp;b algorithm to submatches of size 3 
# (which will result in 3 intervention groups)
bb3 &lt;- match.bb(d, g=3)
str(bb3)

solvec &lt;- bb3$solution 
# matching vector, where each element indicates to which submatch each observation belongs to

# Perform an example random allocation of the above submatches, 
# these will be randomly allocated to 3 arms based on the submatches
set.seed(1)
groups &lt;- match.allocate(solvec)

# Illustrate randomization, no baseline differences in these three artificial groups
by(vcapwide[1:15,c("PSAWeek10", "BWWeek10")], INDICES=groups, FUN=function(x) x)

summary(aov(PSAWeek10 ~ groups, data = data.frame(PSAWeek10 = vcapwide[1:15,"PSAWeek10"], groups)))
summary(aov(BWWeek10 ~ groups, data = data.frame(BWWeek10 = vcapwide[1:15,"BWWeek10"], groups)))
</code></pre>

<hr>
<h2 id='match.bb'>
Branch and Bound algorithm implementation for performing multigroup non-bipartite matching
</h2><span id='topic+match.bb'></span>

<h3>Description</h3>

<p>This function performs multigroup non-bipartite matching of observations based on a provided distance/dissimilarity matrix 'd'. The number of elements in each submatch is defined by the parameter 'g'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.bb(d, g = 2, presort = "complete", progress = 1e+05, 
bestknown = Inf, maxbranches = Inf, verb = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.bb_+3A_d">d</code></td>
<td>

<p>A distance matrix with NxN elements
</p>
</td></tr>
<tr><td><code id="match.bb_+3A_g">g</code></td>
<td>

<p>Number of elements per each submatch, i.e. how many observations are always matched together
</p>
</td></tr>
<tr><td><code id="match.bb_+3A_presort">presort</code></td>
<td>

<p>If hierarchical clustering should be used for an initial guess, hclust method-options are valid options (&quot;complete&quot;, &quot;single&quot;, &quot;ward&quot;, &quot;average&quot;)
</p>
</td></tr>
<tr><td><code id="match.bb_+3A_progress">progress</code></td>
<td>

<p>How many branching operations are done before outputting information to the user
</p>
</td></tr>
<tr><td><code id="match.bb_+3A_bestknown">bestknown</code></td>
<td>

<p>If a best known solution already exists, this can be used to bound branches of the tree before initiation. The default Inf value causes whole search tree to be potential solution space.
</p>
</td></tr>
<tr><td><code id="match.bb_+3A_maxbranches">maxbranches</code></td>
<td>

<p>Maximum number of branching operations before returning current best solution, by default no cutoff is defined.
</p>
</td></tr>
<tr><td><code id="match.bb_+3A_verb">verb</code></td>
<td>

<p>Level of verbosity
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further details in the reference Laajala et al.
</p>


<h3>Value</h3>

<p>The function returns a list of objects, where elements are
</p>
<table role = "presentation">
<tr><td><code>branches</code></td>
<td>
<p>Number of branching operations during the branch and bound algorithm</p>
</td></tr>
<tr><td><code>bounds</code></td>
<td>
<p>Number of bounding operations during the branch and bound algorithm</p>
</td></tr>
<tr><td><code>ends</code></td>
<td>
<p>Number of end leaf nodes visited during the branch and bound algorithm</p>
</td></tr>
<tr><td><code>matrix</code></td>
<td>
<p>The resulting binary matching matrix where rows and columns sum to g</p>
</td></tr>
<tr><td><code>solution</code></td>
<td>
<p>The resulting matching vector where each element indicates the submatch where the observation was placed</p>
</td></tr>
<tr><td><code>cost</code></td>
<td>
<p>Final cost value of the target function in the minimization task</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Notice that the solution submatch vector in $solution is not the same as the intervention group allocation. Submatches should be randomly allocated to intervention arms using the match.allocate-function.
</p>
<p>The package 'nbpMatching' provides a FORTRAN implementation for computation of paired non-bipartite matching case (g=2).
</p>
<p>Computation may be heavy if the number of observations is high, or the number of within-submatch pairwise distances to consider is high (increases quadratically as a function of 'g').
</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match.allocate">match.allocate</a></code>
<code><a href="#topic+match.mat2vec">match.mat2vec</a></code>
<code><a href="#topic+match.vec2mat">match.vec2mat</a></code>
<code><a href="#topic+match.dummy">match.dummy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcapwide)

# Construct an Euclidean distance example distance matrix using 15 observations from the VCaP study
d &lt;- as.matrix(dist(vcapwide[1:15,c("PSAWeek10", "BWWeek10")]))

bb3 &lt;- match.bb(d, g=3)
str(bb3)

mat &lt;- bb3$matrix 
# binary matching matrix
solvec &lt;- bb3$solution 
# matching vector, where each element indicates to which submatch each observation belongs to

mixplot(data.frame(vcapwide[1:15,c("PSAWeek10", "BWWeek10")], 
 submatch=as.factor(paste("Submatch_",solvec, sep=""))), pch=16, col=rainbow(5))
</code></pre>

<hr>
<h2 id='match.dummy'>
Create dummy individuals or sinks to a data matrix or a distance/dissimilarity matrix
</h2><span id='topic+match.dummy'></span>

<h3>Description</h3>

<p>Dummy observations are allowed in order to make the number of observations dividable by the number of elements in each submatch, i.e. for pairwise matching the number of observations should be paired, for triangular matching the number of observations should be dividable by 3, etc. This can be done either by adding column averaged individuals to the original data frame (parameter 'dat'), or by adding zero distance sinks to the distance/dissimilarity matrix (parameter 'd'). The latter approach favors dummies being matched to real extreme observations, while the former favors dummies being matched to close-to-mean real observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.dummy(dat, d, g = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.dummy_+3A_dat">dat</code></td>
<td>

<p>A data.frame of the original observations, to which column averaged new dummy observations are added
</p>
</td></tr>
<tr><td><code id="match.dummy_+3A_d">d</code></td>
<td>

<p>N times N distance/dissimilarity matrix, to which zero distance sinks are added
</p>
</td></tr>
<tr><td><code id="match.dummy_+3A_g">g</code></td>
<td>

<p>The desired number of elements per each submatch, i.e. the size of the clusters. The number of added dummies is the smallest number of additions that fulfills (N+dummy)%%g == 0
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on if the dat or the d parameter was provided, the function either:
dat: adds new averaged individuals according to column means and then returns the data matrix
d: adds zero distance sinks to the distance/dissimilarity matrix and returns the new distance/dissimilarity matrix
</p>


<h3>Note</h3>

<p>Adding zero distance sinks to the distance matrix or averaged individuals to the original data frame produce different results and affect the optimal matching task differently.
</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match.allocate">match.allocate</a></code>
<code><a href="#topic+match.mat2vec">match.mat2vec</a></code>
<code><a href="#topic+match.vec2mat">match.vec2mat</a></code>
<code><a href="#topic+match.bb">match.bb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcapwide)

exdat &lt;- vcapwide[1:10,c("PSAWeek10", "BWWeek10")]
dim(exdat)
avgdummies &lt;- match.dummy(dat=exdat, g=3)
dim(avgdummies)
# Construct an Euclidean distance matrix after adding two dummy individuals 
# (averaged individuals to the original data matrix)
bb3 &lt;- match.bb(as.matrix(dist(avgdummies)), g=3)
str(bb3)

# Construct an Euclidean distance matrix after adding two dummy distances (zero distance sinks)
exd &lt;- as.matrix(dist(vcapwide[1:10,c("PSAWeek10", "BWWeek10")]))
dim(exd)
d &lt;- match.dummy(d=exd, g=3)
dim(d)
# 10 is not dividable by 3, 2 sinks are added to make d 12x12
bb3 &lt;- match.bb(d, g=3)
str(bb3)

# Notice that sinks produce a lot smaller target function costs than averaged individuals
</code></pre>

<hr>
<h2 id='match.ga'>
Non-bipartite matching using the Genetic Algorithm (GA)
</h2><span id='topic+match.ga'></span>

<h3>Description</h3>

<p>An implementation of the Genetic Algorithm for solving non-bipartite matching tasks with customizable evolutionary events and parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.ga(d, g, 
	pops, 
	generations = 100, 
	popsize = 100, 
	nmutate = 100, 
	ndeath = 30, 
	type = "min", 
	mutate = hamlet:::.ga.mutate, 
	breed = hamlet:::.ga.breed, 
	weight = hamlet:::.ga.weight, 
	fitness = hamlet:::.ga.fitness, 
	step = hamlet:::.ga.step, 
	initialize = hamlet:::.ga.init, 
	progplot = T, 
	plot = T, 
	verb = 0, 
	progress = 500, 
	...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.ga_+3A_d">d</code></td>
<td>

<p>A distance/dissimilarity matrix 'd'
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_g">g</code></td>
<td>

<p>The size in submatches, as in how many observations are always connected
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_pops">pops</code></td>
<td>

<p>If user wants to specify starting populations, they can be provided here as a matrix. Each row correspondings to the observations, while columns are the different solutions (population in the GA). For example, a 10 row 100 column pops-matrix would be 100 different matching solutions of 10 observations. Each number in the matrix indicates a different submatch.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_generations">generations</code></td>
<td>

<p>Number of simulations to run in the GA. In each step, mutations, breeding and breeding occur according to user's specified settings, and a new generation is created out of this.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_popsize">popsize</code></td>
<td>

<p>Number of solutions (='individuals') to have in each step of the algorithm.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_nmutate">nmutate</code></td>
<td>

<p>Number of mutations to occur in each step. Individuals are sampled with replacement, and then given the corresponding number of mutations.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_ndeath">ndeath</code></td>
<td>

<p>Number of deaths to occur in each step. Each dead solution (='individual') is then replaced by breeding suitable parents (probability of being a parent weighted by fitness).
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_type">type</code></td>
<td>

<p>Type of optimization, can be 'min' or 'max'.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_mutate">mutate</code></td>
<td>

<p>Mutation function; by default the hamlet internal function '.ga.mutate' is used. This function takes in solution vector 'x'. Two random positions are then swapped, which could be seen as a form of a point mutation.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_breed">breed</code></td>
<td>

<p>Breeding function; by default the hamlet internal function '.ga.breed' is used. This function takes in solution vectors 'x' and 'y' ,which will be the parents, and the distance matrix 'd'. The products x*d and y*d are computed, and row-wise differences are computed between the two matrices. The row with the highest difference indicates where one of the parents can be most improved, and this trait is inherited from the other parent.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_weight">weight</code></td>
<td>

<p>Weighting function; by default the hamlet internal function '.ga.weight' is used. This weight should be correspond to probabilities that the corresponding individuals will undergo some sort of event (i.e. mutation, death) or participate in producing offspring (i.e. breed). This probability weight is computed according to ranks of fitnesses computed in the
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_fitness">fitness</code></td>
<td>

<p>Fitness function; by default the hamlet internal function '.ga.fitness' is used. This should yield the numeric fitness for a solution, indicating how viable the solution is in relation to the others. In a minimization task the lower fitness indicates better viability.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_step">step</code></td>
<td>

<p>A step function; by default the hamlet internal function '.ga.step' is used. The step function which combines all operations in the GA, in order to produce the next generation of solutions given the previous one.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_initialize">initialize</code></td>
<td>

<p>Initialization function; by default the hamlet internal function '.ga.initialize' is used. This function should format a set of valid solutions to produce the first generation in the beginning of the GA.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_progplot">progplot</code></td>
<td>

<p>Should progress be plotted. If true, in every generation index dividable by the parameter 'progress', a function of fitnesses over the generations is plotted. The plot shows development of solution cost quantiles over time.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_plot">plot</code></td>
<td>

<p>Should the function plot the final quantiles over all the generations.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_verb">verb</code></td>
<td>

<p>Level of verbosity; -1 indicates omitting of verbal output, 0 indicates normal level, and +1 indicates debugging/additional information.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_progress">progress</code></td>
<td>

<p>How often should the function plot and print intermediate information on the progress.
</p>
</td></tr>
<tr><td><code id="match.ga_+3A_...">...</code></td>
<td>

<p>Additional parameters for the internal GA functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Genetic Algorithm (GA) is a form of an evolutionary optimization algorithm, where a population (a group of solutions to an optimization tasks) reproduce among themselves, die, mutate, and live on in a simulated environment. As the GA is a generic framework of solution approaches, it has many adjustable parameters and user may wish to explore many different options for the populations (for example in population size, mutation frequencies, fitness functions, drift etc) and also the evolutionary mechanics (such as breeding technique, types of mutations, and suitability for reproducing). Here, general default options and mechanics are provided, but it is advisable to explore different parameters for the particular optimization task in hand to find optimal solutions. If the user wishes to explore the implementation of the default mechanics, the function implementations are internally available in the hamlet-package. For example, the mutation function is accessible with the command: ' hamlet::.ga.mutate '.
</p>


<h3>Value</h3>

<p>The returned list compromises of:
</p>

<ul>
<li><p> A list of solutions; a matrix 'pops' which contains the population of solutions in the final generation of the algorithm, a vector 'fitnesses' which portrait the corresponding fitnesses to the columns of 'pops', and 'weights' which were the corresponding probabilities to events in the GA.
</p>
</li>
<li><p> A vector 'bestsol', for which the fitness function obtained minimum (or maximum) value during the algorithm.
</p>
</li>
<li><p> A value 'best', which is the optimum solution cost value observed during the algorithm.
</p>
</li></ul>



<h3>Note</h3>

<p>Notice that end quality of the matching based allocation is heavily dependent on providing a feasible matrix D. One should carefully consider choice and tuning of the similarity metric. For example, Euclidean distance without standardization is often not a good choice as it does not normalize the variance of each variable and emphasis is on baseline variables that have a large relative variance.
</p>
<p>Note that the R-package 'GA' offers a wide range of generalized GA-related tools.
</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match.bb">match.bb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up a distance matrix and add dummies, then run GA
data(vcapwide)

# Construct an Euclidean distance example distance matrix using 15 observations from the VCaP study
d &lt;- as.matrix(dist(vcapwide[1:15,c("PSAWeek10", "BWWeek10")]))
# Or rather, z-score transform all input variables first
d2 &lt;- as.matrix(dist(scale(vcapwide[1:15,c("PSAWeek10", "BWWeek10")])))

# Notice that random simulations take place, so we will fix the RNG seed for reproducibility
set.seed(1)
# Resulting genetic algorithm progression is plotted by default
ga &lt;- match.ga(d2, g=3, generations=60)
str(ga)
# Submatches, i.e. similar individuals that ought to be allocated to separate groups
ga[[2]]

</code></pre>

<hr>
<h2 id='match.mat2vec'>
Transform a binary matching matrix to a matching vector
</h2><span id='topic+match.mat2vec'></span>

<h3>Description</h3>

<p>This function transforms a binary matching matrix to a matching vector. A matching vector is of length N where each element indicates the submatch to which the observation belongs to. Notice that this is not the same as the group allocation vector that is provided by the match.allocate-function. The binary matching matrix is of size N x N where 0 indicates that the observations have been part of a different submatch, and 1 indicates that the observations have been part of the same submatch. Diagonal is always 0 although an observation is always in the same submatch with its self.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.mat2vec(xmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.mat2vec_+3A_xmat">xmat</code></td>
<td>

<p>A binary matching matrix 'xmat'
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matching vector where each element indicates submatch the observation belongs to
</p>


<h3>Note</h3>

<p>Notice that the particular index numbers produced by match.mat2vec may be different to that of the branch and bound solution vector, but that the submatches shared by observations are common.
</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match.allocate">match.allocate</a></code>
<code><a href="#topic+match.bb">match.bb</a></code>
<code><a href="#topic+match.vec2mat">match.vec2mat</a></code>
<code><a href="#topic+match.dummy">match.dummy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcapwide)

# Construct an Euclidean distance example distance matrix using 15 observations from the VCaP study
d &lt;- as.matrix(dist(vcapwide[1:15,c("PSAWeek10", "BWWeek10")]))

bb3 &lt;- match.bb(d, g=3)
str(bb3)

mat &lt;- bb3$matrix 
# matching vector, where each element indicates to which submatch each observation belongs to

mat
solvec &lt;- match.mat2vec(mat)
which(mat[1,] == 1) 
# E.g. the first, third and thirteenth observation are part of the same submatch
which(solvec == solvec[1]) 
# Similarly
</code></pre>

<hr>
<h2 id='match.vec2mat'>
Transform a matching vector to a binary matching matrix
</h2><span id='topic+match.vec2mat'></span>

<h3>Description</h3>

<p>This function allows transforming a matching vector to a binary matching matrix. A matching vector is of length N where each element indicates the submatch to which the observation belongs to. Notice that this is not the same as the group allocation vector that is provided by the match.allocate-function. The binary matching matrix is of size N x N where 0 indicates that the observations have been part of a different submatch, and 1 indicates that the observations have been part of the same submatch. Diagonal is always 0 although an observation is always in the same submatch with its self.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.vec2mat(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.vec2mat_+3A_x">x</code></td>
<td>

<p>A matching vector 'x'
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N times N binary matching matrix, where 0 indicates that the observations have been part of a different submatch, and 1 indicates that the observations have been part of the same submatch.</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match.allocate">match.allocate</a></code>
<code><a href="#topic+match.mat2vec">match.mat2vec</a></code>
<code><a href="#topic+match.bb">match.bb</a></code>
<code><a href="#topic+match.dummy">match.dummy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcapwide)

# Construct an Euclidean distance example distance matrix using 15 observations from the VCaP study
d &lt;- as.matrix(dist(vcapwide[1:15,c("PSAWeek10", "BWWeek10")]))

bb3 &lt;- match.bb(d, g=3)
str(bb3)

solvec &lt;- bb3$solution 
# matching vector, where each element indicates to which submatch each observation belongs to

solvec
mat &lt;- match.vec2mat(solvec)
mat
which(mat[1,] == 1) 
# E.g. the first, third and thirteenth observation are part of the same submatch
which(solvec == solvec[1]) 
# Similarly
</code></pre>

<hr>
<h2 id='mem.getcomp'>
Extract per-observation components for fixed and random effects of a mixed-effects model
</h2><span id='topic+mem.getcomp'></span>

<h3>Description</h3>

<p>Assuming a mixed-effects model of form y_fit = Xb + Zu + e, where X is the model matrix for fixed effects, Z is the model matrix for random effects, and b and u are the fixed and random effects respectively, this function returns these components per each fitted value y. These may be useful for model inference and/or diagnostic purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mem.getcomp(fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mem.getcomp_+3A_fit">fit</code></td>
<td>

<p>A fitted mixed-effects model generated either through the lme4 or the nlme package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notice that per-observation model error is e = Xb + Zu - y_observation. Similarly, the components Xb and Zu are extracted.
</p>


<h3>Value</h3>

<p>The function returns per-observation model fit components for a mixed-effects model. The return fields are
</p>
<table role = "presentation">
<tr><td><code>Xb</code></td>
<td>
<p>Fixed effects component Xb</p>
</td></tr>
<tr><td><code>Zu</code></td>
<td>
<p>Random effects component Zu</p>
</td></tr>
<tr><td><code>XbZu</code></td>
<td>
<p>Full model fit by summing the above two Xb+Zu</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>Model error e</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Original observations y</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mem.plotran">mem.plotran</a></code>
<code><a href="#topic+mem.plotresid">mem.plotresid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcaplong)

exdat &lt;- vcaplong[vcaplong[,"Group"] %in% c("Vehicle", "ARN"),]

library(lme4)
f1 &lt;- lmer(log2PSA ~ 1 + DrugWeek + DrugWeek:ARN + (1 + DrugWeek|ID), data = exdat)

mem.getcomp(f1)
</code></pre>

<hr>
<h2 id='mem.plotran'>
Plot random effects histograms for a fitted mixed-effects model
</h2><span id='topic+mem.plotran'></span>

<h3>Description</h3>

<p>This plot creates histogram plots for the columns extracted from random effects from a model fit. This is useful for model diagnostics, such as observing deviations from normality in the random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mem.plotran(fit, breaks = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mem.plotran_+3A_fit">fit</code></td>
<td>

<p>A fitted mixed-effects model generated either through the lme4 or the nlme package.
</p>
</td></tr>
<tr><td><code id="mem.plotran_+3A_breaks">breaks</code></td>
<td>

<p>Number of breaks in the histograms (passed to the 'hist'-function)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mem.getcomp">mem.getcomp</a></code>, <code><a href="#topic+mem.plotresid">mem.plotresid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcaplong)

exdat &lt;- vcaplong[vcaplong[,"Group"] %in% c("Vehicle", "ARN"),]

library(lme4)
f1 &lt;- lmer(log2PSA ~ 1 + DrugWeek + DrugWeek:ARN + (1 + DrugWeek|ID), data = exdat)

ranef(f1) # Histograms are plotted for these columns
mem.plotran(f1)
</code></pre>

<hr>
<h2 id='mem.plotresid'>
Plot residuals of a mixed-effects model along with trend lines
</h2><span id='topic+mem.plotresid'></span>

<h3>Description</h3>

<p>This function plots stylized residuals of a mixed-effects model. It is possible to obtain fitted values versus errors (XbZu vs e), or original values versus errors (y vs e) in order to obtain different views to the errors in connection to the observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mem.plotresid(fit, linear = T, type = "XbZu", main, xlab, ylab)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mem.plotresid_+3A_fit">fit</code></td>
<td>

<p>A fitted mixed-effects model generated either through the lme4 or the nlme package.
</p>
</td></tr>
<tr><td><code id="mem.plotresid_+3A_linear">linear</code></td>
<td>

<p>Should linear trend lines be drawn to the residual plot
</p>
</td></tr>
<tr><td><code id="mem.plotresid_+3A_type">type</code></td>
<td>

<p>Type of residual plot; should fitted values (value &quot;XbZu&quot;) or original observations (value &quot;y&quot;) be plotted against &quot;e&quot; errors
</p>
</td></tr>
<tr><td><code id="mem.plotresid_+3A_main">main</code></td>
<td>

<p>Main title
</p>
</td></tr>
<tr><td><code id="mem.plotresid_+3A_xlab">xlab</code></td>
<td>

<p>x-axis label
</p>
</td></tr>
<tr><td><code id="mem.plotresid_+3A_ylab">ylab</code></td>
<td>

<p>y-axis label
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notice that the typical residual plot is fitted values (type=&quot;XbZu&quot;) versus errors (&quot;e&quot;).
</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mem.getcomp">mem.getcomp</a></code>, <code><a href="#topic+mem.plotran">mem.plotran</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcaplong)

exdat &lt;- vcaplong[vcaplong[,"Group"] %in% c("Vehicle", "ARN"),]

library(lme4)
f0 &lt;- lmer(log2PSA ~ 1 + DrugWeek + (1 + DrugWeek|ID), data = exdat)
f1 &lt;- lmer(log2PSA ~ 1 + DrugWeek + DrugWeek:ARN + (1 + DrugWeek|ID), data = exdat)
f2 &lt;- lmer(log2PSA ~ 1 + DrugWeek + DrugWeek:ARN + (1|ID) + (0 + DrugWeek|ID), data = exdat)
f3 &lt;- lmer(log2PSA ~ 1 + DrugWeek + DrugWeek:ARN + (1|Submatch) + (0 + DrugWeek|ID), data = exdat)

par(mfrow=c(2,2))
mem.plotresid(f0)
mem.plotresid(f1)
mem.plotresid(f2)
mem.plotresid(f3)

</code></pre>

<hr>
<h2 id='mem.powersimu'>
Power simulations for the fixed effects of a mixed-effects model through 
structured bootstrapping of the data and re-fitting of the model
</h2><span id='topic+mem.powersimu'></span>

<h3>Description</h3>

<p>Bootstrap sampling is used to investigate the statistical significance of the fixed 
effects terms specified for a readily fitted mixed-effects model as a function of the 
number of individuals participating in the study. User either specifies a
suitable sampling unit, or it is automatically identified based on the random effects
formulation of a readily fitted mixed-effects model. Per each count of individuals in 
vector N, a fixed number of bootstrapped datasets are generated and re-fitted using
the model formulation on the pre-fitted model. Power is then computed as the fraction
of effects identified as statistically significant out of all the bootstrapped datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mem.powersimu(fit, N = 4:20, boot = 100, level = NULL, strata = NULL, 
	default = FALSE, seed = NULL, plot = TRUE, plot.loess = FALSE, 
	legendpos = "bottomright", return.data = FALSE, verb = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mem.powersimu_+3A_fit">fit</code></td>
<td>

<p>A fitted mixed-effects model. Should be either a model produced by the 
lme4-package, or then a modified lme4-fit such as provided by lmerTest 
or similar package that builds on lme4.
</p>
</td></tr>
<tr><td><code id="mem.powersimu_+3A_n">N</code></td>
<td>

<p>A vector of desired amounts of individuals to be tested, i.e. sample sizes N.
Notice that the N may be either a total N if no strata is spesified, or then an 
N value per each substrata if strata is not NULL. See below the parameter 'strata'.
</p>
</td></tr>
<tr><td><code id="mem.powersimu_+3A_boot">boot</code></td>
<td>

<p>Number of bootstrapped datasets to generate per each N value. The total number of 
generated data frames in the end will be N times boot.
</p>
</td></tr>
<tr><td><code id="mem.powersimu_+3A_level">level</code></td>
<td>

<p>An unambiguous indicator available in the model data frame that indicates each separate
individual unit in the experiment. For example, this may correspond to a single patient
indicator column ID, where each patient has a unique ID instance. If this parameter is 
given as NULL, then this function automatically attempts to identify the best possible
level of individual indicators based on the random effects specified for the model.
</p>
</td></tr>
<tr><td><code id="mem.powersimu_+3A_strata">strata</code></td>
<td>

<p>If any sampling strata should be balanced, it should be indicated here. For example, if
one is studying the possible effects of an intervention, it is typical to have an equal 
number of individual both in the control and in the intervention arms also in the sampled
datasets. It should be then given as an column name available in the original model data
frame. Each strata will be sampled in equal amounts.
</p>
</td></tr>
<tr><td><code id="mem.powersimu_+3A_default">default</code></td>
<td>

<p>What is the default statistical significance if a model could not be re-fitted to the 
sampled datasets, which may occur for example due to convergence or redundance issues.
This defaults to FALSE, which means that a coefficient is expected to be statistically 
insignificant if the corresponding model re-fitting fails in lme4.
</p>
</td></tr>
<tr><td><code id="mem.powersimu_+3A_seed">seed</code></td>
<td>

<p>For reproducibility, one may wish to set a numeric seed to produce the exact same results.
</p>
</td></tr>
<tr><td><code id="mem.powersimu_+3A_plot">plot</code></td>
<td>

<p>If set to TRUE, the function will plot a power curve. Each fixed effects coefficient is a 
different curve, with color coding and a legend annotated to separate which one is which.
</p>
</td></tr>
<tr><td><code id="mem.powersimu_+3A_plot.loess">plot.loess</code></td>
<td>

<p>If plot==TRUE, this plot.loess==TRUE adds an additional loess-smoothed approximated curve 
to the existing curves. This is useful if running the simulations with a low number of 
bootstrapped samples, as it may help approximate where the curve reaches critical points, i.e.
power = 0.8.
</p>
</td></tr>
<tr><td><code id="mem.powersimu_+3A_legendpos">legendpos</code></td>
<td>

<p>Position for the legend in plot==TRUE, defaults to &quot;bottomright&quot;. Any legal position similar 
to provided the function 'legend' is allowed.
</p>
</td></tr>
<tr><td><code id="mem.powersimu_+3A_return.data">return.data</code></td>
<td>

<p>Should one obtain the bootstrapped data instead of bootstrapping and then re-fitting. This will 
skip the model re-fitting schema and instead return a list of lists with the bootstrapped data 
instead. The outer list corresponds to the values of 'N', while the inner loop corresponds to the
different 'boot' runs of bootstrap. This may be useful to inspecting that the schema is sampling
correct sampling units for example, or if bootstrapping is to be used for something else than 
re-fitting the lme4-models.
</p>
</td></tr>
<tr><td><code id="mem.powersimu_+3A_verb">verb</code></td>
<td>

<p>Numeric value indicating the level of verbosity; 0=silent, 1=normal, 2=debugging.
</p>
</td></tr>
<tr><td><code id="mem.powersimu_+3A_...">...</code></td>
<td>

<p>Additional parameters provided for the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will by default utilizes the lmerTest-package's Satterthwaite approximation for determining the 
p-values for the fixed effects. If this fails, it resorts to the conventional approximation |t|&gt;2 for significance,
which is not accurate, but may provide a reasonable approximation for the power levels.
</p>


<h3>Value</h3>

<p>If return.data==FALSE, this function will return a matrix, where the rows correspond to the different
N values and the columns correspond to the fixed effects. The values [0,1] are the fraction of bootstrapped
datasets where the corresponding fixed effects was detected as statistically significant.
</p>


<h3>Note</h3>

<p>Please note that the example runs in this document are extremely small due to run time constraints on CRAN. For real power analyses, it is recommended that the N counts would vary e.g. from 5 to 15 with steps of 1 and the amount of bootstrapped datasets would be at least 100.
</p>


<h3>Author(s)</h3>

<p>Teemu D. Laajala
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mem.getcomp">mem.getcomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the VCaP ARN data as an example
data(vcaplong)
arn &lt;- vcaplong[vcaplong[,"Group"] == "Vehicle" | vcaplong[,"Group"] == "ARN",]

# lme4 is required for mixed-effects models
library(lme4)
# Fit an example fixed effects model
fit &lt;- lmer(PSA ~ 1 + DrugWeek + ARN:DrugWeek + (1|ID) + (0 + DrugWeek|ID), data = arn)

# For reproducibility, set a seed
set.seed(123)
# Run a brief power analysis with only a few selected N values and a limited number of bootstrapping
# Balance strata over the ARN and non-ARN (=Vehicle) so that both contain equal count of individuals
power &lt;- mem.powersimu(fit, N=c(3, 6, 9), boot=10, strata="ARN", plot=TRUE)
# Power curves are plotted, along with returning the power matrix at:
power

# Notice that each column corresponds to a specified fixed effects at the formula 
# "1 + DrugWeek + ARN:DrugWeek"

</code></pre>

<hr>
<h2 id='mix.binary'>
Binary coding of categorical variables
</h2><span id='topic+mix.binary'></span>

<h3>Description</h3>

<p>This function encodes categorical variables (e.g. columns of type 'factor' or 'character'). U new columns are created per each such column, where U is the number of unique instances of that column. The new columns are named OriginalColumnName_U1, OriginalColumnName_U2, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mix.binary(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mix.binary_+3A_x">x</code></td>
<td>

<p>A data.frame or a matrix where categorical columns are to be binary coded. Categorical columns are assumed to be all non-numeric fields.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function that codes categorical variables in a dataset into binary variables. This is done in the following manner:
e.g. x = red, green, blue, green &ndash;&gt; x_new = 1,0,0, 0,1,0, 0,0,1, 0,1,0 where the dimensions in x_new are is_red, is_green and is_blue
</p>


<h3>Value</h3>

<p>The function returns a data.frame, where categorical variables have been replaced with 0/1-binary fields, and numeric fields have been left untouched. Notice that the order of the columns may not be the original.
</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcapwide)

ex &lt;- mix.binary(vcapwide[,c("Group", "CastrationDate")])
apply(ex, MARGIN=1, FUN=sum) 
# Notice that each row sums to 2, as two categorical variables were binary coded 
# and no missing values were present

mix.binary(vcapwide[,c("PSAWeek4", "Group", "CastrationDate")]) 
# Binary coding is only applied to non-numeric fields
</code></pre>

<hr>
<h2 id='mix.fun'>
Apply function to numerical columns of a mixed data.frame while ignoring non-numeric fields
</h2><span id='topic+mix.fun'></span>

<h3>Description</h3>

<p>This function is intended for applying functions to numeric fields of a mixed type data.frame. Namely, the function ignores fields that are e.g. factors, and returns FUN function applied to only the numeric fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mix.fun(x, FUN = scale, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mix.fun_+3A_x">x</code></td>
<td>

<p>Data.frame x with mixed type fields
</p>
</td></tr>
<tr><td><code id="mix.fun_+3A_fun">FUN</code></td>
<td>

<p>Function to apply, for example 'scale', 'cov', or 'cor'
</p>
</td></tr>
<tr><td><code id="mix.fun_+3A_...">...</code></td>
<td>

<p>Additional parameters passed on to FUN
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return values of FUN when applied to numeric columns of 'x'
</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+apply">apply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcapwide)

mix.fun(vcapwide[,c("Group", "PSAWeek4", "PSAWeek10", "PSAWeek14")], FUN=scale) 
# Column 'Group' is ignored
mix.fun(vcapwide[,c("Group", "PSAWeek4", "PSAWeek10", "PSAWeek14")], FUN=cov, use="na.or.complete") 
# ... is used to pass the 'use' parameter to the 'cov'-function
</code></pre>

<hr>
<h2 id='mixplot'>
Scatterplot for mixed type data
</h2><span id='topic+mixplot'></span>

<h3>Description</h3>

<p>This function plots a scatterplot similar to the default plot-function, with the difference that factor/character fields in input data.frame are handled as categorical variables. These categorical variables are color-coded and handled separately in marginal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixplot(x, 
	main = NA, 
	match, 
	func = function(x, y, par) 
		{ segments(x0 = x[1], y0 = x[2], x1 = y[1], y1 = y[2], col = par)}, 
	legend = T, 
	col = palette(), na.lines = T, 
	origin = F, 
	marginal = F, 
	lhei, 
	lwid, 
	verb = 0,
...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixplot_+3A_x">x</code></td>
<td>

<p>A data.frame or a matrix of observations. Typically x should be a data.frame, where columns are of different types, e.g. some of 'numeric' and some of 'factor' class.
</p>
</td></tr>
<tr><td><code id="mixplot_+3A_main">main</code></td>
<td>

<p>Main title plotted on top of the figure
</p>
</td></tr>
<tr><td><code id="mixplot_+3A_match">match</code></td>
<td>

<p>A matching matrix (e.g. produced by hamlet::match.vec2mat) or a matching vector (e.g. produced by hamlet::match.mat2vec) that indicates with different values if certain observations should be connected.
</p>
</td></tr>
<tr><td><code id="mixplot_+3A_func">func</code></td>
<td>

<p>The function to apply to each pair of observations 'x' and 'y'. By default, it is a segment line in 2 dimensions (each individual bivariate panel). Segment line color is indicated by the matching vector or individual element in the matching matrix. Thus 0-values indicate no line, while other values are used to annotate submatches. 'par' is the index of the submatch, and by default indicate the colors.
</p>
</td></tr>
<tr><td><code id="mixplot_+3A_legend">legend</code></td>
<td>

<p>Should an automated legend be generated
</p>
</td></tr>
<tr><td><code id="mixplot_+3A_col">col</code></td>
<td>

<p>Colors per observation
</p>
</td></tr>
<tr><td><code id="mixplot_+3A_na.lines">na.lines</code></td>
<td>

<p>Should lines be drawn to represent one of the variables if the other one is missing in a 2-dim scatterplot
</p>
</td></tr>
<tr><td><code id="mixplot_+3A_origin">origin</code></td>
<td>

<p>Should the origin x=0, y=0 be separately indicated using lines
</p>
</td></tr>
<tr><td><code id="mixplot_+3A_marginal">marginal</code></td>
<td>

<p>Should marginal distributions be drawn in sides of each scatterplot
</p>
</td></tr>
<tr><td><code id="mixplot_+3A_lhei">lhei</code></td>
<td>

<p>Heights for bins in the layout
</p>
</td></tr>
<tr><td><code id="mixplot_+3A_lwid">lwid</code></td>
<td>

<p>Widths for bins in the layout
</p>
</td></tr>
<tr><td><code id="mixplot_+3A_verb">verb</code></td>
<td>

<p>Level of verbosity: -1&lt;= (no verbosity), 0/FALSE (warnings) or &gt;=1/TRUE (additional information)
</p>
</td></tr>
<tr><td><code id="mixplot_+3A_...">...</code></td>
<td>

<p>Additional parameters given to the plot-function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible return of the measurements and plot layout structure (matrix, heights, and widths)
</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcapwide)

mixplot(vcapwide[,c("Group", "PSAWeek4", "PSAWeek10", "PSAWeek14")], marginal=TRUE, pch=16, 
 main="PSA at weeks 4, 10 and 14 per intervention group")
</code></pre>

<hr>
<h2 id='orxlong'>
Long-format longitudinal data for the ORX study
</h2><span id='topic+orxlong'></span>

<h3>Description</h3>

<p>Long-format measurements of PSA over the intervention period in the ORX study. Notice that this data.frame
is in suitable format for mixed-effects modeling, where each row should correspond to a single
longitudinal measurement. These measurements are annotated using the individual indicator fields 'ID',
time fields 'Day', 'TrDay', 'Date', and the response values are contained in raw format in 'PSA' or
after log2-transformation in 'log2PSA'. Additional fields are provided for group testing and matched 
inference in 'Group', 'Submatch', and the binary indicators 'ORX+Tx', 'ORX', and 'Intact'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("orxlong")</code></pre>


<h3>Format</h3>

<p>A data frame with 392 observations on the following 11 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>A unique character indicator for the different individual(s)</p>
</dd>
<dt><code>PSA</code></dt><dd><p>Raw longitudinal PSA measurement values in unit (ug/l)</p>
</dd>
<dt><code>log2PSA</code></dt><dd><p>Log2-transformed longitudinal PSA measurement values in unit (log2 ug/l)</p>
</dd>
<dt><code>Day</code></dt><dd><p>Day since the first PSA measurement. Notice that there is a single time point prior to interventions.</p>
</dd>
<dt><code>TrDay</code></dt><dd><p>Day since the interventions began, 0 annotating the point at which surgery was performed or drug compounds were first given.</p>
</dd>
<dt><code>Date</code></dt><dd><p>A date format when the actual measurement was performed</p>
</dd>
<dt><code>Group</code></dt><dd><p>The actual intervention groups, after blinded groups were assigned to 'ORX+Tx', 'ORX', or 'Intact'</p>
</dd>
<dt><code>Submatch</code></dt><dd><p>The submatches that were assigned based on the baseline variables.</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;ORXTx&#8288;</span>&rsquo;</dt><dd><p>A binary indicator field indicating which measurements belong to the group 'ORX+Tx'</p>
</dd>
<dt><code>ORX</code></dt><dd><p>A binary indicator field indicating which measurements belong to the group 'ORX'</p>
</dd>
<dt><code>Intact</code></dt><dd><p>A binary indicator field indicating which measurements belong to the group 'Intact'</p>
</dd>
</dl>



<h3>Details</h3>

<p>For mixed-effects modeling, the fields 'ID', 'PSA' (or 'log2PSA'), 'TrDay', and group-specific indicators should be included.
</p>


<h3>Note</h3>

<p>Group-testing should be performed so that 'ORX+Tx' is tested against 'ORX', in order to infer possible effects 
occurring due to 'Tx' on top of 'ORX'. 'ORX' should be compared to 'Intact', in order to infer if the 'ORX' surgical
procedure has beneficial effects in comparison to intact animals. For statistical modeling of the intervention effects,
one should use observations with the positive 'TrDay'-values, as this indicates the beginning of the interventions.
</p>


<h3>Source</h3>

<p>Laajala TD, Jumppanen M, Huhtaniemi R, Fey V, Kaur A, et al. (2016) Optimized design and analysis of preclinical intervention studies in vivo. Sci Rep. 2016 Aug 2;6:30723. doi: 10.1038/srep30723.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orxlong)
# Construct data frames that can be used for testing pairwise group contrasts
orxintact &lt;- orxlong[orxlong[,"Intact"]==1 | orxlong[,"ORX"]==1, 
	c("PSA", "ID", "ORX", "TrDay", "Submatch")]
orxtx &lt;- orxlong[orxlong[,"ORXTx"]==1 | orxlong[,"ORX"]==1, 
	c("PSA", "ID", "ORXTx", "TrDay", "Submatch")]
# Include only observations occurring post-surgery
orxintact &lt;- orxintact[orxintact[,"TrDay"]&gt;=0,]
orxtx &lt;- orxtx[orxtx[,"TrDay"]&gt;=0,]

# Example fits
library(lme4)
library(lmerTest)
# Conventional model fits
fit1a &lt;- lmer(PSA ~ 1 + TrDay + ORXTx:TrDay + (1|ID) + (0 + TrDay|ID), data = orxtx)
fit1b &lt;- lmer(PSA ~ 1 + TrDay + ORXTx:TrDay + (1 + TrDay|ID), data = orxtx)
fit2a &lt;- lmer(PSA ~ 1 + TrDay + ORX:TrDay + (1|ID) + (0 + TrDay|ID), data = orxintact)
fit2b &lt;- lmer(PSA ~ 1 + TrDay + ORX:TrDay + (1 + TrDay|ID), data = orxintact)

# Collate to matched inference for pairwise observations over the submatches
matched.orx &lt;- do.call("rbind", by(orxintact, INDICES=orxintact[,"Submatch"], FUN=function(z){
	z[,"MatchedPSA"] &lt;- z[,"PSA"] - z[z[,"ORX"]==0,"PSA"]
	z &lt;- z[z[,"ORX"]==1,]
	z
}))
# Few examples of matched fits with different model formulations
fit.matched.1 &lt;- lmer(MatchedPSA ~ 0 + TrDay + (1|ID) + (0 + TrDay|ID), data = matched.orx)
fit.matched.2 &lt;- lmer(MatchedPSA ~ 1 + TrDay + (1|ID) + (0 + TrDay|ID), data = matched.orx)
fit.matched.3 &lt;- lmer(MatchedPSA ~ 1 + TrDay + (1 + TrDay|ID), data = matched.orx)
summary(fit.matched.1)
summary(fit.matched.2)
summary(fit.matched.3)
# We notice that the intercept term is highly insignificant 
# if included in the matched model, as expected by baseline balance.
# In contrast, the matched intervention growth coefficient is highly
# statistically significant in each of the models.
</code></pre>

<hr>
<h2 id='orxwide'>
Wide-format baseline data for the ORX study
</h2><span id='topic+orxwide'></span>

<h3>Description</h3>

<p>This data frame contains the wide-format data of the ORX study for baseline characteristics of the 
individuals participating in the study. Some fields (Volume, PSA, High, BodyWeight, PSAChange) were 
used to construct the distance matrix in the original matching-based random allocation of individuals
at baseline, while other variables (Group, Submatch) contain these results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("orxwide")</code></pre>


<h3>Format</h3>

<p>A data frame with 109 observations on the following 8 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>A unique character indicator for the different individual(s)</p>
</dd>
<dt><code>Group</code></dt><dd><p>After identifying suitable submatches, the data were distributed to blinded intervention groups. These groups were later then annotated to actual treatments or non-intervention control groups.</p>
</dd>
<dt><code>Submatch</code></dt><dd><p>Submatches identified at baseline using the methodology presented in this package</p>
</dd>
<dt><code>Volume</code></dt><dd><p>Tumor volume at baseline in cubic millimeters</p>
</dd>
<dt><code>PSA</code></dt><dd><p>Raw baseline PSA measurement values in unit (ug/l)</p>
</dd>
<dt><code>High</code></dt><dd><p>The highest dimension in the tumor in millimeters, giving insight into the shape of the tumor</p>
</dd>
<dt><code>BodyWeight</code></dt><dd><p>Body weight at baseline in unit (g)</p>
</dd>
<dt><code>PSAChange</code></dt><dd><p>A fold-change like change in PSA from the prior measurement defined as: (PSA_current - PSA_last)/(PSA_last)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Originally, 3-fold weighting of the baseline 'Volume' and 'PSA' was used in comparison to 
'High', 'BodyWeight' and 'PSAChange' when computing the distance matrix. Furthermore, some 
individuals were annotated prior to matching for exclusion based on outlierish behaviour.
The exclusion criteria were applied before any interventions were given or the matching was 
performed. The excluded tumors had either non-existant PSA, non-detectable tumor volume,
or extremely large tumors (volume above 700 mm^3).
</p>


<h3>Note</h3>

<p>Notice that while normally the submatches would be distributed equally to the experiment 
groups, here rarely a single submatch may hold multiple instances from a single group. 
This is due to practical constraints in the experiment, that animals had to be manually
moved in order to fulfill groups and to reflect the amount of drug compounds available.
Additionally, the original experiment was performed on 6 intervention groups, while here
only 3 are further presented after the baseline ('ORX+Tx', 'ORX' and 'Intact').
</p>


<h3>Source</h3>

<p>Laajala TD, Jumppanen M, Huhtaniemi R, Fey V, Kaur A, et al. (2016) Optimized design and analysis of preclinical intervention studies in vivo. Sci Rep. 2016 Aug 2;6:30723. doi: 10.1038/srep30723.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orxwide)
# Construct an example distance matrix based on conventional 
# Euclidean distance and the baseline characteristics
d.orx &lt;- dist(orxwide[,c("Volume", "PSA", "High", "BodyWeight", "PSAChange")])
# Plot a hierarchical clustering of the individuals
plot(hclust(d=d.orx))
# This 'd.orx' may then be further processed by downstream experiment 
# design functions such as match.ga, match.bb, etc.
</code></pre>

<hr>
<h2 id='smartjitter'>
Smart jittering function for deterministic shifting of overlapping values
</h2><span id='topic+smartjitter'></span>

<h3>Description</h3>

<p>This function takes in a vector of measurements and computes overlapping bins of observations, and applies a jittering function within each overlapping bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smartjitter(x, q = seq(from = 0, to = 1, length.out = 10), type = 1, 
amount = 0.1, jitterfuncs = list(function(n) {
    (1:n)/(1/amount)
}, function(n) {
    (((-1)^c(0:(n - 1))) * (0:(n - 1)))/(1/amount)
}), jits = jitterfuncs[[type]])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smartjitter_+3A_x">x</code></td>
<td>

<p>The values that should be jittered. Notice that these are used to determine which are overlapping, and should not be though of as x-axis positions (see example).
</p>
</td></tr>
<tr><td><code id="smartjitter_+3A_q">q</code></td>
<td>

<p>Probability quantiles where the ends of the bins should be placed
</p>
</td></tr>
<tr><td><code id="smartjitter_+3A_type">type</code></td>
<td>

<p>Type of jittering, by default it is used to choose which element (1 or 2) of the list of jittering functions is chosen as the final jittering function. Customized functions may be provided to the jitterfuncs-parameter.
</p>
</td></tr>
<tr><td><code id="smartjitter_+3A_amount">amount</code></td>
<td>

<p>Amount of jittering (here deterministic shifting) for the jittering function
</p>
</td></tr>
<tr><td><code id="smartjitter_+3A_jitterfuncs">jitterfuncs</code></td>
<td>

<p>List of possible jittering functions for n overlapping values. The jittering function at list position 'type' is chosen
</p>
</td></tr>
<tr><td><code id="smartjitter_+3A_jits">jits</code></td>
<td>

<p>Final jittering function from the jitterfuncs-list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The smart jittering is applied to the x-parameter values, and returns a vector of shifting amounts per each observation. Notice that in the typical case, parameter 'x' are the desired response values e.g. among the y-axis, and the returned value of smartjitter are the amounts of jittering done on the x-axis of a plot.
</p>


<h3>Value</h3>

<p>The function returns a vector of values with same length as x. The values in this vector indicate what should be the shifting per each observation, if the observations should be jittered along an another axis.
</p>


<h3>Author(s)</h3>

<p>Teemu Daniel Laajala &lt;teelaa@utu.fi&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcapwide)

plot.new()
plot.window(xlim=extendrange(c(0,1)), ylim=extendrange(vcapwide[,"PSAWeek4"]))
y1 &lt;- vcapwide[vcapwide[,"CastrationDate"]=="100413","PSAWeek4"]
y2 &lt;- vcapwide[vcapwide[,"CastrationDate"]=="170413","PSAWeek4"]
points(x=0+smartjitter(y1, type=2, amount=0.02), y=y1)
points(x=1+smartjitter(y2, type=2, amount=0.02), y=y2)
axis(1, at=c(0,1), labels=c("10.04.13", "17.04.13"))
axis(2); box()
title(ylab="PSA at week 4", xlab="Castration batches")
</code></pre>

<hr>
<h2 id='vcaplong'>
Long-format data of the Castration-resistant Prostate Cancer experiment using the VCaP cell line.
</h2><span id='topic+vcaplong'></span>

<h3>Description</h3>

<p>The long-format of the VCaP experiment PSA-measurements may be used to model longitudinal measurements during interventions (Vehicle, ARN, or MDV). Body weights and PSA were measured weekly during the experiment. PSA concentrations were log2-transformed to make data better normally distributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vcaplong)</code></pre>


<h3>Format</h3>

<p>A data frame with 225 observations on the following 11 variables.
</p>

<dl>
<dt><code>PSA</code></dt><dd><p>Raw PSA (prostate-specific antigen) measurements with unit (ug/l)</p>
</dd>
<dt><code>log2PSA</code></dt><dd><p>Log2-transformed PSA (prostate-specific antigen) measurements with unit (log2 ug/l)</p>
</dd>
<dt><code>BW</code></dt><dd><p>Body weights (g)</p>
</dd>
<dt><code>Submatch</code></dt><dd><p>A grouping factor for indicating which measurements belong to individuals that were part of the same submatch prior to interventions</p>
</dd>
<dt><code>ID</code></dt><dd><p>A character vector indicating unique animal IDs</p>
</dd>
<dt><code>Week</code></dt><dd><p>Week of the experiment, notice that this is not the same as the week of drug administration (see below)</p>
</dd>
<dt><code>DrugWeek</code></dt><dd><p>Week since beginning administration of the drugs</p>
</dd>
<dt><code>Group</code></dt><dd><p>Grouping factor for intervention groups of the observations</p>
</dd>
<dt><code>Vehicle</code></dt><dd><p>Binary indicator for which observations belonged to the group 'Vehicle'</p>
</dd>
<dt><code>ARN</code></dt><dd><p>Binary indicator for which observations belonged to the group 'ARN-509'</p>
</dd>
<dt><code>MDV</code></dt><dd><p>Binary indicator for which observations belonged to the group 'MDV3100'</p>
</dd>
</dl>



<h3>Details</h3>

<p>Notice that the long-format is suitable for modeling longitudinal measurements. The grouping factors ID or Submatch could be used to group observations belonging to a single individual or matched individuals.
</p>


<h3>Source</h3>

<p>Laajala TD, Jumppanen M, Huhtaniemi R, Fey V, Kaur A, et al. (2016) Optimized design and analysis of preclinical intervention studies in vivo. Sci Rep. 2016 Aug 2;6:30723. doi: 10.1038/srep30723.
</p>
<p>Knuuttila M, Yatkin E, Kallio J, Savolainen S, Laajala TD, et al. (2014) Castration induces upregulation of intratumoral androgen biosynthesis and androgen receptor expression in orthotopic VCaP human prostate cancer xenograft model.  Am J Pathol. 2014 Aug;184(8):2163-73. doi: 10.1016/j.ajpath.2014.04.010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcaplong)

str(vcaplong)
head(vcaplong)

library(lattice)
xyplot(log2PSA ~ DrugWeek | Group, data = vcaplong, type="l", group=ID, layout=c(3,1))
xyplot(BW ~ DrugWeek | Group, data = vcaplong, type="l", group=ID, layout=c(3,1))
</code></pre>

<hr>
<h2 id='vcapwide'>
Wide-format data of the Castration-resistant Prostate Cancer experiment using the VCaP cell line.
</h2><span id='topic+vcapwide'></span>

<h3>Description</h3>

<p>VCaP cancer cells were injected orthotopically into the prostate of mice and PSA (prostate-specific antigen) was followed. The animals were castrated on two subsequent weeks, after which the castration-resistant tumors were allowed to emerge. Since PSA reached pre-castration levels, the animals were non-bipartite matched and allocated to separate intervention arms (at week 10). 3 different interventions are presented here, with 'Vehicle' as a comparison point and MDV3100 and ARN-509 tested for reducing PSA and its correlated tumor size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vcapwide)</code></pre>


<h3>Format</h3>

<p>A data frame with 45 observations on the following 34 variables.
</p>

<dl>
<dt><code>CastrationDate</code></dt><dd><p>A numeric vector indicating week when the animal was castrated, resulting in steep decrease in PSA and subsequent castration-resistant tumors to emerge.</p>
</dd>
<dt><code>CageAtAllocation</code></dt><dd><p>A factorial vector indicating cage labels for each animal at the intervention allocation.</p>
</dd>
<dt><code>Group</code></dt><dd><p>A character vector indicating which intervention group the animal was allocated to in the actual experiment (3 alternatives).</p>
</dd>
<dt><code>TreatmentInitiationWeek</code></dt><dd><p>A character vector indicating at which week the intervention was started.</p>
</dd>
<dt><code>Submatch</code></dt><dd><p>A character vector indicating which submatch the individual was part of the original non-bipartite matching task.</p>
</dd>
<dt><code>ID</code></dt><dd><p>A unique character vector indicating the animals.</p>
</dd>
<dt><code>PSAWeek2</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>PSAWeek3</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>PSAWeek4</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>PSAWeek5</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>PSAWeek6</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>PSAWeek7</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>PSAWeek8</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>PSAWeek9</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>PSAWeek10</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>PSAWeek11</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>PSAWeek12</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>PSAWeek13</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>PSAWeek14</code></dt><dd><p>Numeric vector(s) indicating PSA concentration (ug/l) per each week (2 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek0</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek1</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek2</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek3</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek4</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek5</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek6</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek7</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek8</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek9</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek10</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek11</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek12</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek13</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
<dt><code>BWWeek14</code></dt><dd><p>Numeric vector indicating body weight (g) of the animals per each week (0 to 14) of the experiment.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The wide-format here presented the longitudinal measurements for PSA and Body Weight per each column. For modeling the PSA growth longitudinally e.g. using mixed-effects models, see the <code><a href="#topic+vcaplong">vcaplong</a></code> dataset where the data has been readily transposed into the long-format.
</p>


<h3>Source</h3>

<p>Laajala TD, Jumppanen M, Huhtaniemi R, Fey V, Kaur A, et al. (2016) Optimized design and analysis of preclinical intervention studies in vivo. Sci Rep. 2016 Aug 2;6:30723. doi: 10.1038/srep30723.
</p>
<p>Knuuttila M, Yatkin E, Kallio J, Savolainen S, Laajala TD, et al. (2014) Castration induces upregulation of intratumoral androgen biosynthesis and androgen receptor expression in orthotopic VCaP human prostate cancer xenograft model.  Am J Pathol. 2014 Aug;184(8):2163-73. doi: 10.1016/j.ajpath.2014.04.010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcaplong">vcaplong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcapwide)

str(vcapwide)
head(vcapwide)

mixplot(vcapwide[,c("PSAWeek10", "PSAWeek14", "BWWeek10", "Group")], pch=16)
anv &lt;- aov(PSA ~ Group, data.frame(PSA = vcapwide[,"PSAWeek14"], Group = vcapwide[,"Group"]))
summary(anv)
TukeyHSD(anv)
summary(aov(BW ~ Group, data.frame(BW = vcapwide[,"BWWeek14"], Group = vcapwide[,"Group"])))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
