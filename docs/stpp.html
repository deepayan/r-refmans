<!DOCTYPE html><html><head><title>Help for package stpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stpp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stpp'><p>Space-Time Point Pattern simulation, visualisation and analysis</p></a></li>
<li><a href='#animation'><p>Space-time data animation</p></a></li>
<li><a href='#as.3dpoints'><p>Create data in spatio-temporal point format</p></a></li>
<li><a href='#ASTIKhat'><p>Anisotropic Space-Time Inhomogeneous <code class="reqn">K</code>-function</p></a></li>
<li><a href='#fmd'><p>2001 food-and-mouth epidemic, north Cumbria (UK)</p></a></li>
<li><a href='#gsp'><p>Spatial mark variogram function</p></a></li>
<li><a href='#gte'><p>Temporal mark variogram function</p></a></li>
<li><a href='#is.3dpoints'><p>Spatio-temporal point objects</p></a></li>
<li><a href='#KLISTAhat'><p>Estimation of the Space-Time Inhomogeneous K LISTA functions</p></a></li>
<li><a href='#kmmr'><p>Spatial mark correlation function</p>
</a></li>
<li><a href='#kmmt'><p>Temporal mark correlation function</p>
</a></li>
<li><a href='#kmr'><p>Spatial <code class="reqn">r</code>-mark function</p>
</a></li>
<li><a href='#kmt'><p>Temporal <code class="reqn">t</code>-mark function</p>
</a></li>
<li><a href='#LISTAhat'><p>Estimation of the Space-Time Inhomogeneous Pair Correlation LISTA functions</p></a></li>
<li><a href='#northcumbria'><p>Polygon boundary of north Cumbria</p></a></li>
<li><a href='#PCFhat'><p>Estimation of the Space-Time Inhomogeneous Pair Correlation function</p></a></li>
<li><a href='#plot.stpp'><p>Plot for spatio-temporal point objects</p></a></li>
<li><a href='#plotK'><p>Plot the estimation of the Space-Time Inhomogeneous K-function</p></a></li>
<li><a href='#plotPCF'><p>Plot the estimation of the Space-Time Inhomogeneous Pair Correlation function</p></a></li>
<li><a href='#rinfec'><p>Generate infection point patterns</p></a></li>
<li><a href='#rinter'><p>Generate interaction point patterns</p></a></li>
<li><a href='#rlgcp'><p>Generate log-Gaussian Cox point patterns</p></a></li>
<li><a href='#rpcp'><p>Generate Poisson cluster point patterns</p></a></li>
<li><a href='#rpp'><p>Generate Poisson point patterns</p></a></li>
<li><a href='#sim.stpp'><p>Generate spatio-temporal point patterns</p></a></li>
<li><a href='#stan'><p>(3D) space-time data animation</p></a></li>
<li><a href='#stdcpp'><p>Generate double-cluster point pattern</p></a></li>
<li><a href='#sthpcpp'><p>Spatio-temporal hot-spots cluster point process model</p></a></li>
<li><a href='#STIKhat'><p>Estimation of the Space-Time Inhomogeneous K-function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-29</td>
</tr>
<tr>
<td>Title:</td>
<td>Space-Time Point Pattern Simulation, Visualisation and Analysis</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), grDevices, graphics, rpanel, splancs</td>
</tr>
<tr>
<td>Imports:</td>
<td>KernSmooth, ggplot2, gridExtra, plot3D, rgl, spatstat.explore,
spatstat.geom, spatstat.random, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr(&ge; 1.11), rmarkdown(&ge; 0.8.1)</td>
</tr>
<tr>
<td>Description:</td>
<td>Many of the models encountered in applications of point process methods to the study of spatio-temporal phenomena are covered in 'stpp'. This package provides statistical tools for analyzing the global and local second-order properties of spatio-temporal point processes, including estimators of the space-time inhomogeneous K-function and pair correlation function. It also includes tools to get static and dynamic display of spatio-temporal point patterns. See Gabriel et al (2013) &lt;<a href="https://doi.org/10.18637%2Fjss.v053.i02">doi:10.18637/jss.v053.i02</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>True</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stpp-GitHub-community">https://github.com/stpp-GitHub-community</a></td>
</tr>
<tr>
<td>Author:</td>
<td>Edith Gabriel [aut, cre],
  Peter J Diggle [aut],
  Barry Rowlingson [aut],
  Francisco J Rodriguez-Cortes [aut]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-29 20:51:26 UTC; UNALMED</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-30 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stpp'>Space-Time Point Pattern simulation, visualisation and analysis</h2><span id='topic+stpp-package'></span><span id='topic+stpp'></span>

<h3>Description</h3>

<p> This package provides models of spatio-temporal point processes in a region <code class="reqn">S\times T</code> and statistical tools for analysing global and local second-order properties of such processes. It also includes static and dynamic (2D and 3D) plots. <code>stpp</code> is the first dedicated unified computational environment in the area of spatio-temporal point processes.
</p>
<p>The <code>stpp</code> package depends upon some other packages:
</p>
<p><code>splancs</code>: spatial and space-time point pattern analysis
</p>
<p><code>rgl</code>: interactive 3D plotting of densities and surfaces
</p>
<p><code>rpanel</code>: simple interactive controls for R using <code>tcltk</code> package
</p>
<p><code>KernSmooth</code>: functions for kernel smoothing for Wand &amp; Jones (1995)
</p>
<p><code>plot3D</code>: Tools for plotting 3-D and 2-D data
</p>
<p><code>ggplot2</code>: Create Elegant Data Visualisations Using the Grammar of Graphics
</p>


<h3>Details</h3>

<p><code>stpp</code> is a package for simulating, analysing and visualising patterns of points in space and time.
</p>
<p>Following is a summary of the main functions and the dataset in the <code>stpp</code> package.
</p>
<p><em>To visualise a spatio-temporal point pattern</em>
</p>

<ul>
<li> <p><code><a href="#topic+animation">animation</a></code>: space-time data animation.
</p>
</li>
<li> <p><code><a href="#topic+as.3dpoints">as.3dpoints</a></code>: create data in spatio-temporal point format.
</p>
</li>
<li> <p><code><a href="#topic+plot.stpp">plot.stpp</a></code>: plot spatio-temporal point object. Either a two-panels plot showing spatial locations and cumulative times, or a one-panel plot showing spatial locations with times treated as a quantitative mark attached to each location.
</p>
</li>
<li> <p><code><a href="#topic+stan">stan</a></code>: 3D space-time animation.
</p>
</li></ul>

<p><em>To simulate spatio-temporal point patterns</em>
</p>

<ul>
<li> <p><code><a href="#topic+rinfec">rinfec</a></code>: simulate an infection point process,
</p>
</li>
<li> <p><code><a href="#topic+rinter">rinter</a></code>: simulate an interaction (inhibition or contagious) point process,
</p>
</li>
<li> <p><code><a href="#topic+rlgcp">rlgcp</a></code>: simulate a log-Gaussian Cox point process,
</p>
</li>
<li> <p><code><a href="#topic+rpcp">rpcp</a></code>: simulate a Poisson cluster point process,
</p>
</li>
<li> <p><code><a href="#topic+rpp">rpp</a></code>: simulate a Poisson point process,
</p>
</li>
<li> <p><code><a href="#topic+stdcpp">stdcpp</a></code>: simulate a double-cluster point process,
</p>
</li>
<li> <p><code><a href="#topic+sthpcpp">sthpcpp</a></code>: simulate a hot-spot point process.
</p>
</li></ul>

<p><em>To analyse spatio-temporal point patterns</em>
</p>

<ul>
<li> <p><code><a href="#topic+PCFhat">PCFhat</a></code>: space-time inhomogeneous pair correlation function,
</p>
</li>
<li> <p><code><a href="#topic+STIKhat">STIKhat</a></code>: space-time inhomogeneous K-function,
</p>
</li>
<li> <p><code><a href="#topic+ASTIKhat">ASTIKhat</a></code>: Anisotropic space-time inhomogeneous K-function,
</p>
</li>
<li> <p><code><a href="#topic+LISTAhat">LISTAhat</a></code>: space-time inhomogeneous pair correlation LISTA funcrions.
</p>
</li>
<li> <p><code><a href="#topic+KLISTAhat">KLISTAhat</a></code>: space-time inhomogeneous K LISTA functions.
</p>
</li>
<li> <p><code><a href="#topic+gsp">gsp</a></code>: Spatial mark variogram function.
</p>
</li>
<li> <p><code><a href="#topic+gte">gte</a></code>: Temporal mark variogram function.
</p>
</li>
<li> <p><code><a href="#topic+kmr">kmr</a></code>: Spatial r-mark function
</p>
</li>
<li> <p><code><a href="#topic+kmt">kmt</a></code>: Temporal t-mark function.
</p>
</li>
<li> <p><code><a href="#topic+kmmr">kmmr</a></code>: Spatial mark correlation functionn.
</p>
</li>
<li> <p><code><a href="#topic+kmmt">kmmt</a></code>: Temporal mark correlation function.
</p>
</li></ul>

<p><em>Dataset</em>
</p>
<p><code><a href="#topic+fmd">fmd</a></code>: 2001 food-and-mouth epidemic in north Cumbria (UK).
</p>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@univ-avignon.fr&gt;, Peter J. Diggle, Barry Rowlingson and Francisco J. Rodriguez-Cortes</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E., Turner, R. (2015). Spatial Point Patterns: Methodology and Applications with R. CRC Press, Boca Raton.
</p>
<p>Chan, G. and Wood A. (1997). An algorithm for simulating stationary Gaussian random fields. Applied Statistics, Algorithm Section, 46, 171&ndash;181.
</p>
<p>Chan, G. and Wood A. (1999). Simulation of stationary Gaussian vector fields. Statistics and Computing, 9, 265&ndash;268.
</p>
<p>Diggle P. , Chedwynd A., Haggkvist R. and Morris S. (1995). Second-order analysis of space-time clustering. Statistical Methods in Medical Research, 4, 124&ndash;136.
</p>
<p>Diggle, P.J., 2013. Statistical Analysis of Spatial and Spatio-Temporal Point Patterns. CRC Press, Boca Raton.
</p>
<p>Gabriel E. (2014). Estimating second-order characteristics of inhomogeneous spatio-temporal point processes: influence ofedge correction methods and intensity estimates. Methodology and computing in Applied Probabillity, 16(1).
</p>
<p>Gabriel E., Diggle P. (2009). Second-order analysis of inhomogeneous spatio-temporal point process data. Statistica Neerlandica, 63, 43&ndash;51.
</p>
<p>Gabriel E., Rowlingson B., Diggle P. (2013). stpp: an R package for plotting, simulating and analyzing 
Spatio-Temporal Point Patterns. Journal of Statistical Software, 
53(2), 1&ndash;29.
</p>
<p>Gneiting T. (2002). Nonseparable, stationary covariance functions for space-time data. Journal of the American Statistical Association, 97, 590&ndash;600.
</p>
<p>Gonzalez, J. A., Rodriguez-Cortes, F. J., Cronie, O. and Mateu, J. (2016). Spatio-temporal point process statistics: a review. Spatial Statiscts, 18, 505&ndash;544.
</p>
<p>Siino, M., Rodriguez-Cortes, F. J., Mateu, J. and Adelfio, G. (2017). Testing for local structure in spatio-temporal point pattern data. Environmetrics. DOI: 10.1002/env.2463.
</p>
<p>Stoyan, D., Rodriguez-Cortes, F. J., Mateu, J., and Gille, W. (2017). Mark variograms for spatio-temporal point processes. Spatial Statistics. 20, 125-147.
</p>

<hr>
<h2 id='animation'>Space-time data animation</h2><span id='topic+animation'></span>

<h3>Description</h3>

<p>Provide an animation of spatio-temporal point patterns.</p>


<h3>Usage</h3>

<pre><code class='language-R'>animation(xyt, s.region, t.region, runtime=1, incident="red", 
prevalent="pink3", pch=19, cex=0.5, plot.s.region=TRUE, 
scales=TRUE, border.frac=0.05, add=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animation_+3A_xyt">xyt</code></td>
<td>
<p>Data-matrix containing the <code class="reqn">(x,y,t)</code>-coordinates. </p>
</td></tr>
<tr><td><code id="animation_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing
all data-locations <code>xyt[,1:2]</code>.
If missing, <code>s.region</code> is the bounding box of <code>xyt[,1:2]</code>.</p>
</td></tr>
<tr><td><code id="animation_+3A_t.region">t.region</code></td>
<td>
<p>Interval containing all data-times <code>xyt[,3]</code>. 
If missing, <code>t.region</code> is defined by the range of <code>xyt[,3]</code>.</p>
</td></tr> 
<tr><td><code id="animation_+3A_runtime">runtime</code></td>
<td>
<p>Approximate running time of animation, in seconds, 
but it is longer than expected. Can also be <code>NULL</code>.</p>
</td></tr>  
<tr><td><code id="animation_+3A_incident">incident</code></td>
<td>
<p>Colour in which incident point <code>xyt[i,1:2]</code> is
plotted at time <code>xyt[i,3]</code>.</p>
</td></tr> 
<tr><td><code id="animation_+3A_prevalent">prevalent</code></td>
<td>
<p>Colour to which prevalent point <code>xyt[i,1:2]</code> fades
at time <code>xyt[i+1,3]</code>.</p>
</td></tr> 
<tr><td><code id="animation_+3A_pch">pch</code></td>
<td>
<p>Plotting symbol used for each point.</p>
</td></tr>
<tr><td><code id="animation_+3A_cex">cex</code></td>
<td>
<p>Magnification of plotting symbol relative to standard size.</p>
</td></tr>
<tr><td><code id="animation_+3A_plot.s.region">plot.s.region</code></td>
<td>
<p>If <code>TRUE</code>, plot <code>s.region</code> as polygon.</p>
</td></tr> 
<tr><td><code id="animation_+3A_scales">scales</code></td>
<td>
<p>If <code>TRUE</code>, plot X and Y axes with scales.</p>
</td></tr> 
<tr><td><code id="animation_+3A_border.frac">border.frac</code></td>
<td>
<p>Extent of border of plotting region surounding
<code>s.region</code>, as fraction of ranges of X and Y.</p>
</td></tr>
<tr><td><code id="animation_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, add the animation to an existing plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Peter J Diggle, Edith Gabriel &lt;edith.gabriel@inrae.fr&gt;.</p>

<hr>
<h2 id='as.3dpoints'>Create data in spatio-temporal point format</h2><span id='topic+as.3dpoints'></span>

<h3>Description</h3>

<p>Create data in spatio-temporal point format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.3dpoints(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.3dpoints_+3A_...">...</code></td>
<td>
<p>Any object(s), such as <code class="reqn">x</code>, <code class="reqn">y</code> and <code class="reqn">t</code> vectors of the same length, or a list or data frame containing <code class="reqn">x</code>, <code class="reqn">y</code> and <code class="reqn">t</code> vectors. Valid options for <code>...</code> are: a points object: returns it unaltered; a list with <code class="reqn">x</code>, <code class="reqn">y</code> and <code class="reqn">t</code> elements of the same length: returns a points object with the <code class="reqn">x</code>, <code class="reqn">y</code> and <code class="reqn">t</code> elements as the coordinates of the points; three vectors of equal length: returns a points object with the first vector as the <code class="reqn">x</code> coordinates, the second vector as the <code class="reqn">y</code>-coordinates and the third vector as the <code class="reqn">t</code>-coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is an object of the class <code>stpp</code>.
as.3dpoints tries to return the argument(s) as a spatio-temporal points object.
</p>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt;, Peter Diggle, Barry Rowlingson.</p>

<hr>
<h2 id='ASTIKhat'>Anisotropic Space-Time Inhomogeneous <code class="reqn">K</code>-function</h2><span id='topic+ASTIKhat'></span>

<h3>Description</h3>

<p>Compute an estimation of the Anisotropic Space-Time inhomogeneous <code class="reqn">K</code>-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASTIKhat(xyt, s.region, t.region, lambda, dist, times, ang,
  correction = "border")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ASTIKhat_+3A_xyt">xyt</code></td>
<td>
<p>Coordinates and times <code class="reqn">(x,y,t)</code> of the point pattern.</p>
</td></tr>
<tr><td><code id="ASTIKhat_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing all data locations. If <code>s.region</code> is missing, the bounding box of <code>xyt[,1:2]</code> is considered.</p>
</td></tr>
<tr><td><code id="ASTIKhat_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of the time interval. If <code>t.region</code> is missing, the range of <code>xyt[,3]</code> is considered.</p>
</td></tr>
<tr><td><code id="ASTIKhat_+3A_dist">dist</code></td>
<td>
<p>Vector of distances <code class="reqn">u</code> at which <code class="reqn">\widehat{K}_{\phi}(r,t)</code> is computed. If missing, the maximum of <code>dist</code> is given by <code class="reqn">\min(S_x,S_y)/4</code>, where <code class="reqn">S_x</code> and <code class="reqn">S_y</code> represent the maximum width and height of the bounding box of <code>s.region</code>.</p>
</td></tr>
<tr><td><code id="ASTIKhat_+3A_times">times</code></td>
<td>
<p>Vector of times <code class="reqn">v</code> at which <code class="reqn">\widehat{K}_{\phi}(r,t)</code> is computed. If missing, the maximum of <code>times</code> is given by <code class="reqn">(T_{\max} - T_{\min})/4</code>, where <code class="reqn">T_{\min}</code> and <code class="reqn">T_{\max}</code> are the minimum and maximum of the time interval <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="ASTIKhat_+3A_lambda">lambda</code></td>
<td>
<p>Vector of values of the space-time intensity function evaluated at the points <code class="reqn">(x,y,t)</code> in <code class="reqn">S\times T</code>. If <code>lambda</code> is missing, the estimate of the anisotropic space-time <code class="reqn">K</code>-function is computed as for the homogeneous case, i.e. considering <code class="reqn">n/|S\times T|</code> as an estimate of the space-time intensity.</p>
</td></tr>
<tr><td><code id="ASTIKhat_+3A_ang">ang</code></td>
<td>
<p>Angle in radians at which <code class="reqn">\widehat{K}_{\phi}(r,t)</code> is computed. The argument <code>ang=2*pi</code> by default.</p>
</td></tr>
<tr><td><code id="ASTIKhat_+3A_correction">correction</code></td>
<td>
<p>A character vector specifying the edge correction(s) to be applied among &quot;border&quot;, &quot;modified.border&quot;, &quot;translate&quot; and &quot;none&quot; (see <code><a href="#topic+STIKhat">STIKhat</a></code>). The default is &quot;border&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>AKhat</code></td>
<td>
<p><code>ndist</code> x <code>ntimes</code> matrix containing values of <code class="reqn">\widehat{K}_{\phi}(u,t)</code>.</p>
</td></tr>
<tr><td><code>dist</code>, <code>times</code></td>
<td>
<p>Parameters passed in argument.</p>
</td></tr>
<tr><td><code>correction</code></td>
<td>
<p>The name(s) of the edge correction method(s) passed in argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francisco J. Rodriguez-Cortes &lt;frrodriguezc@unal.edu.co&gt; 
</p>


<h3>References</h3>

<p>Illian, J. B., Penttinen, A., Stoyan, H. and Stoyan, D. (2008). Statistical Analysis and Modelling of Spatial Point Patterns. John Wiley and Sons, London.
</p>
<p>Gonzalez, J. A., Rodriguez-Cortes, F. J., Cronie, O., Mateu, J. (2016). Spatio-temporal point process statistics: a review. Spatial Statistics. Accepted.
</p>
<p>Ohser, J. and D. Stoyan (1981). On the second-order and orientation analysis of planar stationary point processes. Biometrical Journal 23, 523-533.
</p>

<hr>
<h2 id='fmd'>2001 food-and-mouth epidemic, north Cumbria (UK)</h2><span id='topic+fmd'></span>

<h3>Description</h3>

<p>This data set gives the spatial locations and reported times of food-and-mouth 
disease in north Cumbria (UK), 2001. It is of no scientific value, as it 
deliberately excludes confidential information on farms at risk in the
study-region. It is included in the package purely as an illustrative example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fmd)</code></pre>


<h3>Format</h3>

<p>A matrix containing <code class="reqn">(x,y,t)</code> coordinates of the 648 observations.</p>


<h3>References</h3>

<p>Diggle, P., Rowlingson, B. and Su, T. (2005). Point process methodology
for on-line spatio-temporal disease surveillance. Environmetrics, 16, 423&ndash;34.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+northcumbria">northcumbria</a></code> for boundaries of the county of north Cumbria.
</p>

<hr>
<h2 id='gsp'>Spatial mark variogram function
</h2><span id='topic+gsp'></span>

<h3>Description</h3>

<p>Computes an estimator of the spatial mark variogram function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsp(xyt,s.region,s.lambda,ds,ks="epanech",hs,correction="none",approach="simplified")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsp_+3A_xyt">xyt</code></td>
<td>
<p>Spatial coordinates and times <code class="reqn">(x,y,t)</code> of the point pattern.</p>
</td></tr>
<tr><td><code id="gsp_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing all data locations. </p>
</td></tr>
<tr><td><code id="gsp_+3A_s.lambda">s.lambda</code></td>
<td>
<p>Vector of values of the spatial intensity function evaluated at the points <code class="reqn">(x,y)</code> in <code class="reqn">W</code>. If <code>s.lambda</code> is missing, the estimate of the spatial mark correlation function is computed as for the homogeneous case, i.e. considering <code class="reqn">n/|W|</code> as an estimate of the spatial intensity under the parameter <code>approach="standardised"</code>.</p>
</td></tr>
<tr><td><code id="gsp_+3A_ds">ds</code></td>
<td>
<p>A vector of distances <code>u</code> at which <code>gsp(u)</code> is computed.</p>
</td></tr>
<tr><td><code id="gsp_+3A_ks">ks</code></td>
<td>
<p>A kernel function for the spatial distances. The default is the <code>"epanech"</code> kernel. It can also be <code>"box"</code> for the uniform kernel, or <code>"biweight"</code>.</p>
</td></tr>
<tr><td><code id="gsp_+3A_hs">hs</code></td>
<td>
<p>A bandwidth of the kernel function <code>ks</code>.</p>
</td></tr>
<tr><td><code id="gsp_+3A_correction">correction</code></td>
<td>
<p>A character vector specifying the edge-correction(s) to be applied among <code>"isotropic"</code>, <code>"border"</code>, <code>"modified.border"</code>, <code>"translate"</code>, <code>"setcovf"</code> and <code>"none"</code>. The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="gsp_+3A_approach">approach</code></td>
<td>
<p>A character vector specifying the approach to use for the estimation to be applied among &quot;simplified&quot; or <code>"standardised"</code>. If approach is missing, <code>"simplified"</code> is considered by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this command calculates an estimate of the spatial mark variogram function <code class="reqn">\gamma_[sp](r)</code> for a spatio-temporal point pattern.</p>


<h3>Value</h3>

<table>
<tr><td><code>egsp</code></td>
<td>
<p> A vector containing the values of <code class="reqn">\gamma_{sp}(r)</code> estimated</p>
</td></tr>
<tr><td><code>ds</code></td>
<td>
<p>If <code>ds</code> is missing, a vector of distances <code>u</code> at which <code>gsp(u)</code> is computed from 0 to until quarter of the maximum distance between the points in the pattern.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>A vector of names and bandwidth of the spatial kernel.</p>
</td></tr>
<tr><td><code>gsptheo</code></td>
<td>
<p>Value under the Poisson case is calculated considering <code class="reqn">\tau</code>=<code>max(xyt[,3])-min(xyt[,3])</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Francisco J. Rodriguez Cortes &lt;frrodriguezc@unal.edu.co&gt; <a href="https://fjrodriguezcortes.wordpress.com">https://fjrodriguezcortes.wordpress.com</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E., Turner, R. (2015). Spatial Point Patterns: Methodology and Applications with R. CRC Press, Boca Raton.
</p>
<p>Chiu, S. N., Stoyan, D., Kendall, W. S., and Mecke, J. (2013). Stochastic Geometry and its Applications. John Wiley &amp; Sons.
</p>
<p>Gabriel, E., Rowlingson, B., Diggle P J. (2013) <code>stpp</code>: an R package for plotting, simulating and analyzing Spatio-Temporal Point Patterns. Journal of Statistical Software. 53, 1-29.
</p>
<p>Illian, J B., Penttinen, A., Stoyan, H. and Stoyan, D. (2008). Statistical Analysis and Modelling of Spatial Point Patterns. John Wiley and Sons, London.
</p>
<p>Stoyan, D., Rodriguez-Cortes, F. J., Mateu, J., and Gille, W. (2017). Mark variograms for spatio-temporal point processes. Spatial Statistics. 20, 125-147.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:
#################

# A realisation of spatio-temporal homogeneous Poisson point processes
hpp &lt;- rpp(lambda = 100, replace = FALSE)$xyt

# R plot
plot(hpp)

# This function provides an kernel estimator of the spatial mark variogram function
out &lt;- gsp(hpp)

# R plot - Spatial mark variogram function
par(mfrow=c(1,1))
xl &lt;- c(0,0.25)
yl &lt;- c(0,max(out$gsptheo,out$egsp))
plot(out$ds,out$egsp,type="l",xlab="r = distance",ylab=expression(gamma[sp](r)),
                 xlim=xl,ylim=yl,col=1,cex.lab=1.5,cex.axis=1.5)
lines(out$ds,rep(out$gsptheo,length(out$ds)),col=11)

## End(Not run)

</code></pre>

<hr>
<h2 id='gte'>Temporal mark variogram function
</h2><span id='topic+gte'></span>

<h3>Description</h3>

<p>Computes an estimator of the temporal mark variogram function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gte(xyt,t.region,t.lambda,dt,kt="epanech",ht,correction="none",approach="simplified")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gte_+3A_xyt">xyt</code></td>
<td>
<p>Spatial coordinates and times <code class="reqn">(x,y,t)</code> of the point pattern.</p>
</td></tr>
<tr><td><code id="gte_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of the time interval.</p>
</td></tr>
<tr><td><code id="gte_+3A_t.lambda">t.lambda</code></td>
<td>
<p>Vector of values of the temporal intensity function evaluated at the points <code class="reqn">t</code> in <code class="reqn">T</code>. If <code>t.lambda</code> is missing, the estimate of the temporal mark correlation function is computed as for the homogeneous case, i.e. considering <code class="reqn">n/|T|</code> as an estimate of the temporal intensity under the parameter <code>approach="standardised"</code>.</p>
</td></tr>
<tr><td><code id="gte_+3A_dt">dt</code></td>
<td>
<p>A vector of times <code>v</code> at which <code>gte(v)</code> is computed.</p>
</td></tr>
<tr><td><code id="gte_+3A_kt">kt</code></td>
<td>
<p>A kernel function for the temporal distances. The default is the <code>"epanech"</code> kernel. It can also be <code>"box"</code> for the uniform kernel, or <code>"biweight"</code>.</p>
</td></tr>
<tr><td><code id="gte_+3A_ht">ht</code></td>
<td>
<p>A bandwidth of the kernel function <code>kt</code>.</p>
</td></tr>
<tr><td><code id="gte_+3A_correction">correction</code></td>
<td>
<p>A character vector specifying the edge-correction(s) to be applied among <code>"isotropic"</code>, <code>"border"</code>, <code>"modified.border"</code>, <code>"translate"</code>, <code>"setcovf"</code> and <code>"none"</code>. The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="gte_+3A_approach">approach</code></td>
<td>
<p>A character vector specifying the approach to use for the estimation to be applied among &quot;simplified&quot; or <code>"standardised"</code>. If approach is missing, <code>"simplified"</code> is considered by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this command calculates an estimate of the temporal mark variogram function <code class="reqn">\gamma_[te](t)</code> for a spatio-temporal point pattern.
</p>


<h3>Value</h3>

<table>
<tr><td><code>egte</code></td>
<td>
<p>A vector containing the values of <code class="reqn">\gamma_[te](v)</code> estimated.</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>Parameter passed in argument. If <code>dt</code> is missing, a vector of temporal distances <code>v</code> at which <code>gte(v)</code> is computed from 0 to until quarter of the maximum distance between the times in the temporal pattern.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>Parameters passed in argument. A vector of names and bandwidth of the spatial kernel.</p>
</td></tr>
<tr><td><code>gtetheo</code></td>
<td>
<p>Value under the Poisson case is calculated considering the side lengths of the bounding box of <code>xyt[,1:2]</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Francisco J. Rodriguez Cortes &lt;frrodriguezc@unal.edu.co&gt; <a href="https://fjrodriguezcortes.wordpress.com">https://fjrodriguezcortes.wordpress.com</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E., Turner, R. (2015). Spatial Point Patterns: Methodology and Applications with R. CRC Press, Boca Raton.
</p>
<p>Chiu, S. N., Stoyan, D., Kendall, W. S., and Mecke, J. (2013). Stochastic Geometry and its Applications. John Wiley &amp; Sons.
</p>
<p>Gabriel, E., Rowlingson, B., Diggle P J. (2013) <code>stpp</code>: an R package for plotting, simulating and analyzing Spatio-Temporal Point Patterns. Journal of Statistical Software 53, 1-29.
</p>
<p>Illian, J B., Penttinen, A., Stoyan, H. and Stoyan, D. (2008). Statistical Analysis and Modelling of Spatial Point Patterns. John Wiley and Sons, London.
</p>
<p>Stoyan, D., Rodriguez-Cortes, F. J., Mateu, J., and Gille, W. (2017). Mark variograms for spatio-temporal point processes. Spatial Statistics. 20, 125-147.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:
#################

# A realisation of spatio-temporal homogeneous Poisson point processes
hpp &lt;- rpp(lambda = 100, replace = FALSE)$xyt

# R plot
plot(hpp)

# This function provides an kernel estimator of the temporal mark variograma function
out &lt;- gte(hpp)

# R plot - Temporal mark variogram function
par(mfrow=c(1,1))
xl &lt;- c(0,0.25)
yl &lt;- c(0,max(out$egte,out$gtetheo))
plot(out$dt,out$egte,type="l",xlab="t = time",ylab=expression(gamma[te](t)),
                 xlim=xl,ylim=yl,col=1,cex.lab=1.5,cex.axis=1.5)
lines(out$dt,rep(out$gtetheo,length(out$dt)),col=11)

## End(Not run)

</code></pre>

<hr>
<h2 id='is.3dpoints'>Spatio-temporal point objects</h2><span id='topic+is.3dpoints'></span>

<h3>Description</h3>

<p>Tests for data in spatio-temporal point format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.3dpoints(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.3dpoints_+3A_x">x</code></td>
<td>
<p>any object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>is.3dpoints returns TRUE if <code>x</code> is a spatio-temporal points object, FALSE
otherwise.</p>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt;, Peter Diggle, Barry
Rowlingson.</p>

<hr>
<h2 id='KLISTAhat'>Estimation of the Space-Time Inhomogeneous K LISTA functions</h2><span id='topic+KLISTAhat'></span>

<h3>Description</h3>

<p>Compute an estimate of the space-time K LISTA functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>KLISTAhat(xyt, s.region, t.region, dist, times, lambda, correction = "isotropic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KLISTAhat_+3A_xyt">xyt</code></td>
<td>
<p>Coordinates and times <code class="reqn">(x,y,t)</code> of the point pattern.</p>
</td></tr>
<tr><td><code id="KLISTAhat_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing all data locations. If <code>s.region</code> is missing, the bounding box of <code>xyt[,1:2]</code> is considered.</p>
</td></tr>
<tr><td><code id="KLISTAhat_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of the time interval. If <code>t.region</code> is missing, the range of <code>xyt[,3]</code> is considered.</p>
</td></tr>
<tr><td><code id="KLISTAhat_+3A_dist">dist</code></td>
<td>
<p>Vector of distances <code class="reqn">u</code> at which <code class="reqn">K^{(i)}(u,v)</code> is computed. If missing, the maximum of <code>dist</code> is given by <code class="reqn">\min(S_x,S_y)/4</code>, where <code class="reqn">S_x</code> and <code class="reqn">S_y</code> represent the maximum width and height of the bounding box of <code>s.region</code>.</p>
</td></tr>
<tr><td><code id="KLISTAhat_+3A_times">times</code></td>
<td>
<p>Vector of times <code class="reqn">v</code> at which <code class="reqn">K^{(i)}(u,v)</code> is computed.  If missing, the maximum of <code>times</code> is given by <code class="reqn">(T_{\max} - T_{\min})/4</code>, where <code class="reqn">T_{\min}</code> and <code class="reqn">T_{\max}</code> are the minimum and maximum of the time interval <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="KLISTAhat_+3A_lambda">lambda</code></td>
<td>
<p>Vector of values of the space-time intensity function evaluated at the points <code class="reqn">(x,y,t)</code> in <code class="reqn">S\times T</code>. If <code>lambda</code> is missing, the estimate of the space-time pair correlation function is computed as for the homogeneous case, i.e. considering <code class="reqn">(n-1)/|S \times T|</code> as an estimate of the space-time intensity.</p>
</td></tr>
<tr><td><code id="KLISTAhat_+3A_correction">correction</code></td>
<td>
<p>A character vector specifying the edge correction(s) to be applied among <code>"isotropic"</code>, <code>"border"</code>, <code>"modified.border"</code>, <code>"translate"</code> and <code>"none"</code> (see <code><a href="#topic+PCFhat">PCFhat</a></code>). The default is <code>"isotropic"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An individual product density LISTA functions <code class="reqn">K^{(i)}(.,.)</code> should reveal the extent of the contribution of the event <code class="reqn">(u_i,t_i)</code> to the global estimator of the K-function <code class="reqn">K(.,.)</code>, and may provide a further description of structure in the data (e.g., determining events with similar local structure through dissimilarity measures of the individual LISTA functions), for more details see Siino et al. (2019).</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>list.KLISTA</code></td>
<td>
<p> A list containing the values of the estimation of <code class="reqn">K^{(i)}(r,t)</code> for each one of <code class="reqn">n</code> points of the point pattern by matrixs.</p>
</td></tr>
<tr><td><code>klistatheo</code></td>
<td>
<p><code>ndist</code> x <code>ntimes</code> matrix containing theoretical values for a Poisson process.</p>
</td></tr>
<tr><td><code>dist</code>, <code>times</code></td>
<td>
<p>Parameters passed in argument.</p>
</td></tr>
<tr><td><code>correction</code></td>
<td>
<p>The name(s) of the edge correction method(s) passed in argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francisco J. Rodriguez-Cortes &lt;frrodriguezc@unal.edu.co&gt;</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, J. (2005). <code>spatstat</code>: An R Package for Analyzing Spatial Point Pattens. Journal of Statistical Software 12, 1-42.
</p>
<p>Cressie, N. and Collins, L. B. (2001). Analysis of spatial point patterns using bundles of product density LISA functions. Journal of Agricultural, Biological, and Environmental Statistics 6, 118-135.
</p>
<p>Cressie, N. and Collins, L. B. (2001). Patterns in spatial point locations: Local indicators of spatial association in a minefield with clutter Naval Research Logistics (NRL), John Wiley &amp; Sons, Inc. 48, 333-347.
</p>
<p>Siino, M., Adelfio, G., Mateu, J. and Rodriguez-Cortes, F. J. (2019). Some properties of weighted local second-order statistcs for spatio-temporal point process. Submitted.
</p>
<p>Stoyan, D. and Stoyan, H. (1994). Fractals, random shapes, and point fields: methods of geometrical statistics. Chichester: Wiley.
</p>

<hr>
<h2 id='kmmr'>Spatial mark correlation function

</h2><span id='topic+kmmr'></span>

<h3>Description</h3>

<p>Computes an estimator of the spatial mark correlation function.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kmmr(xyt,s.region,s.lambda,ds,ks="epanech",hs,correction="none",approach="simplified")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmmr_+3A_xyt">xyt</code></td>
<td>
<p>Spatial coordinates and times <code class="reqn">(x,y,t)</code> of the point pattern.</p>
</td></tr>
<tr><td><code id="kmmr_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing all data locations. </p>
</td></tr>
<tr><td><code id="kmmr_+3A_s.lambda">s.lambda</code></td>
<td>
<p>Vector of values of the spatial intensity function evaluated at the points <code class="reqn">(x,y)</code> in <code class="reqn">W</code>. If <code>s.lambda</code> is missing, the estimate of the spatial mark correlation function is computed as for the homogeneous case, i.e. considering <code class="reqn">n/|W|</code> as an estimate of the spatial intensity under the parameter <code>approach="standardised"</code>.</p>
</td></tr>
<tr><td><code id="kmmr_+3A_ds">ds</code></td>
<td>
<p>A vector of distances <code>u</code> at which <code>kmmr(u)</code> is computed.</p>
</td></tr>
<tr><td><code id="kmmr_+3A_ks">ks</code></td>
<td>
<p>A kernel function for the spatial distances. The default is the <code>"epanech"</code> kernel. It can also be <code>"box"</code> for the uniform kernel, or <code>"biweight"</code>.</p>
</td></tr>
<tr><td><code id="kmmr_+3A_hs">hs</code></td>
<td>
<p>A bandwidth of the kernel function <code>ks</code>.</p>
</td></tr>
<tr><td><code id="kmmr_+3A_correction">correction</code></td>
<td>
<p>A character vector specifying the edge-correction(s) to be applied among <code>"isotropic"</code>, <code>"border"</code>, <code>"modified.border"</code>, <code>"translate"</code>, <code>"setcovf"</code> and <code>"none"</code>. The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="kmmr_+3A_approach">approach</code></td>
<td>
<p>A character vector specifying the approach to use for the estimation to be applied among &quot;simplified&quot; or <code>"standardised"</code>. If approach is missing, <code>"simplified"</code> is considered by default.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>By default, this command calculates an estimate of the spatial mark correlation function <code class="reqn">k_[mm](r)</code> for a spatio-temporal point pattern.

</p>


<h3>Value</h3>



<table>
<tr><td><code>ekmmr</code></td>
<td>
<p>A vector containing the values of <code class="reqn">k_[mm](u)</code> estimated.</p>
</td></tr>
<tr><td><code>ds</code></td>
<td>
<p>If <code>ds</code> is missing, a vector of distances <code>u</code> at which <code>kmmr(u)</code> is computed from 0 to until quarter of the maximum distance between the points in the pattern.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>A vector of names and bandwidth of the spatial kernel.</p>
</td></tr>
<tr><td><code>kmmrtheo</code></td>
<td>
<p>Value under the Poisson case is calculated considering <code class="reqn">\tau</code>=<code>max(xyt[,3])-min(xyt[,3])</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francisco J. Rodriguez Cortes &lt;frrodriguezc@unal.edu.co&gt; <a href="https://fjrodriguezcortes.wordpress.com">https://fjrodriguezcortes.wordpress.com</a>

</p>


<h3>References</h3>


<p>Baddeley, A., Rubak, E., Turner, R. (2015). Spatial Point Patterns: Methodology and Applications with R. CRC Press, Boca Raton.
</p>
<p>Chiu, S. N., Stoyan, D., Kendall, W. S., and Mecke, J. (2013). Stochastic Geometry and its Applications. John Wiley &amp; Sons.
</p>
<p>Gabriel, E., Rowlingson, B., Diggle P J. (2013) <code>stpp</code>: an R package for plotting, simulating and analyzing Spatio-Temporal Point Patterns. Journal of Statistical Software 53, 1-29.
</p>
<p>Illian, J B., Penttinen, A., Stoyan, H. and Stoyan, D. (2008). Statistical Analysis and Modelling of Spatial Point Patterns. John Wiley and Sons, London.
</p>
<p>Stoyan, D., Rodriguez-Cortes, F. J., Mateu, J. and Wilfried, G. (2016). Mark variograms for spatio-temporal
point processes, Submitted .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run:
    #################
    
    # A realisation of spatio-temporal homogeneous Poisson point processes
    hpp &lt;- rpp(lambda = 100, replace = FALSE)$xyt
    
    # R plot
    plot(hpp)
    
    # This function provides an kernel estimator of the spatial mark correlation function
    out &lt;- kmmr(hpp)
    
    # R plot - Spatial mark correlation function
    par(mfrow=c(1,1))
    xl &lt;- c(0,0.25)
    plot(out$ds,out$ekmmr,type="l",xlab="r = distance",ylab=expression(k[mm](r)),
         xlim=xl,col=1,cex.lab=1.5,cex.axis=1.5)
    lines(out$ds,rep(out$kmmrtheo,length(out$ds)),col=11)
    
    ## End(Not run)
    
  </code></pre>

<hr>
<h2 id='kmmt'>Temporal mark correlation function

</h2><span id='topic+kmmt'></span>

<h3>Description</h3>

<p>Computes an estimator of the temporal mark correlation function.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kmmt(xyt,t.region,t.lambda,dt,kt="epanech",ht,correction="none",approach="simplified")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmmt_+3A_xyt">xyt</code></td>
<td>
<p>Spatial coordinates and times <code class="reqn">(x,y,t)</code> of the point pattern.</p>
</td></tr>
<tr><td><code id="kmmt_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of the time interval.</p>
</td></tr>
<tr><td><code id="kmmt_+3A_t.lambda">t.lambda</code></td>
<td>
<p>Vector of values of the temporal intensity function evaluated at the points <code class="reqn">t</code> in <code class="reqn">T</code>. If <code>t.lambda</code> is missing, the estimate of the temporal mark correlation function is computed as for the homogeneous case, i.e. considering <code class="reqn">n/|T|</code> as an estimate of the temporal intensity under the parameter <code>approach="standardised"</code>.</p>
</td></tr>
<tr><td><code id="kmmt_+3A_dt">dt</code></td>
<td>
<p>A vector of times <code>v</code> at which <code>kmmt(v)</code> is computed.</p>
</td></tr>
<tr><td><code id="kmmt_+3A_kt">kt</code></td>
<td>
<p>A kernel function for the temporal distances. The default is the <code>"epanech"</code> kernel. It can also be <code>"box"</code> for the uniform kernel, or <code>"biweight"</code>.</p>
</td></tr>
<tr><td><code id="kmmt_+3A_ht">ht</code></td>
<td>
<p>A bandwidth of the kernel function <code>kt</code>.</p>
</td></tr>
<tr><td><code id="kmmt_+3A_correction">correction</code></td>
<td>
<p>A character vector specifying the edge-correction(s) to be applied among <code>"isotropic"</code>, <code>"border"</code>, <code>"modified.border"</code>, <code>"translate"</code>, <code>"setcovf"</code> and <code>"none"</code>. The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="kmmt_+3A_approach">approach</code></td>
<td>
<p>A character vector specifying the approach to use for the estimation to be applied among &quot;simplified&quot; or <code>"standardised"</code>. If approach is missing, <code>"simplified"</code> is considered by default.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>By default, this command calculates an estimate of the temporal mark correlation function <code class="reqn">k_[mm](t)</code> for a spatio-temporal point pattern.

</p>


<h3>Value</h3>



<table>
<tr><td><code>ekmmt</code></td>
<td>
<p>A vector containing the values of <code class="reqn">k_[mm](v)</code> estimated.</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>Parameter passed in argument. If <code>dt</code> is missing, a vector of temporal distances <code>v</code> at which <code>kmmt(v)</code> is computed from 0 to until quarter of the maximum distance between the times in the temporal pattern.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>Parameters passed in argument. A vector of names and bandwidth of the spatial kernel.</p>
</td></tr>
<tr><td><code>kmmttheo</code></td>
<td>
<p>Value under the Poisson case is calculated considering the side lengths of the bounding box of <code>xyt[,1:2]</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Francisco J. Rodriguez Cortes &lt;frrodriguezc@unal.edu.co&gt; <a href="https://fjrodriguezcortes.wordpress.com">https://fjrodriguezcortes.wordpress.com</a>

</p>


<h3>References</h3>


<p>Baddeley, A., Rubak, E., Turner, R. (2015). Spatial Point Patterns: Methodology and Applications with R. CRC Press, Boca Raton.
</p>
<p>Chiu, S. N., Stoyan, D., Kendall, W. S., and Mecke, J. (2013). Stochastic Geometry and its Applications. John Wiley &amp; Sons.
</p>
<p>Gabriel, E., Rowlingson, B., Diggle P J. (2013) <code>stpp</code>: an R package for plotting, simulating and analyzing Spatio-Temporal Point Patterns. Journal of Statistical Software 53, 1-29.
</p>
<p>Illian, J B., Penttinen, A., Stoyan, H. and Stoyan, D. (2008). Statistical Analysis and Modelling of Spatial Point Patterns. John Wiley and Sons, London.
</p>
<p>Stoyan, D., Rodriguez-Cortes, F. J., Mateu, J. and Wilfried, G. (2016). Mark variograms for spatio-temporal
point processes, Submitted .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run:
    #################
    
    # A realisation of spatio-temporal homogeneous Poisson point processes
    hpp &lt;- rpp(lambda = 100, replace = FALSE)$xyt
    
    # R plot
    plot(hpp)
    
    # This function provides an kernel estimator of the temporal mark correlation function
    out &lt;- kmmt(hpp)
    
    # R plot - Temporal mark correlation function
    par(mfrow=c(1,1))
    xl &lt;- c(0,0.25)
    plot(out$dt,out$ekmmt,type="l",xlab="t = time",ylab=expression(k[mm](t)),
         xlim=xl,col=1,cex.lab=1.5,cex.axis=1.5)
    lines(out$dt,rep(out$kmmttheo,length(out$dt)),col=11)
    
    ## End(Not run)
    
  </code></pre>

<hr>
<h2 id='kmr'>Spatial <code class="reqn">r</code>-mark function

</h2><span id='topic+kmr'></span>

<h3>Description</h3>

<p>Computes an estimator of the spatial <code class="reqn">r</code>-mark function.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kmr(xyt,s.region,s.lambda,ds,ks="epanech",hs,correction="none",approach="simplified")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmr_+3A_xyt">xyt</code></td>
<td>
<p>Spatial coordinates and times <code class="reqn">(x,y,t)</code> of the point pattern.</p>
</td></tr>
<tr><td><code id="kmr_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing all data locations. </p>
</td></tr>
<tr><td><code id="kmr_+3A_s.lambda">s.lambda</code></td>
<td>
<p>Vector of values of the spatial intensity function evaluated at the points <code class="reqn">(x,y)</code> in <code class="reqn">W</code>. If <code>s.lambda</code> is missing, the estimate of the spatial mark correlation function is computed as for the homogeneous case, i.e. considering <code class="reqn">n/|W|</code> as an estimate of the spatial intensity under the parameter <code>approach="standardised"</code>.</p>
</td></tr>
<tr><td><code id="kmr_+3A_ds">ds</code></td>
<td>
<p>A vector of distances <code>u</code> at which <code>kmr(u)</code> is computed.</p>
</td></tr>
<tr><td><code id="kmr_+3A_ks">ks</code></td>
<td>
<p>A kernel function for the spatial distances. The default is the <code>"epanech"</code> kernel. It can also be <code>"box"</code> for the uniform kernel, or <code>"biweight"</code>.</p>
</td></tr>
<tr><td><code id="kmr_+3A_hs">hs</code></td>
<td>
<p>A bandwidth of the kernel function <code>ks</code>.</p>
</td></tr>
<tr><td><code id="kmr_+3A_correction">correction</code></td>
<td>
<p>A character vector specifying the edge-correction(s) to be applied among <code>"isotropic"</code>, <code>"border"</code>, <code>"modified.border"</code>, <code>"translate"</code>, <code>"setcovf"</code> and <code>"none"</code>. The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="kmr_+3A_approach">approach</code></td>
<td>
<p>A character vector specifying the approach to use for the estimation to be applied among &quot;simplified&quot; or <code>"standardised"</code>. If approach is missing, <code>"simplified"</code> is considered by default.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>By default, this command calculates an estimate of the spatial <code class="reqn">r</code>-mark function <code class="reqn">k_[m.](r)</code> for a spatio-temporal point pattern.

</p>


<h3>Value</h3>



<table>
<tr><td><code>ekmr</code></td>
<td>
<p>A vector containing the values of <code class="reqn">k_[m.](u)</code> estimated.</p>
</td></tr>
<tr><td><code>ds</code></td>
<td>
<p>If <code>ds</code> is missing, a vector of distances <code>u</code> at which <code>kmr(u)</code> is computed from 0 to until quarter of the maximum distance between the points in the pattern.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>A vector of names and bandwidth of the spatial kernel.</p>
</td></tr>
<tr><td><code>kmrtheo</code></td>
<td>
<p>Value under the Poisson case is calculated considering <code class="reqn">\tau</code>=<code>max(xyt[,3])-min(xyt[,3])</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Francisco J. Rodriguez Cortes &lt;frrodriguezc@unal.edu.co&gt; <a href="https://fjrodriguezcortes.wordpress.com">https://fjrodriguezcortes.wordpress.com</a>

</p>


<h3>References</h3>


<p>Baddeley, A., Rubak, E., Turner, R. (2015). Spatial Point Patterns: Methodology and Applications with R. CRC Press, Boca Raton.
</p>
<p>Chiu, S. N., Stoyan, D., Kendall, W. S., and Mecke, J. (2013). Stochastic Geometry and its Applications. John Wiley &amp; Sons.
</p>
<p>Gabriel, E., Rowlingson, B., Diggle P J. (2013) <code>stpp</code>: an R package for plotting, simulating and analyzing Spatio-Temporal Point Patterns. Journal of Statistical Software 53, 1-29.
</p>
<p>Illian, J B., Penttinen, A., Stoyan, H. and Stoyan, D. (2008). Statistical Analysis and Modelling of Spatial Point Patterns. John Wiley and Sons, London.
</p>
<p>Stoyan, D., Rodriguez-Cortes, F. J., Mateu, J. and Wilfried, G. (2016). Mark variograms for spatio-temporal
point processes, Submitted .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run:
    #################
    
    # A realisation of spatio-temporal homogeneous Poisson point processes
    hpp &lt;- rpp(lambda = 100, replace = FALSE)$xyt
    
    # R plot
    plot(hpp)
    
    # This function provides an kernel estimator of the spatial r-mark function
    out &lt;- kmr(hpp)
    
    # R plot - Spatial r-mark function
    par(mfrow=c(1,1))
    xl &lt;- c(0,0.25)
    plot(out$ds,out$ekmr,type="l",xlab="r = distance",ylab=expression(k[m.](r)),
         xlim=xl,col=1,cex.lab=1.5,cex.axis=1.5)
    lines(out$ds,rep(out$kmrtheo,length(out$ds)),col=11)
    
    ## End(Not run)
  </code></pre>

<hr>
<h2 id='kmt'>Temporal <code class="reqn">t</code>-mark function

</h2><span id='topic+kmt'></span>

<h3>Description</h3>

<p>Computes an estimator of the temporal <code class="reqn">t</code>-mark function.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmt(xyt,t.region,t.lambda,dt,kt="epanech",ht,correction="none",approach="simplified")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmt_+3A_xyt">xyt</code></td>
<td>
<p>Spatial coordinates and times <code class="reqn">(x,y,t)</code> of the point pattern.</p>
</td></tr>
<tr><td><code id="kmt_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of the time interval.</p>
</td></tr>
<tr><td><code id="kmt_+3A_t.lambda">t.lambda</code></td>
<td>
<p>Vector of values of the temporal intensity function evaluated at the points <code class="reqn">t</code> in <code class="reqn">T</code>. If <code>t.lambda</code> is missing, the estimate of the temporal mark correlation function is computed as for the homogeneous case, i.e. considering <code class="reqn">n/|T|</code> as an estimate of the temporal intensity under the parameter <code>approach="standardised"</code>.</p>
</td></tr>
<tr><td><code id="kmt_+3A_dt">dt</code></td>
<td>
<p>A vector of times <code>v</code> at which <code>kmt(v)</code> is computed.</p>
</td></tr>
<tr><td><code id="kmt_+3A_kt">kt</code></td>
<td>
<p>A kernel function for the temporal distances. The default is the <code>"epanech"</code> kernel. It can also be <code>"box"</code> for the uniform kernel, or <code>"biweight"</code>.</p>
</td></tr>
<tr><td><code id="kmt_+3A_ht">ht</code></td>
<td>
<p>A bandwidth of the kernel function <code>kt</code>.</p>
</td></tr>
<tr><td><code id="kmt_+3A_correction">correction</code></td>
<td>
<p>A character vector specifying the edge-correction(s) to be applied among <code>"isotropic"</code>, <code>"border"</code>, <code>"modified.border"</code>, <code>"translate"</code>, <code>"setcovf"</code> and <code>"none"</code>. The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="kmt_+3A_approach">approach</code></td>
<td>
<p>A character vector specifying the approach to use for the estimation to be applied among &quot;simplified&quot; or <code>"standardised"</code>. If approach is missing, <code>"simplified"</code> is considered by default.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>By default, this command calculates an estimate of the temporal <code class="reqn">t</code>-mark function <code class="reqn">k_[m.](t)</code> for a spatio-temporal point pattern.

</p>


<h3>Value</h3>



<table>
<tr><td><code>ekmt</code></td>
<td>
<p>A vector containing the values of <code class="reqn">k_[m.](v)</code> estimated.</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>Parameter passed in argument. If <code>dt</code> is missing, a vector of temporal distances <code>v</code> at which <code>kmt(v)</code> is computed from 0 to until quarter of the maximum distance between the times in the temporal pattern.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>Parameters passed in argument. A vector of names and bandwidth of the spatial kernel.</p>
</td></tr>
<tr><td><code>kmttheo</code></td>
<td>
<p>Value under the Poisson case is calculated considering the side lengths of the bounding box of <code>xyt[,1:2]</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francisco J. Rodriguez Cortes &lt;frrodriguezc@unal.edu.co&gt; <a href="https://fjrodriguezcortes.wordpress.com">https://fjrodriguezcortes.wordpress.com</a>

</p>


<h3>References</h3>


<p>Baddeley, A., Rubak, E., Turner, R. (2015). Spatial Point Patterns: Methodology and Applications with R. CRC Press, Boca Raton.
</p>
<p>Chiu, S. N., Stoyan, D., Kendall, W. S., and Mecke, J. (2013). Stochastic Geometry and its Applications. John Wiley &amp; Sons.
</p>
<p>Gabriel, E., Rowlingson, B., Diggle P J. (2013) <code>stpp</code>: an R package for plotting, simulating and analyzing Spatio-Temporal Point Patterns. Journal of Statistical Software 53, 1-29.
</p>
<p>Illian, J B., Penttinen, A., Stoyan, H. and Stoyan, D. (2008). Statistical Analysis and Modelling of Spatial Point Patterns. John Wiley and Sons, London.
</p>
<p>Stoyan, D., Rodriguez-Cortes, F. J., Mateu, J. and Wilfried, G. (2016). Mark variograms for spatio-temporal
point processes, Submitted .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run:
    #################
    
    # A realisation of spatio-temporal homogeneous Poisson point processes
    hpp &lt;- rpp(lambda = 100, replace = FALSE)$xyt
    
    # R plot
    plot(hpp)
    
    # This function provides an kernel estimator of the temporal t-mark function
    out &lt;- kmt(hpp)
    
    # R plot - Temporal t-mark function
    par(mfrow=c(1,1))
    xl &lt;- c(0,0.25)
    plot(out$dt,out$ekmt,type="l",xlab="t = time",ylab=expression(k[m.](t)),
         xlim=xl,col=1,cex.lab=1.5,cex.axis=1.5)
    lines(out$dt,rep(out$kmttheo,length(out$dt)),col=11)
    
    ## End(Not run)
    
  </code></pre>

<hr>
<h2 id='LISTAhat'>Estimation of the Space-Time Inhomogeneous Pair Correlation LISTA functions</h2><span id='topic+LISTAhat'></span>

<h3>Description</h3>

<p>Compute an estimate of the space-time pair correlarion LISTA functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>LISTAhat(xyt, s.region, t.region, dist, times, lambda,
ks = "box", hs, kt = "box", ht, correction = "isotropic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LISTAhat_+3A_xyt">xyt</code></td>
<td>
<p>Coordinates and times <code class="reqn">(x,y,t)</code> of the point pattern.</p>
</td></tr>
<tr><td><code id="LISTAhat_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing all data locations. If <code>s.region</code> is missing, the bounding box of <code>xyt[,1:2]</code> is considered.</p>
</td></tr>
<tr><td><code id="LISTAhat_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of the time interval. If <code>t.region</code> is missing, the range of <code>xyt[,3]</code> is considered.</p>
</td></tr>
<tr><td><code id="LISTAhat_+3A_dist">dist</code></td>
<td>
<p>Vector of distances <code class="reqn">u</code> at which <code class="reqn">g^{(i)}(u,v)</code> is computed. If missing, the maximum of <code>dist</code> is given by <code class="reqn">\min(S_x,S_y)/4</code>, where <code class="reqn">S_x</code> and <code class="reqn">S_y</code> represent the maximum width and height of the bounding box of <code>s.region</code>.</p>
</td></tr>
<tr><td><code id="LISTAhat_+3A_times">times</code></td>
<td>
<p>Vector of times <code class="reqn">v</code> at which <code class="reqn">g^{(i)}(u,v)</code> is computed.  If missing, the maximum of <code>times</code> is given by <code class="reqn">(T_{\max} - T_{\min})/4</code>, where <code class="reqn">T_{\min}</code> and <code class="reqn">T_{\max}</code> are the minimum and maximum of the time interval <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="LISTAhat_+3A_lambda">lambda</code></td>
<td>
<p>Vector of values of the space-time intensity function evaluated at the points <code class="reqn">(x,y,t)</code> in <code class="reqn">S\times T</code>. If <code>lambda</code> is missing, the estimate of the space-time pair correlation function is computed as for the homogeneous case, i.e. considering <code class="reqn">(n-1)/|S \times T|</code> as an estimate of the space-time intensity.</p>
</td></tr>
<tr><td><code id="LISTAhat_+3A_ks">ks</code></td>
<td>
<p>Kernel function for the spatial distances. Default is the <code>"box"</code> kernel. Can also be <code>"epanech"</code> for the Epanechnikov kernel or <code>"gaussian"</code> or <code>"biweight"</code>.</p>
</td></tr>
<tr><td><code id="LISTAhat_+3A_hs">hs</code></td>
<td>
<p>Bandwidth of the kernel function <code>ks</code>.</p>
</td></tr>
<tr><td><code id="LISTAhat_+3A_kt">kt</code></td>
<td>
<p>Kernel function for the temporal distances. Default is the <code>"box"</code> kernel. Can also be <code>"epanech"</code> for the Epanechnikov kernel or <code>"gaussian"</code> or <code>"biweight"</code>.</p>
</td></tr>
<tr><td><code id="LISTAhat_+3A_ht">ht</code></td>
<td>
<p>Bandwidth of the kernel function <code>kt</code>.</p>
</td></tr>
<tr><td><code id="LISTAhat_+3A_correction">correction</code></td>
<td>
<p>A character vector specifying the edge correction(s) to be applied among <code>"isotropic"</code>, <code>"border"</code>, <code>"modified.border"</code>, <code>"translate"</code> and <code>"none"</code> (see <code><a href="#topic+PCFhat">PCFhat</a></code>). The default is <code>"isotropic"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An individual product density LISTA functions <code class="reqn">g^{(i)}(.,.)</code> should reveal the extent of the contribution of the event <code class="reqn">(u_i,t_i)</code> to the global estimator of the pair correlation function <code class="reqn">g(.,.)</code>, and may provide a further description of structure in the data (e.g., determining events with similar local structure through dissimilarity measures of the individual LISTA functions), for more details see Siino et al. (2017).</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>list.LISTA</code></td>
<td>
<p> A list containing the values of the estimation of <code class="reqn">g^{(i)}(r,t)</code> for each one of <code class="reqn">n</code> points of the point pattern by matrixs.</p>
</td></tr>
<tr><td><code>listatheo</code></td>
<td>
<p><code>ndist</code> x <code>ntimes</code> matrix containing theoretical values for a Poisson process.</p>
</td></tr>
<tr><td><code>dist</code>, <code>times</code></td>
<td>
<p>Parameters passed in argument.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>Vector of names and bandwidths of the spatial and temporal kernels.</p>
</td></tr>
<tr><td><code>correction</code></td>
<td>
<p>The name(s) of the edge correction method(s) passed in argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francisco J. Rodriguez-Cortes &lt;frrodriguezc@unal.edu.co&gt;</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, J. (2005). <code>spatstat</code>: An R Package for Analyzing Spatial Point Pattens. Journal of Statistical Software 12, 1-42.
</p>
<p>Cressie, N. and Collins, L. B. (2001). Analysis of spatial point patterns using bundles of product density LISA functions. Journal of Agricultural, Biological, and Environmental Statistics 6, 118-135.
</p>
<p>Cressie, N. and Collins, L. B. (2001). Patterns in spatial point locations: Local indicators of spatial association in a minefield with clutter Naval Research Logistics (NRL), John Wiley &amp; Sons, Inc. 48, 333-347.
</p>
<p>Siino, M., Rodriguez-Cortes, F. J., Mateu, J. and Adelfio, G. (2017). Testing for local structure in spatio-temporal point pattern data. Environmetrics. DOI: 10.1002/env.2463.
</p>
<p>Stoyan, D. and Stoyan, H. (1994). Fractals, random shapes, and point fields: methods of geometrical statistics. Chichester: Wiley.
</p>

<hr>
<h2 id='northcumbria'>Polygon boundary of north Cumbria</h2><span id='topic+northcumbria'></span>

<h3>Description</h3>

<p>This data set gives the boundary of the county of north Cumbria (UK).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(northcumbria)</code></pre>


<h3>Format</h3>

<p>A matrix containing <code class="reqn">(x,y)</code> coordinates of the boundary.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmd">fmd</a></code> for the space-time pattern of food-and-mouth disease in this county in 2001.
</p>

<hr>
<h2 id='PCFhat'>Estimation of the Space-Time Inhomogeneous Pair Correlation function</h2><span id='topic+PCFhat'></span>

<h3>Description</h3>

<p>Compute an estimate of the space-time pair correlation function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCFhat(xyt, s.region, t.region, dist, times, lambda,
ks="box", hs, kt="box", ht, correction = "isotropic") </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCFhat_+3A_xyt">xyt</code></td>
<td>
<p>Coordinates and times <code class="reqn">(x,y,t)</code> of the point pattern.</p>
</td></tr>
<tr><td><code id="PCFhat_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing all data locations. If <code>s.region</code> is missing, the bounding box of <code>xyt[,1:2]</code> is considered.</p>
</td></tr>
<tr><td><code id="PCFhat_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of the time interval. If <code>t.region</code> is missing, the range of <code>xyt[,3]</code> is considered.</p>
</td></tr>
<tr><td><code id="PCFhat_+3A_dist">dist</code></td>
<td>
<p>Vector of distances <code class="reqn">u</code> at which <code class="reqn">g(u,v)</code> is computed. If missing, the maximum of <code>dist</code> is given by <code class="reqn">\min(S_x,S_y)/4</code>, where <code class="reqn">S_x</code> and <code class="reqn">S_y</code> represent the maximum width and height of the bounding box of <code>s.region</code>.</p>
</td></tr>
<tr><td><code id="PCFhat_+3A_times">times</code></td>
<td>
<p>Vector of times <code class="reqn">v</code> at which <code class="reqn">g(u,v)</code> is computed.  If missing, the maximum of <code>times</code> is given by <code class="reqn">(T_{\max} - T_{\min})/4</code>, where <code class="reqn">T_{\min}</code> and <code class="reqn">T_{\max}</code> are the minimum and maximum of the time interval <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="PCFhat_+3A_lambda">lambda</code></td>
<td>
<p>Vector of values of the space-time intensity function evaluated at the points <code class="reqn">(x,y,t)</code> in <code class="reqn">S\times T</code>. If <code>lambda</code> is missing, the estimate of the space-time pair correlation function is computed as for the homogeneous case, i.e. considering <code class="reqn">n/|S \times T|</code> as an estimate of the space-time intensity.</p>
</td></tr>
<tr><td><code id="PCFhat_+3A_ks">ks</code></td>
<td>
<p>Kernel function for the spatial distances. Default is the <code>"box"</code> kernel. Can also be <code>"epanech"</code> for the Epanechnikov kernel or <code>"gaussian"</code> or <code>"biweight"</code>.</p>
</td></tr>
<tr><td><code id="PCFhat_+3A_hs">hs</code></td>
<td>
<p>Bandwidth of the kernel function <code>ks</code>.</p>
</td></tr>
<tr><td><code id="PCFhat_+3A_kt">kt</code></td>
<td>
<p>Kernel function for the temporal distances. Default is the <code>"box"</code> kernel. Can also be <code>"epanech"</code> for the Epanechnikov kernel or <code>"gaussian"</code> or <code>"biweight"</code>.</p>
</td></tr>
<tr><td><code id="PCFhat_+3A_ht">ht</code></td>
<td>
<p>Bandwidth of the kernel function <code>kt</code>.</p>
</td></tr>
<tr><td><code id="PCFhat_+3A_correction">correction</code></td>
<td>
<p>A character vector specifying the edge correction(s) to be applied among <code>"isotropic"</code>, <code>"border"</code>, <code>"modified.border"</code>, <code>"translate"</code> and <code>"none"</code> (see Details). The default is <code>"isotropic"</code>.</p>
</td></tr></table>


<h3>Details</h3>

<p>An approximately unbiased estimator for the space-time pair correlation function, based on data giving the locations of events <code class="reqn">x_i: i=1,...n</code> on a spatio-temporal region <code class="reqn">S \times T</code>, where <code class="reqn">S</code> is an arbitrary polygon and <code class="reqn">T</code> a time interval: 
</p>
<p style="text-align: center;"><code class="reqn">\widehat{g}(u,v)=\frac{1}{4\pi u}\sum_{i=1}^{n}\sum_{j \neq i} \frac{1}{w_{ij}}\frac{k_{s}(u-\|s_i-s_j\|)k_{t}(v-|t_i-t_j|)}{\lambda(x_i) \lambda(x_j)},</code>
</p>

<p>where <code class="reqn">\lambda(x_i)</code> is the intensity at <code class="reqn">x_i = (s_i,t_i)</code> and <code class="reqn">w_{ij}</code> is an edge correction factor to deal with spatial-temporal edge effects. The edge correction methods implemented are:
</p>
<p><code>isotropic</code>: <code class="reqn">w_{ij} = |S \times T| w_{ij}^{(t)} w_{ij}^{(s)}</code>, where the temporal edge correction factor <code class="reqn">w_{ij}^{(t)} = 1</code> if both ends of the interval of length <code class="reqn">2 |t_i - t_j|</code> centred at <code class="reqn">t_i</code> lie within <code class="reqn">T</code> and <code class="reqn">w_{ij}^{(t)}=1/2</code>  otherwise and <code class="reqn">w_{ij}^{(s)}</code> is the proportion of the circumference of a circle centred at the location <code class="reqn">s_i</code> with radius <code class="reqn">\|s_i -s_j\|</code> lying in <code class="reqn">S</code> (also called Ripley's edge correction factor).
</p>
<p><code>border</code>: <code class="reqn">w_{ij}=\frac{\sum_{j=1}^{n}\mathbf{1}\lbrace d(s_j,S)&gt;u \ ; \ d(t_j,T) &gt;v\rbrace/\lambda(x_j)}{\mathbf{1}_{\lbrace d(s_i,S) &gt; u \ ; \ d(t_i,T) &gt;v \rbrace}}</code>, where <code class="reqn">d(s_i,S)</code> denotes the distance between <code class="reqn">s_i</code>  and the boundary of <code class="reqn">S</code> and <code class="reqn">d(t_i,T)</code> the distance between <code class="reqn">t_i</code> and the boundary of <code class="reqn">T</code>.
</p>
<p><code>modified.border</code>: <code class="reqn">w_{ij} = \frac{|S_{\ominus u}|\times|T_{\ominus v}|}{\mathbf{1}_{\lbrace d(s_i,S) &gt; u \ ; \ d(t_i,T) &gt;v \rbrace}}</code>, where <code class="reqn">S_{\ominus u}</code> and <code class="reqn">T_{\ominus v}</code> are the eroded spatial and temporal region respectively, obtained by trimming off a margin of width <code class="reqn">u</code> and <code class="reqn">v</code> from the border of the original region.
</p>
<p><code>translate</code>: <code class="reqn">w_{ij} =|S \cap S_{s_i-s_j}| \times |T \cap T_{t_i-t_j}|</code>, where <code class="reqn">S_{s_i-s_j}</code> and <code class="reqn">T_{t_i-t_j}</code> 
are the translated spatial and temporal regions.
</p>
<p><code>none</code>: No edge correction is performed and <code class="reqn">w_{ij}=|S \times T|</code>.
</p>
<p><code class="reqn">k_s()</code> and <code class="reqn">k_t()</code> denotes kernel functions with bandwidth <code class="reqn">h_s</code> and <code class="reqn">h_t</code>. Experience with pair correlation function estimation recommends box kernels (the default), see Illian et al. (2008). Epanechnikov, Gaussian and biweight kernels are also implemented. Whatever the kernel function, if the bandwidth is missing, a value is obtain from the function <code>dpik</code> of the package KernSmooth. Note that the bandwidths play an important role and their choice is crucial in the quality of the estimators as they heavily influence their variance.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>pcf</code></td>
<td>
<p><code>ndist</code> x <code>ntimes</code> matrix containing values of <code class="reqn">\hat{g}(u,v)</code>.</p>
</td></tr>
<tr><td><code>pcftheo</code></td>
<td>
<p><code>ndist</code> x <code>ntimes</code> matrix containing theoretical values for a Poisson process.</p>
</td></tr>
<tr><td><code>dist</code>, <code>times</code></td>
<td>
<p>Parameters passed in argument.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>A vector of names and bandwidths of the spatial and temporal kernels.</p>
</td></tr>
<tr><td><code>correction</code></td>
<td>
<p>The name(s) of the edge correction method(s) passed in argument.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt; </p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E., Turner, R., (2015). Spatial Point Patterns: Methodology and Applications with R. CRC Press, Boca Raton.
</p>
<p>Gabriel E., Diggle P. (2009). Second-order analysis of inhomogeneous spatio-temporal point process data. Statistica Neerlandica, 63, 43&ndash;51.
</p>
<p>Gabriel E., Rowlingson B., Diggle P. (2013). stpp: an R package for plotting, simulating and analyzing Spatio-Temporal Point Patterns. Journal of Statistical Software, 53(2), 1&ndash;29.
</p>
<p>Gabriel E. (2014). Estimating second-order characteristics of inhomogeneous spatio-temporal point processes: influence of edge correction methods and intensity estimates. Methodology and computing in Applied Probabillity, 16(2), 411&ndash;431.
</p>
<p>Illian JB, Penttinen A, Stoyan H and Stoyan, D. (2008). Statistical Analysis and Modelling of Spatial Point Patterns. John Wiley and Sons, London.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# First example

data(fmd)
data(northcumbria)
FMD&lt;-as.3dpoints(fmd[,1]/1000,fmd[,2]/1000,fmd[,3])
Northcumbria=northcumbria/1000

# estimation of the temporal intensity
Mt&lt;-density(FMD[,3],n=1000)
mut&lt;-Mt$y[findInterval(FMD[,3],Mt$x)]*dim(FMD)[1]

# estimation of the spatial intensity
h&lt;-mse2d(as.points(FMD[,1:2]), Northcumbria, nsmse=50, range=4)
h&lt;-h$h[which.min(h$mse)]
Ms&lt;-kernel2d(as.points(FMD[,1:2]), Northcumbria, h, nx=500, ny=500)
atx&lt;-findInterval(x=FMD[,1],vec=Ms$x)
aty&lt;-findInterval(x=FMD[,2],vec=Ms$y)
mhat&lt;-NULL
for(i in 1:length(atx)) mhat&lt;-c(mhat,Ms$z[atx[i],aty[i]])

# estimation of the pair correlation function
g1 &lt;- PCFhat(xyt=FMD, dist=1:15, times=1:15, lambda=mhat*mut/dim(FMD)[1],
 s.region=northcumbria/1000,t.region=c(1,200))

# plotting the estimation 

plotPCF(g1)
plotPCF(g1,type="persp",theta=-65,phi=35) 


# Second example

xyt=rpp(lambda=200)
g2=PCFhat(xyt$xyt,dist=seq(0,0.16,by=0.02),
times=seq(0,0.16,by=0.02),correction=c("border","translate"))

plotPCF(g2,type="contour",which="border")
</code></pre>

<hr>
<h2 id='plot.stpp'>Plot for spatio-temporal point objects</h2><span id='topic+plot.stpp'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p>This function plot either <code class="reqn">xy</code>-locations and cumulative distribution of the times, or a space-time 3D scatter, or the time-mark and space-mark of the spatio-temporal point pattern, through arguments <code>style</code> and <code>type</code>.
</p>
<p>It can also plot <code class="reqn">xy</code>-locations with time treated as a quantitative mark attached to each location, as in the previous version of the function, through argument <code>mark</code> (see stpp version &lt; 2.0.0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stpp'
plot(x, s.region=NULL, t.region=NULL, style="generic", type="projection",
mark=NULL , mark.cexmin=0.4, mark.cexmax=1.2, mark.col=1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stpp_+3A_x">x</code></td>
<td>
<p>Any object of class <code>stpp</code> in spatio-temporal point format.</p>
</td></tr>
<tr><td><code id="plot.stpp_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing all data locations. If <code>s.region</code> is missing, the default limits are considered.</p>
</td></tr>
<tr><td><code id="plot.stpp_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of the time interval. If <code>t.region</code> is missing,  the default limits are considered.</p>
</td></tr>
<tr><td><code id="plot.stpp_+3A_type">type</code></td>
<td>
<p>Specify the kind of graphical representation. If <code>type="projection"</code> (default) the function plot the xy-locations and cumulative distribution of the times. If <code>type="mark"</code> the function plot the time-mark and space-mark. If <code>type="scatter"</code> the function plot space-time 3D scatter.</p>
</td></tr>
<tr><td><code id="plot.stpp_+3A_style">style</code></td>
<td>
<p>Two different classes of graphic styles can be chosen. If <code>style="generic"</code> (default) the graphics are plot by default function plot in <code>R</code> and if <code>style="elegant"</code> the  graphics are plot based on the <code>R</code> packages ggplot2 and plot3D. </p>
</td></tr>
<tr><td><code id="plot.stpp_+3A_mark">mark</code></td>
<td>
<p>Logical. If <code>NULL</code> (default), xy-locations and cumulative distribution of the times are plotted. If <code>TRUE</code>, the time is treated as a quantitative mark attached to each location, and the locations are plotted with the size and/or colour of the plotting symbol determined by the value of the mark.</p>
</td></tr>
<tr><td><code id="plot.stpp_+3A_mark.cexmin">mark.cexmin</code>, <code id="plot.stpp_+3A_mark.cexmax">mark.cexmax</code></td>
<td>
<p>Range of the size of the plotting symbol when <code>mark=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.stpp_+3A_mark.col">mark.col</code></td>
<td>
<p>Colour of the plotting symbol when <code>mark=TRUE</code>. If <code>mark.col=0</code>, all locations have the same colour specified by the usual <code>col</code> argument.
Otherwise, can be 1 or &quot;black&quot; (default), 2 or &quot;red&quot;, 3 or &quot;green&quot;, 4 or &quot;blue&quot;, in which cases symbols colour is faded, and the darker corresponds to the most recent time.</p>
</td></tr>
<tr><td><code id="plot.stpp_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the functions plot and scatter3D. Typical arguments are <code>pch</code>, <code>theta</code> and <code>phi</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None</p>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt; and Francisco J. Rodriguez-Cortes.</p>


<h3>References</h3>

<p>Gabriel E., Rowlingson B., Diggle P. (2013). stpp: an R package for plotting, simulating and analyzing Spatio-Temporal Point Patterns. Journal of Statistical Software, 53(2), 1&ndash;29.
</p>
<p>Stoyan, D., Rodriguez-Cortes, F. J., Mateu, J., and Gille, W. (2017). Mark variograms for spatio-temporal point processes. Spatial Statistics. 20, 125-147.</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.3dpoints">as.3dpoints</a></code> for creating data in spatio-temporal point format.</p>

<hr>
<h2 id='plotK'>Plot the estimation of the Space-Time Inhomogeneous K-function</h2><span id='topic+plotK'></span>

<h3>Description</h3>

<p>Contour plot or perspective plot or image of the Space-Time
Inhomogeneous K-function estimate.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotK(K,n=15,L=FALSE,type="contour",legend=TRUE,which=NULL,
main=NULL,...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotK_+3A_k">K</code></td>
<td>
<p>Result of the <code>STIKhat</code> function.</p>
</td></tr>
<tr><td><code id="plotK_+3A_n">n</code></td>
<td>
<p>Number of contour levels desired.</p>
</td></tr>
<tr><td><code id="plotK_+3A_l">L</code></td>
<td>
<p>Logical indicating whether <code class="reqn">K_{ST}(u,v)</code> or <code class="reqn">L(u,v)=K_{ST}(u,v)-\pi u^2 v</code> must be plotted.</p>
</td></tr>
<tr><td><code id="plotK_+3A_type">type</code></td>
<td>
<p>Specifies the kind of plot: <code>contour</code> by default, but can also be <code>persp</code> or <code>image</code></p>
</td></tr>
<tr><td><code id="plotK_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether a legend must be added to the plot.</p>
</td></tr>
<tr><td><code id="plotK_+3A_which">which</code></td>
<td>
<p>A character specifying the edge correction among the ones used in <code>STIKhat</code>. If a single edge correction method was used in <code>STIKhat</code>, it is not necessary to specify <code>which</code>.</p>
</td></tr>
<tr><td><code id="plotK_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="plotK_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>persp</code> if <code>persp=TRUE</code>, such as <code>theta</code> and <code>phi</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt; </p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="graphics.html#topic+image">image</a></code> and <code><a href="#topic+STIKhat">STIKhat</a></code> for an example.
</p>

<hr>
<h2 id='plotPCF'>Plot the estimation of the Space-Time Inhomogeneous Pair Correlation function</h2><span id='topic+plotPCF'></span>

<h3>Description</h3>

<p>Contour, image or perspective plot of the Space-Time Inhomogeneous Pair correlation function estimate.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPCF(PCF,n=15,type="contour",legend=TRUE,which=NULL,
main=NULL,...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPCF_+3A_pcf">PCF</code></td>
<td>
<p>Result of the <code>PCFhat</code> function.</p>
</td></tr>
<tr><td><code id="plotPCF_+3A_n">n</code></td>
<td>
<p>Number of contour levels desired.</p>
</td></tr>
<tr><td><code id="plotPCF_+3A_type">type</code></td>
<td>
<p>Specifies the kind of plot: <code>contour</code> by default, but can also be <code>persp</code> or <code>image</code></p>
</td></tr>
<tr><td><code id="plotPCF_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether a legend must be added to the plot.</p>
</td></tr>
<tr><td><code id="plotPCF_+3A_which">which</code></td>
<td>
<p>A character specifying the edge correction among the ones used in <code>PCFhat</code>. If a single edge correction method was used in <code>PCFhat</code>, it is not necessary to specify <code>which</code>.</p>
</td></tr>
<tr><td><code id="plotPCF_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="plotPCF_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>persp</code> if <code>persp=TRUE</code>, such as <code>theta</code> and <code>phi</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt; </p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="graphics.html#topic+image">image</a></code> and <code><a href="#topic+PCFhat">PCFhat</a></code> for an example.
</p>

<hr>
<h2 id='rinfec'>Generate infection point patterns</h2><span id='topic+rinfec'></span>

<h3>Description</h3>

<p>Generate one (or several) realisation(s) of the infection process 
in a region <code class="reqn">S\times T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rinfec(npoints, s.region, t.region, nsim=1, alpha, beta, gamma, 
s.distr="exponential", t.distr="uniform", maxrad, delta, h="step", 
g="min", recent=1, lambda=NULL, lmax=NULL, nx=100, ny=100, nt=1000, 
t0, inhibition=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rinfec_+3A_npoints">npoints</code></td>
<td>
<p>Number of points to simulate. </p>
</td></tr>
<tr><td><code id="rinfec_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing
all data locations. If <code>s.region</code> is missing, the unit square is considered.</p>
</td></tr> 
<tr><td><code id="rinfec_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of
the time interval. If <code>t.region</code> is missing, the interval <code class="reqn">[0,1]</code> is considered.</p>
</td></tr> 
<tr><td><code id="rinfec_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to generate. Default is 1. </p>
</td></tr>
<tr><td><code id="rinfec_+3A_alpha">alpha</code></td>
<td>
<p>Numerical value for the latent period.</p>
</td></tr> 
<tr><td><code id="rinfec_+3A_beta">beta</code></td>
<td>
<p>Numerical value for the maximum infection rate.</p>
</td></tr>
<tr><td><code id="rinfec_+3A_gamma">gamma</code></td>
<td>
<p>Numerical value for the infection period.</p>
</td></tr> 
<tr><td><code id="rinfec_+3A_h">h</code></td>
<td>
<p>Infection rate function which depends on alpha, beta and delta. 
Must be choosen among &quot;step&quot; and &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="rinfec_+3A_s.distr">s.distr</code></td>
<td>
<p>Spatial distribution. Must be choosen among &quot;uniform&quot;,
&quot;gaussian&quot;, &quot;exponential&quot; and &quot;poisson&quot;. </p>
</td></tr>
<tr><td><code id="rinfec_+3A_t.distr">t.distr</code></td>
<td>
<p>Temporal distribution. Must be choosen among &quot;uniform&quot; and
&quot;exponential&quot;.</p>
</td></tr>
<tr><td><code id="rinfec_+3A_maxrad">maxrad</code></td>
<td>
<p>Single value or 2-vector of spatial and temporal maximum
radiation respectively. If single value, the same value is used for space and time.</p>
</td></tr>
<tr><td><code id="rinfec_+3A_delta">delta</code></td>
<td>
<p>Spatial distance of inhibition/contagion. If missing, the spatial
radiation is used.</p>
</td></tr> 
<tr><td><code id="rinfec_+3A_g">g</code></td>
<td>
<p>Compute the probability of acceptance of a new point from <code>h</code>
and <code>recent</code>. Must be choosen among &quot;min&quot;, &quot;max&quot; and &quot;prod&quot;. </p>
</td></tr>
<tr><td><code id="rinfec_+3A_recent">recent</code></td>
<td>
<p>If &ldquo;<code>all</code>&rdquo; consider all previous events. If
is an integer, say <code class="reqn">N</code>, consider only the <code class="reqn">N</code> most recent events.</p>
</td></tr>
<tr><td><code id="rinfec_+3A_lambda">lambda</code></td>
<td>
<p>Function or matrix defining the intensity of a Poisson process if 
s.distr is Poisson.</p>
</td></tr>
<tr><td><code id="rinfec_+3A_lmax">lmax</code></td>
<td>
<p>Upper bound for the value of lambda.</p>
</td></tr>
<tr><td><code id="rinfec_+3A_nx">nx</code>, <code id="rinfec_+3A_ny">ny</code></td>
<td>
<p>Define the 2-D grid on which the intensity is evaluated if 
<code>s.distr</code> is Poisson.</p>
</td></tr> 
<tr><td><code id="rinfec_+3A_nt">nt</code></td>
<td>
<p>Used to discretize time to compute the infection rate function.</p>
</td></tr>
<tr><td><code id="rinfec_+3A_t0">t0</code></td>
<td>
<p>Minimum time used to compute the infection rate function. 
Default is the minimum of <code>t.region</code>.</p>
</td></tr>
<tr><td><code id="rinfec_+3A_inhibition">inhibition</code></td>
<td>
<p>Logical. If <code>TRUE</code>, an inhibition process is generated. 
Otherwise, it is a contagious process.</p>
</td></tr>
<tr><td><code id="rinfec_+3A_...">...</code></td>
<td>
<p>Additional parameters if <code>lambda</code> is a function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>xyt</code></td>
<td>
<p>Matrix (or list of matrices if <code>nsim</code>&gt;1)
containing the points <code class="reqn">(x,y,t)</code> of the simulated point pattern.
<code>xyt</code> (or any element of the list if <code>nsim</code>&gt;1) is an object 
of the class <code>stpp</code>.</p>
</td></tr>
<tr><td><code>s.region</code>, <code>t.region</code></td>
<td>
<p>Parameters passed in argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt;, Peter J Diggle.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.stpp">plot.stpp</a></code>, <code><a href="#topic+animation">animation</a></code> and <code><a href="#topic+stan">stan</a></code> for plotting space-time point patterns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inhibition; spatial distribution: uniform
inf1 = rinfec(npoints=100, alpha=0.2, beta=0.6, gamma=0.5,
maxrad=c(0.075,0.5), t.region=c(0,50), s.distr="uniform", 
t.distr="uniform", h="gaussian", p="min", recent="all", t0=0.02, 
inhibition=TRUE)
plot(inf1$xyt, style="elegant")


# contagion; spatial distribution: Poisson with intensity a given matrix
data(fmd)
data(northcumbria)
h = mse2d(as.points(fmd[,1:2]), northcumbria, nsmse=30, range=3000)
h = h$h[which.min(h$mse)]
Ls = kernel2d(as.points(fmd[,1:2]), northcumbria, h, nx=50, ny=50)
inf2 = rinfec(npoints=100, alpha=4, beta=0.6, gamma=20, maxrad=c(12000,20), 
s.region=northcumbria, t.region=c(1,2000), s.distr="poisson", 
t.distr="uniform", h="step", p="min", recent=1, 
lambda=Ls$z, inhibition=FALSE)

image(Ls$x, Ls$y, Ls$z, col=grey((1000:1)/1000)); polygon(northcumbria,lwd=2)
animation(inf2$xyt, add=TRUE, cex=0.7, runtime=15)


</code></pre>

<hr>
<h2 id='rinter'>Generate interaction point patterns</h2><span id='topic+rinter'></span>

<h3>Description</h3>

<p>Generate one (or several) realisation(s) of the inhibition or contagious process 
in a region <code class="reqn">S\times T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rinter(npoints,s.region,t.region,hs="step",gs="min",thetas=0,
 deltas,ht="step",gt="min",thetat=1,deltat,recent="all",nsim=1,
 discrete.time=FALSE,replace=FALSE,inhibition=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rinter_+3A_npoints">npoints</code></td>
<td>
<p>Number of points to simulate. </p>
</td></tr>
<tr><td><code id="rinter_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing
all data locations. 
If <code>s.region</code> is missing, the unit square is considered.</p>
</td></tr>
<tr><td><code id="rinter_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of
the time interval. 
If <code>t.region</code> is missing, the interval <code class="reqn">[0,1]</code> is considered.</p>
</td></tr> 
<tr><td><code id="rinter_+3A_hs">hs</code>, <code id="rinter_+3A_ht">ht</code></td>
<td>
<p>Function which depends on the distance between points
and <code>theta</code>. Can be chosen among &quot;<code>step</code>&quot; and &quot;<code>gaussian</code>&quot; 
or can refer to a user defined function which only depend on d, theta, and delta
(see details). 
If <code>inhibition=TRUE</code>, <code>h</code> is monotone, increasing, and must tend
to 1 when the distance tends to infinity. 0 <code class="reqn">\leq</code><code>h(d,theta)</code><code class="reqn">\leq</code> 1. 
Otherwise, <code>h</code> is monotone, decreasing, and must tend
to 1 when the distance tends to 0.</p>
</td></tr>
<tr><td><code id="rinter_+3A_thetas">thetas</code>, <code id="rinter_+3A_thetat">thetat</code></td>
<td>
<p>Parameters of <code>hs</code> and <code>ht</code> functions.</p>
</td></tr> 
<tr><td><code id="rinter_+3A_deltas">deltas</code>, <code id="rinter_+3A_deltat">deltat</code></td>
<td>
<p>Spatial and temporal distance of inhibition.</p>
</td></tr>
<tr><td><code id="rinter_+3A_gs">gs</code>, <code id="rinter_+3A_gt">gt</code></td>
<td>
<p>Compute the probability of acceptance of a new point from
<code>hs</code> or <code>ht</code> and <code>recent</code>. Must be choosen among &quot;<code>min</code>&quot;,
&quot;<code>max</code>&quot; and &quot;<code>prod</code>&quot;. </p>
</td></tr>
<tr><td><code id="rinter_+3A_recent">recent</code></td>
<td>
<p>If &ldquo;<code>all</code>&rdquo; consider all previous events. If
is an integer, say <code class="reqn">N</code>, consider only  the <code class="reqn">N</code> most recent events.</p>
</td></tr>
<tr><td><code id="rinter_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to generate. Default is 1. </p>
</td></tr>
<tr><td><code id="rinter_+3A_discrete.time">discrete.time</code></td>
<td>
<p>If TRUE, times belong to <code class="reqn">N</code>,
otherwise belong to <code class="reqn">{\bf R}^+</code>.</p>
</td></tr> 
<tr><td><code id="rinter_+3A_replace">replace</code></td>
<td>
<p>Logical. If TRUE allows times repeat.</p>
</td></tr>
<tr><td><code id="rinter_+3A_inhibition">inhibition</code></td>
<td>
<p>Logical. If TRUE, an inhibition process is
generated. Otherwise, it is a contagious process. </p>
</td></tr>
<tr><td><code id="rinter_+3A_...">...</code></td>
<td>
<p>Additional parameters if <code>hs</code> and <code>ht</code> are defined by the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>xyt</code></td>
<td>
<p>Matrix (or list of matrices if <code>nsim</code>&gt;1)
containing the points <code class="reqn">(x,y,t)</code> of the simulated point pattern.
<code>xyt</code> (or any element of the list if <code>nsim</code>&gt;1) is an object 
of the class <code>stpp</code>.</p>
</td></tr>
<tr><td><code>s.region</code>, <code>t.region</code></td>
<td>
<p>Parameters passed in argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt;, Peter J Diggle.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.stpp">plot.stpp</a></code>, <code><a href="#topic+animation">animation</a></code> and <code><a href="#topic+stan">stan</a></code> for plotting space-time point patterns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple inhibition process
inh1 = rinter(npoints=200,thetas=0,deltas=0.05,thetat=0,deltat=0.001,
inhibition=TRUE)
plot(inh1$xyt,style="elegant")


# inhibition process using hs and ht defined by the user
hs = function(d,theta,delta,mus=0.1)
{
 res=NULL
 a=(1-theta)/mus
 b=theta-a*delta
 for(i in 1:length(d))
	{	
	if (d[i]&lt;=delta) res=c(res,theta)
	if (d[i]&gt;(delta+mus)) res=c(res,1)
	if (d[i]&gt;delta &amp; d[i]&lt;=(delta+mus)) res=c(res,a*d[i]+b)
	}
 return(res)
}
ht = function(d,theta,delta,mut=0.3)
{
 res=NULL
 a=(1-theta)/mut
 b=theta-a*delta
 for(i in 1:length(d))
	{	
	if (d[i]&lt;=delta) res=c(res,theta)
	if (d[i]&gt;(delta+mut)) res=c(res,1)
	if (d[i]&gt;delta &amp; d[i]&lt;=(delta+mut)) res=c(res,a*d[i]+b)
	}
 return(res)
}
d=seq(0,1,length=100)
plot(d,hs(d,theta=0.2,delta=0.1,mus=0.1),xlab="",ylab="",type="l",
ylim=c(0,1),lwd=2,las=1)
lines(d,ht(d,theta=0.1,delta=0.05,mut=0.3),col=2,lwd=2)
legend("bottomright",col=1:2,lty=1,lwd=2,legend=c(expression(h[s]),
expression(h[t])),bty="n",cex=2)

inh2 = rinter(npoints=100, hs=hs, gs="min", thetas=0.2, deltas=0.1, 
ht=ht, gt="min", thetat=0.1, deltat=0.05, inhibition=TRUE)
animation(inh2$xyt, runtime=15, cex=0.8)

# simple contagious process for given spatial and temporal regions
data(northcumbria)
cont1 = rinter(npoints=100, s.region=northcumbria, t.region=c(1,200), 
thetas=0, deltas=10000, thetat=0, deltat=10, recent=1, inhibition=FALSE)
plot(cont1$xyt,pch=19,s.region=cont1$s.region,mark=TRUE,mark.col=4)

</code></pre>

<hr>
<h2 id='rlgcp'>Generate log-Gaussian Cox point patterns</h2><span id='topic+rlgcp'></span>

<h3>Description</h3>

<p>Generate one (or several) realisation(s) of the log-Gaussian cox process 
in a region <code class="reqn">S\times T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rlgcp(s.region, t.region, replace=TRUE, npoints=NULL, nsim=1, 
 nx=100, ny=100, nt=100,separable=TRUE,model="exponential",
 param=c(1,1,1,1,1,1), scale=c(1,1),var.grf=1,mean.grf=0,
 lmax=NULL,discrete.time=FALSE,exact=FALSE,anisotropy=FALSE,ani.pars=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlgcp_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing
all data locations. If <code>s.region</code> is missing, the unit square is considered.</p>
</td></tr> 
<tr><td><code id="rlgcp_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of
the time interval. If <code>t.region</code> is missing, the interval <code class="reqn">[0,1]</code> is considered.</p>
</td></tr> 
<tr><td><code id="rlgcp_+3A_npoints">npoints</code></td>
<td>
<p>Number of points to simulate. If <code>NULL</code>, the
number of points is from a Poisson distribution with mean the double integral of 	  
<code class="reqn">\lambda(s,t)</code> over <code>s.region</code> and <code>t.region</code>. </p>
</td></tr>
<tr><td><code id="rlgcp_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to generate. Default is 1.</p>
</td></tr>
<tr><td><code id="rlgcp_+3A_separable">separable</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the covariance function of the
Gaussian random field is separable. </p>
</td></tr>
<tr><td><code id="rlgcp_+3A_model">model</code></td>
<td>
<p>Vector of length 1 or 2 specifying the model(s) of
covariance of the Gaussian random field. If <code>separable=TRUE</code> and 
<code>model</code> is of length 2, then the elements of <code>model</code> define the 
spatial and temporal covariances respectively.
If <code>separable=TRUE</code> and <code>model</code> is of length 1, then the
spatial and temporal covariances belongs to the same class of covariances, 
among &quot;matern&quot;, &quot;exponential&quot;, &quot;stable&quot;, &quot;cauchy&quot; and &quot;wave&quot; (see Details). 
If <code>separable=FALSE</code>, <code>model</code> must be of length 1 and is either
&quot;gneiting&quot; or &quot;cesare&quot; (see Details).</p>
</td></tr> 
<tr><td><code id="rlgcp_+3A_param">param</code></td>
<td>
<p><code class="reqn">(\alpha_1,\alpha_2,\alpha_3,\alpha_4,\alpha_5,\alpha_6)</code>. Vector of parameters of the covariance function (see
Details).</p>
</td></tr> 
<tr><td><code id="rlgcp_+3A_scale">scale</code></td>
<td>
<p>Vector of length 2 defining the spatial and temporal scale.</p>
</td></tr>
<tr><td><code id="rlgcp_+3A_var.grf">var.grf</code></td>
<td>
<p>Variance of the Gaussian random field.</p>
</td></tr>
<tr><td><code id="rlgcp_+3A_mean.grf">mean.grf</code></td>
<td>
<p>Mean of the Gaussian random field.</p>
</td></tr>
<tr><td><code id="rlgcp_+3A_replace">replace</code></td>
<td>
<p>Logical allowing times repeat.</p>
</td></tr> 
<tr><td><code id="rlgcp_+3A_nx">nx</code>, <code id="rlgcp_+3A_ny">ny</code>, <code id="rlgcp_+3A_nt">nt</code></td>
<td>
<p>Define the size of the 3-D grid on which the intensity
is evaluated.</p>
</td></tr> 
<tr><td><code id="rlgcp_+3A_lmax">lmax</code></td>
<td>
<p>Upper bound for the value of <code class="reqn">\lambda(x,y,t)</code>.</p>
</td></tr> 
<tr><td><code id="rlgcp_+3A_discrete.time">discrete.time</code></td>
<td>
<p>If <code>TRUE</code>, times belong to <code class="reqn">N</code>,
otherwise belong to <code class="reqn">R^+</code>.</p>
</td></tr> 
<tr><td><code id="rlgcp_+3A_exact">exact</code></td>
<td>
<p>logical allowing exact simulation of Gaussian random fields (see manual for details).</p>
</td></tr>
<tr><td><code id="rlgcp_+3A_anisotropy">anisotropy</code></td>
<td>
<p>If <code>TRUE</code>, simulate an anisotropic point pattern. Currently only implemented for 
separable covariance functions.</p>
</td></tr>
<tr><td><code id="rlgcp_+3A_ani.pars">ani.pars</code></td>
<td>
<p>Vector of length 2, the anisotropy angle 
and the anisotropy ratio, respectively (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We implemented stationary, isotropic spatio-temporal covariance functions.
</p>
<p><em>Separable covariance functions</em>
</p>
<p style="text-align: center;"><code class="reqn">c(h,t) = c_s(\| h \|) \, c_t(|t|) , h \in S, t \in T</code>
</p>

<p>The purely spatial and purely temporal covariance functions can be:
</p>

<ul>
<li><p> Exponential: <code class="reqn">c(r) = \exp(-r)</code>,
</p>
</li>
<li><p> Stable: <code class="reqn">c(r) = \exp(-r^\alpha)</code>, 
<code class="reqn">\alpha \in [0,2]</code>,
</p>
</li>
<li><p> Cauchy: <code class="reqn">c(r) = (1+r^2)^{-\alpha}</code>,
<code class="reqn">\alpha &gt;0</code>,
</p>
</li>
<li><p> Wave: <code class="reqn">c(r) = \frac{\sin(r)}{r}</code> if <code class="reqn">r&gt;0</code>, 
<code class="reqn">c(0)=1</code>,
</p>
</li>
<li><p> Matern: <code class="reqn">c(r) = \frac{(\alpha r)^\nu}{2^{\nu-1}\Gamma(\nu)}
  {\cal K}_{\nu}(\alpha r)</code>, <code class="reqn">\nu &gt; 0</code> and <code class="reqn">\alpha &gt; 0</code>.
</p>
<p><code class="reqn">{\cal K}_{\nu}</code> is the modified Bessel function of second kind:
</p>
<p style="text-align: center;"><code class="reqn">{\cal K}_{\nu}(x) = \frac{\pi}{2} \frac{I_{-\nu}(x) -
    I_{\nu}(x)}{\sin(\pi \nu)},</code>
</p>
<p> with
<code class="reqn">I_{\nu}(x) = \left( \frac{x}{2} \right)^{\nu} \sum_{k=0}^\infty
  \frac{1}{k! \Gamma(\nu+k+1)} \left( \frac{x}{2} \right)^{2k}</code>.
</p>
<p>The parameters <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code> correspond 
to the parameters of the spatial and temporal covariance respectively. For
the Matern model, the parameters <code class="reqn">\alpha_1</code>, <code class="reqn">\alpha_3</code> 
and <code class="reqn">\alpha_2</code>, <code class="reqn">\alpha_4</code> correspond 
to the parameters <code class="reqn">\nu</code>, <code class="reqn">\alpha</code> of the spatial and temporal 
covariance.
</p>
</li></ul>

<p><em>Non-separable covariance functions</em>
</p>
<p>The spatio-temporal covariance function can be:
</p>

<ul>
<li><p> Gneiting: <code class="reqn">c(h,t) = \psi (t^2/\beta_2)^{-\alpha_6} \phi \left(\frac{h^2/
      \beta_1}{\psi (t^2/\beta_2)} \right)</code>, <code class="reqn">\beta_1, \beta_2 &gt;0</code> are spatial and temporal scales respectively,
</p>

<ul>
<li><p> If <code class="reqn">\alpha_2=1</code>, <code class="reqn">\phi(r)</code> is the Stable model.
</p>
</li>
<li><p> if <code class="reqn">\alpha_2=2</code>, <code class="reqn">\phi(r)</code> is the Cauchy model.
</p>
</li>
<li><p> If <code class="reqn">\alpha_2=3</code>, <code class="reqn">\phi(r)</code> is the Matern model.
</p>
</li>
<li><p> If <code class="reqn">\alpha_5=1</code>, <code class="reqn">\psi(r) = (r^{\alpha_3}+
  1)^{\alpha_4}</code>,
</p>
</li>
<li><p> If <code class="reqn">\alpha_5=2</code>, <code class="reqn">\psi(r) = (\alpha_4^{-1} r^{\alpha_3}
    +1)/(r^{\alpha_3}+1)</code>,
</p>
</li>
<li><p> If <code class="reqn">\alpha_5=3</code>, <code class="reqn">\psi(r) = \log(r^{\alpha_3} +
   \alpha_4)/\log {\alpha_4}</code>,
</p>
</li></ul>

<p>The parameter <code class="reqn">\alpha_1</code> is the respective parameter for the model of
<code class="reqn">\phi(\cdot)</code>, <code class="reqn">\alpha_3 \in (0,1]</code>, 
<code class="reqn">\alpha_4 \in (0,1]</code> and <code class="reqn">\alpha_6 \geq 2</code>.
</p>
</li>
<li><p> cesare: <code class="reqn">c(h,t) = \left( 1 + (h/\beta_1)^{\alpha_1} +
    (t/\beta_2)^{\alpha_2} \right)^{-\alpha_3}</code>, <code class="reqn">\beta_1, \beta_2 &gt;0</code>, <code class="reqn">\alpha_1, \alpha_2 \in [1,2]</code>
and <code class="reqn">\alpha_3 \geq 3/2</code>.
</p>
</li></ul>

<p>We also implemented anisotropic Log-Gaussian Cox processes.
We considered geometric spatial anisotropy (see Moller and Toftaker, 2014). In this case the covariance function
is elliptical and anisotropy is characterized by two parameters:
the anisotropy angle <code class="reqn">0 \leq \theta &lt; \pi</code> and the anisotropy ratio <code class="reqn">0 &lt; \delta \leq 1</code> of the minor axis <code class="reqn">2 \omega \delta</code>
and the major axis <code class="reqn">2 \omega</code>.
</p>
<p style="text-align: center;"><code class="reqn">C(h,t)=C_0\left( \sqrt{h \Sigma^{-1} h'},t \right), \ h \in R^2.</code>
</p>
 


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>xyt</code></td>
<td>
<p>Matrix (or list of matrices if <code>nsim</code>&gt;1)
containing the points <code class="reqn">(x,y,t)</code> of the simulated point pattern.
<code>xyt</code> (or any element of the list if <code>nsim</code>&gt;1) is an object 
of the class <code>stpp</code>.</p>
</td></tr>
<tr><td><code>s.region</code>, <code>t.region</code></td>
<td>
<p>parameters passed in argument.</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p><code class="reqn">nx \times ny \times nt</code> array (or list of array if <code>nsim</code>&gt;1) 
of the intensity.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt;, Peter J Diggle.
</p>


<h3>References</h3>

<p>Chan, G. and Wood A. (1997).  An algorithm for simulating stationary
Gaussian random fields. Applied Statistics, Algorithm Section, 46, 171&ndash;181.
</p>
<p>Chan, G. and Wood A. (1999).  Simulation of stationary Gaussian vector fields.
Statistics and Computing, 9, 265&ndash;268.
</p>
<p>Gneiting T. (2002). Nonseparable, stationary covariance functions
for space-time data. Journal of the American Statistical Association,
97, 590&ndash;600.
</p>
<p>Moller J. and Toftaker H. (2014). Geometric anisotropic spatial point pattern analysis
and Cox processes. Scandinavian Journal of Statistics, 41, 414&ndash;435.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.stpp">plot.stpp</a></code>, <code><a href="#topic+animation">animation</a></code> and <code><a href="#topic+stan">stan</a></code> for plotting space-time point patterns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# non separable covariance function: 
lgcp1 &lt;- rlgcp(npoints=200, nx=50, ny=50, nt=50, separable=FALSE, 
model="gneiting", param=c(1,1,1,1,1,2), var.grf=1, mean.grf=0)
N &lt;- lgcp1$Lambda[,,1];for(j in 2:(dim(lgcp1$Lambda)[3])){N &lt;-
N+lgcp1$Lambda[,,j]}
image(N,col=grey((1000:1)/1000));box()
animation(lgcp1$xyt, cex=0.8, runtime=10, add=TRUE, prevalent="orange")

# separable covariance function: 
lgcp2 &lt;- rlgcp(npoints=200, nx=50, ny=50, nt=50, separable=TRUE, 
model="exponential", param=c(1,1,1,1,1,2), var.grf=2, mean.grf=-0.5*2)
N &lt;- lgcp2$Lambda[,,1];for(j in 2:(dim(lgcp2$Lambda)[3])){N &lt;-
N+lgcp2$Lambda[,,j]}
image(N,col=grey((1000:1)/1000));box()
animation(lgcp2$xyt, cex=0.8, pch=20, runtime=10, add=TRUE,
prevalent="orange")

# anisotropic

sigma2=0.5
simlgcp &lt;- rlgcp(npoints=500,nx=250, ny=200, nt=50,separable=TRUE,
s.region=matrix(c(0,2,2,0,0,0,0.5,0.5),byrow=FALSE,ncol=2), model="exponential", 
param=c(1,1,1,1,1,2), var.grf=sigma2, mean.grf=-0.5*sigma2,anisotropy = TRUE,
ani.pars = c(pi/4,0.1))

N &lt;- simlgcp$Lambda[,,1];for(j in 2:dim(simlgcp$Lambda)[3]){N &lt;- N+simlgcp$Lambda[,,j]}
image(x=simlgcp$grid[[1]]$x,y=simlgcp$grid[[1]]$y,z=N,col=grey((1000:1)/1000));box()
points(simlgcp$xyt[,1:2],pch=19,cex=0.25,col=2)


</code></pre>

<hr>
<h2 id='rpcp'>Generate Poisson cluster point patterns</h2><span id='topic+rpcp'></span>

<h3>Description</h3>

<p>Generate one (or several) realisation(s) of the Poisson cluster process in a region 
<code class="reqn">S\times T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rpcp(s.region, t.region, nparents=NULL, npoints=NULL, lambda=NULL, 
 mc=NULL, nsim=1, cluster="uniform", dispersion, infectious=TRUE, 
 edge = "larger.region", larger.region=larger.region, tronc=1,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpcp_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing
all data locations.  
If <code>s.region</code> is missing, the unit square is considered.</p>
</td></tr> 
<tr><td><code id="rpcp_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of
the time interval. If <code>t.region</code> is missing, the interval <code class="reqn">[0,1]</code> is 
considered.</p>
</td></tr>
<tr><td><code id="rpcp_+3A_nparents">nparents</code></td>
<td>
<p>Number of parents. If <code>NULL</code>, <code>nparents</code> is from a
Poisson distribution with intensity <code>lambda</code>.</p>
</td></tr> 
<tr><td><code id="rpcp_+3A_npoints">npoints</code></td>
<td>
<p>Number of points to simulate. If <code>NULL</code> (default), the
number of points is from a Poisson distribution with mean the double integral 
of the intensity over <code>s.region</code> and <code>t.region</code>.</p>
</td></tr> 
<tr><td><code id="rpcp_+3A_lambda">lambda</code></td>
<td>
<p>Intensity of the parent process. Can be either a numeric
value, a function, or a 3d-array (see <code><a href="#topic+rpp">rpp</a></code>). 
If <code>NULL</code>, it is constant and equal to <code>nparents</code> / volume
of the domain.</p>
</td></tr> 
<tr><td><code id="rpcp_+3A_mc">mc</code></td>
<td>
<p>Average number of children per parent. It is used when
<code>npoints</code> is <code>NULL</code>.</p>
</td></tr>  
<tr><td><code id="rpcp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to generate. </p>
</td></tr>
<tr><td><code id="rpcp_+3A_cluster">cluster</code></td>
<td>
<p>Distribution of children: &ldquo;uniform&rdquo;, &ldquo;normal&rdquo; and
&ldquo;exponential&rdquo; are currently implemented. 
Either a single value if the distribution in space and time is the 
same, or a vector of length 2, giving first the spatial distribution of
children  and then the temporal distribution.</p>
</td></tr>
<tr><td><code id="rpcp_+3A_dispersion">dispersion</code></td>
<td>
<p>Scale parameter. It equals twice the standard deviation of 
location of children relative to their parent for a normal distribution of 
children; the mean for an exponential distribution and half range for an uniform 
distribution.</p>
</td></tr> 
<tr><td><code id="rpcp_+3A_infectious">infectious</code></td>
<td>
<p>If <code>TRUE</code>, offspring's times are always greater than 
parent's time.</p>
</td></tr>
<tr><td><code id="rpcp_+3A_edge">edge</code></td>
<td>
<p>Specify the edge correction to use &quot;larger.region&quot; or &quot;without&quot;.</p>
</td></tr> 
<tr><td><code id="rpcp_+3A_larger.region">larger.region</code></td>
<td>
<p>By default, the larger spatial region is the convex hull 
of <code>s.region</code> enlarged by the spatial related value of <code>dispersion</code> 
and the larger time interval is <code>t.region</code> enlarged by the temporal related 
value of <code>dispersion</code>.
One can over-ride default using the 2-vector parameter <code>larger.region</code>.</p>
</td></tr>
<tr><td><code id="rpcp_+3A_tronc">tronc</code></td>
<td>
<p>Parameter of the truncated exponential distribution for the distribution of children.</p>
</td></tr>
<tr><td><code id="rpcp_+3A_...">...</code></td>
<td>
<p>Additional parameters of the intensity of the parent process.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>xyt</code></td>
<td>
<p>Matrix (or list of matrices if <code>nsim</code>&gt;1)
containing the points <code class="reqn">(x,y,t)</code> of the simulated point pattern.
<code>xyt</code> (or any element of the list if <code>nsim</code>&gt;1) is an object 
of the class <code>stpp</code>.</p>
</td></tr>
<tr><td><code>s.region</code>, <code>t.region</code></td>
<td>
<p>Parameters passed in argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt;, Peter J Diggle.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.stpp">plot.stpp</a></code>, <code><a href="#topic+animation">animation</a></code> and <code><a href="#topic+stan">stan</a></code> for plotting space-time point patterns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># homogeneous Poisson distribution of parents

data(northcumbria)
pcp1 &lt;- rpcp(nparents=50, npoints=500, s.region=northcumbria, 
t.region=c(1,365), cluster=c("normal","exponential"), 
maxrad=c(5000,5))

animation(pcp1$xyt, s.region=pcp1$s.region, t.region=pcp1$t.region,
runtime=5)

# inhomogeneous Poisson distribution of parents

lbda &lt;- function(x,y,t,a){a*exp(-4*y) * exp(-2*t)}
pcp2 &lt;- rpcp(nparents=50, npoints=500, cluster="normal", lambda=lbda, 
a=4000/((1-exp(-4))*(1-exp(-2))))
plot(pcp2$xyt, style="elegant")

</code></pre>

<hr>
<h2 id='rpp'>Generate Poisson point patterns</h2><span id='topic+rpp'></span>

<h3>Description</h3>

<p>Generate one (or several) realisation(s) of the (homogeneous or inhomogeneous) Poisson process in a region <code class="reqn">S\times T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpp(lambda, s.region, t.region, npoints=NULL, nsim=1, replace=TRUE,
    discrete.time=FALSE, nx=100, ny=100, nt=100, lmax=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpp_+3A_lambda">lambda</code></td>
<td>
<p>Spatio-temporal intensity of the Poisson process.
If <code>lambda</code> is a single positive number, the function generates 
realisations of a homogeneous Poisson process, whilst if <code>lambda</code> 
is a function of the form <code class="reqn">\lambda(x,y,t,\dots)</code> 
or a 3D-array it generates realisations of an inhomogeneous Poisson process.</p>
</td></tr>
<tr><td><code id="rpp_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing
all data locations. 
If <code>s.region</code> is missing, the unit square is considered.</p>
</td></tr>
<tr><td><code id="rpp_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of
the time interval. 
If <code>t.region</code> is missing, the interval <code class="reqn">[0,1]</code> is considered.</p>
</td></tr>
<tr><td><code id="rpp_+3A_replace">replace</code></td>
<td>
<p>Logical allowing times repeat (should only be used when <code>discrete.time=TRUE</code>).</p>
</td></tr> 
<tr><td><code id="rpp_+3A_npoints">npoints</code></td>
<td>
<p>Number of points to simulate. If <code>NULL</code>, the
number of points is from a 
Poisson distribution with mean the double integral of <code>lambda</code> over 
<code>s.region</code> and <code>t.region</code>.</p>
</td></tr> 
<tr><td><code id="rpp_+3A_discrete.time">discrete.time</code></td>
<td>
<p>If TRUE, times belong to <code class="reqn">{\bf N}</code>,
otherwise belong to <code class="reqn">{\bf R}^+</code>.</p>
</td></tr> 
<tr><td><code id="rpp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to generate. Default is 1.</p>
</td></tr>
<tr><td><code id="rpp_+3A_nx">nx</code>, <code id="rpp_+3A_ny">ny</code>, <code id="rpp_+3A_nt">nt</code></td>
<td>
<p>Define the size of the 3-D grid on which the intensity
is evaluated. </p>
</td></tr>
<tr><td><code id="rpp_+3A_lmax">lmax</code></td>
<td>
<p>Upper bound for the value of <code class="reqn">\lambda(x,y,t)</code>, if
<code>lambda</code> is a function.</p>
</td></tr> 
<tr><td><code id="rpp_+3A_...">...</code></td>
<td>
<p>Additional parameters if <code>lambda</code> is a function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>xyt</code></td>
<td>
<p>Matrix (or list of matrices if <code>nsim</code>&gt;1)
containing the points <code class="reqn">(x,y,t)</code> of the simulated point pattern.
<code>xyt</code> (or any element of the list if <code>nsim</code>&gt;1) is an object 
of the class <code>stpp</code>.</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p><code class="reqn">nx \times ny \times nt</code> array of the intensity surface at each time.</p>
</td></tr>
<tr><td><code>s.region</code>, <code>t.region</code>, <code>lambda</code></td>
<td>
<p>parameters passed in argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt; and Peter J Diggle.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.stpp">plot.stpp</a></code>, <code><a href="#topic+animation">animation</a></code> and <code><a href="#topic+stan">stan</a></code> for plotting space-time point patterns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Homogeneous Poisson process
# ---------------------------
hpp1 &lt;- rpp(lambda=200,replace=FALSE)

stan(hpp1$xyt)

# fixed number of points, discrete time, with time repeat.
data(northcumbria)
hpp2 &lt;- rpp(npoints=500, s.region=northcumbria, t.region=c(1,1000), 
discrete.time=TRUE)
plot(hpp2$xyt, style="elegant")

polymap(northcumbria)
animation(hpp2$xyt, s.region=hpp2$s.region, t.region=hpp2$t.region, 
runtime=10, add=TRUE)



# Inhomogeneous Poisson process
# -----------------------------

# intensity defined by a function
lbda1 = function(x,y,t,a){a*exp(-4*y) * exp(-2*t)}
ipp1 = rpp(lambda=lbda1, npoints=400, a=3200/((1-exp(-4))*(1-exp(-2))))
stan(ipp1$xyt)

# intensity defined by a matrix
data(fmd)
data(northcumbria)
h = mse2d(as.points(fmd[,1:2]), northcumbria, nsmse=30, range=3000)
h = h$h[which.min(h$mse)]
Ls = kernel2d(as.points(fmd[,1:2]), northcumbria, h, nx=100, ny=100)
Lt = dim(fmd)[1]*density(fmd[,3], n=200)$y
Lst=array(0,dim=c(100,100,200))
for(k in 1:200) Lst[,,k] &lt;- Ls$z*Lt[k]/dim(fmd)[1]
ipp2 = rpp(lambda=Lst, s.region=northcumbria, t.region=c(1,200), 
discrete.time=TRUE)
           
par(mfrow=c(1,1))
image(Ls$x, Ls$y, Ls$z, col=grey((1000:1)/1000)); polygon(northcumbria)
animation(ipp2$xyt, add=TRUE, cex=0.5, runtime=15)

</code></pre>

<hr>
<h2 id='sim.stpp'>Generate spatio-temporal point patterns</h2><span id='topic+sim.stpp'></span>

<h3>Description</h3>

<p>Generate one (or several) realisation(s) of a spatio-temporal point process in a region <code class="reqn">S\times T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.stpp(class="poisson", s.region, t.region, npoints=NULL, 
nsim=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.stpp_+3A_class">class</code></td>
<td>
<p>Must be chosen among &quot;poisson&quot;, &quot;cluster&quot;, &quot;cox&quot;, &quot;infectious&quot; and &quot;inhibition&quot;.</p>
</td></tr> 
<tr><td><code id="sim.stpp_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing
all data locations. 
If <code>s.region</code> is missing, the unit square is considered.</p>
</td></tr>
<tr><td><code id="sim.stpp_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of
the time interval. 
If <code>t.region</code> is missing, the interval <code class="reqn">[0,1]</code> is considered.</p>
</td></tr>
<tr><td><code id="sim.stpp_+3A_npoints">npoints</code></td>
<td>
<p>Number of points to simulate.</p>
</td></tr> 
<tr><td><code id="sim.stpp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to generate. Default is 1.</p>
</td></tr>
<tr><td><code id="sim.stpp_+3A_...">...</code></td>
<td>
<p>Additional parameters related to the <code>class</code> parameter.
See <code><a href="#topic+rpp">rpp</a></code> for the Poisson process; <code><a href="#topic+rpcp">rpcp</a></code> for the Poisson 
cluster process; <code><a href="#topic+rlgcp">rlgcp</a></code> for the Log-Gaussian Cox process; 
<code><a href="#topic+rinter">rinter</a></code> for the interaction (inhibition or contagious) 
process and <code><a href="#topic+rinfec">rinfec</a></code> for the infectious process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>xyt</code></td>
<td>
<p>Matrix (or list of matrices if <code>nsim</code>&gt;1)
containing the points <code class="reqn">(x,y,t)</code> of the simulated point pattern.
<code>xyt</code> (or any element of the list if <code>nsim</code>&gt;1) is an object 
of the class <code>stpp</code>.</p>
</td></tr>
<tr><td><code>s.region</code>, <code>t.region</code></td>
<td>
<p>Parameters passed in argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpp">rpp</a></code>, <code><a href="#topic+rinfec">rinfec</a></code>, <code><a href="#topic+rinter">rinter</a></code>, 
<code><a href="#topic+rpcp">rpcp</a></code> and  <code><a href="#topic+rlgcp">rlgcp</a></code> for the simulation of 
Poisson, infectious, interaction, Poisson cluster and log-gaussian 
Cox processes respectively; and <code><a href="#topic+plot.stpp">plot.stpp</a></code>, 
<code><a href="#topic+animation">animation</a></code> and <code><a href="#topic+stan">stan</a></code> for plotting space-time 
point patterns. </p>

<hr>
<h2 id='stan'>(3D) space-time data animation</h2><span id='topic+stan'></span>

<h3>Description</h3>

<p>Displays <code class="reqn">(x,y,t)</code> point data and enables dynamic highlighting of time slices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan(xyt,tlim=range(xyt[,3],na.rm=TRUE),twid=diff(tlim)/20,
persist=FALSE,states,bgpoly,bgframe=TRUE,bgimage,
bgcol=gray(seq(0,1,len=12)),axes=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_+3A_xyt">xyt</code></td>
<td>
<p>A 3-column matrix of <code class="reqn">x</code>, <code class="reqn">y</code>, <code class="reqn">t</code> coordinates</p>
</td></tr>
<tr><td><code id="stan_+3A_tlim">tlim</code></td>
<td>
<p>A two-element vector of upper and lower time limits</p>
</td></tr>
<tr><td><code id="stan_+3A_twid">twid</code></td>
<td>
<p>The initial time window width</p>
</td></tr>
<tr><td><code id="stan_+3A_persist">persist</code></td>
<td>
<p>Whether to display points before time window</p>
</td></tr>
<tr><td><code id="stan_+3A_states">states</code></td>
<td>
<p>How to display points - see Details</p>
</td></tr>
<tr><td><code id="stan_+3A_bgpoly">bgpoly</code></td>
<td>
<p>A polygon to draw on the background plane</p>
</td></tr>
<tr><td><code id="stan_+3A_bgframe">bgframe</code></td>
<td>
<p>Whether to extend the bgpoly to the front plane</p>
</td></tr>
<tr><td><code id="stan_+3A_bgimage">bgimage</code></td>
<td>
<p>An list with <code class="reqn">x</code>, <code class="reqn">y</code> vectors and <code class="reqn">z</code> matrix to display on the background plane</p>
</td></tr>
<tr><td><code id="stan_+3A_bgcol">bgcol</code></td>
<td>
<p>A colour palette vector with which to draw the bgimage</p>
</td></tr>
<tr><td><code id="stan_+3A_axes">axes</code></td>
<td>
<p>Logical value indicating whether labels should be added.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the <code>rpanel</code> and <code>rgl</code> packages. It uses <code>rpanel</code> for the sliders to control the graphics, and <code>rgl</code> for its ability to do flicker-free graphics.
</p>
<p>The sliders set the position and width of the temporal highlight window. For 'time' slider set to time <code class="reqn">T</code> and 'width' slider set to <code class="reqn">S</code>, highlighted points are those with time coordinate <code class="reqn">t</code> such that <code class="reqn">T-S&lt; t&lt; T</code>.
</p>
<p>How points are shown is configured with the states parameter. This is a list of length 3 specifying how points before the time window, inside the time window, and after the time window are displayed. Each element is a list of parameters as would be passed to <code>material3d()</code> together with a radius element. Points are drawn as spheres with the corresponding
material and radius as a fraction of the spatial span of the data.
</p>
<p>By default the third state is invisible, and the first two states are different. By calling with the default for states and <code>persist=TRUE</code>, then the first state is set to the same as the second state. This has the effect of showing all points at time <code class="reqn">&lt; T</code> with the same sphere type.
</p>
<p>If the user specifies the states parameter, then persist is ignored. The user can emulate the persist behaviour by specifying a states list with identical parameters for states 1 and 2.
</p>
<p>Note that each state element should specify all <code>material3d</code> parameters used in any of the state elements. This is to make sure the parameters are reset for each of the sets of points.
</p>
<p>The background polygon must be a simple 2-column vector of <code class="reqn">x</code> and <code class="reqn">y</code> coordinates. When used with <code>bgframe=TRUE</code>, the polygon is also drawn on the front plane, and the convex hull points are connected front to back in order to visualise the space-time prism that the data are contained in.
</p>
<p>A raster image can be displayed on the back plane by setting the bgimage parameter. This must be a list with <code class="reqn">x</code>, <code class="reqn">y</code> and <code class="reqn">z</code> components as needed by the image function. Note that <code class="reqn">x</code> and <code class="reqn">y</code> define the center of cells and so must be the same length as the dimensions of <code class="reqn">z</code> - the image function can accept <code class="reqn">x</code> and <code class="reqn">y</code> values that are one longer than the dimensions of <code class="reqn">z</code> to define the edges, but bgimage does not allow that.
</p>


<h3>Value</h3>

<p>A list of the slider parameters when the dialog is quitted.
</p>


<h3>Author(s)</h3>

<p>Barry Rowlingson &lt;b.rowlingson@lancaster.ac.uk&gt;, Edith Gabriel</p>

<hr>
<h2 id='stdcpp'>Generate double-cluster point pattern</h2><span id='topic+stdcpp'></span>

<h3>Description</h3>

<p>Generate a realisation of the double-cluster process in a region <code class="reqn">S\times T</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdcpp(lambp, a, b, c, mu, s.region, t.region)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdcpp_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing
all data locations.If <code>s.region</code> is missing, the unit square is considered.</p>
</td></tr>
<tr><td><code id="stdcpp_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of the time interval. If <code>t.region</code> is missing, the interval <code class="reqn">[0,1]</code> is considered.</p>
</td></tr>
<tr><td><code id="stdcpp_+3A_lambp">lambp</code></td>
<td>
<p>Intensity of the parent process. Can be either a numeric value, a function, or a 3d-array (see <code><a href="#topic+rpp">rpp</a></code>).</p>
</td></tr>
<tr><td><code id="stdcpp_+3A_a">a</code></td>
<td>
<p>Length of the semi-axes <code class="reqn">x</code> of ellipsoid.</p>
</td></tr>
<tr><td><code id="stdcpp_+3A_b">b</code></td>
<td>
<p>Length of the semi-axes <code class="reqn">y</code> of ellipsoid.</p>
</td></tr>
<tr><td><code id="stdcpp_+3A_c">c</code></td>
<td>
<p>Length of the semi-axes <code class="reqn">y</code> of ellipsoid.</p>
</td></tr>
<tr><td><code id="stdcpp_+3A_mu">mu</code></td>
<td>
<p>Average number of daughter per parent. (a single positive number).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider the straightforward extension of the classical Matern cluster process on the <code class="reqn">R^3</code> case (with ellipsoid or balls) by considering the <code class="reqn">z</code>-coordiantes as times.
</p>
<p>Consider a Poisson point process in the plane with intensity <code class="reqn">\lambda_p</code> as cluster centres for all times 'parent', as well as a ellipsoid (or ball) where the semi-axes are of lengths <code class="reqn">a</code>, <code class="reqn">b</code> and <code class="reqn">c</code>, around of each Poisson point under a random general rotation. The scatter uniformly in all ellipsoid (or ball)  of all points which are of the form <code class="reqn">(x,y,z)</code>, the number of points in each cluster being random with a Poisson (<code class="reqn">\mu</code>) distribution. The resulting point pattern is a spatio-temporal cluster point process with <code class="reqn">t=z</code>. This point process has intensity <code class="reqn">\lambda_{p} \times \mu</code>.</p>


<h3>Value</h3>

<p>The simulated spatio-temporal point pattern.</p>


<h3>Author(s)</h3>

<p>Francisco J. Rodriguez Cortes &lt;frrodriguezc@unal.edu.co&gt;</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E., Turner, R. (2015). Spatial Point Patterns: Methodology and Applications with R. CRC Press, Boca Raton.
</p>
<p>Chiu, S. N., Stoyan, D., Kendall, W. S., and Mecke, J. (2013). Stochastic Geometry and its Applications. John Wiley &amp; Sons.
</p>
<p>Gabriel, E., Rowlingson, B., Diggle P J. (2013) <code>stpp</code>: an R package for plotting, simulating and analyzing Spatio-Temporal Point Patterns. Journal of Statistical Software 53, 1-29.
</p>
<p>Illian, J B., Penttinen, A., Stoyan, H. and Stoyan, D. (2008). Statistical Analysis and Modelling of Spatial Point Patterns. John Wiley and Sons, London.
</p>
<p>Stoyan, D., Rodriguez-Cortes, F. J., Mateu, J., and Gille, W. (2017). Mark variograms for spatio-temporal point processes. Spatial Statistics. 20, 125-147.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ellipsoid
Xe &lt;- stdcpp(lambp=20,a=0.5,b=0.09,c=0.07,mu=100)
plot(Xe$xyt)

# Spatio-temporal 3D scatter plot
par(mfrow=c(1,1))
plot(Xe$xyt,type="scatter")

# Balls
Xb &lt;- stdcpp(lambp=20,a=0.07,b=0.07,c=0.07,mu=100)
plot(Xb$xyt)


# Spatio-temporal 3D scatter plot
par(mfrow=c(1,1))
plot(Xb$xyt,type="mark",style="elegant")

# Northcumbria
data(northcumbria)
Northcumbria &lt;- northcumbria/1000
X &lt;- stdcpp(lambp=0.00004,a=10,b=10,c=10,mu=120,
s.region=Northcumbria,t.region=c(0,200))
plot(X$xyt,s.region=Northcumbria, cex=0.5)

# Spatio-temporal 3D scatter plot
par(mfrow=c(1,1))
plot(X$xyt,type="scatter",theta=45,phi=30,cex=0.1,
ticktype="detailed",col="black",style="elegant")
</code></pre>

<hr>
<h2 id='sthpcpp'>Spatio-temporal hot-spots cluster point process model</h2><span id='topic+sthpcpp'></span>

<h3>Description</h3>

<p>Generate a realisation of the hot-spots cluster process in a region <code class="reqn">S\times T</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sthpcpp(lambp, r, mu, s.region, t.region)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sthpcpp_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing
all data locations.If <code>s.region</code> is missing, the unit square is considered.</p>
</td></tr>
<tr><td><code id="sthpcpp_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of the time interval. If <code>t.region</code> is missing, the interval <code class="reqn">[0,1]</code> is considered.</p>
</td></tr>
<tr><td><code id="sthpcpp_+3A_lambp">lambp</code></td>
<td>
<p>Intensity of the Poisson process of cluster centres. A single positive number, a function, or a pixel image.</p>
</td></tr>
<tr><td><code id="sthpcpp_+3A_r">r</code></td>
<td>
<p>Radius parameter of the clusters.</p>
</td></tr>
<tr><td><code id="sthpcpp_+3A_mu">mu</code></td>
<td>
<p>Average number of daughter per parent (a single positive number) or reference intensity for the cluster points (a function or a pixel image).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation of spatio-temporal cluster process, which can be considered as generalisation of the classical Matern cluster process, inside the spatio-temporal window.
</p>
<p>Consider a Poisson point process in the plane with intensity <code class="reqn">\lambda_{p}</code> as cluster centres for all times 'parent', as well as a infinite cylinder of radius <code class="reqn">R</code> around of each Poisson point, orthogonal to the plane. The scatter uniformly in all cylinders of all points which are of the form <code class="reqn">(x,y,z)</code>, the number of points in each cluster being random with a Poisson (<code class="reqn">\mu</code>) distribution. The resulting point pattern is a spatio-temporal cluster point process with <code class="reqn">t=z</code>. This point process has intensity <code class="reqn">\lambda_{p}\times\mu</code>.</p>


<h3>Value</h3>

<p>The simulated spatio-temporal point pattern.</p>


<h3>Author(s)</h3>

<p>Francisco J. Rodriguez Cortes &lt;frrodriguezc@unal.edu.co&gt;</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E., Turner, R. (2015). Spatial Point Patterns: Methodology and Applications with R. CRC Press, Boca Raton.
</p>
<p>Chiu, S. N., Stoyan, D., Kendall, W. S., and Mecke, J. (2013). Stochastic Geometry and its Applications. John Wiley &amp; Sons.
</p>
<p>Gabriel, E., Rowlingson, B., Diggle P J. (2013) <code>stpp</code>: an R package for plotting, simulating and analyzing Spatio-Temporal Point Patterns. Journal of Statistical Software 53, 1-29.
</p>
<p>Illian, J B., Penttinen, A., Stoyan, H. and Stoyan, D. (2008). Statistical Analysis and Modelling of Spatial Point Patterns. John Wiley and Sons, London.
</p>
<p>Stoyan, D., Rodriguez-Cortes, F. J., Mateu, J., and Gille, W. (2017). Mark variograms for spatio-temporal point processes. Spatial Statistics. 20, 125-147.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example
X &lt;- sthpcpp(lambp=20, r=0.05, mu=100)
plot(X$xyt)

# Spatio-temporal 3D scatter plot
par(mfrow=c(1,1))
plot(X$xyt,type="scatter")

## Spatio-temporal hot-spots cluster point process model
data(northcumbria)
Northcumbria &lt;- northcumbria/1000
Xo &lt;- sthpcpp(lambp=0.0035, r=5, mu=200,
s.region=Northcumbria, t.region=c(28,198))
plot(Xo$xyt,s.region=Northcumbria)

# Spatio-temporal 3D scatter plot
par(mfrow=c(1,1))
plot(Xo$xyt,type="scatter",style="elegant",theta=45,phi=30,cex=0.05,
ticktype="detailed",col="black")
</code></pre>

<hr>
<h2 id='STIKhat'>Estimation of the Space-Time Inhomogeneous K-function</h2><span id='topic+STIKhat'></span>

<h3>Description</h3>

<p>Compute an estimate of the Space-Time Inhomogeneous K-function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>STIKhat(xyt, s.region, t.region, dist, times, lambda, 
correction="isotropic", infectious=FALSE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STIKhat_+3A_xyt">xyt</code></td>
<td>
<p>Coordinates and times <code class="reqn">(x,y,t)</code> of the point pattern.</p>
</td></tr>
<tr><td><code id="STIKhat_+3A_s.region">s.region</code></td>
<td>
<p>Two-column matrix specifying polygonal region containing all data locations. If <code>s.region</code> is missing, the bounding box of <code>xyt[,1:2]</code> is considered.</p>
</td></tr>
<tr><td><code id="STIKhat_+3A_t.region">t.region</code></td>
<td>
<p>Vector containing the minimum and maximum values of the time interval. If <code>t.region</code> is missing, the range of <code>xyt[,3]</code> is considered.</p>
</td></tr>
<tr><td><code id="STIKhat_+3A_dist">dist</code></td>
<td>
<p>Vector of distances <code class="reqn">u</code> at which <code class="reqn">K(u,v)</code> is computed. If missing, the maximum of <code>dist</code> is given by <code class="reqn">\min(S_x,S_y)/4</code>, where <code class="reqn">S_x</code> and <code class="reqn">S_y</code> represent the maximum width and height of the bounding box of <code>s.region</code>.</p>
</td></tr>
<tr><td><code id="STIKhat_+3A_times">times</code></td>
<td>
<p>Vector of times <code class="reqn">v</code> at which <code class="reqn">K(u,v)</code> is computed. If missing, the maximum of <code>times</code> is given by <code class="reqn">(T_{\max} - T_{\min})/4</code>, where <code class="reqn">T_{\min}</code> and <code class="reqn">T_{\max}</code> are the minimum and maximum of the time interval <code class="reqn">T</code>.</p>
</td></tr> 
<tr><td><code id="STIKhat_+3A_lambda">lambda</code></td>
<td>
<p>Vector of values of the space-time intensity function evaluated at the points <code class="reqn">(x,y,t)</code> in <code class="reqn">S\times T</code>. If <code>lambda</code> is missing, the estimate of the space-time K-function is computed as for the homogeneous case (Diggle et al., 1995), i.e. considering <code class="reqn">n/|S \times T|</code> as an estimate of the space-time intensity.</p>
</td></tr>
<tr><td><code id="STIKhat_+3A_correction">correction</code></td>
<td>
<p>A character vector specifying the edge correction(s) to be applied among <code>"isotropic"</code>, <code>"border"</code>, <code>"modified.border"</code>, <code>"translate"</code> and <code>"none"</code> (see Details). The default is <code>"isotropic"</code>.</p>
</td></tr>
<tr><td><code id="STIKhat_+3A_infectious">infectious</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, only future events are considered and the isotropic edge correction method is used. See Details.</p>
</td></tr></table>


<h3>Details</h3>

<p>Gabriel (2014) proposes the following unbiased estimator for the STIK-function, based on data giving the locations of events <code class="reqn">x_i: i=1,\ldots,n</code> on a spatio-temporal region <code class="reqn">S\times T</code>, where <code class="reqn">S</code> is an arbitrary polygon and <code class="reqn">T</code> is a time interval:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{K}(u,v)=\sum_{i=1}^{n}\sum_{j\neq i}\frac{1}{w_{ij}}\frac{1}{\lambda(x_i)\lambda(x_j)}\mathbf{1}_{\lbrace \|s_i - s_j\| \leq u \ ; \ |t_i - t_j| \leq v \rbrace},</code>
</p>

<p>where <code class="reqn">\lambda(x_i)</code> is the intensity at <code class="reqn">x_i = (s_i,t_i)</code> and <code class="reqn">w_{ij}</code> is an edge correction factor to deal with spatial-temporal edge effects. The edge correction methods implemented are:
</p>
<p><code>isotropic</code>: <code class="reqn">w_{ij} = |S \times T| w_{ij}^{(t)} w_{ij}^{(s)}</code>, where the temporal edge correction factor <code class="reqn">w_{ij}^{(t)} = 1</code> if both ends of the interval of length <code class="reqn">2 |t_i - t_j|</code> centred at <code class="reqn">t_i</code> lie within <code class="reqn">T</code> and <code class="reqn">w_{ij}^{(t)}=1/2</code>  otherwise and <code class="reqn">w_{ij}^{(s)}</code> is the proportion of the circumference of a circle centred at the location <code class="reqn">s_i</code> with radius <code class="reqn">\|s_i -s_j\|</code> lying in <code class="reqn">S</code> (also called Ripley's edge correction factor).
</p>
<p><code>border</code>: <code class="reqn">w_{ij}=\frac{\sum_{j=1}^{n}\mathbf{1}\lbrace d(s_j,S)&gt;u \ ; \ d(t_j,T) &gt;v\rbrace/\lambda(x_j)}{\mathbf{1}_{\lbrace d(s_i,S) &gt; u \ ; \ d(t_i,T) &gt;v \rbrace}}</code>, where <code class="reqn">d(s_i,S)</code> denotes the distance between <code class="reqn">s_i</code>  and the boundary of <code class="reqn">S</code> and <code class="reqn">d(t_i,T)</code> the distance between <code class="reqn">t_i</code> and the boundary of <code class="reqn">T</code>.
</p>
<p><code>modified.border</code>: <code class="reqn">w_{ij} = \frac{|S_{\ominus u}|\times|T_{\ominus v}|}{\mathbf{1}_{\lbrace d(s_i,S) &gt; u \ ; \ d(t_i,T) &gt;v \rbrace}}</code>, where <code class="reqn">S_{\ominus u}</code> and <code class="reqn">T_{\ominus v}</code> are the eroded spatial and temporal region respectively, obtained by trimming off a margin of width <code class="reqn">u</code> and <code class="reqn">v</code> from the border of the original region.
</p>
<p><code>translate</code>: <code class="reqn">w_{ij} =|S \cap S_{s_i-s_j}| \times |T \cap T_{t_i-t_j}|</code>, where <code class="reqn">S_{s_i-s_j}</code> and <code class="reqn">T_{t_i-t_j}</code> 
are the translated spatial and temporal regions.
</p>
<p><code>none</code>: No edge correction is performed and <code class="reqn">w_{ij}=|S \times T|</code>.
</p>
<p>If parameter <code>infectious = TRUE</code>, ony future events are considered and the estimator is, using an isotropic edge correction factor (Gabriel and Diggle, 2009): 
</p>
<p style="text-align: center;"><code class="reqn">\widehat{K}(u,v)=\frac{1}{|S\times T|}\frac{n}{n_v}\sum_{i=1}^{n_v}\sum_{j=1; j &gt; i}^{n_v} \frac{1}{w_{ij}} \frac{1}{\lambda(x_i) \lambda(x_j)}\mathbf{1}_{\left\lbrace u_{ij} \leq u\right\rbrace}\mathbf{1}_{\left\lbrace t_j - t_i \leq v \right\rbrace}.</code>
</p>

<p>In this equation, the points <code class="reqn">x_i=(s_i, t_i)</code> are ordered so that <code class="reqn">t_i &lt; t_{i+1}</code>, with ties due to round-off error broken by randomly unrounding if necessary. To deal with temporal edge-effects, for each <code class="reqn">v</code>, <code class="reqn">n_v</code> denotes the number of events for which <code class="reqn">t_i \leq T_1 -v</code>, with <code class="reqn">T=[T_0,T_1]</code>. To deal with spatial edge-effects, we use Ripley's method.
</p>
<p>If <code>lambda</code> is missing in argument, <code>STIKhat</code> computes an estimate of the space-time (homogeneous)
K-function: </p>
<p style="text-align: center;"><code class="reqn">\widehat{K}(u,v)=\frac{|S\times T|}{n_v(n-1)} \sum_{i=1}^{n_v}\sum_{j=1;j&gt;i}^{n_v}\frac{1}{w_{ij}}\mathbf{1}_{\lbrace u_{ij}\leq u \rbrace}\mathbf{1}_{\lbrace t_j - t_i \leq v \rbrace}</code>
</p>


<h3>Value</h3>

<p> A list containing:
</p>
<table>
<tr><td><code>Khat</code></td>
<td>
<p><code>ndist</code> x <code>ntimes</code> matrix containing values of <code class="reqn">\hat{K}_{ST}(u,v).</code>.</p>
</td></tr>
<tr><td><code>Ktheo</code></td>
<td>
<p><code>ndist</code> x <code>ntimes</code> matrix containing theoretical values for a Poisson process; <code class="reqn">\pi u^2 v</code> for <code class="reqn">K</code> and <code class="reqn">2 \pi u^2 v</code> for <code class="reqn">K^*</code>.</p>
</td></tr>
<tr><td><code>dist</code>, <code>times</code>, <code>infectious</code></td>
<td>
<p>Parameters passed in argument.</p>
</td></tr>
<tr><td><code>correction</code></td>
<td>
<p>The name(s) of the edge correction method(s) passed in argument.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Edith Gabriel &lt;edith.gabriel@inrae.fr&gt; </p>


<h3>References</h3>

<p>Baddeley A., Moller J. and Waagepetersen R. (2000). Non- and semi-parametric estimation of interaction in inhomogeneous point patterns. Statistica Neerlandica, 54, 329&ndash;350.
</p>
<p>Baddeley, A., Rubak, E., Turner, R., (2015). Spatial Point Patterns: Methodology and Applications with R. CRC Press, Boca Raton.
</p>
<p>Diggle P. , Chedwynd A., Haggkvist R. and Morris S. (1995). Second-order analysis of space-time clustering. Statistical Methods in Medical Research, 4, 124&ndash;136.
</p>
<p>Gabriel E., Diggle P. (2009). Second-order analysis of inhomogeneous spatio-temporal point process data. Statistica Neerlandica, 63, 43&ndash;51.
</p>
<p>Gabriel E., Rowlingson B., Diggle P. (2013). stpp: an R package for plotting, simulating and analyzing Spatio-Temporal Point Patterns. Journal of Statistical Software, 53(2), 1&ndash;29.
</p>
<p>Gabriel E. (2014). Estimating second-order characteristics of inhomogeneous spatio-temporal point processes: influence of edge correction methods and intensity estimates. Methodology and computing in Applied Probabillity, 16(2), 411&ndash;431.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# First example

data(fmd)
data(northcumbria)
FMD&lt;-as.3dpoints(fmd[,1]/1000,fmd[,2]/1000,fmd[,3])
Northcumbria=northcumbria/1000

# estimation of the temporal intensity
Mt&lt;-density(FMD[,3],n=1000)
mut&lt;-Mt$y[findInterval(FMD[,3],Mt$x)]*dim(FMD)[1]

# estimation of the spatial intensity
h&lt;-mse2d(as.points(FMD[,1:2]), Northcumbria, nsmse=50, range=4)
h&lt;-h$h[which.min(h$mse)]
Ms&lt;-kernel2d(as.points(FMD[,1:2]), Northcumbria, h, nx=5000, ny=5000)
atx&lt;-findInterval(x=FMD[,1],vec=Ms$x)
aty&lt;-findInterval(x=FMD[,2],vec=Ms$y)
mhat&lt;-NULL
for(i in 1:length(atx)) mhat&lt;-c(mhat,Ms$z[atx[i],aty[i]])

# estimation of the STIK function
u &lt;- seq(0,10,by=1)
v &lt;- seq(0,15,by=1)
stik1 &lt;- STIKhat(xyt=FMD, s.region=northcumbria/1000,t.region=c(1,200), 
lambda=mhat*mut/dim(FMD)[1], dist=u, times=v, infectious=TRUE)

# plotting the estimation
plotK(stik1)
plotK(stik1,type="persp",theta=-65,phi=35)
 
# Second example

xyt=rpp(lambda=200)
stik2=STIKhat(xyt$xyt,dist=seq(0,0.16,by=0.02),
times=seq(0,0.16,by=0.02),correction=c("border","translate"))
plotK(stik2,type="contour",legend=TRUE,which="translate")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
