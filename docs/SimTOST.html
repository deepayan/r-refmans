<!DOCTYPE html><html lang="en"><head><title>Help for package SimTOST</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SimTOST}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SimTOST'><p>Sample Size Estimation via Simulation</p></a></li>
<li><a href='#check_equivalence'><p>Check Equivalence for Multiple Endpoints</p></a></li>
<li><a href='#derive_allocation_rate'><p>Derive and Validate Treatment Allocation Rate (TAR)</p></a></li>
<li><a href='#derive_arm_names'><p>Derive or Assign Arm Names</p></a></li>
<li><a href='#derive_endpoint_names'><p>Derive Endpoint Names</p></a></li>
<li><a href='#derive_varcov_list'><p>Derive Variance-Covariance Matrix List</p></a></li>
<li><a href='#get_par'><p>Parameter Configuration for Endpoints and Comparators</p></a></li>
<li><a href='#info_msg'><p>Helper function for conditional messages</p></a></li>
<li><a href='#mcsapply'><p>mcsapply</p></a></li>
<li><a href='#plot.simss'><p>Plot Power vs Sample Size for Simulation Results</p></a></li>
<li><a href='#power_cal'><p>Calculate the power across all comparators</p></a></li>
<li><a href='#power_dom'><p>Power Calculation for Difference of Means (DOM) Hypothesis Test</p></a></li>
<li><a href='#power_Mielke'><p>Power Calculation for Hypothesis Testing in Equivalence Trials</p></a></li>
<li><a href='#print.simss'><p>Print Summary of Sample Size Estimation</p></a></li>
<li><a href='#ptv'><p>Compute p-values for a t-distribution with Fixed Degrees of Freedom</p></a></li>
<li><a href='#ptvdf'><p>Calculate p-values using t-distribution with Variable Degrees of Freedom</p></a></li>
<li><a href='#run_simulations_2x2_dom'><p>Run Simulations for a 2x2 Crossover Design with Difference of Means (DOM) test</p></a></li>
<li><a href='#run_simulations_2x2_rom'><p>Run Simulations for a 2x2 Crossover Design with Ratio of Means (ROM) test</p></a></li>
<li><a href='#run_simulations_par_dom'><p>Run Simulations for a Parallel Design with Difference of Means (DOM) test</p></a></li>
<li><a href='#run_simulations_par_rom'><p>Run Simulations for a Parallel Design with Ratio of Means (ROM) test</p></a></li>
<li><a href='#sampleSize'><p>Sample Size Calculation for Bioequivalence and Multi-Endpoint Studies</p></a></li>
<li><a href='#sampleSize_Mielke'><p>Sample Size Estimation for Multiple Hypothesis Testing Using Mielke's Method</p></a></li>
<li><a href='#sign_Mielke'><p>Simulated Test Statistic for Noninferiority/Equivalence Trials</p></a></li>
<li><a href='#simParallelEndpoints'><p>Generate Simulated Endpoint Data for Parallel Group Design</p></a></li>
<li><a href='#test_2x2_dom'><p>Simulate a 2x2 Crossover Design and Compute Difference of Means (DOM)</p></a></li>
<li><a href='#test_2x2_rom'><p>Simulate a 2x2 Crossover Design and Compute Ratio of Means (ROM)</p></a></li>
<li><a href='#test_par_dom'><p>Simulate a Parallel Design and Test Difference of Means (DOM)</p></a></li>
<li><a href='#test_par_rom'><p>Simulate a Parallel Design and Test Ratio of Means (ROM)</p></a></li>
<li><a href='#test_studies'><p>test_studies</p></a></li>
<li><a href='#uniroot.integer.mod'><p>Optimizer for Uniroot Integer (Modified)</p></a></li>
<li><a href='#validate_positive_definite'><p>Validate Positive Semi-Definite Matrices</p></a></li>
<li><a href='#validate_sample_size_limits'><p>Check Sample Size Limits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Sample Size Estimation for Bio-Equivalence Trials Through
Simulation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Sample size estimation for bio-equivalence trials is supported through a simulation-based approach 
    that extends the Two One-Sided Tests (TOST) procedure. The methodology provides flexibility in 
    hypothesis testing, accommodates multiple treatment comparisons, and accounts for correlated endpoints. 
    Users can model complex trial scenarios, including parallel and crossover designs, intra-subject variability, 
    and different equivalence margins. Monte Carlo simulations enable accurate estimation of power and type I error 
    rates, ensuring well-calibrated study designs. The statistical framework builds on established methods for 
    equivalence testing and multiple hypothesis testing in bio-equivalence studies, as described in Schuirmann (1987) 
    &lt;<a href="https://doi.org/10.1007%2FBF01068419">doi:10.1007/BF01068419</a>&gt;, Mielke et al. (2018) &lt;<a href="https://doi.org/10.1080%2F19466315.2017.1371071">doi:10.1080/19466315.2017.1371071</a>&gt;, Shieh (2022) 
    &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0269128">doi:10.1371/journal.pone.0269128</a>&gt;, and Sozu et al. (2015) &lt;<a href="https://doi.org/10.1007%2F978-3-319-22005-5">doi:10.1007/978-3-319-22005-5</a>&gt;. 
    Comprehensive documentation and vignettes guide users through implementation and interpretation of results.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Rcpp (&ge; 1.0.13), data.table, matrixcalc, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>PowerTOST, ggplot2, kableExtra, knitr, rmarkdown, testthat
(&ge; 3.0.0), tibble, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://smartdata-analysis-and-statistics.github.io/SimTOST/">https://smartdata-analysis-and-statistics.github.io/SimTOST/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-18 16:16:14 UTC; Thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Debray <a href="https://orcid.org/0000-0002-1790-2719"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Johanna Munoz [aut],
  Dewi Amaliah [ctb],
  Wei Wei [ctb],
  Marian Mitroiu [ctb],
  Scott McDonald [ctb],
  Biogen Inc [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Debray &lt;tdebray@fromdatatowisdom.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-18 23:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='SimTOST'>Sample Size Estimation via Simulation</h2><span id='topic+SimTOST-package'></span><span id='topic+SimTOST'></span>

<h3>Description</h3>

<p>SimTOST: A Package for Sample Size Simulations
</p>


<h3>Details</h3>

<p>The SimTOST package provides tools for simulating sample sizes, calculating power,
and assessing type-I error for various statistical scenarios.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a> (<a href="https://orcid.org/0000-0002-1790-2719">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Johanna Munoz <a href="mailto:johanna.munoz@fromdatatowisdom.com">johanna.munoz@fromdatatowisdom.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Dewi Amaliah <a href="mailto:dewi.amaliah@fromdatatowisdom.com">dewi.amaliah@fromdatatowisdom.com</a> [contributor]
</p>
</li>
<li><p> Wei Wei <a href="mailto:wei.wei@biogen.com">wei.wei@biogen.com</a> [contributor]
</p>
</li>
<li><p> Marian Mitroiu <a href="mailto:marian.mitroiu@biogen.com">marian.mitroiu@biogen.com</a> [contributor]
</p>
</li>
<li><p> Scott McDonald <a href="mailto:scott.mcdonald@fromdatatowisdom.com">scott.mcdonald@fromdatatowisdom.com</a> [contributor]
</p>
</li>
<li><p> Biogen Inc [copyright holder, funder]
</p>
</li></ul>



<h3>References</h3>

<p>Mielke, J., Jones, B., Jilma, B. &amp; König, F. Sample Size for Multiple Hypothesis Testing in Biosimilar Development. <em>Statistics in Biopharmaceutical Research</em> 10, 39–49 (2018).
</p>


<h3>See Also</h3>

<p><a href="#topic+sampleSize">sampleSize</a>
</p>

<hr>
<h2 id='check_equivalence'>Check Equivalence for Multiple Endpoints</h2><span id='topic+check_equivalence'></span>

<h3>Description</h3>

<p>This function evaluates whether equivalence criteria are met based on a predefined set of endpoints. It first checks whether all primary endpoints satisfy equivalence (if sequential testing is enabled). Then, it determines whether the required number of endpoints (<code>k</code>) meet the equivalence threshold. The function returns a binary decision indicating whether overall equivalence is established.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_equivalence(typey, adseq, tbioq, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_equivalence_+3A_typey">typey</code></td>
<td>
<p>An integer vector specifying the hierarchy of each endpoint, where <code>1</code> denotes a primary endpoint and <code>2</code> denotes a secondary endpoint.</p>
</td></tr>
<tr><td><code id="check_equivalence_+3A_adseq">adseq</code></td>
<td>
<p>A boolean flag indicating whether sequential testing is enabled. If set to <code>TRUE</code>, all primary endpoints must pass equivalence before secondary endpoints are evaluated. If set to <code>FALSE</code>, primary and secondary endpoints are assessed independently.</p>
</td></tr>
<tr><td><code id="check_equivalence_+3A_tbioq">tbioq</code></td>
<td>
<p>A matrix containing the equivalence test results for each endpoint, where <code>1</code> indicates that equivalence is met and <code>0</code> indicates that equivalence is not met.</p>
</td></tr>
<tr><td><code id="check_equivalence_+3A_k">k</code></td>
<td>
<p>An integer specifying the minimum number of endpoints required for overall equivalence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When sequential testing is enabled (<code>adseq = TRUE</code>), all primary endpoints must meet equivalence before secondary endpoints are considered. If sequential testing is disabled (<code>adseq = FALSE</code>), all endpoints are evaluated simultaneously without hierarchical constraints. The function then determines whether at least <code>k</code> endpoints meet the equivalence criteria. If the conditions are satisfied, the final equivalence decision (<code>totaly</code>) is <code>1</code>; otherwise, it is <code>0</code>.
</p>


<h3>Value</h3>

<p>Returns a (1 × 1 matrix) containing a binary equivalence decision. A value of <code>1</code> indicates that equivalence is established, while <code>0</code> indicates that equivalence is not established.
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='derive_allocation_rate'>Derive and Validate Treatment Allocation Rate (TAR)</h2><span id='topic+derive_allocation_rate'></span>

<h3>Description</h3>

<p>This function validates and adjusts the treatment allocation rate (<code>TAR</code>) to ensure it is correctly specified
for the given number of treatment arms (<code>n_arms</code>). If <code>TAR</code> is missing or NULL, it is assigned a default
vector of ones, ensuring equal allocation across all arms. The function also handles cases where <code>TAR</code>
is shorter than <code>n_arms</code>, contains NA values, or has invalid values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_allocation_rate(TAR = NULL, arm_names, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derive_allocation_rate_+3A_tar">TAR</code></td>
<td>
<p>Optional numeric vector specifying the allocation rate for each treatment arm. If missing, a default
equal allocation rate is assigned.</p>
</td></tr>
<tr><td><code id="derive_allocation_rate_+3A_arm_names">arm_names</code></td>
<td>
<p>Character vector specifying the names of the treatment arms. Used to name the elements of <code>TAR</code>.</p>
</td></tr>
<tr><td><code id="derive_allocation_rate_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, displays messages about the status of <code>TAR</code> derivation or assignment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list representing the treatment allocation rate for each arm.
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='derive_arm_names'>Derive or Assign Arm Names</h2><span id='topic+derive_arm_names'></span>

<h3>Description</h3>

<p>This function checks if <code>arm_names</code> is provided. If <code>arm_names</code> is missing, it attempts to derive names
from <code>mu_list</code>. If <code>mu_list</code> does not contain names, it assigns default names (&quot;A1&quot;, &quot;A2&quot;, etc.) to each arm.
Informational messages are displayed if <code>verbose</code> is set to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_arm_names(arm_names, mu_list, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derive_arm_names_+3A_arm_names">arm_names</code></td>
<td>
<p>Optional vector of arm names.</p>
</td></tr>
<tr><td><code id="derive_arm_names_+3A_mu_list">mu_list</code></td>
<td>
<p>Named list of means per treatment arm, from which arm names may be derived.</p>
</td></tr>
<tr><td><code id="derive_arm_names_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, displays messages about the derivation process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of arm names.
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='derive_endpoint_names'>Derive Endpoint Names</h2><span id='topic+derive_endpoint_names'></span>

<h3>Description</h3>

<p>Derive Endpoint Names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_endpoint_names(ynames_list, mu_list, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derive_endpoint_names_+3A_ynames_list">ynames_list</code></td>
<td>
<p>Optional list of vectors with endpoint names for each arm.</p>
</td></tr>
<tr><td><code id="derive_endpoint_names_+3A_mu_list">mu_list</code></td>
<td>
<p>Named list of means per treatment arm, where names can be used as endpoint names.</p>
</td></tr>
<tr><td><code id="derive_endpoint_names_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, displays messages about the derivation process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of endpoint names for each arm.
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>
<p>This function derives endpoint names (<code>ynames_list</code>) from <code>mu_list</code> if <code>ynames_list</code>
is missing. If <code>ynames_list</code> is already provided, it confirms the names to the user when
<code>verbose</code> is set to <code>TRUE</code>.
</p>

<hr>
<h2 id='derive_varcov_list'>Derive Variance-Covariance Matrix List</h2><span id='topic+derive_varcov_list'></span>

<h3>Description</h3>

<p>Constructs a list of variance-covariance matrices for multiple treatment arms based on provided standard deviations,
means, and correlation structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_varcov_list(
  mu_list,
  sigma_list,
  ynames_list = NULL,
  varcov_list = NULL,
  cor_mat = NULL,
  rho = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derive_varcov_list_+3A_mu_list">mu_list</code></td>
<td>
<p>A list of numeric vectors representing the means (<code class="reqn">\mu</code>) for each treatment arm. Each element corresponds to one arm.</p>
</td></tr>
<tr><td><code id="derive_varcov_list_+3A_sigma_list">sigma_list</code></td>
<td>
<p>A list of numeric vectors representing the standard deviations (<code class="reqn">\sigma</code>) for each treatment arm. Each element corresponds to one arm.</p>
</td></tr>
<tr><td><code id="derive_varcov_list_+3A_ynames_list">ynames_list</code></td>
<td>
<p>A list of character vectors specifying the names of the endpoints for each arm. Each element corresponds to one arm.</p>
</td></tr>
<tr><td><code id="derive_varcov_list_+3A_varcov_list">varcov_list</code></td>
<td>
<p>(Optional) A pre-specified list of variance-covariance matrices for each arm. If provided, it will override the construction of variance-covariance matrices.</p>
</td></tr>
<tr><td><code id="derive_varcov_list_+3A_cor_mat">cor_mat</code></td>
<td>
<p>(Optional) A correlation matrix to be used for constructing the variance-covariance matrices when there are multiple endpoints. If dimensions do not match the number of endpoints, a warning is issued.</p>
</td></tr>
<tr><td><code id="derive_varcov_list_+3A_rho">rho</code></td>
<td>
<p>(Optional) A numeric value specifying the constant correlation coefficient to be used between all pairs of endpoints if no correlation matrix is provided. Default is 0 (uncorrelated endpoints).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a list of variance-covariance matrices for multiple treatment arms. If the <code>varcov_list</code> is not provided,
the function uses the <code>sigma_list</code> to compute the matrices. For single endpoints, the variance is simply the square of the standard deviation.
For multiple endpoints, the function constructs the matrices using either a provided <code>cor_mat</code> or the constant correlation coefficient <code>rho</code>.
</p>
<p>The function ensures that the lengths of <code>mu_list</code>, <code>sigma_list</code>, and <code>ynames_list</code> match for each arm. If dimensions mismatch,
or if neither a variance-covariance matrix (<code>varcov_list</code>) nor a standard deviation list (<code>sigma_list</code>) is provided, an error is raised.
</p>


<h3>Value</h3>

<p>A list of variance-covariance matrices, one for each treatment arm.
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='get_par'>Parameter Configuration for Endpoints and Comparators</h2><span id='topic+get_par'></span>

<h3>Description</h3>

<p>Constructs and returns a list of key parameters (mean vectors, variance-covariance matrices, and allocation rates) required for input into the <code>sampleSize</code> function. This function ensures that the parameters for each endpoint and comparator are consistent, properly named, and formatted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_par(
  mu_list,
  varcov_list,
  TAR_list,
  type_y = NA,
  arm_names = NA,
  y_names = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_par_+3A_mu_list">mu_list</code></td>
<td>
<p>A list of mean (<code class="reqn">\mu</code>) vectors. Each element in the list represents a comparator, with the corresponding <code class="reqn">\mu</code> vector having a length equal to the number of endpoints.</p>
</td></tr>
<tr><td><code id="get_par_+3A_varcov_list">varcov_list</code></td>
<td>
<p>A list of variance-covariance matrices. Each element corresponds to a comparator, with a matrix of size <code class="reqn">(n \times n)</code>, where <code class="reqn">n</code> is the number of endpoints.</p>
</td></tr>
<tr><td><code id="get_par_+3A_tar_list">TAR_list</code></td>
<td>
<p>A list of treatment allocation rates (TARs) for each comparator. Each element contains a numeric value (can be fractional or integer) representing the allocation rate for the respective comparator.</p>
</td></tr>
<tr><td><code id="get_par_+3A_type_y">type_y</code></td>
<td>
<p>A numeric vector specifying the type of each endpoint. Use <code>1</code> for primary endpoints and <code>2</code> for secondary or other endpoints.</p>
</td></tr>
<tr><td><code id="get_par_+3A_arm_names">arm_names</code></td>
<td>
<p>(Optional) A character vector containing names of the arms. If not provided, default names (e.g., T1, T2, ...) will be generated.</p>
</td></tr>
<tr><td><code id="get_par_+3A_y_names">y_names</code></td>
<td>
<p>(Optional) A character vector containing names of the endpoints. If not provided, default names (e.g., y1, y2, ...) will be generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following components:
</p>

<dl>
<dt><code>mu</code></dt><dd><p>A list of mean vectors, named according to <code>arm_names</code>.</p>
</dd>
<dt><code>varcov</code></dt><dd><p>A list of variance-covariance matrices, named according to <code>arm_names</code>.</p>
</dd>
<dt><code>tar</code></dt><dd><p>A list of treatment allocation rates (TARs), named according to <code>arm_names</code>.</p>
</dd>
<dt><code>type_y</code></dt><dd><p>A vector specifying the type of each endpoint.</p>
</dd>
<dt><code>weight_seq</code></dt><dd><p>A weight sequence calculated from <code>type_y</code>, used for endpoint weighting.</p>
</dd>
<dt><code>y_names</code></dt><dd><p>A vector of names for the endpoints, named as per <code>y_names</code>.</p>
</dd>
</dl>

<p>#' @details
This function ensures that all input parameters (<code>mu_list</code>, <code>varcov_list</code>, and <code>TAR_list</code>) are consistent across comparators and endpoints. It performs checks for positive semi-definiteness of variance-covariance matrices and automatically assigns default names for arms and endpoints if not provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu_list &lt;- list(c(0.1, 0.2), c(0.15, 0.25))
varcov_list &lt;- list(matrix(c(1, 0.5, 0.5, 1), ncol = 2), matrix(c(1, 0.3, 0.3, 1), ncol = 2))
TAR_list &lt;- list(0.5, 0.5)
get_par(mu_list, varcov_list, TAR_list, type_y = c(1, 2), arm_names = c("Arm1", "Arm2"))

</code></pre>

<hr>
<h2 id='info_msg'>Helper function for conditional messages</h2><span id='topic+info_msg'></span>

<h3>Description</h3>

<p>This function displays a message if the <code>verbose</code> parameter is set to <code>TRUE</code>.
It is useful for providing optional feedback to users during function execution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_msg(message, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="info_msg_+3A_message">message</code></td>
<td>
<p>A character string containing the message to display.</p>
</td></tr>
<tr><td><code id="info_msg_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the message is displayed; if <code>FALSE</code>, the message is suppressed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (invisible). This function is used for side effects (displaying messages).
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='mcsapply'>mcsapply</h2><span id='topic+mcsapply'></span>

<h3>Description</h3>

<p>An mc-version of the sapply function. https://stackoverflow.com/questions/31050556/parallel-version-of-sapply
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcsapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcsapply_+3A_x">X</code></td>
<td>
<p>vector of iterations</p>
</td></tr>
<tr><td><code id="mcsapply_+3A_fun">FUN</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="mcsapply_+3A_...">...</code></td>
<td>
<p>additional parameters to pass</p>
</td></tr>
<tr><td><code id="mcsapply_+3A_simplify">simplify</code></td>
<td>
<p>simplify array</p>
</td></tr>
<tr><td><code id="mcsapply_+3A_use.names">USE.NAMES</code></td>
<td>
<p>use names in array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector output
</p>

<hr>
<h2 id='plot.simss'>Plot Power vs Sample Size for Simulation Results</h2><span id='topic+plot.simss'></span>

<h3>Description</h3>

<p>Generates a detailed plot showing the relationship between power and total sample size for each comparator and the overall combined comparators.
The plot also includes confidence intervals for power estimates and highlights the target power with a dashed line for easy visual comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simss'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simss_+3A_x">x</code></td>
<td>
<p>An object of class <code>simss</code> containing simulation results.</p>
</td></tr>
<tr><td><code id="plot.simss_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the <code>plot.simss</code> function for customization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot dynamically adjusts to exclude unnecessary components, such as redundant endpoints or comparators with insufficient data, ensuring clarity and simplicity.
The <code>ggplot2</code> framework is used for visualizations, allowing further customization if needed.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object illustrating:
</p>

<ul>
<li><p> Power (y-axis) vs. Total Sample Size (x-axis) for individual endpoints and comparators.
</p>
</li>
<li><p> Error bars representing the 95% confidence interval of the power estimates.
</p>
</li>
<li><p> A dashed horizontal line indicating the target power for comparison.
</p>
</li>
<li><p> Faceted panels for each comparator, making it easy to compare results across different groups.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Johanna Muñoz <a href="mailto:johanna.munoz@fromdatatowisdom.com">johanna.munoz@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='power_cal'>Calculate the power across all comparators</h2><span id='topic+power_cal'></span>

<h3>Description</h3>

<p>Internal function to calculate the power across all comparators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_cal(n, nsim, param, param.d, seed, ncores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_cal_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="power_cal_+3A_nsim">nsim</code></td>
<td>
<p>number of simulated studies</p>
</td></tr>
<tr><td><code id="power_cal_+3A_param">param</code></td>
<td>
<p>list of parameters (mean,sd,tar)</p>
</td></tr>
<tr><td><code id="power_cal_+3A_param.d">param.d</code></td>
<td>
<p>design parameters</p>
</td></tr>
<tr><td><code id="power_cal_+3A_seed">seed</code></td>
<td>
<p>main seed</p>
</td></tr>
<tr><td><code id="power_cal_+3A_ncores">ncores</code></td>
<td>
<p>number of cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>power calculated from a global list of comparators
</p>

<hr>
<h2 id='power_dom'>Power Calculation for Difference of Means (DOM) Hypothesis Test</h2><span id='topic+power_dom'></span>

<h3>Description</h3>

<p>Computes the statistical power for testing the difference of means (DOM) between two groups using Monte Carlo simulations. The power is estimated based on specified sample sizes, means, standard deviations, and significance level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_dom(
  seed,
  mu_test,
  mu_control,
  sigma_test,
  sigma_control,
  N_test,
  N_control,
  lb,
  ub,
  alpha = 0.05,
  nsim = 10000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_dom_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for reproducibility.</p>
</td></tr>
<tr><td><code id="power_dom_+3A_mu_test">mu_test</code></td>
<td>
<p>Numeric. Mean of the test group.</p>
</td></tr>
<tr><td><code id="power_dom_+3A_mu_control">mu_control</code></td>
<td>
<p>Numeric. Mean of the control group.</p>
</td></tr>
<tr><td><code id="power_dom_+3A_sigma_test">sigma_test</code></td>
<td>
<p>Numeric. Standard deviation of the test group.</p>
</td></tr>
<tr><td><code id="power_dom_+3A_sigma_control">sigma_control</code></td>
<td>
<p>Numeric. Standard deviation of the control group.</p>
</td></tr>
<tr><td><code id="power_dom_+3A_n_test">N_test</code></td>
<td>
<p>Integer. Sample size of the test group.</p>
</td></tr>
<tr><td><code id="power_dom_+3A_n_control">N_control</code></td>
<td>
<p>Integer. Sample size of the control group.</p>
</td></tr>
<tr><td><code id="power_dom_+3A_lb">lb</code></td>
<td>
<p>Numeric. Lower bound for the equivalence margin.</p>
</td></tr>
<tr><td><code id="power_dom_+3A_ub">ub</code></td>
<td>
<p>Numeric. Upper bound for the equivalence margin.</p>
</td></tr>
<tr><td><code id="power_dom_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Significance level (default = 0.05).</p>
</td></tr>
<tr><td><code id="power_dom_+3A_nsim">nsim</code></td>
<td>
<p>Integer. Number of simulations (default = 10,000).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. Estimated power (probability between 0 and 1).
</p>

<hr>
<h2 id='power_Mielke'>Power Calculation for Hypothesis Testing in Equivalence Trials</h2><span id='topic+power_Mielke'></span>

<h3>Description</h3>

<p>Estimates the power of hypothesis testing in equivalence trials using
the method described by Mielke et al. This approach accounts for multiple
endpoints, correlation structures, and multiplicity adjustments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_Mielke(
  N,
  m,
  k,
  R,
  sigma,
  true.diff,
  equi.tol = log(1.25),
  design,
  alpha = 0.05,
  adjust = "no",
  nsim = 10000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_Mielke_+3A_n">N</code></td>
<td>
<p>Integer specifying the number of subjects per sequence.</p>
</td></tr>
<tr><td><code id="power_Mielke_+3A_m">m</code></td>
<td>
<p>Integer specifying the number of endpoints.</p>
</td></tr>
<tr><td><code id="power_Mielke_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of endpoints that must meet equivalence
to consider the test successful.</p>
</td></tr>
<tr><td><code id="power_Mielke_+3A_r">R</code></td>
<td>
<p>Matrix specifying the correlation structure between endpoints.
This should be an <code>m x m</code> matrix, e.g., generated using <code>variance.const.corr()</code>.</p>
</td></tr>
<tr><td><code id="power_Mielke_+3A_sigma">sigma</code></td>
<td>
<p>Numeric specifying the standard deviation of endpoints.
Can be a vector of length <code>m</code> (one per endpoint) or a single value.
In a 2x2 crossover design, this represents within-subject variance.
In a parallel-group design, it represents the treatment group standard deviation.</p>
</td></tr>
<tr><td><code id="power_Mielke_+3A_true.diff">true.diff</code></td>
<td>
<p>Numeric specifying the assumed true difference between test and reference.
Can be a vector of length <code>m</code> or a single value.</p>
</td></tr>
<tr><td><code id="power_Mielke_+3A_equi.tol">equi.tol</code></td>
<td>
<p>Numeric specifying the equivalence margins, with the interval defined as
<code>(-equi.tol, +equi.tol)</code>. Default is <code>log(1.25)</code>.</p>
</td></tr>
<tr><td><code id="power_Mielke_+3A_design">design</code></td>
<td>
<p>Character specifying the study design.
Options are <code>"22co"</code> for a 2x2 crossover design or <code>"parallel"</code> for a parallel-group design.</p>
</td></tr>
<tr><td><code id="power_Mielke_+3A_alpha">alpha</code></td>
<td>
<p>Numeric specifying the significance level. Default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="power_Mielke_+3A_adjust">adjust</code></td>
<td>
<p>Character specifying the method for multiplicity adjustment.
Options include <code>"no"</code> for no adjustment, <code>"bon"</code> for Bonferroni correction,
and <code>"k"</code> for k-adjustment.</p>
</td></tr>
<tr><td><code id="power_Mielke_+3A_nsim">nsim</code></td>
<td>
<p>Integer specifying the number of simulations to perform. Default is <code>10,000</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the estimated power based on the simulations.
</p>

<hr>
<h2 id='print.simss'>Print Summary of Sample Size Estimation</h2><span id='topic+print.simss'></span>

<h3>Description</h3>

<p>Prints the summary results of the sample size estimation for bioequivalence trials,
including achieved power, total sample size, and power confidence intervals.
The function also details the study design, primary endpoint comparisons,
and applied multiplicity corrections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simss'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.simss_+3A_x">x</code></td>
<td>
<p>An object of class <code>"simss"</code>, typically generated by a sample size estimation function.</p>
</td></tr>
<tr><td><code id="print.simss_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed from or to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays key metrics from a sample size estimation analysis.
It provides an overview of the study design, treatment comparisons,
tested endpoints, significance level adjustments, and estimated sample size.
For studies with multiple primary endpoints, it describes the multiplicity correction applied.
</p>


<h3>Value</h3>

<p>No return value, called for side effects. The function prints the summary results
of the sample size estimation to the console in a structured format.
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='ptv'>Compute p-values for a t-distribution with Fixed Degrees of Freedom</h2><span id='topic+ptv'></span>

<h3>Description</h3>

<p>Computes p-values for a given set of random variables under a t-distribution with fixed degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptv(x, df, lower)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptv_+3A_x">x</code></td>
<td>
<p>A numeric matrix (or vector) representing the random variables.</p>
</td></tr>
<tr><td><code id="ptv_+3A_df">df</code></td>
<td>
<p>A double specifying the degrees of freedom.</p>
</td></tr>
<tr><td><code id="ptv_+3A_lower">lower</code></td>
<td>
<p>A logical value indicating whether to compute the lower-tail probability (<code>P(T &lt;= x)</code>). If <code>FALSE</code>, the function returns the upper-tail probability (<code>P(T &gt; x)</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix containing the computed cumulative distribution function (CDF) values (p-values).
</p>

<hr>
<h2 id='ptvdf'>Calculate p-values using t-distribution with Variable Degrees of Freedom</h2><span id='topic+ptvdf'></span>

<h3>Description</h3>

<p>This function computes the cumulative distribution function (p-values) for a given random variable <code>x</code> and corresponding degrees of freedom <code>df</code> using the t-distribution. The function can compute the lower or upper tail probabilities depending on the value of the <code>lower</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptvdf(x, df, lower)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptvdf_+3A_x">x</code></td>
<td>
<p>arma::mat (vector) - A matrix or vector of random variable values for which the p-values will be calculated.</p>
</td></tr>
<tr><td><code id="ptvdf_+3A_df">df</code></td>
<td>
<p>arma::mat (vector) - A matrix or vector of degrees of freedom for the t-distribution, matching the size of <code>x</code>.</p>
</td></tr>
<tr><td><code id="ptvdf_+3A_lower">lower</code></td>
<td>
<p>bool - If <code>TRUE</code>, calculates the lower-tail probability (P(T &lt;= x)); if <code>FALSE</code>, calculates the upper-tail probability.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>arma::mat (vector) - A matrix containing the computed cumulative distribution function (p-values) for each element in <code>x</code>. The result is returned as a 1xN matrix, where N is the number of elements in <code>x</code>.
</p>

<hr>
<h2 id='run_simulations_2x2_dom'>Run Simulations for a 2x2 Crossover Design with Difference of Means (DOM) test</h2><span id='topic+run_simulations_2x2_dom'></span>

<h3>Description</h3>

<p>This function simulates a 2x2 crossover trial across multiple iterations.
It evaluates equivalence across multiple endpoints using the
Difference of Means (DOM) test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_simulations_2x2_dom(
  nsim,
  n,
  muT,
  muR,
  SigmaW,
  lequi_tol,
  uequi_tol,
  alpha,
  sigmaB,
  dropout,
  Eper,
  Eco,
  typey,
  adseq,
  k,
  arm_seed
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_simulations_2x2_dom_+3A_nsim">nsim</code></td>
<td>
<p>Integer. The number of simulations to run.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_n">n</code></td>
<td>
<p>Integer. The sample size per period.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_mut">muT</code></td>
<td>
<p>Numeric vector. Mean outcomes for the active treatment.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_mur">muR</code></td>
<td>
<p>Numeric vector. Mean outcomes for the reference treatment.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_sigmaw">SigmaW</code></td>
<td>
<p>Numeric matrix. Within-subject covariance matrix for endpoints.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_lequi_tol">lequi_tol</code></td>
<td>
<p>Numeric vector. Lower equivalence thresholds for each endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_uequi_tol">uequi_tol</code></td>
<td>
<p>Numeric vector. Upper equivalence thresholds for each endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector. Significance levels for hypothesis testing across endpoints.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_sigmab">sigmaB</code></td>
<td>
<p>Numeric. Between-subject variance for the crossover model.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_dropout">dropout</code></td>
<td>
<p>Numeric vector of size 2. Dropout rates for each sequence.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_eper">Eper</code></td>
<td>
<p>Numeric vector. Expected period effects for each sequence.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_eco">Eco</code></td>
<td>
<p>Numeric vector. Expected carryover effects for each sequence.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_typey">typey</code></td>
<td>
<p>Integer vector indicating the classification of each endpoint, where <code>1</code> corresponds to a primary endpoint and <code>2</code> corresponds to a secondary endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_adseq">adseq</code></td>
<td>
<p>Logical. If <code>TRUE</code>, applies sequential (hierarchical) testing.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_k">k</code></td>
<td>
<p>Integer. Minimum number of endpoints required for equivalence.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_dom_+3A_arm_seed">arm_seed</code></td>
<td>
<p>Integer vector. Random seed for each simulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates equivalence using the Difference of Means (DOM) test.
Equivalence is determined based on predefined lower (<code>lequi_tol</code>) and upper (<code>uequi_tol</code>) equivalence thresholds,
and hypothesis testing is conducted at the specified significance level (<code>alpha</code>).
If <code>adseq</code> is <code>TRUE</code>, primary endpoints must establish equivalence before secondary endpoints are evaluated.
The sample size per period is adjusted based on dropout rates, ensuring valid study conclusions.
The simulation incorporates within-subject correlation using <code>SigmaW</code> and accounts for between-subject variance with <code>sigmaB</code>.
Expected period effects (<code>Eper</code>) and carryover effects (<code>Eco</code>) are included in the model.
A fixed random seed (<code>arm_seed</code>) is used to ensure reproducibility across simulations.
</p>


<h3>Value</h3>

<p>A numeric matrix where each column stores simulation results:
The first row (<code>totaly</code>) represents the overall equivalence decision (1 = success, 0 = failure).
Subsequent rows contain equivalence decisions per endpoint,
mean estimates for the treatment group, mean estimates for the reference group,
standard deviations for treatment, and standard deviations for reference.
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='run_simulations_2x2_rom'>Run Simulations for a 2x2 Crossover Design with Ratio of Means (ROM) test</h2><span id='topic+run_simulations_2x2_rom'></span>

<h3>Description</h3>

<p>This function simulates a 2x2 crossover trial across multiple iterations.
It evaluates equivalence across multiple endpoints using the
Ratio of Means (ROM) test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_simulations_2x2_rom(
  nsim,
  n,
  muT,
  muR,
  SigmaW,
  lequi_tol,
  uequi_tol,
  alpha,
  sigmaB,
  dropout,
  Eper,
  Eco,
  typey,
  adseq,
  k,
  arm_seed
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_simulations_2x2_rom_+3A_nsim">nsim</code></td>
<td>
<p>Integer. The number of simulations to run.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_n">n</code></td>
<td>
<p>Integer. The sample size per period.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_mut">muT</code></td>
<td>
<p>Numeric vector. Mean outcomes for the active treatment.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_mur">muR</code></td>
<td>
<p>Numeric vector. Mean outcomes for the reference treatment.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_sigmaw">SigmaW</code></td>
<td>
<p>Numeric matrix. Within-subject covariance matrix for endpoints.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_lequi_tol">lequi_tol</code></td>
<td>
<p>Numeric vector. Lower equivalence thresholds for each endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_uequi_tol">uequi_tol</code></td>
<td>
<p>Numeric vector. Upper equivalence thresholds for each endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector. Significance levels for hypothesis testing across endpoints.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_sigmab">sigmaB</code></td>
<td>
<p>Numeric. Between-subject variance for the crossover model.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_dropout">dropout</code></td>
<td>
<p>Numeric vector of size 2. Dropout rates for each sequence.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_eper">Eper</code></td>
<td>
<p>Numeric vector. Expected period effects for each sequence.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_eco">Eco</code></td>
<td>
<p>Numeric vector. Expected carryover effects for each sequence.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_typey">typey</code></td>
<td>
<p>Integer vector indicating the classification of each endpoint, where <code>1</code> corresponds to a primary endpoint and <code>2</code> corresponds to a secondary endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_adseq">adseq</code></td>
<td>
<p>Logical. If <code>TRUE</code>, applies sequential (hierarchical) testing.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_k">k</code></td>
<td>
<p>Integer. Minimum number of endpoints required for equivalence.</p>
</td></tr>
<tr><td><code id="run_simulations_2x2_rom_+3A_arm_seed">arm_seed</code></td>
<td>
<p>Integer vector. Random seed for each simulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates equivalence using the Ratio of Means (ROM) test.
Equivalence is determined based on predefined lower <code>lequi_tol</code> and upper <code>uequi_tol</code> equivalence thresholds,
and hypothesis testing is conducted at the specified significance level <code>alpha</code>.
If <code>adseq</code> is <code>TRUE</code>, primary endpoints must establish equivalence before secondary endpoints are evaluated.
The sample size per period is adjusted based on dropout rates, ensuring valid study conclusions.
The simulation incorporates within-subject correlation using <code>SigmaW</code> and accounts for between-subject variance with <code>sigmaB</code>.
Expected period effects <code>Eper</code> and carryover effects <code>Eco</code> are included in the model.
A fixed random seed <code>arm_seed</code> is used to ensure reproducibility across simulations.//'
</p>


<h3>Value</h3>

<p>A numeric matrix where each column stores simulation results:
The first row (<code>totaly</code>) represents the overall equivalence decision (1 = success, 0 = failure).
Subsequent rows contain equivalence decisions per endpoint,
mean estimates for the treatment group, mean estimates for the reference group,
standard deviations for treatment, and standard deviations for reference.
</p>
<p>@author Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='run_simulations_par_dom'>Run Simulations for a Parallel Design with Difference of Means (DOM) test</h2><span id='topic+run_simulations_par_dom'></span>

<h3>Description</h3>

<p>This function simulates a parallel-group trial across multiple iterations.
It evaluates equivalence across multiple endpoints using the
Difference of Means (DOM) test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_simulations_par_dom(
  nsim,
  n,
  muT,
  muR,
  SigmaT,
  SigmaR,
  lequi_tol,
  uequi_tol,
  alpha,
  dropout,
  typey,
  adseq,
  k,
  arm_seed_T,
  arm_seed_R,
  TART,
  TARR,
  vareq
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_simulations_par_dom_+3A_nsim">nsim</code></td>
<td>
<p>Integer. The number of simulations to run.</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_n">n</code></td>
<td>
<p>Integer. The sample size per arm (before dropout).</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_mut">muT</code></td>
<td>
<p>arma::vec. Mean vector for the treatment arm.</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_mur">muR</code></td>
<td>
<p>arma::vec. Mean vector for the reference arm.</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_sigmat">SigmaT</code></td>
<td>
<p>arma::mat. Covariance matrix for the treatment arm.</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_sigmar">SigmaR</code></td>
<td>
<p>arma::mat. Covariance matrix for the reference arm.</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_lequi_tol">lequi_tol</code></td>
<td>
<p>arma::rowvec. Lower equivalence thresholds for each endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_uequi_tol">uequi_tol</code></td>
<td>
<p>arma::rowvec. Upper equivalence thresholds for each endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_alpha">alpha</code></td>
<td>
<p>arma::rowvec. Significance level for each endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_dropout">dropout</code></td>
<td>
<p>arma::vec. Dropout rates for each arm (T, R).</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_typey">typey</code></td>
<td>
<p>Integer vector indicating the classification of each endpoint, where <code>1</code> corresponds to a primary endpoint and <code>2</code> corresponds to a secondary endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_adseq">adseq</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, applies sequential (hierarchical) testing.</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_k">k</code></td>
<td>
<p>Integer. Minimum number of endpoints required for equivalence.</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_arm_seed_t">arm_seed_T</code></td>
<td>
<p>arma::ivec. Random seed vector for the treatment group (one per simulation).</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_arm_seed_r">arm_seed_R</code></td>
<td>
<p>arma::ivec. Random seed vector for the reference group (one per simulation).</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_tart">TART</code></td>
<td>
<p>Double. Treatment allocation ratio (proportion of subjects in treatment arm).</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_tarr">TARR</code></td>
<td>
<p>Double. Reference allocation ratio (proportion of subjects in reference arm).</p>
</td></tr>
<tr><td><code id="run_simulations_par_dom_+3A_vareq">vareq</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, assumes equal variances across treatment and reference groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equivalence testing uses either the Difference of Means (DOM) test,
applying predefined equivalence thresholds and significance levels. When hierarchical testing (<code>adseq</code>)
is enabled, all primary endpoints must demonstrate equivalence before secondary endpoints are evaluated.
Dropout rates are incorporated into the sample size calculation to ensure proper adjustment.
Randomization is controlled through separate random seeds for the treatment and reference groups,
enhancing reproducibility.
</p>


<h3>Value</h3>

<p>The function returns an arma::mat storing simulation results row-wise for consistency
with R's output format. The first row (<code>totaly</code>) contains the overall equivalence decision
(1 for success, 0 for failure). The subsequent rows include equivalence deicisons for each endpoint,
mean estimates for both treatment and reference groups, and corresponding standard deviations.
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='run_simulations_par_rom'>Run Simulations for a Parallel Design with Ratio of Means (ROM) test</h2><span id='topic+run_simulations_par_rom'></span>

<h3>Description</h3>

<p>This function simulates a parallel-group trial across multiple iterations.
It evaluates equivalence across multiple endpoints using the
Ratio of Means (ROM) test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_simulations_par_rom(
  nsim,
  n,
  muT,
  muR,
  SigmaT,
  SigmaR,
  lequi_tol,
  uequi_tol,
  alpha,
  dropout,
  typey,
  adseq,
  k,
  arm_seed_T,
  arm_seed_R,
  TART,
  TARR,
  vareq
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_simulations_par_rom_+3A_nsim">nsim</code></td>
<td>
<p>Integer. The number of simulations to run.</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_n">n</code></td>
<td>
<p>Integer. The sample size per arm (before dropout).</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_mut">muT</code></td>
<td>
<p>arma::vec. Mean vector for the treatment arm.</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_mur">muR</code></td>
<td>
<p>arma::vec. Mean vector for the reference arm.</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_sigmat">SigmaT</code></td>
<td>
<p>arma::mat. Covariance matrix for the treatment arm.</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_sigmar">SigmaR</code></td>
<td>
<p>arma::mat. Covariance matrix for the reference arm.</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_lequi_tol">lequi_tol</code></td>
<td>
<p>arma::rowvec. Lower equivalence thresholds for each endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_uequi_tol">uequi_tol</code></td>
<td>
<p>arma::rowvec. Upper equivalence thresholds for each endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_alpha">alpha</code></td>
<td>
<p>arma::rowvec. Significance level for each endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_dropout">dropout</code></td>
<td>
<p>arma::vec. Dropout rates for each arm (T, R).</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_typey">typey</code></td>
<td>
<p>Integer vector indicating the classification of each endpoint, where <code>1</code> corresponds to a primary endpoint and <code>2</code> corresponds to a secondary endpoint.</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_adseq">adseq</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, applies sequential (hierarchical) testing.</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_k">k</code></td>
<td>
<p>Integer. Minimum number of endpoints required for equivalence.</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_arm_seed_t">arm_seed_T</code></td>
<td>
<p>arma::ivec. Random seed vector for the treatment group (one per simulation).</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_arm_seed_r">arm_seed_R</code></td>
<td>
<p>arma::ivec. Random seed vector for the reference group (one per simulation).</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_tart">TART</code></td>
<td>
<p>Double. Treatment allocation ratio (proportion of subjects in treatment arm).</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_tarr">TARR</code></td>
<td>
<p>Double. Reference allocation ratio (proportion of subjects in reference arm).</p>
</td></tr>
<tr><td><code id="run_simulations_par_rom_+3A_vareq">vareq</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, assumes equal variances across treatment and reference groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equivalence testing uses either the Ratio of Means (ROM) test,
applying predefined equivalence thresholds and significance levels. When hierarchical testing (<code>adseq</code>)
is enabled, all primary endpoints must demonstrate equivalence before secondary endpoints are evaluated.
Dropout rates are incorporated into the sample size calculation to ensure proper adjustment.
Randomization is controlled through separate random seeds for the treatment and reference groups,
enhancing reproducibility.
</p>


<h3>Value</h3>

<p>The function returns an arma::mat storing simulation results row-wise for consistency
with R's output format. The first row (<code>totaly</code>) contains the overall equivalence decision
(1 for success, 0 for failure). The subsequent rows include equivalence decisions for each endpoint,
mean estimates for both treatment and reference groups, and corresponding standard deviations.
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='sampleSize'>Sample Size Calculation for Bioequivalence and Multi-Endpoint Studies</h2><span id='topic+sampleSize'></span>

<h3>Description</h3>

<p>Computes the required sample size to achieve a target power in studies with multiple endpoints and treatment arms.
The function employs modified root-finding algorithms to estimate sample size while accounting for correlation structures, variance assumptions,
and equivalence bounds across endpoints. It is particularly useful for bioequivalence trials and multi-arm studies with complex endpoint structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleSize(
  mu_list,
  varcov_list = NA,
  sigma_list = NA,
  cor_mat = NA,
  sigmaB = NA,
  Eper,
  Eco,
  rho = 0,
  TAR = rep(1, length(mu_list)),
  arm_names = NA,
  ynames_list = NA,
  type_y = NA,
  list_comparator = NA,
  list_y_comparator = NA,
  power = 0.8,
  alpha = 0.05,
  lequi.tol = NA,
  uequi.tol = NA,
  list_lequi.tol = NA,
  list_uequi.tol = NA,
  dtype = "parallel",
  ctype = "ROM",
  vareq = TRUE,
  lognorm = TRUE,
  k = NA,
  adjust = "no",
  dropout = NA,
  nsim = 5000,
  seed = 1234,
  ncores = 1,
  optimization_method = "fast",
  lower = 2,
  upper = 500,
  step.power = 6,
  step.up = TRUE,
  pos.side = FALSE,
  maxiter = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleSize_+3A_mu_list">mu_list</code></td>
<td>
<p>Named list of arithmetic means per treatment arm. Each element is a vector representing expected outcomes for all endpoints in that arm.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_varcov_list">varcov_list</code></td>
<td>
<p>List of variance-covariance matrices, where each element corresponds to a comparator. Each matrix has dimensions: number of endpoints × number of endpoints.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_sigma_list">sigma_list</code></td>
<td>
<p>List of standard deviation vectors, where each element corresponds to a comparator and contains one standard deviation per endpoint.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_cor_mat">cor_mat</code></td>
<td>
<p>Matrix specifying the correlation structure between endpoints, used along with <code>sigma_list</code> to calculate <code>varcov_list</code> if not provided.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_sigmab">sigmaB</code></td>
<td>
<p>Numeric. Between-subject variance for a 2×2 crossover design.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_eper">Eper</code></td>
<td>
<p>Optional numeric vector of length 2 specifying the period effect in a <code>dtype = "2x2"</code> design, applied as <code>c(Period 0, Period 1)</code>. Defaults to <code>c(0, 0)</code>. Ignored for <code>dtype = "parallel"</code>.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_eco">Eco</code></td>
<td>
<p>Optional numeric vector of length 2 specifying the carry-over effect per arm in a <code>dtype = "2x2"</code> design, applied as <code>c(Reference, Treatment)</code>. Defaults to <code>c(0, 0)</code>. Ignored for <code>dtype = "parallel"</code>.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_rho">rho</code></td>
<td>
<p>Numeric. Correlation parameter applied uniformly across all endpoint pairs. Used with <code>sigma_list</code> to compute <code>varcov_list</code> when <code>cor_mat</code> or <code>varcov_list</code> are not provided.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_tar">TAR</code></td>
<td>
<p>Numeric vector specifying treatment allocation rates per arm. The order must match <code>arm_names</code>. Defaults to equal allocation across arms if not provided.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_arm_names">arm_names</code></td>
<td>
<p>Optional character vector of treatment names. If not supplied, names are derived from <code>mu_list</code>.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_ynames_list">ynames_list</code></td>
<td>
<p>Optional list of vectors specifying endpoint names per arm. If names are missing, arbitrary names are assigned based on order.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_type_y">type_y</code></td>
<td>
<p>Integer vector indicating endpoint types: <code>1</code> for co-primary endpoints, <code>2</code> for secondary endpoints.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_list_comparator">list_comparator</code></td>
<td>
<p>List of comparators. Each element is a vector of length 2 specifying the treatment names being compared.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_list_y_comparator">list_y_comparator</code></td>
<td>
<p>List of endpoint sets per comparator. Each element is a vector containing endpoint names to compare. If not provided, all endpoints common to both comparator arms are used.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_power">power</code></td>
<td>
<p>Numeric. Target power (default = 0.8).</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Significance level (default = 0.05).</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_lequi.tol">lequi.tol</code></td>
<td>
<p>Numeric. Lower equivalence bounds (e.g., -0.5) applied uniformly across all endpoints and comparators.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_uequi.tol">uequi.tol</code></td>
<td>
<p>Numeric. Upper equivalence bounds (e.g., 0.5) applied uniformly across all endpoints and comparators.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_list_lequi.tol">list_lequi.tol</code></td>
<td>
<p>List of numeric vectors specifying lower equivalence bounds per comparator.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_list_uequi.tol">list_uequi.tol</code></td>
<td>
<p>List of numeric vectors specifying upper equivalence bounds per comparator.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_dtype">dtype</code></td>
<td>
<p>Character. Trial design: <code>"parallel"</code> (default) for parallel-group or <code>"2x2"</code> for crossover (only for 2-arm studies).</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_ctype">ctype</code></td>
<td>
<p>Character. Hypothesis test type: <code>"DOM"</code> (Difference of Means) or <code>"ROM"</code> (Ratio of Means).</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_vareq">vareq</code></td>
<td>
<p>Logical. Assumes equal variances across arms if <code>TRUE</code> (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_lognorm">lognorm</code></td>
<td>
<p>Logical. Whether data follows a log-normal distribution (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_k">k</code></td>
<td>
<p>Integer vector. Minimum number of successful endpoints required for global bioequivalence per comparator. Defaults to all endpoints per comparator.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_adjust">adjust</code></td>
<td>
<p>Character. Alpha adjustment method: <code>"k"</code> (K-fold), <code>"bon"</code> (Bonferroni), <code>"sid"</code> (Sidak), <code>"no"</code> (default, no adjustment), or <code>"seq"</code> (sequential).</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_dropout">dropout</code></td>
<td>
<p>Numeric vector specifying dropout proportion per arm.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_nsim">nsim</code></td>
<td>
<p>Integer. Number of simulated studies (default = 5000).</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for reproducibility.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_ncores">ncores</code></td>
<td>
<p>Integer. Number of processing cores for parallel computation. Defaults to <code>1</code>. Set to <code>NA</code> for automatic detection (<code>ncores - 1</code>).</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_optimization_method">optimization_method</code></td>
<td>
<p>Character. Sample size optimization method: <code>"fast"</code> (default, root-finding algorithm) or <code>"step-by-step"</code>.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_lower">lower</code></td>
<td>
<p>Integer. Minimum sample size for search range (default = 2).</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_upper">upper</code></td>
<td>
<p>Integer. Maximum sample size for search range (default = 500).</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_step.power">step.power</code></td>
<td>
<p>Numeric. Initial step size for sample size search, defined as <code>2^step.power</code>. Used when <code>optimization_method = "fast"</code>.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_step.up">step.up</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), search increments upward from <code>lower</code>; if <code>FALSE</code>, decrements downward from <code>upper</code>. Used when <code>optimization_method = "fast"</code>.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_pos.side">pos.side</code></td>
<td>
<p>Logical. If <code>TRUE</code>, finds the smallest integer <code>i</code> closest to the root such that <code>f(i) &gt; 0</code>. Used when <code>optimization_method = "fast"</code>.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer. Maximum iterations allowed for sample size estimation (default = 1000). Used when <code>optimization_method = "fast"</code>.</p>
</td></tr>
<tr><td><code id="sampleSize_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints progress and messages during execution (default = <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt><code>response</code></dt><dd><p>Array summarizing simulation results, including estimated sample sizes, achieved power, and confidence intervals.</p>
</dd>
<dt><code>table.iter</code></dt><dd><p>Data frame showing estimated sample sizes and calculated power at each iteration.</p>
</dd>
<dt><code>table.test</code></dt><dd><p>Data frame containing test results for all simulated trials.</p>
</dd>
<dt><code>param.u</code></dt><dd><p>Original input parameters.</p>
</dd>
<dt><code>param</code></dt><dd><p>Final adjusted parameters used in sample size calculation.</p>
</dd>
<dt><code>param.d</code></dt><dd><p>Trial design parameters used in the simulation.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Johanna Muñoz <a href="mailto:johanna.munoz@fromdatatowisdom.com">johanna.munoz@fromdatatowisdom.com</a>
</p>


<h3>References</h3>

<p>Schuirmann, D. J. (1987). A comparison of the Two One-Sided Tests procedure and the
Power approach for assessing the equivalence of average bioavailability.
<em>Journal of Pharmacokinetics and Biopharmaceutics, 15</em>(6), 657-680.
<a href="doi:10.1007/BF01068419">doi:10.1007/BF01068419</a>
</p>
<p>Mielke, J., Jones, B., Jilma, B., &amp; König, F. (2018). Sample size for multiple hypothesis
testing in biosimilar development. <em>Statistics in Biopharmaceutical Research, 10</em>(1), 39-49.
<a href="doi:10.1080/19466315.2017.1371071">doi:10.1080/19466315.2017.1371071</a>
</p>
<p>Berger, R. L., &amp; Hsu, J. C. (1996). Bioequivalence trials, intersection-union tests, and
equivalence confidence sets. <em>Statistical Science</em>, 283-302.
</p>
<p>Sozu, T., Sugimoto, T., Hamasaki, T., &amp; Evans, S. R. (2015). &quot;Sample Size Determination in
Clinical Trials with Multiple Endpoints.&quot; <em>SpringerBriefs in Statistics</em>.
<a href="doi:10.1007/978-3-319-22005-5">doi:10.1007/978-3-319-22005-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu_list &lt;- list(SB2 = c(AUCinf = 38703, AUClast = 36862, Cmax = 127.0),
                EUREF = c(AUCinf = 39360, AUClast = 37022, Cmax = 126.2),
                USREF = c(AUCinf = 39270, AUClast = 37368, Cmax = 129.2))

sigma_list &lt;- list(SB2 = c(AUCinf = 11114, AUClast = 9133, Cmax = 16.9),
                   EUREF = c(AUCinf = 12332, AUClast = 9398, Cmax = 17.9),
                   USREF = c(AUCinf = 10064, AUClast = 8332, Cmax = 18.8))

# Equivalent boundaries
lequi.tol &lt;- c(AUCinf = 0.8, AUClast = 0.8, Cmax = 0.8)
uequi.tol &lt;- c(AUCinf = 1.25, AUClast = 1.25, Cmax = 1.25)

# Arms to be compared
list_comparator &lt;- list(EMA = c("SB2", "EUREF"),
                        FDA = c("SB2", "USREF"))

# Endpoints to be compared
list_y_comparator &lt;- list(EMA = c("AUCinf", "Cmax"),
                          FDA = c("AUClast", "Cmax"))

# Equivalence boundaries for each comparison
lequi_lower &lt;- c(AUCinf = 0.80, AUClast = 0.80, Cmax = 0.80)
lequi_upper &lt;- c(AUCinf = 1.25, AUClast = 1.25, Cmax = 1.25)

# Run the simulation
sampleSize(power = 0.9, alpha = 0.05, mu_list = mu_list,
           sigma_list = sigma_list, list_comparator = list_comparator,
           list_y_comparator = list_y_comparator,
           list_lequi.tol = list("EMA" = lequi_lower, "FDA" = lequi_lower),
           list_uequi.tol = list("EMA" = lequi_upper, "FDA" = lequi_upper),
           adjust = "no", dtype = "parallel", ctype = "ROM", vareq = FALSE,
           lognorm = TRUE, ncores = 1, nsim = 50, seed = 1234)
</code></pre>

<hr>
<h2 id='sampleSize_Mielke'>Sample Size Estimation for Multiple Hypothesis Testing Using Mielke's Method</h2><span id='topic+sampleSize_Mielke'></span>

<h3>Description</h3>

<p>Estimates the required sample size to achieve a specified power level for multiple hypothesis testing, using the approach described by Mielke et al. (2018). This function is particularly useful for bioequivalence or biosimilar studies with multiple correlated endpoints, where a minimum number of endpoints must meet equivalence criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleSize_Mielke(
  power,
  Nmax,
  m,
  k,
  rho,
  sigma,
  true.diff,
  equi.tol,
  design,
  alpha,
  adjust = "no",
  seed = NULL,
  nsim = 10000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleSize_Mielke_+3A_power">power</code></td>
<td>
<p>Numeric. Desired statistical power.</p>
</td></tr>
<tr><td><code id="sampleSize_Mielke_+3A_nmax">Nmax</code></td>
<td>
<p>Integer. Maximum allowable sample size.</p>
</td></tr>
<tr><td><code id="sampleSize_Mielke_+3A_m">m</code></td>
<td>
<p>Integer. Total number of endpoints.</p>
</td></tr>
<tr><td><code id="sampleSize_Mielke_+3A_k">k</code></td>
<td>
<p>Integer. Number of endpoints that must meet the success criteria for overall study success.</p>
</td></tr>
<tr><td><code id="sampleSize_Mielke_+3A_rho">rho</code></td>
<td>
<p>Numeric. Constant correlation coefficient among endpoints.</p>
</td></tr>
<tr><td><code id="sampleSize_Mielke_+3A_sigma">sigma</code></td>
<td>
<p>Numeric or vector. Standard deviation of each endpoint. If a single value is provided, it is assumed to be constant across all endpoints. In a 2x2 crossover design, this is the within-subject standard deviation; in a parallel design, it represents the treatment group’s standard deviation, assumed to be the same for both test and reference.</p>
</td></tr>
<tr><td><code id="sampleSize_Mielke_+3A_true.diff">true.diff</code></td>
<td>
<p>Numeric or vector. Assumed true difference between test and reference for each endpoint. If a single value is provided, it is applied uniformly across all endpoints.</p>
</td></tr>
<tr><td><code id="sampleSize_Mielke_+3A_equi.tol">equi.tol</code></td>
<td>
<p>Numeric. Equivalence margin; the equivalence interval is defined as (-equi.tol, +equi.tol).</p>
</td></tr>
<tr><td><code id="sampleSize_Mielke_+3A_design">design</code></td>
<td>
<p>Character. Study design, either &quot;22co&quot; for a 2x2 crossover design or &quot;parallel&quot; for a parallel groups design.</p>
</td></tr>
<tr><td><code id="sampleSize_Mielke_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Significance level for the hypothesis test.</p>
</td></tr>
<tr><td><code id="sampleSize_Mielke_+3A_adjust">adjust</code></td>
<td>
<p>Character. Method for multiplicity adjustment; options are &quot;no&quot; (no adjustment), &quot;bon&quot; (Bonferroni adjustment), and &quot;k&quot; (k-adjustment).</p>
</td></tr>
<tr><td><code id="sampleSize_Mielke_+3A_seed">seed</code></td>
<td>
<p>Integer. Random seed for reproducibility.</p>
</td></tr>
<tr><td><code id="sampleSize_Mielke_+3A_nsim">nsim</code></td>
<td>
<p>Integer. Number of simulations to run for power estimation (default: 10,000).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the method proposed by Mielke et al. (2018) to estimate the sample size required to achieve the desired power level in studies with multiple correlated endpoints. The function iteratively increases sample size until the target power is reached or the maximum allowable sample size (Nmax) is exceeded. The approach accounts for endpoint correlation and supports adjustments for multiple testing using various correction methods.
</p>


<h3>Value</h3>

<p>A named vector containing:
</p>

<dl>
<dt>&quot;power.a&quot;</dt><dd><p>Achieved power with the estimated sample size.</p>
</dd>
<dt>&quot;SS&quot;</dt><dd><p>Required sample size per sequence to achieve the target power.</p>
</dd>
</dl>



<h3>References</h3>

<p>Mielke, J., Jones, B., Jilma, B. &amp; König, F. Sample Size for Multiple Hypothesis Testing in Biosimilar Development. Statistics in Biopharmaceutical Research 10, 39–49 (2018).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 from Mielke
sampleSize_Mielke(power = 0.8, Nmax = 1000, m = 5, k = 5, rho = 0,
                  sigma = 0.3, true.diff =  log(1.05), equi.tol = log(1.25),
                  design = "parallel", alpha = 0.05, adjust = "no",
                  seed = 1234, nsim = 100)

</code></pre>

<hr>
<h2 id='sign_Mielke'>Simulated Test Statistic for Noninferiority/Equivalence Trials</h2><span id='topic+sign_Mielke'></span>

<h3>Description</h3>

<p>Simulates test statistics for multiple hypothesis testing in biosimilar development,
following the approach described by Mielke et al. (2018). It calculates the necessary
sample size for meeting equivalence criteria across multiple endpoints while
considering correlation structures and applying multiplicity adjustments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sign_Mielke(
  N,
  m,
  k,
  R,
  sigma,
  true.diff,
  equi.tol = log(1.25),
  design,
  alpha = 0.05,
  adjust = "no"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sign_Mielke_+3A_n">N</code></td>
<td>
<p>Integer specifying the number of subjects per sequence.</p>
</td></tr>
<tr><td><code id="sign_Mielke_+3A_m">m</code></td>
<td>
<p>Integer specifying the number of endpoints.</p>
</td></tr>
<tr><td><code id="sign_Mielke_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of endpoints that must meet equivalence
to consider the test successful.</p>
</td></tr>
<tr><td><code id="sign_Mielke_+3A_r">R</code></td>
<td>
<p>Matrix specifying the correlation structure between endpoints.
This should be an <code>m x m</code> matrix, e.g., generated using <code>variance.const.corr()</code>.</p>
</td></tr>
<tr><td><code id="sign_Mielke_+3A_sigma">sigma</code></td>
<td>
<p>Numeric specifying the standard deviation of endpoints.
Can be a vector of length <code>m</code> (one per endpoint) or a single value.
In a 2x2 crossover design, this represents within-subject variance.
In a parallel-group design, it represents the treatment group standard deviation.</p>
</td></tr>
<tr><td><code id="sign_Mielke_+3A_true.diff">true.diff</code></td>
<td>
<p>Numeric specifying the assumed true difference between test and reference.
Can be a vector of length <code>m</code> or a single value.</p>
</td></tr>
<tr><td><code id="sign_Mielke_+3A_equi.tol">equi.tol</code></td>
<td>
<p>Numeric specifying the equivalence margins.
The interval is defined as <code>(-equi.tol, +equi.tol)</code>.</p>
</td></tr>
<tr><td><code id="sign_Mielke_+3A_design">design</code></td>
<td>
<p>Character specifying the study design.
Options are <code>"22co"</code> for a 2x2 crossover design or <code>"parallel"</code> for a parallel-group design.</p>
</td></tr>
<tr><td><code id="sign_Mielke_+3A_alpha">alpha</code></td>
<td>
<p>Numeric specifying the significance level.</p>
</td></tr>
<tr><td><code id="sign_Mielke_+3A_adjust">adjust</code></td>
<td>
<p>Character specifying the method for multiplicity adjustment.
Options include <code>"no"</code> for no adjustment, <code>"bon"</code> for Bonferroni correction,
and <code>"k"</code> for k-adjustment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed for multiple-endpoint clinical trials, where success
is defined as meeting equivalence criteria for at least a subset of tests.
Simulated test statistics are based on multivariate normal distribution assumptions,
and the function supports k-out-of-m success criteria for regulatory approval.
</p>
<p>Type I error control is achieved through multiplicity adjustments as proposed by
Lehmann and Romano (2005) to ensure rigorous error rate management. This approach
is particularly relevant for biosimilar studies, where sample size estimation must
account for multiple comparisons across endpoints, doses, or populations.
</p>


<h3>Value</h3>

<p>A numeric vector representing a realization of the simulated test statistic for the given setting.
</p>


<h3>References</h3>

<p>Kong, L., Kohberger, R. C., &amp; Koch, G. G. (2004). Type I Error and Power in
Noninferiority/Equivalence Trials with Correlated Multiple Endpoints: An Example
from Vaccine Development Trials. <em>Journal of Biopharmaceutical Statistics, 14</em>(4), 893–907.
</p>
<p>Lehmann, E. L., &amp; Romano, J. P. (2005). Generalizations of the Familywise Error Rate.
<em>The Annals of Statistics, 33</em>(2), 1138–1154.
</p>
<p>Mielke, J., Jones, B., Jilma, B., &amp; König, F. (2018). Sample Size for Multiple
Hypothesis Testing in Biosimilar Development. <em>Statistics in Biopharmaceutical Research, 10</em>(1), 39–49.
</p>

<hr>
<h2 id='simParallelEndpoints'>Generate Simulated Endpoint Data for Parallel Group Design</h2><span id='topic+simParallelEndpoints'></span>

<h3>Description</h3>

<p>Generate simulated endpoint data for a parallel design, with options for normal and lognormal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simParallelEndpoints(
  n,
  mu.arithmetic,
  mu.geometric = NULL,
  Sigma,
  CV = NULL,
  seed,
  dist = "normal"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simParallelEndpoints_+3A_n">n</code></td>
<td>
<p>Integer. The sample size for the generated data.</p>
</td></tr>
<tr><td><code id="simParallelEndpoints_+3A_mu.arithmetic">mu.arithmetic</code></td>
<td>
<p>Numeric vector. The arithmetic mean of the endpoints on the original scale.</p>
</td></tr>
<tr><td><code id="simParallelEndpoints_+3A_mu.geometric">mu.geometric</code></td>
<td>
<p>Numeric vector. The geometric mean of the endpoints on the original scale. Only used if <code>dist = "lognormal"</code>.</p>
</td></tr>
<tr><td><code id="simParallelEndpoints_+3A_sigma">Sigma</code></td>
<td>
<p>Matrix. Variance-covariance matrix of the raw data on the original scale. If <code>dist = "lognormal"</code>, this matrix is transformed to the log scale.</p>
</td></tr>
<tr><td><code id="simParallelEndpoints_+3A_cv">CV</code></td>
<td>
<p>Numeric vector. Coefficient of variation (CV) of the raw data. Only used when <code>dist = "lognormal"</code>, where it is transformed to the log scale.</p>
</td></tr>
<tr><td><code id="simParallelEndpoints_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed for random number generation, ensuring reproducibility.</p>
</td></tr>
<tr><td><code id="simParallelEndpoints_+3A_dist">dist</code></td>
<td>
<p>Character. Assumed distribution of the endpoints: either <code>"normal"</code> or <code>"lognormal"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of simulated endpoint values for a parallel design, with dimensions <code>n</code> by the number of variables in <code>mu.arithmetic</code> or <code>mu.geometric</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='test_2x2_dom'>Simulate a 2x2 Crossover Design and Compute Difference of Means (DOM)</h2><span id='topic+test_2x2_dom'></span>

<h3>Description</h3>

<p>Simulates a two-sequence, two-period (2x2) crossover design and evaluate equivalence for the difference of means (DOM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_2x2_dom(
  n,
  muT,
  muR,
  SigmaW,
  lequi_tol,
  uequi_tol,
  alpha,
  sigmaB,
  dropout,
  Eper,
  Eco,
  typey,
  adseq,
  k,
  arm_seed
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_2x2_dom_+3A_n">n</code></td>
<td>
<p>integer number of subjects per sequence</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_mut">muT</code></td>
<td>
<p>vector mean of endpoints on treatment arm</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_mur">muR</code></td>
<td>
<p>vector mean of endpoints on reference arm</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_sigmaw">SigmaW</code></td>
<td>
<p>matrix  within subject covar-variance matrix across endpoints</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_lequi_tol">lequi_tol</code></td>
<td>
<p>vector  lower equivalence tolerance band across endpoints</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_uequi_tol">uequi_tol</code></td>
<td>
<p>vector  upper equivalence tolerance band across endpoints</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_alpha">alpha</code></td>
<td>
<p>vector alpha value across endpoints</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_sigmab">sigmaB</code></td>
<td>
<p>double between subject variance (assumed same for all endpoints)</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_dropout">dropout</code></td>
<td>
<p>vector of size 2 with dropout proportion per sequence (0,1)</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_eper">Eper</code></td>
<td>
<p>vector of size 2 with period effect on period (0,1)</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_eco">Eco</code></td>
<td>
<p>vector of size 2 with carry over effect of arm c(Reference, Treatment).</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_typey">typey</code></td>
<td>
<p>vector with positions of primary endpoints</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_adseq">adseq</code></td>
<td>
<p>boolean is used a sequential adjustment?</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_k">k</code></td>
<td>
<p>integer minimum number of equivalent endpoints</p>
</td></tr>
<tr><td><code id="test_2x2_dom_+3A_arm_seed">arm_seed</code></td>
<td>
<p>seed for the simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix containing the simulated hypothesis test results.
The first column represents the overall equivalence decision, where 1 indicates
success and 0 indicates failure. The subsequent columns contain the hypothesis
test results for each endpoint, followed by mean estimates for the reference and
treatment groups, and standard deviations for the reference and treatment groups.
</p>

<hr>
<h2 id='test_2x2_rom'>Simulate a 2x2 Crossover Design and Compute Ratio of Means (ROM)</h2><span id='topic+test_2x2_rom'></span>

<h3>Description</h3>

<p>Simulates a two-sequence, two-period (2x2) crossover design and evaluate equivalence for the ratio of means (ROM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_2x2_rom(
  n,
  muT,
  muR,
  SigmaW,
  lequi_tol,
  uequi_tol,
  alpha,
  sigmaB,
  dropout,
  Eper,
  Eco,
  typey,
  adseq,
  k,
  arm_seed
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_2x2_rom_+3A_n">n</code></td>
<td>
<p>integer number of subjects per sequence</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_mut">muT</code></td>
<td>
<p>vector mean of endpoints on treatment arm</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_mur">muR</code></td>
<td>
<p>vector mean of endpoints on reference arm</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_sigmaw">SigmaW</code></td>
<td>
<p>matrix  within subject covar-variance matrix across endpoints</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_lequi_tol">lequi_tol</code></td>
<td>
<p>vector  lower equivalence tolerance band across endpoints</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_uequi_tol">uequi_tol</code></td>
<td>
<p>vector  upper equivalence tolerance band across endpoints</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_alpha">alpha</code></td>
<td>
<p>vector alpha value across endpoints</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_sigmab">sigmaB</code></td>
<td>
<p>double between subject variance (assumed same for all endpoints)</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_dropout">dropout</code></td>
<td>
<p>vector of size 2 with dropout proportion per sequence (0,1)</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_eper">Eper</code></td>
<td>
<p>vector of size 2 with period effect on period (0,1)</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_eco">Eco</code></td>
<td>
<p>vector of size 2 with carry over effect of arm c(Reference, Treatment).</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_typey">typey</code></td>
<td>
<p>vector with positions of primary endpoints</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_adseq">adseq</code></td>
<td>
<p>boolean is used a sequential adjustment?</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_k">k</code></td>
<td>
<p>integer minimum number of equivalent endpoints</p>
</td></tr>
<tr><td><code id="test_2x2_rom_+3A_arm_seed">arm_seed</code></td>
<td>
<p>seed for the simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix containing the simulated hypothesis test results. The first column represents the overall equivalence decision, where 1 indicates success and 0 indicates failure. The subsequent columns contain the hypothesis test results for each endpoint, followed by mean estimates for the reference and treatment groups, and standard deviations for the reference and treatment groups.
</p>

<hr>
<h2 id='test_par_dom'>Simulate a Parallel Design and Test Difference of Means (DOM)</h2><span id='topic+test_par_dom'></span>

<h3>Description</h3>

<p>Simulates a parallel-group design and performs equivalence testing using the difference of means (DOM) approach.
This function evaluates whether the treatment and reference groups are equivalent based on predefined
equivalence margins and hypothesis testing criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_par_dom(
  n,
  muT,
  muR,
  SigmaT,
  SigmaR,
  lequi_tol,
  uequi_tol,
  alpha,
  dropout,
  typey,
  adseq,
  k,
  arm_seedT,
  arm_seedR,
  TART,
  TARR,
  vareq
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_par_dom_+3A_n">n</code></td>
<td>
<p>integer number of subjects per arm</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_mut">muT</code></td>
<td>
<p>vector mean of endpoints on treatment arm</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_mur">muR</code></td>
<td>
<p>vector mean of endpoints on reference arm</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_sigmat">SigmaT</code></td>
<td>
<p>matrix covar-variance matrix on treatment arm across endpoints</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_sigmar">SigmaR</code></td>
<td>
<p>matrix covar-variance matrix on reference arm across endpoints</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_lequi_tol">lequi_tol</code></td>
<td>
<p>vector  lower equivalence tolerance band across endpoints</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_uequi_tol">uequi_tol</code></td>
<td>
<p>vector  upper equivalence tolerance band across endpoints</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_alpha">alpha</code></td>
<td>
<p>vector alpha value across endpoints</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_dropout">dropout</code></td>
<td>
<p>vector of size 2 with dropout proportion per arm (T,R)</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_typey">typey</code></td>
<td>
<p>vector with positions of primary endpoints</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_adseq">adseq</code></td>
<td>
<p>boolean is used a sequential adjustment?</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_k">k</code></td>
<td>
<p>integer minimum number of equivalent endpoints</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_arm_seedt">arm_seedT</code></td>
<td>
<p>integer seed for the simulation on treatment arm</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_arm_seedr">arm_seedR</code></td>
<td>
<p>integer seed for the simulation on reference arm</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_tart">TART</code></td>
<td>
<p>double treatment allocation rate for the treatment arm</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_tarr">TARR</code></td>
<td>
<p>double treatment allocation rate for the reference arm</p>
</td></tr>
<tr><td><code id="test_par_dom_+3A_vareq">vareq</code></td>
<td>
<p>boolean assumed equivalence variance between arms for the t-test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simulates a parallel-group study design and evaluates equivalence
using the difference of means (DOM) approach. It accounts for dropout rates and
treatment allocation proportions while generating simulated data based on the
specified covariance structure. The test statistics are computed, and a final
equivalence decision is made based on the predefined number of required significant
endpoints (<code>k</code>). If sequential testing (<code>adseq</code>) is enabled, primary endpoints
must establish equivalence before secondary endpoints are evaluated.
When <code>vareq = TRUE</code>, the test assumes equal variances between groups and
applies Schuirmann's two one-sided tests (TOST).
</p>


<h3>Value</h3>

<p>A numeric matrix containing the simulated hypothesis test results.
The first column represents the overall equivalence decision, where 1 indicates
success and 0 indicates failure. The subsequent columns contain the hypothesis
test results for each endpoint, followed by mean estimates for the reference and
treatment groups, and standard deviations for the reference and treatment groups.
</p>

<hr>
<h2 id='test_par_rom'>Simulate a Parallel Design and Test Ratio of Means (ROM)</h2><span id='topic+test_par_rom'></span>

<h3>Description</h3>

<p>Simulates a parallel-group design and performs equivalence testing using the ratio of means (ROM) approach.
This function evaluates whether the treatment and reference groups are equivalent based on predefined
equivalence margins and hypothesis testing criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_par_rom(
  n,
  muT,
  muR,
  SigmaT,
  SigmaR,
  lequi_tol,
  uequi_tol,
  alpha,
  dropout,
  typey,
  adseq,
  k,
  arm_seedT,
  arm_seedR,
  TART,
  TARR,
  vareq
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_par_rom_+3A_n">n</code></td>
<td>
<p>integer number of subjects per arm</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_mut">muT</code></td>
<td>
<p>vector mean of endpoints on treatment arm</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_mur">muR</code></td>
<td>
<p>vector mean of endpoints on reference arm</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_sigmat">SigmaT</code></td>
<td>
<p>matrix covar-variance matrix on treatment arm across endpoints</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_sigmar">SigmaR</code></td>
<td>
<p>matrix covar-variance matrix on reference arm across endpoints</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_lequi_tol">lequi_tol</code></td>
<td>
<p>vector  lower equivalence tolerance band across endpoints</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_uequi_tol">uequi_tol</code></td>
<td>
<p>vector  upper equivalence tolerance band across endpoints</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_alpha">alpha</code></td>
<td>
<p>vector alpha value across endpoints</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_dropout">dropout</code></td>
<td>
<p>vector of size 2 with dropout proportion per arm (T,R)</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_typey">typey</code></td>
<td>
<p>vector with positions of primary endpoints</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_adseq">adseq</code></td>
<td>
<p>boolean is used a sequential adjustment?</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_k">k</code></td>
<td>
<p>integer minimum number of equivalent endpoints</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_arm_seedt">arm_seedT</code></td>
<td>
<p>integer seed for the simulation on treatment arm</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_arm_seedr">arm_seedR</code></td>
<td>
<p>integer seed for the simulation on reference arm</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_tart">TART</code></td>
<td>
<p>double treatment allocation rate for the treatment arm</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_tarr">TARR</code></td>
<td>
<p>double treatment allocation rate for the reference arm</p>
</td></tr>
<tr><td><code id="test_par_rom_+3A_vareq">vareq</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, assumes equal variance between arms and applies Schuirmann's two one-sided tests (TOST) for equivalence using a pooled variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simulates a parallel-group study design and evaluates equivalence
using the ratio of means (ROM) approach. It accounts for dropout rates and
treatment allocation proportions while generating simulated data based on the
specified covariance structure. The test statistics are computed, and a final
equivalence decision is made based on the predefined number of required significant
endpoints (<code>k</code>). If sequential testing (<code>adseq</code>) is enabled, primary endpoints
must establish equivalence before secondary endpoints are evaluated.
When <code>vareq = TRUE</code>, the test assumes equal variances between groups and
applies Schuirmann's two one-sided tests (TOST).
</p>


<h3>Value</h3>

<p>A numeric matrix containing the simulated hypothesis test results.
The first column represents the overall equivalence decision, where 1 indicates
success and 0 indicates failure. The subsequent columns contain the hypothesis
test results for each endpoint, followed by mean estimates for the reference and
treatment groups, and standard deviations for the reference and treatment groups.
</p>

<hr>
<h2 id='test_studies'>test_studies</h2><span id='topic+test_studies'></span>

<h3>Description</h3>

<p>Internal function to estimate the bioequivalence test for nsim simulated studies given a sample size n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_studies(nsim, n, comp, param, param.d, arm_seed, ncores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_studies_+3A_nsim">nsim</code></td>
<td>
<p>number of simulated studies</p>
</td></tr>
<tr><td><code id="test_studies_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="test_studies_+3A_comp">comp</code></td>
<td>
<p>index comparator</p>
</td></tr>
<tr><td><code id="test_studies_+3A_param">param</code></td>
<td>
<p>list of parameters (mean,sd,tar)</p>
</td></tr>
<tr><td><code id="test_studies_+3A_param.d">param.d</code></td>
<td>
<p>design parameters</p>
</td></tr>
<tr><td><code id="test_studies_+3A_arm_seed">arm_seed</code></td>
<td>
<p>seed for each endpoint to get consistent in simulations across all comparators</p>
</td></tr>
<tr><td><code id="test_studies_+3A_ncores">ncores</code></td>
<td>
<p>number of cores used for the calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical matrix of size  (nsim) X (number of endpoints + 1) function only replicates test_bioq nsim times.
</p>

<hr>
<h2 id='uniroot.integer.mod'>Optimizer for Uniroot Integer (Modified)</h2><span id='topic+uniroot.integer.mod'></span>

<h3>Description</h3>

<p>A modified integer-based root-finding algorithm for determining the sample size required to achieve a target power.
This function extends the uniroot integer search method to handle cases with stepwise power searches while considering constraints on search limits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniroot.integer.mod(
  f,
  power,
  lower = lower,
  upper = upper,
  step.power = step.power,
  step.up = step.up,
  pos.side = pos.side,
  maxiter = maxiter,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniroot.integer.mod_+3A_f">f</code></td>
<td>
<p>Function for which a root is needed.</p>
</td></tr>
<tr><td><code id="uniroot.integer.mod_+3A_power">power</code></td>
<td>
<p>Numeric. Target power value.</p>
</td></tr>
<tr><td><code id="uniroot.integer.mod_+3A_lower">lower</code></td>
<td>
<p>Integer. Minimum allowable root value.</p>
</td></tr>
<tr><td><code id="uniroot.integer.mod_+3A_upper">upper</code></td>
<td>
<p>Integer. Maximum allowable root value.</p>
</td></tr>
<tr><td><code id="uniroot.integer.mod_+3A_step.power">step.power</code></td>
<td>
<p>Numeric. Initial step size defined as <code>2^step.power</code>.</p>
</td></tr>
<tr><td><code id="uniroot.integer.mod_+3A_step.up">step.up</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the search increments from <code>lower</code>; if <code>FALSE</code>, it decrements from <code>upper</code>.</p>
</td></tr>
<tr><td><code id="uniroot.integer.mod_+3A_pos.side">pos.side</code></td>
<td>
<p>Logical. If <code>TRUE</code>, finds the closest integer <code>i</code> such that <code>f(i) &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="uniroot.integer.mod_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer. Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="uniroot.integer.mod_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt><code>root</code></dt><dd><p>The integer value closest to the root on the correct side.</p>
</dd>
<dt><code>f.root</code></dt><dd><p>Value of <code>f</code> at the estimated root.</p>
</dd>
<dt><code>iter</code></dt><dd><p>Number of function evaluations performed.</p>
</dd>
<dt><code>table.iter</code></dt><dd><p>A data frame showing estimated sample size (<code>N</code>) and corresponding power at each iteration.</p>
</dd>
<dt><code>table.test</code></dt><dd><p>A data frame containing endpoint-level test results for each simulation and corresponding <code>N</code>.</p>
</dd>
</dl>


<hr>
<h2 id='validate_positive_definite'>Validate Positive Semi-Definite Matrices</h2><span id='topic+validate_positive_definite'></span>

<h3>Description</h3>

<p>Validates that all matrices in a list are symmetric and positive semi-definite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_positive_definite(varcov_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_positive_definite_+3A_varcov_list">varcov_list</code></td>
<td>
<p>List of matrices. Each matrix is checked to ensure it is symmetric and positive semi-definite.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL. If all matrices pass, the function returns nothing. If any matrix fails, it stops with an error message.
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

<hr>
<h2 id='validate_sample_size_limits'>Check Sample Size Limits</h2><span id='topic+validate_sample_size_limits'></span>

<h3>Description</h3>

<p>Validates that the upper and lower limits are numeric and that the upper limit is greater than the lower limit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_sample_size_limits(lower, upper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_sample_size_limits_+3A_lower">lower</code></td>
<td>
<p>Numeric. The initial lower limit for the search range.</p>
</td></tr>
<tr><td><code id="validate_sample_size_limits_+3A_upper">upper</code></td>
<td>
<p>Numeric. The initial upper limit for the search range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL. If the checks pass, the function returns nothing. If the checks fail, it stops execution with an error message.
</p>


<h3>Author(s)</h3>

<p>Thomas Debray <a href="mailto:tdebray@fromdatatowisdom.com">tdebray@fromdatatowisdom.com</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
