<!DOCTYPE html><html><head><title>Help for package prioritizr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prioritizr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#prioritizr'><p>prioritizr: Systematic Conservation Prioritization in R</p></a></li>
<li><a href='#add_absolute_targets'><p>Add absolute targets</p></a></li>
<li><a href='#add_asym_connectivity_penalties'><p>Add asymmetric connectivity penalties</p></a></li>
<li><a href='#add_binary_decisions'><p>Add binary decisions</p></a></li>
<li><a href='#add_boundary_penalties'><p>Add boundary penalties</p></a></li>
<li><a href='#add_cbc_solver'><p>Add a <em>CBC</em> solver</p></a></li>
<li><a href='#add_connectivity_penalties'><p>Add connectivity penalties</p></a></li>
<li><a href='#add_contiguity_constraints'><p>Add contiguity constraints</p></a></li>
<li><a href='#add_cplex_solver'><p>Add a <em>CPLEX</em> solver</p></a></li>
<li><a href='#add_cuts_portfolio'><p>Add Bender's cuts portfolio</p></a></li>
<li><a href='#add_default_portfolio'><p>Add a default portfolio</p></a></li>
<li><a href='#add_default_solver'><p>Add default solver</p></a></li>
<li><a href='#add_extra_portfolio'><p>Add an extra portfolio</p></a></li>
<li><a href='#add_feature_contiguity_constraints'><p>Add feature contiguity constraints</p></a></li>
<li><a href='#add_feature_weights'><p>Add feature weights</p></a></li>
<li><a href='#add_gap_portfolio'><p>Add a gap portfolio</p></a></li>
<li><a href='#add_gurobi_solver'><p>Add a <em>Gurobi</em> solver</p></a></li>
<li><a href='#add_highs_solver'><p>Add a <em>HiGHS</em> solver</p></a></li>
<li><a href='#add_linear_constraints'><p>Add linear constraints</p></a></li>
<li><a href='#add_linear_penalties'><p>Add linear penalties</p></a></li>
<li><a href='#add_locked_in_constraints'><p>Add locked in constraints</p></a></li>
<li><a href='#add_locked_out_constraints'><p>Add locked out constraints</p></a></li>
<li><a href='#add_loglinear_targets'><p>Add targets using log-linear scaling</p></a></li>
<li><a href='#add_lsymphony_solver'><p>Add a <em>SYMPHONY</em> solver with <em>lpsymphony</em></p></a></li>
<li><a href='#add_mandatory_allocation_constraints'><p>Add mandatory allocation constraints</p></a></li>
<li><a href='#add_manual_bounded_constraints'><p>Add manually specified bound constraints</p></a></li>
<li><a href='#add_manual_locked_constraints'><p>Add manually specified locked constraints</p></a></li>
<li><a href='#add_manual_targets'><p>Add manual targets</p></a></li>
<li><a href='#add_max_cover_objective'><p>Add maximum coverage objective</p></a></li>
<li><a href='#add_max_features_objective'><p>Add maximum feature representation objective</p></a></li>
<li><a href='#add_max_phylo_div_objective'><p>Add maximum phylogenetic diversity objective</p></a></li>
<li><a href='#add_max_phylo_end_objective'><p>Add maximum phylogenetic endemism objective</p></a></li>
<li><a href='#add_max_utility_objective'><p>Add maximum utility objective</p></a></li>
<li><a href='#add_min_largest_shortfall_objective'><p>Add minimum largest shortfall objective</p></a></li>
<li><a href='#add_min_set_objective'><p>Add minimum set objective</p></a></li>
<li><a href='#add_min_shortfall_objective'><p>Add minimum shortfall objective</p></a></li>
<li><a href='#add_neighbor_constraints'><p>Add neighbor constraints</p></a></li>
<li><a href='#add_proportion_decisions'><p>Add proportion decisions</p></a></li>
<li><a href='#add_relative_targets'><p>Add relative targets</p></a></li>
<li><a href='#add_rsymphony_solver'><p>Add a <em>SYMPHONY</em> solver with <em>Rsymphony</em></p></a></li>
<li><a href='#add_semicontinuous_decisions'><p>Add semi-continuous decisions</p></a></li>
<li><a href='#add_shuffle_portfolio'><p>Add a shuffle portfolio</p></a></li>
<li><a href='#add_top_portfolio'><p>Add a top portfolio</p></a></li>
<li><a href='#adjacency_matrix'><p>Adjacency matrix</p></a></li>
<li><a href='#binary_stack'><p>Binary stack</p></a></li>
<li><a href='#boundary_matrix'><p>Boundary matrix</p></a></li>
<li><a href='#branch_matrix'><p>Branch matrix</p></a></li>
<li><a href='#category_layer'><p>Category layer</p></a></li>
<li><a href='#category_vector'><p>Category vector</p></a></li>
<li><a href='#compile'><p>Compile a problem</p></a></li>
<li><a href='#connectivity_matrix'><p>Connectivity matrix</p></a></li>
<li><a href='#ConservationModifier-class'><p>Conservation problem modifier class</p></a></li>
<li><a href='#ConservationProblem-class'><p>Conservation problem class</p></a></li>
<li><a href='#Constraint-class'><p>Constraint class</p></a></li>
<li><a href='#constraints'><p>Conservation problem constraints</p></a></li>
<li><a href='#Decision-class'><p>Decision class</p></a></li>
<li><a href='#decisions'><p>Add decision types</p></a></li>
<li><a href='#eval_asym_connectivity_summary'><p>Evaluate asymmetric connectivity of solution</p></a></li>
<li><a href='#eval_boundary_summary'><p>Evaluate boundary length of solution</p></a></li>
<li><a href='#eval_connectivity_summary'><p>Evaluate connectivity of solution</p></a></li>
<li><a href='#eval_cost_summary'><p>Evaluate cost of solution</p></a></li>
<li><a href='#eval_feature_representation_summary'><p>Evaluate feature representation by solution</p></a></li>
<li><a href='#eval_ferrier_importance'><p>Evaluate solution importance using Ferrier scores</p></a></li>
<li><a href='#eval_n_summary'><p>Evaluate number of planning units selected by solution</p></a></li>
<li><a href='#eval_rare_richness_importance'><p>Evaluate solution importance using rarity weighted richness scores</p></a></li>
<li><a href='#eval_replacement_importance'><p>Evaluate solution importance using replacement cost scores</p></a></li>
<li><a href='#eval_target_coverage_summary'><p>Evaluate target coverage by solution</p></a></li>
<li><a href='#fast_extract'><p>Fast extract</p></a></li>
<li><a href='#feature_abundances'><p>Feature abundances</p></a></li>
<li><a href='#feature_names'><p>Feature names</p></a></li>
<li><a href='#importance'><p>Evaluate solution importance</p></a></li>
<li><a href='#intersecting_units'><p>Find intersecting units</p></a></li>
<li><a href='#knit_print'><p>Print an object for knitr package.</p></a></li>
<li><a href='#loglinear_interpolation'><p>Log-linear interpolation</p></a></li>
<li><a href='#marxan_boundary_data_to_matrix'><p>Convert <em>Marxan</em> boundary data to matrix format</p></a></li>
<li><a href='#marxan_connectivity_data_to_matrix'><p>Convert <em>Marxan</em> connectivity data to matrix format</p></a></li>
<li><a href='#marxan_problem'><p><em>Marxan</em> conservation problem</p></a></li>
<li><a href='#new_waiver'><p>Waiver</p></a></li>
<li><a href='#number_of_features'><p>Number of features</p></a></li>
<li><a href='#number_of_planning_units'><p>Number of planning units</p></a></li>
<li><a href='#number_of_total_units'><p>Number of total units</p></a></li>
<li><a href='#number_of_zones'><p>Number of zones</p></a></li>
<li><a href='#Objective-class'><p>Objective class</p></a></li>
<li><a href='#objectives'><p>Add an objective</p></a></li>
<li><a href='#optimization_problem'><p>Optimization problem</p></a></li>
<li><a href='#OptimizationProblem-class'><p>Optimization problem class</p></a></li>
<li><a href='#OptimizationProblem-methods'><p>Optimization problem methods</p></a></li>
<li><a href='#penalties'><p>Add a penalty</p></a></li>
<li><a href='#Penalty-class'><p>Penalty class</p></a></li>
<li><a href='#Portfolio-class'><p>Portfolio class</p></a></li>
<li><a href='#portfolios'><p>Add portfolios</p></a></li>
<li><a href='#presolve_check'><p>Presolve check</p></a></li>
<li><a href='#prioritizr-deprecated'><p>Deprecation notice</p></a></li>
<li><a href='#problem'><p>Conservation planning problem</p></a></li>
<li><a href='#proximity_matrix'><p>Proximity matrix</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rescale_matrix'><p>Rescale a matrix</p></a></li>
<li><a href='#rij_matrix'><p>Feature by planning unit matrix</p></a></li>
<li><a href='#run_calculations'><p>Run calculations</p></a></li>
<li><a href='#show'><p>Show</p></a></li>
<li><a href='#sim_data'><p>Get simulated conservation planning data</p></a></li>
<li><a href='#simulate_cost'><p>Simulate cost data</p></a></li>
<li><a href='#simulate_data'><p>Simulate data</p></a></li>
<li><a href='#simulate_species'><p>Simulate species habitat suitability data</p></a></li>
<li><a href='#solve'><p>Solve</p></a></li>
<li><a href='#Solver-class'><p>Solver class</p></a></li>
<li><a href='#solvers'><p>Add solvers</p></a></li>
<li><a href='#summaries'><p>Evaluate solutions using summary statistics</p></a></li>
<li><a href='#Target-class'><p>Target class</p></a></li>
<li><a href='#targets'><p>Add representation targets</p></a></li>
<li><a href='#tibble-methods'><p>Manipulate tibbles</p></a></li>
<li><a href='#write_problem'><p>Write problem</p></a></li>
<li><a href='#zone_names'><p>Zone names</p></a></li>
<li><a href='#zones'><p>Management zones</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>8.0.4</td>
</tr>
<tr>
<td>Title:</td>
<td>Systematic Conservation Prioritization in R</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Systematic conservation prioritization using mixed integer linear
    programming (MILP). It provides a flexible interface for building and
    solving conservation planning problems. Once built, conservation planning
    problems can be solved using a variety of commercial and open-source exact
    algorithm solvers. By using exact algorithm solvers, solutions can be
    generated that are guaranteed to be optimal (or within a pre-specified
    optimality gap). Furthermore, conservation problems can be constructed to
    optimize the spatial allocation of different management actions or zones,
    meaning that conservation practitioners can identify solutions that benefit
    multiple stakeholders. To solve large-scale or complex conservation
    planning problems, users should install the Gurobi optimization software
    (available from <a href="https://www.gurobi.com/">https://www.gurobi.com/</a>) and the 'gurobi' R package (see
    Gurobi Installation Guide vignette for details). Users can also install the
    IBM CPLEX software (<a href="https://www.ibm.com/products/ilog-cplex-optimization-studio/cplex-optimizer">https://www.ibm.com/products/ilog-cplex-optimization-studio/cplex-optimizer</a>) and
    the 'cplexAPI' R package (available at <a href="https://github.com/cran/cplexAPI">https://github.com/cran/cplexAPI</a>).
    Additionally, the 'rcbc' R package (available at
    <a href="https://github.com/dirkschumacher/rcbc">https://github.com/dirkschumacher/rcbc</a>) can be used to generate solutions
    using the CBC optimization software (<a href="https://github.com/coin-or/Cbc">https://github.com/coin-or/Cbc</a>).</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, methods, parallel, R6 (&ge; 2.5.1), rlang (&ge; 1.0.6), cli
(&ge; 3.6.0), sf (&ge; 1.0-12), terra (&ge; 1.6-53), raster (&ge;
3.6.11), Matrix (&ge; 1.3-0), assertthat (&ge; 0.2.0), slam (&ge;
0.1-48), igraph (&ge; 2.0.3), ape (&ge; 5.6-1), magrittr (&ge;
2.0.1), exactextractr (&ge; 0.8.1), tibble (&ge; 2.0.0), withr (&ge;
2.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.1.0), knitr (&ge; 1.36), scales (&ge; 1.1.1),
gurobi (&ge; 8.0-1), rcbc (&ge; 0.1.0.9001), cplexAPI (&ge; 1.4.0),
lpsymphony (&ge; 1.17.0), Rsymphony (&ge; 0.1-31), highs (&ge;
0.1-10), rmarkdown (&ge; 2.11), prioritizrdata (&ge; 0.2.4),
data.table (&ge; 1.14.2), fields (&ge; 14.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.7), RcppArmadillo (&ge; 0.10.7.3.0), BH (&ge;
1.75.0-0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://prioritizr.net">https://prioritizr.net</a>, <a href="https://github.com/prioritizr/prioritizr">https://github.com/prioritizr/prioritizr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/prioritizr/prioritizr/issues">https://github.com/prioritizr/prioritizr/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'external-classes.R' 'internal.R' 'assertions_class.R'
'assertions_sf.R' 'assertions_misc.R' 'assertions_raster.R'
'assertions_vector.R' 'any_nonzero.R' 'any_nonNA.R'
'all_proportion.R' 'all_positive.R' 'all_finite.R'
'all_columns_inherit.R' 'all_columns_any_finite.R'
'all_binary.R' 'assertions.R' 'waiver.R'
'ConservationModifier-class.R' 'category_vector.R'
'category_layer.R' 'binary_stack.R'
'ConservationProblem-class.R' 'Constraint-class.R'
'Decision-class.R' 'Objective-class.R' 'cli.R'
'OptimizationProblem-class.R' 'reexports.R'
'OptimizationProblem-methods.R' 'Penalty-class.R'
'Portfolio-class.R' 'RcppExports.R' 'Solver-class.R'
'Target-class.R' 'zones.R' 'add_absolute_targets.R'
'marxan_connectivity_data_to_matrix.R'
'add_asym_connectivity_penalties.R' 'add_binary_decisions.R'
'marxan_boundary_data_to_matrix.R' 'add_boundary_penalties.R'
'add_cbc_solver.R' 'add_compile_solver.R'
'add_connectivity_penalties.R' 'add_contiguity_constraints.R'
'add_cplex_solver.R' 'add_cuts_portfolio.R'
'add_default_portfolio.R' 'add_default_solver.R'
'add_extra_portfolio.R' 'add_feature_contiguity_constraints.R'
'add_feature_weights.R' 'add_gap_portfolio.R'
'add_gurobi_solver.R' 'add_highs_solver.R'
'add_linear_constraints.R' 'add_linear_penalties.R'
'intersecting_units.R' 'add_locked_in_constraints.R'
'add_locked_out_constraints.R' 'loglinear_interpolation.R'
'add_loglinear_targets.R' 'add_lpsymphony_solver.R'
'add_mandatory_allocation_constraints.R' 'tbl_df.R'
'add_manual_targets.R' 'add_manual_bounded_constraints.R'
'add_manual_locked_constraints.R' 'add_max_cover_objective.R'
'add_max_features_objective.R' 'add_max_phylo_div_objective.R'
'add_max_phylo_end_objective.R' 'add_max_utility_objective.R'
'add_min_largest_shortfall_objective.R'
'add_min_set_objective.R' 'add_min_shortfall_objective.R'
'add_neighbor_constraints.R' 'add_proportion_decisions.R'
'add_relative_targets.R' 'add_rsymphony_solver.R'
'add_semicontinuous_decisions.R' 'add_shuffle_portfolio.R'
'add_top_portfolio.R' 'adjacency_matrix.R' 'as.R' 'as_Matrix.R'
'boundary_matrix.R' 'branch_matrix.R' 'compile.R'
'connectivity_matrix.R' 'constraints.R' 'data.R' 'decisions.R'
'deprecated.R' 'eval_asym_connectivity_summary.R'
'eval_boundary_summary.R' 'eval_connectivity_summary.R'
'eval_cost_summary.R' 'eval_feature_representation_summary.R'
'eval_ferrier_importance.R' 'eval_n_summary.R'
'is_spatial_extents_overlap.R' 'problem.R'
'eval_rare_richness_importance.R' 'presolve_check.R' 'solve.R'
'eval_replacement_importance.R'
'eval_target_coverage_summary.R' 'fast_extract.R'
'feature_abundances.R' 'feature_names.R' 'get_crs.R'
'importance.R' 'is_numeric_values.R' 'is_same_crs.R'
'knit_print.R' 'list_text.R' 'marxan_problem.R'
'number_of_features.R' 'number_of_planning_units.R'
'number_of_total_units.R' 'number_of_zones.R' 'objectives.R'
'optimization_problem.R' 'package.R' 'penalties.R'
'planning_unit_solution_status.R' 'portfolios.R' 'print.R'
'problem-deprecated.R' 'proximity_matrix.R' 'repr.R'
'rescale_matrix.R' 'rij_matrix.R' 'run_calculations.R' 'show.R'
'simulate.R' 'solvers.R' 'st_geometry_classes.R' 'summaries.R'
'summary.R' 'targets.R' 'test-helpers.R' 'write_problem.R'
'zone_names.R' 'zzz.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-05 16:18:28 UTC; richard</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey O Hanson <a href="https://orcid.org/0000-0002-4716-6134"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Richard Schuster <a href="https://orcid.org/0000-0003-3191-7869"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Nina Morrell [aut],
  Matthew Strimas-Mackey
    <a href="https://orcid.org/0000-0001-8929-7776"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Brandon P M Edwards
    <a href="https://orcid.org/0000-0003-0865-3076"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Matthew E Watts [aut],
  Peter Arcese <a href="https://orcid.org/0000-0002-8097-482X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Joseph R Bennett <a href="https://orcid.org/0000-0002-3901-9513"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Hugh P Possingham <a href="https://orcid.org/0000-0001-7755-996X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Richard Schuster &lt;richard.schuster@glel.carleton.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-05 21:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='prioritizr'>prioritizr: Systematic Conservation Prioritization in R</h2><span id='topic+prioritizr'></span><span id='topic+prioritizr-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">prioritizr R</span> package uses mixed integer linear programming (MILP)
techniques to provide a flexible interface for building and solving
conservation planning problems (Rodrigues <em>et al.</em> 2000; Billionnet
2013). It supports a broad range of objectives, constraints, and penalties
that can be used to custom-tailor conservation planning problems to the
specific needs of a conservation planning exercise. Once built, conservation
planning problems can be solved using a variety of commercial and
open-source exact algorithm solvers. In contrast to the algorithms
conventionally used to solve conservation problems, such as heuristics or
simulated annealing (Ball <em>et al.</em> 2009), the exact algorithms used
here are guaranteed to find optimal solutions. Furthermore, conservation
problems can be constructed to optimize the spatial allocation of different
management actions or zones, meaning that conservation practitioners can
identify solutions that benefit multiple stakeholders. Finally, this package
has the functionality to read input data formatted for the <em>Marxan</em>
conservation planning program (Ball <em>et al.</em> 2009), and find much
cheaper solutions in a much shorter period of time than <em>Marxan</em> (Beyer
<em>et al.</em> 2016). See the
<a href="https://github.com/prioritizr/prioritizr">online code repository</a>
for more information.
</p>


<h3>Details</h3>

<p>This package contains several vignettes that are designed to
showcase its functionality. To view them, please use the code
<code>vignette("name", package = "prioritizr")</code> where <code>"name"</code> is the
name of the desired vignette (e.g., <code>"gurobi_installation"</code>).
</p>

<dl>
<dt>prioritizr</dt><dd><p>Background information on systematic conservation
planning, package intallation instructions and citation, and a
demonstration of the main package features.</p>
</dd>
<dt>package_overview</dt><dd><p>Comprehensive introduction to the package and
example workflows for the main package features.
</p>
</dd>
<dt>calibrating_trade-offs_tutorial</dt><dd><p>Examples of balancing different
criteria to identify candidate prioritizations.</p>
</dd>
<dt>connectivity_tutorial</dt><dd><p>Examples of incorporating and evaluating
connectivity in prioritizations using a range of approaches.</p>
</dd>
<dt>management_zones_tutorial</dt><dd><p>Tutorial on using multiple management
actions or zones to create detailed prioritizations.</p>
</dd>
<dt>gurobi_installation</dt><dd><p>Instructions for installing and setting up
the <em>Gurobi</em> optimization software for use with the package.</p>
</dd>
<dt>solver_benchmark</dt><dd><p>Reports run times for solving
conservation planning problems of varying size and complexity
using different solvers.</p>
</dd>
<dt>publication_record</dt><dd><p>List of publications that have cited the
package.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Authors:
</p>

<ul>
<li><p> Jeffrey O Hanson <a href="mailto:jeffrey.hanson@uqconnect.edu.au">jeffrey.hanson@uqconnect.edu.au</a> (<a href="https://orcid.org/0000-0002-4716-6134">ORCID</a>)
</p>
</li>
<li><p> Richard Schuster <a href="mailto:richard.schuster@glel.carleton.ca">richard.schuster@glel.carleton.ca</a> (<a href="https://orcid.org/0000-0003-3191-7869">ORCID</a>, maintainer)
</p>
</li>
<li><p> Nina Morrell <a href="mailto:nina.morrell@ubc.ca">nina.morrell@ubc.ca</a>
</p>
</li>
<li><p> Matthew Strimas-Mackey <a href="mailto:mstrimas@gmail.com">mstrimas@gmail.com</a> (<a href="https://orcid.org/0000-0001-8929-7776">ORCID</a>)
</p>
</li>
<li><p> Brandon P M Edwards <a href="mailto:brandonedwards3@cmail.carleton.ca">brandonedwards3@cmail.carleton.ca</a> (<a href="https://orcid.org/0000-0003-0865-3076">ORCID</a>)
</p>
</li>
<li><p> Matthew E Watts <a href="mailto:m.watts@uq.edu.au">m.watts@uq.edu.au</a>
</p>
</li>
<li><p> Peter Arcese <a href="mailto:peter.arcese@ubc.ca">peter.arcese@ubc.ca</a> (<a href="https://orcid.org/0000-0002-8097-482X">ORCID</a>)
</p>
</li>
<li><p> Joseph Bennett <a href="mailto:joseph.bennett@carleton.ca">joseph.bennett@carleton.ca</a> (<a href="https://orcid.org/0000-0002-3901-9513">ORCID</a>)
</p>
</li>
<li><p> Hugh P Possingham <a href="mailto:hugh.possingham@tnc.org">hugh.possingham@tnc.org</a> (<a href="https://orcid.org/0000-0001-7755-996X">ORCID</a>)
</p>
</li></ul>



<h3>References</h3>

<p>Ball IR, Possingham HP, and Watts M (2009) <em>Marxan and relatives:
Software for spatial conservation prioritisation</em> in Spatial conservation
prioritisation: Quantitative methods and computational tools. Eds Moilanen
A, Wilson KA, and Possingham HP. Oxford University Press, Oxford, UK.
</p>
<p>Beyer HL, Dujardin Y, Watts ME, and Possingham HP (2016) Solving
conservation planning problems with integer linear programming.
<em>Ecological Modelling</em>, 228: 14&ndash;22.
</p>
<p>Billionnet A (2013) Mathematical optimization ideas for biodiversity
conservation. <em>European Journal of Operational Research</em>, 231:
514&ndash;534.
</p>
<p>Rodrigues AS, Cerdeira OJ, and Gaston KJ (2000) Flexibility,
efficiency, and accountability: adapting reserve selection algorithms to
more complex conservation problems. <em>Ecography</em>, 23: 565&ndash;574.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Package website (<a href="https://prioritizr.net">https://prioritizr.net</a>)
</p>
</li>
<li><p> Source code repository (<a href="https://github.com/prioritizr/prioritizr">https://github.com/prioritizr/prioritizr</a>)
</p>
</li>
<li><p> Report bugs at (<a href="https://github.com/prioritizr/prioritizr/issues">https://github.com/prioritizr/prioritizr/issues</a>)
</p>
</li></ul>


<hr>
<h2 id='add_absolute_targets'>Add absolute targets</h2><span id='topic+add_absolute_targets'></span><span id='topic+add_absolute_targets-method'></span><span id='topic+add_absolute_targets+2CConservationProblem+2Cnumeric-method'></span><span id='topic+add_absolute_targets+2CConservationProblem+2Cmatrix-method'></span><span id='topic+add_absolute_targets+2CConservationProblem+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Set targets expressed as the actual value of features in the study area
that need to be represented in the prioritization. For instance,
setting a target of 10 requires that the solution secure a set of
planning units for which their summed feature values are equal to or greater
than 10.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_absolute_targets(x, targets)

## S4 method for signature 'ConservationProblem,numeric'
add_absolute_targets(x, targets)

## S4 method for signature 'ConservationProblem,matrix'
add_absolute_targets(x, targets)

## S4 method for signature 'ConservationProblem,character'
add_absolute_targets(x, targets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_absolute_targets_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_absolute_targets_+3A_targets">targets</code></td>
<td>
<p>object that specifies the targets for each feature.
See the Targets format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Targets are used to specify the minimum amount or proportion of a
feature's distribution that needs to be protected. Most conservation
planning problems require targets with the exception of the maximum cover
(see <code><a href="#topic+add_max_cover_objective">add_max_cover_objective()</a></code>) and maximum utility
(see <code><a href="#topic+add_max_utility_objective">add_max_utility_objective()</a></code>) problems. Attempting to solve
problems with objectives that require targets without specifying targets
will throw an error.
</p>
<p>For problems associated with multiple management zones,
<code><a href="#topic+add_absolute_targets">add_absolute_targets()</a></code> can
be used to set targets that each pertain to a single feature and a single
zone. To set targets that can be met through allocating different
planning units to multiple zones, see the <code><a href="#topic+add_manual_targets">add_manual_targets()</a></code>
function. An example of a target that could be met through allocations
to multiple zones might be where each management zone is expected to
result in a different amount of a feature and the target requires that
the total amount of the feature in all zones must exceed a certain
threshold. In other words, the target does not require that any single
zone secure a specific amount of the feature, but the total amount held
in all zones must secure a specific amount. Thus the target could,
potentially, be met through allocating all planning units to any specific
management zone, or through allocating the planning units to different
combinations of management zones.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the targets added to it.
</p>


<h3>Targets format</h3>

<p>The <code>targets</code> for a problem can be specified using the following formats.
</p>

<dl>
<dt><code>targets</code> as a <code>numeric</code> vector</dt><dd><p>containing target values for each
feature.
Additionally, for convenience, this format can be a single
value to assign the same target to each feature. Note that this format
cannot be used to specify targets for problems with multiple zones.</p>
</dd>
<dt><code>targets</code> as a <code>matrix</code> object</dt><dd><p>containing a target for each feature
in each zone.
Here, each row corresponds to a different feature in argument to
<code>x</code>, each column corresponds to a different zone in argument to
<code>x</code>, and each cell contains the target value for a given feature
that the solution needs to secure in a given zone.</p>
</dd>
<dt><code>targets</code> as a <code>character</code> vector</dt><dd><p>containing the column name(s) in the
feature data associated with the argument to <code>x</code> that
contain targets. This format can only be used when the
feature data associated with <code>x</code> is a <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> or <code>data.frame</code>.
For problems that contain a single zone, the argument to <code>targets</code> must
contain a single column name. Otherwise, for problems that
contain multiple zones, the argument to <code>targets</code> must
contain a column name for each zone.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="#topic+targets">targets</a> for an overview of all functions for adding targets.
</p>
<p>Other targets: 
<code><a href="#topic+add_loglinear_targets">add_loglinear_targets</a>()</code>,
<code><a href="#topic+add_manual_targets">add_manual_targets</a>()</code>,
<code><a href="#topic+add_relative_targets">add_relative_targets</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem with no targets
p0 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with targets to secure 3 amounts for each feature
p1 &lt;- p0 %&gt;% add_absolute_targets(3)

# create problem with varying targets for each feature
targets &lt;- c(1, 2, 3, 2, 1)
p2 &lt;- p0 %&gt;% add_absolute_targets(targets)

# solve problem
s1 &lt;- c(solve(p1), solve(p2))
names(s1) &lt;- c("equal targets", "varying targets")

# plot solution
plot(s1, axes = FALSE)

# create a problem with multiple management zones
p3 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create a problem with targets that specify an equal amount of each feature
# to be represented in each zone
p4_targets &lt;- matrix(
  2,
  nrow = number_of_features(sim_zones_features),
  ncol = number_of_zones(sim_zones_features),
  dimnames = list(
    feature_names(sim_zones_features), zone_names(sim_zones_features)
  )
)
print(p4_targets)

p4 &lt;- p3 %&gt;% add_absolute_targets(p4_targets)

# solve problem
s4 &lt;- solve(p4)

# plot solution (pixel values correspond to zone identifiers)
plot(category_layer(s4), main = "equal targets", axes = FALSE)

# create a problem with targets that require a varying amount of each
# feature to be represented in each zone
p5_targets &lt;- matrix(
  rpois(15, 1),
  nrow = number_of_features(sim_zones_features),
  ncol = number_of_zones(sim_zones_features),
  dimnames = list(
    feature_names(sim_zones_features),
    zone_names(sim_zones_features)
  )
)
print(p5_targets)

p5 &lt;- p3 %&gt;% add_absolute_targets(p5_targets)

# solve problem
s5 &lt;- solve(p5)

# plot solution (pixel values correspond to zone identifiers)
plot(category_layer(s5), main = "varying targets", axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='add_asym_connectivity_penalties'>Add asymmetric connectivity penalties</h2><span id='topic+add_asym_connectivity_penalties'></span><span id='topic+add_asym_connectivity_penalties+2CConservationProblem+2CANY+2CANY+2CMatrix-method'></span><span id='topic+add_asym_connectivity_penalties+2CConservationProblem+2CANY+2CANY+2Cmatrix-method'></span><span id='topic+add_asym_connectivity_penalties+2CConservationProblem+2CANY+2CANY+2CdgCMatrix-method'></span><span id='topic+add_asym_connectivity_penalties+2CConservationProblem+2CANY+2CANY+2Cdata.frame-method'></span><span id='topic+add_asym_connectivity_penalties+2CConservationProblem+2CANY+2CANY+2Carray-method'></span>

<h3>Description</h3>

<p>Add penalties to a conservation planning problem to account for
asymmetric connectivity between planning units.
Asymmetric connectivity data describe connectivity information that is
directional.
For example, asymmetric connectivity data could describe
the strength of rivers flowing between different planning units. Since
river flow is directional, the level of connectivity
from an upstream planning unit to a downstream planning unit would
be higher than that from a downstream planning unit to an upstream planning
unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConservationProblem,ANY,ANY,matrix'
add_asym_connectivity_penalties(x, penalty, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,Matrix'
add_asym_connectivity_penalties(x, penalty, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,data.frame'
add_asym_connectivity_penalties(x, penalty, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,dgCMatrix'
add_asym_connectivity_penalties(x, penalty, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,array'
add_asym_connectivity_penalties(x, penalty, zones, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_asym_connectivity_penalties_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_asym_connectivity_penalties_+3A_penalty">penalty</code></td>
<td>
<p><code>numeric</code> penalty that is used to scale the importance
of selecting planning units with strong connectivity between them compared
to the main problem objective (e.g., solution cost when the argument to
<code>x</code> has a minimum set objective set using
<code><a href="#topic+add_min_set_objective">add_min_set_objective()</a></code>). Higher <code>penalty</code> values
can be used to obtain solutions with a high degree of connectivity,
and smaller <code>penalty</code> values can be used to obtain solutions with a
small degree of connectivity. Note that negative <code>penalty</code> values can
be used to obtain solutions that have very little connectivity.</p>
</td></tr>
<tr><td><code id="add_asym_connectivity_penalties_+3A_zones">zones</code></td>
<td>
<p><code>matrix</code> or <code>Matrix</code> object describing the
level of connectivity between different zones. Each row and column
corresponds to a different zone in the argument to <code>x</code>, and cell
values indicate the level of connectivity between each combination
of zones. Cell values along the diagonal of the matrix represent
the level of connectivity between planning units allocated to the
same zone. Cell values must lay between 1 and -1, where negative
values favor solutions with weak connectivity. The default argument to
<code>zones</code> is an identity matrix (i.e., a matrix with ones along the
matrix diagonal and zeros elsewhere), so that planning units are
only considered to be connected when they are allocated to the same zone.
This argument is required when working with multiple zones and the
argument to <code>data</code> is a <code>matrix</code> or <code>Matrix</code> object.
If the argument to <code>data</code> is an <code>array</code> or <code>data.frame</code> with data for
multiple zones (e.g., using the <code>"zone1"</code> and <code>"zone2"</code> column names),
this argument must explicitly be set to <code>NULL</code> otherwise an error will be
thrown.</p>
</td></tr>
<tr><td><code id="add_asym_connectivity_penalties_+3A_data">data</code></td>
<td>
<p><code>matrix</code>, <code>Matrix</code>, <code>data.frame</code>, or
<code>array</code> object containing connectivity data. The connectivity values
correspond to the strength of connectivity between
different planning units. Thus connections between planning units
that are associated with higher values are more favorable in the solution.
See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds penalties to conservation planning problem to penalize
solutions that have low connectivity.
Specifically, it penalizes solutions that select planning units that
share high connectivity values with other planning units that are
not selected by the solution (based on Beger <em>et al.</em> 2010).
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the penalties added to it.
</p>


<h3>Mathematical formulation</h3>

<p>The connectivity penalties are implemented using the following equations.
Let <code class="reqn">I</code> represent the set of planning units
(indexed by <code class="reqn">i</code> or <code class="reqn">j</code>), <code class="reqn">Z</code> represent the set
of management zones (indexed by <code class="reqn">z</code> or <code class="reqn">y</code>), and <code class="reqn">X_{iz}</code>
represent the decision variable for planning unit <code class="reqn">i</code> for in zone
<code class="reqn">z</code> (e.g., with binary
values one indicating if planning unit is allocated or not). Also, let
<code class="reqn">p</code> represent the argument to <code>penalty</code>, <code class="reqn">D</code> represent the
argument to <code>data</code>, and <code class="reqn">W</code> represent the argument
to <code>zones</code>.
</p>
<p>If the argument to <code>data</code> is supplied as a <code>matrix</code> or
<code>Matrix</code> object, then the penalties are calculated as:
</p>
<p style="text-align: center;"><code class="reqn">
\sum_{i}^{I} \sum_{j}^{I} \sum_{z}^{Z} \sum_{y}^{Z}
(p \times X_{iz} \times D_{ij} \times W_{zy}) -
\sum_{i}^{I} \sum_{j}^{I} \sum_{z}^{Z} \sum_{y}^{Z}
(p \times X_{iz} \times X_{jy} \times D_{ij} \times W_{zy})</code>
</p>

<p>Otherwise, if the argument to <code>data</code> is supplied as an
<code>array</code> object, then the penalties are
calculated as:
</p>
<p style="text-align: center;"><code class="reqn">
\sum_{i}^{I} \sum_{j}^{I} \sum_{z}^{Z} \sum_{y}^{Z}
(p \times X_{iz} \times D_{ijzy}) -
\sum_{i}^{I} \sum_{j}^{I} \sum_{z}^{Z} \sum_{y}^{Z}
(p \times X_{iz} \times X_{jy} \times D_{ijzy})</code>
</p>

<p>Note that when the problem objective is to maximize some measure of
benefit and not minimize some measure of cost, the term <code class="reqn">p</code> is
replaced with <code class="reqn">-p</code>.
</p>


<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using several different formats.
</p>

<dl>
<dt><code>data</code> as a <code>matrix</code>/<code>Matrix</code> object</dt><dd><p>where rows and columns represent
different planning units and the value of each cell represents the
strength of connectivity between two different planning units. Cells
that occur along the matrix diagonal are treated as weights which
indicate that planning units are more desirable in the solution.
The argument to <code>zones</code> can be used to control
the strength of connectivity between planning units in different zones.
The default argument for <code>zones</code> is to treat planning units
allocated to different zones as having zero connectivity.</p>
</dd>
<dt><code>data</code> as a <code>data.frame</code> object</dt><dd><p>containing columns that are named
<code>"id1"</code>, <code>"id2"</code>, and <code>"boundary"</code>. Here, each row
denotes the connectivity between a pair of planning units
(per values in the <code>"id1"</code> and <code>"id2"</code> columns) following the
<em>Marxan</em> format.
If the argument to <code>x</code> contains multiple zones, then the
<code>"zone1"</code> and <code>"zone2"</code> columns can optionally be provided to manually
specify the connectivity values between planning units when they are
allocated to specific zones. If the <code>"zone1"</code> and
<code>"zone2"</code> columns are present, then the argument to <code>zones</code> must be
<code>NULL</code>.</p>
</dd>
<dt><code>data</code> as an <code>array</code> object</dt><dd>
<p>containing four-dimensions where cell values
indicate the strength of connectivity between planning units
when they are assigned to specific management zones. The first two
dimensions (i.e., rows and columns) indicate the strength of
connectivity between different planning units and the second two
dimensions indicate the different management zones. Thus
the <code>data[1, 2, 3, 4]</code> indicates the strength of
connectivity between planning unit 1 and planning unit 2 when planning
unit 1 is assigned to zone 3 and planning unit 2 is assigned to zone 4.</p>
</dd>
</dl>



<h3>References</h3>

<p>Beger M, Linke S, Watts M, Game E, Treml E, Ball I, and Possingham, HP (2010)
Incorporating asymmetric connectivity into spatial decision making for
conservation, <em>Conservation Letters</em>, 3: 359&ndash;368.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+penalties">penalties</a> for an overview of all functions for adding penalties.
</p>
<p>Other penalties: 
<code><a href="#topic+add_boundary_penalties">add_boundary_penalties</a>()</code>,
<code><a href="#topic+add_connectivity_penalties">add_connectivity_penalties</a>()</code>,
<code><a href="#topic+add_feature_weights">add_feature_weights</a>()</code>,
<code><a href="#topic+add_linear_penalties">add_linear_penalties</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load package
library(Matrix)

# set seed for reproducibility
set.seed(600)

# load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create basic problem
p1 &lt;-
  problem(sim_pu_polygons, sim_features, "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_default_solver(verbose = FALSE)

# create an asymmetric connectivity matrix. Here, connectivity occurs between
# adjacent planning units and, due to rivers flowing southwards
# through the study area, connectivity from northern planning units to
# southern planning units is ten times stronger than the reverse.
acm1 &lt;- matrix(0, nrow(sim_pu_polygons), nrow(sim_pu_polygons))
acm1 &lt;- as(acm1, "Matrix")
centroids &lt;- sf::st_coordinates(
  suppressWarnings(sf::st_centroid(sim_pu_polygons))
)
adjacent_units &lt;- sf::st_intersects(sim_pu_polygons, sparse = FALSE)
for (i in seq_len(nrow(sim_pu_polygons))) {
  for (j in seq_len(nrow(sim_pu_polygons))) {
    # find if planning units are adjacent
    if (adjacent_units[i, j]) {
      # find if planning units lay north and south of each other
      # i.e., they have the same x-coordinate
      if (centroids[i, 1] == centroids[j, 1]) {
        if (centroids[i, 2] &gt; centroids[j, 2]) {
          # if i is north of j add 10 units of connectivity
          acm1[i, j] &lt;- acm1[i, j] + 10
        } else if (centroids[i, 2] &lt; centroids[j, 2]) {
          # if i is south of j add 1 unit of connectivity
          acm1[i, j] &lt;- acm1[i, j] + 1
        }
      }
    }
  }
}

# rescale matrix values to have a maximum value of 1
acm1 &lt;- rescale_matrix(acm1, max = 1)

# visualize asymmetric connectivity matrix
image(acm1)

# create penalties
penalties &lt;- c(1, 50)

# create problems using the different penalties
p2 &lt;- list(
  p1,
  p1 %&gt;% add_asym_connectivity_penalties(penalties[1], data = acm1),
  p1 %&gt;% add_asym_connectivity_penalties(penalties[2], data = acm1)
)

# solve problems
s2 &lt;- lapply(p2, solve)

# create object with all solutions
s2 &lt;- sf::st_sf(
  tibble::tibble(
    p2_1 = s2[[1]]$solution_1,
    p2_2 = s2[[2]]$solution_1,
    p2_3 = s2[[3]]$solution_1
 ),
 geometry = sf::st_geometry(s2[[1]])
)

names(s2)[1:3] &lt;- c("basic problem", paste0("acm1 (", penalties,")"))

# plot solutions based on different penalty values
plot(s2, cex = 1.5)

# create minimal multi-zone problem and limit solver to one minute
# to obtain solutions in a short period of time
p3 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(0.15, nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(time_limit = 60, verbose = FALSE)

# crate asymmetric connectivity data by randomly simulating values
acm2 &lt;- matrix(
  runif(ncell(sim_zones_pu_raster) ^ 2),
  nrow = ncell(sim_zones_pu_raster)
)

# create multi-zone problems using the penalties
p4 &lt;- list(
  p3,
  p3 %&gt;% add_asym_connectivity_penalties(penalties[1], data = acm2),
  p3 %&gt;% add_asym_connectivity_penalties(penalties[2], data = acm2)
)

# solve problems
s4 &lt;- lapply(p4, solve)
s4 &lt;- lapply(s4, category_layer)
s4 &lt;- terra::rast(s4)
names(s4) &lt;- c("basic problem", paste0("acm2 (", penalties,")"))

# plot solutions
plot(s4, axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='add_binary_decisions'>Add binary decisions</h2><span id='topic+add_binary_decisions'></span>

<h3>Description</h3>

<p>Add a binary decision to a conservation planning problem.
This is the classic decision of either prioritizing or not prioritizing a
planning unit. Typically, this decision has the assumed action of buying
the planning unit to include in a protected area network. If no decision is
added to a problem then this decision class will be used by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_binary_decisions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_binary_decisions_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conservation planning problems involve making decisions on planning
units. These decisions are then associated with actions (e.g., turning a
planning unit into a protected area). Only a
single decision should be added to a <code><a href="#topic+problem">problem()</a></code> object.
Note that if multiple decisions are added to an object, then the
last one to be added will be used.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the decisions added to it.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+decisions">decisions</a> for an overview of all functions for adding decisions.
</p>
<p>Other decisions: 
<code><a href="#topic+add_proportion_decisions">add_proportion_decisions</a>()</code>,
<code><a href="#topic+add_semicontinuous_decisions">add_semicontinuous_decisions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem with binary decisions
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# create a matrix with targets for a multi-zone conservation problem
targs &lt;- matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)

# build multi-zone conservation problem with binary decisions
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(targs)  %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s2 &lt;- solve(p2)

# print solution
print(s2)

# plot solution
plot(category_layer(s2), main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_boundary_penalties'>Add boundary penalties</h2><span id='topic+add_boundary_penalties'></span><span id='topic+add_boundary_penalties+2CConservationProblem+2CANY+2CANY+2CANY+2Carray-method'></span><span id='topic+add_boundary_penalties+2CConservationProblem+2CANY+2CANY+2CANY+2Cmatrix-method'></span><span id='topic+add_boundary_penalties+2CConservationProblem+2CANY+2CANY+2CANY+2Cdata.frame-method'></span><span id='topic+add_boundary_penalties+2CConservationProblem+2CANY+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Add penalties to a conservation planning problem to favor solutions
that spatially clump planning units together based on the overall
boundary length (i.e., total perimeter).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConservationProblem,ANY,ANY,ANY,data.frame'
add_boundary_penalties(x, penalty, edge_factor, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,ANY,matrix'
add_boundary_penalties(x, penalty, edge_factor, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,ANY,ANY'
add_boundary_penalties(x, penalty, edge_factor, zones, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_boundary_penalties_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_boundary_penalties_+3A_penalty">penalty</code></td>
<td>
<p><code>numeric</code> penalty that is used to scale the importance
of selecting planning units that are spatially clumped together compared
to the main problem objective (e.g., solution cost when the argument to
<code>x</code> has a minimum set objective per <code><a href="#topic+add_min_set_objective">add_min_set_objective()</a></code>).
Higher <code>penalty</code> values prefer solutions with a higher degree of spatial
clumping, and smaller <code>penalty</code> values prefer solutions with a smaller
degree of clumping. Note that negative <code>penalty</code> values prefer
solutions that are more spread out. This parameter is equivalent to
the boundary length modifier (BLM)
parameter in <a href="https://marxansolutions.org/"><em>Marxan</em></a>.</p>
</td></tr>
<tr><td><code id="add_boundary_penalties_+3A_edge_factor">edge_factor</code></td>
<td>
<p><code>numeric</code> proportion to scale
planning unit edges (borders) that do not have any neighboring planning
units. For example, an edge factor of <code>0.5</code> is commonly used to
avoid overly penalizing planning units along a coastline.
Note that this argument must have an element for each zone in the argument
to <code>x</code>.</p>
</td></tr>
<tr><td><code id="add_boundary_penalties_+3A_zones">zones</code></td>
<td>
<p><code>matrix</code> or <code>Matrix</code> object describing the
clumping scheme for different zones. Each row and column corresponds to a
different zone in the argument to <code>x</code>, and cell values indicate the
relative importance of clumping planning units that are allocated to
a combination of zones. Cell values along the diagonal of the matrix
represent the relative importance of clumping planning units that are
allocated to the same zone. Cell values must range between 1 and -1, where
negative values favor solutions that spread out planning units. The default
argument to <code>zones</code> is an identity
matrix (i.e., a matrix with ones along the matrix diagonal and zeros
elsewhere), so that penalties are incurred when neighboring planning units
are not assigned to the same zone. If the cells along
the matrix diagonal contain markedly smaller values than those found
elsewhere in the matrix, then solutions are preferred that surround
planning units with those allocated to different zones
(i.e., greater spatial fragmentation).</p>
</td></tr>
<tr><td><code id="add_boundary_penalties_+3A_data">data</code></td>
<td>
<p><code>NULL</code>, <code>data.frame</code>, <code>matrix</code>, or <code>Matrix</code>
object containing the boundary data. These data describe the total
amount of boundary (perimeter) length  for each planning unit,
and the amount of boundary (perimeter) length shared between different
planning units (i.e., planning units that are adjacent to each other).
See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds penalties to a conservation planning problem
to penalize fragmented solutions. It was is inspired by Ball <em>et al.</em>
(2009) and Beyer <em>et al.</em> (2016). The <code>penalty</code> argument is
equivalent to the boundary length modifier (<code>BLM</code>) used in
<a href="https://marxansolutions.org"><em>Marxan</em></a>.
Note that this function can only
be used to represent symmetric relationships between planning units. If
asymmetric relationships are required, use the
<code><a href="#topic+add_connectivity_penalties">add_connectivity_penalties()</a></code> function.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the penalties added to it.
</p>


<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using the following formats.
Note that boundary data must always describe symmetric relationships
between planning units.
</p>

<dl>
<dt><code>data</code> as a <code>NULL</code> value</dt><dd><p>indicating that the data should be
automatically calculated using the <code><a href="#topic+boundary_matrix">boundary_matrix()</a></code> function.
This argument is the default.
Note that the boundary data must be supplied
using one of the other formats below if the planning unit data
in the argument to <code>x</code> do not explicitly contain spatial information
(e.g., planning unit data are a <code>data.frame</code> or <code>numeric</code> class).</p>
</dd>
<dt><code>data</code> as a <code>matrix</code>/<code>Matrix</code> object</dt><dd><p>where rows and columns represent
different planning units and the value of each cell represents the
amount of shared boundary length between two different planning units.
Cells that occur along the matrix diagonal denote the total
boundary length associated with each planning unit.</p>
</dd>
<dt><code>data</code> as a <code>data.frame</code> object</dt><dd><p>with the columns <code>"id1"</code>,
<code>"id2"</code>, and <code>"boundary"</code>. The <code>"id1"</code> and <code>"id2"</code> columns contain
identifiers (indices) for a pair of planning units, and the <code>"boundary"</code>
column contains the amount of shared boundary length between these
two planning units.
Additionally, if the values in the <code>"id1"</code> and <code>"id2"</code> columns
contain the same values, then the value denotes the
amount of exposed boundary length (not total boundary).
This format follows the the standard <em>Marxan</em> format for boundary
data (i.e., per the &quot;bound.dat&quot; file).</p>
</dd>
</dl>



<h3>Mathematical formulation</h3>

<p>The boundary penalties are implemented using the following equations. Let
<code class="reqn">I</code> represent the set of planning units
(indexed by <code class="reqn">i</code> or <code class="reqn">j</code>), <code class="reqn">Z</code> represent
the set of management zones (indexed by <code class="reqn">z</code> or <code class="reqn">y</code>), and
<code class="reqn">X_{iz}</code> represent the decision
variable for planning unit <code class="reqn">i</code> for in zone <code class="reqn">z</code> (e.g., with binary
values one indicating if planning unit is allocated or not). Also, let
<code class="reqn">p</code> represent the argument to <code>penalty</code>, <code class="reqn">E_z</code> represent the
argument to <code>edge_factor</code>, <code class="reqn">B_{ij}</code> represent the matrix argument
to <code>data</code> (e.g., generated using <code><a href="#topic+boundary_matrix">boundary_matrix()</a></code>), and
<code class="reqn">W_{zz}</code> represent the matrix argument to <code>zones</code>.
</p>
<p style="text-align: center;"><code class="reqn">
\sum_{i}^{I} \sum_{z}^{Z} (p \times W_{zz} B_{ii}) +
\sum_{i}^{I} \sum_{j}^{I} \sum_{z}^{Z}
\sum_{y}^{Z} (-2 \times p \times X_{iz} \times X_{jy} \times W_{zy} \times
B_{ij})</code>
</p>

<p>Note that when the problem objective is to maximize some measure of
benefit and not minimize some measure of cost, the term <code class="reqn">p</code> is
replaced with <code class="reqn">-p</code>.
</p>


<h3>References</h3>

<p>Ball IR, Possingham HP, and Watts M (2009) <em>Marxan and relatives:
Software for spatial conservation prioritisation</em> in Spatial conservation
prioritisation: Quantitative methods and computational tools. Eds Moilanen
A, Wilson KA, and Possingham HP. Oxford University Press, Oxford, UK.
</p>
<p>Beyer HL, Dujardin Y, Watts ME, and Possingham HP (2016) Solving
conservation planning problems with integer linear programming.
<em>Ecological Modelling</em>, 228: 14&ndash;22.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+penalties">penalties</a> for an overview of all functions for adding penalties.
</p>
<p>Other penalties: 
<code><a href="#topic+add_asym_connectivity_penalties">add_asym_connectivity_penalties</a>()</code>,
<code><a href="#topic+add_connectivity_penalties">add_connectivity_penalties</a>()</code>,
<code><a href="#topic+add_feature_weights">add_feature_weights</a>()</code>,
<code><a href="#topic+add_linear_penalties">add_linear_penalties</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with low boundary penalties
p2 &lt;- p1 %&gt;% add_boundary_penalties(50, 1)

# create problem with high boundary penalties but outer edges receive
# half the penalty as inner edges
p3 &lt;- p1 %&gt;% add_boundary_penalties(500, 0.5)

# create a problem using precomputed boundary data
bmat &lt;- boundary_matrix(sim_pu_raster)
p4 &lt;- p1 %&gt;% add_boundary_penalties(50, 1, data = bmat)

# solve problems
s1 &lt;- c(solve(p1), solve(p2), solve(p3), solve(p4))
names(s1) &lt;- c("basic solution", "small penalties", "high penalties",
  "precomputed data"
)

# plot solutions
plot(s1, axes = FALSE)

# create minimal problem with multiple zones and limit the run-time for
# solver to 10 seconds so this example doesn't take too long
p5 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(0.2, nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(time_limit = 10, verbose = FALSE)

# create zone matrix which favors clumping planning units that are
# allocated to the same zone together - note that this is the default
zm6 &lt;- diag(3)
print(zm6)

# create problem with the zone matrix and low penalties
p6 &lt;- p5 %&gt;% add_boundary_penalties(50, zone = zm6)

# create another problem with the same zone matrix and higher penalties
p7 &lt;- p5 %&gt;% add_boundary_penalties(500, zone = zm6)

# create zone matrix which favors clumping units that are allocated to
# different zones together
zm8 &lt;- matrix(1, ncol = 3, nrow = 3)
diag(zm8) &lt;- 0
print(zm8)

# create problem with the zone matrix
p8 &lt;- p5 %&gt;% add_boundary_penalties(500, zone = zm8)

# create zone matrix which strongly favors clumping units
# that are allocated to the same zone together. It will also prefer
# clumping planning units in zones 1 and 2 together over having
# these planning units with no neighbors in the solution
zm9 &lt;- diag(3)
zm9[upper.tri(zm9)] &lt;- c(0.3, 0, 0)
zm9[lower.tri(zm9)] &lt;- zm9[upper.tri(zm9)]
print(zm9)

# create problem with the zone matrix
p9 &lt;- p5 %&gt;% add_boundary_penalties(500, zone = zm9)

# create zone matrix which favors clumping planning units in zones 1 and 2
# together, and favors planning units in zone 3 being spread out
# (i.e., negative clumping)
zm10 &lt;- diag(3)
zm10[3, 3] &lt;- -1
print(zm10)

# create problem with the zone matrix
p10 &lt;- p5 %&gt;% add_boundary_penalties(500, zone = zm10)

# solve problems
s2 &lt;- list(solve(p5), solve(p6), solve(p7), solve(p8), solve(p9), solve(p10))

#convert to category layers for visualization
s2 &lt;- terra::rast(lapply(s2, category_layer))
names(s2) &lt;- c(
  "basic solution", "within zone clumping (low)",
  "within zone clumping (high)", "between zone clumping",
  "within + between clumping", "negative clumping"
)

# plot solutions
plot(s2, axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='add_cbc_solver'>Add a <em>CBC</em> solver</h2><span id='topic+add_cbc_solver'></span>

<h3>Description</h3>

<p>Specify that the <a href="https://github.com/coin-or/Cbc"><em>CBC</em></a>
(COIN-OR branch and cut) software should be used to solve a conservation
planning problem (Forrest &amp; Lougee-Heimer 2005).
This function can also be used to customize the behavior of the solver.
It requires the <span class="pkg">rcbc</span> package to be installed
(only <a href="https://github.com/dirkschumacher/rcbc">available on GitHub</a>,
see below for installation instructions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_cbc_solver(
  x,
  gap = 0.1,
  time_limit = .Machine$integer.max,
  presolve = TRUE,
  threads = 1,
  first_feasible = FALSE,
  start_solution = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_cbc_solver_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_cbc_solver_+3A_gap">gap</code></td>
<td>
<p><code>numeric</code> gap to optimality. This gap is relative
and expresses the acceptable deviance from the optimal objective.
For example, a value of 0.01 will result in the solver stopping when
it has found a solution within 1% of optimality.
Additionally, a value of 0 will result in the solver stopping
when it has found an optimal solution.
The default value is 0.1 (i.e., 10% from optimality).</p>
</td></tr>
<tr><td><code id="add_cbc_solver_+3A_time_limit">time_limit</code></td>
<td>
<p><code>numeric</code> time limit (seconds) for generating solutions.
The solver will return the current best solution when this time limit is
exceeded. The default value is the largest integer value
(i.e., <code>.Machine$integer.max</code>), effectively meaning that solver
will keep running until a solution within the optimality gap is found.</p>
</td></tr>
<tr><td><code id="add_cbc_solver_+3A_presolve">presolve</code></td>
<td>
<p><code>logical</code> attempt to simplify the
problem before solving it? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_cbc_solver_+3A_threads">threads</code></td>
<td>
<p><code>integer</code> number of threads to use for the
optimization algorithm. The default value is 1.</p>
</td></tr>
<tr><td><code id="add_cbc_solver_+3A_first_feasible">first_feasible</code></td>
<td>
<p><code>logical</code> should the first feasible solution be
be returned? If <code>first_feasible</code> is set to <code>TRUE</code>, the solver
will return the first solution it encounters that meets all the
constraints, regardless of solution quality. Note that the first feasible
solution is not an arbitrary solution, rather it is derived from the
relaxed solution, and is therefore often reasonably close to optimality.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_cbc_solver_+3A_start_solution">start_solution</code></td>
<td>
<p><code>NULL</code> or object containing the starting solution
for the solver. This is can be useful because specifying a starting
solution can speed up the optimization process.
Defaults to <code>NULL</code> such that no starting solution is used.
To specify a starting solution, the argument to <code>start_solution</code> should
be in the same format as the planning units (i.e., a <code>NULL</code>, <code>numeric</code>,
<code>matrix</code>, <code>data.frame</code>, <code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object).
See the Start solution format section for more information.</p>
</td></tr>
<tr><td><code id="add_cbc_solver_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> should information be printed while solving
optimization problems? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://github.com/coin-or/Cbc"><em>CBC</em></a> is an
open-source mixed integer programming solver that is part of the
Computational Infrastructure for Operations Research (COIN-OR) project.
This solver seems to have much better performance than the other open-source
solvers (i.e., <code><a href="#topic+add_highs_solver">add_highs_solver()</a></code>, <code><a href="#topic+add_rsymphony_solver">add_rsymphony_solver()</a></code>,
<code><a href="#topic+add_lpsymphony_solver">add_lpsymphony_solver()</a></code>)
(see the <em>Solver benchmarks</em> vignette for details).
As such, it is strongly recommended to use this solver if the <em>Gurobi</em> and
<em>IBM CPLEX</em> solvers are not available.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the solver added to it.
</p>


<h3>Installation</h3>

<p>The <span class="pkg">rcbc</span> package is required to use this solver. Since the
<span class="pkg">rcbc</span> package is not available on the
the Comprehensive R Archive Network (CRAN), it must be installed from
<a href="https://github.com/dirkschumacher/rcbc">its GitHub repository</a>. To
install the <span class="pkg">rcbc</span> package, please use the following code:
</p>
<div class="sourceCode"><pre>if (!require(remotes)) install.packages("remotes")
remotes::install_github("dirkschumacher/rcbc")
</pre></div>
<p>Note that you may also need to install several dependencies &ndash;
such as the
<a href="https://cran.r-project.org/bin/windows/Rtools/">Rtools software</a>
or system libraries &ndash; prior to installing the <span class="pkg">rcbc</span> package.
For further details on installing this package, please consult the
<a href="https://dirkschumacher.github.io/rcbc/">online package documentation</a>.
</p>


<h3>Start solution format</h3>

<p>Broadly speaking, the argument to <code>start_solution</code> must be in the same
format as the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt><code>x</code> has <code>numeric</code> planning units</dt><dd><p>The argument to <code>start_solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>start_solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>matrix</code> planning units</dt><dd><p>The argument to <code>start_solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>start_solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The argument to <code>start_solution</code>
be a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>start_solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>data.frame</code> planning units</dt><dd><p>The argument to <code>start_solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code><a href="sf.html#topic+sf">sf::sf()</a></code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>start_solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code> planning units</dt><dd><p>The argument to <code>start_solution</code> must be
a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>start_solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>start_solution</code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Forrest J and Lougee-Heimer R (2005) CBC User Guide. In Emerging theory,
Methods, and Applications (pp. 257&ndash;277). INFORMS, Catonsville, MD.
<a href="https://doi.org/10.1287/educ.1053.0020">doi:10.1287/educ.1053.0020</a>.
</p>


<h3>See Also</h3>

<p>Other solvers: 
<code><a href="#topic+add_cplex_solver">add_cplex_solver</a>()</code>,
<code><a href="#topic+add_default_solver">add_default_solver</a>()</code>,
<code><a href="#topic+add_gurobi_solver">add_gurobi_solver</a>()</code>,
<code><a href="#topic+add_highs_solver">add_highs_solver</a>()</code>,
<code><a href="#topic+add_lsymphony_solver">add_lsymphony_solver</a></code>,
<code><a href="#topic+add_rsymphony_solver">add_rsymphony_solver</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create problem
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_cbc_solver(gap = 0, verbose = FALSE)

# generate solution %&gt;%
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# create a similar problem with boundary length penalties and
# specify the solution from the previous run as a starting solution
p2 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_boundary_penalties(10) %&gt;%
  add_binary_decisions() %&gt;%
  add_cbc_solver(gap = 0, start_solution = s1, verbose = FALSE)

# generate solution
s2 &lt;- solve(p2)

# plot solution
plot(s2, main = "solution with boundary penalties", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_connectivity_penalties'>Add connectivity penalties</h2><span id='topic+add_connectivity_penalties'></span><span id='topic+add_connectivity_penalties+2CConservationProblem+2CANY+2CANY+2CMatrix-method'></span><span id='topic+add_connectivity_penalties+2CConservationProblem+2CANY+2CANY+2Cmatrix-method'></span><span id='topic+add_connectivity_penalties+2CConservationProblem+2CANY+2CANY+2CdgCMatrix-method'></span><span id='topic+add_connectivity_penalties+2CConservationProblem+2CANY+2CANY+2Cdata.frame-method'></span><span id='topic+add_connectivity_penalties+2CConservationProblem+2CANY+2CANY+2Carray-method'></span>

<h3>Description</h3>

<p>Add penalties to a conservation planning problem to account for
symmetric connectivity between planning units.
Symmetric connectivity data describe connectivity information that is not
directional. For example, symmetric connectivity data could describe which
planning units are adjacent to each other (see <code><a href="#topic+adjacency_matrix">adjacency_matrix()</a></code>),
or which planning units are within threshold distance of each other (see
<code><a href="#topic+proximity_matrix">proximity_matrix()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConservationProblem,ANY,ANY,matrix'
add_connectivity_penalties(x, penalty, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,Matrix'
add_connectivity_penalties(x, penalty, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,data.frame'
add_connectivity_penalties(x, penalty, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,dgCMatrix'
add_connectivity_penalties(x, penalty, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,array'
add_connectivity_penalties(x, penalty, zones, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_connectivity_penalties_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_connectivity_penalties_+3A_penalty">penalty</code></td>
<td>
<p><code>numeric</code> penalty that is used to scale the importance
of selecting planning units with strong connectivity between them compared
to the main problem objective (e.g., solution cost when the argument to
<code>x</code> has a minimum set objective set using
<code><a href="#topic+add_min_set_objective">add_min_set_objective()</a></code>). Higher <code>penalty</code> values
can be used to obtain solutions with a high degree of connectivity,
and smaller <code>penalty</code> values can be used to obtain solutions with a
small degree of connectivity. Note that negative <code>penalty</code> values can
be used to obtain solutions that have very little connectivity.</p>
</td></tr>
<tr><td><code id="add_connectivity_penalties_+3A_zones">zones</code></td>
<td>
<p><code>matrix</code> or <code>Matrix</code> object describing the
level of connectivity between different zones. Each row and column
corresponds to a different zone in the argument to <code>x</code>, and cell
values indicate the level of connectivity between each combination
of zones. Cell values along the diagonal of the matrix represent
the level of connectivity between planning units allocated to the
same zone. Cell values must lay between 1 and -1, where negative
values favor solutions with weak connectivity. The default argument to
<code>zones</code> is an identity matrix (i.e., a matrix with ones along the
matrix diagonal and zeros elsewhere), so that planning units are
only considered to be connected when they are allocated to the same zone.
This argument is required when working with multiple zones and the
argument to <code>data</code> is a <code>matrix</code> or <code>Matrix</code> object.
If the argument to <code>data</code> is an <code>array</code> or <code>data.frame</code> with data for
multiple zones (e.g., using the <code>"zone1"</code> and <code>"zone2"</code> column names),
this argument must explicitly be set to <code>NULL</code> otherwise an error will be
thrown.</p>
</td></tr>
<tr><td><code id="add_connectivity_penalties_+3A_data">data</code></td>
<td>
<p><code>matrix</code>, <code>Matrix</code>, <code>data.frame</code>, or
<code>array</code> object containing connectivity data. The connectivity values
correspond to the strength of connectivity between
different planning units. Thus connections between planning units
that are associated with higher values are more favorable in the solution.
See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds penalties to conservation planning problem to penalize
solutions that have low connectivity.
Specifically, it favors pair-wise connections between planning units
that have high connectivity values (based on Önal and Briers 2002).
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the penalties added to it.
</p>


<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using several different formats.
</p>

<dl>
<dt><code>data</code> as a <code>matrix</code>/<code>Matrix</code> object</dt><dd><p>where rows and columns represent
different planning units and the value of each cell represents the
strength of connectivity between two different planning units. Cells
that occur along the matrix diagonal are treated as weights which
indicate that planning units are more desirable in the solution.
The argument to <code>zones</code> can be used to control
the strength of connectivity between planning units in different zones.
The default argument for <code>zones</code> is to treat planning units
allocated to different zones as having zero connectivity.</p>
</dd>
<dt><code>data</code> as a <code>data.frame</code> object</dt><dd><p>containing columns that are named
<code>"id1"</code>, <code>"id2"</code>, and <code>"boundary"</code>. Here, each row
denotes the connectivity between a pair of planning units
(per values in the <code>"id1"</code> and <code>"id2"</code> columns) following the
<em>Marxan</em> format.
If the argument to <code>x</code> contains multiple zones, then the
<code>"zone1"</code> and <code>"zone2"</code> columns can optionally be provided to manually
specify the connectivity values between planning units when they are
allocated to specific zones. If the <code>"zone1"</code> and
<code>"zone2"</code> columns are present, then the argument to <code>zones</code> must be
<code>NULL</code>.</p>
</dd>
<dt><code>data</code> as an <code>array</code> object</dt><dd>
<p>containing four-dimensions where cell values
indicate the strength of connectivity between planning units
when they are assigned to specific management zones. The first two
dimensions (i.e., rows and columns) indicate the strength of
connectivity between different planning units and the second two
dimensions indicate the different management zones. Thus
the <code>data[1, 2, 3, 4]</code> indicates the strength of
connectivity between planning unit 1 and planning unit 2 when planning
unit 1 is assigned to zone 3 and planning unit 2 is assigned to zone 4.</p>
</dd>
</dl>



<h3>Mathematical formulation</h3>

<p>The connectivity penalties are implemented using the following equations.
Let <code class="reqn">I</code> represent the set of planning units
(indexed by <code class="reqn">i</code> or <code class="reqn">j</code>), <code class="reqn">Z</code> represent the set
of management zones (indexed by <code class="reqn">z</code> or <code class="reqn">y</code>), and <code class="reqn">X_{iz}</code>
represent the decision variable for planning unit <code class="reqn">i</code> for in zone
<code class="reqn">z</code> (e.g., with binary
values one indicating if planning unit is allocated or not). Also, let
<code class="reqn">p</code> represent the argument to <code>penalty</code>, <code class="reqn">D</code> represent the
argument to <code>data</code>, and <code class="reqn">W</code> represent the argument
to <code>zones</code>.
</p>
<p>If the argument to <code>data</code> is supplied as a <code>matrix</code> or
<code>Matrix</code> object, then the penalties are calculated as:
</p>
<p style="text-align: center;"><code class="reqn">
\sum_{i}^{I} \sum_{j}^{I} \sum_{z}^{Z} \sum_{y}^{Z} (-p \times X_{iz}
\times X_{jy} \times D_{ij} \times W_{zy})</code>
</p>

<p>Otherwise, if the argument to <code>data</code> is supplied as a
<code>data.frame</code> or <code>array</code> object, then the penalties are
calculated as:
</p>
<p style="text-align: center;"><code class="reqn">
\sum_{i}^{I} \sum_{j}^{I} \sum_{z}^{Z} \sum_{y}^{Z} (-p \times X_{iz}
\times X_{jy} \times D_{ijzy})</code>
</p>

<p>Note that when the problem objective is to maximize some measure of
benefit and not minimize some measure of cost, the term <code class="reqn">-p</code> is
replaced with <code class="reqn">p</code>.
</p>


<h3>Notes</h3>

<p>In previous versions, this function aimed to handle both symmetric and
asymmetric connectivity data. This meant that the mathematical
formulation used to account for asymmetric connectivity was different
to that implemented by the <em>Marxan</em> software
(see Beger <em>et al.</em> for details). To ensure that asymmetric connectivity is
handled in a similar manner to the <em>Marxan</em> software, the
<code><a href="#topic+add_asym_connectivity_penalties">add_asym_connectivity_penalties()</a></code> function should now be used for
asymmetric connectivity data.
</p>


<h3>References</h3>

<p>Beger M, Linke S, Watts M, Game E, Treml E, Ball I, and Possingham, HP (2010)
Incorporating asymmetric connectivity into spatial decision making for
conservation, <em>Conservation Letters</em>, 3: 359&ndash;368.
</p>
<p>Önal H, and Briers RA (2002) Incorporating spatial criteria in optimum
reserve network selection. <em>Proceedings of the Royal Society of London.</em>
<em>Series B: Biological Sciences</em>, 269: 2437&ndash;2441.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+penalties">penalties</a> for an overview of all functions for adding penalties.
Additionally, see <code><a href="#topic+add_asym_connectivity_penalties">add_asym_connectivity_penalties()</a></code> to account for
asymmetric connectivity between planning units.
</p>
<p>Other penalties: 
<code><a href="#topic+add_asym_connectivity_penalties">add_asym_connectivity_penalties</a>()</code>,
<code><a href="#topic+add_boundary_penalties">add_boundary_penalties</a>()</code>,
<code><a href="#topic+add_feature_weights">add_feature_weights</a>()</code>,
<code><a href="#topic+add_linear_penalties">add_linear_penalties</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load package
library(Matrix)

# set seed for reproducibility
set.seed(600)

# load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create basic problem
p1 &lt;-
  problem(sim_pu_polygons, sim_features, "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_default_solver(verbose = FALSE)

# create a symmetric connectivity matrix where the connectivity between
# two planning units corresponds to their shared boundary length
b_matrix &lt;- boundary_matrix(sim_pu_polygons)

# rescale matrix values to have a maximum value of 1
b_matrix &lt;- rescale_matrix(b_matrix, max = 1)

# visualize connectivity matrix
image(b_matrix)

# create a symmetric connectivity matrix where the connectivity between
# two planning units corresponds to their spatial proximity
# i.e., planning units that are further apart share less connectivity
centroids &lt;- sf::st_coordinates(
  suppressWarnings(sf::st_centroid(sim_pu_polygons))
)
d_matrix &lt;- (1 / (Matrix::Matrix(as.matrix(dist(centroids))) + 1))

# rescale matrix values to have a maximum value of 1
d_matrix &lt;- rescale_matrix(d_matrix, max = 1)

# remove connections between planning units with values below a threshold to
# reduce run-time
d_matrix[d_matrix &lt; 0.8] &lt;- 0

# visualize connectivity matrix
image(d_matrix)

# create a symmetric connectivity matrix where the connectivity
# between adjacent two planning units corresponds to their combined
# value in a column of the planning unit data

# for example, this column could describe the extent of native vegetation in
# each planning unit and we could use connectivity penalties to identify
# solutions that cluster planning units together that both contain large
# amounts of native vegetation

c_matrix &lt;- connectivity_matrix(sim_pu_polygons, "cost")

# rescale matrix values to have a maximum value of 1
c_matrix &lt;- rescale_matrix(c_matrix, max = 1)

# visualize connectivity matrix
image(c_matrix)

# create penalties
penalties &lt;- c(10, 25)

# create problems using the different connectivity matrices and penalties
p2 &lt;- list(
  p1,
  p1 %&gt;% add_connectivity_penalties(penalties[1], data = b_matrix),
  p1 %&gt;% add_connectivity_penalties(penalties[2], data = b_matrix),
  p1 %&gt;% add_connectivity_penalties(penalties[1], data = d_matrix),
  p1 %&gt;% add_connectivity_penalties(penalties[2], data = d_matrix),
  p1 %&gt;% add_connectivity_penalties(penalties[1], data = c_matrix),
  p1 %&gt;% add_connectivity_penalties(penalties[2], data = c_matrix)
)

# solve problems
s2 &lt;- lapply(p2, solve)

# create single object with all solutions
s2 &lt;- sf::st_sf(
  tibble::tibble(
    p2_1 = s2[[1]]$solution_1,
    p2_2 = s2[[2]]$solution_1,
    p2_3 = s2[[3]]$solution_1,
    p2_4 = s2[[4]]$solution_1,
    p2_5 = s2[[5]]$solution_1,
    p2_6 = s2[[6]]$solution_1,
    p2_7 = s2[[7]]$solution_1
  ),
  geometry = sf::st_geometry(s2[[1]])
)

names(s2)[1:7] &lt;- c(
  "basic problem",
  paste0("b_matrix (", penalties,")"),
  paste0("d_matrix (", penalties,")"),
  paste0("c_matrix (", penalties,")")
)

# plot solutions
plot(s2)

# create minimal multi-zone problem and limit solver to one minute
# to obtain solutions in a short period of time
p3 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(0.15, nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(time_limit = 60, verbose = FALSE)

# create matrix showing which planning units are adjacent to other units
a_matrix &lt;- adjacency_matrix(sim_zones_pu_raster)

# visualize matrix
image(a_matrix)

# create a zone matrix where connectivities are only present between
# planning units that are allocated to the same zone
zm1 &lt;- as(diag(3), "Matrix")

# print zone matrix
print(zm1)

# create a zone matrix where connectivities are strongest between
# planning units allocated to different zones
zm2 &lt;- matrix(1, ncol = 3, nrow = 3)
diag(zm2) &lt;- 0
zm2 &lt;- as(zm2, "Matrix")

# print zone matrix
print(zm2)

# create a zone matrix that indicates that connectivities between planning
# units assigned to the same zone are much higher than connectivities
# assigned to different zones
zm3 &lt;- matrix(0.1, ncol = 3, nrow = 3)
diag(zm3) &lt;- 1
zm3 &lt;- as(zm3, "Matrix")

# print zone matrix
print(zm3)

# create a zone matrix that indicates that connectivities between planning
# units allocated to zone 1 are very high, connectivities between planning
# units allocated to zones 1 and 2 are moderately high, and connectivities
# planning units allocated to other zones are low
zm4 &lt;- matrix(0.1, ncol = 3, nrow = 3)
zm4[1, 1] &lt;- 1
zm4[1, 2] &lt;- 0.5
zm4[2, 1] &lt;- 0.5
zm4 &lt;- as(zm4, "Matrix")

# print zone matrix
print(zm4)

# create a zone matrix with strong connectivities between planning units
# allocated to the same zone, moderate connectivities between planning
# unit allocated to zone 1 and zone 2, and negative connectivities between
# planning units allocated to zone 3 and the other two zones
zm5 &lt;- matrix(-1, ncol = 3, nrow = 3)
zm5[1, 2] &lt;- 0.5
zm5[2, 1] &lt;- 0.5
diag(zm5) &lt;- 1
zm5 &lt;- as(zm5, "Matrix")

# print zone matrix
print(zm5)

# create vector of penalties to use creating problems
penalties2 &lt;- c(5, 15)

# create multi-zone problems using the adjacent connectivity matrix and
# different zone matrices
p4 &lt;- list(
  p3,
  p3 %&gt;% add_connectivity_penalties(penalties2[1], zm1, a_matrix),
  p3 %&gt;% add_connectivity_penalties(penalties2[2], zm1, a_matrix),
  p3 %&gt;% add_connectivity_penalties(penalties2[1], zm2, a_matrix),
  p3 %&gt;% add_connectivity_penalties(penalties2[2], zm2, a_matrix),
  p3 %&gt;% add_connectivity_penalties(penalties2[1], zm3, a_matrix),
  p3 %&gt;% add_connectivity_penalties(penalties2[2], zm3, a_matrix),
  p3 %&gt;% add_connectivity_penalties(penalties2[1], zm4, a_matrix),
  p3 %&gt;% add_connectivity_penalties(penalties2[2], zm4, a_matrix),
  p3 %&gt;% add_connectivity_penalties(penalties2[1], zm5, a_matrix),
  p3 %&gt;% add_connectivity_penalties(penalties2[2], zm5, a_matrix)
)

# solve problems
s4 &lt;- lapply(p4, solve)
s4 &lt;- lapply(s4, category_layer)
s4 &lt;- terra::rast(s4)
names(s4) &lt;-  c(
  "basic problem",
  paste0("zm", rep(seq_len(5), each = 2), " (", rep(penalties2, 2), ")")
)

# plot solutions
plot(s4, axes = FALSE)

# create an array to manually specify the connectivities between
# each planning unit when they are allocated to each different zone

# for real-world problems, these connectivities would be generated using
# data - but here these connectivity values are assigned as random
# ones or zeros
c_array &lt;- array(0, c(rep(ncell(sim_zones_pu_raster[[1]]), 2), 3, 3))
for (z1 in seq_len(3))
  for (z2 in seq_len(3))
    c_array[, , z1, z2] &lt;- round(
      runif(ncell(sim_zones_pu_raster[[1]]) ^ 2, 0, 0.505)
    )

# create a problem with the manually specified connectivity array
# note that the zones argument is set to NULL because the connectivity
# data is an array
p5 &lt;- list(
  p3,
  p3 %&gt;% add_connectivity_penalties(15, zones = NULL, c_array)
)

# solve problems
s5 &lt;- lapply(p5, solve)
s5 &lt;- lapply(s5, category_layer)
s5 &lt;- terra::rast(s5)
names(s5) &lt;- c("basic problem", "connectivity array")

# plot solutions
plot(s5, axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_contiguity_constraints'>Add contiguity constraints</h2><span id='topic+add_contiguity_constraints'></span><span id='topic+add_contiguity_constraints+2CConservationProblem+2CANY+2Cmatrix-method'></span><span id='topic+add_contiguity_constraints+2CConservationProblem+2CANY+2Cdata.frame-method'></span><span id='topic+add_contiguity_constraints+2CConservationProblem+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Add constraints to a conservation planning problem to ensure
that all selected planning units are spatially connected with each other
and form a single contiguous unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConservationProblem,ANY,ANY'
add_contiguity_constraints(x, zones, data)

## S4 method for signature 'ConservationProblem,ANY,data.frame'
add_contiguity_constraints(x, zones, data)

## S4 method for signature 'ConservationProblem,ANY,matrix'
add_contiguity_constraints(x, zones, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_contiguity_constraints_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_contiguity_constraints_+3A_zones">zones</code></td>
<td>
<p><code>matrix</code> or <code>Matrix</code> object describing the
connection scheme for different zones. Each row and column corresponds
to a different zone in the argument to <code>x</code>, and cell values must
contain binary <code>numeric</code> values (i.e., one or zero) that indicate
if connected planning units (as specified in the argument to
<code>data</code>) should be still considered connected if they are allocated to
different zones. The cell values along the diagonal
of the matrix indicate if planning units should be subject to
contiguity constraints when they are allocated to a given zone. Note
arguments to <code>zones</code> must be symmetric, and that a row or column has
a value of one then the diagonal element for that row or column must also
have a value of one. The default argument to <code>zones</code> is an identity
matrix (i.e., a matrix with ones along the matrix diagonal and zeros
elsewhere), so that planning units are only considered connected if they
are both allocated to the same zone.</p>
</td></tr>
<tr><td><code id="add_contiguity_constraints_+3A_data">data</code></td>
<td>
<p><code>NULL</code>, <code>matrix</code>, <code>Matrix</code>, <code>data.frame</code>
object showing which planning units are connected with each
other. The argument defaults to <code>NULL</code> which means that the
connection data is calculated automatically using the
<code><a href="#topic+adjacency_matrix">adjacency_matrix()</a></code> function.
See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses connection data to identify solutions that
form a single contiguous unit. It was inspired by the
mathematical formulations detailed in Önal and Briers (2006).
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the constraints added to it.
</p>


<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using the following formats.
</p>

<dl>
<dt><code>data</code> as a <code>NULL</code> value</dt><dd><p>indicating that connection data should be
calculated automatically using the <code><a href="#topic+adjacency_matrix">adjacency_matrix()</a></code> function.
This is the default argument.
Note that the connection data must be manually defined
using one of the other formats below when the planning unit data
in the argument to <code>x</code> is not spatially referenced (e.g.,
in <code>data.frame</code> or <code>numeric</code> format).</p>
</dd>
<dt><code>data</code> as a <code>matrix</code>/<code>Matrix</code> object</dt><dd><p>where rows and columns represent
different planning units and the value of each cell indicates if the
two planning units are connected or not. Cell values should be binary
<code>numeric</code> values (i.e., one or zero). Cells that occur along the
matrix diagonal have no effect on the solution at all because each
planning unit cannot be a connected with itself.</p>
</dd>
<dt><code>data</code> as a <code>data.frame</code> object</dt><dd><p>containing columns that are named
<code>"id1"</code>, <code>"id2"</code>, and <code>"boundary"</code>. Here, each row
denotes the connectivity between two planning units following the
<em>Marxan</em> format. The <code>"boundary"</code> column should contain
binary <code>numeric</code> values that indicate if the two planning units
specified in the <code>"id1"</code> and <code>"id2"</code> columns are connected
or not. This data can be used to describe symmetric or
asymmetric relationships between planning units. By default,
input data is assumed to be symmetric unless asymmetric data is
also included (e.g., if data is present for planning units 2 and 3, then
the same amount of connectivity is expected for planning units 3 and 2,
unless connectivity data is also provided for planning units 3 and 2).</p>
</dd>
</dl>



<h3>Notes</h3>

<p>In early versions, this function was named as the
<code>add_connected_constraints()</code> function.
</p>


<h3>References</h3>

<p>Önal H and Briers RA (2006) Optimal selection of a connected
reserve network. <em>Operations Research</em>, 54: 379&ndash;388.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+constraints">constraints</a> for an overview of all functions for adding constraints.
</p>
<p>Other constraints: 
<code><a href="#topic+add_feature_contiguity_constraints">add_feature_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_linear_constraints">add_linear_constraints</a>()</code>,
<code><a href="#topic+add_locked_in_constraints">add_locked_in_constraints</a>()</code>,
<code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints</a>()</code>,
<code><a href="#topic+add_mandatory_allocation_constraints">add_mandatory_allocation_constraints</a>()</code>,
<code><a href="#topic+add_manual_bounded_constraints">add_manual_bounded_constraints</a>()</code>,
<code><a href="#topic+add_manual_locked_constraints">add_manual_locked_constraints</a>()</code>,
<code><a href="#topic+add_neighbor_constraints">add_neighbor_constraints</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with added connected constraints
p2 &lt;- p1 %&gt;% add_contiguity_constraints()

# solve problems
s1 &lt;- c(solve(p1), solve(p2))
names(s1) &lt;- c("basic solution", "connected solution")

# plot solutions
plot(s1, axes = FALSE)

# create minimal problem with multiple zones, and limit the solver to
# 30 seconds to obtain solutions in a feasible period of time
p3 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(0.2, ncol = 3, nrow = 5)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(time_limit = 30, verbose = FALSE)

# create problem with added constraints to ensure that the planning units
# allocated to each zone form a separate contiguous unit
z4 &lt;- diag(3)
print(z4)
p4 &lt;- p3 %&gt;% add_contiguity_constraints(z4)

# create problem with added constraints to ensure that the planning
# units allocated to each zone form a separate contiguous unit,
# except for planning units allocated to zone 3 which do not need
# form a single contiguous unit
z5 &lt;- diag(3)
z5[3, 3] &lt;- 0
print(z5)
p5 &lt;- p3 %&gt;% add_contiguity_constraints(z5)

# create problem with added constraints that ensure that the planning
# units allocated to zones 1 and 2 form a contiguous unit
z6 &lt;- diag(3)
z6[1, 2] &lt;- 1
z6[2, 1] &lt;- 1
print(z6)
p6 &lt;- p3 %&gt;% add_contiguity_constraints(z6)

# solve problems
s2 &lt;- lapply(list(p3, p4, p5, p6), solve)
s2 &lt;- lapply(s2, category_layer)
s2 &lt;- terra::rast(s2)
names(s2) &lt;- c("basic solution", "p4", "p5", "p6")

# plot solutions
plot(s2, axes = FALSE)

# create a problem that has a main "reserve zone" and a secondary
# "corridor zone" to connect up import areas. Here, each feature has a
# target of 50% of its distribution. If a planning unit is allocated to the
# "reserve zone", then the prioritization accrues 100% of the amount of
# each feature in the planning unit. If a planning unit is allocated to the
# "corridor zone" then the prioritization accrues 40% of the amount of each
# feature in the planning unit. Also, the cost of managing a planning unit
# in the "corridor zone" is 30% of that when it is managed as the
# "reserve zone". Finally, the problem has constraints which
# ensure that all of the selected planning units form a single contiguous
# unit, so that the planning units allocated to the "corridor zone" can
# link up the planning units allocated to the "reserve zone"

# create planning unit data
pus &lt;- sim_zones_pu_raster[[c(1, 1)]]
pus[[2]] &lt;- pus[[2]] * 0.3
print(pus)

# create biodiversity data
fts &lt;- zones(
  sim_features, sim_features * 0.4,
  feature_names = names(sim_features),
  zone_names = c("reserve zone", "corridor zone")
)
print(fts)

# create targets
targets &lt;- tibble::tibble(
  feature = names(sim_features),
  zone = list(zone_names(fts))[rep(1, 5)],
  target = terra::global(sim_features, "sum", na.rm = TRUE)[[1]] * 0.5,
  type = rep("absolute", 5)
)
print(targets)

# create zones matrix
z7 &lt;- matrix(1, ncol = 2, nrow = 2)
print(z7)

# create problem
p7 &lt;-
  problem(pus, fts) %&gt;%
  add_min_set_objective() %&gt;%
  add_manual_targets(targets) %&gt;%
  add_contiguity_constraints(z7) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problems
s7 &lt;- category_layer(solve(p7))

# plot solutions
plot(s7, main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_cplex_solver'>Add a <em>CPLEX</em> solver</h2><span id='topic+add_cplex_solver'></span>

<h3>Description</h3>

<p>Specify that the
<a href="https://www.ibm.com/products/ilog-cplex-optimization-studio/cplex-optimizer"><em>IBM CPLEX</em></a> software
should be used to solve a conservation planning problem (IBM 2017) .
This function can also be used to customize the behavior of the solver.
It requires the <span class="pkg">cplexAPI</span> package to be installed
(see below for installation instructions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_cplex_solver(
  x,
  gap = 0.1,
  time_limit = .Machine$integer.max,
  presolve = TRUE,
  threads = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_cplex_solver_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_cplex_solver_+3A_gap">gap</code></td>
<td>
<p><code>numeric</code> gap to optimality. This gap is relative
and expresses the acceptable deviance from the optimal objective.
For example, a value of 0.01 will result in the solver stopping when
it has found a solution within 1% of optimality.
Additionally, a value of 0 will result in the solver stopping
when it has found an optimal solution.
The default value is 0.1 (i.e., 10% from optimality).</p>
</td></tr>
<tr><td><code id="add_cplex_solver_+3A_time_limit">time_limit</code></td>
<td>
<p><code>numeric</code> time limit (seconds) for generating solutions.
The solver will return the current best solution when this time limit is
exceeded. The default value is the largest integer value
(i.e., <code>.Machine$integer.max</code>), effectively meaning that solver
will keep running until a solution within the optimality gap is found.</p>
</td></tr>
<tr><td><code id="add_cplex_solver_+3A_presolve">presolve</code></td>
<td>
<p><code>logical</code> attempt to simplify the
problem before solving it? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_cplex_solver_+3A_threads">threads</code></td>
<td>
<p><code>integer</code> number of threads to use for the
optimization algorithm. The default value is 1.</p>
</td></tr>
<tr><td><code id="add_cplex_solver_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> should information be printed while solving
optimization problems? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://www.ibm.com/products/ilog-cplex-optimization-studio/cplex-optimizer"><em>IBM CPLEX</em></a> is a
commercial optimization software. It is faster than
the available open source solvers (e.g., <code><a href="#topic+add_lpsymphony_solver">add_lpsymphony_solver()</a></code> and
<code><a href="#topic+add_rsymphony_solver">add_rsymphony_solver()</a></code>.
Although formal benchmarks examining the performance of this solver for
conservation planning problems have yet to be completed, preliminary
analyses suggest that it performs slightly slower than the <em>Gurobi</em>
solver (i.e., <code><a href="#topic+add_gurobi_solver">add_gurobi_solver()</a></code>).
We recommend using this solver if the <em>Gurobi</em> solver is not available.
Licenses are available for the <em>IBM CPLEX</em> software to academics at no cost
(see &lt;  https://www.ibm.com/products/ilog-cplex-optimization-studio/cplex-optimizer&gt;).
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the solver added to it.
</p>


<h3>Installation</h3>

<p>The <span class="pkg">cplexAPI</span> package is used to interface with <em>IBM CPLEX</em> software.
To install the package, the <em>IBM CPLEX</em> software must be installed
(see <a href="https://www.ibm.com/products/ilog-cplex-optimization-studio/cplex-optimizer">https://www.ibm.com/products/ilog-cplex-optimization-studio/cplex-optimizer</a>). Next, the <code>CPLEX_BIN</code>
environmental variable must be set to specify the file path for the
<em>IBM CPLEX</em> software. For example, on a Linux system,
this variable can be specified by adding the following text to the
<code style="white-space: pre;">&#8288;~/.bashrc&#8288;</code> file:
</p>
<div class="sourceCode"><pre>  export CPLEX_BIN="/opt/ibm/ILOG/CPLEX_Studio128/cplex/bin/x86-64_linux/cplex"
</pre></div>
<p>Please Note that you may need to change the version number in the file path
(i.e., <code>"CPLEX_Studio128"</code>). After specifying the <code>CPLEX_BIN</code>
environmental variable, the <span class="pkg">cplexAPI</span> package can be installed.
Since the <span class="pkg">cplexAPI</span> package is not available on the
the Comprehensive R Archive Network (CRAN), it must be installed from
<a href="https://github.com/cran/cplexAPI">its GitHub repository</a>. To
install the <span class="pkg">cplexAPI</span> package, please use the following code:
</p>
<div class="sourceCode"><pre>if (!require(remotes)) install.packages("remotes")
remotes::install_github("cran/cplexAPI")
</pre></div>
<p>For further details on installing this package, please consult the
<a href="https://github.com/cran/cplexAPI/blob/master/inst/INSTALL">installation instructions</a>.
</p>


<h3>References</h3>

<p>IBM (2017) IBM ILOG CPLEX Optimization Studio CPLEX User's Manual.
Version 12 Release 8. IBM ILOG CPLEX Division, Incline Village, NV.
</p>


<h3>See Also</h3>

<p>Other solvers: 
<code><a href="#topic+add_cbc_solver">add_cbc_solver</a>()</code>,
<code><a href="#topic+add_default_solver">add_default_solver</a>()</code>,
<code><a href="#topic+add_gurobi_solver">add_gurobi_solver</a>()</code>,
<code><a href="#topic+add_highs_solver">add_highs_solver</a>()</code>,
<code><a href="#topic+add_lsymphony_solver">add_lsymphony_solver</a></code>,
<code><a href="#topic+add_rsymphony_solver">add_rsymphony_solver</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_cplex_solver(gap = 0.1, time_limit = 5, verbose = FALSE)

# generate solution
s &lt;- solve(p)

# plot solution
plot(s, main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_cuts_portfolio'>Add Bender's cuts portfolio</h2><span id='topic+add_cuts_portfolio'></span>

<h3>Description</h3>

<p>Generate a portfolio of solutions for a conservation planning
problem using Bender's cuts (discussed in Rodrigues
<em>et al.</em> 2000). This is recommended as a replacement for
<code><a href="#topic+add_gap_portfolio">add_gap_portfolio()</a></code> when the <em>Gurobi</em> software is not
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_cuts_portfolio(x, number_solutions = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_cuts_portfolio_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_cuts_portfolio_+3A_number_solutions">number_solutions</code></td>
<td>
<p><code>integer</code> number of attempts to generate
different solutions. Defaults to 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This strategy for generating a portfolio of solutions involves
solving the problem multiple times and adding additional constraints
to forbid previously obtained solutions. In general, this strategy is most
useful when problems take a long time to solve and benefit from
having multiple threads allocated for solving an individual problem.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the portfolio added to it.
</p>


<h3>Notes</h3>

<p>In early versions (&lt; 4.0.1), this function was only compatible with
<em>Gurobi</em> (i.e., <code><a href="#topic+add_gurobi_solver">add_gurobi_solver()</a></code>). To provide functionality with
exact algorithm solvers, this function now adds constraints to the
problem formulation to generate multiple solutions.
</p>


<h3>References</h3>

<p>Rodrigues AS, Cerdeira OJ, and Gaston KJ (2000) Flexibility,
efficiency, and accountability: adapting reserve selection algorithms to
more complex conservation problems. <em>Ecography</em>, 23: 565&ndash;574.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+portfolios">portfolios</a> for an overview of all functions for adding a portfolio.
</p>
<p>Other portfolios: 
<code><a href="#topic+add_default_portfolio">add_default_portfolio</a>()</code>,
<code><a href="#topic+add_extra_portfolio">add_extra_portfolio</a>()</code>,
<code><a href="#topic+add_gap_portfolio">add_gap_portfolio</a>()</code>,
<code><a href="#topic+add_shuffle_portfolio">add_shuffle_portfolio</a>()</code>,
<code><a href="#topic+add_top_portfolio">add_top_portfolio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem with cuts portfolio
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_cuts_portfolio(10) %&gt;%
  add_default_solver(gap = 0.2, verbose = FALSE)

# solve problem and generate 10 solutions within 20% of optimality
s1 &lt;- solve(p1)

# convert portfolio into a multi-layer raster object
s1 &lt;- terra::rast(s1)

# plot solutions in portfolio
plot(s1, axes = FALSE)

# build multi-zone conservation problem with cuts portfolio
p2 &lt;-
 problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
 add_min_set_objective() %&gt;%
 add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
 add_binary_decisions() %&gt;%
 add_cuts_portfolio(10) %&gt;%
 add_default_solver(gap = 0.2, verbose = FALSE)

# solve the problem
s2 &lt;- solve(p2)

# print solution
str(s2, max.level = 1)

# convert each solution in the portfolio into a single category layer
s2 &lt;- terra::rast(lapply(s2, category_layer))

# plot solutions in portfolio
plot(s2, main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_default_portfolio'>Add a default portfolio</h2><span id='topic+add_default_portfolio'></span>

<h3>Description</h3>

<p>Generate a portfolio containing a single solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_default_portfolio(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_default_portfolio_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this is portfolio is added to <code><a href="#topic+problem">problem()</a></code> objects if no
other portfolios is manually specified.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the portfolio added to it.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+portfolios">portfolios</a> for an overview of all functions for adding a portfolio.
</p>
<p>Other portfolios: 
<code><a href="#topic+add_cuts_portfolio">add_cuts_portfolio</a>()</code>,
<code><a href="#topic+add_extra_portfolio">add_extra_portfolio</a>()</code>,
<code><a href="#topic+add_gap_portfolio">add_gap_portfolio</a>()</code>,
<code><a href="#topic+add_shuffle_portfolio">add_shuffle_portfolio</a>()</code>,
<code><a href="#topic+add_top_portfolio">add_top_portfolio</a>()</code>
</p>

<hr>
<h2 id='add_default_solver'>Add default solver</h2><span id='topic+add_default_solver'></span>

<h3>Description</h3>

<p>Specify that the best solver currently available should be
used to solve a conservation planning problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_default_solver(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_default_solver_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_default_solver_+3A_...">...</code></td>
<td>
<p>arguments passed to the solver.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ranked from best to worst, the available solvers that can be used are:
<code><a href="#topic+add_gurobi_solver">add_gurobi_solver()</a></code>, <code><a href="#topic+add_cplex_solver">add_cplex_solver()</a></code>, <code><a href="#topic+add_cbc_solver">add_cbc_solver()</a></code>,
<code><a href="#topic+add_highs_solver">add_highs_solver()</a></code>, <code><a href="#topic+add_lpsymphony_solver">add_lpsymphony_solver()</a></code>, and finally
<code><a href="#topic+add_rsymphony_solver">add_rsymphony_solver()</a></code>.
For information on the performance of different solvers,
please see Schuster <em>et al.</em> (2020).
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the solver added to it.
</p>


<h3>References</h3>

<p>Schuster R, Hanson JO, Strimas-Mackey M, and Bennett JR (2020). Exact
integer linear programming solvers outperform simulated annealing for
solving conservation planning problems. <em>PeerJ</em>, 8: e9258.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+solvers">solvers</a> for an overview of all functions for adding a solver.
</p>
<p>Other solvers: 
<code><a href="#topic+add_cbc_solver">add_cbc_solver</a>()</code>,
<code><a href="#topic+add_cplex_solver">add_cplex_solver</a>()</code>,
<code><a href="#topic+add_gurobi_solver">add_gurobi_solver</a>()</code>,
<code><a href="#topic+add_highs_solver">add_highs_solver</a>()</code>,
<code><a href="#topic+add_lsymphony_solver">add_lsymphony_solver</a></code>,
<code><a href="#topic+add_rsymphony_solver">add_rsymphony_solver</a>()</code>
</p>

<hr>
<h2 id='add_extra_portfolio'>Add an extra portfolio</h2><span id='topic+add_extra_portfolio'></span>

<h3>Description</h3>

<p>Generate a portfolio of solutions for a conservation planning
problem by storing feasible solutions
discovered during the optimization process.
This method is useful for quickly obtaining multiple solutions,
but does not provide any guarantees on the number of solutions, or
the quality of solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_extra_portfolio(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_extra_portfolio_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This strategy for generating a portfolio requires problems to
be solved using the <em>Gurobi</em> software suite (i.e., using
<code><a href="#topic+add_gurobi_solver">add_gurobi_solver()</a></code>. Specifically, version 8.0.0 (or greater)
of the <span class="pkg">gurobi</span> package must be installed.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the portfolio added to it.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+portfolios">portfolios</a> for an overview of all functions for adding a portfolio.
</p>
<p>Other portfolios: 
<code><a href="#topic+add_cuts_portfolio">add_cuts_portfolio</a>()</code>,
<code><a href="#topic+add_default_portfolio">add_default_portfolio</a>()</code>,
<code><a href="#topic+add_gap_portfolio">add_gap_portfolio</a>()</code>,
<code><a href="#topic+add_shuffle_portfolio">add_shuffle_portfolio</a>()</code>,
<code><a href="#topic+add_top_portfolio">add_top_portfolio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(600)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem with a portfolio for extra solutions
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.05) %&gt;%
  add_extra_portfolio() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem and generate portfolio
s1 &lt;- solve(p1)

# convert portfolio into a multi-layer raster object
s1 &lt;- terra::rast(s1)

# print number of solutions found
print(terra::nlyr(s1))

# plot solutions
plot(s1, axes = FALSE)

# create multi-zone problem with a portfolio for extra solutions
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_extra_portfolio() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem and generate portfolio
s2 &lt;- solve(p2)

# convert each solution in the portfolio into a single category layer
s2 &lt;- terra::rast(lapply(s2, category_layer))

# print number of solutions found
print(terra::nlyr(s2))

# plot solutions in portfolio
plot(s2, axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_feature_contiguity_constraints'>Add feature contiguity constraints</h2><span id='topic+add_feature_contiguity_constraints'></span><span id='topic+add_feature_contiguity_constraints+2CConservationProblem+2CANY+2Cmatrix-method'></span><span id='topic+add_feature_contiguity_constraints+2CConservationProblem+2CANY+2Cdata.frame-method'></span><span id='topic+add_feature_contiguity_constraints+2CConservationProblem+2CANY+2CMatrix-method'></span><span id='topic+add_feature_contiguity_constraints+2CConservationProblem+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Add constraints to a problem to ensure that each feature is
represented in a contiguous unit of dispersible habitat. These constraints
are a more advanced version of those implemented in the
<code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints()</a></code> function, because they ensure that
each feature is represented in a contiguous unit and not that the entire
solution should form a contiguous unit. Additionally, this function
can use data showing the distribution of dispersible habitat for each
feature to ensure that all features can disperse throughout the areas
designated for their conservation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConservationProblem,ANY,data.frame'
add_feature_contiguity_constraints(x, zones, data)

## S4 method for signature 'ConservationProblem,ANY,matrix'
add_feature_contiguity_constraints(x, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY'
add_feature_contiguity_constraints(x, zones, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_feature_contiguity_constraints_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_feature_contiguity_constraints_+3A_zones">zones</code></td>
<td>
<p><code>matrix</code>, <code>Matrix</code> or <code>list</code> object describing
the connection scheme for different zones. For <code>matrix</code> or
and <code>Matrix</code> arguments, each row and column corresponds
to a different zone in the argument to <code>x</code>, and cell values must
contain binary <code>numeric</code> values (i.e., one or zero) that indicate
if connected planning units (as specified in the argument to
<code>data</code>) should be still considered connected if they are allocated to
different zones. The cell values along the diagonal
of the matrix indicate if planning units should be subject to
contiguity constraints when they are allocated to a given zone. Note
arguments to <code>zones</code> must be symmetric, and that a row or column has
a value of one then the diagonal element for that row or column must also
have a value of one. If the connection scheme between different zones
should differ among the features, then the argument to <code>zones</code> should
be a <code>list</code> of <code>matrix</code> or <code>Matrix</code> objects that shows the
specific scheme for each feature using the conventions described above.
The default argument to <code>zones</code> is an identity
matrix (i.e., a matrix with ones along the matrix diagonal and zeros
elsewhere), so that planning units are only considered connected if they
are both allocated to the same zone.</p>
</td></tr>
<tr><td><code id="add_feature_contiguity_constraints_+3A_data">data</code></td>
<td>
<p><code>NULL</code>, <code>matrix</code>, <code>Matrix</code>, <code>data.frame</code>
or <code>list</code> of <code>matrix</code>, <code>Matrix</code>, or <code>data.frame</code>
objects. The argument to data shows which planning units should be treated
as being connected when implementing constraints to ensure that features
are represented in contiguous units. If different features have
different dispersal capabilities, then it may be desirable to specify
which sets of planning units should be treated as being connected
for which features using a <code>list</code> of objects. The default argument
is <code>NULL</code> which means that the connection data is calculated
automatically using the <code><a href="#topic+adjacency_matrix">adjacency_matrix()</a></code> function and so
all adjacent planning units are treated as being connected for all
features. See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses connection data to identify solutions that
represent features in contiguous units of dispersible habitat.
It was inspired by the mathematical formulations detailed in
Önal and Briers (2006) and Cardeira <em>et al.</em> 2010. For an
example that has used these constraints, see Hanson <em>et al.</em> (2019).
Please note
that these constraints require the expanded formulation and therefore
cannot be used with feature data that have negative vales.
<strong>Please note that adding these constraints to a problem will
drastically increase the amount of time required to solve it.</strong>
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the constraints added to it.
</p>


<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using the following formats.
</p>

<dl>
<dt><code>data</code> as a <code>NULL</code> value</dt><dd><p>connection
data should be calculated automatically
using the <code><a href="#topic+adjacency_matrix">adjacency_matrix()</a></code> function. This is the default
argument and means that all adjacent planning units are treated
as potentially dispersible for all features.
Note that the connection data must be manually defined
using one of the other formats below when the planning unit data
in the argument to <code>x</code> is not spatially referenced (e.g.,
in <code>data.frame</code> or <code>numeric</code> format).</p>
</dd>
<dt><code>data</code> as a<code>matrix</code>/<code>Matrix</code> object</dt><dd><p>where rows and columns represent
different planning units and the value of each cell indicates if the
two planning units are connected or not. Cell values should be binary
<code>numeric</code> values (i.e., one or zero). Cells that occur along the
matrix diagonal have no effect on the solution at all because each
planning unit cannot be a connected with itself. Note that pairs
of connected planning units are treated as being potentially dispersible
for all features.</p>
</dd>
<dt><code>data</code> as a <code>data.frame</code> object</dt><dd><p>containing columns that are named
<code>"id1"</code>, <code>"id2"</code>, and <code>"boundary"</code>. Here, each row
denotes the connectivity between two planning units following the
<em>Marxan</em> format. The <code>"boundary"</code> column should contain
binary <code>numeric</code> values that indicate if the two planning units
specified in the <code>"id1"</code> and <code>"id2"</code> columns are connected
or not. This data can be used to describe symmetric or
asymmetric relationships between planning units. By default,
input data is assumed to be symmetric unless asymmetric data is
also included (e.g., if data is present for planning units 2 and 3, then
the same amount of connectivity is expected for planning units 3 and 2,
unless connectivity data is also provided for planning units 3 and 2).
Note that pairs of connected planning units are treated as being
potentially dispersible for all features.</p>
</dd>
<dt><code>data</code> as a <code>list</code> object</dt><dd><p>containing <code>matrix</code>, <code>Matrix</code>, or
<code>data.frame</code> objects showing which planning units
should be treated as connected for each feature. Each element in the
<code>list</code> should correspond to a different feature (specifically,
a different target in the problem), and should contain a <code>matrix</code>,
<code>Matrix</code>, or <code>data.frame</code> object that follows the conventions
detailed above.</p>
</dd>
</dl>



<h3>Notes</h3>

<p>In early versions, it was named as the <code>add_corridor_constraints</code> function.
</p>


<h3>References</h3>

<p>Önal H and Briers RA (2006) Optimal selection of a connected
reserve network. <em>Operations Research</em>, 54: 379&ndash;388.
</p>
<p>Cardeira JO, Pinto LS, Cabeza M and Gaston KJ (2010) Species specific
connectivity in reserve-network design using graphs.
<em>Biological Conservation</em>, 2: 408&ndash;415.
</p>
<p>Hanson JO, Fuller RA, &amp; Rhodes JR (2019) Conventional methods for enhancing
connectivity in conservation planning do not always maintain gene flow.
<em>Journal of Applied Ecology</em>, 56: 913&ndash;922.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+constraints">constraints</a> for an overview of all functions for adding constraints.
</p>
<p>Other constraints: 
<code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_linear_constraints">add_linear_constraints</a>()</code>,
<code><a href="#topic+add_locked_in_constraints">add_locked_in_constraints</a>()</code>,
<code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints</a>()</code>,
<code><a href="#topic+add_mandatory_allocation_constraints">add_mandatory_allocation_constraints</a>()</code>,
<code><a href="#topic+add_manual_bounded_constraints">add_manual_bounded_constraints</a>()</code>,
<code><a href="#topic+add_manual_locked_constraints">add_manual_locked_constraints</a>()</code>,
<code><a href="#topic+add_neighbor_constraints">add_neighbor_constraints</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.3) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with contiguity constraints
p2 &lt;- p1 %&gt;% add_contiguity_constraints()

# create problem with constraints to represent features in contiguous
# units
p3 &lt;- p1 %&gt;% add_feature_contiguity_constraints()

# create problem with constraints to represent features in contiguous
# units that contain highly suitable habitat values
# (specifically in the top 5th percentile)
cm4 &lt;- lapply(seq_len(terra::nlyr(sim_features)), function(i) {
  # create connectivity matrix using the i'th feature's habitat data
  m &lt;- connectivity_matrix(sim_pu_raster, sim_features[[i]])
  # convert matrix to 0/1 values denoting values in top 5th percentile
  m &lt;- round(m &gt; quantile(as.vector(m), 1 - 0.05, names = FALSE))
  # remove 0s from the sparse matrix
  m &lt;- Matrix::drop0(m)
  # return matrix
  m
})
p4 &lt;- p1 %&gt;% add_feature_contiguity_constraints(data = cm4)

# solve problems
s1 &lt;- c(solve(p1), solve(p2), solve(p3), solve(p4))
names(s1) &lt;- c(
  "basic solution", "contiguity constraints",
  "feature contiguity constraints",
  "feature contiguity constraints with data"
)
# plot solutions
plot(s1, axes = FALSE)

# create minimal problem with multiple zones, and limit the solver to
# 30 seconds to obtain solutions in a feasible period of time
p5 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(time_limit = 30, verbose = FALSE)

# create problem with contiguity constraints that specify that the
# planning units used to conserve each feature in different management
# zones must form separate contiguous units
p6 &lt;- p5 %&gt;% add_feature_contiguity_constraints(diag(3))

# create problem with contiguity constraints that specify that the
# planning units used to conserve each feature must form a single
# contiguous unit if the planning units are allocated to zones 1 and 2
# and do not need to form a single contiguous unit if they are allocated
# to zone 3
zm7 &lt;- matrix(0, ncol = 3, nrow = 3)
zm7[seq_len(2), seq_len(2)] &lt;- 1
print(zm7)
p7 &lt;- p5 %&gt;% add_feature_contiguity_constraints(zm7)

# create problem with contiguity constraints that specify that all of
# the planning units in all three of the zones must conserve first feature
# in a single contiguous unit but the planning units used to conserve the
# remaining features do not need to be contiguous in any way
zm8 &lt;- lapply(
  seq_len(number_of_features(sim_zones_features)),
  function(i) matrix(ifelse(i == 1, 1, 0), ncol = 3, nrow = 3)
)
print(zm8)
p8 &lt;- p5 %&gt;% add_feature_contiguity_constraints(zm8)

# solve problems
s2 &lt;- lapply(list(p5, p6, p7, p8), solve)
s2 &lt;- terra::rast(lapply(s2, category_layer))
names(s2) &lt;- c("p5", "p6", "p7", "p8")
# plot solutions
plot(s2, axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_feature_weights'>Add feature weights</h2><span id='topic+add_feature_weights'></span><span id='topic+add_feature_weights+2CConservationProblem+2Cnumeric-method'></span><span id='topic+add_feature_weights+2CConservationProblem+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Add features weights to a conservation planning problem. Specifically,
some objective functions aim to maximize (or minimize) a metric that
measures how well a set of features are represented by a solution
(e.g., maximize the number of features that are adequately represented,
<code><a href="#topic+add_max_features_objective">add_max_features_objective()</a></code>). In such cases,
it may be desirable to prefer the representation of some features
over other features (e.g., features that have higher extinction risk
might be considered more important than those with lower extinction risk).
To achieve this, weights can be used to specify how much more important
it is for a solution to represent particular features compared with other
features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConservationProblem,numeric'
add_feature_weights(x, weights)

## S4 method for signature 'ConservationProblem,matrix'
add_feature_weights(x, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_feature_weights_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_feature_weights_+3A_weights">weights</code></td>
<td>
<p><code>numeric</code> or <code>matrix</code> of weights.
See the Weights format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weights can only be applied to problems that have an objective
that is budget limited (e.g., <code><a href="#topic+add_max_cover_objective">add_max_cover_objective()</a></code>,
<code><a href="#topic+add_min_shortfall_objective">add_min_shortfall_objective()</a></code>).
They can also be applied to problems that aim to maximize phylogenetic
representation (<code><a href="#topic+add_max_phylo_div_objective">add_max_phylo_div_objective()</a></code>) to favor the
representation of specific features over the representation of
some phylogenetic branches. Weights cannot be negative values
and must have values that are equal to or larger than zero.
<strong>Note that planning unit costs are scaled to 0.01 to identify
the cheapest solution among multiple optimal solutions. This means
that the optimization process will favor cheaper solutions over solutions
that meet feature targets (or occurrences) when feature weights are
lower than 0.01.</strong>
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> with the weights added to it.
</p>


<h3>Weights format</h3>

<p>The argument to <code>weights</code> can be specified using the following formats.
</p>

<dl>
<dt><code>weights</code> as a <code>numeric</code> vector</dt><dd><p>containing weights for each feature.
Note that this format cannot be used to specify weights for problems with
multiple zones.</p>
</dd>
<dt><code>weights</code> as a <code>matrix</code> object</dt><dd><p>containing weights
for each feature in each zone.
Here, each row corresponds to a different feature in argument to
<code>x</code>, each column corresponds to a different zone in argument to
<code>x</code>, and each cell contains the weight value for a given feature
that the solution can to secure in a given zone. Note that
if the problem contains targets created using
<code><a href="#topic+add_manual_targets">add_manual_targets()</a></code> then a <code>matrix</code> should be
supplied containing a single column that indicates that weight for
fulfilling each target.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="#topic+penalties">penalties</a> for an overview of all functions for adding penalties.
</p>
<p>Other penalties: 
<code><a href="#topic+add_asym_connectivity_penalties">add_asym_connectivity_penalties</a>()</code>,
<code><a href="#topic+add_boundary_penalties">add_boundary_penalties</a>()</code>,
<code><a href="#topic+add_connectivity_penalties">add_connectivity_penalties</a>()</code>,
<code><a href="#topic+add_linear_penalties">add_linear_penalties</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load package
require(ape)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_phylogeny &lt;- get_sim_phylogeny()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem that aims to maximize the number of features
# adequately conserved given a total budget of 3800. Here, each feature
# needs 20% of its habitat for it to be considered adequately conserved
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_max_features_objective(budget = 3800) %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create weights that assign higher importance to features with less
# suitable habitat in the study area
w2 &lt;- exp((1 / terra::global(sim_features, "sum", na.rm = TRUE)[[1]]) * 200)

# create problem using rarity weights
p2 &lt;- p1 %&gt;% add_feature_weights(w2)

# create manually specified weights that assign higher importance to
# certain features. These weights could be based on a pre-calculated index
# (e.g., an index measuring extinction risk where higher values
# denote higher extinction risk)
w3 &lt;- c(0, 0, 0, 100, 200)
p3 &lt;- p1 %&gt;% add_feature_weights(w3)

# solve problems
s1 &lt;- c(solve(p1), solve(p2), solve(p3))
names(s1) &lt;- c("equal weights", "rarity weights", "manual weights")

# plot solutions
plot(s1, axes = FALSE)

# plot the example phylogeny
par(mfrow = c(1, 1))
plot(sim_phylogeny, main = "simulated phylogeny")

# create problem with a maximum phylogenetic diversity objective,
# where each feature needs 10% of its distribution to be secured for
# it to be adequately conserved and a total budget of 1900
p4 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_max_phylo_div_objective(1900, sim_phylogeny) %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s4 &lt;- solve(p4)

# plot solution
plot(s4, main = "solution", axes = FALSE)

# find out which features have their targets met
r4 &lt;- eval_target_coverage_summary(p4, s4)
print(r4, width = Inf)

# plot the example phylogeny and color the represented features in red
plot(
  sim_phylogeny, main = "represented features",
  tip.color = replace(
    rep("black", terra::nlyr(sim_features)), which(r4$met), "red"
  )
)

# we can see here that the third feature ("layer.3", i.e.,
# sim_features[[3]]) is not represented in the solution. Let us pretend
# that it is absolutely critical this feature is adequately conserved
# in the solution. For example, this feature could represent a species
# that plays important role in the ecosystem, or a species that is
# important commercial activities (e.g., eco-tourism). So, to generate
# a solution that conserves the third feature whilst also aiming to
# maximize phylogenetic diversity, we will create a set of weights that
# assign a particularly high weighting to the third feature
w5 &lt;- c(0, 0, 10000, 0, 0)

# we can see that this weighting (i.e., w5[3]) has a much higher value than
# the branch lengths in the phylogeny so solutions that represent this
# feature be much closer to optimality
print(sim_phylogeny$edge.length)

# create problem with high weighting for the third feature and solve it
s5 &lt;- p4 %&gt;% add_feature_weights(w5) %&gt;% solve()

# plot solution
plot(s5, main = "solution", axes = FALSE)

# find which features have their targets met
r5 &lt;- eval_target_coverage_summary(p4, s5)
print(r5, width = Inf)

# plot the example phylogeny and color the represented features in red
# here we can see that this solution only adequately conserves the
# third feature. This means that, given the budget, we are faced with the
# trade-off of conserving either the third feature, or a phylogenetically
# diverse set of three different features.
plot(
  sim_phylogeny, main = "represented features",
  tip.color = replace(
    rep("black", terra::nlyr(sim_features)), which(r5$met), "red"
  )
)

# create multi-zone problem with maximum features objective,
# with 10% representation targets for each feature, and set
# a budget such that the total maximum expenditure in all zones
# cannot exceed 3000
p6 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_max_features_objective(3000) %&gt;%
  add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create weights that assign equal weighting for the representation
# of each feature in each zone except that it does not matter if
# feature 1 is represented in zone 1 and it really important
# that feature 3 is really in zone 1
w7 &lt;- matrix(1, ncol = 3, nrow = 5)
w7[1, 1] &lt;- 0
w7[3, 1] &lt;- 100

# create problem with weights
p7 &lt;- p6 %&gt;% add_feature_weights(w7)

# solve problems
s6 &lt;- solve(p6)
s7 &lt;- solve(p7)

# convert solutions to category layers
c6 &lt;- category_layer(s6)
c7 &lt;- category_layer(s7)

# plot solutions
plot(c(c6, c7), main = c("equal weights", "manual weights"), axes = FALSE)

# create minimal problem to show the correct method for setting
# weights for problems with manual targets
p8 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_max_features_objective(budget = 3000) %&gt;%
  add_manual_targets(
    data.frame(
    feature = c("feature_1", "feature_4"),
    type = "relative",
    target = 0.1)
  ) %&gt;%
  add_feature_weights(matrix(c(1, 200), ncol = 1)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s8 &lt;- solve(p8)

# plot solution
plot(s8, main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_gap_portfolio'>Add a gap portfolio</h2><span id='topic+add_gap_portfolio'></span>

<h3>Description</h3>

<p>Generate a portfolio of solutions for a conservation planning
problem by finding a certain number of solutions that
are all within a pre-specified optimality gap. This method is useful for
generating multiple solutions that can be used to calculate selection
frequencies for moderate and large-sized problems (similar to
<em>Marxan</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_gap_portfolio(x, number_solutions = 10, pool_gap = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_gap_portfolio_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_gap_portfolio_+3A_number_solutions">number_solutions</code></td>
<td>
<p><code>integer</code> number of solutions required.
Defaults to 10.</p>
</td></tr>
<tr><td><code id="add_gap_portfolio_+3A_pool_gap">pool_gap</code></td>
<td>
<p><code>numeric</code> gap to optimality for solutions in the portfolio.
This relative gap specifies a threshold worst-case performance for
solutions in the portfolio. For example, value of 0.1 will result in the
portfolio returning solutions that are within 10% of an optimal solution.
Note that the gap specified in the solver (i.e.,
<code><a href="#topic+add_gurobi_solver">add_gurobi_solver()</a></code> must be less than or equal to the gap
specified to generate the portfolio. Defaults to 0.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This strategy for generating a portfolio requires problems to
be solved using the <em>Gurobi</em> software suite (i.e., using
<code><a href="#topic+add_gurobi_solver">add_gurobi_solver()</a></code>. Specifically, version 9.0.0 (or greater)
of the <span class="pkg">gurobi</span> package must be installed.
Note that the number of solutions returned may be less than the argument to
<code>number_solutions</code>, if the total number of solutions that
meet the optimality gap is less than the number of solutions requested.
Also, note that this portfolio function only works with problems
that have binary decisions (i.e., specified using
<code><a href="#topic+add_binary_decisions">add_binary_decisions()</a></code>).
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the portfolio added to it.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+portfolios">portfolios</a> for an overview of all functions for adding a portfolio.
</p>
<p>Other portfolios: 
<code><a href="#topic+add_cuts_portfolio">add_cuts_portfolio</a>()</code>,
<code><a href="#topic+add_default_portfolio">add_default_portfolio</a>()</code>,
<code><a href="#topic+add_extra_portfolio">add_extra_portfolio</a>()</code>,
<code><a href="#topic+add_shuffle_portfolio">add_shuffle_portfolio</a>()</code>,
<code><a href="#topic+add_top_portfolio">add_top_portfolio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(600)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem with a portfolio containing 10 solutions within 20%
# of optimality
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.05) %&gt;%
  add_gap_portfolio(number_solutions = 5, pool_gap = 0.2) %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem and generate portfolio
s1 &lt;- solve(p1)

# convert portfolio into a multi-layer raster
s1 &lt;- terra::rast(s1)

# print number of solutions found
print(terra::nlyr(s1))

# plot solutions
plot(s1, axes = FALSE)

# create multi-zone  problem with a portfolio containing 10 solutions within
# 20% of optimality
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_gap_portfolio(number_solutions = 5, pool_gap = 0.2) %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem and generate portfolio
s2 &lt;- solve(p2)

# convert portfolio into a multi-layer raster of category layers
s2 &lt;- terra::rast(lapply(s2, category_layer))

# print number of solutions found
print(terra::nlyr(s2))

# plot solutions in portfolio
plot(s2, axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_gurobi_solver'>Add a <em>Gurobi</em> solver</h2><span id='topic+add_gurobi_solver'></span>

<h3>Description</h3>

<p>Specify that the <a href="https://www.gurobi.com/"><em>Gurobi</em></a> software
should be used to solve a conservation planning problem
(Gurobi Optimization LLC 2021). This function can also be used to
customize the behavior of the solver.
It requires the <span class="pkg">gurobi</span> package to be installed
(see below for installation instructions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_gurobi_solver(
  x,
  gap = 0.1,
  time_limit = .Machine$integer.max,
  presolve = 2,
  threads = 1,
  first_feasible = FALSE,
  numeric_focus = FALSE,
  node_file_start = Inf,
  start_solution = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_gurobi_solver_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_gurobi_solver_+3A_gap">gap</code></td>
<td>
<p><code>numeric</code> gap to optimality. This gap is relative
and expresses the acceptable deviance from the optimal objective.
For example, a value of 0.01 will result in the solver stopping when
it has found a solution within 1% of optimality.
Additionally, a value of 0 will result in the solver stopping
when it has found an optimal solution.
The default value is 0.1 (i.e., 10% from optimality).</p>
</td></tr>
<tr><td><code id="add_gurobi_solver_+3A_time_limit">time_limit</code></td>
<td>
<p><code>numeric</code> time limit (seconds) for generating solutions.
The solver will return the current best solution when this time limit is
exceeded. The default value is the largest integer value
(i.e., <code>.Machine$integer.max</code>), effectively meaning that solver
will keep running until a solution within the optimality gap is found.</p>
</td></tr>
<tr><td><code id="add_gurobi_solver_+3A_presolve">presolve</code></td>
<td>
<p><code>integer</code> number indicating how intensively the
solver should try to simplify the problem before solving it. Available
options are: (-1) automatically determine the intensity of
pre-solving, (0) disable pre-solving, (1) conservative
level of pre-solving, and (2) very aggressive level of pre-solving .
The default value is 2.</p>
</td></tr>
<tr><td><code id="add_gurobi_solver_+3A_threads">threads</code></td>
<td>
<p><code>integer</code> number of threads to use for the
optimization algorithm. The default value is 1.</p>
</td></tr>
<tr><td><code id="add_gurobi_solver_+3A_first_feasible">first_feasible</code></td>
<td>
<p><code>logical</code> should the first feasible solution be
be returned? If <code>first_feasible</code> is set to <code>TRUE</code>, the solver
will return the first solution it encounters that meets all the
constraints, regardless of solution quality. Note that the first feasible
solution is not an arbitrary solution, rather it is derived from the
relaxed solution, and is therefore often reasonably close to optimality.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_gurobi_solver_+3A_numeric_focus">numeric_focus</code></td>
<td>
<p><code>logical</code> should extra attention be paid
to verifying the accuracy of numerical calculations? This may be
useful when dealing with problems that may suffer from numerical instability
issues. Beware that it will likely substantially increase run time
(sets the <em>Gurobi</em> <code>NumericFocus</code> parameter
to 3). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_gurobi_solver_+3A_node_file_start">node_file_start</code></td>
<td>
<p><code>numeric</code> threshold amount of memory (in GB).
Once the amount of memory (RAM) used to store information for solving
the optimization problem exceeds this parameter value, the solver
will begin storing this information on disk
(using the <em>Gurobi</em> <code>NodeFileStart</code> parameter).
This functionality is useful if the system has insufficient memory to
solve a given problem (e.g., solving the problem with default settings
yields the <code style="white-space: pre;">&#8288;OUT OF MEMORY&#8288;</code> error message) and a system with more memory is
not readily available.
For example, a value of 4 indicates that the solver will start using
the disk after it uses more than 4 GB of memory to store information
on solving the problem.
Defaults to <code>Inf</code> such that the solver will not attempt
to store information on disk when solving a given problem.</p>
</td></tr>
<tr><td><code id="add_gurobi_solver_+3A_start_solution">start_solution</code></td>
<td>
<p><code>NULL</code> or object containing the starting solution
for the solver. This is can be useful because specifying a starting
solution can speed up the optimization process.
Defaults to <code>NULL</code> such that no starting solution is used.
To specify a starting solution, the argument to <code>start_solution</code> should
be in the same format as the planning units (i.e., a <code>NULL</code>, <code>numeric</code>,
<code>matrix</code>, <code>data.frame</code>, <code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object).
See the Start solution format section for more information.</p>
</td></tr>
<tr><td><code id="add_gurobi_solver_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> should information be printed while solving
optimization problems? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://www.gurobi.com/"><em>Gurobi</em></a> is a
state-of-the-art commercial optimization software with an R package
interface. It is by far the fastest of the solvers available for
generating prioritizations, however, it is not freely
available. That said, licenses are available to academics at no cost. The
<span class="pkg">gurobi</span> package is distributed with the <em>Gurobi</em> software suite.
This solver uses the <span class="pkg">gurobi</span> package to solve problems.
For information on the performance of different solvers,
please see Schuster <em>et al.</em> (2020) for benchmarks comparing the
run time and solution quality of different solvers when applied to
different sized datasets.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the solver added to it.
</p>


<h3>Installation</h3>

<p>Please see the <em>Gurobi Installation Guide</em> vignette for details on
installing the <em>Gurobi</em> software and the <span class="pkg">gurobi</span> package.
You can access this vignette
<a href="https://prioritizr.net/articles/gurobi_installation_guide.html">online</a>
or using the following code:
</p>
<div class="sourceCode"><pre>vignette("gurobi_installation_guide", package = "prioritizr")
</pre></div>


<h3>Start solution format</h3>

<p>Broadly speaking, the argument to <code>start_solution</code> must be in the same
format as the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt><code>x</code> has <code>numeric</code> planning units</dt><dd><p>The argument to <code>start_solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>start_solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>matrix</code> planning units</dt><dd><p>The argument to <code>start_solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>start_solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The argument to <code>start_solution</code>
be a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>start_solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>data.frame</code> planning units</dt><dd><p>The argument to <code>start_solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code><a href="sf.html#topic+sf">sf::sf()</a></code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>start_solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code> planning units</dt><dd><p>The argument to <code>start_solution</code> must be
a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>start_solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>start_solution</code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Gurobi Optimization LLC (2021) Gurobi Optimizer Reference Manual.
<a href="https://www.gurobi.com">https://www.gurobi.com</a>.
</p>
<p>Schuster R, Hanson JO, Strimas-Mackey M, and Bennett JR (2020). Exact
integer linear programming solvers outperform simulated annealing for
solving conservation planning problems. <em>PeerJ</em>, 8: e9258.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+solvers">solvers</a> for an overview of all functions for adding a solver.
</p>
<p>Other solvers: 
<code><a href="#topic+add_cbc_solver">add_cbc_solver</a>()</code>,
<code><a href="#topic+add_cplex_solver">add_cplex_solver</a>()</code>,
<code><a href="#topic+add_default_solver">add_default_solver</a>()</code>,
<code><a href="#topic+add_highs_solver">add_highs_solver</a>()</code>,
<code><a href="#topic+add_lsymphony_solver">add_lsymphony_solver</a></code>,
<code><a href="#topic+add_rsymphony_solver">add_rsymphony_solver</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create problem
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_gurobi_solver(gap = 0, verbose = FALSE)

# generate solution
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# create a similar problem with boundary length penalties and
# specify the solution from the previous run as a starting solution
p2 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_boundary_penalties(10) %&gt;%
  add_binary_decisions() %&gt;%
  add_gurobi_solver(gap = 0, start_solution = s1, verbose = FALSE)

# generate solution
s2 &lt;- solve(p2)

# plot solution
plot(s2, main = "solution with boundary penalties", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_highs_solver'>Add a <em>HiGHS</em> solver</h2><span id='topic+add_highs_solver'></span>

<h3>Description</h3>

<p>Specify that the <a href="https://highs.dev/"><em>HiGHS</em></a> software
should be used to solve a conservation planning problem
(Huangfu and Hall 2018). This function can also be used to
customize the behavior of the solver.
It requires the <span class="pkg">highs</span> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_highs_solver(
  x,
  gap = 0.1,
  time_limit = .Machine$integer.max,
  presolve = TRUE,
  threads = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_highs_solver_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_highs_solver_+3A_gap">gap</code></td>
<td>
<p><code>numeric</code> gap to optimality. This gap is relative
and expresses the acceptable deviance from the optimal objective.
For example, a value of 0.01 will result in the solver stopping when
it has found a solution within 1% of optimality.
Additionally, a value of 0 will result in the solver stopping
when it has found an optimal solution.
The default value is 0.1 (i.e., 10% from optimality).</p>
</td></tr>
<tr><td><code id="add_highs_solver_+3A_time_limit">time_limit</code></td>
<td>
<p><code>numeric</code> time limit (seconds) for generating solutions.
The solver will return the current best solution when this time limit is
exceeded. The default value is the largest integer value
(i.e., <code>.Machine$integer.max</code>), effectively meaning that solver
will keep running until a solution within the optimality gap is found.</p>
</td></tr>
<tr><td><code id="add_highs_solver_+3A_presolve">presolve</code></td>
<td>
<p><code>logical</code> attempt to simplify the
problem before solving it? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_highs_solver_+3A_threads">threads</code></td>
<td>
<p><code>integer</code> number of threads to use for the
optimization algorithm. The default value is 1.</p>
</td></tr>
<tr><td><code id="add_highs_solver_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> should information be printed while solving
optimization problems? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://highs.dev/"><em>HiGHS</em></a> is an open source optimization software.
Although this solver can have comparable performance to the <em>CBC</em> solver
(i.e., <code><a href="#topic+add_cbc_solver">add_cbc_solver()</a></code>) for particular problems and is generally faster
than the <em>SYMPHONY</em> based solvers (i.e., <code><a href="#topic+add_rsymphony_solver">add_rsymphony_solver()</a></code>,
<code><a href="#topic+add_lpsymphony_solver">add_lpsymphony_solver()</a></code>), it can sometimes take much longer than the
<em>CBC</em> solver for particular problems. This solver is recommended if
the <code><a href="#topic+add_gurobi_solver">add_gurobi_solver()</a></code>, <code><a href="#topic+add_cplex_solver">add_cplex_solver()</a></code>, <code><a href="#topic+add_cbc_solver">add_cbc_solver()</a></code> cannot
be used.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the solver added to it.
</p>


<h3>References</h3>

<p>Huangfu Q and Hall JAJ (2018). Parallelizing the dual revised simplex
method. <em>Mathematical Programming Computation</em>, 10: 119-142.
</p>


<h3>See Also</h3>

<p>Other solvers: 
<code><a href="#topic+add_cbc_solver">add_cbc_solver</a>()</code>,
<code><a href="#topic+add_cplex_solver">add_cplex_solver</a>()</code>,
<code><a href="#topic+add_default_solver">add_default_solver</a>()</code>,
<code><a href="#topic+add_gurobi_solver">add_gurobi_solver</a>()</code>,
<code><a href="#topic+add_lsymphony_solver">add_lsymphony_solver</a></code>,
<code><a href="#topic+add_rsymphony_solver">add_rsymphony_solver</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_highs_solver(gap = 0, verbose = FALSE)

# generate solution
s &lt;- solve(p)

# plot solution
plot(s, main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_linear_constraints'>Add linear constraints</h2><span id='topic+add_linear_constraints'></span><span id='topic+add_linear_constraints+2CConservationProblem+2CANY+2CANY+2CMatrix-method'></span><span id='topic+add_linear_constraints+2CConservationProblem+2CANY+2CANY+2Cmatrix-method'></span><span id='topic+add_linear_constraints+2CConservationProblem+2CANY+2CANY+2CdgCMatrix-method'></span><span id='topic+add_linear_constraints+2CConservationProblem+2CANY+2CANY+2Ccharacter-method'></span><span id='topic+add_linear_constraints+2CConservationProblem+2CANY+2CANY+2Cnumeric-method'></span><span id='topic+add_linear_constraints+2CConservationProblem+2CANY+2CANY+2CRaster-method'></span><span id='topic+add_linear_constraints+2CConservationProblem+2CANY+2CANY+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Add constraints to a conservation planning problem to ensure
that all selected planning units meet certain criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConservationProblem,ANY,ANY,character'
add_linear_constraints(x, threshold, sense, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,numeric'
add_linear_constraints(x, threshold, sense, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,matrix'
add_linear_constraints(x, threshold, sense, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,Matrix'
add_linear_constraints(x, threshold, sense, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,Raster'
add_linear_constraints(x, threshold, sense, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,SpatRaster'
add_linear_constraints(x, threshold, sense, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,dgCMatrix'
add_linear_constraints(x, threshold, sense, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_linear_constraints_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_linear_constraints_+3A_threshold">threshold</code></td>
<td>
<p><code>numeric</code> value.
This threshold value is also known as a &quot;right-hand-side&quot; value
per integer programming terminology.</p>
</td></tr>
<tr><td><code id="add_linear_constraints_+3A_sense">sense</code></td>
<td>
<p><code>character</code> sense for the constraint. Available
options include <code>"&gt;="</code>, <code>"&lt;="</code>, or <code>"="</code> values.</p>
</td></tr>
<tr><td><code id="add_linear_constraints_+3A_data">data</code></td>
<td>
<p><code>character</code>, <code>numeric</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, <code>matrix</code>, or <code>Matrix</code> object
containing the constraint values.
These constraint values are also known as constraint coefficients
per integer programming terminology.
See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds general purpose constraints that can be used to
ensure that solutions meet certain criteria
(see Examples section below for details).
For example, these constraints can be used to add multiple budgets.
They can also be used to ensure that the total number of planning units
allocated to a certain administrative area (e.g., country) does not exceed
a certain threshold (e.g., 30% of its total area). Furthermore,
they can also be used to ensure that features have a minimal level
of representation (e.g., 30%) when using an objective
function that aims to enhance feature representation given a budget
(e.g., <code><a href="#topic+add_min_shortfall_objective">add_min_shortfall_objective()</a></code>).
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the constraints added to it.
</p>


<h3>Mathematical formulation</h3>

<p>The linear constraints are implemented using the following
equation.
Let <code class="reqn">I</code> denote the set of planning units
(indexed by <code class="reqn">i</code>), <code class="reqn">Z</code> the set of management zones (indexed by
<code class="reqn">z</code>), and <code class="reqn">X_{iz}</code> the decision variable for allocating
planning unit <code class="reqn">i</code> to zone <code class="reqn">z</code> (e.g., with binary
values indicating if each planning unit is allocated or not). Also, let
<code class="reqn">D_{iz}</code> denote the constraint data associated with
planning units <code class="reqn">i \in I</code> for zones <code class="reqn">z \in Z</code>
(argument to <code>data</code>, if supplied as a <code>matrix</code> object),
<code class="reqn">\theta</code> denote the constraint sense
(argument to <code>sense</code>, e.g., <code class="reqn">&lt;=</code>), and <code class="reqn">t</code> denote the constraint
threshold (argument to <code>threshold</code>).
</p>
<p style="text-align: center;"><code class="reqn">
\sum_{i}^{I} \sum_{z}^{Z} (D_{iz} \times X_{iz}) \space \theta \space t
</code>
</p>



<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using the following formats.
</p>

<dl>
<dt><code>data</code> as <code>character</code> vector</dt><dd><p>containing column name(s) that
contain penalty values for planning units. This format is only
compatible if the planning units in the argument to <code>x</code> are a
<code><a href="sf.html#topic+sf">sf::sf()</a></code> or <code>data.frame</code> object. The column(s) must have <code>numeric</code>
values, and must not contain any missing (<code>NA</code>) values.
For problems that contain a single zone, the argument to <code>data</code> must
contain a single column name. Otherwise, for problems that
contain multiple zones, the argument to <code>data</code> must
contain a column name for each zone.</p>
</dd>
<dt><code>data</code> as a <code>numeric</code> vector</dt><dd><p>containing values for
planning units. These values must not contain any missing
(<code>NA</code>) values. Note that this format is only available
for planning units that contain a single zone.</p>
</dd>
<dt><code>data</code> as a <code>matrix</code>/<code>Matrix</code> object</dt><dd><p>containing <code>numeric</code> values
that specify data for each planning unit.
Each row corresponds to a planning unit, each column corresponds to a
zone, and each cell indicates the data for penalizing a planning unit
when it is allocated to a given zone.</p>
</dd>
<dt><code>data</code> as a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object</dt><dd><p>containing values for planning
units. This format is only
compatible if the planning units in the argument to <code>x</code> are
<code><a href="sf.html#topic+sf">sf::sf()</a></code>, or <code><a href="terra.html#topic+rast">terra::rast()</a></code> objects.
If the planning unit data are a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object,
then the values are calculated by overlaying the
planning units with the argument to <code>data</code> and calculating the sum of the
values associated with each planning unit.
If the planning unit data are a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object, then the values
are calculated by extracting the cell
values (note that the planning unit data and the argument to <code>data</code> must
have exactly the same dimensionality, extent, and missingness).
For problems involving multiple zones, the argument to <code>data</code> must
contain a layer for each zone.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="#topic+constraints">constraints</a> for an overview of all functions for adding constraints.
</p>
<p>Other constraints: 
<code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_feature_contiguity_constraints">add_feature_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_locked_in_constraints">add_locked_in_constraints</a>()</code>,
<code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints</a>()</code>,
<code><a href="#topic+add_mandatory_allocation_constraints">add_mandatory_allocation_constraints</a>()</code>,
<code><a href="#topic+add_manual_bounded_constraints">add_manual_bounded_constraints</a>()</code>,
<code><a href="#topic+add_manual_locked_constraints">add_manual_locked_constraints</a>()</code>,
<code><a href="#topic+add_neighbor_constraints">add_neighbor_constraints</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create a baseline problem with minimum shortfall objective
p0 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_shortfall_objective(1800) %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s0 &lt;- solve(p0)

# plot solution
plot(s0, main = "solution", axes = FALSE)

# now let's create some modified versions of this baseline problem by
# adding additional criteria using linear constraints

# first, let's create a modified version of p0 that contains
# an additional budget for a secondary cost dataset

# create a secondary cost dataset by simulating values
sim_pu_raster2 &lt;- simulate_cost(sim_pu_raster)

# plot the primary cost dataset (sim_pu_raster) and
# the secondary cost dataset (sim_pu_raster2)
plot(
  c(sim_pu_raster, sim_pu_raster2),
  main = c("sim_pu_raster", "sim_pu_raster2"),
  axes = FALSE
)

# create a modified version of p0 with linear constraints that
# specify that the planning units in the solution must not have
# values in sim_pu_raster2 that sum to a total greater than 500
p1 &lt;-
  p0 %&gt;%
  add_linear_constraints(
    threshold = 500, sense = "&lt;=", data = sim_pu_raster2
  )

# solve problem
s1 &lt;- solve(p1)

# plot solutions s1 and s2 to compare them
plot(c(s0, s1), main = c("s0", "s1"), axes = FALSE)

# second, let's create a modified version of p0 that contains
# additional constraints to ensure that each feature definitely has
# at least 8% of its overall distribution represented by the solution
# (in addition to the 20% targets which specify how much we would
# ideally want to conserve for each feature) 

# to achieve this, we need to calculate the total amount of each feature
# within the planning units so we can, in turn, set the constraint thresholds
feat_abund &lt;- feature_abundances(p0)$absolute_abundance

# create a modified version of p0 with additional constraints for each
# feature to specify that the planning units in the solution must
# secure at least 8% of the total abundance for each feature
p2 &lt;- p0
for (i in seq_len(terra::nlyr(sim_features))) {
  p2 &lt;-
    p2 %&gt;%
    add_linear_constraints(
      threshold = feat_abund[i] * 0.08,
      sense = "&gt;=",
      data = sim_features[[i]]
    )
}

# overall, p2 could be described as an optimization problem
# that maximizes feature representation as much as possible
# towards securing 20% of the total amount of each feature,
# whilst ensuring that (i) the total cost of the solution does
# not exceed 1800 (per cost values in sim_pu_raster) and (ii)
# the solution secures at least 8% of the total amount of each feature
# (if 20% is not possible due to the budget)

# solve problem
s2 &lt;- solve(p2)

# plot solutions s0 and s2 to compare them
plot(c(s0, s2), main = c("s1", "s2"), axes = FALSE)

# third, let's create a modified version of p0 that contains
# additional constraints to ensure that the solution equitably
# distributes conservation effort across different administrative areas
# (e.g., countries) within the study region

# to begin with, we will simulate a dataset describing the spatial extent of
# four different administrative areas across the study region
sim_admin &lt;- sim_pu_raster
sim_admin &lt;- terra::aggregate(sim_admin, fact = 5)
sim_admin &lt;- terra::setValues(sim_admin, seq_len(terra::ncell(sim_admin)))
sim_admin &lt;- terra::resample(sim_admin, sim_pu_raster, method = "near")
sim_admin &lt;- terra::mask(sim_admin, sim_pu_raster)

# plot administrative areas layer,
# we can see that the administrative areas subdivide
# the study region into four quadrants, and the sim_admin object is a
# SpatRaster with integer values denoting ids for the administrative areas
plot(sim_admin, axes = FALSE)

# next we will convert the sim_admin SpatRaster object into a SpatRaster
# object (with a layer for each administrative area) indicating which
# planning units belong to each administrative area using binary
# (presence/absence) values
sim_admin2 &lt;- binary_stack(sim_admin)

# plot binary stack of administrative areas
plot(sim_admin2, axes = FALSE)

# we will now calculate the total amount of planning units associated
# with each administrative area, so that we can set the constraint threshold

# since we are using raster data, we won't bother explicitly
# accounting for the total area of each planning unit (because all
# planning units have the same area in raster formats) -- but if we were
# using vector data then we would need to account for the area of each unit
admin_total &lt;- Matrix::rowSums(rij_matrix(sim_pu_raster, sim_admin2))

# create a modified version of p0 with additional constraints for each
# administrative area to specify that the planning units in the solution must
# not encompass more than 10% of the total extent of the administrative
# area
p3 &lt;- p0
for (i in seq_len(terra::nlyr(sim_admin2))) {
  p3 &lt;-
    p3 %&gt;%
    add_linear_constraints(
      threshold = admin_total[i] * 0.1,
      sense = "&lt;=",
      data = sim_admin2[[i]]
    )
}

# solve problem
s3 &lt;- solve(p3)

# plot solutions s0 and s3 to compare them
plot(c(s0, s3), main = c("s0", "s3"), axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='add_linear_penalties'>Add linear penalties</h2><span id='topic+add_linear_penalties'></span><span id='topic+add_linear_penalties+2CConservationProblem+2CANY+2CMatrix-method'></span><span id='topic+add_linear_penalties+2CConservationProblem+2CANY+2Cmatrix-method'></span><span id='topic+add_linear_penalties+2CConservationProblem+2CANY+2CdgCMatrix-method'></span><span id='topic+add_linear_penalties+2CConservationProblem+2CANY+2Ccharacter-method'></span><span id='topic+add_linear_penalties+2CConservationProblem+2CANY+2Cnumeric-method'></span><span id='topic+add_linear_penalties+2CConservationProblem+2CANY+2CRaster-method'></span><span id='topic+add_linear_penalties+2CConservationProblem+2CANY+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Add penalties to a conservation planning problem to penalize
solutions that select planning units with higher values from a specific
data source (e.g., anthropogenic impact). These penalties assume
a linear trade-off between the penalty values and the primary
objective of the conservation planning problem (e.g.,
solution cost for minimum set problems; <code><a href="#topic+add_min_set_objective">add_min_set_objective()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConservationProblem,ANY,character'
add_linear_penalties(x, penalty, data)

## S4 method for signature 'ConservationProblem,ANY,numeric'
add_linear_penalties(x, penalty, data)

## S4 method for signature 'ConservationProblem,ANY,matrix'
add_linear_penalties(x, penalty, data)

## S4 method for signature 'ConservationProblem,ANY,Matrix'
add_linear_penalties(x, penalty, data)

## S4 method for signature 'ConservationProblem,ANY,Raster'
add_linear_penalties(x, penalty, data)

## S4 method for signature 'ConservationProblem,ANY,SpatRaster'
add_linear_penalties(x, penalty, data)

## S4 method for signature 'ConservationProblem,ANY,dgCMatrix'
add_linear_penalties(x, penalty, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_linear_penalties_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_linear_penalties_+3A_penalty">penalty</code></td>
<td>
<p><code>numeric</code> penalty value that is used to scale the
importance of not selecting planning units with high <code>data</code> values.
Higher <code>penalty</code> values can be used to obtain solutions that
are strongly averse to selecting places with high <code>data</code>
values, and smaller <code>penalty</code> values can be used to obtain solutions
that only avoid places with especially high <code>data</code> values.
Note that negative
<code>penalty</code> values can be used to obtain solutions that prefer places
with high <code>data</code> values. Additionally, when adding these
penalties to problems with multiple zones, the argument to <code>penalty</code>
must have a value for each zone.</p>
</td></tr>
<tr><td><code id="add_linear_penalties_+3A_data">data</code></td>
<td>
<p><code>character</code>, <code>numeric</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, <code>matrix</code>, or <code>Matrix</code> object
containing the values used to penalize solutions. Planning units that are
associated with higher data values are penalized more strongly
in the solution. See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function penalizes solutions that have higher values according
to the sum of the penalty values associated with each planning unit,
weighted by status of each planning unit in the solution.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the penalties added to it.
</p>


<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using the following formats.
</p>

<dl>
<dt><code>data</code> as <code>character</code> vector</dt><dd><p>containing column name(s) that
contain penalty values for planning units. This format is only
compatible if the planning units in the argument to <code>x</code> are a
<code><a href="sf.html#topic+sf">sf::sf()</a></code> or <code>data.frame</code> object. The column(s) must have <code>numeric</code>
values, and must not contain any missing (<code>NA</code>) values.
For problems that contain a single zone, the argument to <code>data</code> must
contain a single column name. Otherwise, for problems that
contain multiple zones, the argument to <code>data</code> must
contain a column name for each zone.</p>
</dd>
<dt><code>data</code> as a <code>numeric</code> vector</dt><dd><p>containing values for
planning units. These values must not contain any missing
(<code>NA</code>) values. Note that this format is only available
for planning units that contain a single zone.</p>
</dd>
<dt><code>data</code> as a <code>matrix</code>/<code>Matrix</code> object</dt><dd><p>containing <code>numeric</code> values
that specify data for each planning unit.
Each row corresponds to a planning unit, each column corresponds to a
zone, and each cell indicates the data for penalizing a planning unit
when it is allocated to a given zone.</p>
</dd>
<dt><code>data</code> as a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object</dt><dd><p>containing values for planning
units. This format is only
compatible if the planning units in the argument to <code>x</code> are
<code><a href="sf.html#topic+sf">sf::sf()</a></code>, or <code><a href="terra.html#topic+rast">terra::rast()</a></code> objects.
If the planning unit data are a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object,
then the values are calculated by overlaying the
planning units with the argument to <code>data</code> and calculating the sum of the
values associated with each planning unit.
If the planning unit data are a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object, then the values
are calculated by extracting the cell
values (note that the planning unit data and the argument to <code>data</code> must
have exactly the same dimensionality, extent, and missingness).
For problems involving multiple zones, the argument to <code>data</code> must
contain a layer for each zone.</p>
</dd>
</dl>



<h3>Mathematical formulation</h3>

<p>The linear penalties are implemented using the following
equations.
Let <code class="reqn">I</code> denote the set of planning units
(indexed by <code class="reqn">i</code>), <code class="reqn">Z</code> the set of management zones (indexed by
<code class="reqn">z</code>), and <code class="reqn">X_{iz}</code> the decision variable for allocating
planning unit <code class="reqn">i</code> to zone <code class="reqn">z</code> (e.g., with binary
values indicating if each planning unit is allocated or not). Also, let
<code class="reqn">P_z</code> represent the penalty scaling value for zones
<code class="reqn">z \in Z</code> (argument to <code>penalty</code>), and
<code class="reqn">D_{iz}</code> the penalty data for allocating planning unit
<code class="reqn">i \in I</code> to zones <code class="reqn">z \in Z</code> (argument to
<code>data</code>, if supplied as a <code>matrix</code> object).
</p>
<p style="text-align: center;"><code class="reqn">
\sum_{i}^{I} \sum_{z}^{Z} P_z \times D_{iz} \times X_{iz}
</code>
</p>

<p>Note that when the problem objective is to maximize some measure of
benefit and not minimize some measure of cost, the term <code class="reqn">P_z</code> is
replaced with <code class="reqn">-P_z</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+penalties">penalties</a> for an overview of all functions for adding penalties.
</p>
<p>Other penalties: 
<code><a href="#topic+add_asym_connectivity_penalties">add_asym_connectivity_penalties</a>()</code>,
<code><a href="#topic+add_boundary_penalties">add_boundary_penalties</a>()</code>,
<code><a href="#topic+add_connectivity_penalties">add_connectivity_penalties</a>()</code>,
<code><a href="#topic+add_feature_weights">add_feature_weights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(600)

# load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# add a column to contain the penalty data for each planning unit
# e.g., these values could indicate the level of habitat
sim_pu_polygons$penalty_data &lt;- runif(nrow(sim_pu_polygons))

# plot the penalty data to visualise its spatial distribution
plot(sim_pu_polygons[, "penalty_data"], axes = FALSE)

# create minimal problem with minimum set objective,
# this does not use the penalty data
p1 &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# print problem
print(p1)

# create an updated version of the previous problem,
# with the penalties added to it
p2 &lt;- p1 %&gt;% add_linear_penalties(100, data = "penalty_data")

# print problem
print(p2)

# solve the two problems
s1 &lt;- solve(p1)
s2 &lt;- solve(p2)

# create a new object with both solutions
s3 &lt;- sf::st_sf(
  tibble::tibble(
    s1 = s1$solution_1,
    s2 = s2$solution_1
  ),
  geometry = sf::st_geometry(s1)
)


# plot the solutions and compare them,
# since we supplied a very high penalty value (i.e., 100), relative
# to the range of values in the penalty data and the objective function,
# the solution in s2 is very sensitive to values in the penalty data
plot(s3, axes = FALSE)

# for real conservation planning exercises,
# it would be worth exploring a range of penalty values (e.g., ranging
# from 1 to 100 increments of 5) to explore the trade-offs

# now, let's examine a conservation planning exercise involving multiple
# management zones

# create targets for each feature within each zone,
# these targets indicate that each zone needs to represent 10% of the
# spatial distribution of each feature
targ &lt;- matrix(
  0.1, ncol = number_of_zones(sim_zones_features),
  nrow = number_of_features(sim_zones_features)
)

# create penalty data for allocating each planning unit to each zone,
# these data will be generated by simulating values
penalty_raster &lt;- simulate_cost(
  sim_zones_pu_raster[[1]],
  n = number_of_zones(sim_zones_features)
)

# plot the penalty data, each layer corresponds to a different zone
plot(penalty_raster, main = "penalty data", axes = FALSE)

# create a multi-zone problem with the minimum set objective
# and penalties for allocating planning units to each zone,
# with a penalty scaling factor of 1 for each zone
p4 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(targ) %&gt;%
  add_linear_penalties(c(1, 1, 1), penalty_raster) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# print problem
print(p4)

# solve problem
s4 &lt;- solve(p4)

# plot solution
plot(category_layer(s4), main = "multi-zone solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_locked_in_constraints'>Add locked in constraints</h2><span id='topic+add_locked_in_constraints'></span><span id='topic+add_locked_in_constraints+2CConservationProblem+2Cnumeric-method'></span><span id='topic+add_locked_in_constraints+2CConservationProblem+2Clogical-method'></span><span id='topic+add_locked_in_constraints+2CConservationProblem+2Cmatrix-method'></span><span id='topic+add_locked_in_constraints+2CConservationProblem+2Ccharacter-method'></span><span id='topic+add_locked_in_constraints+2CConservationProblem+2CRaster-method'></span><span id='topic+add_locked_in_constraints+2CConservationProblem+2CSpatRaster-method'></span><span id='topic+add_locked_in_constraints+2CConservationProblem+2CSpatial-method'></span><span id='topic+add_locked_in_constraints+2CConservationProblem+2Csf-method'></span>

<h3>Description</h3>

<p>Add constraints to a conservation planning problem to ensure
that specific planning units are selected (or allocated
to a specific zone) in the solution. For example, it may be desirable to
lock in planning units that are inside existing protected areas so that the
solution fills in the gaps in the existing reserve network. If specific
planning units should be locked out of a solution, use
<code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints()</a></code>. For problems with non-binary
planning unit allocations (e.g., proportions), the
<code><a href="#topic+add_manual_locked_constraints">add_manual_locked_constraints()</a></code> function can be used to lock
planning unit allocations to a specific value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_locked_in_constraints(x, locked_in)

## S4 method for signature 'ConservationProblem,numeric'
add_locked_in_constraints(x, locked_in)

## S4 method for signature 'ConservationProblem,logical'
add_locked_in_constraints(x, locked_in)

## S4 method for signature 'ConservationProblem,matrix'
add_locked_in_constraints(x, locked_in)

## S4 method for signature 'ConservationProblem,character'
add_locked_in_constraints(x, locked_in)

## S4 method for signature 'ConservationProblem,Spatial'
add_locked_in_constraints(x, locked_in)

## S4 method for signature 'ConservationProblem,sf'
add_locked_in_constraints(x, locked_in)

## S4 method for signature 'ConservationProblem,Raster'
add_locked_in_constraints(x, locked_in)

## S4 method for signature 'ConservationProblem,SpatRaster'
add_locked_in_constraints(x, locked_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_locked_in_constraints_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_locked_in_constraints_+3A_locked_in">locked_in</code></td>
<td>
<p>Object that determines which planning units should be
locked in. See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the constraints added to it.
</p>


<h3>Data format</h3>

<p>The locked planning units can be specified using the following formats.
Generally, the locked data should correspond to the planning units
in the argument to <code>x.</code> To help make working with
<code><a href="terra.html#topic+rast">terra::rast()</a></code> planning unit data easier,
the locked data should correspond to cell indices in the
<code><a href="terra.html#topic+rast">terra::rast()</a></code> data. For example, <code>integer</code> arguments
should correspond to cell indices and <code>logical</code> arguments should have
a value for each cell&mdash;regardless of which planning unit cells contain
<code>NA</code> values.
</p>

<dl>
<dt><code>data</code> as an <code>integer</code> vector</dt><dd><p>containing indices that indicate which
planning units should be locked for the solution. This argument is only
compatible with problems that contain a single zone.</p>
</dd>
<dt><code>data</code> as a <code>logical</code> vector</dt><dd><p>containing <code>TRUE</code> and/or
<code>FALSE</code> values that indicate which planning units should be locked
in the solution. This argument is only compatible with problems that
contain a single zone.</p>
</dd>
<dt><code>data</code> as a <code>matrix</code> object</dt><dd><p>containing <code>logical</code> <code>TRUE</code> and/or
<code>FALSE</code> values which indicate if certain planning units are
should be locked to a specific zone in the solution. Each row
corresponds to a planning unit, each column corresponds to a zone, and
each cell indicates if the planning unit should be locked to a given
zone. Thus each row should only contain at most a single <code>TRUE</code>
value.</p>
</dd>
<dt><code>data</code> as a <code>character</code> vector</dt><dd><p>containing column name(s)
that indicates if planning units should be locked for the solution.
This format is only
compatible if the planning units in the argument to <code>x</code> are a
<code><a href="sf.html#topic+sf">sf::sf()</a></code> or <code>data.frame</code> object. The columns
must have <code>logical</code> (i.e., <code>TRUE</code> or <code>FALSE</code>)
values indicating if the planning unit is to be locked for the solution.
For problems that contain a single zone, the argument to <code>data</code> must
contain a single column name. Otherwise, for problems that
contain multiple zones, the argument to <code>data</code> must
contain a column name for each zone.</p>
</dd>
<dt><code>data</code> as a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object</dt><dd>
<p>containing geometries that will be used to lock planning units for
the solution. Specifically, planning units in <code>x</code> that spatially
intersect with <code>y</code> will be locked (per <code><a href="#topic+intersecting_units">intersecting_units()</a></code>).
Note that this option is only available
for problems that contain a single management zone.</p>
</dd>
<dt><code>data</code> as a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object</dt><dd>
<p>containing cells used to lock planning units for the solution.
Specifically, planning units in <code>x</code>
that intersect with cells that have non-zero and non-<code>NA</code> values are
locked.
For problems that contain multiple zones, the
<code>data</code> object must contain a layer
for each zone. Note that for multi-band arguments, each pixel must
only contain a non-zero value in a single band. Additionally, if the
cost data in <code>x</code> is a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object, we
recommend standardizing <code>NA</code> values in this dataset with the cost
data. In other words, the pixels in <code>x</code> that have <code>NA</code> values
should also have <code>NA</code> values in the locked data.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="#topic+constraints">constraints</a> for an overview of all functions for adding constraints.
</p>
<p>Other constraints: 
<code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_feature_contiguity_constraints">add_feature_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_linear_constraints">add_linear_constraints</a>()</code>,
<code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints</a>()</code>,
<code><a href="#topic+add_mandatory_allocation_constraints">add_mandatory_allocation_constraints</a>()</code>,
<code><a href="#topic+add_manual_bounded_constraints">add_manual_bounded_constraints</a>()</code>,
<code><a href="#topic+add_manual_locked_constraints">add_manual_locked_constraints</a>()</code>,
<code><a href="#topic+add_neighbor_constraints">add_neighbor_constraints</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_locked_in_raster &lt;- get_sim_locked_in_raster()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem
p1 &lt;-
  problem(sim_pu_polygons, sim_features, "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with added locked in constraints using integers
p2 &lt;- p1 %&gt;% add_locked_in_constraints(which(sim_pu_polygons$locked_in))

# create problem with added locked in constraints using a column name
p3 &lt;- p1 %&gt;% add_locked_in_constraints("locked_in")

# create problem with added locked in constraints using raster data
p4 &lt;- p1 %&gt;% add_locked_in_constraints(sim_locked_in_raster)

# create problem with added locked in constraints using spatial polygon data
locked_in &lt;- sim_pu_polygons[sim_pu_polygons$locked_in == 1, ]
p5 &lt;- p1 %&gt;% add_locked_in_constraints(locked_in)

# solve problems
s1 &lt;- solve(p1)
s2 &lt;- solve(p2)
s3 &lt;- solve(p3)
s4 &lt;- solve(p4)
s5 &lt;- solve(p5)

# create single object with all solutions
s6 &lt;- sf::st_sf(
  tibble::tibble(
    s1 = s1$solution_1,
    s2 = s2$solution_1,
    s3 = s3$solution_1,
    s4 = s4$solution_1,
    s5 = s5$solution_1
  ),
  geometry = sf::st_geometry(s1)
)

# plot solutions
plot(
  s6,
  main = c(
    "none locked in", "locked in (integer input)",
    "locked in (character input)", "locked in (raster input)",
    "locked in (polygon input)"
  )
)

# create minimal multi-zone problem with spatial data
p7 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(matrix(rpois(15, 1), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create multi-zone problem with locked in constraints using matrix data
locked_matrix &lt;- as.matrix(sf::st_drop_geometry(
  sim_zones_pu_polygons[, c("locked_1", "locked_2", "locked_3")]
))

p8 &lt;- p7 %&gt;% add_locked_in_constraints(locked_matrix)

# solve problem
s8 &lt;- solve(p8)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s8$solution &lt;- category_vector(sf::st_drop_geometry(
  s8[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
))
s8$solution &lt;- factor(s8$solution)

# plot solution
plot(s8[ "solution"], axes = FALSE)

# create multi-zone problem with locked in constraints using column names
p9 &lt;- p7 %&gt;% add_locked_in_constraints(c("locked_1", "locked_2", "locked_3"))

# solve problem
s9 &lt;- solve(p9)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s9$solution &lt;- category_vector(sf::st_drop_geometry(
  s9[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
))
s9$solution[s9$solution == 1 &amp; s9$solution_1_zone_1 == 0] &lt;- 0
s9$solution &lt;- factor(s9$solution)

# plot solution
plot(s9[, "solution"], axes = FALSE)

# create multi-zone problem with raster planning units
p10 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(matrix(rpois(15, 1), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create multi-layer raster with locked in units
locked_in_raster &lt;- sim_zones_pu_raster[[1]]
locked_in_raster[!is.na(locked_in_raster)] &lt;- 0
locked_in_raster &lt;- locked_in_raster[[c(1, 1, 1)]]
names(locked_in_raster) &lt;- c("zone_1", "zone_2", "zone_3")
locked_in_raster[[1]][1] &lt;- 1
locked_in_raster[[2]][2] &lt;- 1
locked_in_raster[[3]][3] &lt;- 1

# plot locked in raster
plot(locked_in_raster)

# add locked in raster units to problem
p10 &lt;- p10 %&gt;% add_locked_in_constraints(locked_in_raster)

# solve problem
s10 &lt;- solve(p10)

# plot solution
plot(category_layer(s10), main = "solution", axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='add_locked_out_constraints'>Add locked out constraints</h2><span id='topic+add_locked_out_constraints'></span><span id='topic+add_locked_out_constraints+2CConservationProblem+2Cnumeric-method'></span><span id='topic+add_locked_out_constraints+2CConservationProblem+2Clogical-method'></span><span id='topic+add_locked_out_constraints+2CConservationProblem+2Cmatrix-method'></span><span id='topic+add_locked_out_constraints+2CConservationProblem+2Ccharacter-method'></span><span id='topic+add_locked_out_constraints+2CConservationProblem+2CRaster-method'></span><span id='topic+add_locked_out_constraints+2CConservationProblem+2CSpatRaster-method'></span><span id='topic+add_locked_out_constraints+2CConservationProblem+2CSpatial-method'></span><span id='topic+add_locked_out_constraints+2CConservationProblem+2Csf-method'></span>

<h3>Description</h3>

<p>Add constraints to a conservation planning problem to ensure
that specific planning units are not selected
(or allocated to a specific zone) in the solution. For example, it may be
useful to lock out planning units that have been degraded and are not
suitable for conserving species. If specific planning units should be locked
in to the solution, use <code><a href="#topic+add_locked_in_constraints">add_locked_in_constraints()</a></code>. For
problems with non-binary planning unit allocations (e.g., proportions), the
<code><a href="#topic+add_manual_locked_constraints">add_manual_locked_constraints()</a></code> function can be used to lock
planning unit allocations to a specific value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,numeric'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,logical'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,matrix'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,character'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,Spatial'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,sf'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,Raster'
add_locked_out_constraints(x, locked_out)

## S4 method for signature 'ConservationProblem,SpatRaster'
add_locked_out_constraints(x, locked_out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_locked_out_constraints_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_locked_out_constraints_+3A_locked_out">locked_out</code></td>
<td>
<p>Object that determines which planning units that should be
locked out. See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the constraints added to it.
</p>


<h3>Data format</h3>

<p>The locked planning units can be specified using the following formats.
Generally, the locked data should correspond to the planning units
in the argument to <code>x.</code> To help make working with
<code><a href="terra.html#topic+rast">terra::rast()</a></code> planning unit data easier,
the locked data should correspond to cell indices in the
<code><a href="terra.html#topic+rast">terra::rast()</a></code> data. For example, <code>integer</code> arguments
should correspond to cell indices and <code>logical</code> arguments should have
a value for each cell&mdash;regardless of which planning unit cells contain
<code>NA</code> values.
</p>

<dl>
<dt><code>data</code> as an <code>integer</code> vector</dt><dd><p>containing indices that indicate which
planning units should be locked for the solution. This argument is only
compatible with problems that contain a single zone.</p>
</dd>
<dt><code>data</code> as a <code>logical</code> vector</dt><dd><p>containing <code>TRUE</code> and/or
<code>FALSE</code> values that indicate which planning units should be locked
in the solution. This argument is only compatible with problems that
contain a single zone.</p>
</dd>
<dt><code>data</code> as a <code>matrix</code> object</dt><dd><p>containing <code>logical</code> <code>TRUE</code> and/or
<code>FALSE</code> values which indicate if certain planning units are
should be locked to a specific zone in the solution. Each row
corresponds to a planning unit, each column corresponds to a zone, and
each cell indicates if the planning unit should be locked to a given
zone. Thus each row should only contain at most a single <code>TRUE</code>
value.</p>
</dd>
<dt><code>data</code> as a <code>character</code> vector</dt><dd><p>containing column name(s)
that indicates if planning units should be locked for the solution.
This format is only
compatible if the planning units in the argument to <code>x</code> are a
<code><a href="sf.html#topic+sf">sf::sf()</a></code> or <code>data.frame</code> object. The columns
must have <code>logical</code> (i.e., <code>TRUE</code> or <code>FALSE</code>)
values indicating if the planning unit is to be locked for the solution.
For problems that contain a single zone, the argument to <code>data</code> must
contain a single column name. Otherwise, for problems that
contain multiple zones, the argument to <code>data</code> must
contain a column name for each zone.</p>
</dd>
<dt><code>data</code> as a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object</dt><dd>
<p>containing geometries that will be used to lock planning units for
the solution. Specifically, planning units in <code>x</code> that spatially
intersect with <code>y</code> will be locked (per <code><a href="#topic+intersecting_units">intersecting_units()</a></code>).
Note that this option is only available
for problems that contain a single management zone.</p>
</dd>
<dt><code>data</code> as a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object</dt><dd>
<p>containing cells used to lock planning units for the solution.
Specifically, planning units in <code>x</code>
that intersect with cells that have non-zero and non-<code>NA</code> values are
locked.
For problems that contain multiple zones, the
<code>data</code> object must contain a layer
for each zone. Note that for multi-band arguments, each pixel must
only contain a non-zero value in a single band. Additionally, if the
cost data in <code>x</code> is a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object, we
recommend standardizing <code>NA</code> values in this dataset with the cost
data. In other words, the pixels in <code>x</code> that have <code>NA</code> values
should also have <code>NA</code> values in the locked data.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="#topic+constraints">constraints</a> for an overview of all functions for adding constraints.
</p>
<p>Other constraints: 
<code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_feature_contiguity_constraints">add_feature_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_linear_constraints">add_linear_constraints</a>()</code>,
<code><a href="#topic+add_locked_in_constraints">add_locked_in_constraints</a>()</code>,
<code><a href="#topic+add_mandatory_allocation_constraints">add_mandatory_allocation_constraints</a>()</code>,
<code><a href="#topic+add_manual_bounded_constraints">add_manual_bounded_constraints</a>()</code>,
<code><a href="#topic+add_manual_locked_constraints">add_manual_locked_constraints</a>()</code>,
<code><a href="#topic+add_neighbor_constraints">add_neighbor_constraints</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_locked_out_raster &lt;- get_sim_locked_out_raster()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem
p1 &lt;-
  problem(sim_pu_polygons, sim_features, "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with added locked out constraints using integers
p2 &lt;- p1 %&gt;% add_locked_out_constraints(which(sim_pu_polygons$locked_out))

# create problem with added locked out constraints using a column name
p3 &lt;- p1 %&gt;% add_locked_out_constraints("locked_out")

# create problem with added locked out constraints using raster data
p4 &lt;- p1 %&gt;% add_locked_out_constraints(sim_locked_out_raster)

# create problem with added locked out constraints using spatial polygon data
locked_out &lt;- sim_pu_polygons[sim_pu_polygons$locked_out == 1, ]
p5 &lt;- p1 %&gt;% add_locked_out_constraints(locked_out)

# solve problems
s1 &lt;- solve(p1)
s2 &lt;- solve(p2)
s3 &lt;- solve(p3)
s4 &lt;- solve(p4)
s5 &lt;- solve(p5)

# create single object with all solutions
s6 &lt;- sf::st_sf(
  tibble::tibble(
    s1 = s1$solution_1,
    s2 = s2$solution_1,
    s3 = s3$solution_1,
    s4 = s4$solution_1,
    s5 = s5$solution_1
  ),
  geometry = sf::st_geometry(s1)
)

# plot solutions
plot(
  s6,
  main = c(
    "none locked out", "locked out (integer input)",
    "locked out (character input)", "locked out (raster input)",
    "locked out (polygon input)"
  )
)

# reset plot
par(mfrow = c(1, 1))

# create minimal multi-zone problem with spatial data
p7 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(matrix(rpois(15, 1), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create multi-zone problem with locked out constraints using matrix data
locked_matrix &lt;- as.matrix(sf::st_drop_geometry(
  sim_zones_pu_polygons[, c("locked_1", "locked_2", "locked_3")]
))

p8 &lt;- p7 %&gt;% add_locked_out_constraints(locked_matrix)

# solve problem
s8 &lt;- solve(p8)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s8$solution &lt;- category_vector(sf::st_drop_geometry(
  s8[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
))
s8$solution &lt;- factor(s8$solution)

# plot solution
plot(s8[, "solution"], main = "solution", axes = FALSE)

# create multi-zone problem with locked out constraints using column names
p9 &lt;-
  p7 %&gt;%
  add_locked_out_constraints(c("locked_1", "locked_2", "locked_3"))

# solve problem
s9 &lt;- solve(p9)

# create new column in s8 representing the zone id that each planning unit
# was allocated to in the solution
s9$solution &lt;- category_vector(sf::st_drop_geometry(
  s9[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
))
s9$solution[s9$solution == 1 &amp; s9$solution_1_zone_1 == 0] &lt;- 0
s9$solution &lt;- factor(s9$solution)

# plot solution
plot(s9[, "solution"], main = "solution", axes = FALSE)

# create multi-zone problem with raster planning units
p10 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(matrix(rpois(15, 1), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create multi-layer raster with locked out units
locked_out_raster &lt;- sim_zones_pu_raster[[1]]
locked_out_raster[!is.na(locked_out_raster)] &lt;- 0
locked_out_raster &lt;- locked_out_raster[[c(1, 1, 1)]]
names(locked_out_raster) &lt;- c("zones_1", "zones_2", "zones_3")
locked_out_raster[[1]][1] &lt;- 1
locked_out_raster[[2]][2] &lt;- 1
locked_out_raster[[3]][3] &lt;- 1

# plot locked out raster
plot(locked_out_raster)

# add locked out raster units to problem
p10 &lt;- p10 %&gt;% add_locked_out_constraints(locked_out_raster)

# solve problem
s10 &lt;- solve(p10)

# plot solution
plot(category_layer(s10), main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_loglinear_targets'>Add targets using log-linear scaling</h2><span id='topic+add_loglinear_targets'></span>

<h3>Description</h3>

<p>Add targets to a conservation planning problem by log-linearly
interpolating the targets between thresholds based on the total amount of
each feature in the study area (Rodrigues <em>et al.</em> 2004). Additionally,
caps can be applied to targets to prevent features with massive
distributions from being over-represented
in solutions (Butchart <em>et al.</em> 2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_loglinear_targets(
  x,
  lower_bound_amount,
  lower_bound_target,
  upper_bound_amount,
  upper_bound_target,
  cap_amount = NULL,
  cap_target = NULL,
  abundances = feature_abundances(x, na.rm = FALSE)$absolute_abundance
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_loglinear_targets_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_loglinear_targets_+3A_lower_bound_amount">lower_bound_amount</code></td>
<td>
<p><code>numeric</code> threshold.</p>
</td></tr>
<tr><td><code id="add_loglinear_targets_+3A_lower_bound_target">lower_bound_target</code></td>
<td>
<p><code>numeric</code> relative target that should be
applied to features with a total amount that is less
than or equal to <code>lower_bound_amount</code>.</p>
</td></tr>
<tr><td><code id="add_loglinear_targets_+3A_upper_bound_amount">upper_bound_amount</code></td>
<td>
<p><code>numeric</code> threshold.</p>
</td></tr>
<tr><td><code id="add_loglinear_targets_+3A_upper_bound_target">upper_bound_target</code></td>
<td>
<p><code>numeric</code> relative target that should be
applied to features with a total amount that is greater
than or equal to <code>upper_bound_amount</code>.</p>
</td></tr>
<tr><td><code id="add_loglinear_targets_+3A_cap_amount">cap_amount</code></td>
<td>
<p><code>numeric</code> total amount at which targets should be
capped. Defaults to <code>NULL</code> so that targets are not capped.</p>
</td></tr>
<tr><td><code id="add_loglinear_targets_+3A_cap_target">cap_target</code></td>
<td>
<p><code>numeric</code> amount-based target to apply to features
which have a total amount greater than argument to <code>cap_amount</code>.
Defaults to <code>NULL</code> so that targets are not capped.</p>
</td></tr>
<tr><td><code id="add_loglinear_targets_+3A_abundances">abundances</code></td>
<td>
<p><code>numeric</code> total amount of each feature to
use when calculating the targets. Defaults to the feature abundances in the
study area (calculated using the <code><a href="#topic+feature_abundances">feature_abundances()</a></code>) function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Targets are used to specify the minimum amount or proportion of a
feature's distribution that needs to be protected. All conservation
planning problems require adding targets with the exception of the maximum
cover problem (see <code><a href="#topic+add_max_cover_objective">add_max_cover_objective()</a></code>), which maximizes
all features in the solution and therefore does not require targets.
</p>
<p>Seven parameters are used to calculate the targets:
<code>lower_bound_amount</code> specifies the first range size threshold,
<code>lower_bound_target</code> specifies the relative target required for
species with a range size equal to or less than the first threshold,
<code>upper_bound_amount</code> specifies the second range size threshold,
<code>upper_bound_target</code> specifies the relative target required for
species with a range size equal to or greater than the second threshold,
<code>cap_amount</code> specifies the third range size threshold,
<code>cap_target</code> specifies the absolute target that is uniformly applied
to species with a range size larger than that third threshold, and finally
<code>abundances</code> specifies the range size for each feature
that should be used when calculating the targets.
</p>
<p>The target calculations do not account for the
size of each planning unit. Therefore, the feature data should account for
the size of each planning unit if this is important (e.g., pixel values in
the argument to <code>features</code> in the function <code><a href="#topic+problem">problem()</a></code> could
correspond to amount of land occupied by the feature in <code class="reqn">km^2</code> units).
Additionally, the function can only be applied to
<code><a href="#topic+problem">problem()</a></code> objects that are associated with a
single zone.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the targets added to it.
</p>


<h3>Notes</h3>

<p>Early versions (&lt; 5.0.2.4) used different equations for calculating
targets.
</p>


<h3>References</h3>

<p>Rodrigues ASL, Akcakaya HR, Andelman SJ, Bakarr MI, Boitani L, Brooks TM,
Chanson JS, Fishpool LDC, da Fonseca GAB, Gaston KJ, and others (2004)
Global gap analysis: priority regions for expanding the global
protected-area network. <em>BioScience</em>, 54: 1092&ndash;1100.
</p>
<p>Butchart SHM, Clarke M, Smith RJ, Sykes RE, Scharlemann JPW, Harfoot M,
Buchanan, GM, Angulo A, Balmford A, Bertzky B, and others (2015) Shortfalls
and solutions for meeting national and global conservation area targets.
<em>Conservation Letters</em>, 8: 329&ndash;337.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+targets">targets</a> for an overview of all functions for adding targets.
</p>
<p>Other targets: 
<code><a href="#topic+add_absolute_targets">add_absolute_targets</a>()</code>,
<code><a href="#topic+add_manual_targets">add_manual_targets</a>()</code>,
<code><a href="#topic+add_relative_targets">add_relative_targets</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create problem using loglinear targets
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_loglinear_targets(10, 0.9, 100, 0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s &lt;- solve(p)

# plot solution
plot(s, main = "solution", axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='add_lsymphony_solver'>Add a <em>SYMPHONY</em> solver with <em>lpsymphony</em></h2><span id='topic+add_lsymphony_solver'></span><span id='topic+add_lpsymphony_solver'></span>

<h3>Description</h3>

<p>Specify that the <a href="https://github.com/coin-or/SYMPHONY"><em>SYMPHONY</em></a>
software &ndash; using the <span class="pkg">lpsymphony</span> package &ndash;
should be used to solve a conservation planning problem
(Ralphs &amp; Güzelsoy 2005).
This function can also be used to customize the behavior of the solver.
It requires the <span class="pkg">lpsymphony</span> package to be installed
(see below for installation instructions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_lpsymphony_solver(
  x,
  gap = 0.1,
  time_limit = .Machine$integer.max,
  first_feasible = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_lsymphony_solver_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_lsymphony_solver_+3A_gap">gap</code></td>
<td>
<p><code>numeric</code> gap to optimality. This gap is relative
and expresses the acceptable deviance from the optimal objective.
For example, a value of 0.01 will result in the solver stopping when
it has found a solution within 1% of optimality.
Additionally, a value of 0 will result in the solver stopping
when it has found an optimal solution.
The default value is 0.1 (i.e., 10% from optimality).</p>
</td></tr>
<tr><td><code id="add_lsymphony_solver_+3A_time_limit">time_limit</code></td>
<td>
<p><code>numeric</code> time limit (seconds) for generating solutions.
The solver will return the current best solution when this time limit is
exceeded. The default value is the largest integer value
(i.e., <code>.Machine$integer.max</code>), effectively meaning that solver
will keep running until a solution within the optimality gap is found.</p>
</td></tr>
<tr><td><code id="add_lsymphony_solver_+3A_first_feasible">first_feasible</code></td>
<td>
<p><code>logical</code> should the first feasible solution be
be returned? If <code>first_feasible</code> is set to <code>TRUE</code>, the solver
will return the first solution it encounters that meets all the
constraints, regardless of solution quality. Note that the first feasible
solution is not an arbitrary solution, rather it is derived from the
relaxed solution, and is therefore often reasonably close to optimality.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_lsymphony_solver_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> should information be printed while solving
optimization problems? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://github.com/coin-or/SYMPHONY"><em>SYMPHONY</em></a> is an
open-source mixed integer programming solver that is part of the
Computational Infrastructure for Operations Research (COIN-OR) project.
This solver is provided because it may be easier to install
on some systems than the <span class="pkg">Rsymphony</span> package. Additionally &ndash;
although the <span class="pkg">lpsymphony</span> package doesn't provide the functionality
to specify the number of threads for solving a problem &ndash; the
<span class="pkg">lpsymphony</span> package will solve problems using parallel processing
(unlike the <span class="pkg">Rsymphony</span> package). As a consequence, this
solver will likely generate solutions much faster than the
<code><a href="#topic+add_rsymphony_solver">add_rsymphony_solver()</a></code>.
Although formal benchmarks examining the performance of this solver
have yet to be completed,
please see Schuster <em>et al.</em> (2020) for benchmarks comparing the
run time and solution quality of the <span class="pkg">Rsymphony</span> solver.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the solver added to it.
</p>


<h3>Installation</h3>

<p>The <span class="pkg">lpsymphony</span> package is
distributed through
<a href="https://doi.org/doi:10.18129/B9.bioc.lpsymphony">Bioconductor</a>.
To install the <span class="pkg">lpsymphony</span> package, please use the following code:
</p>
<div class="sourceCode"><pre>if (!require(remotes)) install.packages("remotes")
remotes::install_bioc("lpsymphony")
</pre></div>


<h3>References</h3>

<p>Ralphs TK and Güzelsoy M (2005) The SYMPHONY callable library for mixed
integer programming. In The Next Wave in Computing, Optimization, and
Decision Technologies (pp. 61&ndash;76). Springer, Boston, MA.
</p>
<p>Schuster R, Hanson JO, Strimas-Mackey M, and Bennett JR (2020). Exact
integer linear programming solvers outperform simulated annealing for
solving conservation planning problems. <em>PeerJ</em>, 8: e9258.
</p>


<h3>See Also</h3>

<p>Other solvers: 
<code><a href="#topic+add_cbc_solver">add_cbc_solver</a>()</code>,
<code><a href="#topic+add_cplex_solver">add_cplex_solver</a>()</code>,
<code><a href="#topic+add_default_solver">add_default_solver</a>()</code>,
<code><a href="#topic+add_gurobi_solver">add_gurobi_solver</a>()</code>,
<code><a href="#topic+add_highs_solver">add_highs_solver</a>()</code>,
<code><a href="#topic+add_rsymphony_solver">add_rsymphony_solver</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.05) %&gt;%
  add_proportion_decisions() %&gt;%
  add_lpsymphony_solver(time_limit = 5, verbose = FALSE)

# generate solution
s &lt;- solve(p)

# plot solution
plot(s, main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_mandatory_allocation_constraints'>Add mandatory allocation constraints</h2><span id='topic+add_mandatory_allocation_constraints'></span>

<h3>Description</h3>

<p>Add constraints to a conservation planning problem to ensure that every
planning unit is allocated to a
management zone in the solution. Note that this function can only be used
with problems that contain multiple zones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_mandatory_allocation_constraints(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_mandatory_allocation_constraints_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a conservation planning <code><a href="#topic+problem">problem()</a></code> with multiple
management zones, it may sometimes be desirable to obtain a solution that
assigns each and every planning unit to a zone. For example, when
developing land-use plans, some decision makers may require that
every parcel of land is allocated a specific land-use type.
In other words are no &quot;left over&quot; areas. Although it might seem tempting
to simply solve the problem and manually assign &quot;left over&quot; planning units
to a default zone afterwards (e.g., an &quot;other&quot;, &quot;urban&quot;, or &quot;grazing&quot;
land-use), this could result in highly sub-optimal solutions if there are
penalties for siting the default land-use adjacent to other zones.
Instead, this function can be used to specify that all planning units in a
problem with multiple zones must be allocated to a management zone (i.e.,
zone allocation is mandatory).
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the constraints added to it.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+constraints">constraints</a> for an overview of all functions for adding constraints.
</p>
<p>Other constraints: 
<code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_feature_contiguity_constraints">add_feature_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_linear_constraints">add_linear_constraints</a>()</code>,
<code><a href="#topic+add_locked_in_constraints">add_locked_in_constraints</a>()</code>,
<code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints</a>()</code>,
<code><a href="#topic+add_manual_bounded_constraints">add_manual_bounded_constraints</a>()</code>,
<code><a href="#topic+add_manual_locked_constraints">add_manual_locked_constraints</a>()</code>,
<code><a href="#topic+add_neighbor_constraints">add_neighbor_constraints</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create multi-zone problem with minimum set objective
targets_matrix &lt;- matrix(rpois(15, 1), nrow = 5, ncol = 3)

# create minimal problem with minimum set objective
p1 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(targets_matrix) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create another problem that is the same as p1, but has constraints
# to mandate that every planning unit in the solution is assigned to
# zone
p2 &lt;- p1 %&gt;% add_mandatory_allocation_constraints()

# solve problems
s1 &lt;- solve(p1)
s2 &lt;- solve(p2)

# convert solutions into category layers, where each pixel is assigned
 # value indicating which zone it was assigned to in the zone
c1 &lt;- category_layer(s1)
c2 &lt;- category_layer(s2)

# plot solution category layers
plot(c(c1, c2), main = c("default", "mandatory allocation"), axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_manual_bounded_constraints'>Add manually specified bound constraints</h2><span id='topic+add_manual_bounded_constraints'></span><span id='topic+add_manual_bounded_constraints+2CConservationProblem+2Cdata.frame-method'></span><span id='topic+add_manual_bounded_constraints+2CConservationProblem+2Ctbl_df-method'></span>

<h3>Description</h3>

<p>Add constraints to a conservation planning problem to ensure
that the planning unit values (e.g., proportion, binary) in a solution
range between specific lower and upper bounds. This function offers more
fine-grained control than the <code><a href="#topic+add_manual_locked_constraints">add_manual_locked_constraints()</a></code>
function and is is most useful for problems involving proportion-type
or semi-continuous decisions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_manual_bounded_constraints(x, data)

## S4 method for signature 'ConservationProblem,data.frame'
add_manual_bounded_constraints(x, data)

## S4 method for signature 'ConservationProblem,tbl_df'
add_manual_bounded_constraints(x, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_manual_bounded_constraints_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_manual_bounded_constraints_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> object.
See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the constraints added to it.
</p>


<h3>Data format</h3>

<p>The argument to <code>data</code> should be a <code>data.frame</code> with the following columns:
</p>

<dl>
<dt>pu</dt><dd><p><code>integer</code> planning unit identifier.</p>
</dd>
<dt>zone</dt><dd><p><code>character</code> names of zones. Note that this
argument is optional for arguments to <code>x</code> that contain a single
zone.</p>
</dd>
<dt>lower</dt><dd><p><code>numeric</code> values indicating the minimum
value that each planning unit can be allocated to in each zone
in the solution.</p>
</dd>
<dt>upper</dt><dd><p><code>numeric</code> values indicating the maximum
value that each planning unit can be allocated to in each zone
in the solution.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="#topic+constraints">constraints</a> for an overview of all functions for adding constraints.
</p>
<p>Other constraints: 
<code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_feature_contiguity_constraints">add_feature_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_linear_constraints">add_linear_constraints</a>()</code>,
<code><a href="#topic+add_locked_in_constraints">add_locked_in_constraints</a>()</code>,
<code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints</a>()</code>,
<code><a href="#topic+add_mandatory_allocation_constraints">add_mandatory_allocation_constraints</a>()</code>,
<code><a href="#topic+add_manual_locked_constraints">add_manual_locked_constraints</a>()</code>,
<code><a href="#topic+add_neighbor_constraints">add_neighbor_constraints</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem
p1 &lt;-
  problem(sim_pu_polygons, sim_features, "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with locked in constraints using add_locked_constraints
p2 &lt;- p1 %&gt;% add_locked_in_constraints("locked_in")

# create identical problem using add_manual_bounded_constraints
bounds_data &lt;- data.frame(
  pu = which(sim_pu_polygons$locked_in),
  lower = 1,
  upper = 1
)

p3 &lt;- p1 %&gt;% add_manual_bounded_constraints(bounds_data)

# solve problems
s1 &lt;- solve(p1)
s2 &lt;- solve(p2)
s3 &lt;- solve(p3)

# create object with all solutions
s4 &lt;- sf::st_sf(
  tibble::tibble(
    s1 = s1$solution_1,
    s2 = s2$solution_1,
    s3 = s3$solution_1
  ),
  geometry = sf::st_geometry(s1)
)

# plot solutions
## s1 = none locked in
## s2 = locked in constraints
## s3 = manual bounds constraints
plot(s4)

# create minimal problem with multiple zones
p5 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create data.frame with the following constraints:
# planning units 1, 2, and 3 must be allocated to zone 1 in the solution
# planning units 4, and 5 must be allocated to zone 2 in the solution
# planning units 8 and 9 must not be allocated to zone 3 in the solution
bounds_data2 &lt;- data.frame(
  pu = c(1, 2, 3, 4, 5, 8, 9),
  zone = c(rep("zone_1", 3), rep("zone_2", 2), rep("zone_3", 2)),
  lower = c(rep(1, 5), rep(0, 2)),
  upper = c(rep(1, 5), rep(0, 2))
)

# print bounds data
print(bounds_data2)

# create problem with added constraints
p6 &lt;- p5 %&gt;% add_manual_bounded_constraints(bounds_data2)

# solve problem
s5 &lt;- solve(p5)
s6 &lt;- solve(p6)

# create two new columns representing the zone id that each planning unit
# was allocated to in the two solutions
s5$solution &lt;- category_vector(sf::st_drop_geometry(
  s5[, c("solution_1_zone_1","solution_1_zone_2", "solution_1_zone_3")]
))
s5$solution &lt;- factor(s5$solution)

s5$solution_bounded &lt;- category_vector(sf::st_drop_geometry(
  s6[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
))
s5$solution_bounded &lt;- factor(s5$solution_bounded)

# plot solutions
plot(s5[, c("solution", "solution_bounded")], axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='add_manual_locked_constraints'>Add manually specified locked constraints</h2><span id='topic+add_manual_locked_constraints'></span><span id='topic+add_manual_locked_constraints+2CConservationProblem+2Cdata.frame-method'></span><span id='topic+add_manual_locked_constraints+2CConservationProblem+2Ctbl_df-method'></span>

<h3>Description</h3>

<p>Add constraints to a conservation planning problem to ensure
that solutions allocate (or do not allocate) specific planning units to
specific management zones. This function offers more fine-grained control
than the <code><a href="#topic+add_locked_in_constraints">add_locked_in_constraints()</a></code> and
<code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints()</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_manual_locked_constraints(x, data)

## S4 method for signature 'ConservationProblem,data.frame'
add_manual_locked_constraints(x, data)

## S4 method for signature 'ConservationProblem,tbl_df'
add_manual_locked_constraints(x, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_manual_locked_constraints_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_manual_locked_constraints_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> object.
See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the constraints added to it.
</p>


<h3>Data format</h3>

<p>The argument to <code>data</code> should be a <code>data.frame</code> with the following columns:
</p>

<dl>
<dt>pu</dt><dd><p><code>integer</code> planning unit identifier.</p>
</dd>
<dt>zone</dt><dd><p><code>character</code> names of zones. Note that this
argument is optional for arguments to <code>x</code> that contain a single
zone.</p>
</dd>
<dt>status</dt><dd><p><code>numeric</code> values indicating how much
of each planning unit should be allocated to each zone in the solution.
For example, the <code>numeric</code> values could be binary values (i.e., zero
or one) for problems containing binary-type decision variables
(using the <code><a href="#topic+add_binary_decisions">add_binary_decisions()</a></code> function). Alternatively,
the <code>numeric</code> values could be proportions (e.g., 0.5) for problems
containing proportion-type decision variables (using the
<code><a href="#topic+add_proportion_decisions">add_proportion_decisions()</a></code>).</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="#topic+constraints">constraints</a> for an overview of all functions for adding constraints.
</p>
<p>Other constraints: 
<code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_feature_contiguity_constraints">add_feature_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_linear_constraints">add_linear_constraints</a>()</code>,
<code><a href="#topic+add_locked_in_constraints">add_locked_in_constraints</a>()</code>,
<code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints</a>()</code>,
<code><a href="#topic+add_mandatory_allocation_constraints">add_mandatory_allocation_constraints</a>()</code>,
<code><a href="#topic+add_manual_bounded_constraints">add_manual_bounded_constraints</a>()</code>,
<code><a href="#topic+add_neighbor_constraints">add_neighbor_constraints</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem
p1 &lt;-
  problem(sim_pu_polygons, sim_features, "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with locked in constraints using add_locked_constraints
p2 &lt;- p1 %&gt;% add_locked_in_constraints("locked_in")

# create identical problem using add_manual_locked_constraints
locked_data &lt;- data.frame(
  pu = which(sim_pu_polygons$locked_in),
  status = 1
)

p3 &lt;- p1 %&gt;% add_manual_locked_constraints(locked_data)

# solve problems
s1 &lt;- solve(p1)
s2 &lt;- solve(p2)
s3 &lt;- solve(p3)

# create object with all solutions
s4 &lt;- sf::st_sf(
  tibble::tibble(
    s1 = s1$solution_1,
    s2 = s2$solution_1,
    s3 = s3$solution_1
  ),
  geometry = sf::st_geometry(s1)
)

# plot solutions
## s1 = none locked in
## s2 = locked in constraints
## s3 = manual locked constraints
plot(s4)

# create minimal problem with multiple zones
p5 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create data.frame with the following constraints:
# planning units 1, 2, and 3 must be allocated to zone 1 in the solution
# planning units 4, and 5 must be allocated to zone 2 in the solution
# planning units 8 and 9 must not be allocated to zone 3 in the solution
locked_data2 &lt;- data.frame(
  pu = c(1, 2, 3, 4, 5, 8, 9),
  zone = c(rep("zone_1", 3), rep("zone_2", 2),rep("zone_3", 2)),
  status = c(rep(1, 5), rep(0, 2))
)

# print locked constraint data
print(locked_data2)

# create problem with added constraints
p6 &lt;- p5 %&gt;% add_manual_locked_constraints(locked_data2)

# solve problem
s5 &lt;- solve(p5)
s6 &lt;- solve(p6)

# create two new columns representing the zone id that each planning unit
# was allocated to in the two solutions
s5$solution &lt;- category_vector(sf::st_drop_geometry(
  s5[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
))
s5$solution &lt;- factor(s5$solution)

s5$solution_locked &lt;- category_vector(sf::st_drop_geometry(
  s6[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
))
s5$solution_locked &lt;- factor(s5$solution_locked)

# plot solutions
plot(s5[, c("solution", "solution_locked")], axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='add_manual_targets'>Add manual targets</h2><span id='topic+add_manual_targets'></span><span id='topic+add_manual_targets-method'></span><span id='topic+add_manual_targets+2CConservationProblem+2Cdata.frame-method'></span><span id='topic+add_manual_targets+2CConservationProblem+2Ctbl_df-method'></span>

<h3>Description</h3>

<p>Set targets for a conservation planning problem by manually
specifying all the required information for each target. This function
is useful because it can be used to customize all aspects of a target. For
most cases, targets can be specified using the
<code><a href="#topic+add_absolute_targets">add_absolute_targets()</a></code> and <code><a href="#topic+add_relative_targets">add_relative_targets()</a></code>
functions. However, this function can be used to (i) mix absolute and
relative targets for different features and zones, (ii) set targets that
pertain to the allocations of planning units in multiple zones, and (iii)
set targets that require different senses (e.g., targets which specify the
solution should not exceed a certain quantity using <code>"&lt;="</code> values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_manual_targets(x, targets)

## S4 method for signature 'ConservationProblem,data.frame'
add_manual_targets(x, targets)

## S4 method for signature 'ConservationProblem,tbl_df'
add_manual_targets(x, targets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_manual_targets_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_manual_targets_+3A_targets">targets</code></td>
<td>
<p><code>data.frame</code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> object.
See the Targets format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Targets are used to specify the minimum amount or proportion of a
feature's distribution that needs to be protected. Most conservation
planning problems require targets with the exception of the maximum cover
(see <code><a href="#topic+add_max_cover_objective">add_max_cover_objective()</a></code>) and maximum utility
(see <code><a href="#topic+add_max_utility_objective">add_max_utility_objective()</a></code>) problems. Attempting to solve
problems with objectives that require targets without specifying targets
will throw an error.
</p>
<p>For problems associated with multiple management zones,
<code><a href="#topic+add_absolute_targets">add_absolute_targets()</a></code> can
be used to set targets that each pertain to a single feature and a single
zone. To set targets that can be met through allocating different
planning units to multiple zones, see the <code><a href="#topic+add_manual_targets">add_manual_targets()</a></code>
function. An example of a target that could be met through allocations
to multiple zones might be where each management zone is expected to
result in a different amount of a feature and the target requires that
the total amount of the feature in all zones must exceed a certain
threshold. In other words, the target does not require that any single
zone secure a specific amount of the feature, but the total amount held
in all zones must secure a specific amount. Thus the target could,
potentially, be met through allocating all planning units to any specific
management zone, or through allocating the planning units to different
combinations of management zones.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the targets added to it.
</p>


<h3>Targets format</h3>

<p>The <code>targets</code> argument should be a <code>data.frame</code> with the following
columns:
</p>

<dl>
<dt>feature</dt><dd><p><code>character</code> name of features in argument
to <code>x</code>.</p>
</dd>
<dt>zone</dt><dd><p><code>character</code> name of zones in the argument
<code>x</code>. It can also be a <code>list</code> of <code>character</code> vectors if
targets should correspond to multiple zones (see Examples section below).
This column is optional for arguments to <code>x</code>
that do not contain multiple zones.</p>
</dd>
<dt>type</dt><dd><p><code>character</code> describing the type of target.
Acceptable values include <code>"absolute"</code> and <code>"relative"</code>.
These values correspond to <code><a href="#topic+add_absolute_targets">add_absolute_targets()</a></code>,
and <code><a href="#topic+add_relative_targets">add_relative_targets()</a></code> respectively.</p>
</dd>
<dt>sense</dt><dd><p><code>character</code> sense of the target. Acceptable
values include: <code>"&gt;="</code>, <code>"&lt;="</code>, and <code>"="</code>. This
column is optional and if it is missing then target senses will
default to <code>"&gt;="</code> values.</p>
</dd>
<dt>target</dt><dd><p><code>numeric</code> target threshold.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="#topic+targets">targets</a> for an overview of all functions for adding targets.
</p>
<p>Other targets: 
<code><a href="#topic+add_absolute_targets">add_absolute_targets</a>()</code>,
<code><a href="#topic+add_loglinear_targets">add_loglinear_targets</a>()</code>,
<code><a href="#topic+add_relative_targets">add_relative_targets</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create problem with 10% relative targets
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# create equivalent problem using add_manual_targets
p2 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_manual_targets(
    data.frame(
      feature = names(sim_features),
      type = "relative", sense = "&gt;=",
      target = 0.1
    )
  ) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# plot solution
plot(s2, main = "solution", axes = FALSE)

# create problem with targets set for only a few features
p3 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_manual_targets(
    data.frame(
      feature = names(sim_features)[1:3],
      type = "relative",
      sense = "&gt;=",
      target = 0.1
    )
 ) %&gt;%
 add_binary_decisions() %&gt;%
 add_default_solver(verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# plot solution
plot(s3, main = "solution", axes = FALSE)

# create problem that aims to secure at least 10% of the habitat for one
# feature whilst ensuring that the solution does not capture more than
# 20 units habitat for different feature
# create problem with targets set for only a few features
p4 &lt;-
  problem(sim_pu_raster, sim_features[[1:2]]) %&gt;%
  add_min_set_objective() %&gt;%
  add_manual_targets(
    data.frame(
      feature = names(sim_features)[1:2],
      type = "relative",
      sense = c("&gt;=", "&lt;="),
      target = c(0.1, 0.2)
    )
  ) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s4 &lt;- solve(p4)

# plot solution
plot(s4, main = "solution", axes = FALSE)

# create a multi-zone problem that requires a specific amount of each
# feature in each zone
targets_matrix &lt;- matrix(rpois(15, 1), nrow = 5, ncol = 3)

p5 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(targets_matrix) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s5 &lt;- solve(p5)

# plot solution
plot(category_layer(s5), main = "solution", axes = FALSE)

# create equivalent problem using add_manual_targets
targets_dataframe &lt;- expand.grid(
  feature = feature_names(sim_zones_features),
  zone = zone_names(sim_zones_features),
  sense = "&gt;=",
  type = "absolute"
)
targets_dataframe$target &lt;- c(targets_matrix)

p6 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_manual_targets(targets_dataframe) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s6 &lt;- solve(p6)

# plot solution
plot(category_layer(s6), main = "solution", axes = FALSE)

# create a problem that requires a total of 20 units of habitat to be
# captured for two species. This can be achieved through representing
# habitat in two zones. The first zone represents a full restoration of the
# habitat and a second zone represents a partial restoration of the habitat
# Thus only half of the benefit that would have been gained from the full
# restoration is obtained when planning units are allocated a partial
# restoration

# create data
spp_zone1 &lt;- as.list(sim_zones_features)[[1]][[1:2]]
spp_zone2 &lt;- spp_zone1 * 0.5
costs &lt;- sim_zones_pu_raster[[1:2]]

# create targets
targets_dataframe2 &lt;- tibble::tibble(
  feature = names(spp_zone1),
  zone = list(c("z1", "z2"), c("z1", "z2")),
  sense = c("&gt;=", "&gt;="),
  type = c("absolute", "absolute"),
  target = c(20, 20)
)

# create problem
p7 &lt;-
  problem(
    costs,
    zones(
      spp_zone1, spp_zone2,
      feature_names = names(spp_zone1), zone_names = c("z1", "z2")
    )
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_manual_targets(targets_dataframe2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s7 &lt;- solve(p7)

# plot solution
plot(category_layer(s7), main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_max_cover_objective'>Add maximum coverage objective</h2><span id='topic+add_max_cover_objective'></span>

<h3>Description</h3>

<p>Set the objective of a conservation planning problem to
represent at least one instance of as many features as possible within a
given budget. This objective does not use targets, and feature
weights should be used instead to increase the representation of certain
features by a solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_max_cover_objective(x, budget)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_max_cover_objective_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_max_cover_objective_+3A_budget">budget</code></td>
<td>
<p><code>numeric</code> value specifying the maximum expenditure of
the prioritization. For problems with multiple zones, the argument
to <code>budget</code> can be a single <code>numeric</code> value to specify a budget
for the entire solution or a <code>numeric</code> vector to specify
a budget for each each management zone.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum coverage objective seeks to find the set of planning units that
maximizes the number of represented features, while keeping cost within a
fixed budget. Here, features are treated as being represented if
the reserve system contains at least a single instance of a feature
(i.e., an amount greater than 1). This formulation has often been
used in conservation planning problems dealing with binary biodiversity
data that indicate the presence/absence of suitable habitat
(e.g., Church &amp; Velle 1974). Additionally, weights can be used to favor the
representation of certain features over other features (see
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code>). Check out the
<code><a href="#topic+add_max_features_objective">add_max_features_objective()</a></code> for a more
generalized formulation which can accommodate user-specified representation
targets.
</p>


<h3>Value</h3>

<p>An updated <code>problem()</code> object with the objective added to it.
</p>


<h3>Mathematical formulation</h3>

<p>This objective is based on the maximum coverage reserve
selection problem (Church &amp; Velle 1974; Church <em>et al.</em> 1996).
The maximum coverage objective for the reserve design problem can be
expressed mathematically for a set of planning units (<code class="reqn">I</code> indexed by
<code class="reqn">i</code>) and a set of features (<code class="reqn">J</code> indexed by <code class="reqn">j</code>) as:
</p>
<p style="text-align: center;"><code class="reqn">\mathit{Maximize} \space \sum_{i = 1}^{I} -s \space c_i \space x_i +
\sum_{j = 1}^{J} y_j w_j \\
\mathit{subject \space to} \\
\sum_{i = 1}^{I} x_i r_{ij} \geq y_j \times 1 \forall j \in J \\
\sum_{i = 1}^{I} x_i c_i \leq B</code>
</p>

<p>Here, <code class="reqn">x_i</code> is the <a href="#topic+decisions">decisions</a> variable (e.g.,
specifying whether planning unit <code class="reqn">i</code> has been selected (1) or not
(0)), <code class="reqn">r_{ij}</code> is the amount of feature <code class="reqn">j</code> in planning
unit <code class="reqn">i</code>, <code class="reqn">y_j</code> indicates if the solution has meet
the target <code class="reqn">t_j</code> for feature <code class="reqn">j</code>, and <code class="reqn">w_j</code> is the
weight for feature <code class="reqn">j</code> (defaults to 1 for all features; see
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code> to specify weights). Additionally,
<code class="reqn">B</code> is the budget allocated for the solution, <code class="reqn">c_i</code> is the
cost of planning unit <code class="reqn">i</code>, and <code class="reqn">s</code> is a scaling factor used
to shrink the costs so that the problem will return a cheapest solution
when there are multiple solutions that represent the same amount of all
features within the budget.
</p>


<h3>Notes</h3>

<p>In early versions (&lt; 3.0.0.0), the mathematical formulation
underpinning this function was very different. Specifically,
as described above, the function now follows the formulations outlined in
Church <em>et al.</em> (1996). The old formulation is now provided by the
<code><a href="#topic+add_max_utility_objective">add_max_utility_objective()</a></code> function.
</p>


<h3>References</h3>

<p>Church RL and Velle CR (1974) The maximum covering location problem.
<em>Regional Science</em>, 32: 101&ndash;118.
</p>
<p>Church RL, Stoms DM, and Davis FW (1996) Reserve selection as a maximum
covering location problem. <em>Biological Conservation</em>, 76: 105&ndash;112.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+objectives">objectives</a> for an overview of all functions for adding objectives.
Also, see <code><a href="#topic+add_feature_weights">add_feature_weights()</a></code> to specify weights for different features.
</p>
<p>Other objectives: 
<code><a href="#topic+add_max_features_objective">add_max_features_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_div_objective">add_max_phylo_div_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_end_objective">add_max_phylo_end_objective</a>()</code>,
<code><a href="#topic+add_max_utility_objective">add_max_utility_objective</a>()</code>,
<code><a href="#topic+add_min_largest_shortfall_objective">add_min_largest_shortfall_objective</a>()</code>,
<code><a href="#topic+add_min_set_objective">add_min_set_objective</a>()</code>,
<code><a href="#topic+add_min_shortfall_objective">add_min_shortfall_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_features &lt;- get_sim_zones_features()

# threshold the feature data to generate binary biodiversity data
sim_binary_features &lt;- sim_features
thresholds &lt;- terra::global(
  sim_features, fun = quantile, probs = 0.5, na.rm = TRUE
)
for (i in seq_len(terra::nlyr(sim_features))) {
  sim_binary_features[[i]] &lt;- terra::as.int(
    sim_features[[i]] &gt; thresholds[[1]][[i]]
  )
}

# create problem with maximum cover objective
p1 &lt;-
  problem(sim_pu_raster, sim_binary_features) %&gt;%
  add_max_cover_objective(500) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# threshold the multi-zone feature data to generate binary biodiversity data
sim_binary_features_zones &lt;- sim_zones_features
for (z in seq_len(number_of_zones(sim_zones_features))) {
  thresholds &lt;- terra::global(
    sim_zones_features[[z]], fun = quantile, probs = 0.5, na.rm = TRUE
  )
  for (i in seq_len(number_of_features(sim_zones_features))) {
    sim_binary_features_zones[[z]][[i]] &lt;- terra::as.int(
      sim_zones_features[[z]][[i]] &gt; thresholds[[1]][[i]]
    )
  }
}

# create multi-zone problem with maximum cover objective that
# has a single budget for all zones
p2 &lt;-
  problem(sim_zones_pu_raster, sim_binary_features_zones) %&gt;%
  add_max_cover_objective(800) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# plot solution
plot(category_layer(s2), main = "solution", axes = FALSE)

# create multi-zone problem with maximum cover objective that
# has separate budgets for each zone
p3 &lt;-
  problem(sim_zones_pu_raster, sim_binary_features_zones) %&gt;%
  add_max_cover_objective(c(400, 400, 400)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# plot solution
plot(category_layer(s3), main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_max_features_objective'>Add maximum feature representation objective</h2><span id='topic+add_max_features_objective'></span>

<h3>Description</h3>

<p>Set the objective of a conservation planning problem to
fulfill as many targets as possible, whilst ensuring that the cost of the
solution does not exceed a budget.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_max_features_objective(x, budget)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_max_features_objective_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_max_features_objective_+3A_budget">budget</code></td>
<td>
<p><code>numeric</code> value specifying the maximum expenditure of
the prioritization. For problems with multiple zones, the argument
to <code>budget</code> can be (i) a single <code>numeric</code> value to specify a single budget
for the entire solution or (ii) a <code>numeric</code> vector to specify
a separate budget for each management zone.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum feature representation objective is an enhanced version of the
maximum coverage objective <code><a href="#topic+add_max_cover_objective">add_max_cover_objective()</a></code> because
targets can be used to ensure that a certain amount of each feature is
required in order for them to be adequately represented (similar to the
minimum set objective (see <code><a href="#topic+add_min_set_objective">add_min_set_objective()</a></code>). This
objective finds the set of planning units that meets representation targets
for as many features as possible while staying within a fixed budget
(inspired by Cabeza and Moilanen 2001). Additionally, weights can be used
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code>). If multiple solutions can meet the same
number of weighted targets while staying within budget, the cheapest
solution is returned.
</p>


<h3>Value</h3>

<p>An updated <code>problem()</code> object with the objective added to it.
</p>


<h3>Mathematical formulation</h3>

<p>This objective can be expressed mathematically for a set of planning units
(<code class="reqn">I</code> indexed by
<code class="reqn">i</code>) and a set of features (<code class="reqn">J</code> indexed by <code class="reqn">j</code>) as:
</p>
<p style="text-align: center;"><code class="reqn">\mathit{Maximize} \space \sum_{i = 1}^{I} -s \space c_i \space x_i +
\sum_{j = 1}^{J} y_j w_j \\
\mathit{subject \space to} \\
\sum_{i = 1}^{I} x_i r_{ij} \geq y_j t_j \forall j \in J \\
\sum_{i = 1}^{I} x_i c_i \leq B</code>
</p>

<p>Here, <code class="reqn">x_i</code> is the <a href="#topic+decisions">decisions</a> variable (e.g.,
specifying whether planning unit <code class="reqn">i</code> has been selected (1) or not
(0)), <code class="reqn">r_{ij}</code> is the amount of feature <code class="reqn">j</code> in planning
unit <code class="reqn">i</code>, <code class="reqn">t_j</code> is the representation target for feature
<code class="reqn">j</code>, <code class="reqn">y_j</code> indicates if the solution has meet
the target <code class="reqn">t_j</code> for feature <code class="reqn">j</code>, and <code class="reqn">w_j</code> is the
weight for feature <code class="reqn">j</code> (defaults to 1 for all features; see
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code> to specify weights). Additionally,
<code class="reqn">B</code> is the budget allocated for the solution, <code class="reqn">c_i</code> is the
cost of planning unit <code class="reqn">i</code>, and <code class="reqn">s</code> is a scaling factor used
to shrink the costs so that the problem will return a cheapest solution
when there are multiple solutions that represent the same amount of all
features within the budget.
</p>


<h3>References</h3>

<p>Cabeza M and Moilanen A (2001) Design of reserve networks and the
persistence of biodiversity. <em>Trends in Ecology &amp; Evolution</em>,
16: 242&ndash;248.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+objectives">objectives</a> for an overview of all functions for adding objectives.
Also, see <a href="#topic+targets">targets</a> for an overview of all functions for adding targets, and
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code> to specify weights for different features.
</p>
<p>Other objectives: 
<code><a href="#topic+add_max_cover_objective">add_max_cover_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_div_objective">add_max_phylo_div_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_end_objective">add_max_phylo_end_objective</a>()</code>,
<code><a href="#topic+add_max_utility_objective">add_max_utility_objective</a>()</code>,
<code><a href="#topic+add_min_largest_shortfall_objective">add_min_largest_shortfall_objective</a>()</code>,
<code><a href="#topic+add_min_set_objective">add_min_set_objective</a>()</code>,
<code><a href="#topic+add_min_shortfall_objective">add_min_shortfall_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create problem with maximum features objective
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_max_features_objective(1800) %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# create multi-zone problem with maximum features objective,
# with 10% representation targets for each feature, and set
# a budget such that the total maximum expenditure in all zones
# cannot exceed 3000
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_max_features_objective(3000) %&gt;%
  add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# plot solution
plot(category_layer(s2), main = "solution", axes = FALSE)

# create multi-zone problem with maximum features objective,
# with 10% representation targets for each feature, and set
# separate budgets for each management zone
p3 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_max_features_objective(c(3000, 3000, 3000)) %&gt;%
  add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# plot solution
plot(category_layer(s3), main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_max_phylo_div_objective'>Add maximum phylogenetic diversity objective</h2><span id='topic+add_max_phylo_div_objective'></span><span id='topic+add_max_phylo_objective'></span>

<h3>Description</h3>

<p>Set the objective of a conservation planning problem to
maximize the phylogenetic diversity of the features represented in the
solution subject to a budget. This objective is similar to
<code><a href="#topic+add_max_features_objective">add_max_features_objective()</a></code> except
that emphasis is placed on representing a phylogenetically diverse set of
species, rather than as many features as possible (subject to weights).
This function was inspired by Faith (1992) and Rodrigues <em>et al.</em>
(2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_max_phylo_div_objective(x, budget, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_max_phylo_div_objective_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_max_phylo_div_objective_+3A_budget">budget</code></td>
<td>
<p><code>numeric</code> value specifying the maximum expenditure of
the prioritization. For problems with multiple zones, the argument
to <code>budget</code> can be (i) a single <code>numeric</code> value to specify a single budget
for the entire solution or (ii) a <code>numeric</code> vector to specify
a separate budget for each management zone.</p>
</td></tr>
<tr><td><code id="add_max_phylo_div_objective_+3A_tree">tree</code></td>
<td>
<p><code><a href="ape.html#topic+read.tree">ape::phylo()</a></code> object specifying a phylogenetic tree
for the conservation features.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum phylogenetic diversity objective finds the set of
planning units that meets representation targets for a phylogenetic tree
while staying within a fixed budget. If multiple solutions can meet all
targets while staying within budget, the cheapest solution is chosen.
Note that this objective is similar to the maximum
features objective (<code><a href="#topic+add_max_features_objective">add_max_features_objective()</a></code>) in that it
allows for both a budget and targets to be set for each feature. However,
unlike the maximum feature objective, the aim of this objective is to
maximize the total phylogenetic diversity of the targets met in the
solution, so if multiple targets are provided for a single feature, the
problem will only need to meet a single target for that feature
for the phylogenetic benefit for that feature to be counted when
calculating the phylogenetic diversity of the solution. In other words,
for multi-zone problems, this objective does not aim to maximize the
phylogenetic diversity in each zone, but rather this objective
aims to maximize the phylogenetic diversity of targets that can be met
through allocating planning units to any of the different zones in a
problem. This can be useful for problems where targets pertain to the total
amount held for each feature across multiple zones. For example,
each feature might have a non-zero amount of suitable habitat in each
planning unit when the planning units are assigned to a (i) not restored,
(ii) partially restored, or (iii) completely restored management zone.
Here each target corresponds to a single feature and can be met through
the total amount of habitat in planning units present to the three
zones.
</p>


<h3>Value</h3>

<p>An updated <code>problem()</code> object with the objective added to it.
</p>


<h3>Mathematical formulation</h3>

<p>This objective can be expressed mathematically for a set of planning units
(<code class="reqn">I</code> indexed by <code class="reqn">i</code>) and a set of features (<code class="reqn">J</code>
indexed by <code class="reqn">j</code>) as:
</p>
<p style="text-align: center;"><code class="reqn">\mathit{Maximize} \space \sum_{i = 1}^{I} -s \space c_i \space x_i +
\sum_{j = 1}^{J} m_b l_b \\
\mathit{subject \space to} \\
\sum_{i = 1}^{I} x_i r_{ij} \geq y_j t_j \forall j \in J \\
m_b \leq y_j \forall j \in T(b) \\
\sum_{i = 1}^{I} x_i c_i \leq B</code>
</p>

<p>Here, <code class="reqn">x_i</code> is the <a href="#topic+decisions">decisions</a> variable (e.g.,
specifying whether planning unit <code class="reqn">i</code> has been selected (1) or not
(0)), <code class="reqn">r_{ij}</code> is the amount of feature <code class="reqn">j</code> in planning
unit <code class="reqn">i</code>, <code class="reqn">t_j</code> is the representation target for feature
<code class="reqn">j</code>, <code class="reqn">y_j</code> indicates if the solution has meet
the target <code class="reqn">t_j</code> for feature <code class="reqn">j</code>. Additionally,
<code class="reqn">T</code> represents a phylogenetic tree containing features <code class="reqn">j</code>
and has the branches <code class="reqn">b</code> associated within lengths <code class="reqn">l_b</code>.
The binary variable <code class="reqn">m_b</code> denotes if
at least one feature associated with the branch <code class="reqn">b</code> has met its
representation as indicated by <code class="reqn">y_j</code>. For brevity, we denote
the features <code class="reqn">j</code> associated with branch <code class="reqn">b</code> using
<code class="reqn">T(b)</code>. Finally, <code class="reqn">B</code> is the budget allocated for the
solution, <code class="reqn">c_i</code> is the cost of planning unit <code class="reqn">i</code>, and
<code class="reqn">s</code> is a scaling factor used to shrink the costs so that the problem
will return a cheapest solution when there are multiple solutions that
represent the same amount of all features within the budget.
</p>


<h3>Notes</h3>

<p>In early versions, this function was named as the
<code>add_max_phylo_div_objective</code> function.
</p>


<h3>References</h3>

<p>Faith DP (1992) Conservation evaluation and phylogenetic diversity.
<em>Biological Conservation</em>, 61: 1&ndash;10.
</p>
<p>Rodrigues ASL and Gaston KJ (2002) Maximising phylogenetic diversity in the
selection of networks of conservation areas. <em>Biological Conservation</em>,
105: 103&ndash;111.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+objectives">objectives</a> for an overview of all functions for adding objectives.
Also, see <a href="#topic+targets">targets</a> for an overview of all functions for adding targets, and
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code> to specify weights for different features.
</p>
<p>Other objectives: 
<code><a href="#topic+add_max_cover_objective">add_max_cover_objective</a>()</code>,
<code><a href="#topic+add_max_features_objective">add_max_features_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_end_objective">add_max_phylo_end_objective</a>()</code>,
<code><a href="#topic+add_max_utility_objective">add_max_utility_objective</a>()</code>,
<code><a href="#topic+add_min_largest_shortfall_objective">add_min_largest_shortfall_objective</a>()</code>,
<code><a href="#topic+add_min_set_objective">add_min_set_objective</a>()</code>,
<code><a href="#topic+add_min_shortfall_objective">add_min_shortfall_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load ape package
require(ape)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_phylogeny &lt;- get_sim_phylogeny()
sim_zones_pu_raster  &lt;- get_sim_zones_pu_raster()
sim_zones_features  &lt;- get_sim_zones_features()

# plot the simulated phylogeny
par(mfrow = c(1, 1))
plot(sim_phylogeny, main = "phylogeny")

# create problem with a maximum phylogenetic diversity objective,
# where each feature needs 10% of its distribution to be secured for
# it to be adequately conserved and a total budget of 1900
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_max_phylo_div_objective(1900, sim_phylogeny) %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# find out which features have their targets met
r1 &lt;- eval_target_coverage_summary(p1, s1)
print(r1, width = Inf)

# plot the phylogeny and color the adequately represented features in red
plot(
  sim_phylogeny, main = "adequately represented features",
  tip.color = replace(
    rep("black", terra::nlyr(sim_features)),
    sim_phylogeny$tip.label %in% r1$feature[r1$met], "red"
  )
)

# rename the features in the example phylogeny for use with the
# multi-zone data
sim_phylogeny$tip.label &lt;- feature_names(sim_zones_features)

# create targets for a multi-zone problem. Here, each feature needs a total
# of 10 units of habitat to be conserved among the three zones to be
# considered adequately conserved
targets &lt;- tibble::tibble(
  feature = feature_names(sim_zones_features),
  zone = list(zone_names(sim_zones_features))[
    rep(1, number_of_features(sim_zones_features))],
  type = rep("absolute", number_of_features(sim_zones_features)),
  target = rep(10, number_of_features(sim_zones_features))
)

# create a multi-zone problem with a maximum phylogenetic diversity
# objective, where the total expenditure in all zones is 5000.
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_max_phylo_div_objective(5000, sim_phylogeny) %&gt;%
  add_manual_targets(targets) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# plot solution
plot(category_layer(s2), main = "solution", axes = FALSE)

# find out which features have their targets met
r2 &lt;- eval_target_coverage_summary(p2, s2)
print(r2, width = Inf)

# plot the phylogeny and color the adequately represented features in red
plot(
  sim_phylogeny, main = "adequately represented features",
  tip.color = replace(
    rep("black", terra::nlyr(sim_features)), which(r2$met), "red"
  )
)

# create a multi-zone problem with a maximum phylogenetic diversity
# objective, where each zone has a separate budget.
p3 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_max_phylo_div_objective(c(2500, 500, 2000), sim_phylogeny) %&gt;%
  add_manual_targets(targets) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# plot solution
plot(category_layer(s3), main = "solution", axes = FALSE)

# find out which features have their targets met
r3 &lt;- eval_target_coverage_summary(p3, s3)
print(r3, width = Inf)

# plot the phylogeny and color the adequately represented features in red
plot(
  sim_phylogeny, main = "adequately represented features",
  tip.color = replace(
    rep("black", terra::nlyr(sim_features)), which(r3$met), "red"
  )
)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_max_phylo_end_objective'>Add maximum phylogenetic endemism objective</h2><span id='topic+add_max_phylo_end_objective'></span>

<h3>Description</h3>

<p>Set the objective of a conservation planning problem to
maximize the phylogenetic endemism of the features represented in the
solution subject to a budget. This objective is similar to
<code><a href="#topic+add_max_phylo_div_objective">add_max_phylo_div_objective()</a></code> except
that emphasis is placed on representing species with geographically
restricted evolutionary histories, instead representing as much evolutionary
history as possible. This function was inspired by Faith (1992),
Rodrigues <em>et al.</em> (2002), and Rosauer <em>et al.</em> (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_max_phylo_end_objective(x, budget, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_max_phylo_end_objective_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_max_phylo_end_objective_+3A_budget">budget</code></td>
<td>
<p><code>numeric</code> value specifying the maximum expenditure of
the prioritization. For problems with multiple zones, the argument
to <code>budget</code> can be (i) a single <code>numeric</code> value to specify a single budget
for the entire solution or (ii) a <code>numeric</code> vector to specify
a separate budget for each management zone.</p>
</td></tr>
<tr><td><code id="add_max_phylo_end_objective_+3A_tree">tree</code></td>
<td>
<p><code><a href="ape.html#topic+read.tree">ape::phylo()</a></code> object specifying a phylogenetic tree
for the conservation features.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum phylogenetic endemism objective finds the set of
planning units that meets representation targets for a phylogenetic tree
while staying within a fixed budget. If multiple solutions can meet all
targets while staying within budget, the cheapest solution is chosen.
Note that this objective is similar to the maximum
features objective (<code><a href="#topic+add_max_features_objective">add_max_features_objective()</a></code>) in that it
allows for both a budget and targets to be set for each feature. However,
unlike the maximum feature objective, the aim of this objective is to
maximize the total phylogenetic endemism of the targets met in the
solution, so if multiple targets are provided for a single feature, the
problem will only need to meet a single target for that feature
for the phylogenetic benefit for that feature to be counted when
calculating the phylogenetic endemism of the solution. In other words,
for multi-zone problems, this objective does not aim to maximize the
phylogenetic endemism in each zone, but rather this objective
aims to maximize the phylogenetic endemism of targets that can be met
through allocating planning units to any of the different zones in a
problem. This can be useful for problems where targets pertain to the total
amount held for each feature across multiple zones. For example,
each feature might have a non-zero amount of suitable habitat in each
planning unit when the planning units are assigned to a (i) not restored,
(ii) partially restored, or (iii) completely restored management zone.
Here each target corresponds to a single feature and can be met through
the total amount of habitat in planning units present to the three
zones.
</p>


<h3>Value</h3>

<p>An updated <code>problem()</code> object with the objective added to it.
</p>


<h3>Mathematical formulation</h3>

<p>This objective can be expressed mathematically for a set of planning units
(<code class="reqn">I</code> indexed by <code class="reqn">i</code>) and a set of features (<code class="reqn">J</code>
indexed by <code class="reqn">j</code>) as:
</p>
<p style="text-align: center;"><code class="reqn">\mathit{Maximize} \space \sum_{i = 1}^{I} -s \space c_i \space x_i +
\sum_{j = 1}^{J} m_b l_b \frac{1}{a_b} \\
\mathit{subject \space to} \\
\sum_{i = 1}^{I} x_i r_{ij} \geq y_j t_j \forall j \in J \\
m_b \leq y_j \forall j \in T(b) \\
\sum_{i = 1}^{I} x_i c_i \leq B</code>
</p>

<p>Here, <code class="reqn">x_i</code> is the <a href="#topic+decisions">decisions</a> variable (e.g.,
specifying whether planning unit <code class="reqn">i</code> has been selected (1) or not
(0)), <code class="reqn">r_{ij}</code> is the amount of feature <code class="reqn">j</code> in planning
unit <code class="reqn">i</code>, <code class="reqn">t_j</code> is the representation target for feature
<code class="reqn">j</code>, <code class="reqn">y_j</code> indicates if the solution has meet
the target <code class="reqn">t_j</code> for feature <code class="reqn">j</code>. Additionally,
<code class="reqn">T</code> represents a phylogenetic tree containing features <code class="reqn">j</code>
and has the branches <code class="reqn">b</code> associated within lengths <code class="reqn">l_b</code>.
Each branch <code class="reqn">b \in B</code> is associated with a total amount
<code class="reqn">a_b</code> indicating the total geographic extent or amount of habitat.
The <code class="reqn">a_b</code> variable for a given branch is calculated by summing the
<code class="reqn">r_{ij}</code> data for all features <code class="reqn">j \in J</code> that are
associated with the branch. The binary variable <code class="reqn">m_b</code> denotes if
at least one feature associated with the branch <code class="reqn">b</code> has met its
representation as indicated by <code class="reqn">y_j</code>. For brevity, we denote
the features <code class="reqn">j</code> associated with branch <code class="reqn">b</code> using
<code class="reqn">T(b)</code>. Finally, <code class="reqn">B</code> is the budget allocated for the
solution, <code class="reqn">c_i</code> is the cost of planning unit <code class="reqn">i</code>, and
<code class="reqn">s</code> is a scaling factor used to shrink the costs so that the problem
will return a cheapest solution when there are multiple solutions that
represent the same amount of all features within the budget.
</p>


<h3>References</h3>

<p>Faith DP (1992) Conservation evaluation and phylogenetic diversity.
<em>Biological Conservation</em>, 61: 1&ndash;10.
</p>
<p>Rodrigues ASL and Gaston KJ (2002) Maximising phylogenetic diversity in the
selection of networks of conservation areas. <em>Biological Conservation</em>,
105: 103&ndash;111.
</p>
<p>Rosauer D, Laffan SW, Crisp, MD, Donnellan SC and Cook LG (2009)
Phylogenetic endemism: a new approach for identifying geographical
concentrations of evolutionary history. <em>Molecular Ecology</em>, 18:
4061&ndash;4072.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+objectives">objectives</a> for an overview of all functions for adding objectives.
Also, see <a href="#topic+targets">targets</a> for an overview of all functions for adding targets, and
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code> to specify weights for different features.
</p>
<p>Other objectives: 
<code><a href="#topic+add_max_cover_objective">add_max_cover_objective</a>()</code>,
<code><a href="#topic+add_max_features_objective">add_max_features_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_div_objective">add_max_phylo_div_objective</a>()</code>,
<code><a href="#topic+add_max_utility_objective">add_max_utility_objective</a>()</code>,
<code><a href="#topic+add_min_largest_shortfall_objective">add_min_largest_shortfall_objective</a>()</code>,
<code><a href="#topic+add_min_set_objective">add_min_set_objective</a>()</code>,
<code><a href="#topic+add_min_shortfall_objective">add_min_shortfall_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load ape package
require(ape)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_phylogeny &lt;- get_sim_phylogeny()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# plot the simulated phylogeny
par(mfrow = c(1, 1))
plot(sim_phylogeny, main = "phylogeny")

# create problem with a maximum phylogenetic endemism objective,
# where each feature needs 10% of its distribution to be secured for
# it to be adequately conserved and a total budget of 1900
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_max_phylo_end_objective(1900, sim_phylogeny) %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# find out which features have their targets met
r1 &lt;- eval_target_coverage_summary(p1, s1)
print(r1, width = Inf)

# plot the phylogeny and color the adequately represented features in red
plot(
  sim_phylogeny, main = "adequately represented features",
  tip.color = replace(
    rep("black", terra::nlyr(sim_features)),
    sim_phylogeny$tip.label %in% r1$feature[r1$met],
    "red"
  )
)

# rename the features in the example phylogeny for use with the
# multi-zone data
sim_phylogeny$tip.label &lt;- feature_names(sim_zones_features)

# create targets for a multi-zone problem. Here, each feature needs a total
# of 10 units of habitat to be conserved among the three zones to be
# considered adequately conserved
targets &lt;- tibble::tibble(
  feature = feature_names(sim_zones_features),
  zone = list(zone_names(sim_zones_features))[
    rep(1, number_of_features(sim_zones_features))],
  type = rep("absolute", number_of_features(sim_zones_features)),
  target = rep(10, number_of_features(sim_zones_features))
)

# create a multi-zone problem with a maximum phylogenetic endemism
# objective, where the total expenditure in all zones is 5000.
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_max_phylo_end_objective(5000, sim_phylogeny) %&gt;%
  add_manual_targets(targets) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# plot solution
plot(category_layer(s2), main = "solution", axes = FALSE)

# find out which features have their targets met
r2 &lt;- eval_target_coverage_summary(p2, s2)
print(r2, width = Inf)

# plot the phylogeny and color the adequately represented features in red
plot(
  sim_phylogeny, main = "adequately represented features",
  tip.color = replace(
    rep("black", terra::nlyr(sim_features)), which(r2$met), "red"
  )
)

# create a multi-zone problem with a maximum phylogenetic endemism
# objective, where each zone has a separate budget.
p3 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_max_phylo_end_objective(c(2500, 500, 2000), sim_phylogeny) %&gt;%
  add_manual_targets(targets) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# plot solution
plot(category_layer(s3), main = "solution", axes = FALSE)

# find out which features have their targets met
r3 &lt;- eval_target_coverage_summary(p3, s3)
print(r3, width = Inf)

# plot the phylogeny and color the adequately represented features in red
plot(
  sim_phylogeny, main = "adequately represented features",
  tip.color = replace(
    rep("black", terra::nlyr(sim_features)), which(r3$met), "red"
  )
)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_max_utility_objective'>Add maximum utility objective</h2><span id='topic+add_max_utility_objective'></span>

<h3>Description</h3>

<p>Set the objective of a conservation planning problem to
secure as much of the features as possible without exceeding a budget.
This objective does not use targets, and feature
weights should be used instead to increase the representation of certain
features by a solution.
Note that this objective does not aim to maximize as much of each feature as
possible, and so often results in solutions that are heavily biased towards
just a few features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_max_utility_objective(x, budget)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_max_utility_objective_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_max_utility_objective_+3A_budget">budget</code></td>
<td>
<p><code>numeric</code> value specifying the maximum expenditure of
the prioritization. For problems with multiple zones, the argument
to <code>budget</code> can be (i) a single <code>numeric</code> value to specify a single budget
for the entire solution or (ii) a <code>numeric</code> vector to specify
a separate budget for each management zone.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum utility objective seeks to maximize the overall level of
representation across a suite of conservation features, while keeping cost
within a fixed budget.
Additionally, weights can be used to favor the
representation of certain features over other features (see
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code>). It is essentially calculated as a weighted
sum of the feature data inside the selected planning units.
</p>


<h3>Value</h3>

<p>An updated <code>problem()</code> object with the objective added to it.
</p>


<h3>Mathematical formulation</h3>

<p>This objective can be expressed mathematically for a set of planning units
(<code class="reqn">I</code> indexed by <code class="reqn">i</code>) and a set of features (<code class="reqn">J</code> indexed
by <code class="reqn">j</code>) as:
</p>
<p style="text-align: center;"><code class="reqn">\mathit{Maximize} \space \sum_{i = 1}^{I} -s \space c_i \space x_i +
\sum_{j = 1}^{J} a_j w_j \\
\mathit{subject \space to} \\ a_j = \sum_{i = 1}^{I} x_i r_{ij} \space
\forall j \in J \\ \sum_{i = 1}^{I} x_i c_i \leq B</code>
</p>

<p>Here, <code class="reqn">x_i</code> is the <a href="#topic+decisions">decisions</a> variable (e.g.,
specifying whether planning unit <code class="reqn">i</code> has been selected (1) or not
(0)), <code class="reqn">r_{ij}</code> is the amount of feature <code class="reqn">j</code> in planning
unit <code class="reqn">i</code>, <code class="reqn">A_j</code> is the amount of feature <code class="reqn">j</code>
represented in in the solution, and <code class="reqn">w_j</code> is the weight for
feature <code class="reqn">j</code> (defaults to 1 for all features; see
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code>
to specify weights). Additionally, <code class="reqn">B</code> is the budget allocated for
the solution, <code class="reqn">c_i</code> is the cost of planning unit <code class="reqn">i</code>, and
<code class="reqn">s</code> is a scaling factor used to shrink the costs so that the problem
will return a cheapest solution when there are multiple solutions that
represent the same amount of all features within the budget.
</p>


<h3>Notes</h3>

<p>In early versions (&lt; 3.0.0.0), this function was named as
the <code>add_max_cover_objective</code> function. It was renamed to avoid
confusion with existing terminology.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+objectives">objectives</a> for an overview of all functions for adding objectives.
Also, see <code><a href="#topic+add_feature_weights">add_feature_weights()</a></code> to specify weights for different features.
</p>
<p>Other objectives: 
<code><a href="#topic+add_max_cover_objective">add_max_cover_objective</a>()</code>,
<code><a href="#topic+add_max_features_objective">add_max_features_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_div_objective">add_max_phylo_div_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_end_objective">add_max_phylo_end_objective</a>()</code>,
<code><a href="#topic+add_min_largest_shortfall_objective">add_min_largest_shortfall_objective</a>()</code>,
<code><a href="#topic+add_min_set_objective">add_min_set_objective</a>()</code>,
<code><a href="#topic+add_min_shortfall_objective">add_min_shortfall_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create problem with maximum utility objective
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_max_utility_objective(5000) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# create multi-zone problem with maximum utility objective that
# has a single budget for all zones
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_max_utility_objective(5000) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# plot solution
plot(category_layer(s2), main = "solution", axes = FALSE)

# create multi-zone problem with maximum utility objective that
# has separate budgets for each zone
p3 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_max_utility_objective(c(1000, 2000, 3000)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# plot solution
plot(category_layer(s3), main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_min_largest_shortfall_objective'>Add minimum largest shortfall objective</h2><span id='topic+add_min_largest_shortfall_objective'></span>

<h3>Description</h3>

<p>Set the objective of a conservation planning problem to
minimize the largest target shortfall while ensuring that
the cost of the solution does not exceed a budget. Note that if the
target shortfall for a single feature cannot be decreased beyond a certain
point (e.g., because all remaining planning units occupied by that feature
are too costly or are locked out), then solutions may only use a small
proportion of the specified budget.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_min_largest_shortfall_objective(x, budget)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_min_largest_shortfall_objective_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_min_largest_shortfall_objective_+3A_budget">budget</code></td>
<td>
<p><code>numeric</code> value specifying the maximum expenditure of
the prioritization. For problems with multiple zones, the argument
to <code>budget</code> can be (i) a single <code>numeric</code> value to specify a single budget
for the entire solution or (ii) a <code>numeric</code> vector to specify
a separate budget for each management zone.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimum largest shortfall objective aims to
find the set of planning units that minimize the largest
shortfall for any of the representation targets&mdash;that is, the fraction of
each target that remains unmet&mdash;for as many features as possible while
staying within a fixed budget. This objective is different from the
minimum shortfall objective (<code><a href="#topic+add_min_shortfall_objective">add_min_shortfall_objective()</a></code>) because this
objective minimizes the largest (maximum) target shortfall,
whereas the minimum shortfall objective
minimizes the total (weighted sum) of the target shortfalls.
Note that this objective function is not compatible with feature weights
(<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code>).
</p>


<h3>Value</h3>

<p>An updated <code>problem()</code> object with the objective added to it.
</p>


<h3>Mathematical formulation</h3>

<p>This objective can be expressed mathematically for a set of planning units
(<code class="reqn">I</code> indexed by <code class="reqn">i</code>) and a set of features (<code class="reqn">J</code>
indexed by <code class="reqn">j</code>) as:
</p>
<p style="text-align: center;"><code class="reqn">\mathit{Minimize} \space l \\
\mathit{subject \space to} \\
\sum_{i = 1}^{I} x_i r_{ij} + y_j \geq t_j \forall j \in J \\
l \geq \frac{y_j}{t_j} \forall j \in J \\
\sum_{i = 1}^{I} x_i c_i \leq B</code>
</p>

<p>Here, <code class="reqn">x_i</code> is the <a href="#topic+decisions">decisions</a> variable (e.g.,
specifying whether planning unit <code class="reqn">i</code> has been selected (1) or not
(0)), <code class="reqn">r_{ij}</code> is the amount of feature <code class="reqn">j</code> in planning
unit <code class="reqn">i</code>, and <code class="reqn">t_j</code> is the representation target for feature
<code class="reqn">j</code>.
Additionally, <code class="reqn">y_j</code> denotes the target shortfall for
the target <code class="reqn">t_j</code> for feature <code class="reqn">j</code>, and
<code class="reqn">l</code> denotes the largest target shortfall.
Furthermore, <code class="reqn">B</code> is the budget allocated for the solution,
<code class="reqn">c_i</code> is the cost of planning unit <code class="reqn">i</code>. Note that
<code class="reqn">y_j</code> and <code class="reqn">s</code> are continuous variables bounded between zero
and infinity.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+objectives">objectives</a> for an overview of all functions for adding objectives.
Also, see <a href="#topic+targets">targets</a> for an overview of all functions for adding targets, and
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code> to specify weights for different features.
</p>
<p>Other objectives: 
<code><a href="#topic+add_max_cover_objective">add_max_cover_objective</a>()</code>,
<code><a href="#topic+add_max_features_objective">add_max_features_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_div_objective">add_max_phylo_div_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_end_objective">add_max_phylo_end_objective</a>()</code>,
<code><a href="#topic+add_max_utility_objective">add_max_utility_objective</a>()</code>,
<code><a href="#topic+add_min_set_objective">add_min_set_objective</a>()</code>,
<code><a href="#topic+add_min_shortfall_objective">add_min_shortfall_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create problem with minimum largest shortfall objective
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_largest_shortfall_objective(1800) %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# create multi-zone problem with minimum largest shortfall objective,
# with 10% representation targets for each feature, and set
# a budget such that the total maximum expenditure in all zones
# cannot exceed 1800
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_largest_shortfall_objective(1800) %&gt;%
  add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# plot solution
plot(category_layer(s2), main = "solution", axes = FALSE)

# create multi-zone problem with minimum largest shortfall objective,
# with 10% representation targets for each feature, and set
# separate budgets of 1800 for each management zone
p3 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_largest_shortfall_objective(c(1800, 1800, 1800)) %&gt;%
  add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# plot solution
plot(category_layer(s3), main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_min_set_objective'>Add minimum set objective</h2><span id='topic+add_min_set_objective'></span>

<h3>Description</h3>

<p>Set the objective of a conservation planning problem to
minimize the cost of the solution whilst ensuring that all <a href="#topic+targets">targets</a> are met.
This objective is similar to that used in
<em>Marxan</em> and is detailed in Rodrigues <em>et al.</em> (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_min_set_objective(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_min_set_objective_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimum set objective &ndash; in the the context of systematic reserve
design &ndash;  seeks to find the set of planning units that minimizes the
overall cost of a reserve network, while meeting a set of representation
targets for the conservation features. This objective is equivalent to a
simplified <em>Marxan</em> reserve design problem with the Boundary Length Modifier
(BLM) set to zero. The difference between this objective and the
<em>Marxan</em> software is that the targets for the features will always be met
(and as such it does not use Species Penalty Factors).
</p>


<h3>Value</h3>

<p>An updated <code>problem()</code> object with the objective added to it.
</p>


<h3>Mathematical formulation</h3>

<p>This objective can be expressed
mathematically for a set of planning units (<code class="reqn">I</code> indexed by
<code class="reqn">i</code>) and a set of features (<code class="reqn">J</code> indexed by <code class="reqn">j</code>) as:
</p>
<p style="text-align: center;"><code class="reqn">\mathit{Minimize} \space \sum_{i = 1}^{I} x_i c_i \\
\mathit{subject \space to} \\
\sum_{i = 1}^{I} x_i r_{ij} \geq T_j \space \forall \space j \in J</code>
</p>

<p>Here, <code class="reqn">x_i</code> is the <a href="#topic+decisions">decisions</a> variable (e.g.,
specifying whether planning unit <code class="reqn">i</code> has been selected (1) or not
(0)), <code class="reqn">c_i</code> is the cost of planning unit <code class="reqn">i</code>,
<code class="reqn">r_{ij}</code> is the amount of feature <code class="reqn">j</code> in planning unit
<code class="reqn">i</code>, and <code class="reqn">T_j</code> is the target for feature <code class="reqn">j</code>. The
first term is the objective function and the second is the set of
constraints. In words this says find the set of planning units that meets
all the representation targets while minimizing the overall cost.
</p>


<h3>References</h3>

<p>Rodrigues AS, Cerdeira OJ, and Gaston KJ (2000) Flexibility,
efficiency, and accountability: adapting reserve selection algorithms to
more complex conservation problems. <em>Ecography</em>, 23: 565&ndash;574.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+objectives">objectives</a> for an overview of all functions for adding objectives.
Also see <a href="#topic+targets">targets</a> for an overview of all functions for adding targets.
</p>
<p>Other objectives: 
<code><a href="#topic+add_max_cover_objective">add_max_cover_objective</a>()</code>,
<code><a href="#topic+add_max_features_objective">add_max_features_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_div_objective">add_max_phylo_div_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_end_objective">add_max_phylo_end_objective</a>()</code>,
<code><a href="#topic+add_max_utility_objective">add_max_utility_objective</a>()</code>,
<code><a href="#topic+add_min_largest_shortfall_objective">add_min_largest_shortfall_objective</a>()</code>,
<code><a href="#topic+add_min_shortfall_objective">add_min_shortfall_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem with minimum set objective
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# create multi-zone problem with minimum set objective
targets_matrix &lt;- matrix(rpois(15, 1), nrow = 5, ncol = 3)

p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(targets_matrix) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# plot solution
plot(category_layer(s2), main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_min_shortfall_objective'>Add minimum shortfall objective</h2><span id='topic+add_min_shortfall_objective'></span>

<h3>Description</h3>

<p>Set the objective of a conservation planning problem to
minimize the overall shortfall for as many <a href="#topic+targets">targets</a> as possible while
ensuring that the cost of the solution does not exceed a budget.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_min_shortfall_objective(x, budget)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_min_shortfall_objective_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_min_shortfall_objective_+3A_budget">budget</code></td>
<td>
<p><code>numeric</code> value specifying the maximum expenditure of
the prioritization. For problems with multiple zones, the argument
to <code>budget</code> can be (i) a single <code>numeric</code> value to specify a single budget
for the entire solution or (ii) a <code>numeric</code> vector to specify
a separate budget for each management zone.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimum shortfall objective aims to
find the set of planning units that minimize the overall
(weighted sum) shortfall for the
representation targets&mdash;that is, the fraction of each target that
remains unmet&mdash;for as many features as possible while staying within a
fixed budget (inspired by Table 1, equation IV, Arponen <em>et al.</em>
2005). Additionally, weights can be used
to favor the representation of certain features over other features (see
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code>.
</p>


<h3>Value</h3>

<p>An updated <code>problem()</code> object with the objective added to it.
</p>


<h3>Mathematical formulation</h3>

<p>This objective can be expressed mathematically for a set of planning units
(<code class="reqn">I</code> indexed by <code class="reqn">i</code>) and a set of features (<code class="reqn">J</code> indexed
by <code class="reqn">j</code>) as:
</p>
<p style="text-align: center;"><code class="reqn">\mathit{Minimize} \space  \sum_{j = 1}^{J} w_j \frac{y_j}{t_j} \\
\mathit{subject \space to} \\
\sum_{i = 1}^{I} x_i r_{ij} + y_j \geq t_j \forall j \in J \\
\sum_{i = 1}^{I} x_i c_i \leq B</code>
</p>

<p>Here, <code class="reqn">x_i</code> is the <a href="#topic+decisions">decisions</a> variable (e.g.,
specifying whether planning unit <code class="reqn">i</code> has been selected (1) or not
(0)), <code class="reqn">r_{ij}</code> is the amount of feature <code class="reqn">j</code> in planning
unit <code class="reqn">i</code>, <code class="reqn">t_j</code> is the representation target for feature
<code class="reqn">j</code>, <code class="reqn">y_j</code> denotes the representation shortfall for
the target <code class="reqn">t_j</code> for feature <code class="reqn">j</code>, and <code class="reqn">w_j</code> is the
weight for feature <code class="reqn">j</code> (defaults to 1 for all features; see
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code> to specify weights). Additionally,
<code class="reqn">B</code> is the budget allocated for the solution, <code class="reqn">c_i</code> is the
cost of planning unit <code class="reqn">i</code>. Note that <code class="reqn">y_j</code> is a continuous
variable bounded between zero and infinity, and denotes the shortfall
for target <code class="reqn">j</code>.
</p>


<h3>References</h3>

<p>Arponen A, Heikkinen RK, Thomas CD, and Moilanen A (2005) The value of
biodiversity in reserve selection: representation, species weighting, and
benefit functions. <em>Conservation Biology</em>, 19: 2009&ndash;2014.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+objectives">objectives</a> for an overview of all functions for adding objectives.
Also, see <a href="#topic+targets">targets</a> for an overview of all functions for adding targets, and
<code><a href="#topic+add_feature_weights">add_feature_weights()</a></code> to specify weights for different features.
</p>
<p>Other objectives: 
<code><a href="#topic+add_max_cover_objective">add_max_cover_objective</a>()</code>,
<code><a href="#topic+add_max_features_objective">add_max_features_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_div_objective">add_max_phylo_div_objective</a>()</code>,
<code><a href="#topic+add_max_phylo_end_objective">add_max_phylo_end_objective</a>()</code>,
<code><a href="#topic+add_max_utility_objective">add_max_utility_objective</a>()</code>,
<code><a href="#topic+add_min_largest_shortfall_objective">add_min_largest_shortfall_objective</a>()</code>,
<code><a href="#topic+add_min_set_objective">add_min_set_objective</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create problem with minimum shortfall objective
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_shortfall_objective(1800) %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# create multi-zone problem with minimum shortfall objective,
# with 10% representation targets for each feature, and set
# a budget such that the total maximum expenditure in all zones
# cannot exceed 3000
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_shortfall_objective(3000) %&gt;%
  add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# plot solution
plot(category_layer(s2), main = "solution", axes = FALSE)

# create multi-zone problem with minimum shortfall objective,
# with 10% representation targets for each feature, and set
# separate budgets for each management zone
p3 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_shortfall_objective(c(3000, 3000, 3000)) %&gt;%
  add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# plot solution
plot(category_layer(s3), main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_neighbor_constraints'>Add neighbor constraints</h2><span id='topic+add_neighbor_constraints'></span><span id='topic+add_neighbor_constraints+2CConservationProblem+2CANY+2CANY+2CANY+2Carray-method'></span><span id='topic+add_neighbor_constraints+2CConservationProblem+2CANY+2CANY+2CANY+2Cmatrix-method'></span><span id='topic+add_neighbor_constraints+2CConservationProblem+2CANY+2CANY+2CANY+2Cdata.frame-method'></span><span id='topic+add_neighbor_constraints+2CConservationProblem+2CANY+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Add constraints to a conservation planning problem to ensure
that all selected planning units in the solution have at least a certain
number of neighbors that are also selected in the solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConservationProblem,ANY,ANY,ANY,ANY'
add_neighbor_constraints(x, k, clamp, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,ANY,data.frame'
add_neighbor_constraints(x, k, clamp, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,ANY,matrix'
add_neighbor_constraints(x, k, clamp, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,ANY,array'
add_neighbor_constraints(x, k, clamp, zones, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_neighbor_constraints_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_neighbor_constraints_+3A_k">k</code></td>
<td>
<p><code>integer</code> minimum number of neighbors for selected
planning units in the solution. For problems with multiple zones,
the argument to <code>k</code> must have an element for each zone.</p>
</td></tr>
<tr><td><code id="add_neighbor_constraints_+3A_clamp">clamp</code></td>
<td>
<p><code>logical</code> should the minimum number of neighbors
for selected planning units in the solution be clamped to feasibility?
For example, if a planning unit has two neighbors,
<code>k = 3</code>, and <code>clamp = FALSE</code>, then the planning unit could not
ever be selected in the solution. However, if <code>clamp = TRUE</code>,
then the planning unit could potentially be selected in the solution if
both of its two neighbors were also selected.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_neighbor_constraints_+3A_zones">zones</code></td>
<td>
<p><code>matrix</code> or <code>Matrix</code> object describing the
neighborhood scheme for different zones. Each row and column corresponds
to a different zone in the argument to <code>x</code>, and cell values must
contain binary <code>numeric</code> values (i.e., one or zero) that indicate
if neighboring planning units (as specified in the argument to
<code>data</code>) should be considered neighbors if they are allocated to
different zones. The cell values along the diagonal
of the matrix indicate if planning units that are allocated to the same
zone should be considered neighbors or not. The default argument to
<code>zones</code> is an identity matrix (i.e., a matrix with ones along the
matrix diagonal and zeros elsewhere), so that planning units are
only considered neighbors if they are both allocated to the same zone.</p>
</td></tr>
<tr><td><code id="add_neighbor_constraints_+3A_data">data</code></td>
<td>
<p><code>NULL</code>, <code>matrix</code>, <code>Matrix</code>, <code>data.frame</code>, or
<code>array</code> object showing which planning units are neighbors with each
other. The argument defaults to <code>NULL</code> which means that the
neighborhood data is calculated automatically using the
<code><a href="#topic+adjacency_matrix">adjacency_matrix()</a></code> function.
See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses neighborhood data to identify solutions that
surround planning units with a minimum number of neighbors. It
was inspired by the mathematical formulations detailed in
Billionnet (2013) and Beyer <em>et al.</em> (2016).
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the constraints added to it.
</p>


<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using the following formats:
</p>

<dl>
<dt><code>data</code> as a <code>NULL</code> value</dt><dd><p>neighborhood data should be calculated
automatically
using the <code><a href="#topic+adjacency_matrix">adjacency_matrix()</a></code> function. This is the default
argument. Note that the neighborhood data must be manually defined
using one of the other formats below when the planning unit data
in the argument to <code>x</code> is not spatially referenced (e.g.,
in <code>data.frame</code> or <code>numeric</code> format).</p>
</dd>
<dt><code>data</code> as a <code>matrix</code>/<code>Matrix</code> object</dt><dd><p>where rows and columns represent
different planning units and the value of each cell indicates if the
two planning units are neighbors or not. Cell values should be binary
<code>numeric</code> values (i.e., one or zero). Cells that occur along the
matrix diagonal have no effect on the solution at all because each
planning unit cannot be a neighbor with itself.</p>
</dd>
<dt><code>data</code> as a <code>data.frame</code> object</dt><dd><p>containing columns that are named
<code>"id1"</code>, <code>"id2"</code>, and <code>"boundary"</code>. Here, each row
denotes the connectivity between two planning units following the
<em>Marxan</em> format. The <code>"boundary"</code> column should contain
binary <code>numeric</code> values that indicate if the two planning units
specified in the <code>"id1"</code> and <code>"id2"</code> columns are neighbors
or not. This data can be used to describe symmetric or
asymmetric relationships between planning units. By default,
input data is assumed to be symmetric unless asymmetric data is
also included (e.g., if data is present for planning units 2 and 3, then
the same amount of connectivity is expected for planning units 3 and 2,
unless connectivity data is also provided for planning units 3 and 2).
If the argument to <code>x</code> contains multiple zones, then the
<code>"zone1"</code> and <code>"zone2"</code> columns can optionally be provided to manually
specify if the neighborhood data pertain to specific zones. The
<code>"zone1"</code> and <code>"zone2"</code> columns should contain the <code>character</code>
names of the zones. If the columns <code>"zone1"</code> and <code>"zone2"</code>
are present, then the argument to <code>zones</code> must be <code>NULL</code>.</p>
</dd>
<dt><code>data</code> as an <code>array</code> object</dt><dd><p>containing four-dimensions where binary
<code>numeric</code> values indicate if planning unit should be treated
as being neighbors with every other planning unit when they
are allocated to every combination of management zone. The first two
dimensions (i.e., rows and columns) correspond to the planning units,
and second two dimensions correspond to the management zones. For
example, if the argument to <code>data</code> had a value of 1 at the index
<code>data[1, 2, 3, 4]</code> this would indicate that planning unit 1 and
planning unit 2 should be treated as neighbors when they are
allocated to zones 3 and 4 respectively.</p>
</dd>
</dl>



<h3>References</h3>

<p>Beyer HL, Dujardin Y, Watts ME, and Possingham HP (2016) Solving
conservation planning problems with integer linear programming.
<em>Ecological Modelling</em>, 228: 14&ndash;22.
</p>
<p>Billionnet A (2013) Mathematical optimization ideas for biodiversity
conservation. <em>European Journal of Operational Research</em>, 231:
514&ndash;534.
</p>


<h3>See Also</h3>

<p>Other constraints: 
<code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_feature_contiguity_constraints">add_feature_contiguity_constraints</a>()</code>,
<code><a href="#topic+add_linear_constraints">add_linear_constraints</a>()</code>,
<code><a href="#topic+add_locked_in_constraints">add_locked_in_constraints</a>()</code>,
<code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints</a>()</code>,
<code><a href="#topic+add_mandatory_allocation_constraints">add_mandatory_allocation_constraints</a>()</code>,
<code><a href="#topic+add_manual_bounded_constraints">add_manual_bounded_constraints</a>()</code>,
<code><a href="#topic+add_manual_locked_constraints">add_manual_locked_constraints</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with constraints that require 1 neighbor
# and neighbors are defined using a rook-style neighborhood
p2 &lt;- p1 %&gt;% add_neighbor_constraints(1)

# create problem with constraints that require 2 neighbor
# and neighbors are defined using a rook-style neighborhood
p3 &lt;- p1 %&gt;% add_neighbor_constraints(2)

# create problem with constraints that require 3 neighbor
# and neighbors are defined using a queen-style neighborhood
p4 &lt;-
  p1 %&gt;%
  add_neighbor_constraints(
    3, data = adjacency_matrix(sim_pu_raster, directions = 8)
  )

# solve problems
s1 &lt;- terra::rast(list(solve(p1), solve(p2), solve(p3), solve(p4)))
names(s1) &lt;- c("basic solution", "1 neighbor", "2 neighbors", "3 neighbors")

# plot solutions
plot(s1, axes = FALSE)

# create minimal problem with multiple zones
p5 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %&gt;%
  add_default_solver(verbose = FALSE)

# create problem where selected planning units require at least 2 neighbors
# for each zone and planning units are only considered neighbors if they
# are allocated to the same zone
z6 &lt;- diag(3)
print(z6)
p6 &lt;- p5 %&gt;% add_neighbor_constraints(rep(2, 3), zones = z6)

# create problem where the planning units in zone 1 don't explicitly require
# any neighbors, planning units in zone 2 require at least 1 neighbors, and
# planning units in zone 3 require at least 2 neighbors. As before, planning
# units are still only considered neighbors if they are allocated to the
# same zone
p7 &lt;- p5 %&gt;% add_neighbor_constraints(c(0, 1, 2), zones = z6)

# create problem given the same constraints as outlined above, except
# that when determining which selected planning units are neighbors,
# planning units that are allocated to zone 1 and zone 2 can also treated
# as being neighbors with each other
z8 &lt;- diag(3)
z8[1, 2] &lt;- 1
z8[2, 1] &lt;- 1
print(z8)
p8 &lt;- p5 %&gt;% add_neighbor_constraints(c(0, 1, 2), zones = z8)

# solve problems
s2 &lt;- list(p5, p6, p7, p8)
s2 &lt;- lapply(s2, solve)
s2 &lt;- lapply(s2, category_layer)
s2 &lt;- terra::rast(s2)
names(s2) &lt;- c("basic problem", "p6", "p7", "p8")

# plot solutions
plot(s2, main = names(s2), axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_proportion_decisions'>Add proportion decisions</h2><span id='topic+add_proportion_decisions'></span>

<h3>Description</h3>

<p>Add a proportion decision to a conservation planning problem.
This is a relaxed decision where a part of a planning unit can be
prioritized, as opposed to the entire planning unit. Typically, this decision
has the assumed action of buying a fraction of a planning unit to include in
decisions will solve much faster than problems that use binary-type
decisions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_proportion_decisions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_proportion_decisions_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conservation planning problems involve making decisions on planning
units. These decisions are then associated with actions (e.g., turning a
planning unit into a protected area). Only a
single decision should be added to a <code><a href="#topic+problem">problem()</a></code> object.
Note that if multiple decisions are added to an object, then the
last one to be added will be used.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the decisions added to it.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+decisions">decisions</a> for an overview of all functions for adding decisions.
</p>
<p>Other decisions: 
<code><a href="#topic+add_binary_decisions">add_binary_decisions</a>()</code>,
<code><a href="#topic+add_semicontinuous_decisions">add_semicontinuous_decisions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem with proportion decisions
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_proportion_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solutions
plot(s1, main = "solution", axes = FALSE)

# build multi-zone conservation problem with proportion decisions
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_proportion_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s2 &lt;- solve(p2)

# print solution
print(s2)

# plot solution
# panels show the proportion of each planning unit allocated to each zone
plot(s2, axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_relative_targets'>Add relative targets</h2><span id='topic+add_relative_targets'></span><span id='topic+add_relative_targets-method'></span><span id='topic+add_relative_targets+2CConservationProblem+2Cnumeric-method'></span><span id='topic+add_relative_targets+2CConservationProblem+2Cmatrix-method'></span><span id='topic+add_relative_targets+2CConservationProblem+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Set targets as a proportion (between 0 and 1) of the maximum level of
representation of features in the study area. Please note that proportions
are scaled according to the features' total abundances in the study area
(including any locked out planning units, or planning units with <code>NA</code>
cost values) using the <code><a href="#topic+feature_abundances">feature_abundances()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_relative_targets(x, targets)

## S4 method for signature 'ConservationProblem,numeric'
add_relative_targets(x, targets)

## S4 method for signature 'ConservationProblem,matrix'
add_relative_targets(x, targets)

## S4 method for signature 'ConservationProblem,character'
add_relative_targets(x, targets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_relative_targets_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_relative_targets_+3A_targets">targets</code></td>
<td>
<p>Object that specifies the targets for each feature.
See the Targets format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Targets are used to specify the minimum amount or proportion of a
feature's distribution that needs to be protected. Most conservation
planning problems require targets with the exception of the maximum cover
(see <code><a href="#topic+add_max_cover_objective">add_max_cover_objective()</a></code>) and maximum utility
(see <code><a href="#topic+add_max_utility_objective">add_max_utility_objective()</a></code>) problems. Attempting to solve
problems with objectives that require targets without specifying targets
will throw an error.
</p>
<p>For problems associated with multiple management zones,
<code><a href="#topic+add_absolute_targets">add_absolute_targets()</a></code> can
be used to set targets that each pertain to a single feature and a single
zone. To set targets that can be met through allocating different
planning units to multiple zones, see the <code><a href="#topic+add_manual_targets">add_manual_targets()</a></code>
function. An example of a target that could be met through allocations
to multiple zones might be where each management zone is expected to
result in a different amount of a feature and the target requires that
the total amount of the feature in all zones must exceed a certain
threshold. In other words, the target does not require that any single
zone secure a specific amount of the feature, but the total amount held
in all zones must secure a specific amount. Thus the target could,
potentially, be met through allocating all planning units to any specific
management zone, or through allocating the planning units to different
combinations of management zones.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the targets added to it.
</p>


<h3>Targets format</h3>

<p>The <code>targets</code> for a problem can be specified using the following formats.
</p>

<dl>
<dt><code>targets</code> as a <code>numeric</code> vector</dt><dd><p>containing target values for each
feature.
Additionally, for convenience, this format can be a single
value to assign the same target to each feature. Note that this format
cannot be used to specify targets for problems with multiple zones.</p>
</dd>
<dt><code>targets</code> as a <code>matrix</code> object</dt><dd><p>containing a target for each feature
in each zone.
Here, each row corresponds to a different feature in argument to
<code>x</code>, each column corresponds to a different zone in argument to
<code>x</code>, and each cell contains the target value for a given feature
that the solution needs to secure in a given zone.</p>
</dd>
<dt><code>targets</code> as a <code>character</code> vector</dt><dd><p>containing the column name(s) in the
feature data associated with the argument to <code>x</code> that
contain targets. This format can only be used when the
feature data associated with <code>x</code> is a <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> or <code>data.frame</code>.
For problems that contain a single zone, the argument to <code>targets</code> must
contain a single column name. Otherwise, for problems that
contain multiple zones, the argument to <code>targets</code> must
contain a column name for each zone.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="#topic+targets">targets</a> for an overview of all functions for adding targets.
</p>
<p>Other targets: 
<code><a href="#topic+add_absolute_targets">add_absolute_targets</a>()</code>,
<code><a href="#topic+add_loglinear_targets">add_loglinear_targets</a>()</code>,
<code><a href="#topic+add_manual_targets">add_manual_targets</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create base problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with 10% targets
p1 &lt;- p %&gt;% add_relative_targets(0.1)

# create problem with varying targets for each feature
targets &lt;- c(0.1, 0.2, 0.3, 0.4, 0.5)
p2 &lt;- p %&gt;% add_relative_targets(targets)

# solve problem
s3 &lt;- c(solve(p1), solve(p2))
names(s3) &lt;- c("10% targets", "varying targets")

# plot solution
plot(s3, main = , axes = FALSE)

# create a problem with multiple management zones
p4 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create a problem with targets that specify an equal amount of each feature
# to be represented in each zone
p4_targets &lt;- matrix(
  0.1, nrow = 5, ncol = 3, dimnames = list(
    feature_names(sim_zones_features), zone_names(sim_zones_features)
  )
)
print(p4_targets)

p5 &lt;- p4 %&gt;% add_relative_targets(p4_targets)

# solve problem
s5 &lt;- solve(p5)

# plot solution (pixel values correspond to zone identifiers)
plot(category_layer(s5), main = "equal targets")

# create a problem with targets that require a varying amount of each
# feature to be represented in each zone
p6_targets &lt;- matrix(
  runif(15, 0.01, 0.2), nrow = 5, ncol = 3, dimnames = list(
    feature_names(sim_zones_features), zone_names(sim_zones_features)
  )
)
print(p6_targets)

p6 &lt;- p4 %&gt;% add_relative_targets(p6_targets)

# solve problem
s6 &lt;- solve(p6)

# plot solution (pixel values correspond to zone identifiers)
plot(category_layer(s6), main = "varying targets")

## End(Not run)

</code></pre>

<hr>
<h2 id='add_rsymphony_solver'>Add a <em>SYMPHONY</em> solver with <em>Rsymphony</em></h2><span id='topic+add_rsymphony_solver'></span>

<h3>Description</h3>

<p>Specify that the <a href="https://github.com/coin-or/SYMPHONY"><em>SYMPHONY</em></a>
software &ndash; using the <span class="pkg">Rsymphony</span> package &ndash;
should be used to solve a conservation planning problem
(Ralphs &amp; Güzelsoy 2005).
This function can also be used to customize the behavior of the solver.
It requires the <span class="pkg">Rsymphony</span> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_rsymphony_solver(
  x,
  gap = 0.1,
  time_limit = .Machine$integer.max,
  first_feasible = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_rsymphony_solver_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_rsymphony_solver_+3A_gap">gap</code></td>
<td>
<p><code>numeric</code> gap to optimality. This gap is relative
and expresses the acceptable deviance from the optimal objective.
For example, a value of 0.01 will result in the solver stopping when
it has found a solution within 1% of optimality.
Additionally, a value of 0 will result in the solver stopping
when it has found an optimal solution.
The default value is 0.1 (i.e., 10% from optimality).</p>
</td></tr>
<tr><td><code id="add_rsymphony_solver_+3A_time_limit">time_limit</code></td>
<td>
<p><code>numeric</code> time limit (seconds) for generating solutions.
The solver will return the current best solution when this time limit is
exceeded. The default value is the largest integer value
(i.e., <code>.Machine$integer.max</code>), effectively meaning that solver
will keep running until a solution within the optimality gap is found.</p>
</td></tr>
<tr><td><code id="add_rsymphony_solver_+3A_first_feasible">first_feasible</code></td>
<td>
<p><code>logical</code> should the first feasible solution be
be returned? If <code>first_feasible</code> is set to <code>TRUE</code>, the solver
will return the first solution it encounters that meets all the
constraints, regardless of solution quality. Note that the first feasible
solution is not an arbitrary solution, rather it is derived from the
relaxed solution, and is therefore often reasonably close to optimality.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_rsymphony_solver_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> should information be printed while solving
optimization problems? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://github.com/coin-or/SYMPHONY"><em>SYMPHONY</em></a> is an
open-source mixed integer programming solver that is part of the
Computational
Infrastructure for Operations Research (COIN-OR) project.
The <span class="pkg">Rsymphony</span> package
provides an interface to COIN-OR and &ndash; unlike dependencies for other
solvers &ndash; is available on <em>CRAN</em>.
For information on the performance of different solvers,
please see Schuster <em>et al.</em> (2020) for benchmarks comparing the
run time and solution quality of different solvers when applied to
different sized datasets.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the solver added to it.
</p>


<h3>References</h3>

<p>Ralphs TK and Güzelsoy M (2005) The SYMPHONY callable library for mixed
integer programming. In The Next Wave in Computing, Optimization, and
Decision Technologies (pp. 61&ndash;76). Springer, Boston, MA.
</p>
<p>Schuster R, Hanson JO, Strimas-Mackey M, and Bennett JR (2020). Exact
integer linear programming solvers outperform simulated annealing for
solving conservation planning problems. <em>PeerJ</em>, 8: e9258.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+solvers">solvers</a> for an overview of all functions for adding a solver.
</p>
<p>Other solvers: 
<code><a href="#topic+add_cbc_solver">add_cbc_solver</a>()</code>,
<code><a href="#topic+add_cplex_solver">add_cplex_solver</a>()</code>,
<code><a href="#topic+add_default_solver">add_default_solver</a>()</code>,
<code><a href="#topic+add_gurobi_solver">add_gurobi_solver</a>()</code>,
<code><a href="#topic+add_highs_solver">add_highs_solver</a>()</code>,
<code><a href="#topic+add_lsymphony_solver">add_lsymphony_solver</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_rsymphony_solver(time_limit = 10, verbose = FALSE)

# generate solution
s &lt;- solve(p)

# plot solution
plot(s, main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_semicontinuous_decisions'>Add semi-continuous decisions</h2><span id='topic+add_semicontinuous_decisions'></span>

<h3>Description</h3>

<p>Add a semi-continuous decision to a conservation planning
problem. This is a relaxed decision where a part of a planning
unit can be prioritized, as opposed to the entire planning unit.
This decision is similar to the <code><a href="#topic+add_proportion_decisions">add_proportion_decisions()</a></code>
function, except that it has an upper bound parameter. By default, the
decision can range from prioritizing none (0%) to all (100%) of a
planning unit. However, an upper bound can be specified to ensure that, at
most, only a fraction (e.g., 80%) of a planning unit can be prioritized. This
type of decision may be useful when it is not practical to conserve entire
planning units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_semicontinuous_decisions(x, upper_limit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_semicontinuous_decisions_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_semicontinuous_decisions_+3A_upper_limit">upper_limit</code></td>
<td>
<p><code>numeric</code> value specifying the maximum proportion
of a planning unit that can be reserved (e.g., set to 0.8 for 80%).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conservation planning problems involve making decisions on planning
units. These decisions are then associated with actions (e.g., turning a
planning unit into a protected area). Only a
single decision should be added to a <code><a href="#topic+problem">problem()</a></code> object.
Note that if multiple decisions are added to an object, then the
last one to be added will be used.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the decisions added to it.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+decisions">decisions</a> for an overview of all functions for adding decisions.
</p>
<p>Other decisions: 
<code><a href="#topic+add_binary_decisions">add_binary_decisions</a>()</code>,
<code><a href="#topic+add_proportion_decisions">add_proportion_decisions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem with semi-continuous decisions
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_semicontinuous_decisions(0.5) %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# plot solutions
plot(s1, main = "solution", axes = FALSE)

# build multi-zone conservation problem with semi-continuous decisions
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_semicontinuous_decisions(0.5) %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s2 &lt;- solve(p2)

# print solution
print(s2)

# plot solution
# panels show the proportion of each planning unit allocated to each zone
plot(s2, axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_shuffle_portfolio'>Add a shuffle portfolio</h2><span id='topic+add_shuffle_portfolio'></span>

<h3>Description</h3>

<p>Generate a portfolio of solutions for a conservation planning
problem by randomly reordering the data prior to
solving the problem. Although this function can be useful for generating
multiple different solutions for a given problem,
it is recommended to use <a href="#topic+add_pool_portfolio">add_pool_portfolio</a> if the <em>Gurobi</em>
software is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_shuffle_portfolio(
  x,
  number_solutions = 10,
  threads = 1,
  remove_duplicates = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_shuffle_portfolio_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_shuffle_portfolio_+3A_number_solutions">number_solutions</code></td>
<td>
<p><code>integer</code> number of attempts to generate
different solutions. Defaults to 10.</p>
</td></tr>
<tr><td><code id="add_shuffle_portfolio_+3A_threads">threads</code></td>
<td>
<p><code>integer</code> number of threads to use for the generating
the solution portfolio. Defaults to 1.</p>
</td></tr>
<tr><td><code id="add_shuffle_portfolio_+3A_remove_duplicates">remove_duplicates</code></td>
<td>
<p><code>logical</code> should duplicate solutions
be removed? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This strategy for generating a portfolio of solutions often
results in different solutions, depending on optimality gap, but may
return duplicate solutions. In general, this strategy is most effective
when problems are quick to solve and multiple threads are available for
solving each problem separately.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the portfolio added to it.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+portfolios">portfolios</a> for an overview of all functions for adding a portfolio.
</p>
<p>Other portfolios: 
<code><a href="#topic+add_cuts_portfolio">add_cuts_portfolio</a>()</code>,
<code><a href="#topic+add_default_portfolio">add_default_portfolio</a>()</code>,
<code><a href="#topic+add_extra_portfolio">add_extra_portfolio</a>()</code>,
<code><a href="#topic+add_gap_portfolio">add_gap_portfolio</a>()</code>,
<code><a href="#topic+add_top_portfolio">add_top_portfolio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem with shuffle portfolio
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_shuffle_portfolio(10, remove_duplicates = FALSE) %&gt;%
  add_default_solver(gap = 0.2, verbose = FALSE)

# solve problem and generate 10 solutions within 20% of optimality
s1 &lt;- solve(p1)

# convert portfolio into a multi-layer raster
s1 &lt;- terra::rast(s1)

# print number of solutions found
print(terra::nlyr(s1))

# plot solutions in portfolio
plot(s1, axes = FALSE)

# build multi-zone conservation problem with shuffle portfolio
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_shuffle_portfolio(10, remove_duplicates = FALSE) %&gt;%
  add_default_solver(gap = 0.2, verbose = FALSE)

# solve the problem
s2 &lt;- solve(p2)

# convert each solution in the portfolio into a single category layer
s2 &lt;- terra::rast(lapply(s2, category_layer))

# print number of solutions found
print(terra::nlyr(s2))

# plot solutions in portfolio
plot(s2, axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_top_portfolio'>Add a top portfolio</h2><span id='topic+add_top_portfolio'></span>

<h3>Description</h3>

<p>Generate a portfolio of solutions for a conservation planning
problem by finding a pre-specified number of solutions that
are closest to optimality (i.e, the top solutions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_top_portfolio(x, number_solutions = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_top_portfolio_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="add_top_portfolio_+3A_number_solutions">number_solutions</code></td>
<td>
<p><code>integer</code> number of solutions required.
Defaults to 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This strategy for generating a portfolio requires problems to
be solved using the <em>Gurobi</em> software suite (i.e., using
<code><a href="#topic+add_gurobi_solver">add_gurobi_solver()</a></code>. Specifically, version 8.0.0 (or greater)
of the <span class="pkg">gurobi</span> package must be installed.
Note that the number of solutions returned may be less than the argument to
<code>number_solutions</code>, if the total number of feasible solutions
is less than the number of solutions requested.
</p>


<h3>Value</h3>

<p>An updated <code><a href="#topic+problem">problem()</a></code> object with the portfolio added to it.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+portfolios">portfolios</a> for an overview of all functions for adding a portfolio.
</p>
<p>Other portfolios: 
<code><a href="#topic+add_cuts_portfolio">add_cuts_portfolio</a>()</code>,
<code><a href="#topic+add_default_portfolio">add_default_portfolio</a>()</code>,
<code><a href="#topic+add_extra_portfolio">add_extra_portfolio</a>()</code>,
<code><a href="#topic+add_gap_portfolio">add_gap_portfolio</a>()</code>,
<code><a href="#topic+add_shuffle_portfolio">add_shuffle_portfolio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(600)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem with a portfolio for the top 5 solutions
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.05) %&gt;%
  add_top_portfolio(number_solutions = 5) %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem and generate portfolio
s1 &lt;- solve(p1)

# convert portfolio into a multi-layer raster
s1 &lt;- terra::rast(s1)

# print number of solutions found
print(terra::nlyr(s1))

# plot solutions
plot(s1, axes = FALSE)

# create multi-zone problem with a portfolio for the top 5 solutions
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_top_portfolio(number_solutions = 5) %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem and generate portfolio
s2 &lt;- solve(p2)

# convert each solution in the portfolio into a single category layer
s2 &lt;- terra::rast(lapply(s2, category_layer))

# print number of solutions found
print(terra::nlyr(s2))

# plot solutions in portfolio
plot(s2, axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='adjacency_matrix'>Adjacency matrix</h2><span id='topic+adjacency_matrix'></span><span id='topic+adjacency_matrix.Raster'></span><span id='topic+adjacency_matrix.SpatRaster'></span><span id='topic+adjacency_matrix.SpatialPolygons'></span><span id='topic+adjacency_matrix.SpatialLines'></span><span id='topic+adjacency_matrix.SpatialPoints'></span><span id='topic+adjacency_matrix.sf'></span><span id='topic+adjacency_matrix.default'></span>

<h3>Description</h3>

<p>Create a matrix showing which planning units are spatially adjacent to
each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacency_matrix(x, ...)

## S3 method for class 'Raster'
adjacency_matrix(x, directions = 4, ...)

## S3 method for class 'SpatRaster'
adjacency_matrix(x, directions = 4, ...)

## S3 method for class 'SpatialPolygons'
adjacency_matrix(x, ...)

## S3 method for class 'SpatialLines'
adjacency_matrix(x, ...)

## S3 method for class 'SpatialPoints'
adjacency_matrix(x, ...)

## S3 method for class 'sf'
adjacency_matrix(x, ...)

## Default S3 method:
adjacency_matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacency_matrix_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object representing planning units.</p>
</td></tr>
<tr><td><code id="adjacency_matrix_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="adjacency_matrix_+3A_directions">directions</code></td>
<td>
<p><code>integer</code> If <code>x</code> is a
<code><a href="terra.html#topic+rast">terra::rast()</a></code> object, the number of directions
in which cells should be considered adjacent: 4 (rook's case), 8 (queen's
case), 16 (knight and one-cell queen moves), or &quot;bishop&quot; to for cells
with one-cell diagonal moves.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spatial processing is completed using
<code><a href="sf.html#topic+geos_binary_pred">sf::st_intersects()</a></code> for <code><a href="sf.html#topic+sf">sf::sf()</a></code> objects,
and <code><a href="terra.html#topic+adjacent">terra::adjacent()</a></code> for <code><a href="terra.html#topic+rast">terra::rast()</a></code> objects.
Note that spatially overlapping planning units are considered
adjacent.
</p>


<h3>Value</h3>

<p>A <code><a href="Matrix.html#topic+dsCMatrix-class">dsCMatrix</a></code> sparse symmetric matrix.
Each row and column represents a planning unit.
Cells values indicate if different planning units are
adjacent to each other or not (using ones and zeros).
To reduce computational burden, cells among the matrix diagonal are
set to zero. Furthermore, if the argument to <code>x</code> is a
<code><a href="terra.html#topic+rast">terra::rast()</a></code> object, then cells with <code>NA</code> values are set to
zero too.
</p>


<h3>Notes</h3>

<p>In earlier versions (&lt; 5.0.0), this function was named as the
<code>connected_matrix</code> function. It has been renamed to be consistent
with other spatial association matrix functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()

# create adjacency matrix using raster data
## crop raster to 9 cells
r &lt;- terra::crop(sim_pu_raster, terra::ext(c(0, 0.3, 0, 0.3)))

## make adjacency matrix
am_raster &lt;- adjacency_matrix(r)

# create adjacency matrix using polygon data
## subset 9 polygons
ply &lt;- sim_pu_polygons[c(1:3, 11:13, 20:22), ]

## make adjacency matrix
am_ply &lt;- adjacency_matrix(ply)

# plot data and the adjacency matrices

## plot raster and adjacency matrix
plot(r, main = "raster", axes = FALSE)
Matrix::image(am_raster, main = "adjacency matrix")

## plot polygons and adjacency matrix
plot(ply[, 1], main = "polygons")
Matrix::image(am_ply, main = "adjacency matrix")


## End(Not run)
</code></pre>

<hr>
<h2 id='binary_stack'>Binary stack</h2><span id='topic+binary_stack'></span><span id='topic+binary_stack.Raster'></span><span id='topic+binary_stack.SpatRaster'></span>

<h3>Description</h3>

<p>Convert a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object containing
integer/categorical values into a raster
object where each layer corresponds to a different integer/categorical
value and pixel values denote the presence/absence of the given
integer/categorical values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary_stack(x)

## S3 method for class 'Raster'
binary_stack(x)

## S3 method for class 'SpatRaster'
binary_stack(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_stack_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object with a single layer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is provided to help manage data that encompass
multiple management zones. For instance, this function may be helpful
for preparing raster data for <code><a href="#topic+add_locked_in_constraints">add_locked_in_constraints()</a></code> and
<code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints()</a></code> since they require binary
rasters as input arguments.
It is essentially a wrapper for <code><a href="terra.html#topic+segregate">terra::segregate()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="terra.html#topic+rast">terra::rast()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+category_layer">category_layer()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create raster with categorical values
x &lt;- terra::rast(matrix(c(1, 2, 3, 1, NA, 1), nrow = 3))

# plot the raster
plot(x, main = "x")

# convert to binary stack
y &lt;- binary_stack(x)

# plot result
## Not run: 
plot(y)

## End(Not run)
</code></pre>

<hr>
<h2 id='boundary_matrix'>Boundary matrix</h2><span id='topic+boundary_matrix'></span><span id='topic+boundary_matrix.Raster'></span><span id='topic+boundary_matrix.SpatRaster'></span><span id='topic+boundary_matrix.SpatialPolygons'></span><span id='topic+boundary_matrix.SpatialLines'></span><span id='topic+boundary_matrix.SpatialPoints'></span><span id='topic+boundary_matrix.sf'></span><span id='topic+boundary_matrix.default'></span>

<h3>Description</h3>

<p>Generate a matrix describing the amount of shared boundary length
between different planning units, and the total amount of boundary length
for each planning unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundary_matrix(x, ...)

## S3 method for class 'Raster'
boundary_matrix(x, ...)

## S3 method for class 'SpatRaster'
boundary_matrix(x, ...)

## S3 method for class 'SpatialPolygons'
boundary_matrix(x, ...)

## S3 method for class 'SpatialLines'
boundary_matrix(x, ...)

## S3 method for class 'SpatialPoints'
boundary_matrix(x, ...)

## S3 method for class 'sf'
boundary_matrix(x, ...)

## Default S3 method:
boundary_matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundary_matrix_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object representing planning units.</p>
</td></tr>
<tr><td><code id="boundary_matrix_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes the data are in a coordinate
system where Euclidean distances accurately describe the proximity
between two points on the earth. Thus spatial data in a
longitude/latitude coordinate system (i.e.,
<a href="https://spatialreference.org/ref/epsg/4326/">WGS84</a>)
should be reprojected to another coordinate system before using this
function. Note that for <code><a href="terra.html#topic+rast">terra::rast()</a></code> objects
boundaries are missing for cells that have  missing (<code>NA</code>) values in all
cells.
</p>


<h3>Value</h3>

<p>A <code><a href="Matrix.html#topic+dsCMatrix-class">dsCMatrix</a></code> symmetric sparse matrix object.
Each row and column represents a planning unit.
Cell values indicate the shared boundary length between different pairs
of planning units. Values along the matrix diagonal indicate the
total perimeter associated with each planning unit.
</p>


<h3>Notes</h3>

<p>In earlier versions, this function had an extra <code>str_tree</code> parameter
that could be used to leverage STR query trees to speed up processing
for planning units in vector format.
Although this functionality improved performance, it was not
enabled by default because the underlying function
(i.e., <code>rgeos:gUnarySTRtreeQuery()</code>) was documented as experimental.
The <code>boundary_matrix()</code> function has since been updated so that it will
use STR query trees to speed up processing for planning units in vector
format (using <code><a href="terra.html#topic+sharedPaths">terra::sharedPaths()</a></code>).
</p>
<p>Also, note that in previous versions, cell values along the matrix
diagonal indicated the perimeter associated with planning units
that did not contain any neighbors. This has now changed such
that values along the diagonal now correspond to the total
perimeter associated with each planning unit.
</p>


<h3>See Also</h3>

<p>Boundary matrix data might need rescaling to improve optimization
performance, see <code><a href="#topic+rescale_matrix">rescale_matrix()</a></code> to perform these calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()

# subset data to reduce processing time
r &lt;- terra::crop(sim_pu_raster, c(0, 0.3, 0, 0.3))
ply &lt;- sim_pu_polygons[c(1:3, 11:13, 20:22), ]

# create boundary matrix using raster data
bm_raster &lt;- boundary_matrix(r)

# create boundary matrix using polygon data
bm_ply &lt;- boundary_matrix(ply)

# plot raster and boundary matrix
plot(r, main = "raster", axes = FALSE)
Matrix::image(bm_raster, main = "boundary matrix")

# plot polygons and boundary matrices
plot(ply[, 1], main = "polygons", axes = FALSE)
Matrix::image(bm_ply, main = "boundary matrix")

## End(Not run)
</code></pre>

<hr>
<h2 id='branch_matrix'>Branch matrix</h2><span id='topic+branch_matrix'></span><span id='topic+branch_matrix.default'></span><span id='topic+branch_matrix.phylo'></span>

<h3>Description</h3>

<p>Phylogenetic trees depict the evolutionary relationships between different
species. Each branch in a phylogenetic tree represents a period of
evolutionary history. Species that are connected to the same branch
both share that same period of evolutionary history. This function creates
a matrix that shows which species are connected with branch. In other words,
it creates a matrix that shows which periods of evolutionary history
each species have experienced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branch_matrix(x)

## Default S3 method:
branch_matrix(x)

## S3 method for class 'phylo'
branch_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="branch_matrix_+3A_x">x</code></td>
<td>
<p><code><a href="ape.html#topic+read.tree">ape::phylo()</a></code> tree object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> sparse matrix object. Each row
corresponds to a different species. Each column corresponds to a different
branch. Species that inherit from a given branch are denoted with a one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
sim_phylogeny &lt;- get_sim_phylogeny()

# generate species by branch matrix
m &lt;- branch_matrix(sim_phylogeny)

# plot data
## Not run: 
plot(sim_phylogeny, main = "phylogeny")
Matrix::image(m, main = "branch matrix")

## End(Not run)
</code></pre>

<hr>
<h2 id='category_layer'>Category layer</h2><span id='topic+category_layer'></span><span id='topic+category_layer.Raster'></span><span id='topic+category_layer.default'></span>

<h3>Description</h3>

<p>Convert a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where each layer corresponds to a different
identifier and values indicate the presence/absence of that category into a
<code><a href="terra.html#topic+rast">terra::rast()</a></code> object containing categorical
identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>category_layer(x)

## S3 method for class 'Raster'
category_layer(x)

## Default S3 method:
category_layer(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="category_layer_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object containing multiple
layers. Note that pixels must be 0, 1 or <code>NA</code> values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is provided to help manage data that encompass
multiple management zones. For instance, this function may be helpful
for interpreting solutions for problems associated with multiple zones that
have binary decisions.
It is essentially a wrapper for <code><a href="terra.html#topic+which">terra::which.lyr()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="terra.html#topic+rast">terra::rast()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binary_stack">binary_stack()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a binary raster stack
x &lt;- terra::rast(list(
 terra::rast(matrix(c(1, 0, 0, 1, NA, 0), nrow = 3)),
 terra::rast(matrix(c(0, 1, 0, 0, NA, 0), nrow = 3)),
 terra::rast(matrix(c(0, 0, 1, 0, NA, 1), nrow = 3))
))

# plot data
plot(x)

# convert to category layer
y &lt;- category_layer(x)

# plot result
## Not run: 
plot(y)

## End(Not run)
</code></pre>

<hr>
<h2 id='category_vector'>Category vector</h2><span id='topic+category_vector'></span><span id='topic+category_vector.data.frame'></span><span id='topic+category_vector.sf'></span><span id='topic+category_vector.Spatial'></span><span id='topic+category_vector.matrix'></span>

<h3>Description</h3>

<p>Convert an object containing binary (<code>integer</code>) columns into a
<code>integer</code> vector indicating the column index where each row is
<code>1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>category_vector(x)

## S3 method for class 'data.frame'
category_vector(x)

## S3 method for class 'sf'
category_vector(x)

## S3 method for class 'Spatial'
category_vector(x)

## S3 method for class 'matrix'
category_vector(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="category_vector_+3A_x">x</code></td>
<td>
<p><code>matrix</code>, <code>data.frame</code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is conceptually similar to <code><a href="base.html#topic+maxCol">base::max.col()</a></code>
except that rows with no values equal to <code>1</code> values are assigned a
value of zero. Also, note that in the argument to <code>x</code>, each row must
contain only a single value equal to <code>1</code>.
</p>


<h3>Value</h3>

<p>An <code>integer</code> vector.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+maxCol">base::max.col()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create matrix with logical columns
x &lt;- matrix(c(1, 0, 0, NA, 0, 1, 0, NA, 0, 0, 0, NA), ncol = 3)

# print matrix
print(x)

# convert to category vector
y &lt;- category_vector(x)

# print category vector
print(y)
</code></pre>

<hr>
<h2 id='compile'>Compile a problem</h2><span id='topic+compile'></span><span id='topic+compile.ConservationProblem'></span>

<h3>Description</h3>

<p>Compile a conservation planning problem into an
mixed integer linear programming problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile(x, ...)

## S3 method for class 'ConservationProblem'
compile(x, compressed_formulation = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compile_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="compile_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="compile_+3A_compressed_formulation">compressed_formulation</code></td>
<td>
<p><code>logical</code> should the conservation problem
compiled into a compressed version of a planning problem?
If <code>TRUE</code> then the problem is expressed using the compressed
formulation. If <code>FALSE</code> then the problem is expressed using the
expanded formulation. If <code>NA</code>, then the compressed is used unless one
of the constraints requires the expanded formulation. This argument
defaults to <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function might be useful for those interested in understanding
how their conservation planning <code><a href="#topic+problem">problem()</a></code> is expressed
as a mathematical problem. However, if the problem just needs to
be solved, then the <code><a href="#topic+solve">solve()</a></code> function should just be used.
</p>
<p><strong>Please note that in nearly all cases, the default argument to
<code>compressed_formulation</code> should be used</strong>. The only situation where
manually
setting the argument to <code>formulation</code> is desirable is during testing.
Manually setting the argument to <code>formulation</code> will at best
have no effect on the problem. At worst, it may result in
an error, a misspecified problem, or unnecessarily long
solve times.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+optimization_problem">optimization_problem()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# build minimal conservation problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1)

# compile the conservation problem into an optimization problem
o &lt;- compile(p)

# print the optimization problem
print(o)

## End(Not run)
</code></pre>

<hr>
<h2 id='connectivity_matrix'>Connectivity matrix</h2><span id='topic+connectivity_matrix'></span><span id='topic+connectivity_matrix+2CSpatial+2Ccharacter-method'></span><span id='topic+connectivity_matrix+2CSpatial+2CRaster-method'></span><span id='topic+connectivity_matrix+2CRaster+2CRaster-method'></span><span id='topic+connectivity_matrix+2Csf+2Ccharacter-method'></span><span id='topic+connectivity_matrix+2Csf+2CRaster-method'></span><span id='topic+connectivity_matrix+2Csf+2CSpatRaster-method'></span><span id='topic+connectivity_matrix+2CSpatRaster+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Create a matrix showing the connectivity between planning units. Connectivity
is calculated as the average conductance of two planning units multiplied
by the amount of shared boundary between the two planning units. Thus
planning units that each have higher a conductance and share a greater
boundary are associated with greater connectivity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connectivity_matrix(x, y, ...)

## S4 method for signature 'Spatial,Raster'
connectivity_matrix(x, y, ...)

## S4 method for signature 'Spatial,character'
connectivity_matrix(x, y, ...)

## S4 method for signature 'sf,character'
connectivity_matrix(x, y, ...)

## S4 method for signature 'sf,Raster'
connectivity_matrix(x, y, ...)

## S4 method for signature 'sf,SpatRaster'
connectivity_matrix(x, y, ...)

## S4 method for signature 'Raster,Raster'
connectivity_matrix(x, y, ...)

## S4 method for signature 'SpatRaster,SpatRaster'
connectivity_matrix(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connectivity_matrix_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object representing planning units.</p>
</td></tr>
<tr><td><code id="connectivity_matrix_+3A_y">y</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object showing the conductance
of different areas across the study area, or a <code>character</code> object
denoting a column name in the attribute table of <code>x</code> that contains
the conductance values. Note that argument to <code>y</code> can only be a
<code>character</code> object if the argument to <code>x</code> is a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object.
Also, note that if the argument to <code>x</code> is a
<code><a href="terra.html#topic+rast">terra::rast()</a></code> object then
argument to <code>y</code> must have the same spatial properties as it
(i.e., coordinate system, extent, resolution).</p>
</td></tr>
<tr><td><code id="connectivity_matrix_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+fast_extract">fast_extract()</a></code> for
extracting and calculating the conductance values for each planning unit.
These arguments are only used if argument to <code>x</code> is a
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object and argument to <code>y</code> is a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shared boundary calculations are performed using
<code><a href="#topic+boundary_matrix">boundary_matrix()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="Matrix.html#topic+dsCMatrix-class">dsCMatrix</a></code> symmetric sparse matrix object.
Each row and column represents a planning unit.
Cells values indicate the connectivity between different pairs of planning
units.
To reduce computational burden, cells among the matrix diagonal are
set to zero. Furthermore, if the argument to <code>x</code> is a
<code><a href="terra.html#topic+rast">terra::rast()</a></code> object, then cells with missing (<code>NA</code>)
values are set to zero too.
</p>


<h3>See Also</h3>

<p>Connectivity matrix data might need rescaling to improve optimization
performance, see <code><a href="#topic+rescale_matrix">rescale_matrix()</a></code> to perform these calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()

# create connectivity matrix using raster planning unit data using
# the raster cost values to represent conductance
## extract 9 planning units
r &lt;- terra::crop(sim_pu_raster, terra::ext(c(0, 0.3, 0, 0.3)))

## extract conductance data for the 9 planning units
cd &lt;- terra::crop(sim_features, r)

## make connectivity matrix using the habitat suitability data for the
## second feature to represent the planning unit conductance data
cm_raster &lt;- connectivity_matrix(r, cd[[2]])

## plot data and matrix
plot(r, main = "planning units (raster)", axes = FALSE)
plot(cd[[2]], main = "conductivity", axes = FALSE)
Matrix::image(cm_raster,  main = "connectivity matrix")

# create connectivity matrix using polygon planning unit data using
# the habitat suitability data for the second feature to represent
# planning unit conductances
## subset data to 9 polygons
ply &lt;- sim_pu_polygons[c(1:3, 11:13, 20:22), ]

## make connectivity matrix
cm_ply &lt;- connectivity_matrix(ply, sim_features[[2]])

## plot data and matrix
plot(sf::st_geometry(ply), main = "planning units (polygons)")
plot(terra::crop(sim_features[[2]], ply), main = "connectivity")
Matrix::image(cm_ply, main = "connectivity matrix")

# create connectivity matrix using habitat suitability data for each feature,
# this could be useful if prioritizations should spatially clump
# together adjacent planning units that have suitable habitat
# for the same species (e.g., to maintain functional connectivity)

## let's use the raster data for this example, and we can generate the
## connectivity matrix that we would use in the prioritization by
## (1) generating a connectivity matrix for each feature separately, and
## and then (2) summing the values together
cm_sum &lt;- lapply(as.list(cd), connectivity_matrix, x = r) # make matrices
cm_sum &lt;- Reduce("+", cm_sum) # sum matrices together

## plot data and matrix
plot(r, main = "planning units (raster)", axes = FALSE)
Matrix::image(cm_sum, main = "connectivity matrix")

## we could take this example one step further, and use weights to indicate
## relative importance of maintaining functional connectivity
## for each feature (i.e., use the weighted sum instead of the sum)

## let's pretend that the first feature is 20 times more important
## than all the other species
weights &lt;- c(20, 1, 1, 1, 1)

## calculate connectivity matrix using weighted sum
cm_wsum &lt;- lapply(as.list(cd), connectivity_matrix, x = r) # make matrices
cm_wsum &lt;- Map("*", cm_wsum, weights) # multiply by weights
cm_wsum &lt;- Reduce("+", cm_wsum) # sum matrices together

## plot data and matrix
plot(r, main = "planning units (raster)", axes = FALSE)
Matrix::image(cm_wsum, main = "connectivity matrix")

## since the statistical distribution of the connectivity values
## for each feature (e.g., the mean and standard deviation of the
## connectivity values) are different, it might make sense -- depending
## on the goal of the conservation planning exercise and the underlying
## data -- to first normalize the conductance values before applying the
## weights and summing the data for feature together

### calculate functional connectivity matrix using the weighted sum of
### connectivity values that have been normalized by linearly re-scaling
### values
cm_lwsum &lt;- lapply(as.list(cd), connectivity_matrix, x = r) # make matrices
cm_lwsum &lt;- lapply(cm_lwsum, rescale_matrix, max = 1) # rescale matrices
cm_lwsum &lt;- Map("*", cm_lwsum, weights) # multiply by weights
cm_lwsum &lt;- Reduce("+", cm_lwsum) # sum matrices together

## plot data and matrix
plot(r, main = "planning units (raster)", axes = FALSE)
Matrix::image(cm_lwsum, main = "connectivity matrix")

## another approach for normalizing the data could be using z-scores
## note that after normalizing the data we would need to add a constant
## value so that none of the connectivity values are negative

### define helper functions
zscore &lt;- function(x) {x@x &lt;- (x@x - mean(x@x)) / sd(x@x); x}
min_non_zero_value &lt;- function(x) min(x@x)
add_non_zero_value &lt;- function(x, y) {x@x &lt;- x@x + y; x}

### calculate functional connectivity matrix using the weighted sum of
### connectivity values that have been normalized using z-scores,
### and transformed to account for negative values
cm_zwsum &lt;- lapply(as.list(cd), connectivity_matrix, x = r) # make matrices
cm_zwsum &lt;- lapply(cm_zwsum, zscore) # normalize using z-scores
min_value &lt;- min(sapply(cm_zwsum, min_non_zero_value)) # find min value
min_value &lt;- abs(min_value) + 0.01 # prepare constant for adding to matrices
cm_zwsum &lt;- lapply(cm_zwsum, add_non_zero_value, min_value) # add constant
cm_zwsum &lt;- Map("*", cm_zwsum, weights) # multiply by weights
cm_zwsum &lt;- Reduce("+", cm_zwsum) # sum matrices together

## plot data and matrix
plot(r, main = "planning units (raster)", axes = FALSE)
Matrix::image(cm_zwsum, main = "connectivity matrix")

## End(Not run)

</code></pre>

<hr>
<h2 id='ConservationModifier-class'>Conservation problem modifier class</h2><span id='topic+ConservationModifier-class'></span><span id='topic+ConservationModifier'></span>

<h3>Description</h3>

<p>This super-class is used to construct <code><a href="#topic+Objective-class">Objective</a></code>
<code><a href="#topic+Penalty-class">Penalty</a></code>, <code><a href="#topic+Target-class">Target</a></code>, <code><a href="#topic+Constraint-class">Constraint</a></code>,
<code><a href="#topic+Portfolio-class">Portfolio</a></code>, <code><a href="#topic+Solver-class">Solver</a></code>, and <code><a href="#topic+Decision-class">Decision</a></code> objects.
<strong>Only experts should use the fields and methods for this class directly.</strong>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p><code>character</code> value.</p>
</dd>
<dt><code>data</code></dt><dd><p><code>list</code> containing data.</p>
</dd>
<dt><code>internal</code></dt><dd><p><code>list</code> containing internal computed values.</p>
</dd>
<dt><code>compressed_formulation</code></dt><dd><p><code>logical</code> value indicating if the
object is compatible with a compressed formulation.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ConservationModifier-print"><code>ConservationModifier$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationModifier-show"><code>ConservationModifier$show()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationModifier-repr"><code>ConservationModifier$repr()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationModifier-calculate"><code>ConservationModifier$calculate()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationModifier-get_data"><code>ConservationModifier$get_data()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationModifier-set_data"><code>ConservationModifier$set_data()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationModifier-get_internal"><code>ConservationModifier$get_internal()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationModifier-set_internal"><code>ConservationModifier$set_internal()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationModifier-clone"><code>ConservationModifier$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ConservationModifier-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print information about the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationModifier$print()</pre></div>



<h5>Returns</h5>

<p>None.
</p>


<hr>
<a id="method-ConservationModifier-show"></a>



<h4>Method <code>show()</code></h4>

<p>Print information about the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationModifier$show()</pre></div>



<h5>Returns</h5>

<p>None.
</p>


<hr>
<a id="method-ConservationModifier-repr"></a>



<h4>Method <code>repr()</code></h4>

<p>Generate a character representation of the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationModifier$repr(compact = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>compact</code></dt><dd><p><code>logical</code> value indicating if the output value
should be compact? Defaults to <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>character</code> value.
</p>


<hr>
<a id="method-ConservationModifier-calculate"></a>



<h4>Method <code>calculate()</code></h4>

<p>Perform computations that need to be completed before applying
the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationModifier$calculate(x, y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code><a href="#topic+optimization_problem">optimization_problem()</a></code> object.</p>
</dd>
<dt><code>y</code></dt><dd><p><code><a href="#topic+problem">problem()</a></code> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-ConservationModifier-get_data"></a>



<h4>Method <code>get_data()</code></h4>

<p>Get values stored in the <code>data</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationModifier$get_data(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>character</code> name of data.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object. If the <code>data</code> field does not contain an object
associated with the argument to <code>x</code>, then a <code><a href="#topic+new_waiver">new_waiver()</a></code> object is
returned.
</p>


<hr>
<a id="method-ConservationModifier-set_data"></a>



<h4>Method <code>set_data()</code></h4>

<p>Set values stored in the <code>data</code> field. Note that this method will
overwrite existing data.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationModifier$set_data(x, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>character</code> name of data.</p>
</dd>
<dt><code>value</code></dt><dd><p>Object to store.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-ConservationModifier-get_internal"></a>



<h4>Method <code>get_internal()</code></h4>

<p>Get values stored in the <code>internal</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationModifier$get_internal(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>character</code> name of data.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object. If the <code>internal</code> field does not contain an object
associated with the argument to <code>x</code>, then a <code><a href="#topic+new_waiver">new_waiver()</a></code> object is
returned.
</p>


<hr>
<a id="method-ConservationModifier-set_internal"></a>



<h4>Method <code>set_internal()</code></h4>

<p>Set values stored in the <code>internal</code> field. Note that this method will
overwrite existing data.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationModifier$set_internal(x, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>character</code> name of data.</p>
</dd>
<dt><code>value</code></dt><dd><p>Object to store.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object. If the <code>internal</code> field does not contain an object
associated with the argument to <code>x</code>, then a <code><a href="#topic+new_waiver">new_waiver()</a></code> object is
returned.
</p>


<hr>
<a id="method-ConservationModifier-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationModifier$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+ConservationProblem-class">ConservationProblem-class</a></code>,
<code><a href="#topic+Constraint-class">Constraint-class</a></code>,
<code><a href="#topic+Decision-class">Decision-class</a></code>,
<code><a href="#topic+Objective-class">Objective-class</a></code>,
<code><a href="#topic+OptimizationProblem-class">OptimizationProblem-class</a></code>,
<code><a href="#topic+Penalty-class">Penalty-class</a></code>,
<code><a href="#topic+Portfolio-class">Portfolio-class</a></code>,
<code><a href="#topic+Solver-class">Solver-class</a></code>,
<code><a href="#topic+Target-class">Target-class</a></code>
</p>

<hr>
<h2 id='ConservationProblem-class'>Conservation problem class</h2><span id='topic+ConservationProblem-class'></span><span id='topic+ConservationProblem'></span>

<h3>Description</h3>

<p>This class is used to represent conservation planning problems.
It stores the data (e.g., planning units, and features) and
mathematical formulation (e.g., the objective, constraints,
and other design criteria) needed to generate prioritizations.
Most users should use <code><a href="#topic+problem">problem()</a></code> to generate new conservation problem
objects, and the functions distributed with the package to interact
with them (e.g., <code><a href="#topic+number_of_features">number_of_features()</a></code>, <code><a href="#topic+number_of_planning_units">number_of_planning_units()</a></code>).
<strong>Only experts should use the fields and methods for this class directly.</strong>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>data</code></dt><dd><p><code>list</code> containing data (e.g., planning units, costs).</p>
</dd>
<dt><code>defaults</code></dt><dd><p><code>list</code> indicating if other fields contain defaults.</p>
</dd>
<dt><code>objective</code></dt><dd><p><code><a href="#topic+Objective-class">Objective</a></code> object specifying the objective
function for the problem formulation.</p>
</dd>
<dt><code>decisions</code></dt><dd><p>s<code><a href="#topic+Decision-class">Decision</a></code> object specifying the decision types
for the problem formulation.</p>
</dd>
<dt><code>targets</code></dt><dd><p><code><a href="#topic+Target-class">Target</a></code> object specifying the representation
targets for the problem formulation.</p>
</dd>
<dt><code>constraints</code></dt><dd><p><code>list</code> containing <code><a href="#topic+Constraint-class">Constraint</a></code> objects that
specify constraints for the problem formulation.</p>
</dd>
<dt><code>penalties</code></dt><dd><p><code>list</code> containing <code><a href="#topic+Penalty-class">Penalty</a></code> objects that specify
penalties for the problem formulation.</p>
</dd>
<dt><code>portfolio</code></dt><dd><p><code><a href="#topic+Portfolio-class">Portfolio</a></code> object specifying the approach for
generating multiple solutions.</p>
</dd>
<dt><code>solver</code></dt><dd><p><code><a href="#topic+Solver-class">Solver</a></code> object specifying the solver for
generating solutions.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ConservationProblem-new"><code>ConservationProblem$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-summary"><code>ConservationProblem$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-print"><code>ConservationProblem$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-show"><code>ConservationProblem$show()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-repr"><code>ConservationProblem$repr()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-get_data"><code>ConservationProblem$get_data()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-set_data"><code>ConservationProblem$set_data()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-number_of_planning_units"><code>ConservationProblem$number_of_planning_units()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-planning_unit_indices"><code>ConservationProblem$planning_unit_indices()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-set_planning_unit_indices"><code>ConservationProblem$set_planning_unit_indices()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-planning_unit_indices_with_finite_costs"><code>ConservationProblem$planning_unit_indices_with_finite_costs()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-set_planning_unit_indices_with_finite_costs"><code>ConservationProblem$set_planning_unit_indices_with_finite_costs()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-number_of_total_units"><code>ConservationProblem$number_of_total_units()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-planning_unit_costs"><code>ConservationProblem$planning_unit_costs()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-set_planning_unit_costs"><code>ConservationProblem$set_planning_unit_costs()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-number_of_features"><code>ConservationProblem$number_of_features()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-feature_names"><code>ConservationProblem$feature_names()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-feature_abundances_in_planning_units"><code>ConservationProblem$feature_abundances_in_planning_units()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-set_feature_abundances_in_planning_units"><code>ConservationProblem$set_feature_abundances_in_planning_units()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-feature_positive_abundances_in_planning_units"><code>ConservationProblem$feature_positive_abundances_in_planning_units()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-set_feature_positive_abundances_in_planning_units"><code>ConservationProblem$set_feature_positive_abundances_in_planning_units()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-feature_abundances_in_total_units"><code>ConservationProblem$feature_abundances_in_total_units()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-feature_targets"><code>ConservationProblem$feature_targets()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-number_of_zones"><code>ConservationProblem$number_of_zones()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-zone_names"><code>ConservationProblem$zone_names()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-add_portfolio"><code>ConservationProblem$add_portfolio()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-add_solver"><code>ConservationProblem$add_solver()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-add_targets"><code>ConservationProblem$add_targets()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-add_objective"><code>ConservationProblem$add_objective()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-add_decisions"><code>ConservationProblem$add_decisions()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-add_constraint"><code>ConservationProblem$add_constraint()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-add_penalty"><code>ConservationProblem$add_penalty()</code></a>
</p>
</li>
<li> <p><a href="#method-ConservationProblem-clone"><code>ConservationProblem$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ConservationProblem-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new conservation problem object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$new(data = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>list</code> containing data</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>ConservationProblem</code> object.
</p>


<hr>
<a id="method-ConservationProblem-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Print extended information about the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$summary()</pre></div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-ConservationProblem-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print concise information about the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$print()</pre></div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-ConservationProblem-show"></a>



<h4>Method <code>show()</code></h4>

<p>Display concise information about the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$show()</pre></div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-ConservationProblem-repr"></a>



<h4>Method <code>repr()</code></h4>

<p>Generate a character representation of the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$repr()</pre></div>



<h5>Returns</h5>

<p>A <code>character</code> value.
</p>


<hr>
<a id="method-ConservationProblem-get_data"></a>



<h4>Method <code>get_data()</code></h4>

<p>Get values stored in the <code>data</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$get_data(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>character</code> name of data.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object. If the <code>data</code> field does not contain an object
associated with the argument to <code>x</code>, then a <code><a href="#topic+new_waiver">new_waiver()</a></code> object is
returned.
</p>


<hr>
<a id="method-ConservationProblem-set_data"></a>



<h4>Method <code>set_data()</code></h4>

<p>Set values stored in the <code>data</code> field. Note that this method will
overwrite existing data.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$set_data(x, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>character</code> name of data.</p>
</dd>
<dt><code>value</code></dt><dd><p>Object to store.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-ConservationProblem-number_of_planning_units"></a>



<h4>Method <code>number_of_planning_units()</code></h4>

<p>Obtain the number of planning units. The planning units correspond to
elements in the cost data
(e.g., indices, rows, geometries, pixels) that have finite
values in at least one zone. In other words, planning unit are
elements in the cost data that do not have missing (<code>NA</code>) values in
every zone.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$number_of_planning_units()</pre></div>



<h5>Returns</h5>

<p>An <code>integer</code> value.
</p>


<hr>
<a id="method-ConservationProblem-planning_unit_indices"></a>



<h4>Method <code>planning_unit_indices()</code></h4>

<p>Obtain the planning unit indices.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$planning_unit_indices()</pre></div>



<h5>Returns</h5>

<p>An <code>integer</code> vector.
</p>


<hr>
<a id="method-ConservationProblem-set_planning_unit_indices"></a>



<h4>Method <code>set_planning_unit_indices()</code></h4>

<p>Perform calculations to cache the planning unit indices.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$set_planning_unit_indices()</pre></div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-ConservationProblem-planning_unit_indices_with_finite_costs"></a>



<h4>Method <code>planning_unit_indices_with_finite_costs()</code></h4>

<p>Obtain the planning unit indices that are associated with
finite cost values.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$planning_unit_indices_with_finite_costs()</pre></div>



<h5>Returns</h5>

<p>A <code>list</code> of <code>integer</code> vectors. Each <code>list</code> element corresponds to
a different zone.
</p>


<hr>
<a id="method-ConservationProblem-set_planning_unit_indices_with_finite_costs"></a>



<h4>Method <code>set_planning_unit_indices_with_finite_costs()</code></h4>

<p>Perform calculations to cache the planning unit indices that are
associated with finite cost values.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$set_planning_unit_indices_with_finite_costs()</pre></div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-ConservationProblem-number_of_total_units"></a>



<h4>Method <code>number_of_total_units()</code></h4>

<p>Obtain the number of total units. The total units include all elements
in the cost data
(e.g., indices, rows, geometries, pixels), including those with
missing (<code>NA</code>) values.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$number_of_total_units()</pre></div>



<h5>Returns</h5>

<p>An <code>integer</code> value.
</p>


<hr>
<a id="method-ConservationProblem-planning_unit_costs"></a>



<h4>Method <code>planning_unit_costs()</code></h4>

<p>Obtain the planning unit costs.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$planning_unit_costs()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> matrix.
</p>


<hr>
<a id="method-ConservationProblem-set_planning_unit_costs"></a>



<h4>Method <code>set_planning_unit_costs()</code></h4>

<p>Perform calculations to cache the planning unit costs.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$set_planning_unit_costs()</pre></div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-ConservationProblem-number_of_features"></a>



<h4>Method <code>number_of_features()</code></h4>

<p>Obtain the number of features.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$number_of_features()</pre></div>



<h5>Returns</h5>

<p>An <code>integer</code> value.
</p>


<hr>
<a id="method-ConservationProblem-feature_names"></a>



<h4>Method <code>feature_names()</code></h4>

<p>Obtain the names of the features.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$feature_names()</pre></div>



<h5>Returns</h5>

<p>A <code>character</code> vector.
</p>


<hr>
<a id="method-ConservationProblem-feature_abundances_in_planning_units"></a>



<h4>Method <code>feature_abundances_in_planning_units()</code></h4>

<p>Obtain the abundance of the features in the planning units.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$feature_abundances_in_planning_units()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> matrix. Each column corresponds to a different zone
and each row corresponds to a different feature.
</p>


<hr>
<a id="method-ConservationProblem-set_feature_abundances_in_planning_units"></a>



<h4>Method <code>set_feature_abundances_in_planning_units()</code></h4>

<p>Perform calculations to cache the abundance of the features in the
planning units.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$set_feature_abundances_in_planning_units()</pre></div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-ConservationProblem-feature_positive_abundances_in_planning_units"></a>



<h4>Method <code>feature_positive_abundances_in_planning_units()</code></h4>

<p>Obtain the positive abundance of the features in the planning units.
Note that this method, unlike <code>feature_abundances_in_planning_units</code>,
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$feature_positive_abundances_in_planning_units()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> matrix. Each column corresponds to a different zone
and each row corresponds to a different feature.
</p>


<hr>
<a id="method-ConservationProblem-set_feature_positive_abundances_in_planning_units"></a>



<h4>Method <code>set_feature_positive_abundances_in_planning_units()</code></h4>

<p>Perform calculations to cache the positive abundance of the features in
the planning units.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$set_feature_positive_abundances_in_planning_units()</pre></div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-ConservationProblem-feature_abundances_in_total_units"></a>



<h4>Method <code>feature_abundances_in_total_units()</code></h4>

<p>Obtain the abundance of the features in the total units.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$feature_abundances_in_total_units()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> matrix. Each column corresponds to a different zone
and each row corresponds to a different feature.
</p>


<hr>
<a id="method-ConservationProblem-feature_targets"></a>



<h4>Method <code>feature_targets()</code></h4>

<p>Obtain the representation targets for the features.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$feature_targets()</pre></div>



<h5>Returns</h5>

<p><code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> data frame.
</p>


<hr>
<a id="method-ConservationProblem-number_of_zones"></a>



<h4>Method <code>number_of_zones()</code></h4>

<p>Obtain the number of zones.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$number_of_zones()</pre></div>



<h5>Returns</h5>

<p>An <code>integer</code> value.
</p>


<hr>
<a id="method-ConservationProblem-zone_names"></a>



<h4>Method <code>zone_names()</code></h4>

<p>Obtain the zone names.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$zone_names()</pre></div>



<h5>Returns</h5>

<p>A <code>character</code> vector.
</p>


<hr>
<a id="method-ConservationProblem-add_portfolio"></a>



<h4>Method <code>add_portfolio()</code></h4>

<p>Create a new object with a portfolio added to the problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$add_portfolio(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><a href="#topic+Portfolio-class">Portfolio</a> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An updated <code>ConservationProblem</code> object.
</p>


<hr>
<a id="method-ConservationProblem-add_solver"></a>



<h4>Method <code>add_solver()</code></h4>

<p>Create a new object with a solver added to the problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$add_solver(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><a href="#topic+Solver-class">Solver</a> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An updated <code>ConservationProblem</code> object.
</p>


<hr>
<a id="method-ConservationProblem-add_targets"></a>



<h4>Method <code>add_targets()</code></h4>

<p>Create a new object with targets added to the problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$add_targets(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><a href="#topic+Target-class">Target</a> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An updated <code>ConservationProblem</code> object.
</p>


<hr>
<a id="method-ConservationProblem-add_objective"></a>



<h4>Method <code>add_objective()</code></h4>

<p>Create a new object with an objective added to the problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$add_objective(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><a href="#topic+Objective-class">Objective</a> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An updated <code>ConservationProblem</code> object.
</p>


<hr>
<a id="method-ConservationProblem-add_decisions"></a>



<h4>Method <code>add_decisions()</code></h4>

<p>Create a new object with decisions added to the problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$add_decisions(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><a href="#topic+Decision-class">Decision</a> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An updated <code>ConservationProblem</code> object.
</p>


<hr>
<a id="method-ConservationProblem-add_constraint"></a>



<h4>Method <code>add_constraint()</code></h4>

<p>Create a new object with a constraint added to the problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$add_constraint(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><a href="#topic+Constraint-class">Constraint</a> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An updated <code>ConservationProblem</code> object.
</p>


<hr>
<a id="method-ConservationProblem-add_penalty"></a>



<h4>Method <code>add_penalty()</code></h4>

<p>Create a new object with a penalty added to the problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$add_penalty(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><a href="#topic+Penalty-class">Penalty</a> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An updated <code>ConservationProblem</code> object.
</p>


<hr>
<a id="method-ConservationProblem-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConservationProblem$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+ConservationModifier-class">ConservationModifier-class</a></code>,
<code><a href="#topic+Constraint-class">Constraint-class</a></code>,
<code><a href="#topic+Decision-class">Decision-class</a></code>,
<code><a href="#topic+Objective-class">Objective-class</a></code>,
<code><a href="#topic+OptimizationProblem-class">OptimizationProblem-class</a></code>,
<code><a href="#topic+Penalty-class">Penalty-class</a></code>,
<code><a href="#topic+Portfolio-class">Portfolio-class</a></code>,
<code><a href="#topic+Solver-class">Solver-class</a></code>,
<code><a href="#topic+Target-class">Target-class</a></code>
</p>

<hr>
<h2 id='Constraint-class'>Constraint class</h2><span id='topic+Constraint-class'></span><span id='topic+Constraint'></span>

<h3>Description</h3>

<p>This class is used to represent the constraints used in optimization.
<strong>Only experts should use the fields and methods for this class directly.</strong>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ConservationModifier">prioritizr::ConservationModifier</a></code> -&gt; <code>Constraint</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Constraint-apply"><code>Constraint$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-Constraint-clone"><code>Constraint$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="calculate"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-calculate'><code>prioritizr::ConservationModifier$calculate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_data'><code>prioritizr::ConservationModifier$get_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_internal'><code>prioritizr::ConservationModifier$get_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="print"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-print'><code>prioritizr::ConservationModifier$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="repr"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-repr'><code>prioritizr::ConservationModifier$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_data'><code>prioritizr::ConservationModifier$set_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_internal'><code>prioritizr::ConservationModifier$set_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="show"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-show'><code>prioritizr::ConservationModifier$show()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Constraint-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Update an optimization problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Constraint$apply(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code><a href="#topic+optimization_problem">optimization_problem()</a></code> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-Constraint-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Constraint$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+ConservationModifier-class">ConservationModifier-class</a></code>,
<code><a href="#topic+ConservationProblem-class">ConservationProblem-class</a></code>,
<code><a href="#topic+Decision-class">Decision-class</a></code>,
<code><a href="#topic+Objective-class">Objective-class</a></code>,
<code><a href="#topic+OptimizationProblem-class">OptimizationProblem-class</a></code>,
<code><a href="#topic+Penalty-class">Penalty-class</a></code>,
<code><a href="#topic+Portfolio-class">Portfolio-class</a></code>,
<code><a href="#topic+Solver-class">Solver-class</a></code>,
<code><a href="#topic+Target-class">Target-class</a></code>
</p>

<hr>
<h2 id='constraints'>Conservation problem constraints</h2><span id='topic+constraints'></span>

<h3>Description</h3>

<p>A constraint can be added to a conservation planning problem
to ensure that solutions exhibit a specific characteristic.
</p>


<h3>Details</h3>

<p>Constraints can be used to ensure that solutions exhibit
a range of different characteristics. For instance, they can be
used to lock in or lock out certain planning units from the solution, such
as protected areas or degraded land (respectively).
Additionally, similar to the <a href="#topic+penalties">penalties</a> functions,
some of the constraint functions can be used to increase connectivity in a
solution. The key difference between a penalty and a constraint, however,
is that constraints work by invalidating solutions that do not exhibit
a specific characteristic, whereas penalty functions work by than
penalizing solutions which do not meet a specific characteristic. Thus
constraints do not affect the objective function. The following constraints
are available.
</p>
<p>The following constraints can be added to a conservation planning
<code><a href="#topic+problem">problem()</a></code>:
</p>

<dl>
<dt><code><a href="#topic+add_locked_in_constraints">add_locked_in_constraints()</a></code></dt><dd>
<p>Add constraints to ensure
that certain planning units are selected in the solution.</p>
</dd>
<dt><code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints()</a></code></dt><dd>
<p>Add constraints to ensure
that certain planning units are not selected in the solution.</p>
</dd>
<dt><code><a href="#topic+add_neighbor_constraints">add_neighbor_constraints()</a></code></dt><dd>
<p>Add constraints to
ensure that all selected planning units have at least a certain number
of neighbors.</p>
</dd>
<dt><code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints()</a></code></dt><dd>
<p>Add constraints to a
ensure that all selected planning units are spatially connected to each
other and form a single contiguous unit.</p>
</dd>
<dt><code><a href="#topic+add_feature_contiguity_constraints">add_feature_contiguity_constraints()</a></code></dt><dd>
<p>Add constraints to
ensure that each feature is represented in a contiguous unit of
dispersible habitat. These constraints are a more advanced version of
those implemented in the <code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints()</a></code>
function, because they ensure that each feature is represented in a
contiguous unit and not that the entire solution should form a
contiguous unit.</p>
</dd>
<dt><code><a href="#topic+add_linear_constraints">add_linear_constraints()</a></code></dt><dd>
<p>Add constraints to ensure that all selected planning units meet certain
criteria. For example, they can be used to add
multiple budgets, or limit the number of
planning units selected in different administrative areas within a study
region (e.g., different countries).</p>
</dd>
<dt><code><a href="#topic+add_mandatory_allocation_constraints">add_mandatory_allocation_constraints()</a></code></dt><dd>
<p>Add constraints to ensure that every planning unit is allocated to a
management zone in the solution. <strong>This function can only be used
with problems that contain multiple zones.</strong></p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other overviews: 
<code><a href="#topic+decisions">decisions</a></code>,
<code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+objectives">objectives</a></code>,
<code><a href="#topic+penalties">penalties</a></code>,
<code><a href="#topic+portfolios">portfolios</a></code>,
<code><a href="#topic+solvers">solvers</a></code>,
<code><a href="#topic+summaries">summaries</a></code>,
<code><a href="#topic+targets">targets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_locked_in_raster &lt;- get_sim_locked_in_raster()
sim_locked_out_raster &lt;- get_sim_locked_in_raster()

# create minimal problem with only targets and no additional constraints
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with locked in constraints
p2 &lt;- p1 %&gt;% add_locked_in_constraints(sim_locked_in_raster)

# create problem with locked in constraints
p3 &lt;- p1 %&gt;% add_locked_out_constraints(sim_locked_out_raster)

# create problem with neighbor constraints
p4 &lt;- p1 %&gt;% add_neighbor_constraints(2)

# create problem with contiguity constraints
p5 &lt;- p1 %&gt;% add_contiguity_constraints()

# create problem with feature contiguity constraints
p6 &lt;- p1 %&gt;% add_feature_contiguity_constraints()

# solve problems
s &lt;- terra::rast(lapply(list(p1, p2, p3, p4, p5, p6), solve))
names(s) &lt;- c(
  "minimal problem", "locked in", "locked out",
  "neighbor", "contiguity", "feature contiguity"
)

# plot solutions
plot(s, axes = FALSE, nr = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='Decision-class'>Decision class</h2><span id='topic+Decision-class'></span><span id='topic+Decision'></span>

<h3>Description</h3>

<p>This class is used to represent the decision variables used in optimization.
<strong>Only experts should use the fields and methods for this class directly.</strong>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ConservationModifier">prioritizr::ConservationModifier</a></code> -&gt; <code>Decision</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Decision-apply"><code>Decision$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-Decision-clone"><code>Decision$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="calculate"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-calculate'><code>prioritizr::ConservationModifier$calculate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_data'><code>prioritizr::ConservationModifier$get_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_internal'><code>prioritizr::ConservationModifier$get_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="print"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-print'><code>prioritizr::ConservationModifier$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="repr"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-repr'><code>prioritizr::ConservationModifier$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_data'><code>prioritizr::ConservationModifier$set_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_internal'><code>prioritizr::ConservationModifier$set_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="show"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-show'><code>prioritizr::ConservationModifier$show()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Decision-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Update an optimization problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Decision$apply(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code><a href="#topic+optimization_problem">optimization_problem()</a></code> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-Decision-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Decision$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+ConservationModifier-class">ConservationModifier-class</a></code>,
<code><a href="#topic+ConservationProblem-class">ConservationProblem-class</a></code>,
<code><a href="#topic+Constraint-class">Constraint-class</a></code>,
<code><a href="#topic+Objective-class">Objective-class</a></code>,
<code><a href="#topic+OptimizationProblem-class">OptimizationProblem-class</a></code>,
<code><a href="#topic+Penalty-class">Penalty-class</a></code>,
<code><a href="#topic+Portfolio-class">Portfolio-class</a></code>,
<code><a href="#topic+Solver-class">Solver-class</a></code>,
<code><a href="#topic+Target-class">Target-class</a></code>
</p>

<hr>
<h2 id='decisions'>Add decision types</h2><span id='topic+decisions'></span>

<h3>Description</h3>

<p>Conservation planning problems involve making decisions on
how different planning units will be managed. These decisions might involve
turning an entire planning unit into a protected area, turning part
of a planning unit into a protected area, or allocating a planning
unit to a specific management zone. If no decision is explicitly added to a
problem, then binary decisions will be used by default.
</p>


<h3>Details</h3>

<p>Only a single type of decision can be added to a conservation
planning <code><a href="#topic+problem">problem()</a></code>. Note that if multiple decisions are added
to a problem, then the last one added will be used.
</p>
<p>The following decisions can be added to a conservation planning
<code><a href="#topic+problem">problem()</a></code>:
</p>

<dl>
<dt><code><a href="#topic+add_binary_decisions">add_binary_decisions()</a></code></dt><dd><p>Add a binary decision to a
conservation planning <code>problem</code>. This is the classic decision of
either prioritizing or not prioritizing a planning unit. Typically, this
decision has the assumed action of buying the planning unit to include
in a protected area network. If no decision is added to a problem object
then this decision class will be used by default.</p>
</dd>
<dt><code><a href="#topic+add_proportion_decisions">add_proportion_decisions()</a></code></dt><dd><p>Add a proportion decision to
a conservation planning <code>problem</code>. This is a relaxed decision
where a part of a planning unit can be prioritized, as opposed to the
default of the entire planning unit. Typically, this decision
has the assumed action of buying a fraction of a planning unit to
include in a protected area network.</p>
</dd>
<dt><code><a href="#topic+add_semicontinuous_decisions">add_semicontinuous_decisions()</a></code></dt><dd><p>Add a semi-continuous
decision to a conservation planning <code>problem</code>. This decision is
similar to <code>add_proportion_decision</code> except that it has an upper
bound parameter. By default, the decision can range from prioritizing
none (0%) to all (100%) of a planning unit. However, a upper
bound can be specified to ensure that at most only a fraction
(e.g., 80%) of a planning unit can be preserved. This type of
decision may be useful when it is not practical to conserve the
entire area encompassed by any single planning unit.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other overviews: 
<code><a href="#topic+constraints">constraints</a></code>,
<code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+objectives">objectives</a></code>,
<code><a href="#topic+penalties">penalties</a></code>,
<code><a href="#topic+portfolios">portfolios</a></code>,
<code><a href="#topic+solvers">solvers</a></code>,
<code><a href="#topic+summaries">summaries</a></code>,
<code><a href="#topic+targets">targets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create basic problem and using the default decision types (binary)
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with manually specified binary decisions
p2 &lt;- p1 %&gt;% add_binary_decisions()

# create problem with proportion decisions
p3 &lt;- p1 %&gt;% add_proportion_decisions()

# create problem with semicontinuous decisions
p4 &lt;- p1 %&gt;% add_semicontinuous_decisions(upper_limit = 0.5)

# solve problem
s &lt;- c(solve(p1), solve(p2), solve(p3), solve(p4))
names(s) &lt;- c(
  "default (binary)", "binary", "proportion", "semicontinuous (upper = 0.5)"
)
# plot solutions
plot(s)

## End(Not run)

</code></pre>

<hr>
<h2 id='eval_asym_connectivity_summary'>Evaluate asymmetric connectivity of solution</h2><span id='topic+eval_asym_connectivity_summary'></span><span id='topic+eval_asym_connectivity_summary+2CConservationProblem+2CANY+2CANY+2CMatrix-method'></span><span id='topic+eval_asym_connectivity_summary+2CConservationProblem+2CANY+2CANY+2Cmatrix-method'></span><span id='topic+eval_asym_connectivity_summary+2CConservationProblem+2CANY+2CANY+2CdgCMatrix-method'></span><span id='topic+eval_asym_connectivity_summary+2CConservationProblem+2CANY+2CANY+2Cdata.frame-method'></span><span id='topic+eval_asym_connectivity_summary+2CConservationProblem+2CANY+2CANY+2Carray-method'></span>

<h3>Description</h3>

<p>Calculate the connectivity held within a solution to a conservation
planning problem.
This summary statistic evaluates the connectivity of a solution using
pair-wise connectivity values between combinations of planning units.
It is specifically designed for asymmetric connectivity data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConservationProblem,ANY,ANY,matrix'
eval_asym_connectivity_summary(x, solution, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,Matrix'
eval_asym_connectivity_summary(x, solution, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,data.frame'
eval_asym_connectivity_summary(x, solution, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,dgCMatrix'
eval_asym_connectivity_summary(x, solution, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,array'
eval_asym_connectivity_summary(x, solution, zones, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_asym_connectivity_summary_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="eval_asym_connectivity_summary_+3A_solution">solution</code></td>
<td>
<p><code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object.
The argument should be in the same format as the planning unit cost
data in the argument to <code>x</code>.
See the Solution format section for more information.</p>
</td></tr>
<tr><td><code id="eval_asym_connectivity_summary_+3A_zones">zones</code></td>
<td>
<p><code>matrix</code> or <code>Matrix</code> object describing the
level of connectivity between different zones. Each row and column
corresponds to a different zone in the argument to <code>x</code>, and cell
values indicate the level of connectivity between each combination
of zones. Cell values along the diagonal of the matrix represent
the level of connectivity between planning units allocated to the
same zone. Cell values must lay between 1 and -1, where negative
values favor solutions with weak connectivity. The default argument to
<code>zones</code> is an identity matrix (i.e., a matrix with ones along the
matrix diagonal and zeros elsewhere), so that planning units are
only considered to be connected when they are allocated to the same zone.
This argument is required when working with multiple zones and the
argument to <code>data</code> is a <code>matrix</code> or <code>Matrix</code> object.
If the argument to <code>data</code> is an <code>array</code> or <code>data.frame</code> with data for
multiple zones (e.g., using the <code>"zone1"</code> and <code>"zone2"</code> column names),
this argument must explicitly be set to <code>NULL</code> otherwise an error will be
thrown.</p>
</td></tr>
<tr><td><code id="eval_asym_connectivity_summary_+3A_data">data</code></td>
<td>
<p><code>matrix</code>, <code>Matrix</code>, <code>data.frame</code>, or
<code>array</code> object containing connectivity data. The connectivity values
correspond to the strength of connectivity between
different planning units. Thus connections between planning units
that are associated with higher values are more favorable in the solution.
See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This summary statistic is comparable to the <code>Connectivity</code> metric
reported by the
<a href="https://marxansolutions.org"><em>Marxan</em> software</a> (Ball <em>et al.</em> 2009).
It is calculated using the same equations used to penalize solutions
with asymmetric connectivity data
(i.e., <code><a href="#topic+add_asym_connectivity_penalties">add_asym_connectivity_penalties()</a></code>).
Specifically, it is calculated as the sum of the connectivity
values (in the argument to <code>data</code>) that correspond pairs of planning
units, wherein one planning unit is selected by the solution
and the other planning unit is not selected by solution.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> object describing the connectivity of the
solution.
It contains the following columns:
</p>

<dl>
<dt>summary</dt><dd><p><code>character</code> description of the summary statistic.
The statistic associated with the <code>"overall"</code> value
in this column is calculated using the entire solution
(including all management zones if there are multiple zones).
If multiple management zones are present, then summary statistics
are also provided for each zone separately
(indicated using zone names).</p>
</dd>
<dt>asym_connectivity</dt><dd><p><code>numeric</code> connectivity value.
Greater values correspond to solutions associated with greater
connectivity.
Thus conservation planning exercises typically prefer solutions
with greater values.</p>
</dd>
</dl>



<h3>Solution format</h3>

<p>Broadly speaking, the argument to <code>solution</code> must be in the same format as
the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt><code>x</code> has <code>numeric</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>matrix</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The argument to <code>solution</code>
be a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>data.frame</code> planning units</dt><dd><p>The argument to <code>solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code><a href="sf.html#topic+sf">sf::sf()</a></code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code> planning units</dt><dd><p>The argument to <code>solution</code> must be
a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
</dl>



<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using several different formats.
</p>

<dl>
<dt><code>data</code> as a <code>matrix</code>/<code>Matrix</code> object</dt><dd><p>where rows and columns represent
different planning units and the value of each cell represents the
strength of connectivity between two different planning units. Cells
that occur along the matrix diagonal are treated as weights which
indicate that planning units are more desirable in the solution.
The argument to <code>zones</code> can be used to control
the strength of connectivity between planning units in different zones.
The default argument for <code>zones</code> is to treat planning units
allocated to different zones as having zero connectivity.</p>
</dd>
<dt><code>data</code> as a <code>data.frame</code> object</dt><dd><p>containing columns that are named
<code>"id1"</code>, <code>"id2"</code>, and <code>"boundary"</code>. Here, each row
denotes the connectivity between a pair of planning units
(per values in the <code>"id1"</code> and <code>"id2"</code> columns) following the
<em>Marxan</em> format.
If the argument to <code>x</code> contains multiple zones, then the
<code>"zone1"</code> and <code>"zone2"</code> columns can optionally be provided to manually
specify the connectivity values between planning units when they are
allocated to specific zones. If the <code>"zone1"</code> and
<code>"zone2"</code> columns are present, then the argument to <code>zones</code> must be
<code>NULL</code>.</p>
</dd>
<dt><code>data</code> as an <code>array</code> object</dt><dd>
<p>containing four-dimensions where cell values
indicate the strength of connectivity between planning units
when they are assigned to specific management zones. The first two
dimensions (i.e., rows and columns) indicate the strength of
connectivity between different planning units and the second two
dimensions indicate the different management zones. Thus
the <code>data[1, 2, 3, 4]</code> indicates the strength of
connectivity between planning unit 1 and planning unit 2 when planning
unit 1 is assigned to zone 3 and planning unit 2 is assigned to zone 4.</p>
</dd>
</dl>



<h3>References</h3>

<p>Ball IR, Possingham HP, and Watts M (2009) <em>Marxan and relatives:
Software for spatial conservation prioritisation</em> in Spatial conservation
prioritisation: Quantitative methods and computational tools. Eds Moilanen
A, Wilson KA, and Possingham HP. Oxford University Press, Oxford, UK.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+summaries">summaries</a> for an overview of all functions for summarizing solutions.
Also, see <code><a href="#topic+add_asym_connectivity_penalties">add_asym_connectivity_penalties()</a></code> to penalize solutions with low
asymmetric connectivity.
</p>
<p>Other summaries: 
<code><a href="#topic+eval_boundary_summary">eval_boundary_summary</a>()</code>,
<code><a href="#topic+eval_connectivity_summary">eval_connectivity_summary</a>()</code>,
<code><a href="#topic+eval_cost_summary">eval_cost_summary</a>()</code>,
<code><a href="#topic+eval_feature_representation_summary">eval_feature_representation_summary</a>()</code>,
<code><a href="#topic+eval_n_summary">eval_n_summary</a>()</code>,
<code><a href="#topic+eval_target_coverage_summary">eval_target_coverage_summary</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# build minimal conservation problem with polygon data
p1 &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s1 &lt;- solve(p1)

# print solution
print(s1)

# plot solution
plot(s1[, "solution_1"])

# simulate connectivity matrix
# here, we will generate connectivity values randomly
# between all pairs of planning units
acm1 &lt;- matrix(
  runif(nrow(sim_pu_polygons) ^ 2),
  nrow = nrow(sim_pu_polygons)
)

# calculate connectivity associated with the solution
r1 &lt;- eval_asym_connectivity_summary(p1, s1[, "solution_1"], data = acm1)
print(r1)

# build multi-zone conservation problem with polygon data
p2 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
     cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s2 &lt;- solve(p2)

# print solution
print(s2)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s2$solution &lt;- category_vector(
  s2[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
s2$solution &lt;- factor(s2$solution)

# plot solution
plot(s2[, "solution"])

# simulate asymmetric connectivity matrix
acm2 &lt;- matrix(
  runif(nrow(sim_zones_pu_polygons) ^ 2),
  nrow = nrow(sim_zones_pu_polygons)
)

# calculate connectivity associated with the solution
r2 &lt;- eval_asym_connectivity_summary(
  p2,
  s2[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")],
  data = acm2
)
print(r2)


## End(Not run)

</code></pre>

<hr>
<h2 id='eval_boundary_summary'>Evaluate boundary length of solution</h2><span id='topic+eval_boundary_summary'></span>

<h3>Description</h3>

<p>Calculate the exposed boundary length (i.e., perimeter) associated with a
solution to a conservation planning problem.
This summary statistic is useful for evaluating the spatial fragmentation of
planning units selected within a solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_boundary_summary(
  x,
  solution,
  edge_factor = rep(0.5, number_of_zones(x)),
  zones = diag(number_of_zones(x)),
  data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_boundary_summary_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="eval_boundary_summary_+3A_solution">solution</code></td>
<td>
<p><code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object.
The argument should be in the same format as the planning unit cost
data in the argument to <code>x</code>.
See the Solution format section for more information.</p>
</td></tr>
<tr><td><code id="eval_boundary_summary_+3A_edge_factor">edge_factor</code></td>
<td>
<p><code>numeric</code> proportion to scale
planning unit edges (borders) that do not have any neighboring planning
units. For example, an edge factor of <code>0.5</code> is commonly used to
avoid overly penalizing planning units along a coastline.
Note that this argument must have an element for each zone in the argument
to <code>x</code>.</p>
</td></tr>
<tr><td><code id="eval_boundary_summary_+3A_zones">zones</code></td>
<td>
<p><code>matrix</code> or <code>Matrix</code> object describing the
clumping scheme for different zones. Each row and column corresponds to a
different zone in the argument to <code>x</code>, and cell values indicate the
relative importance of clumping planning units that are allocated to
a combination of zones. Cell values along the diagonal of the matrix
represent the relative importance of clumping planning units that are
allocated to the same zone. Cell values must range between 1 and -1, where
negative values favor solutions that spread out planning units. The default
argument to <code>zones</code> is an identity
matrix (i.e., a matrix with ones along the matrix diagonal and zeros
elsewhere), so that penalties are incurred when neighboring planning units
are not assigned to the same zone. If the cells along
the matrix diagonal contain markedly smaller values than those found
elsewhere in the matrix, then solutions are preferred that surround
planning units with those allocated to different zones
(i.e., greater spatial fragmentation).</p>
</td></tr>
<tr><td><code id="eval_boundary_summary_+3A_data">data</code></td>
<td>
<p><code>NULL</code>, <code>data.frame</code>, <code>matrix</code>, or <code>Matrix</code>
object containing the boundary data. These data describe the total
amount of boundary (perimeter) length  for each planning unit,
and the amount of boundary (perimeter) length shared between different
planning units (i.e., planning units that are adjacent to each other).
See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This summary statistic is equivalent to the <code>Connectivity_Edge</code> metric
reported by the <a href="https://marxansolutions.org"><em>Marxan</em> software</a>
(Ball <em>et al.</em> 2009).
It is calculated using the same equations used to penalize solutions
according to their total exposed boundary (i.e., <code><a href="#topic+add_boundary_penalties">add_boundary_penalties()</a></code>).
See the Examples section for examples on how differences <code>zone</code> arguments
can be used to calculate boundaries for different combinations of zones.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> object containing the boundary length of the
solution.
It contains the following columns:
</p>

<dl>
<dt>summary</dt><dd><p><code>character</code> description of the summary statistic.
The statistic associated with the <code>"overall"</code> value
in this column is calculated using the entire solution
(including all management zones if there are multiple zones).
If multiple management zones are present, then summary statistics
are also provided for each zone separately
(indicated using zone names).</p>
</dd>
<dt>boundary</dt><dd><p><code>numeric</code> exposed boundary length value.
Greater values correspond to solutions with greater
boundary length and, in turn, greater spatial fragmentation.
Thus conservation planning exercises typically prefer solutions
with smaller values.</p>
</dd>
</dl>



<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using the following formats.
Note that boundary data must always describe symmetric relationships
between planning units.
</p>

<dl>
<dt><code>data</code> as a <code>NULL</code> value</dt><dd><p>indicating that the data should be
automatically calculated using the <code><a href="#topic+boundary_matrix">boundary_matrix()</a></code> function.
This argument is the default.
Note that the boundary data must be supplied
using one of the other formats below if the planning unit data
in the argument to <code>x</code> do not explicitly contain spatial information
(e.g., planning unit data are a <code>data.frame</code> or <code>numeric</code> class).</p>
</dd>
<dt><code>data</code> as a <code>matrix</code>/<code>Matrix</code> object</dt><dd><p>where rows and columns represent
different planning units and the value of each cell represents the
amount of shared boundary length between two different planning units.
Cells that occur along the matrix diagonal denote the total
boundary length associated with each planning unit.</p>
</dd>
<dt><code>data</code> as a <code>data.frame</code> object</dt><dd><p>with the columns <code>"id1"</code>,
<code>"id2"</code>, and <code>"boundary"</code>. The <code>"id1"</code> and <code>"id2"</code> columns contain
identifiers (indices) for a pair of planning units, and the <code>"boundary"</code>
column contains the amount of shared boundary length between these
two planning units.
Additionally, if the values in the <code>"id1"</code> and <code>"id2"</code> columns
contain the same values, then the value denotes the
amount of exposed boundary length (not total boundary).
This format follows the the standard <em>Marxan</em> format for boundary
data (i.e., per the &quot;bound.dat&quot; file).</p>
</dd>
</dl>



<h3>Solution format</h3>

<p>Broadly speaking, the argument to <code>solution</code> must be in the same format as
the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt><code>x</code> has <code>numeric</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>matrix</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The argument to <code>solution</code>
be a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>data.frame</code> planning units</dt><dd><p>The argument to <code>solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code><a href="sf.html#topic+sf">sf::sf()</a></code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code> planning units</dt><dd><p>The argument to <code>solution</code> must be
a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Ball IR, Possingham HP, and Watts M (2009) <em>Marxan and relatives:
Software for spatial conservation prioritisation</em> in Spatial conservation
prioritisation: Quantitative methods and computational tools. Eds Moilanen
A, Wilson KA, and Possingham HP. Oxford University Press, Oxford, UK.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+summaries">summaries</a> for an overview of all functions for summarizing solutions.
Also, see <code><a href="#topic+add_boundary_penalties">add_boundary_penalties()</a></code> to penalize solutions with high
boundary length.
</p>
<p>Other summaries: 
<code><a href="#topic+eval_asym_connectivity_summary">eval_asym_connectivity_summary</a>()</code>,
<code><a href="#topic+eval_connectivity_summary">eval_connectivity_summary</a>()</code>,
<code><a href="#topic+eval_cost_summary">eval_cost_summary</a>()</code>,
<code><a href="#topic+eval_feature_representation_summary">eval_feature_representation_summary</a>()</code>,
<code><a href="#topic+eval_n_summary">eval_n_summary</a>()</code>,
<code><a href="#topic+eval_target_coverage_summary">eval_target_coverage_summary</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# build minimal conservation problem with raster data
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s1 &lt;- solve(p1)

# print solution
print(s1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# calculate boundary associated with the solution
r1 &lt;- eval_boundary_summary(p1, s1)
print(r1)

# build minimal conservation problem with polygon data
p2 &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s2 &lt;- solve(p2)

# print solution
print(s2)

# plot solution
plot(s2[, "solution_1"])

# calculate boundary associated with the solution
r2 &lt;- eval_boundary_summary(p2, s2[, "solution_1"])
print(r2)

# build multi-zone conservation problem with polygon data
p3 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s3 &lt;- solve(p3)

# print solution
print(s3)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s3$solution &lt;- category_vector(
  s3[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
s3$solution &lt;- factor(s3$solution)

# plot solution
plot(s3[, "solution"])

# calculate boundary associated with the solution
# here we will use the default argument for zones which treats each
# zone as completely separate, meaning that the "overall"
# boundary is just the sum of the boundaries for each zone
r3 &lt;- eval_boundary_summary(
  p3, s3[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
print(r3)

# let's calculate the overall exposed boundary across the entire
# solution, assuming that the shared boundaries between planning
# units allocated to different zones "count" just as much
# as those for planning units allocated to the same zone

# in other words, let's calculate the overall exposed boundary
# across the entire solution by "combining" all selected planning units
# together (regardless of which zone they are allocated to in the solution)
r3_combined &lt;- eval_boundary_summary(
  p3, zones = matrix(1, ncol = 3, nrow = 3),
  s3[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
print(r3_combined)

# we can see that the "overall" boundary is now less than the
# sum of the individual zone boundaries, because it does not
# consider the shared boundary between two planning units allocated to
# different zones as "exposed" when performing the calculations

## End(Not run)
</code></pre>

<hr>
<h2 id='eval_connectivity_summary'>Evaluate connectivity of solution</h2><span id='topic+eval_connectivity_summary'></span><span id='topic+eval_connectivity_summary+2CConservationProblem+2CANY+2CANY+2CMatrix-method'></span><span id='topic+eval_connectivity_summary+2CConservationProblem+2CANY+2CANY+2Cmatrix-method'></span><span id='topic+eval_connectivity_summary+2CConservationProblem+2CANY+2CANY+2CdgCMatrix-method'></span><span id='topic+eval_connectivity_summary+2CConservationProblem+2CANY+2CANY+2Cdata.frame-method'></span><span id='topic+eval_connectivity_summary+2CConservationProblem+2CANY+2CANY+2Carray-method'></span>

<h3>Description</h3>

<p>Calculate the connectivity held within a solution to a conservation
planning problem.
This summary statistic evaluates the connectivity of a solution using
pair-wise connectivity values between combinations of planning units.
It is specifically designed for symmetric connectivity data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConservationProblem,ANY,ANY,matrix'
eval_connectivity_summary(x, solution, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,Matrix'
eval_connectivity_summary(x, solution, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,data.frame'
eval_connectivity_summary(x, solution, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,dgCMatrix'
eval_connectivity_summary(x, solution, zones, data)

## S4 method for signature 'ConservationProblem,ANY,ANY,array'
eval_connectivity_summary(x, solution, zones, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_connectivity_summary_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="eval_connectivity_summary_+3A_solution">solution</code></td>
<td>
<p><code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object.
The argument should be in the same format as the planning unit cost
data in the argument to <code>x</code>.
See the Solution format section for more information.</p>
</td></tr>
<tr><td><code id="eval_connectivity_summary_+3A_zones">zones</code></td>
<td>
<p><code>matrix</code> or <code>Matrix</code> object describing the
level of connectivity between different zones. Each row and column
corresponds to a different zone in the argument to <code>x</code>, and cell
values indicate the level of connectivity between each combination
of zones. Cell values along the diagonal of the matrix represent
the level of connectivity between planning units allocated to the
same zone. Cell values must lay between 1 and -1, where negative
values favor solutions with weak connectivity. The default argument to
<code>zones</code> is an identity matrix (i.e., a matrix with ones along the
matrix diagonal and zeros elsewhere), so that planning units are
only considered to be connected when they are allocated to the same zone.
This argument is required when working with multiple zones and the
argument to <code>data</code> is a <code>matrix</code> or <code>Matrix</code> object.
If the argument to <code>data</code> is an <code>array</code> or <code>data.frame</code> with data for
multiple zones (e.g., using the <code>"zone1"</code> and <code>"zone2"</code> column names),
this argument must explicitly be set to <code>NULL</code> otherwise an error will be
thrown.</p>
</td></tr>
<tr><td><code id="eval_connectivity_summary_+3A_data">data</code></td>
<td>
<p><code>matrix</code>, <code>Matrix</code>, <code>data.frame</code>, or
<code>array</code> object containing connectivity data. The connectivity values
correspond to the strength of connectivity between
different planning units. Thus connections between planning units
that are associated with higher values are more favorable in the solution.
See the Data format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This summary statistic is comparable to the <code>Connectivity_In</code> metric
reported by the
<a href="https://marxansolutions.org"><em>Marxan</em> software</a> (Ball <em>et al.</em> 2009).
It is calculated using the same equations used to penalize solutions
with connectivity data (i.e., <code><a href="#topic+add_connectivity_penalties">add_connectivity_penalties()</a></code>).
Specifically, it is calculated as the sum of the pair-wise connectivity
values in the argument to <code>data</code>, weighted by the value of the planning
units in the solution.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> object describing the connectivity of the
solution.
It contains the following columns:
</p>

<dl>
<dt>summary</dt><dd><p><code>character</code> description of the summary statistic.
The statistic associated with the <code>"overall"</code> value
in this column is calculated using the entire solution
(including all management zones if there are multiple zones).
If multiple management zones are present, then summary statistics
are also provided for each zone separately
(indicated using zone names).</p>
</dd>
<dt>connectivity</dt><dd><p><code>numeric</code> connectivity value.
Greater values correspond to solutions associated with greater
connectivity.
Thus conservation planning exercises typically prefer solutions
with greater values.</p>
</dd>
</dl>



<h3>Solution format</h3>

<p>Broadly speaking, the argument to <code>solution</code> must be in the same format as
the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt><code>x</code> has <code>numeric</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>matrix</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The argument to <code>solution</code>
be a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>data.frame</code> planning units</dt><dd><p>The argument to <code>solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code><a href="sf.html#topic+sf">sf::sf()</a></code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code> planning units</dt><dd><p>The argument to <code>solution</code> must be
a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
</dl>



<h3>Data format</h3>

<p>The argument to <code>data</code> can be specified using several different formats.
</p>

<dl>
<dt><code>data</code> as a <code>matrix</code>/<code>Matrix</code> object</dt><dd><p>where rows and columns represent
different planning units and the value of each cell represents the
strength of connectivity between two different planning units. Cells
that occur along the matrix diagonal are treated as weights which
indicate that planning units are more desirable in the solution.
The argument to <code>zones</code> can be used to control
the strength of connectivity between planning units in different zones.
The default argument for <code>zones</code> is to treat planning units
allocated to different zones as having zero connectivity.</p>
</dd>
<dt><code>data</code> as a <code>data.frame</code> object</dt><dd><p>containing columns that are named
<code>"id1"</code>, <code>"id2"</code>, and <code>"boundary"</code>. Here, each row
denotes the connectivity between a pair of planning units
(per values in the <code>"id1"</code> and <code>"id2"</code> columns) following the
<em>Marxan</em> format.
If the argument to <code>x</code> contains multiple zones, then the
<code>"zone1"</code> and <code>"zone2"</code> columns can optionally be provided to manually
specify the connectivity values between planning units when they are
allocated to specific zones. If the <code>"zone1"</code> and
<code>"zone2"</code> columns are present, then the argument to <code>zones</code> must be
<code>NULL</code>.</p>
</dd>
<dt><code>data</code> as an <code>array</code> object</dt><dd>
<p>containing four-dimensions where cell values
indicate the strength of connectivity between planning units
when they are assigned to specific management zones. The first two
dimensions (i.e., rows and columns) indicate the strength of
connectivity between different planning units and the second two
dimensions indicate the different management zones. Thus
the <code>data[1, 2, 3, 4]</code> indicates the strength of
connectivity between planning unit 1 and planning unit 2 when planning
unit 1 is assigned to zone 3 and planning unit 2 is assigned to zone 4.</p>
</dd>
</dl>



<h3>References</h3>

<p>Ball IR, Possingham HP, and Watts M (2009) <em>Marxan and relatives:
Software for spatial conservation prioritisation</em> in Spatial conservation
prioritisation: Quantitative methods and computational tools. Eds Moilanen
A, Wilson KA, and Possingham HP. Oxford University Press, Oxford, UK.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+summaries">summaries</a> for an overview of all functions for summarizing solutions.
Also, see <code><a href="#topic+add_connectivity_penalties">add_connectivity_penalties()</a></code> to penalize solutions with low
connectivity.
</p>
<p>Other summaries: 
<code><a href="#topic+eval_asym_connectivity_summary">eval_asym_connectivity_summary</a>()</code>,
<code><a href="#topic+eval_boundary_summary">eval_boundary_summary</a>()</code>,
<code><a href="#topic+eval_cost_summary">eval_cost_summary</a>()</code>,
<code><a href="#topic+eval_feature_representation_summary">eval_feature_representation_summary</a>()</code>,
<code><a href="#topic+eval_n_summary">eval_n_summary</a>()</code>,
<code><a href="#topic+eval_target_coverage_summary">eval_target_coverage_summary</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# build minimal conservation problem with raster data
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s1 &lt;- solve(p1)

# print solution
print(s1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# simulate a connectivity matrix to describe the relative strength
# of connectivity between different planning units
# for brevity, we will use cost data here so that pairs
# of adjacent planning units with higher cost values will have a
# higher connectivity value
# (but see ?connectivity_matrix for more information)
cm1 &lt;- connectivity_matrix(sim_pu_raster, sim_pu_raster)

# calculate connectivity associated with the solution
r1 &lt;- eval_connectivity_summary(p1, s1, data = cm1)
print(r1)

# build multi-zone conservation problem with polygon data
p2 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s2 &lt;- solve(p2)

# print solution
print(s2)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s2$solution &lt;- category_vector(
  s2[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
s2$solution &lt;- factor(s2$solution)

# plot solution
plot(s2[, "solution"])

# simulate connectivity matrix
# here, we will add a new column to sim_zones_pu_polygons with
# randomly simulated values and create a connectivity matrix
# based on the average simulated values of adjacent planning units
sim_zones_pu_polygons$con &lt;- runif(nrow(sim_zones_pu_polygons))
cm2 &lt;- connectivity_matrix(sim_zones_pu_polygons, "con")

# calculate connectivity associated with the solution
r2 &lt;- eval_connectivity_summary(
  p2, s2[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")],
  data = cm2
)
print(r2)


## End(Not run)
</code></pre>

<hr>
<h2 id='eval_cost_summary'>Evaluate cost of solution</h2><span id='topic+eval_cost_summary'></span>

<h3>Description</h3>

<p>Calculate the total cost of a solution to a conservation planning
problem.
For example, if the planning unit cost data describe land acquisition costs
(USD), then the total cost would be net cost (USD) needed to acquire
all planning units selected within the solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_cost_summary(x, solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_cost_summary_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="eval_cost_summary_+3A_solution">solution</code></td>
<td>
<p><code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object.
The argument should be in the same format as the planning unit cost
data in the argument to <code>x</code>.
See the Solution format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This metric is equivalent to the <code>Cost</code> metric reported by the
<a href="https://marxansolutions.org"><em>Marxan</em> software</a> (Ball <em>et al.</em> 2009).
Specifically, the cost of a solution is defined as the sum of the cost
values, supplied when creating a <code><a href="#topic+problem">problem()</a></code> object
(e.g., using the <code>cost_column</code> argument),
weighted by the status of each planning unit in the solution.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> object containing the solution cost.
It contains the following columns:
</p>

<dl>
<dt>summary</dt><dd><p><code>character</code> description of the summary statistic.
The statistic associated with the <code>"overall"</code> value
in this column is calculated using the entire solution
(including all management zones if there are multiple zones).
If multiple management zones are present, then summary statistics
are also provided for each zone separately
(indicated using zone names).</p>
</dd>
<dt>cost</dt><dd><p><code>numeric</code> cost value.
Greater values correspond to solutions that are more costly
to implement.
Thus conservation planning exercises typically prefer solutions
with smaller values, because they are cheaper to implement
(assuming all other relevant factors, such as feature representation,
are equal).</p>
</dd>
</dl>



<h3>Solution format</h3>

<p>Broadly speaking, the argument to <code>solution</code> must be in the same format as
the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt><code>x</code> has <code>numeric</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>matrix</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The argument to <code>solution</code>
be a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>data.frame</code> planning units</dt><dd><p>The argument to <code>solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code><a href="sf.html#topic+sf">sf::sf()</a></code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code> planning units</dt><dd><p>The argument to <code>solution</code> must be
a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Ball IR, Possingham HP, and Watts M (2009) <em>Marxan and relatives:
Software for spatial conservation prioritisation</em> in Spatial conservation
prioritisation: Quantitative methods and computational tools. Eds Moilanen
A, Wilson KA, and Possingham HP. Oxford University Press, Oxford, UK.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+summaries">summaries</a> for an overview of all functions for summarizing solutions.
</p>
<p>Other summaries: 
<code><a href="#topic+eval_asym_connectivity_summary">eval_asym_connectivity_summary</a>()</code>,
<code><a href="#topic+eval_boundary_summary">eval_boundary_summary</a>()</code>,
<code><a href="#topic+eval_connectivity_summary">eval_connectivity_summary</a>()</code>,
<code><a href="#topic+eval_feature_representation_summary">eval_feature_representation_summary</a>()</code>,
<code><a href="#topic+eval_n_summary">eval_n_summary</a>()</code>,
<code><a href="#topic+eval_target_coverage_summary">eval_target_coverage_summary</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# build minimal conservation problem with raster data
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s1 &lt;- solve(p1)

# print solution
print(s1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# calculate cost of the solution
r1 &lt;- eval_cost_summary(p1, s1)
print(r1)

# build minimal conservation problem with polygon data
p2 &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s2 &lt;- solve(p2)

# plot solution
plot(s2[, "solution_1"])

# print solution
print(s2)

# calculate cost of the solution
r2 &lt;- eval_cost_summary(p2, s2[, "solution_1"])
print(r2)

# manually calculate cost of the solution
r2_manual &lt;- sum(s2$solution_1 * sim_pu_polygons$cost, na.rm = TRUE)
print(r2_manual)

# build multi-zone conservation problem with polygon data
p3 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s3 &lt;- solve(p3)

# print solution
print(s3)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s3$solution &lt;- category_vector(
  s3[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
s3$solution &lt;- factor(s3$solution)

# plot solution
plot(s3[, "solution"])

# calculate cost of the solution
r3 &lt;- eval_cost_summary(
  p3, s3[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
print(r3)

## End(Not run)
</code></pre>

<hr>
<h2 id='eval_feature_representation_summary'>Evaluate feature representation by solution</h2><span id='topic+eval_feature_representation_summary'></span>

<h3>Description</h3>

<p>Calculate how well features are represented by a solution
to a conservation planning problem.
These summary statistics are reported for each and every feature,
and each and every zone, within a conservation planning problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_feature_representation_summary(x, solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_feature_representation_summary_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="eval_feature_representation_summary_+3A_solution">solution</code></td>
<td>
<p><code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object.
The argument should be in the same format as the planning unit cost
data in the argument to <code>x</code>.
See the Solution format section for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> object describing feature representation.
Here, each row describes a specific summary statistic
(e.g., different management zone) for a specific feature.
It contains the following columns:
</p>

<dl>
<dt>summary</dt><dd><p><code>character</code> description of the summary statistic.
The statistic associated with the <code>"overall"</code> value
in this column is calculated using the entire solution
(including all management zones if there are multiple zones).
If multiple management zones are present, then summary statistics
are also provided for each zone separately
(indicated using zone names).</p>
</dd>
<dt>feature</dt><dd><p><code>character</code> name of the feature.</p>
</dd>
<dt>total_amount</dt><dd><p><code>numeric</code> total amount of each feature available
in the entire conservation planning problem
(not just planning units selected within the solution).
It is calculated as the sum of the feature data,
supplied when creating a <code><a href="#topic+problem">problem()</a></code> object
(e.g., presence/absence values).</p>
</dd>
<dt>absolute_held</dt><dd><p><code>numeric</code> total amount of each feature secured within
the solution. It is calculated as the sum of the feature data,
supplied when creating a <code><a href="#topic+problem">problem()</a></code> object
(e.g., presence/absence values), weighted by the status of each
planning unit in the solution (e.g., selected or not for
prioritization).</p>
</dd>
<dt>relative_held</dt><dd><p><code>numeric</code> proportion of
each feature secured within the solution. It is calculated
by dividing values in the <code>"absolute_held"</code> column by those in the
<code>"total_amount"</code> column.</p>
</dd>
</dl>



<h3>Solution format</h3>

<p>Broadly speaking, the argument to <code>solution</code> must be in the same format as
the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt><code>x</code> has <code>numeric</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>matrix</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The argument to <code>solution</code>
be a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>data.frame</code> planning units</dt><dd><p>The argument to <code>solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code><a href="sf.html#topic+sf">sf::sf()</a></code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code> planning units</dt><dd><p>The argument to <code>solution</code> must be
a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="#topic+summaries">summaries</a> for an overview of all functions for summarizing solutions.
</p>
<p>Other summaries: 
<code><a href="#topic+eval_asym_connectivity_summary">eval_asym_connectivity_summary</a>()</code>,
<code><a href="#topic+eval_boundary_summary">eval_boundary_summary</a>()</code>,
<code><a href="#topic+eval_connectivity_summary">eval_connectivity_summary</a>()</code>,
<code><a href="#topic+eval_cost_summary">eval_cost_summary</a>()</code>,
<code><a href="#topic+eval_n_summary">eval_n_summary</a>()</code>,
<code><a href="#topic+eval_target_coverage_summary">eval_target_coverage_summary</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# create a simple conservation planning dataset so we can see exactly
# how feature representation is calculated
pu &lt;- data.frame(
  id = seq_len(10),
  cost = c(0.2, NA, runif(8)),
  spp1 = runif(10),
  spp2 = c(rpois(9, 4), NA)
)

# create problem
p1 &lt;-
  problem(pu, c("spp1", "spp2"), cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create a solution
# specifically, a data.frame with a single column that contains
# binary values indicating if each planning units was selected or not
s1 &lt;- data.frame(s = c(1, NA, rep(c(1, 0), 4)))
print(s1)

# calculate feature representation
r1 &lt;- eval_feature_representation_summary(p1, s1)
print(r1)

# let's verify that feature representation calculations are correct
# by manually performing the calculations and compare the results with r1
## calculate total amount for each feature
print(
  setNames(
    c(sum(pu$spp1, na.rm = TRUE), sum(pu$spp2, na.rm = TRUE)),
    c("spp1", "spp2")
  )
)

## calculate absolute amount held for each feature
print(
  setNames(
    c(sum(pu$spp1 * s1$s, na.rm = TRUE), sum(pu$spp2 * s1$s, na.rm = TRUE)),
    c("spp1", "spp2")
  )
)

## calculate relative amount held for each feature
print(
  setNames(
    c(
      sum(pu$spp1 * s1$s, na.rm = TRUE) / sum(pu$spp1, na.rm = TRUE),
      sum(pu$spp2 * s1$s, na.rm = TRUE) / sum(pu$spp2, na.rm = TRUE)
    ),
    c("spp1", "spp2")
  )
)

# solve problem using an exact algorithm solver
s1_2 &lt;- solve(p1)
print(s1_2)

# calculate feature representation in this solution
r1_2 &lt;- eval_feature_representation_summary(
  p1, s1_2[, "solution_1", drop = FALSE]
)
print(r1_2)

# build minimal conservation problem with raster data
p2 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# print solution
print(s2)

# calculate feature representation in the solution
r2 &lt;- eval_feature_representation_summary(p2, s2)
print(r2)

# plot solution
plot(s2, main = "solution", axes = FALSE)

# build minimal conservation problem with polygon data
p3 &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# print first six rows of the attribute table
print(head(s3))

# calculate feature representation in the solution
r3 &lt;- eval_feature_representation_summary(p3, s3[, "solution_1"])
print(r3)

# plot solution
plot(s3[, "solution_1"], main = "solution", axes = FALSE)

# build multi-zone conservation problem with raster data
p4 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s4 &lt;- solve(p4)

# print solution
print(s4)

# calculate feature representation in the solution
r4 &lt;- eval_feature_representation_summary(p4, s4)
print(r4)

# plot solution
plot(category_layer(s4), main = "solution", axes = FALSE)

# build multi-zone conservation problem with polygon data
p5 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s5 &lt;- solve(p5)

# print first six rows of the attribute table
print(head(s5))

# calculate feature representation in the solution
r5 &lt;- eval_feature_representation_summary(
  p5, s5[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
print(r5)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s5$solution &lt;- category_vector(
  s5[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
s5$solution &lt;- factor(s5$solution)

# plot solution
plot(s5[, "solution"])

## End(Not run)
</code></pre>

<hr>
<h2 id='eval_ferrier_importance'>Evaluate solution importance using Ferrier scores</h2><span id='topic+eval_ferrier_importance'></span><span id='topic+eval_ferrier_importance+2CConservationProblem+2Cnumeric-method'></span><span id='topic+eval_ferrier_importance+2CConservationProblem+2Cmatrix-method'></span><span id='topic+eval_ferrier_importance+2CConservationProblem+2Cdata.frame-method'></span><span id='topic+eval_ferrier_importance+2CConservationProblem+2CSpatial-method'></span><span id='topic+eval_ferrier_importance+2CConservationProblem+2CSpatRaster-method'></span><span id='topic+eval_ferrier_importance+2CConservationProblem+2Csf-method'></span><span id='topic+eval_ferrier_importance+2CConservationProblem+2CRaster-method'></span>

<h3>Description</h3>

<p>Calculate importance scores for planning units selected in
a solution following Ferrier <em>et al.</em> (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_ferrier_importance(x, solution)

## S4 method for signature 'ConservationProblem,numeric'
eval_ferrier_importance(x, solution)

## S4 method for signature 'ConservationProblem,matrix'
eval_ferrier_importance(x, solution)

## S4 method for signature 'ConservationProblem,data.frame'
eval_ferrier_importance(x, solution)

## S4 method for signature 'ConservationProblem,Spatial'
eval_ferrier_importance(x, solution)

## S4 method for signature 'ConservationProblem,sf'
eval_ferrier_importance(x, solution)

## S4 method for signature 'ConservationProblem,Raster'
eval_ferrier_importance(x, solution)

## S4 method for signature 'ConservationProblem,SpatRaster'
eval_ferrier_importance(x, solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_ferrier_importance_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="eval_ferrier_importance_+3A_solution">solution</code></td>
<td>
<p><code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object.
The argument should be in the same format as the planning unit cost
data in the argument to <code>x</code>.
See the Solution format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Importance scores are reported separately for each feature within
each planning unit. Additionally, a total importance score is also
calculated as the sum of the scores for each feature.
Note that this function only works for problems
that use targets and a single zone.
It will throw an error for problems that do not meet these criteria.
</p>


<h3>Value</h3>

<p>A <code>matrix</code>, <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> object containing the scores for each
planning unit selected in the solution.
Specifically, the returned object is in the
same format (except if the planning units are a <code>numeric</code> vector) as the
planning unit data in the argument to <code>x</code>.
</p>


<h3>Notes</h3>

<p>In previous versions, the documentation for this function had a warning
indicating that the mathematical formulation for this function required
verification. The mathematical formulation for this function has since
been corrected and verified, so now this function is recommended
for general use.
</p>


<h3>Solution format</h3>

<p>Broadly speaking, the argument to <code>solution</code> must be in the same format as
the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt><code>x</code> has <code>numeric</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>matrix</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The argument to <code>solution</code>
be a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>data.frame</code> planning units</dt><dd><p>The argument to <code>solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code><a href="sf.html#topic+sf">sf::sf()</a></code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code> planning units</dt><dd><p>The argument to <code>solution</code> must be
a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Ferrier S, Pressey RL, and Barrett TW (2000) A new predictor of the
irreplaceability of areas for achieving a conservation goal, its application
to real-world planning, and a research agenda for further refinement.
<em>Biological Conservation</em>, 93: 303&ndash;325.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+importance">importance</a> for an overview of all functions for evaluating
the importance of planning units selected in a solution.
</p>
<p>Other importances: 
<code><a href="#topic+eval_rare_richness_importance">eval_rare_richness_importance</a>()</code>,
<code><a href="#topic+eval_replacement_importance">eval_replacement_importance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# seed seed for reproducibility
set.seed(600)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()

# create minimal problem with binary decisions
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# print solution
print(s1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# calculate importance scores using Ferrier et al. 2000 method
fs1 &lt;- eval_ferrier_importance(p1, s1)

# print importance scores,
# each planning unit has an importance score for each feature
# (as indicated by the column names) and each planning unit also
# has an overall total importance score (in the "total" column)
print(fs1)

# plot total importance scores
plot(fs1, main = names(fs1), axes = FALSE)

# create minimal problem with polygon planning units
p2 &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.05) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# print solution
print(s2)

# plot solution
plot(s2[, "solution_1"], main = "solution")

# calculate importance scores
fs2 &lt;- eval_ferrier_importance(p2, s2[, "solution_1"])

# plot importance scores
plot(fs2)


## End(Not run)

</code></pre>

<hr>
<h2 id='eval_n_summary'>Evaluate number of planning units selected by solution</h2><span id='topic+eval_n_summary'></span>

<h3>Description</h3>

<p>Calculate the number of planning units selected within a solution
to a conservation planning problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_n_summary(x, solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_n_summary_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="eval_n_summary_+3A_solution">solution</code></td>
<td>
<p><code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object.
The argument should be in the same format as the planning unit cost
data in the argument to <code>x</code>.
See the Solution format section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This summary statistic is calculated as the sum of the values in
the solution. As a consequence, this metric can produce a
non-integer value (e.g., 4.3) for solutions containing proportion values
(e.g., generated by solving a <code><a href="#topic+problem">problem()</a></code> built using the
<code><a href="#topic+add_proportion_decisions">add_proportion_decisions()</a></code> function).
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> object containing the number of planning
units selected within a solution.
It contains the following columns:
</p>

<dl>
<dt>summary</dt><dd><p><code>character</code> description of the summary statistic.
The statistic associated with the <code>"overall"</code> value
in this column is calculated using the entire solution
(including all management zones if there are multiple zones).
If multiple management zones are present, then summary statistics
are also provided for each zone separately
(indicated using zone names).</p>
</dd>
<dt>n</dt><dd><p><code>numeric</code> number of selected planning units.</p>
</dd>
</dl>



<h3>Solution format</h3>

<p>Broadly speaking, the argument to <code>solution</code> must be in the same format as
the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt><code>x</code> has <code>numeric</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>matrix</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The argument to <code>solution</code>
be a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>data.frame</code> planning units</dt><dd><p>The argument to <code>solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code><a href="sf.html#topic+sf">sf::sf()</a></code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code> planning units</dt><dd><p>The argument to <code>solution</code> must be
a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="#topic+summaries">summaries</a> for an overview of all functions for summarizing solutions.
</p>
<p>Other summaries: 
<code><a href="#topic+eval_asym_connectivity_summary">eval_asym_connectivity_summary</a>()</code>,
<code><a href="#topic+eval_boundary_summary">eval_boundary_summary</a>()</code>,
<code><a href="#topic+eval_connectivity_summary">eval_connectivity_summary</a>()</code>,
<code><a href="#topic+eval_cost_summary">eval_cost_summary</a>()</code>,
<code><a href="#topic+eval_feature_representation_summary">eval_feature_representation_summary</a>()</code>,
<code><a href="#topic+eval_target_coverage_summary">eval_target_coverage_summary</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# build minimal conservation problem with raster data
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s1 &lt;- solve(p1)

# print solution
print(s1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# calculate number of selected planning units within solution
r1 &lt;- eval_n_summary(p1, s1)
print(r1)

# build minimal conservation problem with polygon data
p2 &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s2 &lt;- solve(p2)

# plot solution
plot(s2[, "solution_1"])

# print solution
print(s2)

# calculate number of selected planning units within solution
r2 &lt;- eval_n_summary(p2, s2[, "solution_1"])
print(r2)

# manually calculate number of selected planning units
r2_manual &lt;- sum(s2$solution_1, na.rm = TRUE)
print(r2_manual)

# build multi-zone conservation problem with polygon data
p3 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s3 &lt;- solve(p3)

# print solution
print(s3)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s3$solution &lt;- category_vector(
  s3[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
s3$solution &lt;- factor(s3$solution)

# plot solution
plot(s3[, "solution"])

# calculate number of selected planning units within solution
r3 &lt;- eval_n_summary(
  p3, s3[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
print(r3)

## End(Not run)
</code></pre>

<hr>
<h2 id='eval_rare_richness_importance'>Evaluate solution importance using rarity weighted richness scores</h2><span id='topic+eval_rare_richness_importance'></span><span id='topic+eval_rare_richness_importance+2CConservationProblem+2Cnumeric-method'></span><span id='topic+eval_rare_richness_importance+2CConservationProblem+2Cmatrix-method'></span><span id='topic+eval_rare_richness_importance+2CConservationProblem+2Cdata.frame-method'></span><span id='topic+eval_rare_richness_importance+2CConservationProblem+2CSpatial-method'></span><span id='topic+eval_rare_richness_importance+2CConservationProblem+2Csf-method'></span><span id='topic+eval_rare_richness_importance+2CConservationProblem+2CRaster-method'></span><span id='topic+eval_rare_richness_importance+2CConservationProblem+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Calculate importance scores for planning units selected in a solution
using rarity weighted richness scores (based on Williams <em>et al.</em> 1996).
This method is only recommended for large-scaled conservation
planning exercises (i.e., more than 100,000 planning units) where
importance scores cannot be calculated using other methods in a feasible
period of time. This is because rarity weighted richness scores cannot (i)
account for the cost of different planning units, (ii) account for multiple
management zones, and (iii) identify truly irreplaceable planning units &mdash;
unlike the replacement cost metric which does not suffer any of these
limitations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_rare_richness_importance(x, solution, ...)

## S4 method for signature 'ConservationProblem,numeric'
eval_rare_richness_importance(x, solution, rescale, ...)

## S4 method for signature 'ConservationProblem,matrix'
eval_rare_richness_importance(x, solution, rescale, ...)

## S4 method for signature 'ConservationProblem,data.frame'
eval_rare_richness_importance(x, solution, rescale, ...)

## S4 method for signature 'ConservationProblem,Spatial'
eval_rare_richness_importance(x, solution, rescale, ...)

## S4 method for signature 'ConservationProblem,sf'
eval_rare_richness_importance(x, solution, rescale, ...)

## S4 method for signature 'ConservationProblem,Raster'
eval_rare_richness_importance(x, solution, rescale, ...)

## S4 method for signature 'ConservationProblem,SpatRaster'
eval_rare_richness_importance(x, solution, rescale, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_rare_richness_importance_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="eval_rare_richness_importance_+3A_solution">solution</code></td>
<td>
<p><code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object.
The argument should be in the same format as the planning unit cost
data in the argument to <code>x</code>.
See the Solution format section for more information.</p>
</td></tr>
<tr><td><code id="eval_rare_richness_importance_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="eval_rare_richness_importance_+3A_rescale">rescale</code></td>
<td>
<p><code>logical</code> flag indicating if replacement cost
values &ndash; excepting infinite (<code>Inf</code>) and zero values &ndash; should be
rescaled to range between 0.01 and 1. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rarity weighted richness scores are calculated using the following
terms. Let <code class="reqn">I</code> denote the set of planning units (indexed by
<code class="reqn">i</code>), let <code class="reqn">J</code> denote the set of conservation features (indexed by
<code class="reqn">j</code>), let <code class="reqn">r_{ij}</code> denote the amount of feature <code class="reqn">j</code>
associated with planning unit <code class="reqn">i</code>, and let <code class="reqn">m_j</code> denote the
maximum value of feature <code class="reqn">j</code> in <code class="reqn">r_{ij}</code> in all planning units
<code class="reqn">i \in I</code>. To calculate the rarity weighted richness (<em>RWR</em>) for
planning unit <code class="reqn">k</code>:
</p>
<p style="text-align: center;"><code class="reqn">
  \mathit{RWR}_{k} = \sum_{j}^{J} \frac{ \frac{r_{ik}}{m_j} }{
                                          \sum_{i}^{I}r_{ij}}
  </code>
</p>



<h3>Value</h3>

<p>A <code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object
containing the importance scores for each planning
unit in the solution. Specifically, the returned object is in the
same format as the planning unit data in the argument to <code>x</code>.
</p>


<h3>Solution format</h3>

<p>Broadly speaking, the argument to <code>solution</code> must be in the same format as
the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt><code>x</code> has <code>numeric</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>matrix</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The argument to <code>solution</code>
be a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>data.frame</code> planning units</dt><dd><p>The argument to <code>solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code><a href="sf.html#topic+sf">sf::sf()</a></code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code> planning units</dt><dd><p>The argument to <code>solution</code> must be
a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Williams P, Gibbons D, Margules C, Rebelo A, Humphries C, and Pressey RL
(1996) A comparison of richness hotspots, rarity hotspots and complementary
areas for conserving diversity using British birds.
<em>Conservation Biology</em>, 10: 155&ndash;174.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+importance">importance</a> for an overview of all functions for evaluating
the importance of planning units selected in a solution.
</p>
<p>Other importances: 
<code><a href="#topic+eval_ferrier_importance">eval_ferrier_importance</a>()</code>,
<code><a href="#topic+eval_replacement_importance">eval_replacement_importance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# seed seed for reproducibility
set.seed(600)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()

# create minimal problem with raster planning units
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# print solution
print(s1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# calculate importance scores
rwr1 &lt;- eval_rare_richness_importance(p1, s1)

# print importance scores
print(rwr1)

# plot importance scores
plot(rwr1, main = "rarity weighted richness", axes = FALSE)

# create minimal problem with polygon planning units
p2 &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.05) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# print solution
print(s2)

# plot solution
plot(s2[, "solution_1"], main = "solution")

# calculate importance scores
rwr2 &lt;- eval_rare_richness_importance(p2, s2[, "solution_1"])

# plot importance scores
plot(rwr2, main = "rarity weighted richness")

## End(Not run)

</code></pre>

<hr>
<h2 id='eval_replacement_importance'>Evaluate solution importance using replacement cost scores</h2><span id='topic+eval_replacement_importance'></span><span id='topic+eval_replacement_importance+2CConservationProblem+2Cnumeric-method'></span><span id='topic+eval_replacement_importance+2CConservationProblem+2Cmatrix-method'></span><span id='topic+eval_replacement_importance+2CConservationProblem+2Cdata.frame-method'></span><span id='topic+eval_replacement_importance+2CConservationProblem+2CSpatial-method'></span><span id='topic+eval_replacement_importance+2CConservationProblem+2Csf-method'></span><span id='topic+eval_replacement_importance+2CConservationProblem+2CRaster-method'></span><span id='topic+eval_replacement_importance+2CConservationProblem+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Calculate importance scores for planning units selected in a solution
based on the replacement cost method (Cabeza and Moilanen 2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_replacement_importance(x, solution, ...)

## S4 method for signature 'ConservationProblem,numeric'
eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)

## S4 method for signature 'ConservationProblem,matrix'
eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)

## S4 method for signature 'ConservationProblem,data.frame'
eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)

## S4 method for signature 'ConservationProblem,Spatial'
eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)

## S4 method for signature 'ConservationProblem,sf'
eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)

## S4 method for signature 'ConservationProblem,Raster'
eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)

## S4 method for signature 'ConservationProblem,SpatRaster'
eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_replacement_importance_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="eval_replacement_importance_+3A_solution">solution</code></td>
<td>
<p><code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object.
The argument should be in the same format as the planning unit cost
data in the argument to <code>x</code>.
See the Solution format section for more information.</p>
</td></tr>
<tr><td><code id="eval_replacement_importance_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="eval_replacement_importance_+3A_rescale">rescale</code></td>
<td>
<p><code>logical</code> flag indicating if replacement cost
values &ndash; excepting infinite (<code>Inf</code>) and zero values &ndash; should be
rescaled to range between 0.01 and 1. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="eval_replacement_importance_+3A_run_checks">run_checks</code></td>
<td>
<p><code>logical</code> flag indicating whether presolve checks
should be run prior solving the problem. These checks are performed using
the <code><a href="#topic+presolve_check">presolve_check()</a></code> function. Defaults to <code>TRUE</code>.
Skipping these checks may reduce run time for large problems.</p>
</td></tr>
<tr><td><code id="eval_replacement_importance_+3A_force">force</code></td>
<td>
<p><code>logical</code> flag indicating if an attempt should be
made to solve the problem even if potential issues were detected during
the presolve checks. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="eval_replacement_importance_+3A_threads">threads</code></td>
<td>
<p><code>integer</code> number of threads to use for the
optimization algorithm. Defaults to 1 such that only a single
thread is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements a modified version of the
replacement cost method (Cabeza and Moilanen 2006).
Specifically, the score for each planning unit is calculated
as the difference in the objective value of a solution when each planning
unit is locked out and the optimization processes rerun with all other
selected planning units locked in. In other words, the replacement cost
metric corresponds to change in solution quality incurred if a given
planning unit cannot be acquired when implementing the solution and the
next best planning unit (or set of planning units) will need to be
considered instead. Thus planning units with a higher score are more
important (and irreplaceable).
For example, when using the minimum set objective function
(<code><a href="#topic+add_min_set_objective">add_min_set_objective()</a></code>), the replacement cost scores
correspond to the additional costs needed to meet targets when each
planning unit is locked out. When using the maximum utility
objective function (<code><a href="#topic+add_max_utility_objective">add_max_utility_objective()</a></code>, the
replacement cost scores correspond to the reduction in the utility when
each planning unit is locked out. Infinite values mean that no feasible
solution exists when planning units are locked out&mdash;they are
absolutely essential for obtaining a solution (e.g., they contain rare
species that are not found in any other planning units or were locked in).
Zeros values mean that planning units can be swapped with other planning
units and this will have no effect on the performance of the solution at all
(e.g., because they were only selected due to spatial fragmentation
penalties).
</p>
<p>These calculations can take a long time to complete for large
or complex conservation planning problems. As such, we recommend using this
method for small or moderate-sized conservation planning problems
(e.g., &lt; 30,000 planning units). To reduce run time, we
recommend calculating these scores without additional penalties (e.g.,
<code><a href="#topic+add_boundary_penalties">add_boundary_penalties()</a></code>) or spatial constraints (e.g.,
<code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints()</a></code>). To further reduce run time,
we recommend using proportion-type decisions when calculating the scores
(see below for an example).
</p>


<h3>Value</h3>

<p>A <code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object
containing the importance scores for each planning
unit in the solution. Specifically, the returned object is in the
same format as the planning unit data in the argument to <code>x</code>.
</p>


<h3>Solution format</h3>

<p>Broadly speaking, the argument to <code>solution</code> must be in the same format as
the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt><code>x</code> has <code>numeric</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>matrix</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The argument to <code>solution</code>
be a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>data.frame</code> planning units</dt><dd><p>The argument to <code>solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code><a href="sf.html#topic+sf">sf::sf()</a></code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code> planning units</dt><dd><p>The argument to <code>solution</code> must be
a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Cabeza M and Moilanen A (2006) Replacement cost: A practical measure of site
value for cost-effective reserve planning. <em>Biological Conservation</em>,
132: 336&ndash;342.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+importance">importance</a> for an overview of all functions for evaluating
the importance of planning units selected in a solution.
</p>
<p>Other importances: 
<code><a href="#topic+eval_ferrier_importance">eval_ferrier_importance</a>()</code>,
<code><a href="#topic+eval_rare_richness_importance">eval_rare_richness_importance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# seed seed for reproducibility
set.seed(600)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create minimal problem with binary decisions
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# print solution
print(s1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# calculate importance scores
rc1 &lt;- eval_replacement_importance(p1, s1)

# print importance scores
print(rc1)

# plot importance scores
plot(rc1, main = "replacement cost", axes = FALSE)

# since replacement cost scores can take a long time to calculate with
# binary decisions, we can calculate them using proportion-type
# decision variables. Note we are still calculating the scores for our
# previous solution (s1), we are just using a different optimization
# problem when calculating the scores.
p2 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_proportion_decisions() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# calculate importance scores using proportion type decisions
rc2 &lt;- eval_replacement_importance(p2, s1)

# print importance scores based on proportion type decisions
print(rc2)

# plot importance scores based on proportion type decisions
# we can see that the importance values in rc1 and rc2 are similar,
# and this confirms that the proportion type decisions are a good
# approximation
plot(rc2, main = "replacement cost", axes = FALSE)

# create minimal problem with polygon planning units
p3 &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.05) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# print solution
print(s3)

# plot solution
plot(s3[, "solution_1"], main = "solution")

# calculate importance scores
rc3 &lt;- eval_rare_richness_importance(p3, s3[, "solution_1"])

# plot importance scores
plot(rc3, main = "replacement cost")

# build multi-zone conservation problem with raster data
p4 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve the problem
s4 &lt;- solve(p4)
names(s4) &lt;- paste0("zone ", seq_len(terra::nlyr(s4)))

# print solution
print(s4)

# plot solution
# each panel corresponds to a different zone, and data show the
# status of each planning unit in a given zone
plot(s4, axes = FALSE)

# calculate importance scores
rc4 &lt;- eval_replacement_importance(p4, s4)
names(rc4) &lt;- paste0("zone ", seq_len(terra::nlyr(s4)))

# plot importance
# each panel corresponds to a different zone, and data show the
# importance of each planning unit in a given zone
plot(rc4, axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='eval_target_coverage_summary'>Evaluate target coverage by solution</h2><span id='topic+eval_target_coverage_summary'></span><span id='topic+eval_target_coverage_summary+2CConservationProblem+2Cnumeric-method'></span><span id='topic+eval_target_coverage_summary+2CConservationProblem+2Cmatrix-method'></span><span id='topic+eval_target_coverage_summary+2CConservationProblem+2Cdata.frame-method'></span><span id='topic+eval_target_coverage_summary+2CConservationProblem+2CSpatial-method'></span><span id='topic+eval_target_coverage_summary+2CConservationProblem+2Csf-method'></span><span id='topic+eval_target_coverage_summary+2CConservationProblem+2CRaster-method'></span><span id='topic+eval_target_coverage_summary+2CConservationProblem+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Calculate how well feature representation <a href="#topic+targets">targets</a> are met by a solution to
a conservation planning problem.
It is useful for understanding if features are adequately represented by
a solution.
Note that this function can only be used with problems that contain
<a href="#topic+targets">targets</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_target_coverage_summary(
  x,
  solution,
  include_zone = number_of_zones(x) &gt; 1,
  include_sense = number_of_zones(x) &gt; 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_target_coverage_summary_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="eval_target_coverage_summary_+3A_solution">solution</code></td>
<td>
<p><code>numeric</code>, <code>matrix</code>, <code>data.frame</code>,
<code><a href="terra.html#topic+rast">terra::rast()</a></code>, or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object.
The argument should be in the same format as the planning unit cost
data in the argument to <code>x</code>.
See the Solution format section for more information.</p>
</td></tr>
<tr><td><code id="eval_target_coverage_summary_+3A_include_zone">include_zone</code></td>
<td>
<p><code>logical</code> include the <code>zone</code> column in the output?
Defaults to <code>TRUE</code> for problems that contain multiple zones.</p>
</td></tr>
<tr><td><code id="eval_target_coverage_summary_+3A_include_sense">include_sense</code></td>
<td>
<p><code>logical</code> include the <code>sense</code> column in the output?
Defaults to <code>TRUE</code> for problems that contain multiple zones.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> object.
Here, each row describes information for a different target.
It contains the following columns:
</p>

<dl>
<dt>feature</dt><dd><p><code>character</code> name of the feature associated with each
target.</p>
</dd>
<dt>zone</dt><dd><p><code>list</code> of <code>character</code> zone names associated with each target.
This column is in a list-column format because a single target can
correspond to multiple zones (see <code><a href="#topic+add_manual_targets">add_manual_targets()</a></code> for details
and examples).
For an example of converting the list-column format to a standard
<code>character</code> column format, please see the Examples section.
This column is only included if the argument to <code>include_zones</code>
is <code>TRUE</code>.</p>
</dd>
<dt>sense</dt><dd><p><code>character</code> sense associated with each target.
Sense values specify the nature of the target.
Typically (e.g., when using the <code><a href="#topic+add_absolute_targets">add_absolute_targets()</a></code> or
<code><a href="#topic+add_relative_targets">add_relative_targets()</a></code> functions), targets are specified using sense
values indicating that the total amount of a feature held within a
solution (ideally) be greater than or equal to a threshold amount
(i.e., a  sense value of <code>"&gt;="</code>).
Additionally, targets (i.e., using the <code><a href="#topic+add_manual_targets">add_manual_targets()</a></code> function)
can also be specified using sense values indicating that the total
amount of a feature held within a solution must be equal to a
threshold amount (i.e., a sense value of <code>"="</code>) or smaller than or equal
to a threshold amount (i.e., a sense value of <code>"&lt;="</code>).
This column is only included if the argument to <code>include_sense</code> is
<code>TRUE</code>.</p>
</dd>
<dt>total_amount</dt><dd><p><code>numeric</code> total amount of the feature available across
the entire conservation planning problem for meeting each target
(not just planning units selected within the solution).
For problems involving a single zone, this column is calculated
as the sum of all of the values for a given feature
(similar to values in the <code>total_amount</code> column produced by the
<code><a href="#topic+eval_feature_representation_summary">eval_feature_representation_summary()</a></code> function).
For problems involving multiple zones,
this column is calculated as the sum of the values for the
feature associated with target (per the <code>"feature"</code> column),
across the zones associated with the target (per the <code>"zone"</code> column).</p>
</dd>
<dt>absolute_target</dt><dd><p><code>numeric</code> total threshold amount associated with
each target.</p>
</dd>
<dt>absolute_held</dt><dd><p><code>numeric</code> total amount held within the solution for
the feature and (if relevant) zones associated with each target (per the
<code>"feature"</code> and <code>"zone"</code> columns, respectively).
This column is calculated as the sum of the feature data,
supplied when creating a <code><a href="#topic+problem">problem()</a></code> object
(e.g., presence/absence values), weighted by the status of each
planning unit in the solution (e.g., selected or not for
prioritization).</p>
</dd>
<dt>absolute_shortfall</dt><dd> <p><code>numeric</code> total amount by which the solution
fails to meet each target.
This column is calculated as the difference between the total amount
held within the solution for the feature and (if relevant) zones
associated with the target (i.e., <code>"absolute_held"</code> column) and the
target total threshold amount (i.e., <code>"absolute_target"</code> column), with
values set to zero depending on the sense specified for the target
(e.g., if the target sense is <code>&gt;=</code> then the difference is
set to zero if the value in the <code>"absolute_held"</code> is smaller than
that in the <code>"absolute_target"</code> column).</p>
</dd>
<dt>relative_target</dt><dd><p><code>numeric</code> proportion threshold amount associated
with each target.
This column is calculated by dividing the total threshold amount
associated with each target (i.e., <code>"absolute_target"</code> column) by
the total amount associated with each target
(i.e., <code>"total_amount"</code> column).</p>
</dd>
<dt>relative_held</dt><dd><p><code>numeric</code> proportion held within the solution for the
feature and (if relevant) zones associated with each target (per the
<code>"feature"</code> and <code>"zone"</code> columns, respectively).
This column is calculated by dividing the total amount held
for each target (i.e., <code>"absolute_held"</code> column) by the
total amount for with each target
(i.e., <code>"total_amount"</code> column).</p>
</dd>
<dt>relative_shortfall</dt><dd><p><code>numeric</code> proportion by which the solution fails
to meet each target.
This column is calculated by dividing the total shortfall for
each target (i.e., <code>"absolute_shortfall"</code> column) by the
total amount for each target (i.e., <code>"total_amount"</code> column).</p>
</dd>
<dt>met</dt><dd><p><code>logical</code> indicating if each target is met by the solution. This
column is calculated by checking if the total shortfall associated
with each target (i.e., <code style="white-space: pre;">&#8288;"absolute_shortfall&#8288;</code>&quot; column) is equal to
zero.</p>
</dd>
</dl>



<h3>Solution format</h3>

<p>Broadly speaking, the argument to <code>solution</code> must be in the same format as
the planning unit data in the argument to <code>x</code>.
Further details on the correct format are listed separately
for each of the different planning unit data formats:
</p>

<dl>
<dt><code>x</code> has <code>numeric</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>numeric</code> vector with each element corresponding to a different planning
unit. It should have the same number of planning units as those
in the argument to <code>x</code>. Additionally, any planning units missing
cost (<code>NA</code>) values should also have missing (<code>NA</code>) values in the
argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>matrix</code> planning units</dt><dd><p>The argument to <code>solution</code> must be a
<code>matrix</code> vector with each row corresponding to a different planning
unit, and each column correspond to a different management zone.
It should have the same number of planning units and zones
as those in the argument to <code>x</code>. Additionally, any planning units
missing cost (<code>NA</code>) values for a particular zone should also have a
missing (<code>NA</code>) values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The argument to <code>solution</code>
be a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object where different grid cells (pixels) correspond
to different planning units and layers correspond to
a different management zones. It should have the same dimensionality
(rows, columns, layers), resolution, extent, and coordinate reference
system as the planning units in the argument to <code>x</code>. Additionally,
any planning units missing cost (<code>NA</code>) values for a particular zone
should also have missing (<code>NA</code>)  values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code>data.frame</code> planning units</dt><dd><p>The argument to <code>solution</code> must
be a <code>data.frame</code> with each column corresponding to a different zone,
each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if a <code>data.frame</code>
object containing the solution also contains additional columns, then
these columns will need to be subsetted prior to using this function
(see below for example with <code><a href="sf.html#topic+sf">sf::sf()</a></code> data).
Additionally, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
<dt><code>x</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code> planning units</dt><dd><p>The argument to <code>solution</code> must be
a <code><a href="sf.html#topic+sf">sf::sf()</a></code> object with each column corresponding to a different
zone, each row corresponding to a different planning unit, and cell values
corresponding to the solution value. This means that if the
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object containing the solution also contains additional
columns, then these columns will need to be subsetted prior to using this
function (see below for example).
Additionally, the argument to <code>solution</code> must also have the same
coordinate reference system as the planning unit data.
Furthermore, any planning units missing cost
(<code>NA</code>) values for a particular zone should also have missing (<code>NA</code>)
values in the argument to <code>solution</code>.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="#topic+summaries">summaries</a> for an overview of all functions for summarizing solutions.
</p>
<p>Other summaries: 
<code><a href="#topic+eval_asym_connectivity_summary">eval_asym_connectivity_summary</a>()</code>,
<code><a href="#topic+eval_boundary_summary">eval_boundary_summary</a>()</code>,
<code><a href="#topic+eval_connectivity_summary">eval_connectivity_summary</a>()</code>,
<code><a href="#topic+eval_cost_summary">eval_cost_summary</a>()</code>,
<code><a href="#topic+eval_feature_representation_summary">eval_feature_representation_summary</a>()</code>,
<code><a href="#topic+eval_n_summary">eval_n_summary</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# build minimal conservation problem with raster data
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s1 &lt;- solve(p1)

# print solution
print(s1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# calculate target coverage by the solution
r1 &lt;- eval_target_coverage_summary(p1, s1)
print(r1, width = Inf) # note: `width = Inf` tells R to print all columns

# build minimal conservation problem with polygon data
p2 &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s2 &lt;- solve(p2)

# print first six rows of the attribute table
print(head(s2))

# plot solution
plot(s2[, "solution_1"])

# calculate target coverage by the solution
r2 &lt;- eval_target_coverage_summary(p2, s2[, "solution_1"])
print(r2, width = Inf)

# build multi-zone conservation problem with polygon data
p3 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s3 &lt;- solve(p3)

# print solution
print(s3)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s3$solution &lt;- category_vector(
  s3[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
s3$solution &lt;- factor(s3$solution)

# plot solution
plot(s3[, "solution"])

# calculate target coverage by the solution
r3 &lt;- eval_target_coverage_summary(
  p3, s3[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
print(r3, width = Inf)

# create a new column with character values containing the zone names,
# by extracting these data out of the zone column
# (which is in list-column format)
r3$zone2 &lt;- vapply(r3$zone, FUN.VALUE = character(1), paste, sep = " &amp; ")

# print r3 again to show the new column
print(r3, width = Inf)

## End(Not run)
</code></pre>

<hr>
<h2 id='fast_extract'>Fast extract</h2><span id='topic+fast_extract'></span><span id='topic+fast_extract+2CRaster+2CSpatial-method'></span><span id='topic+fast_extract+2CRaster+2Csf-method'></span><span id='topic+fast_extract+2CRaster+2Csfc-method'></span><span id='topic+fast_extract+2CSpatRaster+2CSpatial-method'></span><span id='topic+fast_extract+2CSpatRaster+2Csf-method'></span><span id='topic+fast_extract+2CSpatRaster+2Csfc-method'></span>

<h3>Description</h3>

<p>Extract data from a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_extract(x, y, ...)

## S4 method for signature 'Raster,Spatial'
fast_extract(x, y, fun = "mean", ...)

## S4 method for signature 'Raster,sfc'
fast_extract(x, y, fun = "mean", ...)

## S4 method for signature 'SpatRaster,sfc'
fast_extract(x, y, fun = "mean", ...)

## S4 method for signature 'Raster,sf'
fast_extract(x, y, fun = "mean", ...)

## S4 method for signature 'SpatRaster,sf'
fast_extract(x, y, fun = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_extract_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object.</p>
</td></tr>
<tr><td><code id="fast_extract_+3A_y">y</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf::sf()</a></code> object.</p>
</td></tr>
<tr><td><code id="fast_extract_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="fast_extract_+3A_fun">fun</code></td>
<td>
<p><code>character</code> name of statistic to summarize data. Defaults
to <code>"mean"</code>. Available options include <code>"sum"</code> or <code>"mean"</code>.
Defaults to <code>"mean"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The performance of this function for large <code><a href="terra.html#topic+rast">terra::rast()</a></code> objects
can be improved by increasing the GDAL cache size.
The default cache size is 25 MB.
For example, the following code can be used to set the cache size to 4 GB.
</p>
<div class="sourceCode"><pre>terra::gdalCache(size = 4000)
</pre></div>
<p>This function is simply a wrapper that uses
<code><a href="exactextractr.html#topic+exact_extract">exactextractr::exact_extract()</a></code> for polygon geometries, and
<code><a href="terra.html#topic+extract">terra::extract()</a></code> for other geometry types.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> containing the summary amount of each feature
within each planning unit. Rows correspond to different spatial features
in the argument to <code>y</code> and columns correspond to different raster
layers in the argument to <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+extract">terra::extract()</a></code>, <code><a href="exactextractr.html#topic+exact_extract">exactextractr::exact_extract()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()

# extract data
result &lt;- fast_extract(sim_features, sim_pu_polygons)

# show result
print(head(result))

</code></pre>

<hr>
<h2 id='feature_abundances'>Feature abundances</h2><span id='topic+feature_abundances'></span><span id='topic+feature_abundances.ConservationProblem'></span>

<h3>Description</h3>

<p>Calculate the total abundance of each feature found in the planning units
of a conservation planning problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feature_abundances(x, na.rm)

## S3 method for class 'ConservationProblem'
feature_abundances(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feature_abundances_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="feature_abundances_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code> should planning units with <code>NA</code> cost
data be excluded from the abundance calculations? The default argument
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Planning units can have cost data with finite values
(e.g., 0.1, 3, 100) and <code>NA</code> values. This functionality is provided so
that locations which are not available for protected area acquisition can
be included when calculating targets for conservation features
(e.g., when targets are specified using <code><a href="#topic+add_relative_targets">add_relative_targets()</a></code>).
If the total amount of each feature in all the planning units is
required&mdash;including the planning units with <code>NA</code> cost data&mdash;then the
the <code>na.rm</code> argument should be set to <code>FALSE</code>. However, if
the planning units with <code>NA</code> cost data should be
excluded&mdash;for instance, to calculate the highest feasible targets for
each feature&mdash;then the <code>na.rm</code> argument should be set to
<code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> object containing the total amount
(<code>"absolute_abundance"</code>) and proportion (<code>"relative_abundance"</code>)
of the distribution of each feature in the planning units. Here, each
row contains data that pertain to a specific feature in a specific
management zone (if multiple zones are present). This object
contains the following columns:
</p>

<dl>
<dt>feature</dt><dd><p><code>character</code> name of the feature.</p>
</dd>
<dt>zone</dt><dd><p><code>character</code> name of the zone (not included when the
argument to <code>x</code> contains only one management zone).</p>
</dd>
<dt>absolute_abundance</dt><dd><p><code>numeric</code> amount of each feature in the
planning units. If the problem contains multiple zones, then this
column shows how well each feature is represented in a each
zone.</p>
</dd>
<dt>relative_abundance</dt><dd><p><code>numeric</code> proportion of the feature's
distribution in the planning units. If the argument to <code>na.rm</code> is
<code>FALSE</code>, then this column will only contain values equal to one.
Otherwise, if the argument to <code>na.rm</code> is <code>TRUE</code> and planning
units with <code>NA</code> cost data contain non-zero amounts of each feature,
then this column will contain values between zero and one.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+problem">problem()</a></code>, <code><a href="#topic+eval_feature_representation_summary">eval_feature_representation_summary()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create a simple conservation planning dataset so we can see exactly
# how the feature abundances are calculated
pu &lt;- data.frame(
  id = seq_len(10),
  cost = c(0.2, NA, runif(8)),
  spp1 = runif(10),
  spp2 = c(rpois(9, 4), NA)
)

# create problem
p1 &lt;- problem(pu, c("spp1", "spp2"), cost_column = "cost")

# calculate feature abundances; including planning units with NA costs
a1 &lt;- feature_abundances(p1, na.rm = FALSE) # (default)
print(a1)

# calculate feature abundances; excluding planning units with NA costs
a2 &lt;- feature_abundances(p1, na.rm = TRUE)
print(a2)

# verify correctness of feature abundance calculations
all.equal(
  a1$absolute_abundance,
  c(sum(pu$spp1), sum(pu$spp2, na.rm = TRUE))
)

all.equal(
  a1$relative_abundance,
  c(sum(pu$spp1) / sum(pu$spp1),
  sum(pu$spp2, na.rm = TRUE) / sum(pu$spp2, na.rm = TRUE))
)

all.equal(
  a2$absolute_abundance,
  c(
    sum(pu$spp1[!is.na(pu$cost)]),
    sum(pu$spp2[!is.na(pu$cost)], na.rm = TRUE)
  )
)

all.equal(
  a2$relative_abundance,
  c(
    sum(pu$spp1[!is.na(pu$cost)]) / sum(pu$spp1, na.rm = TRUE),
    sum(pu$spp2[!is.na(pu$cost)], na.rm = TRUE) /
      sum(pu$spp2, na.rm = TRUE)
  )
)

# initialize conservation problem with raster data
p3 &lt;- problem(sim_pu_raster, sim_features)

# calculate feature abundances; including planning units with NA costs
a3 &lt;- feature_abundances(p3, na.rm = FALSE) # (default)
print(a3)

# create problem using total amounts of features in all the planning units
# (including units with NA cost data)
p4 &lt;-
  p3 %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(a3$relative_abundance) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# attempt to solve the problem, but we will see that this problem is
# infeasible because the targets cannot be met using only the planning units
# with finite cost data
s4 &lt;- try(solve(p4))

# calculate feature abundances; excluding planning units with NA costs
a5 &lt;- feature_abundances(p3, na.rm = TRUE)
print(a5)

# create problem using total amounts of features in the planning units with
# finite cost data
p5 &lt;-
  p3 %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(a5$relative_abundance) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s5 &lt;- solve(p5)

# plot the solution
# this solution contains all the planning units with finite cost data
# (i.e., cost data that do not have NA values)
plot(s5)

## End(Not run)
</code></pre>

<hr>
<h2 id='feature_names'>Feature names</h2><span id='topic+feature_names'></span><span id='topic+feature_names.ConservationProblem'></span><span id='topic+feature_names.ZonesRaster'></span><span id='topic+feature_names.ZonesSpatRaster'></span><span id='topic+feature_names.ZonesCharacter'></span>

<h3>Description</h3>

<p>Extract the names of the features in an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feature_names(x, ...)

## S3 method for class 'ConservationProblem'
feature_names(x, ...)

## S3 method for class 'ZonesRaster'
feature_names(x, ...)

## S3 method for class 'ZonesSpatRaster'
feature_names(x, ...)

## S3 method for class 'ZonesCharacter'
feature_names(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feature_names_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> or <code><a href="#topic+Zones">Zones()</a></code> object.</p>
</td></tr>
<tr><td><code id="feature_names_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector of feature names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions()

# print feature names
print(feature_names(p))

## End(Not run)
</code></pre>

<hr>
<h2 id='importance'>Evaluate solution importance</h2><span id='topic+importance'></span><span id='topic+irreplaceability'></span>

<h3>Description</h3>

<p>Importance scores (also known as irreplaceability scores) can be used to
assess the relative importance of planning units selected in a solution to a
conservation planning problem.
</p>


<h3>Details</h3>

<p>The following methods are available for calculating importance scores
for a solution to a conservation planning <code><a href="#topic+problem">problem()</a></code>:
</p>

<dl>
<dt><code><a href="#topic+eval_replacement_importance">eval_replacement_importance()</a></code></dt><dd>
<p>Calculate importance scores using replacement costs (based
on Cabeza and Moilanen 2006).
These scores quantify the change in the objective
function (e.g., additional costs required to meet feature targets) of the
optimal solution if a given planning unit in a solution cannot be acquired.
They can (i) account for the cost of different planning units, (ii) account
for multiple management zones, (iii) apply to any objective function, and
(iv) identify truly irreplaceable planning units (denoted with infinite
values).</p>
</dd>
<dt><code><a href="#topic+eval_ferrier_importance">eval_ferrier_importance()</a></code></dt><dd>
<p>Calculate importance scores following Ferrier <em>et al.</em> (2000).
These scores measure importance based on how critical
planning units are for meeting targets. They can only be applied to
conservation problems that use targets and a single zone
(e.g., the classic <em>Marxan</em>-type problem). Furthermore &ndash; unlike the
replacement cost scores &ndash; these scores provide a
score for each feature within each planning unit, providing insight into
why certain planning units are more important than other planning units.</p>
</dd>
<dt><code><a href="#topic+eval_rare_richness_importance">eval_rare_richness_importance()</a></code></dt><dd>
<p>Calculate importance scores using the rarity weighted richness metric
(based on Williams <em>et al.</em> 1996).
These score are simply a measure of biodiversity.
They do not account for planning costs, multiple management zones, objective
functions, or feature targets (or weightings).
They merely describe the spatial patterns of
biodiversity, and do not account for many of the factors needed to quantify
the importance of a planning unit for achieving conservation goals.</p>
</dd>
</dl>

<p>Broadly speaking, we recommend using replacement cost scores where
possible. This is because they can be applied to any type of conservation
planning problem &ndash; regardless of the objective function or number of
zones considered in the problem &ndash; and measure planning unit importance based
on degradation of the prioritization.
Although the replacement cost scores can be calculated for small and
moderate sized problems (e.g., less than 30,000 planning units), they may not
be feasible for particularly large problems (e.g., more than 100,000 planning
units). In such cases, we recommend calculating importance scores using the
Ferrier method. This is because the Ferrier method can be
calculated relatively quickly for large-sized problems and it
explicitly accounts for representation targets.
We only recommend using the rarity weighted richness metric
when neither of the other two methods can be used.
</p>


<h3>References</h3>

<p>Cabeza M and Moilanen A (2006) Replacement cost: A practical measure of site
value for cost-effective reserve planning. <em>Biological Conservation</em>,
132:  336&ndash;342.
</p>
<p>Ferrier S, Pressey RL, and Barrett TW (2000) A new predictor of the
irreplaceability of areas for achieving a conservation goal, its application
to real-world planning, and a research agenda for further refinement.
<em>Biological Conservation</em>, 93: 303&ndash;325.
</p>
<p>Williams P, Gibbons D, Margules C, Rebelo A, Humphries C, and Pressey RL
(1996) A comparison of richness hotspots, rarity hotspots and complementary
areas for conserving diversity using British birds.
<em>Conservation Biology</em>, 10: 155&ndash;174.
</p>


<h3>See Also</h3>

<p>Other overviews: 
<code><a href="#topic+constraints">constraints</a></code>,
<code><a href="#topic+decisions">decisions</a></code>,
<code><a href="#topic+objectives">objectives</a></code>,
<code><a href="#topic+penalties">penalties</a></code>,
<code><a href="#topic+portfolios">portfolios</a></code>,
<code><a href="#topic+solvers">solvers</a></code>,
<code><a href="#topic+summaries">summaries</a></code>,
<code><a href="#topic+targets">targets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# build minimal conservation problem with raster data
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(gap = 0, verbose = FALSE)

# solve the problem
s1 &lt;- solve(p1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# calculate importance scores using replacement cost scores
ir1 &lt;- eval_replacement_importance(p1, s1)

# calculate importance scores using Ferrier et al 2000 method,
# and extract the total importance scores
ir2 &lt;- eval_ferrier_importance(p1, s1)[["total"]]

# calculate importance scores using rarity weighted richness scores
ir3 &lt;- eval_rare_richness_importance(p1, s1)

# create multi-band raster with different importance scores
ir &lt;- c(ir1, ir2, ir3)
names(ir) &lt;- c(
  "replacement cost", "Ferrier score", "rarity weighted richness"
)

# plot importance scores
plot(ir, axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='intersecting_units'>Find intersecting units</h2><span id='topic+intersecting_units'></span><span id='topic+intersecting_units+2CRaster+2CANY-method'></span><span id='topic+intersecting_units+2CANY+2CRaster-method'></span><span id='topic+intersecting_units+2CSpatial+2CANY-method'></span><span id='topic+intersecting_units+2CANY+2CSpatial-method'></span><span id='topic+intersecting_units+2Csf+2Csf-method'></span><span id='topic+intersecting_units+2CSpatRaster+2Csf-method'></span><span id='topic+intersecting_units+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+intersecting_units+2Csf+2CSpatRaster-method'></span><span id='topic+intersecting_units+2Cdata.frame+2CANY-method'></span>

<h3>Description</h3>

<p>Find which of the units in a spatial data object intersect
with the units in another spatial data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersecting_units(x, y)

## S4 method for signature 'Raster,ANY'
intersecting_units(x, y)

## S4 method for signature 'ANY,Raster'
intersecting_units(x, y)

## S4 method for signature 'Spatial,ANY'
intersecting_units(x, y)

## S4 method for signature 'ANY,Spatial'
intersecting_units(x, y)

## S4 method for signature 'SpatRaster,SpatRaster'
intersecting_units(x, y)

## S4 method for signature 'sf,sf'
intersecting_units(x, y)

## S4 method for signature 'SpatRaster,sf'
intersecting_units(x, y)

## S4 method for signature 'sf,SpatRaster'
intersecting_units(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersecting_units_+3A_x">x</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf::st_sf()</a></code> or <code><a href="terra.html#topic+rast">terra::rast()</a></code> object.</p>
</td></tr>
<tr><td><code id="intersecting_units_+3A_y">y</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf::st_sf()</a></code> or <code><a href="terra.html#topic+rast">terra::rast()</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The performance of this function for large <code><a href="terra.html#topic+rast">terra::rast()</a></code> objects
can be improved by increasing the GDAL cache size.
The default cache size is 25 MB.
For example, the following code can be used to set the cache size to 4 GB.
</p>
<div class="sourceCode"><pre>terra::gdalCache(size = 4000)
</pre></div>


<h3>Value</h3>

<p>An <code>integer</code> vector of indices of the units in <code>x</code> that intersect
with <code>y</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+fast_extract">fast_extract()</a></code> for extracting data from spatial datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create data
r &lt;- terra::rast(matrix(1:9, byrow = TRUE, ncol = 3))
r_with_holes &lt;- r
r_with_holes[c(1, 5, 9)] &lt;- NA
ply &lt;- sf::st_as_sf(terra::as.polygons(r))
ply_with_holes &lt;- sf::st_as_sf(terra::as.polygons(r_with_holes))

# intersect raster with raster
par(mfrow = c(1, 2))
plot(r, main = "x = SpatRaster", axes = FALSE)
plot(r_with_holes, main = "y = SpatRaster", axes = FALSE)
print(intersecting_units(r, r_with_holes))

# intersect raster with sf
par(mfrow = c(1, 2))
plot(r, main = "x = SpatRaster", axes = FALSE)
plot(ply_with_holes, main = "y = sf", key.pos = NULL, reset = FALSE)
print(intersecting_units(r, ply_with_holes))

# intersect sf with raster
par(mfrow = c(1, 2))
plot(ply, main = "x = sf", key.pos = NULL, reset = FALSE)
plot(r_with_holes, main = "y = SpatRaster")
print(intersecting_units(ply, r_with_holes))

# intersect sf with sf
par(mfrow = c(1, 2))
plot(ply, main = "x = sf", key.pos = NULL, reset = FALSE)
plot(ply_with_holes, main = "y = sf", key.pos = NULL, reset = FALSE)
print(intersecting_units(ply, ply_with_holes))

## End(Not run)

</code></pre>

<hr>
<h2 id='knit_print'>Print an object for knitr package.</h2><span id='topic+knit_print'></span><span id='topic+knit_print.ConservationProblem'></span><span id='topic+knit_print.OptimizationProblem'></span>

<h3>Description</h3>

<p>This function is used to ensure that <code><a href="#topic+problem">problem()</a></code> and
<code><a href="#topic+new_optimization_problem">new_optimization_problem()</a></code> objects are displayed correctly in
<span class="pkg">rmarkdown</span> reports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_print.ConservationProblem(x, ...)

knit_print.OptimizationProblem(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_print_+3A_x">x</code></td>
<td>
<p>Object.</p>
</td></tr>
<tr><td><code id="knit_print_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be called directly. It is intended to be used
by the <span class="pkg">knitr</span> package when displaying objects.
</p>


<h3>Value</h3>

<p>A <code>character</code> vector for knitting.
</p>

<hr>
<h2 id='loglinear_interpolation'>Log-linear interpolation</h2><span id='topic+loglinear_interpolation'></span>

<h3>Description</h3>

<p>Log-linearly interpolate values between two thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglinear_interpolation(
  x,
  coordinate_one_x,
  coordinate_one_y,
  coordinate_two_x,
  coordinate_two_y
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglinear_interpolation_+3A_x">x</code></td>
<td>
<p><code>numeric</code> <em>x</em> values for which interpolate <em>y</em>
values.</p>
</td></tr>
<tr><td><code id="loglinear_interpolation_+3A_coordinate_one_x">coordinate_one_x</code></td>
<td>
<p><code>numeric</code> value for lower <em>x</em>-coordinate.</p>
</td></tr>
<tr><td><code id="loglinear_interpolation_+3A_coordinate_one_y">coordinate_one_y</code></td>
<td>
<p><code>numeric</code> value for lower <em>y</em>-coordinate.</p>
</td></tr>
<tr><td><code id="loglinear_interpolation_+3A_coordinate_two_x">coordinate_two_x</code></td>
<td>
<p><code>numeric</code> value for upper <em>x</em>-coordinate.</p>
</td></tr>
<tr><td><code id="loglinear_interpolation_+3A_coordinate_two_y">coordinate_two_y</code></td>
<td>
<p><code>numeric</code> value for upper <em>y</em>-coordinate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values are log-linearly interpolated at the <em>x</em>-coordinates
specified in <code>x</code> using the lower and upper coordinate arguments to
define the line. Values lesser or greater than these numbers are assigned
the minimum and maximum <em>y</em> coordinates.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create series of x-values
x &lt;- seq(0, 1000)

# interpolate y-values for the x-values given the two reference points:
# (200, 100) and (900, 15)
y &lt;- loglinear_interpolation(x, 200, 100, 900, 15)

# plot the interpolated values
plot(y ~ x)

# add the reference points to the plot (shown in red)
points(x = c(200, 900), y = c(100, 15), pch = 18, col = "red", cex = 2)

# this function can also be used to calculate representation targets
# following Rodrigues et al. (2014). For example, let's say that
# we had a set of species we were interested in calculating representation
# targets for and we had information on their range sizes (in km^2).
spp_range_size_km2 &lt;- seq(0.01, 15000000, by = 100)

# we can now use this function to calculate representation targets
# (expressed as a percentage of the species' range sizes) using
# the thresholds and cap sizes reported by Rodrigues et al. 2014
spp_target_percentage_rodrigues &lt;- loglinear_interpolation(
    x = spp_range_size_km2,
    coordinate_one_x = 1000,
    coordinate_one_y = 1,
    coordinate_two_x = 250000,
    coordinate_two_y = 0.1
) * 100

# it is also common to apply a cap to the representation targets,
# so let's apply the cap these targets following Butchart et al. (2015)
spp_target_percentage_butchart &lt;- ifelse(
  spp_range_size_km2 &gt;= 10000000,
  (1000000 / spp_range_size_km2) * 100,
  spp_target_percentage_rodrigues
)

# plot species range sizes and representation targets
plot(
  spp_target_percentage_butchart ~ spp_range_size_km2,
  xlab = "Range size km^2" , ylab = "Representation target (%)", type = "l"
)

# plot species range sizes and representation targets on a log10 scale
plot(
  spp_target_percentage_butchart ~ log10(spp_range_size_km2),
  xlab = "Range size km^2" , ylab = "Representation target (%)",
  type = "l", xaxt = "n"
)
axis(
  1, pretty(log10(spp_range_size_km2)),
  10^pretty(log10(spp_range_size_km2))
)

## End(Not run)
</code></pre>

<hr>
<h2 id='marxan_boundary_data_to_matrix'>Convert <em>Marxan</em> boundary data to matrix format</h2><span id='topic+marxan_boundary_data_to_matrix'></span>

<h3>Description</h3>

<p>Convert a <code>data.frame</code> object containing <em>Marxan</em> boundary data
to matrix format. This function is designed specifically for
boundary data (not connectivity data).
It ensures that the output matrix correctly specifies
symmetric spatial relationships between planning units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marxan_boundary_data_to_matrix(x, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marxan_boundary_data_to_matrix_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object that
contains planning unit and zone data to ensure that the argument to
<code>data</code> is converted correctly. This argument can be set to
<code>NULL</code> if checks are not required (not recommended).</p>
</td></tr>
<tr><td><code id="marxan_boundary_data_to_matrix_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> object with the columns <code>"id1"</code>,
<code>"id2"</code>, and <code>"boundary"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> sparse matrix object.
</p>


<h3>Notes</h3>

<p>In earlier versions, the function could convert boundary data
that pertain to multiple zones. This is no longer possible, following
updates to streamline the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create marxan boundary with four planning units and one zone
bldf1 &lt;- expand.grid(id1 = seq_len(4), id2 = seq_len(4))
bldf1$boundary &lt;- 1
bldf1$boundary[bldf1$id1 == bldf1$id2] &lt;- 0.5

# convert to matrix
m1 &lt;- marxan_boundary_data_to_matrix(NULL, bldf1)

# visualize matrix
## Not run: 
image(m1)

## End(Not run)
</code></pre>

<hr>
<h2 id='marxan_connectivity_data_to_matrix'>Convert <em>Marxan</em> connectivity data to matrix format</h2><span id='topic+marxan_connectivity_data_to_matrix'></span>

<h3>Description</h3>

<p>Convert a <code>data.frame</code> object containing <em>Marxan</em> connectivity data
to matrix format. This function is designed specifically for
connectivity data (not boundary data).
It ensures that the output matrix correctly specifies
symmetric or asymmetric connectivity relationships between planning units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marxan_connectivity_data_to_matrix(x, data, symmetric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marxan_connectivity_data_to_matrix_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object that
contains planning unit and zone data to ensure that the argument to
<code>data</code> is converted correctly. This argument can be set to
<code>NULL</code> if checks are not required (not recommended).</p>
</td></tr>
<tr><td><code id="marxan_connectivity_data_to_matrix_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> object with the columns <code>"id1"</code>,
<code>"id2"</code>, and <code>"boundary"</code>.</p>
</td></tr>
<tr><td><code id="marxan_connectivity_data_to_matrix_+3A_symmetric">symmetric</code></td>
<td>
<p><code>logical</code> does the connectivity data
describe symmetric relationships between planning units?
If the data contain asymmetric connectivity data,
this parameter should be set to <code>FALSE</code>.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> sparse matrix object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create marxan connectivity data with four planning units and one zone,
# and symmetric connectivity values
bldf1 &lt;- expand.grid(id1 = seq_len(4), id2 = seq_len(4))
bldf1$boundary &lt;- 1
bldf1$boundary[bldf1$id1 == bldf1$id2] &lt;- 0.5

# print data
print(bldf1)

# convert to matrix
m1 &lt;- marxan_connectivity_data_to_matrix(NULL, bldf1)

# print matrix
print(m1)

# visualize matrix
image(m1)

# create marxan connectivity data with four planning units and one zone,
# and asymmetric connectivity values
bldf2 &lt;- expand.grid(id1 = seq_len(4), id2 = seq_len(4))
bldf2$boundary &lt;- runif(nrow(bldf2))
bldf2$boundary[bldf1$id1 == bldf1$id2] &lt;- 0.5

# print data
print(bldf2)

# convert to matrix
m2 &lt;- marxan_connectivity_data_to_matrix(NULL, bldf2, symmetric = FALSE)

# print matrix
print(m2)

# visualize matrix
image(m2)

# create marxan connectivity with three planning units and two zones,
# and symmetric connectivity values
bldf3 &lt;- expand.grid(
  id1 = seq_len(3), id2 = seq_len(3),
  zone1 = c("z1", "z2"),
  zone2 = c("z1", "z2")
)
bldf3$boundary &lt;- 1
bldf3$boundary[bldf2$id1 == bldf2$id2 &amp; bldf2$zone1 == bldf2$zone2] &lt;- 0.5
bldf3$boundary[bldf2$id1 == bldf2$id2 &amp; bldf2$zone1 != bldf2$zone2] &lt;- 0

# print data
print(bldf3)

# convert to array
m3 &lt;- marxan_connectivity_data_to_matrix(NULL, bldf3)

# print array
print(m3)

## End(Not run)
</code></pre>

<hr>
<h2 id='marxan_problem'><em>Marxan</em> conservation problem</h2><span id='topic+marxan_problem'></span><span id='topic+marxan_problem.default'></span><span id='topic+marxan_problem.data.frame'></span><span id='topic+marxan_problem.character'></span>

<h3>Description</h3>

<p>Create a conservation planning <code><a href="#topic+problem">problem()</a></code> following the
mathematical formulations used in <em>Marxan</em> (detailed in Beyer
<em>et al.</em> 2016). Note that these problems are solved using
exact algorithms and not simulated annealing (i.e., the <em>Marxan</em> software).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marxan_problem(x, ...)

## Default S3 method:
marxan_problem(x, ...)

## S3 method for class 'data.frame'
marxan_problem(x, spec, puvspr, bound = NULL, blm = 0, symmetric = TRUE, ...)

## S3 method for class 'character'
marxan_problem(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marxan_problem_+3A_x">x</code></td>
<td>
<p><code>character</code> file path for a <em>Marxan</em> input file (typically
called <code>"input.dat"</code>), or <code>data.frame</code> containing planning unit
data (typically called <code>"pu.dat"</code>). If the argument to <code>x</code> is a
<code>data.frame</code>, then each row corresponds to a different planning unit,
and it must have the following columns:
</p>

<dl>
<dt>id</dt><dd><p><code>integer</code> unique identifier for each planning unit.
These identifiers are used in the argument to <code>puvspr</code>.</p>
</dd>
<dt>cost</dt><dd><p><code>numeric</code> cost of each planning unit.</p>
</dd>
<dt>status</dt><dd><p><code>integer</code> indicating if each planning unit
should not be locked in the solution (0) or if it should be locked in
(2) or locked out (3) of the solution. Although <em>Marxan</em> allows
planning units to be selected in the initial solution (using values of
1), these values have no effect here. This column is optional.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="marxan_problem_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="marxan_problem_+3A_spec">spec</code></td>
<td>
<p><code>data.frame</code> containing information on the features.
The argument to <code>spec</code> must follow the conventions used by
<em>Marxan</em> for the species data file (conventionally called
<code>"spec.dat"</code>). Each row corresponds to a different feature and
each column corresponds to different information about the features. It
must contain the columns listed below. Note that the argument to
<code>spec</code> must contain at least one column named <code>"prop"</code> or
<code>"amount"</code>&mdash;<strong>but not both columns with both of these
names</strong>&mdash;to specify the target for each feature.
</p>

<dl>
<dt>id</dt><dd><p><code>integer</code> unique identifier for each feature
These identifiers are used in the argument to <code>puvspr</code>.</p>
</dd>
<dt>name</dt><dd><p><code>character</code> name for each feature.</p>
</dd>
<dt>prop</dt><dd><p><code>numeric</code> relative target for each feature
(optional).</p>
</dd></dl>
<p>'
</p>
<dl>
<dt>amount</dt><dd><p><code>numeric</code> absolute target for each
feature (optional).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="marxan_problem_+3A_puvspr">puvspr</code></td>
<td>
<p><code>data.frame</code> containing information on the amount of
each feature in each planning unit. The argument to
<code>puvspr</code> must follow the conventions used in the <em>Marxan</em> input
data file (conventionally called <code>"puvspr.dat"</code>). It must contain the
following columns:
</p>

<dl>
<dt>pu</dt><dd><p><code>integer</code> planning unit identifier.</p>
</dd>
<dt>species</dt><dd><p><code>integer</code> feature identifier.</p>
</dd>
<dt>amount</dt><dd><p><code>numeric</code> amount of the feature in the
planning unit.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="marxan_problem_+3A_bound">bound</code></td>
<td>
<p><code>NULL</code> object indicating that no boundary data
is required for the conservation planning problem, or a <code>data.frame</code>
containing information on the planning units' boundaries. The argument to
<code>bound</code> must follow the conventions used in the <em>Marxan</em> input
data file (conventionally called <code>"bound.dat"</code>). It must contain the
following columns:
</p>

<dl>
<dt>id1</dt><dd><p><code>integer</code> planning unit identifier.</p>
</dd>
<dt>id2</dt><dd><p><code>integer</code> planning unit identifier.</p>
</dd>
<dt>boundary</dt><dd><p><code>numeric</code> length of shared boundary
between the planning units identified in the previous two columns.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="marxan_problem_+3A_blm">blm</code></td>
<td>
<p><code>numeric</code> boundary length modifier. This argument only
has an effect when argument to <code>x</code> is a <code>data.frame</code>. The
default argument is zero.</p>
</td></tr>
<tr><td><code id="marxan_problem_+3A_symmetric">symmetric</code></td>
<td>
<p><code>logical</code> does the boundary data (i.e., argument to
<code>bound</code>) describe symmetric relationships between planning units?
If the boundary data contain asymmetric connectivity data,
this parameter should be set to <code>FALSE</code>.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is provided as a convenient wrapper for solving
<em>Marxan</em> problems using the <span class="pkg">prioritizr</span> package.
Please note that it requires installation of the <span class="pkg">data.table</span> package
to import <em>Marxan</em> data files.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+problem">problem()</a></code> object.
</p>


<h3>Notes</h3>

<p>In previous versions, this function could not accommodate asymmetric
connectivity data. It has now been updated to handle asymmetric connectivity
data.
</p>


<h3>References</h3>

<p>Ball IR, Possingham HP, and Watts M (2009) <em>Marxan and relatives:
Software for spatial conservation prioritisation</em> in Spatial conservation
prioritisation: Quantitative methods and computational tools. Eds Moilanen
A, Wilson KA, and Possingham HP. Oxford University Press, Oxford, UK.
</p>
<p>Beyer HL, Dujardin Y, Watts ME, and Possingham HP (2016) Solving
conservation planning problems with integer linear programming.
<em>Ecological Modelling</em>, 228: 14&ndash;22.
</p>


<h3>See Also</h3>

<p>For more information on the correct format for
for <em>Marxan</em> input data, see the
<a href="https://marxansolutions.org">official <em>Marxan</em> website</a> and Ball
<em>et al.</em> (2009).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create Marxan problem using Marxan input file
# (note this example requires the data.table package to be installed)
## Not run: 
input_file &lt;- system.file("extdata/marxan/input.dat", package = "prioritizr")
p1 &lt;-
  marxan_problem(input_file) %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s1 &lt;- solve(p1)

# print solution
head(s1)

# create Marxan problem using data.frames that have been loaded into R
# (note this example also requires the data.table package to be installed)
## load in planning unit data
pu_path &lt;- system.file("extdata/marxan/input/pu.dat", package = "prioritizr")
pu_dat &lt;- data.table::fread(pu_path, data.table = FALSE)
head(pu_dat)

## load in feature data
spec_path &lt;- system.file(
  "extdata/marxan/input/spec.dat", package = "prioritizr"
)
spec_dat &lt;- data.table::fread(spec_path, data.table = FALSE)
head(spec_dat)

## load in planning unit vs feature data
puvspr_path &lt;- system.file(
  "extdata/marxan/input/puvspr.dat", package = "prioritizr"
)
puvspr_dat &lt;- data.table::fread(puvspr_path, data.table = FALSE)
head(puvspr_dat)

## load in the boundary data
bound_path &lt;- system.file(
  "extdata/marxan/input/bound.dat", package = "prioritizr"
)
bound_dat &lt;- data.table::fread(bound_path, data.table = FALSE)
head(bound_dat)

# create problem without the boundary data
p2 &lt;-
  marxan_problem(pu_dat, spec_dat, puvspr_dat) %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s2 &lt;- solve(p2)

# print solution
head(s2)

# create problem with the boundary data and a boundary length modifier
# set to 5
p3 &lt;-
  marxan_problem(pu_dat, spec_dat, puvspr_dat, bound_dat, blm = 5) %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s3 &lt;- solve(p3)

# print solution
head(s3)

## End(Not run)
</code></pre>

<hr>
<h2 id='new_waiver'>Waiver</h2><span id='topic+new_waiver'></span>

<h3>Description</h3>

<p>Create a <code>waiver</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_waiver()
</code></pre>


<h3>Details</h3>

<p>This object is used to represent that the user has not manually
specified a setting, and so defaults should be used. By explicitly
using a <code>new_waiver()</code>, this means that <code>NULL</code> objects can be a
valid setting. The use of a waiver object was inspired by the
<code>ggplot2</code> package.
</p>


<h3>Value</h3>

<p>A <code>Waiver</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create new waiver object
w &lt;- new_waiver()

# print object
print(w)

</code></pre>

<hr>
<h2 id='number_of_features'>Number of features</h2><span id='topic+number_of_features'></span><span id='topic+number_of_features.ConservationProblem'></span><span id='topic+number_of_features.OptimizationProblem'></span><span id='topic+number_of_features.ZonesSpatRaster'></span><span id='topic+number_of_features.ZonesRaster'></span><span id='topic+number_of_features.ZonesCharacter'></span>

<h3>Description</h3>

<p>Extract the number of features in an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_of_features(x, ...)

## S3 method for class 'ConservationProblem'
number_of_features(x, ...)

## S3 method for class 'OptimizationProblem'
number_of_features(x, ...)

## S3 method for class 'ZonesSpatRaster'
number_of_features(x, ...)

## S3 method for class 'ZonesRaster'
number_of_features(x, ...)

## S3 method for class 'ZonesCharacter'
number_of_features(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_of_features_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+problem">problem()</a></code>, <code><a href="#topic+optimization_problem">optimization_problem()</a></code>, or <code><a href="#topic+zones">zones()</a></code> object.</p>
</td></tr>
<tr><td><code id="number_of_features_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>integer</code> number of features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions()

# print number of features
print(number_of_features(p))

## End(Not run)
</code></pre>

<hr>
<h2 id='number_of_planning_units'>Number of planning units</h2><span id='topic+number_of_planning_units'></span><span id='topic+number_of_planning_units.ConservationProblem'></span><span id='topic+number_of_planning_units.OptimizationProblem'></span>

<h3>Description</h3>

<p>Extract the number of planning units in an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_of_planning_units(x, ...)

## S3 method for class 'ConservationProblem'
number_of_planning_units(x, ...)

## S3 method for class 'OptimizationProblem'
number_of_planning_units(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_of_planning_units_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> or <code><a href="#topic+optimization_problem">optimization_problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="number_of_planning_units_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The planning units for an object corresponds to the number
of entries (e.g., rows, cells) for the planning unit data that
do not have missing (<code>NA</code>) values for every zone.
For example, a single-layer raster dataset might have 90 cells
and only two of these cells contain non-missing (<code>NA</code>) values.
As such, this dataset would have two planning units.
</p>


<h3>Value</h3>

<p>An <code>integer</code> number of planning units.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions()

# print number of planning units
print(number_of_planning_units(p))

## End(Not run)
</code></pre>

<hr>
<h2 id='number_of_total_units'>Number of total units</h2><span id='topic+number_of_total_units'></span><span id='topic+number_of_total_units.ConservationProblem'></span>

<h3>Description</h3>

<p>Extract the number of total units in an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_of_total_units(x, ...)

## S3 method for class 'ConservationProblem'
number_of_total_units(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_of_total_units_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="number_of_total_units_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total units for an object corresponds to the total number
of entries (e.g., rows, cells) for the planning unit data.
For example, a single-layer raster dataset might have 90 cells
and only two of these cells contain non-missing (<code>NA</code>) values.
As such, this dataset would have 90 total units and two planning units.
</p>


<h3>Value</h3>

<p>An <code>integer</code> number of total units.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# create problem with one zone
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions()

# print number of planning units
print(number_of_planning_units(p1))

# print number of total units
print(number_of_total_units(p1))

# create problem with multiple zones
p2 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(0.2, ncol = 3, nrow = 5)) %&gt;%
  add_binary_decisions()

# print number of planning units
print(number_of_planning_units(p2))

# print number of total units
print(number_of_total_units(p2))

## End(Not run)
</code></pre>

<hr>
<h2 id='number_of_zones'>Number of zones</h2><span id='topic+number_of_zones'></span><span id='topic+number_of_zones.ConservationProblem'></span><span id='topic+number_of_zones.OptimizationProblem'></span><span id='topic+number_of_zones.ZonesRaster'></span><span id='topic+number_of_zones.ZonesSpatRaster'></span><span id='topic+number_of_zones.ZonesCharacter'></span>

<h3>Description</h3>

<p>Extract the number of zones in an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_of_zones(x, ...)

## S3 method for class 'ConservationProblem'
number_of_zones(x, ...)

## S3 method for class 'OptimizationProblem'
number_of_zones(x, ...)

## S3 method for class 'ZonesRaster'
number_of_zones(x, ...)

## S3 method for class 'ZonesSpatRaster'
number_of_zones(x, ...)

## S3 method for class 'ZonesCharacter'
number_of_zones(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_of_zones_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code>, <code><a href="#topic+optimization_problem">optimization_problem()</a></code>, or <code><a href="#topic+zones">zones()</a></code> object.</p>
</td></tr>
<tr><td><code id="number_of_zones_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>integer</code> number of zones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# print number of zones in a Zones object
print(number_of_zones(sim_zones_features))
# create problem with multiple zones
p &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(0.2, ncol = 3, nrow = 5)) %&gt;%
  add_binary_decisions()

# print number of zones in the problem
print(number_of_zones(p))

## End(Not run)
</code></pre>

<hr>
<h2 id='Objective-class'>Objective class</h2><span id='topic+Objective-class'></span><span id='topic+Objective'></span>

<h3>Description</h3>

<p>This class is used to represent the objective function used in optimization.
<strong>Only experts should use the fields and methods for this class directly.</strong>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ConservationModifier">prioritizr::ConservationModifier</a></code> -&gt; <code>Objective</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Objective-default_weights"><code>Objective$default_weights()</code></a>
</p>
</li>
<li> <p><a href="#method-Objective-apply"><code>Objective$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-Objective-clone"><code>Objective$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="calculate"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-calculate'><code>prioritizr::ConservationModifier$calculate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_data'><code>prioritizr::ConservationModifier$get_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_internal'><code>prioritizr::ConservationModifier$get_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="print"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-print'><code>prioritizr::ConservationModifier$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="repr"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-repr'><code>prioritizr::ConservationModifier$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_data'><code>prioritizr::ConservationModifier$set_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_internal'><code>prioritizr::ConservationModifier$set_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="show"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-show'><code>prioritizr::ConservationModifier$show()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Objective-default_weights"></a>



<h4>Method <code>default_weights()</code></h4>

<p>Specify default values for weights.
</p>


<h5>Usage</h5>

<div class="r"><pre>Objective$default_weights(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code><a href="#topic+problem">problem()</a></code> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-Objective-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Update an optimization problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Objective$apply(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code><a href="#topic+optimization_problem">optimization_problem()</a></code> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-Objective-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Objective$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+ConservationModifier-class">ConservationModifier-class</a></code>,
<code><a href="#topic+ConservationProblem-class">ConservationProblem-class</a></code>,
<code><a href="#topic+Constraint-class">Constraint-class</a></code>,
<code><a href="#topic+Decision-class">Decision-class</a></code>,
<code><a href="#topic+OptimizationProblem-class">OptimizationProblem-class</a></code>,
<code><a href="#topic+Penalty-class">Penalty-class</a></code>,
<code><a href="#topic+Portfolio-class">Portfolio-class</a></code>,
<code><a href="#topic+Solver-class">Solver-class</a></code>,
<code><a href="#topic+Target-class">Target-class</a></code>
</p>

<hr>
<h2 id='objectives'>Add an objective</h2><span id='topic+objectives'></span>

<h3>Description</h3>

<p>An objective is used to specify the overall goal of a conservation planning
problem. All conservation planning problems involve minimizing
or maximizing some kind of objective. For instance, the planner may require
a solution that conserves enough habitat for each species while minimizing
the overall cost of the reserve network. Alternatively, the planner may
require a solution that maximizes the number of conserved species while
ensuring that the cost of the reserve network does not exceed the budget.
</p>


<h3>Details</h3>

<p><strong>Please note that all conservation
planning problems formulated using the <span class="pkg">prioritizr</span> package require an
objective function, and attempting to solve a problem without an objective
will result in an error.</strong>
</p>
<p>The following objectives can be added to a conservation planning
<code><a href="#topic+problem">problem()</a></code>:
</p>

<dl>
<dt><code><a href="#topic+add_min_set_objective">add_min_set_objective()</a></code></dt><dd><p>Minimize the cost of the
solution whilst ensuring that all targets are met. This objective is
similar to that used in <em>Marxan</em>.</p>
</dd>
<dt><code><a href="#topic+add_max_cover_objective">add_max_cover_objective()</a></code></dt><dd><p>Represent at least one
instance of as many features as possible within a given budget.</p>
</dd>
<dt><code><a href="#topic+add_max_features_objective">add_max_features_objective()</a></code></dt><dd><p>Fulfill as many targets as
possible while ensuring that the cost of the solution does not exceed a
budget.</p>
</dd>
<dt><code><a href="#topic+add_min_shortfall_objective">add_min_shortfall_objective()</a></code></dt><dd><p>Minimize the overall
(weighted sum) shortfall for as many targets as possible while ensuring
that the cost of the solution does not exceed a budget.</p>
</dd>
<dt><code><a href="#topic+add_min_largest_shortfall_objective">add_min_largest_shortfall_objective()</a></code></dt><dd><p>Minimize the
largest (maximum) shortfall among all targets while ensuring that
the cost of the solution does not exceed a budget.</p>
</dd>
<dt><code><a href="#topic+add_max_phylo_div_objective">add_max_phylo_div_objective()</a></code></dt><dd><p>Maximize the phylogenetic
diversity of the features represented in the solution subject to a
budget.</p>
</dd>
<dt><code><a href="#topic+add_max_phylo_end_objective">add_max_phylo_end_objective()</a></code></dt><dd><p>Maximize the phylogenetic
endemism of the features represented in the solution subject to a
budget.</p>
</dd>
<dt><code><a href="#topic+add_max_utility_objective">add_max_utility_objective()</a></code></dt><dd><p>Secure as much of the
features as possible without exceeding a budget.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other overviews: 
<code><a href="#topic+constraints">constraints</a></code>,
<code><a href="#topic+decisions">decisions</a></code>,
<code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+penalties">penalties</a></code>,
<code><a href="#topic+portfolios">portfolios</a></code>,
<code><a href="#topic+solvers">solvers</a></code>,
<code><a href="#topic+summaries">summaries</a></code>,
<code><a href="#topic+targets">targets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()
sim_phylogeny &lt;- get_sim_phylogeny()

# create base problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

 # create problem with added minimum set objective
p1 &lt;- p %&gt;% add_min_set_objective()

# create problem with added maximum coverage objective
# note that this objective does not use targets
p2 &lt;- p %&gt;% add_max_cover_objective(500)

# create problem with added maximum feature representation objective
p3 &lt;- p %&gt;% add_max_features_objective(1900)

# create problem with added minimum shortfall objective
p4 &lt;- p %&gt;% add_min_shortfall_objective(1900)

# create problem with added minimum largest shortfall objective
p5 &lt;- p %&gt;% add_min_largest_shortfall_objective(1900)

# create problem with added maximum phylogenetic diversity objective
p6 &lt;- p %&gt;% add_max_phylo_div_objective(1900, sim_phylogeny)

# create problem with added maximum phylogenetic diversity objective
p7 &lt;- p %&gt;% add_max_phylo_end_objective(1900, sim_phylogeny)

# create problem with added maximum utility objective
# note that this objective does not use targets
p8 &lt;- p %&gt;% add_max_utility_objective(1900)

# solve problems
s &lt;- c(
  solve(p1), solve(p2), solve(p3), solve(p4), solve(p5), solve(p6),
  solve(p7), solve(p8)
)
names(s) &lt;- c(
  "min set", "max coverage", "max features", "min shortfall",
  "min largest shortfall", "max phylogenetic diversity",
  "max phylogenetic endemism", "max utility"
)
# plot solutions
plot(s, axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='optimization_problem'>Optimization problem</h2><span id='topic+optimization_problem'></span>

<h3>Description</h3>

<p>Create a new optimization problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimization_problem(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimization_problem_+3A_x">x</code></td>
<td>
<p>A <code>NULL</code> or <code>list</code> object. See Details for more information.
Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument to <code>x</code> can be a <code>NULL</code> or a <code>list</code>. If <code>x</code> is a <code>NULL</code>,
then an empty optimization problem is created. Alternately, if a <code>x</code> is
a <code>list</code> then a fully formulated optimization problem is created.
Specifically, the <code>list</code> should contain the following elements.
</p>

<dl>
<dt>modelsense</dt><dd><p><code>character</code> model sense.</p>
</dd>
<dt>number_of_features</dt><dd><p><code>integer</code> number of features in problem.</p>
</dd>
<dt>number_of_planning_units</dt><dd><p><code>integer</code> number of planning units.</p>
</dd>
<dt>A_i</dt><dd><p><code>integer</code> row indices for problem matrix.</p>
</dd>
<dt>A_j</dt><dd><p><code>integer</code> column indices for problem matrix.</p>
</dd>
<dt>A_x</dt><dd><p><code>numeric</code> values for problem matrix.</p>
</dd>
<dt>obj</dt><dd><p><code>numeric</code> objective function values.</p>
</dd>
<dt>lb</dt><dd><p><code>numeric</code> lower bound for decision values.</p>
</dd>
<dt>ub</dt><dd><p><code>numeric</code> upper bound for decision values.</p>
</dd>
<dt>rhs</dt><dd><p><code>numeric</code> right-hand side values.</p>
</dd>
<dt>sense</dt><dd><p><code>numeric</code> constraint senses.</p>
</dd>
<dt>vtype</dt><dd><p><code>character</code> variable types. These are used to specify
that the decision variables are binary (<code>"B"</code>) or continuous
(<code>"C"</code>).</p>
</dd>
<dt>row_ids</dt><dd><p><code>character</code> identifiers for the rows in the problem
matrix.</p>
</dd>
<dt>col_ids</dt><dd><p><code>character</code> identifiers for the columns in the problem
matrix.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An <a href="#topic+OptimizationProblem-class">OptimizationProblem</a> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+OptimizationProblem-methods">OptimizationProblem-methods</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create new empty object
x1 &lt;- optimization_problem()

# print new empty object
print(x1)

# create list with optimization problem
l &lt;- list(
  modelsense = "min",
  number_of_features = 2,
  number_of_planning_units = 3,
  number_of_zones = 1,
  A_i = c(0L, 1L, 0L, 1L, 0L, 1L),
  A_j = c(0L, 0L, 1L, 1L, 2L, 2L),
  A_x = c(2, 10, 1, 10, 1, 10),
  obj = c(1, 2, 2),
  lb = c(0, 1, 0),
  ub = c(0, 1, 1),
  rhs = c(2, 10),
  compressed_formulation = TRUE,
  sense = c("&gt;=", "&gt;="),
  vtype = c("B", "B", "B"),
  row_ids = c("spp_target", "spp_target"),
  col_ids = c("pu", "pu", "pu")
)

# create fully formulated object based on lists
x2 &lt;- optimization_problem(l)

# print fully formulated object
print(x2)
</code></pre>

<hr>
<h2 id='OptimizationProblem-class'>Optimization problem class</h2><span id='topic+OptimizationProblem-class'></span><span id='topic+OptimizationProblem'></span>

<h3>Description</h3>

<p>This class is used to represent an optimization problem.
It stores the information needed to generate a solution using
an exact algorithm solver.
Most users should use <code><a href="#topic+compile">compile()</a></code> to generate new optimization problem
objects, and the functions distributed with the package to interact
with them (e.g., <code><a href="base.html#topic+list">base::as.list()</a></code>).
<strong>Only experts should use the fields and methods for this class directly.</strong>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ptr</code></dt><dd><p>A <code>Rcpp::Xptr</code> external pointer.
Create a new optimization problem object.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizationProblem-new"><code>OptimizationProblem$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-print"><code>OptimizationProblem$print()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-show"><code>OptimizationProblem$show()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-ncol"><code>OptimizationProblem$ncol()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-nrow"><code>OptimizationProblem$nrow()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-ncell"><code>OptimizationProblem$ncell()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-modelsense"><code>OptimizationProblem$modelsense()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-vtype"><code>OptimizationProblem$vtype()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-obj"><code>OptimizationProblem$obj()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-A"><code>OptimizationProblem$A()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-rhs"><code>OptimizationProblem$rhs()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-sense"><code>OptimizationProblem$sense()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-lb"><code>OptimizationProblem$lb()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-ub"><code>OptimizationProblem$ub()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-number_of_features"><code>OptimizationProblem$number_of_features()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-number_of_planning_units"><code>OptimizationProblem$number_of_planning_units()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-number_of_zones"><code>OptimizationProblem$number_of_zones()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-col_ids"><code>OptimizationProblem$col_ids()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-row_ids"><code>OptimizationProblem$row_ids()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-compressed_formulation"><code>OptimizationProblem$compressed_formulation()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-shuffle_columns"><code>OptimizationProblem$shuffle_columns()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-copy"><code>OptimizationProblem$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizationProblem-clone"><code>OptimizationProblem$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-OptimizationProblem-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$new(ptr)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ptr</code></dt><dd><p><code>Rcpp::Xptr</code> external pointer.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>OptimizationProblem</code> object.
</p>


<hr>
<a id="method-OptimizationProblem-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print concise information about the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$print()</pre></div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-OptimizationProblem-show"></a>



<h4>Method <code>show()</code></h4>

<p>Print concise information about the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$show()</pre></div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-OptimizationProblem-ncol"></a>



<h4>Method <code>ncol()</code></h4>

<p>Obtain the number of columns in the problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$ncol()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> value.
</p>


<hr>
<a id="method-OptimizationProblem-nrow"></a>



<h4>Method <code>nrow()</code></h4>

<p>Obtain the number of rows in the problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$nrow()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> value.
</p>


<hr>
<a id="method-OptimizationProblem-ncell"></a>



<h4>Method <code>ncell()</code></h4>

<p>Obtain the number of cells in the problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$ncell()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> value.
</p>


<hr>
<a id="method-OptimizationProblem-modelsense"></a>



<h4>Method <code>modelsense()</code></h4>

<p>Obtain the model sense.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$modelsense()</pre></div>



<h5>Returns</h5>

<p>A <code>character</code> value.
</p>


<hr>
<a id="method-OptimizationProblem-vtype"></a>



<h4>Method <code>vtype()</code></h4>

<p>Obtain the decision variable types.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$vtype()</pre></div>



<h5>Returns</h5>

<p>A <code>character</code> vector.
</p>


<hr>
<a id="method-OptimizationProblem-obj"></a>



<h4>Method <code>obj()</code></h4>

<p>Obtain the objective function.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$obj()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> vector.
</p>


<hr>
<a id="method-OptimizationProblem-A"></a>



<h4>Method <code>A()</code></h4>

<p>Obtain the constraint matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$A()</pre></div>



<h5>Returns</h5>

<p>A <code><a href="Matrix.html#topic+sparseMatrix">Matrix::sparseMatrix()</a></code> object.
</p>


<hr>
<a id="method-OptimizationProblem-rhs"></a>



<h4>Method <code>rhs()</code></h4>

<p>Obtain the right-hand-side constraint values.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$rhs()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> vector.
</p>


<hr>
<a id="method-OptimizationProblem-sense"></a>



<h4>Method <code>sense()</code></h4>

<p>Obtain the constraint senses.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$sense()</pre></div>



<h5>Returns</h5>

<p>A <code>character</code> vector.
</p>


<hr>
<a id="method-OptimizationProblem-lb"></a>



<h4>Method <code>lb()</code></h4>

<p>Obtain the lower bounds for the decision variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$lb()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> vector.
</p>


<hr>
<a id="method-OptimizationProblem-ub"></a>



<h4>Method <code>ub()</code></h4>

<p>Obtain the upper bounds for the decision variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$ub()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> vector.
</p>


<hr>
<a id="method-OptimizationProblem-number_of_features"></a>



<h4>Method <code>number_of_features()</code></h4>

<p>Obtain the number of features.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$number_of_features()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> value.
</p>


<hr>
<a id="method-OptimizationProblem-number_of_planning_units"></a>



<h4>Method <code>number_of_planning_units()</code></h4>

<p>Obtain the number of planning units.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$number_of_planning_units()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> value.
</p>


<hr>
<a id="method-OptimizationProblem-number_of_zones"></a>



<h4>Method <code>number_of_zones()</code></h4>

<p>Obtain the number of zones.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$number_of_zones()</pre></div>



<h5>Returns</h5>

<p>A <code>numeric</code> value.
</p>


<hr>
<a id="method-OptimizationProblem-col_ids"></a>



<h4>Method <code>col_ids()</code></h4>

<p>Obtain the identifiers for the columns.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$col_ids()</pre></div>



<h5>Returns</h5>

<p>A <code>character</code> value.
</p>


<hr>
<a id="method-OptimizationProblem-row_ids"></a>



<h4>Method <code>row_ids()</code></h4>

<p>Obtain the identifiers for the rows.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$row_ids()</pre></div>



<h5>Returns</h5>

<p>A <code>character</code> value.
</p>


<hr>
<a id="method-OptimizationProblem-compressed_formulation"></a>



<h4>Method <code>compressed_formulation()</code></h4>

<p>Is the problem formulation compressed?
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$compressed_formulation()</pre></div>



<h5>Returns</h5>

<p>A <code>logical</code> value.
</p>


<hr>
<a id="method-OptimizationProblem-shuffle_columns"></a>



<h4>Method <code>shuffle_columns()</code></h4>

<p>Shuffle the order of the columns in the optimization problem.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$shuffle_columns(order)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>order</code></dt><dd><p><code>integer</code> vector with new order.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>integer</code> vector with indices to un-shuffle the problem.
</p>


<hr>
<a id="method-OptimizationProblem-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>Create a copy of the optimization problem.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$copy()</pre></div>



<h5>Returns</h5>

<p>A new <code>OptimizationProblem</code> object .
</p>


<hr>
<a id="method-OptimizationProblem-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizationProblem$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+ConservationModifier-class">ConservationModifier-class</a></code>,
<code><a href="#topic+ConservationProblem-class">ConservationProblem-class</a></code>,
<code><a href="#topic+Constraint-class">Constraint-class</a></code>,
<code><a href="#topic+Decision-class">Decision-class</a></code>,
<code><a href="#topic+Objective-class">Objective-class</a></code>,
<code><a href="#topic+Penalty-class">Penalty-class</a></code>,
<code><a href="#topic+Portfolio-class">Portfolio-class</a></code>,
<code><a href="#topic+Solver-class">Solver-class</a></code>,
<code><a href="#topic+Target-class">Target-class</a></code>
</p>

<hr>
<h2 id='OptimizationProblem-methods'>Optimization problem methods</h2><span id='topic+OptimizationProblem-methods'></span><span id='topic+modelsense'></span><span id='topic+vtype'></span><span id='topic+obj'></span><span id='topic+A'></span><span id='topic+rhs'></span><span id='topic+sense'></span><span id='topic+lb'></span><span id='topic+ub'></span><span id='topic+col_ids'></span><span id='topic+row_ids'></span><span id='topic+compressed_formulation'></span><span id='topic+ncell+2COptimizationProblem-method'></span><span id='topic+A+2COptimizationProblem-method'></span><span id='topic+col_ids+2COptimizationProblem-method'></span><span id='topic+lb+2COptimizationProblem-method'></span><span id='topic+modelsense+2COptimizationProblem-method'></span><span id='topic+ncol+2COptimizationProblem-method'></span><span id='topic+nrow+2COptimizationProblem-method'></span><span id='topic+obj+2COptimizationProblem-method'></span><span id='topic+rhs+2COptimizationProblem-method'></span><span id='topic+row_ids+2COptimizationProblem-method'></span><span id='topic+sense+2COptimizationProblem-method'></span><span id='topic+ub+2COptimizationProblem-method'></span><span id='topic+vtype+2COptimizationProblem-method'></span><span id='topic+compressed_formulation+2COptimizationProblem-method'></span>

<h3>Description</h3>

<p>These functions are used to access data from a <code><a href="#topic+optimization_problem">optimization_problem()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OptimizationProblem'
nrow(x)

## S4 method for signature 'OptimizationProblem'
ncol(x)

## S4 method for signature 'OptimizationProblem'
ncell(x)

modelsense(x)

## S4 method for signature 'OptimizationProblem'
modelsense(x)

vtype(x)

## S4 method for signature 'OptimizationProblem'
vtype(x)

obj(x)

## S4 method for signature 'OptimizationProblem'
obj(x)

A(x)

## S4 method for signature 'OptimizationProblem'
A(x)

rhs(x)

## S4 method for signature 'OptimizationProblem'
rhs(x)

sense(x)

## S4 method for signature 'OptimizationProblem'
sense(x)

lb(x)

## S4 method for signature 'OptimizationProblem'
lb(x)

ub(x)

## S4 method for signature 'OptimizationProblem'
ub(x)

col_ids(x)

## S4 method for signature 'OptimizationProblem'
col_ids(x)

row_ids(x)

## S4 method for signature 'OptimizationProblem'
row_ids(x)

compressed_formulation(x)

## S4 method for signature 'OptimizationProblem'
compressed_formulation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OptimizationProblem-methods_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+optimization_problem">optimization_problem()</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions return the following data:
</p>

<dl>
<dt>nrow</dt><dd><p><code>integer</code> number of rows (constraints).</p>
</dd>
<dt>ncol</dt><dd><p><code>integer</code> number of columns (decision variables).</p>
</dd>
<dt>ncell</dt><dd><p><code>integer</code> number of cells.</p>
</dd>
<dt>modelsense</dt><dd><p><code>character</code> describing if the problem is to be
maximized (<code>"max"</code>) or minimized (<code>"min"</code>).</p>
</dd>
<dt>vtype</dt><dd><p><code>character</code> describing the type of each decision variable:
binary (<code>"B"</code>), semi-continuous (<code>"S"</code>), or continuous
(<code>"C"</code>)</p>
</dd>
<dt>obj</dt><dd><p><code>numeric</code> vector specifying the objective function.</p>
</dd>
<dt>A</dt><dd><p><code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> matrix object defining the
problem matrix.</p>
</dd>
<dt>rhs</dt><dd><p><code>numeric</code> vector with right-hand-side linear constraints</p>
</dd>
<dt>sense</dt><dd><p><code>character</code> vector with the senses of the linear
constraints (<code>"&lt;="</code>, <code>"&gt;="</code>, <code>"="</code>).</p>
</dd>
<dt>lb</dt><dd><p><code>numeric</code> lower bound for each decision variable. Missing data
values (<code>NA</code>) indicate no lower bound for a given variable.</p>
</dd>
<dt>ub</dt><dd><p><code>numeric</code> upper bounds for each decision variable. Missing
data values (<code>NA</code>) indicate no upper bound for a given variable.</p>
</dd>
<dt>number_of_planning_units</dt><dd><p><code>integer</code> number of planning units in
the problem.</p>
</dd>
<dt>number_of_features</dt><dd><p><code>integer</code> number of features
the problem.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>, <code>numeric</code> vector,
<code>numeric</code> vector, or scalar <code>integer</code> depending on the method
used.
</p>

<hr>
<h2 id='penalties'>Add a penalty</h2><span id='topic+penalties'></span>

<h3>Description</h3>

<p>A penalty can be applied to a conservation planning problem to
penalize solutions according to a specific metric. They
directly trade-off with the primary objective of a problem
(e.g., the primary objective when using <code><a href="#topic+add_min_set_objective">add_min_set_objective()</a></code> is
to minimize solution cost).
</p>


<h3>Details</h3>

<p>Both penalties and constraints can be used to modify a problem and
identify solutions that exhibit specific characteristics. Constraints work
by invalidating solutions that do not exhibit specific characteristics.
On the other hand, penalties work by specifying trade-offs against the
primary problem objective and are mediated by a penalty factor.
</p>
<p>The following penalties can be added to a conservation planning
<code><a href="#topic+problem">problem()</a></code>:
</p>

<dl>
<dt><code><a href="#topic+add_boundary_penalties">add_boundary_penalties()</a></code></dt><dd><p>Add penalties to a
conservation problem to favor solutions that have
planning units clumped together into contiguous areas.</p>
</dd>
<dt><code><a href="#topic+add_asym_connectivity_penalties">add_asym_connectivity_penalties()</a></code></dt><dd><p>Add penalties to a
conservation problem to account for asymmetric connectivity.</p>
</dd>
<dt><code><a href="#topic+add_connectivity_penalties">add_connectivity_penalties()</a></code></dt><dd><p>Add penalties to a
conservation problem to account for
symmetric connectivity.</p>
</dd>
<dt><code><a href="#topic+add_linear_penalties">add_linear_penalties()</a></code></dt><dd><p>Add penalties to a
conservation problem to favor solutions that avoid selecting
planning units based on a certain variable
(e.g., anthropogenic pressure).</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other overviews: 
<code><a href="#topic+constraints">constraints</a></code>,
<code><a href="#topic+decisions">decisions</a></code>,
<code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+objectives">objectives</a></code>,
<code><a href="#topic+portfolios">portfolios</a></code>,
<code><a href="#topic+solvers">solvers</a></code>,
<code><a href="#topic+summaries">summaries</a></code>,
<code><a href="#topic+targets">targets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create basic problem
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with boundary penalties
p2 &lt;- p1 %&gt;% add_boundary_penalties(5, 1)

# create connectivity matrix based on spatial proximity
 scm &lt;- terra::as.data.frame(sim_pu_raster, xy = TRUE, na.rm = FALSE)
 scm &lt;- 1 / (as.matrix(dist(as.matrix(scm))) + 1)

# remove weak and moderate connections between planning units to reduce
# run time
scm[scm &lt; 0.85] &lt;- 0

# create problem with connectivity penalties
p3 &lt;- p1 %&gt;% add_connectivity_penalties(25, data = scm)

# create asymmetric connectivity data by randomly simulating values
acm &lt;- matrix(runif(ncell(sim_pu_raster) ^ 2), ncol = ncell(sim_pu_raster))
acm[acm &lt; 0.85] &lt;- 0

# create problem with asymmetric connectivity penalties
p4 &lt;- p1 %&gt;% add_asym_connectivity_penalties(1, data = acm)

# create problem with linear penalties,
# here the penalties will be based on random numbers to keep it simple

# simulate penalty data
sim_penalty_raster &lt;- simulate_cost(sim_pu_raster)

# plot penalty data
plot(sim_penalty_raster, main = "penalty data", axes = FALSE)

# create problem with linear penalties, with a penalty scaling factor of 100
p5 &lt;- p1 %&gt;% add_linear_penalties(100, data = sim_penalty_raster)

# solve problems
s &lt;- c(solve(p1), solve(p2), solve(p3), solve(p4), solve(p5))
names(s) &lt;- c(
  "basic solution", "boundary penalties", "connectivity penalties",
  "asymmetric penalties", "linear penalties"
)

# plot solutions
plot(s, axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='Penalty-class'>Penalty class</h2><span id='topic+Penalty-class'></span><span id='topic+Penalty'></span>

<h3>Description</h3>

<p>This class is used to represent penalties used in optimization.
<strong>Only experts should use the fields and methods for this class directly.</strong>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ConservationModifier">prioritizr::ConservationModifier</a></code> -&gt; <code>Penalty</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Penalty-apply"><code>Penalty$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-Penalty-clone"><code>Penalty$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="calculate"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-calculate'><code>prioritizr::ConservationModifier$calculate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_data'><code>prioritizr::ConservationModifier$get_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_internal'><code>prioritizr::ConservationModifier$get_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="print"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-print'><code>prioritizr::ConservationModifier$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="repr"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-repr'><code>prioritizr::ConservationModifier$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_data'><code>prioritizr::ConservationModifier$set_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_internal'><code>prioritizr::ConservationModifier$set_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="show"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-show'><code>prioritizr::ConservationModifier$show()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Penalty-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Update an optimization problem formulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Penalty$apply(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code><a href="#topic+optimization_problem">optimization_problem()</a></code> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-Penalty-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Penalty$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+ConservationModifier-class">ConservationModifier-class</a></code>,
<code><a href="#topic+ConservationProblem-class">ConservationProblem-class</a></code>,
<code><a href="#topic+Constraint-class">Constraint-class</a></code>,
<code><a href="#topic+Decision-class">Decision-class</a></code>,
<code><a href="#topic+Objective-class">Objective-class</a></code>,
<code><a href="#topic+OptimizationProblem-class">OptimizationProblem-class</a></code>,
<code><a href="#topic+Portfolio-class">Portfolio-class</a></code>,
<code><a href="#topic+Solver-class">Solver-class</a></code>,
<code><a href="#topic+Target-class">Target-class</a></code>
</p>

<hr>
<h2 id='Portfolio-class'>Portfolio class</h2><span id='topic+Portfolio-class'></span><span id='topic+Portfolio'></span>

<h3>Description</h3>

<p>This class is used to represent portfolios used in optimization.
<strong>Only experts should use the fields and methods for this class directly.</strong>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ConservationModifier">prioritizr::ConservationModifier</a></code> -&gt; <code>Portfolio</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Portfolio-run"><code>Portfolio$run()</code></a>
</p>
</li>
<li> <p><a href="#method-Portfolio-clone"><code>Portfolio$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="calculate"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-calculate'><code>prioritizr::ConservationModifier$calculate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_data'><code>prioritizr::ConservationModifier$get_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_internal'><code>prioritizr::ConservationModifier$get_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="print"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-print'><code>prioritizr::ConservationModifier$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="repr"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-repr'><code>prioritizr::ConservationModifier$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_data'><code>prioritizr::ConservationModifier$set_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_internal'><code>prioritizr::ConservationModifier$set_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="show"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-show'><code>prioritizr::ConservationModifier$show()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Portfolio-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run the portfolio to generate solutions.
</p>


<h5>Usage</h5>

<div class="r"><pre>Portfolio$run(x, solver)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code><a href="#topic+optimization_problem">optimization_problem()</a></code> object.</p>
</dd>
<dt><code>solver</code></dt><dd><p><code><a href="#topic+Solver-class">Solver</a></code> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>list</code> of solutions.
</p>


<hr>
<a id="method-Portfolio-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Portfolio$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+ConservationModifier-class">ConservationModifier-class</a></code>,
<code><a href="#topic+ConservationProblem-class">ConservationProblem-class</a></code>,
<code><a href="#topic+Constraint-class">Constraint-class</a></code>,
<code><a href="#topic+Decision-class">Decision-class</a></code>,
<code><a href="#topic+Objective-class">Objective-class</a></code>,
<code><a href="#topic+OptimizationProblem-class">OptimizationProblem-class</a></code>,
<code><a href="#topic+Penalty-class">Penalty-class</a></code>,
<code><a href="#topic+Solver-class">Solver-class</a></code>,
<code><a href="#topic+Target-class">Target-class</a></code>
</p>

<hr>
<h2 id='portfolios'>Add portfolios</h2><span id='topic+portfolios'></span>

<h3>Description</h3>

<p>Conservation planning exercises rarely have access to all the
data needed to identify the <em>truly</em> perfect solution. This is because
available data may lack important details
(e.g., land acquisition costs may be unavailable), contain errors
(e.g., species presence/absence data may have false positives),
or key objectives may not be formally incorporated into the
prioritization process (e.g., future land use requirements).
As such, conservation planners can help decision makers by providing
them with a portfolio of solutions to inform their decision.
</p>


<h3>Details</h3>

<p>The following portfolios can be added to a conservation planning
<code><a href="#topic+problem">problem()</a></code>.
Note that all methods for generating portfolios return solutions that
are within the specified optimality gap.
</p>

<dl>
<dt><code><a href="#topic+add_default_portfolio">add_default_portfolio()</a></code></dt><dd><p>Generate a portfolio containing a single
solution. This portfolio method is added to <code><a href="#topic+problem">problem()</a></code> objects by
default.</p>
</dd>
<dt><code><a href="#topic+add_extra_portfolio">add_extra_portfolio()</a></code></dt><dd><p>Generate a portfolio of solutions
by storing feasible solutions found during the optimization
process. This method is useful for quickly obtaining multiple solutions,
but does not provide any guarantees on the number of solutions, or
the quality of solutions.
Note that it requires the <em>Gurobi</em> solver.</p>
</dd>
<dt><code><a href="#topic+add_top_portfolio">add_top_portfolio()</a></code></dt><dd><p>Generate a portfolio of
solutions by finding a pre-specified number of solutions that
are closest to optimality (i.e., the top solutions). This is useful
for examining differences among near-optimal solutions.
It can also be used to generate multiple solutions and, in turn,
to calculate selection frequencies for small problems.
Note that it requires the <em>Gurobi</em> solver.</p>
</dd>
<dt><code><a href="#topic+add_gap_portfolio">add_gap_portfolio()</a></code></dt><dd><p>Generate a portfolio of solutions
by finding a certain number of solutions that are all within a pre-
specified optimality gap. This method is useful for generating
multiple solutions that can be used to calculate selection frequencies
for moderate and large-sized problems (similar to <em>Marxan</em>).
Note that it requires the <em>Gurobi</em> solver.</p>
</dd>
<dt><code><a href="#topic+add_cuts_portfolio">add_cuts_portfolio()</a></code></dt><dd><p>Generate a portfolio of distinct
solutions within a pre-specified optimality gap using Bender's cuts.
This is recommended as a replacement for <code><a href="#topic+add_top_portfolio">add_top_portfolio()</a></code>
when the <em>Gurobi</em> software is not available.</p>
</dd>
<dt><code><a href="#topic+add_shuffle_portfolio">add_shuffle_portfolio()</a></code></dt><dd><p>Generate a portfolio of
solutions by randomly reordering the data prior to attempting to solve
the problem.
This is recommended as a replacement for <code><a href="#topic+add_gap_portfolio">add_gap_portfolio()</a></code>
when the <em>Gurobi</em> software is not available.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other overviews: 
<code><a href="#topic+constraints">constraints</a></code>,
<code><a href="#topic+decisions">decisions</a></code>,
<code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+objectives">objectives</a></code>,
<code><a href="#topic+penalties">penalties</a></code>,
<code><a href="#topic+solvers">solvers</a></code>,
<code><a href="#topic+summaries">summaries</a></code>,
<code><a href="#topic+targets">targets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(gap = 0.02, verbose = FALSE)

# create problem with default portfolio
p1 &lt;- p %&gt;% add_default_portfolio()

# create problem with cuts portfolio with 4 solutions
p2 &lt;- p %&gt;% add_cuts_portfolio(4)

# create problem with shuffle portfolio with 4 solutions
p3 &lt;- p %&gt;% add_shuffle_portfolio(4)

# create problem with extra portfolio
p4 &lt;- p %&gt;% add_extra_portfolio()

# create problem with top portfolio with 4 solutions
p5 &lt;- p %&gt;% add_top_portfolio(4)

# create problem with gap portfolio with 4 solutions within 50% of optimality
p6 &lt;- p %&gt;% add_gap_portfolio(4, 0.5)

# solve problems to obtain solution portfolios
s &lt;- list(solve(p1), solve(p2), solve(p3), solve(p4), solve(p5), solve(p6))

# plot solution from default portfolio
plot(terra::rast(s[[1]]), axes = FALSE)

# plot solutions from cuts portfolio
plot(terra::rast(s[[2]]), axes = FALSE)

# plot solutions from shuffle portfolio
plot(terra::rast(s[[3]]), axes = FALSE)

# plot solutions from extra portfolio
plot(terra::rast(s[[4]]), axes = FALSE)

# plot solutions from top portfolio
plot(terra::rast(s[[5]]), axes = FALSE)

# plot solutions from gap portfolio
plot(terra::rast(s[[6]]), axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='presolve_check'>Presolve check</h2><span id='topic+presolve_check'></span><span id='topic+presolve_check.ConservationProblem'></span><span id='topic+presolve_check.OptimizationProblem'></span>

<h3>Description</h3>

<p>Check a conservation planning problem for potential issues
before trying to solve it. Specifically, problems are checked for (i) values
that are likely to result in &quot;strange&quot; solutions and (ii) values that are
likely to cause numerical instability issues and lead to unreasonably long
run times when solving it. Although these checks are provided to help
diagnose potential issues, please be aware that some detected issues may be
false positives. Please note that these checks will not be able to
verify if a problem has a feasible solution or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>presolve_check(x, warn = TRUE)

## S3 method for class 'ConservationProblem'
presolve_check(x, warn = TRUE)

## S3 method for class 'OptimizationProblem'
presolve_check(x, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="presolve_check_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> or <code><a href="#topic+optimization_problem">optimization_problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="presolve_check_+3A_warn">warn</code></td>
<td>
<p><code>logical</code> should a warning be thrown if the presolve checks fail?
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks for issues that are likely to result in
&quot;strange&quot; solutions. Specifically, it checks if (i) all planning units are
locked in, (ii) all planning units are locked out, and (iii) all
planning units have negative cost values (after applying penalties if any
were specified). Although such conservation planning problems
are mathematically valid, they are generally the result of a coding mistake
when building the problem (e.g., using an absurdly high
penalty value or using the wrong dataset to lock in planning units).
Thus such issues, if they are indeed issues and not false positives, can
be fixed by carefully checking the code, data, and parameters used to build
the conservation planning problem.
</p>
<p>This function then checks for values that may lead to numerical instability
issues when solving the problem. Specifically, it checks if the range of
values in certain components of the optimization problem are over a
certain threshold (i.e., <code class="reqn">1 \times 10 ^9</code>) or if the values
themselves exceed a certain threshold
(i.e., <code class="reqn">1 \times 10^{10}</code>).
In most cases, such issues will simply cause an exact
algorithm solver to take a very long time to generate a solution. In rare
cases, such issues can cause incorrect calculations which can lead
to exact algorithm solvers returning infeasible solutions
(e.g., a solution to the minimum set problem where not all targets are met)
or solutions that exceed the specified optimality gap (e.g., a suboptimal
solution when a zero optimality gap is specified).
</p>
<p>What can you do if a conservation planning problem fails to pass these
checks? Well, this function will have thrown some warning messages
describing the source of these issues, so read them carefully. For
instance, a common issue is when a relatively large penalty value is
specified for boundary (<code><a href="#topic+add_boundary_penalties">add_boundary_penalties()</a></code>) or
connectivity penalties (<code><a href="#topic+add_connectivity_penalties">add_connectivity_penalties()</a></code>). This
can be fixed by trying a smaller penalty value. In such cases, the
original penalty value supplied was so high that the optimal solution
would just have selected every single planning unit in the solution&mdash;and
this may not be especially helpful anyway (see below for example). Another
common issue is that the
planning unit cost values are too large. For example, if you express the
costs of the planning units in terms of USD then you might have
some planning units that cost over one billion dollars in large-scale
planning exercises. This can be fixed by rescaling the values so that they
are smaller (e.g., multiplying the values by a number smaller than one, or
expressing them as a fraction of the maximum cost). Let's consider another
common issue, let's pretend that you used habitat suitability models to
predict the amount of suitable habitat
in each planning unit for each feature. If you calculated the amount of
suitable habitat in each planning unit in square meters then this
could lead to very large numbers. You could fix this by converting
the units from square meters to square kilometers or thousands of square
kilometers. Alternatively, you could calculate the percentage of each
planning unit that is occupied by suitable habitat, which will yield
values between zero and one hundred.
</p>
<p>But what can you do if you can't fix these issues by simply changing
the penalty values or rescaling data? You will need to apply some creative
thinking. Let's run through a couple of scenarios.
Let's pretend that you have a few planning units that
cost a billion times more than any other planning
unit so you can't fix this by rescaling the cost values. In this case, it's
extremely unlikely that these planning units will
be selected in the optimal solution so just set the costs to zero and lock
them out. If this procedure yields a problem with no feasible solution,
because one (or several) of the planning units that you manually locked out
contains critical habitat for a feature, then find out which planning
unit(s) is causing this infeasibility and set its cost to zero. After
solving the problem, you will need to manually recalculate the cost
of the solutions but at least now you can be confident that you have the
optimal solution. Now let's pretend that you are using the maximum features
objective (i.e., <code><a href="#topic+add_max_features_objective">add_max_features_objective()</a></code>) and assigned some
really high weights to the targets for some features to ensure that their
targets were met in the optimal solution. If you set the weights for
these features to one billion then you will probably run into numerical
instability issues. Instead, you can calculate minimum weight needed to
guarantee that these features will be represented in the optimal solution
and use this value instead of one billion. This minimum weight value
can be calculated as the sum of the weight values for the other features
and adding a small number to it (e.g., 1). Finally, if you're running out
of ideas for addressing numerical stability issues you have one remaining
option: you can use the <code>numeric_focus</code> argument in the
<code><a href="#topic+add_gurobi_solver">add_gurobi_solver()</a></code> function to tell the solver to pay extra
attention to numerical instability issues. This is not a free lunch,
however, because telling the solver to pay extra attention to numerical
issues can substantially increase run time. So, if you have problems that
are already taking an unreasonable time to solve, then this will not help
at all.
</p>


<h3>Value</h3>

<p>A <code>logical</code> value indicating if all checks passed successfully.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+problem">problem()</a></code>, <code><a href="#topic+solve">solve()</a></code>, <a href="http://www.gurobi.cn/download/GuNum.pdf">http://www.gurobi.cn/download/GuNum.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create minimal problem with no issues
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions()

# run presolve checks
# note that no warning is thrown which suggests that we should not
# encounter any numerical stability issues when trying to solve the problem
print(presolve_check(p1))

# create a minimal problem, containing cost values that are really
# high so that they could cause numerical instability issues when trying
# to solve it
sim_pu_raster2 &lt;- sim_pu_raster
sim_pu_raster2[1] &lt;- 1e+15
p2 &lt;-
  problem(sim_pu_raster2, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions()

# run presolve checks
# note that a warning is thrown which suggests that we might encounter
# some issues, such as long solve time or suboptimal solutions, when
# trying to solve the problem
print(presolve_check(p2))

# create a minimal problem with connectivity penalties values that have
# a really high penalty value that is likely to cause numerical instability
# issues when trying to solve the it
cm &lt;- adjacency_matrix(sim_pu_raster)
p3 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_connectivity_penalties(1e+15, data = cm) %&gt;%
  add_binary_decisions()

# run presolve checks
# note that a warning is thrown which suggests that we might encounter
# some numerical instability issues when trying to solve the problem
print(presolve_check(p3))

# let's forcibly solve the problem using Gurobi and tell it to
# be extra careful about numerical instability problems
s3 &lt;-
   p3 %&gt;%
   add_gurobi_solver(numeric_focus = TRUE) %&gt;%
   solve(force = TRUE)

# plot solution
# we can see that all planning units were selected because the connectivity
# penalty is so high that cost becomes irrelevant, so we should try using
# a much lower penalty value
plot(s3, main = "solution", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='prioritizr-deprecated'>Deprecation notice</h2><span id='topic+prioritizr-deprecated'></span><span id='topic+add_connected_constraints'></span><span id='topic+add_corridor_constraints'></span><span id='topic+set_number_of_threads'></span><span id='topic+get_number_of_threads'></span><span id='topic+is.parallel'></span><span id='topic+add_pool_portfolio'></span><span id='topic+connected_matrix'></span><span id='topic+feature_representation'></span><span id='topic+replacement_cost'></span><span id='topic+rarity_weighted_richness'></span><span id='topic+ferrier_score'></span><span id='topic+distribute_load'></span><span id='topic+new_optimization_problem'></span><span id='topic+predefined_optimization_problem'></span>

<h3>Description</h3>

<p>The functions listed here are deprecated.
This means that they once existed in earlier versions of the
of the <span class="pkg">prioritizr</span> package, but they have since been removed
entirely, replaced by other functions, or renamed as other functions
in newer versions.
To help make it easier to transition to new versions of the <span class="pkg">prioritizr</span>
package, we have listed alternatives for deprecated the functions
(where applicable).
If a function is described as being renamed, then this means
that only the name of the function has changed
(i.e., the inputs, outputs, and underlying code remain the same).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_connected_constraints(...)

add_corridor_constraints(...)

set_number_of_threads(...)

get_number_of_threads(...)

is.parallel(...)

add_pool_portfolio(...)

connected_matrix(...)

feature_representation(...)

replacement_cost(...)

rarity_weighted_richness(...)

ferrier_score(...)

distribute_load(...)

new_optimization_problem(...)

predefined_optimization_problem(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prioritizr-deprecated_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following functions have been deprecated:
</p>

<dl>
<dt><code>add_connected_constraints()</code></dt><dd><p>renamed
as the <code><a href="#topic+add_contiguity_constraints">add_contiguity_constraints()</a></code> function.</p>
</dd>
<dt><code>add_corridor_constraints()</code></dt><dd><p>replaced by the
<code><a href="#topic+add_feature_contiguity_constraints">add_feature_contiguity_constraints()</a></code> function.</p>
</dd>
<dt><code>set_number_of_threads()</code></dt><dd>
<p>no longer needed due to improved data extraction methods.</p>
</dd>
<dt><code>get_number_of_threads()</code></dt><dd>
<p>no longer needed due to improved data extraction methods.</p>
</dd>
<dt><code>is.parallel()</code></dt><dd>
<p>no longer needed due to improved data extraction methods.</p>
</dd>
<dt><code>add_pool_portfolio()</code></dt><dd><p>replaced by the
<code><a href="#topic+add_extra_portfolio">add_extra_portfolio()</a></code> and <code><a href="#topic+add_top_portfolio">add_top_portfolio()</a></code>.</p>
</dd>
<dt><code>connected_matrix()</code></dt><dd><p>renamed as
the <code><a href="#topic+adjacency_matrix">adjacency_matrix()</a></code> function.</p>
</dd>
<dt><code>feature_representation()</code></dt><dd><p>replaced by
the <code><a href="#topic+eval_feature_representation_summary">eval_feature_representation_summary()</a></code> function for consistency with
other functions.</p>
</dd>
<dt><code>replacement_cost()</code></dt><dd><p>renamed as
the <code><a href="#topic+eval_replacement_importance">eval_replacement_importance()</a></code> function for consistency with
other functions for evaluating solutions.</p>
</dd>
<dt><code>rarity_weighted_richness()</code></dt><dd><p>renamed as
the <code><a href="#topic+eval_rare_richness_importance">eval_rare_richness_importance()</a></code> function for consistency with
other functions for evaluating solutions.</p>
</dd>
<dt><code>ferrier_score()</code></dt><dd><p>renamed as
the <code><a href="#topic+eval_ferrier_importance">eval_ferrier_importance()</a></code> function for consistency with
other functions for evaluating solutions.</p>
</dd>
<dt><code>distribute_load()</code></dt><dd><p>has been removed because it is no longer used.
See <code>parallel::splitIndices()</code> for equivalent functionality.</p>
</dd>
<dt><code>new_optimization_problem()</code></dt><dd>
<p>replaced by <code><a href="#topic+optimization_problem">optimization_problem()</a></code>.</p>
</dd>
<dt><code>predefined_optimization_problem()</code></dt><dd>
<p>replaced by <code><a href="#topic+optimization_problem">optimization_problem()</a></code>.</p>
</dd>
</dl>


<hr>
<h2 id='problem'>Conservation planning problem</h2><span id='topic+problem'></span><span id='topic+problem+2CRaster+2CRaster-method'></span><span id='topic+problem+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+problem+2CSpatial+2CRaster-method'></span><span id='topic+problem+2Cdata.frame+2Cdata.frame-method'></span><span id='topic+problem+2Cnumeric+2Cdata.frame-method'></span><span id='topic+problem+2Cdata.frame+2Ccharacter-method'></span><span id='topic+problem+2CSpatial+2Ccharacter-method'></span><span id='topic+problem+2CRaster+2CZonesRaster-method'></span><span id='topic+problem+2CSpatRaster+2CZonesRaster-method'></span><span id='topic+problem+2CSpatial+2CZonesRaster-method'></span><span id='topic+problem+2CSpatial+2CZonesCharacter-method'></span><span id='topic+problem+2Cdata.frame+2CZonesCharacter-method'></span><span id='topic+problem+2Cmatrix+2Cdata.frame-method'></span><span id='topic+problem+2Csf+2CRaster-method'></span><span id='topic+problem+2Csf+2CSpatRaster-method'></span><span id='topic+problem+2CSpatRaster+2CZonesSpatRaster-method'></span><span id='topic+problem+2Csf+2CZonesCharacter-method'></span><span id='topic+problem+2Csf+2Ccharacter-method'></span><span id='topic+problem+2Csf+2CZonesRaster-method'></span><span id='topic+problem+2Csf+2CZonesSpatRaster-method'></span>

<h3>Description</h3>

<p>Create a systematic conservation planning problem. This function is used to
specify the basic data used in a spatial prioritization problem: the
spatial distribution of the planning units and their costs, as well as
the features (e.g., species, ecosystems) that need to be conserved. After
constructing this object, it can be
customized to meet specific goals using <a href="#topic+objectives">objectives</a>,
<a href="#topic+targets">targets</a>, <a href="#topic+constraints">constraints</a>, and
<a href="#topic+penalties">penalties</a>. After building the problem, the
<code><a href="#topic+solve">solve()</a></code> function can be used to identify solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>problem(x, features, ...)

## S4 method for signature 'SpatRaster,SpatRaster'
problem(x, features, run_checks, ...)

## S4 method for signature 'SpatRaster,ZonesSpatRaster'
problem(x, features, run_checks, ...)

## S4 method for signature 'data.frame,character'
problem(x, features, cost_column, ...)

## S4 method for signature 'data.frame,ZonesCharacter'
problem(x, features, cost_column, ...)

## S4 method for signature 'data.frame,data.frame'
problem(x, features, rij, cost_column, zones, ...)

## S4 method for signature 'numeric,data.frame'
problem(x, features, rij_matrix, ...)

## S4 method for signature 'matrix,data.frame'
problem(x, features, rij_matrix, ...)

## S4 method for signature 'sf,SpatRaster'
problem(x, features, cost_column, run_checks, ...)

## S4 method for signature 'sf,ZonesSpatRaster'
problem(x, features, cost_column, run_checks, ...)

## S4 method for signature 'sf,character'
problem(x, features, cost_column, ...)

## S4 method for signature 'sf,ZonesCharacter'
problem(x, features, cost_column, ...)

## S4 method for signature 'Raster,Raster'
problem(x, features, run_checks, ...)

## S4 method for signature 'Raster,ZonesRaster'
problem(x, features, run_checks, ...)

## S4 method for signature 'Spatial,Raster'
problem(x, features, cost_column, run_checks, ...)

## S4 method for signature 'Spatial,ZonesRaster'
problem(x, features, cost_column, run_checks, ...)

## S4 method for signature 'Spatial,character'
problem(x, features, cost_column, ...)

## S4 method for signature 'Spatial,ZonesCharacter'
problem(x, features, cost_column, ...)

## S4 method for signature 'sf,Raster'
problem(x, features, cost_column, run_checks, ...)

## S4 method for signature 'sf,ZonesRaster'
problem(x, features, cost_column, run_checks, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="problem_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code>, <code><a href="sf.html#topic+sf">sf::st_sf()</a></code>, <code>data.frame</code>, <code>matrix</code>, or
<code>numeric</code> vector specifying the planning units to use in the reserve
design exercise and their corresponding cost. It may be desirable to
exclude some planning units from the analysis, for example those outside
the study area. To exclude planning units, set the cost for those raster
cells to <code>NA</code>, or use the <code><a href="#topic+add_locked_out_constraints">add_locked_out_constraints()</a></code> function.</p>
</td></tr>
<tr><td><code id="problem_+3A_features">features</code></td>
<td>
<p>The feature data can be specified in a variety of ways.
The specific formats that can be used depend on the cost data format (i.e.,
argument to <code>x</code>) and whether the problem should have a single zone or
multiple zones. If the problem should have a single zone, then the feature
data can be specified following:
</p>

<dl>
<dt><strong><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> or <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> planning units</strong></dt><dd>
<p>The argument to <code>features</code> can be a <code><a href="terra.html#topic+rast">terra::rast()</a></code>
object showing the distribution of conservation features. Missing
values (i.e., <code>NA</code> values) can be used to indicate the absence of
a feature in a particular cell instead of explicitly setting these
cells to zero. Note that this argument type for <code>features</code> can
only be used to specify data for problems involving a single zone.</p>
</dd>
<dt><strong><code>x</code> has <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> or <code>data.frame</code> planning units</strong></dt><dd>
<p>The argument to <code>features</code> can be a <code>character</code> vector
with column names (from <code>x</code>) that correspond to the abundance or
occurrence of different features in each planning unit. Note that
this argument type can only be used to create problems involving a
single zone.</p>
</dd>
<dt><strong><code>x</code> has <code>data.frame</code>, <code>matrix</code>, or <code>numeric</code> vector planning
units</strong></dt><dd>
<p>The argument to <code>features</code> can be a <code>data.frame</code> object
containing the names of the features. Note that if this
type of argument is supplied to <code>features</code> then the argument
<code>rij</code> or <code>rij_matrix</code> must also be supplied. This type of
argument should follow the conventions used by <em>Marxan</em>, wherein
each row corresponds to a different feature. It must also contain the
following columns:
</p>

<dl>
<dt>id</dt><dd><p><code>integer</code> unique identifier for each feature
These identifiers are used in the argument to <code>rij</code>.</p>
</dd>
<dt>name</dt><dd><p><code>character</code> name for each feature.</p>
</dd>
<dt>prop</dt><dd><p><code>numeric</code> relative target for each feature
(optional).</p>
</dd>
<dt>amount</dt><dd><p><code>numeric</code> absolute target for each
feature (optional).</p>
</dd>
</dl>

</dd>
</dl>

<p>If the problem should have multiple zones, then the feature
data can be specified following:
</p>

<dl>
<dt><strong><code>x</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> or <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> planning units</strong></dt><dd>
<p>The argument to <code>features</code> can be a <code><a href="#topic+zones">ZonesRaster</a></code>
object showing the distribution of conservation features in multiple
zones. As above, missing values (i.e., <code>NA</code> values) can be used to
indicate the absence of a feature in a particular cell instead of
explicitly setting these cells to zero.</p>
</dd>
<dt><strong><code>x</code> has <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> or <code>data.frame</code> planning units</strong></dt><dd>
<p>The argument to <code>features</code> can be a <code><a href="#topic+zones">ZonesCharacter</a></code>
object with column names (from <code>x</code>) that correspond to the abundance or
occurrence of different features in each planning unit in different
zones.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="problem_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="problem_+3A_run_checks">run_checks</code></td>
<td>
<p><code>logical</code> flag indicating whether checks should be
run to ensure the integrity of the input data. These checks are run by
default; however, for large datasets they may increase run time. If it is
taking a prohibitively long time to create the prioritization problem,
try setting <code>run_checks</code> to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="problem_+3A_cost_column">cost_column</code></td>
<td>
<p><code>character</code> name or <code>integer</code> indicating the
column(s) with the cost data. This argument must be supplied when the
argument to <code>x</code> is a <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> or
<code>data.frame</code> object. This argument should contain the name of each
column containing cost data for each management zone when creating
problems with multiple zones. To create a problem with a single zone, then
set the argument to <code>cost_column</code> as a single column name.</p>
</td></tr>
<tr><td><code id="problem_+3A_rij">rij</code></td>
<td>
<p><code>data.frame</code> containing information on the amount of
each feature in each planning unit assuming each management zone. Similar
to <code>data.frame</code> arguments for <code>features</code>, the <code>data.frame</code>
objects must follow the conventions used by <em>Marxan</em>. Note that the
<code>"zone"</code> column is not needed for problems involving a single
management zone. Specifically, the argument should contain the following
columns:
</p>

<dl>
<dt>pu</dt><dd><p><code>integer</code> planning unit identifier.</p>
</dd>
<dt>species</dt><dd><p><code>integer</code> feature identifier.</p>
</dd>
<dt>zone</dt><dd><p><code>integer</code> zone identifier (optional for
problems involving a single zone).</p>
</dd>
<dt>amount</dt><dd><p><code>numeric</code> amount of the feature in the
planning unit.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="problem_+3A_zones">zones</code></td>
<td>
<p><code>data.frame</code> containing information on the zones. This
argument is only used when argument to <code>x</code> and <code>features</code> are
both <code>data.frame</code> objects and the problem being built contains
multiple zones. Following conventions used in <code>MarZone</code>, this
argument should contain the following columns:
columns:
</p>

<dl>
<dt>id</dt><dd><p><code>integer</code> zone identifier.</p>
</dd>
<dt>name</dt><dd><p><code>character</code> zone name.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="problem_+3A_rij_matrix">rij_matrix</code></td>
<td>
<p><code>list</code> of <code>matrix</code> or <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>
objects specifying the amount of each feature (rows) within each planning
unit (columns) for each zone. The <code>list</code> elements denote
different zones, matrix rows denote features, and matrix columns denote
planning units. For convenience, the argument to
<code>rij_matrix</code> can be a single <code>matrix</code> or
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> when specifying a problem with a
single management zone. This argument is only used when the argument
to <code>x</code> is a <code>numeric</code> or <code>matrix</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A systematic conservation planning exercise leverages data to help inform
conservation decision making. To help ensure that the
data &ndash; and resulting prioritizations &ndash; are relevant to the over-arching
goals of the exercise, you should decide on the management action
(or set of actions) that need be considered in the exercise.
For example, these actions could include establishing protected areas,
selecting land for conservation easements, restoring habitat,
planting trees for carbon sequestration, eradicating invasive
species, or some combination of the previous actions.
If the exercise involves multiple different actions, they can
be incorporated by using multiple zones
(see the Management Zones vignette for details). After deciding
on the management action(s), you can compile the following data.
</p>
<p>First, you will need to create a set of planning units
(i.e., discrete spatial areas) to inform decision making.
Planning units are often created by subdividing a study region
into a set of square or hexagonal cells. They can also be created using
administrative boundaries (e.g., provinces), land management boundaries
(e.g., property boundaries derived from cadastral data), or
ecological boundaries (e.g., based on ecosystem classification data).
The size (i.e., spatial grain) of the planning units is often determined
based on a compromise between the scale needed to inform decision making, the
spatial accuracy (resolution) of available datasets, and
the computational resources available for generating prioritizations
(e.g., RAM and number of CPU cores on your computer).
</p>
<p>Second, you will need data to quantify the cost of implementing
each management action within each planning unit.
Critically, the cost data should reflect the management action(s)
considered in the exercise.
For example, costs are often specified using data that reflect economic
expenditure (e.g., land acquisition cost),
socioeconomic conditions (e.g., human population density),
opportunity costs of foregone commercial activities
(e.g., logging or agriculture), or
opportunity costs of foregone recreational activities
(e.g., recreational fishing).
In some cases &ndash; depending on the management action(s) considered &ndash;
it can make sense to use a constant cost value
(e.g., all planning units are assigned a cost value equal to one)
or use a cost value based on spatial extent
(e.g., each planning unit is assigned a cost value based on its total area).
Also, in most cases, you want to avoid negative cost values.
This is because a negative value means that a place is <em>desirable</em>
for implementing a management action, and such places will almost
always be selected for prioritization even if they provide no benefit.
</p>
<p>Third, you will need data to quantify the benefits of implementing
management actions within planning units.
To achieve this, you will need to select a set of conservation features
that relate to the over-arching goals of the exercise.
For example, conservation features often include
species (e.g., Clouded Leopard), habitats (e.g., mangroves or
cloud forest), or ecosystems.
The benefit that each feature derives from a planning unit
can take a variety of forms, but is typically occupancy (i.e.,
presence or absence), area of occurrence within each planning unit
(e.g., based on species' geographic range data), or
a measure of habitat suitability (e.g., estimated using a statistical model).
After compiling these data, you have the minimal data needed to generate
a prioritization.
</p>
<p>A systematic conservation planning exercise involves prioritizing a set of
management actions to be implemented within certain planning units.
Critically, this prioritization should ideally optimize the trade-off
between benefits and costs.
To accomplish this, the <span class="pkg">prioritizr</span> package uses input data
to formulate optimization problems (see Optimization section for details).
Broadly speaking, the goal of an optimization problem is to minimize
(or maximize) an objective function over a set of
decision variables, subject to a series of constraints.
Here, an objective function specifies the metric for evaluating
conservation plans. The decision variables are what we control, and usually
there is one binary variable for each planning unit to specify whether that
unit is selected or not (but other approaches are available, see
<a href="#topic+decisions">decisions</a>). The constraints can be thought of as rules that must be
followed. For example, constraints can be used to ensure a prioritization
must stay within a certain budget. These constraints can also leverage
additional data to help ensure that prioritizations meet the over-arching
goals of the exercise. For example, to account for existing conservation
efforts, you could obtain data delineating the extent of existing protected
areas and use constraints to lock in planning units that are covered by them
(see <a href="#topic+add_locked_in_constraints">add_locked_in_constraints</a>).
</p>


<h3>Value</h3>

<p>A new <code>problem()</code> (<code><a href="#topic+ConservationProblem-class">ConservationProblem</a></code>) object.
</p>


<h3>Optimization</h3>

<p>The <span class="pkg">prioritizr</span> package uses exact algorithms to solve reserve design
problems (see <a href="#topic+solvers">solvers</a> for details).
To achieve this, it internally formulates mathematical optimization problems
using mixed integer linear programming (MILP). The general form of
such problems can be expressed in matrix notation using
the following equation.
</p>
<p style="text-align: center;"><code class="reqn">\mathit{Minimize} \space \mathbf{c}^{\mathbf{T}}\mathbf{x} \space
\mathit{subject \space to} \space
\mathbf{Ax}\geq= or\leq \mathbf{b}</code>
</p>

<p>Here, <code class="reqn">x</code> is a vector of decision variables, <code class="reqn">c</code> and <code class="reqn">b</code> are
vectors of known coefficients, and <code class="reqn">A</code> is the constraint
matrix. The final term specifies a series of structural
constraints where relational operators for the constraint can be either
<code class="reqn">\ge</code>, <code class="reqn">=</code>, or <code class="reqn">\le</code> the coefficients. For example, in the
minimum set cover problem, <code class="reqn">c</code> would be a vector of costs for each
planning unit, <code class="reqn">b</code> a vector of targets for each conservation feature,
the relational operator would be <code class="reqn">\ge</code> for all features, and <code class="reqn">A</code>
would be the representation matrix with <code class="reqn">A_{ij}=r_{ij}</code>, the
representation level of feature <code class="reqn">i</code> in planning unit <code class="reqn">j</code>.
If you wish to see exactly how a conservation planning problem is
formulated as mixed integer linear programming problem, you can use
the <code><a href="#topic+write_problem">write_problem()</a></code> function to save the optimization problem
to a plain-text file on your computer and then view it using a standard
text editor (e.g., Notepad).
</p>
<p>Please note that this function internally computes the amount of each
feature in each planning unit when this data is not supplied (using the
<code><a href="#topic+rij_matrix">rij_matrix()</a></code> function). As a consequence, it can take a while to
initialize large-scale conservation planning problems that involve
millions of planning units.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+solve">solve()</a></code> for details on solving a problem to generate solutions.
Also, see <a href="#topic+objectives">objectives</a>, <a href="#topic+penalties">penalties</a>, <a href="#topic+targets">targets</a>, <a href="#topic+constraints">constraints</a>,
<a href="#topic+decisions">decisions</a>, <a href="#topic+portfolios">portfolios</a>, <a href="#topic+solvers">solvers</a> for information on customizing problems.
Additionally, see <a href="#topic+summaries">summaries</a> and <a href="#topic+importance">importance</a> for information on
evaluating solutions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_pu_points &lt;- get_sim_pu_points()
sim_pu_lines &lt;- get_sim_pu_lines()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# create problem using raster planning unit data
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem using polygon planning unit data
p2 &lt;-
  problem(sim_pu_polygons, sim_features, "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem using line planning unit data
p3 &lt;-
  problem(sim_pu_lines, sim_features, "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem using point planning unit data
p4 &lt;-
  problem(sim_pu_points, sim_features, "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# since geo-processing can be slow for large spatial vector datasets
# (e.g., polygons, lines, points), it can be worthwhile to pre-process the
# planning unit data so that it contains columns indicating the amount of
# each feature inside each planning unit
# (i.e., each column corresponds to a different feature)

# calculate the amount of each species within each planning unit
pre_proc_data &lt;- rij_matrix(sim_pu_polygons, sim_features)

# add extra columns to the polygon planning unit data
# to indicate the amount of each species within each planning unit
pre_proc_data &lt;- as.data.frame(t(as.matrix(pre_proc_data)))
names(pre_proc_data) &lt;- names(sim_features)
sim_pu_polygons &lt;- cbind(sim_pu_polygons, pre_proc_data)

# create problem using the polygon planning unit data
# with the pre-processed columns
p5 &lt;-
  problem(sim_pu_polygons, features = names(pre_proc_data), "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# in addition to spatially explicit data, pre-processed aspatial data
# can also be used to create a problem
# (e.g., data created using external spreadsheet software)
costs &lt;- sim_pu_polygons$cost
features &lt;- data.frame(
  id = seq_len(terra::nlyr(sim_features)),
  name = names(sim_features)
)
rij_mat &lt;- rij_matrix(sim_pu_polygons, sim_features)
p6 &lt;-
  problem(costs, features, rij_matrix = rij_mat) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.2) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problems
s1 &lt;- solve(p1)
s2 &lt;- solve(p2)
s3 &lt;- solve(p3)
s4 &lt;- solve(p4)
s5 &lt;- solve(p5)
s6 &lt;- solve(p6)

# plot solutions for problems associated with spatial data
plot(s1, main = "raster data", axes = FALSE)
plot(s2[, "solution_1"], main = "polygon data")
plot(s3[, "solution_1"], main = "line data")
plot(s4[, "solution_1"], main = "point data")
plot(s5[, "solution_1"], main = "preprocessed data (polygon data)")

# show solutions for problems associated with aspatial data
str(s6)

# create some problems with multiple zones

# first, create a matrix containing the targets for multi-zone problems
# here each row corresponds to a different feature, each
# column corresponds to a different zone, and values correspond
# to the total (absolute) amount of a given feature that needs to be secured
# in a given zone
targets &lt;- matrix(
  rpois(15, 1),
  nrow = number_of_features(sim_zones_features),
  ncol = number_of_zones(sim_zones_features),
  dimnames = list(
    feature_names(sim_zones_features), zone_names(sim_zones_features)
  )
)

# print targets
print(targets)

# create a multi-zone problem with raster data
p7 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(targets) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s7 &lt;- solve(p7)

# plot solution
# here, each layer/panel corresponds to a different zone and pixel values
# indicate if a given planning unit has been allocated to a given zone
par(mfrow = c(1, 1))
plot(s7, main = c("zone 1", "zone 2", "zone 3"), axes = FALSE)

# alternatively, the category_layer function can be used to create
# a new raster object containing the zone ids for each planning unit
# in the solution (note this only works for problems with binary decisions)
par(mfrow = c(1, 1))
plot(category_layer(s7), axes = FALSE)

# create a multi-zone problem with polygon data
p8 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(targets) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s8 &lt;- solve(p8)

# create column containing the zone id for which each planning unit was
# allocated to in the solution
s8$solution &lt;- category_vector(sf::st_drop_geometry(
 s8[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
))
s8$solution &lt;- factor(s8$solution)

# plot solution
plot(s8[, "solution"], axes = FALSE)

# create a multi-zone problem with polygon planning unit data
# and where columns correspond to feature abundances

# to begin with, we will add columns to the planning unit data
# that indicate the amount of each feature in each zone
sim_zones_pu_polygons$spp1_z1 &lt;- rpois(nrow(sim_zones_pu_polygons), 1)
sim_zones_pu_polygons$spp2_z1 &lt;- rpois(nrow(sim_zones_pu_polygons), 1)
sim_zones_pu_polygons$spp3_z1 &lt;- rpois(nrow(sim_zones_pu_polygons), 1)
sim_zones_pu_polygons$spp1_z2 &lt;- rpois(nrow(sim_zones_pu_polygons), 1)
sim_zones_pu_polygons$spp2_z2 &lt;- rpois(nrow(sim_zones_pu_polygons), 1)
sim_zones_pu_polygons$spp3_z2 &lt;- rpois(nrow(sim_zones_pu_polygons), 1)

# create problem with polygon planning unit data and use column names
# to indicate feature data
# additionally, to make this example slightly more interesting,
# the problem will have proportion-type decisions such that
# a proportion of each planning unit can be allocated to each of the
# two management zones
p9 &lt;-
  problem(
    sim_zones_pu_polygons,
    zones(
      c("spp1_z1", "spp2_z1", "spp3_z1"),
      c("spp1_z2", "spp2_z2", "spp3_z2"),
      zone_names = c("z1", "z2")
    ),
    cost_column = c("cost_1", "cost_2")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_absolute_targets(targets[1:3, 1:2]) %&gt;%
  add_proportion_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s9 &lt;- solve(p9)

# plot solution
plot(s9[, c("solution_1_z1", "solution_1_z2")], axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='proximity_matrix'>Proximity matrix</h2><span id='topic+proximity_matrix'></span><span id='topic+proximity_matrix.Raster'></span><span id='topic+proximity_matrix.SpatRaster'></span><span id='topic+proximity_matrix.SpatialPolygons'></span><span id='topic+proximity_matrix.SpatialLines'></span><span id='topic+proximity_matrix.SpatialPoints'></span><span id='topic+proximity_matrix.sf'></span><span id='topic+proximity_matrix.default'></span>

<h3>Description</h3>

<p>Create a matrix showing which planning units are within a certain
spatial proximity to each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proximity_matrix(x, distance)

## S3 method for class 'Raster'
proximity_matrix(x, distance)

## S3 method for class 'SpatRaster'
proximity_matrix(x, distance)

## S3 method for class 'SpatialPolygons'
proximity_matrix(x, distance)

## S3 method for class 'SpatialLines'
proximity_matrix(x, distance)

## S3 method for class 'SpatialPoints'
proximity_matrix(x, distance)

## S3 method for class 'sf'
proximity_matrix(x, distance)

## Default S3 method:
proximity_matrix(x, distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proximity_matrix_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object representing planning units.</p>
</td></tr>
<tr><td><code id="proximity_matrix_+3A_distance">distance</code></td>
<td>
<p><code>numeric</code> distance threshold. Planning units
that are further apart from each other than this threshold are
not treated as being within proximity of each other.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Proximity calculations are performed using
<code><a href="sf.html#topic+geos_binary_pred">sf::st_is_within_distance()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="Matrix.html#topic+dsCMatrix-class">dsCMatrix</a></code> symmetric sparse matrix object.
Each row and column represents a planning unit.
Cells values indicate if the pair-wise distances between different
planning units are within the distance threshold or not (using ones and
zeros). To reduce computational burden, cells among the matrix diagonal are
set to zero. Furthermore, if the argument to <code>x</code> is a
<code><a href="terra.html#topic+rast">terra::rast()</a></code> object, then cells with missing (<code>NA</code>)
values are set to zero too.
</p>


<h3>See Also</h3>

<p>Proximity matrix data might need rescaling to improve optimization
performance, see <code><a href="#topic+rescale_matrix">rescale_matrix()</a></code> to perform these calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_pu_lines &lt;- get_sim_pu_lines()
sim_pu_points &lt;- get_sim_pu_points()

# create proximity matrix using raster data
## crop raster to 9 cells to provide a small example
r &lt;- terra::crop(sim_pu_raster, c(0, 0.3, 0, 0.3))

## make proximity matrix using a distance threshold of 2
cm_raster &lt;- proximity_matrix(r, distance = 2)

# create proximity matrix using polygon data
## subset 9 polygons to provide a small example
ply &lt;- sim_pu_polygons[c(1:3, 11:13, 20:22), ]

## make proximity matrix using a distance threshold of 2
cm_ply &lt;- proximity_matrix(ply, distance = 2)

# create proximity matrix using line data
## subset 9 lines to provide a small example
lns &lt;- sim_pu_lines[c(1:3, 11:13, 20:22), ]

## make proximity matrix
cm_lns &lt;- proximity_matrix(lns, distance = 2)

## create proximity matrix using point data
## subset 9 points to provide a small example
pts &lt;- sim_pu_points[c(1:3, 11:13, 20:22), ]

# make proximity matrix
cm_pts &lt;- proximity_matrix(pts, distance = 2)

## plot raster and proximity matrix
plot(r, main = "raster", axes = FALSE)
Matrix::image(cm_raster, main = "proximity matrix")

## plot polygons and proximity matrix
plot(ply[, 1], main = "polygons", axes = FALSE)
Matrix::image(cm_ply, main = "proximity matrix")

## plot lines and proximity matrix
plot(lns[, 1], main = "lines", axes = FALSE)
Matrix::image(cm_lns, main = "proximity matrix")

## plot points and proximity matrix
plot(pts[, 1], main = "points", axes = FALSE)
Matrix::image(cm_pts, main = "proximity matrix")

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic++25T+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code>, <code><a href="magrittr.html#topic+tee">%T&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rescale_matrix'>Rescale a matrix</h2><span id='topic+rescale_matrix'></span>

<h3>Description</h3>

<p>Linearly rescale a matrix. Specifically, the values in the matrix
are rescaled so that the maximum value in the matrix is equal to
a new user-specified maximum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_matrix(x, max = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_matrix_+3A_x">x</code></td>
<td>
<p><code><a href="base.html#topic+matrix">matrix</a></code>, <code><a href="base.html#topic+array">array</a></code>, <code><a href="Matrix.html#topic+Matrix-class">Matrix</a></code> object.</p>
</td></tr>
<tr><td><code id="rescale_matrix_+3A_max">max</code></td>
<td>
<p><code>numeric</code> new maximum value in matrix. Defaults to 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly useful for rescaling data prior to
optimization to avoid numerical issues.
For example, boundary length (e.g., generated using <code><a href="#topic+boundary_matrix">boundary_matrix()</a></code>) or
connectivity data (e.g., generated using <code><a href="#topic+connectivity_matrix">connectivity_matrix()</a></code>) can
contain very large values (e.g., values greater than 1,000,000)
and such large values can, in turn, degrade the performance of
exact algorithm solvers (see Details section in <code><a href="#topic+presolve_check">presolve_check()</a></code> for
more information on numerical issues).
By using this function to rescale boundary length or connectivity
data prior to optimization (e.g., before using <code><a href="#topic+add_boundary_penalties">add_boundary_penalties()</a></code> or
<code><a href="#topic+add_connectivity_penalties">add_connectivity_penalties()</a></code>, this can help avoid numerical issues
during optimization.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code>, <code><a href="base.html#topic+array">array</a></code>, <code><a href="Matrix.html#topic+Matrix-class">Matrix</a></code> object. The returned object is the
is the same class as the argument to <code>x</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+boundary_matrix">boundary_matrix()</a></code> and <code><a href="#topic+connectivity_matrix">connectivity_matrix()</a></code> for details on
creating boundary length and connectivity data.
Also, see <code><a href="#topic+presolve_check">presolve_check()</a></code> for information on numerical issues.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO

</code></pre>

<hr>
<h2 id='rij_matrix'>Feature by planning unit matrix</h2><span id='topic+rij_matrix'></span><span id='topic+rij_matrix+2CRaster+2CRaster-method'></span><span id='topic+rij_matrix+2CSpatial+2CRaster-method'></span><span id='topic+rij_matrix+2Csf+2CRaster-method'></span><span id='topic+rij_matrix+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+rij_matrix+2Csf+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Generate a matrix showing the amount of each feature in each planning
unit (also known as an <em>rij</em> matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rij_matrix(x, y, ...)

## S4 method for signature 'Raster,Raster'
rij_matrix(x, y, ...)

## S4 method for signature 'SpatRaster,SpatRaster'
rij_matrix(x, y, memory, ...)

## S4 method for signature 'Spatial,Raster'
rij_matrix(x, y, fun, ...)

## S4 method for signature 'sf,Raster'
rij_matrix(x, y, fun, ...)

## S4 method for signature 'sf,SpatRaster'
rij_matrix(x, y, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rij_matrix_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> or <code><a href="sf.html#topic+sf">sf::sf()</a></code> object representing planning units.</p>
</td></tr>
<tr><td><code id="rij_matrix_+3A_y">y</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code>  object.</p>
</td></tr>
<tr><td><code id="rij_matrix_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="rij_matrix_+3A_memory">memory</code></td>
<td>
<p><code>logical</code> should calculations be performed using a method
that prioritizes reduced memory consumption over speed?
If <code>TRUE</code>, then calculations are performed using a method that
reduces memory consumption, but can take a long time to complete.
If <code>FALSE</code>, then calculations are performed using a method that
reduces run time, but will fail when insufficient memory is available.
Defaults to <code>NA</code>, such that calculations are automatically performed
using the best method given available memory and dataset sizes.
Note that this parameter can only be used when the arguments to <code>x</code>
and <code>y</code> are both <code><a href="terra.html#topic+rast">terra::rast()</a></code> objects.</p>
</td></tr>
<tr><td><code id="rij_matrix_+3A_fun">fun</code></td>
<td>
<p><code>character</code> for summarizing values inside each planning unit.
This parameter is only used when the argument to <code>x</code> is a
<code><a href="sf.html#topic+sf">sf::sf()</a></code> object.
Defaults to <code>"sum"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, processing <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> data takes much longer to process than
<code><a href="terra.html#topic+rast">terra::rast()</a></code> data.
As such, it is recommended to use <code><a href="terra.html#topic+rast">terra::rast()</a></code> data for planning units
where possible.
The performance of this function for large <code><a href="terra.html#topic+rast">terra::rast()</a></code> datasets
can be improved by increasing the GDAL cache size.
The default cache size is 25 MB.
For example, the following code can be used to set the cache size to 4 GB.
</p>
<div class="sourceCode"><pre>terra::gdalCache(size = 4000)
</pre></div>


<h3>Value</h3>

<p>A <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> sparse matrix object.
The sparse matrix represents the spatial intersection between the
planning units and the features. Rows correspond to features,
and columns correspond to planning units. Values correspond to the amount
(or presence/absence) of the feature in the planning unit. For example,
the amount of the third species in the second planning unit would be
stored in the third column and second row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_features &lt;- get_sim_features()

# create rij matrix using raster layer planning units
rij_raster &lt;- rij_matrix(sim_pu_raster, sim_features)
print(rij_raster)

# create rij matrix using polygon planning units
rij_polygons &lt;- rij_matrix(sim_pu_polygons, sim_features)
print(rij_polygons)

# create rij matrix using raster planning units with multiple zones
rij_zones_raster &lt;- rij_matrix(sim_zones_pu_raster, sim_features)
print(rij_zones_raster)

## End(Not run)
</code></pre>

<hr>
<h2 id='run_calculations'>Run calculations</h2><span id='topic+run_calculations'></span>

<h3>Description</h3>

<p>Execute preliminary calculations in a conservation problem and store the
results for later use. This function is useful when creating slightly
different versions of the same conservation planning problem that involve
the same pre-processing steps (e.g., calculating boundary data), because
means that the same calculations will not be run multiple times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_calculations(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_calculations_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used for the effect of modifying the input
<code><a href="#topic+ConservationProblem-class">ConservationProblem</a></code> object. As such, it does not return
anything. To use this function with <code><a href="base.html#topic+pipe">pipe()</a></code> operators, use the
<code style="white-space: pre;">&#8288;%T&gt;%&#8288;</code> operator and not the <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> operator.
</p>


<h3>Value</h3>

<p>An invisible <code>TRUE</code> indicating success.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# let us imagine a scenario where we wanted to understand the effect of
# setting different targets on our solution.

# create a conservation problem with no targets
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_boundary_penalties(10, 0.5) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create a copies of p and add targets
p1 &lt;- p %&gt;% add_relative_targets(0.1)
p2 &lt;- p %&gt;% add_relative_targets(0.2)
p3 &lt;- p %&gt;% add_relative_targets(0.3)

# now solve each of the different problems and record the time spent
# solving them
s1 &lt;- system.time({solve(p1); solve(p2); solve(p3)})

# This approach is inefficient. Since these problems all share the same
# planning units it is actually performing the same calculations three times.
# To avoid this, we can use the "run_calculations" function before creating
# the copies. Normally, R runs the calculations just before solving the
# problem

# recreate a conservation problem with no targets and tell R run the
# preliminary calculations. Note how we use the %T&gt;% operator here.
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_boundary_penalties(10, 0.5) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE) %T&gt;%
  run_calculations()

# create a copies of p and add targets just like before
p1 &lt;- p %&gt;% add_relative_targets(0.1)
p2 &lt;- p %&gt;% add_relative_targets(0.2)
p3 &lt;- p %&gt;% add_relative_targets(0.3)

# solve each of the different problems and record the time spent
# solving them
s2 &lt;- system.time({solve(p1); solve(p2); solve(p3)})

# now lets compare the times
print(s1) # time spent without running preliminary calculations
print(s2) # time spent after running preliminary calculations

# As we can see, we can save time by running the preliminary
# calculations before making copies of the problem with slightly
# different constraints. Although the time saved in this example
# is rather small, this is because the example data are very small.
# We would expect larger time savings for larger datasets.

## End(Not run)
</code></pre>

<hr>
<h2 id='show'>Show</h2><span id='topic+show'></span><span id='topic+show+2CConservationProblem-method'></span><span id='topic+show+2CConservationModifier-method'></span><span id='topic+show+2COptimizationProblem-method'></span><span id='topic+show+2CId-method'></span><span id='topic+show+2CSolver-method'></span>

<h3>Description</h3>

<p>Display information about an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConservationModifier'
show(x)

## S4 method for signature 'ConservationProblem'
show(x)

## S4 method for signature 'OptimizationProblem'
show(x)

## S4 method for signature 'Solver'
show(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+show">methods::show()</a></code>.
</p>

<hr>
<h2 id='sim_data'>Get simulated conservation planning data</h2><span id='topic+sim_data'></span><span id='topic+sim_pu_polygons'></span><span id='topic+sim_zones_pu_polygons'></span><span id='topic+sim_pu_points'></span><span id='topic+sim_pu_lines'></span><span id='topic+sim_pu_raster'></span><span id='topic+sim_locked_in_raster'></span><span id='topic+sim_locked_out_raster'></span><span id='topic+sim_zones_pu_raster'></span><span id='topic+sim_features'></span><span id='topic+sim_zones_features'></span><span id='topic+sim_phylogeny'></span><span id='topic+get_sim_pu_polygons'></span><span id='topic+get_sim_zones_pu_polygons'></span><span id='topic+get_sim_pu_points'></span><span id='topic+get_sim_pu_lines'></span><span id='topic+get_sim_pu_raster'></span><span id='topic+get_sim_locked_in_raster'></span><span id='topic+get_sim_locked_out_raster'></span><span id='topic+get_sim_zones_pu_raster'></span><span id='topic+get_sim_features'></span><span id='topic+get_sim_zones_features'></span><span id='topic+get_sim_phylogeny'></span>

<h3>Description</h3>

<p>A set of functions are available for importing simulated datasets. These
datasets are designed for creating small example spatial prioritizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sim_pu_polygons()

get_sim_zones_pu_polygons()

get_sim_pu_lines()

get_sim_pu_points()

get_sim_pu_raster()

get_sim_locked_in_raster()

get_sim_locked_out_raster()

get_sim_zones_pu_raster()

get_sim_features()

get_sim_zones_features()

get_sim_phylogeny()
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>get_sim_pu_polygons()</code></dt><dd><p><code><a href="sf.html#topic+sf">sf::st_sf()</a></code> object.</p>
</dd>
<dt><code>get_sim_zones_pu_polygons()</code></dt><dd><p><code><a href="sf.html#topic+sf">sf::st_sf()</a></code> object.</p>
</dd>
<dt><code>get_sim_pu_lines()</code></dt><dd><p><code><a href="sf.html#topic+sf">sf::st_sf()</a></code> object.</p>
</dd>
<dt><code>get_sim_pu_points()</code></dt><dd><p><code><a href="sf.html#topic+sf">sf::st_sf()</a></code> object.</p>
</dd>
<dt><code>get_sim_pu_raster()</code></dt><dd><p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object.</p>
</dd>
<dt><code>get_sim_zones_pu_raster()</code></dt><dd><p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object.</p>
</dd>
<dt><code>get_sim_locked_in_raster()</code></dt><dd><p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object.</p>
</dd>
<dt><code>get_sim_locked_out_raster()</code></dt><dd><p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object.</p>
</dd>
<dt><code>get_sim_features()</code></dt><dd><p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object.</p>
</dd>
<dt><code>get_sim_zones_features()</code></dt><dd><p><code><a href="#topic+ZonesRaster">ZonesRaster()</a></code> object.</p>
</dd>
<dt><code>get_sim_phylogeny()</code></dt><dd><p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object.</p>
</dd>
</dl>



<h3>Single zone datasets</h3>

<p>The following functions are provided for generating spatial prioritizations
that only contain a single management zone.
</p>

<dl>
<dt><code>get_sim_pu_raster()</code></dt><dd><p>Import planning unit data that are stored
in raster format.
Here, cell values indicate planning unit cost and missing (<code>NA</code>)
values indicate that a cell is not a planning unit.</p>
</dd>
<dt><code>get_sim_locked_in_raster()</code></dt><dd><p>Import planning unit data
that are stored in raster format.
Here, cell values are binary and indicate if planning units should be
locked in to a solution.</p>
</dd>
<dt><code>get_sim_locked_out_raster()</code></dt><dd><p>Import planning unit data
that are stored in raster format.
Here, cell values are binary and indicate if planning units
should be locked out from a solution.</p>
</dd>
<dt><code>get_sim_pu_polygons()</code></dt><dd><p>Import planning unit data stored in vector
format. Here, planning units are represented using spatial polygons
(e.g., each polygon corresponds to a different management areas).
The data contains columns indicating the expenditure
required for prioritizing each planning unit (<code>"cost"</code> column), if the
planning units should be selected in the solution (<code>"locked_in"</code> column),
and if the planning units should never be selected in the solution
(<code>"locked_out"</code> column).</p>
</dd>
<dt><code>get_sim_pu_points()</code></dt><dd><p>Import planning unit data stored in vector
format. Here, planning units are represented using spatial lines
(e.g., each line corresponds to a different section along a river) .
The attribute table follows the same conventions as for
<code>sim_pu_polygons</code>.</p>
</dd>
<dt><code>get_sim_pu_lines()</code></dt><dd><p>Import planning unit data stored in vector
format. Here, planning units are represented using spatial points
(e.g., each point corresponds to a different site) .
The attribute table follows the same conventions as for
<code>sim_pu_polygons</code>.</p>
</dd>
<dt><code>get_sim_features()</code></dt><dd><p>Import feature data stored in raster format.
Here, data describe the spatial distribution of five species.
Each layer corresponds to a different species, and
cell values indicate habitat suitability.</p>
</dd>
<dt><code>get_sim_phylogeny()</code></dt><dd><p>Import phylogenetic tree for the ten species.</p>
</dd>
</dl>



<h3>Multiple zone datasets</h3>

<p>The following functions are provided for generating spatial prioritizations
that contain multiple management zones.
</p>

<dl>
<dt><code>get_sim_zones_pu_raster()</code></dt><dd><p>Import planning unit data
for multiple management zones that are stored in raster format.
Here, each layer indicates the cost for a different management
zone. Cells with <code>NA</code> values in a given zone indicate that a
planning unit cannot be allocated to that zone in a solution.
Additionally, cells with <code>NA</code> values in all layers are not a
planning unit.</p>
</dd>
<dt><code>get_sim_zones_pu_polygons()</code></dt><dd><p>Import planning unit data for
multiple management zones stored in vector format.
Here, planning units are represented using spatial polygons.
The data contains columns indicating the
expenditure required for prioritizing each planning unit under different
management zones (<code>"cost_1"</code>, <code>"cost_2"</code>, and <code>"cost_3"</code> columns), and a
series
of columns indicating the value that each planning unit that should be
assigned in the solution (<code>"locked_1"</code>, <code>"locked_2"</code>, <code>"locked_3"</code>
columns).
In these locked columns, planning units that should not be locked to a
specific value are assigned a missing (<code>NA</code>) value.</p>
</dd>
<dt><code>get_sim_zones_features()</code></dt><dd><p>Import feature data for multiple
management zones stored in raster format.
Here, data describe the spatial distribution of ten species
under three different management zones.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_pu_lines &lt;- get_sim_pu_lines()
sim_pu_points &lt;- get_sim_pu_points()
sim_pu_raster &lt;- get_sim_pu_raster()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_locked_in_raster &lt;- get_sim_locked_in_raster()
sim_locked_out_raster &lt;- get_sim_locked_out_raster()
sim_phylogeny &lt;- get_sim_phylogeny()
sim_features &lt;- get_sim_features()
sim_zones_features &lt;- get_sim_zones_features()

# plot raster data
## Not run: 
par(mfrow = c(2, 2))
plot(sim_pu_raster, main = "planning units (raster)", axes = FALSE)
plot(sim_locked_in_raster, main = "locked in units (raster)", axes = FALSE)
plot(sim_locked_out_raster, main = "locked out units (raster)", axes = FALSE)

# plot vector planning unit data
par(mfrow = c(1, 1))
plot(sim_pu_polygons)
plot(sim_pu_lines)
plot(sim_pu_points)

# plot vector planning unit data for multiple management zones
plot(sim_zones_pu_polygons)

# plot phylogeny data
par(mfrow = c(1, 1))
plot(sim_phylogeny, main = "simulated phylogeny")

# plot feature data
par(mfrow = c(1, 1))
plot(sim_features, axes = FALSE)

# plot cost data for multiple management zones
par(mfrow = c(1, 1))
plot(sim_zones_pu_raster, axes = FALSE)

# plot feature data for multiple management zones
plot_names &lt;- paste0(
  "Species ",
   rep(
     seq_len(number_of_zones(sim_zones_features)),
     number_of_features(sim_zones_features)
   ),
   " (zone ",
   rep(
     seq_len(number_of_features(sim_zones_features)),
     each = number_of_zones(sim_zones_features)
   ),
   ")"
)
plot(
  terra::rast(as.list(sim_zones_features)),
   main = plot_names, axes = FALSE
)

## End(Not run)
</code></pre>

<hr>
<h2 id='simulate_cost'>Simulate cost data</h2><span id='topic+simulate_cost'></span><span id='topic+simulate_cost.Raster'></span><span id='topic+simulate_cost.SpatRaster'></span>

<h3>Description</h3>

<p>Generates simulated cost data using Gaussian random fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_cost(x, n, intensity, sd, scale)

## S3 method for class 'Raster'
simulate_cost(x, n = 1, intensity = 100, sd = 20, scale = 2.5)

## S3 method for class 'SpatRaster'
simulate_cost(x, n = 1, intensity = 100, sd = 20, scale = 2.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_cost_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object to use as a template.</p>
</td></tr>
<tr><td><code id="simulate_cost_+3A_n">n</code></td>
<td>
<p><code>integer</code> number of layers to simulate.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="simulate_cost_+3A_intensity">intensity</code></td>
<td>
<p><code>numeric</code> average value of simulated data.
Defaults to 100.</p>
</td></tr>
<tr><td><code id="simulate_cost_+3A_sd">sd</code></td>
<td>
<p><code>numeric</code> standard deviation of simulated data.
Defaults to 20.</p>
</td></tr>
<tr><td><code id="simulate_cost_+3A_scale">scale</code></td>
<td>
<p><code>numeric</code> parameter to control level of spatial
auto-correlation in the simulated data.
Defaults to 2.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="terra.html#topic+rast">terra::rast()</a></code> object with integer values greater than zero.
</p>


<h3>See Also</h3>

<p>Other simulations: 
<code><a href="#topic+simulate_data">simulate_data</a>()</code>,
<code><a href="#topic+simulate_species">simulate_species</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create raster
r &lt;- terra::rast(
  ncols = 10, nrows = 10, xmin = 0, xmax = 1, ymin = 0, ymax = 1, vals = 1
)

# simulate data
cost &lt;- simulate_cost(r)

# plot simulated species
plot(cost, main = "simulated cost data", axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='simulate_data'>Simulate data</h2><span id='topic+simulate_data'></span><span id='topic+simulate_data.Raster'></span><span id='topic+simulate_data.SpatRaster'></span>

<h3>Description</h3>

<p>Simulate spatially auto-correlated data using Gaussian random fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_data(x, n, scale, intensity, sd, transform)

## S3 method for class 'Raster'
simulate_data(
  x,
  n = 1,
  scale = 0.5,
  intensity = 0,
  sd = 1,
  transform = identity
)

## S3 method for class 'SpatRaster'
simulate_data(
  x,
  n = 1,
  scale = 0.5,
  intensity = 0,
  sd = 1,
  transform = identity
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_data_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object to use as a template.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_n">n</code></td>
<td>
<p><code>integer</code> number of layers to simulate.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_scale">scale</code></td>
<td>
<p><code>numeric</code> parameter to control level of spatial
auto-correlation in the simulated data.
Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_intensity">intensity</code></td>
<td>
<p><code>numeric</code> average value of simulated data.
Defaults to 0.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_sd">sd</code></td>
<td>
<p><code>numeric</code> standard deviation of simulated data.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_transform">transform</code></td>
<td>
<p><code>function</code> transform values output from the simulation.
Defaults to the <code><a href="base.html#topic+identity">identity()</a></code> function such that values remain the same
following transformation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="terra.html#topic+rast">terra::rast()</a></code> object.
</p>


<h3>See Also</h3>

<p>Other simulations: 
<code><a href="#topic+simulate_cost">simulate_cost</a>()</code>,
<code><a href="#topic+simulate_species">simulate_species</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create raster
r &lt;- terra::rast(
  ncols = 10, nrows = 10, xmin = 0, xmax = 1, ymin = 0, ymax = 1, vals = 1
)

# simulate data using a Gaussian field
x &lt;- simulate_data(r, n = 1, scale = 0.2)

# plot simulated data
plot(x, main = "simulated data", axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='simulate_species'>Simulate species habitat suitability data</h2><span id='topic+simulate_species'></span><span id='topic+simulate_species.Raster'></span><span id='topic+simulate_species.SpatRaster'></span>

<h3>Description</h3>

<p>Generates simulated species data using Gaussian random fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_species(x, n, scale)

## S3 method for class 'Raster'
simulate_species(x, n = 1, scale = 0.5)

## S3 method for class 'SpatRaster'
simulate_species(x, n = 1, scale = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_species_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object to use as a template.</p>
</td></tr>
<tr><td><code id="simulate_species_+3A_n">n</code></td>
<td>
<p><code>integer</code> number of layers to simulate.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="simulate_species_+3A_scale">scale</code></td>
<td>
<p><code>numeric</code> parameter to control level of spatial
auto-correlation in the simulated data.
Defaults to 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="terra.html#topic+rast">terra::rast()</a></code> object with values between zero and one.
</p>


<h3>See Also</h3>

<p>Other simulations: 
<code><a href="#topic+simulate_cost">simulate_cost</a>()</code>,
<code><a href="#topic+simulate_data">simulate_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create raster
r &lt;- terra::rast(
  ncols = 10, nrows = 10, xmin = 0, xmax = 1, ymin = 0, ymax = 1, vals = 1
)

# simulate data for 4 species
spp &lt;- simulate_species(r, 4)

# plot simulated species
plot(spp, main = "simulated species distributions", axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='solve'>Solve</h2><span id='topic+solve'></span><span id='topic+solve.ConservationProblem'></span>

<h3>Description</h3>

<p>Solve a conservation planning problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ConservationProblem'
solve(a, b, ..., run_checks = TRUE, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_+3A_a">a</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="solve_+3A_b">b</code></td>
<td>
<p>missing.</p>
</td></tr>
<tr><td><code id="solve_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+compile">compile()</a></code>.</p>
</td></tr>
<tr><td><code id="solve_+3A_run_checks">run_checks</code></td>
<td>
<p><code>logical</code> flag indicating whether presolve checks
should be run prior solving the problem. These checks are performed using
the <code><a href="#topic+presolve_check">presolve_check()</a></code> function. Defaults to <code>TRUE</code>.
Skipping these checks may reduce run time for large problems.</p>
</td></tr>
<tr><td><code id="solve_+3A_force">force</code></td>
<td>
<p><code>logical</code> flag indicating if an attempt to should be
made to solve the problem even if potential issues were detected during
the presolve checks. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After formulating a conservation planning <code><a href="#topic+problem">problem()</a></code>,
it can be solved using an exact algorithm solver (see <a href="#topic+solvers">solvers</a>
for available solvers). If no solver has been explicitly specified,
then the best available exact algorithm solver will be used by default
(see <code><a href="#topic+add_default_solver">add_default_solver()</a></code>). Although these exact algorithm
solvers will often display a lot of information that isn't really that
helpful (e.g., nodes, cutting planes), they do display information
about the progress they are making on solving the problem (e.g., the
performance of the best solution found at a given point in time). If
potential issues were detected during the
presolve checks (see <code><a href="#topic+presolve_check">presolve_check()</a></code>)
and the problem is being forcibly solved (i.e., with <code>force = TRUE</code>),
then it is also worth checking for any warnings displayed by the solver
to see if these potential issues are actually causing issues
(e.g., <em>Gurobi</em> can display warnings that include
<code>"Warning: Model contains large matrix coefficient range"</code> and
<code>"Warning: Model contains large rhs"</code>).
</p>


<h3>Value</h3>

<p>A <code>numeric</code>, <code>matrix</code>, <code>data.frame</code>, <code><a href="sf.html#topic+sf">sf::st_sf()</a></code>, or
<code><a href="terra.html#topic+rast">terra::rast()</a></code> object containing the solution to the problem.
Additionally, the returned object has attributes that describe
optimization process or solution (see below  for examples on accessing
these attributes). These attributes provide the following information.
</p>

<dl>
<dt><code>objective</code></dt><dd>
<p><code>numeric</code> mathematical objective value for the solution used
to evaluate the prioritization during optimization.
</p>
</dd>
<dt><code>runtime</code></dt><dd>
<p><code>numeric</code> total amount of time elapsed while during the optimization
process (reported in seconds). Note that this measure of time does not
include any data pre-processing or post-processing steps.
</p>
</dd>
<dt><code>status</code></dt><dd>
<p><code>character</code> status of the optimization process.
This status typically describes
the reason why the optimization process terminated. For example,
it might indicate that the optimization process terminated because
an optimal solution was found, or because a pre-specified time limit
was reached. These status values are (mostly) obtained directly from
the solver software, and so we recommend consulting the solver's
documentation for further information on what particular status values mean.
Note that some solvers (e.g., Gurobi and HiGHS) will return
an <code>"OPTIMAL"</code> status when the solver has found a solution within the
pre-specified optimality gap (e.g., it has found a solution within 10% of
optimality), even though the solution itself may not be strictly optimal.
</p>
</dd>
<dt><code>gap</code></dt><dd>
<p><code>numeric</code> optimality of the solution. This gap value provides an upper
bound of how far the solution is from optimality.
For example, you might specify a
10% optimality gap for the optimization process (e.g., using
<code>add_highs_solver(gap = 0.1)</code>), and this might produce a solution that is
actually 5% from optimality. As such, the solution might have a gap value
of 0.05 (corresponding to 5%). Because this value represents an upper bound,
it is also possible that the solution in this example
&ndash; even though it is actually 5% from optimality &ndash; might have a gap value
of 7% (i.e., 0.07). Note that only some solvers are able to
provide this information (i.e., the <em>Gurobi</em> and <em>HiGHS</em> solvers),
and the gap value for other solvers will contain missing (<code>NA</code>) values.
</p>
</dd>
</dl>



<h3>Output format</h3>

<p>This function will output solutions in a similar format to the
planning units associated with <code>a</code>. Specifically, it will return
solutions based on the following types of planning units.
</p>

<dl>
<dt><code>a</code> has <code>numeric</code> planning units</dt><dd><p>The solution will be
returned as a <code>numeric</code> vector. Here, each element in the vector
corresponds to a different planning unit.
Note that if a portfolio is used to generate multiple solutions,
then a <code>list</code> of such <code>numeric</code> vectors will be returned.</p>
</dd>
<dt><code>a</code> has <code>matrix</code> planning units</dt><dd><p>The solution will be
returned as a <code>matrix</code> object.
Here, rows correspond to different planning units,
and columns correspond to different  management zones.
Note that if a portfolio is used to generate multiple solutions,
then a <code>list</code> of such <code>matrix</code> objects will be returned.</p>
</dd>
<dt><code>a</code> has <code><a href="terra.html#topic+rast">terra::rast()</a></code> planning units</dt><dd><p>The solution
will be returned as a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object.
If the argument to <code>x</code> contains multiple zones, then the object
will have a different layer for each management zone.
Note that if a portfolio is used to generate multiple solutions,
then a <code>list</code> of <code><a href="terra.html#topic+rast">terra::rast()</a></code> objects will be returned.</p>
</dd>
<dt><code>a</code> has <code><a href="sf.html#topic+sf">sf::sf()</a></code>, or <code>data.frame</code> planning units</dt><dd>
<p>The solution will be returned in the same data format as the planning
units.
Here, each row corresponds to a different planning unit,
and columns contain solutions.
If the argument to <code>a</code> contains a single zone, then the solution object
will contain columns named by solution.
Specifically, the column names containing the solution values
be will named as <code>"solution_XXX"</code> where <code>"XXX"</code> corresponds to a solution
identifier (e.g., <code>"solution_1"</code>).
If the argument to <code>a</code> contains multiple zones, then the columns
containing solutions will be named as <code>"solution_XXX_YYY"</code> where
<code>"XXX"</code> corresponds to the solution identifier and <code>"YYY"</code> is the name
of the management zone (e.g., <code>"solution_1_zone1"</code>).</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <code><a href="#topic+problem">problem()</a></code> to create conservation planning problems, and
<code><a href="#topic+presolve_check">presolve_check()</a></code> to check problems for potential issues.
Also, see the <code><a href="#topic+category_layer">category_layer()</a></code> and <code><a href="#topic+category_vector">category_vector()</a></code> function to
reformat solutions that contain multiple zones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_pu_polygons &lt;- get_sim_zones_pu_polygons()
sim_zones_features &lt;- get_sim_zones_features()

# build minimal conservation problem with raster data
p1 &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s1 &lt;- solve(p1)

# print solution
print(s1)

# print attributes describing the optimization process and the solution
print(attr(s1, "objective"))
print(attr(s1, "runtime"))
print(attr(s1, "status"))
print(attr(s1, "gap"))

# calculate feature representation in the solution
r1 &lt;- eval_feature_representation_summary(p1, s1)
print(r1)

# plot solution
plot(s1, main = "solution", axes = FALSE)

# build minimal conservation problem with polygon data
p2 &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s2 &lt;- solve(p2)

# print solution
print(s2)

# calculate feature representation in the solution
r2 &lt;- eval_feature_representation_summary(p2, s2[, "solution_1"])
print(r2)

# plot solution
plot(s2[, "solution_1"], main = "solution", axes = FALSE)

# build multi-zone conservation problem with raster data
p3 &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s3 &lt;- solve(p3)

# print solution
print(s3)

# calculate feature representation in the solution
r3 &lt;- eval_feature_representation_summary(p3, s3)
print(r3)

# plot solution
plot(category_layer(s3), main = "solution", axes = FALSE)

# build multi-zone conservation problem with polygon data
p4 &lt;-
  problem(
    sim_zones_pu_polygons, sim_zones_features,
    cost_column = c("cost_1", "cost_2", "cost_3")
  ) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve the problem
s4 &lt;- solve(p4)

# print solution
print(s4)

# calculate feature representation in the solution
r4 &lt;- eval_feature_representation_summary(
  p4, s4[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
print(r4)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s4$solution &lt;- category_vector(
  s4[, c("solution_1_zone_1", "solution_1_zone_2", "solution_1_zone_3")]
)
s4$solution &lt;- factor(s4$solution)

# plot solution
plot(s4[, "solution"])

## End(Not run)
</code></pre>

<hr>
<h2 id='Solver-class'>Solver class</h2><span id='topic+Solver-class'></span><span id='topic+Solver'></span>

<h3>Description</h3>

<p>This class is used to represent solvers for optimization.
<strong>Only experts should use the fields and methods for this class directly.</strong>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ConservationModifier">prioritizr::ConservationModifier</a></code> -&gt; <code>Solver</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Solver-run"><code>Solver$run()</code></a>
</p>
</li>
<li> <p><a href="#method-Solver-calculate"><code>Solver$calculate()</code></a>
</p>
</li>
<li> <p><a href="#method-Solver-set_variable_ub"><code>Solver$set_variable_ub()</code></a>
</p>
</li>
<li> <p><a href="#method-Solver-set_variable_lb"><code>Solver$set_variable_lb()</code></a>
</p>
</li>
<li> <p><a href="#method-Solver-solve"><code>Solver$solve()</code></a>
</p>
</li>
<li> <p><a href="#method-Solver-clone"><code>Solver$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_data'><code>prioritizr::ConservationModifier$get_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_internal'><code>prioritizr::ConservationModifier$get_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="print"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-print'><code>prioritizr::ConservationModifier$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="repr"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-repr'><code>prioritizr::ConservationModifier$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_data'><code>prioritizr::ConservationModifier$set_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_internal'><code>prioritizr::ConservationModifier$set_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="show"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-show'><code>prioritizr::ConservationModifier$show()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Solver-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run the solver to generate a solution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Solver$run()</pre></div>



<h5>Returns</h5>

<p><code>list</code> of solutions.
</p>


<hr>
<a id="method-Solver-calculate"></a>



<h4>Method <code>calculate()</code></h4>

<p>Perform computations that need to be completed before applying
the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Solver$calculate(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Additional arguments.</p>
</dd>
<dt><code>x</code></dt><dd><p><code><a href="#topic+optimization_problem">optimization_problem()</a></code> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-Solver-set_variable_ub"></a>



<h4>Method <code>set_variable_ub()</code></h4>

<p>Set the upper bound for a decision variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>Solver$set_variable_ub(index, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p><code>integer</code> value indicating the index of the decision
variable.</p>
</dd>
<dt><code>value</code></dt><dd><p><code>numeric</code> new bound value.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-Solver-set_variable_lb"></a>



<h4>Method <code>set_variable_lb()</code></h4>

<p>Set the lower bound for a decision variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>Solver$set_variable_lb(index, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p><code>integer</code> value indicating the index of the decision
variable.</p>
</dd>
<dt><code>value</code></dt><dd><p><code>numeric</code> new bound value.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-Solver-solve"></a>



<h4>Method <code>solve()</code></h4>

<p>Solve an optimization problem.
</p>


<h5>Usage</h5>

<div class="r"><pre>Solver$solve(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code><a href="#topic+optimization_problem">optimization_problem()</a></code> object.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments passed to the <code>calculate()</code> method.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible <code>TRUE</code>.
</p>


<hr>
<a id="method-Solver-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Solver$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+ConservationModifier-class">ConservationModifier-class</a></code>,
<code><a href="#topic+ConservationProblem-class">ConservationProblem-class</a></code>,
<code><a href="#topic+Constraint-class">Constraint-class</a></code>,
<code><a href="#topic+Decision-class">Decision-class</a></code>,
<code><a href="#topic+Objective-class">Objective-class</a></code>,
<code><a href="#topic+OptimizationProblem-class">OptimizationProblem-class</a></code>,
<code><a href="#topic+Penalty-class">Penalty-class</a></code>,
<code><a href="#topic+Portfolio-class">Portfolio-class</a></code>,
<code><a href="#topic+Target-class">Target-class</a></code>
</p>

<hr>
<h2 id='solvers'>Add solvers</h2><span id='topic+solvers'></span>

<h3>Description</h3>

<p>Specify the software and configuration used to solve a conservation planning
problem. By default, the best available
software currently installed on the system will be used.
For information on the performance of different solvers,
please see Schuster <em>et al.</em> (2020) for benchmarks comparing the
run time and solution quality of some of these solvers when applied to
different sized datasets.
</p>


<h3>Details</h3>

<p>The following solvers can be used to find solutions for a
conservation planning <code><a href="#topic+problem">problem()</a></code>:
</p>

<dl>
<dt><code><a href="#topic+add_default_solver">add_default_solver()</a></code></dt><dd><p>This solver uses the best software
currently installed on the system.</p>
</dd>
<dt><code><a href="#topic+add_gurobi_solver">add_gurobi_solver()</a></code></dt><dd><p><a href="https://www.gurobi.com/"><em>Gurobi</em></a>
is a state-of-the-art commercial optimization software with an R package
interface. We recommend using this solver if at all possible.
It is by far the fastest of the solvers available for
generating prioritizations, however, it is not freely available. That
said, licenses are available to academics at no cost. The
<span class="pkg">gurobi</span> package is distributed with the <em>Gurobi</em> software
suite. This solver uses the <span class="pkg">gurobi</span> package to solve problems.</p>
</dd>
<dt><code><a href="#topic+add_cplex_solver">add_cplex_solver()</a></code></dt><dd><p><a href="https://www.ibm.com/products/ilog-cplex-optimization-studio/cplex-optimizer"><em>IBM CPLEX</em></a>
is a commercial optimization software. It is faster than the open
source solvers available for generating prioritizations, however, it
is not freely available.
Similar to the <a href="https://www.gurobi.com/"><em>Gurobi</em></a>
software, licenses are available to academics at no cost.
This solver uses the <span class="pkg">cplexAPI</span> package to solve problems using
<em>IBM CPLEX</em>.</p>
</dd>
<dt><code><a href="#topic+add_cbc_solver">add_cbc_solver()</a></code></dt><dd><p><a href="https://github.com/coin-or/Cbc"><em>CBC</em></a> is an
open-source mixed integer programming solver that is part of the
Computational Infrastructure for Operations Research (COIN-OR) project.
Preliminary benchmarks indicate that it is the fastest open source
solver currently supported.
We recommend using this solver if both <em>Gurobi</em> and <em>IBM CPLEX</em> are
unavailable.
It requires the <span class="pkg">rcbc</span> package, which is currently only available on
<a href="https://github.com/dirkschumacher/rcbc">GitHub</a>.
</p>
</dd>
<dt><code><a href="#topic+add_highs_solver">add_highs_solver()</a></code></dt><dd><p><a href="https://highs.dev/"><em>HiGHS</em></a> is an open
source optimization software. Although this solver can have
comparable performance to the <em>CBC</em> solver for particular problems and is
generally faster than the <em>SYMPHONY</em> based solvers (see below), it
sometimes can take much longer than the <em>CBC</em> solver for particular
problems.
</p>
</dd>
<dt><code><a href="#topic+add_lpsymphony_solver">add_lpsymphony_solver()</a></code></dt><dd>
<p><a href="https://github.com/coin-or/SYMPHONY"><em>SYMPHONY</em></a> is an
open-source mixed integer programming solver that is also part of the
COIN-OR project. Although both <em>SYMPHONY</em> and <em>CBC</em> are part of
the COIN-OR project, they are different software.
The <span class="pkg">lpsymphony</span> package provides an interface to the <em>SYMPHONY</em>
software, and is distributed through
<a href="https://doi.org/doi:10.18129/B9.bioc.lpsymphony">Bioconductor</a>.
We recommend using this solver if the <em>CBC</em> and <em>HiGHS</em> solvers cannot
be installed.
This solver can use parallel processing to solve problems, so it is
faster than <span class="pkg">Rsymphony</span> package interface (see below).
</p>
</dd>
<dt><code><a href="#topic+add_rsymphony_solver">add_rsymphony_solver()</a></code></dt><dd>
<p>This solver provides an alternative interface to the
<a href="https://github.com/coin-or/SYMPHONY"><em>SYMPHONY</em></a> solver using
the <span class="pkg">Rsymphony</span> package.
Unlike other solvers, the <span class="pkg">Rsymphony</span> package can be installed
directly from the Comprehensive R Archive Network (CRAN).
It is also the slowest of the available solvers.</p>
</dd>
</dl>



<h3>References</h3>

<p>Schuster R, Hanson JO, Strimas-Mackey M, and Bennett JR (2020). Exact
integer linear programming solvers outperform simulated annealing for
solving conservation planning problems. <em>PeerJ</em>, 8: e9258.
</p>


<h3>See Also</h3>

<p>Other overviews: 
<code><a href="#topic+constraints">constraints</a></code>,
<code><a href="#topic+decisions">decisions</a></code>,
<code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+objectives">objectives</a></code>,
<code><a href="#topic+penalties">penalties</a></code>,
<code><a href="#topic+portfolios">portfolios</a></code>,
<code><a href="#topic+summaries">summaries</a></code>,
<code><a href="#topic+targets">targets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create basic problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_proportion_decisions()

# create vector to store plot names
n &lt;- c()

# create empty list to store solutions
s &lt;- c()

# if gurobi is installed: create problem with added gurobi solver
if (require("gurobi")) {
  p1 &lt;- p %&gt;% add_gurobi_solver(verbose = FALSE)
  n &lt;- c(n, "gurobi")
  s &lt;- c(s, solve(p1))
}

# if cplexAPI is installed: create problem with added CPLEX solver
if (require("cplexAPI")) {
  p2 &lt;- p %&gt;% add_cplex_solver(verbose = FALSE)
  n &lt;- c(n, "CPLEX")
  s &lt;- c(s, solve(p2))
}

# if rcbc is installed: create problem with added CBC solver
if (require("rcbc")) {
  p3 &lt;- p %&gt;% add_cbc_solver(verbose = FALSE)
  n &lt;- c(n, "CBC")
  s &lt;- c(s, solve(p3))
}

# if highs is installed: create problem with added HiGHs solver
if (require("highs")) {
  p4 &lt;- p %&gt;% add_highs_solver(verbose = FALSE)
  n &lt;- c(n, "HiGHS")
  s &lt;- c(s, solve(p4))
}

# create problem with added rsymphony solver
if (require("Rsymphony")) {
  p5 &lt;- p %&gt;% add_rsymphony_solver(verbose = FALSE)
  n &lt;- c(n, "Rsymphony")
  s &lt;- c(s, solve(p5))
}

# if lpsymphony is installed: create problem with added lpsymphony solver
if (require("lpsymphony")) {
  p6 &lt;- p %&gt;% add_lpsymphony_solver(verbose = FALSE)
  n &lt;- c(n, "lpsymphony")
  s &lt;- c(s, solve(p6))
}

# plot solutions
names(s) &lt;- n
plot(terra::rast(s), axes = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='summaries'>Evaluate solutions using summary statistics</h2><span id='topic+summaries'></span>

<h3>Description</h3>

<p>After generating a solution to a conservation planning problem,
it can be useful to evaluate how well it performs. These functions
can be used to evaluate a solution according to
various different summary statistics.
</p>


<h3>Details</h3>

<p>The following functions can be used to summarize the performance
of a solution to a conservation planning <code><a href="#topic+problem">problem()</a></code>:
</p>

<dl>
<dt><code><a href="#topic+eval_n_summary">eval_n_summary()</a></code></dt><dd><p>Calculate the number of planning units selected
within a solution.</p>
</dd>
<dt><code><a href="#topic+eval_cost_summary">eval_cost_summary()</a></code></dt><dd><p>Calculate the total cost of a solution.</p>
</dd>
<dt><code><a href="#topic+eval_feature_representation_summary">eval_feature_representation_summary()</a></code></dt><dd><p>Calculate how well features
are represented by a solution. This function can be used for all
problems.</p>
</dd>
<dt><code><a href="#topic+eval_target_coverage_summary">eval_target_coverage_summary()</a></code></dt><dd><p>Calculate how well feature
representation <a href="#topic+targets">targets</a> are met by a solution. This function can only be
used with problems that contain <a href="#topic+targets">targets</a>.</p>
</dd>
<dt><code><a href="#topic+eval_boundary_summary">eval_boundary_summary()</a></code></dt><dd><p>Calculate the exposed boundary length
(perimeter) associated with a solution.</p>
</dd>
<dt><code><a href="#topic+eval_connectivity_summary">eval_connectivity_summary()</a></code></dt><dd><p>Calculate the connectivity
held within a solution using symmetric data.</p>
</dd>
<dt><code><a href="#topic+eval_asym_connectivity_summary">eval_asym_connectivity_summary()</a></code></dt><dd><p>Calculate the connectivity
held within a solution using asymmetric data.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other overviews: 
<code><a href="#topic+constraints">constraints</a></code>,
<code><a href="#topic+decisions">decisions</a></code>,
<code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+objectives">objectives</a></code>,
<code><a href="#topic+penalties">penalties</a></code>,
<code><a href="#topic+portfolios">portfolios</a></code>,
<code><a href="#topic+solvers">solvers</a></code>,
<code><a href="#topic+targets">targets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create a minimal problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# solve problem
s &lt;- solve(p)

# evaluate number of selected planning units in solution
eval_n_summary(p, s)

# evaluate solution cost
eval_cost_summary(p, s)

# evaluate feature representation by solution
eval_feature_representation_summary(p, s)

# evaluate target coverage by solution
eval_target_coverage_summary(p, s)

# evaluate exposed boundary (perimeter) length by solution
eval_boundary_summary(p, s)

# create a symmetric connectivity matrix to describe pair-wise connectivity
# values between combinations of planning units,
# see ?connectivity_matrix for more information

# for brevity, we will do this using the cost data
# cost valuers have high connectivity between them
cm &lt;- connectivity_matrix(sim_pu_raster, sim_pu_raster)

# evaluate connectivity of solution using symmetric data
eval_connectivity_summary(p, s, data = cm)

# create an asymmetric connectivity matrix to describe pair-wise
# connectivity values between combinations of planning units

# for brevity, we will just generate a matrix with random values
acm &lt;- matrix(
  runif(ncell(sim_pu_raster) ^ 2),
  ncol = terra::ncell(sim_pu_raster)
)

# evaluate connectivity of solution using asymmetric data
eval_asym_connectivity_summary(p, s, data = acm)


## End(Not run)
</code></pre>

<hr>
<h2 id='Target-class'>Target class</h2><span id='topic+Target-class'></span><span id='topic+Target'></span>

<h3>Description</h3>

<p>This class is used to represent targets for optimization.
<strong>Only experts should use the fields and methods for this class directly.</strong>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ConservationModifier">prioritizr::ConservationModifier</a></code> -&gt; <code>Target</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Target-output"><code>Target$output()</code></a>
</p>
</li>
<li> <p><a href="#method-Target-clone"><code>Target$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="calculate"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-calculate'><code>prioritizr::ConservationModifier$calculate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_data'><code>prioritizr::ConservationModifier$get_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="get_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-get_internal'><code>prioritizr::ConservationModifier$get_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="print"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-print'><code>prioritizr::ConservationModifier$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="repr"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-repr'><code>prioritizr::ConservationModifier$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_data"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_data'><code>prioritizr::ConservationModifier$set_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="set_internal"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-set_internal'><code>prioritizr::ConservationModifier$set_internal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="prioritizr" data-topic="ConservationModifier" data-id="show"><a href='../../prioritizr/html/ConservationModifier.html#method-ConservationModifier-show'><code>prioritizr::ConservationModifier$show()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Target-output"></a>



<h4>Method <code>output()</code></h4>

<p>Output the targets.
</p>


<h5>Usage</h5>

<div class="r"><pre>Target$output()</pre></div>



<h5>Returns</h5>

<p><code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> data frame.
</p>


<hr>
<a id="method-Target-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Target$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+ConservationModifier-class">ConservationModifier-class</a></code>,
<code><a href="#topic+ConservationProblem-class">ConservationProblem-class</a></code>,
<code><a href="#topic+Constraint-class">Constraint-class</a></code>,
<code><a href="#topic+Decision-class">Decision-class</a></code>,
<code><a href="#topic+Objective-class">Objective-class</a></code>,
<code><a href="#topic+OptimizationProblem-class">OptimizationProblem-class</a></code>,
<code><a href="#topic+Penalty-class">Penalty-class</a></code>,
<code><a href="#topic+Portfolio-class">Portfolio-class</a></code>,
<code><a href="#topic+Solver-class">Solver-class</a></code>
</p>

<hr>
<h2 id='targets'>Add representation targets</h2><span id='topic+targets'></span>

<h3>Description</h3>

<p>Targets are used to specify the minimum amount or proportion of a feature's
distribution that should (ideally) be covered (represented) by a solution.
</p>


<h3>Details</h3>

<p><strong>Please note that most objectives require targets, and attempting
to solve a problem that requires targets will throw an error.</strong>
</p>
<p>The following functions can be used to specify targets for a
conservation planning <code><a href="#topic+problem">problem()</a></code>:
</p>

<dl>
<dt><code><a href="#topic+add_relative_targets">add_relative_targets()</a></code></dt><dd><p>Set targets as a proportion
(between 0 and 1) of the total amount of each feature in the
the study area.</p>
</dd>
<dt><code><a href="#topic+add_absolute_targets">add_absolute_targets()</a></code></dt><dd><p>Set targets that denote the
minimum amount of each feature required in the prioritization.</p>
</dd>
<dt><code><a href="#topic+add_loglinear_targets">add_loglinear_targets()</a></code></dt><dd><p>Set targets as a proportion
(between 0 and 1) that are calculated using log-linear interpolation.</p>
</dd>
<dt><code><a href="#topic+add_manual_targets">add_manual_targets()</a></code></dt><dd><p>Set targets manually.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other overviews: 
<code><a href="#topic+constraints">constraints</a></code>,
<code><a href="#topic+decisions">decisions</a></code>,
<code><a href="#topic+importance">importance</a></code>,
<code><a href="#topic+objectives">objectives</a></code>,
<code><a href="#topic+penalties">penalties</a></code>,
<code><a href="#topic+portfolios">portfolios</a></code>,
<code><a href="#topic+solvers">solvers</a></code>,
<code><a href="#topic+summaries">summaries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_pu_raster &lt;- get_sim_pu_raster()
sim_features &lt;- get_sim_features()

# create base problem
p &lt;-
  problem(sim_pu_raster, sim_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_binary_decisions() %&gt;%
  add_default_solver(verbose = FALSE)

# create problem with added relative targets
p1 &lt;- p %&gt;% add_relative_targets(0.1)

# create problem with added absolute targets
p2 &lt;- p %&gt;% add_absolute_targets(3)

# create problem with added loglinear targets
p3 &lt;- p %&gt;% add_loglinear_targets(10, 0.9, 100, 0.2)

# create problem with manual targets that equate to 10% relative targets
targs &lt;- data.frame(
  feature = names(sim_features),
  target = 0.1,
  type = "relative"
)

p4 &lt;- p %&gt;% add_manual_targets(targs)

# solve problem
s &lt;- c(solve(p1), solve(p2), solve(p3), solve(p4))
names(s) &lt;- c(
  "relative targets", "absolute targets", "loglinear targets",
  "manual targets"
)
# plot solution
plot(s, axes = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='tibble-methods'>Manipulate tibbles</h2><span id='topic+tibble-methods'></span><span id='topic+nrow+2Ctbl_df-method'></span><span id='topic+ncol+2Ctbl_df-method'></span><span id='topic+as.list+2Ctbl_df-method'></span>

<h3>Description</h3>

<p>Assorted functions for manipulating <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'tbl_df'
nrow(x)

## S4 method for signature 'tbl_df'
ncol(x)

## S4 method for signature 'tbl_df'
as.list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tibble-methods_+3A_x">x</code></td>
<td>
<p><code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following methods are provided from manipulating
<code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> objects.
</p>

<dl>
<dt>nrow</dt><dd><p><code>integer</code> number of rows.</p>
</dd>
<dt>ncol</dt><dd><p><code>integer</code> number of columns.</p>
</dd>
<dt>as.list</dt><dd><p>convert to a <code>list</code>.</p>
</dd>
<dt>print</dt><dd><p>print the object.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load tibble package
require(tibble)

# make tibble
a &lt;- tibble(value = seq_len(5))

# number of rows
nrow(a)

# number of columns
ncol(a)

# convert to list
as.list(a)
</code></pre>

<hr>
<h2 id='write_problem'>Write problem</h2><span id='topic+write_problem'></span>

<h3>Description</h3>

<p>Save the mathematical formulation for a conservation planning problem
to a file for mixed integer programming solvers. Note that this function
requires either the <span class="pkg">Rsymphony</span> or <span class="pkg">gurobi</span> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_problem(x, path, solver = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_problem_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> object.</p>
</td></tr>
<tr><td><code id="write_problem_+3A_path">path</code></td>
<td>
<p><code>character</code> file path to save the problem formulation.
The argument should contain a <code>".lp"</code> or <code style="white-space: pre;">&#8288;.mps"&#8288;</code> file extension
to specify whether the problem formulation will be saved in the
<a href="https://www.gurobi.com/documentation/9.5/refman/lp_format.html">LP</a> or
<a href="https://www.gurobi.com/documentation/9.5/refman/mps_format.html">MPS</a>
format (respectively).</p>
</td></tr>
<tr><td><code id="write_problem_+3A_solver">solver</code></td>
<td>
<p><code>character</code> name of optimization solver to write the problem
to disk. Available options include: <code>"rsymphony" </code>, <code>"gurobi"</code>, or <code>NULL</code>.
Note that using the Gurobi solver is much faster, because the Rsymphony
solver requires attempting to solve the problem before it can be written.
Defaults to <code>NULL</code>, such that the best available solver is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible <code>TRUE</code> indicating success.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_polygons &lt;- get_sim_pu_polygons()
sim_features &lt;- get_sim_features()

# subset data to extract first four planning units
sim_pu_polygons &lt;- sim_pu_polygons[1:4, ]

# create minimal problem
p &lt;-
  problem(sim_pu_polygons, sim_features, cost_column = "cost") %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(0.1) %&gt;%
  add_binary_decisions()

# specify file path to save problem formulation
path &lt;- file.path(tempdir(), "model.lp")
print(path)

# save problem to file
## note that either the gurobi or Rsymphony package needs to be installed
write_problem(p, path)

# print model file
cat(readLines(path), sep = "\n")

## End(Not run)

</code></pre>

<hr>
<h2 id='zone_names'>Zone names</h2><span id='topic+zone_names'></span><span id='topic+zone_names.ConservationProblem'></span><span id='topic+zone_names.ZonesRaster'></span><span id='topic+zone_names.ZonesSpatRaster'></span><span id='topic+zone_names.ZonesCharacter'></span>

<h3>Description</h3>

<p>Extract the names of zones in an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zone_names(x, ...)

## S3 method for class 'ConservationProblem'
zone_names(x, ...)

## S3 method for class 'ZonesRaster'
zone_names(x, ...)

## S3 method for class 'ZonesSpatRaster'
zone_names(x, ...)

## S3 method for class 'ZonesCharacter'
zone_names(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zone_names_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+problem">problem()</a></code> or <code><a href="#topic+zones">zones()</a></code> object.</p>
</td></tr>
<tr><td><code id="zone_names_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector of zone names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
sim_zones_pu_raster &lt;- get_sim_zones_pu_raster()
sim_zones_features &lt;- get_sim_zones_features()

# print names of zones in a Zones object
print(zone_names(sim_zones_features))
# create problem with multiple zones
p &lt;-
  problem(sim_zones_pu_raster, sim_zones_features) %&gt;%
  add_min_set_objective() %&gt;%
  add_relative_targets(matrix(0.2, ncol = 3, nrow = 5)) %&gt;%
  add_binary_decisions()

# print zone names in problem
print(zone_names(p))

## End(Not run)
</code></pre>

<hr>
<h2 id='zones'>Management zones</h2><span id='topic+zones'></span><span id='topic+Zones-class'></span><span id='topic+ZonesCharacter'></span><span id='topic+ZonesRaster'></span><span id='topic+ZonesSpatRaster'></span><span id='topic+Zones'></span>

<h3>Description</h3>

<p>Organize data for multiple features for multiple management zones.
Specifically, the data should describe the expected amount of each
feature within each planning unit given each management zone.
For example, the data could describe the occupancy
(e.g., presence/absence), probability of occurrence, or
abundance expected for each feature when each planning unit
is allocated to a different zone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zones(..., zone_names = NULL, feature_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zones_+3A_...">...</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> or <code>character</code> objects that
pertain to the biodiversity data. See Details for more information.</p>
</td></tr>
<tr><td><code id="zones_+3A_zone_names">zone_names</code></td>
<td>
<p><code>character</code> names of the management zones. Defaults
to <code>NULL</code> which results in sequential integers.</p>
</td></tr>
<tr><td><code id="zones_+3A_feature_names">feature_names</code></td>
<td>
<p><code>character</code> names of the features zones. Defaults
to <code>NULL</code> which results in sequential integers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to store and organize data for use in a
conservation planning <code><a href="#topic+problem">problem()</a></code> that has multiple management
zones.
In all cases, the data for each zone is input as a separate argument.
The correct arguments depends on the type of planning unit data
used when building the conservation planning <code><a href="#topic+problem">problem()</a></code>.
</p>

<dl>
<dt><code><a href="#topic+problem">problem()</a></code> will have <code><a href="terra.html#topic+rast">terra::rast()</a></code> or <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> planning units</dt><dd>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object can be supplied to specify the expected amount of
each feature within each planning unit under each management zone.
Data for each zone should be specified as separate
arguments, and the data for each feature in a given zone are specified
in separate layers in a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object.
Note that all layers for a given zone must have missing (<code>NA</code>) values in
exactly the same cells.</p>
</dd>
<dt><code><a href="#topic+problem">problem()</a></code> will have <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> or <code>data.frame</code> planning units</dt><dd>
<p><code>character</code> vector containing column names can
be supplied to specify the expected amount of each feature under each
zone. Note that these columns must not contain any missing (<code>NA</code>) values.</p>
</dd>
<dt><code><a href="#topic+problem">problem()</a></code> will have <code><a href="sf.html#topic+sf">sf::st_sf()</a></code>, <code>data.frame</code>, or
<code>matrix</code> planning units</dt><dd>
<p><code>data.frame</code> object can be supplied to specify the
expected amount of each feature under each zone.
Following conventions used in <em>Marxan</em>, the
<code>data.frame</code> object should contain the following columns.
</p>

<dl>
<dt>pu</dt><dd><p><code>integer</code> planning unit identifier.</p>
</dd>
<dt>species</dt><dd><p><code>integer</code> feature identifier.</p>
</dd>
<dt>amount</dt><dd><p><code>numeric</code> amount of the feature in the
planning unit for a given zone.</p>
</dd>
</dl>

<p>Note that data for each zone are specified in a separate argument, and
the data contained in a single <code>data.frame</code> object should correspond to
a single zone. Also, note that data are not required for all
combinations of planning units, features, and zones. The expected amount of
features in planning units under management zones that are
missing from the table are assumed to be zero.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code><a href="#topic+Zones-class">Zones</a></code> object containing data for each zone, and
the feature and zone names.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+problem">problem()</a></code> for information on using this function to generate
a prioritization with multiple management zones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load planning unit data
sim_pu_raster &lt;- get_sim_pu_raster()

zone_1 &lt;- simulate_species(sim_pu_raster, 3)
zone_2 &lt;- simulate_species(sim_pu_raster, 3)

# create zones using two SpatRaster objects
# each object corresponds to a different zone and each layer corresponds to
# a different species
z &lt;- zones(
  zone_1, zone_2,
  zone_names = c("zone_1", "zone_2"),
  feature_names = c("feature_1", "feature_2", "feature_3")
)
print(z)

# plot the rasters for the first zone in the Zones object
plot(
 z[[1]],
 main = c("Zone 1 feature 1", "Zone 1 feature 2", "Zone 1 feature 3")
)

# note that the do.call function can also be used to create a Zones object
# this method for creating a Zones object can be helpful when there are many
# management zones
l &lt;- list(
  zone_1, zone_2,
  zone_names = c("zone_1", "zone_2"),
  feature_names = c("feature_1", "feature_2", "feature_3")
)
z &lt;- do.call(zones, l)
print(z)

# create zones using character vectors corresponding to column names
# of a data.frame or Spatial object that contain the amount
# of each species expected different management zones
z &lt;- zones(
  c("spp1_zone1", "spp2_zone1"),
  c("spp1_zone2", "spp2_zone2"),
  c("spp1_zone3", "spp2_zone3"),
  zone_names = c("zone1", "zone2", "zone3"),
  feature_names = c("spp1", "spp2")
)
print(z)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
