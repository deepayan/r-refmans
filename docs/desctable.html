<!DOCTYPE html><html><head><title>Help for package desctable</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {desctable}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ANOVA'><p>Wrapper for oneway.test(var.equal = T)</p></a></li>
<li><a href='#as.data.frame.desctable'><p>As.data.frame method for desctable</p></a></li>
<li><a href='#chisq.test'><p>Pearson's Chi-squared Test for Count Data</p></a></li>
<li><a href='#datatable'><p>Create an HTML table widget using the DataTables library</p></a></li>
<li><a href='#desc_output'><p>desc_output</p></a></li>
<li><a href='#desc_table'><p>Generate a statistics table</p></a></li>
<li><a href='#desc_tests'><p>Add tests to a desc_table</p></a></li>
<li><a href='#desctable'><p>Generate a statistics table</p></a></li>
<li><a href='#fisher.test'><p>Fisher's Exact Test for Count Data</p></a></li>
<li><a href='#flatten_desctable'><p>Flatten a desctable to a dataframe recursively</p></a></li>
<li><a href='#head_dataframe'><p>Build the header for dataframe</p></a></li>
<li><a href='#head_datatable'><p>Build the header for datatable</p></a></li>
<li><a href='#head_pander'><p>Build the header for pander</p></a></li>
<li><a href='#header'><p>Build header</p></a></li>
<li><a href='#headerList'><p>build a header list object</p></a></li>
<li><a href='#insert'><p>Insert a vector y inside another vector x at position</p></a></li>
<li><a href='#IQR'><p>Return the inter-quartile range</p></a></li>
<li><a href='#is.normal'><p>Test if distribution is normal</p></a></li>
<li><a href='#no.test'><p>No test</p></a></li>
<li><a href='#pander.desctable'><p>Pander method for desctable</p></a></li>
<li><a href='#parse_formula'><p>Parse a formula</p></a></li>
<li><a href='#percent'><p>Return the percentages for the levels of a factor</p></a></li>
<li><a href='#print.desctable'><p>Print method for desctable</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#set_desctable_class'><p>Set the &quot;desctable&quot; class to the passed object</p></a></li>
<li><a href='#statColumn'><p>Generate one statistic for all variables</p></a></li>
<li><a href='#statify'><p>Transform any function into a valid stat function for the table</p></a></li>
<li><a href='#stats_auto'><p>Function to create a list of statistics to use in desctable</p></a></li>
<li><a href='#stats_default'><p>Define a list of default statistics</p></a></li>
<li><a href='#statTable'><p>Generate the table of all statistics for all variables</p></a></li>
<li><a href='#subNames'><p>Create the subtables names</p></a></li>
<li><a href='#subTable'><p>Create a subtable in a grouped desctable</p></a></li>
<li><a href='#testColumn'><p>Create the pvalues column</p></a></li>
<li><a href='#testify'><p>Transform any test function into a valid test function for the table</p></a></li>
<li><a href='#tests_auto'><p>Function to choose a statistical test</p></a></li>
<li><a href='#varColumn'><p>Generate the variable column to display as row names</p></a></li>
<li><a href='#which.desctable'><p>Is the object possibly a desctable?</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Produce Descriptive and Comparative Tables Easily</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Easily create descriptive and comparative tables.
    It makes use and integrates directly with the tidyverse family of packages, and pipes.
    Tables are produced as (nested) dataframes for easy manipulation.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3), pander</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://desctable.github.io">https://desctable.github.io</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/desctable/desctable/issues">https://github.com/desctable/desctable/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, DT, htmltools, rlang, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, purrr, survival</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-24 11:45:17 UTC; maxx</td>
</tr>
<tr>
<td>Author:</td>
<td>Maxime Wack [aut, cre],
  Adrien Boukobza [aut],
  Yihui Xie [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maxime Wack &lt;maximewack@free.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-24 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ANOVA'>Wrapper for oneway.test(var.equal = T)</h2><span id='topic+ANOVA'></span>

<h3>Description</h3>

<p>Wrapper for oneway.test(var.equal = T)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANOVA(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ANOVA_+3A_formula">formula</code></td>
<td>
<p>An anova formula (<code>variable ~ grouping variable</code>)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+oneway.test">oneway.test</a></code>
</p>

<hr>
<h2 id='as.data.frame.desctable'>As.data.frame method for desctable</h2><span id='topic+as.data.frame.desctable'></span>

<h3>Description</h3>

<p>As.data.frame method for desctable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'desctable'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.desctable_+3A_x">x</code></td>
<td>
<p>A desctable</p>
</td></tr>
<tr><td><code id="as.data.frame.desctable_+3A_...">...</code></td>
<td>
<p>Additional as.data.frame parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flat dataframe
</p>

<hr>
<h2 id='chisq.test'>Pearson's Chi-squared Test for Count Data</h2><span id='topic+chisq.test'></span><span id='topic+chisq.test.default'></span><span id='topic+chisq.test.formula'></span>

<h3>Description</h3>

<p><code>chisq.test</code> performs chi-squared contingency table tests and goodness-of-fit tests, with an added method for formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chisq.test(x, y, correct, p, rescale.p, simulate.p.value, B)

## Default S3 method:
chisq.test(
  x,
  y = NULL,
  correct = TRUE,
  p = rep(1/length(x), length(x)),
  rescale.p = FALSE,
  simulate.p.value = FALSE,
  B = 2000
)

## S3 method for class 'formula'
chisq.test(
  x,
  y = NULL,
  correct = T,
  p = rep(1/length(x), length(x)),
  rescale.p = F,
  simulate.p.value = F,
  B = 2000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chisq.test_+3A_x">x</code></td>
<td>
<p>a numeric vector, or matrix, or formula of the form <code>lhs ~ rhs</code> where <code>lhs</code> and <code>rhs</code> are factors. <code>x</code> and <code>y</code> can also both be factors.</p>
</td></tr>
<tr><td><code id="chisq.test_+3A_y">y</code></td>
<td>
<p>a numeric vector; ignored if <code>x</code> is a matrix or a formula. If <code>x</code> is a factor, <code>y</code> should be a factor of the same length.</p>
</td></tr>
<tr><td><code id="chisq.test_+3A_correct">correct</code></td>
<td>
<p>a logical indicating whether to apply continuity
correction when computing the test statistic for 2 by 2 tables: one
half is subtracted from all <code class="reqn">|O - E|</code> differences; however, the
correction will not be bigger than the differences themselves.  No correction
is done if <code>simulate.p.value = TRUE</code>.</p>
</td></tr>
<tr><td><code id="chisq.test_+3A_p">p</code></td>
<td>
<p>a vector of probabilities of the same length of <code>x</code>.
An error is given if any entry of <code>p</code> is negative.</p>
</td></tr>
<tr><td><code id="chisq.test_+3A_rescale.p">rescale.p</code></td>
<td>
<p>a logical scalar; if TRUE then <code>p</code> is rescaled
(if necessary) to sum to 1.  If <code>rescale.p</code> is FALSE, and
<code>p</code> does not sum to 1, an error is given.</p>
</td></tr>
<tr><td><code id="chisq.test_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>a logical indicating whether to compute
p-values by Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="chisq.test_+3A_b">B</code></td>
<td>
<p>an integer specifying the number of replicates used in the
Monte Carlo test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a matrix with one row or column, or if <code>x</code> is a vector
and <code>y</code> is not given, then a _goodness-of-fit test_ is performed
(<code>x</code> is treated as a one-dimensional contingency table).  The
entries of <code>x</code> must be non-negative integers.  In this case, the
hypothesis tested is whether the population probabilities equal
those in <code>p</code>, or are all equal if <code>p</code> is not given.
</p>
<p>If <code>x</code> is a matrix with at least two rows and columns, it is taken
as a two-dimensional contingency table: the entries of <code>x</code> must be
non-negative integers.  Otherwise, <code>x</code> and <code>y</code> must be vectors or
factors of the same length; cases with missing values are removed,
the objects are coerced to factors, and the contingency table is
computed from these.  Then Pearson's chi-squared test is performed
of the null hypothesis that the joint distribution of the cell
counts in a 2-dimensional contingency table is the product of the
row and column marginals.
</p>
<p>If <code>simulate.p.value</code> is <code>FALSE</code>, the p-value is computed from the
asymptotic chi-squared distribution of the test statistic;
continuity correction is only used in the 2-by-2 case (if
<code>correct</code> is <code>TRUE</code>, the default).  Otherwise the p-value is
computed for a Monte Carlo test (Hope, 1968) with <code>B</code> replicates.
</p>
<p>In the contingency table case simulation is done by random
sampling from the set of all contingency tables with given
marginals, and works only if the marginals are strictly positive.
Continuity correction is never used, and the statistic is quoted
without it.  Note that this is not the usual sampling situation
assumed for the chi-squared test but rather that for Fisher's
exact test.
</p>
<p>In the goodness-of-fit case simulation is done by random sampling
from the discrete distribution specified by <code>p</code>, each sample being
of size <code>n = sum(x)</code>.  This simulation is done in R and may be
slow.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
statistic: the value the chi-squared test statistic.
</p>
<p>parameter: the degrees of freedom of the approximate chi-squared
distribution of the test statistic, <code>NA</code> if the p-value is
computed by Monte Carlo simulation.
</p>
<p>p.value: the p-value for the test.
</p>
<p>method: a character string indicating the type of test performed, and
whether Monte Carlo simulation or continuity correction was
used.
</p>
<p>data.name: a character string giving the name(s) of the data.
</p>
<p>observed: the observed counts.
</p>
<p>expected: the expected counts under the null hypothesis.
</p>
<p>residuals: the Pearson residuals, ‘(observed - expected) /
sqrt(expected)’.
</p>
<p>stdres: standardized residuals, <code>(observed - expected) / sqrt(V)</code>,
where <code>V</code> is the residual cell variance (Agresti, 2007,
section 2.4.5 for the case where <code>x</code> is a matrix, ‘n * p * (1
- p)’ otherwise).
</p>


<h3>Source</h3>

<p>The code for Monte Carlo simulation is a C translation of the Fortran algorithm of Patefield (1981).
</p>


<h3>References</h3>

<p>Hope, A. C. A. (1968) A simplified Monte Carlo significance test
procedure.  _J. Roy, Statist. Soc. B_ *30*, 582-598.
</p>
<p>Patefield, W. M. (1981) Algorithm AS159.  An efficient method of
generating r x c tables with given row and column totals.
_Applied Statistics_ *30*, 91-97.
</p>
<p>Agresti, A. (2007) _An Introduction to Categorical Data Analysis,
2nd ed._, New York: John Wiley &amp; Sons.  Page 38.
</p>


<h3>See Also</h3>

<p>For goodness-of-fit testing, notably of continuous distributions, <code><a href="stats.html#topic+ks.test">ks.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## From Agresti(2007) p.39
M &lt;- as.table(rbind(c(762, 327, 468), c(484, 239, 477)))
dimnames(M) &lt;- list(gender = c("F", "M"),
                    party = c("Democrat","Independent", "Republican"))
(Xsq &lt;- chisq.test(M))  # Prints test summary
Xsq$observed   # observed counts (same as M)
Xsq$expected   # expected counts under the null
Xsq$residuals  # Pearson residuals
Xsq$stdres     # standardized residuals


## Effect of simulating p-values
x &lt;- matrix(c(12, 5, 7, 7), ncol = 2)
chisq.test(x)$p.value           # 0.4233
chisq.test(x, simulate.p.value = TRUE, B = 10000)$p.value
                                # around 0.29!

## Testing for population probabilities
## Case A. Tabulated data
x &lt;- c(A = 20, B = 15, C = 25)
chisq.test(x)
chisq.test(as.table(x))             # the same
x &lt;- c(89,37,30,28,2)
p &lt;- c(40,20,20,15,5)
try(
chisq.test(x, p = p)                # gives an error
)
chisq.test(x, p = p, rescale.p = TRUE)
                                # works
p &lt;- c(0.40,0.20,0.20,0.19,0.01)
                                # Expected count in category 5
                                # is 1.86 &lt; 5 ==&gt; chi square approx.
chisq.test(x, p = p)            #               maybe doubtful, but is ok!
chisq.test(x, p = p, simulate.p.value = TRUE)

## Case B. Raw data
x &lt;- trunc(5 * runif(100))
chisq.test(table(x))            # NOT 'chisq.test(x)'!

###

## End(Not run)
</code></pre>

<hr>
<h2 id='datatable'>Create an HTML table widget using the DataTables library</h2><span id='topic+datatable'></span><span id='topic+datatable.default'></span><span id='topic+datatable.desctable'></span>

<h3>Description</h3>

<p>This function creates an HTML widget to display rectangular data (a matrix or data frame) using the JavaScript library DataTables, with a method for <code>desctable</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datatable(data, ...)

## Default S3 method:
datatable(
  data,
  options = list(),
  class = "display",
  callback = DT::JS("return table;"),
  caption = NULL,
  filter = c("none", "bottom", "top"),
  escape = TRUE,
  style = "default",
  width = NULL,
  height = NULL,
  elementId = NULL,
  fillContainer = getOption("DT.fillContainer", NULL),
  autoHideNavigation = getOption("DT.autoHideNavigation", NULL),
  selection = c("multiple", "single", "none"),
  extensions = list(),
  plugins = NULL,
  ...
)

## S3 method for class 'desctable'
datatable(
  data,
  options = list(paging = F, info = F, search = list(), dom = "Brtip", fixedColumns =
    T, fixedHeader = T, buttons = c("copy", "excel")),
  class = "display",
  callback = DT::JS("return table;"),
  caption = NULL,
  filter = c("none", "bottom", "top"),
  escape = FALSE,
  style = "default",
  width = NULL,
  height = NULL,
  elementId = NULL,
  fillContainer = getOption("DT.fillContainer", NULL),
  autoHideNavigation = getOption("DT.autoHideNavigation", NULL),
  selection = c("multiple", "single", "none"),
  extensions = c("FixedHeader", "FixedColumns", "Buttons"),
  plugins = NULL,
  rownames = F,
  digits = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datatable_+3A_data">data</code></td>
<td>
<p>a data object (either a matrix or a data frame)</p>
</td></tr>
<tr><td><code id="datatable_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>format</code>.</p>
</td></tr>
<tr><td><code id="datatable_+3A_options">options</code></td>
<td>
<p>a list of initialization options (see
<a href="https://datatables.net/reference/option/">https://datatables.net/reference/option/</a>); the character options
wrapped in <code><a href="htmlwidgets.html#topic+JS">JS</a>()</code> will be treated as literal
JavaScript code instead of normal character strings; you can also set
options globally via <code><a href="base.html#topic+options">options</a>(DT.options = list(...))</code>, and
global options will be merged into this <code>options</code> argument if set</p>
</td></tr>
<tr><td><code id="datatable_+3A_class">class</code></td>
<td>
<p>the CSS class(es) of the table; see
<a href="https://datatables.net/manual/styling/classes">https://datatables.net/manual/styling/classes</a></p>
</td></tr>
<tr><td><code id="datatable_+3A_callback">callback</code></td>
<td>
<p>the body of a JavaScript callback function with the argument
<code>table</code> to be applied to the DataTables instance (i.e. <code>table</code>)</p>
</td></tr>
<tr><td><code id="datatable_+3A_caption">caption</code></td>
<td>
<p>the table caption; a character vector or a tag object
generated from <code>htmltools::tags$caption()</code></p>
</td></tr>
<tr><td><code id="datatable_+3A_filter">filter</code></td>
<td>
<p>whether/where to use column filters; <code>none</code>: no filters;
<code>bottom/top</code>: put column filters at the bottom/top of the table; range
sliders are used to filter numeric/date/time columns, select lists are used
for factor columns, and text input boxes are used for character columns; if
you want more control over the styles of filters, you can provide a list to
this argument of the form <code>list(position = 'top', clear = TRUE, plain
= FALSE)</code>, where <code>clear</code> indicates whether you want the clear buttons
in the input boxes, and <code>plain</code> means if you want to use Bootstrap
form styles or plain text input styles for the text input boxes</p>
</td></tr>
<tr><td><code id="datatable_+3A_escape">escape</code></td>
<td>
<p>whether to escape HTML entities in the table: <code>TRUE</code> means
to escape the whole table, and <code>FALSE</code> means not to escape it;
alternatively, you can specify numeric column indices or column names to
indicate which columns to escape, e.g. <code>1:5</code> (the first 5 columns),
<code>c(1, 3, 4)</code>, or <code>c(-1, -3)</code> (all columns except the first and
third), or <code>c('Species', 'Sepal.Length')</code>; since the row names take
the first column to display, you should add the numeric column indices by
one when using <code>rownames</code></p>
</td></tr>
<tr><td><code id="datatable_+3A_style">style</code></td>
<td>
<p>either <code>'auto'</code>, <code>'default'</code>, <code>'bootstrap'</code>, or
<code>'bootstrap4'</code>. If <code>'auto'</code>, and a **bslib** theme is
currently active, then bootstrap styling is used in a way that &quot;just works&quot;
for the active theme. Otherwise,
<a href="https://datatables.net/manual/styling/classes">DataTables
<code>'default'</code> styling</a> is used. If set explicitly to <code>'bootstrap'</code>
or <code>'bootstrap4'</code>, one must take care to ensure Bootstrap's HTML
dependencies (as well as Bootswatch themes, if desired) are included on the
page. Note, when set explicitly, it's the user's responsibility to ensure
that only one unique 'style' value is used on the same page, if multiple
DT tables exist, as different styling resources may conflict with each other.</p>
</td></tr>
<tr><td><code id="datatable_+3A_width">width</code></td>
<td>
<p>Width/Height in pixels (optional, defaults to automatic
sizing)</p>
</td></tr>
<tr><td><code id="datatable_+3A_height">height</code></td>
<td>
<p>Width/Height in pixels (optional, defaults to automatic
sizing)</p>
</td></tr>
<tr><td><code id="datatable_+3A_elementid">elementId</code></td>
<td>
<p>An id for the widget (a random string by default).</p>
</td></tr>
<tr><td><code id="datatable_+3A_fillcontainer">fillContainer</code></td>
<td>
<p><code>TRUE</code> to configure the table to automatically fill
it's containing element. If the table can't fit fully into it's container
then vertical and/or horizontal scrolling of the table cells will occur.</p>
</td></tr>
<tr><td><code id="datatable_+3A_autohidenavigation">autoHideNavigation</code></td>
<td>
<p><code>TRUE</code> to automatically hide navigational UI
(only display the table body) when the number of total records is less
than the page size. Note, it only works on the client-side processing mode
and the 'pageLength' option should be provided explicitly.</p>
</td></tr>
<tr><td><code id="datatable_+3A_selection">selection</code></td>
<td>
<p>the row/column selection mode (single or multiple selection
or disable selection) when a table widget is rendered in a Shiny app;
alternatively, you can use a list of the form <code>list(mode = 'multiple',
selected = c(1, 3, 8), target = 'row', selectable = c(-2, -3))</code> to
pre-select rows and control the selectable range; the element
<code>target</code> in the list can be <code>'column'</code> to enable column
selection, or <code>'row+column'</code> to make it possible to select both rows
and columns (click on the footer to select columns), or <code>'cell'</code> to
select cells. See details section for more info.</p>
</td></tr>
<tr><td><code id="datatable_+3A_extensions">extensions</code></td>
<td>
<p>a character vector of the names of the DataTables
extensions (<a href="https://datatables.net/extensions/index">https://datatables.net/extensions/index</a>)</p>
</td></tr>
<tr><td><code id="datatable_+3A_plugins">plugins</code></td>
<td>
<p>a character vector of the names of DataTables plug-ins
(<a href="https://rstudio.github.io/DT/plugins.html">https://rstudio.github.io/DT/plugins.html</a>).  Note that only those
plugins supported by the <code>DT</code> package can be used here. You can see
the available plugins by calling <code>DT:::available_plugins()</code></p>
</td></tr>
<tr><td><code id="datatable_+3A_rownames">rownames</code></td>
<td>
<p><code>TRUE</code> (show row names) or <code>FALSE</code> (hide row names)
or a character vector of row names; by default, the row names are displayed
in the first column of the table if exist (not <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="datatable_+3A_digits">digits</code></td>
<td>
<p>the desired number of digits after the decimal
point (<code>format = "f"</code>) or <em>significant</em> digits
(<code>format = "g"</code>, <code>= "e"</code> or <code>= "fg"</code>).
</p>
<p>Default: 2 for integer, 4 for real numbers.  If less than 0,
the C default of 6 digits is used.  If specified as more than 50, 50
will be used with a warning unless <code>format = "f"</code> where it is
limited to typically 324. (Not more than 15&ndash;21 digits need be
accurate, depending on the OS and compiler used.  This limit is
just a precaution against segfaults in the underlying C runtime.)
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>You are recommended to escape the table content for security reasons (e.g. XSS attacks) when using this function in Shiny or any other dynamic web applications.
</p>


<h3>References</h3>

<p>See <a href="https://rstudio.github.io/DT/">https://rstudio.github.io/DT/</a> for the full documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DT)

# see the package vignette for examples and the link to website
vignette('DT', package = 'DT')

# some boring edge cases for testing purposes
m = matrix(nrow = 0, ncol = 5, dimnames = list(NULL, letters[1:5]))
datatable(m)  # zero rows
datatable(as.data.frame(m))

m = matrix(1, dimnames = list(NULL, 'a'))
datatable(m)  # one row and one column
datatable(as.data.frame(m))

m = data.frame(a = 1, b = 2, c = 3)
datatable(m)
datatable(as.matrix(m))

# dates
datatable(data.frame(
  date = seq(as.Date("2015-01-01"), by = "day", length.out = 5), x = 1:5
))
datatable(data.frame(x = Sys.Date()))
datatable(data.frame(x = Sys.time()))

###
</code></pre>

<hr>
<h2 id='desc_output'>desc_output</h2><span id='topic+desc_output'></span>

<h3>Description</h3>

<p>Output a desctable to the desired target format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc_output(desctable, target = c("df", "pander", "DT"), digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desc_output_+3A_desctable">desctable</code></td>
<td>
<p>The desctable to output</p>
</td></tr>
<tr><td><code id="desc_output_+3A_target">target</code></td>
<td>
<p>The desired target. One of &quot;df&quot;, &quot;pander&quot;, or &quot;DT&quot;.</p>
</td></tr>
<tr><td><code id="desc_output_+3A_digits">digits</code></td>
<td>
<p>The number of digits to display. The p values will be simplified under 1E-digits</p>
</td></tr>
<tr><td><code id="desc_output_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code>data.frame</code>, <code>pander::pander</code>, or <code>DT::datatable</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output a simple or grouped desctable to a different formats.
Currently available formats are</p>

<ul>
<li><p> data.frame (&quot;df&quot;)
</p>
</li>
<li><p> pander (&quot;pander&quot;)
</p>
</li>
<li><p> datatable (&quot;DT&quot;)
</p>
</li></ul>

<p>All numerical values will be rounded to the digits argument.
If statistical tests are presents, p values below 1E-digits will be replaced with &quot;&lt; 1E-digits&quot;
(eg. &quot;&lt; 0.01&quot; for values below 0.01 when digits = 2)
</p>


<h3>Value</h3>

<p>The output object (or corresponding side effect)
</p>


<h3>See Also</h3>

<p><code><a href="DT.html#topic+datatable">datatable</a></code>
</p>
<p><code><a href="pander.html#topic+pander">pander</a></code>
</p>
<p>Other desc_table core functions: 
<code><a href="#topic+desc_table">desc_table</a>()</code>,
<code><a href="#topic+desc_tests">desc_tests</a>()</code>
</p>

<hr>
<h2 id='desc_table'>Generate a statistics table</h2><span id='topic+desc_table'></span><span id='topic+desc_table.default'></span><span id='topic+desc_table.data.frame'></span><span id='topic+desc_table.grouped_df'></span>

<h3>Description</h3>

<p>Generate a statistics table with the chosen statistical functions, nested if called with a grouped dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc_table(data, ..., .auto, .labels)

## Default S3 method:
desc_table(data, ..., .auto, .labels)

## S3 method for class 'data.frame'
desc_table(data, ..., .labels = NULL, .auto = stats_auto)

## S3 method for class 'grouped_df'
desc_table(data, ..., .auto = stats_auto, .labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desc_table_+3A_data">data</code></td>
<td>
<p>The dataframe to analyze</p>
</td></tr>
<tr><td><code id="desc_table_+3A_...">...</code></td>
<td>
<p>A list of named statistics to apply to each element of the dataframe, or a function returning a list of named statistics</p>
</td></tr>
<tr><td><code id="desc_table_+3A_.auto">.auto</code></td>
<td>
<p>A function to automatically determine appropriate statistics</p>
</td></tr>
<tr><td><code id="desc_table_+3A_.labels">.labels</code></td>
<td>
<p>A named character vector of variable labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simple or grouped descriptive table
</p>


<h3>Stats</h3>

<p>The statistical functions to use in the table are passed as additional arguments.
If the argument is named (eg. <code>N = length</code>) the name will be used as the column title instead of the function
name (here, <strong>N</strong> instead of <strong>length</strong>).
</p>
<p>Any R function can be a statistical function, as long as it returns only one value when applied to a vector, or as
many values as there are levels in a factor, plus one.
</p>
<p>Users can also use <code>purrr::map</code>-like formulas as quick anonymous functions (eg. <code>Q1 = ~ quantile(., .25)</code> to get the first quantile in a
column named <strong>Q1</strong>)
</p>
<p>If no statistical function is given to <code>desc_table</code>, the <code>.auto</code> argument is used to provide a function
that automatically determines the most appropriate statistical functions to use based on the contents of the table.
</p>


<h3>Labels</h3>

<p><code>.labels</code> is a named character vector to provide &quot;pretty&quot; labels to variables.
</p>
<p>If given, the variable names for which there is a label will be replaced by their corresponding label.
</p>
<p>Not all variables need to have a label, and labels for non-existing variables are ignored.
</p>
<p>labels must be given in the form <code>c(unquoted_variable_name = "label")</code>
</p>


<h3>Output</h3>

<p>The output is either a dataframe in the case of a simple descriptive table,
or nested dataframes in the case of a comparative table.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stats_auto">stats_auto</a></code>
</p>
<p><code><a href="#topic+IQR">IQR</a></code>
</p>
<p><code><a href="#topic+percent">percent</a></code>
</p>
<p>Other desc_table core functions: 
<code><a href="#topic+desc_output">desc_output</a>()</code>,
<code><a href="#topic+desc_tests">desc_tests</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;%
  desc_table()

# Does the same as stats_auto here
iris %&gt;%
  desc_table("N"      = length,
             "Min"    = min,
             "Q1"     = ~quantile(., .25),
             "Med"    = median,
             "Mean"   = mean,
             "Q3"     = ~quantile(., .75),
             "Max"    = max,
             "sd"     = sd,
             "IQR"    = IQR)

# With grouping on a factor
iris %&gt;%
  group_by(Species) %&gt;%
  desc_table(.auto = stats_auto)
</code></pre>

<hr>
<h2 id='desc_tests'>Add tests to a desc_table</h2><span id='topic+desc_tests'></span>

<h3>Description</h3>

<p>Add test statistics to a grouped desc_table, with the tests specified as <code>variable = test</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc_tests(desctable, .auto = tests_auto, .default = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desc_tests_+3A_desctable">desctable</code></td>
<td>
<p>A desc_table</p>
</td></tr>
<tr><td><code id="desc_tests_+3A_.auto">.auto</code></td>
<td>
<p>A function to automatically determine the appropriate tests</p>
</td></tr>
<tr><td><code id="desc_tests_+3A_.default">.default</code></td>
<td>
<p>A default fallback test</p>
</td></tr>
<tr><td><code id="desc_tests_+3A_...">...</code></td>
<td>
<p>A list of statistical tests associated to variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A desc_table with tests
</p>


<h3>Tests</h3>

<p>The statistical test functions to use in the table are passed as additional named arguments. Tests must be preceded
by a formula tilde (<code>~</code>).
<code>name = ~test</code> will apply test <code>test</code> to variable <code>name</code>.
</p>
<p>Any R test function can be used, as long as it returns an object containing a <code>p.value</code> element, which is the
case for most tests returning an object of class  <code>htest</code>.
</p>
<p>Users can also use <code>purrr::map</code>-like formulas as quick anonymous functions (eg. <code>~ t.test(., var.equal = T)</code> to
compute a t test without the Welch correction.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tests_auto">tests_auto</a></code>
</p>
<p><code><a href="#topic+no.test">no.test</a></code>
</p>
<p><code><a href="#topic+ANOVA">ANOVA</a></code>
</p>
<p>Other desc_table core functions: 
<code><a href="#topic+desc_output">desc_output</a>()</code>,
<code><a href="#topic+desc_table">desc_table</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;%
  group_by(Species) %&gt;%
  desc_table() %&gt;%
  desc_tests(Sepal.Length = ~kruskal.test,
             Sepal.Width  = ~oneway.test,
             Petal.Length = ~oneway.test(., var.equal = T),
             Petal.Length = ~oneway.test(., var.equal = F))
</code></pre>

<hr>
<h2 id='desctable'>Generate a statistics table</h2><span id='topic+desctable'></span><span id='topic+desctable.default'></span><span id='topic+desctable.grouped_df'></span>

<h3>Description</h3>

<p>Generate a statistics table with the chosen statistical functions, and tests if given a <code>"grouped"</code> dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desctable(data, stats, tests, labels)

## Default S3 method:
desctable(data, stats = stats_auto, tests, labels = NULL)

## S3 method for class 'grouped_df'
desctable(data, stats = stats_auto, tests = tests_auto, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desctable_+3A_data">data</code></td>
<td>
<p>The dataframe to analyze</p>
</td></tr>
<tr><td><code id="desctable_+3A_stats">stats</code></td>
<td>
<p>A list of named statistics to apply to each element of the dataframe, or a function returning a list of named statistics</p>
</td></tr>
<tr><td><code id="desctable_+3A_tests">tests</code></td>
<td>
<p>A list of statistical tests to use when calling desctable with a grouped_df</p>
</td></tr>
<tr><td><code id="desctable_+3A_labels">labels</code></td>
<td>
<p>A named character vector of labels to use instead of variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A desctable object, which prints to a table of statistics for all variables
</p>


<h3>Labels</h3>

<p>labels is an option named character vector used to make the table prettier.
</p>
<p>If given, the variable names for which there is a label will be replaced by their corresponding label.
</p>
<p>Not all variables need to have a label, and labels for non-existing variables are ignored.
</p>
<p>labels must be given in the form c(unquoted_variable_name = &quot;label&quot;)
</p>


<h3>Stats</h3>

<p>The stats can be a function which takes a dataframe and returns a list of statistical functions to use.
</p>
<p>stats can also be a named list of statistical functions, or purrr::map like formulas.
</p>
<p>The names will be used as column names in the resulting table. If an element of the list is a function, it will be used as-is for the stats.
</p>


<h3>Tests</h3>

<p>The tests can be a function which takes a variable and a grouping variable, and returns an appropriate statistical test to use in that case.
</p>
<p>tests can also be a named list of statistical test functions, associating the name of a variable in the data and a test to use specifically for that variable.
</p>
<p>That test name must be expressed as a single-term formula (e.g. <code>~t.test</code>), or a purrr::map like formula
(e.g. <code>~t.test(., var.equal = T)</code>). You don't have to specify tests for all the variables: a default test for
all other variables can be defined with the name <code>.default</code>, and an automatic test can be defined with the name <code>.auto</code>.
</p>
<p>If data is a grouped dataframe (using <code>group_by</code>), subtables are created and statistic tests are performed over each sub-group.
</p>


<h3>Output</h3>

<p>The output is a desctable object, which is a list of named dataframes that can be further manipulated. Methods for printing, using in <span class="pkg">pander</span> and <span class="pkg">DT</span> are present. Printing reduces the object to a dataframe.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stats_auto">stats_auto</a></code>
</p>
<p><code><a href="#topic+tests_auto">tests_auto</a></code>
</p>
<p><code><a href="#topic+print.desctable">print.desctable</a></code>
</p>
<p><code><a href="#topic+pander.desctable">pander.desctable</a></code>
</p>
<p><code><a href="#topic+datatable.desctable">datatable.desctable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;%
  desctable()

# Does the same as stats_auto here
iris %&gt;%
  desctable(stats = list("N"      = length,
                         "Mean"   = ~ if (is.normal(.)) mean(.),
                         "sd"     = ~ if (is.normal(.)) sd(.),
                         "Med"    = stats::median,
                         "IQR"    = ~ if(!is.factor(.)) IQR(.)))

# With labels
mtcars %&gt;% desctable(labels = c(hp  = "Horse Power",
                                cyl = "Cylinders",
                                mpg = "Miles per gallon"))

# With grouping on a factor
iris %&gt;%
  group_by(Species) %&gt;%
  desctable(stats = stats_default)

# With nested grouping, on arbitrary variables
mtcars %&gt;%
  group_by(vs, cyl) %&gt;%
  desctable()

# With grouping on a condition, and choice of tests
iris %&gt;%
  group_by(Petal.Length &gt; 5) %&gt;%
  desctable(tests = list(.auto = tests_auto, Species = ~chisq.test))
</code></pre>

<hr>
<h2 id='fisher.test'>Fisher's Exact Test for Count Data</h2><span id='topic+fisher.test'></span><span id='topic+fisher.test.default'></span><span id='topic+fisher.test.formula'></span>

<h3>Description</h3>

<p>Performs Fisher's exact test for testing the null of independence
of rows and columns in a contingency table with fixed marginals, or with a formula expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher.test(
  x,
  y,
  workspace,
  hybrid,
  control,
  or,
  alternative,
  conf.int,
  conf.level,
  simulate.p.value,
  B
)

## Default S3 method:
fisher.test(x, ...)

## S3 method for class 'formula'
fisher.test(
  x,
  y = NULL,
  workspace = 200000,
  hybrid = F,
  control = list(),
  or = 1,
  alternative = "two.sided",
  conf.int = T,
  conf.level = 0.95,
  simulate.p.value = F,
  B = 2000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fisher.test_+3A_x">x</code></td>
<td>
<p>either a two-dimensional contingency table in matrix form, a factor object, or a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code> and <code>rhs</code> are factors.</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_y">y</code></td>
<td>
<p>a factor object; ignored if <code>x</code> is a matrix or a formula.</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_workspace">workspace</code></td>
<td>
<p>an integer specifying the size of the workspace
used in the network algorithm.  In units of 4 bytes.  Only used for
non-simulated p-values larger than <code class="reqn">2 \times 2</code> tables.
Since <span class="rlang"><b>R</b></span> version 3.5.0, this also increases the internal stack size
which allows larger problems to be solved, however sometimes needing
hours.  In such cases, <code>simulate.p.values=TRUE</code> may be more
reasonable.</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_hybrid">hybrid</code></td>
<td>
<p>a logical. Only used for larger than <code class="reqn">2 \times 2</code>
tables, in which cases it indicates whether the exact probabilities
(default) or a hybrid approximation thereof should be computed.</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_control">control</code></td>
<td>
<p>a list with named components for low level algorithm
control.  At present the only one used is <code>"mult"</code>, a positive
integer <code class="reqn">\ge 2</code> with default 30 used only for larger than
<code class="reqn">2 \times 2</code> tables.  This says how many times as much
space should be allocated to paths as to keys: see file
&lsquo;<span class="file">fexact.c</span>&rsquo; in the sources of this package.</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_or">or</code></td>
<td>
<p>the hypothesized odds ratio.  Only used in the
<code class="reqn">2 \times 2</code> case.</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be
one of <code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>.
You can specify just the initial letter.  Only used in the
<code class="reqn">2 \times 2</code> case.</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_conf.int">conf.int</code></td>
<td>
<p>logical indicating if a confidence interval for the
odds ratio in a <code class="reqn">2 \times 2</code> table should be
computed (and returned).</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for the returned confidence
interval.  Only used in the <code class="reqn">2 \times 2</code> case and if
<code>conf.int = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>a logical indicating whether to compute
p-values by Monte Carlo simulation, in larger than <code class="reqn">2 \times
      2</code> tables.</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_b">B</code></td>
<td>
<p>an integer specifying the number of replicates used in the
Monte Carlo test.</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_...">...</code></td>
<td>
<p>additional params to feed to original fisher.test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a matrix, it is taken as a two-dimensional contingency
table, and hence its entries should be nonnegative integers.
Otherwise, both <code>x</code> and <code>y</code> must be vectors of the same length.
Incomplete cases are removed, the vectors are coerced into factor
objects, and the contingency table is computed from these.
</p>
<p>For 2 by 2 cases, p-values are obtained directly using the
(central or non-central) hypergeometric distribution. Otherwise,
computations are based on a C version of the FORTRAN subroutine
FEXACT which implements the network developed by Mehta and Patel
(1986) and improved by Clarkson, Fan and Joe (1993).  The FORTRAN
code can be obtained from <a href="http://www.netlib.org/toms/643">http://www.netlib.org/toms/643</a>.
Note this fails (with an error message) when the entries of the
table are too large.  (It transposes the table if necessary so it
has no more rows than columns.  One constraint is that the product
of the row marginals be less than 2^31 - 1.)
</p>
<p>For 2 by 2 tables, the null of conditional independence is
equivalent to the hypothesis that the odds ratio equals one.
<code>Exact</code> inference can be based on observing that in general, given
all marginal totals fixed, the first element of the contingency
table has a non-central hypergeometric distribution with
non-centrality parameter given by the odds ratio (Fisher, 1935).
The alternative for a one-sided test is based on the odds ratio,
so <code>alternative = "greater"</code> is a test of the odds ratio being
bigger than <code>or</code>.
</p>
<p>Two-sided tests are based on the probabilities of the tables, and
take as <code>more extreme</code> all tables with probabilities less than or
equal to that of the observed table, the p-value being the sum of
such probabilities.
</p>
<p>For larger than 2 by 2 tables and <code>hybrid = TRUE</code>, asymptotic
chi-squared probabilities are only used if the ‘Cochran
conditions’ are satisfied, that is if no cell has count zero, and
more than 80
exact calculation is used.
</p>
<p>Simulation is done conditional on the row and column marginals,
and works only if the marginals are strictly positive.  (A C
translation of the algorithm of Patefield (1981) is used.)
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<p>p.value: the p-value of the test.
</p>
<p>conf.int: a confidence interval for the odds ratio.  Only present in
the 2 by 2 case and if argument <code>conf.int = TRUE</code>.
</p>
<p>estimate: an estimate of the odds ratio.  Note that the _conditional_
Maximum Likelihood Estimate (MLE) rather than the
unconditional MLE (the sample odds ratio) is used.  Only
present in the 2 by 2 case.
</p>
<p>null.value: the odds ratio under the null, <code>or</code>.  Only present in the 2
by 2 case.
</p>
<p>alternative: a character string describing the alternative hypothesis.
</p>
<p>method: the character string <code>"Fisher's Exact Test for Count Data"</code>.
</p>
<p>data.name: a character string giving the names of the data.
</p>


<h3>References</h3>

<p>Agresti, A. (1990) _Categorical data analysis_.  New York: Wiley.
Pages 59-66.
</p>
<p>Agresti, A. (2002) _Categorical data analysis_. Second edition.
New York: Wiley.  Pages 91-101.
</p>
<p>Fisher, R. A. (1935) The logic of inductive inference.  _Journal
of the Royal Statistical Society Series A_ *98*, 39-54.
</p>
<p>Fisher, R. A. (1962) Confidence limits for a cross-product ratio.
_Australian Journal of Statistics_ *4*, 41.
</p>
<p>Fisher, R. A. (1970) _Statistical Methods for Research Workers._
Oliver &amp; Boyd.
</p>
<p>Mehta, C. R. and Patel, N. R. (1986) Algorithm 643. FEXACT: A
Fortran subroutine for Fisher's exact test on unordered r*c
contingency tables.  _ACM Transactions on Mathematical Software_,
*12*, 154-161.
</p>
<p>Clarkson, D. B., Fan, Y. and Joe, H. (1993) A Remark on Algorithm
643: FEXACT: An Algorithm for Performing Fisher's Exact Test in r
x c Contingency Tables.  _ACM Transactions on Mathematical
Software_, *19*, 484-488.
</p>
<p>Patefield, W. M. (1981) Algorithm AS159.  An efficient method of
generating r x c tables with given row and column totals.
_Applied Statistics_ *30*, 91-97.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chisq.test">chisq.test</a></code>
</p>
<p><code>fisher.exact</code> in package <span class="pkg">kexact2x2</span> for alternative
interpretations of two-sided tests and confidence intervals for 2
by 2 tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Agresti (1990, p. 61f; 2002, p. 91) Fisher's Tea Drinker
## A British woman claimed to be able to distinguish whether milk or
##  tea was added to the cup first.  To test, she was given 8 cups of
##  tea, in four of which milk was added first.  The null hypothesis
##  is that there is no association between the true order of pouring
##  and the woman's guess, the alternative that there is a positive
##  association (that the odds ratio is greater than 1).
TeaTasting &lt;-
matrix(c(3, 1, 1, 3),
       nrow = 2,
       dimnames = list(Guess = c("Milk", "Tea"),
                       Truth = c("Milk", "Tea")))
fisher.test(TeaTasting, alternative = "greater")
## =&gt; p = 0.2429, association could not be established

## Fisher (1962, 1970), Criminal convictions of like-sex twins
Convictions &lt;-
matrix(c(2, 10, 15, 3),
       nrow = 2,
       dimnames =
       list(c("Dizygotic", "Monozygotic"),
            c("Convicted", "Not convicted")))
Convictions
fisher.test(Convictions, alternative = "less")
fisher.test(Convictions, conf.int = FALSE)
fisher.test(Convictions, conf.level = 0.95)$conf.int
fisher.test(Convictions, conf.level = 0.99)$conf.int

## A r x c table  Agresti (2002, p. 57) Job Satisfaction
Job &lt;- matrix(c(1,2,1,0, 3,3,6,1, 10,10,14,9, 6,7,12,11), 4, 4,
dimnames = list(income = c("&lt; 15k", "15-25k", "25-40k", "&gt; 40k"),
                satisfaction = c("VeryD", "LittleD", "ModerateS", "VeryS")))
fisher.test(Job)
fisher.test(Job, simulate.p.value = TRUE, B = 1e5)

###

## End(Not run)
</code></pre>

<hr>
<h2 id='flatten_desctable'>Flatten a desctable to a dataframe recursively</h2><span id='topic+flatten_desctable'></span>

<h3>Description</h3>

<p>Flatten a desctable to a dataframe recursively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_desctable(desctable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_desctable_+3A_desctable">desctable</code></td>
<td>
<p>A desctable object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flat dataframe
</p>

<hr>
<h2 id='head_dataframe'>Build the header for dataframe</h2><span id='topic+head_dataframe'></span>

<h3>Description</h3>

<p>Build the header for dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head_dataframe(head)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_dataframe_+3A_head">head</code></td>
<td>
<p>A headerList object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A names vector
</p>

<hr>
<h2 id='head_datatable'>Build the header for datatable</h2><span id='topic+head_datatable'></span>

<h3>Description</h3>

<p>Build the header for datatable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head_datatable(head)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_datatable_+3A_head">head</code></td>
<td>
<p>A headerList object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An htmltools$tags object containing the header
</p>

<hr>
<h2 id='head_pander'>Build the header for pander</h2><span id='topic+head_pander'></span>

<h3>Description</h3>

<p>Build the header for pander
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head_pander(head)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_pander_+3A_head">head</code></td>
<td>
<p>A headerList object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A names vector
</p>

<hr>
<h2 id='header'>Build header</h2><span id='topic+header'></span>

<h3>Description</h3>

<p>Take a desctable object and create a suitable header for the mentionned output.
Output can be one of &quot;pander&quot;, &quot;datatable&quot;, or &quot;dataframe&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>header(desctable, output = c("pander", "datatable", "dataframe"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="header_+3A_desctable">desctable</code></td>
<td>
<p>A desctable object</p>
</td></tr>
<tr><td><code id="header_+3A_output">output</code></td>
<td>
<p>An output format for the header</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A header object in the output format
</p>

<hr>
<h2 id='headerList'>build a header list object</h2><span id='topic+headerList'></span>

<h3>Description</h3>

<p>build a header list object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headerList(desctable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="headerList_+3A_desctable">desctable</code></td>
<td>
<p>a desctable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a nested list of headers with colspans
</p>

<hr>
<h2 id='insert'>Insert a vector y inside another vector x at position</h2><span id='topic+insert'></span>

<h3>Description</h3>

<p>The vectors in the y list will be inserted
at positions respectively *after* the x[position] element of x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert(x, y, position)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_+3A_x">x</code></td>
<td>
<p>A vector to be inserted into</p>
</td></tr>
<tr><td><code id="insert_+3A_y">y</code></td>
<td>
<p>A vector or list of vectors to insert into x</p>
</td></tr>
<tr><td><code id="insert_+3A_position">position</code></td>
<td>
<p>The position / vector of positions to insert vector(s) y in vector x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The combined vector
</p>

<hr>
<h2 id='IQR'>Return the inter-quartile range</h2><span id='topic+IQR'></span>

<h3>Description</h3>

<p>Safe version of IQR for statify
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IQR(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IQR_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The IQR
</p>

<hr>
<h2 id='is.normal'>Test if distribution is normal</h2><span id='topic+is.normal'></span>

<h3>Description</h3>

<p>Test if distribution is normal.
The condition for normality is length &gt; 30 and non-significant Shapiro-Wilks test with p &gt; .1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.normal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.normal_+3A_x">x</code></td>
<td>
<p>A numerical vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean
</p>

<hr>
<h2 id='no.test'>No test</h2><span id='topic+no.test'></span>

<h3>Description</h3>

<p>An empty test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>no.test(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="no.test_+3A_formula">formula</code></td>
<td>
<p>A formula</p>
</td></tr>
</table>

<hr>
<h2 id='pander.desctable'>Pander method for desctable</h2><span id='topic+pander.desctable'></span>

<h3>Description</h3>

<p>Pander method to output a desctable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'desctable'
pander(
  x = NULL,
  digits = 2,
  justify = "left",
  missing = "",
  keep.line.breaks = T,
  split.tables = Inf,
  emphasize.rownames = F,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pander.desctable_+3A_x">x</code></td>
<td>
<p>A desctable</p>
</td></tr>
<tr><td><code id="pander.desctable_+3A_digits">digits</code></td>
<td>
<p>passed to <code>format</code>. Can be a vector specifying values for each column (has to be the same length as number of columns).</p>
</td></tr>
<tr><td><code id="pander.desctable_+3A_justify">justify</code></td>
<td>
<p>defines alignment in cells passed to <code>format</code>. Can be <code>left</code>, <code>right</code> or <code>centre</code>, which latter can be also spelled as <code>center</code>. Defaults to <code>centre</code>. Can be abbreviated to a string consisting of the letters <code>l</code>, <code>c</code> and <code>r</code> (e.g. 'lcr' instead of c('left', 'centre', 'right').</p>
</td></tr>
<tr><td><code id="pander.desctable_+3A_missing">missing</code></td>
<td>
<p>string to replace missing values</p>
</td></tr>
<tr><td><code id="pander.desctable_+3A_keep.line.breaks">keep.line.breaks</code></td>
<td>
<p>(default: <code>FALSE</code>) if to keep or remove line breaks from cells in a table</p>
</td></tr>
<tr><td><code id="pander.desctable_+3A_split.tables">split.tables</code></td>
<td>
<p>where to split wide tables to separate tables. The default value (<code>80</code>) suggests the conventional number of characters used in a line, feel free to change (e.g. to <code>Inf</code> to disable this feature) if you are not using a VT100 terminal any more :)</p>
</td></tr>
<tr><td><code id="pander.desctable_+3A_emphasize.rownames">emphasize.rownames</code></td>
<td>
<p>boolean (default: <code>TRUE</code>) if row names should be highlighted</p>
</td></tr>
<tr><td><code id="pander.desctable_+3A_...">...</code></td>
<td>
<p>unsupported extra arguments directly placed into <code>/dev/null</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>pandoc.table</code>, with some default parameters (<code>digits = 2</code>, <code>justify = "left"</code>, <code>missing = ""</code>, <code>keep.line.breaks = T</code>, <code>split.tables = Inf</code>, and <code>emphasize.rownames = F</code>), that you can override if needed.
</p>


<h3>See Also</h3>

<p><code>pandoc.table</code>
</p>

<hr>
<h2 id='parse_formula'>Parse a formula</h2><span id='topic+parse_formula'></span>

<h3>Description</h3>

<p>Parse a formula defining the conditions to pick a stat/test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_formula(x, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_formula_+3A_x">x</code></td>
<td>
<p>The variable to test it on</p>
</td></tr>
<tr><td><code id="parse_formula_+3A_f">f</code></td>
<td>
<p>A formula to parse</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parse a formula defining the conditions to pick a stat/test
and return the function to use.
The formula is to be given in the form of
conditional ~ T | F
and conditions can be nested such as
conditional1 ~ (conditional2 ~ T | F) | F
The FALSE option can be omitted, and the TRUE can be replaced with NA
</p>


<h3>Value</h3>

<p>A function to use as a stat/test
</p>

<hr>
<h2 id='percent'>Return the percentages for the levels of a factor</h2><span id='topic+percent'></span>

<h3>Description</h3>

<p>Return a compatible vector of length nlevels(x) + 1
to print the percentages of each level of a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percent_+3A_x">x</code></td>
<td>
<p>A factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nlevels(x) + 1 length vector of percentages
</p>

<hr>
<h2 id='print.desctable'>Print method for desctable</h2><span id='topic+print.desctable'></span>

<h3>Description</h3>

<p>Print method for desctable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'desctable'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.desctable_+3A_x">x</code></td>
<td>
<p>A desctable</p>
</td></tr>
<tr><td><code id="print.desctable_+3A_...">...</code></td>
<td>
<p>Additional print parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flat dataframe
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+pander'></span><span id='topic++25+3E+25'></span><span id='topic+group_by'></span><span id='topic++21+21+21'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code></p>
</dd>
<dt>pander</dt><dd><p><code><a href="pander.html#topic+pander">pander</a></code></p>
</dd>
<dt>rlang</dt><dd><p><code><a href="rlang.html#topic+splice-operator">!!!</a></code></p>
</dd>
</dl>

<hr>
<h2 id='set_desctable_class'>Set the &quot;desctable&quot; class to the passed object</h2><span id='topic+set_desctable_class'></span>

<h3>Description</h3>

<p>Set the &quot;desctable&quot; class to the passed object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_desctable_class(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_desctable_class_+3A_x">x</code></td>
<td>
<p>Object to set the &quot;desctable&quot; class to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object with the class &quot;desctable&quot;
</p>

<hr>
<h2 id='statColumn'>Generate one statistic for all variables</h2><span id='topic+statColumn'></span>

<h3>Description</h3>

<p>Use one stat function (made safe using statify) on all the data
to produce a single statistics column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statColumn(stat, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statColumn_+3A_stat">stat</code></td>
<td>
<p>The statistic to use</p>
</td></tr>
<tr><td><code id="statColumn_+3A_data">data</code></td>
<td>
<p>The dataframe to apply the statistic to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result is either a numeric vector, or a character vector if
the content of the column is not made entirely of numbers.
</p>


<h3>Value</h3>

<p>A vector for one statistic column
</p>

<hr>
<h2 id='statify'>Transform any function into a valid stat function for the table</h2><span id='topic+statify'></span>

<h3>Description</h3>

<p>Transform a function into a valid stat function for the table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statify(x, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statify_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="statify_+3A_f">f</code></td>
<td>
<p>The function to try to apply, or a formula combining two functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NA values are removed from the data
</p>
<p>Applying the function on a numerical vector should return one value
</p>
<p>Applying the function on a factor should return nlevels + 1 value, or one value per factor level
</p>
<p>See <code>parse_formula</code> for the usage for formulaes.
</p>


<h3>Value</h3>

<p>The results for the function applied on the vector, compatible with the format of the result table
</p>

<hr>
<h2 id='stats_auto'>Function to create a list of statistics to use in desctable</h2><span id='topic+stats_auto'></span>

<h3>Description</h3>

<p>This function takes a dataframe as argument and returns a list of statistcs in the form accepted by desctable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stats_auto(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stats_auto_+3A_data">data</code></td>
<td>
<p>The dataframe to apply the statistic to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can define your own automatic function, as long as it takes a dataframe as argument and returns a list of functions, or formulas defining conditions to use a stat function.
</p>


<h3>Value</h3>

<p>A list of statistics to use, assessed from the content of the dataframe
</p>

<hr>
<h2 id='stats_default'>Define a list of default statistics</h2><span id='topic+stats_default'></span><span id='topic+stats_normal'></span><span id='topic+stats_nonnormal'></span>

<h3>Description</h3>

<p>Define a list of default statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stats_default(data)

stats_normal(data)

stats_nonnormal(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stats_default_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of statistical functions
</p>

<hr>
<h2 id='statTable'>Generate the table of all statistics for all variables</h2><span id='topic+statTable'></span>

<h3>Description</h3>

<p>If stats is a list of functions or purrr::map like formulas, use them.
If it is a single function, use it with the entire data as
its argument to produce a list of statistical functions to use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statTable(data, stats)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statTable_+3A_data">data</code></td>
<td>
<p>The dataframe to apply the statistic to</p>
</td></tr>
<tr><td><code id="statTable_+3A_stats">stats</code></td>
<td>
<p>A list of named statistics to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of all statistics for all variables
</p>

<hr>
<h2 id='subNames'>Create the subtables names</h2><span id='topic+subNames'></span>

<h3>Description</h3>

<p>Create the subtables names, as
factor: level (n=sub-group length)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subNames(grp, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subNames_+3A_grp">grp</code></td>
<td>
<p>Grouping factor</p>
</td></tr>
<tr><td><code id="subNames_+3A_df">df</code></td>
<td>
<p>Dataframe containing the grouping factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the names for the subtables
</p>

<hr>
<h2 id='subTable'>Create a subtable in a grouped desctable</h2><span id='topic+subTable'></span>

<h3>Description</h3>

<p>Create a subtable in a grouped desctable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subTable(df, stats, tests, grps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subTable_+3A_df">df</code></td>
<td>
<p>Dataframe to use</p>
</td></tr>
<tr><td><code id="subTable_+3A_stats">stats</code></td>
<td>
<p>Stats list/function to use</p>
</td></tr>
<tr><td><code id="subTable_+3A_tests">tests</code></td>
<td>
<p>Tests list/function to use</p>
</td></tr>
<tr><td><code id="subTable_+3A_grps">grps</code></td>
<td>
<p>List of symbols for grouping factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list of statTables and testColumns
</p>

<hr>
<h2 id='testColumn'>Create the pvalues column</h2><span id='topic+testColumn'></span>

<h3>Description</h3>

<p>Create the pvalues column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testColumn(df, tests, grp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testColumn_+3A_df">df</code></td>
<td>
<p>Dataframe to use for the tests</p>
</td></tr>
<tr><td><code id="testColumn_+3A_tests">tests</code></td>
<td>
<p>Test function or list of functions</p>
</td></tr>
<tr><td><code id="testColumn_+3A_grp">grp</code></td>
<td>
<p>Grouping factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of pvalues
</p>

<hr>
<h2 id='testify'>Transform any test function into a valid test function for the table</h2><span id='topic+testify'></span>

<h3>Description</h3>

<p>Transform a function into a valid test function for the table
Applying the function on a numerical vector should return one value
Applying the function on a factor should return nlevels + 1 value, or one value per factor level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testify(x, f, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testify_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="testify_+3A_f">f</code></td>
<td>
<p>The function to try to apply, or a formula combining two functions</p>
</td></tr>
<tr><td><code id="testify_+3A_group">group</code></td>
<td>
<p>Grouping factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results for the function applied on the vector, compatible with the format of the result table
</p>

<hr>
<h2 id='tests_auto'>Function to choose a statistical test</h2><span id='topic+tests_auto'></span>

<h3>Description</h3>

<p>This function takes a variable and a grouping variable as arguments, and returns a statistcal test to use, expressed as a single-term formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tests_auto(var, grp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tests_auto_+3A_var">var</code></td>
<td>
<p>The variable to test</p>
</td></tr>
<tr><td><code id="tests_auto_+3A_grp">grp</code></td>
<td>
<p>The variable for the groups</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses appropriate non-parametric tests depending on the number of levels (wilcoxon.test for two levels
and kruskal.test for more), and fisher.test with fallback on chisq.test on error for factors.
</p>


<h3>Value</h3>

<p>A statistical test function
</p>

<hr>
<h2 id='varColumn'>Generate the variable column to display as row names</h2><span id='topic+varColumn'></span>

<h3>Description</h3>

<p>Generates the variable column.
Replaces the variable names by their label if given in the named character vector labels, and inserts levels for factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varColumn(data, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varColumn_+3A_data">data</code></td>
<td>
<p>The dataframe to get the names from</p>
</td></tr>
<tr><td><code id="varColumn_+3A_labels">labels</code></td>
<td>
<p>The optional named character vector containing the keypairs var = &quot;Label&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>labels is an option named character vector used to make the table prettier.
If given, the variable names for which there is a label will be replaced by their corresponding label.
Not all variables need to have a label, and labels for non-existing variables are ignored.
</p>


<h3>Value</h3>

<p>A dataframe with one variable named &quot;Variables&quot;, a character vector of variable names/labels and levels
</p>

<hr>
<h2 id='which.desctable'>Is the object possibly a desctable?</h2><span id='topic+which.desctable'></span>

<h3>Description</h3>

<p>Check if the object is produced by desc_table.
Return a string:
- simple
- grouped
or FALSE if not a desctable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.desctable(desctable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.desctable_+3A_desctable">desctable</code></td>
<td>
<p>A potential desctable to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type of desctable or FALSE
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
