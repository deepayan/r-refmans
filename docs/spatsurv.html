<!DOCTYPE html><html><head><title>Help for package spatsurv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatsurv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.onAttach'><p>.onAttach function</p></a></li>
<li><a href='#allocate'><p>allocate function</p></a></li>
<li><a href='#alpha'><p>alpha function</p></a></li>
<li><a href='#B'><p>B function</p></a></li>
<li><a href='#basehazard'><p>basehazard function</p></a></li>
<li><a href='#basehazard.basehazardspec'><p>basehazard.basehazardspec function</p></a></li>
<li><a href='#baseHazST'><p>baseHazST function</p></a></li>
<li><a href='#baselinehazard'><p>baselinehazard function</p></a></li>
<li><a href='#baselinehazard_multiWay'><p>baselinehazard_multiWay function</p></a></li>
<li><a href='#betapriorGauss'><p>betapriorGauss function</p></a></li>
<li><a href='#blockDiag'><p>A function to</p></a></li>
<li><a href='#boxplotRisk'><p>boxplotRisk function</p></a></li>
<li><a href='#Bspline.construct'><p>Bspline.construct function</p></a></li>
<li><a href='#BsplineHaz'><p>BsplineHaz function</p></a></li>
<li><a href='#checkSurvivalData'><p>checkSurvivalData function</p></a></li>
<li><a href='#circulant'><p>circulant function</p></a></li>
<li><a href='#circulant.matrix'><p>circulant.matrix function</p></a></li>
<li><a href='#circulant.numeric'><p>circulant.numeric function</p></a></li>
<li><a href='#circulantij'><p>circulantij function</p></a></li>
<li><a href='#covmodel'><p>covmodel function</p></a></li>
<li><a href='#CSplot'><p>CSplot function</p></a></li>
<li><a href='#cumbasehazard'><p>cumbasehazard function</p></a></li>
<li><a href='#cumbasehazard.basehazardspec'><p>cumbasehazard.basehazardspec function</p></a></li>
<li><a href='#cumulativeBspline.construct'><p>cumulativeBspline.construct function</p></a></li>
<li><a href='#density_PP'><p>density_PP function</p></a></li>
<li><a href='#densityquantile'><p>densityquantile function</p></a></li>
<li><a href='#densityquantile_PP'><p>densityquantile_PP function</p></a></li>
<li><a href='#densityquantile.basehazardspec'><p>densityquantile.basehazardspec function</p></a></li>
<li><a href='#derivindepGaussianprior'><p>derivindepGaussianprior function</p></a></li>
<li><a href='#derivindepGaussianpriorST'><p>derivindepGaussianpriorST function</p></a></li>
<li><a href='#derivpsplineprior'><p>derivpsplineprior function</p></a></li>
<li><a href='#distinfo'><p>distinfo function</p></a></li>
<li><a href='#distinfo.basehazardspec'><p>distinfo.basehazardspec function</p></a></li>
<li><a href='#estimateY'><p>estimateY function</p></a></li>
<li><a href='#Et_PP'><p>Et_PP function</p></a></li>
<li><a href='#etapriorGauss'><p>etapriorGauss function</p></a></li>
<li><a href='#EvalCov'><p>EvalCov function</p></a></li>
<li><a href='#ExponentialCovFct'><p>ExponentialCovFct function</p></a></li>
<li><a href='#exponentialHaz'><p>exponentialHaz function</p></a></li>
<li><a href='#FFTgrid'><p>FFTgrid function</p></a></li>
<li><a href='#fixedpars'><p>fixedpars function</p></a></li>
<li><a href='#fixmatrix'><p>fixmatrix function</p></a></li>
<li><a href='#fixParHaz'><p>fixParHaz function</p></a></li>
<li><a href='#frailtylag1'><p>frailtylag1 function</p></a></li>
<li><a href='#fs'><p>London Fire Brigade property</p></a></li>
<li><a href='#fstimes'><p>London Fire Brigade response times to dwelling fires, 2009</p></a></li>
<li><a href='#gamma2risk'><p>gamma2risk function</p></a></li>
<li><a href='#GammafromY'><p>GammafromY function</p></a></li>
<li><a href='#GammaFromY_SPDE'><p>GammaFromY_SPDE function</p></a></li>
<li><a href='#gencens'><p>gencens function</p></a></li>
<li><a href='#getbb'><p>getbb function</p></a></li>
<li><a href='#getBbasis'><p>getBbasis function</p></a></li>
<li><a href='#getcov'><p>getcov function</p></a></li>
<li><a href='#getgrd'><p>getgrd function</p></a></li>
<li><a href='#getGrid'><p>getGrid function</p></a></li>
<li><a href='#getleneta'><p>getleneta function</p></a></li>
<li><a href='#getOptCellwidth'><p>getOptCellwidth function</p></a></li>
<li><a href='#getparranges'><p>getparranges function</p></a></li>
<li><a href='#getsurvdata'><p>getsurvdata function</p></a></li>
<li><a href='#gompertzHaz'><p>gompertzHaz function</p></a></li>
<li><a href='#gradbasehazard'><p>gradbasehazard function</p></a></li>
<li><a href='#gradbasehazard.basehazardspec'><p>gradbasehazard.basehazardspec function</p></a></li>
<li><a href='#gradcumbasehazard'><p>gradcumbasehazard function</p></a></li>
<li><a href='#gradcumbasehazard.basehazardspec'><p>gradcumbasehazard.basehazardspec function</p></a></li>
<li><a href='#grid2spdf'><p>grid2spdf function</p></a></li>
<li><a href='#grid2spix'><p>grid2spix function</p></a></li>
<li><a href='#grid2spts'><p>grid2spts function</p></a></li>
<li><a href='#gridY'><p>gridY function</p></a></li>
<li><a href='#gridY_polygonal'><p>gridY_polygonal function</p></a></li>
<li><a href='#guess_t'><p>guess_t function</p></a></li>
<li><a href='#hasNext'><p>generic hasNext method</p></a></li>
<li><a href='#hasNext.iter'><p>hasNext.iter function</p></a></li>
<li><a href='#hazard_PP'><p>hazard_PP function</p></a></li>
<li><a href='#hazardexceedance'><p>hazardexceedance function</p></a></li>
<li><a href='#hazardpars'><p>hazardpars function</p></a></li>
<li><a href='#hessbasehazard'><p>hessbasehazard function</p></a></li>
<li><a href='#hessbasehazard.basehazardspec'><p>hessbasehazard.basehazardspec function</p></a></li>
<li><a href='#hesscumbasehazard'><p>hesscumbasehazard function</p></a></li>
<li><a href='#hesscumbasehazard.basehazardspec'><p>hesscumbasehazard.basehazardspec function</p></a></li>
<li><a href='#imputationModel'><p>imputationModel function</p></a></li>
<li><a href='#Independent'><p>Independent function</p></a></li>
<li><a href='#indepGaussianprior'><p>indepGaussianprior function</p></a></li>
<li><a href='#indepGaussianpriorST'><p>indepGaussianpriorST function</p></a></li>
<li><a href='#inference.control'><p>inference.control function</p></a></li>
<li><a href='#insert'><p>insert function</p></a></li>
<li><a href='#invtransformweibull'><p>invtransformweibull function</p></a></li>
<li><a href='#is.burnin'><p>is this a burn-in iteration?</p></a></li>
<li><a href='#is.retain'><p>do we retain this iteration?</p></a></li>
<li><a href='#iteration'><p>iteration number</p></a></li>
<li><a href='#logPosterior'><p>logPosterior function</p></a></li>
<li><a href='#logPosterior_gridded'><p>logPosterior_gridded function</p></a></li>
<li><a href='#logPosterior_polygonal'><p>logPosterior_polygonal function</p></a></li>
<li><a href='#logPosterior_SPDE'><p>logPosterior_SPDE function</p></a></li>
<li><a href='#loop.mcmc'><p>loop over an iterator</p></a></li>
<li><a href='#makehamHaz'><p>makehamHaz function</p></a></li>
<li><a href='#maxlikparamPHsurv'><p>maxlikparamPHsurv function</p></a></li>
<li><a href='#MCE'><p>MCE function</p></a></li>
<li><a href='#mcmcLoop'><p>iterator for MCMC loops</p></a></li>
<li><a href='#mcmcpars'><p>mcmcpars function</p></a></li>
<li><a href='#mcmcPriors'><p>mcmcPriors function</p></a></li>
<li><a href='#mcmcProgressNone'><p>null progress monitor</p></a></li>
<li><a href='#mcmcProgressPrint'><p>printing progress monitor</p></a></li>
<li><a href='#mcmcProgressTextBar'><p>text bar progress monitor</p></a></li>
<li><a href='#midpts'><p>midpts function</p></a></li>
<li><a href='#multiWayHaz'><p>multiWayHaz function</p></a></li>
<li><a href='#neighLocs'><p>neighLocs function</p></a></li>
<li><a href='#neighOrder'><p>neighOrder function</p></a></li>
<li><a href='#nextStep'><p>next step of an MCMC chain</p></a></li>
<li><a href='#NonSpatialLogLikelihood_or_gradient'><p>NonSpatialLogLikelihood_or_gradient function</p></a></li>
<li><a href='#omegapriorGauss'><p>omegapriorGauss function</p></a></li>
<li><a href='#omegapriorGaussST'><p>omegapriorGaussST function</p></a></li>
<li><a href='#optifix'><p>optifix function</p></a></li>
<li><a href='#plot.FFTgrid'><p>plot.FFTgrid function</p></a></li>
<li><a href='#plotsurv'><p>plotsurv function</p></a></li>
<li><a href='#polyadd'><p>polyadd function</p></a></li>
<li><a href='#polymult'><p>polymult function</p></a></li>
<li><a href='#posteriorcov'><p>posteriorcov function</p></a></li>
<li><a href='#predict.mcmcspatsurv'><p>predict.mcmcspatsurv function</p></a></li>
<li><a href='#print.mcmc'><p>print.mcmc function</p></a></li>
<li><a href='#print.mcmcspatsurv'><p>print.mcmcspatsurv function</p></a></li>
<li><a href='#print.mlspatsurv'><p>print.mlspatsurv function</p></a></li>
<li><a href='#print.textSummary'><p>print.textSummary function</p></a></li>
<li><a href='#priorposterior'><p>priorposterior function</p></a></li>
<li><a href='#proposalVariance'><p>proposalVariance function</p></a></li>
<li><a href='#proposalVariance_gridded'><p>proposalVariance_gridded function</p></a></li>
<li><a href='#proposalVariance_polygonal'><p>proposalVariance_polygonal function</p></a></li>
<li><a href='#proposalVariance_SPDE'><p>proposalVariance_SPDE function</p></a></li>
<li><a href='#PsplineHaz'><p>PsplineHaz function</p></a></li>
<li><a href='#psplineprior'><p>psplineprior function</p></a></li>
<li><a href='#psplineRWprior'><p>psplineRWprior function</p></a></li>
<li><a href='#QuadApprox'><p>QuadApprox function</p></a></li>
<li><a href='#quantile.mcmcspatsurv'><p>quantile.mcmcspatsurv function</p></a></li>
<li><a href='#quantile.mlspatsurv'><p>quantile.mlspatsurv function</p></a></li>
<li><a href='#randompars'><p>randompars function</p></a></li>
<li><a href='#reconstruct.bs'><p>reconstruct.bs function</p></a></li>
<li><a href='#reconstruct.bs.coxph'><p>reconstruct.bs.coxph function</p></a></li>
<li><a href='#reconstruct.bs.mcmcspatsurv'><p>reconstruct.bs.mcmcspatsurv function</p></a></li>
<li><a href='#resetLoop'><p>reset iterator</p></a></li>
<li><a href='#residuals.mcmcspatsurv'><p>resuiduals.mcmcspatsurv function</p></a></li>
<li><a href='#rootWeibullHaz'><p>rootWeibullHaz function</p></a></li>
<li><a href='#setTxtProgressBar2'><p>set the progress bar</p></a></li>
<li><a href='#setupHazard'><p>setupHazard function</p></a></li>
<li><a href='#setupPrecMatStruct'><p>setupPrecMatStruct function</p></a></li>
<li><a href='#showGrid'><p>showGrid function</p></a></li>
<li><a href='#simsurv'><p>simsurv function</p></a></li>
<li><a href='#spatialpars'><p>spatialpars function</p></a></li>
<li><a href='#spatsurv-package'><p>spatsurv</p></a></li>
<li><a href='#spatsurvVignette'><p>spatsurvVignette function</p></a></li>
<li><a href='#SPDE'><p>SPDE function</p></a></li>
<li><a href='#SPDEprec'><p>SPDEprec function</p></a></li>
<li><a href='#SpikedExponentialCovFct'><p>SpikedExponentialCovFct function</p></a></li>
<li><a href='#Summarise'><p>Summarise function</p></a></li>
<li><a href='#summary.mcmc'><p>summary.mcmc function</p></a></li>
<li><a href='#summary.mcmcspatsurv'><p>summary.mcmcspatsurv function</p></a></li>
<li><a href='#surv3d'><p>Spatial Survival Plot in 3D</p></a></li>
<li><a href='#survival_PP'><p>survival_PP function</p></a></li>
<li><a href='#survspat'><p>survspat function</p></a></li>
<li><a href='#survspatNS'><p>survspatNS function</p></a></li>
<li><a href='#textSummary'><p>textSummary function</p></a></li>
<li><a href='#timevaryingPL'><p>timevaryingPL function</p></a></li>
<li><a href='#tpowHaz'><p>tpowHaz function</p></a></li>
<li><a href='#transformweibull'><p>transformweibull function</p></a></li>
<li><a href='#TwoWayHazAdditive'><p>TwoWayHazAdditive function</p></a></li>
<li><a href='#txtProgressBar2'><p>A text progress bar with label</p></a></li>
<li><a href='#vcov.mcmcspatsurv'><p>vcov.mcmcspatsurv function</p></a></li>
<li><a href='#vcov.mlspatsurv'><p>vcov.mlspatsurv function</p></a></li>
<li><a href='#weibullHaz'><p>weibullHaz function</p></a></li>
<li><a href='#YfromGamma'><p>YfromGamma function</p></a></li>
<li><a href='#YFromGamma_SPDE'><p>YFromGamma_SPDE function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Spatial Survival Analysis with Parametric Proportional
Hazards Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin M. Taylor and Barry S. Rowlingson
        Additional contributions
        Ziyu Zheng</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin M. Taylor &lt;benjamin.taylor.software@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian inference for parametric proportional hazards spatial
    survival models; flexible spatial survival models. See Benjamin M. Taylor, Barry S. Rowlingson (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v077.i04">doi:10.18637/jss.v077.i04</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>survival, sp, spatstat.explore, spatstat.geom,
spatstat.random, raster, iterators, fields, Matrix, stringr,
sf, RColorBrewer, methods, lubridate</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-19 07:47:32 UTC; ben</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-19 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.onAttach'>.onAttach function</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>A function to print a welcome message on loading package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onAttach_+3A_libname">libname</code></td>
<td>
<p>libname argument</p>
</td></tr>
<tr><td><code id=".onAttach_+3A_pkgname">pkgname</code></td>
<td>
<p>pkgname argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='allocate'>allocate function</h2><span id='topic+allocate'></span>

<h3>Description</h3>

<p>A function to allocate coordinates to an observation whose spatial location is known to the regional level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocate(poly, popden, survdat, pid, sid, n = 2, wid = 2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allocate_+3A_poly">poly</code></td>
<td>
<p>a SpatialPolygonsDataFrame, on which the survival data exist in aggregate form</p>
</td></tr>
<tr><td><code id="allocate_+3A_popden">popden</code></td>
<td>
<p>a sub-polygon raster image of population density</p>
</td></tr>
<tr><td><code id="allocate_+3A_survdat">survdat</code></td>
<td>
<p>data.frame containing the survival data</p>
</td></tr>
<tr><td><code id="allocate_+3A_pid">pid</code></td>
<td>
<p>name of the variable in the survival data that gives the region identifier in poly</p>
</td></tr>
<tr><td><code id="allocate_+3A_sid">sid</code></td>
<td>
<p>the name of the variable in poly to match the region identifier in survdat to</p>
</td></tr>
<tr><td><code id="allocate_+3A_n">n</code></td>
<td>
<p>the number of different allocations to make. e.g. if n is 2 (the default) two candidate sets of locations are available.</p>
</td></tr>
<tr><td><code id="allocate_+3A_wid">wid</code></td>
<td>
<p>The default is 2000, interpreted in metres ie 2Km. size of buffer to add to window for raster cropping purposes: this ensures that for each polygon, the cropped raster covers it completely.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrices x and y, both of size (number of observations in survdat x n) giving n potential candidate locations of points in the columns of x and y.
</p>

<hr>
<h2 id='alpha'>alpha function</h2><span id='topic+alpha'></span>

<h3>Description</h3>

<p>A function used in calculating the coefficients of a B-spline curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha(i, j, knots, knotidx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha_+3A_i">i</code></td>
<td>
<p>index i</p>
</td></tr>
<tr><td><code id="alpha_+3A_j">j</code></td>
<td>
<p>index j</p>
</td></tr>
<tr><td><code id="alpha_+3A_knots">knots</code></td>
<td>
<p>knot vector</p>
</td></tr>
<tr><td><code id="alpha_+3A_knotidx">knotidx</code></td>
<td>
<p>knot index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector
</p>

<hr>
<h2 id='B'>B function</h2><span id='topic+B'></span>

<h3>Description</h3>

<p>A recursive function used in calculating the coefficients of a B-spline curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B(x, i, j, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_+3A_x">x</code></td>
<td>
<p>locations at which to evaluate the B-spline</p>
</td></tr>
<tr><td><code id="B_+3A_i">i</code></td>
<td>
<p>index i</p>
</td></tr>
<tr><td><code id="B_+3A_j">j</code></td>
<td>
<p>index j</p>
</td></tr>
<tr><td><code id="B_+3A_knots">knots</code></td>
<td>
<p>a knot vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of polynomial coefficients
</p>

<hr>
<h2 id='basehazard'>basehazard function</h2><span id='topic+basehazard'></span>

<h3>Description</h3>

<p>Generic function for computing the baseline hazard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basehazard(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basehazard_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="basehazard_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method basehazard
</p>


<h3>See Also</h3>

<p><a href="#topic+basehazard.basehazardspec">basehazard.basehazardspec</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='basehazard.basehazardspec'>basehazard.basehazardspec function</h2><span id='topic+basehazard.basehazardspec'></span>

<h3>Description</h3>

<p>A function to retrieve the baseline hazard function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basehazardspec'
basehazard(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basehazard.basehazardspec_+3A_obj">obj</code></td>
<td>
<p>an object of class basehazardspec</p>
</td></tr>
<tr><td><code id="basehazard.basehazardspec_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function returning the baseline hazard
</p>


<h3>See Also</h3>

<p><a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='baseHazST'>baseHazST function</h2><span id='topic+baseHazST'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseHazST(
  bh1 = NULL,
  survobj,
  t0,
  nbreaks = 5,
  breakmethod = "quantile",
  MLinits = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseHazST_+3A_bh1">bh1</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="baseHazST_+3A_survobj">survobj</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="baseHazST_+3A_t0">t0</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="baseHazST_+3A_nbreaks">nbreaks</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="baseHazST_+3A_breakmethod">breakmethod</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="baseHazST_+3A_mlinits">MLinits</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='baselinehazard'>baselinehazard function</h2><span id='topic+baselinehazard'></span>

<h3>Description</h3>

<p>A function to compute quantiles of the posterior baseline hazard or cumulative baseline hazard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baselinehazard(
  x,
  t = NULL,
  n = 100,
  probs = c(0.025, 0.5, 0.975),
  cumulative = FALSE,
  plot = TRUE,
  bw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baselinehazard_+3A_x">x</code></td>
<td>
<p>an object inheriting class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="baselinehazard_+3A_t">t</code></td>
<td>
<p>optional vector of times at which to compute the quantiles, Defult is NULL, in which case a uniformly spaced vector of length n from 0 to the maximum time is used</p>
</td></tr>
<tr><td><code id="baselinehazard_+3A_n">n</code></td>
<td>
<p>the number of points at which to compute the quantiles if t is NULL</p>
</td></tr>
<tr><td><code id="baselinehazard_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="baselinehazard_+3A_cumulative">cumulative</code></td>
<td>
<p>logical, whether to return the baseline hazard (default i.e. FALSE) or cumulative baseline hazard</p>
</td></tr>
<tr><td><code id="baselinehazard_+3A_plot">plot</code></td>
<td>
<p>whether to plot the result</p>
</td></tr>
<tr><td><code id="baselinehazard_+3A_bw">bw</code></td>
<td>
<p>Logical. Plot in black/white/greyscale? Default is to produce a colour plot. Useful for producing plots for journals that do not accept colour plots.</p>
</td></tr>
<tr><td><code id="baselinehazard_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the vector of times and quantiles of the baseline or cumulative baseline hazard at those times
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='baselinehazard_multiWay'>baselinehazard_multiWay function</h2><span id='topic+baselinehazard_multiWay'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baselinehazard_multiWay(
  x,
  probs = c(0.025, 0.5, 0.975),
  cumulative = FALSE,
  plot = TRUE,
  joint = FALSE,
  xlims = NULL,
  ylims = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baselinehazard_multiWay_+3A_x">x</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="baselinehazard_multiWay_+3A_probs">probs</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="baselinehazard_multiWay_+3A_cumulative">cumulative</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="baselinehazard_multiWay_+3A_plot">plot</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="baselinehazard_multiWay_+3A_joint">joint</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="baselinehazard_multiWay_+3A_xlims">xlims</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="baselinehazard_multiWay_+3A_ylims">ylims</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="baselinehazard_multiWay_+3A_...">...</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='betapriorGauss'>betapriorGauss function</h2><span id='topic+betapriorGauss'></span>

<h3>Description</h3>

<p>A function to define Gaussian priors for beta. This function simply stores a vector of means and standard deviations to be passed to the main MCMC function, survspat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betapriorGauss(mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betapriorGauss_+3A_mean">mean</code></td>
<td>
<p>the prior mean, a vector of length 1 or more. 1 implies a common mean.</p>
</td></tr>
<tr><td><code id="betapriorGauss_+3A_sd">sd</code></td>
<td>
<p>the prior standard deviation, a vector of length 1 or more. 1 implies a common standard deviation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;betapriorGauss&quot;
</p>


<h3>See Also</h3>

<p><a href="#topic+survspat">survspat</a>, <a href="#topic+betapriorGauss">betapriorGauss</a>, <a href="#topic+omegapriorGauss">omegapriorGauss</a>, <a href="#topic+etapriorGauss">etapriorGauss</a>, <a href="#topic+indepGaussianprior">indepGaussianprior</a>, <a href="#topic+derivindepGaussianprior">derivindepGaussianprior</a>
</p>

<hr>
<h2 id='blockDiag'>A function to</h2><span id='topic+blockDiag'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockDiag(matlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockDiag_+3A_matlist">matlist</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='boxplotRisk'>boxplotRisk function</h2><span id='topic+boxplotRisk'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxplotRisk(g2r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplotRisk_+3A_g2r">g2r</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='Bspline.construct'>Bspline.construct function</h2><span id='topic+Bspline.construct'></span>

<h3>Description</h3>

<p>A function to construct a B-spline basis matrix for given data and basis coefficients. Used in evaluating the baseline hazard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bspline.construct(x, basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bspline.construct_+3A_x">x</code></td>
<td>
<p>a vector, the data</p>
</td></tr>
<tr><td><code id="Bspline.construct_+3A_basis">basis</code></td>
<td>
<p>an object created by the getBbasis function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a basis matrix
</p>

<hr>
<h2 id='BsplineHaz'>BsplineHaz function</h2><span id='topic+BsplineHaz'></span>

<h3>Description</h3>

<p>A function to define a parametric proportional hazards model where the baseline hazard is modelled by a basis spline.
This function returns an object inheriting class 'basehazardspec', list of functions 'distinfo', 'basehazard', 'gradbasehazard', 'hessbasehazard',
'cumbasehazard', 'gradcumbasehazard', 'hesscumbasehazard' and 'densityquantile'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BsplineHaz(times, knots = quantile(times), degree = 3, MLinits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BsplineHaz_+3A_times">times</code></td>
<td>
<p>vector of survival times (both censored and uncensored)</p>
</td></tr>
<tr><td><code id="BsplineHaz_+3A_knots">knots</code></td>
<td>
<p>vector of knots in ascending order, must include minimum and maximum values of 'times'</p>
</td></tr>
<tr><td><code id="BsplineHaz_+3A_degree">degree</code></td>
<td>
<p>degree of the spline basis, default is 3</p>
</td></tr>
<tr><td><code id="BsplineHaz_+3A_mlinits">MLinits</code></td>
<td>
<p>optional starting values for the non-spatial maximisation routine using optim. Note that we are working with the log of the parameters. Default is -10 for each parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>distinfo</code> function is used to provide basic distribution specific information to other <code>spatsurv</code> functions. The user is required
to provide the following information in the returned list: <code>npars</code>, the number of parameters in this distribution; <code>parnames</code>,
the names of the parameters; <code>trans</code>, the transformation scale on which the priors will be provided; <code>itrans</code>, the inverse
transformation function that will be applied to the parameters before the hazard, and other functions are evaluated; <code>jacobian</code>,
the derivative of the inverse transformation function with respect to each of the parameters; and <code>hessian</code>, the second derivatives
of the inverse transformation function with respect to each of the parameters &ndash; note that currently the package <code>spatsurv</code>
only allows the use of functions where the parameters are transformed independently.
</p>
<p>The <code>basehazard</code> function is used to evaluate the baseline hazard function for the distribution of interest. It returns a
function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradbasehazard</code> function is used to evaluate the gradient of the baseline hazard function with respect to the parameters,
this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hessbasehazard</code> function is used to evaluate the Hessian of the baseline hazard function. It returns a function that accepts
as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>cumbasehazard</code> function is used to evaluate the cumulative baseline hazard function for the distribution of interest.
It returns a function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradcumbasehazard</code> function is used to evaluate the gradient of the cumulative baseline hazard function with respect
to the parameters, this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hesscumbasehazard</code> function is used to evaluate the Hessian of the cumulative baseline hazard function. It returns a
function that accepts as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>densityquantile</code> function is used to return quantiles of the density function. This is NOT REQUIRED for running the MCMC,
merely for us in post-processing with the <code>predict</code> function where <code>type</code> is 'densityquantile'. In the case of the Weibull
model for the baseline hazard, it can be shown that the q-th quantile is:
</p>


<h3>Value</h3>

<p>an object inheriting class 'basehazardspec'
</p>


<h3>See Also</h3>

<p><a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>
</p>

<hr>
<h2 id='checkSurvivalData'>checkSurvivalData function</h2><span id='topic+checkSurvivalData'></span>

<h3>Description</h3>

<p>A function to check whether the survival data to be passed to survspat is in the correct format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSurvivalData(s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkSurvivalData_+3A_s">s</code></td>
<td>
<p>an object of class Surv, from the survival package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if there are any issues with data format, these are returned with the data an error message explaining any issues with the data
</p>

<hr>
<h2 id='circulant'>circulant function</h2><span id='topic+circulant'></span>

<h3>Description</h3>

<p>generic function for constructing circulant matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circulant(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circulant_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="circulant_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method circulant
</p>

<hr>
<h2 id='circulant.matrix'>circulant.matrix function</h2><span id='topic+circulant.matrix'></span>

<h3>Description</h3>

<p>If x is a matrix whose columns are the bases of the sub-blocks of a block circulant matrix, then this function returns the
block circulant matrix of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
circulant(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circulant.matrix_+3A_x">x</code></td>
<td>
<p>a matrix object</p>
</td></tr>
<tr><td><code id="circulant.matrix_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If x is a matrix whose columns are the bases of the sub-blocks of a block circulant matrix, then this function returns the block circulant matrix of interest.
</p>

<hr>
<h2 id='circulant.numeric'>circulant.numeric function</h2><span id='topic+circulant.numeric'></span>

<h3>Description</h3>

<p>returns a circulant matrix with base x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
circulant(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circulant.numeric_+3A_x">x</code></td>
<td>
<p>an numeric object</p>
</td></tr>
<tr><td><code id="circulant.numeric_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a circulant matrix with base x
</p>

<hr>
<h2 id='circulantij'>circulantij function</h2><span id='topic+circulantij'></span>

<h3>Description</h3>

<p>A function to return the &quot;idx&quot; i.e. c(i,j) element of a circulant matrix with base &quot;base&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circulantij(idx, base)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circulantij_+3A_idx">idx</code></td>
<td>
<p>vector of length 2 th (i,j) (row,column) index to return</p>
</td></tr>
<tr><td><code id="circulantij_+3A_base">base</code></td>
<td>
<p>the base matrix of a circulant matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the ij element of the full circulant
</p>

<hr>
<h2 id='covmodel'>covmodel function</h2><span id='topic+covmodel'></span>

<h3>Description</h3>

<p>A function to define the spatial covariance model, see also ?CovarianceFct. Note that the parameters defined by the 'pars' argument are fixed,
i.e. not estimated by the MCMC algorithm. To have spatsurv estimate these parameters, the user must construct a new covariance function to do so, stop(&quot;&quot;)
see the spatsurv vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covmodel(model, pars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covmodel_+3A_model">model</code></td>
<td>
<p>correlation type, a string see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="covmodel_+3A_pars">pars</code></td>
<td>
<p>vector of additional parameters for certain classes of covariance function (eg Matern), these must be supplied in the order given in ?CovarianceFct and are not estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class covmodel
</p>

<hr>
<h2 id='CSplot'>CSplot function</h2><span id='topic+CSplot'></span>

<h3>Description</h3>

<p>A function to produce a diagnostic plot for model fit using the Cox-Snell residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSplot(mod, plot = TRUE, bw = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CSplot_+3A_mod">mod</code></td>
<td>
<p>an object produced by the function survspat</p>
</td></tr>
<tr><td><code id="CSplot_+3A_plot">plot</code></td>
<td>
<p>whether to plot the result, default is TRUE</p>
</td></tr>
<tr><td><code id="CSplot_+3A_bw">bw</code></td>
<td>
<p>Logical. Plot in black/white/greyscale? Default is to produce a colour plot. Useful for producing plots for journals that do not accept colour plots.</p>
</td></tr>
<tr><td><code id="CSplot_+3A_...">...</code></td>
<td>
<p>other arguments to pass to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the x and y values used in the plot
</p>

<hr>
<h2 id='cumbasehazard'>cumbasehazard function</h2><span id='topic+cumbasehazard'></span>

<h3>Description</h3>

<p>Generic function for computing the cumulative baseline hazard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumbasehazard(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumbasehazard_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="cumbasehazard_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method cumbasehazard
</p>


<h3>See Also</h3>

<p><a href="#topic+cumbasehazard.basehazardspec">cumbasehazard.basehazardspec</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='cumbasehazard.basehazardspec'>cumbasehazard.basehazardspec function</h2><span id='topic+cumbasehazard.basehazardspec'></span>

<h3>Description</h3>

<p>A function to retrieve the cumulative baseline hazard function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basehazardspec'
cumbasehazard(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumbasehazard.basehazardspec_+3A_obj">obj</code></td>
<td>
<p>an object of class basehazardspec</p>
</td></tr>
<tr><td><code id="cumbasehazard.basehazardspec_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function returning the cumulative baseline hazard
</p>


<h3>See Also</h3>

<p><a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='cumulativeBspline.construct'>cumulativeBspline.construct function</h2><span id='topic+cumulativeBspline.construct'></span>

<h3>Description</h3>

<p>A function to construct the integral of a B-spline curve given data and basis coefficients. Used in evaluating the cumulative baseline hazard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulativeBspline.construct(x, basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulativeBspline.construct_+3A_x">x</code></td>
<td>
<p>a vector, the data</p>
</td></tr>
<tr><td><code id="cumulativeBspline.construct_+3A_basis">basis</code></td>
<td>
<p>an object created by the getBbasis function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object that allows the integral of a given B-spline curve to be computed
</p>

<hr>
<h2 id='density_PP'>density_PP function</h2><span id='topic+density_PP'></span>

<h3>Description</h3>

<p>A function to compute an individual's density function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_PP(inputs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_PP_+3A_inputs">inputs</code></td>
<td>
<p>inputs for the function including the model matrix, frailties, fixed effects and the parameters of the baseline hazard derived from this model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the density function for the individual
</p>

<hr>
<h2 id='densityquantile'>densityquantile function</h2><span id='topic+densityquantile'></span>

<h3>Description</h3>

<p>Generic function for computing quantiles of the density function for a given baseline hazard. This may not be analytically tractable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityquantile(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityquantile_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="densityquantile_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method densityquantile
</p>


<h3>See Also</h3>

<p><a href="#topic+densityquantile.basehazardspec">densityquantile.basehazardspec</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='densityquantile_PP'>densityquantile_PP function</h2><span id='topic+densityquantile_PP'></span>

<h3>Description</h3>

<p>A function to compute quantiles of the density function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityquantile_PP(inputs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityquantile_PP_+3A_inputs">inputs</code></td>
<td>
<p>inputs for the function including the model matrix, frailties, fixed effects and the parameters of the baseline hazard derived from this model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quantiles of the density function for the individual
</p>

<hr>
<h2 id='densityquantile.basehazardspec'>densityquantile.basehazardspec function</h2><span id='topic+densityquantile.basehazardspec'></span>

<h3>Description</h3>

<p>A function to retrieve the quantiles of the density function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basehazardspec'
densityquantile(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityquantile.basehazardspec_+3A_obj">obj</code></td>
<td>
<p>an object of class basehazardspec</p>
</td></tr>
<tr><td><code id="densityquantile.basehazardspec_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function returning the density quantiles
</p>


<h3>See Also</h3>

<p><a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='derivindepGaussianprior'>derivindepGaussianprior function</h2><span id='topic+derivindepGaussianprior'></span>

<h3>Description</h3>

<p>A function for evaluating the first and second derivatives of the log of an independent Gaussian prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivindepGaussianprior(beta = NULL, omega = NULL, eta = NULL, priors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivindepGaussianprior_+3A_beta">beta</code></td>
<td>
<p>a vector, the parameter beta</p>
</td></tr>
<tr><td><code id="derivindepGaussianprior_+3A_omega">omega</code></td>
<td>
<p>a vector, the parameter omega</p>
</td></tr>
<tr><td><code id="derivindepGaussianprior_+3A_eta">eta</code></td>
<td>
<p>a vector, the parameter eta</p>
</td></tr>
<tr><td><code id="derivindepGaussianprior_+3A_priors">priors</code></td>
<td>
<p>an object of class 'mcmcPrior', see ?mcmcPrior</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the first and second derivatives of the prior
</p>


<h3>See Also</h3>

<p><a href="#topic+survspat">survspat</a>, <a href="#topic+betapriorGauss">betapriorGauss</a>, <a href="#topic+omegapriorGauss">omegapriorGauss</a>, <a href="#topic+etapriorGauss">etapriorGauss</a>, <a href="#topic+indepGaussianprior">indepGaussianprior</a>, <a href="#topic+derivindepGaussianprior">derivindepGaussianprior</a>
</p>

<hr>
<h2 id='derivindepGaussianpriorST'>derivindepGaussianpriorST function</h2><span id='topic+derivindepGaussianpriorST'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivindepGaussianpriorST(beta = NULL, omega = NULL, eta = NULL, priors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivindepGaussianpriorST_+3A_beta">beta</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="derivindepGaussianpriorST_+3A_omega">omega</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="derivindepGaussianpriorST_+3A_eta">eta</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="derivindepGaussianpriorST_+3A_priors">priors</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='derivpsplineprior'>derivpsplineprior function</h2><span id='topic+derivpsplineprior'></span>

<h3>Description</h3>

<p>A function for evaluating the first and second derivatives of the log of an independent Gaussian prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivpsplineprior(beta = NULL, omega = NULL, eta = NULL, priors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivpsplineprior_+3A_beta">beta</code></td>
<td>
<p>a vector, the parameter beta</p>
</td></tr>
<tr><td><code id="derivpsplineprior_+3A_omega">omega</code></td>
<td>
<p>a vector, the parameter omega</p>
</td></tr>
<tr><td><code id="derivpsplineprior_+3A_eta">eta</code></td>
<td>
<p>a vector, the parameter eta</p>
</td></tr>
<tr><td><code id="derivpsplineprior_+3A_priors">priors</code></td>
<td>
<p>an object of class 'mcmcPrior', see ?mcmcPrior</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the first and second derivatives of the prior
</p>


<h3>See Also</h3>

<p><a href="#topic+survspat">survspat</a>, <a href="#topic+betapriorGauss">betapriorGauss</a>, <a href="#topic+omegapriorGauss">omegapriorGauss</a>, <a href="#topic+etapriorGauss">etapriorGauss</a>, <a href="#topic+indepGaussianprior">indepGaussianprior</a>, <a href="#topic+derivindepGaussianprior">derivindepGaussianprior</a>
</p>

<hr>
<h2 id='distinfo'>distinfo function</h2><span id='topic+distinfo'></span>

<h3>Description</h3>

<p>Generic function for returning information about the class of baseline hazard functions employed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distinfo(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinfo_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="distinfo_+3A_...">...</code></td>
<td>
<p>additional argument &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method distinfo
</p>


<h3>See Also</h3>

<p><a href="#topic+distinfo.basehazardspec">distinfo.basehazardspec</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='distinfo.basehazardspec'>distinfo.basehazardspec function</h2><span id='topic+distinfo.basehazardspec'></span>

<h3>Description</h3>

<p>A function to retrive information on the baseline hazard distribution of choice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basehazardspec'
distinfo(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinfo.basehazardspec_+3A_obj">obj</code></td>
<td>
<p>an object of class basehazardspec</p>
</td></tr>
<tr><td><code id="distinfo.basehazardspec_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function returning information on the baseline hazard distribution of choice
</p>


<h3>See Also</h3>

<p><a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='estimateY'>estimateY function</h2><span id='topic+estimateY'></span>

<h3>Description</h3>

<p>A function to get an initial estimate of Y, to be used in calibrating the MCMC. Not for general use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateY(X, betahat, omegahat, surv, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateY_+3A_x">X</code></td>
<td>
<p>the design matrix containing covariate information</p>
</td></tr>
<tr><td><code id="estimateY_+3A_betahat">betahat</code></td>
<td>
<p>an estimate of beta</p>
</td></tr>
<tr><td><code id="estimateY_+3A_omegahat">omegahat</code></td>
<td>
<p>an estimate of omega</p>
</td></tr>
<tr><td><code id="estimateY_+3A_surv">surv</code></td>
<td>
<p>an object of class Surv</p>
</td></tr>
<tr><td><code id="estimateY_+3A_control">control</code></td>
<td>
<p>a list containg various control parameters for the MCMC and post-processing routines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an estimate of Y, to be used in calibrating the MCMC
</p>

<hr>
<h2 id='Et_PP'>Et_PP function</h2><span id='topic+Et_PP'></span>

<h3>Description</h3>

<p>A function to compute an individual's approximate expected survival time using numerical integration. Note this appears to be unstable; the
function is based on R's integrate function. Not intended for general use (yet!).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Et_PP(inputs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Et_PP_+3A_inputs">inputs</code></td>
<td>
<p>inputs for the function including the model matrix, frailties, fixed effects and the parameters of the baseline hazard derived from this model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the expected survival time for the individual, obtained by numerical integration of the density function.
</p>

<hr>
<h2 id='etapriorGauss'>etapriorGauss function</h2><span id='topic+etapriorGauss'></span>

<h3>Description</h3>

<p>A function to define Gaussian priors for eta. This function simply stores a vector of means and standard deviations to be passed to the main MCMC function, survspat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etapriorGauss(mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etapriorGauss_+3A_mean">mean</code></td>
<td>
<p>the prior mean, a vector of length 1 or more. 1 implies a common mean.</p>
</td></tr>
<tr><td><code id="etapriorGauss_+3A_sd">sd</code></td>
<td>
<p>the prior standard deviation, a vector of length 1 or more. 1 implies a common standard deviation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;etapriorGauss&quot;
</p>


<h3>See Also</h3>

<p><a href="#topic+survspat">survspat</a>, <a href="#topic+betapriorGauss">betapriorGauss</a>, <a href="#topic+omegapriorGauss">omegapriorGauss</a>, <a href="#topic+etapriorGauss">etapriorGauss</a>, <a href="#topic+indepGaussianprior">indepGaussianprior</a>, <a href="#topic+derivindepGaussianprior">derivindepGaussianprior</a>
</p>

<hr>
<h2 id='EvalCov'>EvalCov function</h2><span id='topic+EvalCov'></span>

<h3>Description</h3>

<p>This function is used to evaluate the covariance function within the MCMC run. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvalCov(cov.model, u, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EvalCov_+3A_cov.model">cov.model</code></td>
<td>
<p>an object of class covmodel</p>
</td></tr>
<tr><td><code id="EvalCov_+3A_u">u</code></td>
<td>
<p>vector of distances</p>
</td></tr>
<tr><td><code id="EvalCov_+3A_parameters">parameters</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method EvalCov
</p>

<hr>
<h2 id='ExponentialCovFct'>ExponentialCovFct function</h2><span id='topic+ExponentialCovFct'></span>

<h3>Description</h3>

<p>A function to declare and also evaluate an exponential covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExponentialCovFct()
</code></pre>


<h3>Value</h3>

<p>the exponential covariance function
</p>


<h3>See Also</h3>

<p><a href="#topic+SpikedExponentialCovFct">SpikedExponentialCovFct</a>, <a href="#topic+covmodel">covmodel</a>
</p>

<hr>
<h2 id='exponentialHaz'>exponentialHaz function</h2><span id='topic+exponentialHaz'></span>

<h3>Description</h3>

<p>A function to define a parametric proportional hazards model where the baseline hazard is taken from the exponential model. 
This function returns an object inheriting class 'basehazardspec', list of functions 'distinfo', 'basehazard', 'gradbasehazard', 'hessbasehazard',
'cumbasehazard', 'gradcumbasehazard', 'hesscumbasehazard' and 'densityquantile'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponentialHaz()
</code></pre>


<h3>Details</h3>

<p>The <code>distinfo</code> function is used to provide basic distribution specific information to other <code>spatsurv</code> functions. The user is required 
to provide the following information in the returned list: <code>npars</code>, the number of parameters in this distribution; <code>parnames</code>, 
the names of the parameters; <code>trans</code>, the transformation scale on which the priors will be provided; <code>itrans</code>, the inverse 
transformation function that will be applied to the parameters before the hazard, and other functions are evaluated; <code>jacobian</code>, 
the derivative of the inverse transformation function with respect to each of the parameters; and <code>hessian</code>, the second derivatives 
of the inverse transformation function with respect to each of the parameters &ndash; note that currently the package <code>spatsurv</code> 
only allows the use of functions where the parameters are transformed independently.
</p>
<p>The <code>basehazard</code> function is used to evaluate the baseline hazard function for the distribution of interest. It returns a 
function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradbasehazard</code> function is used to evaluate the gradient of the baseline hazard function with respect to the parameters, 
this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hessbasehazard</code> function is used to evaluate the Hessian of the baseline hazard function. It returns a function that accepts 
as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>cumbasehazard</code> function is used to evaluate the cumulative baseline hazard function for the distribution of interest. 
It returns a function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradcumbasehazard</code> function is used to evaluate the gradient of the cumulative baseline hazard function with respect 
to the parameters, this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hesscumbasehazard</code> function is used to evaluate the Hessian of the cumulative baseline hazard function. It returns a 
function that accepts as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>densityquantile</code> function is used to return quantiles of the density function. This is NOT REQUIRED for running the MCMC, 
merely for us in post-processing with the <code>predict</code> function where <code>type</code> is 'densityquantile'. In the case of the Weibull 
model for the baseline hazard, it can be shown that the q-th quantile is:
</p>


<h3>Value</h3>

<p>an object inheriting class 'basehazardspec'
</p>


<h3>See Also</h3>

<p><a href="#topic+tpowHaz">tpowHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>
</p>

<hr>
<h2 id='FFTgrid'>FFTgrid function</h2><span id='topic+FFTgrid'></span>

<h3>Description</h3>

<p>A function to generate an FFT grid and associated quantities including cell dimensions,
size of extended grid, centroids,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FFTgrid(spatialdata, cellwidth, ext, boundingbox = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FFTgrid_+3A_spatialdata">spatialdata</code></td>
<td>
<p>a SpatialPixelsDataFrame object</p>
</td></tr>
<tr><td><code id="FFTgrid_+3A_cellwidth">cellwidth</code></td>
<td>
<p>width of computational cells</p>
</td></tr>
<tr><td><code id="FFTgrid_+3A_ext">ext</code></td>
<td>
<p>multiplying constant: the size of the extended grid: ext*M by ext*N</p>
</td></tr>
<tr><td><code id="FFTgrid_+3A_boundingbox">boundingbox</code></td>
<td>
<p>optional bounding box over which to construct computational grid, supplied as an object on which the function 'bbox' returns the bounding box</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='fixedpars'>fixedpars function</h2><span id='topic+fixedpars'></span>

<h3>Description</h3>

<p>A function to return the mcmc chains for the covariate effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixedpars(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixedpars_+3A_x">x</code></td>
<td>
<p>an object of class mcmcspatsurv</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the beta mcmc chains
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='fixmatrix'>fixmatrix function</h2><span id='topic+fixmatrix'></span>

<h3>Description</h3>

<p>!! THIS FUNCTION IS NOT INTENDED FOR GENERAL USE !!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixmatrix(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixmatrix_+3A_mat">mat</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function to fix up an estimated covariance matrix using a VERY ad-hoc method.
</p>


<h3>Value</h3>

<p>the fixed matrix
</p>

<hr>
<h2 id='fixParHaz'>fixParHaz function</h2><span id='topic+fixParHaz'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixParHaz(bh, idx, fixval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixParHaz_+3A_bh">bh</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="fixParHaz_+3A_idx">idx</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="fixParHaz_+3A_fixval">fixval</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='frailtylag1'>frailtylag1 function</h2><span id='topic+frailtylag1'></span>

<h3>Description</h3>

<p>A function to produce a plot of, and return, the lag 1 (or higher, see argument 'lag') autocorrelation for each of the spatially correlated frailty chains
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frailtylag1(object, plot = TRUE, lag = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frailtylag1_+3A_object">object</code></td>
<td>
<p>an object inheriting class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="frailtylag1_+3A_plot">plot</code></td>
<td>
<p>logical whether to plot the result, default is TRUE</p>
</td></tr>
<tr><td><code id="frailtylag1_+3A_lag">lag</code></td>
<td>
<p>the lag to plot, the default is 1</p>
</td></tr>
<tr><td><code id="frailtylag1_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the lag 1 autocorrelation for each of the spatially correlated frailty chains
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='fs'>London Fire Brigade property</h2><span id='topic+fs'></span>

<h3>Description</h3>

<p>London Fire Brigade property</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fs)</code></pre>


<h3>Format</h3>

<p>data.frame</p>


<h3>Source</h3>

<p>https://data.london.gov.uk/</p>


<h3>References</h3>

<p><a href="https://data.london.gov.uk/">https://data.london.gov.uk/</a>,<a href="https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/">https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>fire &lt;- data(fs)</code></pre>

<hr>
<h2 id='fstimes'>London Fire Brigade response times to dwelling fires, 2009</h2><span id='topic+fstimes'></span>

<h3>Description</h3>

<p>London Fire Brigade response times to dwelling fires, 2009</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fstimes)</code></pre>


<h3>Format</h3>

<p>data.frame</p>


<h3>Source</h3>

<p>https://data.london.gov.uk/</p>


<h3>References</h3>

<p><a href="https://data.london.gov.uk/">https://data.london.gov.uk/</a>,<a href="https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/">https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>firetimes &lt;- data(fstimes)</code></pre>

<hr>
<h2 id='gamma2risk'>gamma2risk function</h2><span id='topic+gamma2risk'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma2risk(mod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma2risk_+3A_mod">mod</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='GammafromY'>GammafromY function</h2><span id='topic+GammafromY'></span>

<h3>Description</h3>

<p>A function to change Ys (spatially correlated noise) into Gammas (white noise). Used in the MALA algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GammafromY(Y, rootQeigs, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GammafromY_+3A_y">Y</code></td>
<td>
<p>Y matrix</p>
</td></tr>
<tr><td><code id="GammafromY_+3A_rootqeigs">rootQeigs</code></td>
<td>
<p>square root of the eigenvectors of the precision matrix</p>
</td></tr>
<tr><td><code id="GammafromY_+3A_mu">mu</code></td>
<td>
<p>parameter of the latent Gaussian field</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gamma
</p>

<hr>
<h2 id='GammaFromY_SPDE'>GammaFromY_SPDE function</h2><span id='topic+GammaFromY_SPDE'></span>

<h3>Description</h3>

<p>A function to go from Y to Gamma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GammaFromY_SPDE(Y, U, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GammaFromY_SPDE_+3A_y">Y</code></td>
<td>
<p>Y</p>
</td></tr>
<tr><td><code id="GammaFromY_SPDE_+3A_u">U</code></td>
<td>
<p>upper Cholesky matrix</p>
</td></tr>
<tr><td><code id="GammaFromY_SPDE_+3A_mu">mu</code></td>
<td>
<p>the mean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of Gamma for the given Y
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li>
<li><p> Finn Lindgren, Havard Rue, Johan Lindstrom. An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach. Journal of the Royal Statistical Society: Series B 73(4)
</p>
</li></ol>


<hr>
<h2 id='gencens'>gencens function</h2><span id='topic+gencens'></span>

<h3>Description</h3>

<p>A function to generate observed times given a vector of true survival times and a vector of censoring times. Used in the simulation of
survival data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gencens(survtimes, censtimes, type = "right")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gencens_+3A_survtimes">survtimes</code></td>
<td>
<p>a vector of survival times</p>
</td></tr>
<tr><td><code id="gencens_+3A_censtimes">censtimes</code></td>
<td>
<p>a vector of censoring times for left or right censored data, 2-column matrix of censoring times for interval censoring (number of rows equal to the number of observations).</p>
</td></tr>
<tr><td><code id="gencens_+3A_type">type</code></td>
<td>
<p>the type of censoring to generate can be 'right' (default), 'left' or 'interval'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'Surv', the censoring indicator is equal to 1 if the
event is uncensored and 0 otherwise for right/left censored data, or for interval censored data, the indicator is 0 uncensored, 1 right censored,
2 left censored, or 3 interval censored.
</p>

<hr>
<h2 id='getbb'>getbb function</h2><span id='topic+getbb'></span>

<h3>Description</h3>

<p>A function to get the bounding box of a Spatial object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getbb(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getbb_+3A_obj">obj</code></td>
<td>
<p>a spatial object e.g. a SpatialPolygonsDataFrame, SpatialPolygons, etc ... anything with a bounding box that can be computed with bbox(obj)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialPolygons object: the bounding box
</p>

<hr>
<h2 id='getBbasis'>getBbasis function</h2><span id='topic+getBbasis'></span>

<h3>Description</h3>

<p>A function returning the piecewise polynomial coefficients for a B-spline basis function i.e. the basis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBbasis(x, knots, degree, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBbasis_+3A_x">x</code></td>
<td>
<p>a vector of data</p>
</td></tr>
<tr><td><code id="getBbasis_+3A_knots">knots</code></td>
<td>
<p>a vector of knots in ascending order. The first and last knots must be respectively the minimum and maximum of x.</p>
</td></tr>
<tr><td><code id="getBbasis_+3A_degree">degree</code></td>
<td>
<p>the degree of the spline</p>
</td></tr>
<tr><td><code id="getBbasis_+3A_force">force</code></td>
<td>
<p>logical: skip check on knots? (not recommended!)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the knots and the piecewise polynomial coefficients for a B-spline basis function i.e. the basis functions.
</p>

<hr>
<h2 id='getcov'>getcov function</h2><span id='topic+getcov'></span>

<h3>Description</h3>

<p>A function to return the covariance from a model based on the randomFields covariance functions. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getcov(u, sigma, phi, model, pars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getcov_+3A_u">u</code></td>
<td>
<p>distance</p>
</td></tr>
<tr><td><code id="getcov_+3A_sigma">sigma</code></td>
<td>
<p>variance parameter</p>
</td></tr>
<tr><td><code id="getcov_+3A_phi">phi</code></td>
<td>
<p>scale parameter</p>
</td></tr>
<tr><td><code id="getcov_+3A_model">model</code></td>
<td>
<p>correlation type, see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="getcov_+3A_pars">pars</code></td>
<td>
<p>vector of additional parameters for certain classes of covariance function (eg Matern), these must be supplied in the order given in ?CovarianceFct and are not estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>this is just a wrapper for CovarianceFct
</p>

<hr>
<h2 id='getgrd'>getgrd function</h2><span id='topic+getgrd'></span>

<h3>Description</h3>

<p>A function to create a regular grid over an observation window in order to model the spatial randome effects as a Gaussian
Markov random field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getgrd(shape, cellwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getgrd_+3A_shape">shape</code></td>
<td>
<p>an object of class SpatialPolygons or SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="getgrd_+3A_cellwidth">cellwidth</code></td>
<td>
<p>a scalar, the width of the grid cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialPolygons object: the grid on which prediction of the spatial effects will occur
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li>
<li><p> Finn Lindgren, Havard Rue, Johan Lindstrom. An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach. Journal of the Royal Statistical Society: Series B 73(4)
</p>
</li></ol>


<hr>
<h2 id='getGrid'>getGrid function</h2><span id='topic+getGrid'></span>

<h3>Description</h3>

<p>A function to extract and return the computational grid from a gridded analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGrid(mod, returnclass = "SpatialPolygonsDataFrame")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGrid_+3A_mod">mod</code></td>
<td>
<p>an object of class mcmcspatsurv, returned by the function survspat</p>
</td></tr>
<tr><td><code id="getGrid_+3A_returnclass">returnclass</code></td>
<td>
<p>the class of object to return, default is a'SpatialPolygonsDataFrame'. Other options are 'raster', which returns a raster brick; or 'SpatialPixelsDataFrame'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialPolygonsDataFrame in which Monte Carlo expectations can be stored and later plotted.
</p>

<hr>
<h2 id='getleneta'>getleneta function</h2><span id='topic+getleneta'></span>

<h3>Description</h3>

<p>A function to compute the length of eta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getleneta(cov.model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getleneta_+3A_cov.model">cov.model</code></td>
<td>
<p>a covariance model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the length of eta
</p>

<hr>
<h2 id='getOptCellwidth'>getOptCellwidth function</h2><span id='topic+getOptCellwidth'></span>

<h3>Description</h3>

<p>A function to compute an optimal cellwidth close to an initial suggestion. This maximises the efficiency of the
MCMC algorithm when in the control argument of the function survspat, the option gridded is set to TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOptCellwidth(dat, cellwidth, ext = 2, plot = TRUE, boundingbox = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOptCellwidth_+3A_dat">dat</code></td>
<td>
<p>any spatial data object whose bounding box can be computed using the function bbox.</p>
</td></tr>
<tr><td><code id="getOptCellwidth_+3A_cellwidth">cellwidth</code></td>
<td>
<p>an initial suggested cellwidth</p>
</td></tr>
<tr><td><code id="getOptCellwidth_+3A_ext">ext</code></td>
<td>
<p>the extension parameter for the FFT transform, set to 2 by default</p>
</td></tr>
<tr><td><code id="getOptCellwidth_+3A_plot">plot</code></td>
<td>
<p>whether to plot the grid and data to illustrate the optimal grid</p>
</td></tr>
<tr><td><code id="getOptCellwidth_+3A_boundingbox">boundingbox</code></td>
<td>
<p>optional bounding box over which to construct computational grid, supplied as an object on which the function 'bbox' returns the bounding box</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the optimum cell width
</p>

<hr>
<h2 id='getparranges'>getparranges function</h2><span id='topic+getparranges'></span>

<h3>Description</h3>

<p>A function to extract parameter ranges for creating a grid on which to evaluate the log-posterior, used in calibrating the MCMC. This function
is not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getparranges(priors, leneta, mult = 1.96)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getparranges_+3A_priors">priors</code></td>
<td>
<p>an object of class mcmcPriors</p>
</td></tr>
<tr><td><code id="getparranges_+3A_leneta">leneta</code></td>
<td>
<p>the length of eta passed to the function</p>
</td></tr>
<tr><td><code id="getparranges_+3A_mult">mult</code></td>
<td>
<p>defaults to 1.96 so the grid formed will be mean plus/minus 1.96 times the standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an appropriate range used to calibrate the MCMC: the mean of the prior for eta plus/minus 1.96 times the standard deviation
</p>

<hr>
<h2 id='getsurvdata'>getsurvdata function</h2><span id='topic+getsurvdata'></span>

<h3>Description</h3>

<p>A function to return the survival data from an object of class mcmcspatsurv. This function is not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getsurvdata(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getsurvdata_+3A_x">x</code></td>
<td>
<p>an object of class mcmcspatsurv</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the survival data from an object of class mcmcspatsurv
</p>

<hr>
<h2 id='gompertzHaz'>gompertzHaz function</h2><span id='topic+gompertzHaz'></span>

<h3>Description</h3>

<p>A function to define a parametric proportional hazards model where the baseline hazard is taken from a Gompertz model. 
This function returns an object inheriting class 'basehazardspec', list of functions 'distinfo', 'basehazard', 'gradbasehazard', 'hessbasehazard',
'cumbasehazard', 'gradcumbasehazard', 'hesscumbasehazard' and 'densityquantile'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gompertzHaz()
</code></pre>


<h3>Details</h3>

<p>The <code>distinfo</code> function is used to provide basic distribution specific information to other <code>spatsurv</code> functions. The user is required 
to provide the following information in the returned list: <code>npars</code>, the number of parameters in this distribution; <code>parnames</code>, 
the names of the parameters; <code>trans</code>, the transformation scale on which the priors will be provided; <code>itrans</code>, the inverse 
transformation function that will be applied to the parameters before the hazard, and other functions are evaluated; <code>jacobian</code>, 
the derivative of the inverse transformation function with respect to each of the parameters; and <code>hessian</code>, the second derivatives 
of the inverse transformation function with respect to each of the parameters &ndash; note that currently the package <code>spatsurv</code> 
only allows the use of functions where the parameters are transformed independently.
</p>
<p>The <code>basehazard</code> function is used to evaluate the baseline hazard function for the distribution of interest. It returns a 
function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradbasehazard</code> function is used to evaluate the gradient of the baseline hazard function with respect to the parameters, 
this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hessbasehazard</code> function is used to evaluate the Hessian of the baseline hazard function. It returns a function that accepts 
as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>cumbasehazard</code> function is used to evaluate the cumulative baseline hazard function for the distribution of interest. 
It returns a function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradcumbasehazard</code> function is used to evaluate the gradient of the cumulative baseline hazard function with respect 
to the parameters, this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hesscumbasehazard</code> function is used to evaluate the Hessian of the cumulative baseline hazard function. It returns a 
function that accepts as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>densityquantile</code> function is used to return quantiles of the density function. This is NOT REQUIRED for running the MCMC, 
merely for us in post-processing with the <code>predict</code> function where <code>type</code> is 'densityquantile'. In the case of the Weibull 
model for the baseline hazard, it can be shown that the q-th quantile is:
</p>


<h3>Value</h3>

<p>an object inheriting class 'basehazardspec'
</p>


<h3>See Also</h3>

<p><a href="#topic+tpowHaz">tpowHaz</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>
</p>

<hr>
<h2 id='gradbasehazard'>gradbasehazard function</h2><span id='topic+gradbasehazard'></span>

<h3>Description</h3>

<p>Generic function for computing the gradient of the baseline hazard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradbasehazard(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradbasehazard_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="gradbasehazard_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method gradbasehazard
</p>


<h3>See Also</h3>

<p><a href="#topic+gradbasehazard.basehazardspec">gradbasehazard.basehazardspec</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='gradbasehazard.basehazardspec'>gradbasehazard.basehazardspec function</h2><span id='topic+gradbasehazard.basehazardspec'></span>

<h3>Description</h3>

<p>A function to retrieve the gradient of the baseline hazard function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basehazardspec'
gradbasehazard(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradbasehazard.basehazardspec_+3A_obj">obj</code></td>
<td>
<p>an object of class basehazardspec</p>
</td></tr>
<tr><td><code id="gradbasehazard.basehazardspec_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function returning the gradient of the baseline hazard
</p>


<h3>See Also</h3>

<p><a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='gradcumbasehazard'>gradcumbasehazard function</h2><span id='topic+gradcumbasehazard'></span>

<h3>Description</h3>

<p>Generic function for computing the gradient of the cumulative baseline hazard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradcumbasehazard(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradcumbasehazard_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="gradcumbasehazard_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method gradcumbasehazard
</p>


<h3>See Also</h3>

<p><a href="#topic+gradcumbasehazard.basehazardspec">gradcumbasehazard.basehazardspec</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='gradcumbasehazard.basehazardspec'>gradcumbasehazard.basehazardspec function</h2><span id='topic+gradcumbasehazard.basehazardspec'></span>

<h3>Description</h3>

<p>A function to retrieve the gradient of the cumulative baseline hazard function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basehazardspec'
gradcumbasehazard(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradcumbasehazard.basehazardspec_+3A_obj">obj</code></td>
<td>
<p>an object of class basehazardspec</p>
</td></tr>
<tr><td><code id="gradcumbasehazard.basehazardspec_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function returning the gradient of the cumulative baseline hazard
</p>


<h3>See Also</h3>

<p><a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='grid2spdf'>grid2spdf function</h2><span id='topic+grid2spdf'></span>

<h3>Description</h3>

<p>A function to convert a regular (x,y) grid of centroids into a SpatialPoints object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid2spdf(xgrid, ygrid, proj4string = CRS(as.character(NA)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid2spdf_+3A_xgrid">xgrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spdf_+3A_ygrid">ygrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spdf_+3A_proj4string">proj4string</code></td>
<td>
<p>an optional proj4string, projection string for the grid, set using the function CRS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialPolygonsDataFrame
</p>

<hr>
<h2 id='grid2spix'>grid2spix function</h2><span id='topic+grid2spix'></span>

<h3>Description</h3>

<p>A function to convert a regular (x,y) grid of centroids into a SpatialPixels object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid2spix(xgrid, ygrid, proj4string = CRS(as.character(NA)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid2spix_+3A_xgrid">xgrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spix_+3A_ygrid">ygrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spix_+3A_proj4string">proj4string</code></td>
<td>
<p>an optional proj4string, projection string for the grid, set using the function CRS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialPixels object
</p>

<hr>
<h2 id='grid2spts'>grid2spts function</h2><span id='topic+grid2spts'></span>

<h3>Description</h3>

<p>A function to convert a regular (x,y) grid of centroids into a SpatialPoints object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid2spts(xgrid, ygrid, proj4string = CRS(as.character(NA)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid2spts_+3A_xgrid">xgrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spts_+3A_ygrid">ygrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spts_+3A_proj4string">proj4string</code></td>
<td>
<p>an optional proj4string, projection string for the grid, set using the function CRS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialPoints object
</p>

<hr>
<h2 id='gridY'>gridY function</h2><span id='topic+gridY'></span>

<h3>Description</h3>

<p>A function to put estimated individual Y's onto a grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridY(Y, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridY_+3A_y">Y</code></td>
<td>
<p>estimate of Y</p>
</td></tr>
<tr><td><code id="gridY_+3A_control">control</code></td>
<td>
<p>control parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='gridY_polygonal'>gridY_polygonal function</h2><span id='topic+gridY_polygonal'></span>

<h3>Description</h3>

<p>A function to put estimated individual Y's onto a grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridY_polygonal(Y, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridY_polygonal_+3A_y">Y</code></td>
<td>
<p>estimate of Y</p>
</td></tr>
<tr><td><code id="gridY_polygonal_+3A_control">control</code></td>
<td>
<p>control parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='guess_t'>guess_t function</h2><span id='topic+guess_t'></span>

<h3>Description</h3>

<p>A function to get an initial guess of the failure time t, to be used in calibrating the MCMC. Not for general use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_t(surv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_t_+3A_surv">surv</code></td>
<td>
<p>an object of class Surv</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a guess at the failure times
</p>

<hr>
<h2 id='hasNext'>generic hasNext method</h2><span id='topic+hasNext'></span>

<h3>Description</h3>

<p>test if an iterator has any more values to go
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasNext(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasNext_+3A_obj">obj</code></td>
<td>
<p>an iterator</p>
</td></tr>
</table>

<hr>
<h2 id='hasNext.iter'>hasNext.iter function</h2><span id='topic+hasNext.iter'></span>

<h3>Description</h3>

<p>method for iter objects
test if an iterator has any more values to go
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iter'
hasNext(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasNext.iter_+3A_obj">obj</code></td>
<td>
<p>an iterator</p>
</td></tr>
</table>

<hr>
<h2 id='hazard_PP'>hazard_PP function</h2><span id='topic+hazard_PP'></span>

<h3>Description</h3>

<p>A function to compute an individual's hazard function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazard_PP(inputs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hazard_PP_+3A_inputs">inputs</code></td>
<td>
<p>inputs for the function including the model matrix, frailties, fixed effects and the parameters of the baseline hazard derived from this model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the hazard function for the individual
</p>

<hr>
<h2 id='hazardexceedance'>hazardexceedance function</h2><span id='topic+hazardexceedance'></span>

<h3>Description</h3>

<p>A function to compute exceedance probabilities for the spatially correlated frailties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazardexceedance(threshold, direction = "upper")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hazardexceedance_+3A_threshold">threshold</code></td>
<td>
<p>vector of thresholds</p>
</td></tr>
<tr><td><code id="hazardexceedance_+3A_direction">direction</code></td>
<td>
<p>default is &quot;upper&quot; which will calculate P(Y&gt;threshold), alternative is &quot;lower&quot;, which will calculate P(Y&lt;threshold)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that can be passed to the function MCE in order to compute the exceedance probabilities
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
</p>

<hr>
<h2 id='hazardpars'>hazardpars function</h2><span id='topic+hazardpars'></span>

<h3>Description</h3>

<p>A function to return the mcmc chains for the hazard function parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazardpars(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hazardpars_+3A_x">x</code></td>
<td>
<p>an object of class mcmcspatsurv</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the omega mcmc chains
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='hessbasehazard'>hessbasehazard function</h2><span id='topic+hessbasehazard'></span>

<h3>Description</h3>

<p>Generic function for computing the hessian of the baseline hazard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hessbasehazard(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hessbasehazard_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="hessbasehazard_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method hessbasehazard
</p>


<h3>See Also</h3>

<p><a href="#topic+hessbasehazard.basehazardspec">hessbasehazard.basehazardspec</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='hessbasehazard.basehazardspec'>hessbasehazard.basehazardspec function</h2><span id='topic+hessbasehazard.basehazardspec'></span>

<h3>Description</h3>

<p>A function to retrieve the Hessian of the baseline hazard function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basehazardspec'
hessbasehazard(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hessbasehazard.basehazardspec_+3A_obj">obj</code></td>
<td>
<p>an object of class basehazardspec</p>
</td></tr>
<tr><td><code id="hessbasehazard.basehazardspec_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function returning the Hessian of the baseline hazard
</p>


<h3>See Also</h3>

<p><a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='hesscumbasehazard'>hesscumbasehazard function</h2><span id='topic+hesscumbasehazard'></span>

<h3>Description</h3>

<p>Generic function for computing the Hessian of the cumulative baseline hazard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hesscumbasehazard(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hesscumbasehazard_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="hesscumbasehazard_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method hesscumbasehazard
</p>


<h3>See Also</h3>

<p><a href="#topic+hesscumbasehazard.basehazardspec">hesscumbasehazard.basehazardspec</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='hesscumbasehazard.basehazardspec'>hesscumbasehazard.basehazardspec function</h2><span id='topic+hesscumbasehazard.basehazardspec'></span>

<h3>Description</h3>

<p>A function to retrieve the hessian of the cumulative baseline hazard function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basehazardspec'
hesscumbasehazard(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hesscumbasehazard.basehazardspec_+3A_obj">obj</code></td>
<td>
<p>an object of class basehazardspec</p>
</td></tr>
<tr><td><code id="hesscumbasehazard.basehazardspec_+3A_...">...</code></td>
<td>
<p>additional arguments &ndash; currently there are none, but this is for extensibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function returning the hessian of the cumulative baseline hazard
</p>


<h3>See Also</h3>

<p><a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+tpowHaz">tpowHaz</a>
</p>

<hr>
<h2 id='imputationModel'>imputationModel function</h2><span id='topic+imputationModel'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputationModel(formula, offset, covariateData, priors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputationModel_+3A_formula">formula</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="imputationModel_+3A_offset">offset</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="imputationModel_+3A_covariatedata">covariateData</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="imputationModel_+3A_priors">priors</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='Independent'>Independent function</h2><span id='topic+Independent'></span>

<h3>Description</h3>

<p>A function to declare and also evaluate an exponential covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Independent()
</code></pre>


<h3>Value</h3>

<p>the exponential covariance function
</p>


<h3>See Also</h3>

<p><a href="#topic+SpikedExponentialCovFct">SpikedExponentialCovFct</a>, <a href="#topic+covmodel">covmodel</a>
</p>

<hr>
<h2 id='indepGaussianprior'>indepGaussianprior function</h2><span id='topic+indepGaussianprior'></span>

<h3>Description</h3>

<p>A function for evaluating the log of an independent Gaussian prior for a given set of parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indepGaussianprior(beta = NULL, omega = NULL, eta = NULL, priors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indepGaussianprior_+3A_beta">beta</code></td>
<td>
<p>parameter beta at which prior is to be evaluated</p>
</td></tr>
<tr><td><code id="indepGaussianprior_+3A_omega">omega</code></td>
<td>
<p>parameter omega at which prior is to be evaluated</p>
</td></tr>
<tr><td><code id="indepGaussianprior_+3A_eta">eta</code></td>
<td>
<p>parameter eta at which prior is to be evaluated</p>
</td></tr>
<tr><td><code id="indepGaussianprior_+3A_priors">priors</code></td>
<td>
<p>an object of class mcmcPriors, see ?mcmcPriors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the log of the prior evaluated at the given parameter values
</p>


<h3>See Also</h3>

<p><a href="#topic+survspat">survspat</a>, <a href="#topic+betapriorGauss">betapriorGauss</a>, <a href="#topic+omegapriorGauss">omegapriorGauss</a>, <a href="#topic+etapriorGauss">etapriorGauss</a>, <a href="#topic+indepGaussianprior">indepGaussianprior</a>, <a href="#topic+derivindepGaussianprior">derivindepGaussianprior</a>
</p>

<hr>
<h2 id='indepGaussianpriorST'>indepGaussianpriorST function</h2><span id='topic+indepGaussianpriorST'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indepGaussianpriorST(beta = NULL, omega = NULL, eta = NULL, priors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indepGaussianpriorST_+3A_beta">beta</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="indepGaussianpriorST_+3A_omega">omega</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="indepGaussianpriorST_+3A_eta">eta</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="indepGaussianpriorST_+3A_priors">priors</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='inference.control'>inference.control function</h2><span id='topic+inference.control'></span>

<h3>Description</h3>

<p>A function to control inferential settings. This function is used to set parameters for more advanced use of spatsurv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inference.control(
  gridded = FALSE,
  cellwidth = NULL,
  ext = 2,
  imputation = NULL,
  optimcontrol = NULL,
  hessian = FALSE,
  plotcal = FALSE,
  timeonlyMCMC = FALSE,
  nugget = FALSE,
  savenugget = FALSE,
  split = 0.5,
  logUsigma_priormean = 0,
  logUsigma_priorsd = 0.5,
  nis = NULL,
  olinfo = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inference.control_+3A_gridded">gridded</code></td>
<td>
<p>logical. Whether to perform compuation on a grid. Default is FALSE.</p>
</td></tr>
<tr><td><code id="inference.control_+3A_cellwidth">cellwidth</code></td>
<td>
<p>the width of computational cells to use</p>
</td></tr>
<tr><td><code id="inference.control_+3A_ext">ext</code></td>
<td>
<p>integer the number of times to extend the computational grid by in order to perform compuitation. The default is 2.</p>
</td></tr>
<tr><td><code id="inference.control_+3A_imputation">imputation</code></td>
<td>
<p>for polygonal data, an optional model for inference at the sub-polygonal level, see function imputationModel</p>
</td></tr>
<tr><td><code id="inference.control_+3A_optimcontrol">optimcontrol</code></td>
<td>
<p>a list of optional arguments to be passed to optim for non-spatial models</p>
</td></tr>
<tr><td><code id="inference.control_+3A_hessian">hessian</code></td>
<td>
<p>whether to return a numerical hessian. Set this to TRUE for non-spatial models.
equal to the number of parameters of the baseline hazard</p>
</td></tr>
<tr><td><code id="inference.control_+3A_plotcal">plotcal</code></td>
<td>
<p>logical, whether to produce plots of the MCMC calibration process, this is a technical option and should onyl be set
to TRUE if poor mixing is evident (the printed h is low), then it is also useful to use a graphics device with multiple plotting windows.</p>
</td></tr>
<tr><td><code id="inference.control_+3A_timeonlymcmc">timeonlyMCMC</code></td>
<td>
<p>logical, whether to only time the MCMC part of the algorithm, or whether to include in the reported running time the time taken to calibrate the method (default)</p>
</td></tr>
<tr><td><code id="inference.control_+3A_nugget">nugget</code></td>
<td>
<p>whether to include a nugget effect in the estimation. Note that only the mean and variance of the nugget effect is returned.</p>
</td></tr>
<tr><td><code id="inference.control_+3A_savenugget">savenugget</code></td>
<td>
<p>whether to save the MCMC chain for the nugget effect</p>
</td></tr>
<tr><td><code id="inference.control_+3A_split">split</code></td>
<td>
<p>how to split the spatial and nugget proposal variance as a the proportion of variance assigned to the spatial effect apriori. Default is 0.5</p>
</td></tr>
<tr><td><code id="inference.control_+3A_logusigma_priormean">logUsigma_priormean</code></td>
<td>
<p>prior mean for log standard deviation of nugget effect</p>
</td></tr>
<tr><td><code id="inference.control_+3A_logusigma_priorsd">logUsigma_priorsd</code></td>
<td>
<p>prior sd for log standard deviation of nugget effect</p>
</td></tr>
<tr><td><code id="inference.control_+3A_nis">nis</code></td>
<td>
<p>list of cell counts, each element being a matrix, with attributes &quot;x&quot; and &quot;y&quot; giving grid centroids in x and y directions. Used to impute locations of aggregated data:.</p>
</td></tr>
<tr><td><code id="inference.control_+3A_olinfo">olinfo</code></td>
<td>
<p>to be supplied with nis, if continuous inference from aggregated data is required</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns parameters to be used in the function survspat
</p>


<h3>See Also</h3>

<p><a href="#topic+survspat">survspat</a>
</p>

<hr>
<h2 id='insert'>insert function</h2><span id='topic+insert'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert(pars, idx, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_+3A_pars">pars</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="insert_+3A_idx">idx</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="insert_+3A_val">val</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='invtransformweibull'>invtransformweibull function</h2><span id='topic+invtransformweibull'></span>

<h3>Description</h3>

<p>A function to transform estimates of the (alpha, lambda) parameters of the weibull baseline hazard function, so they are commensurate
with R's inbuilt density functions, (shape, scale).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invtransformweibull(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invtransformweibull_+3A_x">x</code></td>
<td>
<p>a vector of paramters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the transformed parameters. For the weibull model, this transforms 'shape' 'scale' (see ?dweibull) to 'alpha' and 'lambda' for the MCMC
</p>

<hr>
<h2 id='is.burnin'>is this a burn-in iteration?</h2><span id='topic+is.burnin'></span>

<h3>Description</h3>

<p>if this mcmc iteration is in the burn-in period, return TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.burnin(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.burnin_+3A_obj">obj</code></td>
<td>
<p>an mcmc iterator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE
</p>

<hr>
<h2 id='is.retain'>do we retain this iteration?</h2><span id='topic+is.retain'></span>

<h3>Description</h3>

<p>if this mcmc iteration is one not thinned out, this is true
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.retain(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.retain_+3A_obj">obj</code></td>
<td>
<p>an mcmc iterator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE
</p>

<hr>
<h2 id='iteration'>iteration number</h2><span id='topic+iteration'></span>

<h3>Description</h3>

<p>within a loop, this is the iteration number we are currently doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iteration(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iteration_+3A_obj">obj</code></td>
<td>
<p>an mcmc iterator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>get the iteration number
</p>


<h3>Value</h3>

<p>integer iteration number, starting from 1.
</p>

<hr>
<h2 id='logPosterior'>logPosterior function</h2><span id='topic+logPosterior'></span>

<h3>Description</h3>

<p>A function to evaluate the log-posterior of a spatial parametric proportional hazards model. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logPosterior(
  surv,
  X,
  beta,
  omega,
  eta,
  gamma,
  priors,
  cov.model,
  u,
  control,
  gradient = FALSE,
  hessian = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logPosterior_+3A_surv">surv</code></td>
<td>
<p>an object of class Surv</p>
</td></tr>
<tr><td><code id="logPosterior_+3A_x">X</code></td>
<td>
<p>the design matrix, containing covariate information</p>
</td></tr>
<tr><td><code id="logPosterior_+3A_beta">beta</code></td>
<td>
<p>parameter beta</p>
</td></tr>
<tr><td><code id="logPosterior_+3A_omega">omega</code></td>
<td>
<p>parameter omega</p>
</td></tr>
<tr><td><code id="logPosterior_+3A_eta">eta</code></td>
<td>
<p>parameter eta</p>
</td></tr>
<tr><td><code id="logPosterior_+3A_gamma">gamma</code></td>
<td>
<p>parameter gamma</p>
</td></tr>
<tr><td><code id="logPosterior_+3A_priors">priors</code></td>
<td>
<p>the priors, an object of class 'mcmcPriors'</p>
</td></tr>
<tr><td><code id="logPosterior_+3A_cov.model">cov.model</code></td>
<td>
<p>the spatial covariance model</p>
</td></tr>
<tr><td><code id="logPosterior_+3A_u">u</code></td>
<td>
<p>vector of interpoint distances</p>
</td></tr>
<tr><td><code id="logPosterior_+3A_control">control</code></td>
<td>
<p>a list containg various control parameters for the MCMC and post-processing routines</p>
</td></tr>
<tr><td><code id="logPosterior_+3A_gradient">gradient</code></td>
<td>
<p>logical whether to evaluate the gradient</p>
</td></tr>
<tr><td><code id="logPosterior_+3A_hessian">hessian</code></td>
<td>
<p>logical whether to evaluate the Hessian</p>
</td></tr>
</table>


<h3>Value</h3>

<p>evaluates the log-posterior and the gradient and hessian, if required.
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li></ol>


<hr>
<h2 id='logPosterior_gridded'>logPosterior_gridded function</h2><span id='topic+logPosterior_gridded'></span>

<h3>Description</h3>

<p>A function to evaluate the log-posterior of a spatial parametric proportional hazards model using gridded Y. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logPosterior_gridded(
  surv,
  X,
  beta,
  omega,
  eta,
  gamma,
  priors,
  cov.model,
  u,
  control,
  gradient = FALSE,
  hessian = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logPosterior_gridded_+3A_surv">surv</code></td>
<td>
<p>an object of class Surv</p>
</td></tr>
<tr><td><code id="logPosterior_gridded_+3A_x">X</code></td>
<td>
<p>the design matrix, containing covariate information</p>
</td></tr>
<tr><td><code id="logPosterior_gridded_+3A_beta">beta</code></td>
<td>
<p>parameter beta</p>
</td></tr>
<tr><td><code id="logPosterior_gridded_+3A_omega">omega</code></td>
<td>
<p>parameter omega</p>
</td></tr>
<tr><td><code id="logPosterior_gridded_+3A_eta">eta</code></td>
<td>
<p>parameter eta</p>
</td></tr>
<tr><td><code id="logPosterior_gridded_+3A_gamma">gamma</code></td>
<td>
<p>parameter gamma</p>
</td></tr>
<tr><td><code id="logPosterior_gridded_+3A_priors">priors</code></td>
<td>
<p>the priors, an object of class 'mcmcPriors'</p>
</td></tr>
<tr><td><code id="logPosterior_gridded_+3A_cov.model">cov.model</code></td>
<td>
<p>the spatial covariance model</p>
</td></tr>
<tr><td><code id="logPosterior_gridded_+3A_u">u</code></td>
<td>
<p>vector of interpoint distances</p>
</td></tr>
<tr><td><code id="logPosterior_gridded_+3A_control">control</code></td>
<td>
<p>a list containg various control parameters for the MCMC and post-processing routines</p>
</td></tr>
<tr><td><code id="logPosterior_gridded_+3A_gradient">gradient</code></td>
<td>
<p>logical whether to evaluate the gradient</p>
</td></tr>
<tr><td><code id="logPosterior_gridded_+3A_hessian">hessian</code></td>
<td>
<p>logical whether to evaluate the Hessian</p>
</td></tr>
</table>


<h3>Value</h3>

<p>evaluates the log-posterior and the gradient and hessian, if required.
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li></ol>


<hr>
<h2 id='logPosterior_polygonal'>logPosterior_polygonal function</h2><span id='topic+logPosterior_polygonal'></span>

<h3>Description</h3>

<p>A function to evaluate the log-posterior of a spatial parametric proportional hazards model. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logPosterior_polygonal(
  surv,
  X,
  beta,
  omega,
  eta,
  gamma,
  priors,
  cov.model,
  u,
  control,
  gradient = FALSE,
  hessian = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logPosterior_polygonal_+3A_surv">surv</code></td>
<td>
<p>an object of class Surv</p>
</td></tr>
<tr><td><code id="logPosterior_polygonal_+3A_x">X</code></td>
<td>
<p>the design matrix, containing covariate information</p>
</td></tr>
<tr><td><code id="logPosterior_polygonal_+3A_beta">beta</code></td>
<td>
<p>parameter beta</p>
</td></tr>
<tr><td><code id="logPosterior_polygonal_+3A_omega">omega</code></td>
<td>
<p>parameter omega</p>
</td></tr>
<tr><td><code id="logPosterior_polygonal_+3A_eta">eta</code></td>
<td>
<p>parameter eta</p>
</td></tr>
<tr><td><code id="logPosterior_polygonal_+3A_gamma">gamma</code></td>
<td>
<p>parameter gamma</p>
</td></tr>
<tr><td><code id="logPosterior_polygonal_+3A_priors">priors</code></td>
<td>
<p>the priors, an object of class 'mcmcPriors'</p>
</td></tr>
<tr><td><code id="logPosterior_polygonal_+3A_cov.model">cov.model</code></td>
<td>
<p>the spatial covariance model</p>
</td></tr>
<tr><td><code id="logPosterior_polygonal_+3A_u">u</code></td>
<td>
<p>vector of interpoint distances</p>
</td></tr>
<tr><td><code id="logPosterior_polygonal_+3A_control">control</code></td>
<td>
<p>a list containg various control parameters for the MCMC and post-processing routines</p>
</td></tr>
<tr><td><code id="logPosterior_polygonal_+3A_gradient">gradient</code></td>
<td>
<p>logical whether to evaluate the gradient</p>
</td></tr>
<tr><td><code id="logPosterior_polygonal_+3A_hessian">hessian</code></td>
<td>
<p>logical whether to evaluate the Hessian</p>
</td></tr>
</table>


<h3>Value</h3>

<p>evaluates the log-posterior and the gradient and hessian, if required.
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li></ol>


<hr>
<h2 id='logPosterior_SPDE'>logPosterior_SPDE function</h2><span id='topic+logPosterior_SPDE'></span>

<h3>Description</h3>

<p>A function to evaluate the log-posterior of a spatial parametric proportional hazards model. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logPosterior_SPDE(
  surv,
  X,
  beta,
  omega,
  eta,
  gamma,
  priors,
  cov.model,
  u,
  control,
  gradient = FALSE,
  hessian = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logPosterior_SPDE_+3A_surv">surv</code></td>
<td>
<p>an object of class Surv</p>
</td></tr>
<tr><td><code id="logPosterior_SPDE_+3A_x">X</code></td>
<td>
<p>the design matrix, containing covariate information</p>
</td></tr>
<tr><td><code id="logPosterior_SPDE_+3A_beta">beta</code></td>
<td>
<p>parameter beta</p>
</td></tr>
<tr><td><code id="logPosterior_SPDE_+3A_omega">omega</code></td>
<td>
<p>parameter omega</p>
</td></tr>
<tr><td><code id="logPosterior_SPDE_+3A_eta">eta</code></td>
<td>
<p>parameter eta</p>
</td></tr>
<tr><td><code id="logPosterior_SPDE_+3A_gamma">gamma</code></td>
<td>
<p>parameter gamma</p>
</td></tr>
<tr><td><code id="logPosterior_SPDE_+3A_priors">priors</code></td>
<td>
<p>the priors, an object of class 'mcmcPriors'</p>
</td></tr>
<tr><td><code id="logPosterior_SPDE_+3A_cov.model">cov.model</code></td>
<td>
<p>the spatial covariance model</p>
</td></tr>
<tr><td><code id="logPosterior_SPDE_+3A_u">u</code></td>
<td>
<p>vector of interpoint distances</p>
</td></tr>
<tr><td><code id="logPosterior_SPDE_+3A_control">control</code></td>
<td>
<p>a list containg various control parameters for the MCMC and post-processing routines</p>
</td></tr>
<tr><td><code id="logPosterior_SPDE_+3A_gradient">gradient</code></td>
<td>
<p>logical whether to evaluate the gradient</p>
</td></tr>
<tr><td><code id="logPosterior_SPDE_+3A_hessian">hessian</code></td>
<td>
<p>logical whether to evaluate the Hessian</p>
</td></tr>
</table>


<h3>Value</h3>

<p>evaluates the log-posterior and the gradient and hessian, if required.
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li>
<li><p> Finn Lindgren, Havard Rue, Johan Lindstrom. An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach. Journal of the Royal Statistical Society: Series B 73(4)
</p>
</li></ol>


<hr>
<h2 id='loop.mcmc'>loop over an iterator</h2><span id='topic+loop.mcmc'></span>

<h3>Description</h3>

<p>useful for testing progress bars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loop.mcmc(object, sleep = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loop.mcmc_+3A_object">object</code></td>
<td>
<p>an mcmc iterator</p>
</td></tr>
<tr><td><code id="loop.mcmc_+3A_sleep">sleep</code></td>
<td>
<p>pause between iterations in seconds</p>
</td></tr>
</table>

<hr>
<h2 id='makehamHaz'>makehamHaz function</h2><span id='topic+makehamHaz'></span>

<h3>Description</h3>

<p>A function to define a parametric proportional hazards model where the baseline hazard is taken from the Gompertz-Makeham model. 
This function returns an object inheriting class 'basehazardspec', list of functions 'distinfo', 'basehazard', 'gradbasehazard', 'hessbasehazard',
'cumbasehazard', 'gradcumbasehazard', 'hesscumbasehazard' and 'densityquantile'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makehamHaz()
</code></pre>


<h3>Details</h3>

<p>The <code>distinfo</code> function is used to provide basic distribution specific information to other <code>spatsurv</code> functions. The user is required 
to provide the following information in the returned list: <code>npars</code>, the number of parameters in this distribution; <code>parnames</code>, 
the names of the parameters; <code>trans</code>, the transformation scale on which the priors will be provided; <code>itrans</code>, the inverse 
transformation function that will be applied to the parameters before the hazard, and other functions are evaluated; <code>jacobian</code>, 
the derivative of the inverse transformation function with respect to each of the parameters; and <code>hessian</code>, the second derivatives 
of the inverse transformation function with respect to each of the parameters &ndash; note that currently the package <code>spatsurv</code> 
only allows the use of functions where the parameters are transformed independently.
</p>
<p>The <code>basehazard</code> function is used to evaluate the baseline hazard function for the distribution of interest. It returns a 
function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradbasehazard</code> function is used to evaluate the gradient of the baseline hazard function with respect to the parameters, 
this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hessbasehazard</code> function is used to evaluate the Hessian of the baseline hazard function. It returns a function that accepts 
as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>cumbasehazard</code> function is used to evaluate the cumulative baseline hazard function for the distribution of interest. 
It returns a function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradcumbasehazard</code> function is used to evaluate the gradient of the cumulative baseline hazard function with respect 
to the parameters, this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hesscumbasehazard</code> function is used to evaluate the Hessian of the cumulative baseline hazard function. It returns a 
function that accepts as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>densityquantile</code> function is used to return quantiles of the density function. This is NOT REQUIRED for running the MCMC, 
merely for us in post-processing with the <code>predict</code> function where <code>type</code> is 'densityquantile'. In the case of the Weibull 
model for the baseline hazard, it can be shown that the q-th quantile is:
</p>


<h3>Value</h3>

<p>an object inheriting class 'basehazardspec'
</p>


<h3>See Also</h3>

<p><a href="#topic+tpowHaz">tpowHaz</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>
</p>

<hr>
<h2 id='maxlikparamPHsurv'>maxlikparamPHsurv function</h2><span id='topic+maxlikparamPHsurv'></span>

<h3>Description</h3>

<p>A function to get initial estimates of model parameters using maximum likelihood. Not intended for general purose use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxlikparamPHsurv(surv, X, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxlikparamPHsurv_+3A_surv">surv</code></td>
<td>
<p>an object of class Surv</p>
</td></tr>
<tr><td><code id="maxlikparamPHsurv_+3A_x">X</code></td>
<td>
<p>the design matrix, containing covariate information</p>
</td></tr>
<tr><td><code id="maxlikparamPHsurv_+3A_control">control</code></td>
<td>
<p>a list containg various control parameters for the MCMC and post-processing routines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>initial estimates of the parameters
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li></ol>


<hr>
<h2 id='MCE'>MCE function</h2><span id='topic+MCE'></span>

<h3>Description</h3>

<p>A function to compute Monte Carlo expectations from an object inheriting class mcmcspatsurv
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCE(object, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCE_+3A_object">object</code></td>
<td>
<p>an object inheriting class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="MCE_+3A_fun">fun</code></td>
<td>
<p>a function with arguments beta, omega, eta and Y</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the Monte Carlo mean of the function over the posterior.
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='mcmcLoop'>iterator for MCMC loops</h2><span id='topic+mcmcLoop'></span>

<h3>Description</h3>

<p>control an MCMC loop with this iterator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcLoop(N, burnin, thin, trim = TRUE, progressor = mcmcProgressPrint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcLoop_+3A_n">N</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="mcmcLoop_+3A_burnin">burnin</code></td>
<td>
<p>length of burn-in</p>
</td></tr>
<tr><td><code id="mcmcLoop_+3A_thin">thin</code></td>
<td>
<p>frequency of thinning</p>
</td></tr>
<tr><td><code id="mcmcLoop_+3A_trim">trim</code></td>
<td>
<p>whether to cut off iterations after the last retained iteration</p>
</td></tr>
<tr><td><code id="mcmcLoop_+3A_progressor">progressor</code></td>
<td>
<p>a function that returns a progress object</p>
</td></tr>
</table>

<hr>
<h2 id='mcmcpars'>mcmcpars function</h2><span id='topic+mcmcpars'></span>

<h3>Description</h3>

<p>A function for setting MCMC options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcpars(nits, burn, thin, inits = NULL, adaptivescheme = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcpars_+3A_nits">nits</code></td>
<td>
<p>numer of iterations,</p>
</td></tr>
<tr><td><code id="mcmcpars_+3A_burn">burn</code></td>
<td>
<p>length of burnin</p>
</td></tr>
<tr><td><code id="mcmcpars_+3A_thin">thin</code></td>
<td>
<p>thinning parameter eg operated on chain every 'thin' iteration (eg store output or compute some posterior functional)</p>
</td></tr>
<tr><td><code id="mcmcpars_+3A_inits">inits</code></td>
<td>
<p>NOT CURRENTLY IN USE</p>
</td></tr>
<tr><td><code id="mcmcpars_+3A_adaptivescheme">adaptivescheme</code></td>
<td>
<p>NOT CURRENTLY IN USE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mcmc parameters
</p>

<hr>
<h2 id='mcmcPriors'>mcmcPriors function</h2><span id='topic+mcmcPriors'></span>

<h3>Description</h3>

<p>A function to define priors for the MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcPriors(
  betaprior = NULL,
  omegaprior = NULL,
  etaprior = NULL,
  call = NULL,
  derivative = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcPriors_+3A_betaprior">betaprior</code></td>
<td>
<p>prior for beta, the covariate effects</p>
</td></tr>
<tr><td><code id="mcmcPriors_+3A_omegaprior">omegaprior</code></td>
<td>
<p>prior for omega, the parameters of the baseline hazard</p>
</td></tr>
<tr><td><code id="mcmcPriors_+3A_etaprior">etaprior</code></td>
<td>
<p>prior for eta, the parameters of the latent field</p>
</td></tr>
<tr><td><code id="mcmcPriors_+3A_call">call</code></td>
<td>
<p>function to evaluate the log-prior e.g. logindepGaussianprior</p>
</td></tr>
<tr><td><code id="mcmcPriors_+3A_derivative">derivative</code></td>
<td>
<p>function to evaluate the first and second derivatives of the prior</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package <code>spatsurv</code> only provides functionality for the built-in Gaussian priors. However, the choice of prior is 
extensible by the user by creating functions similar to the functions <code>betapriorGauss</code>, <code>omegapriorGauss</code>, <code>etapriorGauss</code>, 
<code>indepGaussianprior</code> and <code>derivindepGaussianprior</code>: the first three of which provide a mechanism for storing and retrieving the 
parameters of the priors; the fourth, a function for evaluating the log of the prior for a given set of parameter values; and the fifth, a 
function for evaluating the first and second derivatives of the log of the prior. It is assumed that parameters are a priori independent. 
The user interested in using other priors is encouraged to look at the structure of the five functions mentioned above.
</p>


<h3>Value</h3>

<p>an object of class mcmcPriors
</p>


<h3>See Also</h3>

<p><a href="#topic+survspat">survspat</a>, <a href="#topic+betapriorGauss">betapriorGauss</a>, <a href="#topic+omegapriorGauss">omegapriorGauss</a>, <a href="#topic+etapriorGauss">etapriorGauss</a>, <a href="#topic+indepGaussianprior">indepGaussianprior</a>, <a href="#topic+derivindepGaussianprior">derivindepGaussianprior</a>
</p>

<hr>
<h2 id='mcmcProgressNone'>null progress monitor</h2><span id='topic+mcmcProgressNone'></span>

<h3>Description</h3>

<p>a progress monitor that does nothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcProgressNone(mcmcloop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcProgressNone_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>an mcmc loop iterator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a progress monitor
</p>

<hr>
<h2 id='mcmcProgressPrint'>printing progress monitor</h2><span id='topic+mcmcProgressPrint'></span>

<h3>Description</h3>

<p>a progress monitor that prints each iteration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcProgressPrint(mcmcloop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcProgressPrint_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>an mcmc loop iterator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a progress monitor
</p>

<hr>
<h2 id='mcmcProgressTextBar'>text bar progress monitor</h2><span id='topic+mcmcProgressTextBar'></span>

<h3>Description</h3>

<p>a progress monitor that uses a text progress bar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcProgressTextBar(mcmcloop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcProgressTextBar_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>an mcmc loop iterator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a progress monitor
</p>

<hr>
<h2 id='midpts'>midpts function</h2><span id='topic+midpts'></span>

<h3>Description</h3>

<p>A function to compute the midpoints of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midpts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midpts_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the midpoints, a vector of length length(x)-1
</p>

<hr>
<h2 id='multiWayHaz'>multiWayHaz function</h2><span id='topic+multiWayHaz'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiWayHaz(bhlist, bhtime, bhfix, MLinits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiWayHaz_+3A_bhlist">bhlist</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="multiWayHaz_+3A_bhtime">bhtime</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="multiWayHaz_+3A_bhfix">bhfix</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="multiWayHaz_+3A_mlinits">MLinits</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='neighLocs'>neighLocs function</h2><span id='topic+neighLocs'></span>

<h3>Description</h3>

<p>A function used in the computation of neighbours on non-rectangular grids. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighLocs(coord, cellwidth, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighLocs_+3A_coord">coord</code></td>
<td>
<p>coordinate of interest</p>
</td></tr>
<tr><td><code id="neighLocs_+3A_cellwidth">cellwidth</code></td>
<td>
<p>a scalar, the width of the grid cells</p>
</td></tr>
<tr><td><code id="neighLocs_+3A_order">order</code></td>
<td>
<p>the order of the SPDE approximation: see Lindgren et al 2011 for details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coordinates of centroids of neighbours
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li>
<li><p> Finn Lindgren, Havard Rue, Johan Lindstrom. An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach. Journal of the Royal Statistical Society: Series B 73(4)
</p>
</li></ol>


<hr>
<h2 id='neighOrder'>neighOrder function</h2><span id='topic+neighOrder'></span>

<h3>Description</h3>

<p>A function to compute the order of a set of neighbours. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighOrder(neighlocs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighOrder_+3A_neighlocs">neighlocs</code></td>
<td>
<p>an object created by the function neighLocs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the neighbour orders
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li>
<li><p> Finn Lindgren, Havard Rue, Johan Lindstrom. An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach. Journal of the Royal Statistical Society: Series B 73(4)
</p>
</li></ol>


<hr>
<h2 id='nextStep'>next step of an MCMC chain</h2><span id='topic+nextStep'></span>

<h3>Description</h3>

<p>just a wrapper for nextElem really.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextStep(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextStep_+3A_object">object</code></td>
<td>
<p>an mcmc loop object</p>
</td></tr>
</table>

<hr>
<h2 id='NonSpatialLogLikelihood_or_gradient'>NonSpatialLogLikelihood_or_gradient function</h2><span id='topic+NonSpatialLogLikelihood_or_gradient'></span>

<h3>Description</h3>

<p>A function to evaluate the log-likelihood of a non-spatial parametric proportional hazards model. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NonSpatialLogLikelihood_or_gradient(
  surv,
  X,
  beta,
  omega,
  control,
  loglikelihood,
  gradient
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NonSpatialLogLikelihood_or_gradient_+3A_surv">surv</code></td>
<td>
<p>an object of class Surv</p>
</td></tr>
<tr><td><code id="NonSpatialLogLikelihood_or_gradient_+3A_x">X</code></td>
<td>
<p>the design matrix, containing covariate information</p>
</td></tr>
<tr><td><code id="NonSpatialLogLikelihood_or_gradient_+3A_beta">beta</code></td>
<td>
<p>parameter beta</p>
</td></tr>
<tr><td><code id="NonSpatialLogLikelihood_or_gradient_+3A_omega">omega</code></td>
<td>
<p>parameter omega</p>
</td></tr>
<tr><td><code id="NonSpatialLogLikelihood_or_gradient_+3A_control">control</code></td>
<td>
<p>a list containg various control parameters for the MCMC and post-processing routines</p>
</td></tr>
<tr><td><code id="NonSpatialLogLikelihood_or_gradient_+3A_loglikelihood">loglikelihood</code></td>
<td>
<p>logical whether to evaluate the log-likelihood</p>
</td></tr>
<tr><td><code id="NonSpatialLogLikelihood_or_gradient_+3A_gradient">gradient</code></td>
<td>
<p>logical whether to evaluate the gradient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li></ol>


<hr>
<h2 id='omegapriorGauss'>omegapriorGauss function</h2><span id='topic+omegapriorGauss'></span>

<h3>Description</h3>

<p>A function to define Gaussian priors for omega. This function simply stores a vector of means and standard deviations to be passed to the main MCMC function, survspat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omegapriorGauss(mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omegapriorGauss_+3A_mean">mean</code></td>
<td>
<p>the prior mean, a vector of length 1 or more. 1 implies a common mean.</p>
</td></tr>
<tr><td><code id="omegapriorGauss_+3A_sd">sd</code></td>
<td>
<p>the prior standard deviation, a vector of length 1 or more. 1 implies a common standard deviation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;omegapriorGauss&quot;
</p>


<h3>See Also</h3>

<p><a href="#topic+survspat">survspat</a>, <a href="#topic+betapriorGauss">betapriorGauss</a>, <a href="#topic+omegapriorGauss">omegapriorGauss</a>, <a href="#topic+etapriorGauss">etapriorGauss</a>, <a href="#topic+indepGaussianprior">indepGaussianprior</a>, <a href="#topic+derivindepGaussianprior">derivindepGaussianprior</a>
</p>

<hr>
<h2 id='omegapriorGaussST'>omegapriorGaussST function</h2><span id='topic+omegapriorGaussST'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omegapriorGaussST(basehaz, fmean, fsd, taumean, tausd, thetamean, thetasd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omegapriorGaussST_+3A_basehaz">basehaz</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="omegapriorGaussST_+3A_fmean">fmean</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="omegapriorGaussST_+3A_fsd">fsd</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="omegapriorGaussST_+3A_taumean">taumean</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="omegapriorGaussST_+3A_tausd">tausd</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="omegapriorGaussST_+3A_thetamean">thetamean</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="omegapriorGaussST_+3A_thetasd">thetasd</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='optifix'>optifix function</h2><span id='topic+optifix'></span>

<h3>Description</h3>

<p>optifix. Optimise with fixed parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optifix(
  par,
  fixed,
  fn,
  gr = NULL,
  ...,
  method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN"),
  lower = -Inf,
  upper = Inf,
  control = list(),
  hessian = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optifix_+3A_par">par</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="optifix_+3A_fixed">fixed</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="optifix_+3A_fn">fn</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="optifix_+3A_gr">gr</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="optifix_+3A_...">...</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="optifix_+3A_method">method</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="optifix_+3A_lower">lower</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="optifix_+3A_upper">upper</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="optifix_+3A_control">control</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="optifix_+3A_hessian">hessian</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Details</h3>

<p>its like optim, but with fixed parameters.
</p>
<p>specify a second argument 'fixed', a vector of TRUE/FALSE values.
If TRUE, the corresponding parameter in fn() is fixed. Otherwise its
variable and optimised over.
</p>
<p>The return thing is the return thing from optim() but with a couple of extra
bits - a vector of all the parameters and a vector copy of the 'fixed' argument.
</p>
<p>Written by Barry Rowlingson &lt;b.rowlingson@lancaster.ac.uk&gt; October 2011
</p>
<p>This file released under a CC By-SA license:
http://creativecommons.org/licenses/by-sa/3.0/
</p>
<p>and must retain the text: &quot;Originally written by Barry Rowlingson&quot; in comments.
</p>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='plot.FFTgrid'>plot.FFTgrid function</h2><span id='topic+plot.FFTgrid'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FFTgrid'
plot(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.FFTgrid_+3A_x">x</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="plot.FFTgrid_+3A_y">y</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="plot.FFTgrid_+3A_...">...</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='plotsurv'>plotsurv function</h2><span id='topic+plotsurv'></span>

<h3>Description</h3>

<p>A function to produce a 2-D plot of right censored spatial survival data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsurv(
  spp,
  ss,
  maxcex = 1,
  transform = identity,
  background = NULL,
  eventpt = 19,
  eventcol = "red",
  censpt = "+",
  censcol = "black",
  xlim = NULL,
  ylim = NULL,
  xlab = NULL,
  ylab = NULL,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotsurv_+3A_spp">spp</code></td>
<td>
<p>A spatial points data frame</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_ss">ss</code></td>
<td>
<p>A Surv object (with right-censoring)</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_maxcex">maxcex</code></td>
<td>
<p>maximum size of dots default is equavalent to setting cex equal to 1</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_transform">transform</code></td>
<td>
<p>optional transformation to apply to the data, a function, for example 'sqrt'</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_background">background</code></td>
<td>
<p>a background object to plot default is null, which gives a blamk background note that if non-null, the parameters xlim and ylim will be derived from this object.</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_eventpt">eventpt</code></td>
<td>
<p>The type of point to illustrate events, default is 19 (see ?pch)</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_eventcol">eventcol</code></td>
<td>
<p>the colour of events, default is black</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_censpt">censpt</code></td>
<td>
<p>The type of point to illustrate events, default is &quot;+&quot; (see ?pch)</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_censcol">censcol</code></td>
<td>
<p>the colour of censored observations, default is red</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_xlim">xlim</code></td>
<td>
<p>optional x-limits of plot, default is to choose this automatically</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_ylim">ylim</code></td>
<td>
<p>optional y-limits of plot, default is to choose this automatically</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_xlab">xlab</code></td>
<td>
<p>label for x-axis</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_add">add</code></td>
<td>
<p>logical, whether to add the survival plot on top of an existing plot, default is FALSE, which produces a plot in a new device</p>
</td></tr>
<tr><td><code id="plotsurv_+3A_...">...</code></td>
<td>
<p>other arguments to pass to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots the survival data non-censored observations appear as dots and censored observations as crosses. The size of the dot is proportional to the observed time.
</p>

<hr>
<h2 id='polyadd'>polyadd function</h2><span id='topic+polyadd'></span>

<h3>Description</h3>

<p>A function to add two polynomials in the form of vectors of coefficients. The first
element of the vector being the constant (order 0) term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyadd(poly1, poly2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyadd_+3A_poly1">poly1</code></td>
<td>
<p>a vector of coefficients for the first polynomial of length degree plus 1</p>
</td></tr>
<tr><td><code id="polyadd_+3A_poly2">poly2</code></td>
<td>
<p>a vector of coefficients for the second polynomial of length degree plus 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the coefficients of the sum of poly1 and poly2
</p>

<hr>
<h2 id='polymult'>polymult function</h2><span id='topic+polymult'></span>

<h3>Description</h3>

<p>A function to multiply two polynomials in the form of vectors of coefficients. The first
element of the vector being the constant (order 0) term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polymult(poly1, poly2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polymult_+3A_poly1">poly1</code></td>
<td>
<p>a vector of coefficients for the first polynomial of length degree plus 1</p>
</td></tr>
<tr><td><code id="polymult_+3A_poly2">poly2</code></td>
<td>
<p>a vector of coefficients for the second polynomial of length degree plus 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the coefficients of the product of poly1 and poly2
</p>

<hr>
<h2 id='posteriorcov'>posteriorcov function</h2><span id='topic+posteriorcov'></span>

<h3>Description</h3>

<p>A function to produce a plot of the posterior covariance function with upper and lower quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriorcov(
  x,
  probs = c(0.025, 0.5, 0.975),
  rmax = NULL,
  n = 100,
  plot = TRUE,
  bw = FALSE,
  corr = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriorcov_+3A_x">x</code></td>
<td>
<p>an object of class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="posteriorcov_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities to be fed to quantile function</p>
</td></tr>
<tr><td><code id="posteriorcov_+3A_rmax">rmax</code></td>
<td>
<p>maximum distance in space to compute this distance up to</p>
</td></tr>
<tr><td><code id="posteriorcov_+3A_n">n</code></td>
<td>
<p>the number of points at which to evaluate the posterior covariance.</p>
</td></tr>
<tr><td><code id="posteriorcov_+3A_plot">plot</code></td>
<td>
<p>whether to plot the result</p>
</td></tr>
<tr><td><code id="posteriorcov_+3A_bw">bw</code></td>
<td>
<p>Logical. Plot in black/white/greyscale? Default is to produce a colour plot. Useful for producing plots for journals that do not accept colour plots.</p>
</td></tr>
<tr><td><code id="posteriorcov_+3A_corr">corr</code></td>
<td>
<p>logical whether to return the correlation function, default is FALSE i.e. returns the covariance function</p>
</td></tr>
<tr><td><code id="posteriorcov_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to matplot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>produces a plot of the posterior spatial covariance function.
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='predict.mcmcspatsurv'>predict.mcmcspatsurv function</h2><span id='topic+predict.mcmcspatsurv'></span>

<h3>Description</h3>

<p>A function to produce predictions from MCMC output. These could include quantiles of the individual density, survival or
hazard functions or quantiles of the density function (if available analytically).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcspatsurv'
predict(
  object,
  type = "density",
  t = NULL,
  n = 110,
  indx = NULL,
  probs = c(0.025, 0.5, 0.975),
  plot = TRUE,
  pause = TRUE,
  bw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mcmcspatsurv_+3A_object">object</code></td>
<td>
<p>an object of class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="predict.mcmcspatsurv_+3A_type">type</code></td>
<td>
<p>can be &quot;density&quot;, &quot;hazard&quot;, &quot;survival&quot; or &quot;densityquantile&quot;. Default is &quot;density&quot;. Note that &quot;densityquantile&quot; is not always analytically tractable for some choices of baseline hazard function.</p>
</td></tr>
<tr><td><code id="predict.mcmcspatsurv_+3A_t">t</code></td>
<td>
<p>optional vector of times at which to compute the quantiles, Defult is NULL, in which case a uniformly spaced vector of length n from 0 to the maximum time is used</p>
</td></tr>
<tr><td><code id="predict.mcmcspatsurv_+3A_n">n</code></td>
<td>
<p>the number of points at which to compute the quantiles if t is NULL</p>
</td></tr>
<tr><td><code id="predict.mcmcspatsurv_+3A_indx">indx</code></td>
<td>
<p>the index number of a particular individual or vector of indices of individuals for which the quantiles should be produced</p>
</td></tr>
<tr><td><code id="predict.mcmcspatsurv_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="predict.mcmcspatsurv_+3A_plot">plot</code></td>
<td>
<p>whether to plot the result</p>
</td></tr>
<tr><td><code id="predict.mcmcspatsurv_+3A_pause">pause</code></td>
<td>
<p>logical whether to pause between plots, the default is TRUE</p>
</td></tr>
<tr><td><code id="predict.mcmcspatsurv_+3A_bw">bw</code></td>
<td>
<p>Logical. Plot in black/white/greyscale? Default is to produce a colour plot. Useful for producing plots for journals that do not accept colour plots.</p>
</td></tr>
<tr><td><code id="predict.mcmcspatsurv_+3A_...">...</code></td>
<td>
<p>other arguments, not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the required predictions
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='print.mcmc'>print.mcmc function</h2><span id='topic+print.mcmc'></span>

<h3>Description</h3>

<p>print method
print an mcmc iterator's details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mcmc_+3A_x">x</code></td>
<td>
<p>a mcmc iterator</p>
</td></tr>
<tr><td><code id="print.mcmc_+3A_...">...</code></td>
<td>
<p>other args</p>
</td></tr>
</table>

<hr>
<h2 id='print.mcmcspatsurv'>print.mcmcspatsurv function</h2><span id='topic+print.mcmcspatsurv'></span>

<h3>Description</h3>

<p>A function to print summary tables from an MCMC run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcspatsurv'
print(x, probs = c(0.5, 0.025, 0.975), digits = 3, scientific = -3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mcmcspatsurv_+3A_x">x</code></td>
<td>
<p>an object inheriting class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="print.mcmcspatsurv_+3A_probs">probs</code></td>
<td>
<p>vector of quantiles to return</p>
</td></tr>
<tr><td><code id="print.mcmcspatsurv_+3A_digits">digits</code></td>
<td>
<p>see help file ?format</p>
</td></tr>
<tr><td><code id="print.mcmcspatsurv_+3A_scientific">scientific</code></td>
<td>
<p>see help file ?format</p>
</td></tr>
<tr><td><code id="print.mcmcspatsurv_+3A_...">...</code></td>
<td>
<p>additional arguments, not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints summary tables to the console
</p>


<h3>See Also</h3>

<p><a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='print.mlspatsurv'>print.mlspatsurv function</h2><span id='topic+print.mlspatsurv'></span>

<h3>Description</h3>

<p>A function to print summary tables from an MCMC run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlspatsurv'
print(x, probs = c(0.5, 0.025, 0.975), digits = 3, scientific = -3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mlspatsurv_+3A_x">x</code></td>
<td>
<p>an object inheriting class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="print.mlspatsurv_+3A_probs">probs</code></td>
<td>
<p>vector of quantiles to return</p>
</td></tr>
<tr><td><code id="print.mlspatsurv_+3A_digits">digits</code></td>
<td>
<p>see help file ?format</p>
</td></tr>
<tr><td><code id="print.mlspatsurv_+3A_scientific">scientific</code></td>
<td>
<p>see help file ?format</p>
</td></tr>
<tr><td><code id="print.mlspatsurv_+3A_...">...</code></td>
<td>
<p>additional arguments, not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints summary tables to the console
</p>


<h3>See Also</h3>

<p><a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='print.textSummary'>print.textSummary function</h2><span id='topic+print.textSummary'></span>

<h3>Description</h3>

<p>A function to print summary tables from an MCMC run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'textSummary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.textSummary_+3A_x">x</code></td>
<td>
<p>an object inheriting class textSummary</p>
</td></tr>
<tr><td><code id="print.textSummary_+3A_...">...</code></td>
<td>
<p>additional arguments, not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints a text summary of 'x' to the console
</p>

<hr>
<h2 id='priorposterior'>priorposterior function</h2><span id='topic+priorposterior'></span>

<h3>Description</h3>

<p>A function to produce plots of the prior (which shows as a red line) and posterior (showing as a histogram)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priorposterior(
  x,
  breaks = 30,
  ylab = "Density",
  main = "",
  pause = TRUE,
  bw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priorposterior_+3A_x">x</code></td>
<td>
<p>an object inheriting class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="priorposterior_+3A_breaks">breaks</code></td>
<td>
<p>see ?hist</p>
</td></tr>
<tr><td><code id="priorposterior_+3A_ylab">ylab</code></td>
<td>
<p>optional y label</p>
</td></tr>
<tr><td><code id="priorposterior_+3A_main">main</code></td>
<td>
<p>optional title</p>
</td></tr>
<tr><td><code id="priorposterior_+3A_pause">pause</code></td>
<td>
<p>logical whether to pause between plots, the default is TRUE</p>
</td></tr>
<tr><td><code id="priorposterior_+3A_bw">bw</code></td>
<td>
<p>Logical. Plot in black/white/greyscale? Default is to produce a colour plot. Useful for producing plots for journals that do not accept colour plots.</p>
</td></tr>
<tr><td><code id="priorposterior_+3A_...">...</code></td>
<td>
<p>other arguments passed to the hist function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots of the prior (red line) and posterior (histogram).
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='proposalVariance'>proposalVariance function</h2><span id='topic+proposalVariance'></span>

<h3>Description</h3>

<p>A function to compute an approximate scaling matrix for the MCMC algorithm. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proposalVariance(
  X,
  surv,
  betahat,
  omegahat,
  Yhat,
  priors,
  cov.model,
  u,
  control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proposalVariance_+3A_x">X</code></td>
<td>
<p>the design matrix, containing covariate information</p>
</td></tr>
<tr><td><code id="proposalVariance_+3A_surv">surv</code></td>
<td>
<p>an object of class Surv</p>
</td></tr>
<tr><td><code id="proposalVariance_+3A_betahat">betahat</code></td>
<td>
<p>an estimate of beta</p>
</td></tr>
<tr><td><code id="proposalVariance_+3A_omegahat">omegahat</code></td>
<td>
<p>an estimate of omega</p>
</td></tr>
<tr><td><code id="proposalVariance_+3A_yhat">Yhat</code></td>
<td>
<p>an estimate of Y</p>
</td></tr>
<tr><td><code id="proposalVariance_+3A_priors">priors</code></td>
<td>
<p>the priors</p>
</td></tr>
<tr><td><code id="proposalVariance_+3A_cov.model">cov.model</code></td>
<td>
<p>the spatial covariance model</p>
</td></tr>
<tr><td><code id="proposalVariance_+3A_u">u</code></td>
<td>
<p>a vector of pairwise distances</p>
</td></tr>
<tr><td><code id="proposalVariance_+3A_control">control</code></td>
<td>
<p>a list containg various control parameters for the MCMC and post-processing routines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an estimate of eta and also an approximate scaling matrix for the MCMC
</p>

<hr>
<h2 id='proposalVariance_gridded'>proposalVariance_gridded function</h2><span id='topic+proposalVariance_gridded'></span>

<h3>Description</h3>

<p>A function to compute an approximate scaling matrix for the MCMC algorithm. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proposalVariance_gridded(
  X,
  surv,
  betahat,
  omegahat,
  Yhat,
  priors,
  cov.model,
  u,
  control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proposalVariance_gridded_+3A_x">X</code></td>
<td>
<p>the design matrix, containing covariate information</p>
</td></tr>
<tr><td><code id="proposalVariance_gridded_+3A_surv">surv</code></td>
<td>
<p>an object of class Surv</p>
</td></tr>
<tr><td><code id="proposalVariance_gridded_+3A_betahat">betahat</code></td>
<td>
<p>an estimate of beta</p>
</td></tr>
<tr><td><code id="proposalVariance_gridded_+3A_omegahat">omegahat</code></td>
<td>
<p>an estimate of omega</p>
</td></tr>
<tr><td><code id="proposalVariance_gridded_+3A_yhat">Yhat</code></td>
<td>
<p>an estimate of Y</p>
</td></tr>
<tr><td><code id="proposalVariance_gridded_+3A_priors">priors</code></td>
<td>
<p>the priors</p>
</td></tr>
<tr><td><code id="proposalVariance_gridded_+3A_cov.model">cov.model</code></td>
<td>
<p>the spatial covariance model</p>
</td></tr>
<tr><td><code id="proposalVariance_gridded_+3A_u">u</code></td>
<td>
<p>a vector of pairwise distances</p>
</td></tr>
<tr><td><code id="proposalVariance_gridded_+3A_control">control</code></td>
<td>
<p>a list containg various control parameters for the MCMC and post-processing routines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an estimate of eta and also an approximate scaling matrix for the MCMC
</p>

<hr>
<h2 id='proposalVariance_polygonal'>proposalVariance_polygonal function</h2><span id='topic+proposalVariance_polygonal'></span>

<h3>Description</h3>

<p>A function to compute an approximate scaling matrix for the MCMC algorithm. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proposalVariance_polygonal(
  X,
  surv,
  betahat,
  omegahat,
  Yhat,
  priors,
  cov.model,
  u,
  control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proposalVariance_polygonal_+3A_x">X</code></td>
<td>
<p>the design matrix, containing covariate information</p>
</td></tr>
<tr><td><code id="proposalVariance_polygonal_+3A_surv">surv</code></td>
<td>
<p>an object of class Surv</p>
</td></tr>
<tr><td><code id="proposalVariance_polygonal_+3A_betahat">betahat</code></td>
<td>
<p>an estimate of beta</p>
</td></tr>
<tr><td><code id="proposalVariance_polygonal_+3A_omegahat">omegahat</code></td>
<td>
<p>an estimate of omega</p>
</td></tr>
<tr><td><code id="proposalVariance_polygonal_+3A_yhat">Yhat</code></td>
<td>
<p>an estimate of Y</p>
</td></tr>
<tr><td><code id="proposalVariance_polygonal_+3A_priors">priors</code></td>
<td>
<p>the priors</p>
</td></tr>
<tr><td><code id="proposalVariance_polygonal_+3A_cov.model">cov.model</code></td>
<td>
<p>the spatial covariance model</p>
</td></tr>
<tr><td><code id="proposalVariance_polygonal_+3A_u">u</code></td>
<td>
<p>a vector of pairwise distances</p>
</td></tr>
<tr><td><code id="proposalVariance_polygonal_+3A_control">control</code></td>
<td>
<p>a list containg various control parameters for the MCMC and post-processing routines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an estimate of eta and also an approximate scaling matrix for the MCMC
</p>

<hr>
<h2 id='proposalVariance_SPDE'>proposalVariance_SPDE function</h2><span id='topic+proposalVariance_SPDE'></span>

<h3>Description</h3>

<p>A function to compute an approximate scaling matrix for the MCMC algorithm. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proposalVariance_SPDE(
  X,
  surv,
  betahat,
  omegahat,
  Yhat,
  priors,
  cov.model,
  u,
  control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proposalVariance_SPDE_+3A_x">X</code></td>
<td>
<p>the design matrix, containing covariate information</p>
</td></tr>
<tr><td><code id="proposalVariance_SPDE_+3A_surv">surv</code></td>
<td>
<p>an object of class Surv</p>
</td></tr>
<tr><td><code id="proposalVariance_SPDE_+3A_betahat">betahat</code></td>
<td>
<p>an estimate of beta</p>
</td></tr>
<tr><td><code id="proposalVariance_SPDE_+3A_omegahat">omegahat</code></td>
<td>
<p>an estimate of omega</p>
</td></tr>
<tr><td><code id="proposalVariance_SPDE_+3A_yhat">Yhat</code></td>
<td>
<p>an estimate of Y</p>
</td></tr>
<tr><td><code id="proposalVariance_SPDE_+3A_priors">priors</code></td>
<td>
<p>the priors</p>
</td></tr>
<tr><td><code id="proposalVariance_SPDE_+3A_cov.model">cov.model</code></td>
<td>
<p>the spatial covariance model</p>
</td></tr>
<tr><td><code id="proposalVariance_SPDE_+3A_u">u</code></td>
<td>
<p>a vector of pairwise distances</p>
</td></tr>
<tr><td><code id="proposalVariance_SPDE_+3A_control">control</code></td>
<td>
<p>a list containg various control parameters for the MCMC and post-processing routines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an estimate of eta and also an approximate scaling matrix for the MCMC
</p>

<hr>
<h2 id='PsplineHaz'>PsplineHaz function</h2><span id='topic+PsplineHaz'></span>

<h3>Description</h3>

<p>A function to define a parametric proportional hazards model where the baseline hazard is modelled by a basis spline and 
where the coefficients of the model follow a partially imporper random walk prior. 
This function returns an object inheriting class 'basehazardspec', list of functions 'distinfo', 'basehazard', 'gradbasehazard', 'hessbasehazard',
'cumbasehazard', 'gradcumbasehazard', 'hesscumbasehazard' and 'densityquantile'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PsplineHaz(times, knots = quantile(times), degree = 3, MLinits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PsplineHaz_+3A_times">times</code></td>
<td>
<p>vector of survival times (both censored and uncensored)</p>
</td></tr>
<tr><td><code id="PsplineHaz_+3A_knots">knots</code></td>
<td>
<p>vector of knots in ascending order, must include minimum and maximum values of 'times'</p>
</td></tr>
<tr><td><code id="PsplineHaz_+3A_degree">degree</code></td>
<td>
<p>degree of the spline basis, default is 3</p>
</td></tr>
<tr><td><code id="PsplineHaz_+3A_mlinits">MLinits</code></td>
<td>
<p>optional starting values for the non-spatial maximisation routine using optim. Note that we are working with the log of the parameters. Default is -10 for each parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>distinfo</code> function is used to provide basic distribution specific information to other <code>spatsurv</code> functions. The user is required 
to provide the following information in the returned list: <code>npars</code>, the number of parameters in this distribution; <code>parnames</code>, 
the names of the parameters; <code>trans</code>, the transformation scale on which the priors will be provided; <code>itrans</code>, the inverse 
transformation function that will be applied to the parameters before the hazard, and other functions are evaluated; <code>jacobian</code>, 
the derivative of the inverse transformation function with respect to each of the parameters; and <code>hessian</code>, the second derivatives 
of the inverse transformation function with respect to each of the parameters &ndash; note that currently the package <code>spatsurv</code> 
only allows the use of functions where the parameters are transformed independently.
</p>
<p>The <code>basehazard</code> function is used to evaluate the baseline hazard function for the distribution of interest. It returns a 
function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradbasehazard</code> function is used to evaluate the gradient of the baseline hazard function with respect to the parameters, 
this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hessbasehazard</code> function is used to evaluate the Hessian of the baseline hazard function. It returns a function that accepts 
as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>cumbasehazard</code> function is used to evaluate the cumulative baseline hazard function for the distribution of interest. 
It returns a function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradcumbasehazard</code> function is used to evaluate the gradient of the cumulative baseline hazard function with respect 
to the parameters, this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hesscumbasehazard</code> function is used to evaluate the Hessian of the cumulative baseline hazard function. It returns a 
function that accepts as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>densityquantile</code> function is used to return quantiles of the density function. This is NOT REQUIRED for running the MCMC, 
merely for us in post-processing with the <code>predict</code> function where <code>type</code> is 'densityquantile'. In the case of the Weibull 
model for the baseline hazard, it can be shown that the q-th quantile is:
</p>


<h3>Value</h3>

<p>an object inheriting class 'basehazardspec'
</p>


<h3>See Also</h3>

<p><a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>
</p>

<hr>
<h2 id='psplineprior'>psplineprior function</h2><span id='topic+psplineprior'></span>

<h3>Description</h3>

<p>A function for evaluating the log of an independent Gaussian prior for a given set of parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psplineprior(beta = NULL, omega = NULL, eta = NULL, priors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psplineprior_+3A_beta">beta</code></td>
<td>
<p>parameter beta at which prior is to be evaluated</p>
</td></tr>
<tr><td><code id="psplineprior_+3A_omega">omega</code></td>
<td>
<p>parameter omega at which prior is to be evaluated</p>
</td></tr>
<tr><td><code id="psplineprior_+3A_eta">eta</code></td>
<td>
<p>parameter eta at which prior is to be evaluated</p>
</td></tr>
<tr><td><code id="psplineprior_+3A_priors">priors</code></td>
<td>
<p>an object of class mcmcPriors, see ?mcmcPriors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the log of the prior evaluated at the given parameter values
</p>


<h3>See Also</h3>

<p><a href="#topic+survspat">survspat</a>, <a href="#topic+betapriorGauss">betapriorGauss</a>, <a href="#topic+omegapriorGauss">omegapriorGauss</a>, <a href="#topic+etapriorGauss">etapriorGauss</a>, <a href="#topic+indepGaussianprior">indepGaussianprior</a>, <a href="#topic+derivindepGaussianprior">derivindepGaussianprior</a>
</p>

<hr>
<h2 id='psplineRWprior'>psplineRWprior function</h2><span id='topic+psplineRWprior'></span>

<h3>Description</h3>

<p>A function to define Gaussian priors for omega. This function simply stores a vector of means and standard deviations to be passed to the main MCMC function, survspat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psplineRWprior(taumean, tausd, basehaz, order = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psplineRWprior_+3A_taumean">taumean</code></td>
<td>
<p>the prior mean, a vector of length 1 or more. 1 implies a common mean.</p>
</td></tr>
<tr><td><code id="psplineRWprior_+3A_tausd">tausd</code></td>
<td>
<p>the prior standard deviation, a vector of length 1 or more. 1 implies a common standard deviation.</p>
</td></tr>
<tr><td><code id="psplineRWprior_+3A_basehaz">basehaz</code></td>
<td>
<p>an object inheriting class &quot;basehazardspec&quot;, specificlly, this function was used for such objects created by a call to the function PsplineHaz</p>
</td></tr>
<tr><td><code id="psplineRWprior_+3A_order">order</code></td>
<td>
<p>the order of the random walk, default is 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;omegapriorGauss&quot;
</p>


<h3>See Also</h3>

<p><a href="#topic+survspat">survspat</a>, <a href="#topic+betapriorGauss">betapriorGauss</a>, <a href="#topic+omegapriorGauss">omegapriorGauss</a>, <a href="#topic+etapriorGauss">etapriorGauss</a>, <a href="#topic+indepGaussianprior">indepGaussianprior</a>, <a href="#topic+derivindepGaussianprior">derivindepGaussianprior</a>
</p>

<hr>
<h2 id='QuadApprox'>QuadApprox function</h2><span id='topic+QuadApprox'></span>

<h3>Description</h3>

<p>A function to compute the second derivative of a function (of several real variables) using a quadratic approximation  on a
grid of points defined by the list argRanges. Also returns the local maximum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuadApprox(fun, npts, argRanges, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QuadApprox_+3A_fun">fun</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="QuadApprox_+3A_npts">npts</code></td>
<td>
<p>integer number of points in each direction</p>
</td></tr>
<tr><td><code id="QuadApprox_+3A_argranges">argRanges</code></td>
<td>
<p>a list of ranges on which to construct the grid for each parameter</p>
</td></tr>
<tr><td><code id="QuadApprox_+3A_plot">plot</code></td>
<td>
<p>whether to plot the quadratic approximation of the posterior (for two-dimensional parameters only)</p>
</td></tr>
<tr><td><code id="QuadApprox_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to fun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2 by 2 matrix containing the curvature at the maximum and the (x,y) value at which the maximum occurs
</p>

<hr>
<h2 id='quantile.mcmcspatsurv'>quantile.mcmcspatsurv function</h2><span id='topic+quantile.mcmcspatsurv'></span>

<h3>Description</h3>

<p>A function to extract quantiles of the parameters from an mcmc run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcspatsurv'
quantile(x, probs = c(0.025, 0.5, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.mcmcspatsurv_+3A_x">x</code></td>
<td>
<p>an object inheriting class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="quantile.mcmcspatsurv_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="quantile.mcmcspatsurv_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the function, not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quantiles of model parameters
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='quantile.mlspatsurv'>quantile.mlspatsurv function</h2><span id='topic+quantile.mlspatsurv'></span>

<h3>Description</h3>

<p>A function to extract quantiles of the parameters from an mcmc run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlspatsurv'
quantile(x, probs = c(0.025, 0.5, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.mlspatsurv_+3A_x">x</code></td>
<td>
<p>an object inheriting class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="quantile.mlspatsurv_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="quantile.mlspatsurv_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the function, not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quantiles of model parameters
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='randompars'>randompars function</h2><span id='topic+randompars'></span>

<h3>Description</h3>

<p>A function to return the mcmc chains for the spatially correlated frailties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randompars(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randompars_+3A_x">x</code></td>
<td>
<p>an object of class mcmcspatsurv</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the Y mcmc chains
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='reconstruct.bs'>reconstruct.bs function</h2><span id='topic+reconstruct.bs'></span>

<h3>Description</h3>

<p>Generic function for reconstructing B-spline covariate effects. See ?reconstruct.bs.mcmcspatsurv and ?reconstruct.bs.coxph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct.bs(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstruct.bs_+3A_mod">mod</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="reconstruct.bs_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method reconstruct.bs
</p>

<hr>
<h2 id='reconstruct.bs.coxph'>reconstruct.bs.coxph function</h2><span id='topic+reconstruct.bs.coxph'></span>

<h3>Description</h3>

<p>When bs(varname) has been used in the formula of a coxph model, this function can be used to reconstruct the predicted relative risk of
that parameter over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxph'
reconstruct.bs(
  mod,
  varname,
  fun = NULL,
  probs = c(0.025, 0.975),
  bw = FALSE,
  xlab = NULL,
  ylab = NULL,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstruct.bs.coxph_+3A_mod">mod</code></td>
<td>
<p>model output, created by function survspat</p>
</td></tr>
<tr><td><code id="reconstruct.bs.coxph_+3A_varname">varname</code></td>
<td>
<p>name of the variable modelled by a B-spline</p>
</td></tr>
<tr><td><code id="reconstruct.bs.coxph_+3A_fun">fun</code></td>
<td>
<p>optional function to feed in. Default is to plot relative risk against the covariate of interest. Useful choices include &quot;identity&quot; (but with no quotes), which plots the non-linear effect on the scale of the linear predictor.</p>
</td></tr>
<tr><td><code id="reconstruct.bs.coxph_+3A_probs">probs</code></td>
<td>
<p>upper and lower quantiles for confidence regions to plot&gt; The default is c(0.025,0.975).</p>
</td></tr>
<tr><td><code id="reconstruct.bs.coxph_+3A_bw">bw</code></td>
<td>
<p>Logical. Plot in black/white/greyscale? Default is to produce a colour plot. Useful for producing plots for journals that do not accept colour plots.</p>
</td></tr>
<tr><td><code id="reconstruct.bs.coxph_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis, there is a sensible default</p>
</td></tr>
<tr><td><code id="reconstruct.bs.coxph_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis, there is a sensible default</p>
</td></tr>
<tr><td><code id="reconstruct.bs.coxph_+3A_plot">plot</code></td>
<td>
<p>logical, whether to plot the effect of varname over time</p>
</td></tr>
<tr><td><code id="reconstruct.bs.coxph_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the plotting function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>median, upper and lower confidence bands for the effect of varname over time; the funciton also produces a plot.
</p>

<hr>
<h2 id='reconstruct.bs.mcmcspatsurv'>reconstruct.bs.mcmcspatsurv function</h2><span id='topic+reconstruct.bs.mcmcspatsurv'></span>

<h3>Description</h3>

<p>When bs(varname) has been used in the formula of a model, this function can be used to reconstruct the posterior relative risk of
that parameter over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcspatsurv'
reconstruct.bs(
  mod,
  varname,
  probs = c(0.025, 0.975),
  bw = FALSE,
  xlab = NULL,
  ylab = NULL,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstruct.bs.mcmcspatsurv_+3A_mod">mod</code></td>
<td>
<p>model output, created by function survspat</p>
</td></tr>
<tr><td><code id="reconstruct.bs.mcmcspatsurv_+3A_varname">varname</code></td>
<td>
<p>name of the variable modelled by a B-spline</p>
</td></tr>
<tr><td><code id="reconstruct.bs.mcmcspatsurv_+3A_probs">probs</code></td>
<td>
<p>upper and lower quantiles for confidence regions to plot&gt; The default is c(0.025,0.975).</p>
</td></tr>
<tr><td><code id="reconstruct.bs.mcmcspatsurv_+3A_bw">bw</code></td>
<td>
<p>Logical. Plot in black/white/greyscale? Default is to produce a colour plot. Useful for producing plots for journals that do not accept colour plots.</p>
</td></tr>
<tr><td><code id="reconstruct.bs.mcmcspatsurv_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis, there is a sensible default</p>
</td></tr>
<tr><td><code id="reconstruct.bs.mcmcspatsurv_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis, there is a sensible default</p>
</td></tr>
<tr><td><code id="reconstruct.bs.mcmcspatsurv_+3A_plot">plot</code></td>
<td>
<p>logical, whether to plot the effect of varname over time</p>
</td></tr>
<tr><td><code id="reconstruct.bs.mcmcspatsurv_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the plotting function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>median, upper and lower confidence bands for the effect of varname over time; the funciton also produces a plot.
</p>

<hr>
<h2 id='resetLoop'>reset iterator</h2><span id='topic+resetLoop'></span>

<h3>Description</h3>

<p>call this to reset an iterator's state to the initial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetLoop(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resetLoop_+3A_obj">obj</code></td>
<td>
<p>an mcmc iterator</p>
</td></tr>
</table>

<hr>
<h2 id='residuals.mcmcspatsurv'>resuiduals.mcmcspatsurv function</h2><span id='topic+residuals.mcmcspatsurv'></span>

<h3>Description</h3>

<p>A function to compute Cox-Snell / modeified Cox-Snell / Martingale or Deviance residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcspatsurv'
residuals(object, type = "Cox-Snell", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.mcmcspatsurv_+3A_object">object</code></td>
<td>
<p>an object produced by the function survspat</p>
</td></tr>
<tr><td><code id="residuals.mcmcspatsurv_+3A_type">type</code></td>
<td>
<p>type of residuals to return. Possible choices are 'Cox-Snell', 'modified-Cox-Snell', 'Martingale' or 'deviance'.</p>
</td></tr>
<tr><td><code id="residuals.mcmcspatsurv_+3A_...">...</code></td>
<td>
<p>other arguments (not used here)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the residuals
</p>

<hr>
<h2 id='rootWeibullHaz'>rootWeibullHaz function</h2><span id='topic+rootWeibullHaz'></span>

<h3>Description</h3>

<p>A function to define a parametric proportional hazards model where the baseline hazard is taken from the Weibull model.
This function returns an object inheriting class 'basehazardspec', list of functions 'distinfo', 'basehazard', 'gradbasehazard', 'hessbasehazard',
'cumbasehazard', 'gradcumbasehazard', 'hesscumbasehazard' and 'densityquantile'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rootWeibullHaz(MLinits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rootWeibullHaz_+3A_mlinits">MLinits</code></td>
<td>
<p>initial values for optim, default is NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>distinfo</code> function is used to provide basic distribution specific information to other <code>spatsurv</code> functions. The user is required
to provide the following information in the returned list: <code>npars</code>, the number of parameters in this distribution; <code>parnames</code>,
the names of the parameters; <code>trans</code>, the transformation scale on which the priors will be provided; <code>itrans</code>, the inverse
transformation function that will be applied to the parameters before the hazard, and other functions are evaluated; <code>jacobian</code>,
the derivative of the inverse transformation function with respect to each of the parameters; and <code>hessian</code>, the second derivatives
of the inverse transformation function with respect to each of the parameters &ndash; note that currently the package <code>spatsurv</code>
only allows the use of functions where the parameters are transformed independently.
</p>
<p>The <code>basehazard</code> function is used to evaluate the baseline hazard function for the distribution of interest. It returns a
function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradbasehazard</code> function is used to evaluate the gradient of the baseline hazard function with respect to the parameters,
this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hessbasehazard</code> function is used to evaluate the Hessian of the baseline hazard function. It returns a function that accepts
as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>cumbasehazard</code> function is used to evaluate the cumulative baseline hazard function for the distribution of interest.
It returns a function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradcumbasehazard</code> function is used to evaluate the gradient of the cumulative baseline hazard function with respect
to the parameters, this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hesscumbasehazard</code> function is used to evaluate the Hessian of the cumulative baseline hazard function. It returns a
function that accepts as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>densityquantile</code> function is used to return quantiles of the density function. This is NOT REQUIRED for running the MCMC,
merely for us in post-processing with the <code>predict</code> function where <code>type</code> is 'densityquantile'. In the case of the Weibull
model for the baseline hazard, it can be shown that the q-th quantile is:
</p>


<h3>Value</h3>

<p>an object inheriting class 'basehazardspec'
</p>


<h3>See Also</h3>

<p><a href="#topic+tpowHaz">tpowHaz</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>
</p>

<hr>
<h2 id='setTxtProgressBar2'>set the progress bar</h2><span id='topic+setTxtProgressBar2'></span>

<h3>Description</h3>

<p>update a text progress bar. See help(txtProgressBar) for more info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTxtProgressBar2(pb, value, title = NULL, label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setTxtProgressBar2_+3A_pb">pb</code></td>
<td>
<p>text progress bar object</p>
</td></tr>
<tr><td><code id="setTxtProgressBar2_+3A_value">value</code></td>
<td>
<p>new value</p>
</td></tr>
<tr><td><code id="setTxtProgressBar2_+3A_title">title</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="setTxtProgressBar2_+3A_label">label</code></td>
<td>
<p>text for end of progress bar</p>
</td></tr>
</table>

<hr>
<h2 id='setupHazard'>setupHazard function</h2><span id='topic+setupHazard'></span>

<h3>Description</h3>

<p>A function to set up the baseline hazard, cumulative hazard and derivative functions for use in evaluating the log posterior.
This fucntion is not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupHazard(dist, pars, grad = FALSE, hess = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setupHazard_+3A_dist">dist</code></td>
<td>
<p>an object of class 'basehazardspec'</p>
</td></tr>
<tr><td><code id="setupHazard_+3A_pars">pars</code></td>
<td>
<p>parameters with which to create the functions necessary to evaluate the log posterior</p>
</td></tr>
<tr><td><code id="setupHazard_+3A_grad">grad</code></td>
<td>
<p>logical, whetether to create gradient functions for the baseline hazard and cumulative hazard</p>
</td></tr>
<tr><td><code id="setupHazard_+3A_hess">hess</code></td>
<td>
<p>logical, whetether to create hessian functions for the baseline hazard and cumulative hazard</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of functions used in evaluating the log posterior
</p>

<hr>
<h2 id='setupPrecMatStruct'>setupPrecMatStruct function</h2><span id='topic+setupPrecMatStruct'></span>

<h3>Description</h3>

<p>A function to set up the computational grid and precision matrix structure for SPDE models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupPrecMatStruct(shape, cellwidth, no)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setupPrecMatStruct_+3A_shape">shape</code></td>
<td>
<p>an object of class SpatialPolygons or SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="setupPrecMatStruct_+3A_cellwidth">cellwidth</code></td>
<td>
<p>a scalar, the width of the grid cells</p>
</td></tr>
<tr><td><code id="setupPrecMatStruct_+3A_no">no</code></td>
<td>
<p>the order of the SPDE approximation: see Lindgren et al 2011 for details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the computational grid and a function for constructing the precision matrix
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li>
<li><p> Finn Lindgren, Havard Rue, Johan Lindstrom. An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach. Journal of the Royal Statistical Society: Series B 73(4)
</p>
</li></ol>


<hr>
<h2 id='showGrid'>showGrid function</h2><span id='topic+showGrid'></span>

<h3>Description</h3>

<p>A function to show the grid that will be used for a given cellwidth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showGrid(dat, cellwidth, ext = 2, boundingbox = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showGrid_+3A_dat">dat</code></td>
<td>
<p>any spatial data object whose bounding box can be computed using the function bbox.</p>
</td></tr>
<tr><td><code id="showGrid_+3A_cellwidth">cellwidth</code></td>
<td>
<p>an initial suggested cellwidth</p>
</td></tr>
<tr><td><code id="showGrid_+3A_ext">ext</code></td>
<td>
<p>the extension parameter for the FFT transform, set to 2 by default</p>
</td></tr>
<tr><td><code id="showGrid_+3A_boundingbox">boundingbox</code></td>
<td>
<p>optional bounding box over which to construct computational grid, supplied as an object on which the function 'bbox' returns the bounding box</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot showing the grid and the data. Ideally the data should only just fit inside the grid.
</p>

<hr>
<h2 id='simsurv'>simsurv function</h2><span id='topic+simsurv'></span>

<h3>Description</h3>

<p>A function to simulate spatial parametric proportional hazards model. The function works
by simulating candidate survival times using MCMC in parallel for each individual based on each individual's covariates and the common
parameter effects, beta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsurv(
  X = cbind(age = runif(100, 5, 50), sex = rbinom(100, 1, 0.5), cancer = rbinom(100, 1,
    0.2)),
  beta = c(0.0296, 0.0261, 0.035),
  omega = 1,
  dist = exponentialHaz(),
  coords = matrix(runif(2 * nrow(X)), nrow(X), 2),
  cov.parameters = c(1, 0.1),
  cov.model = ExponentialCovFct(),
  mcmc.control = mcmcpars(nits = 1e+05, burn = 10000, thin = 90),
  savechains = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simsurv_+3A_x">X</code></td>
<td>
<p>a matrix of covariate information</p>
</td></tr>
<tr><td><code id="simsurv_+3A_beta">beta</code></td>
<td>
<p>the parameter effects</p>
</td></tr>
<tr><td><code id="simsurv_+3A_omega">omega</code></td>
<td>
<p>vector of parameters for the baseline hazard model</p>
</td></tr>
<tr><td><code id="simsurv_+3A_dist">dist</code></td>
<td>
<p>the distribution choice: exp or weibull at present</p>
</td></tr>
<tr><td><code id="simsurv_+3A_coords">coords</code></td>
<td>
<p>matrix with 2 columns giving the coordinates at which to simulate data</p>
</td></tr>
<tr><td><code id="simsurv_+3A_cov.parameters">cov.parameters</code></td>
<td>
<p>a vector: the parameters for the covariance function</p>
</td></tr>
<tr><td><code id="simsurv_+3A_cov.model">cov.model</code></td>
<td>
<p>an object of class covmodel, see ?covmodel</p>
</td></tr>
<tr><td><code id="simsurv_+3A_mcmc.control">mcmc.control</code></td>
<td>
<p>mcmc control paramters, see ?mcmcpars</p>
</td></tr>
<tr><td><code id="simsurv_+3A_savechains">savechains</code></td>
<td>
<p>save all chains? runs faster if set to FALSE, but then you'll be unable to conduct convergence/mixing diagnostics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>in list element 'survtimes', a vector of simulated survival times (the last simulated value from the MCMC chains)
in list element 'T' the MCMC chains
</p>


<h3>See Also</h3>

<p><a href="#topic+covmodel">covmodel</a>, <a href="#topic+survspat">survspat</a>, <a href="#topic+tpowHaz">tpowHaz</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>
</p>

<hr>
<h2 id='spatialpars'>spatialpars function</h2><span id='topic+spatialpars'></span>

<h3>Description</h3>

<p>A function to return the mcmc chains for the spatial covariance function parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialpars(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialpars_+3A_x">x</code></td>
<td>
<p>an object of class mcmcspatsurv</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the eta mcmc chains
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='spatsurv-package'>spatsurv</h2><span id='topic+spatsurv-package'></span><span id='topic+spatsurv'></span>

<h3>Description</h3>

<p>An R package for spatially correlated parametric proportional hazards survial analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatsurv
</code></pre>


<h3>Format</h3>

<p>An object of class <code>logical</code> of length 1.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> spatsurv</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Bayesian Spatial Survival Analysis with Parametric Proportional
Hazards Models</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.0-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-10-18</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Benjamin M. Taylor and Barry S. Rowlingson
        Additional contributions
        Ziyu Zheng</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Benjamin M. Taylor &lt;benjamin.taylor.software@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Bayesian inference for parametric proportional hazards spatial
    survival models; flexible spatial survival models. See Benjamin M. Taylor, Barry S. Rowlingson (2017) &lt;doi:10.18637/jss.v077.i04&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> survival, sp, spatstat.explore, spatstat.geom,
spatstat.random, raster, iterators, fields, Matrix, stringr,
sf, RColorBrewer, methods, lubridate</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> rgl</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> 2022-11-22 14:11:17 UTC; taylorb7</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.10)</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository: </td><td style="text-align: left;"> CRAN</td>
</tr>
<tr>
 <td style="text-align: left;">
Date/Publication: </td><td style="text-align: left;"> 2022-11-22 14:30:02 UTC</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
.onAttach               .onAttach function
B                       B function
Bspline.construct       Bspline.construct function
BsplineHaz              BsplineHaz function
CSplot                  CSplot function
Et_PP                   Et_PP function
EvalCov                 EvalCov function
ExponentialCovFct       ExponentialCovFct function
FFTgrid                 FFTgrid function
GammaFromY_SPDE         GammaFromY_SPDE function
GammafromY              GammafromY function
Independent             Independent function
MCE                     MCE function
NonSpatialLogLikelihood_or_gradient
                        NonSpatialLogLikelihood_or_gradient function
PsplineHaz              PsplineHaz function
QuadApprox              QuadApprox function
SPDE                    SPDE function
SPDEprec                SPDEprec function
SpikedExponentialCovFct
                        SpikedExponentialCovFct function
Summarise               Summarise function
TwoWayHazAdditive       TwoWayHazAdditive function
YFromGamma_SPDE         YFromGamma_SPDE function
YfromGamma              YfromGamma function
allocate                allocate function
alpha                   alpha function
baseHazST               baseHazST function
basehazard              basehazard function
basehazard.basehazardspec
                        basehazard.basehazardspec function
baselinehazard          baselinehazard function
baselinehazard_multiWay
                        baselinehazard_multiWay function
betapriorGauss          betapriorGauss function
blockDiag               A function to
boxplotRisk             boxplotRisk function
checkSurvivalData       checkSurvivalData function
circulant               circulant function
circulant.matrix        circulant.matrix function
circulant.numeric       circulant.numeric function
circulantij             circulantij function
covmodel                covmodel function
cumbasehazard           cumbasehazard function
cumbasehazard.basehazardspec
                        cumbasehazard.basehazardspec function
cumulativeBspline.construct
                        cumulativeBspline.construct function
density_PP              density_PP function
densityquantile         densityquantile function
densityquantile.basehazardspec
                        densityquantile.basehazardspec function
densityquantile_PP      densityquantile_PP function
derivindepGaussianprior
                        derivindepGaussianprior function
derivindepGaussianpriorST
                        derivindepGaussianpriorST function
derivpsplineprior       derivpsplineprior function
distinfo                distinfo function
distinfo.basehazardspec
                        distinfo.basehazardspec function
estimateY               estimateY function
etapriorGauss           etapriorGauss function
exponentialHaz          exponentialHaz function
fixParHaz               fixParHaz function
fixedpars               fixedpars function
fixmatrix               fixmatrix function
frailtylag1             frailtylag1 function
fs                      London Fire Brigade property
fstimes                 London Fire Brigade response times to dwelling
                        fires, 2009
gamma2risk              gamma2risk function
gencens                 gencens function
getBbasis               getBbasis function
getGrid                 getGrid function
getOptCellwidth         getOptCellwidth function
getbb                   getbb function
getcov                  getcov function
getgrd                  getgrd function
getleneta               getleneta function
getparranges            getparranges function
getsurvdata             getsurvdata function
gompertzHaz             gompertzHaz function
gradbasehazard          gradbasehazard function
gradbasehazard.basehazardspec
                        gradbasehazard.basehazardspec function
gradcumbasehazard       gradcumbasehazard function
gradcumbasehazard.basehazardspec
                        gradcumbasehazard.basehazardspec function
grid2spdf               grid2spdf function
grid2spix               grid2spix function
grid2spts               grid2spts function
gridY                   gridY function
gridY_polygonal         gridY_polygonal function
guess_t                 guess_t function
hasNext                 generic hasNext method
hasNext.iter            hasNext.iter function
hazard_PP               hazard_PP function
hazardexceedance        hazardexceedance function
hazardpars              hazardpars function
hessbasehazard          hessbasehazard function
hessbasehazard.basehazardspec
                        hessbasehazard.basehazardspec function
hesscumbasehazard       hesscumbasehazard function
hesscumbasehazard.basehazardspec
                        hesscumbasehazard.basehazardspec function
imputationModel         imputationModel function
indepGaussianprior      indepGaussianprior function
indepGaussianpriorST    indepGaussianpriorST function
inference.control       inference.control function
insert                  insert function
invtransformweibull     invtransformweibull function
is.burnin               is this a burn-in iteration?
is.retain               do we retain this iteration?
iteration               iteration number
logPosterior            logPosterior function
logPosterior_SPDE       logPosterior_SPDE function
logPosterior_gridded    logPosterior_gridded function
logPosterior_polygonal
                        logPosterior_polygonal function
loop.mcmc               loop over an iterator
makehamHaz              makehamHaz function
maxlikparamPHsurv       maxlikparamPHsurv function
mcmcLoop                iterator for MCMC loops
mcmcPriors              mcmcPriors function
mcmcProgressNone        null progress monitor
mcmcProgressPrint       printing progress monitor
mcmcProgressTextBar     text bar progress monitor
mcmcpars                mcmcpars function
midpts                  midpts function
multiWayHaz             multiWayHaz function
neighLocs               neighLocs function
neighOrder              neighOrder function
nextStep                next step of an MCMC chain
omegapriorGauss         omegapriorGauss function
omegapriorGaussST       omegapriorGaussST function
optifix                 optifix function
plot.FFTgrid            plot.FFTgrid function
plotsurv                plotsurv function
polyadd                 polyadd function
polymult                polymult function
posteriorcov            posteriorcov function
predict.mcmcspatsurv    predict.mcmcspatsurv function
print.mcmc              print.mcmc function
print.mcmcspatsurv      print.mcmcspatsurv function
print.mlspatsurv        print.mlspatsurv function
print.textSummary       print.textSummary function
priorposterior          priorposterior function
proposalVariance        proposalVariance function
proposalVariance_SPDE   proposalVariance_SPDE function
proposalVariance_gridded
                        proposalVariance_gridded function
proposalVariance_polygonal
                        proposalVariance_polygonal function
psplineRWprior          psplineRWprior function
psplineprior            psplineprior function
quantile.mcmcspatsurv   quantile.mcmcspatsurv function
quantile.mlspatsurv     quantile.mlspatsurv function
randompars              randompars function
reconstruct.bs          reconstruct.bs function
reconstruct.bs.coxph    reconstruct.bs.coxph function
reconstruct.bs.mcmcspatsurv
                        reconstruct.bs.mcmcspatsurv function
resetLoop               reset iterator
residuals.mcmcspatsurv
                        resuiduals.mcmcspatsurv function
rootWeibullHaz          rootWeibullHaz function
setTxtProgressBar2      set the progress bar
setupHazard             setupHazard function
setupPrecMatStruct      setupPrecMatStruct function
showGrid                showGrid function
simsurv                 simsurv function
spatialpars             spatialpars function
spatsurv-package        spatsurv
spatsurvVignette        spatsurvVignette function
summary.mcmc            summary.mcmc function
summary.mcmcspatsurv    summary.mcmcspatsurv function
surv3d                  Spatial Survival Plot in 3D
survival_PP             survival_PP function
survspat                survspat function
survspatNS              survspatNS function
textSummary             textSummary function
timevaryingPL           timevaryingPL function
tpowHaz                 tpowHaz function
transformweibull        transformweibull function
txtProgressBar2         A text progress bar with label
vcov.mcmcspatsurv       vcov.mcmcspatsurv function
vcov.mlspatsurv         vcov.mlspatsurv function
weibullHaz              weibullHaz function
</pre>
<p>Dependencies
</p>
<p>The package <code>spatsurv</code> depends upon some other important contributions to CRAN in order to operate; their uses here are indicated:<br /><br />
survival, sp, spatstat, raster, iterators, RandomFields, fields, rgl, Matrix, stringr, RColorBrewer, geostatsp.
</p>
<p>Citation
</p>
<p>To cite use of <code>spatsurv</code>, the user may refer to the following work:<br /><br />
Benjamin M. Taylor and Barry S. Rowlingson (2017).<br />
spatsurv: An R Package for Bayesian Inference with Spatial Survival Models.<br />
Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
<p>references
</p>
<p>X
</p>


<h3>Author(s)</h3>

<p>Benjamin Taylor, Health and Medicine, Lancaster University,
Barry Rowlingson, Health and Medicine, Lancaster University
</p>

<hr>
<h2 id='spatsurvVignette'>spatsurvVignette function</h2><span id='topic+spatsurvVignette'></span>

<h3>Description</h3>

<p>Display the introductory vignette for the spatsurv package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatsurvVignette()
</code></pre>


<h3>Value</h3>

<p>displays the vignette by calling browseURL
</p>

<hr>
<h2 id='SPDE'>SPDE function</h2><span id='topic+SPDE'></span>

<h3>Description</h3>

<p>A function to declare and evaluate an SPDE covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPDE(ord)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SPDE_+3A_ord">ord</code></td>
<td>
<p>the order of the model to be used, currently an integer between 1 an 3. See Lindgren 2011 paper.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an covariance function based on the SPDE model
</p>


<h3>See Also</h3>

<p><a href="#topic+ExponentialCovFct">ExponentialCovFct</a>, <a href="#topic+covmodel">covmodel</a>
</p>

<hr>
<h2 id='SPDEprec'>SPDEprec function</h2><span id='topic+SPDEprec'></span>

<h3>Description</h3>

<p>A function to used in entering elements into the precision matrix of an SPDE model. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPDEprec(a, ord)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SPDEprec_+3A_a">a</code></td>
<td>
<p>parameter a, see Lindgren et al 2011.</p>
</td></tr>
<tr><td><code id="SPDEprec_+3A_ord">ord</code></td>
<td>
<p>the order of the SPDE model, see Lindgren et al 2011.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function used for creating the precision matrix
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li>
<li><p> Finn Lindgren, Havard Rue, Johan Lindstrom. An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach. Journal of the Royal Statistical Society: Series B 73(4)
</p>
</li></ol>


<hr>
<h2 id='SpikedExponentialCovFct'>SpikedExponentialCovFct function</h2><span id='topic+SpikedExponentialCovFct'></span>

<h3>Description</h3>

<p>A function to declare and also evaluate a spiked exponential covariance function. This is an exponential covariance function with a nugget.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpikedExponentialCovFct()
</code></pre>


<h3>Value</h3>

<p>the spiked exponential covariance function
</p>


<h3>See Also</h3>

<p><a href="#topic+ExponentialCovFct">ExponentialCovFct</a>, <a href="#topic+covmodel">covmodel</a>
</p>

<hr>
<h2 id='Summarise'>Summarise function</h2><span id='topic+Summarise'></span>

<h3>Description</h3>

<p>A function to completely summarise the output of an object of class mcmcspatsurv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Summarise(
  obj,
  digits = 3,
  scientific = -3,
  inclIntercept = FALSE,
  printmode = "LaTeX",
  displaymode = "console",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Summarise_+3A_obj">obj</code></td>
<td>
<p>an object produced by a call to lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars orlgcpPredictMultitypeSpatialPlusPars</p>
</td></tr>
<tr><td><code id="Summarise_+3A_digits">digits</code></td>
<td>
<p>see the option &quot;digits&quot; in ?format</p>
</td></tr>
<tr><td><code id="Summarise_+3A_scientific">scientific</code></td>
<td>
<p>see the option &quot;scientific&quot; in ?format</p>
</td></tr>
<tr><td><code id="Summarise_+3A_inclintercept">inclIntercept</code></td>
<td>
<p>logical: whether to summarise the intercept term, default is FALSE.</p>
</td></tr>
<tr><td><code id="Summarise_+3A_printmode">printmode</code></td>
<td>
<p>the format of the text to return, can be 'LaTeX' (the default) or 'text' for plain text.</p>
</td></tr>
<tr><td><code id="Summarise_+3A_displaymode">displaymode</code></td>
<td>
<p>default is 'console' alternative is 'rstudio'</p>
</td></tr>
<tr><td><code id="Summarise_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function &quot;format&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A text summary, that can be pasted into a LaTeX document and later edited.
</p>

<hr>
<h2 id='summary.mcmc'>summary.mcmc function</h2><span id='topic+summary.mcmc'></span>

<h3>Description</h3>

<p>summary of an mcmc iterator
print out values of an iterator and reset it. DONT call this
in a loop that uses this iterator - it will reset it. And break.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mcmc_+3A_object">object</code></td>
<td>
<p>an mcmc iterator</p>
</td></tr>
<tr><td><code id="summary.mcmc_+3A_...">...</code></td>
<td>
<p>other args</p>
</td></tr>
</table>

<hr>
<h2 id='summary.mcmcspatsurv'>summary.mcmcspatsurv function</h2><span id='topic+summary.mcmcspatsurv'></span>

<h3>Description</h3>

<p>A function to return summary tables from an MCMC run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcspatsurv'
summary(object, probs = c(0.5, 0.025, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mcmcspatsurv_+3A_object">object</code></td>
<td>
<p>an object inheriting class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="summary.mcmcspatsurv_+3A_probs">probs</code></td>
<td>
<p>vector of quantiles to return</p>
</td></tr>
<tr><td><code id="summary.mcmcspatsurv_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary tables to the console
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+vcov.mcmcspatsurv">vcov.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='surv3d'>Spatial Survival Plot in 3D</h2><span id='topic+surv3d'></span>

<h3>Description</h3>

<p>Do a 3d plot of spatial survival data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv3d(
  spp,
  ss,
  lwd = 2,
  lcol = "black",
  lalpha = 1,
  pstyle = c("point", "text"),
  psize = c(20, 10),
  pcol = c("red", "black"),
  ptext = c("X", ""),
  palpha = 1,
  title = "Spatial Survival",
  basegrid = TRUE,
  baseplane = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv3d_+3A_spp">spp</code></td>
<td>
<p>A spatial points data frame</p>
</td></tr>
<tr><td><code id="surv3d_+3A_ss">ss</code></td>
<td>
<p>A Surv object (with right-censoring)</p>
</td></tr>
<tr><td><code id="surv3d_+3A_lwd">lwd</code></td>
<td>
<p>Line width for stems</p>
</td></tr>
<tr><td><code id="surv3d_+3A_lcol">lcol</code></td>
<td>
<p>Line colour for stems</p>
</td></tr>
<tr><td><code id="surv3d_+3A_lalpha">lalpha</code></td>
<td>
<p>Opacity for stems</p>
</td></tr>
<tr><td><code id="surv3d_+3A_pstyle">pstyle</code></td>
<td>
<p>Point style &quot;point&quot; or &quot;text&quot;</p>
</td></tr>
<tr><td><code id="surv3d_+3A_psize">psize</code></td>
<td>
<p>Vector of length 2 for uncensored/censored points size</p>
</td></tr>
<tr><td><code id="surv3d_+3A_pcol">pcol</code></td>
<td>
<p>Vector of length 2 for uncensored/censored points colours</p>
</td></tr>
<tr><td><code id="surv3d_+3A_ptext">ptext</code></td>
<td>
<p>Vector of length 2 for uncensored/censored text characters</p>
</td></tr>
<tr><td><code id="surv3d_+3A_palpha">palpha</code></td>
<td>
<p>Opacity for points/text</p>
</td></tr>
<tr><td><code id="surv3d_+3A_title">title</code></td>
<td>
<p>Main title for plot</p>
</td></tr>
<tr><td><code id="surv3d_+3A_basegrid">basegrid</code></td>
<td>
<p>add a grid at t=0</p>
</td></tr>
<tr><td><code id="surv3d_+3A_baseplane">baseplane</code></td>
<td>
<p>add a plane at t=0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses rgl graphics to make a spinny zoomy plot
</p>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Barry S Rowlingson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(sp)
require(survival)
d = data.frame(
  x=runif(40)*1.5,
  y = runif(40),
  age=as.integer(20+30*runif(40)),
  sex = sample(c("M","F"),40,TRUE)
)
coordinates(d)=~x+y
d$surv = Surv(as.integer(5+20*runif(40)),runif(40)&gt;.9)
clear3d();surv3d(d,d$surv,baseplane=TRUE,basegrid=TRUE)
clear3d();surv3d(d,d$surv,baseplane=TRUE,basegrid=TRUE,pstyle="t",lalpha=0.5,lwd=3,palpha=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='survival_PP'>survival_PP function</h2><span id='topic+survival_PP'></span>

<h3>Description</h3>

<p>A function to compute an individual's survival function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survival_PP(inputs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survival_PP_+3A_inputs">inputs</code></td>
<td>
<p>inputs for the function including the model matrix, frailties, fixed effects and the parameters of the baseline hazard derived from this model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the survival function for the individual
</p>

<hr>
<h2 id='survspat'>survspat function</h2><span id='topic+survspat'></span>

<h3>Description</h3>

<p>A function to run a Bayesian analysis on censored spatial survial data assuming a proportional hazards model using an adaptive Metropolis-adjusted
Langevin algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survspat(
  formula,
  data,
  dist,
  cov.model,
  mcmc.control,
  priors,
  shape = NULL,
  ids = list(shpid = NULL, dataid = NULL),
  control = inference.control(gridded = FALSE),
  boundingbox = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survspat_+3A_formula">formula</code></td>
<td>
<p>the model formula in a format compatible with the function flexsurvreg from the flexsurv package</p>
</td></tr>
<tr><td><code id="survspat_+3A_data">data</code></td>
<td>
<p>a SpatialPointsDataFrame object containing the survival data as one of the columns OR for polygonal data a data.frame, in which case, the argument shape must also be supplied</p>
</td></tr>
<tr><td><code id="survspat_+3A_dist">dist</code></td>
<td>
<p>choice of distribution function for baseline hazard. Current options are: exponentialHaz, weibullHaz, gompertzHaz, makehamHaz, tpowHaz</p>
</td></tr>
<tr><td><code id="survspat_+3A_cov.model">cov.model</code></td>
<td>
<p>an object of class covmodel, see ?covmodel ?ExponentialCovFct or ?SpikedExponentialCovFct</p>
</td></tr>
<tr><td><code id="survspat_+3A_mcmc.control">mcmc.control</code></td>
<td>
<p>mcmc control parameters, see ?mcmcpars</p>
</td></tr>
<tr><td><code id="survspat_+3A_priors">priors</code></td>
<td>
<p>an object of class Priors, see ?mcmcPriors</p>
</td></tr>
<tr><td><code id="survspat_+3A_shape">shape</code></td>
<td>
<p>when data is a data.frame, this can be a SpatialPolygonsDataFrame, or a SpatialPointsDataFrame, used to model spatial variation at the small region level. The regions are the polygons, or they represent the (possibly weighted) centroids of the polygons.</p>
</td></tr>
<tr><td><code id="survspat_+3A_ids">ids</code></td>
<td>
<p>named list entry shpid character string giving name of variable in shape to be matched to variable dataid in data. dataid is the second entry of the named list.</p>
</td></tr>
<tr><td><code id="survspat_+3A_control">control</code></td>
<td>
<p>additional control parameters, see ?inference.control</p>
</td></tr>
<tr><td><code id="survspat_+3A_boundingbox">boundingbox</code></td>
<td>
<p>optional bounding box over which to construct computational grid, supplied as an object on which the function 'bbox' returns the bounding box</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object inheriting class 'mcmcspatsurv' for which there exist methods for printing, summarising and making inference from.
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+tpowHaz">tpowHaz</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>,
<a href="#topic+covmodel">covmodel</a>, <a href="#topic+ExponentialCovFct">ExponentialCovFct</a>, <code>SpikedExponentialCovFct</code>,
<a href="#topic+mcmcpars">mcmcpars</a>, <a href="#topic+mcmcPriors">mcmcPriors</a>, <a href="#topic+inference.control">inference.control</a>
</p>

<hr>
<h2 id='survspatNS'>survspatNS function</h2><span id='topic+survspatNS'></span>

<h3>Description</h3>

<p>A function to perform maximun likelihood inference for non-spatial survival data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survspatNS(formula, data, dist, control = inference.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survspatNS_+3A_formula">formula</code></td>
<td>
<p>the model formula in a format compatible with the function flexsurvreg from the flexsurv package</p>
</td></tr>
<tr><td><code id="survspatNS_+3A_data">data</code></td>
<td>
<p>a SpatialPointsDataFrame object containing the survival data as one of the columns</p>
</td></tr>
<tr><td><code id="survspatNS_+3A_dist">dist</code></td>
<td>
<p>choice of distribution function for baseline hazard. Current options are: exponentialHaz, weibullHaz, gompertzHaz, makehamHaz, tpowHaz</p>
</td></tr>
<tr><td><code id="survspatNS_+3A_control">control</code></td>
<td>
<p>additional control parameters, see ?inference.control</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object inheriting class 'mcmcspatsurv' for which there exist methods for printing, summarising and making inference from.
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+tpowHaz">tpowHaz</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>,
<a href="#topic+covmodel">covmodel</a>, <a href="#topic+ExponentialCovFct">ExponentialCovFct</a>, <code>SpikedExponentialCovFct</code>,
<a href="#topic+mcmcpars">mcmcpars</a>, <a href="#topic+mcmcPriors">mcmcPriors</a>, <a href="#topic+inference.control">inference.control</a>
</p>

<hr>
<h2 id='textSummary'>textSummary function</h2><span id='topic+textSummary'></span>

<h3>Description</h3>

<p>A function to print a text description of the inferred paramerers beta and eta from a call to the function lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars or lgcpPredictMultitypeSpatialPlusPars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textSummary(
  obj,
  digits = 3,
  scientific = -3,
  inclIntercept = FALSE,
  printmode = "LaTeX",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textSummary_+3A_obj">obj</code></td>
<td>
<p>an object produced by a call to lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars orlgcpPredictMultitypeSpatialPlusPars</p>
</td></tr>
<tr><td><code id="textSummary_+3A_digits">digits</code></td>
<td>
<p>see the option &quot;digits&quot; in ?format</p>
</td></tr>
<tr><td><code id="textSummary_+3A_scientific">scientific</code></td>
<td>
<p>see the option &quot;scientific&quot; in ?format</p>
</td></tr>
<tr><td><code id="textSummary_+3A_inclintercept">inclIntercept</code></td>
<td>
<p>logical: whether to summarise the intercept term, default is FALSE.</p>
</td></tr>
<tr><td><code id="textSummary_+3A_printmode">printmode</code></td>
<td>
<p>the format of the text to return, can be 'LaTeX' (the default) or 'text' for plain text.</p>
</td></tr>
<tr><td><code id="textSummary_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function &quot;format&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A text summary, that can be pasted into a LaTeX document and later edited.
</p>

<hr>
<h2 id='timevaryingPL'>timevaryingPL function</h2><span id='topic+timevaryingPL'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timevaryingPL(
  formula,
  t0,
  t,
  delta,
  dist,
  data,
  ties = "Efron",
  optimcontrol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timevaryingPL_+3A_formula">formula</code></td>
<td>
<p>a formula of the form 'S ~ coef1 + coef2' etc the object S will be created</p>
</td></tr>
<tr><td><code id="timevaryingPL_+3A_t0">t0</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="timevaryingPL_+3A_t">t</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="timevaryingPL_+3A_delta">delta</code></td>
<td>
<p>censoring indicator a vector of 1 for an event and 0 for censoring</p>
</td></tr>
<tr><td><code id="timevaryingPL_+3A_dist">dist</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="timevaryingPL_+3A_data">data</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="timevaryingPL_+3A_ties">ties</code></td>
<td>
<p>X default is Efron</p>
</td></tr>
<tr><td><code id="timevaryingPL_+3A_optimcontrol">optimcontrol</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='tpowHaz'>tpowHaz function</h2><span id='topic+tpowHaz'></span>

<h3>Description</h3>

<p>A function to define a parametric proportional hazards model where the baseline hazard is taken from the 'powers of t' model. 
This function returns an object inheriting class 'basehazardspec', list of functions 'distinfo', 'basehazard', 'gradbasehazard', 'hessbasehazard',
'cumbasehazard', 'gradcumbasehazard', 'hesscumbasehazard' and 'densityquantile'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpowHaz(powers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpowHaz_+3A_powers">powers</code></td>
<td>
<p>a vector of powers of t. These are powers are treated as fixed in estimation routines and it is assumed that the log cumulatice baseline hazard is a linear combination of these powers of t</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>distinfo</code> function is used to provide basic distribution specific information to other <code>spatsurv</code> functions. The user is required 
to provide the following information in the returned list: <code>npars</code>, the number of parameters in this distribution; <code>parnames</code>, 
the names of the parameters; <code>trans</code>, the transformation scale on which the priors will be provided; <code>itrans</code>, the inverse 
transformation function that will be applied to the parameters before the hazard, and other functions are evaluated; <code>jacobian</code>, 
the derivative of the inverse transformation function with respect to each of the parameters; and <code>hessian</code>, the second derivatives 
of the inverse transformation function with respect to each of the parameters &ndash; note that currently the package <code>spatsurv</code> 
only allows the use of functions where the parameters are transformed independently.
</p>
<p>The <code>basehazard</code> function is used to evaluate the baseline hazard function for the distribution of interest. It returns a 
function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradbasehazard</code> function is used to evaluate the gradient of the baseline hazard function with respect to the parameters, 
this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hessbasehazard</code> function is used to evaluate the Hessian of the baseline hazard function. It returns a function that accepts 
as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>cumbasehazard</code> function is used to evaluate the cumulative baseline hazard function for the distribution of interest. 
It returns a function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradcumbasehazard</code> function is used to evaluate the gradient of the cumulative baseline hazard function with respect 
to the parameters, this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hesscumbasehazard</code> function is used to evaluate the Hessian of the cumulative baseline hazard function. It returns a 
function that accepts as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>densityquantile</code> function is used to return quantiles of the density function. This is NOT REQUIRED for running the MCMC, 
merely for us in post-processing with the <code>predict</code> function where <code>type</code> is 'densityquantile'. In the case of the Weibull 
model for the baseline hazard, it can be shown that the q-th quantile is:
</p>


<h3>Value</h3>

<p>an object inheriting class 'basehazardspec'
</p>


<h3>See Also</h3>

<p><a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>, <a href="#topic+weibullHaz">weibullHaz</a>
</p>

<hr>
<h2 id='transformweibull'>transformweibull function</h2><span id='topic+transformweibull'></span>

<h3>Description</h3>

<p>A function to back-transform estimates of the parameters of the weibull baseline hazard function, so they are commensurate with R's inbuilt density functions.
Transforms from (shape, scale) to (alpha, lambda)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformweibull(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformweibull_+3A_x">x</code></td>
<td>
<p>a vector of paramters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the transformed parameters. For the weibull model, this is the back-transform from 'alpha' and 'lambda' to 'shape' 'scale' (see ?dweibull).
</p>

<hr>
<h2 id='TwoWayHazAdditive'>TwoWayHazAdditive function</h2><span id='topic+TwoWayHazAdditive'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwoWayHazAdditive(bhlist, bhtime, bhfix, MLinits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwoWayHazAdditive_+3A_bhlist">bhlist</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="TwoWayHazAdditive_+3A_bhtime">bhtime</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="TwoWayHazAdditive_+3A_bhfix">bhfix</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="TwoWayHazAdditive_+3A_mlinits">MLinits</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='txtProgressBar2'>A text progress bar with label</h2><span id='topic+txtProgressBar2'></span>

<h3>Description</h3>

<p>This is the base txtProgressBar but with a little modification to
implement the label parameter for style=3. For full info see txtProgressBar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>txtProgressBar2(
  min = 0,
  max = 1,
  initial = 0,
  char = "=",
  width = NA,
  title = "",
  label = "",
  style = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="txtProgressBar2_+3A_min">min</code></td>
<td>
<p>min value for bar</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_max">max</code></td>
<td>
<p>max value for bar</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_initial">initial</code></td>
<td>
<p>initial value for bar</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_char">char</code></td>
<td>
<p>the character (or character string) to form the progress bar.</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_width">width</code></td>
<td>
<p>progress bar width</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_title">title</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_label">label</code></td>
<td>
<p>text to put at the end of the bar</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_style">style</code></td>
<td>
<p>bar style</p>
</td></tr>
</table>

<hr>
<h2 id='vcov.mcmcspatsurv'>vcov.mcmcspatsurv function</h2><span id='topic+vcov.mcmcspatsurv'></span>

<h3>Description</h3>

<p>A function to return the variance covariance matrix of the parameters beta, omega and eta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcspatsurv'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.mcmcspatsurv_+3A_object">object</code></td>
<td>
<p>an object inheriting class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="vcov.mcmcspatsurv_+3A_...">...</code></td>
<td>
<p>other arguments, not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the variance covariance matrix of the parameters beta, omega and eta
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='vcov.mlspatsurv'>vcov.mlspatsurv function</h2><span id='topic+vcov.mlspatsurv'></span>

<h3>Description</h3>

<p>A function to return the variance covariance matrix of the parameters beta, omega and eta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlspatsurv'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.mlspatsurv_+3A_object">object</code></td>
<td>
<p>an object inheriting class mcmcspatsurv</p>
</td></tr>
<tr><td><code id="vcov.mlspatsurv_+3A_...">...</code></td>
<td>
<p>other arguments, not used here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the variance covariance matrix of the parameters beta, omega and eta
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mcmcspatsurv">print.mcmcspatsurv</a>, <a href="#topic+quantile.mcmcspatsurv">quantile.mcmcspatsurv</a>, <a href="#topic+summary.mcmcspatsurv">summary.mcmcspatsurv</a>,
<a href="#topic+frailtylag1">frailtylag1</a>, <a href="#topic+spatialpars">spatialpars</a>, <a href="#topic+hazardpars">hazardpars</a>, <a href="#topic+fixedpars">fixedpars</a>, <a href="#topic+randompars">randompars</a>,
<a href="#topic+baselinehazard">baselinehazard</a>, <a href="#topic+predict.mcmcspatsurv">predict.mcmcspatsurv</a>, <a href="#topic+priorposterior">priorposterior</a>, <a href="#topic+posteriorcov">posteriorcov</a>, <a href="#topic+MCE">MCE</a>,
<a href="#topic+hazardexceedance">hazardexceedance</a>
</p>

<hr>
<h2 id='weibullHaz'>weibullHaz function</h2><span id='topic+weibullHaz'></span>

<h3>Description</h3>

<p>A function to define a parametric proportional hazards model where the baseline hazard is taken from the Weibull model.
This function returns an object inheriting class 'basehazardspec', list of functions 'distinfo', 'basehazard', 'gradbasehazard', 'hessbasehazard',
'cumbasehazard', 'gradcumbasehazard', 'hesscumbasehazard' and 'densityquantile'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weibullHaz(MLinits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weibullHaz_+3A_mlinits">MLinits</code></td>
<td>
<p>initial values for optim, default is NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>distinfo</code> function is used to provide basic distribution specific information to other <code>spatsurv</code> functions. The user is required
to provide the following information in the returned list: <code>npars</code>, the number of parameters in this distribution; <code>parnames</code>,
the names of the parameters; <code>trans</code>, the transformation scale on which the priors will be provided; <code>itrans</code>, the inverse
transformation function that will be applied to the parameters before the hazard, and other functions are evaluated; <code>jacobian</code>,
the derivative of the inverse transformation function with respect to each of the parameters; and <code>hessian</code>, the second derivatives
of the inverse transformation function with respect to each of the parameters &ndash; note that currently the package <code>spatsurv</code>
only allows the use of functions where the parameters are transformed independently.
</p>
<p>The <code>basehazard</code> function is used to evaluate the baseline hazard function for the distribution of interest. It returns a
function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradbasehazard</code> function is used to evaluate the gradient of the baseline hazard function with respect to the parameters,
this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hessbasehazard</code> function is used to evaluate the Hessian of the baseline hazard function. It returns a function that accepts
as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>cumbasehazard</code> function is used to evaluate the cumulative baseline hazard function for the distribution of interest.
It returns a function that accepts as input a vector of times, <code>t</code> and returns a vector.
</p>
<p>The <code>gradcumbasehazard</code> function is used to evaluate the gradient of the cumulative baseline hazard function with respect
to the parameters, this typically returns a vector. It returns a function that accepts as input a vector of times, <code>t</code>, and returns a matrix.
</p>
<p>The <code>hesscumbasehazard</code> function is used to evaluate the Hessian of the cumulative baseline hazard function. It returns a
function that accepts as input a vector of times, <code>t</code> and returns a list of hessian matrices corresponding to each <code>t</code>.
</p>
<p>The <code>densityquantile</code> function is used to return quantiles of the density function. This is NOT REQUIRED for running the MCMC,
merely for us in post-processing with the <code>predict</code> function where <code>type</code> is 'densityquantile'. In the case of the Weibull
model for the baseline hazard, it can be shown that the q-th quantile is:
</p>


<h3>Value</h3>

<p>an object inheriting class 'basehazardspec'
</p>


<h3>See Also</h3>

<p><a href="#topic+tpowHaz">tpowHaz</a>, <a href="#topic+exponentialHaz">exponentialHaz</a>, <a href="#topic+gompertzHaz">gompertzHaz</a>, <a href="#topic+makehamHaz">makehamHaz</a>
</p>

<hr>
<h2 id='YfromGamma'>YfromGamma function</h2><span id='topic+YfromGamma'></span>

<h3>Description</h3>

<p>A function to change Gammas (white noise) into Ys (spatially correlated noise). Used in the MALA algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YfromGamma(Gamma, invrootQeigs, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="YfromGamma_+3A_gamma">Gamma</code></td>
<td>
<p>Gamma matrix</p>
</td></tr>
<tr><td><code id="YfromGamma_+3A_invrootqeigs">invrootQeigs</code></td>
<td>
<p>inverse square root of the eigenvectors of the precision matrix</p>
</td></tr>
<tr><td><code id="YfromGamma_+3A_mu">mu</code></td>
<td>
<p>parameter of the latent Gaussian field</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Y
</p>

<hr>
<h2 id='YFromGamma_SPDE'>YFromGamma_SPDE function</h2><span id='topic+YFromGamma_SPDE'></span>

<h3>Description</h3>

<p>A function to go from Gamma to Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YFromGamma_SPDE(gamma, U, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="YFromGamma_SPDE_+3A_gamma">gamma</code></td>
<td>
<p>Gamma</p>
</td></tr>
<tr><td><code id="YFromGamma_SPDE_+3A_u">U</code></td>
<td>
<p>upper Cholesky matrix</p>
</td></tr>
<tr><td><code id="YFromGamma_SPDE_+3A_mu">mu</code></td>
<td>
<p>the mean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of Y for the given Gamma
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor and Barry S. Rowlingson (2017). spatsurv: An R Package for Bayesian Inference with Spatial Survival Models. Journal of Statistical Software, 77(4), 1-32, doi:10.18637/jss.v077.i04.
</p>
</li>
<li><p> Finn Lindgren, Havard Rue, Johan Lindstrom. An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach. Journal of the Royal Statistical Society: Series B 73(4)
</p>
</li></ol>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
