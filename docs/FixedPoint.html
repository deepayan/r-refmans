<!DOCTYPE html><html lang="en"><head><title>Help for package FixedPoint</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FixedPoint}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ChangePerIterate'><p>ChangePerIterate</p>
A function for plotting the change in each vector per iterate.</a></li>
<li><a href='#ConvergenceFig'><p>A function for plotting the convergence change over a series of iterates.</p></a></li>
<li><a href='#EpsilonExtrapolation'><p>EpsilonExtrapolation</p>
This function takes a matrix with previous iterates and extrapolates the limit of the sequence.</a></li>
<li><a href='#EpsilonExtrapolationVectorOfInverses'><p>EpsilonExtrapolationVectorOfInverses</p>
This is a helper function for EpsilonExtrapolation</a></li>
<li><a href='#FixedPoint'><p>A function for finding the fixed point of a contraction mapping</p></a></li>
<li><a href='#FixedPointNewInput'><p>FixedPointNewInput</p>
This function takes the previous inputs and outputs from the FixedPoint function and determines what vector to try next in seeking
a fixed point.</a></li>
<li><a href='#PolynomialExtrapolation'><p>PolynomialExtrapolation</p>
This function performs Minimal Polynomial extrapolation (MPE) or Reduced Rank Extrapolation (RRE) given a matrix of previous iterates of the
function.</a></li>
<li><a href='#PutTogetherIteratesWithoutJumps'><p>PutTogetherIteratesWithoutJumps</p>
This function takes the previous inputs and outputs and assembles a matrix with both excluding jumps.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Algorithms for Finding Fixed Point Vectors of Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Stuart Baumann &amp; Margaryta Klymak</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stuart Baumann &lt;Stuart@StuartBaumann.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>For functions that take and return vectors (or scalars), this package provides 8 algorithms for finding fixed point vectors (vectors for which the inputs and outputs to the function are the same vector). These algorithms include Anderson (1965) acceleration &lt;<a href="https://doi.org/10.1145%2F321296.321305">doi:10.1145/321296.321305</a>&gt;, epsilon extrapolation methods (Wynn 1962 &lt;<a href="https://doi.org/10.2307%2F2004051">doi:10.2307/2004051</a>&gt;) and minimal polynomial methods (Cabay and Jackson 1976 &lt;<a href="https://doi.org/10.1137%2F0713060">doi:10.1137/0713060</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, schumaker, cubature, knitr, foreach, doParallel,
SQUAREM, rmarkdown, qpdf</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-19 13:50:48 UTC; dr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-19 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ChangePerIterate'>ChangePerIterate
A function for plotting the change in each vector per iterate.</h2><span id='topic+ChangePerIterate'></span>

<h3>Description</h3>

<p>ChangePerIterate
A function for plotting the change in each vector per iterate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChangePerIterate(
  Inputs,
  Outputs,
  ConvergenceVector = c(),
  ConvergenceSigFig = 5,
  ShowInputs = TRUE,
  ShowOutputs = TRUE,
  ShowPrevious = TRUE,
  xaxis = c(),
  secondhold = 0,
  FromIterate = 1,
  ToIterate = c()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ChangePerIterate_+3A_inputs">Inputs</code></td>
<td>
<p>The Inputs matrix returned by FixedPoint.</p>
</td></tr>
<tr><td><code id="ChangePerIterate_+3A_outputs">Outputs</code></td>
<td>
<p>The Outputs matrix returned by FixedPoint.</p>
</td></tr>
<tr><td><code id="ChangePerIterate_+3A_convergencevector">ConvergenceVector</code></td>
<td>
<p>The Convergence vector returned by fixedpoint.</p>
</td></tr>
<tr><td><code id="ChangePerIterate_+3A_convergencesigfig">ConvergenceSigFig</code></td>
<td>
<p>The number of significant figures convergence values should be shown with in the plot header.</p>
</td></tr>
<tr><td><code id="ChangePerIterate_+3A_showinputs">ShowInputs</code></td>
<td>
<p>A boolean describing whether to show the inputs in the figure.</p>
</td></tr>
<tr><td><code id="ChangePerIterate_+3A_showoutputs">ShowOutputs</code></td>
<td>
<p>A boolean describing whether to show the outputs in the figure.</p>
</td></tr>
<tr><td><code id="ChangePerIterate_+3A_showprevious">ShowPrevious</code></td>
<td>
<p>A boolean describing whether to show the previous inputs/outputs in the figure.</p>
</td></tr>
<tr><td><code id="ChangePerIterate_+3A_xaxis">xaxis</code></td>
<td>
<p>A vector for meaningful values corresponding to the input/output values. By default the indexes of each input/output vector
are used.</p>
</td></tr>
<tr><td><code id="ChangePerIterate_+3A_secondhold">secondhold</code></td>
<td>
<p>If this is -1 or less then all plotting happens immediately. This means that very quickly only the last iterate will be seen
so it makes sense to do it only if FromIterate and ToIterate indicate only one iterate. If this is 0 then a user can click through each figure.
If this is positive then it describes how many seconds to pause between frames. By default this is 0 so a user must click through each frame.</p>
</td></tr>
<tr><td><code id="ChangePerIterate_+3A_fromiterate">FromIterate</code></td>
<td>
<p>This describes what iterate to show first.</p>
</td></tr>
<tr><td><code id="ChangePerIterate_+3A_toiterate">ToIterate</code></td>
<td>
<p>This describes what iterate to show last.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns nothing. It just shows a plot in the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Inputs = seq(1,10)
Function = function(x){ cos(x) }
A = FixedPoint(Function, Inputs, Method = "Anderson")
ChangePerIterate(A$Inputs, A$Outputs, A$Convergence)
#Any now to have it play one frame every half a second starting from the nineth iterate
ChangePerIterate(A$Inputs, A$Outputs, A$Convergence, secondhold = 0.5, FromIterate = 9)
</code></pre>

<hr>
<h2 id='ConvergenceFig'>A function for plotting the convergence change over a series of iterates.</h2><span id='topic+ConvergenceFig'></span>

<h3>Description</h3>

<p>On the x axis is the index of each iterate. On the y axis are different convergence metric values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvergenceFig(
  Inputs,
  Outputs,
  Input_Convergence = c(),
  LinesToDraw = c("Sup_Norm", "Euclidean_Norm", "Sum_Of_Absolute_Value_Of_Residuals",
    "Smallest_Residual"),
  LogScale = TRUE,
  FromIterate = 1,
  ToIterate = c()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConvergenceFig_+3A_inputs">Inputs</code></td>
<td>
<p>The Inputs matrix returned by FixedPoint.</p>
</td></tr>
<tr><td><code id="ConvergenceFig_+3A_outputs">Outputs</code></td>
<td>
<p>The Outputs matrix returned by FixedPoint.</p>
</td></tr>
<tr><td><code id="ConvergenceFig_+3A_input_convergence">Input_Convergence</code></td>
<td>
<p>Convergence vector to be used in the figure. Often makes sense for it to be the same as that used in
the Fixedpoint function.</p>
</td></tr>
<tr><td><code id="ConvergenceFig_+3A_linestodraw">LinesToDraw</code></td>
<td>
<p>A vector describing which convergence metrics to draw. This vector can contain anything in c(&quot;Sup_Norm&quot;, &quot;Euclidean_Norm&quot;,
&quot;Sum_Of_Absolute_Value_Of_Residuals&quot;, &quot;Smallest_Residual&quot;, &quot;Input_Convergence&quot;). Here &quot;Input_Convergence&quot; draws the input convergence vector.
&quot;Sup_Norm&quot; gives the greatest residual (in absolute value), &quot;Euclidean_Norm&quot; is the eucleadean norm of the residuals, &quot;Sum_Of_Absolute_Value_Of_Residuals&quot;
sums up the absolute value of the residuals and &quot;Smallest_Residual&quot; is the smallest residual by absolute value. Clearly if the function takes
and returns a scalar (rather than a vector) then all of these are identical.</p>
</td></tr>
<tr><td><code id="ConvergenceFig_+3A_logscale">LogScale</code></td>
<td>
<p>This is whether or not to use a log scale. If so instead of convergence, log(1+convergence) is shown on the y axis. By default this is true.</p>
</td></tr>
<tr><td><code id="ConvergenceFig_+3A_fromiterate">FromIterate</code></td>
<td>
<p>This describes the first iterate on the figure.</p>
</td></tr>
<tr><td><code id="ConvergenceFig_+3A_toiterate">ToIterate</code></td>
<td>
<p>This describes the last iterate on the figure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns nothing. It just shows a plot in the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Inputs = seq(1,10)
Function = function(x){ cos(x) }
A = FixedPoint(Function, Inputs, Method = "Anderson")
ConvergenceFig(A$Inputs, A$Outputs)
# And now to only show a median norm:
Differences = A$Inputs - A$Outputs
Convergence = apply(Differences,2,function(x){median(abs(x))})
ConvergenceFig(A$Inputs, A$Outputs, Convergence, LinesToDraw = "Input_Convergence")
</code></pre>

<hr>
<h2 id='EpsilonExtrapolation'>EpsilonExtrapolation
This function takes a matrix with previous iterates and extrapolates the limit of the sequence.</h2><span id='topic+EpsilonExtrapolation'></span>

<h3>Description</h3>

<p>EpsilonExtrapolation
This function takes a matrix with previous iterates and extrapolates the limit of the sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EpsilonExtrapolation(Iterates, Method = c("VEA", "SEA"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EpsilonExtrapolation_+3A_iterates">Iterates</code></td>
<td>
<p>A matrix representing different iterates with one iterate per column. Can be pieced together from Inputs and Outputs matrices
of the FixedPoint function using the PutTogetherIteratesWithoutJumps function.</p>
</td></tr>
<tr><td><code id="EpsilonExtrapolation_+3A_method">Method</code></td>
<td>
<p>Method for epsilon extrapolation. Should be either &quot;VEA&quot; for the vector extrapolation algorithm or &quot;SEA&quot; for the scalar epsilon
algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the extrapolated vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FPFunction = function(x){c(0.5*sqrt(abs(x[1] + x[2])), 1.5*x[1] + 0.5*x[2])}
A = FixedPoint( Function = FPFunction, Inputs = c(0.3,900), MaxIter = 6, Method = "Simple")
Iterates = PutTogetherIteratesWithoutJumps(A$Inputs, A$Outputs)
EpsilonExtrapolation(Iterates, "VEA")
B = FixedPoint( function(x){cos(x)}, Inputs = 1, MaxIter = 5, Method = "Simple")
Iterates = PutTogetherIteratesWithoutJumps(B$Inputs, B$Outputs)
EpsilonExtrapolation(Iterates, "SEA")
</code></pre>

<hr>
<h2 id='EpsilonExtrapolationVectorOfInverses'>EpsilonExtrapolationVectorOfInverses
This is a helper function for EpsilonExtrapolation</h2><span id='topic+EpsilonExtrapolationVectorOfInverses'></span>

<h3>Description</h3>

<p>EpsilonExtrapolationVectorOfInverses
This is a helper function for EpsilonExtrapolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EpsilonExtrapolationVectorOfInverses(DifferenceMatrix, Method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EpsilonExtrapolationVectorOfInverses_+3A_differencematrix">DifferenceMatrix</code></td>
<td>
<p>The matrix of the differences in elements to be inverted.</p>
</td></tr>
<tr><td><code id="EpsilonExtrapolationVectorOfInverses_+3A_method">Method</code></td>
<td>
<p>&quot;SEA&quot; or &quot;VEA&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the result of inverting each (column) vector in a mmatrix.
</p>

<hr>
<h2 id='FixedPoint'>A function for finding the fixed point of a contraction mapping</h2><span id='topic+FixedPoint'></span>

<h3>Description</h3>

<p>This function takes in a function and an initial guess for the fixed point of that function. It then uses a fixed point method to find the
fixed point of that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FixedPoint(
  Function,
  Inputs,
  Outputs = c(),
  Method = c("Anderson", "Simple", "Aitken", "Newton", "MPE", "RRE", "VEA", "SEA"),
  ConvergenceMetric = function(Residuals) {
     max(abs(Residuals))
 },
  ConvergenceMetricThreshold = 1e-10,
  MaxIter = 1000,
  MaxM = 10,
  ExtrapolationPeriod = 7,
  Dampening = 1,
  ReplaceInvalids = c("ReplaceElements", "ReplaceVector", "NoAction"),
  PrintReports = FALSE,
  ReportingSigFig = 5,
  ConditionNumberThreshold = 1000,
  Plot = c("NoPlot", "ConvergenceFig", "ChangePerIterate"),
  ConvergenceFigLags = 5,
  ChangePerIteratexaxis = c(),
  DropOldIterates = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FixedPoint_+3A_function">Function</code></td>
<td>
<p>This is the function for which a fixed point is sought. This function must take and return a vector of the same dimension.</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_inputs">Inputs</code></td>
<td>
<p>This can be either a vector of values that is an initial guess for a fixed point or it can be an N x A matrix of previous inputs
for which corresponding outputs are available. In this case N is the dimensionality of the fixed point vector you are seeking (Hence each
column is a matrix that is input to the &quot;Function&quot;) and A is the number of previous Inputs/Outputs that are being provided to the fixed point.
Where a matrix is input, a corresponding outputs must be provided or the last column of the outputs matrix is taken as a startpoint guess and
the rest of the inputs and output matrices are discarded.</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_outputs">Outputs</code></td>
<td>
<p>(Optional) This is a matrix of the Function values for each column of the input. It must be provided so that column k of the
outputs matrix is equal to Function(Column k of inputs matrix).</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_method">Method</code></td>
<td>
<p>This is the fixed point method to be used. It can be &quot;Anderson&quot;, &quot;Simple&quot;, &quot;Aitken&quot;, &quot;Newton&quot;, &quot;MPE&quot;, &quot;RRE&quot;, &quot;VEA&quot; or &quot;SEA&quot;. See
vignette and references to see explanations of these methods.</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_convergencemetric">ConvergenceMetric</code></td>
<td>
<p>This is a function that takes in a vector of residuals from one iterate of the function (defined as f(x) - x for
vector x and function f) and returns a scalar. This scalar should be low when convergence is close to being achieved. By default this is
the maximum residual by absolute value (the sup norm in the space of residuals).</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_convergencemetricthreshold">ConvergenceMetricThreshold</code></td>
<td>
<p>This is the threshold for terminating the algorithm. The algorithm will terminate when the scalar that
ConvergenceMetric returns is less than ConvergenceMetricThreshold. This can be set to a negative number in which case the algorithm will
run until MaxIter is hit or an error occurs (Note that an error is likely in trying to use any method other than &quot;Simple&quot; when a fixed point
is already found).</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_maxiter">MaxIter</code></td>
<td>
<p>This is the maximum number of iterates that will be undertaken.</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_maxm">MaxM</code></td>
<td>
<p>This is the maximum number of saved iterates that are used in the Anderson algorithm. It has no effect if another method is chosen.
Note that the number of previous iterates that will actually be used is the minimum of MaxIter, the dimensionality of the function's vector and
the number of inputs that have been tried to previously (the width of the Outputs matrix at each given stage of the algorithm). If
PrintReports = TRUE, the number of previous iterates actually used is reported as the algorithm is running.</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_extrapolationperiod">ExtrapolationPeriod</code></td>
<td>
<p>This is the number of simple iterates to perform before extrapolating. This is used for the MPE, RRE, VEA and SEA
methods and has no effect if another method is chosen. Where an epsilon algorithm is used this should be one plus a multiple of two, ie (3,5,7,etc).</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_dampening">Dampening</code></td>
<td>
<p>This is the dampening parameter. By default it is 1 which means no dampening takes place. It can also be less than 1
(indicating dampening) or more than 1 (indicating extrapolation).</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_replaceinvalids">ReplaceInvalids</code></td>
<td>
<p>This determines how NAs and Infs generated by the extrapolation method are handled. If it is &quot;NoAction&quot; then if
the extrapolation algorithm generates an NA or Inf then no action is taken. This will likely result in these NAs and Infs being fed into
the function and an error resulting. If it is &quot;ReplaceVector&quot; then the entire extrapolated vector will be replaced by a vector of a simple
iterate. If it is &quot;ReplaceElements&quot; then the elements containing an NA or Inf will be replaced by the corresponding elements from a simple iterate.</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_printreports">PrintReports</code></td>
<td>
<p>This is a boolean describing whether to print ongoing ConvergenceMetric values for each iterate.</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_reportingsigfig">ReportingSigFig</code></td>
<td>
<p>This is the number of significant figures that will be used in printing the convergence values to the console
(only if PrintReports is TRUE).</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_conditionnumberthreshold">ConditionNumberThreshold</code></td>
<td>
<p>This is a threshold for what condition number is acceptable for solving the least squares problem for the
Anderson Method. If the condition number is larger than this threshold then fewer previous iterates will be used in solving the problem.
This has no effect unless the &quot;Anderson&quot; method is used.</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_plot">Plot</code></td>
<td>
<p>This determines whether a plot should be drawn for every iterate. It can be &quot;NoPlot&quot;, &quot;ConvergenceFig&quot; or &quot;ChangePerIterate&quot;.
By default it is &quot;NoPlot&quot; and no plot is drawn. If it is &quot;ConvergenceFig&quot; then a plot is shown with iterates on the x axis and convergence
(as defined by the ConvergenceMetric) is on the y axis. If it is &quot;ChangePerIterate&quot; then there is the index of the array value on the x axis
and the value of the array value on the y axis. The previous iterate is also shown so the change per iterate can be visualised.</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_convergencefiglags">ConvergenceFigLags</code></td>
<td>
<p>This only affects anything if Plot == &quot;ConvergenceFig&quot;. This gives how many previous iterates should be shown on
the x axis. By default it is 5. To see them all set it to a high number.</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_changeperiteratexaxis">ChangePerIteratexaxis</code></td>
<td>
<p>This only affects anything if Plot == &quot;ChangePerIterate&quot;. Sometimes there is a more appropriate xaxis value
to use than (the default) value index for this figure. For instance in the consumption smoothing problem in the vignette every value is a
value function value at a given budget level. In this case the budget levels could be used for this xaxis.</p>
</td></tr>
<tr><td><code id="FixedPoint_+3A_dropolditerates">DropOldIterates</code></td>
<td>
<p>This drops old iterates that will not be used in determining the next fixedpoint guess under the current setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the FixedPoint, the Inputs and corresponding Outputs, and convergence values (which are computed under the
&quot;ConvergenceMetric&quot;). The list will also include a &quot;Finish&quot; statement describing why it has finished. This is often going to be due to
either MaxIter or ConvergenceMetricThreshold being  reached. It may also terminate due to an error in generating a new input guess or using
the function with that guess. If this occurs the function will terminate early and the &quot;Finish&quot; statement will describe the issue.
In this event there will also be additional objects returned in the list &quot;NewInputVector&quot; and possibly &quot;NewOutputVector&quot; for use in debugging
the issue.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the simplest possible example we can seek the fixed point of the cos function with a scalar.
Inputs = 0.3
Function = function(x){ cos(x) }
A = FixedPoint(Function, Inputs, Method = "Aitken", Dampening = 0.5)
B = FixedPoint(Function, Inputs, Method = "Anderson", Dampening = 1.0)

# For this next one the ConvergenceMetricThreshold is negative so the algorithm
# will keep running until MaxIter is met.
C = FixedPoint(Function, Inputs, Method = "Simple", MaxIter = 4, ConvergenceMetricThreshold = -1)
# This is not yet close to the fixed point but we can continue solving for this fixed point
# by inputting the previous inputs and outputs to the function. We can also switch methods
# and will switch below to the Newton Method.
D = FixedPoint(Function, C$Inputs, C$Outputs, Method = "Newton")

# We can also find a 4 dimensional fixed point vector of this function.
Inputs = c(0.3, 98, 0, pi)
E = FixedPoint(Function, Inputs, Method = "Anderson")
F = FixedPoint(Function, Inputs, Method = "Anderson", MaxM = 4, ReportingSigFig = 13)
</code></pre>

<hr>
<h2 id='FixedPointNewInput'>FixedPointNewInput
This function takes the previous inputs and outputs from the FixedPoint function and determines what vector to try next in seeking
a fixed point.</h2><span id='topic+FixedPointNewInput'></span>

<h3>Description</h3>

<p>FixedPointNewInput
This function takes the previous inputs and outputs from the FixedPoint function and determines what vector to try next in seeking
a fixed point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FixedPointNewInput(
  Inputs,
  Outputs,
  Method = "Anderson",
  MaxM = 10,
  SimpleStartIndex = 1,
  ExtrapolationPeriod = 7,
  Dampening = 1,
  ConditionNumberThreshold = 1000,
  PrintReports = FALSE,
  ReplaceInvalids = c("ReplaceElements", "ReplaceVector", "NoAction")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FixedPointNewInput_+3A_inputs">Inputs</code></td>
<td>
<p>This is an N x A matrix of previous inputs for which corresponding outputs are available. In this case N is the
dimensionality of the fixed point vector that is being sought (Hence each column is a matrix that is input to the &quot;Function&quot;) and A
is the number of previous Inputs/Outputs that are being provided to the fixed point.</p>
</td></tr>
<tr><td><code id="FixedPointNewInput_+3A_outputs">Outputs</code></td>
<td>
<p>This is a matrix of Function values for the each column of the &quot;Inputs&quot; matrix.</p>
</td></tr>
<tr><td><code id="FixedPointNewInput_+3A_method">Method</code></td>
<td>
<p>This is the fixed point method to be used. It can be &quot;Anderson&quot;, &quot;Simple&quot;, &quot;Aitken&quot;, &quot;Newton&quot;, &quot;MPE&quot;, &quot;RRE&quot;, &quot;VEA&quot;, &quot;SEA&quot;.</p>
</td></tr>
<tr><td><code id="FixedPointNewInput_+3A_maxm">MaxM</code></td>
<td>
<p>This is the number of saved iterates that are used in the Anderson algorithm. This has no role if another method is used.</p>
</td></tr>
<tr><td><code id="FixedPointNewInput_+3A_simplestartindex">SimpleStartIndex</code></td>
<td>
<p>This is the index for what column in the input/output matrices did the algorithm start doing simple iterates
without jumps. This is used for all methods except the simple and Anderson methods where it has no effect.</p>
</td></tr>
<tr><td><code id="FixedPointNewInput_+3A_extrapolationperiod">ExtrapolationPeriod</code></td>
<td>
<p>This is the number of simple iterates to perform before extrapolating. This is used for the MPE, RRE, VEA and SEA
methods and has no effect if another method is chosen. Where an epsilon algorithm is used this should be one plus a multiple of two, ie (3,5,7,etc).</p>
</td></tr>
<tr><td><code id="FixedPointNewInput_+3A_dampening">Dampening</code></td>
<td>
<p>This is the dampening parameter. By default it is 1 which means no dampening takes place. It can also be less than 1
(indicating dampening) or more than 1 (indicating extrapolation).</p>
</td></tr>
<tr><td><code id="FixedPointNewInput_+3A_conditionnumberthreshold">ConditionNumberThreshold</code></td>
<td>
<p>This is what threshold should be chosen to drop previous iterates if the matrix is ill conditioned.
Only used in Anderson acceleration.</p>
</td></tr>
<tr><td><code id="FixedPointNewInput_+3A_printreports">PrintReports</code></td>
<td>
<p>This is a boolean describing whether to print ongoing ConvergenceMetric values for each iterate.</p>
</td></tr>
<tr><td><code id="FixedPointNewInput_+3A_replaceinvalids">ReplaceInvalids</code></td>
<td>
<p>This determines how NAs and Infs generated by the extrapolation method are handled. If it is &quot;NoAction&quot; then if
the extrapolation algorithm generates an NA or Inf then no action is taken. This will likely result in these NAs and Infs being fed into
the function and an error resulting. If it is &quot;ReplaceVector&quot; then the entire extrapolated vector will be replaced by a vector of a simple
iterate. If it is &quot;ReplaceElements&quot; then the elements containing an NA or Inf will be replaced by the corresponding elements from a simple iterate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the next guess in seeking a fixed point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FPFunction = function(x){c(0.5*sqrt(abs(x[1] + x[2])), 1.5*x[1] + 0.5*x[2])}
A = FixedPoint( Function = FPFunction, Inputs = c(0.3,900), MaxIter = 6, Method = "Simple")
NewGuessAnderson = FixedPointNewInput(A$Inputs, A$Outputs, Method = "Anderson")
NewGuessVEA = FixedPointNewInput(A$Inputs, A$Outputs, Method = "VEA")
NewGuessMPE = FixedPointNewInput(A$Inputs, A$Outputs, Method = "MPE")
NewGuessAitken = FixedPointNewInput(A$Inputs, A$Outputs, Method = "Aitken")
</code></pre>

<hr>
<h2 id='PolynomialExtrapolation'>PolynomialExtrapolation
This function performs Minimal Polynomial extrapolation (MPE) or Reduced Rank Extrapolation (RRE) given a matrix of previous iterates of the
function.</h2><span id='topic+PolynomialExtrapolation'></span>

<h3>Description</h3>

<p>PolynomialExtrapolation
This function performs Minimal Polynomial extrapolation (MPE) or Reduced Rank Extrapolation (RRE) given a matrix of previous iterates of the
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PolynomialExtrapolation(Iterates, Method = c("MPE", "RRE"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PolynomialExtrapolation_+3A_iterates">Iterates</code></td>
<td>
<p>A matrix of inputs and outputs excluding jumps. Can be pieced together from Inputs and Outputs matrices of the FixedPoint
function using the PutTogetherIteratesWithoutJumps function.</p>
</td></tr>
<tr><td><code id="PolynomialExtrapolation_+3A_method">Method</code></td>
<td>
<p>The method for polynomial extrapolation. Should be either &quot;MPE&quot; for minimal polynomial extrapolation or &quot;RRE&quot; for reduced
rank extrapolation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the extrapolated vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FPFunction = function(x){c(0.5*sqrt(abs(x[1] + x[2])), 1.5*x[1] + 0.5*x[2])}
A = FixedPoint( Function = FPFunction, Inputs = c(0.3,900), MaxIter = 6, Method = "Simple")
Iterates = PutTogetherIteratesWithoutJumps(A$Inputs, A$Outputs)
PolynomialExtrapolation(Iterates, "MPE")
B = FixedPoint( function(x){cos(x)}, Inputs = 1, MaxIter = 5, Method = "Simple")
Iterates = PutTogetherIteratesWithoutJumps(B$Inputs, B$Outputs)
PolynomialExtrapolation(Iterates, "RRE")
</code></pre>

<hr>
<h2 id='PutTogetherIteratesWithoutJumps'>PutTogetherIteratesWithoutJumps
This function takes the previous inputs and outputs and assembles a matrix with both excluding jumps.</h2><span id='topic+PutTogetherIteratesWithoutJumps'></span>

<h3>Description</h3>

<p>PutTogetherIteratesWithoutJumps
This function takes the previous inputs and outputs and assembles a matrix with both excluding jumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PutTogetherIteratesWithoutJumps(
  Inputs,
  Outputs,
  AgreementThreshold = 10 * .Machine$double.eps
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PutTogetherIteratesWithoutJumps_+3A_inputs">Inputs</code></td>
<td>
<p>This is an N x A matrix of previous inputs for which corresponding outputs are available. In this case N is the
dimensionality of the fixed point vector that is being sought (and each column is a matrix that is input to the &quot;Function&quot;) and A is the
number of previous Inputs/Outputs that are being provided to the fixed point.</p>
</td></tr>
<tr><td><code id="PutTogetherIteratesWithoutJumps_+3A_outputs">Outputs</code></td>
<td>
<p>This is a matrix of &quot;Function&quot; values for each column of the &quot;Inputs&quot; matrix.</p>
</td></tr>
<tr><td><code id="PutTogetherIteratesWithoutJumps_+3A_agreementthreshold">AgreementThreshold</code></td>
<td>
<p>A parameter for determining when a column in Inputs and a column in Outputs match. They are deemed to match if
the sum of the absolute values of the difference in the columns is less than AgreementThreshold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of inputs and outputs excluding jumps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = FixedPoint( function(x){c(0.5*sqrt(abs(x[1] + x[2])), 1.5*x[1] + 0.5*x[2])},
Inputs = c(0.3,900), MaxIter = 5, Method = "Simple")
A = FixedPoint( function(x){c(0.5*sqrt(abs(x[1] + x[2])), 1.5*x[1] + 0.5*x[2])},
Inputs = A$Inputs, Outputs = A$Outputs, MaxIter = 5, Method = "Aitken")
A = FixedPoint( function(x){c(0.5*sqrt(abs(x[1] + x[2])), 1.5*x[1] + 0.5*x[2])},
Inputs = A$Inputs, Outputs = A$Outputs, MaxIter = 5, Method = "Simple")
CombinedSequence = PutTogetherIteratesWithoutJumps(A$Inputs, A$Outputs)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
