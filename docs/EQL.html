<!DOCTYPE html><html lang="en"><head><title>Help for package EQL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EQL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EQL-package'>
<p>Extended Quasi-Likelihood Function (EQL)</p></a></li>
<li><a href='#approximation'><p>An Approximation Class</p></a></li>
<li><a href='#cumulants'><p>Cumulants Class For Saddlepoint Approximations</p></a></li>
<li><a href='#edgeworth'><p>Edgeworth Approximation</p></a></li>
<li><a href='#eql'><p>The Extended Quasi-Likelihood Function</p></a></li>
<li><a href='#hermite'><p>Hermite Polynomials</p></a></li>
<li><a href='#saddlepoint'><p>Saddlepoint Approximation</p></a></li>
<li><a href='#varianceFamily'><p>Variance Family Class For The EQL-Method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2009-06-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Extended-Quasi-Likelihood-Function (EQL)</td>
</tr>
<tr>
<td>Depends:</td>
<td>ttutils(&ge; 0.1-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice(&ge; 0.17-17)</td>
</tr>
<tr>
<td>Author:</td>
<td>Thorn Thaler &lt;thorn.thaler@thothal.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thorn Thaler &lt;thorn.thaler@thothal.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computation of the EQL for a given family of variance
        functions, Saddlepoint-approximations and related auxiliary
        functions (e.g. Hermite polynomials).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-08-30 13:02:46 UTC; hornik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-08-30 13:04:27 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='EQL-package'>
Extended Quasi-Likelihood Function (EQL)
</h2><span id='topic+EQL-package'></span><span id='topic+EQL'></span>

<h3>Description</h3>

<p>The package <span class="pkg">EQL</span> contains functions for
</p>

<ul>
<li><p> computation of the EQL for a given family of variance
functions
</p>
</li>
<li><p> Edgeworth approximations
</p>
</li>
<li><p> Saddlepoint approximations
</p>
</li>
<li><p> related auxiliary functions (e.g. Hermite polynomials)</p>
</li></ul>

<p>See section &lsquo;Index&rsquo; for a list of exported functions. Section
&lsquo;Internals&rsquo; lists the internal functions of the package, which
are not exported but may be referenced by
<code>EQL:::.functionName</code>. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 1.0-0</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2009-06-18</td>
</tr>
<tr>
 <td style="text-align: left;">
    Depends: </td><td style="text-align: left;"> ttutils(&gt;= 0.1-0)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Imports: </td><td style="text-align: left;"> lattice(&gt;= 0.17-17)</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
    Built: </td><td style="text-align: left;"> R 2.8.1; ; 2009-06-22 15:24:08; unix</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Index</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+approximation">approximation</a></code> </td><td style="text-align: left;"> : Approximation class</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cumulants">cumulants</a></code> </td><td style="text-align: left;"> : Cumulant class for the saddlepoint
    approximation</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+edgeworth">edgeworth</a></code> </td><td style="text-align: left;"> : Edgeworth approximation</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+eql">eql</a></code> </td><td style="text-align: left;"> : Maximization of the <abbr><span class="acronym">EQL</span></abbr>
    function for a particular</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> : variance family for a given set of parameters </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+extBinomialVarianceFamily">extBinomialVarianceFamily</a></code> </td><td style="text-align: left;"> : Extended binomial
    variance family (<code class="reqn">V(\mu)=\mu^k(1-\mu)^l</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+gammaCumulants">gammaCumulants</a></code> </td><td style="text-align: left;"> : Cumulant functions of the
    Gamma distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+gaussianCumulants">gaussianCumulants</a></code> </td><td style="text-align: left;"> : Cumulant functions of the
    normal distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+hermite">hermite</a></code> </td><td style="text-align: left;"> : Hermite polynomials</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+inverseGaussianCumulants">inverseGaussianCumulants</a></code> </td><td style="text-align: left;"> : Cumulant functions of the
    inverse-gaussian distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+powerVarianceFamily">powerVarianceFamily</a></code> </td><td style="text-align: left;"> : Power variance family
    (<code class="reqn">V(\mu)=\mu^\theta</code>)  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+saddlepoint">saddlepoint</a></code> </td><td style="text-align: left;"> : Saddlepoint approximation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+varianceFamily">varianceFamily</a></code> </td><td style="text-align: left;"> : Variance family class
  </td>
</tr>

</table>



<h3>Internals</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code>.eql</code> </td><td style="text-align: left;"> : Computes a single EQL value</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>.getFactor</code> </td><td style="text-align: left;"> : Calculates the normalizing factor for the
    saddlepoint approximation</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>.missingFormals</code> </td><td style="text-align: left;"> : Check if a list contains all the
    arguments of a particular function
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Thorn Thaler &lt;thorn.thaler@thothal.com&gt;
</p>
<p>Maintainer: Thorn Thaler &lt;thorn.thaler@thothal.com&gt;
</p>


<h3>See Also</h3>

<p><span class="pkg"><a href="ttutils.html#topic+ttutils">ttutils</a></span></p>

<hr>
<h2 id='approximation'>An Approximation Class</h2><span id='topic+approximation'></span><span id='topic+plot.approximation'></span>

<h3>Description</h3>

<p>An object of class <code>approximation</code> stores the approximation nodes
together with the approximation itself. Some meta information is saved
as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approximation(y, approx, n,
              type = c("standardized", "mean", "sum"),
              approx.type = c("Edgeworth", "Saddlepoint"))

## S3 method for class 'approximation'
plot(x, do.annotate = TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approximation_+3A_y">y</code></td>
<td>
<p>a numeric vector or array giving the approximation nodes.</p>
</td></tr>
<tr><td><code id="approximation_+3A_approx">approx</code></td>
<td>
<p>a numeric vector or array giving the approximated values
at <code>y</code>.</p>
</td></tr>
<tr><td><code id="approximation_+3A_n">n</code></td>
<td>
<p>a positive integer giving the number of i.i.d. random
variables in the sum.</p>
</td></tr>
<tr><td><code id="approximation_+3A_type">type</code></td>
<td>
<p>a character string giving the type of approximation,
i.e. which kind of sum is to be approximated. Must be one
of (&ldquo;standardized&rdquo;, &ldquo;mean&rdquo;, &ldquo;sum&rdquo;),
representing the shifted and scaled sum, the weighted sum and the
raw sum. Can be abbreviated.</p>
</td></tr>
<tr><td><code id="approximation_+3A_approx.type">approx.type</code></td>
<td>
<p>a character string giving the approximation routine
used. Must be one of of (&ldquo;Edgeworth&rdquo;, &ldquo;Saddlepoint&rdquo;) and
can be abbreviated.</p>
</td></tr>
<tr><td><code id="approximation_+3A_x">x</code></td>
<td>
<p>an <code>approximation</code> object.</p>
</td></tr>
<tr><td><code id="approximation_+3A_do.annotate">do.annotate</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) the value of
the argument <code>n</code> is added to the plot.</p>
</td></tr>
<tr><td><code id="approximation_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to the plotting
function. Giving a named argument for any of
</p>

<ul>
<li> <p><code>main</code>
</p>
</li>
<li> <p><code>sub</code>
</p>
</li>
<li> <p><code>type</code>
</p>
</li>
<li> <p><code>xlab</code>
</p>
</li>
<li> <p><code>ylab</code>
</p>
</li></ul>

<p>overrides the default values in <code>plot.approximation</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>approximation</code> contains the following components:
</p>
<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>a numeric vector of values at which the
approximation is evaluated (the approximation nodes).</p>
</td></tr>
<tr><td><code>approx</code></td>
<td>
<p>a numeric vector containing the approximated values at
the approximation nodes <code>y</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a character string giving the type of sum considered,
i.e. one of (&ldquo;standardized&rdquo;, &ldquo;mean&rdquo;, &ldquo;sum&rdquo;).</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a positive integer giving the number of i.i.d. random
variables in the sum.</p>
</td></tr>
<tr><td><code>approx.type</code></td>
<td>
<p>a character string giving the type of
approximation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thorn Thaler</p>


<h3>See Also</h3>

<p><code><a href="#topic+edgeworth">edgeworth</a></code>, <code><a href="#topic+saddlepoint">saddlepoint</a></code></p>

<hr>
<h2 id='cumulants'>Cumulants Class For Saddlepoint Approximations</h2><span id='topic+cumulants'></span><span id='topic+gammaCumulants'></span><span id='topic+gaussianCumulants'></span><span id='topic+inverseGaussianCumulants'></span><span id='topic+check.cumulants'></span>

<h3>Description</h3>

<p>A <code>cumulants</code> object contains all the cumulant functions that are needed to
calculate the saddlepoint approximation.
</p>
<p>The predefined functions
</p>

<ul>
<li> <p><code>gammaCumulants</code>,
</p>
</li>
<li> <p><code>gaussianCumulants</code> and
</p>
</li>
<li> <p><code>inverseGaussianCumulants</code>
</p>
</li></ul>

<p>compute the cumulant functions for the normal, gamma and inverse
gaussian distribution, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulants(saddlef, cgf = NULL, kappa2f = NULL, rho3f = NULL,
          rho4f = NULL, cgf.deriv = NULL,
          domain = interval(-Inf, Inf), ...)

gammaCumulants(shape, scale)
gaussianCumulants(mu, sigma2)
inverseGaussianCumulants(lambda, nu)

## S3 method for class 'cumulants'
check(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumulants_+3A_saddlef">saddlef</code></td>
<td>
<p>the saddlepoint function. Corresponds to the inverse of
the first derivative of the cumulant generating function (<abbr><span class="acronym">cgf</span></abbr>).</p>
</td></tr>
<tr><td><code id="cumulants_+3A_cgf">cgf</code>, <code id="cumulants_+3A_cgf.deriv">cgf.deriv</code></td>
<td>
<p><code>cgf</code> is the cumulant generating
function. If <code>NULL</code> (the default),  it will be derived from
<code>cgf.deriv</code> (the generic derivative function of  the cgf).</p>
</td></tr>
<tr><td><code id="cumulants_+3A_kappa2f">kappa2f</code></td>
<td>
<p>the variance function. If <code>NULL</code> (the default), it will be
derived from the function <code>cgf.deriv</code>.</p>
</td></tr>
<tr><td><code id="cumulants_+3A_rho3f">rho3f</code>, <code id="cumulants_+3A_rho4f">rho4f</code></td>
<td>
<p>the 3rd and the 4th standardized cumulant function,
respectively. If <code>NULL</code> (the default), the functions will be
derived from <code>cgf.deriv</code> if supplied. If neither the cumulants
nor <code>cgf.deriv</code> are supplied, a warning will be 
displayed and a flag is set in the output. In this case, saddlepoint
approximations cannot make use of the correction term (see
<code><a href="#topic+saddlepoint">saddlepoint</a></code> for further details).</p>
</td></tr>
<tr><td><code id="cumulants_+3A_domain">domain</code></td>
<td>
<p>an object of type <code>interval</code> giving the domain of
the random variable. Will be needed to calculate the normalizing
factor. See <code><a href="ttutils.html#topic+interval">interval</a></code> for further
information.</p>
</td></tr>
<tr><td><code id="cumulants_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the cumulant
functions, respectively function <code>check</code>.
See section &lsquo;Details&rsquo; for further information.</p>
</td></tr>
<tr><td><code id="cumulants_+3A_shape">shape</code>, <code id="cumulants_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameter for the gamma
distribution.</p>
</td></tr>
<tr><td><code id="cumulants_+3A_mu">mu</code>, <code id="cumulants_+3A_sigma2">sigma2</code></td>
<td>
<p>mean and variance parameter for the normal
distribution.</p>
</td></tr>
<tr><td><code id="cumulants_+3A_lambda">lambda</code>, <code id="cumulants_+3A_nu">nu</code></td>
<td>
<p>parameters for the inverse Gaussian distribution.</p>
</td></tr>
<tr><td><code id="cumulants_+3A_object">object</code></td>
<td>
<p>an object to be tested whether or not it meets the
formal requirements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, there are two ways to specify the cumulant functions using
<code>cumulants</code>. The first one is to specify each of the following
functions seperately:
</p>

<ul>
<li> <p><code>cgf</code>
</p>
</li>
<li> <p><code>kappa2f</code>
</p>
</li>
<li> <p><code>rho3f</code>
</p>
</li>
<li> <p><code>rho4f</code>
</p>
</li></ul>

<p>Since the functions may (and probably will) depend on some additional
parameters, it is necessary to include these parameters in the
respective argument lists. Thus, these additional parameters
must be passed to <code>cumulants</code> as <em>named</em> parameters as
well. To be more specific, if one of the above functions has an extra
parameter <code>z</code>, say, the particular value of <code>z</code> must be
passed to the function <code>cumulants</code> as well (see the example). In
any case, the first argument of the cumulant functions must be the
value at which the particular function will be evaluated. 
</p>
<p>The other way to specify the cumulant functions is to specify the
generic derivative of the <abbr><span class="acronym">cgf</span></abbr> <code>cgf.deriv</code>. Its first
argument  must be the order of the derivative and its second the value
at which it should be evaluated, followed by supplementary
arguments. <code>cgf.deriv</code> must be capable to return the
<abbr><span class="acronym">cgf</span></abbr> itself, which corresponds to the zeroth derivative.
</p>
<p>The function <code>cumulants</code> performs a basic check to test if all
needed additional parameters are supplied and displays a warning if
there are extra arguments in the cumulant functions, which are not
specified.
</p>
<p>The generic function <code>check</code> for the class <code>cumulants</code> tests if 
</p>

<ul>
<li><p> an object has the same fields as an <code>cumulants</code> object
and 
</p>
</li>
<li><p> the cumulant functions are properly vectorized, i.e. if they
return a vector whenever the argument is a vector.
</p>
</li></ul>



<h3>Value</h3>

<p><code>cumulants</code> returns an object of class <code>cumulants</code>
containing the following components:
</p>
<table role = "presentation">
<tr><td><code>K</code></td>
<td>
<p>the cumulant function.</p>
</td></tr>
<tr><td><code>mu.inv</code></td>
<td>
<p>the saddlepoint function.</p>
</td></tr>
<tr><td><code>kappa2</code></td>
<td>
<p>the variance function.</p>
</td></tr>
<tr><td><code>rho3</code>, <code>rho4</code></td>
<td>
<p>the 3rd and the 4th standardized cumulant functions.</p>
</td></tr>
<tr><td><code>domain</code></td>
<td>
<p>an interval giving the domain of the random variable.</p>
</td></tr>
<tr><td><code>extra.params</code></td>
<td>
<p>extra parameter passed to <code>cumulants</code>,
typically parameters of the underlying distribution.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>character string equating either to &ldquo;explicit&rdquo; or
&ldquo;implicit&rdquo; indicating whether the cumulant functions were
passed explicitly or were derived from the generic derivative of
the <abbr><span class="acronym">cgf</span></abbr>.</p>
</td></tr>
<tr><td><code>missing</code></td>
<td>
<p>logical. If <code>TRUE</code>, the 3rd and/or the 4th
cumulant function were not defined.</p>
</td></tr>
</table>
<p><code>gammaCumulants</code>, <code>gaussianCumulants</code> and
<code>inverseGaussianCumulants</code> return a <code>cumulants</code> object
representing the cumulant functions of the particular distribution.
</p>


<h3>Note</h3>

<p>If it happens that one of the cumulant functions <code>f</code>, say, does
not need any extra arguments while the others do, one have to define
these extra arguments for <code>f</code> nonetheless. The reason is that
<code>cumulants</code> passes any additional arguments to all defined
cumulant functions and it would end up in an error, if a function is
not capable of dealing with additional arguments.
</p>
<p>Hence, it is good practice to define all cumulant functions for the
same set of arguments, needed or not. An alternative is to add
<code>...</code> to the argument list in order to absorb any additional
arguments.
</p>
<p>The functions must be capable of handling vector input properly.
</p>
<p>Supplementary arguments <em>must not</em> be named similar to the arguments of
<code>cumulants</code> (especially any abbreviation must be avoided),
for the argument matching may match an argument (thought to be an extra
argument for one of the cumulant function) to an argument of
<code>cumulants</code>. The same problem may arise, if additional cumulant
function parameters are not named.
</p>


<h3>Author(s)</h3>

<p>Thorn Thaler</p>


<h3>References</h3>

<p>Reid, N. (1991).  Approximations and Asymptotics. <em>Statistical
Theory and Modelling</em>, London: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edgeworth">edgeworth</a></code>,
<code><a href="#topic+saddlepoint">saddlepoint</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Define cumulant functions for the normal distribution

saddlef &lt;- function(x, mu, sigma2) (x-mu)/sigma2
cgf &lt;- function(x, mu, sigma2) mu*x+sigma2*x^2/2

## Not run: 

# cgf, saddlef, kappa2, rho3 and rho4 must have the same argument lists! 
# Functions are _not_ properly vectorized!
kappa2 &lt;- function(x, sigma2) sigma2 
rho3 &lt;- function(x) 0                 
rho4 &lt;- function(x) 0

cc &lt;- cumulants(saddlef, cgf, kappa2, rho3, rho4, mu=0, sigma2=1)

check(cc) # FALSE


## End(Not run)

kappa2 &lt;- function(x, mu, sigma2)
    rep(sigma2, length(x)) 
rho3 &lt;- function(x, mu, sigma2)   # or function(x, ...)
    rep(0, length(x))        
rho4 &lt;- function(x, mu, sigma2)   # or function(x, ...)
    rep(0, length(x))        

cc &lt;- cumulants(saddlef, cgf, kappa2, rho3, rho4, mu=0, sigma2=1)

cc$K(1:2)       # 0.5 2
cc$kappa2(1:2)  # 1 1
cc$mu.inv(1:2)  # 1 2
cc$rho3(1:2)    # 0 0
cc$rho4(1:2)    # 0 0

check(cc) # TRUE

# The same using the generic derivative of the cgf

K.deriv &lt;- function(n, x, mu, sigma2) {
  if (n &lt;= 2) {
    switch(n + 1,
           return(mu * x + sigma2 * x ^ 2 / 2), # n == 0
           return(mu + sigma2 * x),             # n == 1
           return(rep(sigma2, length(x))))      # n == 2
  } else {
    return(rep(0, length(x)))                   # n &gt;= 3
  }
}

cc &lt;- cumulants(saddlef, cgf.deriv=K.deriv, mu=0, sigma2=1)

cc$K(1:2)       # 0.5 2
cc$kappa2(1:2)  # 1 1
cc$mu.inv(1:2)  # 1 2
cc$rho3(1:2)    # 0 0
cc$rho4(1:2)    # 0 0

check(cc) # TRUE

# The same using a predefined function
cc &lt;- gaussianCumulants(0, 1)

cc$K(1:2)       # 0.5 2
cc$kappa2(1:2)  # 1 1
cc$mu.inv(1:2)  # 1 2
cc$rho3(1:2)    # 0 0
cc$rho4(1:2)    # 0 0

check(cc) # TRUE

</code></pre>

<hr>
<h2 id='edgeworth'>Edgeworth Approximation</h2><span id='topic+edgeworth'></span>

<h3>Description</h3>

<p>Computes the Edgeworth expansion of either the
standardized mean, the mean or the sum of i.i.d. random variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgeworth(x, n, rho3, rho4, mu, sigma2, deg=3,
          type = c("standardized", "mean", "sum"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edgeworth_+3A_x">x</code></td>
<td>
<p>a numeric vector or array giving the values at which the
approximation should be evaluated.</p>
</td></tr>
<tr><td><code id="edgeworth_+3A_n">n</code></td>
<td>
<p>a positive integer giving the number of i.i.d. random
variables in the sum.</p>
</td></tr>
<tr><td><code id="edgeworth_+3A_rho3">rho3</code></td>
<td>
<p>a numeric value giving the standardized 3rd cumulant. May
be missing if <code>deg &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="edgeworth_+3A_rho4">rho4</code></td>
<td>
<p>a numeric value giving the standardized 4th cumulant. May
be missing if <code>deg &lt;= 2</code>.</p>
</td></tr>
<tr><td><code id="edgeworth_+3A_mu">mu</code></td>
<td>
<p>a numeric value giving the mean.
</p>
<p>May be missing if <code>type = "standardized"</code>, since it is
only needed for transformation purposes.</p>
</td></tr>  
<tr><td><code id="edgeworth_+3A_sigma2">sigma2</code></td>
<td>
<p>a positive numeric value giving the variance.
</p>
<p>May be missing if <code>type= "standardized"</code>.</p>
</td></tr>
<tr><td><code id="edgeworth_+3A_deg">deg</code></td>
<td>
<p>an integer value giving the order of the approximation:
</p>

<ul>
<li> <p><code>deg=1</code>: corresponds to a normal approximation
</p>
</li>
<li> <p><code>deg=2</code>: takes 3rd cumulant into account
</p>
</li>
<li> <p><code>deg=3</code>: allows for the 4th cumulant as well.
The default value is 3.
</p>
</li></ul>
</td></tr>
<tr><td><code id="edgeworth_+3A_type">type</code></td>
<td>
<p>determines which sum should be approximated. Must be one
of (&ldquo;standardized&rdquo;, &ldquo;mean&rdquo;, &ldquo;sum&rdquo;),
representing the shifted and scaled sum, the weighted sum and the
raw sum. Can be abbreviated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Edgeworth approximation (<abbr><span class="acronym">EA</span></abbr>) for the density of the
standardized mean <code class="reqn">Z=\frac{S_n-n\mu}
    {\sqrt{n\sigma^2}}</code>, where
</p>

<ul>
<li> <p><code class="reqn">S_n = Y_1 + \ldots + Y_n</code> denotes the sum of i.i.d. random
variables,
</p>
</li>
<li> <p><code class="reqn">\mu</code> denotes the expected value of <code class="reqn">Y_i</code>,
</p>
</li>
<li> <p><code class="reqn">\sigma^2</code> denotes the variance of <code class="reqn">Y_i</code>
</p>
</li></ul>

<p>is given by:
</p>
<p style="text-align: center;"><code class="reqn">f_{Z}(s)=\varphi(s)[ 1 + \frac{\rho_3}{6\sqrt{n}} H_3(s) +
    \frac{\rho_4}{24n} H_4(s) + \frac{\rho_3^2}{72n} H_6(s)],</code>
</p>


<p>with <code class="reqn">\varphi</code> denoting the density of the standard normal
distribution and <code class="reqn">\rho_3</code> and <code class="reqn">\rho_4</code> denoting
the 3rd and the 4th standardized cumulants of <code class="reqn">Y_i</code>
respectively. <code class="reqn">H_n(x)</code> denotes the <code class="reqn">n</code>th Hermite polynomial (see
<code><a href="#topic+hermite">hermite</a></code> for details).
</p>
<p>The <abbr><span class="acronym">EA</span></abbr> for the mean and the sum can be obtained by applying
the transformation theorem for densities. In this case, the expected
value <code>mu</code> and the variance <code>sigma2</code> must be given to allow
for an appropriate transformation.
</p>


<h3>Value</h3>

<p><code>edgeworth</code> returns an object of the class
<code>approximation</code>. See <code><a href="#topic+approximation">approximation</a></code> for further
details.
</p>


<h3>Author(s)</h3>

<p>Thorn Thaler</p>


<h3>References</h3>

<p>Reid, N. (1991).  Approximations and Asymptotics. <em>Statistical
Theory and Modelling</em>, London: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+approximation">approximation</a></code>,<code><a href="#topic+hermite">hermite</a></code>,<code><a href="#topic+saddlepoint">saddlepoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Approximation of the mean of n iid Chi-squared(2) variables

n &lt;- 10
df &lt;- 2
mu &lt;- df
sigma2 &lt;- 2*df
rho3 &lt;- sqrt(8/df)
rho4 &lt;- 12/df
x &lt;- seq(max(df-3*sqrt(2*df/n),0), df+3*sqrt(2*df/n), length=1000)
ea &lt;- edgeworth(x, n, rho3, rho4, mu, sigma2, type="mean")
plot(ea, lwd=2)

# Mean of n Chi-squared(2) variables is n*Chi-squared(n*2) distributed
lines(x, n*dchisq(n*x, df=n*mu), col=2)
</code></pre>

<hr>
<h2 id='eql'>The Extended Quasi-Likelihood Function</h2><span id='topic+eql'></span><span id='topic+plot.eql'></span>

<h3>Description</h3>

<p>Computes the Extended Quasi Likelihood (<abbr><span class="acronym">EQL</span></abbr>) function for
a given set of variance functions from a particular variance family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eql(formula, param.space, family = powerVarianceFamily(),
    phi.method = c("pearson", "mean.dev"), include.model = TRUE,
    smooth.grid = 10, do.smooth = dim(family) == 1,
    verbose = 1, ...)

## S3 method for class 'eql'
plot(x, do.points = (dim(x) == 1 &amp;&amp; sum(!x$is.smoothed) &lt;= 20),
     do.ci = TRUE, alpha = 0.95, do.bw = TRUE,
     show.max = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eql_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code> (or one that can be coerced to
that class): a symbolic description of the model to be
used to determine the parameters of the variance function.</p>
</td></tr>
<tr><td><code id="eql_+3A_param.space">param.space</code></td>
<td>
<p>a list of parameters for which the <abbr><span class="acronym">EQL</span></abbr>
value should be evaluated. If provided as a named list,
the names must equal the names of the parameters defined by
the variance family.</p>
</td></tr>
<tr><td><code id="eql_+3A_family">family</code></td>
<td>
<p>an object of class <code>varianceFamily</code> giving a
parameterized family of variance functions. See
<code><a href="#topic+varianceFamily">varianceFamily</a></code> for further details.</p>
</td></tr>
<tr><td><code id="eql_+3A_phi.method">phi.method</code></td>
<td>
<p>a character string giving the name of the method 
used to estimate the dispersion parameter
<code class="reqn">\phi</code>. Must be one of (&ldquo;pearson&rdquo;,
&ldquo;mean.dev&rdquo;) representing the estimation of <code class="reqn">\phi</code>
by the mean Pearson's statistic or by the mean deviance, respectively.</p>
</td></tr>
<tr><td><code id="eql_+3A_include.model">include.model</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) the final
model is included in the output.</p>
</td></tr>
<tr><td><code id="eql_+3A_x">x</code></td>
<td>
<p>an object of class <code>eql</code>.</p>
</td></tr>
<tr><td><code id="eql_+3A_do.smooth">do.smooth</code>, <code id="eql_+3A_smooth.grid">smooth.grid</code></td>
<td>
<p><code>do.smooth</code> is a logical value and
<code>smooth.grid</code> is an integer value giving the number of nodes
for the smoothing process. If <code>do.smooth</code> is <code>TRUE</code>,
smoothing is carried out by cubic splines on an equidistant grid
with an amount of nodes equals to <code>smooth.grid</code> between two
adjacent <abbr><span class="acronym">EQL</span></abbr> values. Smoothing is currently only
available for one-dimensional variance families, i.e. families that
depend only on one parameter.</p>
</td></tr>
<tr><td><code id="eql_+3A_verbose">verbose</code></td>
<td>
<p>the amount of feedback requested: &lsquo;0&rsquo; or <code>FALSE</code> means
no feedback, &lsquo;1&rsquo; or <code>TRUE</code> means some feedback (the
default), and &lsquo;2&rsquo; means to show all available
feedback. For the default setting, a progress bar will be displayed
to give a rough estimation of the remaining calculation time. Full
feedback prints  the <abbr><span class="acronym">EQL</span></abbr> value for each parameter
combination.</p>
</td></tr>
<tr><td><code id="eql_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the <code><a href="stats.html#topic+glm">glm</a></code>
routine and the plotting routine, respectively.</p>
</td></tr>
<tr><td><code id="eql_+3A_do.points">do.points</code>, <code id="eql_+3A_show.max">show.max</code></td>
<td>
<p>logical. If <code>do.points</code> is
<code>TRUE</code>, the computed <abbr><span class="acronym">EQL</span></abbr>  values are marked in the
plot. If <code>show.max</code> is <code>TRUE</code>, the maximum of the
<abbr><span class="acronym">EQL</span></abbr> function is emphasized in the plot.</p>
</td></tr>
<tr><td><code id="eql_+3A_do.ci">do.ci</code>, <code id="eql_+3A_alpha">alpha</code></td>
<td>
<p><code>do.ci</code> is a logical value, if <code>TRUE</code> a
<code class="reqn">\alpha</code> confidence interval (respectively confidence
ellipsoid) is added to the plot.</p>
</td></tr>
<tr><td><code id="eql_+3A_do.bw">do.bw</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) a &ldquo;black
and white&rdquo; plot is produced, otherwise colours are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <abbr><span class="acronym">EQL</span></abbr> function as defined by <cite>Nelder and Pregibon</cite>
(see &lsquo;References&rsquo;) is given by:
</p>
<p style="text-align: center;"><code class="reqn">Q^+_\theta(y,\mu) = -\frac{1}{2} \log [2\pi\phi V_\theta(y)] -
     \frac{1}{2\phi} D_\theta(y,\mu),</code>
</p>

<p>where <code class="reqn">D_\theta()</code> and <code class="reqn">V_\theta()</code> denote the
deviance function and the variance function, respectively, determined by
the particular choice of the variance family.
</p>
<p>The goal is to maximize the <abbr><span class="acronym">EQL</span></abbr> function over <code class="reqn">\mu</code>
and the not necessarily one-dimensional space of parameters
<code class="reqn">\theta</code>. The function <code>eql</code> takes a particular finite
set of candidate parameters and computes the corresponding
<abbr><span class="acronym">EQL</span></abbr> value for each of these parameters and returns the
maximum <abbr><span class="acronym">EQL</span></abbr> value for the given set. That implies that the
function is only capable of capturing local maxima. If the maximum occurs
at the boundary of the set, the set of parameters may be badly chosen
and one should consider a larger set with the found maximum as an
interior point.
</p>
<p>The <code>plot</code> function is an important tool to investigate the
structure of the <abbr><span class="acronym">EQL</span></abbr> function. Confidence intervals and
confidence ellipsoids give an idea of plausible parameter values
for the variance function. The contour plot
used for two-dimensional variance families is generated using the
package <span class="pkg">lattice</span>, which in turn relies on so called
<code>trellis</code> plots. Hence, for two-dimensional families the
<code>plot</code> function does not only generate the plot, but also
returns the plot object to allow for further modifications of the
plot. This is not true for one-dimensional variance models, which are
plotted using the <span class="rlang"><b>R</b></span> standard graphical engine.
</p>
<p>For large parameter sets the computation may take a long time. If no
feedback is chosen, the function seems to be hung up, because the
function does not provide any textual feedback while computing. Hence,
a minimal feedback (including a progress bar) should be chosen to have
an idea of the remaining calculation time.
</p>
<p>An explicitely given deviance function speeds up calculation. A rather
large amount of the total calculation time is used to determine the
numerical values of the integral in the deviance function.
</p>


<h3>Value</h3>

<p><code>eql</code> returns an object of class <code>eql</code>, which contains the
following components:
</p>
<table role = "presentation">
<tr><td><code>eql</code></td>
<td>
<p>a numerical vector with the computed eql values for the given
set of parameter values. For one-dimensional variance families
(i.e. those families with only one parameter), a smoothing
operation can be performed to obtain intermediate values.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a <code>data.frame</code> containing the values of the
parameters at which the eql function was evaluated.</p>
</td></tr>
<tr><td><code>eql.max</code></td>
<td>
<p>the maximum value of the eql function in the considered
range.</p>
</td></tr>
<tr><td><code>param.max</code></td>
<td>
<p>a <code>data.frame</code> containing the values of the
parameters at which the maximum is obtained.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>an integer value giving the dimension of the parameters in
the underlying variance family.</p>
</td></tr>
<tr><td><code>smooth</code></td>
<td>
<p>a logical value indicating whether a smoothing operation
was performed.</p>
</td></tr>
<tr><td><code>is.smoothed</code></td>
<td>
<p>a vector of logical values of the same length as
<code>eql</code> indicating if the particular <abbr><span class="acronym">EQL</span></abbr> value was
obtained by smoothing or was calculated directly.</p>
</td></tr> 
<tr><td><code>smooth.grid</code></td>
<td>
<p>an integer value giving the number of points used
in the smoothing process or <code>NULL</code> if no smoothing was
performed.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if <code>include.model</code> is <code>TRUE</code>, the <abbr><span class="acronym">GLM</span></abbr>
for which the maximum <abbr><span class="acronym">EQL</span></abbr> value was archieved,
<code>NULL</code> otherwise.</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>The EQL for variance functions with <code class="reqn">V_\theta(0)=0</code>
becomes infinite. Hence, if there are exact zeros in the data, one
should provide a variance family, which do not equate to zero at the
origin. <cite>Nelder and Pregibon</cite> propose some adjustment of <code class="reqn">V(y)</code>
at the origin, which leads to a modified variance function. 
</p>
<p>The predefined families <code><a href="#topic+powerVarianceFamily">powerVarianceFamily</a></code> and
<code><a href="#topic+extBinomialVarianceFamily">extBinomialVarianceFamily</a></code> are, however, <em>not</em> capable of
dealing with exact zeros, for there is no general mechanism to modify
the variance function for all possible values of the particular variance
family.
</p>
<p>The confidence interval for one-dimensional variance families is not
calculated exactly, but depends on the amount of <abbr><span class="acronym">EQL</span></abbr> values
available. Hence, if one is interested in a confidence interval, one
should allow for smoothing.
</p>
<p>The function <code>eql</code> does not use a direct maximization routine, but
rather do a simple maximation over a finite set. Hence, all obtained
values including confidence intervals and confidence ellipsoids have a
&ldquo;local flavour&rdquo; and should not be regarded as global solutions.
</p>
<p>The confidence bounds are determined rather empirically and do heavily
depend on the amount of parameter values under consideration.
</p>


<h3>Author(s)</h3>

<p>Thorn Thaler</p>


<h3>References</h3>

<p>Nelder, J.A. and Pregibon, D. (1987).  An extended quasi-likelihood
function. <em>Biometrika</em>, <b>74</b>, 221&ndash;232.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varianceFamily">varianceFamily</a></code>, <code><a href="stats.html#topic+glm">glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Power Variance Family
# Data from Box and Cox (1964)
x &lt;- (-1:1)
y &lt;- c(674,370,292,338,266,210,170,118,90,1414,1198,634,1022,620,438,
       442,332,220,3636,3184,2000,1568,1070,566,1140,884,360)
yarn.raw &lt;- data.frame(expand.grid(x3=x, x2=x, x1=x), cycles=y)
yarn &lt;- data.frame(x1=yarn.raw$x1, x2=yarn.raw$x2, x3=yarn.raw$x3,
   cycles=yarn.raw$cycles)
attach(yarn)

ps.power &lt;- list(theta=seq(1, 4, length = 20))
eq.power &lt;- eql(cycles~x1+x2+x3, param.space=ps.power,
   family=powerVarianceFamily("log"), smooth.grid=500)
plot(eq.power)

## Not run: 
## Extended Binomial Variance Family
# Data from McCullagh &amp; Nelder: GLM, p. 329
# (zeros replaced by 'NA')

site &lt;- rep(1:9, each=10)
variety &lt;- rep(1:10, 9)
resp &lt;- c(0.05,NA,NA,0.10,0.25,0.05,0.50,1.30,1.50,1.50,
   NA,0.05,0.05,0.30,0.75,0.30,3,7.50,1,12.70,1.25,1.25,
   2.50,16.60,2.50,2.50,NA,20,37.50,26.25,2.50,0.50,0.01,
   3,2.50,0.01,25,55,5,40,5.50,1,6,1.10,2.50,8,16.50,
   29.50,20,43.50,1,5,5,5,5,5,10,5,50,75,5,0.10,5,5,
   50,10,50,25,50,75,5,10,5,5,25,75,50,75,75,75,17.50,
   25,42.50,50,37.50,95,62.50,95,95,95) / 100

ps.binomial &lt;- list(seq(1, 2.2, length=32), seq(1, 3, length=32))
eq.binomial &lt;- eql(resp~site*variety, param.space=ps.binomial,
   family=extBinomialVarianceFamily())
plot(eq.binomial)

## End(Not run)
</code></pre>

<hr>
<h2 id='hermite'>Hermite Polynomials</h2><span id='topic+hermite'></span>

<h3>Description</h3>

<p>Computes the Hermite polynomial <code class="reqn">H_n(x)</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>hermite(x, n, prob = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hermite_+3A_x">x</code></td>
<td>
<p>a numeric vector or array giving the values at which the
Hermite polynomial should be evaluated.</p>
</td></tr>
<tr><td><code id="hermite_+3A_n">n</code></td>
<td>
<p>an integer vector or array giving the degrees of the Hermite
polynomials. If <code>length(x) != 1</code>, <code>n</code> must be either of the
same length as <code>x</code> or a  single value.</p>
</td></tr>
<tr><td><code id="hermite_+3A_prob">prob</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) the probabilistic
version of the Hermite polynomial is evaluated, otherwise the
physicists' Hermite polynomials are used. See the &lsquo;Details&rsquo;
section below for further information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hermite polynomials are given by:
</p>

<ul>
<li> <p><code class="reqn">H_{n+1}(x)=xH_n(x)-nH_{n-1}(x),</code> with <code class="reqn">H_0(x)=1</code> and <code class="reqn">H_1(x)=x</code>,
(Probabilists' version <code class="reqn">H_n^{Pr}(x)</code>)
</p>
</li>
<li> <p><code class="reqn">H_{n+1}(x)=2xH_n(x)-2nH_{n-1}(x)</code>, with <code class="reqn">H_0(x)=1</code> and
<code class="reqn">H_1(x)=2x</code>. (Physicists' version <code class="reqn">H_n^{Ph}(x)</code>)
</p>
</li></ul>

<p>and the relationship between the two versions is given by
</p>
<p style="text-align: center;"><code class="reqn">H_n^{Ph}(x)=2^{n/2}H_n^{Pr}(\sqrt{2}x).
  </code>
</p>

<p>The term &lsquo;probabilistic&rsquo; is motivated by the fact that in this
case the Hermite polynomial <code class="reqn">H_n(x)</code> can be as well defined by
</p>
<p style="text-align: center;"><code class="reqn">H_n(x)=(-1)^{n}\frac{1}{\varphi(x)} \varphi^{(n)}(x),</code>
</p>

<p>where <code class="reqn">\varphi(x)</code> denotes the density function of the
standard normal distribution and <code class="reqn">\varphi^{(k)}(x)</code>
denotes the <code class="reqn">k</code>th derivative of <code class="reqn">\varphi(x)</code> with respect
to <code class="reqn">x</code>. 
</p>
<p>If the argument <code>n</code> is a vector it must be of the same
length as the argument <code>x</code> or the length of the argument <code>x</code>
must be equal to one. The Hermite polynomials are then evaluated
either at <code class="reqn">x_i</code> with degree <code class="reqn">n_i</code> or at <code class="reqn">x</code> with degree
<code class="reqn">n_i</code>, respectively.
</p>


<h3>Value</h3>

<p>the Hermite polynomial (either the probabilists' or the
physicists' version) evaluated at <code>x</code>.</p>


<h3>Author(s)</h3>

<p>Thorn Thaler</p>


<h3>References</h3>

<p>Fedoryuk, M.V. (2001). Hermite
polynomials. <em>Encyclopaedia of Mathematics</em>, Kluwer Academic
Publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>2^(3/2)*hermite(sqrt(2)*5, 3)    # = 940
hermite(5, 3, FALSE)             # = 940
hermite(2:4, 1:3)                # H_1(2), H_2(3), H_3(4)
hermite(2:4, 2)                  # H_2(2), H_2(3), H_2(4)
hermite(2, 1:3)                  # H_1(2), H_2(2), H_3(2)
## Not run: 
hermite(1:3, 1:4)                # Error!

## End(Not run)
</code></pre>

<hr>
<h2 id='saddlepoint'>Saddlepoint Approximation</h2><span id='topic+saddlepoint'></span>

<h3>Description</h3>

<p>Computes the (normalized) saddlepoint approximation of the mean of
<code class="reqn">n</code> i.i.d. random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saddlepoint(x, n, cumulants, correct = TRUE, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saddlepoint_+3A_x">x</code></td>
<td>
<p>a numeric vector or array with the values at which the
approximation should be evaluated.</p>
</td></tr>
<tr><td><code id="saddlepoint_+3A_n">n</code></td>
<td>
<p>a positive integer giving the number of i.i.d. random
variables in the sum.</p>
</td></tr>
<tr><td><code id="saddlepoint_+3A_cumulants">cumulants</code></td>
<td>
<p>a <code>cumulants</code> object giving the cumulant
functions and the saddlepoint function. See <code><a href="#topic+cumulants">cumulants</a></code>
for further information.</p>
</td></tr>
<tr><td><code id="saddlepoint_+3A_correct">correct</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) the correction term
involving the 3rd and the 4th standardized cumulant functions is included.</p>
</td></tr>
<tr><td><code id="saddlepoint_+3A_normalize">normalize</code></td>
<td>
<p>logical. If <code>TRUE</code> the renormalized version of
the saddlepoint approximation is calculated. The renormalized
version does neither make use of the 3rd nor of the 4th cumulant
function so setting <code>correct=TRUE</code> will result in a
warning. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The saddlepoint approximation (<abbr><span class="acronym">SA</span></abbr>) for the density of the
mean <code class="reqn">Z=S_n/n</code> of i.i.d. random variables
<code class="reqn">Y_i</code> with <code class="reqn">S_n=\sum_{i=1}^n Y_i</code> is given
by:
</p>
<p style="text-align: center;"><code class="reqn">f_Z(z) \approx c\sqrt{\frac{n}{2\pi K_{Y}''(s)}}
    \exp\{n[K_{Y}(s)- sz]\},</code>
</p>

<p>where <code class="reqn">c</code> is an appropriatly chosen correction term, which is
based on higher cumulants. The function <code class="reqn">K_Y(\cdot)</code> denotes the cumulant
generating function and <code class="reqn">s</code> denotes the <em>saddlepoint</em>
which is the solution of the saddlepoint function:
</p>
<p style="text-align: center;"><code class="reqn">K'(s)=z.</code>
</p>

<p>For the renormalized version of the <abbr><span class="acronym">SA</span></abbr> one chooses <code class="reqn">c</code>
such that <code class="reqn">f_Z(z)</code> integrates to one, otherwise it includes the
3rd and the 4th standardized cumulant.
</p>
<p>The saddlepoint approximation is an improved version of the Edgeworth
approximation and makes use of &lsquo;exponential tilted&rsquo;
densities. The weakness of the Edgeworth method lies in the
approximation in the tails of the density. Thus, the saddlepoint
approximation embed  the original density in the &ldquo;conjugate
exponential family&rdquo; with parameter <code class="reqn">\theta</code>. The mean of
the embeded density depends on <code class="reqn">\theta</code> which allows for
evaluating the Edgeworth approximation at the mean, where it is known
to give reasonable results.
</p>


<h3>Value</h3>

<p><code>saddlepoint</code> returns an object of class <code>approximation</code>. See
function <code><a href="#topic+approximation">approximation</a></code> for further details.
</p>


<h3>Author(s)</h3>

<p>Thorn Thaler</p>


<h3>References</h3>

<p>Reid, N. (1991).  Approximations and Asymptotics. <em>Statistical
Theory and Modelling</em>, London: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+approximation">approximation</a></code>, <code><a href="#topic+cumulants">cumulants</a></code>, <code><a href="#topic+edgeworth">edgeworth</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Saddlepoint approximation for the density of the mean of n Gamma
# variables with shape=1 and scale=1
n &lt;- 10
shape &lt;- scale &lt;- 1
x &lt;- seq(0, 3, length=1000) 
sp &lt;- saddlepoint(x, n, gammaCumulants(shape, scale))
plot(sp, lwd=2)

# Mean of n Gamma(1,1) variables is n*Gamma(n,1) distributed
lines(x, n*dgamma(n*x, shape=n*shape, scale=scale), col=2)

</code></pre>

<hr>
<h2 id='varianceFamily'>Variance Family Class For The EQL-Method</h2><span id='topic+varianceFamily'></span><span id='topic+powerVarianceFamily'></span><span id='topic+extBinomialVarianceFamily'></span>

<h3>Description</h3>

<p><code>varianceFamily</code> provides a class for a parameterized family of
variance functions to be used with <code><a href="#topic+eql">eql</a></code>.
</p>
<p>The predefined functions <code>powerVarianceFamily</code> and
<code>extBinomialVarianceFamily</code> compute the variance family defined
by the parametric variance functions <code class="reqn">V_\theta(\mu) =
  \mu^\theta</code> and <code class="reqn">V_{k,l}(\mu) =
  \mu^k(1-\mu)^l</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varianceFamily(varf, devf = NULL, link = "log", initf = NULL,
               validmuf = NULL, name = "default")

powerVarianceFamily(link = "log")
extBinomialVarianceFamily(link = "logit")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varianceFamily_+3A_varf">varf</code></td>
<td>
<p>the parameterized variance function.</p>
</td></tr>
<tr><td><code id="varianceFamily_+3A_devf">devf</code></td>
<td>
<p>the deviance function. If <code>NULL</code> (the default) it
will be determined numerically from the variance function <code>varf</code>.</p>
</td></tr>
<tr><td><code id="varianceFamily_+3A_link">link</code></td>
<td>
<p>the link function.</p>
</td></tr>
<tr><td><code id="varianceFamily_+3A_initf">initf</code></td>
<td>
<p>a function returning an object of class
<code>expression</code>. The <code>expression</code> object should give a
sequence of initializing commands for the <code><a href="stats.html#topic+glm">glm</a></code> routine
such as setting the  starting values. If <code>NULL</code> (the default),
a very rudimentary initialize function is  chosen, which may not be
appropriate. See <code><a href="stats.html#topic+family">family</a></code> for further details.</p>
</td></tr>
<tr><td><code id="varianceFamily_+3A_validmuf">validmuf</code></td>
<td>
<p>a function giving <code>TRUE</code> if its argument is a
valid value for <code class="reqn">\mu</code> and <code>FALSE</code> otherwise. If
<code>NULL</code> (the default), all <code class="reqn">\mu</code> are supposed to be
valid.</p>
</td></tr>
<tr><td><code id="varianceFamily_+3A_name">name</code></td>
<td>
<p>a character string giving the name of the variance family.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of the function <code>varianceFamily</code> is to provide a
convenient way to specify families of variance functions. An extended
glm <code><a href="stats.html#topic+family">family</a></code> object for a particular choice of a parameter
vector can be obtained via the class member <code>family</code>.
</p>
<p>The minimal specification for a <code>varianceFamily</code> object is the
variance function <code class="reqn">V_\theta(\mu)</code> with
<code class="reqn">\theta</code> describing the vector of family
parameters. If not given explicitly, the deviance function is
determined numerically.
</p>
<p>The family parameter of <code>powerVarianceFamily</code> is &lsquo;theta&rsquo;,
while the names of the parameters of <code>extBinomialVarianceFamily</code> are
&lsquo;k&rsquo; and &lsquo;l&rsquo;.
</p>


<h3>Value</h3>

<p><code>varianceFamily</code> returns an object of class <code>varianceFamily</code>
containing the following components:
</p>
<table role = "presentation">
<tr><td><code>family</code></td>
<td>
<p>a function which computes an <code>extFamily</code> object,
which is an extension of the <code><a href="stats.html#topic+family">family</a></code> object known from
classical <code><a href="stats.html#topic+glm">glm</a></code>. <code>extFamily</code> inherits from class
<code><a href="stats.html#topic+family">family</a></code> and contains an additional field holding the
value of the particular parameters at which the family was evaluated.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>a character string giving the name of the variance
family.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>a list of the parameters of the variance family.</p>
</td></tr>
<tr><td><code>type.dev</code></td>
<td>
<p>a character string. Equals either &ldquo;explicit&rdquo; or
&ldquo;numerical&rdquo; depending on how the deviance function was determined.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Those arguments passed to <code>varianceFunction</code> that are functions,
are supposed to accept the variance family's parameter as an
argument. The idea is that any of these functions may give different
results for different values of the family's parameters. Even if any
of these functions do not depend on these parameters, they must be
contained in the function's argument list.
</p>


<h3>Author(s)</h3>

<p>Thorn Thaler</p>


<h3>References</h3>

<p>Nelder, J.A. and Pregibon, D. (1987).  An Extended Quasi-Likelihood
Function. <em>Biometrika</em>, <b>74</b>, 221&ndash;232.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+family">family</a></code>, <code><a href="#topic+eql">eql</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># The extended binomial variance family
# (the deviance is determined numerically)

# init does not depend on k and l but it must accept
# these parameters anyways
init &lt;- function(k, l) {
  return(expression({
    mustart &lt;- (weights * y + 0.5)/(weights + 1)
    n &lt;- rep.int(1, nobs)}))
}
validmuf &lt;- function(mu, k, l) {
  return(all(mu &gt; 0) &amp;&amp; all(mu &lt; 1))
}
varf &lt;- function(y, k, l)  y^k*(1-y)^l
suppressWarnings(vf &lt;- varianceFamily(varf=varf, link="log", initf=init, 
                        validmuf=validmuf,
                        name="Extended-Binomial-Family"))
vf$family(1,1) # corresponds to binomial()

y &lt;- runif(10, 0, 1)
mu &lt;- runif(10, 0, 1)

all.equal(vf$family(1,1)$dev.resids(y,mu,1),     # TRUE
          binomial()$dev.resids(y,mu,1))    

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
