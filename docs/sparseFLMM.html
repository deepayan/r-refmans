<!DOCTYPE html><html><head><title>Help for package sparseFLMM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sparseFLMM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acoustic'><p>Phonetics acoustic data (complete)</p></a></li>
<li><a href='#acoustic_subset'><p>Phonetics acoustic data (subset)</p></a></li>
<li><a href='#make_summation_matrix'><p>Construct symmetry constraint matrix for bivariate symmetric smoothing.</p></a></li>
<li><a href='#Predict.matrix.symm.smooth'><p>Predict matrix method for (skew-)symmetric bivariate smooths.</p></a></li>
<li><a href='#smooth.construct.symm.smooth.spec'><p>Symmetric bivariate smooths constructor</p></a></li>
<li><a href='#sparseFLMM'><p>Functional Linear Mixed Models for Irregularly or Sparsely Sampled Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functional Linear Mixed Models for Irregularly or Sparsely
Sampled Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jona Cederbaum &lt;Jona.Cederbaum@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of functional linear mixed models for irregularly or
    sparsely sampled data based on functional principal component analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3), mgcv (&ge; 1.8-12), refund (&ge; 0.1-22)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, parallel, MASS, Matrix, data.table</td>
</tr>
<tr>
<td>Collate:</td>
<td>'call_all_functions.R' 'cov_estimation_tri.R'
'cov_estimation_tri_constr.R' 'cov_estimation_whole.R'
'cov_estimation_tri_constr_nest.R' 'fpc_estimation.R'
'fpc_famm_estimation.R' 'get_cross_products.R'
'mean_estimation.R' 'tri_constraint_constructor.R'
'useful_functions.R' 'zzz.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-19 08:37:32 UTC; Jona</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-19 09:10:02 UTC</td>
</tr>
<tr>
<td>Author:</td>
<td>Jona Cederbaum [aut, cre],
  Alexander Volkmann [aut],
  Almond St√∂cker [aut]</td>
</tr>
</table>
<hr>
<h2 id='acoustic'>Phonetics acoustic data (complete)</h2><span id='topic+acoustic'></span>

<h3>Description</h3>

<p>The data are part of a large study on consonant assimilation, which is
the phenomenon that the articulation of two consonants becomes
phonetically more alike when they appear subsequently in fluent speech.
The data set contains the audio signals of nine different speakers which
repeated the same sixteen German target words each five times.
The target words are bisyllabic noun-noun compound words which
contained the two abutting consonants of interest,
s and sh, in either order. Consonant assimilation is accompanied by a complex interplay
of language-specific, perceptual and articulatory factors. The aim in the study was to investigate the assimilation
of the two consonants as a function of their order (either first s, then sh or vice-versa),
syllable stress (stressed or unstressed) and vowel
context, i.e. which vowels are immediately adjacent to the target consonants of interest.
The vowels are either of the form ia or ai. For more details, see references below.
</p>


<h3>Format</h3>

<p>A data frame with 24830 rows and 11 variables
</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li> <p><code>subject_long</code>: unique identification number for each speaker.
</p>
</li>
<li> <p><code>word_long</code>: unique identification number for each target word.
</p>
</li>
<li> <p><code>combi_long</code>: number of the repetition of the combination of the
corresponding speaker and target word.
</p>
</li>
<li> <p><code>y_vec</code>: the response values for each observation point
</p>
</li>
<li> <p><code>n_long</code>: unique identification number for each curve.
</p>
</li>
<li> <p><code>t</code>: the observations point locations.
</p>
</li>
<li> <p><code>covariate.1</code>: (order of the consonants, reference category first /s/ then /sh/).
</p>
</li>
<li> <p><code>covariate.2</code>: (stress of the final syllable of the first compound,
reference category 'stressed').
</p>
</li>
<li> <p><code>covariate.3</code>: (stress of the initial syllable of the second compound,
reference category 'stressed').
</p>
</li>
<li> <p><code>covariate.4</code>: (vowel context, reference category ia).
</p>
</li>
<li> <p><code>word_names_long</code>: names of the target words.
</p>
</li></ul>



<h3>References</h3>

<p>Pouplier, Marianne and Hoole, Philip (2016): Articulatory and
Acoustic Characteristics of German Fricative Clusters,
Phonetica, 73(1), 52&ndash;78.
</p>
<p>Cederbaum, Pouplier, Hoole, Greven (2016): Functional Linear Mixed Models
for Irregularly or Sparsely Sampled Data. Statistical Modelling, 16(1), 67-88.
</p>

<hr>
<h2 id='acoustic_subset'>Phonetics acoustic data (subset)</h2><span id='topic+acoustic_subset'></span>

<h3>Description</h3>

<p>A small subset of the phonetics acoustic
data set <code><a href="#topic+acoustic">acoustic</a></code> with observations from two speakers and two items only.
This will not produce meaningful results but can be used as a toy
data set when testing the code.
The variables are as in the full data set, see <code><a href="#topic+acoustic">acoustic</a></code>.
</p>


<h3>Format</h3>

<p>A data frame with 656 rows and 11 variables
</p>


<h3>References</h3>

<p>Pouplier, Marianne and Hoole, Philip (2016): Articulatory and
Acoustic Characteristics of German Fricative Clusters,
Phonetica, 73(1), 52&ndash;78.
</p>
<p>Cederbaum, Pouplier, Hoole, Greven (2016): Functional Linear Mixed Models
for Irregularly or Sparsely Sampled Data. Statistical Modelling, 16(1), 67-88.
</p>

<hr>
<h2 id='make_summation_matrix'>Construct symmetry constraint matrix for bivariate symmetric smoothing.</h2><span id='topic+make_summation_matrix'></span>

<h3>Description</h3>

<p>This function can be used to construct a symmetry constraint matrix that imposes
a (skew-)symmetry constraint on (cyclic) spline coefficients in symmetric bivariate smoothing problems and is especially
designed for constructing objects of the class &quot;symm.smooth&quot;, see <code><a href="#topic+smooth.construct.symm.smooth.spec">smooth.construct.symm.smooth.spec</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_summation_matrix(F, skew = FALSE, cyclic.degree = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_summation_matrix_+3A_f">F</code></td>
<td>
<p>number of marginal basis functions.</p>
</td></tr>
<tr><td><code id="make_summation_matrix_+3A_skew">skew</code></td>
<td>
<p>logical, should the basis be constraint to skew-symmetry instead
of symmetry.</p>
</td></tr>
<tr><td><code id="make_summation_matrix_+3A_cyclic.degree">cyclic.degree</code></td>
<td>
<p>integer, specifying the number of basis functions identified
with each other at the boundaries in order to implement periodicity. Should
be specified to match the degree of the utilized B-spline basis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imposing a symmetry constraint to the spline coefficients in order to obtain a reduced coefficient vector is
equivalent to right multiplication of the bivariate design matrix
with the symmetry constraint matrix obtained with function <code>make_summation_matrix</code>.
The penalty matrix of the bivariate smooth needs to be adjusted to the reduced coefficient vector
by left and right multiplication with the symmetry constraint matrix.
This function is used in the constructor function <code><a href="#topic+smooth.construct.symm.smooth.spec">smooth.construct.symm.smooth.spec</a></code>.
</p>


<h3>Value</h3>

<p>A basis transformation matrix of dimension <code class="reqn">F^2 \times G</code> with
<code class="reqn">G&lt;F^2</code> depending on the specified constraint.
</p>


<h3>Author(s)</h3>

<p>Jona Cederbaum, Almond Stoecker
</p>


<h3>References</h3>

<p>Cederbaum, Scheipl, Greven (2016): Fast symmetric additive covariance smoothing.
Submitted on arXiv.
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> and <code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code> for details on constructors
</p>

<hr>
<h2 id='Predict.matrix.symm.smooth'>Predict matrix method for (skew-)symmetric bivariate smooths.</h2><span id='topic+Predict.matrix.symm.smooth'></span>

<h3>Description</h3>

<p>Predict matrix method for (skew-)symmetric bivariate smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'symm.smooth'
Predict.matrix(object, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Predict.matrix.symm.smooth_+3A_object">object</code></td>
<td>
<p>is a <code>symm.smooth</code> object created by <code><a href="#topic+smooth.construct.symm.smooth.spec">smooth.construct.symm.smooth.spec</a></code>,
see <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="Predict.matrix.symm.smooth_+3A_data">data</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jona Cederbaum, Almond Stoecker
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+Predict.matrix">Predict.matrix</a></code> and <code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code> for details on constructors.
</p>

<hr>
<h2 id='smooth.construct.symm.smooth.spec'>Symmetric bivariate smooths constructor</h2><span id='topic+smooth.construct.symm.smooth.spec'></span>

<h3>Description</h3>

<p>The <code>symm</code> class is a smooth class that is appropriate for symmetric bivariate smooths, e.g. of covariance functions,
using tensor-product smooths in a <code>gam</code> formula. A constraint matrix is constructed
(see <code><a href="#topic+make_summation_matrix">make_summation_matrix</a></code>) to impose
a (skew-)symmetry constraint on the (cyclic) spline coefficients,
which considerably reduces the number of coefficients that have to be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'symm.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.symm.smooth.spec_+3A_object">object</code></td>
<td>
<p>is a smooth specification object or a smooth object.</p>
</td></tr>
<tr><td><code id="smooth.construct.symm.smooth.spec_+3A_data">data</code></td>
<td>
<p>a data frame, model frame or list containing the values
of the (named) covariates at which the smooth term is to be evaluated.</p>
</td></tr>
<tr><td><code id="smooth.construct.symm.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>an optional data frame supplying any knot locations
to be supplied for basis construction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default a symmetric bivariate B-spline smooth <code class="reqn">g</code> is specified,
in the sense that <code class="reqn">g(s, t) = g(t, s)</code>. By setting
<code>s(..., bs = "symm", xt = list(skew = TRUE))</code>, a skew-symmetric (or anti-smmetric)
smooth with <code class="reqn">g(s, t) = -g(t, s)</code> can be specified instead.
In both cases, the smooth can also be constraint to be cyclic
with the property <code class="reqn">g(s, t) = g(s + c, t) = g(s, t + c)</code>
for some fixed constant <code class="reqn">c</code> via specifying <code>xt = list(cyclic = TRUE)</code>.
Note that this does not correspond to specifying a tensor-product smooth from
cyclic marginal B-splines as given by the <code>cp</code>-smooth.
In the cyclic case, it is recommended to explicitly specify the range of the domain
of the smooth via the <code>knots</code> argument, as this determines the period and
often deviates from the observed range.
</p>
<p>The underlying procedure is the following: First, the marginal spline design matrices and the corresponding
marginal difference penalties are built. Second, the tensor product of the marginal design matrices is built
and the bivariate penalty matrix is set up. Third, the constraint matrix is applied
to the tensor product design matrix and to the penalty matrix.
</p>


<h3>Value</h3>

<p>An object of class &quot;symm.smooth&quot;. See <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> for the elements it will contain.
</p>


<h3>Author(s)</h3>

<p>Jona Cederbaum, Almond Stoecker
</p>


<h3>References</h3>

<p>Cederbaum, Scheipl, Greven (2016): Fast symmetric additive covariance smoothing.
Submitted on arXiv.
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> and <code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code> for details on constructors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(sparseFLMM)

# (skew-)symmetric smooths ---------------------------------------

# generate random surface 
dat1 &lt;- data.frame(arg1 = 1:50)
dat2 &lt;- expand.grid(arg1 = 1:50, arg2 = 1:50)

Bskew &lt;- Predict.matrix(
  smooth.construct( 
    s(arg1, arg2, bs = "symm", xt = list(skew = TRUE)),
    data = dat2, knots = NULL ),
  data = dat2 )
Bsymm &lt;- Predict.matrix(
  smooth.construct( 
    s(arg1, arg2, bs = "symm", xt = list(skew = FALSE)),
    data = dat2, knots = NULL ),
  data = dat2 )

set.seed(934811)
dat2$yskew &lt;- c(Bskew %*% rnorm(ncol(Bskew)))
dat2$ysymm &lt;- c(Bsymm %*% rnorm(ncol(Bsymm)))

# fit sum of skew-symmetric and symmetric parts with corresponding smooths
modpa &lt;- gam( I(yskew + ysymm) ~ s(arg1, arg2, bs = "symm", xt = list(skew = TRUE)) + 
                s(arg1, arg2, bs = "symm", xt = list(skew = FALSE)), data = dat2)
# predict surfaces
preds &lt;- predict(modpa, type = "terms")
dat1 &lt;- as.list(dat1)
dat1$arg2 &lt;- dat1$arg1
dat1$predskew &lt;- matrix(preds[,1], nrow = length(dat1$arg1))
dat1$predsymm &lt;- matrix(preds[,2], nrow = length(dat1$arg1))

cols &lt;- hcl.colors(12, "RdBu")
opar &lt;- par(mfcol = c(2,2))
# symm part (intercept missing)
with(dat1, image(arg1, arg2, predsymm, asp = 1,
                 main = "Symmetric part of y",
                 col = cols))
with(dat1, image(arg1, arg2, asp = 1, 
                 main = "Fit via symm.smooth",
                 matrix(dat2$ysymm, nrow = length(arg1)), 
                                    col = cols))
# skew-symm part
with(dat1, image(arg1, arg2, predskew, asp = 1,
                 main = "Skew-symmetric part of y",
                 col = cols))
with(dat1, image(arg1, arg2, asp = 1, 
                 main = "Fit via symm.smooth",
                 matrix(dat2$yskew, nrow = length(arg1)), 
                 col = cols))
par(opar)

stopifnot(all.equal(dat1$predskew, - t(dat1$predskew)))
stopifnot(all.equal(dat1$predsymm, t(dat1$predsymm)))




# cyclic (skew-)symmetric splines ---------------------------------------

# fit the above example with cyclic smooths
modpac &lt;- gam( I(yskew + ysymm) ~ s(arg1, arg2, bs = "symm", 
                                   xt = list(skew = TRUE, cyclic = TRUE)) + 
                s(arg1, arg2, bs = "symm", xt = list(skew = FALSE, cyclic = TRUE)),
              knots = list(arg1 = c(1, 50), arg2 = c(1,50)), 
              # specify arg range to specify 'wavelength'! 
              data = dat2)
plot(modpac, asp = 1, se = FALSE, pages = 1)

predsc &lt;- predict(modpac, type = "terms")
dat1$predskewc &lt;- matrix(predsc[,1], nrow = length(dat1$arg1))
dat1$predsymmc &lt;- matrix(predsc[,2], nrow = length(dat1$arg1))

# check cyclic margins
opar &lt;- par(mfrow = c(1,2))
with(dat1, matplot(arg1, predsymmc[, c(1,10, 40)], t = "l",
                   main = "symmetric smooth"))
abline(h = dat1$predsymmc[1, c(1,10, 40)], col = "darkgrey")
abline(v = c(1,50), col = "darkgrey")

with(dat1, matplot(arg1, predskewc[, c(1,10, 40)], t = "l",
                   main = "skew-symmetric smooth"))
abline(h = dat1$predskewc[1, c(1,10, 40)], col = "darkgrey")
abline(v = c(1,50), col = "darkgrey")
par(opar)



# 1D point symmetric B-splines --------------------------------------------

# generate toy data
dat &lt;- data.frame( x = 1:100 )
ps_obj &lt;- with(dat, s(x, bs = "ps"))
B &lt;- Predict.matrix(smooth.construct(ps_obj, dat, NULL), dat)               
set.seed(3904)
dat$y &lt;- B %*% rnorm(ncol(B))
plot(dat, t = "l")

# fit skew-symmetric spline
mod0 &lt;- gam( y ~ s(x, bs = "symm", xt = list(skew = TRUE)), 
             knots = list(x = c(0,100)), # specify x range to determine inversion point 
             dat = dat )
lines(dat$x, predict(mod0), col = "cornflowerblue", lty = "dashed")

# or a symmetric spline to first part only
mod1 &lt;- gam( y ~ s(x, bs = "symm"), 
             knots = list(x=c(0,50)), 
                          dat = dat[1:50, ])
lines(dat[1:50, ]$x, predict(mod1), col = "darkred", lty = "dashed")
</code></pre>

<hr>
<h2 id='sparseFLMM'>Functional Linear Mixed Models for Irregularly or Sparsely Sampled Data</h2><span id='topic+sparseFLMM'></span>

<h3>Description</h3>

<p>Estimation of functional linear mixed models (FLMMs) for irregularly or sparsely
sampled data based on functional principal component analysis (FPCA).
The implemented models are special cases of the general FLMM
</p>
<p style="text-align: center;"><code class="reqn">Y_i(t_{ij}) = \mu(t_{ij},x_i) + z_i^T U(t_{ij}) + \epsilon_i(t_{ij}), i = 1,...,n, j = 1,...,D_i,</code>
</p>

<p>with <code class="reqn">Y_i(t_{ij})</code> the value of the response of curve <code class="reqn">i</code> at observation point
<code class="reqn">t_{ij}</code>, <code class="reqn">\mu(t_{ij},x_i)</code> is a mean function, which may depend on covariates
<code class="reqn">x_i = (x_{i1},\ldots,x_{ip})^T</code>. <code class="reqn">z_i</code> is a covariate vector,
which is multiplied with the vector of functional random effects <code class="reqn">U(t_{ij})</code>.
<code class="reqn">\epsilon_i(t_{ij})</code> is independent and identically distributed white noise
measurement error with homoscedastic, constant variance. For more details, see references below.<br /> <br />
The current implementation can be used to fit four special cases
of the above general FLMM:
</p>

<ul>
<li><p> a model for independent functional data (e.g. longitudinal data),
for which <code class="reqn">z_i^T U(t_{ij})</code> only consists of
a smooth curve-specific deviation (smooth error curve)
</p>
</li>
<li><p> a model for correlated functional data with one
functional random intercept (fRI) for one grouping variable in addition
to a smooth curve-specific error
</p>
</li>
<li><p> a model for correlated functional data with two crossed
fRIs for two grouping variables in addition to a smooth curve-specific error
</p>
</li>
<li><p> a model for correlated functional data with two nested fRIs for
two grouping variables in addition to a smooth curve-specific error.</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sparseFLMM(
  curve_info,
  use_RI = FALSE,
  use_simple = FALSE,
  method = "fREML",
  use_bam = TRUE,
  bs = "ps",
  d_grid = 100,
  min_grid = 0,
  max_grid = 1,
  my_grid = NULL,
  bf_mean = 8,
  bf_covariates = 8,
  m_mean = c(2, 3),
  covariate = FALSE,
  num_covariates,
  covariate_form,
  interaction,
  which_interaction = matrix(NA),
  save_model_mean = FALSE,
  para_estim_mean = FALSE,
  para_estim_mean_nc = 0,
  bf_covs,
  m_covs,
  use_whole = FALSE,
  use_tri = FALSE,
  use_tri_constr = TRUE,
  use_tri_constr_weights = FALSE,
  np = TRUE,
  mp = TRUE,
  use_discrete_cov = FALSE,
  para_estim_cov = FALSE,
  para_estim_cov_nc = 0,
  var_level = 0.95,
  N_B = NA,
  N_C = NA,
  N_E = NA,
  use_famm = FALSE,
  use_bam_famm = TRUE,
  bs_int_famm = list(bs = "ps", k = 8, m = c(2, 3)),
  bs_y_famm = list(bs = "ps", k = 8, m = c(2, 3)),
  save_model_famm = FALSE,
  use_discrete_famm = FALSE,
  para_estim_famm = FALSE,
  para_estim_famm_nc = 0,
  nested = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseFLMM_+3A_curve_info">curve_info</code></td>
<td>
<p>data table in which each row represents a single observation
point. <code>curve_info</code> needs to contain the following columns:
</p>

<ul>
<li> <p><code>y_vec</code> (numeric): the response values for each observation point
</p>
</li>
<li> <p><code>t</code>  (numeric): the observations point locations, i.e. <code class="reqn">t_{ij}</code>
</p>
</li>
<li> <p><code>n_long</code> (integer): unique identification number for each curve
</p>
</li>
<li> <p><code>subject_long</code> (integer): unique identification number for each
level of the first grouping variable
(e.g. speakers for the phonetics data in the example below).
In the case of independent functions, <code>subject_long</code> should be set equal to <code>n_long</code>.
</p>
</li></ul>

<p>For models with two crossed functional random intercepts, the data table additionally needs to have columns:
</p>

<ul>
<li> <p><code>word_long</code> (integer): unique identification number for each level of
the second grouping variable (e.g. words for the phonetics data in the example below)
</p>
</li>
<li> <p><code>combi_long</code> (integer): number of the repetition of the combination of the
corresponding level of the first and of the second grouping variable.
</p>
</li></ul>

<p>For models with two nested functional random intercepts, the data table
additionally needs to have columns:
#' </p>

<ul>
<li> <p><code>word_long</code> (integer): unique identification number for each level
of the second grouping variable (e.g. phases of a randomized controled
trial). Note that the nested model is only implemented for two levels in the
second grouping variable.
</p>
</li>
<li> <p><code>combi_long</code> (integer): number of the repetition of the combination of the
corresponding level of the first and of the second grouping variable.
</p>
</li></ul>

<p>For models with covariates as part of the mean function <code class="reqn">\mu(t_{ij},x_i)</code>,
the covariate values (numeric) need to be in
separate columns with names: <code>covariate.1</code>, <code>covariate.2</code>, etc.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_use_ri">use_RI</code></td>
<td>
<p>TRUE to specify a model with one functional random intercept
for the first grouping variable (<code>subject_long</code>) and a smooth random error curve.
Defaults to <code>FALSE</code>, which specifies a model with crossed functional random
intercepts for the
first and second grouping variable and a smooth error curve.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_use_simple">use_simple</code></td>
<td>
<p><code>TRUE</code> to specify a model with only a smooth random error function,
<code>use_RI</code> should then also be set to <code>TRUE</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_method">method</code></td>
<td>
<p>estimation method for <code>gam</code> or <code>bam</code>, see <code><a href="mgcv.html#topic+mgcv">mgcv</a></code> for more details.
Defaults to <code>"fREML"</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_use_bam">use_bam</code></td>
<td>
<p><code>TRUE</code> to use function bam instead of function <code>gam</code> (syntax is the same, bam is faster for large data sets).
<code>bam</code> is recommended and set as default.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_bs">bs</code></td>
<td>
<p>spline basis function type for the estimation of the mean function and
the auto-covariance, see <code><a href="mgcv.html#topic+s">s</a></code> and <code><a href="mgcv.html#topic+te">te</a></code> for more details.
Defaults to penalized B-splines, i.e. <code>bs = "ps"</code>. This choice is recommended as others have not been
tested yet.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_d_grid">d_grid</code></td>
<td>
<p>pre-specified grid length for equidistant grid on which the mean, the auto-covariance surfaces, the eigenfunctions
and the functional random effects are evaluated. NOTE: the length of the grid can be important for computation time (approx. quadratic influence).
Defaults to <code>d_grid = 100</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_min_grid">min_grid</code></td>
<td>
<p>minimum value of equidistant grid (should approx. correspond to minimum value of time interval). Defaults to <code>min_grid = 0</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_max_grid">max_grid</code></td>
<td>
<p>maximum value of equidistant grid (should approx. correspond to maximum value of time interval). Defaults to <code>max_grid = 1</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_my_grid">my_grid</code></td>
<td>
<p>optional evaluation grid, which can be specified and used instead of <code>d_grid</code>, <code>min_grid</code>, <code>max_grid</code>.
NOTE: the grid should be equidistant.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_bf_mean">bf_mean</code></td>
<td>
<p>basis dimension (number of basis functions) used for the functional intercept
<code class="reqn">f_0(t_{ij})</code> in the mean estimation via <code>bam/gam</code>. Defaults to <code>bf_mean = 8</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_bf_covariates">bf_covariates</code></td>
<td>
<p>basis dimension (number of basis functions) used for the functional effects
of covariates in the mean estimation via <code>bam/gam</code>. Defaults to <code>bf_covariates = 8</code>.
NOTE: in the current implementation, the same basis dimension for all covariates is used.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_m_mean">m_mean</code></td>
<td>
<p>order of the penalty for this term in <code>bam/gam</code> of mean estimation, for <code>bs = "ps"</code> spline and penalty order,
defaults to <code>m_mean = c(2, 3)</code>, i.e., cubic B-splines with third order difference penalty, see <code><a href="mgcv.html#topic+s">s</a></code> for details.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_covariate">covariate</code></td>
<td>
<p><code>TRUE</code> to estimate covariate effects (as part of the mean function).</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_num_covariates">num_covariates</code></td>
<td>
<p>number of covariates that are included in the model.
NOTE: not number of effects in case interactions of covariates are specified.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_covariate_form">covariate_form</code></td>
<td>
<p>vector with entries for each covariate that specify the form in which the
respective covariate enters the mean function. Possible forms are <code>"by"</code> for varying-coefficient <code class="reqn">(f(t_{ij})*covariate)</code>, which is
possible for dummy coded covariates and metric covariates and
<code>"smooth"</code> for smooth effect in t and in covariate <code class="reqn">(f(t_{ij}, covariate))</code>, which is only
possible for metric covariates! NOTE: metric covariates should be centered such that the global functional intercept <code class="reqn">f_0(t_{ij})</code> can be interpreted as
global mean function and the effect can be interpreted as difference from the global mean.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_interaction">interaction</code></td>
<td>
<p><code>TRUE</code> to estimate interaction effects of covariates, which interactions, see <code>which_interaction</code> (below).
Interactions are possible for dummy-coded covariates that act as varying coefficients.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_which_interaction">which_interaction</code></td>
<td>
<p>symmetric matrix that specifies which interactions should be considered in case <code>covariate = TRUE</code> and <code>interaction = TRUE</code>.
Entry <code>which_interaction</code>[k, l] specifies that the interaction between <code>covariate.k</code> and <code>covariate.l</code> is modeled (example below).
NOTE: entries are redundant, <code>which_interaction</code>[l, k] should be set to the
same as <code>which_interaction</code>[k, l] (symmetric). Defaults to <code>which_interaction = matrix(NA)</code> which should be specified when <code>interaction = FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_save_model_mean">save_model_mean</code></td>
<td>
<p><code>TRUE</code> to give out <code>gam/bam</code> object (attention: can be large!), defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_para_estim_mean">para_estim_mean</code></td>
<td>
<p><code>TRUE</code> to parallelize mean estimation (only possible using <code>bam</code>), defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_para_estim_mean_nc">para_estim_mean_nc</code></td>
<td>
<p>number of cores for parallelization of mean estimation (only possible using <code>bam</code>,
only active if <code>para_estim_mean = TRUE</code>). Defaults to 0.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_bf_covs">bf_covs</code></td>
<td>
<p>vector of marginal basis dimensions (number of basis functions) used for covariance estimation via <code>bam/gam</code>
for each functional random effect (including the smooth error curve).
In the case of multiple grouping variables, the first entry corresponds to the first grouping variable,
the second vector entry corresponds to the second grouping variable, and the third to the smooth error curve.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_m_covs">m_covs</code></td>
<td>
<p>list of marginal orders of the penalty for <code>bam/gam</code> for covariance estimation, for <code>bs = "ps"</code> marginal spline and
penalty order. As only symmetric surfaces are considered: same for both directions. <br />
For crossed fRIs: list of three vectors, e.g. <code>m_covs = list(c(2, 3), c(2, 3), c(2, 3))</code>, where first and second entry correspond to first
and second grouping variable, respectively and third entry corresponds to smooth error.
For one fRI: list of two vectors, e.g. <code>m_covs = list(c(2, 3), c(2, 3))</code>, where first entry corresponds to (first) grouping variable
and second entry corresponds to smooth error.
For independent curves: list of one vector, e.g. <code>m_covs = list(c(2,3))</code> corresponding to smooth error.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_use_whole">use_whole</code></td>
<td>
<p><code>TRUE</code> to estimate the whole auto-covariance surfaces without symmetry constraint.
Defaults to <code>FALSE</code> as is much slower than <code>use_tri_constr</code> and <code>use_tri_constr_weights</code>. For more details, see references below.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_use_tri">use_tri</code></td>
<td>
<p><code>TRUE</code> to estimate only the upper triangle of the auto-covariance surfaces without
symmetry constraint. Defaults to <code>FALSE</code> and not recommended. For more details, see references below.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_use_tri_constr">use_tri_constr</code></td>
<td>
<p><code>TRUE</code> to estimate only the upper triangle of the auto-covariance surfaces with symmetry constraint using the
smooth class <code>'symm'</code>. Defaults to <code>TRUE</code>. For more details, see references below.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_use_tri_constr_weights">use_tri_constr_weights</code></td>
<td>
<p><code>TRUE</code> to estimate only the upper triangle of the auto-covariances with symmetry constraint, using the
smooth class <code>'symm'</code> and weights of 0.5 on the diagonal to use the same weights as for estimating the whole auto-covariance surfaces.
Defaults to <code>FALSE</code>. For more details, see references below.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_np">np</code></td>
<td>
<p><code>TRUE</code> to use 'normal parameterization' for a tensor product smooth, see <code><a href="mgcv.html#topic+te">te</a></code> for more details.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_mp">mp</code></td>
<td>
<p><code>FALSE</code> to use Kronecker product penalty instead of Kronecker sum penalty
with only one smoothing parameter (<code>use_whole = TRUE</code> and <code>use_tri = TRUE</code>), for details see <code><a href="mgcv.html#topic+te">te</a></code>.
For <code>use_tri_constr = TRUE</code> and <code>use_tri_constr_weights = TRUE</code>, only one smoothing parameter is estimated anyway.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_use_discrete_cov">use_discrete_cov</code></td>
<td>
<p><code>TRUE</code> to further speed up the auto-covariance computation by discretization of
covariates for storage and efficiency reasons, includes parallelization controlled by <code>para_estim_cov_nc</code> (below),
see <code><a href="mgcv.html#topic+bam">bam</a></code> for more details. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_para_estim_cov">para_estim_cov</code></td>
<td>
<p><code>TRUE</code> to parallelize auto-covariance estimation (only possible using <code>bam</code>), defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_para_estim_cov_nc">para_estim_cov_nc</code></td>
<td>
<p>number of cores (if <code>use_discrete_cov = FALSE</code>) or number of threads (if <code>use_discrete_cov = TRUE</code>)
for parallelization of auto-covariance estimation (only possible using <code>bam</code>, only active if <code>para_estim_cov = TRUE</code>).
Defaults to 0.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_var_level">var_level</code></td>
<td>
<p>pre-specified level of explained variance used for the choice of the number of the functional principal
components (FPCs). Alternatively, a specific number of FPCs can be specified (see below). Defaults to <code>var_level = 0.95</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_n_b">N_B</code></td>
<td>
<p>number of components for B (fRI for first grouping variable) to keep, overrides <code>var_level</code> if not <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_n_c">N_C</code></td>
<td>
<p>number of components for C (fRI for second grouping variable) to keep, overrides <code>var_level</code> if not <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_n_e">N_E</code></td>
<td>
<p>number of components for E (smooth error) to keep, overrides <code>var_level</code> if not <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_use_famm">use_famm</code></td>
<td>
<p><code>TRUE</code> to embed the model into the framework of functional additive mixed
models (FAMMs) using re-estimation of the mean function together with the prediction of the FPC weights (scores).
This allows for point-wise confidence bands for the covariate effects. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_use_bam_famm">use_bam_famm</code></td>
<td>
<p><code>TRUE</code> to use function <code>bam</code> instead of function <code>gam</code> in FAMM estimation
(reduces computation time for large data sets),
highly recommended. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_bs_int_famm">bs_int_famm</code></td>
<td>
<p>specification of the estimation of the functional intercept <code class="reqn">f_0(t_{ij})</code>
(as part of the mean function), see <code><a href="refund.html#topic+pffr">pffr</a></code> for details.
Defaults to <code>bs_int = list(bs = "ps", k = 8, m = c(2, 3))</code>, where
<code>bs</code>: type of basis functions, <code>k</code>: number of basis functions, <code>m</code>: order of the spline and order of the penalty.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_bs_y_famm">bs_y_famm</code></td>
<td>
<p>specification of the estimation of the covariates effects (as part of the mean function), see <code><a href="refund.html#topic+pffr">pffr</a></code> for details.
Defaults to <code>bs_y_famm = list(bs = "ps", k = 8, m = c(2, 3))</code>, where
<code>bs</code>: type of basis functions, <code>k</code>: number of basis functions, <code>m</code>: order of the spline and order of the penalty.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_save_model_famm">save_model_famm</code></td>
<td>
<p><code>TRUE</code> to give out the FAMM model object (attention: can be very large!).
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_use_discrete_famm">use_discrete_famm</code></td>
<td>
<p><code>TRUE</code> to further speed up the fpc-famm computation by discretization of
# covariates for storage and efficiency reasons, includes parallelization controlled by <code>para_estim_famm_nc</code> (below),
see <code><a href="mgcv.html#topic+bam">bam</a></code> for more details. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_para_estim_famm">para_estim_famm</code></td>
<td>
<p><code>TRUE</code> to parallelize FAMM estimation. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_para_estim_famm_nc">para_estim_famm_nc</code></td>
<td>
<p>number of cores (if <code>use_discrete_famm = FALSE</code>) or number of
threads (if <code>use_discrete_famm = TRUE</code>)
for parallelization of FAMM estimation (only possible using <code>bam</code>, only active if <code>para_estim_famm = TRUE</code>).
Defaults to 0.</p>
</td></tr>
<tr><td><code id="sparseFLMM_+3A_nested">nested</code></td>
<td>
<p><code>TRUE</code> to specify a model with nested functional random
intercepts for the first and second grouping variable and a smooth error
curve. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code can handle irregularly and possibly sparsely sampled
data. Of course, it can also be used to analyze regular grid data,
but as it is especially designed for the irregular case and there may
be a more efficient way to analyze regular grid data. <br /> <br />
The mean function is of the form </p>
<p style="text-align: center;"><code class="reqn">\mu(t_{ij},x_i) = f_0(t_{ij}) +
\sum_{k=1}^r f_k(t_{ij},x_{ik}),</code>
</p>
<p> where <code class="reqn">f_0(t_{ij})</code> is a functional
intercept.
Currently implemented are effects of dummy-coded and metric covariates which act as
varying-coefficients of the
form <code class="reqn">f_k(t_{ij})*x_{ik}</code> and smooth effects of metric covariates (smooth in t and in the covariate)
of the form <code class="reqn">f(t_{ij}, x_{ik})</code>. NOTE: metric covariates should be centered such that the global functional intercept can be interpreted as global mean function and
the effect can be interpreted as difference from the global mean. Interaction effects of dummy-coded
covariates acting as varying coefficients are possible.
<br />
<br />
The estimation consists of four main steps:
</p>

<ol>
<li><p> estimation of the smooth mean function (including covariate effects)
under independence assumption using splines.
</p>
</li>
<li><p> estimation of the smooth auto-covariances of the functional random effects.
A fast bivariate symmetric smoother implemented in the smooth class 'symm' can be used to speed up estimation (see below).
</p>
</li>
<li><p> eigen decomposition of the estimated auto-covariances, which are evaluated on a
pre-specified equidistant grid. This yields estimated eigenvalues and eigenfunctions, which are
rescaled to ensure orthonormality with respect to the L2-scalar product.
</p>
</li>
<li><p> prediction of the functional principal component weights (scores) yielding predictions for
the functional random effects.
</p>
</li></ol>

<p>The estimation of the mean function and auto-covariance functions is based on package <span class="pkg">mgcv</span>.
<br />
The functional principal component weights (scores) are predicted as best (linear)
unbiased predictors. In addition, this implementation allows to embed the model
in the general framework of functional additive mixed models (FAMM) based on package <span class="pkg">refund</span>, which allows for the construction of
point-wise confidence bands for covariate effects (in the mean function) conditional on the FPCA.
Note that the estimation as FAMM may be computationally expensive as the model
is re-estimated in a mixed model framework.
</p>
<p>The four special cases of the general FLMM (two nested fRIs, two
crossed fRIs, one fRI, independent curves) are implemented as follows:
</p>

<ul>
<li><p> In the special case with two nested fRIs, three random processes B, C,
and E are considered, where B is the fRI for the first grouping variable (e.
g. patient in a random controlled trial), C denotes the fRI for the second
grouping variable (e.g. individual specific effect in the follow-up) and E
denotes the smooth error. For this special
case, arguments <code>use_RI</code> and <code>use_simple</code> are both set to
<code>FALSE</code> and argument <code>nested</code> is set to <code>TRUE</code>. Note that
this implementation only allows for a simple before/after study design.
</p>
</li>
<li><p> In the special case with two crossed fRIs,  three
random processes B, C, and E are considered, where B is the
fRI for the first grouping variable (e.g. speakers in the phonetics example below),
C denotes the fRI for the second grouping variable
(e.g. target words in the phonetics example below) and
E denotes the smooth error. For this special case, arguments
<code>use_RI</code> and <code>use_simple</code> are both set to <code>FALSE</code>.
</p>
</li>
<li><p> In the special case with only one fRI, only B and E are considered
and the number of levels for the second grouping variable is to zero.
For this special case, argument <code>use_RI</code> is set to <code>TRUE</code> and argument
<code>use_simple</code> is set to <code>FALSE</code>.
</p>
</li>
<li><p> The special case with independent curves is internally seen as a special case
of the model with one fRI for the first grouping variable, with the number of
levels for this grouping variable corresponding to the number of curves.
Thus, for each level of the first grouping variable there is one curve.
Therefore, for the special case of independent curves, the estimation returns an
estimate for the auto-covariance of B (instead of E) and all corresponding results are indicated with <code>'_B'</code>, although they
correspond to the smooth error. For this special case, arguments
<code>use_RI</code> and <code>use_simple</code> are both set to <code>TRUE</code>.</p>
</li></ul>



<h3>Value</h3>

<p>The function returns a list of two elements: <code>time_all</code> and <code>results</code>. <br />
<code>time_all</code> contains the total system.time() for calling function <code>sparseFLMM()</code>.<br />
<code>results</code> is a list of all estimates, including:
</p>

<ul>
<li> <p><code>mean_hat</code>: includes the components of the estimated mean function.
</p>

<ul>
<li> <p><code>mean_pred</code> contains effects of dummy covariates or metric covariates with a linear effect (varying coefficients).
</p>
</li>
<li> <p><code>mean_pred_smooth</code> contains effects of metric covariates with a smooth effect.
</p>
</li>
<li> <p><code>intercept</code> is the estimated intercept, which is part of <code class="reqn">f_0(t_{ij})</code>.
</p>
</li></ul>
</li></ul>

<p>For each auto-covariance smoothing alternative <code>X</code> (<code>use_whole</code>, <code>use_tri</code>,
<code>use_tri_constr</code>, <code>use_tri_constr_weights</code>):
</p>

<ul>
<li> <p><code>cov_hat_X</code>: includes
</p>

<ul>
<li> <p><code>sigmasq</code>: the estimated error variance
</p>
</li>
<li> <p><code>sigmasq_int</code>: the integral of the estimated error variance over the domain
</p>
</li>
<li> <p><code>grid_mat_B/C/E</code>: the estimated auto-covariance(s) evaluated on the pre-specified grid
</p>
</li>
<li> <p><code>sp</code>: the smoothing parameter(s) for smoothing the auto-covariance(s)
</p>
</li>
<li> <p><code>time_cov_estim</code>: the time for the smoothing the auto-covariance(s) only
</p>
</li>
<li> <p><code>time_cov_pred_grid</code>: the time for evaluating the estimated auto-covariance(s) on the pre-specified grid.
</p>
</li></ul>

</li>
<li> <p><code>time_cov_X</code>: the total system.time() for the auto-covariance estimation
</p>
</li>
<li> <p><code>fpc_hat_X</code>: including
</p>

<ul>
<li> <p><code>phi_B/C/E_hat_grid</code>: the estimated rescaled eigenfunctions evaluated on the pre-specified grid
</p>
</li>
<li> <p><code>nu_B/C/E_hat</code>: the estimated rescaled eigenvalues
</p>
</li>
<li> <p><code>N_B/C/E</code>: the estimated truncation numbers, i.e., number of FPCs which are chosen
</p>
</li>
<li> <p><code>total_var</code>: the estimated total variance
</p>
</li>
<li> <p><code>var_explained</code>: the estimated explained variance
</p>
</li>
<li> <p><code>xi_B/C/E_hat</code>: the predicted FPC weights (scores).
</p>
</li></ul>

</li>
<li> <p><code>time_fpc_X</code>: the total system.time() for the eigen decompositions
and prediction on the FPC weights (scores)
If <code>use_famm = TRUE</code>, the list <code>results</code> additionally contains:
</p>

<ul>
<li> <p><code>fpc_famm_hat_X</code>: including
</p>

<ul>
<li> <p><code>intercept</code>: the estimated intercept, which is part of <code class="reqn">f_0(t_{ij})</code>
</p>
</li>
<li> <p><code>residuals</code>: the residuals of the FAMM estimation
</p>
</li>
<li> <p><code>xi_B/C/E_hat_famm</code>: the predicted basis weights
</p>
</li>
<li> <p><code>famm_predict_B/C/E</code>: the predicted functional processes evaluated on the pre-specified grid
</p>
</li>
<li> <p><code>famm_cb_mean</code>: the re-estimated functional intercept <code class="reqn">f_0(t_{ij})</code>
</p>
</li>
<li> <p><code>famm_cb_covariate.1</code>, <code>famm_cb_covariate.1</code>, etc: possible re-estimated covariate effects
</p>
</li>
<li> <p><code>famm_cb_inter_1_2</code>, <code>famm_cb_inter_1_3</code>, etc: possible interaction effects
</p>
</li>
<li> <p><code>time_fpc_famm_X</code>: the total system.time() for the FAMM estimation.
</p>
</li></ul>

</li></ul>

<p>The unique identification numbers for the levels of the grouping variables and curves are
renumbered for convenience during estimation from 1 in ascending order.
The original identification numbers are returned in the list <code>results</code>:
</p>

<ul>
<li> <p><code>n_orig</code>: curve levels as they entered the estimation
</p>
</li>
<li> <p><code>subject_orig</code>: levels of the first grouping variable as they entered the estimation
</p>
</li>
<li> <p><code>word_orig</code>: levels of the second grouping variable (if existent) as they entered the estimation
</p>
</li>
<li> <p><code>my_grid</code>: pre-specified grid.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Jona Cederbaum
</p>


<h3>References</h3>

<p>Cederbaum, Pouplier, Hoole, Greven (2016): Functional Linear Mixed Models
for Irregularly or Sparsely Sampled Data. Statistical Modelling, 16(1), 67-88.
</p>
<p>Cederbaum, Scheipl, Greven (2016): Fast symmetric additive covariance smoothing.
Submitted on arXiv.
</p>
<p>Scheipl, F., Staicu, A.-M. and Greven, S. (2015):
Functional Additive Mixed Models, Journal of Computational and Graphical Statistics, 24(2), 477-501.
</p>


<h3>See Also</h3>

<p>Note that <code><a href="#topic+sparseFLMM">sparseFLMM</a></code> calls <code><a href="mgcv.html#topic+bam">bam</a></code> or <code><a href="mgcv.html#topic+gam">gam</a></code> directly.
</p>
<p>For functional linear mixed models with complex correlation structures
for data sampled on equal grids based on functional principal component analysis,
see function <code>denseFLMM</code> in package <code>denseFLMM</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# subset of acoustic data (very small subset, no meaningful results can be expected and
# FAMM estimation does not work for this subset example. For FAMM estimation, see below.)
data("acoustic_subset")

acoustic_results &lt;- sparseFLMM(curve_info = acoustic_subset, use_RI = FALSE, use_simple = FALSE,
              method = "fREML", use_bam = TRUE, bs = "ps", d_grid = 100, min_grid = 0,
              max_grid = 1, my_grid = NULL, bf_mean = 8, bf_covariates = 8, m_mean = c(2,3),
              covariate = TRUE, num_covariates = 4, covariate_form = rep("by", 4),
              interaction = TRUE,
              which_interaction = matrix(c(FALSE, TRUE, TRUE, TRUE, TRUE,
              FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE,
              FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE),
              byrow = TRUE, nrow = 4, ncol = 4),
              save_model_mean = FALSE, para_estim_mean = FALSE, para_estim_mean_nc = 0,
              bf_covs = c(5, 5, 5), m_covs = list(c(2, 3), c(2, 3), c(2, 3)),
              use_whole = FALSE, use_tri = FALSE, use_tri_constr = TRUE,
              use_tri_constr_weights = FALSE, np = TRUE, mp = TRUE,
              use_discrete_cov = FALSE,
              para_estim_cov = FALSE, para_estim_cov_nc = 5,
              var_level = 0.95, N_B = NA, N_C = NA, N_E = NA,
              use_famm = FALSE, use_bam_famm = TRUE,
              bs_int_famm = list(bs = "ps", k = 8, m = c(2, 3)),
              bs_y_famm = list(bs = "ps", k = 8, m = c(2, 3)),
              save_model_famm = FALSE, use_discrete_famm = FALSE,
              para_estim_famm = FALSE, para_estim_famm_nc = 0)
## End(Not run)

## Not run: 
# whole data set with estimation in the FAMM framework

data("acoustic")
acoustic_results &lt;- sparseFLMM(curve_info = acoustic, use_RI = FALSE, use_simple = FALSE,
              method = "fREML", use_bam = TRUE, bs = "ps", d_grid = 100, min_grid = 0,
              max_grid = 1, my_grid = NULL, bf_mean = 8, bf_covariates = 8, m_mean = c(2,3),
              covariate = TRUE, num_covariates = 4, covariate_form = rep("by", 4),
              interaction = TRUE,
              which_interaction = matrix(c(FALSE, TRUE, TRUE, TRUE, TRUE,
              FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE,
              FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE),
              byrow = TRUE, nrow = 4, ncol = 4),
              save_model_mean = FALSE, para_estim_mean = FALSE, para_estim_mean_nc = 0,
              bf_covs = c(5, 5, 5), m_covs = list(c(2, 3), c(2, 3), c(2, 3)),
              use_whole = FALSE, use_tri = FALSE, use_tri_constr = TRUE,
              use_tri_constr_weights = FALSE, np = TRUE, mp = TRUE,
              use_discrete_cov = FALSE,
              para_estim_cov = TRUE, para_estim_cov_nc = 5,
              var_level = 0.95, N_B = NA, N_C = NA, N_E = NA,
              use_famm = TRUE, use_bam_famm = TRUE,
              bs_int_famm = list(bs = "ps", k = 8, m = c(2, 3)),
              bs_y_famm = list(bs = "ps", k = 8, m = c(2, 3)),
              save_model_famm = FALSE, use_discrete_famm = FALSE,
              para_estim_famm = TRUE, para_estim_famm_nc = 5)
## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
