<!DOCTYPE html><html lang="en"><head><title>Help for package twosigma</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {twosigma}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adhoc.twosigma'><p>adhoc.twosigma: Perform the ad hoc method described in TWO-SIGMA paper</p></a></li>
<li><a href='#lr.twosigma'><p>Convenient wrapper function for performing joint likelihood ratio tests using the TWO-SIGMA model.</p></a></li>
<li><a href='#lr.twosigma_custom'><p>Convenient wrapper function for performing joint likelihood ratio tests with the TWO-SIGMA model using custom user-specified formulas.</p></a></li>
<li><a href='#simulate_zero_inflated_nb_random_effect_data'><p>Simulated zero-inflated negative binomial data with random effects</p></a></li>
<li><a href='#test.vc.twosigma'><p>Convenient wrapper function for performing (joint) likelihood ratio tests of variance components using the TWO-SIGMA model.</p></a></li>
<li><a href='#twosigma'><p>Fit the TWO-SIGMA Model.</p></a></li>
<li><a href='#twosigma_custom'><p>Fit the TWO-SIGMA model with custom user-specified model formulas.</p></a></li>
<li><a href='#twosigmag'><p>Gene set testing for single-cell RNA-sequencing data adjusting for inter-gene correlation.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>DE Analysis for Single-Cell RNA-Sequencing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-12-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Van Buren &lt;edvanburen@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the TWO-Component Single Cell Model-Based Association Method (TWO-SIGMA) for gene-level differential expression (DE) analysis and DE-based gene set testing of single-cell RNA-sequencing datasets. See Van Buren et al. (2020) &lt;<a href="https://doi.org/10.1002%2Fgepi.22361">doi:10.1002/gepi.22361</a>&gt; and Van Buren et al. (2021) &lt;<a href="https://doi.org/10.1101%2F2021.01.24.427979">doi:10.1101/2021.01.24.427979</a>&gt;.   </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>multcomp (&ge; 1.4-13), glmmTMB, methods, pscl (&ge; 1.5.5),
pbapply (&ge; 1.4.0), parallel (&ge; 3.6.3), doParallel (&ge; 1.0.15)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/edvanburen/twosigma">https://github.com/edvanburen/twosigma</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/edvanburen/twosigma/issues">https://github.com/edvanburen/twosigma/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-10 21:30:03 UTC; edvanburen</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric Van Buren [aut, cre],
  Yun Li [aut],
  Di Wu [aut],
  Ming Hu [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-13 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adhoc.twosigma'>adhoc.twosigma: Perform the ad hoc method described in TWO-SIGMA paper</h2><span id='topic+adhoc.twosigma'></span>

<h3>Description</h3>

<p>adhoc.twosigma: Perform the ad hoc method described in TWO-SIGMA paper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adhoc.twosigma(
  count,
  mean_covar,
  zi_covar,
  id,
  weights = rep(1, length(count))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adhoc.twosigma_+3A_count">count</code></td>
<td>
<p>Vector of non-negative integer read counts.</p>
</td></tr>
<tr><td><code id="adhoc.twosigma_+3A_mean_covar">mean_covar</code></td>
<td>
<p>Covariates for the (conditional) mean model. Must be a matrix (without an intercept column) or = 1 to indicate an intercept only model.</p>
</td></tr>
<tr><td><code id="adhoc.twosigma_+3A_zi_covar">zi_covar</code></td>
<td>
<p>Covariates for the zero-inflation model. Must be a matrix (without an intercept column), = 1 to indicate an intercept only model, or = 0 to indicate no zero-inflation model desired.</p>
</td></tr>
<tr><td><code id="adhoc.twosigma_+3A_id">id</code></td>
<td>
<p>Vector of individual-level ID's. Used as predictor in ANOVA model.</p>
</td></tr>
<tr><td><code id="adhoc.twosigma_+3A_weights">weights</code></td>
<td>
<p>weights, as in glm. Defaults to 1 for all observations and no scaling or centering of weights is performed. Passed into zeroinfl function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>P-value from the ANOVA F test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set Parameters to Simulate Some Data

nind&lt;-10;ncellsper&lt;-rep(50,nind)
sigma.a&lt;-.5;sigma.b&lt;-.5;phi&lt;-.1
alpha&lt;-c(1,0,-.5,-2);beta&lt;-c(2,0,-.1,.6)
beta2&lt;-c(2,1,-.1,.6)
id.levels&lt;-1:nind;nind&lt;-length(id.levels)
id&lt;-rep(id.levels,times=ncellsper)
sim.seed&lt;-1234

# Simulate individual level covariates

t2d_sim&lt;-rep(rbinom(nind,1,p=.4),times=ncellsper)
cdr_sim&lt;-rbeta(sum(ncellsper),3,6)
age_sim&lt;-rep(sample(c(20:60),size=nind,replace = TRUE),times=ncellsper)

# Construct design matrices

Z&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(Z)&lt;-c("t2d_sim","age_sim","cdr_sim")
X&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(X)&lt;-c("t2d_sim","age_sim","cdr_sim")

# Simulate Data

sim_dat&lt;-matrix(nrow=2,ncol=sum(ncellsper))
for(i in 1:nrow(sim_dat)){
   sim_dat[i,]&lt;-simulate_zero_inflated_nb_random_effect_data(ncellsper,X,Z,alpha,beta2
   ,phi,sigma.a,sigma.b,id.levels=NULL)$Y
}
rownames(sim_dat)&lt;-paste("Gene",1:2)

# Run adhoc.twosigma

adhoc.twosigma(sim_dat[1,],mean_covar = X,zi_covar=Z,id = id)
</code></pre>

<hr>
<h2 id='lr.twosigma'>Convenient wrapper function for performing joint likelihood ratio tests using the TWO-SIGMA model.</h2><span id='topic+lr.twosigma'></span>

<h3>Description</h3>

<p>Convenient wrapper function for performing joint likelihood ratio tests using the TWO-SIGMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lr.twosigma(
  count_matrix,
  mean_covar,
  zi_covar,
  covar_to_test,
  mean_re = FALSE,
  zi_re = FALSE,
  id,
  return_full_fits = TRUE,
  adhoc = FALSE,
  adhoc_thresh = 0.1,
  silent = FALSE,
  disp_covar = NULL,
  weights = rep(1, ncol(count_matrix)),
  control = glmmTMBControl(),
  ncores = 1,
  cluster_type = "Fork",
  chunk_size = 10,
  lb = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lr.twosigma_+3A_count_matrix">count_matrix</code></td>
<td>
<p>Matrix of non-negative integer read counts, with rows corresponding to genes and columns corresponding to cells. It is recommended to make the rownames the gene names for better output.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_mean_covar">mean_covar</code></td>
<td>
<p>Covariates for the (conditional) mean model. Must be a matrix (without an intercept column) or a vector if a single covariate is being tested.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_zi_covar">zi_covar</code></td>
<td>
<p>Covariates for the zero-inflation model. Must be a matrix (without an intercept column) or a vector if a single covariate is being tested.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_covar_to_test">covar_to_test</code></td>
<td>
<p>Either a string indicating the column name of the covariate to test or an integer referring to its column position in BOTH the mean_covar and zi_covar matrices (if the two matrices differ using a string name is preferred). Argument is ignored if mean_covar and zi_covar are both a single covariate (that covariate is assumed of interest).</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_mean_re">mean_re</code></td>
<td>
<p>Should random intercepts be included in the (conditional) mean model?</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_zi_re">zi_re</code></td>
<td>
<p>Should random intercepts be included in the zero-inflation model?</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_id">id</code></td>
<td>
<p>Vector of individual-level ID's. Used for random effect prediction and the adhoc method but required regardless.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_return_full_fits">return_full_fits</code></td>
<td>
<p>If TRUE, fit objects of class glmmTMB are returned. If FALSE, only objects of class summary.glmmTMB are returned. The latter require a much larger amount of memory to store.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_adhoc">adhoc</code></td>
<td>
<p>Should the adhoc method be used by default to judge if random effects are needed?</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_adhoc_thresh">adhoc_thresh</code></td>
<td>
<p>Value below which the adhoc p-value is deemed significant (and thus RE are deemed necessary). Only used if adhoc==TRUE.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_silent">silent</code></td>
<td>
<p>If TRUE, progress is not printed.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_disp_covar">disp_covar</code></td>
<td>
<p>Covariates for a log-linear model for the dispersion. Either a matrix or = 1 to indicate an intercept only model.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_weights">weights</code></td>
<td>
<p>weights, as in glm. Defaults to 1 for all observations and no scaling or centering of weights is performed.  See <code>?glmmTMBControl</code>.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_control">control</code></td>
<td>
<p>Control parameters for optimization in glmmTMB.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for parallelization. Defaults to 1, meaning no parallelization of any kind is done.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_cluster_type">cluster_type</code></td>
<td>
<p>Whether to use a &quot;cluster of type &quot;Fork&quot; or &quot;Sock&quot;. On Unix systems, &quot;Fork&quot; will likely improve performance. On Windows, only &quot;Sock&quot; will actually result in parallelized computing.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_chunk_size">chunk_size</code></td>
<td>
<p>Number of genes to be sent to each parallel environment. Parallelization is more efficient, particularly with a large count matrix, when the count matrix is 'chunked' into some common size (e.g. 10, 50, 200). Defaults to 10.</p>
</td></tr>
<tr><td><code id="lr.twosigma_+3A_lb">lb</code></td>
<td>
<p>Should load balancing be used for parallelization? Users will likely want to set to FALSE for improved performance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p><code>fit_null: </code> Model fits under the null hypothesis. If <code>return_summary_fits=TRUE</code>, returns a list of objects of class <code>summary.glmmTMB</code>. If <code>return_summary_fits=FALSE</code>, returns a list of model fit objects of class <code>glmmTMB</code>. In either case, the order matches the row order of <code>count_matrix</code>, and the names of the list elements are taken as the rownames of <code>count_matrix</code>.
</p>
</li>
<li><p><code>fit_alt: </code> Model fits under the alt hypothesis of the same format as <code>fit_null</code>.
</p>
</li>
<li><p><code>LR_stat: </code> Vector of Likelihood Ratio statistics. A value of 'NA' implies a convergence issue or other model fit problem.
</p>
</li>
<li><p><code>LR_p.val: </code> Vector of Likelihood Ratio p-values. A value of 'NA' implies a convergence issue or other model fit problem.
</p>
</li>
<li><p><code>adhoc_include_RE: </code> Logical vector indicator whether the adhoc method determined random effects needed.  If <code>adhoc=F</code>, then a vector of NA's.
</p>
</li></ul>



<h3>Details</h3>

<p>This function assumes that the variable being tested is in both components of the model (and thus that the zero-inflation component exists and contains more than an Intercept). Users wishing to do fixed effect testing in other cases or specify custom model formulas they will need to construct the statistics themselves using either two separate calls to <code>twosigma</code> or the <code>lr.twosigma_custom</code> function. If <code>adhoc=TRUE</code>, any input in mean_re and zi_re will be ignored. If either model fails to converge, or the LR statistic is negative, both the statistic and p-value are assigned as NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set Parameters to Simulate Some Data

nind&lt;-10;ncellsper&lt;-rep(50,nind)
sigma.a&lt;-.5;sigma.b&lt;-.5;phi&lt;-.1
alpha&lt;-c(1,0,-.5,-2);beta&lt;-c(2,0,-.1,.6)
beta2&lt;-c(2,1,-.1,.6)
id.levels&lt;-1:nind;nind&lt;-length(id.levels)
id&lt;-rep(id.levels,times=ncellsper)
sim.seed&lt;-1234

# Simulate individual level covariates

t2d_sim&lt;-rep(rbinom(nind,1,p=.4),times=ncellsper)
cdr_sim&lt;-rbeta(sum(ncellsper),3,6)
age_sim&lt;-rep(sample(c(20:60),size=nind,replace = TRUE),times=ncellsper)

# Construct design matrices

Z&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(Z)&lt;-c("t2d_sim","age_sim","cdr_sim")
X&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(X)&lt;-c("t2d_sim","age_sim","cdr_sim")

# Simulate Data

sim_dat&lt;-matrix(nrow=2,ncol=sum(ncellsper))
for(i in 1:nrow(sim_dat)){
   sim_dat[i,]&lt;-simulate_zero_inflated_nb_random_effect_data(ncellsper,X,Z,alpha,beta2
   ,phi,sigma.a,sigma.b,id.levels=NULL)$Y
}
rownames(sim_dat)&lt;-paste("Gene",1:2)

# Run lr.twosigma

lr.twosigma(count=sim_dat[1,,drop=FALSE],mean_covar = X,zi_covar = Z,id=id,covar_to_test = 1)
</code></pre>

<hr>
<h2 id='lr.twosigma_custom'>Convenient wrapper function for performing joint likelihood ratio tests with the TWO-SIGMA model using custom user-specified formulas.</h2><span id='topic+lr.twosigma_custom'></span>

<h3>Description</h3>

<p>Convenient wrapper function for performing joint likelihood ratio tests with the TWO-SIGMA model using custom user-specified formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lr.twosigma_custom(
  count_matrix,
  mean_form_alt,
  zi_form_alt,
  mean_form_null,
  zi_form_null,
  id,
  lr.df,
  return_full_fits = TRUE,
  disp_covar = NULL,
  weights = rep(1, ncol(count_matrix)),
  control = glmmTMBControl(),
  ncores = 1,
  cluster_type = "Fork",
  chunk_size = 10,
  lb = FALSE,
  internal_call = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lr.twosigma_custom_+3A_count_matrix">count_matrix</code></td>
<td>
<p>Matrix of non-negative integer read counts, with rows corresponding to genes and columns corresponding to cells. It is recommended to make the rownames the gene names for better output.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_mean_form_alt">mean_form_alt</code></td>
<td>
<p>Custom two-sided model formula for the (conditional) mean model under the null. Formula is passed directly into glmmTMB with random effects specified as in the lme4 package. Users should ensure that the dependent variable matches the argument to the parameter &quot;count.&quot;</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_zi_form_alt">zi_form_alt</code></td>
<td>
<p>Custom one-sided model formula for the zero-inflation model under the alternative. Formula is passed directly into glmmTMB with random effects specified as in lme4.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_mean_form_null">mean_form_null</code></td>
<td>
<p>Custom two-sided model formula for the (conditional) mean model under the null. Syntax is as in <code>mean_form_alt</code>.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_zi_form_null">zi_form_null</code></td>
<td>
<p>Custom one-sided model formula for the zero-inflation model under the null. Syntax is as in <code>zi_form_alt</code>.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_id">id</code></td>
<td>
<p>Vector of individual-level (sample-level) ID's. Used for random effect prediction but required regardless of their presence in the model.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_lr.df">lr.df</code></td>
<td>
<p>Degrees of Freedom for the constructed likelihood ratio test. Must be a non-negative integer.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_return_full_fits">return_full_fits</code></td>
<td>
<p>If TRUE, full fit objects of class glmmTMB are returned.  If FALSE, only fit objects of class summary.glmmTMB are returned.  The latter requires far less memory to store.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_disp_covar">disp_covar</code></td>
<td>
<p>Covariates for a log-linear model for the dispersion. Either a matrix or = 1 to indicate an intercept only model.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_weights">weights</code></td>
<td>
<p>weights, as in glm. Defaults to 1 for all observations and no scaling or centering of weights is performed.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_control">control</code></td>
<td>
<p>Control parameters for optimization in glmmTMB.  See <code>?glmmTMBControl</code>.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for parallelization. Defaults to 1, meaning no parallelization of any kind is done.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_cluster_type">cluster_type</code></td>
<td>
<p>Whether to use a &quot;cluster of type &quot;Fork&quot; or &quot;Sock&quot;. On Unix systems, &quot;Fork&quot; will likely improve performance. On Windows, only &quot;Sock&quot; will actually result in parallelized computing.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_chunk_size">chunk_size</code></td>
<td>
<p>Number of genes to be sent to each parallel environment. Parallelization is more efficient, particularly with a large count matrix, when the count matrix is 'chunked' into some common size (e.g. 10, 50, 200). Defaults to 10.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_lb">lb</code></td>
<td>
<p>Should load balancing be used for parallelization? Users will likely want to set to FALSE for improved performance.</p>
</td></tr>
<tr><td><code id="lr.twosigma_custom_+3A_internal_call">internal_call</code></td>
<td>
<p>Not needed by users called <code>lr.twosigma_custom</code> directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p><code>fit_null: </code> Model fits under the null hypothesis. If <code>return_summary_fits=TRUE</code>, returns a list of objects of class <code>summary.glmmTMB</code>. If <code>return_summary_fits=FALSE</code>, returns a list of model fit objects of class <code>glmmTMB</code>. In either case, the order matches the row order of <code>count_matrix</code>, and the names of the list elements are taken as the rownames of <code>count_matrix</code>.
</p>
</li>
<li><p><code>fit_alt: </code> Model fits under the alt hypothesis of the same format as <code>fit_null</code>.
</p>
</li>
<li><p><code>LR_stat: </code> Vector of Likelihood Ratio statistics. A value of 'NA' implies a convergence issue or other model fit problem.
</p>
</li>
<li><p><code>LR_p.val: </code> Vector of Likelihood Ratio p-values. A value of 'NA' implies a convergence issue or other model fit problem.
</p>
</li></ul>



<h3>Details</h3>

<p>This function is a wrapper for conducting fixed effect likelihood ratio tests with twosigma.  There is no checking to make sure that the alt and null model formulas represent a valid likelihood ratio test when fit together.  Users must ensure that inputted formulas represent valid nested models. If either model fails to converge, or the LR statistic is negative, both the statistic and p-value are assigned as NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set Parameters to Simulate Some Data

nind&lt;-10;ncellsper&lt;-rep(50,nind)
sigma.a&lt;-.5;sigma.b&lt;-.5;phi&lt;-.1
alpha&lt;-c(1,0,-.5,-2);beta&lt;-c(2,0,-.1,.6)
beta2&lt;-c(2,1,-.1,.6)
id.levels&lt;-1:nind;nind&lt;-length(id.levels)
id&lt;-rep(id.levels,times=ncellsper)
sim.seed&lt;-1234

# Simulate individual level covariates

t2d_sim&lt;-rep(rbinom(nind,1,p=.4),times=ncellsper)
cdr_sim&lt;-rbeta(sum(ncellsper),3,6)
age_sim&lt;-rep(sample(c(20:60),size=nind,replace = TRUE),times=ncellsper)

# Construct design matrices

Z&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(Z)&lt;-c("t2d_sim","age_sim","cdr_sim")
X&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(X)&lt;-c("t2d_sim","age_sim","cdr_sim")

# Simulate Data

sim_dat&lt;-matrix(nrow=2,ncol=sum(ncellsper))
for(i in 1:nrow(sim_dat)){
   sim_dat[i,]&lt;-simulate_zero_inflated_nb_random_effect_data(ncellsper,X,Z,alpha,beta2
   ,phi,sigma.a,sigma.b,id.levels=NULL)$Y
}
rownames(sim_dat)&lt;-paste("Gene",1:2)

# Run lr.twosigma_custom

lr.twosigma_custom(count=sim_dat[1,,drop=FALSE]
,mean_form_alt = count~X,mean_form_null = count~X[,-1]
,zi_form_alt = ~0,zi_form_null = ~0,id=id,lr.df=1)
</code></pre>

<hr>
<h2 id='simulate_zero_inflated_nb_random_effect_data'>Simulated zero-inflated negative binomial data with random effects</h2><span id='topic+simulate_zero_inflated_nb_random_effect_data'></span>

<h3>Description</h3>

<p>Simulated zero-inflated negative binomial data with random effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_zero_inflated_nb_random_effect_data(
  ncellsper,
  X,
  Z,
  alpha,
  beta,
  phi,
  sigma.a,
  sigma.b,
  id.levels = NULL,
  sim.seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_zero_inflated_nb_random_effect_data_+3A_ncellsper">ncellsper</code></td>
<td>
<p>Vector giving the number of cells per individual.  Length of the vector is taken as the number of individuals.</p>
</td></tr>
<tr><td><code id="simulate_zero_inflated_nb_random_effect_data_+3A_x">X</code></td>
<td>
<p>Covariate matrix (without intercept) for the (conditional) mean model.</p>
</td></tr>
<tr><td><code id="simulate_zero_inflated_nb_random_effect_data_+3A_z">Z</code></td>
<td>
<p>Covariate matrix (without intercept) for the zero-inflation model.</p>
</td></tr>
<tr><td><code id="simulate_zero_inflated_nb_random_effect_data_+3A_alpha">alpha</code></td>
<td>
<p>Column vector of true parameters from the zero-inflation model. Number of rows must match number of columns in Z.</p>
</td></tr>
<tr><td><code id="simulate_zero_inflated_nb_random_effect_data_+3A_beta">beta</code></td>
<td>
<p>Column vector of true parameters from the (conditional) mean model. Number of rows must match number of columns in X.</p>
</td></tr>
<tr><td><code id="simulate_zero_inflated_nb_random_effect_data_+3A_phi">phi</code></td>
<td>
<p>Overdispersion parameter for the negative binomial distribution (see details for more about parameterization).</p>
</td></tr>
<tr><td><code id="simulate_zero_inflated_nb_random_effect_data_+3A_sigma.a">sigma.a</code></td>
<td>
<p>Standard deviation for the zero-inflation model random intercept.</p>
</td></tr>
<tr><td><code id="simulate_zero_inflated_nb_random_effect_data_+3A_sigma.b">sigma.b</code></td>
<td>
<p>Standard deviation for the (conditional) mean random intercept.</p>
</td></tr>
<tr><td><code id="simulate_zero_inflated_nb_random_effect_data_+3A_id.levels">id.levels</code></td>
<td>
<p>Individual-level IDs. If NULL set as 1,2,... up to the number of individuals.</p>
</td></tr>
<tr><td><code id="simulate_zero_inflated_nb_random_effect_data_+3A_sim.seed">sim.seed</code></td>
<td>
<p>Random seed to be used. If NULL one will be randomly chosen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Y Simulated counts
</p>
<p>X Covariate matrix (without intercept) for the (conditional) mean model.
</p>
<p>Z Covariate matrix (without intercept) for the zero-inflation model.
</p>
<p>a Random effects for the zero-inflation model.
</p>
<p>b Random effects for the (conditional) mean model.
</p>
<p>alpha Column vector of true parameters from the zero-inflation model. Number of rows must match number of columns in Z.
</p>
<p>beta Column vector of true parameters from the (conditional) mean model. Number of rows must match number of columns in X.
</p>
<p>phi Overdispersion parameter for the negative binomial distribution (see details for more about parameterization).
</p>
<p>sigma.a Standard deviation for the zero-inflation model random intercept.
</p>
<p>sigma.b Standard deviation for the (conditional) mean random intercept.
</p>
<p>nind Number of individuals.
</p>
<p>ncellsper Vector giving the number of cells per individual.
</p>
<p>id.levels Individual-level IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set Parameters to Simulate Some Data

nind&lt;-10;ncellsper&lt;-rep(50,nind)
sigma.a&lt;-.5;sigma.b&lt;-.5;phi&lt;-.1
alpha&lt;-c(1,0,-.5,-2);beta&lt;-c(2,0,-.1,.6)
beta2&lt;-c(2,1,-.1,.6)
id.levels&lt;-1:nind;nind&lt;-length(id.levels)
id&lt;-rep(id.levels,times=ncellsper)
sim.seed&lt;-1234

# Simulate individual level covariates

t2d_sim&lt;-rep(rbinom(nind,1,p=.4),times=ncellsper)
cdr_sim&lt;-rbeta(sum(ncellsper),3,6)
age_sim&lt;-rep(sample(c(20:60),size=nind,replace = TRUE),times=ncellsper)

# Construct design matrices

Z&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(Z)&lt;-c("t2d_sim","age_sim","cdr_sim")
X&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(X)&lt;-c("t2d_sim","age_sim","cdr_sim")

# Simulate Data

sim_dat&lt;-matrix(nrow=2,ncol=sum(ncellsper))
for(i in 1:nrow(sim_dat)){
   sim_dat[i,]&lt;-simulate_zero_inflated_nb_random_effect_data(ncellsper,X,Z,alpha,beta2
   ,phi,sigma.a,sigma.b,id.levels=NULL)$Y
}
rownames(sim_dat)&lt;-paste("Gene",1:2)
</code></pre>

<hr>
<h2 id='test.vc.twosigma'>Convenient wrapper function for performing (joint) likelihood ratio tests of variance components using the TWO-SIGMA model.</h2><span id='topic+test.vc.twosigma'></span>

<h3>Description</h3>

<p>Convenient wrapper function for performing (joint) likelihood ratio tests of variance components using the TWO-SIGMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.vc.twosigma(
  count_matrix,
  mean_covar,
  zi_covar,
  mean_re = TRUE,
  zi_re = TRUE,
  id,
  return_full_fits = TRUE,
  adhoc = FALSE,
  adhoc_thresh = 0.1,
  silent = FALSE,
  disp_covar = NULL,
  weights = rep(1, ncol(count_matrix)),
  control = glmmTMBControl(),
  ncores = 1,
  cluster_type = "Fork",
  chunk_size = 1,
  lb = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.vc.twosigma_+3A_count_matrix">count_matrix</code></td>
<td>
<p>Matrix of non-negative integer read counts, with rows corresponding to genes and columns corresponding to cells. It is recommended to make the rownames the gene names for better output.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_mean_covar">mean_covar</code></td>
<td>
<p>Covariates for the (conditional) mean model. Must be a matrix (without an intercept column) or a vector if a single covariate is being tested.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_zi_covar">zi_covar</code></td>
<td>
<p>Covariates for the zero-inflation model. Must be a matrix (without an intercept column) or a vector if a single covariate is being tested.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_mean_re">mean_re</code></td>
<td>
<p>Should random intercepts be tested in the (conditional) mean model?</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_zi_re">zi_re</code></td>
<td>
<p>Should random intercepts be tested in the zero-inflation model?</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_id">id</code></td>
<td>
<p>Vector of individual-level ID's. Used for random effect prediction and the adhoc method but required regardless.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_return_full_fits">return_full_fits</code></td>
<td>
<p>If TRUE, fit objects of class glmmTMB are returned. If FALSE, only objects of class summary.glmmTMB are returned. The latter require a much larger amount of memory to store.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_adhoc">adhoc</code></td>
<td>
<p>Should the adhoc method be used by default to judge if random effects are needed?</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_adhoc_thresh">adhoc_thresh</code></td>
<td>
<p>Value below which the adhoc p-value is deemed significant (and thus RE are deemed necessary). Only used if adhoc==TRUE.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_silent">silent</code></td>
<td>
<p>If TRUE, progress is not printed.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_disp_covar">disp_covar</code></td>
<td>
<p>Covariates for a log-linear model for the dispersion. Either a matrix or = 1 to indicate an intercept only model.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_weights">weights</code></td>
<td>
<p>weights, as in glm. Defaults to 1 for all observations and no scaling or centering of weights is performed.  See <code>?glmmTMBControl</code>.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_control">control</code></td>
<td>
<p>Control parameters for optimization in glmmTMB.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for parallelization. Defaults to 1, meaning no parallelization of any kind is done.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_cluster_type">cluster_type</code></td>
<td>
<p>Whether to use a &quot;cluster of type &quot;Fork&quot; or &quot;Sock&quot;. On Unix systems, &quot;Fork&quot; will likely improve performance. On Windows, only &quot;Sock&quot; will actually result in parallelized computing.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_chunk_size">chunk_size</code></td>
<td>
<p>Number of genes to be sent to each parallel environment. Parallelization is more efficient, particularly with a large count matrix, when the count matrix is 'chunked' into some common size (e.g. 10, 50, 200). Defaults to 10.</p>
</td></tr>
<tr><td><code id="test.vc.twosigma_+3A_lb">lb</code></td>
<td>
<p>Should load balancing be used for parallelization? Users will likely want to set to FALSE for improved performance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p><code>fit_null: </code> Model fits under the null hypothesis. If <code>return_summary_fits=TRUE</code>, returns a list of objects of class <code>summary.glmmTMB</code>. If <code>return_summary_fits=FALSE</code>, returns a list of model fit objects of class <code>glmmTMB</code>. In either case, the order matches the row order of <code>count_matrix</code>, and the names of the list elements are taken as the rownames of <code>count_matrix</code>.
</p>
</li>
<li><p><code>fit_alt: </code> Model fits under the alt hypothesis of the same format as <code>fit_null</code>.
</p>
</li>
<li><p><code>LR_stat: </code> Vector of Likelihood Ratio statistics. A value of 'NA' implies a convergence issue or other model fit problem.
</p>
</li>
<li><p><code>LR_p.val: </code> Vector of Likelihood Ratio p-values. A value of 'NA' implies a convergence issue or other model fit problem.
</p>
</li></ul>



<h3>Details</h3>

<p>If either model fails to converge, or the LR statistic is negative, both the statistic and p-value are assigned as NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set Parameters to Simulate Some Data

nind&lt;-10;ncellsper&lt;-rep(50,nind)
sigma.a&lt;-.5;sigma.b&lt;-.5;phi&lt;-.1
alpha&lt;-c(1,0,-.5,-2);beta&lt;-c(2,0,-.1,.6)
beta2&lt;-c(2,1,-.1,.6)
id.levels&lt;-1:nind;nind&lt;-length(id.levels)
id&lt;-rep(id.levels,times=ncellsper)
sim.seed&lt;-1234

# Simulate individual level covariates

t2d_sim&lt;-rep(rbinom(nind,1,p=.4),times=ncellsper)
cdr_sim&lt;-rbeta(sum(ncellsper),3,6)
age_sim&lt;-rep(sample(c(20:60),size=nind,replace = TRUE),times=ncellsper)

# Construct design matrices

Z&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(Z)&lt;-c("t2d_sim","age_sim","cdr_sim")
X&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(X)&lt;-c("t2d_sim","age_sim","cdr_sim")

# Simulate Data

sim_dat&lt;-matrix(nrow=2,ncol=sum(ncellsper))
for(i in 1:nrow(sim_dat)){
   sim_dat[i,]&lt;-simulate_zero_inflated_nb_random_effect_data(ncellsper,X,Z,alpha,beta2
   ,phi,sigma.a,sigma.b,id.levels=NULL)$Y
}
rownames(sim_dat)&lt;-paste("Gene",1:2)

# Run test.vc.twosigma

test.vc.twosigma(sim_dat[1,,drop=FALSE],mean_covar = X,zi_covar=Z
,mean_re = TRUE,zi_re=FALSE,id = id)
</code></pre>

<hr>
<h2 id='twosigma'>Fit the TWO-SIGMA Model.</h2><span id='topic+twosigma'></span>

<h3>Description</h3>

<p>Fit the TWO-SIGMA Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twosigma(
  count_matrix,
  mean_covar,
  zi_covar,
  mean_re = TRUE,
  zi_re = TRUE,
  id,
  adhoc = TRUE,
  adhoc_thresh = 0.1,
  return_summary_fits = TRUE,
  disp_covar = NULL,
  weights = rep(1, ncol(count_matrix)),
  control = glmmTMBControl(),
  ncores = 1,
  cluster_type = "Fork",
  chunk_size = 10,
  lb = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="twosigma_+3A_count_matrix">count_matrix</code></td>
<td>
<p>Matrix of non-negative integer read counts, with rows corresponding to genes and columns corresponding to cells. It is recommended to make the rownames the gene names for better output.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_mean_covar">mean_covar</code></td>
<td>
<p>Covariates for the (conditional) mean model. Must be a matrix (without an intercept column) or = 1 to indicate an intercept only model.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_zi_covar">zi_covar</code></td>
<td>
<p>Covariates for the zero-inflation model. Must be a matrix (without an intercept column), = 1 to indicate an intercept only model, or = 0 to indicate no zero-inflation model desired.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_mean_re">mean_re</code></td>
<td>
<p>Should random intercepts be included in the (conditional) mean model? Ignored if adhoc=TRUE.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_zi_re">zi_re</code></td>
<td>
<p>Should random intercepts be included in the zero-inflation model? Ignored if adhoc=TRUE.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_id">id</code></td>
<td>
<p>Vector of individual-level ID's. Used for random effect prediction and the adhoc method but required regardless.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_adhoc">adhoc</code></td>
<td>
<p>Should the adhoc method be used by default to judge if random effects are needed?</p>
</td></tr>
<tr><td><code id="twosigma_+3A_adhoc_thresh">adhoc_thresh</code></td>
<td>
<p>Value below which the adhoc p-value is deemed significant (and thus RE are deemed necessary). Only used if adhoc==TRUE.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_return_summary_fits">return_summary_fits</code></td>
<td>
<p>If TRUE, the package returns a <code>summary.glmmTMB</code> object for each gene.  If FALSE, an object of class <code>glmmTMB</code> is returned for each gene. The latter requires far more memory to store.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_disp_covar">disp_covar</code></td>
<td>
<p>Covariates for a log-linear model for the dispersion. Either a matrix of covariates or = 1 to indicate an intercept only model. Random effect terms are not permitted in the dispersion model. Defaults to NULL for constant dispersion.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_weights">weights</code></td>
<td>
<p>weights, as in glm. Defaults to 1 for all observations and no scaling or centering of weights is performed.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_control">control</code></td>
<td>
<p>Control parameters for optimization in <code>glmmTMB</code>.  See <code>?glmmTMBControl</code>.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for parallelization. Defaults to 1, meaning no parallelization of any kind is done.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_cluster_type">cluster_type</code></td>
<td>
<p>Whether to use a &quot;cluster of type &quot;Fork&quot; or &quot;Sock&quot;. On Unix systems, &quot;Fork&quot; will likely improve performance. On Windows, only &quot;Sock&quot; will actually result in parallelized computing.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_chunk_size">chunk_size</code></td>
<td>
<p>Number of genes to be sent to each parallel environment. Parallelization is more efficient, particularly with a large count matrix, when the count matrix is 'chunked' into some common size (e.g. 10, 50, 200). Defaults to 10.</p>
</td></tr>
<tr><td><code id="twosigma_+3A_lb">lb</code></td>
<td>
<p>Should load balancing be used for parallelization? Users will likely want to set to FALSE for improved performance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
##' </p>

<ul>
<li><p><code>fit: </code> If <code>return_summary_fits=TRUE</code>, returns a list of model fit objects of class <code>summary.glmmTMB</code>. If <code>return_summary_fits=FALSE</code>, returns a list of model fit objects of class <code>glmmTMB</code>. In either case, the order matches the row order of <code>count_matrix</code>, and the names of the list elements are taken as the rownames of <code>count_matrix</code>.
</p>
</li>
<li><p><code>adhoc_include_RE: </code> Logical vector indicator whether the adhoc method determined random effects needed.  If <code>adhoc=F</code>, then a vector of NA's.
</p>
</li>
<li><p><code>gene_error:</code> Vector indicating whether the particular gene produced an error during model fitting (TRUE) or not (FALSE).
</p>
</li></ul>



<h3>Details</h3>

<p>If adhoc=TRUE, any input in mean_re and zi_re will be ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set Parameters to Simulate Some Data

nind&lt;-10;ncellsper&lt;-rep(50,nind)
sigma.a&lt;-.5;sigma.b&lt;-.5;phi&lt;-.1
alpha&lt;-c(1,0,-.5,-2);beta&lt;-c(2,0,-.1,.6)
beta2&lt;-c(2,1,-.1,.6)
id.levels&lt;-1:nind;nind&lt;-length(id.levels)
id&lt;-rep(id.levels,times=ncellsper)
sim.seed&lt;-1234

# Simulate individual level covariates

t2d_sim&lt;-rep(rbinom(nind,1,p=.4),times=ncellsper)
cdr_sim&lt;-rbeta(sum(ncellsper),3,6)
age_sim&lt;-rep(sample(c(20:60),size=nind,replace = TRUE),times=ncellsper)

# Construct design matrices

Z&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(Z)&lt;-c("t2d_sim","age_sim","cdr_sim")
X&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(X)&lt;-c("t2d_sim","age_sim","cdr_sim")

# Simulate Data

sim_dat&lt;-matrix(nrow=2,ncol=sum(ncellsper))
for(i in 1:nrow(sim_dat)){
   sim_dat[i,]&lt;-simulate_zero_inflated_nb_random_effect_data(ncellsper,X,Z,alpha,beta2
   ,phi,sigma.a,sigma.b,id.levels=NULL)$Y
}
rownames(sim_dat)&lt;-paste("Gene",1:2)

# Run twosigma

twosigma(sim_dat[1:2,],mean_covar = X,zi_covar=1,id = id)
</code></pre>

<hr>
<h2 id='twosigma_custom'>Fit the TWO-SIGMA model with custom user-specified model formulas.</h2><span id='topic+twosigma_custom'></span>

<h3>Description</h3>

<p>Fit the TWO-SIGMA model with custom user-specified model formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twosigma_custom(
  count_matrix,
  mean_form,
  zi_form,
  id,
  return_summary_fits = TRUE,
  silent = FALSE,
  disp_covar = NULL,
  weights = rep(1, ncol(count_matrix)),
  control = glmmTMBControl(),
  ncores = 1,
  cluster_type = "Fork",
  chunk_size = 10,
  lb = FALSE,
  internal_call = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="twosigma_custom_+3A_count_matrix">count_matrix</code></td>
<td>
<p>Matrix of non-negative integer read counts, with rows corresponding to genes and columns corresponding to cells. It is recommended to make the rownames the gene names for better output.</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_mean_form">mean_form</code></td>
<td>
<p>Custom two-sided model formula for the (conditional) mean model. Formula is passed directly into glmmTMB with random effects specified as in the lme4 package. Users should ensure that the LHS of the formula begins with &quot;count.&quot;</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_zi_form">zi_form</code></td>
<td>
<p>Custom one-sided model formula for the zero-inflation model. Formula is passed directly into glmmTMB with random effects specified as in lme4.</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_id">id</code></td>
<td>
<p>Vector of individual-level (sample-level) ID's. Used for random effect prediction but required regardless of their presence in the model.</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_return_summary_fits">return_summary_fits</code></td>
<td>
<p>If TRUE, the package returns a <code>summary.glmmTMB</code> object for each gene.  If FALSE, a <code>glmmTMB</code> object is returned for each gene. The latter requires far more storage space.</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_silent">silent</code></td>
<td>
<p>If TRUE, progress is not printed.</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_disp_covar">disp_covar</code></td>
<td>
<p>Covariates for a log-linear model for the dispersion. Either a matrix of covariates or = 1 to indicate an intercept only model. Random effect terms are not permitted in the dispersion model.</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_weights">weights</code></td>
<td>
<p>weights, as in glm. Defaults to 1 for all observations and no scaling or centering of weights is performed.</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_control">control</code></td>
<td>
<p>Control parameters for optimization in <code>glmmTMB</code>.  See <code>?glmmTMBControl</code>.</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for parallelization. Defaults to 1, meaning no parallelization of any kind is done.</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_cluster_type">cluster_type</code></td>
<td>
<p>Whether to use a &quot;cluster of type &quot;Fork&quot; or &quot;Sock&quot;. On Unix systems, &quot;Fork&quot; will likely improve performance. On Windows, only &quot;Sock&quot; will actually result in parallelized computing.</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_chunk_size">chunk_size</code></td>
<td>
<p>Number of genes to be sent to each parallel environment. Parallelization is more efficient, particularly with a large count matrix, when the count matrix is 'chunked' into some common size (e.g. 10, 50, 200). Defaults to 10.</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_lb">lb</code></td>
<td>
<p>Should load balancing be used for parallelization? Users will likely want to set to FALSE for improved performance.</p>
</td></tr>
<tr><td><code id="twosigma_custom_+3A_internal_call">internal_call</code></td>
<td>
<p>Not needed by users called <code>twosigma_custom</code> directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p><code>fit: </code> If <code>return_summary_fits=TRUE</code>, returns a list of model fit objects of class <code>summary.glmmTMB</code>. If <code>return_summary_fits=FALSE</code>, returns a list of model fit objects of class <code>glmmTMB</code>. In either case, the order matches the row order of <code>count_matrix</code>, and the names of the list elements are taken as the rownames of <code>count_matrix</code>.
</p>
</li>
<li><p><code>gene_error:</code> Vector indicating whether the particular gene produced an error during model fitting (TRUE) or not (FALSE).
</p>
</li></ul>



<h3>Details</h3>

<p>This function is likely only needed if users wish to include random effect terms beyond random intercepts. Users should be confident in their abilities to specify random effects using the syntax of lme4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set Parameters to Simulate Some Data

nind&lt;-10;ncellsper&lt;-rep(50,nind)
sigma.a&lt;-.5;sigma.b&lt;-.5;phi&lt;-.1
alpha&lt;-c(1,0,-.5,-2);beta&lt;-c(2,0,-.1,.6)
beta2&lt;-c(2,1,-.1,.6)
id.levels&lt;-1:nind;nind&lt;-length(id.levels)
id&lt;-rep(id.levels,times=ncellsper)
sim.seed&lt;-1234

# Simulate individual level covariates

t2d_sim&lt;-rep(rbinom(nind,1,p=.4),times=ncellsper)
cdr_sim&lt;-rbeta(sum(ncellsper),3,6)
age_sim&lt;-rep(sample(c(20:60),size=nind,replace = TRUE),times=ncellsper)

# Construct design matrices

Z&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(Z)&lt;-c("t2d_sim","age_sim","cdr_sim")
X&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(X)&lt;-c("t2d_sim","age_sim","cdr_sim")

# Simulate Data

sim_dat&lt;-matrix(nrow=2,ncol=sum(ncellsper))
for(i in 1:nrow(sim_dat)){
   sim_dat[i,]&lt;-simulate_zero_inflated_nb_random_effect_data(ncellsper,X,Z,alpha,beta2
   ,phi,sigma.a,sigma.b,id.levels=NULL)$Y
}
rownames(sim_dat)&lt;-paste("Gene",1:2)

# Run twosigma_custom

twosigma_custom(sim_dat[1:2,],mean_form = count~X,zi_form = ~0,id=id)
</code></pre>

<hr>
<h2 id='twosigmag'>Gene set testing for single-cell RNA-sequencing data adjusting for inter-gene correlation.</h2><span id='topic+twosigmag'></span>

<h3>Description</h3>

<p>Gene set testing for single-cell RNA-sequencing data adjusting for inter-gene correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twosigmag(
  count_matrix,
  index_test,
  index_ref = NULL,
  all_as_ref = FALSE,
  mean_form,
  zi_form,
  mean_form_null = NULL,
  zi_form_null = NULL,
  id,
  statistic,
  lr.df = NULL,
  covar_to_test = NULL,
  contrast_matrix = NULL,
  factor_name = NULL,
  rho = NULL,
  allow_neg_corr = FALSE,
  return_summary_fits = FALSE,
  weights = NULL,
  control = glmmTMBControl(),
  ncores = 1,
  cluster_type = "Fork",
  chunk_size = 10,
  lb = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="twosigmag_+3A_count_matrix">count_matrix</code></td>
<td>
<p>Matrix of non-negative integer read counts. It is recommended to make the rownames the gene names for better output. No missing values can be present in the data.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_index_test">index_test</code></td>
<td>
<p>List of indices corresponding to rows of the count matrix that are in the test set. Names of each list element (i.e. Gene Set Names) are carried forward to output if present.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_index_ref">index_ref</code></td>
<td>
<p>List of indices corresponding to rows of the count matrix that are in the reference set.  If <code>NULL</code>, a reference set is randomly selected of the same size as the test size using genes not in the test set (if <code>all_as_ref=FALSE</code>) or using all other genes (if <code>all_as_ref=TRUE</code>). See <code>all_as_ref</code>. Must be either <code>NULL</code> or a list with the same length as <code>index_test</code>.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_all_as_ref">all_as_ref</code></td>
<td>
<p>Should all genes not in the test set be used as the reference? If <code>FALSE</code>, a random subset is taken of size equal to the test size.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_mean_form">mean_form</code></td>
<td>
<p>Two-sided model formula for the (conditional) mean model. Formula is passed directly into glmmTMB with random effects specified as in the lme4 package. Users should ensure that the LHS of the formula contains  '<code>count</code> '.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_zi_form">zi_form</code></td>
<td>
<p>One-sided model formula for the zero-inflation model under the alternative. Formula is passed directly into glmmTMB with random effects specified as in the lme4 package.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_mean_form_null">mean_form_null</code></td>
<td>
<p>Two-sided model formula for the (conditional) mean model under the null. Needed if and only if <code>statistic='LR'</code>. Syntax is as in <code>mean_form</code>. Users should ensure that the LHS of the formula contains '<code>count</code> '.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_zi_form_null">zi_form_null</code></td>
<td>
<p>One-sided model formula for the zero-inflation model under the null. Needed if and only if <code>statistic='LR'</code>. Syntax is as in <code>zi_form</code>.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_id">id</code></td>
<td>
<p>Vector of individual-level (sample-level) ID's. Used to estimate inter-gene correlation and random effect prediction (if present) and is currently required.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_statistic">statistic</code></td>
<td>
<p>Which gene-level statistic should be used. Options are Likelihood Ratio (&quot;LR&quot;, default), Z-statistic from the mean model (&quot;Z&quot;),the  Stouffer's method combined Z-statistic (&quot;Stouffer&quot;), or a contrast of regression parameters (&quot;contrast&quot;). If &quot;Stouffer&quot;, covar_to_test must be in both components. If &quot;contrast&quot;, covar_to_test is not used and must be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_lr.df">lr.df</code></td>
<td>
<p>degrees of freedom for the asymptotic chi-square approximation to the likelihood ratio statistic. Needed if and only if <code>statistic='LR'</code>.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_covar_to_test">covar_to_test</code></td>
<td>
<p>Covariate used for reporting direction (as Up or Down) of the test set and for collecting gene-level statistics. Either a string indicating the name of the covariate to use or an integer giving its associated position in the RHS of the mean_form argument. If a string, the name is matched to the predictors of the mean model, so users should ensure such a match would be unique. Not required and should be <code>NULL</code> if <code>statistic='contrast'.</code></p>
</td></tr>
<tr><td><code id="twosigmag_+3A_contrast_matrix">contrast_matrix</code></td>
<td>
<p>Matrix of contrasts of regression parameters from the mean model to be tested. Each row will have separate gene-level and set-level statistics.  Rownames of <code>contrast_matrix</code> should correspond to a meaningful name of the hypothesis for nicely formatted output. If testing a factor, must have a number of columns exactly equal to the number of levels of the factor.  Otherwise, must have one column per parameter in the mean model (including a column for the intercept.)</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_factor_name">factor_name</code></td>
<td>
<p>Name of the factor being tested by <code>contrast_matrix</code>. Needed if and only if <code>statistic='contrast'</code> and <code>contrast_matrix</code> is testing a factor variable in the mean model.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_rho">rho</code></td>
<td>
<p>Inter-gene correlation value. If <code>NULL</code> (default), estimated using TWO-SIGMA model residuals.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_allow_neg_corr">allow_neg_corr</code></td>
<td>
<p>Should negative correlation values be allowed? If FALSE, negative correlations are set to zero (leads to conservative inference)..</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_return_summary_fits">return_summary_fits</code></td>
<td>
<p>If <code>TRUE</code>, returns a list containing objects of class <code>summary.glmmTMB</code> for each gene.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_weights">weights</code></td>
<td>
<p>weights, as in <code>glm</code>. Defaults to 1 for all observations and no scaling or centering of weights is performed.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_control">control</code></td>
<td>
<p>Control parameters for optimization in <code>glmmTMB</code>.  See <code>?glmmTMBControl</code>.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for parallelization. Defaults to 1, meaning no parallelization of any kind is done.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_cluster_type">cluster_type</code></td>
<td>
<p>Whether to use a &quot;cluster of type &quot;Fork&quot; or &quot;Sock&quot;. On Unix systems, &quot;Fork&quot; will likely improve performance. On Windows, only &quot;Sock&quot; will actually result in parallelized computing.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_chunk_size">chunk_size</code></td>
<td>
<p>Number of genes to be sent to each parallel environment. Parallelization is more efficient, particularly with a large count matrix, when the count matrix is 'chunked' into some common size (e.g. 10, 50, 200). Defaults to 10.</p>
</td></tr>
<tr><td><code id="twosigmag_+3A_lb">lb</code></td>
<td>
<p>Should load balancing be used for parallelization? Users will likely want to set to FALSE for improved performance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
##' </p>

<ul>
<li><p><code>stats_gene_level_all: </code>Gives all gene-level statistics.  Order matches the order of the inputted count matrix.
</p>
</li>
<li><p><code>p.vals_gene_level: </code>Gives raw (unadjusted) p-values associated with <code>stats_gene_level_all</code>.
</p>
</li>
<li><p><code>set_p.val: </code>Unadjusted set-level p-values. Order matches the order of inputted test sets.
</p>
</li>
<li><p><code>set_p.val_FDR: </code>FDR-corrected (using the Benjamini-Hochberg procedure) set-level p-values. Order matches the order of inputted test sets.
</p>
</li>
<li><p><code>estimates_gene_level: </code>Gives the average logFC or contrast estimate for each gene.
</p>
</li>
<li><p><code>se_gene_level: </code>Standard error of the gene-level logFC values. Useful to construct gene-level summary statistics.
</p>
</li>
<li><p><code>estimates_set_level: </code>Gives the set-level average of the gene-level logFC or contrast estimates.
</p>
</li>
<li><p><code>direction: </code>Reports whether the test set tends to be Up or Down Regulated based on the sign of <code>estimates_set_level</code>.
</p>
</li>
<li><p><code>corr: </code>Vector of estimated inter-gene correlations for each test set. Order matches the order of inputted test sets.
</p>
</li>
<li><p><code>gene_level_loglik: </code>Vector of log-likelihood values for each gene. Values of NA indicates a model fitting or convergence problem for that gene.
</p>
</li>
<li><p><code>gene_error:</code> Vector indicating whether the particular gene produced an error during model fitting (TRUE) or not (FALSE).
</p>
</li>
<li><p><code>test_sets: </code>Vector of numeric indices corresponding to genes in each test set.
</p>
</li>
<li><p><code>ref_sets: </code>Vector of numeric indices corresponding to the genes in each reference set.
</p>
</li>
<li><p><code>gene_summary_fits: </code>Summary.glmmTMB objects for each gene from the alternative model (if return_summary_fits=TRUE)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Set Parameters to Simulate Some Data

nind&lt;-10;ncellsper&lt;-rep(50,nind)
sigma.a&lt;-.5;sigma.b&lt;-.5;phi&lt;-.1
alpha&lt;-c(1,0,-.5,-2);beta&lt;-c(2,0,-.1,.6)
beta2&lt;-c(2,1,-.1,.6)
id.levels&lt;-1:nind;nind&lt;-length(id.levels)
id&lt;-rep(id.levels,times=ncellsper)
sim.seed&lt;-1234

# Simulate individual level covariates

t2d_sim&lt;-rep(rbinom(nind,1,p=.4),times=ncellsper)
cdr_sim&lt;-rbeta(sum(ncellsper),3,6)
age_sim&lt;-rep(sample(c(20:60),size=nind,replace = TRUE),times=ncellsper)

# Construct design matrices

Z&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(Z)&lt;-c("t2d_sim","age_sim","cdr_sim")
X&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(X)&lt;-c("t2d_sim","age_sim","cdr_sim")

# Simulate Data, half under null half under alternative

sim_dat&lt;-matrix(nrow=4,ncol=sum(ncellsper))
for(i in 1:nrow(sim_dat)){
 if(i&lt;2){# Gene Sets Under the Null
   sim_dat[i,]&lt;-simulate_zero_inflated_nb_random_effect_data(ncellsper,X,Z,alpha,beta2
   ,phi,sigma.a,sigma.b,id.levels=NULL)$Y
 }else{# Gene Sets Under the Alternative
   sim_dat[i,]&lt;-simulate_zero_inflated_nb_random_effect_data(ncellsper,X,Z,alpha,beta
   ,phi,sigma.a,sigma.b,id.levels=NULL)$Y
 }
}
rownames(sim_dat)&lt;-paste("Gene",1:4)

# Run twosigmag

twosigmag(sim_dat,index_test = list(c(1,3)),all_as_ref = TRUE,mean_form = count~X
,zi_form = ~0,id=id,covar_to_test  = "t2d_sim",statistic = "Z")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
