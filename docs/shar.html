<!DOCTYPE html><html lang="en"><head><title>Help for package shar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#shar'><p>Package description</p></a></li>
<li><a href='#calc_gest'><p>calc_gest</p></a></li>
<li><a href='#calc_moments'><p>calc_moments</p></a></li>
<li><a href='#calculate_energy'><p>calculate_energy</p></a></li>
<li><a href='#classify_habitats'><p>classify_habitats</p></a></li>
<li><a href='#classint_to_vector'><p>classint_to_vector</p></a></li>
<li><a href='#compute_statistics'><p>compute_statistics</p></a></li>
<li><a href='#create_neighbourhood'><p>create_neighbourhood</p></a></li>
<li><a href='#Energy_fun'><p>energy_fun</p></a></li>
<li><a href='#extract_points'><p>extract_points</p></a></li>
<li><a href='#fit_point_process'><p>fit_point_process</p></a></li>
<li><a href='#get_dist_pairs'><p>get_dist_pairs</p></a></li>
<li><a href='#landscape'><p>Example landscape (random cluster neutral landscape model).</p></a></li>
<li><a href='#list_to_randomized'><p>list_to_randomized</p></a></li>
<li><a href='#pack_randomized'><p>pack_randomized</p></a></li>
<li><a href='#plot_energy'><p>plot_energy</p></a></li>
<li><a href='#plot.rd_mar'><p>plot.rd_mar</p></a></li>
<li><a href='#plot.rd_multi'><p>plot.rd_multi</p></a></li>
<li><a href='#plot.rd_pat'><p>plot.rd_pat</p></a></li>
<li><a href='#plot.rd_ras'><p>plot.rd_ras</p></a></li>
<li><a href='#print.rd_mar'><p>print.rd_mar</p></a></li>
<li><a href='#print.rd_pat'><p>print.rd_pat</p></a></li>
<li><a href='#print.rd_ras'><p>print.rd_ras</p></a></li>
<li><a href='#randomize_raster'><p>randomize_raster</p></a></li>
<li><a href='#reconstruct_algorithm'><p>reconstruct_algorithm</p></a></li>
<li><a href='#reconstruct_pattern'><p>reconstruct_pattern</p></a></li>
<li><a href='#reconstruct_pattern_marks'><p>reconstruct_pattern_marks</p></a></li>
<li><a href='#reconstruct_pattern_multi'><p>reconstruct_pattern_multi</p></a></li>
<li><a href='#results_habitat_association'><p>results_habitat_association</p></a></li>
<li><a href='#sample_randomized'><p>sample_randomized</p></a></li>
<li><a href='#select_kernel'><p>select_kernel</p></a></li>
<li><a href='#species_a'><p>Species a</p></a></li>
<li><a href='#species_b'><p>Species b</p></a></li>
<li><a href='#to_dummy'><p>dummy_transf</p></a></li>
<li><a href='#translate_raster'><p>translate_raster</p></a></li>
<li><a href='#unpack_randomized'><p>unpack_randomized</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Species-Habitat Associations</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian H.K. Hesselbarth &lt;mhk.hesselbarth@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Analyse species-habitat associations in R. Therefore, information about the location 
  of the species (as a point pattern) is needed together with environmental conditions 
  (as a categorical raster). To test for significance habitat associations, one of 
  the two components is randomized. Methods are mainly based on Plotkin et al. (2000) 
  &lt;<a href="https://doi.org/10.1006%2Fjtbi.2000.2158">doi:10.1006/jtbi.2000.2158</a>&gt; and Harms et al. (2001) &lt;<a href="https://doi.org/10.1111%2Fj.1365-2745.2001.00615.x">doi:10.1111/j.1365-2745.2001.00615.x</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-spatialecology.github.io/shar/">https://r-spatialecology.github.io/shar/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-spatialecology/shar/issues/">https://github.com/r-spatialecology/shar/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>classInt, graphics, grDevices, methods, spatstat.explore,
spatstat.geom, spatstat.model, spatstat.random, stats, terra,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, knitr, rmarkdown, spatstat (&ge; 2.0-0), testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-10 12:59:54 UTC; mhesselbarth</td>
</tr>
<tr>
<td>Author:</td>
<td>Maximilian H.K. Hesselbarth
    <a href="https://orcid.org/0000-0003-1125-9918"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Marco Sciaini <a href="https://orcid.org/0000-0002-3042-5435"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Chris Wudel <a href="https://orcid.org/0000-0003-0446-4665"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Zeke Marshall <a href="https://orcid.org/0000-0001-9260-7827"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Thomas Etherington
    <a href="https://orcid.org/0000-0002-3187-075X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Janosch Heinermann
    <a href="https://orcid.org/0000-0001-5080-8591"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-10 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='shar'>Package description</h2><span id='topic+shar-package'></span><span id='topic+shar'></span>

<h3>Description</h3>

<p>Analyse species-habitat associations in R. Therefore, information about the
location of the species is needed and about the environmental conditions. To test
for significance habitat associations, one of the two components is randomized.
Methods are mainly based on Plotkin et al. (2000) &lt;doi:10.1006/jtbi.2000.2158&gt; and
Harms et al. (2001) &lt;doi:10.1111/j.1365-2745.2001.00615.x&gt;.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Maximilian H.K. Hesselbarth <a href="mailto:mhk.hesselbarth@gmail.com">mhk.hesselbarth@gmail.com</a> (<a href="https://orcid.org/0000-0003-1125-9918">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Marco Sciaini <a href="mailto:marco.sciaini@posteo.net">marco.sciaini@posteo.net</a> (<a href="https://orcid.org/0000-0002-3042-5435">ORCID</a>)
</p>
</li>
<li><p> Chris Wudel <a href="mailto:chris.wudel@tu-dresden.de">chris.wudel@tu-dresden.de</a> (<a href="https://orcid.org/0000-0003-0446-4665">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Zeke Marshall <a href="mailto:ee18zm@leeds.ac.uk">ee18zm@leeds.ac.uk</a> (<a href="https://orcid.org/0000-0001-9260-7827">ORCID</a>) [contributor]
</p>
</li>
<li><p> Thomas Etherington <a href="mailto:teth001@aucklanduni.ac.nz">teth001@aucklanduni.ac.nz</a> (<a href="https://orcid.org/0000-0002-3187-075X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Janosch Heinermann <a href="mailto:janosch.heinermann@tu-dresden.de">janosch.heinermann@tu-dresden.de</a> (<a href="https://orcid.org/0000-0001-5080-8591">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://r-spatialecology.github.io/shar/">https://r-spatialecology.github.io/shar/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-spatialecology/shar/issues/">https://github.com/r-spatialecology/shar/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='calc_gest'>calc_gest</h2><span id='topic+calc_gest'></span>

<h3>Description</h3>

<p>Calculate Gest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_gest(dist, r, n_points)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_gest_+3A_dist">dist</code></td>
<td>
<p>matrix with distance pairs.</p>
</td></tr>
<tr><td><code id="calc_gest_+3A_r">r</code></td>
<td>
<p>vector with distances r.</p>
</td></tr>
<tr><td><code id="calc_gest_+3A_n_points">n_points</code></td>
<td>
<p>numeric with number of points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates Gest based on distances created with <code>get_dist_pairs</code>.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_dist_pairs">get_dist_pairs</a></code>
</p>

<hr>
<h2 id='calc_moments'>calc_moments</h2><span id='topic+calc_moments'></span>

<h3>Description</h3>

<p>Calculate moments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_moments(fn, p, exclude = NULL, x, y, mark, kernel, rmax_bw, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_moments_+3A_fn">fn</code></td>
<td>
<p>Determination of the weightings of the mark correlation functions.</p>
</td></tr>
<tr><td><code id="calc_moments_+3A_p">p</code></td>
<td>
<p>Defines the initial state of the new ponit pattern.</p>
</td></tr>
<tr><td><code id="calc_moments_+3A_exclude">exclude</code></td>
<td>
<p>Vector indicating which values not to use.</p>
</td></tr>
<tr><td><code id="calc_moments_+3A_x">x</code>, <code id="calc_moments_+3A_y">y</code></td>
<td>
<p>x and y coordinates of the points from the reference point pattern.</p>
</td></tr>
<tr><td><code id="calc_moments_+3A_mark">mark</code></td>
<td>
<p>Marks the currently viewed point pattern.</p>
</td></tr>
<tr><td><code id="calc_moments_+3A_kernel">kernel</code></td>
<td>
<p>Result of the kernel calculation, calculated with the calc_kernels function.</p>
</td></tr>
<tr><td><code id="calc_moments_+3A_rmax_bw">rmax_bw</code></td>
<td>
<p>Maximum distance at which the summary statistics are
evaluated + Bandwidth with which the kernels are scaled, so that this is the
standard deviation of the smoothing kernel.</p>
</td></tr>
<tr><td><code id="calc_moments_+3A_r">r</code></td>
<td>
<p>Sequence from rmin to rmax in rcount steps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Definition of the product-moment function for calculating the contribution
of a point at the coordinates x, y with marking.
</p>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='calculate_energy'>calculate_energy</h2><span id='topic+calculate_energy'></span>

<h3>Description</h3>

<p>Calculate mean energy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_energy(
  pattern,
  weights = c(1, 1),
  return_mean = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_energy_+3A_pattern">pattern</code></td>
<td>
<p>List with reconstructed patterns.</p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_weights">weights</code></td>
<td>
<p>Vector with weights used to calculate energy.
The first number refers to Gest(r), the second number to pcf(r).</p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_return_mean">return_mean</code></td>
<td>
<p>Logical if the mean energy is returned.</p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_verbose">verbose</code></td>
<td>
<p>Logical if progress report is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the mean energy (or deviation) between the observed
pattern and all reconstructed patterns (for more information see Tscheschel &amp;
Stoyan (2006) or Wiegand &amp; Moloney (2014)). The pair correlation function and the
nearest neighbour distance function are used to describe the patterns.
</p>


<h3>Value</h3>

<p>vector
</p>


<h3>References</h3>

<p>Kirkpatrick, S., Gelatt, C.D.Jr., Vecchi, M.P., 1983. Optimization by simulated
annealing. Science 220, 671–680. &lt;https://doi.org/10.1126/science.220.4598.671&gt;
</p>
<p>Tscheschel, A., Stoyan, D., 2006. Statistical reconstruction of random point
patterns. Computational Statistics and Data Analysis 51, 859–871.
&lt;https://doi.org/10.1016/j.csda.2005.09.007&gt;
</p>
<p>Wiegand, T., Moloney, K.A., 2014. Handbook of spatial point-pattern analysis in
ecology. Chapman and Hall/CRC Press, Boca Raton. ISBN 978-1-4200-8254-8
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_energy">plot_energy</a></code>,
<code><a href="#topic+reconstruct_pattern">reconstruct_pattern</a></code>,
<code><a href="#topic+fit_point_process">fit_point_process</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pattern_random &lt;- fit_point_process(species_a, n_random = 19)
calculate_energy(pattern_random)
calculate_energy(pattern_random, return_mean = TRUE)

## Not run: 
marks_sub &lt;- spatstat.geom::subset.ppp(species_a, select = dbh)
marks_recon &lt;- reconstruct_pattern_marks(pattern_random$randomized[[1]], marks_sub,
n_random = 19, max_runs = 1000)
calculate_energy(marks_recon, return_mean = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='classify_habitats'>classify_habitats</h2><span id='topic+classify_habitats'></span>

<h3>Description</h3>

<p>Classify habitats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_habitats(raster, return_breaks = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classify_habitats_+3A_raster">raster</code></td>
<td>
<p>SpatRaster with continuous environmental values.</p>
</td></tr>
<tr><td><code id="classify_habitats_+3A_return_breaks">return_breaks</code></td>
<td>
<p>Logical if breaks should be returned as well.</p>
</td></tr>
<tr><td><code id="classify_habitats_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>classIntervals</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Classifies a SpatRaster from the <code>raster</code> packages with continuous
values into n discrete classes. The <code>cut</code> function used to classify the raster,
uses <code>include.lowest = TRUE</code>.
</p>
<p>For more information about the classification methods, see <code>classIntervals</code> from
the <code>classInt</code> package and/or the provided References. The help page of <code>classIntervals</code>
also includes further possible arguments to find  breaks (e.g., different styles, number
of classes, fixed breaks, etc.).
</p>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>References</h3>

<p>Armstrong, M.P., Xiao, N., Bennett, D.A., 2003. Using genetic algorithms to create
multicriteria class intervals for choropleth maps. Annals of the Association of
American Geographers 93, 595–623. &lt;https://doi.org/10.1111/1467-8306.9303005&gt;
</p>
<p>Dent, B.D., 1999. Cartography: Thematic map design, 5th ed. WCB/McGraw-Hill, Boston, USA.
ISBN 978-0-697-38495-9
</p>
<p>Fisher, W.D., 1958. On grouping for maximum homogeneity. Journal of the American
Statistical Association 53, 789–798. &lt;https://doi.org/10.1080/01621459.1958.10501479&gt;
</p>
<p>Jenks, G.F., Caspall, F.C., 1971. Error in choroplethic maps: Definition, measurement,
reduction. Annals of the Association of American Geographers 61, 217–244.
&lt;https://doi.org/10.1111/j.1467-8306.1971.tb00779.x&gt;
</p>
<p>Jiang, B., 2013. Head/tail breaks: A new classification scheme for data with a
heavy-tailed distribution. The Professional Geographer 65, 482-494.
&lt;https://doi.org/10.1080/00330124.2012.700499&gt;
</p>
<p>Slocum, T.A., McMaster, R.B., Kessler, F.C., Howard, H.H., 2009. Thematic cartography
and geovisualization, 3rd ed. ed, Prentice Hall Series in Geographic Information Science.
Pearson Prentice Hall, Upper Saddle River, USA. ISBN 978-0-13-229834-6
</p>
<p>Wand, M. P., 1995. Data-based choice of histogram binwidth. The American
Statistician 51, 59-64. &lt;https://doi.org/10.1080/00031305.1997.10473591&gt;
</p>


<h3>See Also</h3>

<p><code><a href="classInt.html#topic+classIntervals">classIntervals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape_classified &lt;- classify_habitats(terra::rast(landscape), n = 5, style = "fisher")

landscape_classified &lt;- classify_habitats(terra::rast(landscape), style = "fixed",
fixedBreaks = c(0, 0.25, 0.75, 1.0), return_breaks = TRUE)

</code></pre>

<hr>
<h2 id='classint_to_vector'>classint_to_vector</h2><span id='topic+classint_to_vector'></span>

<h3>Description</h3>

<p>Convert classIntervals to vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classint_to_vector(x, digits = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classint_to_vector_+3A_x">x</code></td>
<td>
<p>classIntervals object</p>
</td></tr>
<tr><td><code id="classint_to_vector_+3A_digits">digits</code></td>
<td>
<p>Integer with digits used for rounding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a character vector with breaks of a <code>classIntervals</code> object. If
<code>digits = NULL</code>, results will not be rounded
</p>


<h3>Value</h3>

<p>vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
classint_to_vector(x = landscape_classified$breaks, digits = 4)

## End(Not run)

</code></pre>

<hr>
<h2 id='compute_statistics'>compute_statistics</h2><span id='topic+compute_statistics'></span>

<h3>Description</h3>

<p>Compute summary statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_statistics(x, y, k, xr, yr, w_statistics, bw, divisor, kernel_arg, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_statistics_+3A_x">x</code>, <code id="compute_statistics_+3A_y">y</code></td>
<td>
<p>x and y coordinates of the points from the reference point pattern.</p>
</td></tr>
<tr><td><code id="compute_statistics_+3A_k">k</code></td>
<td>
<p>Vector of values k; used only if Dk is included in w_statistics below.</p>
</td></tr>
<tr><td><code id="compute_statistics_+3A_xr">xr</code>, <code id="compute_statistics_+3A_yr">yr</code></td>
<td>
<p>x and y extension of the observation window (start, end).</p>
</td></tr>
<tr><td><code id="compute_statistics_+3A_w_statistics">w_statistics</code></td>
<td>
<p>vector of named weights for optional spatial statistics
from the <code>spatstat</code> package to be included in the energy calculation. This may
include Dk, K, Hs, pcf.</p>
</td></tr>
<tr><td><code id="compute_statistics_+3A_bw">bw</code>, <code id="compute_statistics_+3A_divisor">divisor</code>, <code id="compute_statistics_+3A_kernel_arg">kernel_arg</code>, <code id="compute_statistics_+3A_r">r</code></td>
<td>
<p>Several parameters related to summary function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute optional spatial statistics using the spatstat package.
</p>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='create_neighbourhood'>create_neighbourhood</h2><span id='topic+create_neighbourhood'></span>

<h3>Description</h3>

<p>Create neighbourhood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_neighbourhood(cells, matrix, directions = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_neighbourhood_+3A_cells">cells</code></td>
<td>
<p>Matrix with cell ids of focal cells.</p>
</td></tr>
<tr><td><code id="create_neighbourhood_+3A_matrix">matrix</code></td>
<td>
<p>Matrix in which cells are located.</p>
</td></tr>
<tr><td><code id="create_neighbourhood_+3A_directions">directions</code></td>
<td>
<p>Integer with cells neighbourhood rule: 4 (rook's case), 8 (queen's case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Get cell ids of all neighbouring cells. The neighbourhoood rule can be specified
and is either rook's case (4 neighbours) or queen's case (8 neighbours).
</p>


<h3>Value</h3>

<p>matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomize_raster">randomize_raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mat &lt;- matrix(1, nrow= 10, ncol = 10)
cell_id &lt;- rbind(cbind(3,5), cbind(7,1))
create_neighbourhood(cell_id, mat)

## End(Not run)

</code></pre>

<hr>
<h2 id='Energy_fun'>energy_fun</h2><span id='topic+Energy_fun'></span>

<h3>Description</h3>

<p>Energy function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Energy_fun(
  f,
  f0,
  statistics,
  f_,
  f0_,
  statistics_,
  fn,
  p,
  p_,
  Lp,
  w_statistics
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Energy_fun_+3A_f">f</code></td>
<td>
<p>Result of the calc_moments_full function which represents
product-moment contribution of a point at coordinates x, y with marks,
for the whole new ponit pattern.</p>
</td></tr>
<tr><td><code id="Energy_fun_+3A_f0">f0</code></td>
<td>
<p>Column sums of the weights of the brand correlation functions of
the new point pattern.</p>
</td></tr>
<tr><td><code id="Energy_fun_+3A_statistics">statistics</code></td>
<td>
<p>Results of the compute_statistics function for the
new point pattern (calculation of optional spatial statistics).</p>
</td></tr>
<tr><td><code id="Energy_fun_+3A_fn">fn</code></td>
<td>
<p>Determination of the weightings of the mark correlation functions.</p>
</td></tr>
<tr><td><code id="Energy_fun_+3A_p">p</code></td>
<td>
<p>Defines the initial state of the new ponit pattern.</p>
</td></tr>
<tr><td><code id="Energy_fun_+3A_p_">p_</code></td>
<td>
<p>Reference point pattern.</p>
</td></tr>
<tr><td><code id="Energy_fun_+3A_lp">Lp</code></td>
<td>
<p>Distance measure for the calculation of the energy function
(Lp distance, 1 &lt;= p &lt;Inf).</p>
</td></tr>
<tr><td><code id="Energy_fun_+3A_w_statistics">w_statistics</code></td>
<td>
<p>Vector of named weights for optional spatial statistics
from the <code>spatstat</code> package to be included in the energy calculation.This may
include Dk, K, Hs, pcf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Defining the Energy_fun function to calculate the &quot;energy&quot; of the pattern
(where a lower energy indicates a better match).
</p>


<h3>Value</h3>

<p>vector
</p>

<hr>
<h2 id='extract_points'>extract_points</h2><span id='topic+extract_points'></span>

<h3>Description</h3>

<p>Extract points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_points(raster, pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_points_+3A_raster">raster</code></td>
<td>
<p>SpatRaster with environmental data</p>
</td></tr>
<tr><td><code id="extract_points_+3A_pattern">pattern</code></td>
<td>
<p>ppp object with point pattern.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts the number of points within each discrete habitat.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+results_habitat_association">results_habitat_association</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
landscape_classified &lt;- classify_habitats(terra::rast(landscape), n = 5, style = "fisher")
extract_points(raster = landscape_classified, pattern = species_b)

## End(Not run)

</code></pre>

<hr>
<h2 id='fit_point_process'>fit_point_process</h2><span id='topic+fit_point_process'></span>

<h3>Description</h3>

<p>Fit point process to randomize data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_point_process(
  pattern,
  n_random = 1,
  process = "poisson",
  return_para = FALSE,
  return_input = TRUE,
  simplify = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_point_process_+3A_pattern">pattern</code></td>
<td>
<p>ppp object with point pattern</p>
</td></tr>
<tr><td><code id="fit_point_process_+3A_n_random">n_random</code></td>
<td>
<p>Integer with number of randomizations.</p>
</td></tr>
<tr><td><code id="fit_point_process_+3A_process">process</code></td>
<td>
<p>Character specifying which point process model to use.
Either <code>"poisson"</code> or <code>"cluster"</code>.</p>
</td></tr>
<tr><td><code id="fit_point_process_+3A_return_para">return_para</code></td>
<td>
<p>Logical if fitted parameters should be returned.</p>
</td></tr>
<tr><td><code id="fit_point_process_+3A_return_input">return_input</code></td>
<td>
<p>Logical if the original input data is returned.</p>
</td></tr>
<tr><td><code id="fit_point_process_+3A_simplify">simplify</code></td>
<td>
<p>Logical if only pattern will be returned if <code>n_random = 1</code>
and <code>return_input = FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_point_process_+3A_verbose">verbose</code></td>
<td>
<p>Logical if progress report is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions randomizes the observed point pattern by fitting a point process to
the data and simulating <code>n_random</code> patterns using the fitted point process.
It is possible to choose between a Poisson process or a Thomas cluster process model.
For more information about the point process models, see e.g. Wiegand &amp; Moloney (2014).
</p>


<h3>Value</h3>

<p>rd_pat
</p>


<h3>References</h3>

<p>Plotkin, J.B., Potts, M.D., Leslie, N., Manokaran, N., LaFrankie, J.V.,
Ashton, P.S., 2000. Species-area curves, spatial aggregation, and habitat specialization
in tropical forests. Journal of Theoretical Biology 207, 81–99.
&lt;https://doi.org/10.1006/jtbi.2000.2158&gt;
</p>
<p>Wiegand, T., Moloney, K.A., 2014. Handbook of spatial point-pattern analysis in
ecology. Chapman and Hall/CRC Press, Boca Raton. ISBN 978-1-4200-8254-8
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pattern_fitted &lt;- fit_point_process(pattern = species_a, n_random = 39)

</code></pre>

<hr>
<h2 id='get_dist_pairs'>get_dist_pairs</h2><span id='topic+get_dist_pairs'></span>

<h3>Description</h3>

<p>Distance between points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dist_pairs(X, rmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dist_pairs_+3A_x">X</code></td>
<td>
<p>ppp object</p>
</td></tr>
<tr><td><code id="get_dist_pairs_+3A_rmax">rmax</code></td>
<td>
<p>Numeric with maximum distance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns matrix with point pairs and distances between them.
</p>


<h3>Value</h3>

<p>matrix
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+pcf.ppp">pcf.ppp</a></code>
</p>

<hr>
<h2 id='landscape'>Example landscape (random cluster neutral landscape model).</h2><span id='topic+landscape'></span>

<h3>Description</h3>

<p>An example map to show landscapetools functionality
generated with the <code>NLMR::nlm_fbm()</code> algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscape
</code></pre>


<h3>Format</h3>

<p>A SpatRaster object.
</p>


<h3>Source</h3>

<p>Simulated neutral landscape model with R. &lt;https://github.com/ropensci/NLMR/&gt;
</p>

<hr>
<h2 id='list_to_randomized'>list_to_randomized</h2><span id='topic+list_to_randomized'></span>

<h3>Description</h3>

<p>Convert list to rd_* object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_to_randomized(list, observed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_to_randomized_+3A_list">list</code></td>
<td>
<p>List</p>
</td></tr>
<tr><td><code id="list_to_randomized_+3A_observed">observed</code></td>
<td>
<p>Observed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert list of randomized point pattern or raster layer to a rd_* object that
can be used with all functions of the package. The main purpose of this utility function
is to allow an easy parallelization of the randomization approach.
</p>
<p>For more information, please see the &quot;Parallelization&quot; article.
</p>


<h3>Value</h3>

<p>rd_pat, rd_ras
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomize_raster">randomize_raster</a></code>,
<code><a href="#topic+translate_raster">translate_raster</a></code>,
<code><a href="#topic+reconstruct_pattern">reconstruct_pattern</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit_list &lt;- lapply(X = 1:39, FUN = function(i) {fit_point_process(pattern = species_a,
n_random = 1, simplify = TRUE, return_input = FALSE, verbose = FALSE)})

list_to_randomized(list = fit_list, observed = species_a)

## End(Not run)

</code></pre>

<hr>
<h2 id='pack_randomized'>pack_randomized</h2><span id='topic+pack_randomized'></span>

<h3>Description</h3>

<p>Save randomized raster object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pack_randomized(raster)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pack_randomized_+3A_raster">raster</code></td>
<td>
<p>rd_ras object with randomized raster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because of how SpatRaster are saved (need to be packed), this function wraps
all raster objects and prepares them for saving first. For further details, see <code>wrap</code>.
</p>


<h3>Value</h3>

<p>rd_ras
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unpack_randomized">unpack_randomized</a></code>,
<code><a href="terra.html#topic+wrap">wrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
landscape_classified &lt;- classify_habitats(terra::rast(landscape), n = 5, style = "fisher")
landscape_random &lt;- randomize_raster(landscape_classified, n_random = 3)
x &lt;- pack_randomized(raster = landscape_random)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_energy'>plot_energy</h2><span id='topic+plot_energy'></span>

<h3>Description</h3>

<p>Plot energy of pattern reconstruction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_energy(pattern, col = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_energy_+3A_pattern">pattern</code></td>
<td>
<p>rd_pat or rd_mar object with randomized patterns.</p>
</td></tr>
<tr><td><code id="plot_energy_+3A_col">col</code></td>
<td>
<p>Vector with colors. Must be the same length as <code>n_random</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots the decrease of the energy over time, i.e. the iterations.
This can help to identify if the chosen <code>max_runs</code> for the reconstruction
were sufficient. The <code>pattern</code> object must have been created using
<code>reconstruct_pattern_*</code> .
</p>


<h3>Value</h3>

<p>void
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconstruct_pattern">reconstruct_pattern</a></code>,
<code><a href="#topic+fit_point_process">fit_point_process</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pattern_recon &lt;- reconstruct_pattern(species_a, n_random = 3, max_runs = 1000)
plot_energy(pattern_recon)

marks_sub &lt;- spatstat.geom::subset.ppp(species_a, select = dbh)
marks_recon &lt;- reconstruct_pattern_marks(pattern_recon$randomized[[1]], marks_sub,
n_random = 1, max_runs = 1000)
plot_energy(marks_recon)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.rd_mar'>plot.rd_mar</h2><span id='topic+plot.rd_mar'></span>

<h3>Description</h3>

<p>Plot method for rd_pat object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rd_mar'
plot(
  x,
  what = "sf",
  n = NULL,
  probs = c(0.025, 0.975),
  ask = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.rd_mar_+3A_x">x</code></td>
<td>
<p>rd_mar object with randomized patterns.</p>
</td></tr>
<tr><td><code id="plot.rd_mar_+3A_what">what</code></td>
<td>
<p>Character specifying to plot summary functions of point patterns
(<code>what = "sf"</code>) or actual patterns (<code>what = "pp"</code>).</p>
</td></tr>
<tr><td><code id="plot.rd_mar_+3A_n">n</code></td>
<td>
<p>Integer with number or vector of ids of randomized pattern to plot.
See Details section for more information.</p>
</td></tr>
<tr><td><code id="plot.rd_mar_+3A_probs">probs</code></td>
<td>
<p>Vector with quantiles of randomized data used for envelope construction.</p>
</td></tr>
<tr><td><code id="plot.rd_mar_+3A_ask">ask</code></td>
<td>
<p>Logical if the user is asked to press &lt;RETURN&gt; before second summary function
is plotted (only used if <code>what = "sf"</code>).</p>
</td></tr>
<tr><td><code id="plot.rd_mar_+3A_verbose">verbose</code></td>
<td>
<p>Logical if progress report is printed.</p>
</td></tr>
<tr><td><code id="plot.rd_mar_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots the pair correlation function and the nearest neighbour function of
the observed pattern and the reconstructed patterns (as &quot;simulation envelopes&quot;).
</p>
<p>It is also possible to plot n randomized patterns and the observed pattern
using <code>what = "pp"</code>. If <code>n</code> is a single number, <code>n</code> randomized
patterns will be sampled to plot. If <code>n</code> is a vector, the corresponding patterns
will be plotted.
</p>


<h3>Value</h3>

<p>void
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconstruct_pattern">reconstruct_pattern</a></code>,
<code><a href="#topic+fit_point_process">fit_point_process</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pattern_recon &lt;- reconstruct_pattern(species_a, n_random = 1, max_runs = 1000,
simplify = TRUE, return_input = FALSE)
marks_sub &lt;- spatstat.geom::subset.ppp(species_a, select = dbh)
marks_recon &lt;- reconstruct_pattern_marks(pattern_recon, marks_sub,
n_random = 19, max_runs = 1000)
plot(marks_recon)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.rd_multi'>plot.rd_multi</h2><span id='topic+plot.rd_multi'></span>

<h3>Description</h3>

<p>Plot method for rd_multi object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rd_multi'
plot(x, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.rd_multi_+3A_x">x</code></td>
<td>
<p>rd_multi Object created with <code>reconstruct_pattern_multi</code>.
multiple marks.</p>
</td></tr>
<tr><td><code id="plot.rd_multi_+3A_verbose">verbose</code></td>
<td>
<p>Logical if progress should be printed.</p>
</td></tr>
<tr><td><code id="plot.rd_multi_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates and visualises various summary statistics for the results of
multi-marks point pattern reconstruction.
</p>


<h3>Value</h3>

<p>void
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconstruct_pattern_multi">reconstruct_pattern_multi</a></code>
</p>

<hr>
<h2 id='plot.rd_pat'>plot.rd_pat</h2><span id='topic+plot.rd_pat'></span>

<h3>Description</h3>

<p>Plot method for rd_pat object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rd_pat'
plot(
  x,
  what = "sf",
  n = NULL,
  probs = c(0.025, 0.975),
  ask = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.rd_pat_+3A_x">x</code></td>
<td>
<p>rd_pat object with randomized patterns.</p>
</td></tr>
<tr><td><code id="plot.rd_pat_+3A_what">what</code></td>
<td>
<p>Character specifying to plot summary functions of point patterns
(<code>what = "sf"</code>) or actual patterns (<code>what = "pp"</code>).</p>
</td></tr>
<tr><td><code id="plot.rd_pat_+3A_n">n</code></td>
<td>
<p>Integer with number or vector of ids of randomized pattern to plot.
See Details section for more information.</p>
</td></tr>
<tr><td><code id="plot.rd_pat_+3A_probs">probs</code></td>
<td>
<p>Vector with quantiles of randomized data used for envelope construction.</p>
</td></tr>
<tr><td><code id="plot.rd_pat_+3A_ask">ask</code></td>
<td>
<p>Logical if the user is asked to press &lt;RETURN&gt; before second summary function
is plotted (only used if <code>what = "sf"</code>).</p>
</td></tr>
<tr><td><code id="plot.rd_pat_+3A_verbose">verbose</code></td>
<td>
<p>Logical if progress report is printed.</p>
</td></tr>
<tr><td><code id="plot.rd_pat_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots the pair correlation function and the nearest neighbour function of
the observed pattern and the reconstructed patterns (as &quot;simulation envelopes&quot;).
</p>
<p>It is also possible to plot n randomized patterns and the observed pattern
using <code>what = "pp"</code>. If <code>n</code> is a single number, <code>n</code> randomized
patterns will be sampled to plot. If <code>n</code> is a vector, the corresponding patterns
will be plotted.
</p>


<h3>Value</h3>

<p>void
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconstruct_pattern">reconstruct_pattern</a></code>,
<code><a href="#topic+fit_point_process">fit_point_process</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pattern_random &lt;- fit_point_process(species_a, n_random = 39)
plot(pattern_random)

pattern_recon &lt;- reconstruct_pattern(species_b, n_random = 19,
max_runs = 1000, method = "hetero")
plot(pattern_recon)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.rd_ras'>plot.rd_ras</h2><span id='topic+plot.rd_ras'></span>

<h3>Description</h3>

<p>Plot method for rd_ras object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rd_ras'
plot(x, n = NULL, col, verbose = TRUE, nrow, ncol, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.rd_ras_+3A_x">x</code></td>
<td>
<p>rd_ras object with randomized raster.</p>
</td></tr>
<tr><td><code id="plot.rd_ras_+3A_n">n</code></td>
<td>
<p>Integer with number or vector of ids of randomized raster to plot.
See Details section for more information.</p>
</td></tr>
<tr><td><code id="plot.rd_ras_+3A_col">col</code></td>
<td>
<p>Vector with color palette used for plotting.</p>
</td></tr>
<tr><td><code id="plot.rd_ras_+3A_verbose">verbose</code></td>
<td>
<p>Logical if messages are printed.</p>
</td></tr>
<tr><td><code id="plot.rd_ras_+3A_nrow">nrow</code>, <code id="plot.rd_ras_+3A_ncol">ncol</code></td>
<td>
<p>Integer with number of rows and columns of plot grid.</p>
</td></tr>
<tr><td><code id="plot.rd_ras_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to plot randomized raster. If <code>n</code> is a single number, <code>n</code> randomized
raster will be sampled to plot. If <code>n</code> is a vector, the corresponding raster
will be plotted. <code>col, nrow, ncol</code> are passed to <code>plot</code>.
</p>


<h3>Value</h3>

<p>void
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomize_raster">randomize_raster</a></code>,
<code><a href="#topic+translate_raster">translate_raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
landscape_classified &lt;- classify_habitats(terra::rast(landscape), n = 5, style = "fisher")
landscape_random &lt;- randomize_raster(landscape_classified, n_random = 19)
plot(landscape_random)

## End(Not run)

</code></pre>

<hr>
<h2 id='print.rd_mar'>print.rd_mar</h2><span id='topic+print.rd_mar'></span>

<h3>Description</h3>

<p>Print method for rd_mar object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rd_mar'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rd_mar_+3A_x">x</code></td>
<td>
<p>rd_mar object with randomized patterns.</p>
</td></tr>
<tr><td><code id="print.rd_mar_+3A_digits">digits</code></td>
<td>
<p>Integer with number of decimal places (round) to be printed.</p>
</td></tr>
<tr><td><code id="print.rd_mar_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>cat</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Printing method for random patterns created with <code><a href="#topic+reconstruct_pattern_marks">reconstruct_pattern_marks</a></code>.
</p>


<h3>Value</h3>

<p>void
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconstruct_pattern_marks">reconstruct_pattern_marks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pattern_recon &lt;- reconstruct_pattern(species_a, n_random = 1, max_runs = 1000,
simplify = TRUE, return_input = FALSE)
marks_sub &lt;- spatstat.geom::subset.ppp(species_a, select = dbh)
marks_recon &lt;- reconstruct_pattern_marks(pattern_recon, marks_sub,
n_random = 19, max_runs = 1000)
print(marks_recon)

## End(Not run)

</code></pre>

<hr>
<h2 id='print.rd_pat'>print.rd_pat</h2><span id='topic+print.rd_pat'></span>

<h3>Description</h3>

<p>Print method for rd_pat object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rd_pat'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rd_pat_+3A_x">x</code></td>
<td>
<p>rd_pat object with randomized patterns.</p>
</td></tr>
<tr><td><code id="print.rd_pat_+3A_digits">digits</code></td>
<td>
<p>Integer with number of decimal places (round).</p>
</td></tr>
<tr><td><code id="print.rd_pat_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>cat</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Printing method for random patterns created with <code>reconstruct_pattern_*</code>.
</p>


<h3>Value</h3>

<p>void
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconstruct_pattern">reconstruct_pattern</a></code>,
<code><a href="#topic+fit_point_process">fit_point_process</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pattern_random &lt;- fit_point_process(species_a, n_random = 199)
print(pattern_random)

## Not run: 
pattern_recon &lt;- reconstruct_pattern(species_b, n_random = 19, max_runs = 1000,
method = "hetero")
print(pattern_recon)

## End(Not run)

</code></pre>

<hr>
<h2 id='print.rd_ras'>print.rd_ras</h2><span id='topic+print.rd_ras'></span>

<h3>Description</h3>

<p>Print method for rd_ras object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rd_ras'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rd_ras_+3A_x">x</code></td>
<td>
<p>rd_ras object with randomized raster.</p>
</td></tr>
<tr><td><code id="print.rd_ras_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>cat</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Printing method for random patterns created with <code><a href="#topic+randomize_raster">randomize_raster</a></code> or
<code><a href="#topic+translate_raster">translate_raster</a></code>.
</p>


<h3>Value</h3>

<p>void
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomize_raster">randomize_raster</a></code>,
<code><a href="#topic+translate_raster">translate_raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
landscape_classified &lt;- classify_habitats(terra::rast(landscape), n = 5, style = "fisher")
landscape_random &lt;- randomize_raster(landscape_classified, n_random = 19)

print(landscape_random)

## End(Not run)

</code></pre>

<hr>
<h2 id='randomize_raster'>randomize_raster</h2><span id='topic+randomize_raster'></span>

<h3>Description</h3>

<p>Randomized-habitats procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomize_raster(
  raster,
  n_random = 1,
  directions = 4,
  return_input = TRUE,
  simplify = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomize_raster_+3A_raster">raster</code></td>
<td>
<p>SpatRaster with discrete habitat classes.</p>
</td></tr>
<tr><td><code id="randomize_raster_+3A_n_random">n_random</code></td>
<td>
<p>Integer with number of randomizations.</p>
</td></tr>
<tr><td><code id="randomize_raster_+3A_directions">directions</code></td>
<td>
<p>Interger with cells neighbourhood rule: 4 (rook's case), 8 (queen's case).</p>
</td></tr>
<tr><td><code id="randomize_raster_+3A_return_input">return_input</code></td>
<td>
<p>Logical if the original input data is returned.</p>
</td></tr>
<tr><td><code id="randomize_raster_+3A_simplify">simplify</code></td>
<td>
<p>Logical if only the raster will be returned if <code>n_random = 1</code>
and <code>return_input = FALSE</code>.</p>
</td></tr>
<tr><td><code id="randomize_raster_+3A_verbose">verbose</code></td>
<td>
<p>Logical if progress report is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function randomizes a habitat map with discrete classes (as SpatRaster) as proposed
by Harms et al. (2001) as “randomized-habitats procedure”. The algorithm starts with an
empty habitat map and starts to assign random neighbouring cells to each habitat
(in increasing order of abundance in observed map). We modified the procedure
slightly by increasing a probability to jump to a non-neighbouring cell as the
current patch becomes larger.
</p>
<p>In case the SpatRaster contains NA cells, this needs to be reflected in the observation
window of the point pattern as well (i.e., no point locations possible in these areas).
</p>


<h3>Value</h3>

<p>rd_ras
</p>


<h3>References</h3>

<p>Harms, K.E., Condit, R., Hubbell, S.P., Foster, R.B., 2001. Habitat associations of
trees and shrubs in a 50-ha neotropical forest plot. Journal of Ecology 89, 947–959.
&lt;https://doi.org/10.1111/j.1365-2745.2001.00615.x&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+translate_raster">translate_raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
landscape_classified &lt;- classify_habitats(terra::rast(landscape), n = 5, style = "fisher")
landscape_random &lt;- randomize_raster(landscape_classified, n_random = 19)

## End(Not run)

</code></pre>

<hr>
<h2 id='reconstruct_algorithm'>reconstruct_algorithm</h2><span id='topic+reconstruct_algorithm'></span>

<h3>Description</h3>

<p>Pattern reconstruction (internal)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct_algorithm(
  pattern,
  method,
  n_random,
  e_threshold,
  max_runs,
  no_change,
  annealing,
  weights,
  r_length,
  r_max,
  stoyan,
  verbose,
  plot
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconstruct_algorithm_+3A_pattern">pattern</code></td>
<td>
<p>ppp object with pattern.</p>
</td></tr>
<tr><td><code id="reconstruct_algorithm_+3A_n_random">n_random</code></td>
<td>
<p>Integer with number of randomizations.</p>
</td></tr>
<tr><td><code id="reconstruct_algorithm_+3A_e_threshold">e_threshold</code></td>
<td>
<p>Double with minimum energy to stop reconstruction.</p>
</td></tr>
<tr><td><code id="reconstruct_algorithm_+3A_max_runs">max_runs</code></td>
<td>
<p>Integer with maximum number of iterations if <code>e_threshold</code>
is not reached.</p>
</td></tr>
<tr><td><code id="reconstruct_algorithm_+3A_no_change">no_change</code></td>
<td>
<p>Integer with number of iterations at which the reconstruction will
stop if the energy does not decrease.</p>
</td></tr>
<tr><td><code id="reconstruct_algorithm_+3A_annealing">annealing</code></td>
<td>
<p>Double with probability to keep relocated point even if energy
did not decrease.</p>
</td></tr>
<tr><td><code id="reconstruct_algorithm_+3A_weights">weights</code></td>
<td>
<p>Vector with weights used to calculate energy.
The first number refers to Gest(r), the second number to pcf(r).</p>
</td></tr>
<tr><td><code id="reconstruct_algorithm_+3A_r_length">r_length</code></td>
<td>
<p>Integer with number of intervals from <code>r = 0</code> to <code>r = rmax</code> for which
the summary functions are evaluated.</p>
</td></tr>
<tr><td><code id="reconstruct_algorithm_+3A_r_max">r_max</code></td>
<td>
<p>Double with maximum distance used during calculation of summary functions. If <code>NULL</code>,
will be estimated from data.</p>
</td></tr>
<tr><td><code id="reconstruct_algorithm_+3A_stoyan">stoyan</code></td>
<td>
<p>Coefficient for Stoyan's bandwidth selection rule.</p>
</td></tr>
<tr><td><code id="reconstruct_algorithm_+3A_verbose">verbose</code></td>
<td>
<p>Logical if progress report is printed.</p>
</td></tr>
<tr><td><code id="reconstruct_algorithm_+3A_plot">plot</code></td>
<td>
<p>Logical if pcf(r) function is plotted and updated during optimization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='reconstruct_pattern'>reconstruct_pattern</h2><span id='topic+reconstruct_pattern'></span>

<h3>Description</h3>

<p>Pattern reconstruction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct_pattern(
  pattern,
  method = "homo",
  n_random = 1,
  e_threshold = 0.01,
  max_runs = 10000,
  no_change = Inf,
  annealing = 0.01,
  weights = c(1, 1),
  r_length = 255,
  r_max = NULL,
  stoyan = 0.15,
  return_input = TRUE,
  simplify = FALSE,
  verbose = TRUE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconstruct_pattern_+3A_pattern">pattern</code></td>
<td>
<p>ppp object with pattern.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_method">method</code></td>
<td>
<p>Character with specifying the method. Either <code>"homo"</code>,
<code>"cluster"</code> or <code>"hetero"</code>.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_n_random">n_random</code></td>
<td>
<p>Integer with number of randomizations.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_e_threshold">e_threshold</code></td>
<td>
<p>Double with minimum energy to stop reconstruction.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_max_runs">max_runs</code></td>
<td>
<p>Integer with maximum number of iterations if <code>e_threshold</code>
is not reached.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_no_change">no_change</code></td>
<td>
<p>Integer with number of iterations at which the reconstruction will
stop if the energy does not decrease.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_annealing">annealing</code></td>
<td>
<p>Double with probability to keep relocated point even if energy
did not decrease.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_weights">weights</code></td>
<td>
<p>Vector with weights used to calculate energy.
The first number refers to Gest(r), the second number to pcf(r).</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_r_length">r_length</code></td>
<td>
<p>Integer with number of intervals from <code>r=0</code> to <code>r=rmax</code> for which
the summary functions are evaluated.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_r_max">r_max</code></td>
<td>
<p>Double with maximum distance used during calculation of summary functions. If <code>NULL</code>,
will be estimated from data.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_stoyan">stoyan</code></td>
<td>
<p>Coefficient for Stoyan's bandwidth selection rule.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_return_input">return_input</code></td>
<td>
<p>Logical if the original input data is returned.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_simplify">simplify</code></td>
<td>
<p>Logical if only pattern will be returned if <code>n_random=1</code>
and <code>return_input=FALSE</code>.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_verbose">verbose</code></td>
<td>
<p>Logical if progress report is printed.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_+3A_plot">plot</code></td>
<td>
<p>Logical if pcf(r) function is plotted and updated during optimization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions randomizes the observed pattern by using pattern reconstruction
as described in Tscheschel &amp; Stoyan (2006) and Wiegand &amp; Moloney (2014). The
algorithm shifts a point to a new location and keeps the change only, if the
deviation between the observed and the reconstructed pattern decreases.
The pair correlation function and the nearest neighbour distance function are
used to describe the patterns.
</p>
<p>The reconstruction can be stopped automatically if for n steps the energy does not
decrease. The number of steps can be controlled by <code>no_change</code> and is set to
<code>no_change = Inf</code> as default to never stop automatically.
</p>
<p>The weights must be 0 &lt; sum(weights) &lt;= 1. To weight both summary functions identical,
use <code>weights = c(1, 1)</code>.
</p>
<p><code>spatstat</code> sets <code>r_length</code> to 513 by default. However, a lower value decreases
the computational time, while increasing the &quot;bumpiness&quot; of the summary function.
</p>
<p>The arguments <code>n_points</code> and <code>window</code> are used for <code>method="homo"</code> only.
</p>


<h4>method=&quot;homo&quot;:</h4>

<p>The algorithm starts with a random pattern.
</p>



<h4>method=&quot;cluster&quot;:</h4>

<p>The algorithm starts with a random but clustered pattern.
</p>



<h4>method=&quot;hetero&quot;:</h4>

<p>The algorithm starts with a random but heterogeneous pattern.
</p>



<h3>Value</h3>

<p>rd_pat
</p>


<h3>References</h3>

<p>Kirkpatrick, S., Gelatt, C.D.Jr., Vecchi, M.P., 1983. Optimization by simulated
annealing. Science 220, 671–680. &lt;https://doi.org/10.1126/science.220.4598.671&gt;
</p>
<p>Tscheschel, A., Stoyan, D., 2006. Statistical reconstruction of random point
patterns. Computational Statistics and Data Analysis 51, 859–871.
&lt;https://doi.org/10.1016/j.csda.2005.09.007&gt;
</p>
<p>Wiegand, T., Moloney, K.A., 2014. Handbook of spatial point-pattern analysis in
ecology. Chapman and Hall/CRC Press, Boca Raton. ISBN 978-1-4200-8254-8
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculate_energy">calculate_energy</a></code>,
<code><a href="#topic+reconstruct_pattern_marks">reconstruct_pattern_marks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pattern_recon &lt;- reconstruct_pattern(species_b, n_random = 19, max_runs = 1000)

## End(Not run)

</code></pre>

<hr>
<h2 id='reconstruct_pattern_marks'>reconstruct_pattern_marks</h2><span id='topic+reconstruct_pattern_marks'></span>

<h3>Description</h3>

<p>Pattern reconstruction of marked pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct_pattern_marks(
  pattern,
  marked_pattern,
  n_random = 1,
  e_threshold = 0.01,
  max_runs = 10000,
  no_change = Inf,
  annealing = 0.01,
  r_length = 250,
  r_max = NULL,
  return_input = TRUE,
  simplify = FALSE,
  verbose = TRUE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconstruct_pattern_marks_+3A_pattern">pattern</code></td>
<td>
<p>ppp object with pattern.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_marks_+3A_marked_pattern">marked_pattern</code></td>
<td>
<p>ppp  object with marked pattern. See Details section for more information.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_marks_+3A_n_random">n_random</code></td>
<td>
<p>Integer with number of randomizations.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_marks_+3A_e_threshold">e_threshold</code></td>
<td>
<p>Double with minimum energy to stop reconstruction.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_marks_+3A_max_runs">max_runs</code></td>
<td>
<p>Integer with maximum number of iterations if <code>e_threshold</code>
is not reached.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_marks_+3A_no_change">no_change</code></td>
<td>
<p>Integer with number of iterations at which the reconstruction will
stop if the energy does not decrease.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_marks_+3A_annealing">annealing</code></td>
<td>
<p>Double with probability to keep relocated point even if energy
did not decrease.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_marks_+3A_r_length">r_length</code></td>
<td>
<p>Integer with number of intervals from <code>r = 0</code> to <code>r = rmax</code> for which
the summary functions are evaluated.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_marks_+3A_r_max">r_max</code></td>
<td>
<p>Double with maximum distance used during calculation of summary functions. If <code>NULL</code>,
will be estimated from data.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_marks_+3A_return_input">return_input</code></td>
<td>
<p>Logical if the original input data is returned.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_marks_+3A_simplify">simplify</code></td>
<td>
<p>Logical if only pattern will be returned if <code>n_random = 1</code>
and <code>return_input = FALSE</code>.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_marks_+3A_verbose">verbose</code></td>
<td>
<p>Logical if progress report is printed.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_marks_+3A_plot">plot</code></td>
<td>
<p>Logical if pcf(r) function is plotted and updated during optimization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function randomizes the numeric marks of a point pattern using pattern reconstruction
as described in Tscheschel &amp; Stoyan (2006) and Wiegand &amp; Moloney (2014). Therefore,
an unmarked as well as a marked pattern must be provided. The unmarked pattern must have
the spatial characteristics and the same observation window and number of points
as the marked one (see <code>reconstruct_pattern_*</code> or <code><a href="#topic+fit_point_process">fit_point_process</a></code>).
Marks must be numeric because the mark-correlation function is used as summary function.
Two randomly chosen marks are switch each iterations and changes only kept if the
deviation between the observed and the reconstructed pattern decreases.
</p>
<p><code>spatstat</code> sets <code>r_length</code> to 513 by default. However, a lower value decreases
the computational time while increasing the &quot;bumpiness&quot; of the summary function.
</p>


<h3>Value</h3>

<p>rd_mar
</p>


<h3>References</h3>

<p>Kirkpatrick, S., Gelatt, C.D.Jr., Vecchi, M.P., 1983. Optimization by simulated
annealing. Science 220, 671–680. &lt;https://doi.org/10.1126/science.220.4598.671&gt;
</p>
<p>Tscheschel, A., Stoyan, D., 2006. Statistical reconstruction of random point
patterns. Computational Statistics and Data Analysis 51, 859–871.
&lt;https://doi.org/10.1016/j.csda.2005.09.007&gt;
</p>
<p>Wiegand, T., Moloney, K.A., 2014. Handbook of spatial point-pattern analysis in
ecology. Chapman and Hall/CRC Press, Boca Raton. ISBN 978-1-4200-8254-8
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_point_process">fit_point_process</a></code>,
<code><a href="#topic+reconstruct_pattern">reconstruct_pattern</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pattern_recon &lt;- reconstruct_pattern(species_a, n_random = 1, max_runs = 1000,
simplify = TRUE, return_input = FALSE)
marks_sub &lt;- spatstat.geom::subset.ppp(species_a, select = dbh)
marks_recon &lt;- reconstruct_pattern_marks(pattern_recon, marks_sub,
n_random = 19, max_runs = 1000)

## End(Not run)

</code></pre>

<hr>
<h2 id='reconstruct_pattern_multi'>reconstruct_pattern_multi</h2><span id='topic+reconstruct_pattern_multi'></span>

<h3>Description</h3>

<p>Pattern reconstruction of a pattern marked by multiple traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct_pattern_multi(
  marked_pattern,
  xr = marked_pattern$window$xrange,
  yr = marked_pattern$window$yrange,
  n_repetitions = 1,
  max_steps = 10000,
  no_change = 5,
  rcount = 250,
  rmax = 25,
  issue = 1000,
  divisor = "r",
  kernel_arg = "epanechnikov",
  timing = FALSE,
  energy_evaluation = FALSE,
  plot = FALSE,
  Lp = 1,
  bw = if (divisor %in% c("r", "d")) 0.5 else 5,
  sd = "step",
  steps_tol = 1000,
  tol = 1e-04,
  w_markcorr = c(d_d = 1, all = 1, d_all = 1, all_all = 1, d_d0 = 1, all0 = 1, d_all0 =
    1, all_all0 = 1),
  prob_of_actions = c(move_coordinate = 0.4, switch_coords = 0.1, exchange_mark_one =
    0.1, exchange_mark_two = 0.1, pick_mark_one = 0.2, pick_mark_two = 0.1),
  k = 1,
  w_statistics = c(),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconstruct_pattern_multi_+3A_marked_pattern">marked_pattern</code></td>
<td>
<p>ppp  object with marked pattern. See Details section
for more information.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_xr">xr</code>, <code id="reconstruct_pattern_multi_+3A_yr">yr</code></td>
<td>
<p>Maximum extent in x and y direction of observation window.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_n_repetitions">n_repetitions</code></td>
<td>
<p>Integer representing the number of simulations to be
performed.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_max_steps">max_steps</code></td>
<td>
<p>Maximum number simulation steps.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_no_change">no_change</code></td>
<td>
<p>Integer representing the number of iterations
(per 1000 simulation steps) after which the reconstruction is terminated if the
energy does not decrease.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_rcount">rcount</code></td>
<td>
<p>Integer representing the number of intervals for which the
summary statistics are evaluated.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_rmax">rmax</code></td>
<td>
<p>Maximum distance [m] up to which the summary statistics are
evaluated.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_issue">issue</code></td>
<td>
<p>Integer that determines after how many simulations steps an
output occurs.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_divisor">divisor</code></td>
<td>
<p>Choice of divisor in the estimation formula: either &quot;r&quot; or &quot;d&quot;.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_kernel_arg">kernel_arg</code></td>
<td>
<p>The kernel used to calculate the energy, possible kernels
can be: Gaussian, Epanechnikov, Rectangular, Cumulative.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_timing">timing</code></td>
<td>
<p>Logical value: The computation time is measured if this is TRUE.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_energy_evaluation">energy_evaluation</code></td>
<td>
<p>Logical value: If this is TRUE, the procedure stores
the energy shares of the total energy per simulation step.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_plot">plot</code></td>
<td>
<p>Logical value: If this is TRUE, the procedure records the
point pattern during optimization and updated.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_lp">Lp</code></td>
<td>
<p>Distance measure for the calculation of the energy function
(Lp distance, 1 &lt;= p &lt; Inf).</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_bw">bw</code></td>
<td>
<p>Bandwidth [m] with which the kernels are scaled, so that this is
the standard deviation of the smoothing kernel.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_sd">sd</code></td>
<td>
<p>This is the standard deviation [m] used in the move_coordinate action.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_steps_tol">steps_tol</code></td>
<td>
<p>After the value steps_tol it is checked whether the energy
change is smaller than tol.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_tol">tol</code></td>
<td>
<p>Stops the procedure of energy if more than 1 - tol times no changes.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_w_markcorr">w_markcorr</code></td>
<td>
<p>Vector of possible weightings of individual mcf's. (Default: all equal).</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_prob_of_actions">prob_of_actions</code></td>
<td>
<p>Vector of probabilities for the actions performed.
<code>c(move_coordinate = 0.4, switch_coords = 0.1, exchange_mark_one = 0.1,
exchange_mark_two = 0.1, pick_mark_one = 0.2, pick_mark_two = 0.1)</code>.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_k">k</code></td>
<td>
<p>Vector of values k; used only if Dk is included in w_statistics.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_w_statistics">w_statistics</code></td>
<td>
<p>vector of named weights for optional spatial statistics
from the <code>spatstat</code> package to be included in the energy calculation. This may
include Dk, K, Hs, pcf.</p>
</td></tr>
<tr><td><code id="reconstruct_pattern_multi_+3A_verbose">verbose</code></td>
<td>
<p>Logical if progress report is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A novel approach carries out a pattern reconstruction of marked dot patterns
as described by Tscheschel and Stoyan (2006) and Wiegand and Moloney (2014).
</p>
<p>One particular feature is the simultaneous consideration of both marks,
accounting for their correlation during reconstruction.
</p>
<p>The marked point pattern (PPP object) must is currently structured as follows:
X-coordinate, Y-coordinate, metric mark (e.g. diameter at breast height),
and nominal mark (e.g. tree species).It is calculated in the unit metre [m].
</p>
<p>A combination of the mark correlation function and pair correlation function
is used for pattern description. Additional summary statistics may be
considered.Two randomly selected marks are chosen in each iteration, and one
of various actions is performed. Changes will only be retained if the
difference between the observed and reconstructed pattern decreases
(minimizing energy).
</p>
<p>This method is currently only suitable for homogeneous point patterns.
</p>
<p>A comprehensive description of the method can be found in Wudel et al. (2023).
</p>


<h3>Value</h3>

<p>rd_multi
</p>


<h3>References</h3>

<p>Kirkpatrick, S., Gelatt, C.D.Jr., Vecchi, M.P., 1983. Optimization by simulated
annealing. Science 220, 671–680. &lt;https://doi.org/10.1126/science.220.4598.671&gt;
</p>
<p>Tscheschel, A., Stoyan, D., 2006. Statistical reconstruction of random point
patterns. Computational Statistics and Data Analysis 51, 859–871.
&lt;https://doi.org/10.1016/j.csda.2005.09.007&gt;
</p>
<p>Wiegand, T., Moloney, K.A., 2014. Handbook of spatial point-pattern analysis in
ecology. Chapman and Hall/CRC Press, Boca Raton. ISBN 978-1-4200-8254-8
</p>
<p>Wudel, C., Schlicht, R., &amp; Berger, U. (2023). Multi-trait point pattern
reconstruction of plant ecosystems. Methods in Ecology and Evolution, 14, 2668–2679.
https://doi.org/10.1111/2041-210X.14206
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_point_process">fit_point_process</a></code>,
<code><a href="#topic+reconstruct_pattern">reconstruct_pattern</a></code>,
<code><a href="#topic+reconstruct_pattern_marks">reconstruct_pattern_marks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Random example data set
xr &lt;- 500
yr &lt;- 1000
N &lt;- 400
y &lt;- runif(N, min = 0, max = yr)
x &lt;- runif(N, min = 0, max = xr)

species &lt;- sample(c("A","B"), N, replace = TRUE)
diameter &lt;- runif(N, 0.1, 0.4)

random &lt;- data.frame(x = x, y = y, dbh = diameter, species = factor(species))

marked_pattern &lt;- spatstat.geom::as.ppp(random, W = spatstat.geom::owin(c(0, xr), c(0, yr)))

# Reconstruction function
reconstruction &lt;- reconstruct_pattern_multi(marked_pattern, n_repetitions = 2,
max_steps = 10000)

## End(Not run)

</code></pre>

<hr>
<h2 id='results_habitat_association'>results_habitat_association</h2><span id='topic+results_habitat_association'></span>

<h3>Description</h3>

<p>Results habitat association
</p>


<h3>Usage</h3>

<pre><code class='language-R'>results_habitat_association(
  pattern,
  raster,
  significance_level = 0.05,
  breaks = NULL,
  digits = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="results_habitat_association_+3A_pattern">pattern</code></td>
<td>
<p>ppp object with original point pattern data or rd_pat or rd_mar
object with randomized point pattern.</p>
</td></tr>
<tr><td><code id="results_habitat_association_+3A_raster">raster</code></td>
<td>
<p>SpatRaster with original discrete habitat data or rd_ras object with
randomized environmental data.</p>
</td></tr>
<tr><td><code id="results_habitat_association_+3A_significance_level">significance_level</code></td>
<td>
<p>Double with significance level.</p>
</td></tr>
<tr><td><code id="results_habitat_association_+3A_breaks">breaks</code></td>
<td>
<p>Vector with breaks of habitat classes.</p>
</td></tr>
<tr><td><code id="results_habitat_association_+3A_digits">digits</code></td>
<td>
<p>Integer with digits used during rounding.</p>
</td></tr>
<tr><td><code id="results_habitat_association_+3A_verbose">verbose</code></td>
<td>
<p>Logical if messages should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions shows significant habitat associations by comparing the number of
points within a habitat between the observed data and randomized data as described in
Plotkin et al. (2000) and Harms et al. (2001). Significant positive or associations are present
if the observed count in a habitat is above or below a certain threshold of the
randomized count, respectively.
</p>
<p>In case the SpatRaster contains NA cells, this needs to be reflected in the observation
window of the point pattern as well (i.e., no point locations possible in these areas).
</p>
<p>If <code>breaks = NULL</code> (default), only habitat labels (but not breaks) will be
returned. If a vector with <code>breaks</code> is provided (same order as increasing habitat values),
the breaks will be included as well.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>References</h3>

<p>Harms, K.E., Condit, R., Hubbell, S.P., Foster, R.B., 2001. Habitat associations of
trees and shrubs in a 50-ha neotropical forest plot. Journal of Ecology 89, 947–959.
&lt;https://doi.org/10.1111/j.1365-2745.2001.00615.x&gt;
</p>
<p>Plotkin, J.B., Potts, M.D., Leslie, N., Manokaran, N., LaFrankie, J.V.,
Ashton, P.S., 2000. Species-area curves, spatial aggregation, and habitat specialization
in tropical forests. Journal of Theoretical Biology 207, 81–99.
&lt;https://doi.org/10.1006/jtbi.2000.2158&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconstruct_pattern">reconstruct_pattern</a></code>,
<code><a href="#topic+fit_point_process">fit_point_process</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landscape_classified &lt;- classify_habitats(terra::rast(landscape), n = 5, style = "fisher")
species_a_random &lt;- fit_point_process(species_a, n_random = 199)
results_habitat_association(pattern = species_a_random, raster = landscape_classified)

</code></pre>

<hr>
<h2 id='sample_randomized'>sample_randomized</h2><span id='topic+sample_randomized'></span>

<h3>Description</h3>

<p>Sample randomized list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_randomized(randomized, n = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_randomized_+3A_randomized">randomized</code></td>
<td>
<p>List with randomized raster or patterns.</p>
</td></tr>
<tr><td><code id="sample_randomized_+3A_n">n</code></td>
<td>
<p>Integer with number or vector of ids of randomized pattern to plot.</p>
</td></tr>
<tr><td><code id="sample_randomized_+3A_verbose">verbose</code></td>
<td>
<p>Logical if progress report is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Get list with <code>n</code> randomized raster or patterns. If <code>n</code> is a single number,
<code>n</code> randomized elements will be sampledt. If <code>n</code> is a vector, the
corresponding elements will be returned.
</p>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sample_randomized(randomized = reconstruction$randomized, n = c(5, 10, 15))

## End(Not run)

</code></pre>

<hr>
<h2 id='select_kernel'>select_kernel</h2><span id='topic+select_kernel'></span>

<h3>Description</h3>

<p>Kernel selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_kernel(kernel_arg, bw, rmax, divisor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_kernel_+3A_kernel_arg">kernel_arg</code></td>
<td>
<p>Parameter of the function
reconstruct_pattern_multi_trait_marks, specifies the kernel to be used to
calculate the energy, possible kernels can be: Gaussian, Epanechnikov,
Rectangular, Cumulative.</p>
</td></tr>
<tr><td><code id="select_kernel_+3A_bw">bw</code></td>
<td>
<p>Bandwidth with which the kernels are scaled, so that this is the
standard deviation of the smoothing kernel.</p>
</td></tr>
<tr><td><code id="select_kernel_+3A_rmax">rmax</code></td>
<td>
<p>Maximum distance at which the summary statistics are evaluated.</p>
</td></tr>
<tr><td><code id="select_kernel_+3A_divisor">divisor</code></td>
<td>
<p>Divisor in the smoothing kernel, d or r.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the function of the selected kernel, which is then used to
calculate the kernel.
</p>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='species_a'>Species a</h2><span id='topic+species_a'></span>

<h3>Description</h3>

<p>A species with negative associations to habitat 4 of <code>landscape</code>. Please be
aware that a negative association to one habitat will inevitable lead to positive
associations to other habitats (Yamada et al. 2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_a
</code></pre>


<h3>Format</h3>

<p>A spatstat ppp object.
</p>


<h3>References</h3>

<p>Yamada, T., Tomita, A., Itoh, A., Yamakura, T., Ohkubo, T., Kanzaki, M., Tan, S.,
Ashton, P.S., 2006. Habitat associations of Sterculiaceae trees in a Bornean rain
forest plot. Journal of Vegetation Science 17, 559–566.
</p>

<hr>
<h2 id='species_b'>Species b</h2><span id='topic+species_b'></span>

<h3>Description</h3>

<p>A species with positive associations to habitat 5 of <code>landscape</code>. Please be
aware that a positive association to one habitat will inevitable lead to negative
associations to other habitats (Yamada et al. 2006)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_b
</code></pre>


<h3>Format</h3>

<p>A spatstat ppp object.
</p>


<h3>References</h3>

<p>Yamada, T., Tomita, A., Itoh, A., Yamakura, T., Ohkubo, T., Kanzaki, M., Tan, S.,
Ashton, P.S., 2006. Habitat associations of Sterculiaceae trees in a Bornean rain
forest plot. Journal of Vegetation Science 17, 559–566.
</p>

<hr>
<h2 id='to_dummy'>dummy_transf</h2><span id='topic+to_dummy'></span>

<h3>Description</h3>

<p>Tranfsorm to dummy variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_dummy(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_dummy_+3A_f">f</code></td>
<td>
<p>Result of the calc_moments_full function which represents
product-moment contribution of a point at coordinates x, y with marks,
for the whole point pattern.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for the transformation of variables to dummy variables and back
</p>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='translate_raster'>translate_raster</h2><span id='topic+translate_raster'></span>

<h3>Description</h3>

<p>Torus translation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_raster(
  raster,
  steps_x = NULL,
  steps_y = NULL,
  return_input = TRUE,
  simplify = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translate_raster_+3A_raster">raster</code></td>
<td>
<p>SpatRaster with discrete habitat classes.</p>
</td></tr>
<tr><td><code id="translate_raster_+3A_steps_x">steps_x</code>, <code id="translate_raster_+3A_steps_y">steps_y</code></td>
<td>
<p>Integer with number of steps (cells) the raster is translated
into the corresponding direction. If both are null, all possible combinations are used
resulting in n = ((50 + 1) * (50 + 1)) - 4 rasters.</p>
</td></tr>
<tr><td><code id="translate_raster_+3A_return_input">return_input</code></td>
<td>
<p>Logical if the original input data is returned.</p>
</td></tr>
<tr><td><code id="translate_raster_+3A_simplify">simplify</code></td>
<td>
<p>Logical if only the raster will be returned if <code>n_random = 1</code>
and <code>return_input = FALSE</code>.</p>
</td></tr>
<tr><td><code id="translate_raster_+3A_verbose">verbose</code></td>
<td>
<p>Logical if progress report is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Torus translation test as described in Harms et al. (2001). The raster is shifted
in all four cardinal directions by steps equal to the raster resolution. If a cell
exits the extent on one side, it enters the extent on the opposite side.
</p>
<p>The method does not allow any NA values to be present in the SpatRaster.
</p>


<h3>Value</h3>

<p>rd_ras
</p>


<h3>References</h3>

<p>Harms, K.E., Condit, R., Hubbell, S.P., Foster, R.B., 2001. Habitat associations
of trees and shrubs in a 50-ha neotropical forest plot. Journal of Ecology 89, 947–959.
&lt;https://doi.org/10.1111/j.1365-2745.2001.00615.x&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomize_raster">randomize_raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
landscape_classified &lt;- classify_habitats(terra::rast(landscape), n = 5, style = "fisher")

landscape_random &lt;- translate_raster(landscape_classified)
landscape_random_sub &lt;- translate_raster(landscape_classified,
steps_x = 1:10, steps_y = 1:5)

## End(Not run)

</code></pre>

<hr>
<h2 id='unpack_randomized'>unpack_randomized</h2><span id='topic+unpack_randomized'></span>

<h3>Description</h3>

<p>Load randomized raster object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_randomized(raster)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unpack_randomized_+3A_raster">raster</code></td>
<td>
<p>rd_ras object with randomized raster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because of how SpatRaster are saved (need to be packed), this function allows to
unpack previously packed raster objects that were saved using <code>pack_randomized</code>.
For further details, see <code>wrap</code>.
</p>


<h3>Value</h3>

<p>rd_ras
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pack_randomized">pack_randomized</a></code>
<code><a href="terra.html#topic+wrap">wrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
landscape_classified &lt;- classify_habitats(terra::rast(landscape), n = 5, style = "fisher")
landscape_random &lt;- randomize_raster(landscape_classified, n_random = 3)
x &lt;- pack_randomized(raster = landscape_random)
y &lt;- unpack_randomized(raster = y)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
