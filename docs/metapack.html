<!DOCTYPE html><html lang="en"><head><title>Help for package metapack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metapack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayes_nmr'><p>Fit Bayesian Network Meta-Regression Models</p></a></li>
<li><a href='#bayes_parobs'><p>Fit Bayesian Inference for Meta-Regression</p></a></li>
<li><a href='#bmeta_analyze'><p>bmeta_analyze supersedes the previous two functions: bayes_parobs, bayes_nmr</p></a></li>
<li><a href='#cholesterol'><p>26 double-blind, randomized, active, or placebo-controlled clinical trials on patients with primary hypercholesterolemia sponsored by Merck &amp; Co., Inc., Kenilworth, NJ, USA.</p></a></li>
<li><a href='#coef.bsynthesis'><p>get the posterior mean of fixed-effect coefficients</p></a></li>
<li><a href='#fitted.bayesnmr'><p>get fitted values</p></a></li>
<li><a href='#fitted.bayesparobs'><p>get fitted values</p></a></li>
<li><a href='#hpd'><p>get the highest posterior density (HPD) interval</p></a></li>
<li><a href='#hpd.bayesnmr'><p>get the highest posterior density (HPD) interval</p></a></li>
<li><a href='#hpd.bayesparobs'><p>get the highest posterior density (HPD) interval or equal-tailed credible interval</p></a></li>
<li><a href='#metapack'><p>metapack: a package for Bayesian meta-analysis and network meta-analysis</p></a></li>
<li><a href='#model_comp'><p>compute the model comparison measures: DIC, LPML, or Pearson's residuals</p></a></li>
<li><a href='#model_comp.bayesnmr'><p>get compute the model comparison measures</p></a></li>
<li><a href='#model_comp.bayesparobs'><p>compute the model comparison measures</p></a></li>
<li><a href='#ns'><p>helper function encoding trial sample sizes in formulas</p></a></li>
<li><a href='#plot.bayesnmr'><p>get goodness of fit</p></a></li>
<li><a href='#plot.bayesparobs'><p>get goodness of fit</p></a></li>
<li><a href='#plot.sucra'><p>plot the surface under the cumulative ranking curve (SUCRA)</p></a></li>
<li><a href='#print.bayesnmr'><p>Print results</p></a></li>
<li><a href='#print.bayesparobs'><p>Print results</p></a></li>
<li><a href='#sucra'><p>get surface under the cumulative ranking curve (SUCRA)</p></a></li>
<li><a href='#sucra.bayesnmr'><p>get surface under the cumulative ranking curve (SUCRA)</p></a></li>
<li><a href='#summary.bayesnmr'><p>'summary' method for class &quot;'bayesnmr'&quot;</p></a></li>
<li><a href='#summary.bayesparobs'><p><code>summary</code> method for class &quot;<code>bayesparobs</code>&quot;</p></a></li>
<li><a href='#TNM'><p>Triglycerides Network Meta (TNM) data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Meta-Analysis and Network Meta-Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-14</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions performing Bayesian inference for meta-analytic and network meta-analytic models through Markov chain Monte Carlo algorithm. Currently, the package implements Hui Yao, Sungduk Kim, Ming-Hui Chen, Joseph G. Ibrahim, Arvind K. Shah, and Jianxin Lin (2015) &lt;<a href="https://doi.org/10.1080%2F01621459.2015.1006065">doi:10.1080/01621459.2015.1006065</a>&gt; and Hao Li, Daeyoung Lim, Ming-Hui Chen, Joseph G. Ibrahim, Sungduk Kim, Arvind K. Shah, Jianxin Lin (2021) &lt;<a href="https://doi.org/10.1002%2Fsim.8983">doi:10.1002/sim.8983</a>&gt;. For maximal computational efficiency, the Markov chain Monte Carlo samplers for each model, written in C++, are fine-tuned. This software has been developed under the auspices of the National Institutes of Health and Merck &amp; Co., Inc., Kenilworth, NJ, USA.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, ggplot2, methods, gridExtra, Formula</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress, BH</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://events.stat.uconn.edu/metapack/">https://events.stat.uconn.edu/metapack/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/daeyounglim/metapack/issues">https://github.com/daeyounglim/metapack/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 17:06:22 UTC; daeyounglim</td>
</tr>
<tr>
<td>Author:</td>
<td>Daeyoung Lim [aut, cre],
  Ming-Hui Chen [ctb],
  Sungduk Kim [ctb],
  Joseph Ibrahim [ctb],
  Arvind Shah [ctb],
  Jianxin Lin [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daeyoung Lim &lt;Daeyoung.Lim@fda.hhs.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayes_nmr'>Fit Bayesian Network Meta-Regression Models</h2><span id='topic+bayes_nmr'></span>

<h3>Description</h3>

<p>This is a function the fits the model introduced in <em>Bayesian Network Meta-Regression Models Using Heavy-Tailed Multivariate Random Effects with Covariate-Dependent Variances</em>. The first seven arguments are required except <code>ZCovariate</code>. If not provided, <code>ZCovariate</code> will be assigned a vector of ones, <code>rep(1, length(Outcome))</code>. <code>ZCovariate</code> is the centerpiece of the modeling of variances and the heavy-tailed random effects distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes_nmr(
  Outcome,
  SD,
  XCovariate,
  ZCovariate,
  Treat,
  Trial,
  Npt,
  prior = list(),
  mcmc = list(),
  control = list(),
  init = list(),
  Treat_order = NULL,
  Trial_order = NULL,
  scale_x = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayes_nmr_+3A_outcome">Outcome</code></td>
<td>
<p>the aggregate mean of the responses for each arm of every study.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_sd">SD</code></td>
<td>
<p>the standard deviation of the responses for each arm of every study.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_xcovariate">XCovariate</code></td>
<td>
<p>the aggregate covariates for the fixed effects.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_zcovariate">ZCovariate</code></td>
<td>
<p>the aggregate covariates associated with the variance of the random effects.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_treat">Treat</code></td>
<td>
<p>the treatment identifiers for trial arm. This is equivalent to the arm labels in each study. The elements within will be coerced to consecutive integers</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_trial">Trial</code></td>
<td>
<p>the study/trial identifiers. The elements within will be coerced to consecutive integers.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_npt">Npt</code></td>
<td>
<p>the number of observations/participants for a unique <code style="white-space: pre;">&#8288;(k,t)&#8288;</code>, or each arm of every trial.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_prior">prior</code></td>
<td>
<p>(Optional) a list of hyperparameters. The hyperparameters include <code>df</code>, <code>c01</code>, <code>c02</code>, <code>a4</code>, <code>b4</code>, <code>a5</code>, and <code>b5</code>. <code>df</code> indicates the degrees of freedom whose value is 20. The hyperparameters <code style="white-space: pre;">&#8288;a*&#8288;</code> and <code style="white-space: pre;">&#8288;b*&#8288;</code> will take effect only if <code>sample_df=TRUE</code>. See <code>control</code>.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_mcmc">mcmc</code></td>
<td>
<p>(Optional) a list of MCMC specification. <code>ndiscard</code> is the number of burn-in iterations. <code>nskip</code> configures the thinning of the MCMC. For instance, if <code>nskip=5</code>, <code>bayes_nmr</code> will save the posterior sample every 5 iterations. <code>nkeep</code> is the size of the posterior sample. The total number of iterations will be <code>ndiscard + nskip * nkeep</code>.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_control">control</code></td>
<td>
<p>(Optional) a list of parameters for <a href="https://en.wikipedia.org/wiki/Metropolis-Hastings_algorithm">the Metropolis-Hastings algorithm</a>. <code>lambda</code>, <code>phi</code>, and <code>Rho</code> are sampled through the localized Metropolis algorithm. <code style="white-space: pre;">&#8288;*_stepsize&#8288;</code> with the asterisk replaced with one of the names above specifies the stepsize for determining the sample evaluation points in the localized Metropolis algorithm. <code>sample_Rho</code> can be set to <code>FALSE</code> to suppress the sampling of <code>Rho</code>. When <code>sample_Rho</code> is <code>FALSE</code>, <code>Rho</code> will be fixed using the value given by the <code>init</code> argument, which defaults to an equicorrelation matrix of <code class="reqn">0.5\boldsymbol{I}+0.5\boldsymbol{1}\boldsymbol{1}^\prime</code> where <code class="reqn">\boldsymbol{1}</code> is the vector of ones. When <code>sample_df</code> is <code>TRUE</code>, <code>df</code> will be sampled.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_init">init</code></td>
<td>
<p>(Optional) a list of initial values for the parameters to be sampled: <code>theta</code>, <code>phi</code>, <code>sig2</code>, and <code>Rho</code>.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_treat_order">Treat_order</code></td>
<td>
<p>(Optional) a vector of unique treatments to be used for renumbering the <code>Treat</code> vector. The first element will be assigned treatment zero, potentially indicating placebo. If not provided, the numbering will default to an alphabetical/numerical order.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_trial_order">Trial_order</code></td>
<td>
<p>(Optional) a vector unique trials. The first element will be assigned trial zero. If not provided, the numbering will default to an alphabetical/numerical order.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_scale_x">scale_x</code></td>
<td>
<p>(Optional) a logical variable indicating whether <code>XCovariate</code> should be scaled/standardized. The effect of setting this to <code>TRUE</code> is not limited to merely standardizing <code>XCovariate</code>. The following generic functions will scale the posterior sample of <code>theta</code> back to its original unit: <code>plot</code>, <code>fitted</code>, <code>summary</code>, and <code>print</code>. That is <code>theta[j] &lt;- theta[j] / sd(XCovariate[,j])</code>.</p>
</td></tr>
<tr><td><code id="bayes_nmr_+3A_verbose">verbose</code></td>
<td>
<p>(Optional) a logical value indicating whether to print the progress bar during the MCMC sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bayes_nmr</code> returns an object of class <code>"bayesnmr"</code>. The functions <code>summary</code> or <code>print</code> are used to obtain and print a summary of the results. The generic accessor function <code>fitted</code> extracts the posterior mean, posterior standard deviation, and the interval estimates of the value returned by <code>bayes_nmr</code>.
</p>
<p>An object of class <code>bayesnmr</code> is a list containing the following components:
</p>

<ul>
<li> <p><code>Outcome</code> - the aggregate response used in the function call.
</p>
</li>
<li> <p><code>SD</code> - the standard deviation used in the function call.
</p>
</li>
<li> <p><code>Npt</code> - the number of participants for <code style="white-space: pre;">&#8288;(k,t)&#8288;</code> used in the function call.
</p>
</li>
<li> <p><code>XCovariate</code> - the aggregate design matrix for fixed effects used in the function call. Depending on <code>scale_x</code>, this may differ from the matrix provided at function call.
</p>
</li>
<li> <p><code>ZCovariate</code> - the aggregate design matrix for random effects. <code>bayes_nmr</code> will assign <code>rep(1, length(Outcome))</code> if it was not provided at function call.
</p>
</li>
<li> <p><code>Trial</code> - the <em>renumbered</em> trial indicators. Depending on <code>Trial_order</code>, it may differ from the vector provided at function call.
</p>
</li>
<li> <p><code>Treat</code> - the <em>renumbered</em> treatment indicators. Depending on <code>Treat_order</code>, it may differ from the vector provided at function call.
</p>
</li>
<li> <p><code>TrtLabels</code> - the vector of treatment labels corresponding to the renumbered <code>Treat</code>. This is equivalent to <code>Treat_order</code> if it was given at function call.
</p>
</li>
<li> <p><code>TrialLabels</code> - the vector of trial labels corresponding to the renumbered <code>Trial</code>. This is equivalent to <code>Trial_order</code> if it was given at function call.
</p>
</li>
<li> <p><code>K</code> - the total number of trials.
</p>
</li>
<li> <p><code>nT</code> - the total number of treatments.
</p>
</li>
<li> <p><code>scale_x</code> - a Boolean indicating whether <code>XCovariate</code> has been scaled/standardized.
</p>
</li>
<li> <p><code>prior</code> - the list of hyperparameters used in the function call.
</p>
</li>
<li> <p><code>control</code> - the list of tuning parameters used for MCMC in the function call.
</p>
</li>
<li> <p><code>mcmctime</code> - the elapsed time for the MCMC algorithm in the function call. This does not include all the other preprocessing and post-processing outside of MCMC.
</p>
</li>
<li> <p><code>mcmc</code> - the list of MCMC specification used in the function call.
</p>
</li>
<li> <p><code>mcmc.draws</code> - the list containing the MCMC draws. The posterior sample will be accessible here.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daeyoung Lim, <a href="mailto:daeyoung.lim@uconn.edu">daeyoung.lim@uconn.edu</a>
</p>


<h3>References</h3>

<p>Li, H., Chen, M. H., Ibrahim, J. G., Kim, S., Shah, A. K., Lin, J., &amp; Tershakovec, A. M. (2019). Bayesian inference for network meta-regression using multivariate random effects with applications to cholesterol lowering drugs. <em>Biostatistics</em>, <strong>20(3)</strong>, 499-516.
</p>
<p>Li, H., Lim, D., Chen, M. H., Ibrahim, J. G., Kim, S., Shah, A. K., &amp; Lin, J. (2021). Bayesian network meta-regression hierarchical models using heavy-tailed multivariate random effects with covariate-dependent variances. <em>Statistics in Medicine</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bmeta_analyze">bmeta_analyze</a></code> for using the <code><a href="Formula.html#topic+Formula">Formula</a></code> interface
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(metapack)
data(TNM)
groupInfo &lt;- list(c("PBO"), c("R"))
nz &lt;- length(groupInfo)
ns &lt;- nrow(TNM)
XCovariate &lt;- model.matrix(~ 0 + bldlc + bhdlc + btg + age +
 white + male + bmi + potencymed + potencyhigh + durat, data = TNM)
XCovariate &lt;- scale(XCovariate, center = TRUE, scale = FALSE)
ZCovariate &lt;- matrix(0, ns, nz)
for (j in 1:length(groupInfo)) {
    for (i in 1:ns) {
        if (TNM$treat[i] %in% groupInfo[[j]]) {
            ZCovariate[i, j] &lt;- 1
        }
    }
}
addz &lt;- scale(cbind(TNM$bldlc, TNM$btg), center=TRUE, scale=TRUE)
ZCovariate &lt;- cbind(1, ZCovariate, addz)
theta_init &lt;- c(0.05113, -1.38866, 1.09817, -0.85855, -1.12056, -1.14133,
             -0.22435, 3.63453, -2.09322, 1.07858, 0.80566, -40.76753,
             -45.07127, -28.27232, -44.14054, -28.13203, -19.19989,
             -47.21824, -51.31234, -48.46266, -47.71443)
set.seed(2797542)
fit &lt;- bayes_nmr(TNM$ptg, TNM$sdtg, XCovariate, ZCovariate, TNM$treat,
    TNM$trial, TNM$n, prior = list(c01 = 1.0e05, c02 = 4, df = 3),
    mcmc = list(ndiscard = 1, nskip = 1, nkeep = 1),
    init = list(theta = theta_init),
    Treat_order = c("PBO", "S", "A", "L", "R", "P", "E", "SE",
         "AE", "LE", "PE"),
    scale_x = TRUE, verbose = FALSE)
</code></pre>

<hr>
<h2 id='bayes_parobs'>Fit Bayesian Inference for Meta-Regression</h2><span id='topic+bayes_parobs'></span>

<h3>Description</h3>

<p>This is a function for running the Markov chain Monte Carlo algorithm for the <em>Bayesian inference for multivariate meta-regression with a partially observed within-study sample covariance matrix</em> model. The first six arguments are required.
fmodel can be one of 5 numbers: 1, 2, 3, 4, and 5. The first model, fmodel = 1 denoted by M1, indicates that the <code class="reqn">\Sigma_{kt}</code>
are diagonal matrices with zero covariances. M2 indicates that <code class="reqn">\Sigma_{kt}</code> are all equivalent but allowed to be full symmetric
positive definite. M3 is where <code class="reqn">\Sigma_{kt}</code> are allowed to differ across treatments, i.e., <code class="reqn">\Sigma_{kt}=\Sigma_t</code>.
M4 assumes thata the correlation matrix, <code class="reqn">\rho</code>, is identical for all trials/treatments, but the variances are allowed to vary.
Finally, M5 assumes a hierarchical model where <code class="reqn">(\Sigma_{kt} | \Sigma)</code> follows an inverse-Wishart distribution with fixed
degrees of freedom and scale matrix <code class="reqn">\Sigma</code>. <code class="reqn">\Sigma</code> then follows another inverse-Wishart distribution with fixed parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes_parobs(
  Outcome,
  SD,
  XCovariate,
  WCovariate,
  Treat,
  Trial,
  Npt,
  fmodel = 1,
  prior = list(),
  mcmc = list(),
  control = list(),
  init = list(),
  Treat_order = NULL,
  Trial_order = NULL,
  group = NULL,
  group_order = NULL,
  scale_x = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayes_parobs_+3A_outcome">Outcome</code></td>
<td>
<p>the aggregate mean of the responses for each arm of every study.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_sd">SD</code></td>
<td>
<p>the standard deviation of the responses for each arm of every study.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_xcovariate">XCovariate</code></td>
<td>
<p>the aggregate covariates for the fixed effects.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_wcovariate">WCovariate</code></td>
<td>
<p>the aggregate covariates for the random effects.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_treat">Treat</code></td>
<td>
<p>the treatment identifiers. This is equivalent to the arm number of each study. The number of unique treatments must be equal across trials. The elements within will be coerced to consecutive integers.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_trial">Trial</code></td>
<td>
<p>the trial identifiers. This is equivalent to the arm labels in each study. The elements within will be coerced to consecutive integers</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_npt">Npt</code></td>
<td>
<p>the number of observations/participants for a unique <code style="white-space: pre;">&#8288;(k,t)&#8288;</code>, or each arm of every trial.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_fmodel">fmodel</code></td>
<td>
<p>the model number. The possible values for <code>fmodel</code> are 1 to 5, each indicating a different prior specification for <code class="reqn">\Sigma_{kt}</code>. It will default to M1, <code>fmodel=1</code> if not specified at function call. See the following model descriptions. The objects enclosed in parentheses at the end of every bullet point are the hyperparameters associated with each model.
</p>

<ul>
<li> <p><code>fmodel=1</code> - <code class="reqn">\Sigma_{kt} = diag(\sigma_{kt,11}^2,\ldots,\sigma_{kt,JJ}^2)</code> where <code class="reqn">\sigma_{kt,jj}^2 \sim IG(a_0,b_0)</code> and <code class="reqn">IG(a,b)</code> is <a href="https://en.wikipedia.org/wiki/Inverse-gamma_distribution">the inverse-gamma distribution</a>. This specification is useful if the user does not care about the correlation recovery. (<code>c0</code>, <code>dj0</code>, <code>a0</code>, <code>b0</code>, <code>Omega0</code>)
</p>
</li>
<li> <p><code>fmodel=2</code> - <code class="reqn">\Sigma_{kt}=\Sigma</code> for every combination of <code class="reqn">(k,t)</code> and <code class="reqn">\Sigma^{-1}\sim Wish_{s_0}(\Sigma_0)</code>. This specification assumes that the user has prior knowledge that the correlation structure does not change across the arms included. (<code>c0</code>, <code>dj0</code>, <code>s0</code>, <code>Omega0</code>, <code>Sigma0</code>)
</p>
</li>
<li> <p><code>fmodel=3</code> - <code class="reqn">\Sigma_{kt}=\Sigma_t</code> and <code class="reqn">\Sigma_t^{-1}\sim  Wish_{s_0}(\Sigma_0)</code>. This is a relaxed version of <code>fmodel=2</code>, allowing the correlation structure to differ across trials but forcing it to stay identical within a trial. (<code>c0</code>, <code>dj0</code>, <code>s0</code>, <code>Omega0</code>, <code>Sigma0</code>)
</p>
</li>
<li> <p><code>fmodel=4</code> - <code class="reqn">\Sigma_{kt}=\delta_{kt} \rho \delta_{kt}</code> where <code class="reqn">\delta_{kt}=diag(\Sigma_{kt,11}^{1/2},\ldots,\Sigma_{kt,JJ}^{1/2})</code>, and <code class="reqn">\rho</code> is the correlation matrix. This specification allows the variances to vary across arms but requires that the correlations be the same. This is due to the lack of correlation information in the data, which would in turn lead to the nonidentifiability of the correlations if they were allowed to vary. However, this still is an ambitious model which permits maximal degrees of freedom in terms of variance and correlation estimation. (<code>c0</code>, <code>dj0</code>, <code>a0</code>, <code>b0</code>, <code>Omega0</code>)
</p>
</li>
<li> <p><code>fmodel=5</code> - The fifth model is hierarchical and thus may require more data than the others: <code class="reqn">(\Sigma_{kt}^{-1}\mid \Sigma)\sim  Wish_{\nu_0}((\nu_0-J-1)^{-1}\Sigma^{-1})</code> and <code class="reqn">\Sigma \sim  Wish_{d_0}(\Sigma_0)</code>. <code class="reqn">\Sigma_{kt}</code> encodes the within-treatment-arm variation while <code class="reqn">\Sigma</code> captures the between-treatment-arm variation. The hierarchical structure allows the &quot;borrowing of strength&quot; across treatment arms. (<code>c0</code>, <code>dj0</code>, <code>d0</code>, <code>nu0</code>, <code>Sigma0</code>, <code>Omega0</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_prior">prior</code></td>
<td>
<p>(Optional) a list of hyperparameters. Despite <code>theta</code> in every model, each <code>fmodel</code>, along with the <code>group</code> argument, requires a different set of hyperparameters. See <code>fmodel</code> for the model specifications.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_mcmc">mcmc</code></td>
<td>
<p>(Optional) a list for MCMC specification. <code>ndiscard</code> is the number of burn-in iterations. <code>nskip</code> configures the thinning of the MCMC. For instance, if <code>nskip=5</code>, <code>bayes_parobs</code> will save the posterior sample every 5 iterations. <code>nkeep</code> is the size of the posterior sample. The total number of iterations will be <code>ndiscard + nskip * nkeep</code>.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_control">control</code></td>
<td>
<p>(Optional) a list of tuning parameters for <a href="https://en.wikipedia.org/wiki/Metropolis-Hastings_algorithm">the Metropolis-Hastings algorithm</a>. <code>Rho</code>, <code>R</code>, and <code>delta</code> are sampled through either localized Metropolis algorithm or delayed rejection robust adaptive Metropolis algorithm. <code style="white-space: pre;">&#8288;*_stepsize&#8288;</code> with the asterisk replaced with one of the names above specifies the stepsize for determining the sample evaluation points in the localized Metropolis algorithm. <code>sample_Rho</code> can be set to <code>FALSE</code> to suppress the sampling of <code>Rho</code> for <code>fmodel=4</code>. When <code>sample_Rho</code> is <code>FALSE</code>, <code class="reqn">\rho</code> will be fixed using the value given by the <code>init</code> argument, which defaults to <code class="reqn">0.5 I+0.511'</code> where <code class="reqn">1</code> is the vector of ones.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_init">init</code></td>
<td>
<p>(Optional) a list of initial values for the parameters to be sampled: <code>theta</code>, <code>gamR</code>, <code>Omega</code>, and <code>Rho</code>. The initial value for <code>Rho</code> will be effective only if <code>fmodel=4</code>.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_treat_order">Treat_order</code></td>
<td>
<p>(Optional) a vector of unique treatments to be used for renumbering the <code>Treat</code> vector. The first element will be assigned treatment zero, potentially indicating placebo. If not provided, the numbering will default to an alphabetical/numerical order.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_trial_order">Trial_order</code></td>
<td>
<p>(Optional) a vector of unique trials. The first element will be assigned zero. If not provided, the numbering will default to an alphabetical/numerical order.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_group">group</code></td>
<td>
<p>(Optional) a vector containing binary variables for <code class="reqn">u_{kt}</code>. If not provided, <code>bayes_parobs</code> will assume that there is no grouping and set <code class="reqn">u_{kt}=0</code> for all <code style="white-space: pre;">&#8288;(k,t)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_group_order">group_order</code></td>
<td>
<p>(Optional) a vector of unique group labels. The first element will be assigned zero. If not provided, the numbering will default to an alphabetical/numerical order. <code>group_order</code> will take effect only if <code>group</code> is provided by the user.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_scale_x">scale_x</code></td>
<td>
<p>(Optional) a logical variable indicating whether <code>XCovariate</code> should be scaled/standardized. The effect of setting this to <code>TRUE</code> is not limited to merely standardizing <code>XCovariate</code>. The following generic functions will scale the posterior sample of <code>theta</code> back to its original unit: <code>plot</code>, <code>fitted</code>, <code>summary</code>, and <code>print</code>.</p>
</td></tr>
<tr><td><code id="bayes_parobs_+3A_verbose">verbose</code></td>
<td>
<p>(Optional) a logical variable indicating whether to print the progress bar during the MCMC sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bayes_parobs</code> returns an object of class <code>"bayesparobs"</code>. The functions <code>summary</code> or <code>print</code> are used to obtain and print a summary of the results. The generic accessor function <code>fitted</code> extracts the posterior mean, posterior standard deviation, and the interval estimates of the value returned by <code>bayes_parobs</code>.
</p>
<p>An object of class <code>bayesparobs</code> is a list containing the following components:
</p>

<ul>
<li> <p><code>Outcome</code> - the aggregate response used in the function call.
</p>
</li>
<li> <p><code>SD</code> - the standard deviation used in the function call.
</p>
</li>
<li> <p><code>Npt</code> - the number of participants for <code style="white-space: pre;">&#8288;(k,t)&#8288;</code> used in the function call.
</p>
</li>
<li> <p><code>XCovariate</code> - the aggregate design matrix for fixed effects used in the function call. Depending on <code>scale_x</code>, this may differ from the matrix provided at function call.
</p>
</li>
<li> <p><code>WCovariate</code> - the aggregate design matrix for random effects.
</p>
</li>
<li> <p><code>Treat</code> - the <em>renumbered</em> treatment indicators. Depending on <code>Treat_order</code>, it may differ from the vector provided at function call.
</p>
</li>
<li> <p><code>Trial</code> - the <em>renumbered</em> trial indicators. Depending on <code>Trial_order</code>, it may differ from the vector provided at function call.
</p>
</li>
<li> <p><code>group</code> - the <em>renumbered</em> grouping indicators in the function call. Depending on <code>group_order</code>, it may differ from the vector provided at function call. If <code>group</code> was missing at function call, <code>bayes_parobs</code> will assign <code>NULL</code> for <code>group</code>.
</p>
</li>
<li> <p><code>TrtLabels</code> - the vector of treatment labels corresponding to the renumbered <code>Treat</code>. This is equivalent to <code>Treat_order</code> if it was given at function call.
</p>
</li>
<li> <p><code>TrialLabels</code> - the vector of trial labels corresponding to the renumbered <code>Trial</code>. This is equivalent to <code>Trial_order</code> if it was given at function call.
</p>
</li>
<li> <p><code>GroupLabels</code> - the vector of group labels corresponding to the renumbered <code>group</code>. This is equivalent to <code>group_order</code> if it was given at function call. If <code>group</code> was missing at function call, <code>bayes_parobs</code> will assign <code>NULL</code> for <code>GroupLabels</code>.
</p>
</li>
<li> <p><code>K</code> - the total number of trials.
</p>
</li>
<li> <p><code>T</code> - the total number of treatments.
</p>
</li>
<li> <p><code>fmodel</code> - the model number as described <a href="#model-spec">here</a>.
</p>
</li>
<li> <p><code>scale_x</code> - a Boolean indicating whether <code>XCovariate</code> has been scaled/standardized.
</p>
</li>
<li> <p><code>prior</code> - the list of hyperparameters used in the function call.
</p>
</li>
<li> <p><code>control</code> - the list of tuning parameters used for MCMC in the function call.
</p>
</li>
<li> <p><code>mcmctime</code> - the elapsed time for the MCMC algorithm in the function call. This does not include all the other preprocessing and post-processing outside of MCMC.
</p>
</li>
<li> <p><code>mcmc</code> - the list of MCMC specification used in the function call.
</p>
</li>
<li> <p><code>mcmc.draws</code> - the list containing the MCMC draws. The posterior sample will be accessible here.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daeyoung Lim, <a href="mailto:daeyoung.lim@uconn.edu">daeyoung.lim@uconn.edu</a>
</p>


<h3>References</h3>

<p>Yao, H., Kim, S., Chen, M. H., Ibrahim, J. G., Shah, A. K., &amp; Lin, J. (2015). Bayesian inference for multivariate meta-regression with a partially observed within-study sample covariance matrix. <em>Journal of the American Statistical Association</em>, <strong>110(510)</strong>, 528-544.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bmeta_analyze">bmeta_analyze</a></code> for using the <code><a href="Formula.html#topic+Formula">Formula</a></code> interface
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(metapack)
data("cholesterol")
Outcome &lt;- model.matrix(~ 0 + pldlc + phdlc + ptg, data = cholesterol)
SD &lt;- model.matrix(~ 0 + sdldl + sdhdl + sdtg, data = cholesterol)
Trial &lt;- cholesterol$trial
Treat &lt;- cholesterol$treat
Npt &lt;- cholesterol$n
XCovariate &lt;- model.matrix(~ 0 + bldlc + bhdlc + btg + age + durat +
 white + male + dm, data = cholesterol)
WCovariate &lt;- model.matrix(~ treat, data = cholesterol)

fmodel &lt;- 1
set.seed(2797542)
fit &lt;- bayes_parobs(Outcome, SD, XCovariate, WCovariate, Treat, Trial,
   Npt, fmodel, mcmc = list(ndiscard = 1, nskip = 1, nkeep = 1),
   scale_x = TRUE, group = cholesterol$onstat, verbose = FALSE)
</code></pre>

<hr>
<h2 id='bmeta_analyze'>bmeta_analyze supersedes the previous two functions: bayes_parobs, bayes_nmr</h2><span id='topic+bmeta_analyze'></span><span id='topic+bmeta_analyse'></span>

<h3>Description</h3>

<p>All other worker functions are superseded by this function, so that users can forget about the implementation details and focus on modeling. Meta-analytic data can be either aggregate or individual participant data (IPD). Aggregate data implies that the response consists of estimated effect sizes and their corresponding standard errors, whereas IPD is raw data. Data sets to be used for metapack should be formatted as follows:</p>

<table>
<tr>
 <td style="text-align: center;">
   Outcome </td><td style="text-align: center;"> SD </td><td style="text-align: center;"> DesignM1 </td><td style="text-align: center;"> DesignM2 </td><td style="text-align: center;"> Trial indicator (<code>k</code>) </td><td style="text-align: center;"> Treatment indicator (<code>t</code>) </td><td style="text-align: center;"> n </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code class="reqn">y_{13}</code> </td><td style="text-align: center;"> <code class="reqn">S_{13}</code> </td><td style="text-align: center;"> <code class="reqn">x_{13}</code> </td><td style="text-align: center;"> <code class="reqn">w_{13}</code> </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 1000 </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code class="reqn">y_{10}</code> </td><td style="text-align: center;"> <code class="reqn">S_{10}</code> </td><td style="text-align: center;"> <code class="reqn">x_{10}</code> </td><td style="text-align: center;"> <code class="reqn">w_{10}</code> </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 545 </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code class="reqn">y_{20}</code> </td><td style="text-align: center;"> <code class="reqn">S_{20}</code> </td><td style="text-align: center;"> <code class="reqn">x_{20}</code> </td><td style="text-align: center;"> <code class="reqn">w_{20}</code> </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1200 </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>The first treatment indicator is intentionally selected to be 3, a number greater than 1, to indicate that this data format works for both meta-regression and network meta-regression. Meta-regression refers to when trials included have 2 treatments (i.e., <code class="reqn">t = 0, 1</code> for all <code class="reqn">k</code>), and the treatments are compared head to head. On the other hand, network meta-regression includes more than two treatments, where each trial can have a different set of treatments, allowing indirect comparison between treatments that are not compared head to head as long as <em>consistency</em> holds (see <a href="https://onlinelibrary.wiley.com/doi/10.1002/jrsm.1044">Higgins et al. (2012)</a> for consistency).
</p>
<p><code>bmeta_analyze()</code> and <code>bmeta_analyse()</code> are synonyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmeta_analyze(
  formula,
  data,
  prior = list(),
  mcmc = list(),
  control = list(),
  init = list()
)

bmeta_analyse(
  formula,
  data,
  prior = list(),
  mcmc = list(),
  control = list(),
  init = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bmeta_analyze_+3A_formula">formula</code></td>
<td>
<p>an object of class <a href="Formula.html#topic+Formula">Formula</a>: a symbolic description of the meta-analytic model to fit. For aggregate models, the vector of arm sample sizes must be provided using the function <code>ns()</code>. For example, <code>y1 + y2 | sd1 + sd2 ~ x1 + x2 + ns(n)</code>&mdash;an incomplete formula only for illustration purposes. If no <code>ns()</code> is found, individual participant data (IPD) model is assumed.</p>
</td></tr>
<tr><td><code id="bmeta_analyze_+3A_data">data</code></td>
<td>
<p>a data frame, list, or environment (or an object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>bmeta_analyze</code> is called.</p>
</td></tr>
<tr><td><code id="bmeta_analyze_+3A_prior">prior</code></td>
<td>
<p>an optional object that contains the hyperparameter values for the model. To see the complete list of hyperparameters for a specific model, refer to the corresponding worker function's help page, e.g., <code>help(bayes_parobs)</code> or <code>help(bayes_nmr)</code>. For meta-analysis, <code>model</code> is required in the <code>prior</code> argument, which is passed to <code>fmodel</code> as an integer. If the response is univariate, <code>NoRecovery</code> is the only valid option.
</p>

<ul>
<li> <p><code>model="NoRecovery"</code> - <code class="reqn">\Sigma_{tk} = diag(\sigma_{tk,11}^2,\ldots,\sigma_{tk,JJ}^2)</code> where <code class="reqn">\sigma_{tk,jj}^2 \sim IG(a_0,b_0)</code> and <code class="reqn">IG(a,b)</code> is <a href="https://en.wikipedia.org/wiki/Inverse-gamma_distribution">the inverse-gamma distribution</a>. This specification is useful if the user does not care about the correlation recovery. (<code>c0</code>, <code>dj0</code>, <code>a0</code>, <code>b0</code>, <code>Omega0</code>)
</p>
</li>
<li> <p><code>model="EquiCovariance"</code> - <code class="reqn">\Sigma_{tk}=\Sigma</code> for every combination of <code class="reqn">(t,k)</code> and <code class="reqn">\Sigma^{-1}\sim Wish_{s_0}(\Sigma_0)</code>. This specification assumes that the user has prior knowledge that the correlation structure does not change across the arms included. (<code>c0</code>, <code>dj0</code>, <code>s0</code>, <code>Omega0</code>, <code>Sigma0</code>)
</p>
</li>
<li> <p><code>model="EquiWithinTreat"</code> - <code class="reqn">\Sigma_{tk}=\Sigma_t</code> and <code class="reqn">\Sigma_t^{-1}\sim  Wish_{s_0}(\Sigma_0)</code>. This is a relaxed version of <code>model=2</code>, allowing the correlation structure to differ across trials but forcing it to stay identical within a trial. (<code>c0</code>, <code>dj0</code>, <code>s0</code>, <code>Omega0</code>, <code>Sigma0</code>)
</p>
</li>
<li> <p><code>model="EquiCorrelation"</code> - <code class="reqn">\Sigma_{tk}=\delta_{tk} \rho \delta_{tk}</code> where <code class="reqn">\delta_{tk}=diag(\Sigma_{tk,11}^{1/2},\ldots,\Sigma_{tk,JJ}^{1/2})</code>, and <code class="reqn">\rho</code> is the correlation matrix. This specification allows the variances to vary across arms but requires that the correlations be the same. This is due to the lack of correlation information in the data, which would in turn lead to the nonidentifiability of the correlations if they were allowed to vary. However, this still is an ambitious model which permits maximal degrees of freedom in terms of variance and correlation estimation. (<code>c0</code>, <code>dj0</code>, <code>a0</code>, <code>b0</code>, <code>Omega0</code>)
</p>
</li>
<li> <p><code>model="Hierarchical"</code> - The fifth model is hierarchical and thus may require more data than the others: <code class="reqn">(\Sigma_{tk}^{-1}\mid \Sigma)\sim  Wish_{\nu_0}((\nu_0-J-1)^{-1}\Sigma^{-1})</code> and <code class="reqn">\Sigma \sim  Wish_{d_0}(\Sigma_0)</code>. <code class="reqn">\Sigma_{tk}</code> encodes the within-treatment-arm variation while <code class="reqn">\Sigma</code> captures the between-treatment-arm variation. The hierarchical structure allows the &quot;borrowing of strength&quot; across treatment arms. (<code>c0</code>, <code>dj0</code>, <code>d0</code>, <code>nu0</code>, <code>Sigma0</code>, <code>Omega0</code>)
</p>
</li></ul>

<p>For network meta-analysis,
</p>

<ul>
<li> <p><code>df</code> - the degrees of freedom of the multivariate t-distribution for the random effects. Any positive value can be assigned; if <code>df=Inf</code>, multivariate normal random effects will be assumed.
</p>
</li>
<li> <p><code>c01</code> - the variance of the fixed-effect coefficients' prior distribuiton, a multivariate normal distribution, i.e., <code class="reqn">\theta \sim N(0, c_{1}I)</code>.
</p>
</li>
<li> <p><code>c02</code> - the variance of the random-effects' variance-related coefficients' prior distribution, a multivariate normal distribution, i.e., <code class="reqn">\phi \sim N(0, c_{2}I)</code>.
</p>
</li>
<li> <p><code>a4</code>, <code>b4</code>, <code>a5</code>, <code>b5</code> - the hyperparameters related to when the degrees of freedom for the random effects are treated as unknown/random. <code>df</code> is then considered to follow <code class="reqn">Ga(\nu_a, \nu_a/\nu_b)</code>, <code class="reqn">\nu_a \sim Ga(a_4, b_4)</code>, and <code class="reqn">\nu_b \sim IG(a_5, b_5)</code>. All gamma and inverse-gamma distributions are rate-parameterized.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bmeta_analyze_+3A_mcmc">mcmc</code></td>
<td>
<p>an optional object containing MCMC specification. <code>ndiscard</code> is the number of burn-in iterations. <code>nskip</code> configures the thinning of the MCMC. For instance, if <code>nskip=5</code>, parameters will be saved every 5 iterations. <code>nkeep</code> is the size of the posterior sample. The total number of iterations will be <code>ndiscard + nskip * nkeep</code>.</p>
</td></tr>
<tr><td><code id="bmeta_analyze_+3A_control">control</code></td>
<td>
<p>an optional object that contains the control tuning parameters for the Metropolis-Hastings algorithm. Similar to <code>prior</code>, the complete list of control parameters for a specific model is given in the corresponding worker function's help page (see <code><a href="#topic+bayes_parobs">bayes_parobs</a></code> or <code><a href="#topic+bayes_nmr">bayes_nmr</a></code>).
These are the lists of available tuning parameters in <code>control</code> for meta-analysis and network meta-analysis. Keep in mind that <code>model</code> will render some irrelevant tuning parameters ineffective.
</p>

<ul>
<li><p> Meta-analysis - <code>model</code> (string), <code>sample_Rho</code> (logical), <code>Rho_stepsize</code> (double), <code>R_stepsize</code> (double), <code>delta_stepsize</code> (double), <code>sample_Rho</code> (logical)
</p>
</li>
<li><p> Network meta-analysis - <code>sample_df</code> (logical), <code>sample_Rho</code> (logical), <code>lambda_stepsize</code> (double), <code>phi_stepsize</code> (double), <code>Rho_stepsize</code> (double)
</p>
</li></ul>
</td></tr>
<tr><td><code id="bmeta_analyze_+3A_init">init</code></td>
<td>
<p>(Optional) a list of initial values for the parameters to be sampled. The following is the list of available parameters for meta-analysis and network meta-analysis.
</p>

<ul>
<li><p> Meta-analysis - <code>theta</code> (vector), <code>gamR</code> (matrix), <code>Omega</code> (matrix), <code>Rho</code> (matrix)
</p>
</li>
<li><p> Network meta-analysis - <code>theta</code> (vector), <code>phi</code> (vector), <code>sig2</code> (vector), <code>Rho</code> (matrix)
</p>
</li></ul>

<p>The dimensions of the initial values must be conformable for matrix operations. If dimensions don't agree, <code>bmeta_analyze</code> will tell you the correct dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bmeta_analyze</code> currently subsumes two worker functions: <code>bayes_parobs</code> and <code>bayes_nmr</code>. <code>bmeta_analyze</code> offers a formula interface.
All formulas are parsed using <a href="Formula.html#topic+Formula">Formula</a>. Formulas for <code>bmeta_analyze</code> are constrained to have a strict structure: one or two LHS, and two or three RHS. That is, <code>lhs_1 ~ rhs_1 | rhs2 | rhs3</code> or <code>lhs_1 | lhs_2 ~ rhs_1 | rhs2 | rhs3</code> (see Examples for more). The tilde (<code>~</code>) separates the LHS's and RHS's, each side further separated into parts by vertical bars (<code>|</code>).
The meaning of each part is syntactically determined by its location inside the formula, like an English sentence. Therefore, all parts <strong>must</strong> come in the exact order as prescribed for <code>bmeta_analyze</code> to correctly configure your model.
</p>

<ul>
<li><p> The first LHS, the responses, is required for all models.
</p>
</li>
<li><p> The second LHS is only required for aggregate models, corresponding to the standard deviations of the responses.
</p>
</li>
<li><p> The first RHS corresponds to fixed-effects covariates.
</p>
</li>
<li><p> The second RHS corresponds to the variables in either the random-effects matrix (<code class="reqn">w_{tk}' * \gamma_{k}</code>') for multivariate meta-analysis or modeling the variances (<code class="reqn">\log\tau_{tk}</code> = <code class="reqn">z_{tk}' * \phi</code>) for univariate network meta-analysis.
</p>
</li>
<li><p> The third RHS corresponds to the treatment and trial indicators, and optionally the grouping variable if it exists. The order must be <code>treat + trial + group</code>, or <code>treat + trial</code> if no grouping exists. Variables here must be supplied in the exact order described; otherwise, model will not be correctly identified.
</p>
</li></ul>

<p>Internally, <code>bmeta_analyze</code> looks for three things: multivariate/univariate, meta-analyis/network meta-analysis, and <a href="https://en.wikipedia.org/wiki/Meta-analysis#Approaches">aggregate/IPD</a>.
</p>

<ul>
<li><p> multivariate/univariate: the dimension of the response is explicit in the formula, and determines univariate versus multivariate.
</p>
</li>
<li><p> meta-analysis/network meta-analysis: the number of levels (<code>nlevels</code>) of treatments determines this. If <code>treat</code> is not already a factor variable, it is coerced to one.
</p>
</li>
<li><p> aggregate/IPD: <code>bmeta_analyze</code> looks for <code>ns()</code> in the first RHS. Aggregate models <strong>must</strong> provide the arm sample sizes using the function <code>ns()</code> (e.g., if <code>n</code> is the sample sizes, <code style="white-space: pre;">&#8288;y1 + y2 | sd1 + sd2 ~ x1 + x2 + ns(n))&#8288;</code>). If there is no <code>ns()</code>, IPD is assumed. Currently, IPD models are a work in progress and not supported yet.
</p>
</li></ul>

<p>Currently, only <code>univariate/multivariate</code> + <code>meta-analysis</code> and <code>univariate</code> + <code style="white-space: pre;">&#8288;network meta-analysis&#8288;</code> are allowed. More models will be added in the future.
</p>


<h3>Value</h3>

<p><code>bmeta_analyze</code> returns a classed object of <code>bsynthesis</code> for <em>Bayesian synthesis</em>
</p>


<h3>Author(s)</h3>

<p>Daeyoung Lim, <a href="mailto:daeyoung.lim@uconn.edu">daeyoung.lim@uconn.edu</a>
</p>


<h3>References</h3>

<p>Yao, H., Kim, S., Chen, M. H., Ibrahim, J. G., Shah, A. K., &amp; Lin, J. (2015). Bayesian inference for multivariate meta-regression with a partially observed within-study sample covariance matrix. <em>Journal of the American Statistical Association</em>, <strong>110(510)</strong>, 528-544.
</p>
<p>Li, H., Chen, M. H., Ibrahim, J. G., Kim, S., Shah, A. K., Lin, J., &amp; Tershakovec, A. M. (2019). Bayesian inference for network meta-regression using multivariate random effects with applications to cholesterol lowering drugs. <em>Biostatistics</em>, <strong>20(3)</strong>, 499-516.
</p>
<p>Li, H., Lim, D., Chen, M. H., Ibrahim, J. G., Kim, S., Shah, A. K., &amp; Lin, J. (2021). Bayesian network meta-regression hierarchical models using heavy-tailed multivariate random effects with covariate-dependent variances. <em>Statistics in Medicine</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayes_parobs">bayes_parobs</a></code> for multivariate meta-analysis, and <code><a href="#topic+bayes_nmr">bayes_nmr</a></code> for univariate network meta-analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2797542)
data("cholesterol")
f_1 &lt;- 'pldlc + phdlc + ptg | sdldl + sdhdl + sdtg ~ 0 + bldlc + bhdlc + btg +
  age + durat + white + male + dm + ns(n) | treat | treat + trial + onstat'
out_1 &lt;- bmeta_analyze(as.formula(f_1), data = cholesterol,
  prior = list(model="NoRecovery"),
  mcmc = list(ndiscard = 3, nskip = 1, nkeep = 1),
  control=list(scale_x = TRUE, verbose=FALSE))

set.seed(2797542)
data("TNM")
TNM$group &lt;- factor(match(TNM$treat, c("PBO", "R"), nomatch = 0))
f_2 &lt;- 'ptg | sdtg ~
  0 + bldlc + bhdlc + btg + age + white + male + bmi +
  potencymed + potencyhigh + durat + ns(n) |
  scale(bldlc) + scale(btg) + group | treat  + trial'
out_2 &lt;- bmeta_analyze(as.formula(f_2), data = TNM,
  mcmc = list(ndiscard = 1, nskip = 1, nkeep = 1),
  control=list(scale_x = TRUE, verbose=FALSE))
</code></pre>

<hr>
<h2 id='cholesterol'>26 double-blind, randomized, active, or placebo-controlled clinical trials on patients with primary hypercholesterolemia sponsored by Merck &amp; Co., Inc., Kenilworth, NJ, USA.</h2><span id='topic+cholesterol'></span>

<h3>Description</h3>

<p>A data set containing clinical trial on hypercholesterolemia including 26 trials and 2 treatment arms each, and other attributes of the participants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cholesterol)
</code></pre>


<h3>Format</h3>

<p>A data frame with 52 rows and 19 variables
</p>

<dl>
<dt>study</dt><dd><p>study identifier</p>
</dd>
<dt>trial</dt><dd><p>trial identifier</p>
</dd>
<dt>treat</dt><dd><p>treatment indicator for Statin or Statin+Ezetimibe</p>
</dd>
<dt>n</dt><dd><p>the number of participants in the study arms corresponding to the trial and treatment</p>
</dd>
<dt>pldlc</dt><dd><p>aggregate percentage change in LDL-C</p>
</dd>
<dt>phdlc</dt><dd><p>aggregate percentage change from baseline in HDL-C</p>
</dd>
<dt>ptg</dt><dd><p>aggregate percentage change from baseline in triglycerides (TG)</p>
</dd>
<dt>sdldl</dt><dd><p>sample standard deviation of percentage change in LDL-C</p>
</dd>
<dt>sdhdl</dt><dd><p>sample standard deviation of percentage change in HDL-C</p>
</dd>
<dt>sdtg</dt><dd><p>sample standard deviation of percentage change in triglycerides (TG)</p>
</dd>
<dt>onstat</dt><dd><p>whether the participants were on Statin prior to the trial</p>
</dd>
<dt>bldlc</dt><dd><p>baseline LDL-C</p>
</dd>
<dt>bhdlc</dt><dd><p>baseline HDL-C</p>
</dd>
<dt>btg</dt><dd><p>baseline triglycerides (TG)</p>
</dd>
<dt>age</dt><dd><p>age in years</p>
</dd>
<dt>white</dt><dd><p>the proportion of white participants</p>
</dd>
<dt>male</dt><dd><p>the proportion of male participants</p>
</dd>
<dt>dm</dt><dd><p>the proportion of participants with diabetes mellitus</p>
</dd>
<dt>durat</dt><dd><p>duration in weeks</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(cholesterol)
</code></pre>

<hr>
<h2 id='coef.bsynthesis'>get the posterior mean of fixed-effect coefficients</h2><span id='topic+coef.bsynthesis'></span>

<h3>Description</h3>

<p>get the posterior mean of fixed-effect coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsynthesis'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.bsynthesis_+3A_object">object</code></td>
<td>
<p>a class of <code>bsynthesize</code></p>
</td></tr>
<tr><td><code id="coef.bsynthesis_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients extracted from the model object <code>object</code>
</p>

<hr>
<h2 id='fitted.bayesnmr'>get fitted values</h2><span id='topic+fitted.bayesnmr'></span>

<h3>Description</h3>

<p>get fitted values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesnmr'
fitted(object, level = 0.95, HPD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.bayesnmr_+3A_object">object</code></td>
<td>
<p>the output model from fitting a meta analysis/regression model</p>
</td></tr>
<tr><td><code id="fitted.bayesnmr_+3A_level">level</code></td>
<td>
<p>credible level for interval estimation; set to 0.95 by default</p>
</td></tr>
<tr><td><code id="fitted.bayesnmr_+3A_hpd">HPD</code></td>
<td>
<p>a logical argument indicating whether HPD intervals should be computed; if FALSE, equal-tail credible intervals are computed</p>
</td></tr>
<tr><td><code id="fitted.bayesnmr_+3A_...">...</code></td>
<td>
<p>additional arguments for fitted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of fitted values
</p>

<hr>
<h2 id='fitted.bayesparobs'>get fitted values</h2><span id='topic+fitted.bayesparobs'></span>

<h3>Description</h3>

<p>get fitted values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesparobs'
fitted(object, level = 0.95, HPD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.bayesparobs_+3A_object">object</code></td>
<td>
<p>the output model from fitting a meta analysis/regression model</p>
</td></tr>
<tr><td><code id="fitted.bayesparobs_+3A_level">level</code></td>
<td>
<p>credible level for interval estimation; set to 0.95 by default</p>
</td></tr>
<tr><td><code id="fitted.bayesparobs_+3A_hpd">HPD</code></td>
<td>
<p>a logical argument indicating whether HPD intervals should be computed; if FALSE, equal-tail credible intervals are computed</p>
</td></tr>
<tr><td><code id="fitted.bayesparobs_+3A_...">...</code></td>
<td>
<p>additional arguments for fitted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of fitted values
</p>

<hr>
<h2 id='hpd'>get the highest posterior density (HPD) interval</h2><span id='topic+hpd'></span>

<h3>Description</h3>

<p>get the highest posterior density (HPD) interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hpd(object, parm, level = 0.95, HPD = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hpd_+3A_object">object</code></td>
<td>
<p>the output model from fitting a (network) meta analysis/regression model</p>
</td></tr>
<tr><td><code id="hpd_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="hpd_+3A_level">level</code></td>
<td>
<p>the probability which the HPD interval will cover</p>
</td></tr>
<tr><td><code id="hpd_+3A_hpd">HPD</code></td>
<td>
<p>a logical value indicating whether HPD or equal-tailed credible interval should be computed; by default, TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code class="reqn">100(1-\alpha)</code>% HPD interval for <code class="reqn">\theta</code> is given by </p>
<p style="text-align: center;"><code class="reqn">R(\pi_\alpha) = {\theta: \pi(\theta| D) \ge \pi_\alpha},</code>
</p>
<p> where <code class="reqn">\pi_\alpha</code> is the largest constant that satisfies <code class="reqn">P(\theta \in  R(\pi_\alpha)) \ge 1-\alpha</code>. <code>hpd</code> computes the HPD interval from an MCMC sample by letting <code class="reqn">\theta_{(j)}</code> be the <code class="reqn">j</code>th smallest of the MCMC sample, <code class="reqn">{\theta_i}</code> and denoting </p>
<p style="text-align: center;"><code class="reqn">R_j(n) = (\theta_{(j)}, \theta_{(j+[(1-\alpha)n])}),</code>
</p>
<p> for <code class="reqn">j=1,2,\ldots,n-[(1-\alpha)n]</code>. Once <code class="reqn">\theta_i</code>'s are sorted, the appropriate <code class="reqn">j</code> is chosen so that </p>
<p style="text-align: center;"><code class="reqn">\theta_{(j+[(1-\alpha)n])} - \theta_{(j)} = \min_{1\le j \leq n-[(1-\alpha)n]} (\theta_{(j+[(1-\alpha)n])} - \theta_{(j)}).</code>
</p>



<h3>Value</h3>

<p>dataframe containing HPD intervals for the parameters
</p>


<h3>References</h3>

<p>Chen, M. H., &amp; Shao, Q. M. (1999). Monte Carlo estimation of Bayesian credible and HPD intervals. <em>Journal of Computational and Graphical Statistics</em>, <strong>8(1)</strong>, 69-92.
</p>

<hr>
<h2 id='hpd.bayesnmr'>get the highest posterior density (HPD) interval</h2><span id='topic+hpd.bayesnmr'></span>

<h3>Description</h3>

<p>get the highest posterior density (HPD) interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesnmr'
hpd(object, parm, level = 0.95, HPD = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hpd.bayesnmr_+3A_object">object</code></td>
<td>
<p>the output model from fitting a (network) meta analysis/regression model</p>
</td></tr>
<tr><td><code id="hpd.bayesnmr_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="hpd.bayesnmr_+3A_level">level</code></td>
<td>
<p>the probability which the HPD interval will cover</p>
</td></tr>
<tr><td><code id="hpd.bayesnmr_+3A_hpd">HPD</code></td>
<td>
<p>a logical value indicating whether HPD or equal-tailed credible interval should be computed; by default, TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe containing HPD intervals for the parameters
</p>

<hr>
<h2 id='hpd.bayesparobs'>get the highest posterior density (HPD) interval or equal-tailed credible interval</h2><span id='topic+hpd.bayesparobs'></span>

<h3>Description</h3>

<p>get the highest posterior density (HPD) interval or equal-tailed credible interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesparobs'
hpd(object, parm, level = 0.95, HPD = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hpd.bayesparobs_+3A_object">object</code></td>
<td>
<p>the output model from fitting a (network) meta analysis/regression model</p>
</td></tr>
<tr><td><code id="hpd.bayesparobs_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="hpd.bayesparobs_+3A_level">level</code></td>
<td>
<p>the probability which the HPD interval will cover</p>
</td></tr>
<tr><td><code id="hpd.bayesparobs_+3A_hpd">HPD</code></td>
<td>
<p>a logical value indicating whether HPD or equal-tailed credible interval should be computed; by default, TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe containing HPD intervals for the parameters
</p>

<hr>
<h2 id='metapack'>metapack: a package for Bayesian meta-analysis and network meta-analysis</h2><span id='topic+metapack'></span>

<h3>Description</h3>

<p>The metapack package provides one category of functions:
bayes.parobs and bayes.nmr
</p>


<h3>Multivariate Meta-Regression function</h3>

<p>The bayes.parobs function fits the multivariate meta-regression model
with partially observed sample covariance matrix to the given data.
</p>


<h3>Network Meta-Regression function</h3>

<p>The bayes.nmr function fits the network meta-regression model with 
heavy-tailed random effects distribution to the given data.
</p>

<hr>
<h2 id='model_comp'>compute the model comparison measures: DIC, LPML, or Pearson's residuals</h2><span id='topic+model_comp'></span>

<h3>Description</h3>

<p><code>model_comp</code> is a generic function that computes the model comparison measures (DIC and LPML) or the Pearson's residuals. Note that the Pearson's residuals are not available for <code>bayes.nmr</code> when <code>df</code> is either random or fixed but smaller than 2 since the variance of the random effects is not finite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_comp(object, type = "lpml", verbose = FALSE, ncores = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_comp_+3A_object">object</code></td>
<td>
<p>the output model from fitting a meta analysis/regression model</p>
</td></tr>
<tr><td><code id="model_comp_+3A_type">type</code></td>
<td>
<p>the type of model comparison measure to compute; DIC or LPML</p>
</td></tr>
<tr><td><code id="model_comp_+3A_verbose">verbose</code></td>
<td>
<p>FALSE by default; If TRUE, then progress bar will appear</p>
</td></tr>
<tr><td><code id="model_comp_+3A_ncores">ncores</code></td>
<td>
<p>the number of CPU cores to use for parallel processing. It must not exceed the number of existing cores. If unspecified, it will default to 2 cores or the number of existing cores, whichever is smaller.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe containing the compute the model comparison measures
</p>

<hr>
<h2 id='model_comp.bayesnmr'>get compute the model comparison measures</h2><span id='topic+model_comp.bayesnmr'></span>

<h3>Description</h3>

<p>get compute the model comparison measures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesnmr'
model_comp(object, type = "lpml", verbose = FALSE, ncores = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_comp.bayesnmr_+3A_object">object</code></td>
<td>
<p>the output model from fitting a meta analysis/regression model</p>
</td></tr>
<tr><td><code id="model_comp.bayesnmr_+3A_type">type</code></td>
<td>
<p>the type of model comparison measures; DIC or LPML</p>
</td></tr>
<tr><td><code id="model_comp.bayesnmr_+3A_verbose">verbose</code></td>
<td>
<p>FALSE by default; If TRUE, then progress bar will appear</p>
</td></tr>
<tr><td><code id="model_comp.bayesnmr_+3A_ncores">ncores</code></td>
<td>
<p>the number of CPU cores to use for parallel processing. It must not exceed the number of existing cores. If unspecified, it will default to 2 cores or the number of existing cores, whichever is smaller.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe containing the compute the model comparison measures
</p>

<hr>
<h2 id='model_comp.bayesparobs'>compute the model comparison measures</h2><span id='topic+model_comp.bayesparobs'></span>

<h3>Description</h3>

<p>compute the model comparison measures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesparobs'
model_comp(object, type = "lpml", verbose = FALSE, ncores = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_comp.bayesparobs_+3A_object">object</code></td>
<td>
<p>the output model from fitting a meta analysis/regression model</p>
</td></tr>
<tr><td><code id="model_comp.bayesparobs_+3A_type">type</code></td>
<td>
<p>the type of model comparison measures; DIC or LPML</p>
</td></tr>
<tr><td><code id="model_comp.bayesparobs_+3A_verbose">verbose</code></td>
<td>
<p>FALSE by default; If TRUE, then progress bar will appear</p>
</td></tr>
<tr><td><code id="model_comp.bayesparobs_+3A_ncores">ncores</code></td>
<td>
<p>the number of CPU cores to use for parallel processing. It must not exceed the number of existing cores. If unspecified, it will default to 2 cores or the number of existing cores, whichever is smaller.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe containing the compute the model comparison measures
</p>

<hr>
<h2 id='ns'>helper function encoding trial sample sizes in formulas</h2><span id='topic+ns'></span>

<h3>Description</h3>

<p>helper function encoding trial sample sizes in formulas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ns(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ns_+3A_x">x</code></td>
<td>
<p>the name of the variable containing trial sample sizes</p>
</td></tr>
</table>

<hr>
<h2 id='plot.bayesnmr'>get goodness of fit</h2><span id='topic+plot.bayesnmr'></span>

<h3>Description</h3>

<p>get goodness of fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesnmr'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bayesnmr_+3A_x">x</code></td>
<td>
<p>the output model from fitting a meta analysis/regression model</p>
</td></tr>
<tr><td><code id="plot.bayesnmr_+3A_...">...</code></td>
<td>
<p>additional parameters for plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='plot.bayesparobs'>get goodness of fit</h2><span id='topic+plot.bayesparobs'></span>

<h3>Description</h3>

<p>get goodness of fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesparobs'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bayesparobs_+3A_x">x</code></td>
<td>
<p>the output model from fitting a meta analysis/regression model</p>
</td></tr>
<tr><td><code id="plot.bayesparobs_+3A_...">...</code></td>
<td>
<p>additional parameters for plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='plot.sucra'>plot the surface under the cumulative ranking curve (SUCRA)</h2><span id='topic+plot.sucra'></span>

<h3>Description</h3>

<p>plot the surface under the cumulative ranking curve (SUCRA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sucra'
plot(x, legend.position = "none", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sucra_+3A_x">x</code></td>
<td>
<p>the output model from fitting a network meta analysis/regression model</p>
</td></tr>
<tr><td><code id="plot.sucra_+3A_legend.position">legend.position</code></td>
<td>
<p>the position of the legend that will be passed onto ggplot</p>
</td></tr>
<tr><td><code id="plot.sucra_+3A_...">...</code></td>
<td>
<p>additional arguments for plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='print.bayesnmr'>Print results</h2><span id='topic+print.bayesnmr'></span>

<h3>Description</h3>

<p>Print results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesnmr'
print(x, level = 0.95, HPD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bayesnmr_+3A_x">x</code></td>
<td>
<p>the output model from fitting a network meta analysis/regression model</p>
</td></tr>
<tr><td><code id="print.bayesnmr_+3A_level">level</code></td>
<td>
<p>credible level for interval estimation; set to 0.95 by default</p>
</td></tr>
<tr><td><code id="print.bayesnmr_+3A_hpd">HPD</code></td>
<td>
<p>a logical argument indicating whether HPD intervals should be computed; if FALSE, equal-tail credible intervals are computed</p>
</td></tr>
<tr><td><code id="print.bayesnmr_+3A_...">...</code></td>
<td>
<p>additional arguments for print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value; print a summary of the output
</p>

<hr>
<h2 id='print.bayesparobs'>Print results</h2><span id='topic+print.bayesparobs'></span>

<h3>Description</h3>

<p>Print results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesparobs'
print(x, level = 0.95, HPD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bayesparobs_+3A_x">x</code></td>
<td>
<p>the output model from fitting a meta analysis/regression model</p>
</td></tr>
<tr><td><code id="print.bayesparobs_+3A_level">level</code></td>
<td>
<p>credible level for interval estimation; set to 0.95 by default</p>
</td></tr>
<tr><td><code id="print.bayesparobs_+3A_hpd">HPD</code></td>
<td>
<p>a logical argument indicating whether HPD intervals should be computed; if FALSE, equal-tail credible intervals are computed</p>
</td></tr>
<tr><td><code id="print.bayesparobs_+3A_...">...</code></td>
<td>
<p>additional arguments for print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value; print a summary of the output
</p>

<hr>
<h2 id='sucra'>get surface under the cumulative ranking curve (SUCRA)</h2><span id='topic+sucra'></span>

<h3>Description</h3>

<p>get surface under the cumulative ranking curve (SUCRA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sucra(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sucra_+3A_object">object</code></td>
<td>
<p>the output model from fitting a network meta analysis/regression model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing SUCRA and the discrete rank probability matrix of size T by T
</p>

<hr>
<h2 id='sucra.bayesnmr'>get surface under the cumulative ranking curve (SUCRA)</h2><span id='topic+sucra.bayesnmr'></span>

<h3>Description</h3>

<p>get surface under the cumulative ranking curve (SUCRA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesnmr'
sucra(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sucra.bayesnmr_+3A_object">object</code></td>
<td>
<p>the output model from fitting a network meta analysis/regression model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing SUCRA and the discrete rank probability matrix of size T by T
</p>

<hr>
<h2 id='summary.bayesnmr'>'summary' method for class &quot;'bayesnmr'&quot;</h2><span id='topic+summary.bayesnmr'></span>

<h3>Description</h3>

<p>'summary' method for class &quot;'bayesnmr'&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesnmr'
summary(object, level = 0.95, HPD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bayesnmr_+3A_object">object</code></td>
<td>
<p>the output model from fitting a network meta analysis/regression model</p>
</td></tr>
<tr><td><code id="summary.bayesnmr_+3A_level">level</code></td>
<td>
<p>credible level for interval estimation; set to 0.95 by default</p>
</td></tr>
<tr><td><code id="summary.bayesnmr_+3A_hpd">HPD</code></td>
<td>
<p>a logical argument indicating whether HPD intervals should be computed; if FALSE, equal-tail credible intervals are computed</p>
</td></tr>
<tr><td><code id="summary.bayesnmr_+3A_...">...</code></td>
<td>
<p>additional arguments for print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>does not return anything; print a summary of the output
</p>

<hr>
<h2 id='summary.bayesparobs'><code>summary</code> method for class &quot;<code>bayesparobs</code>&quot;</h2><span id='topic+summary.bayesparobs'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;<code>bayesparobs</code>&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesparobs'
summary(object, level = 0.95, HPD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bayesparobs_+3A_object">object</code></td>
<td>
<p>the output model from fitting a meta analysis/regression model</p>
</td></tr>
<tr><td><code id="summary.bayesparobs_+3A_level">level</code></td>
<td>
<p>credible level for interval estimation; set to 0.95 by default</p>
</td></tr>
<tr><td><code id="summary.bayesparobs_+3A_hpd">HPD</code></td>
<td>
<p>a logical argument indicating whether HPD intervals should be computed; if FALSE, equal-tail credible intervals are computed</p>
</td></tr>
<tr><td><code id="summary.bayesparobs_+3A_...">...</code></td>
<td>
<p>additional arguments for summary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>print summary for the model fit
</p>

<hr>
<h2 id='TNM'>Triglycerides Network Meta (TNM) data</h2><span id='topic+TNM'></span>

<h3>Description</h3>

<p>A systemically reviewed network meta data set on tryglyceride (TG) lowering drugs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TNM)
</code></pre>


<h3>Format</h3>

<p>A data frame with 73 rows and 15 variables
</p>

<dl>
<dt>trial</dt><dd><p>trial identifier</p>
</dd>
<dt>treat</dt><dd><p>treatment indicator for placebo (PBO), simvastatin (S), atorvastatin (A), lovastatin (L), rosuvastatin (R), pravastatin (P), ezetimibe (E), simvastatin+ezetimibe (SE), atorvastatin+ezetimibe (AE), lovastatin+ezetimibe (LE), or pravastatin+ezetimibe (PE)</p>
</dd>
<dt>n</dt><dd><p>the number of participants in the study corresponding to the trial and treatment</p>
</dd>
<dt>ptg</dt><dd><p>percentage change from baseline in triglycerides (TG)</p>
</dd>
<dt>sdtg</dt><dd><p>sample standard deviation of percentage change in triglycerides (TG)</p>
</dd>
<dt>bldlc</dt><dd><p>baseline LDL-C</p>
</dd>
<dt>bhdlc</dt><dd><p>baseline HDL-C</p>
</dd>
<dt>btg</dt><dd><p>baseline triglycerides (TG)</p>
</dd>
<dt>age</dt><dd><p>age in years</p>
</dd>
<dt>white</dt><dd><p>the proportion of white participants</p>
</dd>
<dt>male</dt><dd><p>the proportion of male participants</p>
</dd>
<dt>bmi</dt><dd><p>body fat index</p>
</dd>
<dt>potencymed</dt><dd><p>the proportion of medium statin potency</p>
</dd>
<dt>potencyhigh</dt><dd><p>the proportion of high statin potency</p>
</dd>
<dt>durat</dt><dd><p>duration in weeks</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(TNM)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
