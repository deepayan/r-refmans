<!DOCTYPE html><html><head><title>Help for package gbutils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gbutils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjacencyOfClasses'><p>Adjacency graph of classes in packages</p></a></li>
<li><a href='#cdf2quantile'>
<p>Calculate a quantile from a distribution function</p></a></li>
<li><a href='#isargunnamed'><p> Is an element of a list named?</p></a></li>
<li><a href='#isNA'><p>Check if an object is NA</p></a></li>
<li><a href='#mintersect'><p>Set intersection of arbitrary number of arguments</p></a></li>
<li><a href='#missing_arg'><p>Check if an element of a pairlist is missing</p></a></li>
<li><a href='#myouter'><p> Functions for some basic operations</p></a></li>
<li><a href='#nposargs'><p> Function to count the number of positional arguments used in a call</p></a></li>
<li><a href='#objectPad-class'><p>Class &quot;objectPad&quot; objects and methods to store and retrieve information</p></a></li>
<li><a href='#pad-methods'>
<p>Store and get data in pad objects</p></a></li>
<li><a href='#parse_text'><p>Parse expressions residing in character vectors</p></a></li>
<li><a href='#plotpdf'>
<p>Plot a probability denstity function</p></a></li>
<li><a href='#pseudoInverse'><p>Compute a pseudo-inverse matrix</p></a></li>
<li><a href='#raw_history'><p> Get the command history</p></a></li>
<li><a href='#rpoly'><p>Polynomials with real coefficients</p></a></li>
<li><a href='#sim_complex'><p> Simulate real or complex numbers using polar form</p></a></li>
<li><a href='#sim_numbers'><p> Simulation based on polar form specifications</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Utilities for Simulation, Plots, Quantile Functions and
Programming</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-27</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, Rdpack (&ge; 0.9)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), classGraph, graph, Rgraphviz</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Description:</td>
<td>Plot density and distribution functions with automatic selection of
       suitable regions. Numerically invert (compute quantiles) distribution
       functions. Simulate real and complex numbers from distributions of their
       magnitude and arguments. Optionally, the magnitudes and/or arguments may
       be fixed in almost arbitrary ways. Create polynomials from roots given in
       Cartesian or polar form. Small programming utilities: check if an object
       is identical to NA, count positional arguments in a call, set
       intersection of more than two sets, check if an argument is unnamed,
       compute the graph of S4 classes in packages.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/GeoBosh/gbutils">https://github.com/GeoBosh/gbutils</a> (devel),
<a href="https://geobosh.github.io/gbutils/">https://geobosh.github.io/gbutils/</a> (website)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GeoBosh/gbutils/issues">https://github.com/GeoBosh/gbutils/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>parse_text.R sim_numbers.R isNA.R mintersect.R pad.R args.R
history.R cdf2qf.R S4utils.R pseudoInverse.R rpoly.R</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-27 07:31:07 UTC; georgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Georgi N. Boshnakov [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-27 09:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjacencyOfClasses'>Adjacency graph of classes in packages</h2><span id='topic+adjacencyOfClasses'></span>

<h3>Description</h3>

<p>Get inheritance graph of classes in one or more packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacencyOfClasses(packages, externalSubclasses = FALSE, 
                   result = c("default", "matrixOfPairs", "adjacencyMatrix"), 
                   Wolfram = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacencyOfClasses_+3A_packages">packages</code></td>
<td>
<p>names of one or more packages, a character vector</p>
</td></tr>
<tr><td><code id="adjacencyOfClasses_+3A_externalsubclasses">externalSubclasses</code></td>
<td>

<p>if <code>TRUE</code>, exclude subtrees of classes not defined in any of the
packages listed in argument <code>packages</code>.
</p>
</td></tr>
<tr><td><code id="adjacencyOfClasses_+3A_result">result</code></td>
<td>

<p>format of the result, can be missing or one of
<code>"default"</code>, <code>"matrixOfPairs"</code>, <code>"adjacencyMatrix"</code>,
see Details. 
</p>
</td></tr>
<tr><td><code id="adjacencyOfClasses_+3A_wolfram">Wolfram</code></td>
<td>

<p>if <code>TRUE</code>, print a suitable graph expression to be run by
Mathematica, see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code style="white-space: pre;">&#8288;
&#8288;</code>
</p>
<p><code>adjacencyOfClasses</code> computes a graph representation of the
dependencies of S4 classes defined in one or more packages (as
specified by argument <code>package</code>) and returns a list.  The
contents of the list returned by <code>adjacencyOfClasses</code> depend on
argument <code>result</code>.  Partial matching is used for the value of
argument <code>result</code>, e.g., &quot;adj&quot; is equivalent to
&quot;adjacencyMatrix&quot;.
</p>
<p>If <code>externalSubclasses = FALSE</code>, the default, subclasses defined
outside the requested packages are excluded. This is typically what
the user will be looking for. To get a complete tree, set
<code>externalSubclasses</code> to <code>TRUE</code>.
</p>
<p>The S4 classes are represented by the vertices of the graph.
Component <code>"vertices"</code> of the result gives them as a character
vector. References below to the <code class="reqn">i</code>th class or vertex
correspond to the order in this vector. No attempt is made to arrange
the vertices in a particular order. An empty list is returned if this
vector is empty.
</p>
<p>If <code>result</code> is missing or <code>"default"</code>, the edges of the
graph are represented by a character vector. Each  edge is represented
by a string with an arrow <code>"-&gt;"</code> from a superclass to a
subclass. Here is an example that shows that this package defines one
class, which is a subclass of <code>"list"</code>:
</p>
<pre>adjacencyOfClasses("gbutils")
##: $vertices
##: [1] "objectPad" "list"     

##: $edges
##: [1] "list -&gt; objectPad"

</pre>

<p>This illustrates the effect of argument <code>"externalSubclasses"</code>:
</p>
<pre>adjacencyOfClasses("gbutils", externalSubclasses = TRUE)
##: $vertices
##: [1] "objectPad" "list"      "vector"   

##: $edges
##: [1] "list -&gt; objectPad" "vector -&gt; list"   

</pre>

<p>The edge, &quot;vector -&gt; list&quot; was omitted in the previous example since
this relationship is defined elsewhere. This resulted in class
<code>"vector"</code> being dropped also from the vertices, since it is not
defined in <code>"gbutils"</code> and none of the remaining edges contains
it.
</p>
<p>If <code>result</code> is <code>"matrixOfPairs"</code>, the edges of the
graph are represented by a character matrix with two columns, where each row 
represents an edge from the element in the first column to the element
in the second. In this example there is one edge, so the matrix
contains one row:
</p>
<pre>adjacencyOfClasses("gbutils", result = "matrixOfPairs")
##: $vertices
##: [1] "objectPad" "list"     

##: $edges
##:      [,1]   [,2]       
##: [1,] "list" "objectPad"

</pre>

<p>If <code>result</code> is <code>"adjacencyMatrix"</code>, the adjacency matrix of
the graph is in component &quot;AM&quot; of the returned list. Element <code class="reqn">(i,j)</code> of
this matrix is equal to one, if the <code class="reqn">j</code>th class is a superclass
to the <code class="reqn">i</code>th. In other words, the <code class="reqn">j</code>th column gives the
superclasses of the <code class="reqn">i</code>th class. Here the element in position
(1,2) is non-zero, so <code>"list"</code> is the superclass of <code>"objectPad"</code>:
</p>
<pre>adjacencyOfClasses("gbutils", result = "adjacencyMatrix")
##: $vertices
##: [1] "objectPad" "list"     

##: $AM
##:           objectPad list
##: objectPad         0    1
##: list              0    0

</pre>

<p>Note that including the vertices in the result is not redundant, since
some may not be in any edge. This can happen if a class does not
have any superclasses and subclasses.
</p>
<p>As described above the result is not converted to a graph object but
it can be fed to functions provided by a number of <span class="rlang"><b>R</b></span> packages. 
</p>
<p>An additional option is to use argument <code>Wolfram</code>.  If
<code>Wolfram</code> is <code>TRUE</code>, a suitable Mathematica command is
printed. It can be evaluated in a Mathematica session (e.g., by
copy/paste) to produce a graphical representation of the graph and/or
be manipulated further by it. This feature is a side effect, the
return value of <code>adjacencyOfClasses</code> is as controlled by the
other arguments. For example, the return value below is as without
argument <code>"Wolfram"</code> but, in addition, the printed line defines a
Wolfram language graph in terms of its vertices and edges:
</p>
<pre>adjacencyOfClasses("gbutils", Wolfram = TRUE)
##: Graph[{objectPad,list}, {list -&gt; objectPad}, VertexLabels -&gt; Automatic] 

##: $vertices
##: [1] "objectPad" "list"     

##: $edges
##: [1] "list -&gt; objectPad"

</pre>

<p>Setting <code>result = "adjacencyMatrix"</code> in the last <span class="rlang"><b>R</b></span> command
exports the graph in terms of its adjacency matrix:
</p>
<pre>adjacencyOfClasses("gbutils", Wolfram = TRUE, result = "adjacencyMatrix")
##: AdjacencyGraph[{objectPad,list}, {{0, 0},
##: {1, 0} }
##: , VertexLabels -&gt; Automatic] 

##: $vertices
##: [1] "objectPad" "list"     

##: $AM
##:           objectPad list
##: objectPad         0    1
##: list              0    0

</pre>



<h3>Value</h3>

<p>a list with some of the following components (as described in Details):
</p>
<table>
<tr><td><code>vertices</code></td>
<td>
<p>a character vector of S4 class names,</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>
<p>the edges of the graph, in the format controlled by
argument <code>results</code> (not present when <code>result</code> is equal to
<code>"adjacencyMatrix"</code>),</p>
</td></tr>
<tr><td><code>AM</code></td>
<td>
<p>the adjacency matrix of the graph (present only when
<code>result</code> is <code>"adjacencyMatrix"</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Gentleman R, Whalen E, Huber W, Falcon S (2017).
<em>graph: A package to handle graph data structures</em>.
R package version 1.56.0.
</p>
<p>Hansen KD, Gentry J, Long L, Gentleman R, Falcon S, Hahne F, Sarkar D (2017).
<em>Rgraphviz: Provides plotting capabilities for R graph objects</em>.
R package version 2.22.0.
</p>
<p>Maechler M (2015).
<em>classGraph: Construct Graphs of S4 Class Hierarchies</em>.
(partly based on code from Robert Gentleman) R package version 0.7-5, <a href="https://CRAN.R-project.org/package=classGraph">https://CRAN.R-project.org/package=classGraph</a>.
</p>


<h3>See Also</h3>

<p><code>?methods::classesToAM</code> which is used for the main computation
here,
</p>
<p>Maechler (2015) for a suite of related functions.
Gentleman et al. (2017) for creation and manipulation of
graphs, and Hansen et al. (2017) for
visualisation of graphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adjacencyOfClasses("gbutils")
adjacencyOfClasses("gbutils", TRUE)

adjacencyOfClasses("gbutils", FALSE, "matrixOfPairs")
adjacencyOfClasses("gbutils", TRUE,  "matrixOfPairs")

adjacencyOfClasses("gbutils", FALSE, "adjacencyMatrix")
adjacencyOfClasses("gbutils", TRUE,  "adjacencyMatrix")

## as above, also represent the graph using the edges
adjacencyOfClasses("gbutils", Wolfram = TRUE)
adjacencyOfClasses("gbutils", TRUE, Wolfram = TRUE)

## here the graph is represented by the adjacency matrix: 
adjacencyOfClasses("gbutils", FALSE, "adjacencyMatrix", Wolfram = TRUE)
adjacencyOfClasses("gbutils", TRUE,  "adjacencyMatrix", Wolfram = TRUE)

if(requireNamespace("graph", quietly = TRUE) &amp;&amp;
   requireNamespace("Rgraphviz", quietly = TRUE)) withAutoprint({
    ## another package
    adjacencyOfClasses("graph")
    ac1 &lt;- adjacencyOfClasses("graph", FALSE, "adjacencyMatrix")
    ## note the use of t() below
    gr_ac1 &lt;- graph::graphAM(adjMat = t(ac1$AM), edgemode = "directed")
    if(require("Rgraphviz", quietly = TRUE, warn.conflicts = FALSE))
        plot(gr_ac1)
    ## more than one package
    ac2 &lt;- adjacencyOfClasses(c("graph", "Rgraphviz"), FALSE, "adjacencyMatrix")
    gr_ac2 &lt;- graph::graphAM(adjMat = t(ac2$AM), edgemode = "directed")
    if(require("Rgraphviz", quietly = TRUE))
        plot(gr_ac2)
})
</code></pre>

<hr>
<h2 id='cdf2quantile'>
Calculate a quantile from a distribution function
</h2><span id='topic+cdf2quantile'></span>

<h3>Description</h3>

<p>Numerically calculate a quantile from a distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf2quantile(p, cdf, interval = c(-3, 3), lower = min(interval),
      upper = max(interval), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf2quantile_+3A_p">p</code></td>
<td>
<p> a number in the interval (0,1).  </p>
</td></tr>
<tr><td><code id="cdf2quantile_+3A_cdf">cdf</code></td>
<td>
<p>cumulative distribution function, a function.</p>
</td></tr>
<tr><td><code id="cdf2quantile_+3A_interval">interval</code></td>
<td>
<p>interval in which to look for the root, see Details.</p>
</td></tr>
<tr><td><code id="cdf2quantile_+3A_lower">lower</code></td>
<td>
<p>lower end point of the interval.</p>
</td></tr>
<tr><td><code id="cdf2quantile_+3A_upper">upper</code></td>
<td>
<p>upper end point of the interval.</p>
</td></tr>
<tr><td><code id="cdf2quantile_+3A_...">...</code></td>
<td>
<p>any further arguments to be passed to the root finding
function and the cdf, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quantile, <code class="reqn">q</code>, is computed numerically as the solution of the
equation <code class="reqn">cdf(q)-p=0</code>.
</p>
<p>Function <code>uniroot</code> is used to find the root.  To request higher
precision, set argument <code>tol</code>.  Other arguments in <code>...</code> are
passed on to <code>cdf</code>.
</p>
<p><code>uniroot</code> needs an interval where to look for the root.
There is a default one, which is extended automatically if it does not
contain the quantile. This assumes that argument <code>cdf</code> is an
increasing function (as it should be).
</p>
<p>To override the default interval, use argument <code>interval</code> (a
vector of two numbers) or <code>lower</code> and/or <code>upper</code>. This may
be necessary if the support of the distribution is not the whole real
line and <code>cdf</code> does not cope with values outside the support of
the distribution.
</p>


<h3>Value</h3>

<p>The computed quantile as a number.</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotpdf">plotpdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdf2quantile(0.95, pnorm)
cdf2quantile(0.05, pexp)   # support [0,Inf) is no problem for
cdf2quantile(0.05, plnorm) # for built-in distributions.

## default predicision is about 4 digits after decimal point
cdf2quantile(0.95, pnorm, mean = 3, sd = 1)
cdf2quantile(0.05, pnorm, mean = 3, sd = 1)
qnorm(c(0.95, 0.05), mean = 3, sd = 1)

## request a higher precision:
cdf2quantile(0.05, pnorm, mean = 3, sd = 1, tol = 1e-8)
cdf2quantile(0.05, pnorm, mean = 3, sd = 1, tol = 1e-12)

## see also examples for plotpdf()
</code></pre>

<hr>
<h2 id='isargunnamed'> Is an element of a list named? </h2><span id='topic+isargunnamed'></span>

<h3>Description</h3>

<p>Check if a component of a list is not named.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isargunnamed(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isargunnamed_+3A_x">x</code></td>
<td>
<p> a list. </p>
</td></tr>
<tr><td><code id="isargunnamed_+3A_k">k</code></td>
<td>
<p> an integer, specifies a position in <code>x</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>isargunnamed(x,k)</code> returns TRUE if the k-th component of
<code>x</code> is not named and FALSE otherwise.
</p>
<p>Argument <code>x</code> is typically a list of arguments used in a call
to a function, such as the one obtained by <code>list(...)</code> in the
body of a function definition.
</p>
<p>If <code>k</code> is not positive, <code>isargunnamed</code> returns FALSE.
</p>


<h3>Value</h3>

<p>TRUE or FALSE
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match.call">match.call</a></code> in base package</p>


<h3>Examples</h3>

<pre><code class='language-R'>li1 &lt;- list(a=1, 2, 3)
isargunnamed(li1, 1)
isargunnamed(li1, 2)

## wholly unnamed list
li2 &lt;- list(1, 2, 3)
isargunnamed(li2, 1)
isargunnamed(li2, 2)

## using in a function definition
f1 &lt;- function(...){
    dots &lt;- list(...)
    for(i in seq(along=dots))
        cat(i, isargunnamed(dots, i), "\n")
}

f1(1)
f1(a = 3, 4, c = 5)
f1(x = "a", y = "b")
</code></pre>

<hr>
<h2 id='isNA'>Check if an object is NA</h2><span id='topic+isNA'></span>

<h3>Description</h3>

<p>Check if an object is NA. Always return TRUE of FALSE, a logical
vector of length one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNA(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNA_+3A_x">x</code></td>
<td>
<p>any R object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>isNA</code> returns TRUE if the argument is a single NA, i.e. it is
atomic, has length one, and represents an NA value. In any other case
<code>isNA</code> returns <code>FALSE</code>. 
</p>
<p><code>isNA</code> is suitable for use in conditional constructs since it
always returns a single value which is never NA.
</p>
<p>Note that <code>identical()</code> distinguishes different types of NA,
i.e. <code>identical(x, NA)</code> is TRUE only if <code>x</code> is NA (logical).
</p>


<h3>Value</h3>

<p>TRUE or FALSE
</p>


<h3>Note</h3>

<p>The requirement that <code>x</code> is atomic means that
<code>isNA(list(NA))</code> gives <code>FALSE</code>.
</p>
<p>For comparison, <code>is.na(list(NA))</code> gives <code>TRUE</code>.  The same
holds for classed lists, such as <code>is.na(structure(list(NA), class
  = "myclass"))</code>.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+isTRUE">isTRUE</a></code>, <code><a href="Matrix.html#topic+is.na">is.na</a></code>,  <code><a href="base.html#topic+identical">identical</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- c(1, NA, 3)
isNA(v[2]) # TRUE

## a vector of two or more Na's is not isNA
isNA(rep(NA,3)) # FALSE

## a list containing NA is not isNA
isNA(list(NA)) # FALSE
## ... but
is.na(list(NA))  # TRUE

## identical() distinguishes different types of NA:
class(v) # "numeric", not "integer"

identical(v[2], NA)          # FALSE, NA on its own is "logical"
identical(v[2], NA_integer_) # FALSE
identical(v[2], NA_real_)    # TRUE


vi &lt;- c(1L, NA_integer_, 3L)
isNA(vi[2]) # TRUE

class(vi) # "integer"
identical(vi[2], NA_integer_) # TRUE
identical(vi[2], NA_real_)    # FALSE

## is.na(NULL) would give a warning
isNA(NULL) # FALSE

## a length zero object is not NA, so isNA() returns FALSE:
isNA(logical(0)) # FALSE

## is.na() has a different remit and returns a 0-length vector:
is.na(logical(0))  # logical(0)
</code></pre>

<hr>
<h2 id='mintersect'>Set intersection of arbitrary number of arguments</h2><span id='topic+mintersect'></span>

<h3>Description</h3>

<p>Set intersection of arbitrary number of arguments.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mintersect(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mintersect_+3A_...">...</code></td>
<td>
<p>arguments to be intersected, vectors of the same mode,
see <code>intersect</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The base <span class="rlang"><b>R</b></span> function <code>intersect</code> is a binary
operation. <code>mintersect</code> works with any positive number of
arguments.
</p>
<p>If called with one argument, <code>mintersect</code> returns it. This is
unlike <code>intersect</code> which gives an error in this case.
</p>
<p>Calling <code>mintersect</code> with no arguments is an error (as it is for
<code>intercect</code>).
</p>


<h3>Value</h3>

<p>a vector representing the intersection of the arguments
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>mintersect(1:20, 3:18, 7:12)
mintersect(letters[1:20], letters[3:18], letters[7:12])
mintersect(1:4)
</code></pre>

<hr>
<h2 id='missing_arg'>Check if an element of a pairlist is missing</h2><span id='topic+missing_arg'></span>

<h3>Description</h3>

<p>Check if an element of a pairlist is missing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_arg(arg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_arg_+3A_arg">arg</code></td>
<td>
<p>the object to test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument passed to <code>missing_arg</code> is typically an element of a
<code>pairlist</code> or the list produced by <code>alist()</code>. <code>missing_arg</code>
returns <code>TRUE</code> if it is missing and <code>FALSE</code> otherwise.
</p>
<p>Objects of type <code>pairlist</code> come up at R level almost exclusively
as the formal arguments of functions. <code>missing_arg</code> can be useful
when they are manipulated programmatically.
</p>


<h3>Value</h3>

<p>TRUE or FALSE
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>lmargs &lt;- formals(lm)
class(lmargs) # pairlist
missing_arg(lmargs$data)
## which arguments of lm() have no (explicit) defaults?
sapply(lmargs, missing_arg)

## This gives an error:
## pairlist(x = 3, y = , z = 5)

## an example with alist()
pl2 &lt;- alist(a = "", b = , c = 3)
class(pl2) # list
## this shows that 'b' is missing, 'a' and 'c' are not:
sapply(pl2, missing_arg) # FALSE  TRUE FALSE
## superficially, 'b' is equal to the empty string:
pl2[[2]]
sapply(pl2, function(x) x == "") # TRUE  TRUE FALSE

## with pairlist the results are the same:
g &lt;- function(a = "", b, c = 3) NULL
a.g &lt;- formals(g)
class(a.g) # pairlist
sapply(a.g, missing_arg) # FALSE  TRUE FALSE
a.g[[2]]
sapply(a.g, function(x) x == "") # TRUE  TRUE FALSE
</code></pre>

<hr>
<h2 id='myouter'> Functions for some basic operations </h2><span id='topic+myouter'></span><span id='topic+shiftleft'></span><span id='topic+shiftright'></span>

<h3>Description</h3>

<p> Small utility functions </p>


<h3>Usage</h3>

<pre><code class='language-R'>myouter(x, y, fun)
shiftleft(x, k = 1)
shiftright(x, k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myouter_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="myouter_+3A_y">y</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="myouter_+3A_k">k</code></td>
<td>
<p>a non-negative integer.</p>
</td></tr>
<tr><td><code id="myouter_+3A_fun">fun</code></td>
<td>
<p>a function, see &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>myouter(x,y,fun)</code> computes the outer product of <code>x</code> and
<code>y</code> using the function <code>fun</code>. The result is a matrix with
<code class="reqn">(i,j)</code>th element equal to <code>fun(x[i],y[j])</code>. It is not
required for fun to be able to work with vector arguments. The function
does the computations in <span class="rlang"><b>R</b></span> using a simple double loop. So, it is a
convenience function, not a speed improving one.
</p>
<p><code>shiftright(x,k)</code> rotates the vector <code>x</code> <code>k</code> positions
to the right.
</p>
<p><code>shiftleft(x,k)</code> rotates the vector <code>x</code> <code>k</code> positions to
the left.
</p>


<h3>Value</h3>

<p>for <code>myouter</code>, a matrix, as described in &lsquo;Details&rsquo;
</p>
<p>for <code>shiftleft</code> and <code>shiftright</code>, a vector
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='nposargs'> Function to count the number of positional arguments used in a call </h2><span id='topic+nposargs'></span>

<h3>Description</h3>

<p>Calculates the number of positional arguments used in a call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nposargs(x, a = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nposargs_+3A_x">x</code></td>
<td>
<p> a call object, usually obtained from <code>sys.call()</code>. </p>
</td></tr>
<tr><td><code id="nposargs_+3A_a">a</code></td>
<td>

<p>if <code>a[1]</code> is <code>TRUE</code> make a correction to distinguish
<code>x[]</code> from <code>x[i]</code>, see details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nposargs</code> is mainly for use in the body of function definitions,
paricularly for functions or methods that wish to mimic the behaviour
of <code>"["</code>.
</p>
<p><code>nposargs</code> gives the number of positional arguments used in a
call. It also takes into account empty arguments like those used in
expressions like <code>x[1, ]</code>.
</p>
<p>Optionally, it makes a particular correction that is peculiar
for &quot;[&quot; - if there are no named arguments in the call and the count
of the arguments is 2 and <code>a[1]=TRUE</code>, it decreases the count by
one, i.e. returns 1. This is to distinguish between a <code>x[]</code> and
<code>x[i]</code> which both would give 2 otherwise. I have forgotten the details but,
roughly speaking, x[i] becomes &quot;[&quot;(x,i) while x[] becomes &quot;[&quot;(x,),
i.e. <span class="rlang"><b>R</b></span> puts the comma after x in any case.
</p>


<h3>Value</h3>

<p>the number of positional arguments in the call
</p>


<h3>Note</h3>

<p>I wrote this function (a long time ago) for use in methods for
<code>"["</code>.
</p>
<p><code>a[1]</code> above is typically obtained by a call <code>missing(i)</code>
somewhere at the beginning of the function. In my application I put
the results of several such calls in a vector, hence the check for
<code>a[1]</code> rather than <code>a</code>, For <code>"["</code>, we may set
<code>a = c(missing(i), missing(j), missing(k))</code>.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x,y,z,...){
    call &lt;- sys.call()
    nposargs(call)
}
f(a,b,c)  # 3
f(a, , )  # 3
f(a,  )   # 2
f(a)      # 1
f(,  )    # 2
f(, a,  ) # 3
f()       # 0
</code></pre>

<hr>
<h2 id='objectPad-class'>Class &quot;objectPad&quot; objects and methods to store and retrieve information </h2><span id='topic+objectPad-class'></span><span id='topic+pad+3C-+2CobjectPad-method'></span><span id='topic+initialize+2CobjectPad-method'></span>

<h3>Description</h3>

<p>Objects of class &quot;objectPad&quot; can be used as storage of information.
There are methods for storage and retrieval.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("objectPad",
...)</code>.  Currently the <code>...</code> arguments are ignored and an empty
object is created.
</p>
<p>Objects of class &quot;objectPad&quot; have no user-level slots. Values are stored
and retrieved with the function <code>pad</code>, for the former purpose using
it on the left-hand side of an assignment.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code>, inherited from <code>"list"</code>. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+list-class">list</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;list&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "objectPad")</code>: ... </p>
</dd>
<dt>pad</dt><dd><p><code>signature(x = "objectPad", item = "missing")</code>: ... </p>
</dd>
<dt>pad</dt><dd><p><code>signature(x = "objectPad", item = "ANY")</code>: ... </p>
</dd>
<dt>pad&lt;-</dt><dd><p><code>signature(x = "objectPad")</code>: ... </p>
</dd>
</dl>



<h3>Note</h3>

<p>The methods for this class are set to work directly on objects from
classes that have slot <code>pad</code> of class <code>objectPad</code>.  Classes
may define additional methods for the function <code>pad</code> (it is
generic) to adapt it to their needs.
</p>






<h3>Author(s)</h3>

<p> Georgi Boshnakov </p>


<h3>See Also</h3>

<p><code><a href="#topic+pad-methods">pad-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a pad and store some info.
pa &lt;- new("objectPad")
pad(pa,"apple") &lt;- "fruit"
pad(pa,"sweets") &lt;- "sweets"
# pad(pa,"apple","dentist") &lt;- "keeps away from her/him"
# pad(pa,"sweets","dentist") &lt;- "helps meeting her/him"
pad(pa,"young Gauss") &lt;- 100*(100+1)/2
pad(pa,"layman") &lt;- sum(1:100)

pad(pa,"apple")
pad(pa,"sweets")
# pad(pa,"apple","dentist")
# pad(pa,"sweets","dentist")
pad(pa,"young Gauss") - pad(pa,"layman")

# create a class of vectors with a pad
setClass("vecWithPad",representation(x="numeric",pad="objectPad"))
a &lt;- new("vecWithPad",x=1:10)
pad(a,"mean") &lt;- mean(a@x)    # Compute and store the mean, and
pad(a,"mean")                 # retrieve it
</code></pre>

<hr>
<h2 id='pad-methods'>
Store and get data in pad objects
</h2><span id='topic+pad'></span><span id='topic+pad+3C-'></span><span id='topic+pad-methods'></span><span id='topic+pad+2CANY+2CANY-method'></span><span id='topic+pad+2CANY+2Cmissing-method'></span><span id='topic+pad+2CobjectPad+2Cmissing-method'></span><span id='topic+pad+2CobjectPad+2CANY-method'></span><span id='topic+padcheck'></span>

<h3>Description</h3>

<p>Get and store information in a pad.  <code>pad</code> can be used on the
lefthand side of an assignment to store information in an object and
as normal function call to retrieve previously stored information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad(x, item)
pad(x, item, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad-methods_+3A_x">x</code></td>
<td>
<p> the object where the information is stored. </p>
</td></tr>
<tr><td><code id="pad-methods_+3A_item">item</code></td>
<td>
<p> the <code>item</code> to be stored or extracted. </p>
</td></tr>
<tr><td><code id="pad-methods_+3A_value">value</code></td>
<td>
<p> the value to be stored </p>
</td></tr>
<tr><td><code id="pad-methods_+3A_...">...</code></td>
<td>
<p> additional arguments (??? are these  really possible? !!!) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function. There are methods for <code>x</code> of class
<code>objectPad</code>. The generic works with the slot <code>pad</code> of
<code>x</code>.  Currently there is no check if there is one.
</p>
<p>To remove an item use <code>pad(x,item) &lt;- NULL</code>. So, by definition,
items may not have the value <code>NULL</code>.
</p>
<p><code>padcheck</code> checks if <code>item</code> has a value and if so returns
<code>TRUE</code>. Otherwise it returns <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>The requested item.
</p>
<p>If <code>item</code> is missing a named list containing all stored items.
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;objectPad&quot;, item = &quot;missing&quot;</dt><dd>
<p>get all items stored in the pad <code>x</code>, as a named list. </p>
</dd>
<dt>x = &quot;objectPad&quot;, item = &quot;ANY&quot;</dt><dd>
<p>get the requested <code>item</code> from the pad <code>x</code>. </p>
</dd>
<dt>x = &quot;ANY&quot;, item = &quot;missing&quot;</dt><dd>
<p>get all items stored in the pad of <code>x</code> as a named list. </p>
</dd>
<dt>x = &quot;ANY&quot;, item = &quot;ANY&quot;</dt><dd>
<p>get the requested <code>item</code> from the pad of <code>x</code>. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p> Georgi N. Boshnakov </p>


<h3>See Also</h3>

<p><code><a href="#topic+objectPad-class">objectPad</a></code>
</p>

<hr>
<h2 id='parse_text'>Parse expressions residing in character vectors</h2><span id='topic+parse_text'></span>

<h3>Description</h3>

<p>Parse expressions residing in character vectors. Similar to parse() but
keeping or not the source is controlled by an argument rather than
global options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_text(text, ..., keep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_text_+3A_text">text</code></td>
<td>
<p>the text to parse, normally a character vector but can be
anything that <code>parse</code> accepts for this artgument.</p>
</td></tr>
<tr><td><code id="parse_text_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed on to <code>parse</code>.</p>
</td></tr>
<tr><td><code id="parse_text_+3A_keep">keep</code></td>
<td>
<p>required setting for option <code style="white-space: pre;">&#8288;keep.source&#8288;</code>, see
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is like <code>parse(text=text,...)</code>, except that whether or not
the source is kept is controlled by argument <code>keep</code>, not by
<code>options("keep.source")</code>.
</p>
<p><code>parse_text</code> sets <code>options("keep.source")</code> to <code>keep</code>
(if they are different) before calling <code>parse</code> and restores it
afterwards.
</p>


<h3>Value</h3>

<p>an expression representing the parsed text, see <code><a href="base.html#topic+parse">parse</a></code> for
details
</p>


<h3>Note</h3>

<p>The usual setting of option &quot;keep.source&quot; in interactive sessions is
TRUE. However, in &lsquo;R CMD check&rsquo; it is FALSE.
</p>
<p>As a consequence, if the documentation of a package uses functions
that depend on option &quot;keep.source&quot; being <code>TRUE</code>,
then some examples may run fine when copied and pasted in an R session
but (rightly) fail &lsquo;R CMD check&rsquo;.
</p>
<p>The oposite may also happen, in that the documentation passes 'R CMD
check' or Sweave files successfully build but some examples do not
work when copied and pasted in an interactive session.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+parse">parse</a></code>
</p>

<hr>
<h2 id='plotpdf'>
Plot a probability denstity function
</h2><span id='topic+plotpdf'></span>

<h3>Description</h3>

<p>Plot a probability denstity function with x-axis limits determined by
quantiles of the distribution. Quantiles are computed using a quantile
function or cumulative distribution function, whichever is supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotpdf(pdf, qdf, cdf, lq = 0.01, uq = 0.99, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotpdf_+3A_pdf">pdf</code></td>
<td>
<p>probability density to be plotted, a function.</p>
</td></tr>
<tr><td><code id="plotpdf_+3A_qdf">qdf</code></td>
<td>
<p>quantile function to be used for computation of quantiles,
a function.</p>
</td></tr>
<tr><td><code id="plotpdf_+3A_cdf">cdf</code></td>
<td>
<p>cumulative distribution function to be used for computation of quantiles,
a function. This argument is used if <code>qdf</code> is not given, see
&lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="plotpdf_+3A_lq">lq</code></td>
<td>
<p>lower quantile, used in the computation of the left limit.</p>
</td></tr>
<tr><td><code id="plotpdf_+3A_uq">uq</code></td>
<td>
<p>upper quantile, used in the computation of the right limit.</p>
</td></tr>
<tr><td><code id="plotpdf_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed on to the <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots <code>pdf(x)</code> over the interval (xmin,xmax) where
xmin and xmax are the <code>lq</code>th and <code>uq</code>th quantiles,
respectively, of the distribution.  The quantile function,
<code>qdf</code>, is used, if supplied. Otherwise the quantiles are computed
numerically from the cdf.
</p>
<p>Argument <code>pdf</code> is not required to be a pdf, it may be any
function. For example, the same way of choosing the limits may be
appropriate for a plot of the cdf, see the examples.
</p>
<p>Similarly, <code>qdf</code> and <code>cdf</code> need not be related to <code>pdf</code>.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+cdf2quantile">cdf2quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pdf1 &lt;- function(x) dnorm(x, mean = 100, sd = 5)
qdf1 &lt;- function(x) qnorm(x, mean = 100, sd = 5)
cdf1 &lt;- function(x) pnorm(x, mean = 100, sd = 5)

plot(pdf1) # needs to specify 'from' and 'to' args for meaningful plot
plotpdf(pdf1, qdf1)                               # using quantile function
plotpdf(pdf1, cdf = cdf1)                         # using cdf
plotpdf(pdf1, cdf = cdf1, lq = 0.001, uq = 0.999) # ... and non-default quantiles

plotpdf(cdf1, cdf = cdf1, lq = 0.001, uq = 0.999) # plot a cdf


## a mixture distribution:
pf1 &lt;- function(x){
    0.25 * pnorm(x, mean = 3, sd = 0.2) + 0.75 * pnorm(x, mean = -1, sd = 0.5)
}
df1 &lt;- function(x){
    0.25 * dnorm(x, mean = 3, sd = 0.2) + 0.75 * dnorm(x, mean = -1, sd = 0.5)
}

plotpdf(df1, cdf = pf1) # plot the pdf
plotpdf(pf1, cdf = pf1) # plot the cdf

c(cdf2quantile(0.05, pf1), cdf2quantile(0.95, pf1))
</code></pre>

<hr>
<h2 id='pseudoInverse'>Compute a pseudo-inverse matrix</h2><span id='topic+pseudoInverse'></span>

<h3>Description</h3>

<p>Compute a pseudo-inverse matrix using singular value
decomposition and setting very small singular values to zero.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudoInverse(a, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudoInverse_+3A_a">a</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="pseudoInverse_+3A_tol">tol</code></td>
<td>
<p>a number, the threshold for non-zero singular values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The singular value decomposition of <code>a</code> is computed and singular
values smaller than <code>tol</code> are set to zero. The result is formed
using the standard formula.
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
</code></pre>

<hr>
<h2 id='raw_history'> Get the command history </h2><span id='topic+raw_history'></span>

<h3>Description</h3>

<p> Get the command history.</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_history()
</code></pre>


<h3>Details</h3>

<p>The command history is saved to a temporary file with
<code>savehistory</code> and read back into a character vector.
</p>


<h3>Value</h3>

<p>a character vector
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
hist &lt;- raw_history()
length(hist)

## End(Not run)
</code></pre>

<hr>
<h2 id='rpoly'>Polynomials with real coefficients</h2><span id='topic+rpoly'></span>

<h3>Description</h3>

<p>Compute the coefficients of a polynomial with real coefficients, given
its real zeroes (roots) and one representative for each complex pair.
If complex numbers are given in polar form, there is an option to
specify the complex arguments as multiples of <code class="reqn">\pi</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpoly(x = numeric(0), arg = numeric(0), real = numeric(0), argpi = FALSE,
      monic = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpoly_+3A_x">x</code></td>
<td>

<p>if <code>complex</code>, the roots (including the real ones), otherwise
the moduli of the complex roots of the polynomial.  In both cases
only one representative for each complex pair should be included.
</p>
</td></tr>
<tr><td><code id="rpoly_+3A_arg">arg</code></td>
<td>

<p>the complex arguments corresponding to the moduli in <code>x</code>. This
argument is not needed when <code>x</code> is complex.
</p>
</td></tr>
<tr><td><code id="rpoly_+3A_real">real</code></td>
<td>

<p>the real roots of the polynomial. This argument is not needed when
<code>x</code> is complex.
</p>
</td></tr>
<tr><td><code id="rpoly_+3A_argpi">argpi</code></td>
<td>

<p>if <code>TRUE</code>, then <code>arg</code> represents the complex arguments as
a multiple of <code class="reqn">\pi</code>, see section &lsquo;Details&rsquo;. The default
is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="rpoly_+3A_monic">monic</code></td>
<td>

<p>if <code>TRUE</code>, the default, the coefficient of the highest term of
the polynomialis is set to 1. if <code>FALSE</code>, the constant term is
one.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The complex zeroes of polynomials with real coefficients come in
complex conjugated pairs. Only one representative from each pair
should be supplied to <code>rpoly</code>. The other is added
automatically. Of course, all real roots should be supplied, if any.
</p>
<p>If <code>x</code> is complex, it should contain all real roots and one
representative for each comple pair.
</p>
<p>Otherise, if <code>x</code> is not complex, it contains the moduli of the
numbers and <code>arg</code> contains the complex arguments. The two should
be of equal length.
</p>
<p>With the default <code>FALSE</code> for <code>argpi</code>, the k-th root of the
polynomial is <code>x[k]*cos(arg[k]) + i*x[k]*sin(arg[k])</code>.  If
<code>argpi</code> is <code>TRUE</code> it is <code>x[k]*cos(pi*arg[k]) + i*x[k]*sin(pi*arg[k])</code>.
</p>
<p>By default, a monic polinomial (the coefficient of the highest order
term is 1) is created but if <code>monic</code> is <code>FALSE</code>, the
constant term of the polynomial is set to 1 .
</p>
<p>The options for <code>argpi = TRUE</code> and/or <code>monic = FALSE</code> are
convenient in some applications, e.g., time series analysis and
digital signal processing.
</p>



<h3>Value</h3>

<p>a real vector containing the coefficients of the polynomial.
</p>


<h3>Note</h3>

<p>When <code>argpi</code> is <code>TRUE</code>, <code class="reqn">\cos(\pi a)</code> is computed using
<code>cospi(a)</code>. So this may differ slightly from the equivalent
result obtained with <code>argpi = FALSE</code> and <code>b = pi*a</code>, which
is computed as  <code>cos(b) = cos(pi*a)</code>, see the example.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_numbers">sim_numbers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## z-1
rpoly(real = 1)

## roots 1, i, -i;  p3(z) = (z-1)(z-i)(z+i)
p3 &lt;- rpoly(c(1, 1i))
p3
polyroot(p3)

## using polar for the complex roots (i = e^(i pi/2))
p3a &lt;- rpoly(1, pi/2, real = 1)
p3a
## mathematically, p3a is the same as p3
## but the numerical calculation here gives a slight discrepancy
p3a == p3
p3a - p3

## using argpi = TRUE is somewhat more precise:
p3b &lt;- rpoly(1, 1/2, real = 1, argpi = TRUE)
p3b
p3b == p3
p3b - p3
## indeed, in this case the results for p3b and p3 are identical:
identical(p3b, p3)

## two ways to expand (z - 2*exp(i*pi/4))(z - 2*exp(-i*pi/4))
rpoly(2, pi/4)
rpoly(2, 1/4, argpi = TRUE)

## set the constant term to 1; can be used, say, for AR models
rpoly(2, pi/4, monic = FALSE)
rpoly(2, 1/4, argpi = TRUE, monic = FALSE)
</code></pre>

<hr>
<h2 id='sim_complex'> Simulate real or complex numbers using polar form</h2><span id='topic+sim_complex'></span><span id='topic+sim_real'></span>

<h3>Description</h3>

<p>Simulate complex numbers with given distributions for the modulus and
the argument and real numbers with given distributions for the absolute
value and the sign. Some of the values may be partially or fully
specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_complex(abs, arg, absgen = "runif", absarg = list(0, 1),
                      arggen = runif, argarg = list(-pi, pi), ...)

sim_real(abs, sign, signprob = 0.5, absgen = "runif",
                                    absarg = list(0, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_complex_+3A_abs">abs</code></td>
<td>
<p> vector of absolute values. </p>
</td></tr>
<tr><td><code id="sim_complex_+3A_sign">sign</code></td>
<td>
<p> vector of signs (1 or -1).  </p>
</td></tr>
<tr><td><code id="sim_complex_+3A_signprob">signprob</code></td>
<td>
<p> probability for a positive sign. </p>
</td></tr>
<tr><td><code id="sim_complex_+3A_arg">arg</code></td>
<td>
<p> vector of arguments (of complex numbers). </p>
</td></tr>
<tr><td><code id="sim_complex_+3A_absgen">absgen</code></td>
<td>
<p> generator for the absolute values, a function or a
character string naming a function.
</p>
</td></tr>
<tr><td><code id="sim_complex_+3A_absarg">absarg</code></td>
<td>
<p> arguments for <code>absgen</code>. </p>
</td></tr>
<tr><td><code id="sim_complex_+3A_arggen">arggen</code></td>
<td>
<p> generator for the arguments of the complex numbers, a
function or a string naming a function.
</p>
</td></tr>
<tr><td><code id="sim_complex_+3A_argarg">argarg</code></td>
<td>
<p> arguments for <code>arggen</code>. </p>
</td></tr>
<tr><td><code id="sim_complex_+3A_...">...</code></td>
<td>
<p> not used, simplifies the call from <code>sim_numbers</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sim_real</code> simulates real numbers by simulating separately their
absolute values and signs.  <code>sim_complex</code> simulates complex
numbers by simulating separately their moduli and arguments.
</p>
<p>Both functions replace <code>NA</code>'s in argument <code>abs</code> with values
simulated by the function specified by <code>absgen</code>. Arguments for
<code>absgen</code> are specified by the (possibly named) list
<code>absarg</code>.
</p>
<p>Similarly, <code>sim_complex</code> replaces <code>NA</code>'s in argument
<code>arg</code> with values simulated according to <code>arggen</code> and
<code>argarg</code>.
</p>
<p>Further, <code>sim_real</code> replaces <code>NA</code>'s in argument <code>sign</code>
with a random sample of ones and minus ones, where the probability for
the positive value is <code>signprob</code>.
</p>
<p>Only <code>NA</code> entries in <code>abs</code>, <code>arg</code> and <code>sign</code> are
filled with simulated values, the remaining entries are left
unchanged. This means that some (and even all) values may be
specified partially or completely.
</p>
<p><code>abs</code> is combined with <code>arg</code> or <code>sign</code> to create the
result. These arguments are expected to be of matching shape and
length but this is not enforced and the usual recycling rules will
apply if this is not the case (not recommended to rely on this).
</p>
<p>The default range for the (complex) argument is (-pi,pi).
</p>


<h3>Value</h3>

<p>for <code>sim_real</code>, a vector of real numbers
</p>
<p>for <code>sim_complex</code>, a vector of complex numbers
</p>


<h3>Note</h3>

<p>Currently the shape of the result for <code>sim_real</code> is the same as
that of argument <code>abs</code>. But <code>sim_complex</code> always returns a
vector. Probably this inconsistency should be removed.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_numbers">sim_numbers</a></code> which offers more flexible interface to
these functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## x[1] is fixed to 1, x[2] is negative with random magnitude:
x &lt;- sim_real(c(1,NA,NA,NA), c(1, -1, NA, NA))

## z[1] fixed to 1, the remaining elements of z
## have random magnitude and fixed arguments:
z &lt;- sim_complex(c(1,NA,NA,NA), c(0, pi/2, pi, -pi/2))

## without restrictions
sim_complex(rep(NA,4))
sim_real(rep(NA,4))

## moduli unrestricted; arguments restricted
sim_complex(rep(NA,4), c(0, pi/2, pi, -pi/2))
</code></pre>

<hr>
<h2 id='sim_numbers'> Simulation based on polar form specifications </h2><span id='topic+sim_numbers'></span>

<h3>Description</h3>

<p>Simulate real and complex numbers from polar form specifications. The
numbers may be partially or fully specified. The distributions of
absolute values and arguments/signs are specified independently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_numbers(type = rep(as.character(NA), length(abs)),
            abs = rep(as.numeric(NA), length(type)),
            sign = rep(as.numeric(NA), length(type)), values = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_numbers_+3A_type">type</code></td>
<td>
<p> character vector specifying the types of the eigenvalues,
see Details.</p>
</td></tr>
<tr><td><code id="sim_numbers_+3A_abs">abs</code></td>
<td>
<p> vector of absolute values (moduli).</p>
</td></tr>
<tr><td><code id="sim_numbers_+3A_sign">sign</code></td>
<td>
<p> vector of signs (for reals) and  arguments (for complex
numbers), see Details for interpretation.</p>
</td></tr>
<tr><td><code id="sim_numbers_+3A_values">values</code></td>
<td>
<p>values, see details.</p>
</td></tr>
<tr><td><code id="sim_numbers_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to <code>sim_real</code> and
<code>sim_complex</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<p><code>sim_numbers</code> simulates a vector of real and complex numbers with
given distributions of their polar parts. It is possible also to fix
some of the numbers or one of their polar parts.
The length of the simulated vector is inferred from the length of
<code>type</code> or <code>abs</code>, so one of them must be
provided. <code>sim_numbers</code> is a flexible front-end for
<code>sim_real</code> and <code>sim_complex</code>.
</p>
<p><code>sim_numbers</code> generates a vector of values with types specified
by argument <code>type</code> and/or inferred from argument <code>values</code>.
The recommended way to use <code>sim_numbers</code> is to provide argument
<code>type</code>. 
</p>
<p><code>type[i]</code> specifies the type of the i-th element of the result:
real (<code>type[i]=="r"</code>), complex (<code>type[i]=="c"</code>) or
representing a complex conjugate pair (<code>type[i]=="cp"</code>).  If
<code>values</code> is provided, the imaginary parts of its non-NA elements
are used to fill <code>NA</code> elements of <code>type</code> (&quot;r&quot; if zero, &quot;cp&quot;
otherwise).
</p>
<p>Some (or even all) values may be fixed or partially fixed with the
help of arguments <code>abs</code>, <code>sign</code> and <code>values</code>. A
non-missing value of <code>values[i]</code> fixes the i-th element of the
result to that value. Simlarly <code>abs[i]</code> fixes the modulus and
<code>sign[i]</code> fixes the sign/argument of the i-th element. If
<code>values[i]</code> is not <code>NA</code>, then it takes precedence and
<code>abs[i]</code> and <code>sign[i]</code> are ignored.
</p>
<p>For real numbers <code>sign</code> is the sign with possible values 1
(positive) or -1 (negative). For complex numbers, <code>sign</code> is the
argument and is in the interval (-pi,pi).
</p>
<p>If <code>values</code> is supplied, then <code>NA</code> entries in <code>type</code>
are replaced by &quot;r&quot; or &quot;cp&quot; depending on whether or not the imaginary
parts of the corresponding entries in <code>values</code> are equal to zero.
A check is done for consistency when both <code>type[i]</code> and
<code>values[i]</code> are non-missing. Generally, <code>values</code> is meant to
be used for values that are fixed and available directly in Cartesian
form, to avoid having to fill the corresponding entries of <code>abs</code>
and <code>sign</code>.
</p>
<p><code>NA</code> entries of <code>abs</code> and <code>sign</code> are filled with
simulated values, the remaining entries are considered fixed and left
unchanged. The default generator is uniform (0,1) for <code>abs</code>,
uniform (-pi,pi) for the argument of complex values, and 1 or -1 with
p=1/2 for the sign of real values.
</p>
<p>To specify a different generator for the moduli and absolute values,
use argument <code>absgen</code>, giving it a function or the name of a
function. The arguments for this function can be specified by
<code>absarg</code> (as a list). Similarly, the generator for arguments of
complex numbers can be specified by <code>arggen</code> and <code>argarg</code>.
Finally, the probability for the real numbers to be positive is given
by <code>signprob</code>. These arguments are not in the signature of the
function since they are passed on directly (via <code>"..."</code>) to the
underlying <code>sim_complex</code> and <code>sim_real</code>, see their
documentation and the examples below for further details.
</p>


<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>vector of values; it is of type <code>numeric</code> if
all values are real and <code>complex</code> otherwise.
</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a character vector of the types as above</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Values of type &quot;cp&quot; (complex pairs) are represented by one element, the
complex conjugate elements are NOT generated. (todo: maybe add an
argument to control this)
</p>
<p>The convention for the sign of a real eigenvalue is 1 and -1,
not 0 and pi.


</p>
<p>The checks for consistency between <code>type</code> and <code>values</code> are
not complete and only straightforward use is recommended.
</p>
<p>The current defaults for the arguments, see the signature
above, require that at least one of <code>type</code> and <code>abs</code> is not
missing.
</p>





<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_real">sim_real</a></code>
, <code><a href="#topic+sim_complex">sim_complex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## one real number and one complex conjugated pair
## (maybe to specify a cubic polynomial through its roots)
sim_numbers(type = c("r", "cp"))

## here the real value is fixed to have modulus 1, leaving the sign unspecified
sim_numbers(type = c("r", "cp"), abs = c(1, NA))

## now the real value is fixed to 1,
##     the complex pair has argument  +-pi/2, and free modulus:
sim_numbers(type = c("r", "cp"), abs = c(1, NA), sign = c(0, pi/2))


## using argument 'values' to fix some values;
## here the the third value is fixed:
sim_numbers(type = c("r", "cp", "r"), values = c(NA,NA,3))  # type[3] = "r"
sim_numbers(type = c("r", "cp", "cp"), values = c(NA,NA,3i)) # type[3] = "cp"

## type[3] can be left NA since it can be inferred from values[3]:
sim_numbers(type = c("r", "cp", NA), values = c(NA,NA,3))  # type[3] = "r"
sim_numbers(type = c("r", "cp", NA), values = c(NA,NA,3i)) # type[3] = "cp"

## it is an error to have a mismatch between args `type' and value:
## Not run: 
sim_numbers(type = c("r", "cp", "cp"), values = c(NA,NA,3))
sim_numbers(type = c("r", "cp", "r"), values = c(NA,NA,3i))

## End(Not run)

## simulate 10 reals with the default generators
sim_numbers(rep("r", 10))

## simulate modulus from Rayleigh distribution
##
rR &lt;- function(n, sigma = 1) sigma * sqrt(-2*log(runif(n)))
sim_numbers(type = c("cp", "cp"), absgen = rR, absarg = list())

# test the the components are N(0,1)
## (not run to save time for CRAN check)
## \dontrun{
## v &lt;- sim_numbers(type = rep("cp", 10000), absgen = "rR",
##                  absarg = list(sigma = 1))
## ks.test(Re(v$values), "pnorm")
## ks.test(Im(v$values), "pnorm")
## }
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
