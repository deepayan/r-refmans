<!DOCTYPE html><html><head><title>Help for package fpopw</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fpopw}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compress.data'><p>compress.data</p></a></li>
<li><a href='#Fpop'><p>Fpop</p></a></li>
<li><a href='#Fpop_w'><p>Fpop_w</p></a></li>
<li><a href='#fpopw'><p>fpopw: A package to solve the optimal partionning and segment neighborhood problems using</p>
a weighted L2-loss.</a></li>
<li><a href='#Fpsn'><p>Fpsn</p></a></li>
<li><a href='#Fpsn_w'><p>Fpsn_w</p></a></li>
<li><a href='#Fpsn_w_nomemory'><p>Fpsn_w_nomemory</p></a></li>
<li><a href='#get.change'><p>get.change</p></a></li>
<li><a href='#getSegSums_'><p>getSegSums_</p></a></li>
<li><a href='#getSMT'><p>getSMT</p></a></li>
<li><a href='#getSMT_'><p>getSMT_</p></a></li>
<li><a href='#getTau_nomemory'><p>getTau_nomemory</p></a></li>
<li><a href='#retour_op'><p>retour_op</p></a></li>
<li><a href='#retour_sn'><p>retour_sn</p></a></li>
<li><a href='#saut'><p>saut</p></a></li>
<li><a href='#sdDiff'><p>sdDiff</p></a></li>
<li><a href='#select_Fpsn'><p>select_Fpsn</p></a></li>
<li><a href='#uncompress.smt'><p>decompress.smt</p></a></li>
<li><a href='#uncompress.vec'><p>uncompress.vec</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Weighted Segmentation using Functional Pruning and Optimal
Partioning</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Weighted-L2 FPOP Maidstone et al. (2017) &lt;<a href="https://doi.org/10.1007%2Fs11222-016-9636-3">doi:10.1007/s11222-016-9636-3</a>&gt; and pDPA/FPSN Rigaill (2010) &lt;<a href="https://arxiv.org/abs/1004.0887">arXiv:1004.0887</a>&gt; algorithm for detecting multiple changepoints in the mean of a vector. Also includes a few model selection functions using Lebarbier (2005) &lt;<a href="https://doi.org/10.1016%2Fj.sigpro.2004.11.012">doi:10.1016/j.sigpro.2004.11.012</a>&gt; and the 'capsushe' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-02 06:19:30 UTC; grigaill</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillem Rigaill [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guillem Rigaill &lt;guillem.rigaill@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-05 14:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='compress.data'>compress.data</h2><span id='topic+compress.data'></span>

<h3>Description</h3>

<p>compress data and return a weighted profile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compress.data(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compress.data_+3A_x">x</code></td>
<td>
<p>a numerical vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the compressed profile x and associated repeat vector vrep
</p>

<hr>
<h2 id='Fpop'>Fpop</h2><span id='topic+Fpop'></span>

<h3>Description</h3>

<p>Function to run the Fpop algorithm (Maidstone et al. 2016). It uses functional pruning and optimal partionning. It optimizes the L2-loss for a penalty lambda per change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fpop(x, lambda, mini = min(x), maxi = max(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fpop_+3A_x">x</code></td>
<td>
<p>a numerical vector to segment</p>
</td></tr>
<tr><td><code id="Fpop_+3A_lambda">lambda</code></td>
<td>
<p>the penalty per changepoint (see Maidstone et al. 2016)</p>
</td></tr>
<tr><td><code id="Fpop_+3A_mini">mini</code></td>
<td>
<p>minimum mean segment value to consider in the optimisation.</p>
</td></tr>
<tr><td><code id="Fpop_+3A_maxi">maxi</code></td>
<td>
<p>maximum mean segment value to consider in the optimisation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list with a vector t.est containing the position of the change-points, the number of changes K and, the cost J.est.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(100), rnorm(10^3)+2, rnorm(1000)+1)
est.sd &lt;- sdDiff(x) ## rough estimate of std-deviation
res &lt;- Fpop(x=x,lambda=2*est.sd^2*log(length(x)))
smt &lt;- getSMT(res)
</code></pre>

<hr>
<h2 id='Fpop_w'>Fpop_w</h2><span id='topic+Fpop_w'></span>

<h3>Description</h3>

<p>Function to run the Fpop algorithm (Maidstone et al. 2016) with weights. It uses functional pruning and optimal partionning. It optimizes the weighted L2-loss (<code class="reqn">w_i (x_i - \mu)2</code>) for a penalty lambda per change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fpop_w(x, w, lambda, mini = min(x), maxi = max(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fpop_w_+3A_x">x</code></td>
<td>
<p>a numerical vector to segment.</p>
</td></tr>
<tr><td><code id="Fpop_w_+3A_w">w</code></td>
<td>
<p>a numerical vector of weights (values should be larger than 0).</p>
</td></tr>
<tr><td><code id="Fpop_w_+3A_lambda">lambda</code></td>
<td>
<p>the penalty per changepoint (see Maidstone et al. 2016).</p>
</td></tr>
<tr><td><code id="Fpop_w_+3A_mini">mini</code></td>
<td>
<p>minimum mean segment value to consider in the optimisation.</p>
</td></tr>
<tr><td><code id="Fpop_w_+3A_maxi">maxi</code></td>
<td>
<p>maximum mean segment value to consider in the optimisation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list with a vector t.est containing the position of the change-points, the number of changes K and, the cost J.est.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(100), rnorm(10^3)+2, rnorm(1000)+1)
est.sd &lt;- sdDiff(x) ## rough estimate of std-deviation
res &lt;- Fpop_w(x=x, w=rep(1, length(x)), lambda=2*est.sd^2*log(length(x)))
smt &lt;- getSMT(res)
</code></pre>

<hr>
<h2 id='fpopw'>fpopw: A package to solve the optimal partionning and segment neighborhood problems using
a weighted L2-loss.</h2><span id='topic+fpopw'></span>

<h3>Description</h3>

<p>The fpopw package provides wrapper to four functionnal pruning functions to
to solve the optimal partionning and segment neighborhood problems with the L2-loss:
Fpop, Fpop_w, Fpsn, Fpsn_w
</p>


<h3>fpopw functions</h3>

<p>fpopw functions are Fpop, Fpop_w, Fpsn, Fpsn_w, Fpsn_w_nomemory
</p>

<hr>
<h2 id='Fpsn'>Fpsn</h2><span id='topic+Fpsn'></span>

<h3>Description</h3>

<p>Function to run the pDPA algorithm (Rigaill 2010 and 2015). It uses functional pruning and segment neighborhood. It optimizes the L2-loss for 1 to Kmax changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fpsn(x, Kmax, mini = min(x), maxi = max(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fpsn_+3A_x">x</code></td>
<td>
<p>a numerical vector to segment</p>
</td></tr>
<tr><td><code id="Fpsn_+3A_kmax">Kmax</code></td>
<td>
<p>max number of segments (segmentations in 1 to Kmax segments are recovered).</p>
</td></tr>
<tr><td><code id="Fpsn_+3A_mini">mini</code></td>
<td>
<p>minimum mean segment value to consider in the optimisation</p>
</td></tr>
<tr><td><code id="Fpsn_+3A_maxi">maxi</code></td>
<td>
<p>maximum mean segment value to consider in the optimisation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list with a matrix t.est containing the change-points of the segmentations in 1 to Kmax changes and, the cost J.est in 1 to Kmax changes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(100), rnorm(10^3)+2, rnorm(1000)+1)
res &lt;- Fpsn(x=x, K=100)
select.res &lt;- select_Fpsn(res, method="givenVariance")
smt &lt;- getSMT(res, select.res)
</code></pre>

<hr>
<h2 id='Fpsn_w'>Fpsn_w</h2><span id='topic+Fpsn_w'></span>

<h3>Description</h3>

<p>Function to run the weighted pDPA algorithm (Rigaill 2010 and 2015). It uses functional pruning and segment neighborhood. It optimizes the weighted L2-loss (<code class="reqn">w_i (x_i - \mu)2</code>) for 1 to Kmax changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fpsn_w(x, w, Kmax, mini = min(x), maxi = max(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fpsn_w_+3A_x">x</code></td>
<td>
<p>a numerical vector to segment</p>
</td></tr>
<tr><td><code id="Fpsn_w_+3A_w">w</code></td>
<td>
<p>a numerical vector of weights (values should be larger than 0).</p>
</td></tr>
<tr><td><code id="Fpsn_w_+3A_kmax">Kmax</code></td>
<td>
<p>max number of segments (segmentations in 1 to Kmax segments are recovered).</p>
</td></tr>
<tr><td><code id="Fpsn_w_+3A_mini">mini</code></td>
<td>
<p>minimum mean segment value to consider in the optimisation</p>
</td></tr>
<tr><td><code id="Fpsn_w_+3A_maxi">maxi</code></td>
<td>
<p>maximum mean segment value to consider in the optimisation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list with a matrix t.est containing the change-points of the segmentations in 1 to Kmax changes and, the costs J.est in 1 to Kmax changes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(100), rnorm(10^3)+2, rnorm(1000)+1)
res &lt;- Fpsn_w(x=x, w=rep(1, length(x)), K=100)
select.res &lt;- select_Fpsn(res, method="givenVariance")
smt &lt;- getSMT(res, select.res)
</code></pre>

<hr>
<h2 id='Fpsn_w_nomemory'>Fpsn_w_nomemory</h2><span id='topic+Fpsn_w_nomemory'></span>

<h3>Description</h3>

<p>Function to run the weighted pDPA algorithm (Rigaill 2010 and 2015) without storing the set of last changes. It only return the cost in 1 to Kmax changes. It uses functional pruning and segment neighborhood. It optimizes the weighted L2-loss (<code class="reqn">w_i (x_i - \mu)2</code>) for 1 to Kmax changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fpsn_w_nomemory(x, w, Kmax, mini = min(x), maxi = max(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fpsn_w_nomemory_+3A_x">x</code></td>
<td>
<p>a numerical vector to segment</p>
</td></tr>
<tr><td><code id="Fpsn_w_nomemory_+3A_w">w</code></td>
<td>
<p>a numerical vector of weights (values should be larger than 0).</p>
</td></tr>
<tr><td><code id="Fpsn_w_nomemory_+3A_kmax">Kmax</code></td>
<td>
<p>max number of segments (segmentations in 1 to Kmax segments are recovered).</p>
</td></tr>
<tr><td><code id="Fpsn_w_nomemory_+3A_mini">mini</code></td>
<td>
<p>minimum mean segment value to consider in the optimisation</p>
</td></tr>
<tr><td><code id="Fpsn_w_nomemory_+3A_maxi">maxi</code></td>
<td>
<p>maximum mean segment value to consider in the optimisation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list with the costs J.est in 1 to Kmax changes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- Fpsn_w_nomemory(x=rnorm(10^4), w=rep(1, 10^4), K=100)
</code></pre>

<hr>
<h2 id='get.change'>get.change</h2><span id='topic+get.change'></span>

<h3>Description</h3>

<p>Function returning changes in a smoothed profile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.change(smt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.change_+3A_smt">smt</code></td>
<td>
<p>smoothed profile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of changes including n
</p>

<hr>
<h2 id='getSegSums_'>getSegSums_</h2><span id='topic+getSegSums_'></span>

<h3>Description</h3>

<p>A function to get the segment sums of a vector given some changes including n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSegSums_(x, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSegSums__+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="getSegSums__+3A_tau">tau</code></td>
<td>
<p>changes (including n)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the sums
</p>

<hr>
<h2 id='getSMT'>getSMT</h2><span id='topic+getSMT'></span>

<h3>Description</h3>

<p>A function to get the smoothed profile from the output of Fpop, Fpop_w, Fpsn and Fpsn_w
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSMT(res, K = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSMT_+3A_res">res</code></td>
<td>
<p>output of Fpop, Fpop_w, Fpsn or Fpsn_w</p>
</td></tr>
<tr><td><code id="getSMT_+3A_k">K</code></td>
<td>
<p>the number of changes (only if Fpsn or Fpsn_w)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the smoothed profile
</p>

<hr>
<h2 id='getSMT_'>getSMT_</h2><span id='topic+getSMT_'></span>

<h3>Description</h3>

<p>A function to get the smoothed profile from the data, weights and changepoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSMT_(x, weights = NULL, tauHat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSMT__+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="getSMT__+3A_weights">weights</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="getSMT__+3A_tauhat">tauHat</code></td>
<td>
<p>changes (including n)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the smoothed profile
</p>

<hr>
<h2 id='getTau_nomemory'>getTau_nomemory</h2><span id='topic+getTau_nomemory'></span>

<h3>Description</h3>

<p>function to recover changes for a given selected K after fpsn_nomemory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTau_nomemory(res_fpsn, K_selected)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTau_nomemory_+3A_res_fpsn">res_fpsn</code></td>
<td>
<p>output of the function res_fpsn_nomemory</p>
</td></tr>
<tr><td><code id="getTau_nomemory_+3A_k_selected">K_selected</code></td>
<td>
<p>K obtained using select_Fpsn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a set of changes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(100), rnorm(10^3)+2, rnorm(1000)+1)
res &lt;- Fpsn_w_nomemory(x=x, w=rep(1, length(x)), K=100)
select.res &lt;- select_Fpsn(res, method="givenVariance")
tau &lt;- getTau_nomemory(res, select.res)
smt &lt;- getSMT_(res$signal, res$weights, tau)
</code></pre>

<hr>
<h2 id='retour_op'>retour_op</h2><span id='topic+retour_op'></span>

<h3>Description</h3>

<p>Function used internally by Fpop and Fpop_w to do the backtracking and recover the best set of changes from 1 to i
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retour_op(path, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retour_op_+3A_path">path</code></td>
<td>
<p>vector of length n containing the best last changes for any j in <code class="reqn">[1, n]</code>. This vector is computed in the Fpop and Fpop_w using the colibri_op_c or colibri_op_weight_c function.</p>
</td></tr>
<tr><td><code id="retour_op_+3A_i">i</code></td>
<td>
<p>the last position to consider to start the backtracking.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>set of optimal changes up to i.
</p>

<hr>
<h2 id='retour_sn'>retour_sn</h2><span id='topic+retour_sn'></span>

<h3>Description</h3>

<p>Function used internally by Fpsn and Fpsn_w to do the backtracking and recover the best set of segmentations in 1 to K changes from 1 to n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retour_sn(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retour_sn_+3A_path">path</code></td>
<td>
<p>matrix of size (K x n) containing the last optimal changes up to j in k segments with i in <code class="reqn">[1, n]</code> and k in <code class="reqn">[1, K]</code>. This matrix is computed in the Fpsn or Fpsn_w function using the colibri_sn_c or colibri_sn_weight_c functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of size (K x K) containing the best segmentations in 1 to K segments.
</p>

<hr>
<h2 id='saut'>saut</h2><span id='topic+saut'></span>

<h3>Description</h3>

<p>model selection function taken from S3IB,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saut(Lv, pen, Kseq, n, seuil = sqrt(n)/log(n), biggest = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saut_+3A_lv">Lv</code></td>
<td>
<p>likelihood</p>
</td></tr>
<tr><td><code id="saut_+3A_pen">pen</code></td>
<td>
<p>penalty</p>
</td></tr>
<tr><td><code id="saut_+3A_kseq">Kseq</code></td>
<td>
<p>number of changes</p>
</td></tr>
<tr><td><code id="saut_+3A_n">n</code></td>
<td>
<p>number of datapoints</p>
</td></tr>
<tr><td><code id="saut_+3A_seuil">seuil</code></td>
<td>
<p>threshold</p>
</td></tr>
<tr><td><code id="saut_+3A_biggest">biggest</code></td>
<td>
<p>heuristic (biggest jump or slope)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a selected number of chagnes
</p>

<hr>
<h2 id='sdDiff'>sdDiff</h2><span id='topic+sdDiff'></span>

<h3>Description</h3>

<p>Function to estimate the standard deviation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdDiff(x, method = "MAD")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdDiff_+3A_x">x</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="sdDiff_+3A_method">method</code></td>
<td>
<p>used to estimate the variance : MAD or HALL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a numeric value
</p>

<hr>
<h2 id='select_Fpsn'>select_Fpsn</h2><span id='topic+select_Fpsn'></span>

<h3>Description</h3>

<p>function to select the number of changepoints after Fpsn or Fpsn_w
using the penalty of Lebarbier 2005 given a estimator of the variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_Fpsn(
  res_fpsn,
  method = "givenVariance",
  sigma = sdDiff(res_fpsn$signal)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_Fpsn_+3A_res_fpsn">res_fpsn</code></td>
<td>
<p>output of Fpsn or Fpsn_w containg the costs in J.est and the segmented signal</p>
</td></tr>
<tr><td><code id="select_Fpsn_+3A_method">method</code></td>
<td>
<p>one of (1) &quot;givenVariance&quot; = using the penalty of Lebarbier 2005 given a estimator of the variance, (2) &quot;biggest.S3IB&quot; = biggest=TRUE in saut taken from S3IB, (3) &quot;notbiggest.S3IB&quot;  biggest=FALSE in saut taken from S3IB.</p>
</td></tr>
<tr><td><code id="select_Fpsn_+3A_sigma">sigma</code></td>
<td>
<p>variance used of the selection. If NULL use MAD on unweighted data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return an integer: selected number of changes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(100), rnorm(10^3)+2, rnorm(1000)+1)
res &lt;- Fpsn_w(x=x, w=rep(1, length(x)), K=100)
select.res &lt;- select_Fpsn(res, method="givenVariance")
smt &lt;- getSMT(res, select.res)
</code></pre>

<hr>
<h2 id='uncompress.smt'>decompress.smt</h2><span id='topic+uncompress.smt'></span>

<h3>Description</h3>

<p>vector to decompress a compressed smoothed profile (a call to rep)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncompress.smt(smt.CP, vec.rep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncompress.smt_+3A_smt.cp">smt.CP</code></td>
<td>
<p>smoothed and compressed profile</p>
</td></tr>
<tr><td><code id="uncompress.smt_+3A_vec.rep">vec.rep</code></td>
<td>
<p>weights to use for decompression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector to replicate duplicated datapoints
</p>

<hr>
<h2 id='uncompress.vec'>uncompress.vec</h2><span id='topic+uncompress.vec'></span>

<h3>Description</h3>

<p>return a vector to uncompress a profile, segmentation or smt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncompress.vec(vec.rep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncompress.vec_+3A_vec.rep">vec.rep</code></td>
<td>
<p>integer vector with the number of time each point should be repeated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a vector to uncompress a profile, segmentation or smt
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
