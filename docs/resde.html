<!DOCTYPE html><html><head><title>Help for package resde</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {resde}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bc'><p>Box-Cox transformation</p></a></li>
<li><a href='#resde-package'><p><span class="pkg">resde</span> - Parameter estimation in reducible SDE models.</p></a></li>
<li><a href='#sdefit'><p>Fit SDE model</p></a></li>
<li><a href='#sdemodel'><p>Model specification</p></a></li>
<li><a href='#sdemodel_display'><p>Display the model specification</p></a></li>
<li><a href='#str2fun_theta'><p>String to function, with parameters in theta</p></a></li>
<li><a href='#unitran'><p>Unified transformation</p></a></li>
<li><a href='#userphi'><p>Examples of optional external transformation and derivative functions</p></a></li>
<li><a href='#uvector'><p>ML estimation vector for reducible SDEs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Estimation in Reducible Stochastic Differential Equations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Maximum likelihood estimation for univariate reducible
 stochastic differential equation models. Discrete, possibly noisy
 observations, not necessarily evenly spaced in time. Can fit
 multiple individuals/units with global and local parameters, by
 fixed-effects or mixed-effects methods. Ref.: Garcia, O. (2019)
 "Estimating reducible stochastic differential equations by
 conversion to a least-squares problem", Computational Statistics
 34(1): 23-46, &lt;<a href="https://doi.org/10.1007%2Fs00180-018-0837-4">doi:10.1007/s00180-018-0837-4</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Deriv, nlme, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ogarciav/resde/">https://github.com/ogarciav/resde/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ogarciav/resde/issues">https://github.com/ogarciav/resde/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-18 15:49:47 UTC; oscar</td>
</tr>
<tr>
<td>Author:</td>
<td>Oscar Garcia <a href="https://orcid.org/0000-0002-8995-1341"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Oscar Garcia &lt;garcia@dasometrics.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-19 17:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='bc'>Box-Cox transformation</h2><span id='topic+bc'></span><span id='topic+bc_inv'></span><span id='topic+bc_prime'></span>

<h3>Description</h3>

<p>These functions calculate the Box-Cox transformation, its inverse, and derivative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bc(x, lambda)

bc_inv(y, lambda)

bc_prime(y, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bc_+3A_x">x</code>, <code id="bc_+3A_y">y</code></td>
<td>
<p>Numeric vector (<code>x</code> must be &gt;= 0).</p>
</td></tr>
<tr><td><code id="bc_+3A_lambda">lambda</code></td>
<td>
<p>Numeric scalar, power parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bc()</code> uses <code>expm1()</code>, wich is more accurate
for small <code>lambda</code> than a more &quot;obvious&quot; alternative like
</p>
<pre>  if (abs(lambda) &lt; 6e-9) log(y)
 else (y^lambda - 1) / lambda</pre><p> The difference might be important
in optimization applications. See example below. Similarly,
<code>bc_inv()</code> uses <code>log1p()</code>.
</p>


<h3>Value</h3>

<p><code>bc()</code>: Returns the transform value(s).
</p>
<p><code>bc_inv()</code>: Computes the inverse of <code>bc()</code>.
</p>
<p><code>bc_prime()</code>: Gives the derivative of <code>bc()</code>
with respect to <code>y</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>bc()</code>: The Box-Cox transformation
</p>
</li>
<li> <p><code>bc_inv()</code>: Inverse of the Box-Cox transformation
</p>
</li>
<li> <p><code>bc_prime()</code>: Derivative of the Box-Cox transformation
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>bc(0.5, 1.5)
bc(1, 0)
obvious &lt;- function(lambda){(0.6^lambda - 1) / lambda} # at y = 0.6
plot(obvious, xlab="lambda", xlim=c(1e-6, 1e-9), log="x")

bc_inv(-0.4, 1.5)
bc_inv(0, 0)

bc_prime(0.5, 1.5)
bc_prime(1, 0)

</code></pre>

<hr>
<h2 id='resde-package'><span class="pkg">resde</span> - Parameter estimation in reducible SDE models.</h2><span id='topic+resde'></span><span id='topic+resde-package'></span>

<h3>Description</h3>

<p>The main functions for model fitting are <code><a href="#topic+sdemodel">sdemodel</a>()</code>
and <code><a href="#topic+sdefit">sdefit</a>()</code>. First, specify the model structure in
<code>sdemodel()</code>, including the variable transformation, any
re-parameterizations, initial condition, and the presence or not of process,
measurement, and initial condition noise. Then, fit the model with
<code>sdefit()</code>, indicating the data to be used and starting parameter
values for the iterations. For hierarchical models, one must also
indicate which are the global and local parameters, and if fixed
locals or a mixed effects method should be used.
</p>
<p>Some auxilliary functions include the Box-Cox transformation <code><a href="#topic+bc">bc</a>()</code>,
and the <em>unified transformation</em> <code><a href="#topic+unitran">unitran</a>()</code>.
</p>
<p>For detailed usage see the vignette: <code>vignette("resde-vignette", package="resde")</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Oscar Garcia <a href="mailto:garcia@dasometrics.net">garcia@dasometrics.net</a> (<a href="https://orcid.org/0000-0002-8995-1341">ORCID</a>)
</p>


<h3>References</h3>

<p>Garcia, O. (2019) &quot;Estimating reducible stochastic differential
equations by conversion to a least-squares problem&quot;. <em>Computational
Statistics 34</em>(1), 23-46. <a href="https://doi.org/10.1007/s00180-018-0837-4">doi:10.1007/s00180-018-0837-4</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ogarciav/resde/">https://github.com/ogarciav/resde/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ogarciav/resde/issues">https://github.com/ogarciav/resde/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Richards model  dH^c = b(a^c - H^c) dt + s dW for tree heights
tree1 &lt;- subset(Loblolly, Seed == Seed[1]) # first tree
m &lt;- sdemodel(~x^c, beta0=~b*a^c, beta1=~-b, mum=0) # no measurement error
sdefit(m, x="height", t="age", data=tree1, start=c(a=70, b=0.1, c=0.5))

</code></pre>

<hr>
<h2 id='sdefit'>Fit SDE model</h2><span id='topic+sdefit'></span>

<h3>Description</h3>

<p>ML estimation of parameters for a reducible SDE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdefit(model, x, t, unit=NULL, data=NULL, start=NULL,
  global=NULL, local=NULL, known=NULL, method="nls",
  control=NULL, phi=NULL, phiprime=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdefit_+3A_model">model</code></td>
<td>
<p>Model specification, as produced by <code><a href="#topic+sdemodel">sdemodel</a>()</code>.</p>
</td></tr>
<tr><td><code id="sdefit_+3A_x">x</code>, <code id="sdefit_+3A_t">t</code></td>
<td>
<p>Vectors with variables, or names of columns in data frame.</p>
</td></tr>
<tr><td><code id="sdefit_+3A_unit">unit</code></td>
<td>
<p>If applicable, unit id vector, or name of its column in data frame.</p>
</td></tr>
<tr><td><code id="sdefit_+3A_data">data</code></td>
<td>
<p>Data frame, if data not given directly in <code>x</code>, <code>t</code>, <code>unit</code>.</p>
</td></tr>
<tr><td><code id="sdefit_+3A_start">start</code></td>
<td>
<p>Named vector or named list with starting parameter values
for non-hierarchical models. They can also be given
in global.</p>
</td></tr>
<tr><td><code id="sdefit_+3A_global">global</code></td>
<td>
<p>Named vector or list of global parameters and their starting
values for hierarchical models. Can also contain
starting values for non-hierarchical models.</p>
</td></tr>
<tr><td><code id="sdefit_+3A_local">local</code></td>
<td>
<p>Named vector or list of local parameters and their starting values for
hierarchical models. The value can be a vector with
values for each unit, or a single scalar that
applies to all the units.</p>
</td></tr>
<tr><td><code id="sdefit_+3A_known">known</code></td>
<td>
<p>Named vector or list with any parameters that should be fixed at given values.</p>
</td></tr>
<tr><td><code id="sdefit_+3A_method">method</code></td>
<td>
<p><code>'nls'</code> for non-hierarchical models (default). For
hierarchical models it can be <code>'nls'</code>, for fixed
locals, or <code>'nlme'</code> for mixed effects.</p>
</td></tr>
<tr><td><code id="sdefit_+3A_control">control</code></td>
<td>
<p>Optional control list for <code>nls()</code> or <code>nlme()</code>.</p>
</td></tr>
<tr><td><code id="sdefit_+3A_phi">phi</code></td>
<td>
<p>Optional transformation function. If <code>NULL</code> (default), it is automatically generated.</p>
</td></tr>
<tr><td><code id="sdefit_+3A_phiprime">phiprime</code></td>
<td>
<p>Optional derivative function. If <code>NULL</code> (default), it is automatically generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two components: a list <code>fit</code> containing the output from
the optimizer (<code>nls</code> or <code>nlme</code>), and a list <code>more</code> containing
sigma estimates, log-likelihood, AIC and BIC. Note that in <code>fit</code>, &quot;residual sum-of-squares&quot;
corresponds to <code>uvector</code>, not to <code>x</code> or <code>y</code>. Same for <code>nls</code> and <code>nlme</code>
methods like <code>fitted</code> or <code>residuals</code> applied to <code>fit</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- sdemodel(phi=~x^c, beta0=~b*a^c, beta1=~-b)
mod1 &lt;- sdefit(m, "height", "age", data=Loblolly[Loblolly$Seed=="301",],
               start=c(a=70, b=0.1, c=1))
mod2 &lt;- sdefit(m, "height", "age", "Seed", Loblolly, global=c(b=0.1, c=0.5),
               local=c(a=72))
</code></pre>

<hr>
<h2 id='sdemodel'>Model specification</h2><span id='topic+sdemodel'></span>

<h3>Description</h3>

<p>Specify transformation and re-parametrizations for reducible SDE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdemodel(phi=~x, phiprime=NULL, beta0=~beta0, beta1=~beta1,
   t0=0, x0=0, mu0=0, mup=1, mum=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdemodel_+3A_phi">phi</code></td>
<td>
<p>Transformation formula <code class="reqn">y = \varphi(x, parameters)</code>.</p>
</td></tr>
<tr><td><code id="sdemodel_+3A_phiprime">phiprime</code></td>
<td>
<p>Optional formula for derivative of <code>phi</code>.</p>
</td></tr>
<tr><td><code id="sdemodel_+3A_beta0">beta0</code>, <code id="sdemodel_+3A_beta1">beta1</code></td>
<td>
<p>Optional formulas or constants, possibly giving a re-parameterization,.</p>
</td></tr>
<tr><td><code id="sdemodel_+3A_t0">t0</code>, <code id="sdemodel_+3A_x0">x0</code></td>
<td>
<p>Formulas or constants for the initial condition.</p>
</td></tr>
<tr><td><code id="sdemodel_+3A_mu0">mu0</code></td>
<td>
<p>Formula or constant for the initial condition <code class="reqn">\sigma_0</code> multiplier.</p>
</td></tr>
<tr><td><code id="sdemodel_+3A_mup">mup</code>, <code id="sdemodel_+3A_mum">mum</code></td>
<td>
<p>Formulas or constants for the process and measurement <code class="reqn">\sigma</code> multipliers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with model specification, to be used by <code><a href="#topic+sdefit">sdefit</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   richards &lt;- sdemodel(phi=~x^c, beta0=~b*a^c, beta1=~-b, mum=0)

</code></pre>

<hr>
<h2 id='sdemodel_display'>Display the model specification</h2><span id='topic+sdemodel_display'></span>

<h3>Description</h3>

<p>Display the model specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdemodel_display(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdemodel_display_+3A_model">model</code></td>
<td>
<p>SDE model specification, as produced by sdemodel()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns its argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  mod &lt;- sdemodel(); sdemodel_display(mod)
</code></pre>

<hr>
<h2 id='str2fun_theta'>String to function, with parameters in theta</h2><span id='topic+str2fun_theta'></span>

<h3>Description</h3>

<p>Normally not called by the user directly, used by <code><a href="#topic+sdefit">sdefit</a>()</code>.
Converts an expression, in a character string, to a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str2fun_theta(s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str2fun_theta_+3A_s">s</code></td>
<td>
<p>String representation of a function of <code>x</code> and parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function of <code>x</code> and <code>theta</code>, <code>theta</code> being a named vector or list of parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str2fun_theta("x^c / a")
</code></pre>

<hr>
<h2 id='unitran'>Unified transformation</h2><span id='topic+unitran'></span><span id='topic+unitran_inv'></span><span id='topic+unitran_prime'></span>

<h3>Description</h3>

<p>Calculates a variable transformation that produces various growth curve models, depending on the
values of two shape parameters, <code>alpha</code> and <code>beta</code>. Models can also
be specified by name. Uses <code><a href="#topic+bc">bc</a>(), bc_inv(), bc_prime()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitran(x, name=NULL, par=NULL, alpha=NULL, beta=NULL, reverse="auto")

unitran_inv(y, name=NULL, par=NULL, alpha=NULL, beta=NULL, reverse="auto")

unitran_prime(x, name=NULL, par=NULL, alpha=NULL, beta=NULL, reverse="auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitran_+3A_x">x</code>, <code id="unitran_+3A_y">y</code></td>
<td>
<p>Variable to be transformed, <code>x</code> must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="unitran_+3A_name">name</code></td>
<td>
<p>Optional model name, case-insensitive, in quotes. One of <code>Richards</code>,
<code>monomolecular</code>, <code>Mitscherlich</code>, <code>Bertalanffy</code>, <code>Gompertz</code>,
<code>logistic</code>, <code>Levacovic</code>, <code>Weibull</code>, <code>Korf</code>, <code>exponential</code>,
<code>Schumacher</code>, <code>Hosfeld</code>.</p>
</td></tr>
<tr><td><code id="unitran_+3A_par">par</code></td>
<td>
<p>Model parameter, if needed and model name supplied.</p>
</td></tr>
<tr><td><code id="unitran_+3A_alpha">alpha</code>, <code id="unitran_+3A_beta">beta</code></td>
<td>
<p>Shape parameters, if the model is not specified by name.</p>
</td></tr>
<tr><td><code id="unitran_+3A_reverse">reverse</code></td>
<td>
<p>Reverse <code>x</code> and <code>t</code> axes? One of <code>"yes"</code>, <code>"no"</code>, <code>"auto"</code>.
With <code>"auto"</code>, axes are reversed as necessary for an upper asymptote.
(i.e., if <code>alpha &lt;= 0</code> and <code>beta &gt; 0</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>unitran()</code>: Transformed <code>x</code>, i.e., <code class="reqn">y = \varphi(x)</code>.
</p>
<p><code>unitran_inv()</code>: Inverse of <code>unitran()</code>,  <code class="reqn">x = \varphi^{-1}(y)</code>.
</p>
<p><code>unitran_prime()</code>: Derivative of <code>unitran()</code>,  <code class="reqn">y' = \varphi'(x)</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>unitran()</code>: Unified transformation.
</p>
</li>
<li> <p><code>unitran_inv()</code>: Inverse of unitran().
</p>
</li>
<li> <p><code>unitran_prime()</code>: Derivative of <code>unitran()</code> with respect to <code>x</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>curve(unitran(x, "Gompertz"))  # same as unitran(x, alpha=0, beta=0)
curve(unitran_inv(y, "logistic"), xname="y", from=-4, to=4)
curve(unitran_prime(x, "logistic"))
</code></pre>

<hr>
<h2 id='userphi'>Examples of optional external transformation and derivative functions</h2><span id='topic+userphi'></span><span id='topic+userphiprime'></span>

<h3>Description</h3>

<p>Templates for user-supplied transformation and drivative functions, used by
<code>sdefit()</code> if specified in parameters <code>phi</code> and/or
<code>phiprime</code>. To be completed by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>userphi(x, theta)

userphiprime(x, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="userphi_+3A_x">x</code></td>
<td>
<p>Numeric vector, variable to be transformed.</p>
</td></tr>
<tr><td><code id="userphi_+3A_theta">theta</code></td>
<td>
<p>Named list of transformation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transformed variable
</p>
<p>Transformation derivative
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>userphi()</code>: transformation
</p>
</li>
<li> <p><code>userphiprime()</code>: derivative
</p>
</li></ul>

<hr>
<h2 id='uvector'>ML estimation vector for reducible SDEs</h2><span id='topic+uvector'></span><span id='topic+uvector_noh'></span><span id='topic+logdet.and.v'></span>

<h3>Description</h3>

<p>These functions are not normally called directly by the user.
Function <code>uvector()</code> is used by <code><a href="#topic+sdefit">sdefit</a>()</code>. Function
<code>uvector_noh()</code> is a more limited version, maintained for documentation
purposes. Function <code>logdet_and_v()</code> is used by <code>uvector()</code> and
<code>uvector_noh()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uvector(x, t, unit = NULL, beta0, beta1, eta, eta0, x0, t0, lambda,
  mum = 1, mu0 = 1, mup = 1, sorted = FALSE, final = FALSE)

uvector_noh(x, t, beta0, beta1, eta, eta0, x0, t0, lambda, final = FALSE)

logdet.and.v(cdiag, csub = NULL, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uvector_+3A_x">x</code>, <code id="uvector_+3A_t">t</code></td>
<td>
<p>Data vectors</p>
</td></tr>
<tr><td><code id="uvector_+3A_unit">unit</code></td>
<td>
<p>Unit id vector, if any.</p>
</td></tr>
<tr><td><code id="uvector_+3A_beta0">beta0</code>, <code id="uvector_+3A_beta1">beta1</code>, <code id="uvector_+3A_eta">eta</code>, <code id="uvector_+3A_eta0">eta0</code>, <code id="uvector_+3A_x0">x0</code>, <code id="uvector_+3A_t0">t0</code></td>
<td>
<p>SDE parameters or re-parameterizations.</p>
</td></tr>
<tr><td><code id="uvector_+3A_lambda">lambda</code></td>
<td>
<p>Named list of parameters(s) for <code>phi()</code>, possibly local
vectors.</p>
</td></tr>
<tr><td><code id="uvector_+3A_mum">mum</code>, <code id="uvector_+3A_mu0">mu0</code>, <code id="uvector_+3A_mup">mup</code></td>
<td>
<p>Optional <code class="reqn">\sigma</code> multipliers.</p>
</td></tr>
<tr><td><code id="uvector_+3A_sorted">sorted</code></td>
<td>
<p>Data already ordered by increasing t?</p>
</td></tr>
<tr><td><code id="uvector_+3A_final">final</code></td>
<td>
<p>Mode, see below.</p>
</td></tr>
<tr><td><code id="uvector_+3A_cdiag">cdiag</code></td>
<td>
<p>Vector with the diagonal elements <code class="reqn">c_{ii}</code> of
<code class="reqn">C</code>.</p>
</td></tr>
<tr><td><code id="uvector_+3A_csub">csub</code></td>
<td>
<p>Vector with sub-diagonal <code class="reqn">c_{i, i-1}</code> for <code class="reqn">i &gt;
1</code>.</p>
</td></tr>
<tr><td><code id="uvector_+3A_z">z</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>uvector()</code> and <code>uvector_noh()</code> calculate a vector of
residuals for sum of squares minimization by <code>nls()</code> or <code>nlme()</code>.
The first one works both for single-unit and for bilevel hierarchical models.
It is backward-compatible with <code>uvector_noh()</code>, which is only for
single-unit models but simpler and easier to understand. They require a
transformation function <code>phi(x, theta)</code>, and a function
<code>phiprime(x, theta)</code> for the derivative dy/dx, where <code>theta</code> is a
list containing the transformation parameters.
</p>
<p><code>logdet_and_v()</code> calculates <code class="reqn">\log[\det(L)]</code> and <code class="reqn">v
= L^{-1} z</code>, where <code class="reqn">C = LL'</code>, with <code class="reqn">L</code> lower-triangular.
</p>
<p>The three functions are essentially unchanged from Garc√≠a (2019)
&lt;<a href="https://doi.org/10.1007/s00180-018-0837-4">doi:10.1007/s00180-018-0837-4</a>&gt;, except for a somewhat safer computation
for very small <code>beta1</code>, and adding in <code>logdet_and_v()</code> a shortcut
for when <code class="reqn">L</code> is diagonal (e.g., when <code class="reqn">\sigma_m = 0</code>). The
transformation functions <code>phi</code> and <code>phiprime</code> can be passed as
globals, as in the original, or in an environment named <code>trfuns</code>.
</p>


<h3>Value</h3>

<p><code>uvector()</code> and <code>uvector_noh()</code>: If <code>final = FALSE</code>
(default), return a vector whose sum of squares should be minimized over the
parameters to obtain maximum-likelihood estimates. If <code>final = TRUE</code>,
passing the ML parameter estimates returns a list with the sigma estimates,
the maximized log-likelihood, and AIC and BIC criteria..
</p>
<p><code>logdet_and_v()</code>: List with elements <code>logdet</code> and <code>v</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>uvector()</code>: Estimation vector, general
</p>
</li>
<li> <p><code>uvector_noh()</code>: Estimation vector, non-hierarchical
</p>
</li>
<li> <p><code>logdet.and.v()</code>: Logarithm of determinant, and <code class="reqn">v</code> vector
</p>
</li></ul>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
