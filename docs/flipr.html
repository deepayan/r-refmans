<!DOCTYPE html><html><head><title>Help for package flipr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flipr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#flipr-package'><p>flipr: Flexible inference via permutations in R</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#grid_biregular'><p>Create a biregular grid around a center point</p></a></li>
<li><a href='#one_sample_test'><p>One-Sample Permutation Test</p></a></li>
<li><a href='#one-sample-stats'><p>Test Statistics for the One-Sample Problem</p></a></li>
<li><a href='#PlausibilityFunction'><p>R6 Class representing a plausibility function</p></a></li>
<li><a href='#plot_pf'><p>Visualization of Plausibility Functions</p></a></li>
<li><a href='#two_sample_test'><p>Two-Sample Permutation Test</p></a></li>
<li><a href='#two-sample-stats'><p>Test Statistics for the Two-Sample Problem</p></a></li>
<li><a href='#use_stat'><p>Test Statistic Template</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Flexible Inference via Permutations in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>A flexible permutation framework for making 
    inference such as point estimation, confidence 
    intervals or hypothesis testing, on any kind of data, 
    be it univariate, multivariate, or more complex such 
    as network-valued data, topological data, functional 
    data or density-valued data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dials, ggplot2, magrittr, optimParallel, pbapply, purrr,
R6, Rcpp, rgenoud, rlang, tibble, usethis, viridisLite, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, htmltools, htmlwidgets, interp, knitr, plotly,
rmarkdown, testthat (&ge; 3.0.0), tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://LMJL-Alea.github.io/flipr/">https://LMJL-Alea.github.io/flipr/</a>,
<a href="https://github.com/LMJL-Alea/flipr/">https://github.com/LMJL-Alea/flipr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/LMJL-Alea/flipr/issues/">https://github.com/LMJL-Alea/flipr/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 08:34:24 UTC; stamm-a</td>
</tr>
<tr>
<td>Author:</td>
<td>Alessia Pini [aut],
  Aymeric Stamm <a href="https://orcid.org/0000-0002-8725-3654"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Simone Vantini [aut],
  Juliette Chiapello [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aymeric Stamm &lt;aymeric.stamm@cnrs.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-23 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='flipr-package'>flipr: Flexible inference via permutations in R</h2><span id='topic+flipr'></span><span id='topic+flipr-package'></span>

<h3>Description</h3>

<p>The flipr package provides a flexible permutation framework for making
inference such as point estimation, confidence intervals or hypothesis
testing, on any kind of data, be it univariate, multivariate, or more complex
such as network-valued data, topological data, functional data or
density-valued data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aymeric Stamm <a href="mailto:aymeric.stamm@cnrs.fr">aymeric.stamm@cnrs.fr</a> (<a href="https://orcid.org/0000-0002-8725-3654">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Alessia Pini <a href="mailto:alessia.pini@unicatt.it">alessia.pini@unicatt.it</a>
</p>
</li>
<li><p> Simone Vantini <a href="mailto:simone.vantini@polimi.it">simone.vantini@polimi.it</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Juliette Chiapello [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://LMJL-Alea.github.io/flipr/">https://LMJL-Alea.github.io/flipr/</a>
</p>
</li>
<li> <p><a href="https://github.com/LMJL-Alea/flipr/">https://github.com/LMJL-Alea/flipr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/LMJL-Alea/flipr/issues/">https://github.com/LMJL-Alea/flipr/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='grid_biregular'>Create a biregular grid around a center point</h2><span id='topic+grid_biregular'></span>

<h3>Description</h3>

<p>Biregular grids can be created for any number of parameter objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_biregular(
  x,
  ...,
  center = NULL,
  levels = 3,
  original = TRUE,
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_biregular_+3A_x">x</code></td>
<td>
<p>A <code>param</code> object, list, or <code>parameters</code>.</p>
</td></tr>
<tr><td><code id="grid_biregular_+3A_...">...</code></td>
<td>
<p>One or more <code>param</code> objects (such as <code><a href="dials.html#topic+mtry">mtry()</a></code> or
<code><a href="dials.html#topic+penalty">penalty()</a></code>). None of the objects can have <code>unknown()</code> values in
the parameter ranges or values.</p>
</td></tr>
<tr><td><code id="grid_biregular_+3A_center">center</code></td>
<td>
<p>A numeric vector specifying the point onto which the biregular
grid should be centered. Defaults to <code>NULL</code>, in which case
<code><a href="dials.html#topic+grid_regular">grid_regular</a></code> is used instead.</p>
</td></tr>
<tr><td><code id="grid_biregular_+3A_levels">levels</code></td>
<td>
<p>An integer for the number of values of each parameter to use
to make the regular grid. <code>levels</code> can be a single integer or a vector of
integers that is the same length as the number of parameters in <code>...</code>.
<code>levels</code> can be a named integer vector, with names that match the id values
of parameters.</p>
</td></tr>
<tr><td><code id="grid_biregular_+3A_original">original</code></td>
<td>
<p>A logical: should the parameters be in the original units or
in the transformed space (if any)?</p>
</td></tr>
<tr><td><code id="grid_biregular_+3A_filter">filter</code></td>
<td>
<p>A logical: should the parameters be filtered prior to
generating the grid. Must be a single expression referencing parameter
names that evaluates to a logical vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that there may a difference in grids depending on how the function
is called. If the call uses the parameter objects directly the possible
ranges come from the objects in <code>dials</code>. For example:
</p>
<div class="sourceCode r"><pre>mixture()
</pre></div>
<div class="sourceCode"><pre>## Proportion of Lasso Penalty (quantitative)
## Range: [0, 1]
</pre></div>
<div class="sourceCode r"><pre>set.seed(283)
mix_grid_1 &lt;- grid_random(mixture(), size = 1000)
range(mix_grid_1$mixture)
</pre></div>
<div class="sourceCode"><pre>## [1] 0.001490161 0.999741096
</pre></div>
<p>However, in some cases, the <code>parsnip</code> and <code>recipe</code> packages overrides
the default ranges for specific models and preprocessing steps. If the
grid function uses a <code>parameters</code> object created from a model or recipe,
the ranges may have different defaults (specific to those models). Using
the example above, the <code>mixture</code> argument above is different for
<code>glmnet</code> models:
</p>
<div class="sourceCode r"><pre>library(parsnip)
library(tune)

# When used with glmnet, the range is [0.05, 1.00]
glmn_mod &lt;-
  linear_reg(mixture = tune()) %&gt;%
  set_engine("glmnet")

set.seed(283)
mix_grid_2 &lt;- grid_random(extract_parameter_set_dials(glmn_mod), size = 1000)
range(mix_grid_2$mixture)
</pre></div>
<div class="sourceCode"><pre>## [1] 0.05141565 0.99975404
</pre></div>


<h3>Value</h3>

<p>A tibble. There are columns for each parameter and a row for every
parameter combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid_biregular(dials::mixture(), center = 0.2)
</code></pre>

<hr>
<h2 id='one_sample_test'>One-Sample Permutation Test</h2><span id='topic+one_sample_test'></span>

<h3>Description</h3>

<p>This function carries out an hypothesis test where the null hypothesis is
that the sample is governed by a generative probability distribution which is
centered and symmetric against the alternative hypothesis that they are
governed by a probability distribution that is either not centered or not
symmetric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_sample_test(
  x,
  stats = list(stat_max),
  B = 1000L,
  M = NULL,
  alternative = "two_tail",
  combine_with = "tippett",
  type = "exact",
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_sample_test_+3A_x">x</code></td>
<td>
<p>A numeric vector or a numeric matrix or a list representing the
sample from which the user wants to make inference.</p>
</td></tr>
<tr><td><code id="one_sample_test_+3A_stats">stats</code></td>
<td>
<p>A list of functions produced by <code><a href="rlang.html#topic+as_function">as_function</a></code>
specifying the chosen test statistic(s). A number of test statistic
functions are implemented in the package and can be used as such.
Alternatively, one can provide its own implementation of test statistics
that (s)he deems relevant for the problem at hand. See the section
<em>User-supplied statistic function</em> for more information on how these
user-supplied functions should be structured for compatibility with the
<strong>flipr</strong> framework. Default is <code>list(<a href="#topic+stat_t">stat_t</a>)</code>.</p>
</td></tr>
<tr><td><code id="one_sample_test_+3A_b">B</code></td>
<td>
<p>The number of sampled permutations. Default is <code>1000L</code>.</p>
</td></tr>
<tr><td><code id="one_sample_test_+3A_m">M</code></td>
<td>
<p>The total number of possible permutations. Defaults to <code>NULL</code>, which
means that it is automatically computed from the given sample size(s).</p>
</td></tr>
<tr><td><code id="one_sample_test_+3A_alternative">alternative</code></td>
<td>
<p>A single string or a character vector specifying whether
the p-value is right-tailed, left-tailed or two-tailed. Choices are
<code>"right_tail"</code>, <code>"left_tail"</code> and <code>"two_tail"</code>. Default is <code>"two_tail"</code>. If
a single string is provided, it is assumed that it should be applied to all
test statistics provided by the user. Alternative, the length of
<code>alternative</code> should match the length of the <code>stats</code> parameter and it is
assumed that there is a one-to-one correspondence.</p>
</td></tr>
<tr><td><code id="one_sample_test_+3A_combine_with">combine_with</code></td>
<td>
<p>A string specifying the combining function to be used to
compute the single test statistic value from the set of p-value estimates
obtained during the non-parametric combination testing procedure. For now,
choices are either <code>"tippett"</code> or <code>"fisher"</code>. Default is <code>"tippett"</code>, which
picks Tippett's function.</p>
</td></tr>
<tr><td><code id="one_sample_test_+3A_type">type</code></td>
<td>
<p>A string specifying which formula should be used to compute the
p-value. Choices are <code>exact</code> (default), <code>upper_bound</code> and <code>estimate</code>. See
Phipson &amp; Smith (2010) for details.</p>
</td></tr>
<tr><td><code id="one_sample_test_+3A_seed">seed</code></td>
<td>
<p>An integer specifying the seed of the random generator useful for
result reproducibility or method comparisons. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="one_sample_test_+3A_...">...</code></td>
<td>
<p>Extra parameters specific to some statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with three components: the value of the
statistic for the original two samples, the p-value of the resulting
permutation test and a numeric vector storing the values of the permuted
statistics.
</p>


<h3>User-supplied statistic function</h3>

<p>A user-specified function should have at least two arguments:
</p>

<ul>
<li><p> the first argument is <code>data</code> which should be a list of the <code>n</code>
observations from the sample;
</p>
</li>
<li><p> the second argument is <code>flips</code> which should be an integer vector giving
the signs by which each observation in <code>data</code> should be multiplied.
</p>
</li></ul>

<p>It is possible to use the <code><a href="#topic+use_stat">use_stat</a></code> function with <code>nsamples = 1</code>
to have <strong>flipr</strong> automatically generate a template file for writing down
your own test statistics in a way that makes it compatible with the <strong>flipr</strong>
framework.
</p>
<p>See the <code><a href="#topic+stat_max">stat_max</a></code> function for an example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10L
mu &lt;- 3
sigma &lt;- 1

# Sample under the null distribution
x1 &lt;- rnorm(n = n, mean = 0, sd = sigma)
t1 &lt;- one_sample_test(x1, B = 100L)
t1$pvalue

# Sample under some alternative distribution
x2 &lt;- rnorm(n = n, mean = mu, sd = sigma)
t2 &lt;- one_sample_test(x2, B = 100L)
t2$pvalue
</code></pre>

<hr>
<h2 id='one-sample-stats'>Test Statistics for the One-Sample Problem</h2><span id='topic+one-sample-stats'></span><span id='topic+stat_max'></span>

<h3>Description</h3>

<p>This is a collection of functions that provide test statistics to be used
into the permutation scheme for performing one-sample testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_max(data, flips, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one-sample-stats_+3A_data">data</code></td>
<td>
<p>A list storing the sample from which the user wants to make
inference.</p>
</td></tr>
<tr><td><code id="one-sample-stats_+3A_flips">flips</code></td>
<td>
<p>A numeric vectors of <code>-1</code>s and <code>1</code>s to be used to randomly flip
some data points around the center of symmetric of the distribution of the
sample.</p>
</td></tr>
<tr><td><code id="one-sample-stats_+3A_...">...</code></td>
<td>
<p>Extra parameters specific to some statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value evaluating the desired test statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
x &lt;- as.list(rnorm(n))
flips &lt;- sample(c(-1, 1), n, replace = TRUE)
stat_max(x, flips)
</code></pre>

<hr>
<h2 id='PlausibilityFunction'>R6 Class representing a plausibility function</h2><span id='topic+PlausibilityFunction'></span>

<h3>Description</h3>

<p>A plausibility function is...
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>nparams</code></dt><dd><p>An integer specifying the number of parameters to be
inferred. Default is <code>1L</code>.</p>
</dd>
<dt><code>nperms</code></dt><dd><p>An integer specifying the number of permutations to be
sampled. Default is <code>1000L</code>.</p>
</dd>
<dt><code>nperms_max</code></dt><dd><p>An integer specifying the total number of distinct
permutations that can be made given the sample sizes.</p>
</dd>
<dt><code>alternative</code></dt><dd><p>A string specifying the type of alternative
hypothesis. Choices are <code>"two_tail"</code>, <code>"left_tail"</code> and <code style="white-space: pre;">&#8288;"right_tail&#8288;</code>.
Defaults to <code>"two_tail"</code>.</p>
</dd>
<dt><code>aggregator</code></dt><dd><p>A string specifying which function should be used to
aggregate test statistic values when non-parametric combination is used
(i.e. when multiple test statistics are used). Choices are <code>"tippett"</code>
and <code style="white-space: pre;">&#8288;"fisher&#8288;</code> for now. Defaults to <code>"tippett"</code>.</p>
</dd>
<dt><code>pvalue_formula</code></dt><dd><p>A string specifying which formula to use for
computing the permutation p-value. Choices are either <code>probability</code>
(default) or <code>estimator</code>. The former provides p-values that lead to
exact hypothesis tests while the latter provides an unbiased estimate
of the traditional p-value.</p>
</dd>
<dt><code>max_conf_level</code></dt><dd><p>A numeric value specifying the maximum confidence
level that we aim to achieve for the confidence regions. This is used
to compute bounds on each parameter of interest in order to fit a
Kriging model that approximates the expensive plausibility function on
a hypercube. Defaults to <code>0.99</code>.</p>
</dd>
<dt><code>point_estimate</code></dt><dd><p>A numeric vector providing point estimates for the
parameters of interest.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>A list of functions of class <code>param</code> produced via
<code><a href="dials.html#topic+new_quant_param">new_quant_param</a></code> that stores the parameters to be
inferred along with important properties such as their name, range,
etc. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>grid</code></dt><dd><p>A tibble storing evaluations of the plausibility function on
a regular centered grid of the parameter space. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PlausibilityFunction-new"><code>PlausibilityFunction$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PlausibilityFunction-set_nperms"><code>PlausibilityFunction$set_nperms()</code></a>
</p>
</li>
<li> <p><a href="#method-PlausibilityFunction-set_nperms_max"><code>PlausibilityFunction$set_nperms_max()</code></a>
</p>
</li>
<li> <p><a href="#method-PlausibilityFunction-set_alternative"><code>PlausibilityFunction$set_alternative()</code></a>
</p>
</li>
<li> <p><a href="#method-PlausibilityFunction-set_aggregator"><code>PlausibilityFunction$set_aggregator()</code></a>
</p>
</li>
<li> <p><a href="#method-PlausibilityFunction-set_pvalue_formula"><code>PlausibilityFunction$set_pvalue_formula()</code></a>
</p>
</li>
<li> <p><a href="#method-PlausibilityFunction-get_value"><code>PlausibilityFunction$get_value()</code></a>
</p>
</li>
<li> <p><a href="#method-PlausibilityFunction-set_max_conf_level"><code>PlausibilityFunction$set_max_conf_level()</code></a>
</p>
</li>
<li> <p><a href="#method-PlausibilityFunction-set_point_estimate"><code>PlausibilityFunction$set_point_estimate()</code></a>
</p>
</li>
<li> <p><a href="#method-PlausibilityFunction-set_parameter_bounds"><code>PlausibilityFunction$set_parameter_bounds()</code></a>
</p>
</li>
<li> <p><a href="#method-PlausibilityFunction-set_grid"><code>PlausibilityFunction$set_grid()</code></a>
</p>
</li>
<li> <p><a href="#method-PlausibilityFunction-evaluate_grid"><code>PlausibilityFunction$evaluate_grid()</code></a>
</p>
</li>
<li> <p><a href="#method-PlausibilityFunction-clone"><code>PlausibilityFunction$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PlausibilityFunction-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new plausibility function object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$new(
  null_spec,
  stat_functions,
  stat_assignments,
  ...,
  seed = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>null_spec</code></dt><dd><p>A function or an R object coercible into a function (via
<code>rlang::as_function()</code>). For one-sample problems, it should transform
the <code>x</code> sample (provided as first argument) using the parameters (as
second argument) to make its distribution centered symmetric. For
two-sample problems, it should transform the <code>y</code> sample (provided as
first argument) using the parameters (as second argument) to make it
exchangeable with the <code>x</code> sample under a null hypothesis.</p>
</dd>
<dt><code>stat_functions</code></dt><dd><p>A vector or list of functions (or R objects
coercible into functions via <code>rlang::as_function()</code>) specifying the
whole set of test statistics that should be used.</p>
</dd>
<dt><code>stat_assignments</code></dt><dd><p>A named list of integer vectors specifying which
test statistic should be associated with each parameter. The length of
this list should match the number of parameters under investigation and
is thus used to set it. Each element of the list should be named after
the parameter it identifies.</p>
</dd>
<dt><code>...</code></dt><dd><p>Vectors, matrices or lists providing the observed samples.</p>
</dd>
<dt><code>seed</code></dt><dd><p>A numeric value specifying the seed to be used. Defaults to
<code>NULL</code> in which case <code>seed = 1234</code> is used and the user is informed of
this setting.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>PlausibilityFunction</code> object.
</p>


<hr>
<a id="method-PlausibilityFunction-set_nperms"></a>



<h4>Method <code>set_nperms()</code></h4>

<p>Change the value of the <code>nperms</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$set_nperms(val)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>val</code></dt><dd><p>New value for the number of permutations to be sampled.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {purrr::map(y, ~ .x - parameters[1])}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$nperms
pf$set_nperms(10000)
pf$nperms
</pre>
</div>


<hr>
<a id="method-PlausibilityFunction-set_nperms_max"></a>



<h4>Method <code>set_nperms_max()</code></h4>

<p>Change the value of the <code>nperms_max</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$set_nperms_max(val)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>val</code></dt><dd><p>New value for the total number of of possible distinct
permutations.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {purrr::map(y, ~ .x - parameters[1])}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$nperms_max
pf$set_nperms_max(10000)
pf$nperms_max
</pre>
</div>


<hr>
<a id="method-PlausibilityFunction-set_alternative"></a>



<h4>Method <code>set_alternative()</code></h4>

<p>Change the value of the <code>alternative</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$set_alternative(val)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>val</code></dt><dd><p>New value for the type of alternative hypothesis.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {purrr::map(y, ~ .x - parameters[1])}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$alternative
pf$set_alternative("right_tail")
pf$alternative
</pre>
</div>


<hr>
<a id="method-PlausibilityFunction-set_aggregator"></a>



<h4>Method <code>set_aggregator()</code></h4>

<p>Change the value of the <code>aggregator</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$set_aggregator(val)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>val</code></dt><dd><p>New value for the string specifying which function should be
used to aggregate test statistic values when non-parametric combination
is used (i.e. when multiple test statistics are used).</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {purrr::map(y, ~ .x - parameters[1])}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$aggregator
pf$set_aggregator("fisher")
pf$aggregator
</pre>
</div>


<hr>
<a id="method-PlausibilityFunction-set_pvalue_formula"></a>



<h4>Method <code>set_pvalue_formula()</code></h4>

<p>Change the value of the <code>pvalue_formula</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$set_pvalue_formula(val)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>val</code></dt><dd><p>New value for the string specifying which formula should be
used to compute the permutation p-value.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {
  purrr::map(y, ~ .x - parameters[1])
}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$pvalue_formula
pf$set_pvalue_formula("estimate")
pf$pvalue_formula
</pre>
</div>


<hr>
<a id="method-PlausibilityFunction-get_value"></a>



<h4>Method <code>get_value()</code></h4>

<p>Computes an indicator of the plausibility of specific values
for the parameters of interest in the form of a p-value of an
hypothesis test against these values.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$get_value(
  parameters,
  keep_null_distribution = FALSE,
  keep_permutations = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameters</code></dt><dd><p>A vector whose length should match the <code>nparams</code> field
providing specific values of the parameters of interest for assessment
of their plausibility in the form of a p-value of the corresponding
hypothesis test.</p>
</dd>
<dt><code>keep_null_distribution</code></dt><dd><p>A boolean specifying whether the empirical
permutation null distribution should be returned as well. Defaults to
<code>FALSE</code>.</p>
</dd>
<dt><code>keep_permutations</code></dt><dd><p>A boolean specifying whether the list of sampled
permutations used to compute the empirical permutation null
distribution should be returned as well. Defaults to <code>FALSE</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra parameters specific to some statistics.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {purrr::map(y, ~ .x - parameters[1])}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$set_nperms(50)
pf$get_value(2)
</pre>
</div>


<hr>
<a id="method-PlausibilityFunction-set_max_conf_level"></a>



<h4>Method <code>set_max_conf_level()</code></h4>

<p>Change the value of the <code>max_conf_level</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$set_max_conf_level(val)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>val</code></dt><dd><p>New value for the maximum confidence level that we aim to
achieve for the confidence regions.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {
  purrr::map(y, ~ .x - parameters[1])
}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$max_conf_level
pf$set_max_conf_level(0.999)
pf$max_conf_level
</pre>
</div>


<hr>
<a id="method-PlausibilityFunction-set_point_estimate"></a>



<h4>Method <code>set_point_estimate()</code></h4>

<p>Change the value of the <code>point_estimate</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$set_point_estimate(
  point_estimate = NULL,
  lower_bound = -10,
  upper_bound = 10,
  ncores = 1L,
  estimate = FALSE,
  overwrite = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point_estimate</code></dt><dd><p>A numeric vector providing rough point estimates for the
parameters under investigation.</p>
</dd>
<dt><code>lower_bound</code></dt><dd><p>A scalar or numeric vector specifying the lower bounds
for each parameter under investigation. If it is a scalar, the value is
used as lower bound for all parameters. Defaults to <code>-10</code>.</p>
</dd>
<dt><code>upper_bound</code></dt><dd><p>A scalar or numeric vector specifying the lower bounds
for each parameter under investigation. If it is a scalar, the value is
used as lower bound for all parameters. Defaults to <code>10</code>.</p>
</dd>
<dt><code>ncores</code></dt><dd><p>An integer specifying the number of cores to use for
maximizing the plausibility function to get a point estimate of the
parameters. Defaults to <code>1L</code>.</p>
</dd>
<dt><code>estimate</code></dt><dd><p>A boolean specifying whether the rough point estimate
provided by <code>val</code> should serve as initial point for maximizing the
plausibility function (<code>estimate = TRUE</code>) or as final point estimate
for the parameters (<code>estimate = FALSE</code>). Defaults to <code>FALSE</code>.</p>
</dd>
<dt><code>overwrite</code></dt><dd><p>A boolean specifying whether to force the computation if
it has already been set. Defaults to <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {
  purrr::map(y, ~ .x - parameters[1])
}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$point_estimate
pf$set_point_estimate(mean(y) - mean(x))
pf$point_estimate
</pre>
</div>


<hr>
<a id="method-PlausibilityFunction-set_parameter_bounds"></a>



<h4>Method <code>set_parameter_bounds()</code></h4>

<p>Change the value of the <code>parameters</code> field.
</p>
<p>Updates the range of the parameters under investigation.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$set_parameter_bounds(point_estimate, conf_level)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point_estimate</code></dt><dd><p>A numeric vector providing a point estimate for
each parameter under investigation. If no estimator is known by the
user, (s)he can resort to the <code style="white-space: pre;">&#8288;$set_point_estimate()&#8288;</code> method to get a
point estimate by maximizing the plausibility function.</p>
</dd>
<dt><code>conf_level</code></dt><dd><p>A numeric value specifying the confidence level to be
used for setting parameter bounds. It should be in (0,1).</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {
  purrr::map(y, ~ .x - parameters[1])
}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$set_nperms(50)
pf$set_point_estimate(point_estimate = mean(y) - mean(x))
pf$parameters
pf$set_parameter_bounds(
  point_estimate = pf$point_estimate,
  conf_level = 0.8
)
pf$parameters
</pre>
</div>


<hr>
<a id="method-PlausibilityFunction-set_grid"></a>



<h4>Method <code>set_grid()</code></h4>

<p>Computes a tibble storing a regular centered grid of the
parameter space.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$set_grid(parameters, npoints = 20L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameters</code></dt><dd><p>A list of <code><a href="dials.html#topic+new_quant_param">new_quant_param</a></code> objects
containing information about the parameters under investigation. It
should contain the fields <code>point_estimate</code> and <code>range</code>.</p>
</dd>
<dt><code>npoints</code></dt><dd><p>An integer specifying the number of points to discretize
each dimension. Defaults to <code>20L</code>.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {
  purrr::map(y, ~ .x - parameters[1])
}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$set_nperms(50)
pf$set_point_estimate(mean(y) - mean(x))
pf$set_parameter_bounds(
  point_estimate = pf$point_estimate,
  conf_level = 0.8
)
pf$set_grid(
  parameters = pf$parameters,
  npoints = 2L
)
</pre>
</div>


<hr>
<a id="method-PlausibilityFunction-evaluate_grid"></a>



<h4>Method <code>evaluate_grid()</code></h4>

<p>Updates the <code>grid</code> field with a <code>pvalue</code> column storing
evaluations of the plausibility function on the regular centered grid
of the parameter space.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$evaluate_grid(grid, ncores = 1L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grid</code></dt><dd><p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> storing a grid that spans the
space of parameters under investigation.</p>
</dd>
<dt><code>ncores</code></dt><dd><p>An integer specifying the number of cores to run
evaluations in parallel. Defaults to <code>1L</code>.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {
  purrr::map(y, ~ .x - parameters[1])
}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$set_nperms(50)
pf$set_point_estimate(mean(y) - mean(x))
pf$set_parameter_bounds(
  point_estimate = pf$point_estimate,
  conf_level = 0.8
)
pf$set_grid(
  parameters = pf$parameters,
  npoints = 2L
)
pf$evaluate_grid(grid = pf$grid)
</pre>
</div>


<hr>
<a id="method-PlausibilityFunction-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlausibilityFunction$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `PlausibilityFunction$set_nperms`
## ------------------------------------------------

x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {purrr::map(y, ~ .x - parameters[1])}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$nperms
pf$set_nperms(10000)
pf$nperms

## ------------------------------------------------
## Method `PlausibilityFunction$set_nperms_max`
## ------------------------------------------------

x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {purrr::map(y, ~ .x - parameters[1])}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$nperms_max
pf$set_nperms_max(10000)
pf$nperms_max

## ------------------------------------------------
## Method `PlausibilityFunction$set_alternative`
## ------------------------------------------------

x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {purrr::map(y, ~ .x - parameters[1])}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$alternative
pf$set_alternative("right_tail")
pf$alternative

## ------------------------------------------------
## Method `PlausibilityFunction$set_aggregator`
## ------------------------------------------------

x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {purrr::map(y, ~ .x - parameters[1])}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$aggregator
pf$set_aggregator("fisher")
pf$aggregator

## ------------------------------------------------
## Method `PlausibilityFunction$set_pvalue_formula`
## ------------------------------------------------

x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {
  purrr::map(y, ~ .x - parameters[1])
}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$pvalue_formula
pf$set_pvalue_formula("estimate")
pf$pvalue_formula

## ------------------------------------------------
## Method `PlausibilityFunction$get_value`
## ------------------------------------------------

x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {purrr::map(y, ~ .x - parameters[1])}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$set_nperms(50)
pf$get_value(2)

## ------------------------------------------------
## Method `PlausibilityFunction$set_max_conf_level`
## ------------------------------------------------

x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {
  purrr::map(y, ~ .x - parameters[1])
}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$max_conf_level
pf$set_max_conf_level(0.999)
pf$max_conf_level

## ------------------------------------------------
## Method `PlausibilityFunction$set_point_estimate`
## ------------------------------------------------

x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {
  purrr::map(y, ~ .x - parameters[1])
}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$point_estimate
pf$set_point_estimate(mean(y) - mean(x))
pf$point_estimate

## ------------------------------------------------
## Method `PlausibilityFunction$set_parameter_bounds`
## ------------------------------------------------

x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {
  purrr::map(y, ~ .x - parameters[1])
}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$set_nperms(50)
pf$set_point_estimate(point_estimate = mean(y) - mean(x))
pf$parameters
pf$set_parameter_bounds(
  point_estimate = pf$point_estimate,
  conf_level = 0.8
)
pf$parameters

## ------------------------------------------------
## Method `PlausibilityFunction$set_grid`
## ------------------------------------------------

x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {
  purrr::map(y, ~ .x - parameters[1])
}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$set_nperms(50)
pf$set_point_estimate(mean(y) - mean(x))
pf$set_parameter_bounds(
  point_estimate = pf$point_estimate,
  conf_level = 0.8
)
pf$set_grid(
  parameters = pf$parameters,
  npoints = 2L
)

## ------------------------------------------------
## Method `PlausibilityFunction$evaluate_grid`
## ------------------------------------------------

x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {
  purrr::map(y, ~ .x - parameters[1])
}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$set_nperms(50)
pf$set_point_estimate(mean(y) - mean(x))
pf$set_parameter_bounds(
  point_estimate = pf$point_estimate,
  conf_level = 0.8
)
pf$set_grid(
  parameters = pf$parameters,
  npoints = 2L
)
pf$evaluate_grid(grid = pf$grid)
</code></pre>

<hr>
<h2 id='plot_pf'>Visualization of Plausibility Functions</h2><span id='topic+plot_pf'></span>

<h3>Description</h3>

<p>This function plots the plausibility function for up to two parameters of
interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pf(pf, alpha = 0.05, ngrid = 10, ncores = 1, subtitle = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pf_+3A_pf">pf</code></td>
<td>
<p>A <code><a href="#topic+PlausibilityFunction">PlausibilityFunction</a></code> object.</p>
</td></tr>
<tr><td><code id="plot_pf_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value specifying a significance level to contrast the
plausibility function against. Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="plot_pf_+3A_ngrid">ngrid</code></td>
<td>
<p>An integer specifying the grid size on which the plausibility
function will be evaluated. Specifically if <code>K</code> is the number of parameters
under investigation, the grid will be of size <code>(ngrid + 1)^K</code>. Defaults to
<code>10L</code>.</p>
</td></tr>
<tr><td><code id="plot_pf_+3A_ncores">ncores</code></td>
<td>
<p>An integer specifying the number of cores to use for
parallelized computations. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="plot_pf_+3A_subtitle">subtitle</code></td>
<td>
<p>A string for specifying a subtitle to the plot. Defaults to
<code>""</code> leading to no subtitle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(10)
y &lt;- rnorm(10, mean = 2)
null_spec &lt;- function(y, parameters) {purrr::map(y, ~ .x - parameters[1])}
stat_functions &lt;- list(stat_t)
stat_assignments &lt;- list(mean = 1)
pf &lt;- PlausibilityFunction$new(
  null_spec = null_spec,
  stat_functions = stat_functions,
  stat_assignments = stat_assignments,
  x, y
)
pf$set_nperms(50)
pf$set_point_estimate(mean(y) - mean(x))
pf$set_parameter_bounds(
  point_estimate = pf$point_estimate,
  conf_level = 0.8
)
pf$set_grid(
  parameters = pf$parameters,
  npoints = 2L
)
pf$evaluate_grid(grid = pf$grid)
plot_pf(pf)
</code></pre>

<hr>
<h2 id='two_sample_test'>Two-Sample Permutation Test</h2><span id='topic+two_sample_test'></span>

<h3>Description</h3>

<p>This function carries out an hypothesis test in which the null hypothesis is
that the two samples are governed by the same underlying generative
probability distribution against the alternative hypothesis that they are
governed by two different generative probability distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two_sample_test(
  x,
  y,
  stats = list(stat_t),
  B = 1000L,
  M = NULL,
  alternative = "two_tail",
  combine_with = "tippett",
  type = "exact",
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two_sample_test_+3A_x">x</code></td>
<td>
<p>A numeric vector or a numeric matrix or a list representing the 1st
sample. Alternatively, it can be a distance matrix stored as an object of
class <code><a href="stats.html#topic+dist">dist</a></code>, in which case test statistics based on
inter-point distances (marked with the <code style="white-space: pre;">&#8288;_ip&#8288;</code> suffix) should be used.</p>
</td></tr>
<tr><td><code id="two_sample_test_+3A_y">y</code></td>
<td>
<p>A numeric vector if <code>x</code> is a numeric vector, or a numeric matrix if
<code>x</code> is a numeric matrix, or a list if <code>x</code> is a list, representing the second
sample. Alternatively, if <code>x</code> is an object of class
<code><a href="stats.html#topic+dist">dist</a></code>, it should be a numeric scalar specifying the
size of the first sample.</p>
</td></tr>
<tr><td><code id="two_sample_test_+3A_stats">stats</code></td>
<td>
<p>A list of functions produced by <code><a href="rlang.html#topic+as_function">as_function</a></code>
specifying the chosen test statistic(s). A number of test statistic
functions are implemented in the package and can be used as such.
Alternatively, one can provide its own implementation of test statistics
that (s)he deems relevant for the problem at hand. See the section
<em>User-supplied statistic function</em> for more information on how these
user-supplied functions should be structured for compatibility with the
<strong>flipr</strong> framework. Default is <code>list(<a href="#topic+stat_t">stat_t</a>)</code>.</p>
</td></tr>
<tr><td><code id="two_sample_test_+3A_b">B</code></td>
<td>
<p>The number of sampled permutations. Default is <code>1000L</code>.</p>
</td></tr>
<tr><td><code id="two_sample_test_+3A_m">M</code></td>
<td>
<p>The total number of possible permutations. Defaults to <code>NULL</code>, which
means that it is automatically computed from the given sample size(s).</p>
</td></tr>
<tr><td><code id="two_sample_test_+3A_alternative">alternative</code></td>
<td>
<p>A single string or a character vector specifying whether
the p-value is right-tailed, left-tailed or two-tailed. Choices are
<code>"right_tail"</code>, <code>"left_tail"</code> and <code>"two_tail"</code>. Default is <code>"two_tail"</code>. If
a single string is provided, it is assumed that it should be applied to all
test statistics provided by the user. Alternative, the length of
<code>alternative</code> should match the length of the <code>stats</code> parameter and it is
assumed that there is a one-to-one correspondence.</p>
</td></tr>
<tr><td><code id="two_sample_test_+3A_combine_with">combine_with</code></td>
<td>
<p>A string specifying the combining function to be used to
compute the single test statistic value from the set of p-value estimates
obtained during the non-parametric combination testing procedure. For now,
choices are either <code>"tippett"</code> or <code>"fisher"</code>. Default is <code>"tippett"</code>, which
picks Tippett's function.</p>
</td></tr>
<tr><td><code id="two_sample_test_+3A_type">type</code></td>
<td>
<p>A string specifying which formula should be used to compute the
p-value. Choices are <code>exact</code> (default), <code>upper_bound</code> and <code>estimate</code>. See
Phipson &amp; Smith (2010) for details.</p>
</td></tr>
<tr><td><code id="two_sample_test_+3A_seed">seed</code></td>
<td>
<p>An integer specifying the seed of the random generator useful for
result reproducibility or method comparisons. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="two_sample_test_+3A_...">...</code></td>
<td>
<p>Extra parameters specific to some statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with three components: the value of the
statistic for the original two samples, the p-value of the resulting
permutation test and a numeric vector storing the values of the permuted
statistics.
</p>


<h3>User-supplied statistic function</h3>

<p>A user-specified function should have at least two arguments:
</p>

<ul>
<li><p> the first argument is <code>data</code> which should be a list of the <code>n1 + n2</code>
concatenated observations with the original <code>n1</code> observations from the first
sample on top and the original <code>n2</code> observations from the second sample
below;
</p>
</li>
<li><p> the second argument is <code>perm_data</code> which should be an integer vector giving
the indices in <code>data</code> that are considered to belong to the first sample.
</p>
</li></ul>

<p>It is possible to use the <code><a href="#topic+use_stat">use_stat</a></code> function with <code>nsamples = 2</code>
to have <strong>flipr</strong> automatically generate a template file for writing down
your own test statistics in a way that makes it compatible with the <strong>flipr</strong>
framework.
</p>
<p>See the <code><a href="#topic+stat_t">stat_t</a></code> function for an example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10L
mx &lt;- 0
sigma &lt;- 1

# Two different models for the two populations
x &lt;- rnorm(n = n, mean = mx, sd = sigma)
delta &lt;- 10
my &lt;- mx + delta
y &lt;- rnorm(n = n, mean = my, sd = sigma)
t1 &lt;- two_sample_test(x, y)
t1$pvalue

# Same model for the two populations
x &lt;- rnorm(n = n, mean = mx, sd = sigma)
delta &lt;- 0
my &lt;- mx + delta
y &lt;- rnorm(n = n, mean = my, sd = sigma)
t2 &lt;- two_sample_test(x, y)
t2$pvalue
</code></pre>

<hr>
<h2 id='two-sample-stats'>Test Statistics for the Two-Sample Problem</h2><span id='topic+two-sample-stats'></span><span id='topic+stat_welch'></span><span id='topic+stat_student'></span><span id='topic+stat_t'></span><span id='topic+stat_fisher'></span><span id='topic+stat_f'></span><span id='topic+stat_mean'></span><span id='topic+stat_hotelling'></span><span id='topic+stat_bs'></span><span id='topic+stat_student_ip'></span><span id='topic+stat_t_ip'></span><span id='topic+stat_fisher_ip'></span><span id='topic+stat_f_ip'></span><span id='topic+stat_bg_ip'></span><span id='topic+stat_energy_ip'></span><span id='topic+stat_cq_ip'></span><span id='topic+stat_mod_ip'></span><span id='topic+stat_dom_ip'></span>

<h3>Description</h3>

<p>This is a collection of functions that provide test statistics to be used
into the permutation scheme for performing two-sample testing. These test
statistics can be divided into two categories: traditional statistics that
use empirical moments and inter-point statistics that only rely on pairwise
dissimilarities between data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_welch(data, indices1, ...)

stat_student(data, indices1, ...)

stat_t(data, indices1, ...)

stat_fisher(data, indices1, ...)

stat_f(data, indices1, ...)

stat_mean(data, indices1, ...)

stat_hotelling(data, indices1, ...)

stat_bs(data, indices1, ...)

stat_student_ip(data, indices1, ...)

stat_t_ip(data, indices1, ...)

stat_fisher_ip(data, indices1, ...)

stat_f_ip(data, indices1, ...)

stat_bg_ip(data, indices1, ...)

stat_energy_ip(data, indices1, alpha = 1L, ...)

stat_cq_ip(data, indices1, ...)

stat_mod_ip(data, indices1, ...)

stat_dom_ip(data, indices1, standardize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two-sample-stats_+3A_data">data</code></td>
<td>
<p>Either a list of the <code>n1 + n2</code> concatenated observations with the
original <code>n1</code> observations from the first sample on top and the original
<code>n2</code> observations from the second sample below. Or a dissimilarity matrix
stored as a <code><a href="stats.html#topic+dist">dist</a></code> object for all inter-point statistics
whose function name should end with <code style="white-space: pre;">&#8288;_ip()&#8288;</code>.</p>
</td></tr>
<tr><td><code id="two-sample-stats_+3A_indices1">indices1</code></td>
<td>
<p>An integer vector specifying the indices in <code>data</code> that are
considered to belong to the first sample.</p>
</td></tr>
<tr><td><code id="two-sample-stats_+3A_...">...</code></td>
<td>
<p>Extra parameters specific to some statistics.</p>
</td></tr>
<tr><td><code id="two-sample-stats_+3A_alpha">alpha</code></td>
<td>
<p>A scalar value specifying the power to which the dissimilarities
should be elevated in the computation of the inter-point energy statistic.
Default is <code>1L</code>.</p>
</td></tr>
<tr><td><code id="two-sample-stats_+3A_standardize">standardize</code></td>
<td>
<p>A boolean specifying whether the distance between medoids
in the <code><a href="#topic+stat_dom_ip">stat_dom_ip</a></code> function should be normalized by the
pooled corresponding variances. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real scalar giving the value of test statistic for the permutation
specified by the integer vector <code>indices</code>.
</p>


<h3>Traditional Test Statistics</h3>


<ul>
<li> <p><code><a href="#topic+stat_hotelling">stat_hotelling</a></code> implements Hotelling's <code class="reqn">T^2</code> statistic for
multivariate data with <code class="reqn">p &lt; n</code>.
</p>
</li>
<li> <p><code><a href="#topic+stat_student">stat_student</a></code> or <code><a href="#topic+stat_t">stat_t</a></code> implements Student's
statistic (originally assuming equal variances and thus using the pooled
empirical variance estimator). See <code><a href="stats.html#topic+t.test">t.test</a></code> for details.
</p>
</li>
<li> <p><code><a href="#topic+stat_welch">stat_welch</a></code> implements Student-Welch statistic which is
essentially a modification of Student's statistic accounting for unequal
variances. See <code><a href="stats.html#topic+t.test">t.test</a></code> for details.
</p>
</li>
<li> <p><code><a href="#topic+stat_fisher">stat_fisher</a></code> or <code><a href="#topic+stat_f">stat_f</a></code> implements Fisher's
variance ratio statistic. See <code><a href="stats.html#topic+var.test">var.test</a></code> for details.
</p>
</li>
<li> <p><code><a href="#topic+stat_mean">stat_mean</a></code> implements a statistic that computes the difference
between the means.
</p>
</li>
<li> <p><code><a href="#topic+stat_bs">stat_bs</a></code> implements the statistic proposed by Bai &amp; Saranadasa
(1996) for high-dimensional multivariate data.
</p>
</li></ul>



<h3>Inter-Point Test Statistics</h3>


<ul>
<li> <p><code><a href="#topic+stat_student_ip">stat_student_ip</a></code> or <code><a href="#topic+stat_t_ip">stat_t_ip</a></code> implements a
Student-like test statistic based on inter-point distances only as described
in Lovato et al. (2020).
</p>
</li>
<li> <p><code><a href="#topic+stat_fisher_ip">stat_fisher_ip</a></code> or <code><a href="#topic+stat_f_ip">stat_f_ip</a></code> implements a
Fisher-like test statistic based on inter-point distances only as described
in Lovato et al. (2020).
</p>
</li>
<li> <p><code><a href="#topic+stat_bg_ip">stat_bg_ip</a></code> implements the statistic proposed by Biswas &amp;
Ghosh (2014).
</p>
</li>
<li> <p><code><a href="#topic+stat_energy_ip">stat_energy_ip</a></code> implements the class of energy-based
statistics as described in Székely &amp; Rizzo (2013);
</p>
</li>
<li> <p><code><a href="#topic+stat_cq_ip">stat_cq_ip</a></code> implements the statistic proposed by Chen &amp; Qin
(2010).
</p>
</li>
<li> <p><code><a href="#topic+stat_mod_ip">stat_mod_ip</a></code> implements a statistic that computes the mean of
inter-point distances.
</p>
</li>
<li> <p><code><a href="#topic+stat_dom_ip">stat_dom_ip</a></code> implements a statistic that computes the distance
between the medoids of the two samples, possibly standardized by the pooled
corresponding variances.
</p>
</li></ul>



<h3>References</h3>

<p>Bai, Z., &amp; Saranadasa, H. (1996). Effect of high dimension: by an example of
a two sample problem. Statistica Sinica, 311-329.
</p>
<p>Lovato, I., Pini, A., Stamm, A., &amp; Vantini, S. (2020). Model-free two-sample
test for network-valued data. Computational Statistics &amp; Data Analysis, 144,
106896.
</p>
<p>Biswas, M., &amp; Ghosh, A. K. (2014). A nonparametric two-sample test applicable
to high dimensional data. Journal of Multivariate Analysis, 123, 160-171.
</p>
<p>Székely, G. J., &amp; Rizzo, M. L. (2013). Energy statistics: A class of
statistics based on distances. Journal of statistical planning and inference,
143(8), 1249-1272.
</p>
<p>Chen, S. X., &amp; Qin, Y. L. (2010). A two-sample test for high-dimensional data
with applications to gene-set testing. The Annals of Statistics, 38(2),
808-835.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10L
mx &lt;- 0
sigma &lt;- 1
delta &lt;- 10
my &lt;- mx + delta
x &lt;- rnorm(n = n, mean = mx, sd = sigma)
y &lt;- rnorm(n = n, mean = my, sd = sigma)
D &lt;- dist(c(x, y))

x &lt;- as.list(x)
y &lt;- as.list(y)

stat_welch(c(x, y), 1:n)
stat_t(c(x, y), 1:n)
stat_f(c(x, y), 1:n)
stat_mean(c(x, y), 1:n)
stat_hotelling(c(x, y), 1:n)
stat_bs(c(x, y), 1:n)

stat_t_ip(D, 1:n)
stat_f_ip(D, 1:n)
stat_bg_ip(D, 1:n)
stat_energy_ip(D, 1:n)
stat_cq_ip(D, 1:n)
stat_mod_ip(D, 1:n)
stat_dom_ip(D, 1:n)
</code></pre>

<hr>
<h2 id='use_stat'>Test Statistic Template</h2><span id='topic+use_stat'></span>

<h3>Description</h3>

<p>This function is a helper to automatically generate an <code>.R</code> file populated
with a skeleton of a typical test function compatible with <code>flipr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_stat(nsamples = 1, stat_name = "mystat")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_stat_+3A_nsamples">nsamples</code></td>
<td>
<p>An integer specifying the number of samples to be used.
Defaults to <code>1L</code>. Currently only works for one- or two-sample problems.</p>
</td></tr>
<tr><td><code id="use_stat_+3A_stat_name">stat_name</code></td>
<td>
<p>A string specifying the name of the test statistic that is
being implemented. Defaults to <code>mystat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a dedicated <code>.R</code> file with a template of code for the
function that implements the test statistic and saves it to the <code style="white-space: pre;">&#8288;R/&#8288;</code> folder
of your package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
use_stat()

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
