<!DOCTYPE html><html><head><title>Help for package relatable</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {relatable}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#elements'><p>Data from the periodic table of elements</p></a></li>
<li><a href='#relate'><p>Map inputs from a vector of keys to a vector of values.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Mapping Key-Value Pairs, Many-to-Many,
One-to-Many, and Many-to-One Relations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to safely map from a vector of keys to a vector of values, determine properties of a given relation, or ensure a relation conforms to a given type, such as many-to-many, one-to-many, injective, surjective, or bijective. Permits default return values for use similar to a vectorised switch statement, as well as safely handling large vectors, NAs, and duplicate mappings.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>compare (&ge; 0.2-6)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/domjarkey/relatable">https://github.com/domjarkey/relatable</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-01-30 15:13:31 UTC; dom</td>
</tr>
<tr>
<td>Author:</td>
<td>Dominic Jarkey [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominic Jarkey &lt;dominic.jarkey@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-01-30 16:56:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='elements'>Data from the periodic table of elements</h2><span id='topic+elements'></span>

<h3>Description</h3>

<p>A dataset containing atomic numbers, chemical symbols, and
names of 118 elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elements
</code></pre>


<h3>Format</h3>

<p>A data frame with 118 rows and 3 variables:
</p>

<dl>
<dt>Z</dt><dd><p>Atomic number</p>
</dd>
<dt>Symbol</dt><dd><p>Chemical symbol</p>
</dd>
<dt>Name</dt><dd><p>Name of element</p>
</dd>
</dl>


<h3>Source</h3>

<p><a href="https://en.wikipedia.org/wiki/Symbol_(chemistry)">https://en.wikipedia.org/wiki/Symbol_(chemistry)</a>
</p>

<hr>
<h2 id='relate'>Map inputs from a vector of keys to a vector of values.</h2><span id='topic+relate'></span><span id='topic+relation'></span>

<h3>Description</h3>

<p><code>relate</code> returns a vector <code class="reqn">Y = F(X)</code> where <code class="reqn">F</code> maps each element of input vector <code>X</code> from its position in vector <code>A</code> to its corresponding position in vector <code class="reqn">B</code>. Can be applied as a vectorised key-value dictionary with an optional default return value. Additional options restrict mapping types so relation <code class="reqn">F</code> must be a function, injective, surjective, etc.
</p>
<p><code>relation</code> returns a reusable function <code class="reqn">F</code> that performs the same operation as <code>relate</code>. In addition to providing a reusable function, if <code>handle_duplicate_mappings = TRUE</code>, <code>relation</code> checks for and eliminates duplicate mappings that would be invalid inputs for <code>relate</code>. If <code>report_properties = TRUE</code>, <code>relation</code> also prints the restrictions the mapping from <code>A</code> to <code>B</code> conforms to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relate(X, A, B, default = NA, atomic = TRUE, named = FALSE,
  allow_default = TRUE, heterogeneous_outputs = FALSE,
  handle_duplicate_mappings = FALSE, report_properties = FALSE,
  relation_type = "func", restrictions = list(),
  map_error_response = "warn")

relation(A, B, default = NA, atomic = TRUE, named = FALSE,
  allow_default = TRUE, heterogeneous_outputs = FALSE,
  handle_duplicate_mappings = FALSE, report_properties = FALSE,
  relation_type = "func", restrictions = list(),
  map_error_response = "warn")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relate_+3A_x">X</code></td>
<td>
<p>A vector of inputs</p>
</td></tr>
<tr><td><code id="relate_+3A_a">A</code></td>
<td>
<p>A vector possible inputs ordered to correspond to desired outputs given by <code>B</code>.</p>
</td></tr>
<tr><td><code id="relate_+3A_b">B</code></td>
<td>
<p>A vector possible outputs ordered to correspond to each input to the relation given by <code>A</code>.</p>
</td></tr>
<tr><td><code id="relate_+3A_default">default</code></td>
<td>
<p>The default value to return if the value of <code class="reqn">F(x)</code> is undefined.</p>
</td></tr>
<tr><td><code id="relate_+3A_atomic">atomic</code></td>
<td>
<p>If <code>TRUE</code>, the return vector <code class="reqn">Y</code> will be atomic; If <code>TRUE</code> <code class="reqn">Y</code> will be a list vector. To allow for multiple outputs from a single input, <code>atomic</code> must be set to <code>FALSE</code> if <code>relation_type = "many_to_many"</code> or <code>"one_to_many"</code>, or if <code>relation_type = NULL</code> and <code>max_one_y_per_x = FALSE</code> is an element of <code>restrictions</code> list.</p>
</td></tr>
<tr><td><code id="relate_+3A_named">named</code></td>
<td>
<p>The elements of the returned vector <code class="reqn">Y</code> will be named by to their corresponding inputs in X.</p>
</td></tr>
<tr><td><code id="relate_+3A_allow_default">allow_default</code></td>
<td>
<p>If TRUE, the provided default will be returned when <code class="reqn">F(x)</code> is undefined; otherwise invalid mappings will return an error determined by the <code>map_error_response</code> argument.</p>
</td></tr>
<tr><td><code id="relate_+3A_heterogeneous_outputs">heterogeneous_outputs</code></td>
<td>
<p>By default, elements <code class="reqn">y</code> of the output vector <code class="reqn">Y</code> will be returned as atomic vectors. In many-to-many and one-to-many relations, if the elements in the codomain are not all of the same type, this will coerce outputs to the same type. Set <code>heterogeneous_outputs = TRUE</code> to return each <code class="reqn">y</code> as a list vector. This will avoid coercion of individual outputs to the same type, but may also result in messy nested list vectors.</p>
</td></tr>
<tr><td><code id="relate_+3A_handle_duplicate_mappings">handle_duplicate_mappings</code></td>
<td>
<p>If <code>TRUE</code>, each possible input/output pair in the returned function <code class="reqn">F</code> for duplicate mappings and removes them. This may increase the runtime for larger mappings, but only for the first instance of <code>relation</code>. The function returned by <code>relation</code> does not need to re-check these properties, so will run more quickly. If <code>handle_duplicate_mappings = FALSE</code>, duplicate mappings from <code>A</code> to <code>B</code> in <code>relate</code> or <code>relation</code> will return multiple instances of the same output. See Examples.</p>
</td></tr>
<tr><td><code id="relate_+3A_report_properties">report_properties</code></td>
<td>
<p>If <code>TRUE</code>, <code>relation</code> reports which restrictions <code class="reqn">F</code> conforms to. See Details.</p>
</td></tr>
<tr><td><code id="relate_+3A_relation_type">relation_type</code></td>
<td>
<p>Ensure that the relation is restricted to a certain type, e.g. &quot;bijection&quot;. See Details.</p>
</td></tr>
<tr><td><code id="relate_+3A_restrictions">restrictions</code></td>
<td>
<p>A named list of logicals imposing constraints on the relation. These will only be used if relation_type is <em>NULL</em>. See Details.</p>
</td></tr>
<tr><td><code id="relate_+3A_map_error_response">map_error_response</code></td>
<td>
<p>How to deal with mapping errors caused by violated restrictions. Takes values &quot;ignore&quot;, &quot;warn&quot;, or &quot;throw&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>relate</code> returns vector of outputs <code class="reqn">Y = F(X)</code> where the <code class="reqn">F</code> is a relation defined by the collection of ordered pairs <code class="reqn">(a_i, b_i)</code> where <code class="reqn">a_i, b_i</code> are the <code class="reqn">i</code>th elements of <code>A</code> and <code>B</code> respectively. If <code class="reqn">F(x)</code> is undefined because <code class="reqn">x</code> is not in <code class="reqn">A</code> or it does not map to an element of <code>B</code>, <code>relate</code> will either return <code>default</code> if <code>allow_default = TRUE</code>.  Otherwise the function will throw an error.
</p>
<p>The relation <code class="reqn">F</code> can be restricted so it conforms to a particular type specified, for example <code>relation_type = "one_to_many"</code>. If <code>relation_type = NULL</code>, the properties are determined by restrictions specified with a named list, for example <code>restrictions = list(min_one_y_per_x = TRUE)</code>. For all relations where <code>min_one_y_per_x = FALSE</code>, only a list vector can be returned, so an error will be thrown if <code>atomic = TRUE</code>. If <code>A</code> and <code>B</code> do not produce a relation that conforms to the specified type or restrictions, the value of <code>map_error_response</code> will determine whether the <code>relate</code> ignores the error, reports it, or throws it. The full list of restrictions and relation types are listed below:
</p>
<p><strong>Restrictions</strong>
</p>
<p><em>NB:</em> 1) The <code>restrictions</code> argument is only used if <code>relation_type = NULL</code>; 2) If relation is allowed to return multiple values, i.e. <code>max_one_y_per_x = FALSE</code>, then <code>atomic</code> must be set to <code>FALSE</code>, otherwise an error will be throw; 3). All unspecified restrictions are assumed false, e.g.
<code>restrictions = list()</code> is equivalent to
<code>restrictions = list("min_one_y_per_x" = FALSE,
"min_one_x_per_y" = FALSE,
"max_one_y_per_x" = FALSE,
"max_one_x_per_y" = FALSE)</code>
</p>

<dl>
<dt><code>min_one_y_per_x</code></dt><dd><p>Guarantees at least one <code class="reqn">y = F(x)</code> in <code>B</code> exists for each <code class="reqn">x</code> in <code>A</code>. Returns an error if B is longer than A.</p>
</dd>
<dt><code>min_one_x_per_y</code></dt><dd><p>Guarantees at least one <code class="reqn">x</code> in <code>A</code> exists for each <code class="reqn">y</code> in <code>B</code> such that <code class="reqn">y = F(x)</code>. Returns an error if A is longer than B.</p>
</dd>
<dt><code>max_one_y_per_x</code></dt><dd><p>Guarantees no more than one <code class="reqn">y = F(x)</code> in <code>B</code> exists for each <code class="reqn">x</code> in <code>A</code>. Returns an error if A contains duplicate elements.</p>
</dd>
<dt><code>max_one_x_per_y</code></dt><dd><p>Guarantees no more than one <code class="reqn">x</code> in <code>A</code> exists for each <code class="reqn">y</code> in <code>B</code> such that <code class="reqn">y = F(x)</code>. Returns an error if B contains duplicate elements.</p>
</dd>
</dl>

<p><strong>Relation types</strong>
</p>

<dl>
<dt><code>relation_type = "one_to_one"</code></dt><dd><p>One-to-one relations require that each element in the domain to map to at most one element in the codomain, and each element of the codomain to map from the only one element in the domain. There may still be elements in <code>A</code> that do not have a mapping to an element in <code>B</code>, and vice versa. This is equivalent to
<code>restrictions = list("min_one_y_per_x" = FALSE,
"min_one_x_per_y" = FALSE,
"max_one_y_per_x" = TRUE,
"max_one_x_per_y" = TRUE)</code></p>
</dd>
<dt><code>relation_type = "many_to_many"</code></dt><dd><p>Many-to-many relations allow multiple elements in the domain to map to the same element of the codomain, and multiple elements of the codomain to map from the same element of the domain. This is equivalent to
<code>restrictions = list("min_one_y_per_x" = FALSE,
"min_one_x_per_y" = FALSE,
"max_one_y_per_x" = FALSE,
"max_one_x_per_y" = FALSE)</code></p>
</dd>
<dt><code>relation_type = "one_to_many"</code></dt><dd><p>One-to-many relations require each element of the domain to map to a distinct set of one or more elements in the codomain. This is equivalent to
<code>restrictions = list("min_one_y_per_x" = FALSE,
"min_one_x_per_y" = FALSE,
"max_one_y_per_x" = FALSE,
"max_one_x_per_y" = TRUE)</code></p>
</dd>
<dt><code>relation_type = "many_to_one"</code></dt><dd><p>Many-to-one relations allows sets of one or more elements in the domain to map to the same distinct element in the codomain. This is equivalent to
<code>restrictions = list("min_one_y_per_x" = FALSE,
"min_one_x_per_y" = FALSE,
"max_one_y_per_x" = TRUE,
"max_one_x_per_y" = FALSE)</code></p>
</dd>
<dt><code>relation_type = "func"</code></dt><dd><p>Functions map each element in the domain to exactly one element in the codomain. This is equivalent to
<code>restrictions = list("min_one_y_per_x" = TRUE,
"min_one_x_per_y" = FALSE,
"max_one_y_per_x" = TRUE,
"max_one_x_per_y" = FALSE)</code></p>
</dd>
<dt><code>relation_type = "injection"</code></dt><dd><p>A function is injective if every element of the domain maps to a unique element of the codomain. This is equivalent to
<code>restrictions = list("min_one_y_per_x" = TRUE,
"min_one_x_per_y" = FALSE,
"max_one_y_per_x" = TRUE,
"max_one_x_per_y" = TRUE)</code></p>
</dd>
<dt><code>relation_type = "surjection"</code></dt><dd><p>A function is surjective if every element of the codomain maps from an element of the domain. This is equivalent to
<code>restrictions = list("min_one_y_per_x" = TRUE,
"min_one_x_per_y" = TRUE,
"max_one_y_per_x" = TRUE,
"max_one_x_per_y" = FALSE)</code></p>
</dd>
<dt><code>relation_type = "bijection"</code></dt><dd><p>A function is bijective if it is both injective and surjective, i.e. a complete one-to-one mapping. This is equivalent to
<code>restrictions = list("min_one_y_per_x" = TRUE,
"min_one_x_per_y" = TRUE,
"max_one_y_per_x" = TRUE,
"max_one_x_per_y" = TRUE)</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Map from one vector to another
relate(c("a", "e", "i", "o", "u"), letters, LETTERS)
# [1] "A" "E" "I" "O" "U"
## or
caps &lt;- relation(letters, LETTERS)
caps("t")
# [1] "T"
caps(c("p", "q", "r"))
# [1] "P" "Q" "R"

## Create a new column in a data frame
df &lt;- data.frame(
name = c("Alice", "Bob", "Charlotte", "Dan", "Elise", "Frank"),
position = c("right", "lean-left", "left", "left", "lean-right", "no response")
)
positions &lt;- c("left", "lean-left", "independent", "lean-right", "right")
colours &lt;- c("darkblue", "lightblue", "green", "lightred", "darkred")
df$colour &lt;- relate(df$position, positions, colours, default = "gray")
df
#        name     position    colour
# 1     Alice        right   darkred
# 2       Bob    lean-left lightblue
# 3 Charlotte         left  darkblue
# 4       Dan         left  darkblue
# 5     Elise   lean-right  lightred
# 6     Frank  no response      gray

## Authors have a many-to-many relation with books:
## a book can have multiple authors and authors can write multiple books
my_library &lt;- data.frame(
  author = c(
    "Arendt",
    "Austen-Smith",
    "Austen-Smith",
    "Austen-Smith",
    "Banks",
    "Banks",
    "Camus",
    "Camus",
    "Arendt",
    "Dryzek",
    "Dunleavy"
  ),
  work = c(
    "The Human Condition",
    "Social Choice and Voting Models",
    "Information Aggregation, Rationality, and the Condorcet Jury Theorem",
    "Positive Political Theory I",
    "Information Aggregation, Rationality, and the Condorcet Jury Theorem",
    "Positive Political Theory I",
    "The Myth of Sisyphus",
    "The Rebel",
    "The Origins of Totalitarianism",
    "Theories of the Democratic State",
    "Theories of the Democratic State"
  ),
  stringsAsFactors = FALSE
)
relate(
  X = c("Arendt", "Austen-Smith", "Banks", "Dryzek", "Dunleavy"),
  A = my_library$author,
  B = my_library$work,
  atomic = FALSE,
  named = TRUE,
  relation_type = "many_to_many"
)
# $Arendt
# [1] "The Human Condition"            "The Origins of Totalitarianism"
#
# $`Austen-Smith`
# [1] "Social Choice and Voting Models"
# [2] "Information Aggregation, Rationality, and the Condorcet Jury Theorem"
# [3] "Positive Political Theory I"
#
# $Banks
# [1] "Information Aggregation, Rationality, and the Condorcet Jury Theorem"
# [2] "Positive Political Theory I"
#
# $Dryzek
# [1] "Theories of the Democratic State"
#
# $Dunleavy
# [1] "Theories of the Democratic State"

## Duplicate mappings will return multiple copies by default:
relate(
  X = 1:3,
  A = c(1, 2, 2, 3, 4, 5),
  B = c('a', 'b', 'b', 'c', 'd', 'e'),
  relation_type = "many_to_many",
  atomic = FALSE
)
# [[1]]
# [1] "a"
#
# [[2]]
# [1] "b" "b"
#
# [[3]]
# [1] "c"

## Use handle_duplicate_mappings = TRUE to ignore these and avoid mapping errors.
nums_to_letters &lt;- relation(
  A = c(1, 2, 2, 3, 4, 5),
  B = c('a', 'b', 'b', 'c', 'd', 'e'),
  relation_type = "bijection",
  handle_duplicate_mappings = TRUE
)
nums_to_letters(X = c(1, 2, 3))
# [1] "a" "b" "c"

## Use relation with report_properties = TRUE to determine the properties of specified relation
domain &lt;- -3:3
image &lt;- domain^2
relation(domain, image, report_properties = TRUE)
# Relation properties:
# min_one_y_per_x min_one_x_per_y max_one_y_per_x max_one_x_per_y
# TRUE            TRUE            TRUE           FALSE
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
