<!DOCTYPE html><html lang="en"><head><title>Help for package hht</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hht}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CEEMD'><p>Complete Ensemble Empirical Mode Decomposition</p></a></li>
<li><a href='#CombineTrials'><p>Gather EEMD trial files</p></a></li>
<li><a href='#EEMD'><p>Ensemble Empirical Mode Decomposition</p></a></li>
<li><a href='#EEMDCompile'><p>Process EEMD results</p></a></li>
<li><a href='#EEMDResift'><p>Resift averaged IMFs from EEMD</p></a></li>
<li><a href='#EvolutiveFFT'>
<p>Calculate the evolutive Fourier spectrogram.</p></a></li>
<li><a href='#FTGramImage'><p>Display Fourier spectrogram</p></a></li>
<li><a href='#HHGramImage'><p>Display Hilbert spectrogram</p></a></li>
<li><a href='#HHRender'><p>Render Hilbert spectrogram</p></a></li>
<li><a href='#HHSpecPlot'><p>Display Hilbert periodogram</p></a></li>
<li><a href='#HHSpectrum'><p>Generate Hilbert spectrum</p></a></li>
<li><a href='#HHTPackagePlotter'>
<p>Set up spectrogram figure</p></a></li>
<li><a href='#HilbertEnvelope'>
<p>Instantaneous amplitude</p></a></li>
<li><a href='#HilbertTransform'>
<p>The Hilbert transform</p></a></li>
<li><a href='#InstantaneousFrequency'>
<p>Derive instantaneous frequency</p></a></li>
<li><a href='#PlotIMFs'><p>Display IMFs</p></a></li>
<li><a href='#PrecisionTester'>
<p>Test numerically determined instantaneous frequency against exact instantaneous frequency</p></a></li>
<li><a href='#sig'><p>Transitory Seismic Event at Deception Island Volcano</p></a></li>
<li><a href='#Sig2IMF'><p>Empirical Mode Decomposition wrapper</p></a></li>
<li><a href='#tt'><p>Ocean Bottom Seismometer Sample Rate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Hilbert-Huang Transform: Tools and Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-12</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>EMD (&ge; 1.5.5), fields (&ge; 6.7.6)</td>
</tr>
<tr>
<td>Description:</td>
<td>Builds on the EMD package to provide additional tools for empirical mode decomposition (EMD) and Hilbert spectral analysis. It also implements the ensemble empirical decomposition (EEMD) and the complete ensemble empirical mode decomposition (CEEMD) methods to avoid mode mixing and intermittency problems found in EMD analysis.  The package comes with several plotting methods that can be used to view intrinsic mode functions, the HHT spectrum, and the Fourier spectrum. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel C. Bowman &lt;danny.c.bowman@gmail.com&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel C. Bowman [aut, cre],
  Jonathan M. Lees [ctb]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-13 01:59:52 UTC; dantayaga</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-13 14:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='CEEMD'>Complete Ensemble Empirical Mode Decomposition</h2><span id='topic+CEEMD'></span>

<h3>Description</h3>

<p>This function implements the complete ensemble empirical mode decomposition (CEEMD) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEEMD(sig, tt, noise.amp, trials, verbose = TRUE, 
    spectral.method = "arctan", diff.lag = 1, tol = 5, max.sift = 200,
    stop.rule = "type5", boundary = "wave", sm = "none",
    smlevels = c(1), spar = NULL, max.imf = 100, interm = NULL, 
    noise.type = "gaussian", noise.array = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CEEMD_+3A_sig">sig</code></td>
<td>
<p>a time series to be decomposed (vector)</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_tt">tt</code></td>
<td>
<p>The sample times of <code>sig</code></p>
</td></tr>
<tr><td><code id="CEEMD_+3A_noise.amp">noise.amp</code></td>
<td>
<p>Amplitude of white noise to use in denoising algorithm</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_trials">trials</code></td>
<td>
<p>Number of times to run EMD</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, notify when each trial is complete</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_spectral.method">spectral.method</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_diff.lag">diff.lag</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_tol">tol</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_max.sift">max.sift</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_stop.rule">stop.rule</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_boundary">boundary</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_sm">sm</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_smlevels">smlevels</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_spar">spar</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_max.imf">max.imf</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_interm">interm</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_noise.type">noise.type</code></td>
<td>
<p>If unspecified or <code>gaussian</code>, produce a Gaussian noise series with length <code>length(sig)</code> and standard deviation <code>noise.amp</code>.
If <code>uniform</code>, produce a uniform random distribution with length <code>length(sig)</code> and maximum absolute value of <code>noise.amp</code>.
If <code>custom</code>, then use a custom noise array as defined in input parameter <code>noise.array</code> (see below).</p>
</td></tr>
<tr><td><code id="CEEMD_+3A_noise.array">noise.array</code></td>
<td>
<p>If <code>noise.type = "custom"</code>, this array must be a TRIALS x LENGTH(TT) collection of time series to be used in the place of uniform or gaussian noise.
Each row in the array corresponds to the noise series added for that particular trial during the CEEMD run.
By default, <code>noise.array = NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the complete ensemble empirical mode decomposition, a noise assisted empirical mode decomposition algorithm.
The CEEMD works by adding a certain amplitude of white noise to a time series, decomposing it via EMD, and saving the result.
In contrast to the Ensemble Empirical Mode Decomposition (EEMD) method, the CEEMD also ensures that the IMF set is quasi-complete and orthogonal.
The CEEMD can ameliorate mode mixing and intermittency problems.
Keep in mind that the CEEMD is a computationally expensive algorithm and may take significant time to run.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>ceemd.result</code></td>
<td>
<p>The final result of the CEEMD algorithm</p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p>Daniel Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a></p>


<h3>References</h3>

<p>Torres, M. E., Colominas, M. A., Schlotthauer, G., Flandrin, P. (2011).  A complete ensemble empirical mode decomposition with adaptive noise.
<em>2011 IEEE International Conference on Acoustics, Speech, and Signal Processing</em>, pp.4144-4147, doi: 10.1109/ICASSP.2011.5947265.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EEMD">EEMD</a></code>, <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>, <code><a href="#topic+PlotIMFs">PlotIMFs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(PortFosterEvent)
noise.amp &lt;- 6.4e-07
trials &lt;- 100

ceemd.result &lt;- CEEMD(sig, tt, noise.amp, trials)
PlotIMFs(ceemd.result, imf.list = 1:6, time.span = c(5, 10))

## End(Not run)

</code></pre>

<hr>
<h2 id='CombineTrials'>Gather EEMD trial files</h2><span id='topic+CombineTrials'></span>

<h3>Description</h3>

<p>This function gathers trial files from multiple directories, renumbers them, and saves them to a single directory for processing using <code><a href="#topic+EEMDCompile">EEMDCompile</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CombineTrials(in.dirs, out.dir, copy=TRUE)  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CombineTrials_+3A_in.dirs">in.dirs</code></td>
<td>
<p>Directories containing trial file sets from one EEMD run.</p>
</td></tr>
<tr><td><code id="CombineTrials_+3A_out.dir">out.dir</code></td>
<td>
<p>Directory in which to save all trial files.</p>
</td></tr>
<tr><td><code id="CombineTrials_+3A_copy">copy</code></td>
<td>
<p>Copy files (<code>TRUE</code>) or move them (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parallel processing is an efficient method for running EEMD.
However, this will result in several directories, each with trial files numbered from 1 to N.
These files cannot simply be copied together into the same directory, because then they would overwrite each other.
This function gathers all trial files in multiple directories, renumbers them, and saves them in a different directory.
</p>


<h3>Value</h3>

 
<p>The trial files are saved in the directory specified by <code>out.dir</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+EEMD">EEMD</a></code>, <code><a href="#topic+EEMDCompile">EEMDCompile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Suppose you have run 3 different EEMD sets of 100 trials each 
#and saved the results in EEMD1, EEMD2, EEMD3, respectively:
in.dirs &lt;- c("/home/user/EEMD1", "/home/user/EEMD2/", "/home/user/EEMD3")
out.dir &lt;- "/home/user/all.trials"
## Not run: CombineTrials(in.dirs, out.dir)
#Now all your trials should be located in /home/user/all.trials, 
#numbered 1 through 300
</code></pre>

<hr>
<h2 id='EEMD'>Ensemble Empirical Mode Decomposition</h2><span id='topic+EEMD'></span>

<h3>Description</h3>

<p>This function performs ensemble empirical mode decomposition (EEMD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EEMD(sig, tt, noise.amp, trials, nimf, trials.dir = NULL, verbose = TRUE, 
    spectral.method = "arctan", diff.lag = 1, tol = 5, max.sift = 200,
    stop.rule = "type5", boundary = "wave", sm = "none",
    smlevels = c(1), spar = NULL, max.imf = 100, interm = NULL, 
    noise.type = "gaussian", noise.array = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EEMD_+3A_sig">sig</code></td>
<td>
<p>a time series to be decomposed (vector)</p>
</td></tr>
<tr><td><code id="EEMD_+3A_tt">tt</code></td>
<td>
<p>The sample times of <code>sig</code></p>
</td></tr>
<tr><td><code id="EEMD_+3A_noise.amp">noise.amp</code></td>
<td>
<p>Amplitude of white noise to use in denoising algorithm</p>
</td></tr>
<tr><td><code id="EEMD_+3A_trials">trials</code></td>
<td>
<p>Number of times to run EMD</p>
</td></tr>
<tr><td><code id="EEMD_+3A_nimf">nimf</code></td>
<td>
<p>Number of IMFs to record, IMFs past this number will not be saved</p>
</td></tr>
<tr><td><code id="EEMD_+3A_trials.dir">trials.dir</code></td>
<td>
<p>Directory where EEMD trial files will be stored, defaults to &ldquo;trials.&rdquo;  This will create a directory if none exists.</p>
</td></tr>
<tr><td><code id="EEMD_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, notify when each trial is complete</p>
</td></tr>
<tr><td><code id="EEMD_+3A_spectral.method">spectral.method</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMD_+3A_diff.lag">diff.lag</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMD_+3A_tol">tol</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMD_+3A_max.sift">max.sift</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMD_+3A_stop.rule">stop.rule</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMD_+3A_boundary">boundary</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMD_+3A_sm">sm</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMD_+3A_smlevels">smlevels</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMD_+3A_spar">spar</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMD_+3A_max.imf">max.imf</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMD_+3A_interm">interm</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMD_+3A_noise.type">noise.type</code></td>
<td>
<p>If unspecified or <code>gaussian</code>, produce a Gaussian noise series with length <code>length(sig)</code> and standard deviation <code>noise.amp</code>.
If <code>uniform</code>, produce a uniform random distribution with length <code>length(sig)</code> and maximum absolute value of <code>noise.amp</code>.
If <code>custom</code>, then use a custom noise array as defined in input parameter <code>noise.array</code> (see below).</p>
</td></tr>
<tr><td><code id="EEMD_+3A_noise.array">noise.array</code></td>
<td>
<p>If <code>noise.type = "custom"</code>, this array must be a TRIALS x LENGTH(TT) collection of time series to be used in the place of uniform or gaussian noise.
Each row in the array corresponds to the noise series added for that particular trial during the EEMD run.
By default, <code>noise.array = NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs ensemble empirical mode decomposition, a noise assisted version of the EMD algorithm.
The EEMD works by adding a certain amplitude of white noise to a time series, decomposing it via EMD, and saving the result.
If this is done enough times, the averages of the noise perturbed IMFs will approach the &ldquo;true&rdquo; IMF set.
The EEMD can ameliorate mode mixing and intermittency problems (see references section).
</p>
<p>This EEMD algorithm creates a directory <code>trials.dir</code> and saves each EMD trial into this directory.
The number of trials is defined using <code>trials</code>.
The trial files in this directory can then be processed using <code><a href="#topic+EEMDCompile">EEMDCompile</a></code> to produce the averaged IMF set, or to plot the Hilbert spectrogram of the data.
Keep in mind that the EEMD is an expensive algorithm and may take significant time to run.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>emd.result</code></td>
<td>
<p>The result of each individual EMD trial. This is saved directly to files in directory <code>trials.dir</code> (i.e. it is not returned by <code>EEMD</code>.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Previous versions of this function used a uniform random noise distribution (i.e. <code>runif</code>) to generate the noise time series.
The default noise time series is now Gaussian in accordance with existing EEMD literature.</p>


<h3>Author(s)</h3>

<p>Daniel Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a></p>


<h3>References</h3>

<p>Wu, Z. A. and Huang, N. E. (2009) Ensemble empirical mode decomposition: A noise assisted data analysis method.
<em>Advances in Adaptive Data Analysis</em>, <b>1</b>, 1-41.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sig2IMF">Sig2IMF</a></code>, <code><a href="#topic+CombineTrials">CombineTrials</a></code>, <code><a href="#topic+EEMDCompile">EEMDCompile</a></code>, <code><a href="#topic+PlotIMFs">PlotIMFs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PortFosterEvent)
trials &lt;- 10
nimf &lt;- 10
noise.amp &lt;- 6.4e-07
trials.dir &lt;- "test"

set.seed(628)
#Run EEMD (this may take some time)
## Not run: EEMD(sig, tt, noise.amp, trials, nimf, trials.dir = trials.dir)

#Compile the results
## Not run: EEMD.result &lt;- EEMDCompile(trials.dir, trials, nimf)

#Plot the IMFs
time.span &lt;- c(5, 10)
imf.list &lt;- 1:3
os &lt;- TRUE
res &lt;- TRUE
## Not run: PlotIMFs(EEMD.result, time.span, imf.list, os, res)
</code></pre>

<hr>
<h2 id='EEMDCompile'>Process EEMD results</h2><span id='topic+EEMDCompile'></span>

<h3>Description</h3>

<p>This function compiles individual trial files from an EEMD run, allowing other functions to plot IMFs and Hilbert spectrograms of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EEMDCompile(trials.dir, trials, nimf)  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EEMDCompile_+3A_trials.dir">trials.dir</code></td>
<td>
<p>Directory where previously generated EEMD trial files are stored.</p>
</td></tr>
<tr><td><code id="EEMDCompile_+3A_trials">trials</code></td>
<td>
<p>Number of trial files to read.  This will warn users if the number of requested trials is greater than the number of files in the directory.</p>
</td></tr>
<tr><td><code id="EEMDCompile_+3A_nimf">nimf</code></td>
<td>
<p>Number of IMFs per EMD run. IMFs past this number will not be saved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EEMD algorithm can generate hundreds of files, resulting in massive amounts of data.
The <code>EEMDCompile</code> function processes these files, generating an averaged IMF set and compiling the Hilbert spectrogram of each EMD run.
The output of <code>EEMDCompile</code> can be used in <code><a href="#topic+PlotIMFs">PlotIMFs</a></code> and <code><a href="#topic+HHGramImage">HHGramImage</a></code>.
The averaged IMF set from <code>EEMDCompile</code> can be resifted using <code><a href="#topic+EEMDResift">EEMDResift</a></code>. 
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>EEMD.result</code></td>
<td>
<p>The averaged IMF set and individual Hilbert spectra of EMD trials generated through EEMD.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+EEMD">EEMD</a></code>, <code><a href="#topic+CombineTrials">CombineTrials</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PortFosterEvent)
trials &lt;- 10
nimf &lt;- 10
noise.amp &lt;- 6.4e-07
trials.dir &lt;- "test"

set.seed(628)
#Run EEMD (this may take some time)
## Not run: EEMD(sig, tt, noise.amp, trials, nimf, trials.dir = trials.dir)

#Compile the results
## Not run: EEMD.result &lt;- EEMDCompile(trials.dir, trials, nimf)

#Plot the IMFs
time.span &lt;- c(5, 10)
imf.list &lt;- 1:3
os &lt;- TRUE
res &lt;- TRUE
## Not run: PlotIMFs(EEMD.result, time.span, imf.list, os, res)
</code></pre>

<hr>
<h2 id='EEMDResift'>Resift averaged IMFs from EEMD</h2><span id='topic+EEMDResift'></span>

<h3>Description</h3>

<p>Averaged IMFs produced by EEMD may not satisfy the strict definition of an IMF, and therefore they may not have meaningful Hilbert spectrograms.
Huang and Wu (2008) suggest another round of sifting to ensure that the averaged IMFs are made to satisfy the IMF definition.
This function resifts the averaged IMF set and saves the results based on rules described in the input <code>resift.rule</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EEMDResift(EEMD.result, resift.rule, spectral.method = "arctan", 
    diff.lag = 1, tol = 5, max.sift = 200, stop.rule = "type5", 
    boundary = "wave", sm = "none", smlevels = c(1), 
    spar = NULL, max.imf = 100, interm = NULL)  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EEMDResift_+3A_eemd.result">EEMD.result</code></td>
<td>
<p>The averaged IMF set and individual Hilbert spectra of EMD trials generated through EEMD.</p>
</td></tr>
<tr><td><code id="EEMDResift_+3A_resift.rule">resift.rule</code></td>
<td>
<p>How the resifting algorithm chooses which IMF to save
</p>

<ul>
<li><p>Integer - Which IMF in the resifted set will be saved (so if resift.rule=1, the first IMF will be saved, the rest will be discarded)
</p>
</li>
<li><p>&ldquo;last&rdquo; - The last IMF will be saved (not terribly useful)
</p>
</li>
<li><p>&ldquo;max.var&rdquo; - The IMF with the most variance will be saved.  This will get the most &ldquo;significant&rdquo; IMF out of each resifted set.
</p>
</li>
<li><p>&ldquo;all&rdquo; - Every single new IMF generated from resifting the averaged IMFs will be saved.  There may be a lot of them!</p>
</li></ul>
</td></tr>
<tr><td><code id="EEMDResift_+3A_spectral.method">spectral.method</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMDResift_+3A_diff.lag">diff.lag</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMDResift_+3A_tol">tol</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMDResift_+3A_max.sift">max.sift</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMDResift_+3A_stop.rule">stop.rule</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMDResift_+3A_boundary">boundary</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMDResift_+3A_sm">sm</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMDResift_+3A_smlevels">smlevels</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMDResift_+3A_spar">spar</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMDResift_+3A_max.imf">max.imf</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
<tr><td><code id="EEMDResift_+3A_interm">interm</code></td>
<td>
<p>See <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+EEMDCompile">EEMDCompile</a></code> generates a list of averaged IMFs from EEMD trials.
These averaged IMFs often do not satisfy the definition of an IMF, usually because some of them are mixtures of different time scales.
This is a consequence of the noise perturbation method of EEMD, but it complicates the attempt to create a meaningful Hilbert spectrogram from the averaged IMF set.
The resifting algorithm takes each averaged IMF and performs EMD, thereby splitting each one into multiple &ldquo;sub-IMFs&rdquo;, each of which satisfy the strict definition of an IMF.
The question then is: which of these sub-IMFs best represent the averaged IMF?
The most rigorous solution is to set <code>resift.rule</code> to <code>"all"</code>, but that tends to make a large number of sub-IMFs, many with very low amplitude.
Another solution is to accept the sub-IMF with the most variance, as that probably represents the fundamental information content of the original averaged IMF.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>resift.result</code></td>
<td>
<p>The resifted results of the averaged IMF set and the individual Hilbert spectra of each resifted IMF.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+EEMD">EEMD</a></code>, <code><a href="#topic+EEMDCompile">EEMDCompile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PortFosterEvent)

trials=10
nimf=10
noise.amp=6.4e-07
trials.dir="test"

set.seed(628)

#Run EEMD (this may take some time)
## Not run: EEMD(sig, tt, noise.amp, trials, nimf, noise.amp, trials.dir = trials.dir)

#Compile the results
## Not run: EEMD.result &lt;- EEMDCompile(trials.dir, trials, nimf)


resift.rule="max.var"
## Not run: resift.result &lt;- EEMDResift(EEMD.result, resift.rule)

#Plot the IMFs
time.span=c(5, 10)
imf.list=1:3
os=TRUE
res=TRUE
## Not run: PlotIMFs(resift.result, time.span, imf.list, os, res)
</code></pre>

<hr>
<h2 id='EvolutiveFFT'>
Calculate the evolutive Fourier spectrogram.
</h2><span id='topic+EvolutiveFFT'></span>

<h3>Description</h3>

<p>Generates the evolutive Fourier spectrogram of a signal, and returns it for use in <code><a href="#topic+FTGramImage">FTGramImage</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvolutiveFFT(sig, dt, ft, freq.span, taper = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EvolutiveFFT_+3A_sig">sig</code></td>
<td>

<p>Signal to analyze.
</p>
</td></tr>
<tr><td><code id="EvolutiveFFT_+3A_dt">dt</code></td>
<td>

<p>Sample rate (must be constant).
</p>
</td></tr>
<tr><td><code id="EvolutiveFFT_+3A_ft">ft</code></td>
<td>

<p>Fourier transform input parameters
</p>

<ul>
<li><p>ft$nfft  The frequency resolution, should be in powers of 2
</p>
</li>
<li><p>ft$ns  Number of samples in a window
</p>
</li>
<li><p>ft$nov  Number of samples to overlap, must be less than <code>ft$ns</code></p>
</li></ul>

</td></tr>
<tr><td><code id="EvolutiveFFT_+3A_freq.span">freq.span</code></td>
<td>

<p>Frequency range to return.
</p>
</td></tr>
<tr><td><code id="EvolutiveFFT_+3A_taper">taper</code></td>
<td>

<p>Amount of cosine taper to apply.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function and users will likely not call it directly.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>z</code></td>
<td>
<p>Power spectrum</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Frequency</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Time</p>
</td></tr>
<tr><td><code>original.signal</code></td>
<td>
<p>The input signal</p>
</td></tr>
<tr><td><code>tt</code></td>
<td>
<p>Sample times based on input sample rate <code>dt</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a modification of the <code>evolfft</code> function in the <code>RSEIS</code> package.
</p>


<h3>Author(s)</h3>

<p>Daniel C. Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a>, Jonathan M. Lees
</p>


<h3>References</h3>

<p>Jonathan M. Lees (2012). RSEIS: Seismic Time Series Analysis Tools. R
package version 3.1-3.
</p>

<hr>
<h2 id='FTGramImage'>Display Fourier spectrogram</h2><span id='topic+FTGramImage'></span>

<h3>Description</h3>

<p>This function displays a Fourier spectrogram using the same plot structure and options as <code><a href="#topic+HHGramImage">HHGramImage</a></code>.
It uses the function <code><a href="#topic+EvolutiveFFT">EvolutiveFFT</a></code> to generate a spectrogram, then wraps it in the same plotting format as <code><a href="#topic+HHGramImage">HHGramImage</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FTGramImage(sig, dt, ft, time.span = NULL, freq.span = NULL, 
     amp.span = NULL, taper=0.05, scaling = "none", grid=TRUE, 
    colorbar=TRUE, backcol=c(0, 0, 0), colormap=NULL, pretty=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FTGramImage_+3A_sig">sig</code></td>
<td>
<p>The signal to process</p>
</td></tr>
<tr><td><code id="FTGramImage_+3A_dt">dt</code></td>
<td>
<p>sample rate</p>
</td></tr>
<tr><td><code id="FTGramImage_+3A_ft">ft</code></td>
<td>
<p>Fourier spectrogram options</p>
</td></tr>
</table>

<ul>
<li><p><code>ft$nfft</code> is the fft length
</p>
</li>
<li><p><code>ft$ns</code> is the number of samples in a window
</p>
</li>
<li><p><code>ft$nov</code> is the number of samples to overlap</p>
</li></ul>

<table role = "presentation">
<tr><td><code id="FTGramImage_+3A_time.span">time.span</code></td>
<td>
<p>Time span to render spectrogram over.  <code>NULL</code> will draw the spectrogram over the entire signal.</p>
</td></tr>
<tr><td><code id="FTGramImage_+3A_freq.span">freq.span</code></td>
<td>
<p>Frequency span to render spectrogram over.  <code>NULL</code> plots everything up to the Nyquist frequency.</p>
</td></tr>
<tr><td><code id="FTGramImage_+3A_amp.span">amp.span</code></td>
<td>
<p>Amplitude range to plot.  <code>NULL</code> plots everything.</p>
</td></tr>
<tr><td><code id="FTGramImage_+3A_taper">taper</code></td>
<td>
<p>Taper value to use for spectrogram (default is 0.05), see <code>spec.taper</code> in the <code>base</code> package.</p>
</td></tr>
<tr><td><code id="FTGramImage_+3A_scaling">scaling</code></td>
<td>
<p>determines whether to apply logarithmic (log), or square root (sqrt) scaling to the amplitude data</p>
</td></tr>
<tr><td><code id="FTGramImage_+3A_grid">grid</code></td>
<td>
<p>Boolean - whether to display grid lines or not</p>
</td></tr>
<tr><td><code id="FTGramImage_+3A_colorbar">colorbar</code></td>
<td>
<p>Boolean - whether to display amplitude colorbar or not</p>
</td></tr>
<tr><td><code id="FTGramImage_+3A_backcol">backcol</code></td>
<td>
<p>What background color to use behind the spectrogram, in a 3 element vector: <code>c(red, green, blue)</code></p>
</td></tr>
<tr><td><code id="FTGramImage_+3A_colormap">colormap</code></td>
<td>
<p>What palette object to use for the spectrogram, defaults to <code>rainbow</code></p>
</td></tr>
<tr><td><code id="FTGramImage_+3A_pretty">pretty</code></td>
<td>
<p>Boolean - choose nice axes values, some adjustment may result</p>
</td></tr>
<tr><td><code id="FTGramImage_+3A_...">...</code></td>
<td>
<p>This function supports some optional parameters as well:
</p>

<ul>
<li><p>trace.format - the format of the trace minima and maxima in sprintf format
</p>
</li>
<li><p>img.x.format - the format of the X axis labels of the image in sprintf format
</p>
</li>
<li><p>img.y.format - the format of the Y axis labels of the image in sprintf format
</p>
</li>
<li><p>colorbar.format - the format of the colorbar labels in sprintf format
</p>
</li>
<li><p>cex.lab - the font size of the image axis labels
</p>
</li>
<li><p>cex.colorbar - the font size of the colorbar
</p>
</li>
<li><p>cex.trace - the font size of the trace axis labels
</p>
</li>
<li><p>img.x.lab - the X - axis label of the image, it defaults to &quot;time&quot;
</p>
</li>
<li><p>img.y.lab- the Y - axis label of the image, it defaults to &quot;frequency&quot;
</p>
</li>
<li><p>main - figure title</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple Fourier spectrogram plotter.
It's useful to compare this image with images generated by <code><a href="#topic+HHGramImage">HHGramImage</a></code> to see how the Fourier and Hilbert spectrograms differ.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>img</code></td>
<td>
<p>The spectrogram image, suitable for plotting with the generic <code>image</code> function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a></p>


<h3>References</h3>

<p>Jonathan M. Lees (2012). RSEIS: Seismic Time Series Analysis Tools. R
package version 3.0-6. http://CRAN.R-project.org/package=RSEIS</p>


<h3>See Also</h3>

<p><code><a href="#topic+HHGramImage">HHGramImage</a></code>, <code><a href="#topic+EvolutiveFFT">EvolutiveFFT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PortFosterEvent)

dt &lt;- mean(diff(tt))

ft &lt;- list()
ft$nfft &lt;- 4096
ft$ns &lt;- 30
ft$nov &lt;- 29

time.span &lt;- c(5, 10)
freq.span &lt;- c(0, 25)
amp.span &lt;- c(1e-5, 0.0003)
FTGramImage(sig, dt, ft, time.span = time.span, freq.span = freq.span, 
    amp.span = amp.span, pretty = TRUE, img.x.format = "%.1f",
    img.y.format = "%.0f",
    main = "Port Foster Event - Fourier Spectrogram")
</code></pre>

<hr>
<h2 id='HHGramImage'>Display Hilbert spectrogram</h2><span id='topic+HHGramImage'></span>

<h3>Description</h3>

<p>This function displays the Hilbert spectrogram of EMD and EEMD results.</p>


<h3>Usage</h3>

<pre><code class='language-R'>HHGramImage(hgram, time.span = NULL, freq.span = NULL, amp.span = NULL, 
    clustergram = FALSE, cluster.span = NULL, imf.list = NULL, 
    fit.line = FALSE, scaling = "none", grid = TRUE, colorbar = TRUE, 
    backcol = c(0, 0, 0), colormap = NULL, pretty = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HHGramImage_+3A_hgram">hgram</code></td>
<td>
<p>Data structure generated by <code><a href="#topic+HHRender">HHRender</a></code>.</p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_time.span">time.span</code></td>
<td>
<p>Time span to render spectrogram over.  <code>NULL</code> will draw the spectrogram over the entire signal.</p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_freq.span">freq.span</code></td>
<td>
<p>Frequency span to render spectrogram over.  <code>NULL</code> plots everything up to the max frequency set when <code><a href="#topic+HHRender">HHRender</a></code> was run.</p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_amp.span">amp.span</code></td>
<td>
<p>This is the amplitude span to plot, everything below is set to <code>backcol</code>, everything above is set to max color, <code>NULL</code> scales to the range in the signal.</p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_clustergram">clustergram</code></td>
<td>
<p>If <code>TRUE</code>, plot the number of times data occupies a given pixel instead of plotting the signal amplitude.
This is akin to the <code>weight</code> component returned by the <code>as.image</code> function in the <code>fields</code> package.
Only applies when using EEMD.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_cluster.span">cluster.span</code></td>
<td>
<p>Plots only parts of the signal that have a certain number of data points per pixel (see notes below).  
This only applies when using EEMD.  
The pixel range is defined as <code>c(AT LEAST, AT MOST)</code>.</p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_imf.list">imf.list</code></td>
<td>
<p>A vector of IMFs to plot on the spectrogram, the others will not be shown.
You must set <code>combine.imfs = FALSE</code> in <code><a href="#topic+HHRender">HHRender</a></code> for this to work correctly.</p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_fit.line">fit.line</code></td>
<td>
<p>If <code>TRUE</code>, plot a red line on the trace that shows the part of the signal represented by the spectrogram</p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code id="HHGramImage_+3A_scaling">scaling</code></td>
<td>
<p>determines whether to apply a logarithmic (<code>"log"</code>), or square root (<code>"sqrt"</code>) scaling to the amplitude data, default is <code>"none"</code></p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_grid">grid</code></td>
<td>
<p>Boolean - whether to display grid lines or not</p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_colorbar">colorbar</code></td>
<td>
<p>Boolean - whether to display amplitude colorbar or not</p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_backcol">backcol</code></td>
<td>
<p>What background color to use behind the spectrogram, in a 3 element vector: <code>c(red, green, blue)</code></p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_colormap">colormap</code></td>
<td>
<p>What palette object to use for the spectrogram, defaults to <code>rainbow</code></p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_pretty">pretty</code></td>
<td>
<p>Boolean - to choose nice axes values or to use exactly the ranges given</p>
</td></tr>
<tr><td><code id="HHGramImage_+3A_...">...</code></td>
<td>
<p>This function supports some optional parameters as well:
</p>

<ul>
<li><p>trace.format - the format of the trace minima and maxima in sprintf format
</p>
</li>
<li><p>img.x.format - the format of the X axis labels of the image in sprintf format
</p>
</li>
<li><p>img.y.format - the format of the Y axis labels of the image in sprintf format
</p>
</li>
<li><p>colorbar.format - the format of the colorbar labels in sprintf format
</p>
</li>
<li><p>cex.lab - the font size of the image axis labels
</p>
</li>
<li><p>cex.colorbar - the font size of the colorbar
</p>
</li>
<li><p>cex.trace - the font size of the trace axis labels
</p>
</li>
<li><p>img.x.lab - the X - axis label of the image, it defaults to &quot;time&quot;
</p>
</li>
<li><p>img.y.lab - the Y - axis label of the image, it defaults to &quot;frequency&quot;
</p>
</li>
<li><p>main - adds a title to the figure</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the image generated by <code><a href="#topic+HHRender">HHRender</a></code> along with the original signal trace.
The plotter can use data from both EMD and EEMD runs.
When it plots EEMD data, it shows the time frequency plot of every single trial at once.
The <code>cluster.span</code> option is useful in this case because it can distinguish &ldquo;signal&rdquo; (pixels where multiple trials intersect) from &ldquo;noise&rdquo; (whether from EEMD or from nature) where only one trial contributes data.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>img</code></td>
<td>
<p>The spectrogram image, suitable for plotting with the generic <code>image</code> function</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Using the option <code>combine.imfs = FALSE</code> in <code><a href="#topic+HHRender">HHRender</a></code> will cause <code>HHGramImage</code> to run much, much slower.
Unless you have a compelling reason to plot certain IMFs (as opposed to all of them combined), I recommend against using this.
</p>
<p>It may take some trial and error to get a nice image.
For example, if the data points are too small (and thus the spectrogram looks like a mist of fine points rather than continuous frequency bands), try rerunning <code><a href="#topic+HHRender">HHRender</a></code>, but with lower frequency resolution.
If the spectrogram is extremely noisy, try defining <code>cluster.span</code> - this usually gets rid of most of the random noise.
For example, a <code>cluster.span</code> of <code>c(3, 10)</code> only keeps pixels that have data from at least 3 trials, up to 10.  
Most noise pixels will only have one trial contributing data. 
The upper limit (10) is a formality - it does not make much sense at this point to put an upper limit on trial intersections unless you are interested in the <b>noise</b> component isolated from the signal.
</p>


<h3>Author(s)</h3>

<p>Daniel Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+FTGramImage">FTGramImage</a></code>, <code><a href="#topic+HHRender">HHRender</a></code>, <code><a href="#topic+HHSpecPlot">HHSpecPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PortFosterEvent)

trials &lt;- 10
nimf &lt;- 10
noise.amp &lt;- 6.4e-07
trials.dir &lt;- "test"

set.seed(628)
#Run EEMD (this may take some time)
## Not run: EEMD(sig, tt, noise.amp, trials, nimf, trials.dir = trials.dir)

#Compile the results
## Not run: EEMD.result &lt;- EEMDCompile(trials.dir, trials, nimf)

#Calculate spectrogram
dt  &lt;-  0.1
dfreq  &lt;-  0.1
## Not run: hgram &lt;- HHRender(EEMD.result, dt, dfreq)


#Plot spectrogram 
time.span &lt;- c(4, 10)
freq.span &lt;- c(0, 25)
## Not run: HHGramImage(hgram, time.span, freq.span,  
pretty = TRUE, img.x.format = "%.1f", img.y.format = "%.0f", 
main = "Port Foster event - ensemble Hilbert spectrogram")
## End(Not run)

#Plot intersections

## Not run: HHGramImage(hgram, time.span, freq.span, amp.span = c(1, 5),  
clustergram = TRUE, pretty = TRUE, img.x.format = "%.1f", colorbar.format = "%.0f",
img.y.format = "%.0f", main = "Port Foster event - signal stability")
## End(Not run)

#Decluster
#show only areas with stable signal 
#i.e. each pixel has data from at least 3 EEMD trials
## Not run: HHGramImage(hgram, time.span = time.span, freq.span = freq.span,
cluster.span = c(, 10), pretty = TRUE, img.x.format = "%.1f", 
img.y.format = "%.0f",
main = "Port Foster event - ensemble Hilbert spectrogram")
## End(Not run)

#Log amplitude plot

## Not run: HHGramImage(hgram, time.span = time.span, freq.span = freq.span,
scaling = "log", pretty = TRUE, img.x.format = "%.1f", img.y.format = "%.0f",
main = "Port Foster event - ensemble Hilbert spectrogram with log amplitude")
## End(Not run)

#Log frequency plot
dfreq &lt;- 0.001
## Not run: hgram=HHRender(EEMD.result, dt, dfreq, scaling = "log")
## Not run: HHGramImage(hgram, time.span, freq.span = c(0, 2),          
pretty = TRUE, img.x.format = "%.1f", img.y.format = "%.2f",
img.y.lab = "log frequency",
main = "Port Foster event - ensemble Hilbert spectrogram with log frequency")
## End(Not run)

#Only show IMF 1
dfreq &lt;- 0.1
## Not run: hgram=HHRender(EEMD.result, dt, dfreq, combine.imfs = FALSE)
## Not run: HHGramImage(hgram, time.span, freq.span, imf.list = 1,
pretty = TRUE, img.x.format = "%.1f", img.y.format = "%.0f",
main = "Port Foster event - ensemble Hilbert spectrogram of IMF 1")
## End(Not run)
</code></pre>

<hr>
<h2 id='HHRender'>Render Hilbert spectrogram</h2><span id='topic+HHRender'></span>

<h3>Description</h3>

<p>This function prepares results from the Hilbert transform of EMD or EEMD results for display using <code><a href="#topic+HHGramImage">HHGramImage</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HHRender(hres, dt, dfreq, time.span = NULL, freq.span = NULL, scaling = "none", 
    combine.imfs = TRUE, verbose = TRUE)  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HHRender_+3A_hres">hres</code></td>
<td>
<p>This is the output generated by <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>, <code><a href="#topic+EEMDCompile">EEMDCompile</a></code>, <code><a href="#topic+EEMDResift">EEMDResift</a></code></p>
</td></tr></table>
<p>, or <code><a href="#topic+CEEMD">CEEMD</a></code>.
</p>
<table role = "presentation">
<tr><td><code id="HHRender_+3A_dt">dt</code></td>
<td>
<p>Time resolution of spectrogram.  Must be greater than the sample rate of the time series to avoid gaps.</p>
</td></tr>
<tr><td><code id="HHRender_+3A_dfreq">dfreq</code></td>
<td>
<p>Frequency resolution of spectrogram.</p>
</td></tr>
<tr><td><code id="HHRender_+3A_time.span">time.span</code></td>
<td>
<p>Time span to render spectrogram over; <code>NULL</code> means over the whole time series.</p>
</td></tr>
<tr><td><code id="HHRender_+3A_freq.span">freq.span</code></td>
<td>
<p>Frequency span to include in spectrogram; <code>NULL</code> means render all the frequencies in the time series</p>
</td></tr>
<tr><td><code id="HHRender_+3A_scaling">scaling</code></td>
<td>
<p>If <code>"log"</code>, render a log frequency spectrogram.  Defaults to <code>"none"</code> (linear).</p>
</td></tr>
<tr><td><code id="HHRender_+3A_combine.imfs">combine.imfs</code></td>
<td>
<p>If <code>TRUE</code>, add the spectra for all IMFS together in one ensemble Hilbert spectrogram, if <code>FALSE</code>, keep separate so you can investigate individual IMFs in <code><a href="#topic+HHGramImage">HHGramImage</a></code>.</p>
</td></tr>
<tr><td><code id="HHRender_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print progress messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>HHRender</code> processes Hilbert spectral data prior to displaying with <code><a href="#topic+HHGramImage">HHGramImage</a></code>.
<code>HHRender</code> returns the ensemble Hilbert spectrogram if <code>combine.imfs = TRUE</code>, otherwise it returns an IMF-by-IMF Hilbert spectrogram of dimensions <code>[time, freq, imf]</code>.
The user can then choose which IMFs to plot when he or she calls <code><a href="#topic+HHGramImage">HHGramImage</a></code>, but this makes <code><a href="#topic+HHGramImage">HHGramImage</a></code> run about 40x slower on my machine.
The trade off is in speed versus flexibility for <code><a href="#topic+HHGramImage">HHGramImage</a></code>; the <code>combine.imfs</code> option does not affect <code>HHRender</code> very much.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>hgram</code></td>
<td>
<p>A data structure containing the spectrogram image and other information required by <code><a href="#topic+HHGramImage">HHGramImage</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>HHRender</code> function also keeps track of which trial contributes what data to the spectrogram.
For the EMD, this does not make much sense, because there is only one trial.
However, when <code>HHRender</code> is run on EEMD results, it remembers which time/frequency bin gets data from each trial.
This is a way to distinguish between noise and signal in data:  signal is where multiple trials contribute data to the same time/frequency bin,
noise is where only one (or a couple) of trials contribute data.
See options for <code><a href="#topic+HHGramImage">HHGramImage</a></code> for ways to plot data based on signal stability.</p>


<h3>Author(s)</h3>

<p>Daniel Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+EEMDCompile">EEMDCompile</a></code>, <code><a href="#topic+HHGramImage">HHGramImage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PortFosterEvent)

trials &lt;- 10
nimf &lt;- 10
noise.amp &lt;- 6.4e-07
trials.dir &lt;- "test"

set.seed(628)
#Run EEMD (this may take some time)
## Not run: EEMD(sig, tt, noise.amp, trials, nimf, noise.amp, trials.dir &lt;- trials.dir)

#Compile the results
## Not run: EEMD.result &lt;- EEMDCompile(trials.dir, trials, nimf)

#Calculate spectrogram
dt &lt;- 0.1
dfreq &lt;- 0.1

## Not run: hgram &lt;- HHRender(EEMD.result, dt, dfreq)

#Plot spectrogram 
time.span &lt;- c(5, 10)
freq.span &lt;- c(0, 25)
amp.span &lt;- c(1e-6, 2.5e-5)
## Not run: HHGramImage(hgram, time.span = time.span, 
    freq.span = freq.span, amp.span = amp.span)
## End(Not run)
</code></pre>

<hr>
<h2 id='HHSpecPlot'>Display Hilbert periodogram</h2><span id='topic+HHSpecPlot'></span>

<h3>Description</h3>

<p>This function displays the Hilbert periodogram, with options to plot individual IMFs and also the Fourier periodogram for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HHSpecPlot(hspec, freq.span = NULL, scaling = "none", imf.list = NULL, 
    show.total = TRUE, show.fourier = FALSE, scale.fourier = FALSE, 
    show.imfs = FALSE, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HHSpecPlot_+3A_hspec">hspec</code></td>
<td>
<p>Data structure returned by <code><a href="#topic+HHSpectrum">HHSpectrum</a></code></p>
</td></tr>
<tr><td><code id="HHSpecPlot_+3A_freq.span">freq.span</code></td>
<td>
<p>Frequency range to plot, <code>NULL</code> plots all of them</p>
</td></tr>
<tr><td><code id="HHSpecPlot_+3A_scaling">scaling</code></td>
<td>
<p>Amplitude scaling, can be <code>"log"</code> (log 10), <code>"sqrt"</code> (square root), defaults to <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="HHSpecPlot_+3A_imf.list">imf.list</code></td>
<td>
<p>Which IMFs to plot, requires <code>show.imfs = TRUE</code>.</p>
</td></tr>
<tr><td><code id="HHSpecPlot_+3A_show.total">show.total</code></td>
<td>
<p>Show the ensemble Hilbert spectrogram</p>
</td></tr>
<tr><td><code id="HHSpecPlot_+3A_show.fourier">show.fourier</code></td>
<td>
<p>Show the Fourier periodogram</p>
</td></tr>
<tr><td><code id="HHSpecPlot_+3A_scale.fourier">scale.fourier</code></td>
<td>
<p>Scale Fourier and Hilbert spectra to each other for easier comparison</p>
</td></tr>
<tr><td><code id="HHSpecPlot_+3A_show.imfs">show.imfs</code></td>
<td>
<p>Plot individual IMF spectra</p>
</td></tr>
<tr><td><code id="HHSpecPlot_+3A_legend">legend</code></td>
<td>
<p>Determines whether or not a legend is shown</p>
</td></tr>
<tr><td><code id="HHSpecPlot_+3A_...">...</code></td>
<td>
<p>This function supports some optional parameters as well:
</p>

<ul>
<li><p>xlab - X axis label
</p>
</li>
<li><p>ylab - Y axis label
</p>
</li>
<li><p>legend.location - where to put the legend
</p>
</li>
<li><p>total.col - color of ensemble Hilbert periodogram
</p>
</li>
<li><p>total.lwd - lwd of ensemble Hilbert periodogram
</p>
</li>
<li><p>total.lty - lty of ensemble Hilbert periodogram
</p>
</li>
<li><p>imf.cols - colors of IMF periodogram
</p>
</li>
<li><p>imf.lwd - lwds of IMF periodogram
</p>
</li>
<li><p>imf.lty - ltys of IMF periodogram
</p>
</li>
<li><p>fourier.col - color of Fourier periodogram
</p>
</li>
<li><p>fourier.lwd - lwd of Fourier periodogram
</p>
</li>
<li><p>fourier.lty - lty of Fourier periodogram
</p>
</li>
<li><p>main - figure title</p>
</li></ul>

</td></tr></table>


<h3>Details</h3>

<p>This function plots the Hilbert periodogram of a signal, with options to show periodograms of individual IMFs.
You can also plot a simple Fourier periodogram for comparison.
</p>


<h3>Author(s)</h3>

<p>Daniel Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+HHSpectrum">HHSpectrum</a></code>, <code><a href="#topic+HHGramImage">HHGramImage</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Here we see how the EMD produces a dyadic filter bank for uniform random noise
#The frequency distributions of all but the first IMF display a Chi-Square distribution
#See Huang, N. E. &amp; Wu, Z. 
#A review on Hilbert-Huang Transform: Method and its applications to geophysical studies.
#Reviews of Geophysics, 2008, 46, RG2006

#The EMD of this signal may take a couple of minutes to run

set.seed(628)
sig  &lt;-  runif(10000)
tt  &lt;-  seq_len(length(sig)) * 0.01

## Not run: emd.result  &lt;-  Sig2IMF(sig, tt)

dfreq  &lt;-  0.1
## Not run: hspec  &lt;-  HHSpectrum(emd.result, dfreq)

## Not run: HHSpecPlot(hspec, show.imfs = TRUE, 
imf.list = 1:10, show.total = TRUE, scaling = "sqrt", 
imf.lwd = rep(2, 10), total.lty = 3)
## End(Not run)
</code></pre>

<hr>
<h2 id='HHSpectrum'>Generate Hilbert spectrum</h2><span id='topic+HHSpectrum'></span>

<h3>Description</h3>

<p>Generates a Hilbert periodogram from the results of <code><a href="#topic+Sig2IMF">Sig2IMF</a></code> and <code><a href="#topic+EEMD">EEMD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HHSpectrum(hres, dfreq, freq.span = NULL, time.span = NULL, 
    scaling = "none", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HHSpectrum_+3A_hres">hres</code></td>
<td>
<p>This is the output generated by <code><a href="#topic+EEMDCompile">EEMDCompile</a></code> or <code><a href="#topic+EEMDResift">EEMDResift</a></code></p>
</td></tr>
<tr><td><code id="HHSpectrum_+3A_dfreq">dfreq</code></td>
<td>
<p>Frequency resolution of spectrum</p>
</td></tr>
<tr><td><code id="HHSpectrum_+3A_time.span">time.span</code></td>
<td>
<p>Time span to render spectrum over; <code>NULL</code> means over the whole time series</p>
</td></tr>
<tr><td><code id="HHSpectrum_+3A_freq.span">freq.span</code></td>
<td>
<p>Frequency span to include in spectrum; <code>NULL</code> means render all the frequencies in the time series</p>
</td></tr>
<tr><td><code id="HHSpectrum_+3A_scaling">scaling</code></td>
<td>
<p>If <code>"log"</code>, render a log10 frequency spectrum.  Defaults to <code>"none"</code> (linear).</p>
</td></tr>
<tr><td><code id="HHSpectrum_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print progress messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>HHSpectrum</code> sums Hilbert spectral data over the time domain to produce the equivalent of a periodogram.  
The result can be plotted using <code><a href="#topic+HHSpecPlot">HHSpecPlot</a></code>.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>hspec</code></td>
<td>
<p>A data structure containing the spectrum of each IMF.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+HHRender">HHRender</a></code>, <code><a href="#topic+HHSpecPlot">HHSpecPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(PortFosterEvent)

emd.result &lt;- Sig2IMF(sig, tt)

dfreq &lt;- 0.1
hspec &lt;- HHSpectrum(emd.result, dfreq)
HHSpecPlot(hspec, show.fourier = TRUE, scale.fourier = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='HHTPackagePlotter'>
Set up spectrogram figure
</h2><span id='topic+HHTPackagePlotter'></span>

<h3>Description</h3>

<p>Sets up the figure window for <code><a href="#topic+HHGramImage">HHGramImage</a></code> and <code><a href="#topic+FTGramImage">FTGramImage</a></code>.
This is an internal function and will likely never be called by a user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HHTPackagePlotter(img, trace, amp.span, img.x.lab, img.y.lab, 
fit.line = NULL, window = NULL, colormap = NULL, backcol = c(0, 0, 0), 
pretty = FALSE, grid = TRUE, colorbar = TRUE, opts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HHTPackagePlotter_+3A_img">img</code></td>
<td>

<p>Fourier or Hilbert spectrogram image.
</p>
</td></tr>
<tr><td><code id="HHTPackagePlotter_+3A_trace">trace</code></td>
<td>

<p>Time series corresponding to the spectrogram.
</p>
</td></tr>
<tr><td><code id="HHTPackagePlotter_+3A_amp.span">amp.span</code></td>
<td>

<p>Amplitudes over which to plot.
</p>
</td></tr>
<tr><td><code id="HHTPackagePlotter_+3A_img.x.lab">img.x.lab</code></td>
<td>

<p>Specifies the X axis label on the image part of the figure, defaults to &quot;time&quot;
</p>
</td></tr>
<tr><td><code id="HHTPackagePlotter_+3A_img.y.lab">img.y.lab</code></td>
<td>

<p>Specifies the Y axis label on the image part of the figure, defaults to &quot;frequency&quot;
</p>
</td></tr>
<tr><td><code id="HHTPackagePlotter_+3A_fit.line">fit.line</code></td>
<td>

<p>Plots a line corresponding to the IMF sum on the trace, if requested
</p>
</td></tr>
<tr><td><code id="HHTPackagePlotter_+3A_window">window</code></td>
<td>

<p>The Fourier window length, if applicable
</p>
</td></tr>
<tr><td><code id="HHTPackagePlotter_+3A_colormap">colormap</code></td>
<td>

<p>The image color map
</p>
</td></tr>
<tr><td><code id="HHTPackagePlotter_+3A_backcol">backcol</code></td>
<td>

<p>The background color of the image (what shows up for pixels with value <code>NA</code>)
</p>
</td></tr>
<tr><td><code id="HHTPackagePlotter_+3A_pretty">pretty</code></td>
<td>

<p>Adjusts image axes to have nice values, see the <code>pretty</code> function in the <code>base</code> package included in R
</p>
</td></tr>
<tr><td><code id="HHTPackagePlotter_+3A_grid">grid</code></td>
<td>

<p>Determines whether to plot grid lines on the spectrogram
</p>
</td></tr>
<tr><td><code id="HHTPackagePlotter_+3A_colorbar">colorbar</code></td>
<td>

<p>Whether to plot a color bar for amplitude values
</p>
</td></tr>
<tr><td><code id="HHTPackagePlotter_+3A_opts">opts</code></td>
<td>

<p>Other possible options passed from <code><a href="#topic+HHGramImage">HHGramImage</a></code> and <code><a href="#topic+FTGramImage">FTGramImage</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>INTERNAL
</p>


<h3>Author(s)</h3>

<p>Daniel Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a>
</p>

<hr>
<h2 id='HilbertEnvelope'>
Instantaneous amplitude
</h2><span id='topic+HilbertEnvelope'></span>

<h3>Description</h3>

<p>Generates the instantaneous amplitude of an analytic signal given by <code><a href="#topic+HilbertTransform">HilbertTransform</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HilbertEnvelope(asig)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HilbertEnvelope_+3A_asig">asig</code></td>
<td>

<p>The analytic signal returned by <code><a href="#topic+HilbertTransform">HilbertTransform</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>envelope</code></td>
<td>
<p>Instantaneous amplitude</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel C. Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HilbertTransform">HilbertTransform</a></code>, <code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- seq(1000) * 0.01
sig &lt;- sin(4 * pi * tt) + sin(3.4 * pi * tt)
asig &lt;- HilbertTransform(sig)
env &lt;- HilbertEnvelope(asig)
plot(tt, sig, type = "l")
lines(tt, env, col = "red")
lines(tt, -env, col = "red")

</code></pre>

<hr>
<h2 id='HilbertTransform'>
The Hilbert transform
</h2><span id='topic+HilbertTransform'></span>

<h3>Description</h3>

<p>Creates the analytic signal using the Hilbert transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HilbertTransform(sig)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HilbertTransform_+3A_sig">sig</code></td>
<td>

<p>Signal to transform.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates the real and imaginary parts of a signal.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>asig</code></td>
<td>
<p>Analytic signal</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel C. Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HilbertEnvelope">HilbertEnvelope</a></code>, <code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- seq(1000) * 0.01
sig &lt;- sin(pi * tt)
asig &lt;- HilbertTransform(sig)
plot(tt, sig, xlim = c(0, 12))
lines(tt, Re(asig), col = "green")
lines(tt, Im(asig), col = "red")
legend("topright", col = c("black", "green", "red"), 
lty = c(NA, 1, 1), pch = c(1, NA, NA), 
legend = c("Signal", "Real", "Imaginary"))

</code></pre>

<hr>
<h2 id='InstantaneousFrequency'>
Derive instantaneous frequency
</h2><span id='topic+InstantaneousFrequency'></span>

<h3>Description</h3>

<p>Calculates instantaneous frequency from an analytic signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InstantaneousFrequency(asig, tt, method = "arctan", lag = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InstantaneousFrequency_+3A_asig">asig</code></td>
<td>

<p>Analytic signal produced by <code><a href="#topic+HilbertTransform">HilbertTransform</a></code>
</p>
</td></tr>
<tr><td><code id="InstantaneousFrequency_+3A_tt">tt</code></td>
<td>

<p>Sample times
</p>
</td></tr>
<tr><td><code id="InstantaneousFrequency_+3A_method">method</code></td>
<td>

<p>How the instantaneous frequency is calculated. 
<code>"arctan"</code> uses the arctangent of the real and imaginary parts of the Hilbert transform, taking the numerical derivative of phase for frequency.
<code>"chain"</code> uses the analytical derivative of the arctangent function prior to performing the numerical calculation.
</p>
</td></tr>
<tr><td><code id="InstantaneousFrequency_+3A_lag">lag</code></td>
<td>

<p>Differentiation lag, see the <code>diff</code> function in the <code>base</code> package.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>instfreq</code></td>
<td>
<p>Instataneous frequency in 1/time</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>"arctan"</code> method was adapted from the <code>hilbertspec</code> function in the <code>EMD</code> package.
</p>
<p>!!IMPORTANT!!
The numeric differentiation may be unstable for certain signals.
For example, high frequency sinusoids near the Nyquist frequency can give inaccurate results when using the <code>"chain"</code> method.
When in doubt, use the <code><a href="#topic+PrecisionTester">PrecisionTester</a></code> function to check your results!
</p>


<h3>Author(s)</h3>

<p>Daniel C. Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PrecisionTester">PrecisionTester</a></code>
</p>

<hr>
<h2 id='PlotIMFs'>Display IMFs</h2><span id='topic+PlotIMFs'></span>

<h3>Description</h3>

<p>This function displays IMFs generated using <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>, <code><a href="#topic+EEMDCompile">EEMDCompile</a>.</code> or <code><a href="#topic+EEMDResift">EEMDResift</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotIMFs(sig, time.span = NULL, imf.list = NULL, original.signal = TRUE, 
    residue = TRUE, fit.line = FALSE, lwd = 1, cex = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotIMFs_+3A_sig">sig</code></td>
<td>
<p>Data structure returned by <code><a href="#topic+Sig2IMF">Sig2IMF</a></code>, <code><a href="#topic+EEMDCompile">EEMDCompile</a></code>, or <code><a href="#topic+EEMDResift">EEMDResift</a></code>.</p>
</td></tr>
<tr><td><code id="PlotIMFs_+3A_time.span">time.span</code></td>
<td>
<p>Time span over which to plot IMFs.  <code>NULL</code> will draw the entire signal.</p>
</td></tr>
<tr><td><code id="PlotIMFs_+3A_imf.list">imf.list</code></td>
<td>
<p>Which IMFs to plot, <code>NULL</code> plots all of them.</p>
</td></tr>
<tr><td><code id="PlotIMFs_+3A_original.signal">original.signal</code></td>
<td>
<p>whether or not to plot the original signal.</p>
</td></tr>
<tr><td><code id="PlotIMFs_+3A_residue">residue</code></td>
<td>
<p>whether to plot the residue of the EMD method.</p>
</td></tr>
<tr><td><code id="PlotIMFs_+3A_fit.line">fit.line</code></td>
<td>
<p>whether to add a red line to the original signal trace showing how much of the original signal is contained in the selected IMFs and/or residual.</p>
</td></tr>
<tr><td><code id="PlotIMFs_+3A_lwd">lwd</code></td>
<td>
<p>Line weight.</p>
</td></tr>
<tr><td><code id="PlotIMFs_+3A_cex">cex</code></td>
<td>
<p>Text size.</p>
</td></tr>
<tr><td><code id="PlotIMFs_+3A_...">...</code></td>
<td>
<p>Pass additional graphics parameters to IMF plotter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the IMF decomposition of a signal.
It can show the original signal and also the residue left over when the IMFs are removed from the signal.
The plotter can use data from both EMD and EEMD runs.
When it plots EEMD data, it shows the averaged IMFs from the trials processed by <code><a href="#topic+EEMDCompile">EEMDCompile</a></code>.
</p>


<h3>Note</h3>

<p>It is very important to inspect the IMF set prior to rendering Hilbert spectrograms.
Oftentimes, problems with the EMD are obvious when the IMFs are plotted.
The <code>fit.line</code> option can help with this.
</p>


<h3>Author(s)</h3>

<p>Daniel Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+HHGramImage">HHGramImage</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PortFosterEvent)

#Run EMD
emd.result &lt;- Sig2IMF(sig, tt, sm = "polynomial")

#Plot the first 4 IMFs of the EEMD of a signal.
time.span &lt;- c(5, 10)
imf.list &lt;- 1:4
original.signal &lt;- TRUE
residue &lt;- TRUE

PlotIMFs(emd.result, time.span, imf.list, original.signal, residue)

#Check how much contribution IMFs 2 and 3 make to the complete signal
imf.list &lt;- c(2, 3)
fit.line &lt;- TRUE
PlotIMFs(emd.result, time.span, imf.list, original.signal, residue, fit.line)
</code></pre>

<hr>
<h2 id='PrecisionTester'>
Test numerically determined instantaneous frequency against exact instantaneous frequency
</h2><span id='topic+PrecisionTester'></span>

<h3>Description</h3>

<p>This function compares the performance of <code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code> against signals of known instantaneous frequency.
The known signal is of the form
</p>
<p style="text-align: center;"><code class="reqn"> x(t) = a\sin(\omega_{1} + \varphi_{1}) + b\sin(\omega_{2} + \varphi_{2}) + c</code>
</p>

<p>One can create quite complicated signals by choosing the various amplitude, frequency, and phase constants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrecisionTester(tt = seq(0, 10, by = 0.01), method = "arctan", lag = 1, 
    a = 1, b = 1, c = 1, omega.1 = 2 * pi, omega.2 = 4 * pi, 
    phi.1 = 0, phi.2 = pi/6, plot.signal = TRUE, 
    plot.instfreq = TRUE, plot.error = TRUE, new.device = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PrecisionTester_+3A_tt">tt</code></td>
<td>

<p>Sample times.
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_method">method</code></td>
<td>

<p>How the numeric instantaneous frequency is calculated, see <code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code>
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_lag">lag</code></td>
<td>

<p>Differentiation lag, see the <code>diff</code> function in the <code>base</code> package.
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_a">a</code></td>
<td>

<p>Amplitude coefficient for the first sinusoid.
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_b">b</code></td>
<td>

<p>Amplitude coefficient for the second sinusoid.
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_c">c</code></td>
<td>

<p>DC shift
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_omega.1">omega.1</code></td>
<td>

<p>Frequency of the first sinusoid.
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_omega.2">omega.2</code></td>
<td>

<p>Frequency of the second sinusoid.
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_phi.1">phi.1</code></td>
<td>

<p>Phase shift of the first sinusoid.
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_phi.2">phi.2</code></td>
<td>

<p>Phase shift of the second sinusoid.
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_plot.signal">plot.signal</code></td>
<td>

<p>Whether to show the time series.
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_plot.instfreq">plot.instfreq</code></td>
<td>

<p>Whether to show the instantaneous frequencies, comparing the numerical and analytical result.
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_plot.error">plot.error</code></td>
<td>

<p>Whether to show the difference between the numerical and analytical result.
</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_new.device">new.device</code></td>
<td>

<p>Whether to open each plot as a new plot window (defaults to <code>TRUE</code>).  However, Sweave doesn't like <code>dev.new()</code>.
If you want to use <code>PrecisionTester</code> in Sweave, be sure that <code>new.device = FALSE</code></p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_...">...</code></td>
<td>

<p>Plotting parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>instfreq$sig</code></td>
<td>
<p>The time series</p>
</td></tr>
<tr><td><code>instfreq$analytic</code></td>
<td>
<p>The exact instantaneous frequency</p>
</td></tr>
<tr><td><code>instfreq$numeric</code></td>
<td>
<p>The numerically-derived instantaneous frequency from <code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel C. Bowman <a href="mailto:danny.c.bowman@gmail.com">danny.c.bowman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simple signal
tt &lt;- seq(0, 10, by = 0.01)
a &lt;- 1
b &lt;- 0
c &lt;- 0
omega.1 &lt;- 30 * pi
omega.2 &lt;- 0
phi.1 &lt;- 0
phi.2 &lt;- 0
PrecisionTester(tt, method = "arctan", lag = 1, a, b, c, 
    omega.1, omega.2, phi.1, phi.2)

#That was nice - what happens if we use the "chain" method...?

PrecisionTester(tt, method = "chain", lag = 1, a, b, c, 
    omega.1, omega.2, phi.1, phi.2)

#Big problems!  Let's increase the sample rate

tt &lt;- seq(0, 10, by = 0.0005)
PrecisionTester(tt, method = "chain", lag = 1, a, b, c, 
omega.1, omega.2, phi.1, phi.2)

#That's better

#Frequency modulations caused by signal that is not symmetric about 0

tt &lt;- seq(0, 10, by = 0.01)
a &lt;- 1
b &lt;- 0
c &lt;- 0.25
omega.1 &lt;- 2 * pi
omega.2 &lt;- 0
phi.1 &lt;- 0
phi.2 &lt;- 0

PrecisionTester(tt, method = "arctan", lag = 1, a, b, c, 
omega.1, omega.2, phi.1, phi.2)

#Non-uniform sample rate
set.seed(628)
tt &lt;- sort(runif(500, 0, 10))
a &lt;- 1
b &lt;- 0
c &lt;- 0
omega.1 &lt;- 2 * pi
omega.2 &lt;- 0
phi.1 &lt;- 0
phi.2 &lt;- 0

PrecisionTester(tt, method = "arctan", lag = 1, a, b, c, 
omega.1, omega.2, phi.1, phi.2)
</code></pre>

<hr>
<h2 id='sig'>Transitory Seismic Event at Deception Island Volcano</h2><span id='topic+sig'></span>

<h3>Description</h3>

<p>This is 20 seconds of data from the 2005 TOMODEC ocean bottom seismometer network at Deception Island, South Shetland Islands, Antarctica with sample rate <code><a href="#topic+tt">tt</a></code>.
It shows one of several thousand transitory seismic events occurring in Port Foster (the flooded caldera of the volcano).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PortFosterEvent)</code></pre>


<h3>Format</h3>

<p>A 2500 element vector containing the seismic record.  Units are meters per second.
</p>


<h3>Source</h3>

<p>Ocean bottom seismometer records from the 2005 TOMODEC active source tomography experiment, Deception Island, Antarctica.</p>

<hr>
<h2 id='Sig2IMF'>Empirical Mode Decomposition wrapper</h2><span id='topic+Sig2IMF'></span>

<h3>Description</h3>

<p>This function wraps the <code>emd</code> function in the <code>EMD</code> package.
<code>Sig2IMF</code> is used in <code><a href="#topic+EEMD">EEMD</a></code> and others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sig2IMF(sig, tt, spectral.method = "arctan", diff.lag = 1, stop.rule = "type5", 
    tol = 5, boundary = "wave", sm = "none", smlevels = c(1), spar = NULL, 
    max.sift = 200, max.imf = 100, interm = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sig2IMF_+3A_sig">sig</code></td>
<td>
<p>a time series to be decomposed (vector)</p>
</td></tr>
<tr><td><code id="Sig2IMF_+3A_tt">tt</code></td>
<td>
<p>A vector of sample times for <code>sig</code></p>
</td></tr>
<tr><td><code id="Sig2IMF_+3A_spectral.method">spectral.method</code></td>
<td>
<p>defines how to calculate instantaneous frequency - whether to use the arctangent of the analytic signal with numeric differentiation (&ldquo;arctan&rdquo;)
or the result of the chain rule applied to the arctangent, then numerically differentiated (&quot;chain&quot;);  see <code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code>.</p>
</td></tr>
<tr><td><code id="Sig2IMF_+3A_diff.lag">diff.lag</code></td>
<td>
<p>specifies if you want to do naive differentiation (<code>diff.lag</code> = 1), central difference method (<code>diff.lag = 2</code> or higher difference methods (<code>diff.lag</code> &gt; 2) 
to determine instantaneous frequency; see <code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code>.</p>
</td></tr>
<tr><td><code id="Sig2IMF_+3A_stop.rule">stop.rule</code></td>
<td>
<p>As quoted from the EMD package documentation:  &rdquo;The stop rule of sifting. 
The type1 stop rule indicates that absolute values 
of envelope mean must be less than the user-specified tolerance level in the sense
that the local average of upper and lower envelope is zero. The stopping rules
type2, type3, type4 and type5 are the stopping rules given by equation (5.5)
of Huang et al. (1998), equation (11a), equation (11b) and S stoppage of Huang
and Wu (2008), respectively.&rdquo;</p>
</td></tr>
<tr><td><code id="Sig2IMF_+3A_tol">tol</code></td>
<td>
<p>Determines what value is used to stop the sifting - this will depend on which stop rule you use.</p>
</td></tr>
<tr><td><code id="Sig2IMF_+3A_boundary">boundary</code></td>
<td>
<p>how the beginning and end of the signal are handled</p>
</td></tr>
<tr><td><code id="Sig2IMF_+3A_sm">sm</code></td>
<td>
<p>Specifies how the signal envelope is constructed, see Kim et al, 2012.</p>
</td></tr>
<tr><td><code id="Sig2IMF_+3A_smlevels">smlevels</code></td>
<td>
<p>Specifies what level of the IMF is obtained by smoothing other than interpolation, see EMD package documentation</p>
</td></tr>
<tr><td><code id="Sig2IMF_+3A_spar">spar</code></td>
<td>
<p>User-defined smoothing parameter for spline, kernel, or local polynomial smoothing.</p>
</td></tr>
<tr><td><code id="Sig2IMF_+3A_max.sift">max.sift</code></td>
<td>
<p>How many sifts are allowed - if this value is exceeded the IMF is returned as-is.</p>
</td></tr>
<tr><td><code id="Sig2IMF_+3A_max.imf">max.imf</code></td>
<td>
<p>Maximum number of IMFs allowed.</p>
</td></tr>
<tr><td><code id="Sig2IMF_+3A_interm">interm</code></td>
<td>
<p>Specifies vector of periods to be excluded from IMFs to cope with mode mixing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function configures and performs empirical mode decomposition using the <code>emd</code> function in the <code>EMD</code> package.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>emd.result</code></td>
<td>
<p>The intrinsic mode functions (IMFs), instantaneous frequencies, and instantaneous amplitudes of <code>sig</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kim, D., Kim, K. and Oh, H.-S. (2012) Extending the scope of empirical mode decomposition by smoothing.
<em>EURASIP Journal on Advances in Signal Processing</em>, <b>2012</b>, 168.
</p>
<p>Huang, N. E., Shen, Z., Long, S. R., Wu, M. L. Shih, H. H.,
Zheng, Q., Yen, N. C., Tung, C. C. and Liu, H. H. (1998) The empirical
mode decomposition and Hilbert spectrum for nonlinear and
nonstationary time series analysis. <em>Proceedings of the Royal
Society London A</em>, <b>454</b>, 903&ndash;995.
</p>
<p>Huang, N. E. and Wu Z. A. (2008) A review on Hilbert-Huang Transform: Method and its applications to geophysical studies.
<em>Reviews of Geophysics</em>, <b>46</b>, RG2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EEMD">EEMD</a></code>, <code><a href="#topic+PlotIMFs">PlotIMFs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PortFosterEvent)

#Run EMD
emd.result=Sig2IMF(sig, tt)

#Display IMFs

time.span &lt;- c(5, 10)
imf.list &lt;- 1:3
original.signal &lt;- TRUE
residue &lt;- TRUE

PlotIMFs(emd.result, time.span, imf.list, original.signal, residue)

#Plot spectrogram
sdt &lt;- tt[2] - tt[1]
dfreq &lt;- 0.25
freq.span &lt;- c(0, 25)
hgram &lt;- HHRender(emd.result, sdt, dfreq, freq.span = freq.span, verbose = FALSE)

time.span &lt;- c(4, 10)
freq.span &lt;- c(0, 25)
amp.span &lt;- c(0.000001, 0.00001)
HHGramImage(hgram, time.span = time.span, 
freq.span = freq.span, amp.span = amp.span,
pretty = TRUE)
</code></pre>

<hr>
<h2 id='tt'>Ocean Bottom Seismometer Sample Rate</h2><span id='topic+tt'></span>

<h3>Description</h3>

<p>This is the sample times for the instrument that recorded <code><a href="#topic+sig">sig</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PortFosterEvent)</code></pre>


<h3>Format</h3>

<p>A vector describing the sample times. The sample rate was constant at 125 samples per second.
</p>


<h3>Source</h3>

<p>Ocean bottom seismometer records from the 2005 TOMODEC active source tomography experiment, Deception Island, Antarctica.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
