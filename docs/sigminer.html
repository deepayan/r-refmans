<!DOCTYPE html><html><head><title>Help for package sigminer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sigminer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sigminer-package'><p>sigminer: Extract, Analyze and Visualize Signatures for Genomic Variations</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_h_arrow'><p>Add Horizontal Arrow with Text Label to a ggplot</p></a></li>
<li><a href='#add_labels'><p>Add Text Labels to a ggplot</p></a></li>
<li><a href='#bp'><p>A Best Practice for Signature Extraction and Exposure (Activity) Attribution</p></a></li>
<li><a href='#centromeres.hg19'><p>Location of Centromeres at Genome Build hg19</p></a></li>
<li><a href='#centromeres.hg38'><p>Location of Centromeres at Genome Build hg38</p></a></li>
<li><a href='#centromeres.mm10'><p>Location of Centromeres at Genome Build mm10</p></a></li>
<li><a href='#centromeres.mm9'><p>Location of Centromeres at Genome Build mm9</p></a></li>
<li><a href='#centromeres.T2T'><p>Location of Centromeres at Genome Build T2T</p></a></li>
<li><a href='#chromsize.hg19'><p>Chromosome Size of Genome Build hg19</p></a></li>
<li><a href='#chromsize.hg38'><p>Chromosome Size of Genome Build hg38</p></a></li>
<li><a href='#chromsize.mm10'><p>Chromosome Size of Genome Build mm10</p></a></li>
<li><a href='#chromsize.mm9'><p>Chromosome Size of Genome Build mm9</p></a></li>
<li><a href='#chromsize.T2T'><p>Chromosome Size of Genome Build T2T</p></a></li>
<li><a href='#CN.features'><p>Classification Table of Copy Number Features Devised by Wang et al. for Method 'W'</p></a></li>
<li><a href='#CopyNumber-class'><p>Class CopyNumber</p></a></li>
<li><a href='#cosine'><p>Calculate Cosine Measures</p></a></li>
<li><a href='#cytobands.hg19'><p>Location of Chromosome Cytobands at Genome Build hg19</p></a></li>
<li><a href='#cytobands.hg38'><p>Location of Chromosome Cytobands at Genome Build hg38</p></a></li>
<li><a href='#cytobands.mm10'><p>Location of Chromosome Cytobands at Genome Build mm10</p></a></li>
<li><a href='#cytobands.mm9'><p>Location of Chromosome Cytobands at Genome Build mm9</p></a></li>
<li><a href='#cytobands.T2T'><p>Location of Chromosome Cytobands at Genome Build T2T</p></a></li>
<li><a href='#enrich_component_strand_bias'><p>Performs Strand Bias Enrichment Analysis for a Given Sample-by-Component Matrix</p></a></li>
<li><a href='#get_adj_p'><p>Get Adjust P Values from Group Comparison</p></a></li>
<li><a href='#get_Aneuploidy_score'><p>Get Aneuploidy Score from Copy Number Profile</p></a></li>
<li><a href='#get_bayesian_result'><p>Get Specified Bayesian NMF Result from Run</p></a></li>
<li><a href='#get_cn_freq_table'><p>Get CNV Frequency Table</p></a></li>
<li><a href='#get_cn_ploidy'><p>Get Ploidy from Absolute Copy Number Profile</p></a></li>
<li><a href='#get_genome_annotation'><p>Get Genome Annotation</p></a></li>
<li><a href='#get_group_comparison'><p>Get Comparison Result between Signature Groups</p></a></li>
<li><a href='#get_groups'><p>Get Sample Groups from Signature Decomposition Information</p></a></li>
<li><a href='#get_intersect_size'><p>Get Overlap Size between Interval x and y</p></a></li>
<li><a href='#get_pLOH_score'><p>Get proportions of pLOH score from Allele Specific Copy Number Profile</p></a></li>
<li><a href='#get_shannon_diversity_index'><p>Get Shannon Diversity Index for Signatures</p></a></li>
<li><a href='#get_sig_cancer_type_index'><p>Obtain Signature Index for Cancer Types</p></a></li>
<li><a href='#get_sig_db'><p>Get Curated Reference Signature Database</p></a></li>
<li><a href='#get_sig_exposure'><p>Get Signature Exposure from 'Signature' Object</p></a></li>
<li><a href='#get_sig_feature_association'><p>Calculate Association between Signature Exposures and Other Features</p></a></li>
<li><a href='#get_sig_rec_similarity'><p>Get Reconstructed Profile Cosine Similarity, RSS, etc.</p></a></li>
<li><a href='#get_sig_similarity'><p>Calculate Similarity between Identified Signatures and Reference Signatures</p></a></li>
<li><a href='#get_tidy_association'><p>Get Tidy Signature Association Results</p></a></li>
<li><a href='#group_enrichment'><p>General Group Enrichment Analysis</p></a></li>
<li><a href='#group_enrichment2'><p>Group Enrichment Analysis with Subsets</p></a></li>
<li><a href='#handle_hyper_mutation'><p>Handle Hypermutant Samples</p></a></li>
<li><a href='#hello'><p>Say Hello to Users</p></a></li>
<li><a href='#MAF-class'><p>Class MAF</p></a></li>
<li><a href='#output_bootstrap'><p>Output Signature Bootstrap Fitting Results</p></a></li>
<li><a href='#output_fit'><p>Output Signature Fitting Results</p></a></li>
<li><a href='#output_sig'><p>Output Signature Results</p></a></li>
<li><a href='#output_tally'><p>Output Tally Result in Barplots</p></a></li>
<li><a href='#read_copynumber'><p>Read Absolute Copy Number Profile</p></a></li>
<li><a href='#read_copynumber_ascat'><p>Read Copy Number Data from ASCAT Result Files</p></a></li>
<li><a href='#read_copynumber_seqz'><p>Read Absolute Copy Number Profile from Sequenza Result Directory</p></a></li>
<li><a href='#read_maf'><p>Read MAF Files</p></a></li>
<li><a href='#read_sv_as_rs'><p>Read Structural Variation Data as RS object</p></a></li>
<li><a href='#read_vcf'><p>Read VCF Files as MAF Object</p></a></li>
<li><a href='#read_xena_variants'><p>Read UCSC Xena Variant Format Data as MAF Object</p></a></li>
<li><a href='#report_bootstrap_p_value'><p>Report P Values from bootstrap Results</p></a></li>
<li><a href='#same_size_clustering'><p>Same Size Clustering</p></a></li>
<li><a href='#scoring'><p>Score Copy Number Profile</p></a></li>
<li><a href='#show_catalogue'><p>Show Alteration Catalogue Profile</p></a></li>
<li><a href='#show_cn_circos'><p>Show Copy Number Profile in Circos</p></a></li>
<li><a href='#show_cn_components'><p>Show Copy Number Components</p></a></li>
<li><a href='#show_cn_distribution'><p>Show Copy Number Distribution either by Length or Chromosome</p></a></li>
<li><a href='#show_cn_features'><p>Show Copy Number Feature Distributions</p></a></li>
<li><a href='#show_cn_freq_circos'><p>Show Copy Number Variation Frequency Profile with Circos</p></a></li>
<li><a href='#show_cn_group_profile'><p>Show Summary Copy Number Profile for Sample Groups</p></a></li>
<li><a href='#show_cn_profile'><p>Show Sample Copy Number Profile</p></a></li>
<li><a href='#show_cor'><p>A Simple and General Way for Association Analysis</p></a></li>
<li><a href='#show_cosmic'><p>Show Signature Information in Web Browser</p></a></li>
<li><a href='#show_cosmic_sig_profile'><p>Plot Reference (Mainly COSMIC) Signature Profile</p></a></li>
<li><a href='#show_group_comparison'><p>Plot Group Comparison Result</p></a></li>
<li><a href='#show_group_distribution'><p>Show Groupped Variable Distribution</p></a></li>
<li><a href='#show_group_enrichment'><p>Show Group Enrichment Result</p></a></li>
<li><a href='#show_group_mapping'><p>Map Groups using Sankey</p></a></li>
<li><a href='#show_groups'><p>Show Signature Contribution in Clusters</p></a></li>
<li><a href='#show_sig_bootstrap'><p>Show Signature Bootstrap Analysis Results</p></a></li>
<li><a href='#show_sig_consensusmap'><p>Show Signature Consensus Map</p></a></li>
<li><a href='#show_sig_exposure'><p>Plot Signature Exposure</p></a></li>
<li><a href='#show_sig_feature_corrplot'><p>Draw Corrplot for Signature Exposures and Other Features</p></a></li>
<li><a href='#show_sig_fit'><p>Show Signature Fit Result</p></a></li>
<li><a href='#show_sig_profile'><p>Show Signature Profile</p></a></li>
<li><a href='#show_sig_profile_heatmap'><p>Show Signature Profile with Heatmap</p></a></li>
<li><a href='#show_sig_profile_loop'><p>Show Signature Profile with Loop Way</p></a></li>
<li><a href='#sig_auto_extract'><p>Extract Signatures through the Automatic Relevance Determination Technique</p></a></li>
<li><a href='#sig_convert'><p>Convert Signatures between different Genomic Distribution of Components</p></a></li>
<li><a href='#sig_estimate'><p>Estimate Signature Number</p></a></li>
<li><a href='#sig_extract'><p>Extract Signatures through NMF</p></a></li>
<li><a href='#sig_fit'><p>Fit Signature Exposures with Linear Combination Decomposition</p></a></li>
<li><a href='#sig_fit_bootstrap'><p>Obtain Bootstrap Distribution of Signature Exposures of a Certain Tumor Sample</p></a></li>
<li><a href='#sig_fit_bootstrap_batch'><p>Exposure Instability Analysis of Signature Exposures with Bootstrapping</p></a></li>
<li><a href='#sig_operation'><p>Obtain or Modify Signature Information</p></a></li>
<li><a href='#sig_tally'><p>Tally a Genomic Alteration Object</p></a></li>
<li><a href='#sig_unify_extract'><p>An Unified Interface to Extract Signatures</p></a></li>
<li><a href='#sigprofiler'><p>Extract Signatures with SigProfiler</p></a></li>
<li><a href='#simulated_catalogs'><p>A List of Simulated SBS-96 Catalog Matrix</p></a></li>
<li><a href='#simulation'><p>Simulation Analysis</p></a></li>
<li><a href='#subset.CopyNumber'><p>Subsetting CopyNumber object</p></a></li>
<li><a href='#tidyeval'><p>Tidy eval helpers</p></a></li>
<li><a href='#transcript.hg19'><p>Merged Transcript Location at Genome Build hg19</p></a></li>
<li><a href='#transcript.hg38'><p>Merged Transcript Location at Genome Build hg38</p></a></li>
<li><a href='#transcript.mm10'><p>Merged Transcript Location at Genome Build mm10</p></a></li>
<li><a href='#transcript.mm9'><p>Merged Transcript Location at Genome Build mm9</p></a></li>
<li><a href='#transcript.T2T'><p>Merged Transcript Location at Genome Build T2T</p></a></li>
<li><a href='#transform_seg_table'><p>Transform Copy Number Table</p></a></li>
<li><a href='#use_color_style'><p>Set Color Style for Plotting</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Extract, Analyze and Visualize Mutational Signatures for Genomic
Variations</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Genomic alterations including single nucleotide substitution,
    copy number alteration, etc. are the major force for cancer
    initialization and development. Due to the specificity of molecular
    lesions caused by genomic alterations, we can generate characteristic
    alteration spectra, called 'signature' (Wang, Shixiang, et al. (2021)
    &lt;<a href="https://doi.org/10.1371%2Fjournal.pgen.1009557">doi:10.1371/journal.pgen.1009557</a>&gt; &amp; Alexandrov, Ludmil B., et al.
    (2020) &lt;<a href="https://doi.org/10.1038%2Fs41586-020-1943-3">doi:10.1038/s41586-020-1943-3</a>&gt; &amp; Steele Christopher D., et al.
    (2022) &lt;<a href="https://doi.org/10.1038%2Fs41586-022-04738-6">doi:10.1038/s41586-022-04738-6</a>&gt;).  This package helps users to
    extract, analyze and visualize signatures from genomic alteration
    records, thus providing new insight into cancer study.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ShixiangWang/sigminer">https://github.com/ShixiangWang/sigminer</a>,
<a href="https://shixiangwang.github.io/sigminer/">https://shixiangwang.github.io/sigminer/</a>,
<a href="https://shixiangwang.github.io/sigminer-book/">https://shixiangwang.github.io/sigminer-book/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ShixiangWang/sigminer/issues">https://github.com/ShixiangWang/sigminer/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 2.0.0), cowplot, data.table, dplyr, furrr (&ge; 0.2.0),
future, ggplot2 (&ge; 3.3.0), ggpubr, maftools, magrittr,
methods, NMF, purrr, Rcpp, rlang (&ge; 0.1.2), stats, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Biobase, Biostrings, BSgenome, BSgenome.Hsapiens.UCSC.hg19,
circlize, cluster, covr, digest, GenomicRanges, GenSA,
ggalluvial, ggcorrplot, ggfittext, ggplotify, ggrepel, IRanges,
knitr, lpSolve, markdown, matrixStats, nnls, parallel,
patchwork, pheatmap, quadprog, R.utils, RColorBrewer,
reticulate, rmarkdown, roxygen2, scales, synchronicity,
testthat (&ge; 3.0.0), tibble, UCSCXenaTools</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 11:18:30 UTC; Administrator</td>
</tr>
<tr>
<td>Author:</td>
<td>Shixiang Wang <a href="https://orcid.org/0000-0001-9855-7357"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ziyu Tao <a href="https://orcid.org/0000-0003-3272-1227"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Huimin Li <a href="https://orcid.org/0000-0003-1683-9057"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Tao Wu <a href="https://orcid.org/0000-0002-8999-9628"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Xue-Song Liu <a href="https://orcid.org/0000-0002-7736-0077"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Anand Mayakonda [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shixiang Wang &lt;w_shixiang@163.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 11:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='sigminer-package'>sigminer: Extract, Analyze and Visualize Signatures for Genomic Variations</h2><span id='topic+sigminer'></span><span id='topic+sigminer-package'></span>

<h3>Description</h3>


<ul>
<li><p> Author: <a href="https://shixiangwang.github.io/home/">Shixiang Wang</a> (<a href="mailto:w_shixiang@163.com">w_shixiang@163.com</a>)
</p>
</li>
<li><p> Please go to <a href="https://shixiangwang.github.io/sigminer-doc/">https://shixiangwang.github.io/sigminer-doc/</a> for full vignette.
</p>
</li>
<li><p> Please go to <a href="https://shixiangwang.github.io/sigminer/reference/index.html">https://shixiangwang.github.io/sigminer/reference/index.html</a>
for organized documentation of functions and datasets.
</p>
</li>
<li><p> Result visualization for <a href="#topic+MAF">MAF</a> is provide by <strong>maftools</strong> package,
please read its <a href="https://bioconductor.org/packages/release/bioc/vignettes/maftools/inst/doc/maftools.html">vignette</a>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Shixiang Wang <a href="mailto:w_shixiang@163.com">w_shixiang@163.com</a> (<a href="https://orcid.org/0000-0001-9855-7357">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Ziyu Tao <a href="mailto:taozy@shanghaitech.edu.cn">taozy@shanghaitech.edu.cn</a> (<a href="https://orcid.org/0000-0003-3272-1227">ORCID</a>)
</p>
</li>
<li><p> Huimin Li <a href="mailto:lihm@shanghaitech.edu.cn">lihm@shanghaitech.edu.cn</a> (<a href="https://orcid.org/0000-0003-1683-9057">ORCID</a>)
</p>
</li>
<li><p> Tao Wu <a href="mailto:wutao2@shanghaitech.edu.cn">wutao2@shanghaitech.edu.cn</a> (<a href="https://orcid.org/0000-0002-8999-9628">ORCID</a>)
</p>
</li>
<li><p> Xue-Song Liu (<a href="https://orcid.org/0000-0002-7736-0077">ORCID</a>) [contributor]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Anand Mayakonda [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ShixiangWang/sigminer">https://github.com/ShixiangWang/sigminer</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ShixiangWang/sigminer/issues">https://github.com/ShixiangWang/sigminer/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_h_arrow'>Add Horizontal Arrow with Text Label to a ggplot</h2><span id='topic+add_h_arrow'></span>

<h3>Description</h3>

<p>Add Horizontal Arrow with Text Label to a ggplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_h_arrow(
  p,
  x,
  y,
  label = "optimal number",
  space = 0.01,
  vjust = 0.3,
  seg_len = 0.1,
  arrow_len = unit(2, "mm"),
  arrow_type = c("closed", "open"),
  font_size = 5,
  font_family = c("serif", "sans", "mono"),
  font_face = c("plain", "bold", "italic")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_h_arrow_+3A_p">p</code></td>
<td>
<p>a <code>ggplot</code>.</p>
</td></tr>
<tr><td><code id="add_h_arrow_+3A_x">x</code></td>
<td>
<p>position at x axis.</p>
</td></tr>
<tr><td><code id="add_h_arrow_+3A_y">y</code></td>
<td>
<p>position at y axis.</p>
</td></tr>
<tr><td><code id="add_h_arrow_+3A_label">label</code></td>
<td>
<p>text label.</p>
</td></tr>
<tr><td><code id="add_h_arrow_+3A_space">space</code></td>
<td>
<p>a small space between arrow and text.</p>
</td></tr>
<tr><td><code id="add_h_arrow_+3A_vjust">vjust</code></td>
<td>
<p>vertical adjustment, set to 0 to align with the bottom,
0.5 for the middle, and 1 (the default) for the top.</p>
</td></tr>
<tr><td><code id="add_h_arrow_+3A_seg_len">seg_len</code></td>
<td>
<p>length of the arrow segment.</p>
</td></tr>
<tr><td><code id="add_h_arrow_+3A_arrow_len">arrow_len</code></td>
<td>
<p>length of the arrow.</p>
</td></tr>
<tr><td><code id="add_h_arrow_+3A_arrow_type">arrow_type</code></td>
<td>
<p>type of the arrow.</p>
</td></tr>
<tr><td><code id="add_h_arrow_+3A_font_size">font_size</code></td>
<td>
<p>font size.</p>
</td></tr>
<tr><td><code id="add_h_arrow_+3A_font_family">font_family</code></td>
<td>
<p>font family.</p>
</td></tr>
<tr><td><code id="add_h_arrow_+3A_font_face">font_face</code></td>
<td>
<p>font face.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object.
</p>

<hr>
<h2 id='add_labels'>Add Text Labels to a ggplot</h2><span id='topic+add_labels'></span>

<h3>Description</h3>

<p>Add text labels to a ggplot object, such as the result
from <a href="#topic+show_sig_profile">show_sig_profile</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_labels(
  p,
  x,
  y,
  y_end = NULL,
  n_label = NULL,
  labels = NULL,
  revert_order = FALSE,
  font_size = 5,
  font_family = "serif",
  font_face = c("plain", "bold", "italic"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_labels_+3A_p">p</code></td>
<td>
<p>a <code>ggplot</code>.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_x">x</code></td>
<td>
<p>position at x axis.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_y">y</code></td>
<td>
<p>position at y axis.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_y_end">y_end</code></td>
<td>
<p>end position of y axis when <code>n_label</code> is set.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_n_label">n_label</code></td>
<td>
<p>the number of label, when this is set,
the position of labels at y axis is auto-generated
according to <code>y</code> and <code>y_end</code>.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_labels">labels</code></td>
<td>
<p>text labels or a <code>similarity</code> object from <a href="#topic+get_sig_similarity">get_sig_similarity</a>.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_revert_order">revert_order</code></td>
<td>
<p>if <code>TRUE</code>, revert label order.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_font_size">font_size</code></td>
<td>
<p>font size.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_font_family">font_family</code></td>
<td>
<p>font family.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_font_face">font_face</code></td>
<td>
<p>font face.</p>
</td></tr>
<tr><td><code id="add_labels_+3A_...">...</code></td>
<td>
<p>other parameters passing to <a href="ggplot2.html#topic+annotate">ggplot2::annotate</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load mutational signature
load(system.file("extdata", "toy_mutational_signature.RData",
  package = "sigminer", mustWork = TRUE
))
# Show signature profile
p &lt;- show_sig_profile(sig2, mode = "SBS")

# Method 1
p1 &lt;- add_labels(p,
  x = 0.75, y = 0.3, y_end = 0.9, n_label = 3,
  labels = paste0("text", 1:3)
)
p1

# Method 2
p2 &lt;- add_labels(p,
  x = c(0.15, 0.6, 0.75), y = c(0.3, 0.6, 0.9),
  labels = paste0("text", 1:3)
)
p2

# Method 3
sim &lt;- get_sig_similarity(sig2)
p3 &lt;- add_labels(p,
  x = c(0.15, 0.6, 0.75), y = c(0.25, 0.55, 0.8),
  labels = sim, font_size = 2
)
p3
</code></pre>

<hr>
<h2 id='bp'>A Best Practice for Signature Extraction and Exposure (Activity) Attribution</h2><span id='topic+bp'></span><span id='topic+bp_extract_signatures'></span><span id='topic+bp_extract_signatures_iter'></span><span id='topic+bp_cluster_iter_list'></span><span id='topic+bp_get_clustered_sigs'></span><span id='topic+bp_get_sig_obj'></span><span id='topic+bp_get_stats'></span><span id='topic+bp_get_rank_score'></span><span id='topic+bp_show_survey2'></span><span id='topic+bp_show_survey'></span><span id='topic+bp_attribute_activity'></span>

<h3>Description</h3>

<p>These functions are combined to provide a best practice for optimally
identifying mutational signatures and attributing their activities (exposures)
in tumor samples. They are listed in order to use.
</p>

<ul>
<li> <p><code>bp_extract_signatures()</code> for extracting signatures.
</p>
</li>
<li> <p><code>bp_show_survey()</code> for showing measures change under different
signature numbers to help user select optimal signature number.
At default, an aggregated score (named score) is generated to
suggest the best solution.
</p>
</li>
<li> <p><code>bp_show_survey2()</code> for showing simplified signature number survey like
<code><a href="#topic+show_sig_number_survey">show_sig_number_survey()</a></code>.
</p>
</li>
<li> <p><code>bp_get_sig_obj()</code> for get a (list of) <code>Signature</code> object which is common
used in <strong>sigminer</strong> for analysis and visualization.
</p>
</li>
<li> <p><code>bp_attribute_activity()</code> for optimizing signature activities (exposures).
NOTE: the activities from extraction step may be better!
You can also use <a href="#topic+sig_extract">sig_extract</a> to get optimal NMF result from multiple NMF runs.
Besides, you can use <a href="#topic+sig_fit">sig_fit</a> to quantify exposures based on signatures extracted
from <code>bp_extract_signatures()</code>.
</p>
</li>
<li> <p><code>bp_extract_signatures_iter()</code> for extracting signature in a iteration way.
</p>
</li>
<li> <p><code>bp_cluster_iter_list()</code> for clustering (<code>hclust</code> with average linkage)
iterated signatures to help collapse
multiple signatures into one. The result cluster can be visualized by
<code>plot()</code> or <code>factoextra::fviz_dend()</code>.
</p>
</li>
<li> <p><code>bp_get_clustered_sigs()</code> for getting clustered (grouped) mean signatures from signature clusters.
</p>
</li>
<li><p> Extra: <code>bp_get_stats</code>() for obtaining stats for signatures and samples of a solution.
These stats are aggregated (averaged) as the stats for a solution
(specific signature number).
</p>
</li>
<li><p> Extra: <code>bp_get_rank_score()</code> for obtaining rank score for all signature numbers.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>bp_extract_signatures(
  nmf_matrix,
  range = 2:5,
  n_bootstrap = 20L,
  n_nmf_run = 50,
  RTOL = 0.001,
  min_contribution = 0,
  cores = min(4L, future::availableCores()),
  cores_solution = min(cores, length(range)),
  seed = 123456L,
  handle_hyper_mutation = TRUE,
  report_integer_exposure = FALSE,
  only_core_stats = nrow(nmf_matrix) &gt; 100,
  cache_dir = file.path(tempdir(), "sigminer_bp"),
  keep_cache = FALSE,
  pynmf = FALSE,
  use_conda = TRUE,
  py_path = "/Users/wsx/anaconda3/bin/python"
)

bp_extract_signatures_iter(
  nmf_matrix,
  range = 2:5,
  sim_threshold = 0.95,
  max_iter = 10L,
  n_bootstrap = 20L,
  n_nmf_run = 50,
  RTOL = 0.001,
  min_contribution = 0,
  cores = min(4L, future::availableCores()),
  cores_solution = min(cores, length(range)),
  seed = 123456L,
  handle_hyper_mutation = TRUE,
  report_integer_exposure = FALSE,
  only_core_stats = nrow(nmf_matrix) &gt; 100,
  cache_dir = file.path(tempdir(), "sigminer_bp"),
  keep_cache = FALSE,
  pynmf = FALSE,
  use_conda = FALSE,
  py_path = "/Users/wsx/anaconda3/bin/python"
)

bp_cluster_iter_list(x, k = NULL, include_final_iteration = TRUE)

bp_get_clustered_sigs(SigClusters, cluster_label)

bp_get_sig_obj(obj, signum = NULL)

bp_get_stats(obj)

bp_get_rank_score(obj)

bp_show_survey2(
  obj,
  x = "signature_number",
  left_y = "silhouette",
  right_y = "L2_error",
  left_name = left_y,
  right_name = right_y,
  left_color = "black",
  right_color = "red",
  left_shape = 16,
  right_shape = 18,
  shape_size = 4,
  highlight = NULL
)

bp_show_survey(
  obj,
  add_score = FALSE,
  scales = c("free_y", "free"),
  fixed_ratio = TRUE
)

bp_attribute_activity(
  input,
  sample_class = NULL,
  nmf_matrix = NULL,
  method = c("bt", "stepwise"),
  bt_use_prop = FALSE,
  return_class = c("matrix", "data.table"),
  use_parallel = FALSE,
  cache_dir = file.path(tempdir(), "sigminer_attribute_activity"),
  keep_cache = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bp_+3A_nmf_matrix">nmf_matrix</code></td>
<td>
<p>a <code>matrix</code> used for NMF decomposition with rows indicate samples and columns indicate components.</p>
</td></tr>
<tr><td><code id="bp_+3A_range">range</code></td>
<td>
<p>a <code>numeric</code> vector containing the ranks of factorization to try. Note that duplicates are removed
and values are sorted in increasing order. The results are notably returned in this order.</p>
</td></tr>
<tr><td><code id="bp_+3A_n_bootstrap">n_bootstrap</code></td>
<td>
<p>number of bootstrapped (resampling) catalogs used.
When it is <code>0</code>, the original (input) mutation catalog is used for NMF decomposition,
this is not recommended, just for testing, user should not set it to <code>0</code>.</p>
</td></tr>
<tr><td><code id="bp_+3A_n_nmf_run">n_nmf_run</code></td>
<td>
<p>number of NMF runs for each bootstrapped or original catalog.
At default, in total n_bootstrap x n_nmf_run (i.e. 1000) NMF runs are used
for the task.</p>
</td></tr>
<tr><td><code id="bp_+3A_rtol">RTOL</code></td>
<td>
<p>a threshold proposed by Nature Cancer paper to control how to
filter solutions of NMF. Default is <code style="white-space: pre;">&#8288;0.1%&#8288;</code> (from reference #2),
only NMF solutions with KLD (KL deviance) &lt;= <code style="white-space: pre;">&#8288;100.1%&#8288;</code> minimal KLD are kept.</p>
</td></tr>
<tr><td><code id="bp_+3A_min_contribution">min_contribution</code></td>
<td>
<p>a component contribution threshold to filer out small
contributed components.</p>
</td></tr>
<tr><td><code id="bp_+3A_cores">cores</code></td>
<td>
<p>number of cpu cores to run NMF.</p>
</td></tr>
<tr><td><code id="bp_+3A_cores_solution">cores_solution</code></td>
<td>
<p>cores for processing solutions, default is equal to argument <code>cores</code>.</p>
</td></tr>
<tr><td><code id="bp_+3A_seed">seed</code></td>
<td>
<p>a random seed to make reproducible result.</p>
</td></tr>
<tr><td><code id="bp_+3A_handle_hyper_mutation">handle_hyper_mutation</code></td>
<td>
<p>default is <code>TRUE</code>, handle hyper-mutant samples.</p>
</td></tr>
<tr><td><code id="bp_+3A_report_integer_exposure">report_integer_exposure</code></td>
<td>
<p>if <code>TRUE</code>, report integer signature
exposure by bootstrapping technique.</p>
</td></tr>
<tr><td><code id="bp_+3A_only_core_stats">only_core_stats</code></td>
<td>
<p>if <code>TRUE</code>, only calculate the core stats for signatures and samples.</p>
</td></tr>
<tr><td><code id="bp_+3A_cache_dir">cache_dir</code></td>
<td>
<p>a directory for keep temp result files.</p>
</td></tr>
<tr><td><code id="bp_+3A_keep_cache">keep_cache</code></td>
<td>
<p>if <code>TRUE</code>, keep cache results.</p>
</td></tr>
<tr><td><code id="bp_+3A_pynmf">pynmf</code></td>
<td>
<p>if <code>TRUE</code>, use Python NMF driver <a href="http://nimfa.biolab.si/index.html">Nimfa</a>.
The seed currently is not used by this implementation, so the only way to reproduce
your result is setting <code>keep_cache = TRUE</code>.</p>
</td></tr>
<tr><td><code id="bp_+3A_use_conda">use_conda</code></td>
<td>
<p>if <code>TRUE</code>, create an independent conda environment to run NMF.</p>
</td></tr>
<tr><td><code id="bp_+3A_py_path">py_path</code></td>
<td>
<p>path to Python executable file, e.g. '/Users/wsx/anaconda3/bin/python'. In my
test, it is more stable than <code>use_conda=TRUE</code>. You can install the Nimfa package by yourself
or set <code>use_conda</code> to <code>TRUE</code> to install required Python environment, and then set this option.</p>
</td></tr>
<tr><td><code id="bp_+3A_sim_threshold">sim_threshold</code></td>
<td>
<p>a similarity threshold for selecting samples to auto-rerun
the extraction procedure (i.e. <code>bp_extract_signatures()</code>), default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="bp_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum iteration size, default is 10, i.e., at most run
the extraction procedure 10 times.</p>
</td></tr>
<tr><td><code id="bp_+3A_x">x</code></td>
<td>
<p>result from <code><a href="#topic+bp_extract_signatures_iter">bp_extract_signatures_iter()</a></code> or a list of
<code>Signature</code> objects.</p>
</td></tr>
<tr><td><code id="bp_+3A_k">k</code></td>
<td>
<p>an integer sequence specifying the cluster number to get silhouette.</p>
</td></tr>
<tr><td><code id="bp_+3A_include_final_iteration">include_final_iteration</code></td>
<td>
<p>if <code>FALSE</code>, exclude final iteration result
from clustering for input from <code><a href="#topic+bp_extract_signatures_iter">bp_extract_signatures_iter()</a></code>, not applied
if input is a list of <code>Signature</code> objects.</p>
</td></tr>
<tr><td><code id="bp_+3A_sigclusters">SigClusters</code></td>
<td>
<p>result from <code><a href="#topic+bp_cluster_iter_list">bp_cluster_iter_list()</a></code>.</p>
</td></tr>
<tr><td><code id="bp_+3A_cluster_label">cluster_label</code></td>
<td>
<p>cluster labels for a specified cluster number, obtain it
from <code>SigClusters$sil_df</code>.</p>
</td></tr>
<tr><td><code id="bp_+3A_obj">obj</code></td>
<td>
<p>a <code>ExtractionResult</code> object from <code><a href="#topic+bp_extract_signatures">bp_extract_signatures()</a></code>.</p>
</td></tr>
<tr><td><code id="bp_+3A_signum">signum</code></td>
<td>
<p>a integer vector to extract the corresponding <code>Signature</code> object(s).
If it is <code>NULL</code> (default), all will be returned.</p>
</td></tr>
<tr><td><code id="bp_+3A_left_y">left_y</code></td>
<td>
<p>column name for left y axis.</p>
</td></tr>
<tr><td><code id="bp_+3A_right_y">right_y</code></td>
<td>
<p>column name for right y axis.</p>
</td></tr>
<tr><td><code id="bp_+3A_left_name">left_name</code></td>
<td>
<p>label name for left y axis.</p>
</td></tr>
<tr><td><code id="bp_+3A_right_name">right_name</code></td>
<td>
<p>label name for right y axis.</p>
</td></tr>
<tr><td><code id="bp_+3A_left_color">left_color</code></td>
<td>
<p>color for left axis.</p>
</td></tr>
<tr><td><code id="bp_+3A_right_color">right_color</code></td>
<td>
<p>color for right axis.</p>
</td></tr>
<tr><td><code id="bp_+3A_left_shape">left_shape</code>, <code id="bp_+3A_right_shape">right_shape</code>, <code id="bp_+3A_shape_size">shape_size</code></td>
<td>
<p>shape setting.</p>
</td></tr>
<tr><td><code id="bp_+3A_highlight">highlight</code></td>
<td>
<p>a <code>integer</code> to highlight a <code>x</code>.</p>
</td></tr>
<tr><td><code id="bp_+3A_add_score">add_score</code></td>
<td>
<p>if <code>FALSE</code>, don't show score and label optimal points by
rank score.</p>
</td></tr>
<tr><td><code id="bp_+3A_scales">scales</code></td>
<td>
<p>one of &quot;free_y&quot; (default) and &quot;free&quot; to control the scales
of plot facet.</p>
</td></tr>
<tr><td><code id="bp_+3A_fixed_ratio">fixed_ratio</code></td>
<td>
<p>if <code>TRUE</code> (default), make the x/y axis ratio fixed.</p>
</td></tr>
<tr><td><code id="bp_+3A_input">input</code></td>
<td>
<p>result from <code><a href="#topic+bp_extract_signatures">bp_extract_signatures()</a></code> or a Signature object.</p>
</td></tr>
<tr><td><code id="bp_+3A_sample_class">sample_class</code></td>
<td>
<p>a named string vector whose names are sample names
and values are class labels (i.e. cancer subtype). If it is <code>NULL</code> (the default),
treat all samples as one group.</p>
</td></tr>
<tr><td><code id="bp_+3A_method">method</code></td>
<td>
<p>one of 'bt' (use bootstrap exposure median, from reference #2,
<strong>the most recommended way in my personal view</strong>) or stepwise'
(stepwise reduce and update signatures then do signature fitting
with last signature sets, from reference #2, the result tends to assign
the contribution of removed signatures to the remaining signatures,
<strong>maybe I misunderstand the paper method? PAY ATTENTION</strong>).</p>
</td></tr>
<tr><td><code id="bp_+3A_bt_use_prop">bt_use_prop</code></td>
<td>
<p>this parameter is only used for <code>bt</code> method to reset
low contributing signature activity (relative activity <code style="white-space: pre;">&#8288;&lt;0.01&#8288;</code>). If <code>TRUE</code>,
use empirical P value calculation way (i.e. proportion, used by reference <code style="white-space: pre;">&#8288;#2&#8288;</code>),
otherwise a <code>t.test</code> is applied.</p>
</td></tr>
<tr><td><code id="bp_+3A_return_class">return_class</code></td>
<td>
<p>string, 'matrix' or 'data.table'.</p>
</td></tr>
<tr><td><code id="bp_+3A_use_parallel">use_parallel</code></td>
<td>
<p>if <code>TRUE</code>, use parallel computation based on <strong>furrr</strong> package.
It can also be an integer for specifying cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The signature extraction approach is adopted from reference #1, #2, and
the whole best practice is adopted from the pipeline used by reference #3.
I implement the whole procedure with R code based on the method description
of papers. The code is well organized, tested and documented so user will
find it pretty simple and useful. Besides, the structure of the results is
very clear to see and also visualize like other approaches provided by <strong>sigminer</strong>.
</p>


<h3>Value</h3>

<p>It depends on the called function.
</p>


<h3>Measure Explanation in Survey Plot</h3>

<p>The survey plot provides a pretty good way to facilitate the signature number
selection. A <code>score</code> measure is calculated as the weighted mean of selected
measures and visualized as the first sub-plot. The optimal number is highlighted
with red color dot and the best values for each measures are also
highlighted with orange color dots. The detail of 6 measures shown in plot are
explained as below.
</p>

<ul>
<li> <p><code>score</code> - an aggregated score based on rank scores from selected measures below.
The higher, the better. When two signature numbers have the same score,
the larger signature number is preferred (this is a rare situation, you
have to double check other measures).
</p>
</li>
<li> <p><code>silhouette</code> - the average silhouette width for signatures, also named as ASW in reference #2.
The signature number with silhouette decreases sharply is preferred.
</p>
</li>
<li> <p><code>distance</code> - the average sample reconstructed cosine distance, the lower value is better.
</p>
</li>
<li> <p><code>error</code> - the average sample reconstructed error calculated with L2 formula
(i.e. L2 error). This lower value is better. This measure represents a
similar concept like <code>distance</code> above, they are all used to quantify how well
sample mutation profiles can be reconstructed from signatures, but <code>distance</code>
cares the whole mutation profile similarity while <code>error</code> here cares value difference.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;pos cor&#8288;</code> - the average positive signature exposure correlation coefficient.
The lower value is better. This measure is constructed based on my understanding
about signatures: mutational signatures are typically treated as independent
recurrent patterns, so their activities are less correlated.
</p>
</li>
<li> <p><code>similarity</code> - the average similarity within in a signature cluster.
Like <code>silhouette</code>, the point decreases sharply is preferred.
In the practice, results from multiple NMF runs are clustered
with &quot;clustering with match&quot; algorithm proposed by reference #2. This value
indicates if the signature profiles extracted from different NMF runs are similar.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Shixiang Wang <a href="mailto:w_shixiang@163.com">w_shixiang@163.com</a>
</p>


<h3>References</h3>

<p>Alexandrov, Ludmil B., et al. &quot;Deciphering signatures of mutational processes operative in human cancer.&quot; Cell reports 3.1 (2013): 246-259.
</p>
<p>Degasperi, Andrea, et al. &quot;A practical framework and online tool for mutational signature analyses show intertissue variation and driver dependencies.&quot; Nature cancer 1.2 (2020): 249-263.
</p>
<p>Alexandrov, Ludmil B., et al. “The repertoire of mutational signatures in human cancer.” Nature 578.7793 (2020): 94-101.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+sig_estimate">sig_estimate</a>, <a href="#topic+sig_extract">sig_extract</a>, <a href="#topic+sig_auto_extract">sig_auto_extract</a>,
<a href="#topic+sigprofiler_extract">sigprofiler_extract</a> for other approaches.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("simulated_catalogs")

# Here I reduce the values for n_bootstrap and n_nmf_run
# for reducing the run time.
# In practice, you should keep default or increase the values
# for better estimation.
#
# The input data here is simulated from 10 mutational signatures

# e1 &lt;- bp_extract_signatures(
#   t(simulated_catalogs$set1),
#   range = 8:12,
#   n_bootstrap = 5,
#   n_nmf_run = 10
# )
#
# To avoid computation in examples,
# Here just load the result
# (e1$signature and e1$exposure set to NA to reduce package size)
load(system.file("extdata", "e1.RData", package = "sigminer"))


# See the survey for different signature numbers
# The suggested solution is marked as red dot
# with highest integrated score.
p1 &lt;- bp_show_survey(e1)
p1
# You can also exclude plotting and highlighting the score
p2 &lt;- bp_show_survey(e1, add_score = FALSE)
p2

# You can also plot a simplified version
p3 &lt;- bp_show_survey2(e1, highlight = 10)
p3

# Obtain the suggested solution from extraction result
obj_suggested &lt;- bp_get_sig_obj(e1, e1$suggested)
obj_suggested
# If you think the suggested signature number is not right
# Just pick up the solution you want
obj_s8 &lt;- bp_get_sig_obj(e1, 8)

# Track the reconstructed profile similarity
rec_sim &lt;- get_sig_rec_similarity(obj_s8, t(simulated_catalogs$set1))
rec_sim

# After extraction, you can assign the signatures
# to reference COSMIC signatures
# More see ?get_sig_similarity
sim &lt;- get_sig_similarity(obj_suggested)
# Visualize the match result
if (require(pheatmap)) {
  pheatmap::pheatmap(sim$similarity)
}

# You already got the activities of signatures
# in obj_suggested, however, you can still
# try to optimize the result.
# NOTE: the optimization step may not truly optimize the result!
expo &lt;- bp_attribute_activity(e1, return_class = "data.table")
expo$abs_activity


## Not run: 
# Iterative extraction:
# This procedure will rerun extraction step
# for those samples with reconstructed catalog similarity
# lower than a threshold (default is 0.95)
e2 &lt;- bp_extract_signatures_iter(
  t(simulated_catalogs$set1),
  range = 9:11,
  n_bootstrap = 5,
  n_nmf_run = 5,
  sim_threshold = 0.99
)
e2
# When the procedure run multiple rounds
# you can cluster the signatures from different rounds by
# the following command
# bp_cluster_iter_list(e2)

## Extra utilities
rank_score &lt;- bp_get_rank_score(e1)
rank_score
stats &lt;- bp_get_stats(e2$iter1)
# Get the mean reconstructed similarity
1 - stats$stats_sample$cosine_distance_mean

## End(Not run)
</code></pre>

<hr>
<h2 id='centromeres.hg19'>Location of Centromeres at Genome Build hg19</h2><span id='topic+centromeres.hg19'></span>

<h3>Description</h3>

<p>Location of Centromeres at Genome Build hg19
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>Generate from UCSC gold path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centromeres.hg19)
</code></pre>

<hr>
<h2 id='centromeres.hg38'>Location of Centromeres at Genome Build hg38</h2><span id='topic+centromeres.hg38'></span>

<h3>Description</h3>

<p>Location of Centromeres at Genome Build hg38
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>Generate from Genome Reference Consortium
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centromeres.hg38)
</code></pre>

<hr>
<h2 id='centromeres.mm10'>Location of Centromeres at Genome Build mm10</h2><span id='topic+centromeres.mm10'></span>

<h3>Description</h3>

<p>Location of Centromeres at Genome Build mm10
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>Generate from <a href="https://hgdownload.soe.ucsc.edu/goldenPath/mm10/database/gap.txt.gz">https://hgdownload.soe.ucsc.edu/goldenPath/mm10/database/gap.txt.gz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centromeres.mm10)
</code></pre>

<hr>
<h2 id='centromeres.mm9'>Location of Centromeres at Genome Build mm9</h2><span id='topic+centromeres.mm9'></span>

<h3>Description</h3>

<p>Location of Centromeres at Genome Build mm9
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>Generate from <a href="https://hgdownload.soe.ucsc.edu/goldenPath/mm9/database/">https://hgdownload.soe.ucsc.edu/goldenPath/mm9/database/</a>
with code:
</p>
<div class="sourceCode sh"><pre>for i in $(seq 1 19) X Y;
do
wget https://hgdownload.soe.ucsc.edu/goldenPath/mm9/database/chr${i}_gap.txt.gz
done
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>data(centromeres.mm9)
</code></pre>

<hr>
<h2 id='centromeres.T2T'>Location of Centromeres at Genome Build T2T</h2><span id='topic+centromeres.T2T'></span>

<h3>Description</h3>

<p>Location of Centromeres at Genome Build T2T
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>from T2T study
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centromeres.T2T)
</code></pre>

<hr>
<h2 id='chromsize.hg19'>Chromosome Size of Genome Build hg19</h2><span id='topic+chromsize.hg19'></span>

<h3>Description</h3>

<p>Chromosome Size of Genome Build hg19
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>Generate from UCSC gold path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chromsize.hg19)
</code></pre>

<hr>
<h2 id='chromsize.hg38'>Chromosome Size of Genome Build hg38</h2><span id='topic+chromsize.hg38'></span>

<h3>Description</h3>

<p>Chromosome Size of Genome Build hg38
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>Generate from UCSC gold path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chromsize.hg38)
</code></pre>

<hr>
<h2 id='chromsize.mm10'>Chromosome Size of Genome Build mm10</h2><span id='topic+chromsize.mm10'></span>

<h3>Description</h3>

<p>Chromosome Size of Genome Build mm10
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>Generate from UCSC gold path <a href="http://hgdownload.cse.ucsc.edu/goldenPath/mm10/bigZips/mm10.chrom.sizes">http://hgdownload.cse.ucsc.edu/goldenPath/mm10/bigZips/mm10.chrom.sizes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chromsize.mm10)
</code></pre>

<hr>
<h2 id='chromsize.mm9'>Chromosome Size of Genome Build mm9</h2><span id='topic+chromsize.mm9'></span>

<h3>Description</h3>

<p>Chromosome Size of Genome Build mm9
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>Generate from UCSC gold path <a href="http://hgdownload.cse.ucsc.edu/goldenPath/mm9/bigZips/mm9.chrom.sizes">http://hgdownload.cse.ucsc.edu/goldenPath/mm9/bigZips/mm9.chrom.sizes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chromsize.mm9)
</code></pre>

<hr>
<h2 id='chromsize.T2T'>Chromosome Size of Genome Build T2T</h2><span id='topic+chromsize.T2T'></span>

<h3>Description</h3>

<p>Chromosome Size of Genome Build T2T
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>from T2T study
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chromsize.T2T)
</code></pre>

<hr>
<h2 id='CN.features'>Classification Table of Copy Number Features Devised by Wang et al. for Method 'W'</h2><span id='topic+CN.features'></span>

<h3>Description</h3>

<p>Classification Table of Copy Number Features Devised by Wang et al. for Method 'W'
</p>


<h3>Format</h3>

<p>A <code>data.table</code> with &quot;sigminer.features&quot; class name
</p>


<h3>Source</h3>

<p>Generate from code under data_raw/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CN.features)
</code></pre>

<hr>
<h2 id='CopyNumber-class'>Class CopyNumber</h2><span id='topic+CopyNumber-class'></span><span id='topic+CopyNumber'></span>

<h3>Description</h3>

<p>S4 class for storing summarized absolute copy number profile.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>data.table of absolute copy number calling.</p>
</dd>
<dt><code>summary.per.sample</code></dt><dd><p>data.table of copy number variation summary per sample.</p>
</dd>
<dt><code>genome_build</code></dt><dd><p>genome build version, should be one of 'hg19' or 'hg38'.</p>
</dd>
<dt><code>genome_measure</code></dt><dd><p>Set 'called' will use autosomo called segments size to compute total size
for CNA burden calculation, this option is useful for WES and target sequencing.
Set 'wg' will autosome size from genome build, this option is useful for WGS, SNP etc..</p>
</dd>
<dt><code>annotation</code></dt><dd><p>data.table of annotation for copy number segments.</p>
</dd>
<dt><code>dropoff.segs</code></dt><dd><p>data.table of copy number segments dropped from raw input.</p>
</dd>
</dl>

<hr>
<h2 id='cosine'>Calculate Cosine Measures</h2><span id='topic+cosine'></span>

<h3>Description</h3>

<p>Calculate Cosine Measures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosine(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosine_+3A_x">x</code></td>
<td>
<p>a numeric vector or matrix with column representing vector to calculate similarity.</p>
</td></tr>
<tr><td><code id="cosine_+3A_y">y</code></td>
<td>
<p>must be same format as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value or <code>matrix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0)
y &lt;- c(0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0)
z1 &lt;- cosine(x, y)
z1
z2 &lt;- cosine(matrix(x), matrix(y))
z2
</code></pre>

<hr>
<h2 id='cytobands.hg19'>Location of Chromosome Cytobands at Genome Build hg19</h2><span id='topic+cytobands.hg19'></span>

<h3>Description</h3>

<p>Location of Chromosome Cytobands at Genome Build hg19
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>from UCSC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cytobands.hg19)
</code></pre>

<hr>
<h2 id='cytobands.hg38'>Location of Chromosome Cytobands at Genome Build hg38</h2><span id='topic+cytobands.hg38'></span>

<h3>Description</h3>

<p>Location of Chromosome Cytobands at Genome Build hg38
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>from UCSC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cytobands.hg38)
</code></pre>

<hr>
<h2 id='cytobands.mm10'>Location of Chromosome Cytobands at Genome Build mm10</h2><span id='topic+cytobands.mm10'></span>

<h3>Description</h3>

<p>Location of Chromosome Cytobands at Genome Build mm10
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>from UCSC <a href="http://hgdownload.cse.ucsc.edu/goldenpath/mm10/database/cytoBand.txt.gz">http://hgdownload.cse.ucsc.edu/goldenpath/mm10/database/cytoBand.txt.gz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cytobands.mm10)
</code></pre>

<hr>
<h2 id='cytobands.mm9'>Location of Chromosome Cytobands at Genome Build mm9</h2><span id='topic+cytobands.mm9'></span>

<h3>Description</h3>

<p>Location of Chromosome Cytobands at Genome Build mm9
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>from UCSC <a href="http://hgdownload.cse.ucsc.edu/goldenpath/mm9/database/cytoBand.txt.gz">http://hgdownload.cse.ucsc.edu/goldenpath/mm9/database/cytoBand.txt.gz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cytobands.mm9)
</code></pre>

<hr>
<h2 id='cytobands.T2T'>Location of Chromosome Cytobands at Genome Build T2T</h2><span id='topic+cytobands.T2T'></span>

<h3>Description</h3>

<p>Location of Chromosome Cytobands at Genome Build T2T
</p>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Source</h3>

<p>from T2T study
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cytobands.T2T)
</code></pre>

<hr>
<h2 id='enrich_component_strand_bias'>Performs Strand Bias Enrichment Analysis for a Given Sample-by-Component Matrix</h2><span id='topic+enrich_component_strand_bias'></span>

<h3>Description</h3>

<p>See <a href="#topic+sig_tally">sig_tally</a> for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enrich_component_strand_bias(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enrich_component_strand_bias_+3A_mat">mat</code></td>
<td>
<p>a sample-by-component matrix from <a href="#topic+sig_tally">sig_tally</a> with strand bias labels &quot;T:&quot; and &quot;B:&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.table</code> sorted by <code>p_value</code>.
</p>

<hr>
<h2 id='get_adj_p'>Get Adjust P Values from Group Comparison</h2><span id='topic+get_adj_p'></span>

<h3>Description</h3>

<p>Setting <code>aes(label=..p.adj..)</code> in <code><a href="ggpubr.html#topic+compare_means">ggpubr::compare_means()</a></code> does not
show adjust p values. The returned result of this function can be combined with <code><a href="ggpubr.html#topic+stat_pvalue_manual">ggpubr::stat_pvalue_manual()</a></code> to fix
this problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_adj_p(
  data,
  .col,
  .grp = "Sample",
  comparisons = NULL,
  method = "wilcox.test",
  p.adjust.method = "fdr",
  p.digits = 3L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_adj_p_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing column for groups and column for comparison.</p>
</td></tr>
<tr><td><code id="get_adj_p_+3A_.col">.col</code></td>
<td>
<p>column name for comparison.</p>
</td></tr>
<tr><td><code id="get_adj_p_+3A_.grp">.grp</code></td>
<td>
<p>column name for groups.</p>
</td></tr>
<tr><td><code id="get_adj_p_+3A_comparisons">comparisons</code></td>
<td>
<p>Default is <code>NULL</code>, use all combination in group column.
It can be a list of length-2 vectors. The entries in the vector are either
the names of 2 values on the x-axis or the 2 integers that correspond to the
index of the groups of interest, to be compared.</p>
</td></tr>
<tr><td><code id="get_adj_p_+3A_method">method</code></td>
<td>
<p>a character string indicating which method to be used for comparing means.
It can be 't.test', 'wilcox.test' etc..</p>
</td></tr>
<tr><td><code id="get_adj_p_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>correction method, default is 'fdr'. Run <code>p.adjust.methods</code> to
see all available options.</p>
</td></tr>
<tr><td><code id="get_adj_p_+3A_p.digits">p.digits</code></td>
<td>
<p>how many significant digits are to be used.</p>
</td></tr>
<tr><td><code id="get_adj_p_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="ggpubr.html#topic+compare_means">ggpubr::compare_means()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>More info see <code><a href="ggpubr.html#topic+compare_means">ggpubr::compare_means()</a></code>, <code><a href="ggpubr.html#topic+stat_compare_means">ggpubr::stat_compare_means()</a></code> and <code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code>.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> containing comparison result
</p>


<h3>Source</h3>

<p>https://github.com/kassambara/ggpubr/issues/143
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggpubr)
# T-test
stat.test &lt;- compare_means(
  len ~ dose,
  data = ToothGrowth,
  method = "t.test",
  p.adjust.method = "fdr"
)
stat.test
# Create a simple box plot
p &lt;- ggboxplot(ToothGrowth, x = "dose", y = "len")
p

# Add p values
my_comparisons &lt;- list(c("0.5", "1"), c("1", "2"), c("0.5", "2"))
p + stat_compare_means(method = "t.test", comparisons = my_comparisons)

# Try adding adjust p values
# proposed by author of ggpubr
# however it does not work
p + stat_compare_means(aes(label = ..p.adj..), method = "t.test", comparisons = my_comparisons)

# Solution:
# calculate adjust p values and their location
# then use stat_pvalue_manual() function
p_adj &lt;- get_adj_p(ToothGrowth, .col = "len", .grp = "dose")
p_adj
p + stat_pvalue_manual(p_adj, label = "p.adj")

# Show selected comparisons
# Of note, p value is ajusted
# for three comparisons, but only
# two are showed in figure
p_adj &lt;- get_adj_p(ToothGrowth,
  .col = "len", .grp = "dose",
  comparisons = list(c("0.5", "1"), c("1", "2"))
)
p + stat_pvalue_manual(p_adj, label = "p.adj")
</code></pre>

<hr>
<h2 id='get_Aneuploidy_score'>Get Aneuploidy Score from Copy Number Profile</h2><span id='topic+get_Aneuploidy_score'></span>

<h3>Description</h3>

<p>This implements a Cohen-Sharir method (see reference) like &quot;Aneuploidy Score&quot; computation.
You can read the source code to see how it works. Basically, it follows
the logic of Cohen-Sharir method but with some difference in detail implementation.
Their results should be counterpart, but with no data validation for now.
<strong>Please raise an issue if you find problem/bugs in this function</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Aneuploidy_score(
  data,
  ploidy_df = NULL,
  genome_build = "hg19",
  rm_black_arms = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Aneuploidy_score_+3A_data">data</code></td>
<td>
<p>a CopyNumber object or a <code>data.frame</code> containing at least
'chromosome', 'start', 'end', 'segVal', 'sample' these columns.</p>
</td></tr>
<tr><td><code id="get_Aneuploidy_score_+3A_ploidy_df">ploidy_df</code></td>
<td>
<p>default is <code>NULL</code>, compute ploidy by segment-size weighted copy number
aross autosome, see <a href="#topic+get_cn_ploidy">get_cn_ploidy</a>. You can also provide a <code>data.frame</code> with 'sample'
and 'ploidy' columns.</p>
</td></tr>
<tr><td><code id="get_Aneuploidy_score_+3A_genome_build">genome_build</code></td>
<td>
<p>genome build version, should be 'hg19', 'hg38', 'mm9' or 'mm10'.</p>
</td></tr>
<tr><td><code id="get_Aneuploidy_score_+3A_rm_black_arms">rm_black_arms</code></td>
<td>
<p>if <code>TRUE</code>, remove short arms of chr13/14/15/21/22 from calculation
as documented in reference #3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>References</h3>


<ul>
<li><p> Cohen-Sharir, Y., McFarland, J. M., Abdusamad, M., Marquis, C., Bernhard, S. V., Kazachkova, M., ... &amp; Ben-David, U. (2021). Aneuploidy renders cancer cells vulnerable to mitotic checkpoint inhibition. Nature, 1-6.
</p>
</li>
<li><p> Logic reference: <a href="https://github.com/quevedor2/aneuploidy_score/">https://github.com/quevedor2/aneuploidy_score/</a>.
</p>
</li>
<li><p> Taylor, Alison M., et al. &quot;Genomic and functional approaches to understanding cancer aneuploidy.&quot; Cancer cell 33.4 (2018): 676-689.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load copy number object
load(system.file("extdata", "toy_copynumber.RData",
  package = "sigminer", mustWork = TRUE
))

df &lt;- get_Aneuploidy_score(cn)
df

df2 &lt;- get_Aneuploidy_score(cn@data)
df2

df3 &lt;- get_Aneuploidy_score(cn@data,
  ploidy_df = get_cn_ploidy(cn@data)
)
df3
</code></pre>

<hr>
<h2 id='get_bayesian_result'>Get Specified Bayesian NMF Result from Run</h2><span id='topic+get_bayesian_result'></span>

<h3>Description</h3>

<p>Sometimes, we may want to use or inspect specified run result from <a href="#topic+sig_auto_extract">sig_auto_extract</a>.
This function is designed for this purpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_bayesian_result(run_info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_bayesian_result_+3A_run_info">run_info</code></td>
<td>
<p>a <code>data.frame</code> with 1 row and two necessary columns <code>Run</code> and <code>file</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code>.
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata", "toy_copynumber_tally_W.RData",
  package = "sigminer", mustWork = TRUE
))

res &lt;- sig_auto_extract(cn_tally_W$nmf_matrix, result_prefix = "Test_copynumber", nrun = 1)

# All run info are stored in res$Raw$summary_run
# Obtain result of run 1
res_run1 &lt;- get_bayesian_result(res$Raw$summary_run[1, ])
</code></pre>

<hr>
<h2 id='get_cn_freq_table'>Get CNV Frequency Table</h2><span id='topic+get_cn_freq_table'></span>

<h3>Description</h3>

<p>Get CNV Frequency Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cn_freq_table(
  data,
  genome_build = "hg19",
  cutoff = 2L,
  resolution_factor = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cn_freq_table_+3A_data">data</code></td>
<td>
<p>a <code>CopyNumber</code> object or a data.frame containing
at least 'chromosome', 'start', 'end', 'segVal', 'sample' these columns.</p>
</td></tr>
<tr><td><code id="get_cn_freq_table_+3A_genome_build">genome_build</code></td>
<td>
<p>genome build version, used when <code>data</code> is a <code>data.frame</code>, should be 'hg19' or 'hg38'.</p>
</td></tr>
<tr><td><code id="get_cn_freq_table_+3A_cutoff">cutoff</code></td>
<td>
<p>copy number value cutoff for splitting data into AMP and DEL.
The values equal to cutoff are discarded. Default is <code>2</code>, you can also set
a length-2 vector, e.g. <code>c(2, 2)</code>.</p>
</td></tr>
<tr><td><code id="get_cn_freq_table_+3A_resolution_factor">resolution_factor</code></td>
<td>
<p>an integer to control the resolution.
When it is <code>1</code> (default), compute frequency in each cytoband.
When it is <code>2</code>, use compute frequency in each half cytoband.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.table</code>.
</p>

<hr>
<h2 id='get_cn_ploidy'>Get Ploidy from Absolute Copy Number Profile</h2><span id='topic+get_cn_ploidy'></span>

<h3>Description</h3>

<p>Get Ploidy from Absolute Copy Number Profile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cn_ploidy(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cn_ploidy_+3A_data">data</code></td>
<td>
<p>a <a href="#topic+CopyNumber">CopyNumber</a> object or a <code>data.frame</code> containing at least 'chromosome', 'start',
'end', 'segVal' these columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value or a <code>data.table</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load copy number object
load(system.file("extdata", "toy_copynumber.RData",
  package = "sigminer", mustWork = TRUE
))

df &lt;- get_cn_ploidy(cn)
df
</code></pre>

<hr>
<h2 id='get_genome_annotation'>Get Genome Annotation</h2><span id='topic+get_genome_annotation'></span>

<h3>Description</h3>

<p>Get Genome Annotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_genome_annotation(
  data_type = c("chr_size", "centro_loc", "cytobands", "transcript", "gene"),
  chrs = paste0("chr", c(1:22, "X", "Y")),
  genome_build = c("hg19", "hg38", "T2T", "mm10", "mm9", "ce11")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_genome_annotation_+3A_data_type">data_type</code></td>
<td>
<p>'chr_size' for chromosome size,
'centro_loc' for location of centromeres,
'cytobands' for location of chromosome cytobands
and 'transcript' for location of transcripts.</p>
</td></tr>
<tr><td><code id="get_genome_annotation_+3A_chrs">chrs</code></td>
<td>
<p>chromosomes start with 'chr'</p>
</td></tr>
<tr><td><code id="get_genome_annotation_+3A_genome_build">genome_build</code></td>
<td>
<p>one of 'hg19', 'hg38'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> containing annotation data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- get_genome_annotation()
df1

df2 &lt;- get_genome_annotation(genome_build = "hg38")
df2

df3 &lt;- get_genome_annotation(data_type = "centro_loc")
df3

df4 &lt;- get_genome_annotation(data_type = "centro_loc", genome_build = "hg38")
df4

df5 &lt;- get_genome_annotation(data_type = "cytobands")
df5

df6 &lt;- get_genome_annotation(data_type = "cytobands", genome_build = "hg38")
df6
</code></pre>

<hr>
<h2 id='get_group_comparison'>Get Comparison Result between Signature Groups</h2><span id='topic+get_group_comparison'></span>

<h3>Description</h3>

<p>Compare genotypes/phenotypes based on signature groups (samples are assigned to
several groups). For categorical
type, calculate fisher p value (using <a href="stats.html#topic+fisher.test">stats::fisher.test</a>) and count table.
In larger than 2 by 2 tables, compute p-values by Monte Carlo simulation.
For continuous type, calculate anova p value (using <a href="stats.html#topic+aov">stats::aov</a>),
summary table and Tukey Honest significant difference (using <a href="stats.html#topic+TukeyHSD">stats::TukeyHSD</a>).
The result of this function can be plotted by <code><a href="#topic+show_group_comparison">show_group_comparison()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_group_comparison(
  data,
  col_group,
  cols_to_compare,
  type = "ca",
  NAs = NA,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_group_comparison_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing signature groups and genotypes/phenotypes
(including categorical and continuous type data) want to analyze. User need to
construct this <code>data.frame</code> by him/herself.</p>
</td></tr>
<tr><td><code id="get_group_comparison_+3A_col_group">col_group</code></td>
<td>
<p>column name of signature groups.</p>
</td></tr>
<tr><td><code id="get_group_comparison_+3A_cols_to_compare">cols_to_compare</code></td>
<td>
<p>column names of genotypes/phenotypes want to summarize based on groups.</p>
</td></tr>
<tr><td><code id="get_group_comparison_+3A_type">type</code></td>
<td>
<p>a characater vector with length same as <code>cols_to_compare</code>,
'ca' for categorical type and 'co' for continuous type.</p>
</td></tr>
<tr><td><code id="get_group_comparison_+3A_nas">NAs</code></td>
<td>
<p>default is <code>NA</code>, filter <code>NA</code>s for categorical columns.
Otherwise a value (either length 1 or length same as <code>cols_to_compare</code>) fill <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="get_group_comparison_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print extra information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> contains data, summary, p value etc..
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang <a href="mailto:w_shixiang@163.com">w_shixiang@163.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load(system.file("extdata", "toy_copynumber_signature_by_W.RData",
  package = "sigminer", mustWork = TRUE
))

# Assign samples to clusters
groups &lt;- get_groups(sig, method = "k-means")

set.seed(1234)

groups$prob &lt;- rnorm(10)
groups$new_group &lt;- sample(c("1", "2", "3", "4", NA), size = nrow(groups), replace = TRUE)

# Compare groups (filter NAs for categorical coloumns)
groups.cmp &lt;- get_group_comparison(groups[, -1],
  col_group = "group",
  cols_to_compare = c("prob", "new_group"),
  type = c("co", "ca"), verbose = TRUE
)

# Compare groups (Set NAs of categorical columns to 'Rest')
groups.cmp2 &lt;- get_group_comparison(groups[, -1],
  col_group = "group",
  cols_to_compare = c("prob", "new_group"),
  type = c("co", "ca"), NAs = "Rest", verbose = TRUE
)

</code></pre>

<hr>
<h2 id='get_groups'>Get Sample Groups from Signature Decomposition Information</h2><span id='topic+get_groups'></span>

<h3>Description</h3>

<p>One of key results from signature analysis is to cluster samples into different
groups. This function takes <code>Signature</code> object as input
and return the membership in each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_groups(
  Signature,
  method = c("consensus", "k-means", "exposure", "samples"),
  n_cluster = NULL,
  match_consensus = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_groups_+3A_signature">Signature</code></td>
<td>
<p>a <code>Signature</code> object obtained either from <a href="#topic+sig_extract">sig_extract</a> or <a href="#topic+sig_auto_extract">sig_auto_extract</a>.
Now it can be used to relative exposure result in <code>data.table</code> format from <a href="#topic+sig_fit">sig_fit</a>.</p>
</td></tr>
<tr><td><code id="get_groups_+3A_method">method</code></td>
<td>
<p>grouping method, more see details, could be one of the following:
</p>

<ul>
<li><p> 'consensus' - returns the cluster membership based on the hierarchical clustering of the consensus matrix,
it can only be used for the result obtained by <code><a href="#topic+sig_extract">sig_extract()</a></code> with multiple runs using <strong>NMF</strong> package.
</p>
</li>
<li><p> 'k-means' -  returns the clusters by k-means.
</p>
</li>
<li><p> 'exposure' - assigns a sample into a group whose signature exposure
is dominant.
</p>
</li>
<li><p> 'samples' - returns the cluster membership based on the contribution of signature to each sample,
it can only be used for the result obtained by <code><a href="#topic+sig_extract">sig_extract()</a></code> using <strong>NMF</strong> package.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_groups_+3A_n_cluster">n_cluster</code></td>
<td>
<p>only used when the <code>method</code> is 'k-means'.</p>
</td></tr>
<tr><td><code id="get_groups_+3A_match_consensus">match_consensus</code></td>
<td>
<p>only used when the <code>method</code> is 'consensus'.
If <code>TRUE</code>, the result will match order as shown in consensus map.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users may find there are bigger differences between using method 'samples' and 'exposure' but
they use a similar idear to find dominant signature, here goes the reason:
</p>
<p>Method 'samples' using data directly from NMF decomposition, this means the two matrix
<code>W</code> (basis matrix or signature matrix) and <code>H</code> (coefficient matrix or exposure matrix) are
the results of NMF. For method 'exposure', it uses the signature exposure loading matrix.
In this situation, each signture represents a number of mutations (alterations)
about implementation please see source code of <code><a href="#topic+sig_extract">sig_extract()</a></code> function.
</p>


<h3>Value</h3>

<p>a <code>data.table</code> object
</p>


<h3>See Also</h3>

<p><code><a href="NMF.html#topic+predict">NMF::predict()</a></code>, <a href="#topic+show_groups">show_groups</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load copy number prepare object
load(system.file("extdata", "toy_copynumber_tally_W.RData",
  package = "sigminer", mustWork = TRUE
))
# Extract copy number signatures
library(NMF)
sig &lt;- sig_extract(cn_tally_W$nmf_matrix, 2,
  nrun = 10
)

# Methods 'consensus' and 'samples' are from NMF::predict()
g1 &lt;- get_groups(sig, method = "consensus", match_consensus = TRUE)
g1
g2 &lt;- get_groups(sig, method = "samples")
g2

# Use k-means clustering
g3 &lt;- get_groups(sig, method = "k-means")
g3

</code></pre>

<hr>
<h2 id='get_intersect_size'>Get Overlap Size between Interval x and y</h2><span id='topic+get_intersect_size'></span>

<h3>Description</h3>

<p>Get Overlap Size between Interval x and y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_intersect_size(x.start, x.end, y.start, y.end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_intersect_size_+3A_x.start">x.start</code></td>
<td>
<p>start position of interval x.</p>
</td></tr>
<tr><td><code id="get_intersect_size_+3A_x.end">x.end</code></td>
<td>
<p>start position of interval x.</p>
</td></tr>
<tr><td><code id="get_intersect_size_+3A_y.start">y.start</code></td>
<td>
<p>start position of interval x.</p>
</td></tr>
<tr><td><code id="get_intersect_size_+3A_y.end">y.end</code></td>
<td>
<p>start position of interval x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o1 &lt;- get_intersect_size(1, 5, 3, 20)
o1
o2 &lt;- get_intersect_size(3, 20, 1, 10)
o2
o3 &lt;- get_intersect_size(c(1, 2, 1), c(10, 4, 6), c(4, 2, 5), c(10, 3, 22))
o3

</code></pre>

<hr>
<h2 id='get_pLOH_score'>Get proportions of pLOH score from Allele Specific Copy Number Profile</h2><span id='topic+get_pLOH_score'></span>

<h3>Description</h3>

<p>pLOH score represents the genome that displayed LOH.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pLOH_score(data, rm_chrs = c("chrX", "chrY"), genome_build = "hg19")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pLOH_score_+3A_data">data</code></td>
<td>
<p>a CopyNumber object or a <code>data.frame</code> containing at least
'chromosome', 'start', 'end', 'segVal', &quot;minor_cn&quot;, 'sample' these columns.</p>
</td></tr>
<tr><td><code id="get_pLOH_score_+3A_rm_chrs">rm_chrs</code></td>
<td>
<p>chromosomes to be removed in calculation. Default is sex
chromosomes (recommended).</p>
</td></tr>
<tr><td><code id="get_pLOH_score_+3A_genome_build">genome_build</code></td>
<td>
<p>genome build version, should be 'hg19', 'hg38', 'mm9' or 'mm10'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>References</h3>

<p>Steele, Christopher D., et al. &quot;Signatures of copy number alterations in human cancer.&quot; bioRxiv (2021).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load toy dataset of absolute copynumber profile
load(system.file("extdata", "toy_segTab.RData",
  package = "sigminer", mustWork = TRUE
))

set.seed(1234)
segTabs$minor_cn &lt;- sample(c(0, 1), size = nrow(segTabs), replace = TRUE)
cn &lt;- read_copynumber(segTabs,
  seg_cols = c("chromosome", "start", "end", "segVal"),
  genome_measure = "wg", complement = TRUE, add_loh = TRUE
)

df &lt;- get_pLOH_score(cn)
df

df2 &lt;- get_pLOH_score(cn@data)
df2

</code></pre>

<hr>
<h2 id='get_shannon_diversity_index'>Get Shannon Diversity Index for Signatures</h2><span id='topic+get_shannon_diversity_index'></span>

<h3>Description</h3>

<p style="text-align: center;"><code class="reqn">H = - \sum_{i=1}^n{p_i ln(p_i)}</code>
</p>

<p>where <code>n</code> is the number
of signatures identified in the signature with exposure &gt; <code>cutoff</code>,
and <code>pi</code> is the normalized exposure of the ith signature with
exposure &gt; <code>cutoff</code>. Exposures of signatures were normalized to
sum to <code>1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_shannon_diversity_index(rel_expo, cutoff = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_shannon_diversity_index_+3A_rel_expo">rel_expo</code></td>
<td>
<p>a <code>data.frame</code> with numeric columns indicating
<strong>relative</strong> signature exposures for each sample. Typically
this data can be obtained from <code><a href="#topic+get_sig_exposure">get_sig_exposure()</a></code>.</p>
</td></tr>
<tr><td><code id="get_shannon_diversity_index_+3A_cutoff">cutoff</code></td>
<td>
<p>a relative exposure cutoff for filtering signatures,
default is <code style="white-space: pre;">&#8288;0.1%&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>


<h3>References</h3>

<p>Steele, Christopher D., et al. &quot;Undifferentiated sarcomas develop through distinct evolutionary pathways.&quot; Cancer Cell 35.3 (2019): 441-456.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load mutational signature
load(system.file("extdata", "toy_mutational_signature.RData",
  package = "sigminer", mustWork = TRUE
))
# Get signature exposure
rel_expo &lt;- get_sig_exposure(sig2, type = "relative")
rel_expo
diversity_index &lt;- get_shannon_diversity_index(rel_expo)
diversity_index
</code></pre>

<hr>
<h2 id='get_sig_cancer_type_index'>Obtain Signature Index for Cancer Types</h2><span id='topic+get_sig_cancer_type_index'></span>

<h3>Description</h3>

<p>Obtain Signature Index for Cancer Types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sig_cancer_type_index(
  sig_type = c("legacy", "SBS", "DBS", "ID"),
  seq_type = c("WGS", "WES"),
  source = c("PCAWG", "TCGA", "nonPCAWG"),
  keyword = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sig_cancer_type_index_+3A_sig_type">sig_type</code></td>
<td>
<p>signature type.</p>
</td></tr>
<tr><td><code id="get_sig_cancer_type_index_+3A_seq_type">seq_type</code></td>
<td>
<p>sequencing type.</p>
</td></tr>
<tr><td><code id="get_sig_cancer_type_index_+3A_source">source</code></td>
<td>
<p>data source.</p>
</td></tr>
<tr><td><code id="get_sig_cancer_type_index_+3A_keyword">keyword</code></td>
<td>
<p>keyword to search in the signature index database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l1 &lt;- get_sig_cancer_type_index()
l2 &lt;- get_sig_cancer_type_index(sig_type = "SBS")
l3 &lt;- get_sig_cancer_type_index(sig_type = "DBS", source = "PCAWG", seq_type = "WGS")
l4 &lt;- get_sig_cancer_type_index(sig_type = "ID")
l5 &lt;- get_sig_cancer_type_index(keyword = "breast")
l1
l2
l3
l4
l5
</code></pre>

<hr>
<h2 id='get_sig_db'>Get Curated Reference Signature Database</h2><span id='topic+get_sig_db'></span>

<h3>Description</h3>

<p>Reference mutational signatures and their aetiologies,
mainly obtained from COSMIC database
(SigProfiler results) and cleaned before saving into
<strong>sigminer</strong> package. You can obtain:
</p>

<ul>
<li><p> COSMIC legacy SBS signatures.
</p>
</li>
<li><p> COSMIC v3 SBS signatures.
</p>
</li>
<li><p> COSMIC v3 DBS signatures.
</p>
</li>
<li><p> COSMIC v3 ID (indel) signatures.
</p>
</li>
<li><p> SBS and RS (rearrangement) signatures from Nik lab 2020 Nature Cancer paper.
</p>
</li>
<li><p> RS signatures from BRCA560 and USARC cohorts.
</p>
</li>
<li><p> Copy number signatures from USARC cohort and TCGA.
</p>
</li>
<li><p> Copy number signatures from Liu lab 2023. It supports both PCAWG and TCGA cohort.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>get_sig_db(sig_db = "legacy")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sig_db_+3A_sig_db">sig_db</code></td>
<td>
<p>default 'legacy', it can be 'legacy' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures_v2.tt/">COSMIC v2 'SBS'</a>),
'SBS', 'DBS', 'ID' and 'TSB' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures/">COSMIV v3.1 signatures</a>)
for small scale mutations.
For more specific details, it can also be 'SBS_hg19', 'SBS_hg38',
'SBS_mm9', 'SBS_mm10', 'DBS_hg19', 'DBS_hg38', 'DBS_mm9', 'DBS_mm10' to use
COSMIC v3 reference signatures from Alexandrov, Ludmil B., et al. (2020) (reference #1).
In addition, it can be one of &quot;SBS_Nik_lab_Organ&quot;, &quot;RS_Nik_lab_Organ&quot;,
&quot;SBS_Nik_lab&quot;, &quot;RS_Nik_lab&quot; to refer reference signatures from
Degasperi, Andrea, et al. (2020) (reference #2);
&quot;RS_BRCA560&quot;, &quot;RS_USARC&quot; to reference signatures from BRCA560 and USARC cohorts;
&quot;CNS_USARC&quot; (40 categories), &quot;CNS_TCGA&quot; (48 categories) to reference copy number signatures from USARC cohort and TCGA;
&quot;CNS_TCGA176&quot; (176 categories) and &quot;CNS_PCAWG176&quot; (176 categories) to reference copy number signatures from PCAWG and TCGA separately.
<strong>UPDATE</strong>, the latest version of reference version can be automatically
downloaded and loaded from <a href="https://cancer.sanger.ac.uk/signatures/downloads/">https://cancer.sanger.ac.uk/signatures/downloads/</a>
when a option with <code>latest_</code> prefix is specified (e.g. &quot;latest_SBS_GRCh37&quot;).
<strong>Note</strong>: the signature profile for different genome builds are basically same.
And specific database (e.g. 'SBS_mm10') contains less signatures than all COSMIC
signatures (because some signatures are not detected from Alexandrov, Ludmil B., et al. (2020)).
For all available options, check the parameter setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Steele, Christopher D., et al. &quot;Signatures of copy number alterations in human cancer.&quot; Nature 606.7916 (2022): 984-991.
</p>
</li>
<li><p> Alexandrov, Ludmil B., et al. &quot;The repertoire of mutational signatures in human cancer.&quot; Nature 578.7793 (2020): 94-101.
</p>
</li>
<li><p> Steele, Christopher D., et al. &quot;Undifferentiated sarcomas develop through distinct evolutionary pathways.&quot; Cancer Cell 35.3 (2019): 441-456.
</p>
</li>
<li><p> Ziyu Tao, et al. &quot;The repertoire of copy number alteration signatures in human cancer.&quot; Briefings in Bioinformatics (2023): bbad053.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+get_sig_similarity">get_sig_similarity</a>, <a href="#topic+sig_fit">sig_fit</a> and <a href="#topic+show_cosmic_sig_profile">show_cosmic_sig_profile</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- get_sig_db()
s2 &lt;- get_sig_db("SBS")
s3 &lt;- get_sig_db("DBS")
s4 &lt;- get_sig_db("DBS_mm10")
s5 &lt;- get_sig_db("SBS_Nik_lab")
s6 &lt;- get_sig_db("ID")
s7 &lt;- get_sig_db("RS_BRCA560")
s8 &lt;- get_sig_db("RS_USARC")
s9 &lt;- get_sig_db("RS_Nik_lab")
s10 &lt;- get_sig_db("CNS_USARC")
s11 &lt;- get_sig_db("CNS_TCGA")
s12 &lt;- get_sig_db("CNS_TCGA176")
s13 &lt;- get_sig_db("CNS_PCAWG176")
s1
s2
s3
s4
s5
s6
s7
s8
s9
s10
s11
s12
s13
</code></pre>

<hr>
<h2 id='get_sig_exposure'>Get Signature Exposure from 'Signature' Object</h2><span id='topic+get_sig_exposure'></span>

<h3>Description</h3>

<p>The expected number of mutations (or copy number segment records) with each signature was
determined after a scaling transformation V ~ WH = W'H' where W' = WU' and H' = UH.
The scaling matrix U is a KxK diagnal matrix (K is signature number, U' is the inverse of U)
with the element corresponding to the L1-norm of column vectors of W
(ie. the sum of the elements of the vector). As a result, the k-th row vector of the final
matrix H' represents the absolute exposure (activity) of the k-th process across samples
(e.g., for SBS, the estimated (or expected) number of mutations generated by the k-th process).
Of note, for copy number signatures, only components of feature CN was used for calculating H'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sig_exposure(
  Signature,
  type = c("absolute", "relative"),
  rel_threshold = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sig_exposure_+3A_signature">Signature</code></td>
<td>
<p>a <code>Signature</code> object obtained either from <a href="#topic+sig_extract">sig_extract</a> or <a href="#topic+sig_auto_extract">sig_auto_extract</a>,
or just a raw exposure matrix with column representing samples (patients) and row
representing signatures.</p>
</td></tr>
<tr><td><code id="get_sig_exposure_+3A_type">type</code></td>
<td>
<p>'absolute' for signature exposure and 'relative' for signature relative exposure.</p>
</td></tr>
<tr><td><code id="get_sig_exposure_+3A_rel_threshold">rel_threshold</code></td>
<td>
<p>only used when type is 'relative', relative exposure less
than (<code>&lt;=</code>) this value will be set to 0 and thus all signature exposures
may not sum to 1. This is similar to this argument in <a href="#topic+sig_fit">sig_fit</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.table</code>
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang <a href="mailto:w_shixiang@163.com">w_shixiang@163.com</a>
</p>


<h3>References</h3>

<p>Kim, Jaegil, et al. &quot;Somatic ERCC2 mutations are associated with a distinct genomic signature in urothelial tumors.&quot;
Nature genetics 48.6 (2016): 600.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load mutational signature
load(system.file("extdata", "toy_mutational_signature.RData",
  package = "sigminer", mustWork = TRUE
))
# Get signature exposure
expo1 &lt;- get_sig_exposure(sig2)
expo1
expo2 &lt;- get_sig_exposure(sig2, type = "relative")
expo2
</code></pre>

<hr>
<h2 id='get_sig_feature_association'>Calculate Association between Signature Exposures and Other Features</h2><span id='topic+get_sig_feature_association'></span>

<h3>Description</h3>

<p>Association of signature exposures with other features will be performed using one of two procedures:
for a continuous association variable (including ordinal variable), correaltion is performed;
for a binary association variable, samples will be divided into two groups and Mann-Whitney U-test
is performed to test for differences in signature exposure medians between the two groups.
See <a href="#topic+get_tidy_association">get_tidy_association</a> for cleaning association result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sig_feature_association(
  data,
  cols_to_sigs,
  cols_to_features,
  type = "ca",
  method_co = c("spearman", "pearson", "kendall"),
  method_ca = stats::wilcox.test,
  min_n = 0.01,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sig_feature_association_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> contains signature exposures and other features</p>
</td></tr>
<tr><td><code id="get_sig_feature_association_+3A_cols_to_sigs">cols_to_sigs</code></td>
<td>
<p>colnames for signature exposure</p>
</td></tr>
<tr><td><code id="get_sig_feature_association_+3A_cols_to_features">cols_to_features</code></td>
<td>
<p>colnames for other features</p>
</td></tr>
<tr><td><code id="get_sig_feature_association_+3A_type">type</code></td>
<td>
<p>a character vector containing 'ca' for categorical variable and 'co' for continuous variable,
it must have the same length as <code>cols_to_features</code>.</p>
</td></tr>
<tr><td><code id="get_sig_feature_association_+3A_method_co">method_co</code></td>
<td>
<p>method for continuous variable, default is &quot;spearman&quot;, could also be &quot;pearson&quot; and &quot;kendall&quot;.</p>
</td></tr>
<tr><td><code id="get_sig_feature_association_+3A_method_ca">method_ca</code></td>
<td>
<p>method for categorical variable, default is &quot;wilcox.test&quot;</p>
</td></tr>
<tr><td><code id="get_sig_feature_association_+3A_min_n">min_n</code></td>
<td>
<p>a minimal fraction (e.g. 0.01) or a integer number (e.g. 10) for filtering some variables with few positive events.
Default is 0.01.</p>
</td></tr>
<tr><td><code id="get_sig_feature_association_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print extra message.</p>
</td></tr>
<tr><td><code id="get_sig_feature_association_+3A_...">...</code></td>
<td>
<p>other arguments passing to test functions, like <code>cor.test</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code>. For 'co' features, 'measure' means correlation coefficient.
For 'ca' features, 'measure' means difference in means of signature exposure.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_tidy_association">get_tidy_association</a>
</p>

<hr>
<h2 id='get_sig_rec_similarity'>Get Reconstructed Profile Cosine Similarity, RSS, etc.</h2><span id='topic+get_sig_rec_similarity'></span>

<h3>Description</h3>

<p>See <a href="#topic+bp_extract_signatures">bp_extract_signatures</a> for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sig_rec_similarity(Signature, nmf_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sig_rec_similarity_+3A_signature">Signature</code></td>
<td>
<p>a <code>Signature</code> object.</p>
</td></tr>
<tr><td><code id="get_sig_rec_similarity_+3A_nmf_matrix">nmf_matrix</code></td>
<td>
<p>a <code>matrix</code> used for NMF decomposition with rows indicate samples and columns indicate components.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.table</code>.
</p>

<hr>
<h2 id='get_sig_similarity'>Calculate Similarity between Identified Signatures and Reference Signatures</h2><span id='topic+get_sig_similarity'></span>

<h3>Description</h3>

<p>The reference signatures can be either a <code>Signature</code> object specified by <code>Ref</code> argument
or known COSMIC signatures specified by <code>sig_db</code> argument.
Two COSMIC databases are used for comparisons - &quot;legacy&quot; which includes 30 signaures,
and &quot;SBS&quot; - which includes updated/refined 65 signatures. This function is modified
from <code>compareSignatures()</code> in <strong>maftools</strong> package.
<strong>NOTE</strong>: all reference signatures are generated from gold standard tool:
SigProfiler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sig_similarity(
  Signature,
  Ref = NULL,
  sig_db = c("SBS", "legacy", "DBS", "ID", "TSB", "SBS_Nik_lab", "RS_Nik_lab",
    "RS_BRCA560", "RS_USARC", "CNS_USARC", "CNS_TCGA", "CNS_TCGA176", "CNS_PCAWG176",
    "SBS_hg19", "SBS_hg38", "SBS_mm9", "SBS_mm10", "DBS_hg19", "DBS_hg38", "DBS_mm9",
    "DBS_mm10", "SBS_Nik_lab_Organ", "RS_Nik_lab_Organ", "latest_SBS_GRCh37",
    "latest_DBS_GRCh37", "latest_ID_GRCh37", "latest_SBS_GRCh38", "latest_DBS_GRCh38",
    "latest_SBS_mm9", "latest_DBS_mm9", "latest_SBS_mm10", "latest_DBS_mm10",
    "latest_SBS_rn6", "latest_DBS_rn6", "latest_CN_GRCh37", 
    
    "latest_RNA-SBS_GRCh37", "latest_SV_GRCh38"),
  db_type = c("", "human-exome", "human-genome"),
  method = "cosine",
  normalize = c("row", "feature"),
  feature_setting = sigminer::CN.features,
  set_order = TRUE,
  pattern_to_rm = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sig_similarity_+3A_signature">Signature</code></td>
<td>
<p>a <code>Signature</code> object or a component-by-signature matrix/<code>data.frame</code>
(sum of each column is 1) or a normalized component-by-sample matrix/<code>data.frame</code>
(sum of each column is 1).
More please see examples.</p>
</td></tr>
<tr><td><code id="get_sig_similarity_+3A_ref">Ref</code></td>
<td>
<p>default is <code>NULL</code>, can be a same object as <code>Signature</code>.</p>
</td></tr>
<tr><td><code id="get_sig_similarity_+3A_sig_db">sig_db</code></td>
<td>
<p>default 'legacy', it can be 'legacy' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures_v2.tt/">COSMIC v2 'SBS'</a>),
'SBS', 'DBS', 'ID' and 'TSB' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures/">COSMIV v3.1 signatures</a>)
for small scale mutations.
For more specific details, it can also be 'SBS_hg19', 'SBS_hg38',
'SBS_mm9', 'SBS_mm10', 'DBS_hg19', 'DBS_hg38', 'DBS_mm9', 'DBS_mm10' to use
COSMIC v3 reference signatures from Alexandrov, Ludmil B., et al. (2020) (reference #1).
In addition, it can be one of &quot;SBS_Nik_lab_Organ&quot;, &quot;RS_Nik_lab_Organ&quot;,
&quot;SBS_Nik_lab&quot;, &quot;RS_Nik_lab&quot; to refer reference signatures from
Degasperi, Andrea, et al. (2020) (reference #2);
&quot;RS_BRCA560&quot;, &quot;RS_USARC&quot; to reference signatures from BRCA560 and USARC cohorts;
&quot;CNS_USARC&quot; (40 categories), &quot;CNS_TCGA&quot; (48 categories) to reference copy number signatures from USARC cohort and TCGA;
&quot;CNS_TCGA176&quot; (176 categories) and &quot;CNS_PCAWG176&quot; (176 categories) to reference copy number signatures from PCAWG and TCGA separately.
<strong>UPDATE</strong>, the latest version of reference version can be automatically
downloaded and loaded from <a href="https://cancer.sanger.ac.uk/signatures/downloads/">https://cancer.sanger.ac.uk/signatures/downloads/</a>
when a option with <code>latest_</code> prefix is specified (e.g. &quot;latest_SBS_GRCh37&quot;).
<strong>Note</strong>: the signature profile for different genome builds are basically same.
And specific database (e.g. 'SBS_mm10') contains less signatures than all COSMIC
signatures (because some signatures are not detected from Alexandrov, Ludmil B., et al. (2020)).
For all available options, check the parameter setting.</p>
</td></tr>
<tr><td><code id="get_sig_similarity_+3A_db_type">db_type</code></td>
<td>
<p>only used when <code>sig_db</code> is enabled.
&quot;&quot; for keeping default, &quot;human-exome&quot; for transforming to exome frequency of component,
and &quot;human-genome&quot; for transforming to whole genome frequency of component.
Currently only works for 'SBS'.</p>
</td></tr>
<tr><td><code id="get_sig_similarity_+3A_method">method</code></td>
<td>
<p>default is 'cosine' for cosine similarity.</p>
</td></tr>
<tr><td><code id="get_sig_similarity_+3A_normalize">normalize</code></td>
<td>
<p>one of &quot;row&quot; and &quot;feature&quot;. &quot;row&quot; is typically used
for common mutational signatures. &quot;feature&quot; is designed by me to use when input
are copy number signatures.</p>
</td></tr>
<tr><td><code id="get_sig_similarity_+3A_feature_setting">feature_setting</code></td>
<td>
<p>a <code>data.frame</code> used for classification.
<strong>Only used when method is &quot;Wang&quot; (&quot;W&quot;)</strong>.
Default is <a href="#topic+CN.features">CN.features</a>. Users can also set custom input with &quot;feature&quot;,
&quot;min&quot; and &quot;max&quot; columns available. Valid features can be printed by
<code>unique(CN.features$feature)</code>.</p>
</td></tr>
<tr><td><code id="get_sig_similarity_+3A_set_order">set_order</code></td>
<td>
<p>if <code>TRUE</code>, order the return similarity matrix.</p>
</td></tr>
<tr><td><code id="get_sig_similarity_+3A_pattern_to_rm">pattern_to_rm</code></td>
<td>
<p>patterns for removing some features/components in similarity
calculation. A vector of component name is also accepted.
The remove operation will be done after normalization. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_sig_similarity_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print extra info.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> containing smilarities, aetiologies if available, best match and RSS.
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang <a href="mailto:w_shixiang@163.com">w_shixiang@163.com</a>
</p>


<h3>References</h3>

<p>Alexandrov, Ludmil B., et al. &quot;The repertoire of mutational signatures in human cancer.&quot; Nature 578.7793 (2020): 94-101.
</p>
<p>Degasperi, Andrea, et al. &quot;A practical framework and online tool for mutational signature analyses show intertissue variation and driver dependencies.&quot; Nature cancer 1.2 (2020): 249-263.
</p>
<p>Steele, Christopher D., et al. &quot;Undifferentiated sarcomas develop through distinct evolutionary pathways.&quot; Cancer Cell 35.3 (2019): 441-456.
</p>
<p>Nik-Zainal, Serena, et al. &quot;Landscape of somatic mutations in 560 breast cancer whole-genome sequences.&quot; Nature 534.7605 (2016): 47-54.
</p>
<p>Steele, Christopher D., et al. &quot;Signatures of copy number alterations in human cancer.&quot; Nature 606.7916 (2022): 984-991.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load mutational signature
load(system.file("extdata", "toy_mutational_signature.RData",
  package = "sigminer", mustWork = TRUE
))

s1 &lt;- get_sig_similarity(sig2, Ref = sig2)
s1

s2 &lt;- get_sig_similarity(sig2)
s2
s3 &lt;- get_sig_similarity(sig2, sig_db = "SBS")
s3

# Set order for result similarity matrix
s4 &lt;- get_sig_similarity(sig2, sig_db = "SBS", set_order = TRUE)
s4

## Remove some components
## in similarity calculation
s5 &lt;- get_sig_similarity(sig2,
  Ref = sig2,
  pattern_to_rm = c("T[T&gt;G]C", "T[T&gt;G]G", "T[T&gt;G]T")
)
s5

## Same to DBS and ID signatures
x1 &lt;- get_sig_db("DBS_hg19")
x2 &lt;- get_sig_db("DBS_hg38")
s6 &lt;- get_sig_similarity(x1$db, x2$db)
s6
</code></pre>

<hr>
<h2 id='get_tidy_association'>Get Tidy Signature Association Results</h2><span id='topic+get_tidy_association'></span>

<h3>Description</h3>

<p>Get Tidy Signature Association Results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tidy_association(cor_res, p_adjust = FALSE, method = "fdr")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tidy_association_+3A_cor_res">cor_res</code></td>
<td>
<p>data returned by <code><a href="#topic+get_sig_feature_association">get_sig_feature_association()</a></code></p>
</td></tr>
<tr><td><code id="get_tidy_association_+3A_p_adjust">p_adjust</code></td>
<td>
<p>logical, if <code>TRUE</code>, adjust p values by data type.</p>
</td></tr>
<tr><td><code id="get_tidy_association_+3A_method">method</code></td>
<td>
<p>p value correction method, see <a href="stats.html#topic+p.adjust">stats::p.adjust</a> for
more detail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+get_sig_feature_association">get_sig_feature_association</a>
</p>

<hr>
<h2 id='group_enrichment'>General Group Enrichment Analysis</h2><span id='topic+group_enrichment'></span>

<h3>Description</h3>

<p>This function takes a <code>data.frame</code> as input, compares proportion of positive
cases or mean measure in one subgroup and the remaining samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_enrichment(
  df,
  grp_vars = NULL,
  enrich_vars = NULL,
  cross = TRUE,
  co_method = c("t.test", "wilcox.test"),
  ref_group = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_enrichment_+3A_df">df</code></td>
<td>
<p>a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="group_enrichment_+3A_grp_vars">grp_vars</code></td>
<td>
<p>character vector specifying group variables to split samples
into subgroups (at least 2 subgroups, otherwise this variable will be skipped).</p>
</td></tr>
<tr><td><code id="group_enrichment_+3A_enrich_vars">enrich_vars</code></td>
<td>
<p>character vector specifying measure variables to be compared.
If variable is not numeric, only binary cases are accepted in the form of
<code>TRUE/FALSE</code> or <code>P/N</code> (P for positive cases and N for negative cases).
Of note, <code>NA</code> values set to negative cases.</p>
</td></tr>
<tr><td><code id="group_enrichment_+3A_cross">cross</code></td>
<td>
<p>logical, default is <code>TRUE</code>, combine all situations provided by
<code>grp_vars</code> and <code>enrich_vars</code>. For examples, <code>c('A', 'B')</code> and <code>c('C', 'D')</code>
will construct 4 combinations(i.e. &quot;AC&quot;, &quot;AD&quot;, &quot;BC&quot; and &quot;BD&quot;). A variable can
not be in both <code>grp_vars</code> and <code>enrich_vars</code>, such cases will be automatically
drop. If <code>FALSE</code>, use pairwise combinations, see section &quot;examples&quot; for use cases.</p>
</td></tr>
<tr><td><code id="group_enrichment_+3A_co_method">co_method</code></td>
<td>
<p>test method for continuous variable, default is 't.test'.</p>
</td></tr>
<tr><td><code id="group_enrichment_+3A_ref_group">ref_group</code></td>
<td>
<p>reference group set in <code>grp_vars</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.table</code> with following columns:
</p>

<ul>
<li> <p><code>grp_var</code>: group variable name.
</p>
</li>
<li> <p><code>enrich_var</code>: enrich variable (variable to be compared) name.
</p>
</li>
<li> <p><code>grp1</code>: the first group name, should be a member in <code>grp_var</code> column.
</p>
</li>
<li> <p><code>grp2</code>: the remaining samples, marked as 'Rest'.
</p>
</li>
<li> <p><code>grp1_size</code>: sample size for <code>grp1</code>.
</p>
</li>
<li> <p><code>grp1_pos_measure</code>: for binary variable, it stores the proportion of
positive cases in <code>grp1</code>; for continuous variable, it stores mean value.
</p>
</li>
<li> <p><code>grp2_size</code>: sample size for <code>grp2</code>.
</p>
</li>
<li> <p><code>grp2_pos_measure</code>: same as <code>grp1_pos_measure</code> but for <code>grp2</code>.
</p>
</li>
<li> <p><code>measure_observed</code>: for binary variable, it stores odds ratio;
for continuous variable, it stores scaled mean ratio.
</p>
</li>
<li> <p><code>measure_tested</code>: only for binary variable, it stores
estimated odds ratio and its 95% CI from <code>fisher.test()</code>.
</p>
</li>
<li> <p><code>p_value</code>: for binary variable, it stores p value from <code>fisher.test()</code>;
for continuous variable, it stores value from <code>wilcox.test()</code> or <code>t.test()</code>.
</p>
</li>
<li> <p><code>type</code>: one of &quot;binary&quot; and &quot;continuous&quot;.
</p>
</li>
<li> <p><code>method</code>: one of &quot;fish.test&quot;, &quot;wilcox.test&quot; and &quot;t.test&quot;.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+show_group_enrichment">show_group_enrichment</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
df &lt;- dplyr::tibble(
  g1 = factor(abs(round(rnorm(99, 0, 1)))),
  g2 = rep(LETTERS[1:4], c(50, 40, 8, 1)),
  e1 = sample(c("P", "N"), 99, replace = TRUE),
  e2 = rnorm(99)
)

print(str(df))
print(head(df))

# Compare g1:e1, g1:e2, g2:e1 and g2:e2
x1 &lt;- group_enrichment(df, grp_vars = c("g1", "g2"), enrich_vars = c("e1", "e2"))
x1

# Only compare g1:e1, g2:e2
x2 &lt;- group_enrichment(df,
  grp_vars = c("g1", "g2"),
  enrich_vars = c("e1", "e2"),
  co_method = "wilcox.test",
  cross = FALSE
)
x2


# Visualization
p1 &lt;- show_group_enrichment(x1, fill_by_p_value = TRUE)
p1
p2 &lt;- show_group_enrichment(x1, fill_by_p_value = FALSE)
p2
p3 &lt;- show_group_enrichment(x1, return_list = TRUE)
p3

</code></pre>

<hr>
<h2 id='group_enrichment2'>Group Enrichment Analysis with Subsets</h2><span id='topic+group_enrichment2'></span>

<h3>Description</h3>

<p>More details see <code><a href="#topic+group_enrichment">group_enrichment()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_enrichment2(
  df,
  subset_var,
  grp_vars,
  enrich_vars,
  co_method = c("t.test", "wilcox.test"),
  ref_group = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_enrichment2_+3A_df">df</code></td>
<td>
<p>a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="group_enrichment2_+3A_subset_var">subset_var</code></td>
<td>
<p>a column for subsetting.</p>
</td></tr>
<tr><td><code id="group_enrichment2_+3A_grp_vars">grp_vars</code></td>
<td>
<p>character vector specifying group variables to split samples
into subgroups (at least 2 subgroups, otherwise this variable will be skipped).</p>
</td></tr>
<tr><td><code id="group_enrichment2_+3A_enrich_vars">enrich_vars</code></td>
<td>
<p>character vector specifying measure variables to be compared.
If variable is not numeric, only binary cases are accepted in the form of
<code>TRUE/FALSE</code> or <code>P/N</code> (P for positive cases and N for negative cases).
Of note, <code>NA</code> values set to negative cases.</p>
</td></tr>
<tr><td><code id="group_enrichment2_+3A_co_method">co_method</code></td>
<td>
<p>test method for continuous variable, default is 't.test'.</p>
</td></tr>
<tr><td><code id="group_enrichment2_+3A_ref_group">ref_group</code></td>
<td>
<p>reference group set in <code>grp_vars</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+show_group_enrichment">show_group_enrichment</a>
</p>

<hr>
<h2 id='handle_hyper_mutation'>Handle Hypermutant Samples</h2><span id='topic+handle_hyper_mutation'></span>

<h3>Description</h3>

<p>This can be used for SNV/INDEL count matrix. For copy number analysis,
please skip it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_hyper_mutation(nmf_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_hyper_mutation_+3A_nmf_matrix">nmf_matrix</code></td>
<td>
<p>a <code>matrix</code> used for NMF decomposition with rows indicate samples and columns indicate components.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>matrix</code>.
</p>


<h3>References</h3>

<p>Kim, Jaegil, et al. &quot;Somatic ERCC2 mutations are associated with a distinct genomic signature in urothelial tumors.&quot;
Nature genetics 48.6 (2016): 600.
</p>

<hr>
<h2 id='hello'>Say Hello to Users</h2><span id='topic+hello'></span>

<h3>Description</h3>

<p>Say Hello to Users
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hello()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>hello()
</code></pre>

<hr>
<h2 id='MAF-class'>Class MAF</h2><span id='topic+MAF-class'></span><span id='topic+MAF'></span>

<h3>Description</h3>

<p>S4 class for storing summarized MAF. It is from <code>maftools</code> package.
</p>


<h3>Details</h3>

<p>More about MAF object please see <a href="https://github.com/PoisonAlien/maftools">maftools</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>data.table of MAF file containing all non-synonymous variants.</p>
</dd>
<dt><code>variants.per.sample</code></dt><dd><p>table containing variants per sample</p>
</dd>
<dt><code>variant.type.summary</code></dt><dd><p>table containing variant types per sample</p>
</dd>
<dt><code>variant.classification.summary</code></dt><dd><p>table containing variant classification per sample</p>
</dd>
<dt><code>gene.summary</code></dt><dd><p>table containing variant classification per gene</p>
</dd>
<dt><code>summary</code></dt><dd><p>table with basic MAF summary stats</p>
</dd>
<dt><code>maf.silent</code></dt><dd><p>subset of main MAF containing only silent variants</p>
</dd>
<dt><code>clinical.data</code></dt><dd><p>clinical data associated with each sample/Tumor_Sample_Barcode in MAF.</p>
</dd>
</dl>

<hr>
<h2 id='output_bootstrap'>Output Signature Bootstrap Fitting Results</h2><span id='topic+output_bootstrap'></span>

<h3>Description</h3>

<p>Output Signature Bootstrap Fitting Results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output_bootstrap(x, result_dir, mut_type = "SBS", sig_db = mut_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output_bootstrap_+3A_x">x</code></td>
<td>
<p>result from <a href="#topic+sig_fit_bootstrap_batch">sig_fit_bootstrap_batch</a>.</p>
</td></tr>
<tr><td><code id="output_bootstrap_+3A_result_dir">result_dir</code></td>
<td>
<p>a result directory.</p>
</td></tr>
<tr><td><code id="output_bootstrap_+3A_mut_type">mut_type</code></td>
<td>
<p>one of 'SBS', 'DBS', 'ID' or 'CN'.</p>
</td></tr>
<tr><td><code id="output_bootstrap_+3A_sig_db">sig_db</code></td>
<td>
<p>default 'legacy', it can be 'legacy' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures_v2.tt/">COSMIC v2 'SBS'</a>),
'SBS', 'DBS', 'ID' and 'TSB' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures/">COSMIV v3.1 signatures</a>)
for small scale mutations.
For more specific details, it can also be 'SBS_hg19', 'SBS_hg38',
'SBS_mm9', 'SBS_mm10', 'DBS_hg19', 'DBS_hg38', 'DBS_mm9', 'DBS_mm10' to use
COSMIC v3 reference signatures from Alexandrov, Ludmil B., et al. (2020) (reference #1).
In addition, it can be one of &quot;SBS_Nik_lab_Organ&quot;, &quot;RS_Nik_lab_Organ&quot;,
&quot;SBS_Nik_lab&quot;, &quot;RS_Nik_lab&quot; to refer reference signatures from
Degasperi, Andrea, et al. (2020) (reference #2);
&quot;RS_BRCA560&quot;, &quot;RS_USARC&quot; to reference signatures from BRCA560 and USARC cohorts;
&quot;CNS_USARC&quot; (40 categories), &quot;CNS_TCGA&quot; (48 categories) to reference copy number signatures from USARC cohort and TCGA;
&quot;CNS_TCGA176&quot; (176 categories) and &quot;CNS_PCAWG176&quot; (176 categories) to reference copy number signatures from PCAWG and TCGA separately.
<strong>UPDATE</strong>, the latest version of reference version can be automatically
downloaded and loaded from <a href="https://cancer.sanger.ac.uk/signatures/downloads/">https://cancer.sanger.ac.uk/signatures/downloads/</a>
when a option with <code>latest_</code> prefix is specified (e.g. &quot;latest_SBS_GRCh37&quot;).
<strong>Note</strong>: the signature profile for different genome builds are basically same.
And specific database (e.g. 'SBS_mm10') contains less signatures than all COSMIC
signatures (because some signatures are not detected from Alexandrov, Ludmil B., et al. (2020)).
For all available options, check the parameter setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>

<hr>
<h2 id='output_fit'>Output Signature Fitting Results</h2><span id='topic+output_fit'></span>

<h3>Description</h3>

<p>Output Signature Fitting Results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output_fit(x, result_dir, mut_type = "SBS", sig_db = mut_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output_fit_+3A_x">x</code></td>
<td>
<p>result from <a href="#topic+sig_fit">sig_fit</a>.</p>
</td></tr>
<tr><td><code id="output_fit_+3A_result_dir">result_dir</code></td>
<td>
<p>a result directory.</p>
</td></tr>
<tr><td><code id="output_fit_+3A_mut_type">mut_type</code></td>
<td>
<p>one of 'SBS', 'DBS', 'ID' or 'CN'.</p>
</td></tr>
<tr><td><code id="output_fit_+3A_sig_db">sig_db</code></td>
<td>
<p>default 'legacy', it can be 'legacy' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures_v2.tt/">COSMIC v2 'SBS'</a>),
'SBS', 'DBS', 'ID' and 'TSB' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures/">COSMIV v3.1 signatures</a>)
for small scale mutations.
For more specific details, it can also be 'SBS_hg19', 'SBS_hg38',
'SBS_mm9', 'SBS_mm10', 'DBS_hg19', 'DBS_hg38', 'DBS_mm9', 'DBS_mm10' to use
COSMIC v3 reference signatures from Alexandrov, Ludmil B., et al. (2020) (reference #1).
In addition, it can be one of &quot;SBS_Nik_lab_Organ&quot;, &quot;RS_Nik_lab_Organ&quot;,
&quot;SBS_Nik_lab&quot;, &quot;RS_Nik_lab&quot; to refer reference signatures from
Degasperi, Andrea, et al. (2020) (reference #2);
&quot;RS_BRCA560&quot;, &quot;RS_USARC&quot; to reference signatures from BRCA560 and USARC cohorts;
&quot;CNS_USARC&quot; (40 categories), &quot;CNS_TCGA&quot; (48 categories) to reference copy number signatures from USARC cohort and TCGA;
&quot;CNS_TCGA176&quot; (176 categories) and &quot;CNS_PCAWG176&quot; (176 categories) to reference copy number signatures from PCAWG and TCGA separately.
<strong>UPDATE</strong>, the latest version of reference version can be automatically
downloaded and loaded from <a href="https://cancer.sanger.ac.uk/signatures/downloads/">https://cancer.sanger.ac.uk/signatures/downloads/</a>
when a option with <code>latest_</code> prefix is specified (e.g. &quot;latest_SBS_GRCh37&quot;).
<strong>Note</strong>: the signature profile for different genome builds are basically same.
And specific database (e.g. 'SBS_mm10') contains less signatures than all COSMIC
signatures (because some signatures are not detected from Alexandrov, Ludmil B., et al. (2020)).
For all available options, check the parameter setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>

<hr>
<h2 id='output_sig'>Output Signature Results</h2><span id='topic+output_sig'></span>

<h3>Description</h3>

<p>Output Signature Results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output_sig(sig, result_dir, mut_type = "SBS", sig_db = mut_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output_sig_+3A_sig">sig</code></td>
<td>
<p>a <code>Signature</code> object.</p>
</td></tr>
<tr><td><code id="output_sig_+3A_result_dir">result_dir</code></td>
<td>
<p>a result directory.</p>
</td></tr>
<tr><td><code id="output_sig_+3A_mut_type">mut_type</code></td>
<td>
<p>one of 'SBS', 'DBS', 'ID' or 'CN'.</p>
</td></tr>
<tr><td><code id="output_sig_+3A_sig_db">sig_db</code></td>
<td>
<p>default 'legacy', it can be 'legacy' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures_v2.tt/">COSMIC v2 'SBS'</a>),
'SBS', 'DBS', 'ID' and 'TSB' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures/">COSMIV v3.1 signatures</a>)
for small scale mutations.
For more specific details, it can also be 'SBS_hg19', 'SBS_hg38',
'SBS_mm9', 'SBS_mm10', 'DBS_hg19', 'DBS_hg38', 'DBS_mm9', 'DBS_mm10' to use
COSMIC v3 reference signatures from Alexandrov, Ludmil B., et al. (2020) (reference #1).
In addition, it can be one of &quot;SBS_Nik_lab_Organ&quot;, &quot;RS_Nik_lab_Organ&quot;,
&quot;SBS_Nik_lab&quot;, &quot;RS_Nik_lab&quot; to refer reference signatures from
Degasperi, Andrea, et al. (2020) (reference #2);
&quot;RS_BRCA560&quot;, &quot;RS_USARC&quot; to reference signatures from BRCA560 and USARC cohorts;
&quot;CNS_USARC&quot; (40 categories), &quot;CNS_TCGA&quot; (48 categories) to reference copy number signatures from USARC cohort and TCGA;
&quot;CNS_TCGA176&quot; (176 categories) and &quot;CNS_PCAWG176&quot; (176 categories) to reference copy number signatures from PCAWG and TCGA separately.
<strong>UPDATE</strong>, the latest version of reference version can be automatically
downloaded and loaded from <a href="https://cancer.sanger.ac.uk/signatures/downloads/">https://cancer.sanger.ac.uk/signatures/downloads/</a>
when a option with <code>latest_</code> prefix is specified (e.g. &quot;latest_SBS_GRCh37&quot;).
<strong>Note</strong>: the signature profile for different genome builds are basically same.
And specific database (e.g. 'SBS_mm10') contains less signatures than all COSMIC
signatures (because some signatures are not detected from Alexandrov, Ludmil B., et al. (2020)).
For all available options, check the parameter setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>

<hr>
<h2 id='output_tally'>Output Tally Result in Barplots</h2><span id='topic+output_tally'></span>

<h3>Description</h3>

<p>Output Tally Result in Barplots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output_tally(x, result_dir, mut_type = "SBS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output_tally_+3A_x">x</code></td>
<td>
<p>a matrix with row representing components (motifs) and column
representing samples.</p>
</td></tr>
<tr><td><code id="output_tally_+3A_result_dir">result_dir</code></td>
<td>
<p>a result directory.</p>
</td></tr>
<tr><td><code id="output_tally_+3A_mut_type">mut_type</code></td>
<td>
<p>one of 'SBS', 'DBS', 'ID' or 'CN'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>

<hr>
<h2 id='read_copynumber'>Read Absolute Copy Number Profile</h2><span id='topic+read_copynumber'></span>

<h3>Description</h3>

<p>Read <strong>absolute</strong> copy number profile for preparing CNV signature
analysis. See detail part of <code><a href="#topic+sig_tally">sig_tally()</a></code> to see how to handle sex to get correct
summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_copynumber(
  input,
  pattern = NULL,
  ignore_case = FALSE,
  seg_cols = c("Chromosome", "Start.bp", "End.bp", "modal_cn"),
  samp_col = "sample",
  add_loh = FALSE,
  loh_min_len = 10000,
  loh_min_frac = 0.05,
  join_adj_seg = TRUE,
  skip_annotation = FALSE,
  use_all = add_loh,
  min_segnum = 0L,
  max_copynumber = 20L,
  genome_build = c("hg19", "hg38", "T2T", "mm10", "mm9", "ce11"),
  genome_measure = c("called", "wg"),
  complement = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_copynumber_+3A_input">input</code></td>
<td>
<p>a <code>data.frame</code> or a file or a directory contains copy number profile.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_pattern">pattern</code></td>
<td>
<p>an optional regular expression used to select part of files if
<code>input</code> is a directory, more detail please see <code><a href="base.html#topic+list.files">list.files()</a></code> function.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_ignore_case">ignore_case</code></td>
<td>
<p>logical. Should pattern-matching be case-insensitive?</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_seg_cols">seg_cols</code></td>
<td>
<p>four strings used to specify chromosome, start position,
end position and copy number value in <code>input</code>, respectively.
Default use names from ABSOLUTE calling result.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_samp_col">samp_col</code></td>
<td>
<p>a character used to specify the sample column name. If <code>input</code>
is a directory and cannot find <code>samp_col</code>, sample names will use file names
(set this parameter to <code>NULL</code> is recommended in this case).</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_add_loh">add_loh</code></td>
<td>
<p>if <code>TRUE</code>, add LOH labels to segments. <strong>NOTE</strong> a column
'minor_cn' must exist to indicate minor allele copy number value.
Sex chromosome will not be labeled.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_loh_min_len">loh_min_len</code></td>
<td>
<p>The length cut-off for labeling a segment as 'LOH'.
Default is <code style="white-space: pre;">&#8288;10Kb&#8288;</code>.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_loh_min_frac">loh_min_frac</code></td>
<td>
<p>When <code>join_adj_seg</code> set to <code>TRUE</code>, only the length fraction
of LOH region is larger than this value will be labeled as 'LOH'.
Default is 30%.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_join_adj_seg">join_adj_seg</code></td>
<td>
<p>if <code>TRUE</code> (default), join adjacent segments with
same copy number value. This is helpful for precisely count the number of breakpoint.
When set <code>use_all=TRUE</code>, the mean function will be applied to extra numeric columns
and unique string columns will be pasted by comma for joined records.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_skip_annotation">skip_annotation</code></td>
<td>
<p>if <code>TRUE</code>, skip annotation step, it may affect some analysis
and visualization functionality, but speed up reading data.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_use_all">use_all</code></td>
<td>
<p>default is <code>FALSE</code>. If <code>True</code>, use all columns from raw input.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_min_segnum">min_segnum</code></td>
<td>
<p>minimal number of copy number segments within a sample.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_max_copynumber">max_copynumber</code></td>
<td>
<p>bigger copy number within a sample will be reset to this value.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_genome_build">genome_build</code></td>
<td>
<p>genome build version, should be 'hg19', 'hg38', 'mm9' or 'mm10'.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_genome_measure">genome_measure</code></td>
<td>
<p>default is 'called', can be 'wg' or 'called'.
Set 'called' will use called segments size to compute total size for CNA burden calculation,
this option is useful for WES and target sequencing.
Set 'wg' will use autosome size from genome build, this option is useful for WGS, SNP etc..</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_complement">complement</code></td>
<td>
<p>if <code>TRUE</code>, complement chromosome (except 'Y') does not show in input data
with normal copy 2.</p>
</td></tr>
<tr><td><code id="read_copynumber_+3A_...">...</code></td>
<td>
<p>other parameters pass to <code><a href="data.table.html#topic+fread">data.table::fread()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="#topic+CopyNumber">CopyNumber</a> object.
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang <a href="mailto:w_shixiang@163.com">w_shixiang@163.com</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+read_maf">read_maf</a> for reading mutation data to <a href="#topic+MAF">MAF</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load toy dataset of absolute copynumber profile
load(system.file("extdata", "toy_segTab.RData",
  package = "sigminer", mustWork = TRUE
))


cn &lt;- read_copynumber(segTabs,
  seg_cols = c("chromosome", "start", "end", "segVal"),
  genome_build = "hg19", complement = FALSE
)
cn
cn_subset &lt;- subset(cn, sample == "TCGA-DF-A2KN-01A-11D-A17U-01")

# Add LOH
set.seed(1234)
segTabs$minor_cn &lt;- sample(c(0, 1), size = nrow(segTabs), replace = TRUE)
cn &lt;- read_copynumber(segTabs,
  seg_cols = c("chromosome", "start", "end", "segVal"),
  genome_measure = "wg", complement = TRUE, add_loh = TRUE
)
# Use tally method "S" (Steele et al.)
tally_s &lt;- sig_tally(cn, method = "S")

tab_file &lt;- system.file("extdata", "metastatic_tumor.segtab.txt",
  package = "sigminer", mustWork = TRUE
)
cn2 &lt;- read_copynumber(tab_file)
cn2

</code></pre>

<hr>
<h2 id='read_copynumber_ascat'>Read Copy Number Data from ASCAT Result Files</h2><span id='topic+read_copynumber_ascat'></span>

<h3>Description</h3>

<p>Note, the result is not a <code>CopyNumber</code> object, you need to generate it
by yourself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_copynumber_ascat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_copynumber_ascat_+3A_x">x</code></td>
<td>
<p>one or more <code>.rds</code> format files which contains <code>ASCAT</code> object from result of <code>ascat.runAscat()</code>
in <a href="https://github.com/VanLoo-lab/ascat"><strong>ASCAT</strong></a> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tidy <code>list</code>.
</p>

<hr>
<h2 id='read_copynumber_seqz'>Read Absolute Copy Number Profile from Sequenza Result Directory</h2><span id='topic+read_copynumber_seqz'></span>

<h3>Description</h3>

<p>Read Absolute Copy Number Profile from Sequenza Result Directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_copynumber_seqz(target_dir, return_df = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_copynumber_seqz_+3A_target_dir">target_dir</code></td>
<td>
<p>a directory path.</p>
</td></tr>
<tr><td><code id="read_copynumber_seqz_+3A_return_df">return_df</code></td>
<td>
<p>if <code>TRUE</code>, return a <code>data.frame</code> directly, otherwise return a
<a href="#topic+CopyNumber">CopyNumber</a> object.</p>
</td></tr>
<tr><td><code id="read_copynumber_seqz_+3A_...">...</code></td>
<td>
<p>other parameters passing to <code><a href="#topic+read_copynumber">read_copynumber()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> or a <code>CopyNumber</code> object.
</p>

<hr>
<h2 id='read_maf'>Read MAF Files</h2><span id='topic+read_maf'></span><span id='topic+read_maf_minimal'></span>

<h3>Description</h3>

<p>This function is a wrapper of <a href="maftools.html#topic+read.maf">maftools::read.maf</a>.
Useless options in <a href="maftools.html#topic+read.maf">maftools::read.maf</a> are dropped here.
You can also use <a href="maftools.html#topic+read.maf">maftools::read.maf</a> to read the data.
All reference alleles and mutation alleles should be recorded in
positive strand format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_maf(maf, verbose = TRUE)

read_maf_minimal(dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_maf_+3A_maf">maf</code></td>
<td>
<p>tab delimited MAF file. File can also be gz compressed. Required. Alternatively, you can also provide already read MAF file as a dataframe.</p>
</td></tr>
<tr><td><code id="read_maf_+3A_verbose">verbose</code></td>
<td>
<p>TRUE logical. Default to be talkative and prints summary.</p>
</td></tr>
<tr><td><code id="read_maf_+3A_dt">dt</code></td>
<td>
<p>A data.frame contains at least the following columns:
&quot;Tumor_Sample_Barcode&quot;, &quot;Chromosome&quot;, &quot;Start_Position&quot;, &quot;End_Position&quot;, &quot;Reference_Allele&quot;, &quot;Tumor_Seq_Allele2&quot;</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>read_maf_minimal()</code>: Read Maf data.frame from a minimal maf-like data
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+read_copynumber">read_copynumber</a> for reading copy number data to <a href="#topic+CopyNumber">CopyNumber</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
laml.maf &lt;- system.file("extdata", "tcga_laml.maf.gz", package = "maftools", mustWork = TRUE)
if (!require("R.utils")) {
  message("Please install 'R.utils' package firstly")
} else {
  laml &lt;- read_maf(maf = laml.maf)
  laml

  laml_mini &lt;- laml@data[, list(
    Tumor_Sample_Barcode, Chromosome,
    Start_Position, End_Position,
    Reference_Allele, Tumor_Seq_Allele2
  )]
  laml2 &lt;- read_maf_minimal(laml_mini)
  laml2
}

</code></pre>

<hr>
<h2 id='read_sv_as_rs'>Read Structural Variation Data as RS object</h2><span id='topic+read_sv_as_rs'></span>

<h3>Description</h3>

<p>Read Structural Variation Data as RS object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_sv_as_rs(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_sv_as_rs_+3A_input">input</code></td>
<td>
<p>a <code>data.frame</code> or a file with the following columns:
&quot;sample&quot;, &quot;chr1&quot;, &quot;start1&quot;, &quot;end1&quot;, &quot;chr2&quot;, &quot;start2&quot;, &quot;end2&quot;, &quot;strand1&quot;, &quot;strand2&quot;, &quot;svclass&quot;.
NOTE: If column &quot;svclass&quot; already exists in input, &quot;strand1&quot; and &quot;strand2&quot; are optional.
If &quot;svclass&quot; is not provided, <code>read_sv_as_rs()</code> will compute it by
&quot;strand1&quot;,&quot;strand2&quot;(strand1/strand2),&quot;chr1&quot; and &quot;chr2&quot;:
</p>

<ul>
<li><p> translocation, if mates are on different chromosomes.
</p>
</li>
<li><p> inversion (+/-) and (-/+), if mates on the same chromosome.
</p>
</li>
<li><p> deletion (+/+), if mates on the same chromosome.
</p>
</li>
<li><p> tandem-duplication (-/-), if mates on the same chromosome.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sv &lt;- readRDS(system.file("extdata", "toy_sv.rds", package = "sigminer", mustWork = TRUE))
rs &lt;- read_sv_as_rs(sv)
# svclass is optional
rs2 &lt;- read_sv_as_rs(sv[, setdiff(colnames(sv), "svclass")])
identical(rs, rs2)
## Not run: 
tally_rs &lt;- sig_tally(rs)

## End(Not run)
</code></pre>

<hr>
<h2 id='read_vcf'>Read VCF Files as MAF Object</h2><span id='topic+read_vcf'></span>

<h3>Description</h3>

<p>MAF file is more recommended. In this function, we will mimic
the MAF object from the key <code>c(1, 2, 4, 5, 7)</code> columns of VCF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_vcf(
  vcfs,
  samples = NULL,
  genome_build = c("hg19", "hg38", "T2T", "mm10", "mm9", "ce11"),
  keep_only_pass = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_vcf_+3A_vcfs">vcfs</code></td>
<td>
<p>VCF file paths.</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_samples">samples</code></td>
<td>
<p>sample names for VCF files.</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_genome_build">genome_build</code></td>
<td>
<p>genome build version like &quot;hg19&quot;.</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_keep_only_pass">keep_only_pass</code></td>
<td>
<p>if <code>TRUE</code>, keep only 'PASS' mutation for analysis.</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print extra info.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="#topic+MAF">MAF</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+read_maf">read_maf</a>, <a href="#topic+read_copynumber">read_copynumber</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcfs &lt;- list.files(system.file("extdata", package = "sigminer"), "*.vcf", full.names = TRUE)

maf &lt;- read_vcf(vcfs)
maf &lt;- read_vcf(vcfs, keep_only_pass = TRUE)

</code></pre>

<hr>
<h2 id='read_xena_variants'>Read UCSC Xena Variant Format Data as MAF Object</h2><span id='topic+read_xena_variants'></span>

<h3>Description</h3>

<p>Read UCSC Xena Variant Format Data as MAF Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_xena_variants(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_xena_variants_+3A_path">path</code></td>
<td>
<p>a path to variant file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>MAF</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("UCSCXenaTools")) {
  library(UCSCXenaTools)
  options(use_hiplot = TRUE)
  example_file &lt;- XenaGenerate(subset = XenaDatasets == "mc3/ACC_mc3.txt") %&gt;%
    XenaQuery() %&gt;%
    XenaDownload()
  x &lt;- read_xena_variants(example_file$destfiles)
  x@data
  y &lt;- sig_tally(x)
  y
}

</code></pre>

<hr>
<h2 id='report_bootstrap_p_value'>Report P Values from bootstrap Results</h2><span id='topic+report_bootstrap_p_value'></span>

<h3>Description</h3>

<p>See examples in <a href="#topic+sig_fit_bootstrap">sig_fit_bootstrap</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report_bootstrap_p_value(x, thresholds = c(0.01, 0.05, 0.1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report_bootstrap_p_value_+3A_x">x</code></td>
<td>
<p>a (list of) result from <a href="#topic+sig_fit_bootstrap">sig_fit_bootstrap</a>.</p>
</td></tr>
<tr><td><code id="report_bootstrap_p_value_+3A_thresholds">thresholds</code></td>
<td>
<p>a vector of relative exposure threshold for calculating p values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (list of) <code>matrix</code>
</p>

<hr>
<h2 id='same_size_clustering'>Same Size Clustering</h2><span id='topic+same_size_clustering'></span>

<h3>Description</h3>

<p>This is a wrapper for several implementation that classify samples into
same size clusters, the details please see <a href="http://jmonlong.github.io/Hippocamplus/2018/06/09/cluster-same-size/">this blog</a>.
The source code is modified based on code from the blog.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>same_size_clustering(
  mat,
  diss = FALSE,
  clsize = NULL,
  algo = c("nnit", "hcbottom", "kmvar"),
  method = c("maxd", "random", "mind", "elki", "ward.D", "average", "complete", "single")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="same_size_clustering_+3A_mat">mat</code></td>
<td>
<p>a data/distance matrix.</p>
</td></tr>
<tr><td><code id="same_size_clustering_+3A_diss">diss</code></td>
<td>
<p>if <code>TRUE</code>, treat <code>mat</code> as a distance matrix.</p>
</td></tr>
<tr><td><code id="same_size_clustering_+3A_clsize">clsize</code></td>
<td>
<p>integer, number of sample within a cluster.</p>
</td></tr>
<tr><td><code id="same_size_clustering_+3A_algo">algo</code></td>
<td>
<p>algorithm.</p>
</td></tr>
<tr><td><code id="same_size_clustering_+3A_method">method</code></td>
<td>
<p>method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234L)
x &lt;- rbind(
  matrix(rnorm(100, sd = 0.3), ncol = 2),
  matrix(rnorm(100, mean = 1, sd = 0.3), ncol = 2)
)
colnames(x) &lt;- c("x", "y")

y1 &lt;- same_size_clustering(x, clsize = 10)
y11 &lt;- same_size_clustering(as.matrix(dist(x)), clsize = 10, diss = TRUE)

y2 &lt;- same_size_clustering(x, clsize = 10, algo = "hcbottom", method = "ward.D")

y3 &lt;- same_size_clustering(x, clsize = 10, algo = "kmvar")
y33 &lt;- same_size_clustering(as.matrix(dist(x)), clsize = 10, algo = "kmvar", diss = TRUE)
</code></pre>

<hr>
<h2 id='scoring'>Score Copy Number Profile</h2><span id='topic+scoring'></span>

<h3>Description</h3>

<p>Returns quantification of copy number profile and events including
tandem duplication and Chromothripisis etc.
Only copy number data from autosome is used here.
<strong>Some of the quantification methods are rough,
you use at your risk</strong>. You should do some extra work to check the
result scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoring(object, TD_size_cutoff = c(1000, 100000, 2000000), TD_cn_cutoff = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoring_+3A_object">object</code></td>
<td>
<p>a object of <a href="#topic+CopyNumber">CopyNumber</a>.</p>
</td></tr>
<tr><td><code id="scoring_+3A_td_size_cutoff">TD_size_cutoff</code></td>
<td>
<p>a length-3 numeric vector used to specify the start, midpoint, end
segment size for determining tandem duplication size range, midpoint is used to split
TD into short TD and long TD. Default is 1Kb to 100Kb for short TD, 100Kb to 2Mb for long
TD.</p>
</td></tr>
<tr><td><code id="scoring_+3A_td_cn_cutoff">TD_cn_cutoff</code></td>
<td>
<p>a number defining the maximum copy number of TD,
default is <code>Inf</code>, i.e. no cutoff.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.table</code> with following scores:
</p>

<ul>
<li><p> cnaBurden: CNA burden representing the altered genomic fraction as previously reported.
</p>
</li>
<li><p> cnaLoad: CNA load representing the quantity of copy number alteration.
</p>
</li>
<li><p> MACN: mean altered copy number (MACN) reflecting the property of altered copy number segments,
calculated as
</p>
<p style="text-align: center;"><code class="reqn">MACN = \frac{\sum_{i} CN_i}{N_{cnv}}</code>
</p>

<p>where <code class="reqn">CN_i</code> is the copy number of altered segment <code class="reqn">i</code>, <code class="reqn">N_{cnv}</code> is
the number of CNV.
</p>
</li>
<li><p> weightedMACN: same as MACN but weighted with segment length.
</p>
<p style="text-align: center;"><code class="reqn">MACN_{weighted} = \frac{\sum_{i} (CN_i \times L_{i})}{ \sum_{i} L_{i} }</code>
</p>

<p>where <code class="reqn">L_{i}</code> is the length of altered copy number segment <code class="reqn">i</code>.
</p>
</li>
<li><p> Ploidy: ploidy, the formula is same as <code>weightedMACN</code> but using all copy number segments instead of
altered copy number segments.
</p>
</li>
<li><p> TDP_pnas: tandem duplication phenotype score from <code style="white-space: pre;">&#8288;https://www.pnas.org/doi/10.1073/pnas.1520010113&#8288;</code>,
the threshold <code>k</code> in reference is omitted.
</p>
<p style="text-align: center;"><code class="reqn">TDP = - \frac{\sum_{chr} |TD_{obs}-TD_{exp}|}{TD_{total}}</code>
</p>

<p>where <code class="reqn">TD_{total}</code> is the number of TD, <code class="reqn">TD_{obs}</code> and
<code class="reqn">TD_exp</code> are observed number of TD and expected number of TD for each chromosome.
</p>
</li>
<li><p> TDP: tandem duplication score used defined by our group work,
TD represents segment with copy number greater than 2.
</p>
<p style="text-align: center;"><code class="reqn">TD = \frac{TD_{total}}{\sum_{chr} |TD_{obs}-TD_{exp}|+1}</code>
</p>

</li>
<li><p> sTDP: TDP score for short TD.
</p>
</li>
<li><p> lTDP: TDP score for long TD.
</p>
</li>
<li><p> TDP_size : TDP region size (Mb).
</p>
</li>
<li><p> sTDP_size: sTDP region size (Mb).
</p>
</li>
<li><p> lTDP_size: lTDP region size(Mb).
</p>
</li>
<li><p> Chromoth_state: chromothripsis state score,
according to reference <a href="https://doi.org/10.1016/j.cell.2013.02.023">doi:10.1016/j.cell.2013.02.023</a>,
chromothripsis frequently leads to massive loss of segments on
the affected chromosome with segmental losses being interspersed with regions displaying
normal (disomic) copy-number (e.g., copy-number states oscillating between
copy-number = 1 and copy-number = 2), form tens to hundreds of locally clustered DNA rearrangements.
Most of methods use both SV and CNV to infer chromothripsis, here we roughly quantify it with
</p>
<p style="text-align: center;"><code class="reqn">\sum_{chr}{N_{OsCN}^2}</code>
</p>

<p>where <code class="reqn">N_{OsCN}</code> is the number of oscillating copy number pattern &quot;2-1-2&quot; for each chromosome.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load copy number object
load(system.file("extdata", "toy_copynumber.RData",
  package = "sigminer", mustWork = TRUE
))

d &lt;- scoring(cn)
d

d2 &lt;- scoring(cn, TD_cn_cutoff = 4L)
d2
</code></pre>

<hr>
<h2 id='show_catalogue'>Show Alteration Catalogue Profile</h2><span id='topic+show_catalogue'></span>

<h3>Description</h3>

<p>Show Alteration Catalogue Profile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_catalogue(
  catalogue,
  mode = c("SBS", "copynumber", "DBS", "ID", "RS"),
  method = "Wang",
  normalize = c("raw", "row", "feature"),
  style = c("default", "cosmic"),
  samples = NULL,
  samples_name = NULL,
  x_lab = "Components",
  y_lab = "Counts",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_catalogue_+3A_catalogue">catalogue</code></td>
<td>
<p>result from <a href="#topic+sig_tally">sig_tally</a> or a
matrix with row representing components (motifs) and
column representing samples</p>
</td></tr>
<tr><td><code id="show_catalogue_+3A_mode">mode</code></td>
<td>
<p>signature type for plotting, now supports 'copynumber', 'SBS',
'DBS', 'ID' and 'RS' (genome rearrangement signature).</p>
</td></tr>
<tr><td><code id="show_catalogue_+3A_method">method</code></td>
<td>
<p>method for copy number feature classification in <a href="#topic+sig_tally">sig_tally</a>,
can be one of &quot;Wang&quot; (&quot;W&quot;), &quot;S&quot;.</p>
</td></tr>
<tr><td><code id="show_catalogue_+3A_normalize">normalize</code></td>
<td>
<p>normalize method.</p>
</td></tr>
<tr><td><code id="show_catalogue_+3A_style">style</code></td>
<td>
<p>plot style, one of 'default' and 'cosmic'.</p>
</td></tr>
<tr><td><code id="show_catalogue_+3A_samples">samples</code></td>
<td>
<p>default is <code>NULL</code>, show sum of all samples in one row.
If not <code>NULL</code>, show specified samples.</p>
</td></tr>
<tr><td><code id="show_catalogue_+3A_samples_name">samples_name</code></td>
<td>
<p>set the sample names shown in plot.</p>
</td></tr>
<tr><td><code id="show_catalogue_+3A_x_lab">x_lab</code></td>
<td>
<p>x axis lab.</p>
</td></tr>
<tr><td><code id="show_catalogue_+3A_y_lab">y_lab</code></td>
<td>
<p>y axis lab.</p>
</td></tr>
<tr><td><code id="show_catalogue_+3A_...">...</code></td>
<td>
<p>other arguments passing to <a href="#topic+show_sig_profile">show_sig_profile</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("simulated_catalogs")
p &lt;- show_catalogue(simulated_catalogs$set1, style = "cosmic")
p

</code></pre>

<hr>
<h2 id='show_cn_circos'>Show Copy Number Profile in Circos</h2><span id='topic+show_cn_circos'></span>

<h3>Description</h3>

<p>Another visualization method for copy number profile like <a href="#topic+show_cn_profile">show_cn_profile</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_cn_circos(
  data,
  samples = NULL,
  show_title = TRUE,
  chrs = paste0("chr", 1:22),
  genome_build = c("hg19", "hg38", "T2T", "mm10", "mm9", "ce11"),
  col = NULL,
  side = "inside",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_cn_circos_+3A_data">data</code></td>
<td>
<p>a <a href="#topic+CopyNumber">CopyNumber</a> object or a <code>data.frame</code> containing at least 'chromosome', 'start',
'end', 'segVal' these columns.</p>
</td></tr>
<tr><td><code id="show_cn_circos_+3A_samples">samples</code></td>
<td>
<p>default is <code>NULL</code>, can be a chracter vector representing multiple samples or
number of samples to show.
If data argument is a <code>data.frame</code>, a column called sample must exist.</p>
</td></tr>
<tr><td><code id="show_cn_circos_+3A_show_title">show_title</code></td>
<td>
<p>if <code>TRUE</code> (default), show title with sample ID.</p>
</td></tr>
<tr><td><code id="show_cn_circos_+3A_chrs">chrs</code></td>
<td>
<p>chromosomes start with 'chr'.</p>
</td></tr>
<tr><td><code id="show_cn_circos_+3A_genome_build">genome_build</code></td>
<td>
<p>genome build version, used when <code>data</code> is a <code>data.frame</code>, should be 'hg19' or 'hg38'.</p>
</td></tr>
<tr><td><code id="show_cn_circos_+3A_col">col</code></td>
<td>
<p>colors for the heatmaps. If it is <code>NULL</code>, set to
<code>circlize::colorRamp2(c(1, 2, 4), c("blue", "black", "red"))</code>.</p>
</td></tr>
<tr><td><code id="show_cn_circos_+3A_side">side</code></td>
<td>
<p>side of the heatmaps.</p>
</td></tr>
<tr><td><code id="show_cn_circos_+3A_...">...</code></td>
<td>
<p>other parameters passing to <a href="circlize.html#topic+circos.genomicHeatmap">circlize::circos.genomicHeatmap</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a circos plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata", "toy_copynumber.RData",
  package = "sigminer", mustWork = TRUE
))

show_cn_circos(cn, samples = 1)
show_cn_circos(cn, samples = "TCGA-99-7458-01A-11D-2035-01")

## Remove title
show_cn_circos(cn, samples = 1, show_title = FALSE)

## Subset chromosomes
show_cn_circos(cn, samples = 1, chrs = c("chr1", "chr2", "chr3"))

## Arrange plots
layout(matrix(1:4, 2, 2))
show_cn_circos(cn, samples = 4)

layout(1) # reset layout

</code></pre>

<hr>
<h2 id='show_cn_components'>Show Copy Number Components</h2><span id='topic+show_cn_components'></span>

<h3>Description</h3>

<p>Show classified components (&quot;Wang&quot; (&quot;W&quot;) method) for copy number data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_cn_components(
  parameters,
  method = "Wang",
  show_weights = TRUE,
  log_y = FALSE,
  return_plotlist = FALSE,
  base_size = 12,
  nrow = 2,
  align = "hv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_cn_components_+3A_parameters">parameters</code></td>
<td>
<p>a <code>data.frame</code> contain parameter components, obtain this
from <a href="#topic+sig_tally">sig_tally</a> function.</p>
</td></tr>
<tr><td><code id="show_cn_components_+3A_method">method</code></td>
<td>
<p>method for feature classification, can be one of
&quot;Wang&quot; (&quot;W&quot;), &quot;S&quot; (for method described in Steele et al. 2019),
&quot;X&quot; (for method described in Tao et al. 2023).</p>
</td></tr>
<tr><td><code id="show_cn_components_+3A_show_weights">show_weights</code></td>
<td>
<p>default is <code>TRUE</code>, show weights for each component.
Only used when method is &quot;Macintyre&quot;.</p>
</td></tr>
<tr><td><code id="show_cn_components_+3A_log_y">log_y</code></td>
<td>
<p>logical, if <code>TRUE</code>, show <code>log10</code> based y axis, only
works for input from &quot;Wang&quot; (&quot;W&quot;) method.</p>
</td></tr>
<tr><td><code id="show_cn_components_+3A_return_plotlist">return_plotlist</code></td>
<td>
<p>if <code>TRUE</code>, return a list of ggplot objects but a combined plot.</p>
</td></tr>
<tr><td><code id="show_cn_components_+3A_base_size">base_size</code></td>
<td>
<p>overall font size.</p>
</td></tr>
<tr><td><code id="show_cn_components_+3A_nrow">nrow</code></td>
<td>
<p>(optional) Number of rows in the plot grid.</p>
</td></tr>
<tr><td><code id="show_cn_components_+3A_align">align</code></td>
<td>
<p>(optional) Specifies whether graphs in the grid should be horizontally (&quot;h&quot;) or
vertically (&quot;v&quot;) aligned. Options are &quot;none&quot; (default), &quot;hv&quot; (align in both directions), &quot;h&quot;, and &quot;v&quot;.</p>
</td></tr>
<tr><td><code id="show_cn_components_+3A_...">...</code></td>
<td>
<p>other options pass to <code><a href="cowplot.html#topic+plot_grid">plot_grid</a></code> function of <strong>cowplot</strong> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang <a href="mailto:w_shixiang@163.com">w_shixiang@163.com</a>
</p>

<hr>
<h2 id='show_cn_distribution'>Show Copy Number Distribution either by Length or Chromosome</h2><span id='topic+show_cn_distribution'></span>

<h3>Description</h3>

<p>Visually summarize copy number distribution either by copy number segment length
or chromosome. Input is a <a href="#topic+CopyNumber">CopyNumber</a> object, <code>genome_build</code> option will
read from <code>genome_build</code> slot of object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_cn_distribution(
  data,
  rm_normal = TRUE,
  mode = c("ld", "cd"),
  fill = FALSE,
  scale_chr = TRUE,
  base_size = 14
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_cn_distribution_+3A_data">data</code></td>
<td>
<p>a <a href="#topic+CopyNumber">CopyNumber</a> object.</p>
</td></tr>
<tr><td><code id="show_cn_distribution_+3A_rm_normal">rm_normal</code></td>
<td>
<p>logical. Whether remove normal copy (i.e. &quot;segVal&quot; equals 2), default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="show_cn_distribution_+3A_mode">mode</code></td>
<td>
<p>either &quot;ld&quot; for distribution by CN length or &quot;cd&quot; for distribution by chromosome.</p>
</td></tr>
<tr><td><code id="show_cn_distribution_+3A_fill">fill</code></td>
<td>
<p>when <code>mode</code> is &quot;cd&quot; and <code>fill</code> is <code>TRUE</code>, plot percentage instead of count.</p>
</td></tr>
<tr><td><code id="show_cn_distribution_+3A_scale_chr">scale_chr</code></td>
<td>
<p>logical. If <code>TRUE</code>, normalize count to per Megabase unit.</p>
</td></tr>
<tr><td><code id="show_cn_distribution_+3A_base_size">base_size</code></td>
<td>
<p>overall font size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang <a href="mailto:w_shixiang@163.com">w_shixiang@163.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load copy number object
load(system.file("extdata", "toy_copynumber.RData",
  package = "sigminer", mustWork = TRUE
))
# Plot distribution
p1 &lt;- show_cn_distribution(cn)
p1
p2 &lt;- show_cn_distribution(cn, mode = "cd")
p2
p3 &lt;- show_cn_distribution(cn, mode = "cd", fill = TRUE)
p3
</code></pre>

<hr>
<h2 id='show_cn_features'>Show Copy Number Feature Distributions</h2><span id='topic+show_cn_features'></span>

<h3>Description</h3>

<p>Show Copy Number Feature Distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_cn_features(
  features,
  method = "Wang",
  rm_outlier = FALSE,
  ylab = NULL,
  log_y = FALSE,
  return_plotlist = FALSE,
  base_size = 12,
  nrow = 2,
  align = "hv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_cn_features_+3A_features">features</code></td>
<td>
<p>a feature <code>list</code> generate from <a href="#topic+sig_tally">sig_tally</a> function.</p>
</td></tr>
<tr><td><code id="show_cn_features_+3A_method">method</code></td>
<td>
<p>method for feature classification, can be one of
&quot;Wang&quot; (&quot;W&quot;), &quot;S&quot; (for method described in Steele et al. 2019),
&quot;X&quot; (for method described in Tao et al. 2023).</p>
</td></tr>
<tr><td><code id="show_cn_features_+3A_rm_outlier">rm_outlier</code></td>
<td>
<p>default is <code>FALSE</code>, if <code>TRUE</code>, remove outliers. Only
works when method is &quot;Wang&quot; (&quot;W&quot;).</p>
</td></tr>
<tr><td><code id="show_cn_features_+3A_ylab">ylab</code></td>
<td>
<p>lab of y axis.</p>
</td></tr>
<tr><td><code id="show_cn_features_+3A_log_y">log_y</code></td>
<td>
<p>logical, if <code>TRUE</code>, show <code>log10</code> based y axis, only
works for input from &quot;Wang&quot; (&quot;W&quot;) method.</p>
</td></tr>
<tr><td><code id="show_cn_features_+3A_return_plotlist">return_plotlist</code></td>
<td>
<p>if <code>TRUE</code>, return a list of ggplot objects but a combined plot.</p>
</td></tr>
<tr><td><code id="show_cn_features_+3A_base_size">base_size</code></td>
<td>
<p>overall font size.</p>
</td></tr>
<tr><td><code id="show_cn_features_+3A_nrow">nrow</code></td>
<td>
<p>(optional) Number of rows in the plot grid.</p>
</td></tr>
<tr><td><code id="show_cn_features_+3A_align">align</code></td>
<td>
<p>(optional) Specifies whether graphs in the grid should be horizontally (&quot;h&quot;) or
vertically (&quot;v&quot;) aligned. Options are &quot;none&quot; (default), &quot;hv&quot; (align in both directions), &quot;h&quot;, and &quot;v&quot;.</p>
</td></tr>
<tr><td><code id="show_cn_features_+3A_...">...</code></td>
<td>
<p>other options pass to <code><a href="cowplot.html#topic+plot_grid">plot_grid</a></code> function of <code>cowplot</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>

<hr>
<h2 id='show_cn_freq_circos'>Show Copy Number Variation Frequency Profile with Circos</h2><span id='topic+show_cn_freq_circos'></span>

<h3>Description</h3>

<p>Show Copy Number Variation Frequency Profile with Circos
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_cn_freq_circos(
  data,
  groups = NULL,
  cutoff = 2L,
  resolution_factor = 1L,
  title = c("AMP", "DEL"),
  chrs = paste0("chr", 1:22),
  genome_build = c("hg19", "hg38", "T2T", "mm10", "mm9", "ce11"),
  cols = NULL,
  plot_ideogram = TRUE,
  track_height = 0.5,
  ideogram_height = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_cn_freq_circos_+3A_data">data</code></td>
<td>
<p>a <code>CopyNumber</code> object or a data.frame containing
at least 'chromosome', 'start', 'end', 'segVal', 'sample' these columns.</p>
</td></tr>
<tr><td><code id="show_cn_freq_circos_+3A_groups">groups</code></td>
<td>
<p>a named list or a column name for specifying groups.</p>
</td></tr>
<tr><td><code id="show_cn_freq_circos_+3A_cutoff">cutoff</code></td>
<td>
<p>copy number value cutoff for splitting data into AMP and DEL.
The values equal to cutoff are discarded. Default is <code>2</code>, you can also set
a length-2 vector, e.g. <code>c(2, 2)</code>.</p>
</td></tr>
<tr><td><code id="show_cn_freq_circos_+3A_resolution_factor">resolution_factor</code></td>
<td>
<p>an integer to control the resolution.
When it is <code>1</code> (default), compute frequency in each cytoband.
When it is <code>2</code>, use compute frequency in each half cytoband.</p>
</td></tr>
<tr><td><code id="show_cn_freq_circos_+3A_title">title</code></td>
<td>
<p>length-2 titles for AMP and DEL.</p>
</td></tr>
<tr><td><code id="show_cn_freq_circos_+3A_chrs">chrs</code></td>
<td>
<p>chromosomes start with 'chr'.</p>
</td></tr>
<tr><td><code id="show_cn_freq_circos_+3A_genome_build">genome_build</code></td>
<td>
<p>genome build version, used when <code>data</code> is a <code>data.frame</code>, should be 'hg19' or 'hg38'.</p>
</td></tr>
<tr><td><code id="show_cn_freq_circos_+3A_cols">cols</code></td>
<td>
<p>length-2 colors for AMP and DEL.</p>
</td></tr>
<tr><td><code id="show_cn_freq_circos_+3A_plot_ideogram">plot_ideogram</code></td>
<td>
<p>default is <code>TRUE</code>, show ideogram.</p>
</td></tr>
<tr><td><code id="show_cn_freq_circos_+3A_track_height">track_height</code></td>
<td>
<p>track height in <code>mm</code> unit.</p>
</td></tr>
<tr><td><code id="show_cn_freq_circos_+3A_ideogram_height">ideogram_height</code></td>
<td>
<p>ideogram height in <code>mm</code> unit.</p>
</td></tr>
<tr><td><code id="show_cn_freq_circos_+3A_...">...</code></td>
<td>
<p>other parameters passing to <a href="circlize.html#topic+circos.genomicLines">circlize::circos.genomicLines</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load(system.file("extdata", "toy_copynumber.RData",
  package = "sigminer", mustWork = TRUE
))

show_cn_freq_circos(cn)
ss &lt;- unique(cn@data$sample)
show_cn_freq_circos(cn, groups = list(a = ss[1:5], b = ss[6:10]), cols = c("red", "green"))

</code></pre>

<hr>
<h2 id='show_cn_group_profile'>Show Summary Copy Number Profile for Sample Groups</h2><span id='topic+show_cn_group_profile'></span>

<h3>Description</h3>

<p>Show Summary Copy Number Profile for Sample Groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_cn_group_profile(
  data,
  groups = NULL,
  fill_area = TRUE,
  cols = NULL,
  chrs = paste0("chr", c(1:22, "X")),
  genome_build = c("hg19", "hg38", "T2T", "mm10", "mm9", "ce11"),
  cutoff = 2L,
  resolution_factor = 1L,
  force_y_limit = TRUE,
  highlight_genes = NULL,
  repel = FALSE,
  nrow = NULL,
  ncol = NULL,
  return_plotlist = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_cn_group_profile_+3A_data">data</code></td>
<td>
<p>a <code>CopyNumber</code> object or a data.frame containing
at least 'chromosome', 'start', 'end', 'segVal', 'sample' these columns.</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_groups">groups</code></td>
<td>
<p>a named list or a column name for specifying groups.</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_fill_area">fill_area</code></td>
<td>
<p>default is <code>TRUE</code>, fill area with colors.</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_cols">cols</code></td>
<td>
<p>length-2 colors for AMP and DEL.</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_chrs">chrs</code></td>
<td>
<p>chromosomes start with 'chr'.</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_genome_build">genome_build</code></td>
<td>
<p>genome build version, used when <code>data</code> is a <code>data.frame</code>, should be 'hg19' or 'hg38'.</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_cutoff">cutoff</code></td>
<td>
<p>copy number value cutoff for splitting data into AMP and DEL.
The values equal to cutoff are discarded. Default is <code>2</code>, you can also set
a length-2 vector, e.g. <code>c(2, 2)</code>.</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_resolution_factor">resolution_factor</code></td>
<td>
<p>an integer to control the resolution.
When it is <code>1</code> (default), compute frequency in each cytoband.
When it is <code>2</code>, use compute frequency in each half cytoband.</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_force_y_limit">force_y_limit</code></td>
<td>
<p>default is <code>TRUE</code>, force multiple plots</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_highlight_genes">highlight_genes</code></td>
<td>
<p>gene list to highlight.
have same y ranges. You can also set a length-2 numeric value.</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_repel">repel</code></td>
<td>
<p>if <code>TRUE</code> (default is <code>FALSE</code>), repel highlight genes to
avoid overlap.</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_nrow">nrow</code></td>
<td>
<p>number of rows in the plot grid when multiple samples are selected.</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_ncol">ncol</code></td>
<td>
<p>number of columns in the plot grid when multiple samples are selected.</p>
</td></tr>
<tr><td><code id="show_cn_group_profile_+3A_return_plotlist">return_plotlist</code></td>
<td>
<p>default is <code>FALSE</code>, if <code>TRUE</code>, return a plot list instead of a combined plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (list of) <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata", "toy_copynumber.RData",
  package = "sigminer", mustWork = TRUE
))

p1 &lt;- show_cn_group_profile(cn)
p1

ss &lt;- unique(cn@data$sample)
p2 &lt;- show_cn_group_profile(cn, groups = list(a = ss[1:5], b = ss[6:10]))
p2
p3 &lt;- show_cn_group_profile(cn,
  groups = list(g1 = ss[1:5], g2 = ss[6:10]),
  force_y_limit = c(-1, 1), nrow = 2
)
p3

## Set custom cutoff for custom data
data &lt;- cn@data
data$segVal &lt;- data$segVal - 2L
p4 &lt;- show_cn_group_profile(data,
  groups = list(g1 = ss[1:5], g2 = ss[6:10]),
  force_y_limit = c(-1, 1), nrow = 2,
  cutoff = c(0, 0)
)
p4

## Add highlight gene
p5 &lt;- show_cn_group_profile(cn, highlight_genes = c("TP53", "EGFR"))
p5

</code></pre>

<hr>
<h2 id='show_cn_profile'>Show Sample Copy Number Profile</h2><span id='topic+show_cn_profile'></span>

<h3>Description</h3>

<p>Sometimes it is very useful to check details about copy number profile for one or multiple
samples. This function is designed to do this job and can be further modified by <strong>ggplot2</strong>
related packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_cn_profile(
  data,
  samples = NULL,
  show_n = NULL,
  show_title = FALSE,
  show_labels = NULL,
  chrs = paste0("chr", 1:22),
  position = NULL,
  genome_build = c("hg19", "hg38", "T2T", "mm10", "mm9", "ce11"),
  ylim = NULL,
  nrow = NULL,
  ncol = NULL,
  return_plotlist = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_cn_profile_+3A_data">data</code></td>
<td>
<p>a <a href="#topic+CopyNumber">CopyNumber</a> object or a <code>data.frame</code> containing at least 'chromosome', 'start',
'end', 'segVal' these columns.</p>
</td></tr>
<tr><td><code id="show_cn_profile_+3A_samples">samples</code></td>
<td>
<p>default is NULL, can be a chracter vector representing multiple samples. If <code>data</code> argument
is a <code>data.frame</code>, a column called <code>sample</code> must exist.</p>
</td></tr>
<tr><td><code id="show_cn_profile_+3A_show_n">show_n</code></td>
<td>
<p>number of samples to show, this is used for checking.</p>
</td></tr>
<tr><td><code id="show_cn_profile_+3A_show_title">show_title</code></td>
<td>
<p>if <code>TRUE</code>, show title for multiple samples.</p>
</td></tr>
<tr><td><code id="show_cn_profile_+3A_show_labels">show_labels</code></td>
<td>
<p>one of <code>NULL</code>, &quot;s&quot; (for labelling short segments &lt; 1e7)
or &quot;a&quot; (all segments).</p>
</td></tr>
<tr><td><code id="show_cn_profile_+3A_chrs">chrs</code></td>
<td>
<p>chromosomes start with 'chr'.</p>
</td></tr>
<tr><td><code id="show_cn_profile_+3A_position">position</code></td>
<td>
<p>a position range, e.g. <code>"chr1:3218923-116319008"</code>. Only data
overlaps with this range will be shown.</p>
</td></tr>
<tr><td><code id="show_cn_profile_+3A_genome_build">genome_build</code></td>
<td>
<p>genome build version, used when <code>data</code> is a <code>data.frame</code>, should be 'hg19' or 'hg38'.</p>
</td></tr>
<tr><td><code id="show_cn_profile_+3A_ylim">ylim</code></td>
<td>
<p>limites for y axis.</p>
</td></tr>
<tr><td><code id="show_cn_profile_+3A_nrow">nrow</code></td>
<td>
<p>number of rows in the plot grid when multiple samples are selected.</p>
</td></tr>
<tr><td><code id="show_cn_profile_+3A_ncol">ncol</code></td>
<td>
<p>number of columns in the plot grid when multiple samples are selected.</p>
</td></tr>
<tr><td><code id="show_cn_profile_+3A_return_plotlist">return_plotlist</code></td>
<td>
<p>default is <code>FALSE</code>, if <code>TRUE</code>, return a plot list instead of a combined plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object or a <code>list</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load copy number object
load(system.file("extdata", "toy_copynumber.RData",
  package = "sigminer", mustWork = TRUE
))

p &lt;- show_cn_profile(cn, nrow = 2, ncol = 1)
p

p2 &lt;- show_cn_profile(cn,
  nrow = 2, ncol = 1,
  position = "chr1:3218923-116319008"
)
p2

</code></pre>

<hr>
<h2 id='show_cor'>A Simple and General Way for Association Analysis</h2><span id='topic+show_cor'></span>

<h3>Description</h3>

<p>All variables must be continuous.
The matrix will be returned as an element of <code>ggplot</code> object.
This is basically a wrapper of R package
<a href="https://github.com/kassambara/ggcorrplot">ggcorrplot</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_cor(
  data,
  x_vars = colnames(data),
  y_vars = x_vars,
  cor_method = "spearman",
  vis_method = "square",
  lab = TRUE,
  test = TRUE,
  hc_order = FALSE,
  p_adj = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_cor_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="show_cor_+3A_x_vars">x_vars</code></td>
<td>
<p>variables/column names shown in x axis.</p>
</td></tr>
<tr><td><code id="show_cor_+3A_y_vars">y_vars</code></td>
<td>
<p>variables/column names shown in y axis.</p>
</td></tr>
<tr><td><code id="show_cor_+3A_cor_method">cor_method</code></td>
<td>
<p>method for correlation, default is 'spearman'.</p>
</td></tr>
<tr><td><code id="show_cor_+3A_vis_method">vis_method</code></td>
<td>
<p>visualization method, default is 'square',
can also be 'circle'.</p>
</td></tr>
<tr><td><code id="show_cor_+3A_lab">lab</code></td>
<td>
<p>logical value. If TRUE, add correlation coefficient on the plot.</p>
</td></tr>
<tr><td><code id="show_cor_+3A_test">test</code></td>
<td>
<p>if <code>TRUE</code>, run test for correlation and mark significance.</p>
</td></tr>
<tr><td><code id="show_cor_+3A_hc_order">hc_order</code></td>
<td>
<p>logical value. If <code>TRUE</code>,
correlation matrix will be hc.ordered using <code>hclust</code> function.</p>
</td></tr>
<tr><td><code id="show_cor_+3A_p_adj">p_adj</code></td>
<td>
<p>p adjust method, see <a href="stats.html#topic+p.adjust">stats::p.adjust</a> for details.</p>
</td></tr>
<tr><td><code id="show_cor_+3A_...">...</code></td>
<td>
<p>other parameters passing to <code>ggcorrplot::ggcorrplot()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>See Also</h3>

<p><a href="#topic+show_sig_feature_corrplot">show_sig_feature_corrplot</a> for specific and more powerful
association analysis and visualization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mtcars")
p1 &lt;- show_cor(mtcars)
p2 &lt;- show_cor(mtcars,
  x_vars = colnames(mtcars)[1:4],
  y_vars = colnames(mtcars)[5:8]
)
p3 &lt;- show_cor(mtcars, vis_method = "circle", p_adj = "fdr")
p1
p1$cor
p2
p3

## Auto detect problem variables
mtcars$xx &lt;- 0L
p4 &lt;- show_cor(mtcars)
p4
</code></pre>

<hr>
<h2 id='show_cosmic'>Show Signature Information in Web Browser</h2><span id='topic+show_cosmic'></span>

<h3>Description</h3>

<p>Show Signature Information in Web Browser
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_cosmic(x = "home")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_cosmic_+3A_x">x</code></td>
<td>
<p>a string indicating location
(&quot;home&quot; for COSMIC signature home, &quot;legacy&quot; for COSMIC v2 signatures,
&quot;SBS&quot; for COSMIC v3 SBS signatures, &quot;DBS&quot; for COSMIC v3 DBS signatures,
&quot;ID&quot; for COSMIC v3 INDEL signatures) or signature index (e.g.
&quot;SBS1&quot;, &quot;DBS2&quot;, &quot;ID3&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
show_cosmic()
show_cosmic("legacy")
show_cosmic("SBS")
show_cosmic("DBS")
show_cosmic("ID")
show_cosmic("SBS1")
show_cosmic("DBS2")
show_cosmic("ID3")

## End(Not run)
</code></pre>

<hr>
<h2 id='show_cosmic_sig_profile'>Plot Reference (Mainly COSMIC) Signature Profile</h2><span id='topic+show_cosmic_sig_profile'></span>

<h3>Description</h3>

<p>Plot Reference (Mainly COSMIC) Signature Profile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_cosmic_sig_profile(
  sig_index = NULL,
  show_index = TRUE,
  sig_db = "legacy",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_cosmic_sig_profile_+3A_sig_index">sig_index</code></td>
<td>
<p>a vector for signature index. &quot;ALL&quot; for all signatures.</p>
</td></tr>
<tr><td><code id="show_cosmic_sig_profile_+3A_show_index">show_index</code></td>
<td>
<p>if <code>TRUE</code>, show valid indices.</p>
</td></tr>
<tr><td><code id="show_cosmic_sig_profile_+3A_sig_db">sig_db</code></td>
<td>
<p>default 'legacy', it can be 'legacy' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures_v2.tt/">COSMIC v2 'SBS'</a>),
'SBS', 'DBS', 'ID' and 'TSB' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures/">COSMIV v3.1 signatures</a>)
for small scale mutations.
For more specific details, it can also be 'SBS_hg19', 'SBS_hg38',
'SBS_mm9', 'SBS_mm10', 'DBS_hg19', 'DBS_hg38', 'DBS_mm9', 'DBS_mm10' to use
COSMIC v3 reference signatures from Alexandrov, Ludmil B., et al. (2020) (reference #1).
In addition, it can be one of &quot;SBS_Nik_lab_Organ&quot;, &quot;RS_Nik_lab_Organ&quot;,
&quot;SBS_Nik_lab&quot;, &quot;RS_Nik_lab&quot; to refer reference signatures from
Degasperi, Andrea, et al. (2020) (reference #2);
&quot;RS_BRCA560&quot;, &quot;RS_USARC&quot; to reference signatures from BRCA560 and USARC cohorts;
&quot;CNS_USARC&quot; (40 categories), &quot;CNS_TCGA&quot; (48 categories) to reference copy number signatures from USARC cohort and TCGA;
&quot;CNS_TCGA176&quot; (176 categories) and &quot;CNS_PCAWG176&quot; (176 categories) to reference copy number signatures from PCAWG and TCGA separately.
<strong>UPDATE</strong>, the latest version of reference version can be automatically
downloaded and loaded from <a href="https://cancer.sanger.ac.uk/signatures/downloads/">https://cancer.sanger.ac.uk/signatures/downloads/</a>
when a option with <code>latest_</code> prefix is specified (e.g. &quot;latest_SBS_GRCh37&quot;).
<strong>Note</strong>: the signature profile for different genome builds are basically same.
And specific database (e.g. 'SBS_mm10') contains less signatures than all COSMIC
signatures (because some signatures are not detected from Alexandrov, Ludmil B., et al. (2020)).
For all available options, check the parameter setting.</p>
</td></tr>
<tr><td><code id="show_cosmic_sig_profile_+3A_...">...</code></td>
<td>
<p>other arguments passing to <a href="#topic+show_sig_profile">show_sig_profile</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang <a href="mailto:w_shixiang@163.com">w_shixiang@163.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
show_cosmic_sig_profile()
show_cosmic_sig_profile(sig_db = "SBS")
show_cosmic_sig_profile(sig_index = 1:5)
show_cosmic_sig_profile(sig_db = "SBS", sig_index = c("10a", "17a"))

gg &lt;- show_cosmic_sig_profile(sig_index = 1:5)
gg$aetiology

</code></pre>

<hr>
<h2 id='show_group_comparison'>Plot Group Comparison Result</h2><span id='topic+show_group_comparison'></span>

<h3>Description</h3>

<p>Using result data from <a href="#topic+get_group_comparison">get_group_comparison</a>, this function plots
genotypes/phenotypes comparison between signature groups using <strong>ggplot2</strong> package and return
a list of <code>ggplot</code> object contains individual and combined plots. The combined
plot is easily saved to local using <code><a href="cowplot.html#topic+save_plot">cowplot::save_plot()</a></code>. Of note, default fisher
test p values are shown for categorical data and fdr values are shown for
continuous data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_group_comparison(
  group_comparison,
  xlab = "group",
  ylab_co = NA,
  legend_title_ca = NA,
  legend_position_ca = "bottom",
  set_ca_sig_yaxis = FALSE,
  set_ca_custom_xlab = FALSE,
  show_pvalue = TRUE,
  ca_p_threshold = 0.01,
  method = "wilcox.test",
  p.adjust.method = "fdr",
  base_size = 12,
  font_size_x = 12,
  text_angle_x = 30,
  text_hjust_x = 0.2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_group_comparison_+3A_group_comparison">group_comparison</code></td>
<td>
<p>a <code>list</code> from result of <a href="#topic+get_group_comparison">get_group_comparison</a> function.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_xlab">xlab</code></td>
<td>
<p>lab name of x axis for all plots. if it is <code>NA</code>, remove title for x axis.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_ylab_co">ylab_co</code></td>
<td>
<p>lab name of y axis for plots of continuous type data. Of note,
this argument should be a character vector has same length as <code>group_comparison</code>,
the location for categorical type data should mark with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_legend_title_ca">legend_title_ca</code></td>
<td>
<p>legend title for plots of categorical type data.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_legend_position_ca">legend_position_ca</code></td>
<td>
<p>legend position for plots of categorical type data.
Of note,
this argument should be a character vector has same length as <code>group_comparison</code>,
the location for continuous type data should mark with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_set_ca_sig_yaxis">set_ca_sig_yaxis</code></td>
<td>
<p>if <code>TRUE</code>, use y axis to show signature proportion instead of
variable proportion.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_set_ca_custom_xlab">set_ca_custom_xlab</code></td>
<td>
<p>only works when <code>set_ca_sig_yaxis</code> is <code>TRUE</code>. If
<code>TRUE</code>, set x labels using input <code>xlab</code>, otherwise variable names will be used.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_show_pvalue">show_pvalue</code></td>
<td>
<p>if <code>TRUE</code>, show p values.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_ca_p_threshold">ca_p_threshold</code></td>
<td>
<p>a p threshold for categorical variables, default is 0.01.
A p value less than 0.01 will be shown as <code>P &lt; 0.01</code>.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_method">method</code></td>
<td>
<p>a character string indicating which method to be used for comparing means.
It can be 't.test', 'wilcox.test' etc..</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>correction method, default is 'fdr'. Run <code>p.adjust.methods</code> to
see all available options.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_base_size">base_size</code></td>
<td>
<p>overall font size.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_font_size_x">font_size_x</code></td>
<td>
<p>font size for x.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_text_angle_x">text_angle_x</code></td>
<td>
<p>text angle for x.</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_text_hjust_x">text_hjust_x</code></td>
<td>
<p>adjust x axis text</p>
</td></tr>
<tr><td><code id="show_group_comparison_+3A_...">...</code></td>
<td>
<p>other paramters pass to <code><a href="ggpubr.html#topic+compare_means">ggpubr::compare_means()</a></code> or <code><a href="ggpubr.html#topic+stat_compare_means">ggpubr::stat_compare_means()</a></code>
according to the specified <code>method</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> of <code>ggplot</code> objects.
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang <a href="mailto:w_shixiang@163.com">w_shixiang@163.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load(system.file("extdata", "toy_copynumber_signature_by_W.RData",
  package = "sigminer", mustWork = TRUE
))

# Assign samples to clusters
groups &lt;- get_groups(sig, method = "k-means")

set.seed(1234)

groups$prob &lt;- rnorm(10)
groups$new_group &lt;- sample(c("1", "2", "3", "4", NA), size = nrow(groups), replace = TRUE)

# Compare groups (filter NAs for categorical coloumns)
groups.cmp &lt;- get_group_comparison(groups[, -1],
  col_group = "group",
  cols_to_compare = c("prob", "new_group"),
  type = c("co", "ca"), verbose = TRUE
)

# Compare groups (Set NAs of categorical columns to 'Rest')
groups.cmp2 &lt;- get_group_comparison(groups[, -1],
  col_group = "group",
  cols_to_compare = c("prob", "new_group"),
  type = c("co", "ca"), NAs = "Rest", verbose = TRUE
)

show_group_comparison(groups.cmp)

ggcomp &lt;- show_group_comparison(groups.cmp2)
ggcomp$co_comb
ggcomp$ca_comb

</code></pre>

<hr>
<h2 id='show_group_distribution'>Show Groupped Variable Distribution</h2><span id='topic+show_group_distribution'></span>

<h3>Description</h3>

<p>This is a general function, it can be used in any proper analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_group_distribution(
  data,
  gvar,
  dvar,
  fun = stats::median,
  order_by_fun = FALSE,
  alpha = 0.8,
  g_label = "label",
  g_angle = 0,
  g_position = "top",
  point_size = 1L,
  segment_size = 1L,
  segment_color = "red",
  xlab = NULL,
  ylab = NULL,
  nrow = 1L,
  background_color = c("#DCDCDC", "#F5F5F5")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_group_distribution_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_gvar">gvar</code></td>
<td>
<p>a group variable name/index.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_dvar">dvar</code></td>
<td>
<p>a distribution variable name/index.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_fun">fun</code></td>
<td>
<p>a function to summarize, default is <a href="stats.html#topic+median">stats::median</a>, can also be <a href="base.html#topic+mean">mean</a>.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_order_by_fun">order_by_fun</code></td>
<td>
<p>if <code>TRUE</code>, reorder the groups by summary measure computed
by argument <code>fun</code>.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_alpha">alpha</code></td>
<td>
<p>alpha for points, range from 0 to 1.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_g_label">g_label</code></td>
<td>
<p>a string 'label' (default) for labeling with sample size,
or 'norm' to show just group name, or a named vector to set facet labels.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_g_angle">g_angle</code></td>
<td>
<p>angle for facet labels, default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_g_position">g_position</code></td>
<td>
<p>position for facet labels, default is 'top', can also
be 'bottom'.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_point_size">point_size</code></td>
<td>
<p>size of point.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_segment_size">segment_size</code></td>
<td>
<p>size of segment.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_segment_color">segment_color</code></td>
<td>
<p>color of segment.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_xlab">xlab</code></td>
<td>
<p>title for x axis.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_ylab">ylab</code></td>
<td>
<p>title for y axis.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_nrow">nrow</code></td>
<td>
<p>number of row.</p>
</td></tr>
<tr><td><code id="show_group_distribution_+3A_background_color">background_color</code></td>
<td>
<p>background color for plot panel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object.
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang <a href="mailto:w_shixiang@163.com">w_shixiang@163.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
data &lt;- data.frame(
  yval = rnorm(120),
  gr = c(rep("A", 50), rep("B", 40), rep("C", 30))
)
p &lt;- show_group_distribution(data,
  gvar = 2, dvar = 1,
  g_label = "norm",
  background_color = "grey"
)
p
p2 &lt;- show_group_distribution(data,
  gvar = "gr", dvar = "yval",
  g_position = "bottom",
  order_by_fun = TRUE,
  alpha = 0.3
)
p2

# Set custom group names
p3 &lt;- show_group_distribution(data,
  gvar = 2, dvar = 1,
  g_label = c("A" = "X", "B" = "Y", "C" = "Z")
)
p3

</code></pre>

<hr>
<h2 id='show_group_enrichment'>Show Group Enrichment Result</h2><span id='topic+show_group_enrichment'></span>

<h3>Description</h3>

<p>See <a href="#topic+group_enrichment">group_enrichment</a> for examples.
NOTE the box fill and the box text have different meanings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_group_enrichment(
  df_enrich,
  return_list = FALSE,
  scales = "free",
  add_text_annotation = TRUE,
  fill_by_p_value = TRUE,
  use_fdr = TRUE,
  cut_p_value = FALSE,
  cut_breaks = c(-Inf, -5, log10(0.05), -log10(0.05), 5, Inf),
  cut_labels = c("↓ 1e-5", "↓ 0.05", "non-significant", "↑ 0.05", "↑ 1e-5"),
  fill_scale = scale_fill_gradient2(low = "#08A76B", mid = "white", high = "red",
    midpoint = ifelse(fill_by_p_value, 0, 1)),
  cluster_row = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_group_enrichment_+3A_df_enrich">df_enrich</code></td>
<td>
<p>result <code>data.frame</code> from <a href="#topic+group_enrichment">group_enrichment</a>.</p>
</td></tr>
<tr><td><code id="show_group_enrichment_+3A_return_list">return_list</code></td>
<td>
<p>if <code>TRUE</code>, return a list of <code>ggplot</code> object so user
can combine multiple plots by other R packages like <code>patchwork</code>.</p>
</td></tr>
<tr><td><code id="show_group_enrichment_+3A_scales">scales</code></td>
<td>
<p>Should scales be fixed (<code>"fixed"</code>, the default),
free (<code>"free"</code>), or free in one dimension (<code>"free_x"</code>,
<code>"free_y"</code>)?</p>
</td></tr>
<tr><td><code id="show_group_enrichment_+3A_add_text_annotation">add_text_annotation</code></td>
<td>
<p>if <code>TRUE</code>, add text annotation in box.
When show p value with filled color, the text indicates relative change;
when show relative change with filled color, the text indicates p value.</p>
</td></tr>
<tr><td><code id="show_group_enrichment_+3A_fill_by_p_value">fill_by_p_value</code></td>
<td>
<p>if <code>TRUE</code>, show log10 based p values with filled color.
The +/- of p values indicates change direction.
If p vlaues is mapped to fill, then text shows effect size, and vice versa.</p>
</td></tr>
<tr><td><code id="show_group_enrichment_+3A_use_fdr">use_fdr</code></td>
<td>
<p>if <code>TRUE</code>, show FDR values instead of raw p-values.</p>
</td></tr>
<tr><td><code id="show_group_enrichment_+3A_cut_p_value">cut_p_value</code></td>
<td>
<p>if <code>TRUE</code>, cut p values into 5 regions for better visualization.
Only works when <code>fill_by_p_value = TRUE</code>.</p>
</td></tr>
<tr><td><code id="show_group_enrichment_+3A_cut_breaks">cut_breaks</code></td>
<td>
<p>when <code>cut_p_value</code> is <code>TRUE</code>, this option set the (log10 based) breaks.</p>
</td></tr>
<tr><td><code id="show_group_enrichment_+3A_cut_labels">cut_labels</code></td>
<td>
<p>when <code>cut_p_value</code> is <code>TRUE</code>, this option set the labels.</p>
</td></tr>
<tr><td><code id="show_group_enrichment_+3A_fill_scale">fill_scale</code></td>
<td>
<p>a <code>Scale</code> object generated by <code>ggplot2</code> package to
set color for continuous values.</p>
</td></tr>
<tr><td><code id="show_group_enrichment_+3A_cluster_row">cluster_row</code></td>
<td>
<p>if <code>TRUE</code>, cluster rows with Hierarchical Clustering ('complete' method).</p>
</td></tr>
<tr><td><code id="show_group_enrichment_+3A_...">...</code></td>
<td>
<p>other parameters passing to <a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap</a>, only used
when <code>return_list</code> is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (list of) <code>ggplot</code> object.
</p>

<hr>
<h2 id='show_group_mapping'>Map Groups using Sankey</h2><span id='topic+show_group_mapping'></span>

<h3>Description</h3>

<p>This feature is designed for signature analysis. However, users can also use
it in other similar situations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_group_mapping(
  data,
  col_to_flow,
  cols_to_map,
  include_sig = FALSE,
  fill_na = FALSE,
  title = NULL,
  xlab = NULL,
  ylab = NULL,
  custom_theme = cowplot::theme_minimal_hgrid()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_group_mapping_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing signature group and other categorical groups.</p>
</td></tr>
<tr><td><code id="show_group_mapping_+3A_col_to_flow">col_to_flow</code></td>
<td>
<p>length-1 character showing the column to flow, typically a signature group.</p>
</td></tr>
<tr><td><code id="show_group_mapping_+3A_cols_to_map">cols_to_map</code></td>
<td>
<p>character vector showing colnames of other groups.</p>
</td></tr>
<tr><td><code id="show_group_mapping_+3A_include_sig">include_sig</code></td>
<td>
<p>default if <code>FALSE</code>, if <code>TRUE</code>, showing signature group.</p>
</td></tr>
<tr><td><code id="show_group_mapping_+3A_fill_na">fill_na</code></td>
<td>
<p>length-1 string to fill NA, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="show_group_mapping_+3A_title">title</code></td>
<td>
<p>the title.</p>
</td></tr>
<tr><td><code id="show_group_mapping_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis.</p>
</td></tr>
<tr><td><code id="show_group_mapping_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis.</p>
</td></tr>
<tr><td><code id="show_group_mapping_+3A_custom_theme">custom_theme</code></td>
<td>
<p>theme for plotting, default is <code>cowplot::theme_minimal_hgrid()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- dplyr::tibble(
  Group1 = rep(LETTERS[1:5], each = 10),
  Group2 = rep(LETTERS[6:15], each = 5),
  zzzz = c(rep("xx", 20), rep("yy", 20), rep(NA, 10))
)
p1 &lt;- show_group_mapping(data, col_to_flow = "Group1", cols_to_map = colnames(data)[-1])
p1

p2 &lt;- show_group_mapping(data,
  col_to_flow = "Group1", cols_to_map = colnames(data)[-1],
  include_sig = TRUE
)
p2

</code></pre>

<hr>
<h2 id='show_groups'>Show Signature Contribution in Clusters</h2><span id='topic+show_groups'></span>

<h3>Description</h3>

<p>See example section in <code><a href="#topic+sig_fit">sig_fit()</a></code> for an examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_groups(grp_dt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_groups_+3A_grp_dt">grp_dt</code></td>
<td>
<p>a result <code>data.table</code> from <a href="#topic+get_groups">get_groups</a>.</p>
</td></tr>
<tr><td><code id="show_groups_+3A_...">...</code></td>
<td>
<p>parameters passing to <code><a href="graphics.html#topic+legend">legend()</a></code>, e.g. <code>x = "topleft"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_groups">get_groups</a>, <a href="#topic+sig_fit">sig_fit</a>.
</p>

<hr>
<h2 id='show_sig_bootstrap'>Show Signature Bootstrap Analysis Results</h2><span id='topic+show_sig_bootstrap'></span><span id='topic+show_sig_bootstrap_exposure'></span><span id='topic+show_sig_bootstrap_error'></span><span id='topic+show_sig_bootstrap_stability'></span>

<h3>Description</h3>

<p>See details for description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_sig_bootstrap_exposure(
  bt_result,
  sample = NULL,
  signatures = NULL,
  methods = "QP",
  plot_fun = c("boxplot", "violin"),
  agg_fun = c("mean", "median", "min", "max"),
  highlight = "auto",
  highlight_size = 4,
  palette = "aaas",
  title = NULL,
  xlab = FALSE,
  ylab = "Signature exposure",
  width = 0.3,
  dodge_width = 0.8,
  outlier.shape = NA,
  add = "jitter",
  add.params = list(alpha = 0.3),
  ...
)

show_sig_bootstrap_error(
  bt_result,
  sample = NULL,
  methods = "QP",
  plot_fun = c("boxplot", "violin"),
  agg_fun = c("mean", "median"),
  highlight = "auto",
  highlight_size = 4,
  palette = "aaas",
  title = NULL,
  xlab = FALSE,
  ylab = "Reconstruction error (L2 norm)",
  width = 0.3,
  dodge_width = 0.8,
  outlier.shape = NA,
  add = "jitter",
  add.params = list(alpha = 0.3),
  legend = "none",
  ...
)

show_sig_bootstrap_stability(
  bt_result,
  signatures = NULL,
  measure = c("RMSE", "CV", "MAE", "AbsDiff"),
  methods = "QP",
  plot_fun = c("boxplot", "violin"),
  palette = "aaas",
  title = NULL,
  xlab = FALSE,
  ylab = "Signature instability",
  width = 0.3,
  outlier.shape = NA,
  add = "jitter",
  add.params = list(alpha = 0.3),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_sig_bootstrap_+3A_bt_result">bt_result</code></td>
<td>
<p>result object from <a href="#topic+sig_fit_bootstrap_batch">sig_fit_bootstrap_batch</a>.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_sample">sample</code></td>
<td>
<p>a sample id.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_signatures">signatures</code></td>
<td>
<p>signatures to show.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_methods">methods</code></td>
<td>
<p>a subset of <code>c("NNLS", "QP", "SA")</code>.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_plot_fun">plot_fun</code></td>
<td>
<p>set the plot function.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_agg_fun">agg_fun</code></td>
<td>
<p>set the aggregation function when <code>sample</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_highlight">highlight</code></td>
<td>
<p>set the color for optimal solution. Default is &quot;auto&quot;, which use the same color as
bootstrap results, you can set it to color like &quot;red&quot;, &quot;gold&quot;, etc.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_highlight_size">highlight_size</code></td>
<td>
<p>size for highlighting triangle, default is <code>4</code>.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_palette">palette</code></td>
<td>
<p>the color palette to be used for coloring or filling by groups.
Allowed values include &quot;grey&quot; for grey color palettes; brewer palettes e.g.
&quot;RdBu&quot;, &quot;Blues&quot;, ...; or custom color palette e.g. c(&quot;blue&quot;, &quot;red&quot;); and
scientific journal palettes from ggsci R package, e.g.: &quot;npg&quot;, &quot;aaas&quot;,
&quot;lancet&quot;, &quot;jco&quot;, &quot;ucscgb&quot;, &quot;uchicago&quot;, &quot;simpsons&quot; and &quot;rickandmorty&quot;.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_title">title</code></td>
<td>
<p>plot main title.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_xlab">xlab</code></td>
<td>
<p>character vector specifying x axis labels. Use xlab = FALSE to
hide xlab.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_ylab">ylab</code></td>
<td>
<p>character vector specifying y axis labels. Use ylab = FALSE to
hide ylab.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_width">width</code></td>
<td>
<p>numeric value between 0 and 1 specifying box width.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_dodge_width">dodge_width</code></td>
<td>
<p>dodge width.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_outlier.shape">outlier.shape</code></td>
<td>
<p>point shape of outlier. Default is 19. To hide outlier,
specify <code>outlier.shape = NA</code>. When jitter is added, then outliers will
be automatically hidden.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_add">add</code></td>
<td>
<p>character vector for adding another plot element (e.g.: dot plot or
error bars). Allowed values are one or the combination of: &quot;none&quot;,
&quot;dotplot&quot;, &quot;jitter&quot;, &quot;boxplot&quot;, &quot;point&quot;, &quot;mean&quot;, &quot;mean_se&quot;, &quot;mean_sd&quot;,
&quot;mean_ci&quot;, &quot;mean_range&quot;, &quot;median&quot;, &quot;median_iqr&quot;, &quot;median_hilow&quot;,
&quot;median_q1q3&quot;, &quot;median_mad&quot;, &quot;median_range&quot;; see ?desc_statby for more
details.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_add.params">add.params</code></td>
<td>
<p>parameters (color, shape, size, fill, linetype) for the
argument 'add'; e.g.: add.params = list(color = &quot;red&quot;).</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_...">...</code></td>
<td>
<p>other parameters passing to <a href="ggpubr.html#topic+ggboxplot">ggpubr::ggboxplot</a> or <a href="ggpubr.html#topic+ggviolin">ggpubr::ggviolin</a>.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_legend">legend</code></td>
<td>
<p>character specifying legend position. Allowed values are one of
c(&quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;none&quot;). To remove the legend use
legend = &quot;none&quot;. Legend position can be also specified using a numeric
vector c(x, y); see details section.</p>
</td></tr>
<tr><td><code id="show_sig_bootstrap_+3A_measure">measure</code></td>
<td>
<p>measure to estimate the exposure instability, can be one of 'RMSE', 'CV', 'MAE' and 'AbsDiff'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions:
</p>

<ul>
<li> <p><a href="#topic+show_sig_bootstrap_exposure">show_sig_bootstrap_exposure</a> - this function plots exposures from bootstrap samples with both dotted boxplot.
The optimal exposure (the exposure from original input) is shown as triangle point. <strong>Only one sample can be plotted</strong>.
</p>
</li>
<li> <p><a href="#topic+show_sig_bootstrap_error">show_sig_bootstrap_error</a> - this function plots decomposition errors from bootstrap samples with both dotted boxplot.
The error from optimal solution (the decomposition error from original input) is shown as triangle point. <strong>Only one sample can be plotted</strong>.
</p>
</li>
<li> <p><a href="#topic+show_sig_bootstrap_stability">show_sig_bootstrap_stability</a> - this function plots the signature exposure instability for specified signatures. Currently,
the instability measure supports 3 types:
</p>

<ul>
<li><p> 'RMSE' for Mean Root Squared Error (default) of bootstrap exposures and original exposures for each sample.
</p>
</li>
<li><p> 'CV' for  Coefficient of Variation (CV) based on RMSE (i.e. <code>RMSE / btExposure_mean</code>).
</p>
</li>
<li><p> 'MAE' for Mean Absolute Error of bootstrap exposures and original exposures for each sample.
</p>
</li>
<li><p> 'AbsDiff' for Absolute Difference between mean bootstram exposure and original exposure.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>References</h3>

<p>Huang X, Wojtowicz D, Przytycka TM. Detecting presence of mutational signatures in cancer with confidence. Bioinformatics. 2018;34(2):330–337. doi:10.1093/bioinformatics/btx604
</p>


<h3>See Also</h3>

<p><a href="#topic+sig_fit_bootstrap_batch">sig_fit_bootstrap_batch</a>, <a href="#topic+sig_fit">sig_fit</a>, <a href="#topic+sig_fit_bootstrap">sig_fit_bootstrap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("BSgenome.Hsapiens.UCSC.hg19")) {
  laml.maf &lt;- system.file("extdata", "tcga_laml.maf.gz", package = "maftools")
  laml &lt;- read_maf(maf = laml.maf)
  mt_tally &lt;- sig_tally(
    laml,
    ref_genome = "BSgenome.Hsapiens.UCSC.hg19",
    use_syn = TRUE
  )

  library(NMF)
  mt_sig &lt;- sig_extract(mt_tally$nmf_matrix,
    n_sig = 3,
    nrun = 2,
    cores = 1
  )

  mat &lt;- t(mt_tally$nmf_matrix)
  mat &lt;- mat[, colSums(mat) &gt; 0]
  bt_result &lt;- sig_fit_bootstrap_batch(mat, sig = mt_sig, n = 10)
  ## Parallel computation
  ## bt_result = sig_fit_bootstrap_batch(mat, sig = mt_sig, n = 10, use_parallel = TRUE)

  ## At default, mean bootstrap exposure for each sample has been calculated
  p &lt;- show_sig_bootstrap_exposure(bt_result, methods = c("QP"))
  ## Show bootstrap exposure (optimal exposure is shown as triangle)
  p1 &lt;- show_sig_bootstrap_exposure(bt_result, methods = c("QP"), sample = "TCGA-AB-2802")
  p1
  p2 &lt;- show_sig_bootstrap_exposure(bt_result,
    methods = c("QP"),
    sample = "TCGA-AB-3012",
    signatures = c("Sig1", "Sig2")
  )
  p2

  ## Show bootstrap error
  ## Similar to exposure above
  p &lt;- show_sig_bootstrap_error(bt_result, methods = c("QP"))
  p
  p3 &lt;- show_sig_bootstrap_error(bt_result, methods = c("QP"), sample = "TCGA-AB-2802")
  p3

  ## Show exposure (in)stability
  p4 &lt;- show_sig_bootstrap_stability(bt_result, methods = c("QP"))
  p4
  p5 &lt;- show_sig_bootstrap_stability(bt_result, methods = c("QP"), measure = "MAE")
  p5
  p6 &lt;- show_sig_bootstrap_stability(bt_result, methods = c("QP"), measure = "AbsDiff")
  p6
  p7 &lt;- show_sig_bootstrap_stability(bt_result, methods = c("QP"), measure = "CV")
  p7
} else {
  message("Please install package 'BSgenome.Hsapiens.UCSC.hg19' firstly!")
}

</code></pre>

<hr>
<h2 id='show_sig_consensusmap'>Show Signature Consensus Map</h2><span id='topic+show_sig_consensusmap'></span>

<h3>Description</h3>

<p>This function is a wrapper of <code>NMF::consensusmap()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_sig_consensusmap(
  sig,
  main = "Consensus matrix",
  tracks = c("consensus:", "silhouette:"),
  lab_row = NA,
  lab_col = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_sig_consensusmap_+3A_sig">sig</code></td>
<td>
<p>a <code>Signature</code> object obtained from <a href="#topic+sig_extract">sig_extract</a>.</p>
</td></tr>
<tr><td><code id="show_sig_consensusmap_+3A_main">main</code></td>
<td>
<p>Main title as a character string or a grob.</p>
</td></tr>
<tr><td><code id="show_sig_consensusmap_+3A_tracks">tracks</code></td>
<td>
<p>Special additional annotation tracks to
highlight associations between basis components and
sample clusters: </p>
 <dl>
<dt>basis</dt><dd><p>matches each row
(resp. column) to the most contributing basis component
in <code>basismap</code> (resp. <code>coefmap</code>). In
<code>basismap</code> (resp. <code>coefmap</code>), adding a track
<code>':basis'</code> to <code>annCol</code> (resp. <code>annRow</code>)
makes the column (resp. row) corresponding to the
component being also highlited using the mathcing
colours.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="show_sig_consensusmap_+3A_lab_row">lab_row</code></td>
<td>
<p>labels for the rows.</p>
</td></tr>
<tr><td><code id="show_sig_consensusmap_+3A_lab_col">lab_col</code></td>
<td>
<p>labels for the columns.</p>
</td></tr>
<tr><td><code id="show_sig_consensusmap_+3A_...">...</code></td>
<td>
<p>other parameters passing to <code>NMF::consensusmap()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>

<hr>
<h2 id='show_sig_exposure'>Plot Signature Exposure</h2><span id='topic+show_sig_exposure'></span>

<h3>Description</h3>

<p>Currently support copy number signatures and mutational signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_sig_exposure(
  Signature,
  sig_names = NULL,
  groups = NULL,
  grp_order = NULL,
  grp_size = NULL,
  samps = NULL,
  cutoff = NULL,
  style = c("default", "cosmic"),
  palette = use_color_style(style),
  base_size = 12,
  font_scale = 1,
  rm_space = FALSE,
  rm_grid_line = TRUE,
  rm_panel_border = FALSE,
  hide_samps = TRUE,
  legend_position = "top"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_sig_exposure_+3A_signature">Signature</code></td>
<td>
<p>a <code>Signature</code> object obtained either from <a href="#topic+sig_extract">sig_extract</a> or <a href="#topic+sig_auto_extract">sig_auto_extract</a>,
or just a raw <strong>absolute</strong> exposure matrix with column representing samples (patients) and row
representing signatures (signature names must end with different digital numbers,
e.g. Sig1, Sig10, x12). If you named signatures with letters,
you can specify them by <code>sig_names</code> parameter.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_sig_names">sig_names</code></td>
<td>
<p>set name of signatures, can be a character vector.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_groups">groups</code></td>
<td>
<p>sample groups, default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_grp_order">grp_order</code></td>
<td>
<p>order of groups, default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_grp_size">grp_size</code></td>
<td>
<p>font size of groups.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_samps">samps</code></td>
<td>
<p>sample vector to filter samples or sort samples, default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_cutoff">cutoff</code></td>
<td>
<p>a cutoff value to remove hyper-mutated samples.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_style">style</code></td>
<td>
<p>plot style, one of 'default' and 'cosmic', works when
parameter <code>set_gradient_color</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_palette">palette</code></td>
<td>
<p>palette used to plot, default use a built-in palette
according to parameter <code>style</code>.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_base_size">base_size</code></td>
<td>
<p>overall font size.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_font_scale">font_scale</code></td>
<td>
<p>a number used to set font scale.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_rm_space">rm_space</code></td>
<td>
<p>default is <code>FALSE</code>. If <code>TRUE</code>, it will remove border color
and expand the bar width to 1. This is useful when the sample size is big.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_rm_grid_line">rm_grid_line</code></td>
<td>
<p>default is <code>FALSE</code>, if <code>TRUE</code>, remove grid lines of plot.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_rm_panel_border">rm_panel_border</code></td>
<td>
<p>default is <code>TRUE</code> for style 'cosmic',
remove panel border to keep plot tight.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_hide_samps">hide_samps</code></td>
<td>
<p>if <code>TRUE</code>, hide sample names.</p>
</td></tr>
<tr><td><code id="show_sig_exposure_+3A_legend_position">legend_position</code></td>
<td>
<p>position of legend, default is 'top'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load mutational signature
load(system.file("extdata", "toy_mutational_signature.RData",
  package = "sigminer", mustWork = TRUE
))
# Show signature exposure
p1 &lt;- show_sig_exposure(sig2)
p1

# Load copy number signature
load(system.file("extdata", "toy_copynumber_signature_by_W.RData",
  package = "sigminer", mustWork = TRUE
))
# Show signature exposure
p2 &lt;- show_sig_exposure(sig)
p2

</code></pre>

<hr>
<h2 id='show_sig_feature_corrplot'>Draw Corrplot for Signature Exposures and Other Features</h2><span id='topic+show_sig_feature_corrplot'></span>

<h3>Description</h3>

<p>This function is for association visualization. Of note,
the parameters <code>p_val</code> and <code>drop</code> will affect the visualization
of association results under p value threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_sig_feature_corrplot(
  tidy_cor,
  feature_list,
  sort_features = FALSE,
  sig_orders = NULL,
  drop = TRUE,
  return_plotlist = FALSE,
  p_val = 0.05,
  xlab = "Signatures",
  ylab = "Features",
  co_gradient_colors = scale_color_gradient2(low = "blue", mid = "white", high = "red",
    midpoint = 0),
  ca_gradient_colors = co_gradient_colors,
  plot_ratio = "auto",
  breaks_count = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_sig_feature_corrplot_+3A_tidy_cor">tidy_cor</code></td>
<td>
<p>data returned by <a href="#topic+get_tidy_association">get_tidy_association</a>.</p>
</td></tr>
<tr><td><code id="show_sig_feature_corrplot_+3A_feature_list">feature_list</code></td>
<td>
<p>a character vector contains features want to be plotted.
If missing, all features will be used.</p>
</td></tr>
<tr><td><code id="show_sig_feature_corrplot_+3A_sort_features">sort_features</code></td>
<td>
<p>default is <code>FALSE</code>, use feature order obtained from the previous
step. If <code>TRUE</code>, sort features as <code>feature_list</code>.</p>
</td></tr>
<tr><td><code id="show_sig_feature_corrplot_+3A_sig_orders">sig_orders</code></td>
<td>
<p>signature levels for ordering.</p>
</td></tr>
<tr><td><code id="show_sig_feature_corrplot_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code>, when a feature has no association with all signatures
(p value larger than threshold set by <code>p_val</code>), this feature will be removed
from the plot. Otherwise, this feature (a row) will keep with all blank white.</p>
</td></tr>
<tr><td><code id="show_sig_feature_corrplot_+3A_return_plotlist">return_plotlist</code></td>
<td>
<p>if <code>TRUE</code>, return as a list of <code>ggplot</code> objects.</p>
</td></tr>
<tr><td><code id="show_sig_feature_corrplot_+3A_p_val">p_val</code></td>
<td>
<p>p value threshold. If p value larger than this threshold,
the result becomes blank white.</p>
</td></tr>
<tr><td><code id="show_sig_feature_corrplot_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis.</p>
</td></tr>
<tr><td><code id="show_sig_feature_corrplot_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis.</p>
</td></tr>
<tr><td><code id="show_sig_feature_corrplot_+3A_co_gradient_colors">co_gradient_colors</code></td>
<td>
<p>a Scale object representing gradient colors used to plot for continuous features.</p>
</td></tr>
<tr><td><code id="show_sig_feature_corrplot_+3A_ca_gradient_colors">ca_gradient_colors</code></td>
<td>
<p>a Scale object representing gradient colors used to plot for categorical features.</p>
</td></tr>
<tr><td><code id="show_sig_feature_corrplot_+3A_plot_ratio">plot_ratio</code></td>
<td>
<p>a length-2 numeric vector to set the height/width ratio.</p>
</td></tr>
<tr><td><code id="show_sig_feature_corrplot_+3A_breaks_count">breaks_count</code></td>
<td>
<p>breaks for sample count. If set it to <code>NULL</code>,
ggplot <code>bin</code> scale will be used to automatically determine the
breaks. If set it to <code>NA</code>, <code>aes</code> for sample will be not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot2</code> object
</p>


<h3>See Also</h3>

<p><a href="#topic+get_tidy_association">get_tidy_association</a> and <a href="#topic+get_sig_feature_association">get_sig_feature_association</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The data is generated from Wang, Shixiang et al.
load(system.file("extdata", "asso_data.RData",
  package = "sigminer", mustWork = TRUE
))

p &lt;- show_sig_feature_corrplot(
            tidy_data.seqz.feature,
            p_val = 0.05,
            breaks_count = c(0L,200L, 400L, 600L, 800L, 1020L))
p

</code></pre>

<hr>
<h2 id='show_sig_fit'>Show Signature Fit Result</h2><span id='topic+show_sig_fit'></span>

<h3>Description</h3>

<p>See <a href="#topic+sig_fit">sig_fit</a> for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_sig_fit(
  fit_result,
  samples = NULL,
  signatures = NULL,
  plot_fun = c("boxplot", "violin", "scatter"),
  palette = "aaas",
  title = NULL,
  xlab = FALSE,
  ylab = "Signature exposure",
  legend = "none",
  width = 0.3,
  outlier.shape = NA,
  add = "jitter",
  add.params = list(alpha = 0.3),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_sig_fit_+3A_fit_result">fit_result</code></td>
<td>
<p>result object from <a href="#topic+sig_fit">sig_fit</a>.</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_samples">samples</code></td>
<td>
<p>samples to show, if <code>NULL</code>, all samples are used.</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_signatures">signatures</code></td>
<td>
<p>signatures to show.</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_plot_fun">plot_fun</code></td>
<td>
<p>set the plot function.</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_palette">palette</code></td>
<td>
<p>the color palette to be used for coloring or filling by groups.
Allowed values include &quot;grey&quot; for grey color palettes; brewer palettes e.g.
&quot;RdBu&quot;, &quot;Blues&quot;, ...; or custom color palette e.g. c(&quot;blue&quot;, &quot;red&quot;); and
scientific journal palettes from ggsci R package, e.g.: &quot;npg&quot;, &quot;aaas&quot;,
&quot;lancet&quot;, &quot;jco&quot;, &quot;ucscgb&quot;, &quot;uchicago&quot;, &quot;simpsons&quot; and &quot;rickandmorty&quot;.</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_title">title</code></td>
<td>
<p>plot main title.</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_xlab">xlab</code></td>
<td>
<p>character vector specifying x axis labels. Use xlab = FALSE to
hide xlab.</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_ylab">ylab</code></td>
<td>
<p>character vector specifying y axis labels. Use ylab = FALSE to
hide ylab.</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_legend">legend</code></td>
<td>
<p>character specifying legend position. Allowed values are one of
c(&quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;none&quot;). To remove the legend use
legend = &quot;none&quot;. Legend position can be also specified using a numeric
vector c(x, y); see details section.</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_width">width</code></td>
<td>
<p>numeric value between 0 and 1 specifying box width.</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_outlier.shape">outlier.shape</code></td>
<td>
<p>point shape of outlier. Default is 19. To hide outlier,
specify <code>outlier.shape = NA</code>. When jitter is added, then outliers will
be automatically hidden.</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_add">add</code></td>
<td>
<p>character vector for adding another plot element (e.g.: dot plot or
error bars). Allowed values are one or the combination of: &quot;none&quot;,
&quot;dotplot&quot;, &quot;jitter&quot;, &quot;boxplot&quot;, &quot;point&quot;, &quot;mean&quot;, &quot;mean_se&quot;, &quot;mean_sd&quot;,
&quot;mean_ci&quot;, &quot;mean_range&quot;, &quot;median&quot;, &quot;median_iqr&quot;, &quot;median_hilow&quot;,
&quot;median_q1q3&quot;, &quot;median_mad&quot;, &quot;median_range&quot;; see ?desc_statby for more
details.</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_add.params">add.params</code></td>
<td>
<p>parameters (color, shape, size, fill, linetype) for the
argument 'add'; e.g.: add.params = list(color = &quot;red&quot;).</p>
</td></tr>
<tr><td><code id="show_sig_fit_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to
<code><a href="ggplot2.html#topic+geom_boxplot">geom_boxplot</a></code>, <code><a href="ggpubr.html#topic+ggpar">ggpar</a></code> and
<code><a href="ggpubr.html#topic+facet">facet</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+sig_fit">sig_fit</a>, <a href="#topic+show_sig_bootstrap_exposure">show_sig_bootstrap_exposure</a>, <a href="#topic+sig_fit_bootstrap">sig_fit_bootstrap</a>, <a href="#topic+sig_fit_bootstrap_batch">sig_fit_bootstrap_batch</a>
</p>

<hr>
<h2 id='show_sig_profile'>Show Signature Profile</h2><span id='topic+show_sig_profile'></span>

<h3>Description</h3>

<p>Who don't like to show a barplot for signature profile? This is for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_sig_profile(
  Signature,
  mode = c("SBS", "copynumber", "DBS", "ID", "RS"),
  method = "Wang",
  by_context = FALSE,
  normalize = c("row", "column", "raw", "feature"),
  y_tr = NULL,
  filters = NULL,
  feature_setting = sigminer::CN.features,
  style = c("default", "cosmic"),
  palette = use_color_style(style, ifelse(by_context, "SBS", mode), method),
  set_gradient_color = FALSE,
  free_space = "free_x",
  rm_panel_border = style == "cosmic",
  rm_grid_line = style == "cosmic",
  rm_axis_text = FALSE,
  bar_border_color = ifelse(style == "default", "grey50", "white"),
  bar_width = 0.7,
  paint_axis_text = TRUE,
  x_label_angle = ifelse(mode == "copynumber" &amp; !(startsWith(method, "T") | method ==
    "X"), 60, 90),
  x_label_vjust = ifelse(mode == "copynumber" &amp; !(startsWith(method, "T") | method ==
    "X"), 1, 0.5),
  x_label_hjust = 1,
  x_lab = "Components",
  y_lab = "auto",
  y_limits = NULL,
  params = NULL,
  show_cv = FALSE,
  params_label_size = 3,
  params_label_angle = 60,
  y_expand = 1,
  digits = 2,
  base_size = 12,
  font_scale = 1,
  sig_names = NULL,
  sig_orders = NULL,
  check_sig_names = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_sig_profile_+3A_signature">Signature</code></td>
<td>
<p>a <code>Signature</code> object obtained either from <a href="#topic+sig_extract">sig_extract</a> or <a href="#topic+sig_auto_extract">sig_auto_extract</a>,
or just a raw signature matrix with row representing components (motifs) and column
representing signatures (column names must start with 'Sig').</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_mode">mode</code></td>
<td>
<p>signature type for plotting, now supports 'copynumber', 'SBS',
'DBS', 'ID' and 'RS' (genome rearrangement signature).</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_method">method</code></td>
<td>
<p>method for copy number feature classification in <a href="#topic+sig_tally">sig_tally</a>,
can be one of &quot;Wang&quot; (&quot;W&quot;), &quot;S&quot;.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_by_context">by_context</code></td>
<td>
<p>for specific use.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_normalize">normalize</code></td>
<td>
<p>one of 'row', 'column', 'raw' and &quot;feature&quot;, for row normalization (signature),
column normalization (component), raw data, row normalization by feature, respectively.
Of note, 'feature' only works when the mode is 'copynumber'.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_y_tr">y_tr</code></td>
<td>
<p>a function (e.g. <code>log10</code>) to transform y axis before plotting.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_filters">filters</code></td>
<td>
<p>a pattern used to select components to plot.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_feature_setting">feature_setting</code></td>
<td>
<p>a <code>data.frame</code> used for classification.
<strong>Only used when method is &quot;Wang&quot; (&quot;W&quot;)</strong>.
Default is <a href="#topic+CN.features">CN.features</a>. Users can also set custom input with &quot;feature&quot;,
&quot;min&quot; and &quot;max&quot; columns available. Valid features can be printed by
<code>unique(CN.features$feature)</code>.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_style">style</code></td>
<td>
<p>plot style, one of 'default' and 'cosmic', works when
parameter <code>set_gradient_color</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_palette">palette</code></td>
<td>
<p>palette used to plot when <code>set_gradient_color</code> is <code>FALSE</code>,
default use a built-in palette according to parameter <code>style</code>.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_set_gradient_color">set_gradient_color</code></td>
<td>
<p>default is <code>FALSE</code>, if <code>TRUE</code>, use gradient colors
to fill bars.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_free_space">free_space</code></td>
<td>
<p>default is 'free_x'. If &quot;fixed&quot;, all panels have the same size.
If &quot;free_y&quot; their height will be proportional to the length of the y scale;
if &quot;free_x&quot; their width will be proportional to the length of the x scale;
or if &quot;free&quot; both height and width will vary.
This setting has no effect unless the appropriate scales also vary.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_rm_panel_border">rm_panel_border</code></td>
<td>
<p>default is <code>TRUE</code> for style 'cosmic',
remove panel border to keep plot tight.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_rm_grid_line">rm_grid_line</code></td>
<td>
<p>default is <code>FALSE</code>, if <code>TRUE</code>, remove grid lines of plot.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_rm_axis_text">rm_axis_text</code></td>
<td>
<p>default is <code>FALSE</code>, if <code>TRUE</code>, remove component texts.
This is useful when multiple signature profiles are plotted together.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_bar_border_color">bar_border_color</code></td>
<td>
<p>the color of bar border.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_bar_width">bar_width</code></td>
<td>
<p>bar width. By default, set to 70% of the resolution of the
data.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_paint_axis_text">paint_axis_text</code></td>
<td>
<p>if <code>TRUE</code>, color on text of x axis.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_x_label_angle">x_label_angle</code></td>
<td>
<p>font angle for x label.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_x_label_vjust">x_label_vjust</code></td>
<td>
<p>font vjust for x label.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_x_label_hjust">x_label_hjust</code></td>
<td>
<p>font hjust for x label.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_x_lab">x_lab</code></td>
<td>
<p>x axis lab.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_y_lab">y_lab</code></td>
<td>
<p>y axis lab.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_y_limits">y_limits</code></td>
<td>
<p>limits to expand in y axis. e.g., <code>0.2</code>, <code>c(0, 0.3)</code>.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_params">params</code></td>
<td>
<p>params <code>data.frame</code> of components, obtained from <a href="#topic+sig_tally">sig_tally</a>.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_show_cv">show_cv</code></td>
<td>
<p>default is <code>FALSE</code>, if <code>TRUE</code>, show coefficient of variation when
<code>params</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_params_label_size">params_label_size</code></td>
<td>
<p>font size for params label.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_params_label_angle">params_label_angle</code></td>
<td>
<p>font angle for params label.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_y_expand">y_expand</code></td>
<td>
<p>y expand height for plotting params of copy number signatures.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_digits">digits</code></td>
<td>
<p>digits for plotting params of copy number signatures.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_base_size">base_size</code></td>
<td>
<p>overall font size.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_font_scale">font_scale</code></td>
<td>
<p>a number used to set font scale.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_sig_names">sig_names</code></td>
<td>
<p>subset signatures or set name of signatures, can be a character vector.
Default is <code>NULL</code>, prefix 'Sig' plus number is used.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_sig_orders">sig_orders</code></td>
<td>
<p>set order of signatures, can be a character vector.
Default is <code>NULL</code>, the signatures are ordered by alphabetical order.
If an integer vector set, only specified signatures are plotted.</p>
</td></tr>
<tr><td><code id="show_sig_profile_+3A_check_sig_names">check_sig_names</code></td>
<td>
<p>if <code>TRUE</code>, check signature names when input is
a matrix, i.e., all signatures (colnames) must start with 'Sig'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang
</p>


<h3>See Also</h3>

<p><a href="#topic+show_sig_profile_loop">show_sig_profile_loop</a>, <a href="#topic+show_sig_profile_heatmap">show_sig_profile_heatmap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load SBS signature
load(system.file("extdata", "toy_mutational_signature.RData",
  package = "sigminer", mustWork = TRUE
))
# Show signature profile
p1 &lt;- show_sig_profile(sig2, mode = "SBS")
p1

# Use 'y_tr' option to transform values in y axis
p11 &lt;- show_sig_profile(sig2, mode = "SBS", y_tr = function(x) x * 100)
p11

# Load copy number signature from method "W"
load(system.file("extdata", "toy_copynumber_signature_by_W.RData",
  package = "sigminer", mustWork = TRUE
))
# Show signature profile
p2 &lt;- show_sig_profile(sig,
  style = "cosmic",
  mode = "copynumber",
  method = "W",
  normalize = "feature"
)
p2

# Visualize rearrangement signatures
s &lt;- get_sig_db("RS_Nik_lab")
ss &lt;- s$db[, 1:3]
colnames(ss) &lt;- c("Sig1", "Sig2", "Sig3")
p3 &lt;- show_sig_profile(ss, mode = "RS", style = "cosmic")
p3

</code></pre>

<hr>
<h2 id='show_sig_profile_heatmap'>Show Signature Profile with Heatmap</h2><span id='topic+show_sig_profile_heatmap'></span>

<h3>Description</h3>

<p>This is a complementary function to <code><a href="#topic+show_sig_profile">show_sig_profile()</a></code>, it is used for visualizing
some big signatures, i.e. SBS-1536, not all signatures are supported. See details for
current supported signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_sig_profile_heatmap(
  Signature,
  mode = c("SBS", "DBS"),
  normalize = c("row", "column", "raw"),
  filters = NULL,
  x_lab = NULL,
  y_lab = NULL,
  legend_name = "auto",
  palette = "red",
  x_label_angle = 90,
  x_label_vjust = 1,
  x_label_hjust = 0.5,
  y_label_angle = 0,
  y_label_vjust = 0.5,
  y_label_hjust = 1,
  flip_xy = FALSE,
  sig_names = NULL,
  sig_orders = NULL,
  check_sig_names = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_sig_profile_heatmap_+3A_signature">Signature</code></td>
<td>
<p>a <code>Signature</code> object obtained either from <a href="#topic+sig_extract">sig_extract</a> or <a href="#topic+sig_auto_extract">sig_auto_extract</a>,
or just a raw signature matrix with row representing components (motifs) and column
representing signatures (column names must start with 'Sig').</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_mode">mode</code></td>
<td>
<p>one of &quot;SBS&quot; and &quot;DBS&quot;.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_normalize">normalize</code></td>
<td>
<p>one of 'row', 'column', 'raw' and &quot;feature&quot;, for row normalization (signature),
column normalization (component), raw data, row normalization by feature, respectively.
Of note, 'feature' only works when the mode is 'copynumber'.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_filters">filters</code></td>
<td>
<p>a pattern used to select components to plot.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_x_lab">x_lab</code></td>
<td>
<p>x label.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_y_lab">y_lab</code></td>
<td>
<p>y label.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_legend_name">legend_name</code></td>
<td>
<p>name of figure legend.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_palette">palette</code></td>
<td>
<p>color for value.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_x_label_angle">x_label_angle</code></td>
<td>
<p>angle for x axis text.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_x_label_vjust">x_label_vjust</code></td>
<td>
<p>vjust for x axis text.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_x_label_hjust">x_label_hjust</code></td>
<td>
<p>hjust for x axis text.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_y_label_angle">y_label_angle</code></td>
<td>
<p>angle for y axis text.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_y_label_vjust">y_label_vjust</code></td>
<td>
<p>vjust for y axis text.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_y_label_hjust">y_label_hjust</code></td>
<td>
<p>hjust for y axis text.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_flip_xy">flip_xy</code></td>
<td>
<p>if <code>TRUE</code>, flip x axis and y axis.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_sig_names">sig_names</code></td>
<td>
<p>subset signatures or set name of signatures, can be a character vector.
Default is <code>NULL</code>, prefix 'Sig' plus number is used.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_sig_orders">sig_orders</code></td>
<td>
<p>set order of signatures, can be a character vector.
Default is <code>NULL</code>, the signatures are ordered by alphabetical order.
If an integer vector set, only specified signatures are plotted.</p>
</td></tr>
<tr><td><code id="show_sig_profile_heatmap_+3A_check_sig_names">check_sig_names</code></td>
<td>
<p>if <code>TRUE</code>, check signature names when input is
a matrix, i.e., all signatures (colnames) must start with 'Sig'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Support:
</p>

<ul>
<li><p> SBS-24
</p>
</li>
<li><p> SBS-96
</p>
</li>
<li><p> SBS-384
</p>
</li>
<li><p> SBS-1536
</p>
</li>
<li><p> SBS-6144
</p>
</li>
<li><p> DBS-78
</p>
</li>
<li><p> DBS-186
</p>
</li></ul>



<h3>Value</h3>

<p>a <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load SBS signature
load(system.file("extdata", "toy_mutational_signature.RData",
  package = "sigminer", mustWork = TRUE
))
# Show signature profile
p1 &lt;- show_sig_profile_heatmap(sig2, mode = "SBS")
p1

</code></pre>

<hr>
<h2 id='show_sig_profile_loop'>Show Signature Profile with Loop Way</h2><span id='topic+show_sig_profile_loop'></span>

<h3>Description</h3>

<p>Show Signature Profile with Loop Way
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_sig_profile_loop(
  Signature,
  sig_names = NULL,
  ncol = 1,
  nrow = NULL,
  x_lab = "Components",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_sig_profile_loop_+3A_signature">Signature</code></td>
<td>
<p>a <code>Signature</code> object obtained either from <a href="#topic+sig_extract">sig_extract</a> or <a href="#topic+sig_auto_extract">sig_auto_extract</a>,
or just a raw signature matrix with row representing components (motifs) and column
representing signatures (column names must start with 'Sig').</p>
</td></tr>
<tr><td><code id="show_sig_profile_loop_+3A_sig_names">sig_names</code></td>
<td>
<p>subset signatures or set name of signatures, can be a character vector.
Default is <code>NULL</code>, prefix 'Sig' plus number is used.</p>
</td></tr>
<tr><td><code id="show_sig_profile_loop_+3A_ncol">ncol</code></td>
<td>
<p>(optional) Number of columns in the plot grid.</p>
</td></tr>
<tr><td><code id="show_sig_profile_loop_+3A_nrow">nrow</code></td>
<td>
<p>(optional) Number of rows in the plot grid.</p>
</td></tr>
<tr><td><code id="show_sig_profile_loop_+3A_x_lab">x_lab</code></td>
<td>
<p>x axis lab.</p>
</td></tr>
<tr><td><code id="show_sig_profile_loop_+3A_...">...</code></td>
<td>
<p>other parameters but <code>sig_order</code> passing to <a href="#topic+show_sig_profile">show_sig_profile</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> result from <code>cowplot::plot_grid()</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+show_sig_profile">show_sig_profile</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load(system.file("extdata", "toy_mutational_signature.RData",
  package = "sigminer", mustWork = TRUE
))
# Show signature profile
p1 &lt;- show_sig_profile_loop(sig2, mode = "SBS")
p1
p2 &lt;- show_sig_profile_loop(sig2, mode = "SBS", style = "cosmic", sig_names = c("A", "B", "C"))
p2

</code></pre>

<hr>
<h2 id='sig_auto_extract'>Extract Signatures through the Automatic Relevance Determination Technique</h2><span id='topic+sig_auto_extract'></span>

<h3>Description</h3>

<p>A bayesian variant of NMF algorithm to enable optimal inferences for the
number of signatures through the automatic relevance determination technique.
This functions delevers highly interpretable and sparse representations for
both signature profiles and attributions at a balance between data fitting and
model complexity (this method may introduce more signatures than expected,
especially for copy number signatures (thus <strong>I don't recommend you to use this feature
to extract copy number signatures</strong>)). See detail part and references for more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_auto_extract(
  nmf_matrix = NULL,
  result_prefix = "BayesNMF",
  destdir = tempdir(),
  method = c("L1W.L2H", "L1KL", "L2KL"),
  strategy = c("stable", "optimal", "ms"),
  ref_sigs = NULL,
  K0 = 25,
  nrun = 10,
  niter = 200000,
  tol = 0.0000001,
  cores = 1,
  optimize = FALSE,
  skip = FALSE,
  recover = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_auto_extract_+3A_nmf_matrix">nmf_matrix</code></td>
<td>
<p>a <code>matrix</code> used for NMF decomposition with rows indicate samples and columns indicate components.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_result_prefix">result_prefix</code></td>
<td>
<p>prefix for result data files.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_destdir">destdir</code></td>
<td>
<p>path to save data runs, default is <code>tempdir()</code>.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_method">method</code></td>
<td>
<p>default is &quot;L1W.L2H&quot;, which uses an exponential prior for W and
a half-normal prior for H (This method is used by PCAWG project, see reference #3).
You can also use &quot;L1KL&quot; to set expoential priors for both W and H, and &quot;L2KL&quot; to
set half-normal priors for both W and H. The latter two methods are originally
implemented by SignatureAnalyzer software.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_strategy">strategy</code></td>
<td>
<p>the selection strategy for returned data. Set 'stable' for getting optimal
result from the most frequent K. Set 'optimal' for getting optimal result from all Ks.
Set 'ms' for getting result with maximum mean cosine similarity with provided reference
signatures. See <code>ref_sigs</code> option for details.
If you want select other solution, please check <a href="#topic+get_bayesian_result">get_bayesian_result</a>.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_ref_sigs">ref_sigs</code></td>
<td>
<p>A Signature object or matrix or string for specifying
reference signatures, only used when <code>strategy = 'ms'</code>.
See <code>Signature</code> and <code>sig_db</code> options in <a href="#topic+get_sig_similarity">get_sig_similarity</a> for details.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_k0">K0</code></td>
<td>
<p>number of initial signatures.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_nrun">nrun</code></td>
<td>
<p>number of independent simulations.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_niter">niter</code></td>
<td>
<p>the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_tol">tol</code></td>
<td>
<p>tolerance for convergence.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_cores">cores</code></td>
<td>
<p>number of cpu cores to run NMF.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_optimize">optimize</code></td>
<td>
<p>if <code>TRUE</code>, then refit the denovo signatures with QP method, see <a href="#topic+sig_fit">sig_fit</a>.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_skip">skip</code></td>
<td>
<p>if <code>TRUE</code>, it will skip running a previous stored result. This can be used to
extend run times, e.g. you try running 10 times firstly and then you want to extend it to
20 times.</p>
</td></tr>
<tr><td><code id="sig_auto_extract_+3A_recover">recover</code></td>
<td>
<p>if <code>TRUE</code>, try to recover result from previous runs based on input <code>result_prefix</code>,
<code>destdir</code> and <code>nrun</code>. This is pretty useful for reproducing result. Please use <code>skip</code> if you want
to recover an unfinished job.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three methods available in this function: &quot;L1W.L2H&quot;, &quot;L1KL&quot; and &quot;L2KL&quot;.
They use different priors for the bayesian variant of NMF algorithm
(see <code>method</code> parameter) written by reference #1 and implemented in
SignatureAnalyzer software
(reference #2).
</p>
<p>I copied source code for the three methods from Broad Institute and supplementary
files of reference #3, and wrote this higher function. It is more friendly for users
to extract, visualize and analyze signatures by combining with other powerful functions
in <strong>sigminer</strong> package. Besides, I implemented parallel computation to speed up
the calculation process and a similar input and output structure like <code><a href="#topic+sig_extract">sig_extract()</a></code>.
</p>


<h3>Value</h3>

<p>a <code>list</code> with <code>Signature</code> class.
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang
</p>


<h3>References</h3>

<p>Tan, Vincent YF, and Cédric Févotte. &quot;Automatic relevance determination in nonnegative matrix factorization with the/spl beta/-divergence.&quot;
IEEE Transactions on Pattern Analysis and Machine Intelligence 35.7 (2012): 1592-1605.
</p>
<p>Kim, Jaegil, et al. &quot;Somatic ERCC2 mutations are associated with a distinct genomic signature in urothelial tumors.&quot;
Nature genetics 48.6 (2016): 600.
</p>
<p>Alexandrov, Ludmil, et al. &quot;The repertoire of mutational signatures in human cancer.&quot; BioRxiv (2018): 322859.
</p>


<h3>See Also</h3>

<p><a href="#topic+sig_tally">sig_tally</a> for getting variation matrix,
<a href="#topic+sig_extract">sig_extract</a> for extracting signatures using <strong>NMF</strong> package, <a href="#topic+sig_estimate">sig_estimate</a> for
estimating signature number for <a href="#topic+sig_extract">sig_extract</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load(system.file("extdata", "toy_copynumber_tally_W.RData",
  package = "sigminer", mustWork = TRUE
))
res &lt;- sig_auto_extract(cn_tally_W$nmf_matrix, result_prefix = "Test_copynumber", nrun = 1)
# At default, all run files are stored in tempdir()
dir(tempdir(), pattern = "Test_copynumber")

laml.maf &lt;- system.file("extdata", "tcga_laml.maf.gz", package = "maftools")
laml &lt;- read_maf(maf = laml.maf)
mt_tally &lt;- sig_tally(
  laml,
  ref_genome = "BSgenome.Hsapiens.UCSC.hg19",
  use_syn = TRUE
)

x &lt;- sig_auto_extract(mt_tally$nmf_matrix,
  strategy = "ms", nrun = 3, ref_sigs = "legacy"
)
x

</code></pre>

<hr>
<h2 id='sig_convert'>Convert Signatures between different Genomic Distribution of Components</h2><span id='topic+sig_convert'></span>

<h3>Description</h3>

<p>Converts signatures between two representations relative to different sets of mutational opportunities.
Currently, only SBS signature is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_convert(sig, from = "human-genome", to = "human-exome")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_convert_+3A_sig">sig</code></td>
<td>
<p>a <code>Signature</code> object obtained either from <a href="#topic+sig_extract">sig_extract</a> or <a href="#topic+sig_auto_extract">sig_auto_extract</a>,
or just a raw signature matrix/<code>data.frame</code> with row representing components (motifs) and
column representing signatures.</p>
</td></tr>
<tr><td><code id="sig_convert_+3A_from">from</code></td>
<td>
<p>either one of &quot;human-genome&quot; and &quot;human-exome&quot; or an opportunity matrix
(repeated <code>n</code> columns with each row represents the total number of mutations for
a component, <code>n</code> is the number of signature).</p>
</td></tr>
<tr><td><code id="sig_convert_+3A_to">to</code></td>
<td>
<p>same as <code>from</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default opportunity matrix for &quot;human-genome&quot; and &quot;human-exome&quot; comes from COSMIC
signature database v2 and v3.
</p>


<h3>Value</h3>

<p>a <code>matrix</code>.
</p>


<h3>References</h3>

<p><code>convert_signatures</code> function from sigfit package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load SBS signature
load(system.file("extdata", "toy_mutational_signature.RData",
  package = "sigminer", mustWork = TRUE
))
# Exome-relative to Genome-relative
sig_converted &lt;- sig_convert(sig2,
  from = "human-exome",
  to = "human-genome"
)
sig_converted


show_sig_profile(sig2, style = "cosmic")
show_sig_profile(sig_converted, style = "cosmic")

</code></pre>

<hr>
<h2 id='sig_estimate'>Estimate Signature Number</h2><span id='topic+sig_estimate'></span><span id='topic+show_sig_number_survey'></span><span id='topic+show_sig_number_survey2'></span>

<h3>Description</h3>

<p>Use <strong>NMF</strong> package to evaluate the optimal number of signatures.
This is used along with <a href="#topic+sig_extract">sig_extract</a>.
Users should <code>library(NMF)</code> firstly. If NMF objects are returned,
the result can be further visualized by NMF plot methods like
<code>NMF::consensusmap()</code> and <code>NMF::basismap()</code>.
</p>
<p><code>sig_estimate()</code> shows comprehensive rank survey generated by
<strong>NMF</strong> package, sometimes
it is hard to consider all measures. <code>show_sig_number_survey()</code> provides a
one or two y-axis visualization method to help users determine
the optimal signature number (showing both
stability (&quot;cophenetic&quot;) and error (RSS) at default).
Users can also set custom measures to show.
</p>
<p><code>show_sig_number_survey2()</code> is modified from <strong>NMF</strong> package to
better help users to explore survey of signature number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_estimate(
  nmf_matrix,
  range = 2:5,
  nrun = 10,
  use_random = FALSE,
  method = "brunet",
  seed = 123456,
  cores = 1,
  keep_nmfObj = FALSE,
  save_plots = FALSE,
  plot_basename = file.path(tempdir(), "nmf"),
  what = "all",
  verbose = FALSE
)

show_sig_number_survey(
  object,
  x = "rank",
  left_y = "cophenetic",
  right_y = "rss",
  left_name = left_y,
  right_name = toupper(right_y),
  left_color = "black",
  right_color = "red",
  left_shape = 16,
  right_shape = 18,
  shape_size = 4,
  highlight = NULL
)

show_sig_number_survey2(
  x,
  y = NULL,
  what = c("all", "cophenetic", "rss", "residuals", "dispersion", "evar", "sparseness",
    "sparseness.basis", "sparseness.coef", "silhouette", "silhouette.coef",
    "silhouette.basis", "silhouette.consensus"),
  na.rm = FALSE,
  xlab = "Total signatures",
  ylab = "",
  main = "Signature number survey using NMF package"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_estimate_+3A_nmf_matrix">nmf_matrix</code></td>
<td>
<p>a <code>matrix</code> used for NMF decomposition with rows indicate samples and columns indicate components.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_range">range</code></td>
<td>
<p>a <code>numeric</code> vector containing the ranks of factorization to try. Note that duplicates are removed
and values are sorted in increasing order. The results are notably returned in this order.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_nrun">nrun</code></td>
<td>
<p>a <code>numeric</code> giving the number of run to perform for each value in <code>range</code>, <code>nrun</code> set to 30~50 is
enough to achieve robust result.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_use_random">use_random</code></td>
<td>
<p>Should generate random data from input to test measurements. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_method">method</code></td>
<td>
<p>specification of the NMF algorithm. Use 'brunet' as default.
Available methods for NMF decompositions are 'brunet', 'lee', 'ls-nmf', 'nsNMF', 'offset'.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_seed">seed</code></td>
<td>
<p>specification of the starting point or seeding method, which will compute a starting point,
usually using data from the target matrix in order to provide a good guess.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_cores">cores</code></td>
<td>
<p>number of cpu cores to run NMF.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_keep_nmfobj">keep_nmfObj</code></td>
<td>
<p>default is <code>FALSE</code>, if <code>TRUE</code>, keep NMF objects from runs, and the result may be huge.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_save_plots">save_plots</code></td>
<td>
<p>if <code>TRUE</code>, save signature number survey plot to local machine.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_plot_basename">plot_basename</code></td>
<td>
<p>when save plots, set custom basename for file path.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_what">what</code></td>
<td>
<p>a character vector whose elements partially match one of the following item,
which correspond to the measures computed by <code>summary()</code> on each – multi-run – NMF result:
'all', 'cophenetic', 'rss', 'residuals', 'dispersion', 'evar', 'silhouette'
(and more specific <code style="white-space: pre;">&#8288;*.coef&#8288;</code>, <code style="white-space: pre;">&#8288;*.basis&#8288;</code>, <code style="white-space: pre;">&#8288;*.consensus&#8288;</code>), 'sparseness'
(and more specific <code style="white-space: pre;">&#8288;*.coef&#8288;</code>, <code style="white-space: pre;">&#8288;*.basis&#8288;</code>).
It specifies which measure must be plotted (what='all' plots all the measures).</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print extra message.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_object">object</code></td>
<td>
<p>a <code>Survey</code> object generated from <a href="#topic+sig_estimate">sig_estimate</a>, or
a <code>data.frame</code> contains at least rank columns and columns for
one measure.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_x">x</code></td>
<td>
<p>a <code>data.frame</code> or <code>NMF.rank</code> object obtained from <code><a href="#topic+sig_estimate">sig_estimate()</a></code>.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_left_y">left_y</code></td>
<td>
<p>column name for left y axis.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_right_y">right_y</code></td>
<td>
<p>column name for right y axis.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_left_name">left_name</code></td>
<td>
<p>label name for left y axis.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_right_name">right_name</code></td>
<td>
<p>label name for right y axis.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_left_color">left_color</code></td>
<td>
<p>color for left axis.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_right_color">right_color</code></td>
<td>
<p>color for right axis.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_left_shape">left_shape</code>, <code id="sig_estimate_+3A_right_shape">right_shape</code>, <code id="sig_estimate_+3A_shape_size">shape_size</code></td>
<td>
<p>shape setting.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_highlight">highlight</code></td>
<td>
<p>a <code>integer</code> to highlight a <code>x</code>.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_y">y</code></td>
<td>
<p>for random simulation,
a <code>data.frame</code> or <code>NMF.rank</code> object obtained from <code><a href="#topic+sig_estimate">sig_estimate()</a></code>.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_na.rm">na.rm</code></td>
<td>
<p>single logical that specifies if the rank
for which the measures are NA values should be removed
from the graph or not (default to <code>FALSE</code>).  This is
useful when plotting results which include NAs due to
error during the estimation process. See argument
<code>stop</code> for <code>nmfEstimateRank</code>.</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="sig_estimate_+3A_main">main</code></td>
<td>
<p>main title</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most common approach is to choose the smallest rank for which cophenetic correlation coefficient
starts decreasing (Used by this function). Another approach is to choose the rank for which the plot
of the residual sum of squares (RSS) between the input matrix and its estimate shows an inflection point.
More custom features please directly use <a href="NMF.html#topic+nmfEstimateRank">NMF::nmfEstimateRank</a>.
</p>


<h3>Value</h3>


<ul>
<li><p> sig_estimate: a <code>list</code> contains information of NMF run and rank survey.
</p>
</li></ul>


<ul>
<li><p> show_sig_number_survey: a <code>ggplot</code> object
</p>
</li></ul>


<ul>
<li><p> show_sig_number_survey2: a <code>ggplot</code> object
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Shixiang Wang
</p>


<h3>References</h3>

<p>Gaujoux, Renaud, and Cathal Seoighe. &quot;A flexible R package for nonnegative matrix factorization.&quot; BMC bioinformatics 11.1 (2010): 367.
</p>


<h3>See Also</h3>

<p><a href="#topic+sig_extract">sig_extract</a> for extracting signatures using <strong>NMF</strong> package, <a href="#topic+sig_auto_extract">sig_auto_extract</a> for
extracting signatures using automatic relevance determination technique.
</p>
<p><a href="#topic+sig_estimate">sig_estimate</a> for estimating signature number for <a href="#topic+sig_extract">sig_extract</a>,
<a href="#topic+show_sig_number_survey2">show_sig_number_survey2</a> for more visualization method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load(system.file("extdata", "toy_copynumber_tally_W.RData",
  package = "sigminer", mustWork = TRUE
))
library(NMF)
cn_estimate &lt;- sig_estimate(cn_tally_W$nmf_matrix,
  cores = 1, nrun = 5,
  verbose = TRUE
)

p &lt;- show_sig_number_survey2(cn_estimate$survey)
p

# Show two measures
show_sig_number_survey(cn_estimate)
# Show one measure
p1 &lt;- show_sig_number_survey(cn_estimate, right_y = NULL)
p1
p2 &lt;- add_h_arrow(p, x = 4.1, y = 0.953, label = "selected number")
p2

# Show data from a data.frame
p3 &lt;- show_sig_number_survey(cn_estimate$survey)
p3
# Show other measures
head(cn_estimate$survey)
p4 &lt;- show_sig_number_survey(cn_estimate$survey,
  right_y = "dispersion",
  right_name = "dispersion"
)
p4
p5 &lt;- show_sig_number_survey(cn_estimate$survey,
  right_y = "evar",
  right_name = "evar"
)
p5

</code></pre>

<hr>
<h2 id='sig_extract'>Extract Signatures through NMF</h2><span id='topic+sig_extract'></span>

<h3>Description</h3>

<p>Do NMF de-composition and then extract signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_extract(
  nmf_matrix,
  n_sig,
  nrun = 10,
  cores = 1,
  method = "brunet",
  optimize = FALSE,
  pynmf = FALSE,
  use_conda = TRUE,
  py_path = "/Users/wsx/anaconda3/bin/python",
  seed = 123456,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_extract_+3A_nmf_matrix">nmf_matrix</code></td>
<td>
<p>a <code>matrix</code> used for NMF decomposition with rows indicate samples and columns indicate components.</p>
</td></tr>
<tr><td><code id="sig_extract_+3A_n_sig">n_sig</code></td>
<td>
<p>number of signature. Please run <a href="#topic+sig_estimate">sig_estimate</a> to select a suitable value.</p>
</td></tr>
<tr><td><code id="sig_extract_+3A_nrun">nrun</code></td>
<td>
<p>a <code>numeric</code> giving the number of run to perform for each value in <code>range</code>, <code>nrun</code> set to 30~50 is
enough to achieve robust result.</p>
</td></tr>
<tr><td><code id="sig_extract_+3A_cores">cores</code></td>
<td>
<p>number of cpu cores to run NMF.</p>
</td></tr>
<tr><td><code id="sig_extract_+3A_method">method</code></td>
<td>
<p>specification of the NMF algorithm. Use 'brunet' as default.
Available methods for NMF decompositions are 'brunet', 'lee', 'ls-nmf', 'nsNMF', 'offset'.</p>
</td></tr>
<tr><td><code id="sig_extract_+3A_optimize">optimize</code></td>
<td>
<p>if <code>TRUE</code>, then refit the denovo signatures with QP method, see <a href="#topic+sig_fit">sig_fit</a>.</p>
</td></tr>
<tr><td><code id="sig_extract_+3A_pynmf">pynmf</code></td>
<td>
<p>if <code>TRUE</code>, use Python NMF driver <a href="http://nimfa.biolab.si/index.html">Nimfa</a>.
The seed currently is not used by this implementation.</p>
</td></tr>
<tr><td><code id="sig_extract_+3A_use_conda">use_conda</code></td>
<td>
<p>if <code>TRUE</code>, create an independent conda environment to run NMF.</p>
</td></tr>
<tr><td><code id="sig_extract_+3A_py_path">py_path</code></td>
<td>
<p>path to Python executable file, e.g. '/Users/wsx/anaconda3/bin/python'. In my
test, it is more stable than <code>use_conda=TRUE</code>. You can install the Nimfa package by yourself
or set <code>use_conda</code> to <code>TRUE</code> to install required Python environment, and then set this option.</p>
</td></tr>
<tr><td><code id="sig_extract_+3A_seed">seed</code></td>
<td>
<p>specification of the starting point or seeding method, which will compute a starting point,
usually using data from the target matrix in order to provide a good guess.</p>
</td></tr>
<tr><td><code id="sig_extract_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="NMF.html#topic+nmf">NMF::nmf()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> with <code>Signature</code> class.
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang
</p>


<h3>References</h3>

<p>Gaujoux, Renaud, and Cathal Seoighe. &quot;A flexible R package for nonnegative matrix factorization.&quot; BMC bioinformatics 11.1 (2010): 367.
</p>
<p>Mayakonda, Anand, et al. &quot;Maftools: efficient and comprehensive analysis of somatic variants in cancer.&quot; Genome research 28.11 (2018): 1747-1756.
</p>


<h3>See Also</h3>

<p><a href="#topic+sig_tally">sig_tally</a> for getting variation matrix,
<a href="#topic+sig_estimate">sig_estimate</a> for estimating signature number for <a href="#topic+sig_extract">sig_extract</a>, <a href="#topic+sig_auto_extract">sig_auto_extract</a> for
extracting signatures using automatic relevance determination technique.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load(system.file("extdata", "toy_copynumber_tally_W.RData",
  package = "sigminer", mustWork = TRUE
))
# Extract copy number signatures
res &lt;- sig_extract(cn_tally_W$nmf_matrix, 2, nrun = 1)

</code></pre>

<hr>
<h2 id='sig_fit'>Fit Signature Exposures with Linear Combination Decomposition</h2><span id='topic+sig_fit'></span>

<h3>Description</h3>

<p>The function performs a signatures decomposition of a given mutational
catalogue <code>V</code> with known signatures <code>W</code> by solving the minimization problem
<code style="white-space: pre;">&#8288;min(||W*H - V||)&#8288;</code> where W and V are known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_fit(
  catalogue_matrix,
  sig,
  sig_index = NULL,
  sig_db = c("legacy", "SBS", "DBS", "ID", "TSB", "SBS_Nik_lab", "RS_Nik_lab",
    "RS_BRCA560", "RS_USARC", "CNS_USARC", "CNS_TCGA", "CNS_TCGA176", "CNS_PCAWG176",
    "SBS_hg19", "SBS_hg38", "SBS_mm9", "SBS_mm10", "DBS_hg19", "DBS_hg38", "DBS_mm9",
    "DBS_mm10", "SBS_Nik_lab_Organ", "RS_Nik_lab_Organ", "latest_SBS_GRCh37",
    "latest_DBS_GRCh37", "latest_ID_GRCh37", "latest_SBS_GRCh38", "latest_DBS_GRCh38",
    "latest_SBS_mm9", "latest_DBS_mm9", "latest_SBS_mm10", "latest_DBS_mm10",
    "latest_SBS_rn6", "latest_DBS_rn6", "latest_CN_GRCh37", 
    
    "latest_RNA-SBS_GRCh37", "latest_SV_GRCh38"),
  db_type = c("", "human-exome", "human-genome"),
  show_index = TRUE,
  method = c("QP", "NNLS", "SA"),
  auto_reduce = FALSE,
  type = c("absolute", "relative"),
  return_class = c("matrix", "data.table"),
  return_error = FALSE,
  rel_threshold = 0,
  mode = c("SBS", "DBS", "ID", "copynumber"),
  true_catalog = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_fit_+3A_catalogue_matrix">catalogue_matrix</code></td>
<td>
<p>a numeric matrix <code>V</code> with row representing components and
columns representing samples, typically you can get <code>nmf_matrix</code> from <code>sig_tally()</code> and
transpose it by <code>t()</code>.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_sig">sig</code></td>
<td>
<p>a <code>Signature</code> object obtained either from <a href="#topic+sig_extract">sig_extract</a> or <a href="#topic+sig_auto_extract">sig_auto_extract</a>,
or just a raw signature matrix/<code>data.frame</code> with row representing components (motifs) and
column representing signatures.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_sig_index">sig_index</code></td>
<td>
<p>a vector for signature index. &quot;ALL&quot; for all signatures.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_sig_db">sig_db</code></td>
<td>
<p>default 'legacy', it can be 'legacy' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures_v2.tt/">COSMIC v2 'SBS'</a>),
'SBS', 'DBS', 'ID' and 'TSB' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures/">COSMIV v3.1 signatures</a>)
for small scale mutations.
For more specific details, it can also be 'SBS_hg19', 'SBS_hg38',
'SBS_mm9', 'SBS_mm10', 'DBS_hg19', 'DBS_hg38', 'DBS_mm9', 'DBS_mm10' to use
COSMIC v3 reference signatures from Alexandrov, Ludmil B., et al. (2020) (reference #1).
In addition, it can be one of &quot;SBS_Nik_lab_Organ&quot;, &quot;RS_Nik_lab_Organ&quot;,
&quot;SBS_Nik_lab&quot;, &quot;RS_Nik_lab&quot; to refer reference signatures from
Degasperi, Andrea, et al. (2020) (reference #2);
&quot;RS_BRCA560&quot;, &quot;RS_USARC&quot; to reference signatures from BRCA560 and USARC cohorts;
&quot;CNS_USARC&quot; (40 categories), &quot;CNS_TCGA&quot; (48 categories) to reference copy number signatures from USARC cohort and TCGA;
&quot;CNS_TCGA176&quot; (176 categories) and &quot;CNS_PCAWG176&quot; (176 categories) to reference copy number signatures from PCAWG and TCGA separately.
<strong>UPDATE</strong>, the latest version of reference version can be automatically
downloaded and loaded from <a href="https://cancer.sanger.ac.uk/signatures/downloads/">https://cancer.sanger.ac.uk/signatures/downloads/</a>
when a option with <code>latest_</code> prefix is specified (e.g. &quot;latest_SBS_GRCh37&quot;).
<strong>Note</strong>: the signature profile for different genome builds are basically same.
And specific database (e.g. 'SBS_mm10') contains less signatures than all COSMIC
signatures (because some signatures are not detected from Alexandrov, Ludmil B., et al. (2020)).
For all available options, check the parameter setting.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_db_type">db_type</code></td>
<td>
<p>only used when <code>sig_db</code> is enabled.
&quot;&quot; for keeping default, &quot;human-exome&quot; for transforming to exome frequency of component,
and &quot;human-genome&quot; for transforming to whole genome frequency of component.
Currently only works for 'SBS'.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_show_index">show_index</code></td>
<td>
<p>if <code>TRUE</code>, show valid indices.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_method">method</code></td>
<td>
<p>method to solve the minimazation problem.
'NNLS' for non-negative least square; 'QP' for quadratic programming; 'SA' for simulated annealing.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_auto_reduce">auto_reduce</code></td>
<td>
<p>if <code>TRUE</code>, try reducing the input reference signatures to increase
the cosine similarity of reconstructed profile to observed profile.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_type">type</code></td>
<td>
<p>'absolute' for signature exposure and 'relative' for signature relative exposure.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_return_class">return_class</code></td>
<td>
<p>string, 'matrix' or 'data.table'.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_return_error">return_error</code></td>
<td>
<p>if <code>TRUE</code>, also return sample error (Frobenius norm) and cosine
similarity between observed sample profile (asa. spectrum) and reconstructed profile. NOTE:
it is better to obtain the error when the type is 'absolute', because the error is
affected by relative exposure accuracy.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_rel_threshold">rel_threshold</code></td>
<td>
<p>numeric vector, a signature with relative exposure
lower than (equal is included, i.e. <code>&lt;=</code>) this value will be set to 0
(both absolute exposure and relative exposure).
In this case, sum of signature contribution may not equal to 1.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_mode">mode</code></td>
<td>
<p>signature type for plotting, now supports 'copynumber', 'SBS',
'DBS', 'ID' and 'RS' (genome rearrangement signature).</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_true_catalog">true_catalog</code></td>
<td>
<p>used by <a href="#topic+sig_fit_bootstrap">sig_fit_bootstrap</a>, user never use it.</p>
</td></tr>
<tr><td><code id="sig_fit_+3A_...">...</code></td>
<td>
<p>control parameters passing to argument <code>control</code> in <code>GenSA</code> function when use method 'SA'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method 'NNLS' solves the minimization problem with nonnegative least-squares constraints.
The method 'QP' and 'SA' are modified from SignatureEstimation package.
See references for details.
Of note, when fitting exposures for copy number signatures, only components of
feature CN is used.
</p>


<h3>Value</h3>

<p>The exposure result either in <code>matrix</code> or <code>data.table</code> format.
If <code>return_error</code> set <code>TRUE</code>, a <code>list</code> is returned.
</p>


<h3>References</h3>

<p>Daniel Huebschmann, Zuguang Gu and Matthias Schlesner (2019). YAPSA: Yet Another Package for Signature Analysis. R package version 1.12.0.
</p>
<p>Huang X, Wojtowicz D, Przytycka TM. Detecting presence of mutational signatures in cancer with confidence. Bioinformatics. 2018;34(2):330–337. doi:10.1093/bioinformatics/btx604
</p>
<p>Kim, Jaegil, et al. &quot;Somatic ERCC2 mutations are associated with a distinct genomic signature in urothelial tumors.&quot;
Nature genetics 48.6 (2016): 600.
</p>


<h3>See Also</h3>

<p><a href="#topic+sig_extract">sig_extract</a>, <a href="#topic+sig_auto_extract">sig_auto_extract</a>, <a href="#topic+sig_fit_bootstrap">sig_fit_bootstrap</a>, <a href="#topic+sig_fit_bootstrap_batch">sig_fit_bootstrap_batch</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
W &lt;- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2)
colnames(W) &lt;- c("sig1", "sig2")
W &lt;- apply(W, 2, function(x) x / sum(x))

H &lt;- matrix(c(2, 5, 3, 6, 1, 9, 1, 2), ncol = 4)
colnames(H) &lt;- paste0("samp", 1:4)

V &lt;- W %*% H
V

if (requireNamespace("quadprog", quietly = TRUE)) {
  H_infer &lt;- sig_fit(V, W, method = "QP")
  H_infer
  H

  H_dt &lt;- sig_fit(V, W, method = "QP", auto_reduce = TRUE, return_class = "data.table")
  H_dt

  ## Show results
  show_sig_fit(H_infer)
  show_sig_fit(H_dt)

  ## Get clusters/groups
  H_dt_rel &lt;- sig_fit(V, W, return_class = "data.table", type = "relative")
  z &lt;- get_groups(H_dt_rel, method = "k-means")
  show_groups(z)
}

# if (requireNamespace("GenSA", quietly = TRUE)) {
#   H_infer &lt;- sig_fit(V, W, method = "SA")
#   H_infer
#   H
#
#   H_dt &lt;- sig_fit(V, W, method = "SA", return_class = "data.table")
#   H_dt
#
#   ## Modify arguments to method
#   sig_fit(V, W, method = "SA", maxit = 10, temperature = 100)
#
#   ## Show results
#   show_sig_fit(H_infer)
#   show_sig_fit(H_dt)
# }

</code></pre>

<hr>
<h2 id='sig_fit_bootstrap'>Obtain Bootstrap Distribution of Signature Exposures of a Certain Tumor Sample</h2><span id='topic+sig_fit_bootstrap'></span>

<h3>Description</h3>

<p>This can be used to obtain the confidence of signature exposures or search
the suboptimal decomposition solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_fit_bootstrap(
  catalog,
  sig,
  n = 100L,
  sig_index = NULL,
  sig_db = "legacy",
  db_type = c("", "human-exome", "human-genome"),
  show_index = TRUE,
  method = c("QP", "NNLS", "SA"),
  auto_reduce = FALSE,
  SA_not_bootstrap = FALSE,
  type = c("absolute", "relative"),
  rel_threshold = 0,
  mode = c("SBS", "DBS", "ID", "copynumber"),
  find_suboptimal = FALSE,
  suboptimal_ref_error = NULL,
  suboptimal_factor = 1.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_fit_bootstrap_+3A_catalog">catalog</code></td>
<td>
<p>a named numeric vector or a numeric matrix with dimension Nx1.
N is the number of component, 1 is the sample.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_sig">sig</code></td>
<td>
<p>a <code>Signature</code> object obtained either from <a href="#topic+sig_extract">sig_extract</a> or <a href="#topic+sig_auto_extract">sig_auto_extract</a>,
or just a raw signature matrix/<code>data.frame</code> with row representing components (motifs) and
column representing signatures.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_n">n</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_sig_index">sig_index</code></td>
<td>
<p>a vector for signature index. &quot;ALL&quot; for all signatures.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_sig_db">sig_db</code></td>
<td>
<p>default 'legacy', it can be 'legacy' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures_v2.tt/">COSMIC v2 'SBS'</a>),
'SBS', 'DBS', 'ID' and 'TSB' (for <a href="https://cancer.sanger.ac.uk/cosmic/signatures/">COSMIV v3.1 signatures</a>)
for small scale mutations.
For more specific details, it can also be 'SBS_hg19', 'SBS_hg38',
'SBS_mm9', 'SBS_mm10', 'DBS_hg19', 'DBS_hg38', 'DBS_mm9', 'DBS_mm10' to use
COSMIC v3 reference signatures from Alexandrov, Ludmil B., et al. (2020) (reference #1).
In addition, it can be one of &quot;SBS_Nik_lab_Organ&quot;, &quot;RS_Nik_lab_Organ&quot;,
&quot;SBS_Nik_lab&quot;, &quot;RS_Nik_lab&quot; to refer reference signatures from
Degasperi, Andrea, et al. (2020) (reference #2);
&quot;RS_BRCA560&quot;, &quot;RS_USARC&quot; to reference signatures from BRCA560 and USARC cohorts;
&quot;CNS_USARC&quot; (40 categories), &quot;CNS_TCGA&quot; (48 categories) to reference copy number signatures from USARC cohort and TCGA;
&quot;CNS_TCGA176&quot; (176 categories) and &quot;CNS_PCAWG176&quot; (176 categories) to reference copy number signatures from PCAWG and TCGA separately.
<strong>UPDATE</strong>, the latest version of reference version can be automatically
downloaded and loaded from <a href="https://cancer.sanger.ac.uk/signatures/downloads/">https://cancer.sanger.ac.uk/signatures/downloads/</a>
when a option with <code>latest_</code> prefix is specified (e.g. &quot;latest_SBS_GRCh37&quot;).
<strong>Note</strong>: the signature profile for different genome builds are basically same.
And specific database (e.g. 'SBS_mm10') contains less signatures than all COSMIC
signatures (because some signatures are not detected from Alexandrov, Ludmil B., et al. (2020)).
For all available options, check the parameter setting.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_db_type">db_type</code></td>
<td>
<p>only used when <code>sig_db</code> is enabled.
&quot;&quot; for keeping default, &quot;human-exome&quot; for transforming to exome frequency of component,
and &quot;human-genome&quot; for transforming to whole genome frequency of component.
Currently only works for 'SBS'.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_show_index">show_index</code></td>
<td>
<p>if <code>TRUE</code>, show valid indices.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_method">method</code></td>
<td>
<p>method to solve the minimazation problem.
'NNLS' for non-negative least square; 'QP' for quadratic programming; 'SA' for simulated annealing.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_auto_reduce">auto_reduce</code></td>
<td>
<p>if <code>TRUE</code>, try reducing the input reference signatures to increase
the cosine similarity of reconstructed profile to observed profile.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_sa_not_bootstrap">SA_not_bootstrap</code></td>
<td>
<p>if <code>TRUE</code>, directly run 'SA' multiple times with original input instead of
bootstrap samples.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_type">type</code></td>
<td>
<p>'absolute' for signature exposure and 'relative' for signature relative exposure.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_rel_threshold">rel_threshold</code></td>
<td>
<p>numeric vector, a signature with relative exposure
lower than (equal is included, i.e. <code>&lt;=</code>) this value will be set to 0
(both absolute exposure and relative exposure).
In this case, sum of signature contribution may not equal to 1.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_mode">mode</code></td>
<td>
<p>signature type for plotting, now supports 'copynumber', 'SBS',
'DBS', 'ID' and 'RS' (genome rearrangement signature).</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_find_suboptimal">find_suboptimal</code></td>
<td>
<p>logical, if <code>TRUE</code>, find suboptimal decomposition with
slightly higher error than the optimal solution by method 'SA'. This is useful
to explore hidden dependencies between signatures. More see reference.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_suboptimal_ref_error">suboptimal_ref_error</code></td>
<td>
<p>baseline error used for finding suboptimal solution.
if it is <code>NULL</code>, then use 'SA' method to obtain the optimal error.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_suboptimal_factor">suboptimal_factor</code></td>
<td>
<p>suboptimal factor to get suboptimal error, default is <code>1.05</code>,
i.e., suboptimal error is <code>1.05</code> times baseline error.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_+3A_...">...</code></td>
<td>
<p>control parameters passing to argument <code>control</code> in <code>GenSA</code> function when use method 'SA'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code>
</p>


<h3>References</h3>

<p>Huang X, Wojtowicz D, Przytycka TM. Detecting presence of mutational signatures in cancer with confidence. Bioinformatics. 2018;34(2):330–337. doi:10.1093/bioinformatics/btx604
</p>


<h3>See Also</h3>

<p><a href="#topic+report_bootstrap_p_value">report_bootstrap_p_value</a>, <a href="#topic+sig_fit">sig_fit</a>, <a href="#topic+sig_fit_bootstrap_batch">sig_fit_bootstrap_batch</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2)
colnames(W) &lt;- c("sig1", "sig2")
W &lt;- apply(W, 2, function(x) x / sum(x))

H &lt;- matrix(c(2, 5, 3, 6, 1, 9, 1, 2), ncol = 4)
colnames(H) &lt;- paste0("samp", 1:4)

V &lt;- W %*% H
V

if (requireNamespace("quadprog", quietly = TRUE)) {
  H_bootstrap &lt;- sig_fit_bootstrap(V[, 1], W, n = 10, type = "absolute")
  ## Typically, you have to run many times to get close to the answer
  boxplot(t(H_bootstrap$expo))
  H[, 1]

  ## Return P values
  ## In practice, run times &gt;= 100
  ## is recommended
  report_bootstrap_p_value(H_bootstrap)
  ## For multiple samples
  ## Input a list
  report_bootstrap_p_value(list(samp1 = H_bootstrap, samp2 = H_bootstrap))

  #   ## Find suboptimal decomposition
  #   H_suboptimal &lt;- sig_fit_bootstrap(V[, 1], W,
  #     n = 10,
  #     type = "absolute",
  #     method = "SA",
  #     find_suboptimal = TRUE
  #   )
}
</code></pre>

<hr>
<h2 id='sig_fit_bootstrap_batch'>Exposure Instability Analysis of Signature Exposures with Bootstrapping</h2><span id='topic+sig_fit_bootstrap_batch'></span>

<h3>Description</h3>

<p>Read <a href="#topic+sig_fit_bootstrap">sig_fit_bootstrap</a> for more option setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_fit_bootstrap_batch(
  catalogue_matrix,
  methods = c("QP"),
  n = 100L,
  min_count = 1L,
  p_val_thresholds = c(0.05),
  use_parallel = FALSE,
  seed = 123456L,
  job_id = NULL,
  result_dir = tempdir(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_fit_bootstrap_batch_+3A_catalogue_matrix">catalogue_matrix</code></td>
<td>
<p>a numeric matrix <code>V</code> with row representing components and
columns representing samples, typically you can get <code>nmf_matrix</code> from <code>sig_tally()</code> and
transpose it by <code>t()</code>.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_batch_+3A_methods">methods</code></td>
<td>
<p>a subset of <code>c("NNLS", "QP", "SA")</code>.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_batch_+3A_n">n</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_batch_+3A_min_count">min_count</code></td>
<td>
<p>minimal exposure in a sample, default is 1. Any patient has total exposure less
than this value will be filtered out.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_batch_+3A_p_val_thresholds">p_val_thresholds</code></td>
<td>
<p>a vector of relative exposure threshold for calculating p values.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_batch_+3A_use_parallel">use_parallel</code></td>
<td>
<p>if <code>TRUE</code>, use parallel computation based on <strong>furrr</strong> package.
It can also be an integer for specifying cores.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_batch_+3A_seed">seed</code></td>
<td>
<p>random seed to reproduce the result.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_batch_+3A_job_id">job_id</code></td>
<td>
<p>a job ID, default is <code>NULL</code>, can be a string. When not <code>NULL</code>, all bootstrapped results
will be saved to local machine location defined by <code>result_dir</code>. This is very useful for running
more than 10 times for more than 100 samples.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_batch_+3A_result_dir">result_dir</code></td>
<td>
<p>see above, default is temp directory defined by R.</p>
</td></tr>
<tr><td><code id="sig_fit_bootstrap_batch_+3A_...">...</code></td>
<td>
<p>other common parameters passing to <a href="#topic+sig_fit_bootstrap">sig_fit_bootstrap</a>, including
<code>sig</code>, <code>sig_index</code>, <code>sig_db</code>, <code>db_type</code>, <code>mode</code>, <code>auto_reduce</code> etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> of <code>data.table</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+sig_fit">sig_fit</a>, <a href="#topic+sig_fit_bootstrap">sig_fit_bootstrap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2)
colnames(W) &lt;- c("sig1", "sig2")
W &lt;- apply(W, 2, function(x) x / sum(x))

H &lt;- matrix(c(2, 5, 3, 6, 1, 9, 1, 2), ncol = 4)
colnames(H) &lt;- paste0("samp", 1:4)

V &lt;- W %*% H
V

if (requireNamespace("quadprog")) {
  z10 &lt;- sig_fit_bootstrap_batch(V, sig = W, n = 10)
  z10
}
</code></pre>

<hr>
<h2 id='sig_operation'>Obtain or Modify Signature Information</h2><span id='topic+sig_operation'></span><span id='topic+sig_names'></span><span id='topic+sig_modify_names'></span><span id='topic+sig_number'></span><span id='topic+sig_attrs'></span><span id='topic+sig_signature'></span><span id='topic+sig_exposure'></span>

<h3>Description</h3>

<p>Obtain or Modify Signature Information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_names(sig)

sig_modify_names(sig, new_names)

sig_number(sig)

sig_attrs(sig)

sig_signature(sig, normalize = c("row", "column", "raw", "feature"))

sig_exposure(sig, type = c("absolute", "relative"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_operation_+3A_sig">sig</code></td>
<td>
<p>a <code>Signature</code> object obtained either from <a href="#topic+sig_extract">sig_extract</a> or <a href="#topic+sig_auto_extract">sig_auto_extract</a>.</p>
</td></tr>
<tr><td><code id="sig_operation_+3A_new_names">new_names</code></td>
<td>
<p>new signature names.</p>
</td></tr>
<tr><td><code id="sig_operation_+3A_normalize">normalize</code></td>
<td>
<p>one of 'row', 'column', 'raw' and &quot;feature&quot;, for row normalization (signature),
column normalization (component), raw data, row normalization by feature, respectively.</p>
</td></tr>
<tr><td><code id="sig_operation_+3A_type">type</code></td>
<td>
<p>one of 'absolute' and 'relative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Signature</code> object or data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Operate signature names
load(system.file("extdata", "toy_mutational_signature.RData",
  package = "sigminer", mustWork = TRUE
))
sig_names(sig2)
cc &lt;- sig_modify_names(sig2, new_names = c("Sig2", "Sig1", "Sig3"))
sig_names(cc)

# The older names are stored in tags.
print(attr(cc, "tag"))
## Get signature number
sig_number(sig2)
## Get signature attributes
sig_number(sig2)
## Get signature matrix
z &lt;- sig_signature(sig2)
z &lt;- sig_signature(sig2, normalize = "raw")
## Get exposure matrix
## Of note, this is different from get_sig_exposure()
## it returns a matrix instead of data table.
z &lt;- sig_exposure(sig2) # it is same as sig$Exposure
z &lt;- sig_exposure(sig2, type = "relative") # it is same as sig2$Exposure.norm
</code></pre>

<hr>
<h2 id='sig_tally'>Tally a Genomic Alteration Object</h2><span id='topic+sig_tally'></span><span id='topic+sig_tally.CopyNumber'></span><span id='topic+sig_tally.RS'></span><span id='topic+sig_tally.MAF'></span>

<h3>Description</h3>

<p>Tally a variation object like <a href="#topic+MAF">MAF</a>, <a href="#topic+CopyNumber">CopyNumber</a> and return a matrix for NMF de-composition and more.
This is a generic function,
so it can be further extended to other mutation cases.
<strong>Please read details about how to set sex for identifying copy number signatures</strong>.
Please read <a href="https://osf.io/s93d5/">https://osf.io/s93d5/</a> for the generation of SBS, DBS and ID (INDEL)
components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_tally(object, ...)

## S3 method for class 'CopyNumber'
sig_tally(
  object,
  method = "Wang",
  ignore_chrs = NULL,
  indices = NULL,
  add_loh = FALSE,
  feature_setting = sigminer::CN.features,
  cores = 1,
  keep_only_matrix = FALSE,
  ...
)

## S3 method for class 'RS'
sig_tally(object, keep_only_matrix = FALSE, ...)

## S3 method for class 'MAF'
sig_tally(
  object,
  mode = c("SBS", "DBS", "ID", "ALL"),
  ref_genome = "BSgenome.Hsapiens.UCSC.hg19",
  genome_build = NULL,
  add_trans_bias = FALSE,
  ignore_chrs = NULL,
  use_syn = TRUE,
  keep_only_matrix = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_tally_+3A_object">object</code></td>
<td>
<p>a <a href="#topic+CopyNumber">CopyNumber</a> object or <a href="#topic+MAF">MAF</a> object or SV object (from <a href="#topic+read_sv_as_rs">read_sv_as_rs</a>).</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_...">...</code></td>
<td>
<p>custom setting for operating object. Detail see S3 method for
corresponding class (e.g. <code>CopyNumber</code>).</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_method">method</code></td>
<td>
<p>method for feature classification, can be one of
&quot;Wang&quot; (&quot;W&quot;), &quot;S&quot; (for method described in Steele et al. 2019),
&quot;X&quot; (for method described in Tao et al. 2023).</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_ignore_chrs">ignore_chrs</code></td>
<td>
<p>Chromsomes to ignore from analysis. e.g. chrX and chrY.</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_indices">indices</code></td>
<td>
<p>integer vector indicating segments to keep.</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_add_loh">add_loh</code></td>
<td>
<p>flag to add LOH classifications.</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_feature_setting">feature_setting</code></td>
<td>
<p>a <code>data.frame</code> used for classification.
<strong>Only used when method is &quot;Wang&quot; (&quot;W&quot;)</strong>.
Default is <a href="#topic+CN.features">CN.features</a>. Users can also set custom input with &quot;feature&quot;,
&quot;min&quot; and &quot;max&quot; columns available. Valid features can be printed by
<code>unique(CN.features$feature)</code>.</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_cores">cores</code></td>
<td>
<p>number of computer cores to run this task.
You can use <code><a href="future.html#topic+re-exports">future::availableCores()</a></code> function to check how
many cores you can use.</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_keep_only_matrix">keep_only_matrix</code></td>
<td>
<p>if <code>TRUE</code>, keep only matrix for signature extraction.
For a <code>MAF</code> object, this will just return the most useful matrix.</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_mode">mode</code></td>
<td>
<p>type of mutation matrix to extract, can be one of 'SBS', 'DBS' and 'ID'.</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_ref_genome">ref_genome</code></td>
<td>
<p>'BSgenome.Hsapiens.UCSC.hg19', 'BSgenome.Hsapiens.UCSC.hg38',
'BSgenome.Mmusculus.UCSC.mm10',  'BSgenome.Mmusculus.UCSC.mm9', etc.</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_genome_build">genome_build</code></td>
<td>
<p>genome build 'hg19', 'hg38', 'mm9' or &quot;mm10&quot;, if not set, guess it by <code>ref_genome</code>.</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_add_trans_bias">add_trans_bias</code></td>
<td>
<p>if <code>TRUE</code>, consider transcriptional bias categories.
'T:' for Transcribed (the variant is on the transcribed strand);
'U:' for Un-transcribed (the variant is on the untranscribed strand);
'B:' for Bi-directional (the variant is on both strand and is transcribed either way);
'N:' for Non-transcribed (the variant is in a non-coding region and is untranslated);
'Q:' for Questionable.
<strong>NOTE</strong>: the result counts of 'B' and 'N' labels are a little different from
SigProfilerMatrixGenerator, the reason is unknown (may be caused by annotation file).</p>
</td></tr>
<tr><td><code id="sig_tally_+3A_use_syn">use_syn</code></td>
<td>
<p>Logical. If <code>TRUE</code>, include synonymous variants in analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For identifying copy number signatures, we have to derive copy number
features firstly. Due to the difference of copy number values in sex chromosomes
between male and female, we have to do an extra step <strong>if we don't want to
ignore them</strong>.
</p>
<p>I create two options to control this, the default values are shown as
the following, you can use the same way to set (per R session).
</p>
<p><code>options(sigminer.sex = "female", sigminer.copynumber.max = NA_integer_)</code>
</p>

<ul>
<li><p> If your cohort are all females, you can totally ignore this.
</p>
</li>
<li><p> If your cohort are all males, set <code>sigminer.sex</code> to 'male' and
<code>sigminer.copynumber.max</code> to a proper value (the best is consistent
with <a href="#topic+read_copynumber">read_copynumber</a>).
</p>
</li>
<li><p> If your cohort contains both males and females, set <code>sigminer.sex</code>
as a <code>data.frame</code> with two columns &quot;sample&quot; and &quot;sex&quot;. And
set <code>sigminer.copynumber.max</code> to a proper value (the best is consistent
with <a href="#topic+read_copynumber">read_copynumber</a>).
</p>
</li></ul>



<h3>Value</h3>

<p>a <code>list</code> contains a <code>matrix</code> used for NMF de-composition.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>sig_tally(CopyNumber)</code>: Returns copy number features, components and component-by-sample matrix
</p>
</li>
<li> <p><code>sig_tally(RS)</code>: Returns genome rearrangement sample-by-component matrix
</p>
</li>
<li> <p><code>sig_tally(MAF)</code>: Returns SBS mutation sample-by-component matrix and APOBEC enrichment
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Shixiang Wang
</p>


<h3>References</h3>

<p>Wang, Shixiang, et al. &quot;Copy number signature analyses in prostate cancer reveal
distinct etiologies and clinical outcomes.&quot; medRxiv (2020).
</p>
<p>Steele, Christopher D., et al. &quot;Undifferentiated sarcomas develop through
distinct evolutionary pathways.&quot; Cancer Cell 35.3 (2019): 441-456.
</p>
<p>Mayakonda, Anand, et al. &quot;Maftools: efficient and comprehensive analysis of somatic variants in cancer.&quot; Genome research 28.11 (2018): 1747-1756.
</p>
<p>Roberts SA, Lawrence MS, Klimczak LJ, et al. An APOBEC Cytidine Deaminase Mutagenesis Pattern is Widespread in Human Cancers. Nature genetics. 2013;45(9):970-976. doi:10.1038/ng.2702.
</p>
<p>Bergstrom EN, Huang MN, Mahto U, Barnes M, Stratton MR, Rozen SG, Alexandrov LB: SigProfilerMatrixGenerator: a tool for visualizing and exploring patterns of small mutational events. BMC Genomics 2019, 20:685 https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-019-6041-2
</p>


<h3>See Also</h3>

<p><a href="#topic+sig_estimate">sig_estimate</a> for estimating signature number for <a href="#topic+sig_extract">sig_extract</a>,
<a href="#topic+sig_auto_extract">sig_auto_extract</a> for extracting signatures using automatic relevance determination technique.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load copy number object
load(system.file("extdata", "toy_copynumber.RData",
  package = "sigminer", mustWork = TRUE
))

# Use method designed by Wang, Shixiang et al.
cn_tally_W &lt;- sig_tally(cn, method = "W")

# Use method designed by Steele et al.
# See example in read_copynumber

# Prepare SBS signature analysis
laml.maf &lt;- system.file("extdata", "tcga_laml.maf.gz", package = "maftools")
laml &lt;- read_maf(maf = laml.maf)
if (require("BSgenome.Hsapiens.UCSC.hg19")) {
  mt_tally &lt;- sig_tally(
    laml,
    ref_genome = "BSgenome.Hsapiens.UCSC.hg19",
    use_syn = TRUE
  )
  mt_tally$nmf_matrix[1:5, 1:5]

  ## Use strand bias categories
  mt_tally &lt;- sig_tally(
    laml,
    ref_genome = "BSgenome.Hsapiens.UCSC.hg19",
    use_syn = TRUE, add_trans_bias = TRUE
  )
  ## Test it by enrichment analysis
  enrich_component_strand_bias(mt_tally$nmf_matrix)
  enrich_component_strand_bias(mt_tally$all_matrices$SBS_24)
} else {
  message("Please install package 'BSgenome.Hsapiens.UCSC.hg19' firstly!")
}

</code></pre>

<hr>
<h2 id='sig_unify_extract'>An Unified Interface to Extract Signatures</h2><span id='topic+sig_unify_extract'></span>

<h3>Description</h3>

<p>This function provides an unified interface to signature extractor
implemented in <strong>sigminer</strong>. If you determine a specific <code>approach</code>,
please also read the documentation of corresponding extractor.
See &quot;Arguments&quot; part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_unify_extract(
  nmf_matrix,
  range = 2:5,
  nrun = 10,
  approach = c("bayes_nmf", "repeated_nmf", "bootstrap_nmf", "sigprofiler"),
  cores = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_unify_extract_+3A_nmf_matrix">nmf_matrix</code></td>
<td>
<p>a <code>matrix</code> used for NMF decomposition with rows indicate samples and columns indicate components.</p>
</td></tr>
<tr><td><code id="sig_unify_extract_+3A_range">range</code></td>
<td>
<p>signature number range, i.e. <code>2:5</code>.</p>
</td></tr>
<tr><td><code id="sig_unify_extract_+3A_nrun">nrun</code></td>
<td>
<p>the number of iteration to be performed to extract each signature number.</p>
</td></tr>
<tr><td><code id="sig_unify_extract_+3A_approach">approach</code></td>
<td>
<p>approach name.
</p>

<ul>
<li><p> &quot;repeated_nmf&quot; - <a href="#topic+sig_extract">sig_extract</a>
</p>
</li>
<li><p> &quot;bayes_nmf&quot; - <a href="#topic+sig_auto_extract">sig_auto_extract</a>
</p>
</li>
<li><p> &quot;bootstrap_nmf&quot; - <a href="#topic+bp_extract_signatures">bp_extract_signatures</a>
</p>
</li>
<li><p> &quot;sigprofiler&quot; - <a href="#topic+sigprofiler">sigprofiler</a>
</p>
</li></ul>
</td></tr>
<tr><td><code id="sig_unify_extract_+3A_cores">cores</code></td>
<td>
<p>number of cores used for computation.</p>
</td></tr>
<tr><td><code id="sig_unify_extract_+3A_...">...</code></td>
<td>
<p>other parameters passing to signature extractor based
on the <code>approach</code> setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result dependent on the <code>approach</code> setting.
</p>


<h3>See Also</h3>

<p><a href="#topic+sig_extract">sig_extract</a>, <a href="#topic+sig_auto_extract">sig_auto_extract</a>, <a href="#topic+bp_extract_signatures">bp_extract_signatures</a>,
<a href="#topic+sigprofiler">sigprofiler</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load(system.file("extdata", "toy_copynumber_tally_W.RData",
  package = "sigminer", mustWork = TRUE
))
# Extract signatures
# It is same as sig_extract(cn_tally_W$nmf_matrix, 2, nrun = 1)
res &lt;- sig_unify_extract(cn_tally_W$nmf_matrix, 2,
  nrun = 1,
  approach = "repeated_nmf"
)
# Auto-extract signatures based on bayesian NMF
res2 &lt;- sig_unify_extract(cn_tally_W$nmf_matrix,
  nrun = 1,
  approach = "bayes_nmf"
)

</code></pre>

<hr>
<h2 id='sigprofiler'>Extract Signatures with SigProfiler</h2><span id='topic+sigprofiler'></span><span id='topic+sigprofiler_extract'></span><span id='topic+sigprofiler_import'></span><span id='topic+sigprofiler_reorder'></span>

<h3>Description</h3>

<p>This function provides an interface to software SigProfiler.
More please see <a href="https://github.com/AlexandrovLab/SigProfilerExtractor">https://github.com/AlexandrovLab/SigProfilerExtractor</a>.
Typically, a reference genome is not required because the input is a matrix (my understanding).
<strong>If you are using refitting result by SigProfiler, please make sure you have input the matrix same order as examples at <a href="https://github.com/AlexandrovLab/SigProfilerMatrixGenerator/tree/master/SigProfilerMatrixGenerator/references/matrix/BRCA_example">https://github.com/AlexandrovLab/SigProfilerMatrixGenerator/tree/master/SigProfilerMatrixGenerator/references/matrix/BRCA_example</a></strong>. If not, use <code>sigprofiler_reorder()</code> firstly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigprofiler_extract(
  nmf_matrix,
  output,
  output_matrix_only = FALSE,
  range = 2:5,
  nrun = 10L,
  refit = FALSE,
  refit_plot = FALSE,
  is_exome = FALSE,
  init_method = c("random", "nndsvd_min", "nndsvd", "nndsvda", "nndsvdar"),
  cores = -1L,
  genome_build = c("hg19", "hg38", "T2T", "mm10", "mm9", "ce11"),
  use_conda = FALSE,
  py_path = NULL,
  sigprofiler_version = "1.1.3"
)

sigprofiler_import(
  output,
  order_by_expo = FALSE,
  type = c("suggest", "refit", "all")
)

sigprofiler_reorder(
  nmf_matrix,
  type = c("SBS96", "SBS6", "SBS12", "SBS192", "SBS1536", "SBS3072", "DBS78", "DBS312",
    "DBS1248", "DBS4992")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigprofiler_+3A_nmf_matrix">nmf_matrix</code></td>
<td>
<p>a <code>matrix</code> used for NMF decomposition with rows indicate samples and columns indicate components.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_output">output</code></td>
<td>
<p>output directory.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_output_matrix_only">output_matrix_only</code></td>
<td>
<p>if <code>TRUE</code>, only generate matrix file for SigProfiler
so user can call SigProfiler with the input by himself.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_range">range</code></td>
<td>
<p>signature number range, i.e. <code>2:5</code>.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_nrun">nrun</code></td>
<td>
<p>the number of iteration to be performed to extract each signature number.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_refit">refit</code></td>
<td>
<p>if <code>TRUE</code>, then refit the denovo signatures with nnls. Same
meaning as <code>optimize</code> option in <a href="#topic+sig_extract">sig_extract</a> or <a href="#topic+sig_auto_extract">sig_auto_extract</a>.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_refit_plot">refit_plot</code></td>
<td>
<p>if <code>TRUE</code>, SigProfiler will make
denovo to COSMIC sigantures decompostion plots. However, this may fail due
to some matrix cannot be identified by SigProfiler plot program.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_is_exome">is_exome</code></td>
<td>
<p>if <code>TRUE</code>, the exomes will be extracted.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_init_method">init_method</code></td>
<td>
<p>the initialization algorithm for W and H matrix of NMF.
Options are 'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'alexandrov-lab-custom'
and 'nndsvd_min'.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_cores">cores</code></td>
<td>
<p>number of cores used for computation.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_genome_build">genome_build</code></td>
<td>
<p>I think this option is useless when input is <code>matrix</code>, keep it
in case it is useful.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_use_conda">use_conda</code></td>
<td>
<p>if <code>TRUE</code>, create an independent conda environment to run SigProfiler.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_py_path">py_path</code></td>
<td>
<p>path to Python executable file, e.g. '/Users/wsx/anaconda3/bin/python'.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_sigprofiler_version">sigprofiler_version</code></td>
<td>
<p>version of <code>SigProfilerExtractor</code>. If this
package is not installed, the specified package will be installed.
If this package is installed, this option is useless.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_order_by_expo">order_by_expo</code></td>
<td>
<p>if <code>TRUE</code>, order the import signatures by their exposures, e.g. the signature
contributed the most exposure in all samples will be named as <code>Sig1</code>.</p>
</td></tr>
<tr><td><code id="sigprofiler_+3A_type">type</code></td>
<td>
<p>mutational signature type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>sigprofiler_extract()</code>, returns nothing. See <code>output</code> directory.
</p>
<p>For <code>sigprofiler_import()</code>, a <code>list</code> containing <code>Signature</code> object.
</p>
<p>A NMF matrix for input of <code>sigprofiler_extract()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (FALSE) {
  load(system.file("extdata", "toy_copynumber_tally_W.RData",
    package = "sigminer", mustWork = TRUE
  ))

  reticulate::conda_list()

  sigprofiler_extract(cn_tally_W$nmf_matrix, "~/test/test_sigminer",
    use_conda = TRUE
  )

  sigprofiler_extract(cn_tally_W$nmf_matrix, "~/test/test_sigminer",
    use_conda = FALSE, py_path = "/Users/wsx/anaconda3/bin/python"
  )
}

data("simulated_catalogs")
sigprofiler_reorder(t(simulated_catalogs$set1))
</code></pre>

<hr>
<h2 id='simulated_catalogs'>A List of Simulated SBS-96 Catalog Matrix</h2><span id='topic+simulated_catalogs'></span>

<h3>Description</h3>

<p>Data from <a href="https://doi.org/10.1038/s43018-020-0027-5">doi:10.1038/s43018-020-0027-5</a>.
5 simulated mutation catalogs are used by the paper but only 4 are available.
The data are simulated from COSMIC mutational signatures 1, 2, 3, 5, 6, 8,
12, 13, 17 and 18. Each sample is a linear combination of 5 randomly selected
signatures with the addiction of Poisson noise. The number of mutation in
each sample is randomly selected between 1,000 and 50,000 mutations, in log
scale so that a lower number of mutations is more likely to be selected.
The proportion of each signature in each sample is also random.
</p>


<h3>Format</h3>

<p>A list of matrix
</p>


<h3>Source</h3>

<p>Generate from code under data_raw/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simulated_catalogs)
</code></pre>

<hr>
<h2 id='simulation'>Simulation Analysis</h2><span id='topic+simulation'></span><span id='topic+simulate_signature'></span><span id='topic+simulate_catalogue'></span><span id='topic+simulate_catalogue_matrix'></span>

<h3>Description</h3>


<ul>
<li> <p><code>simulate_signature()</code> - Simulate signatures from signature pool.
</p>
</li>
<li> <p><code>simulate_catalogue()</code> - Simulate catalogs from signature/catalog pool.
</p>
</li>
<li> <p><code>simulate_catalogue_matrix()</code> - Simulate a bootstrapped catalog matrix.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>simulate_signature(x, weights = NULL)

simulate_catalogue(x, n, weights = NULL)

simulate_catalogue_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulation_+3A_x">x</code></td>
<td>
<p>a numeric vector representing a signature/catalog or matrix with rows representing
signatures/samples and columns representing components.</p>
</td></tr>
<tr><td><code id="simulation_+3A_weights">weights</code></td>
<td>
<p>a numeric vector for weights.</p>
</td></tr>
<tr><td><code id="simulation_+3A_n">n</code></td>
<td>
<p>an integer indicating mutation number to be generated in a catalog.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>matrix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a catalog
set.seed(1234)
catalog &lt;- as.integer(table(sample(1:96, 1000, replace = TRUE)))
names(catalog) &lt;- paste0("comp", 1:96)
# Generate a signature
sig &lt;- catalog / sum(catalog)

# Simulate catalogs
x1 &lt;- simulate_catalogue(catalog, 10) # 10 mutations
x1
x2 &lt;- simulate_catalogue(catalog, 100) # 100 mutations
x2
x3 &lt;- simulate_catalogue(catalog, 1000) # 1000 mutations
x3
# Similar with a signature
x4 &lt;- simulate_catalogue(sig, 10) # 10 mutations
x4

# Load SBS signature
load(system.file("extdata", "toy_mutational_signature.RData",
  package = "sigminer", mustWork = TRUE
))
s &lt;- t(sig2$Signature.norm)
# Generate a signature from multiple signatures/catalogs
s1 &lt;- simulate_signature(s)
s1
s2 &lt;- simulate_signature(s, weights = 1:3)
s2
# Generate a catalog from multiple signatures/catalogs
c1 &lt;- simulate_catalogue(s, 100, weights = 1:3)
c1
</code></pre>

<hr>
<h2 id='subset.CopyNumber'>Subsetting CopyNumber object</h2><span id='topic+subset.CopyNumber'></span>

<h3>Description</h3>

<p>Subset <code>data</code> slot of <a href="#topic+CopyNumber">CopyNumber</a> object, un-selected rows will move to
dropoff.segs slot, annotation slot will update in the same way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CopyNumber'
subset(x, subset = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.CopyNumber_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+CopyNumber">CopyNumber</a> object to be subsetted.</p>
</td></tr>
<tr><td><code id="subset.CopyNumber_+3A_subset">subset</code></td>
<td>
<p>logical expression indicating rows to keep.</p>
</td></tr>
<tr><td><code id="subset.CopyNumber_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.
Useless here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="#topic+CopyNumber">CopyNumber</a> object
</p>


<h3>Author(s)</h3>

<p>Shixiang Wang
</p>

<hr>
<h2 id='tidyeval'>Tidy eval helpers</h2><span id='topic+tidyeval'></span><span id='topic+expr'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+sym'></span><span id='topic+syms'></span><span id='topic+.data'></span><span id='topic+.env'></span><span id='topic++3A+3D'></span><span id='topic+as_name'></span><span id='topic+as_label'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="rlang.html#topic+sym">sym</a>()</code> creates a symbol from a string and
<code><a href="rlang.html#topic+sym">syms</a>()</code> creates a list of symbols from a
character vector.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+nse-defuse">enquo</a>()</code> and
<code><a href="rlang.html#topic+nse-defuse">enquos</a>()</code> delay the execution of one or
several function arguments. <code>enquo()</code> returns a single quoted
expression, which is like a blueprint for the delayed computation.
<code>enquos()</code> returns a list of such quoted expressions.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+nse-defuse">expr</a>()</code> quotes a new expression <em>locally</em>. It
is mostly useful to build new expressions around arguments
captured with <code><a href="#topic+enquo">enquo()</a></code> or <code><a href="#topic+enquos">enquos()</a></code>:
<code>expr(mean(!!enquo(arg), na.rm = TRUE))</code>.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+as_name">as_name</a>()</code> transforms a quoted variable name
into a string. Supplying something else than a quoted variable
name is an error.
</p>
<p>That's unlike <code><a href="rlang.html#topic+as_label">as_label</a>()</code> which also returns
a single string but supports any kind of R object as input,
including quoted function calls and vectors. Its purpose is to
summarise that object into a single label. That label is often
suitable as a default name.
</p>
<p>If you don't know what a quoted expression contains (for instance
expressions captured with <code>enquo()</code> could be a variable
name, a call to a function, or an unquoted constant), then use
<code>as_label()</code>. If you know you have quoted a simple variable
name, or would like to enforce this, use <code>as_name()</code>.
</p>
</li></ul>

<p>To learn more about tidy eval and how to use these tools, visit
<a href="https://dplyr.tidyverse.org/articles/programming.html">https://dplyr.tidyverse.org/articles/programming.html</a> and the
<a href="https://adv-r.hadley.nz/metaprogramming.html">Metaprogramming
section</a> of <a href="https://adv-r.hadley.nz">Advanced R</a>.
</p>

<hr>
<h2 id='transcript.hg19'>Merged Transcript Location at Genome Build hg19</h2><span id='topic+transcript.hg19'></span>

<h3>Description</h3>

<p>Merged Transcript Location at Genome Build hg19
</p>


<h3>Format</h3>

<p>A <code>data.table</code>
</p>


<h3>Source</h3>

<p>from GENCODE release v33.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(transcript.hg19)
</code></pre>

<hr>
<h2 id='transcript.hg38'>Merged Transcript Location at Genome Build hg38</h2><span id='topic+transcript.hg38'></span>

<h3>Description</h3>

<p>Merged Transcript Location at Genome Build hg38
</p>


<h3>Format</h3>

<p>A <code>data.table</code>
</p>


<h3>Source</h3>

<p>from GENCODE release v33.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(transcript.hg38)
</code></pre>

<hr>
<h2 id='transcript.mm10'>Merged Transcript Location at Genome Build mm10</h2><span id='topic+transcript.mm10'></span>

<h3>Description</h3>

<p>Merged Transcript Location at Genome Build mm10
</p>


<h3>Format</h3>

<p>A <code>data.table</code>
</p>


<h3>Source</h3>

<p>from GENCODE release M25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(transcript.mm10)
</code></pre>

<hr>
<h2 id='transcript.mm9'>Merged Transcript Location at Genome Build mm9</h2><span id='topic+transcript.mm9'></span>

<h3>Description</h3>

<p>Merged Transcript Location at Genome Build mm9
</p>


<h3>Format</h3>

<p>A <code>data.table</code>
</p>


<h3>Source</h3>

<p>from UCSC <a href="http://hgdownload.cse.ucsc.edu/goldenPath/mm9/database/transcriptome.txt.gz">http://hgdownload.cse.ucsc.edu/goldenPath/mm9/database/transcriptome.txt.gz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(transcript.mm9)
</code></pre>

<hr>
<h2 id='transcript.T2T'>Merged Transcript Location at Genome Build T2T</h2><span id='topic+transcript.T2T'></span>

<h3>Description</h3>

<p>Merged Transcript Location at Genome Build T2T
</p>


<h3>Format</h3>

<p>A <code>data.table</code>
</p>


<h3>Source</h3>

<p>from T2T study.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(transcript.T2T)
</code></pre>

<hr>
<h2 id='transform_seg_table'>Transform Copy Number Table</h2><span id='topic+transform_seg_table'></span>

<h3>Description</h3>

<p>Transform Copy Number Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_seg_table(
  data,
  genome_build = c("hg19", "hg38", "T2T", "mm10", "mm9", "ce11"),
  ref_type = c("cytoband", "gene"),
  values_fill = NA,
  values_fn = function(x, ...) {
     round(mean(x, ...))
 },
  resolution_factor = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_seg_table_+3A_data">data</code></td>
<td>
<p>a <code>CopyNumber</code> object or a data.frame containing
at least 'chromosome', 'start', 'end', 'segVal', 'sample' these columns.</p>
</td></tr>
<tr><td><code id="transform_seg_table_+3A_genome_build">genome_build</code></td>
<td>
<p>genome build version, used when <code>data</code> is a <code>data.frame</code>, should be 'hg19' or 'hg38'.</p>
</td></tr>
<tr><td><code id="transform_seg_table_+3A_ref_type">ref_type</code></td>
<td>
<p>annotation data type used for constructing matrix.</p>
</td></tr>
<tr><td><code id="transform_seg_table_+3A_values_fill">values_fill</code></td>
<td>
<p>Optionally, a (scalar) value that specifies what each
<code>value</code> should be filled in with when missing.
</p>
<p>This can be a named list if you want to apply different fill values to
different value columns.</p>
</td></tr>
<tr><td><code id="transform_seg_table_+3A_values_fn">values_fn</code></td>
<td>
<p>Optionally, a function applied to the value in each cell
in the output. You will typically use this when the combination of
<code>id_cols</code> and <code>names_from</code> columns does not uniquely identify an
observation.
</p>
<p>This can be a named list if you want to apply different aggregations
to different <code>values_from</code> columns.</p>
</td></tr>
<tr><td><code id="transform_seg_table_+3A_resolution_factor">resolution_factor</code></td>
<td>
<p>an integer to control the resolution.
When it is <code>1</code> (default), compute frequency in each cytoband.
When it is <code>2</code>, use compute frequency in each half cytoband.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.table</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load(system.file("extdata", "toy_copynumber.RData",
  package = "sigminer", mustWork = TRUE
))
# Compute the mean segVal in each cytoband
x &lt;- transform_seg_table(cn, resolution_factor = 1)
x
# Compute the mean segVal in each half-cytoband
x2 &lt;- transform_seg_table(cn, resolution_factor = 2)
x2

</code></pre>

<hr>
<h2 id='use_color_style'>Set Color Style for Plotting</h2><span id='topic+use_color_style'></span>

<h3>Description</h3>

<p>Set Color Style for Plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_color_style(
  style,
  mode = c("SBS", "copynumber", "DBS", "ID", "RS"),
  method = "Wang"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_color_style_+3A_style">style</code></td>
<td>
<p>one of 'default' and 'cosmic'.</p>
</td></tr>
<tr><td><code id="use_color_style_+3A_mode">mode</code></td>
<td>
<p>only used when the <code>style</code> is 'cosmic', can be one of
&quot;SBS&quot;, &quot;copynumber&quot;, &quot;DBS&quot;, &quot;ID&quot;.</p>
</td></tr>
<tr><td><code id="use_color_style_+3A_method">method</code></td>
<td>
<p>used to set a more custom palette for different methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>color values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use_color_style("default")
use_color_style("cosmic")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
