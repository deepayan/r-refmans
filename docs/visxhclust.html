<!DOCTYPE html><html lang="en"><head><title>Help for package visxhclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {visxhclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#annotate_clusters'><p>Annotate data frame with clusters</p></a></li>
<li><a href='#bin_df'><p>Simulated binary data</p></a></li>
<li><a href='#cluster_boxplots'><p>Plot boxplots with clusters</p></a></li>
<li><a href='#cluster_colors'><p>List of colors used in the Shiny app for clusters</p></a></li>
<li><a href='#cluster_heatmaps'><p>Plot heatmap with cluster results and dendrogram</p></a></li>
<li><a href='#compute_clusters'><p>Compute clusters hierarchically from distance matrix</p></a></li>
<li><a href='#compute_dmat'><p>Compute a distance matrix from scaled data</p></a></li>
<li><a href='#compute_gapstat'><p>Compute Gap statistic for clustered data</p></a></li>
<li><a href='#compute_metric'><p>Compute an internal evaluation metric for clustered data</p></a></li>
<li><a href='#correlation_heatmap'><p>Plot a correlation heatmap</p></a></li>
<li><a href='#create_annotations'><p>Create heatmap annotations from selected variables</p></a></li>
<li><a href='#cut_clusters'><p>Cut a hierarchical tree targeting k clusters</p></a></li>
<li><a href='#dmat_projection'><p>Plot a 2D MDS projection of a distance matrix</p></a></li>
<li><a href='#facet_boxplot'><p>Faceted boxplots with points or violin plots</p></a></li>
<li><a href='#line_plot'><p>A custom line plot with optional vertical line</p></a></li>
<li><a href='#logscaled_df'><p>Simulated logscaled data</p></a></li>
<li><a href='#normal_annotated'><p>Simulated normal data with annotations</p></a></li>
<li><a href='#normal_df'><p>Simulated normal data</p></a></li>
<li><a href='#normal_missing'><p>Simulated normal data with missing values</p></a></li>
<li><a href='#optimal_score'><p>Find minimum or maximum score in a vector</p></a></li>
<li><a href='#plot_annotation_dist'><p>Plot distribution of annotation data across clusters</p></a></li>
<li><a href='#plot_cluster_heatmaps'><p>Draw two heatmaps</p></a></li>
<li><a href='#run_app'><p>Runs the Shiny app</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Shiny App for Visual Exploration of Hierarchical Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rafael Henkin &lt;r.henkin@qmul.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A Shiny application and functions for visual exploration of hierarchical clustering with numeric datasets. Allows users to iterative set hyperparameters, select features and evaluate results through various plots and computation of evaluation criteria.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rhenkin/visxhclust">https://github.com/rhenkin/visxhclust</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rhenkin/visxhclust/issues">https://github.com/rhenkin/visxhclust/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>shiny, shinyhelper, shinycssloaders, bsplus, DT, ggplot2,
dplyr, readr, tidyr, cluster, fastcluster, clValid, dunn.test,
RColorBrewer, dendextend, ComplexHeatmap, circlize, patchwork,
knitr, kableExtra</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-16 14:43:48 UTC; rafaelhenkin</td>
</tr>
<tr>
<td>Author:</td>
<td>Rafael Henkin [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-17 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='annotate_clusters'>Annotate data frame with clusters</h2><span id='topic+annotate_clusters'></span>

<h3>Description</h3>

<p>Annotate data frame with clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_clusters(df, cluster_labels, long = TRUE, selected_clusters = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="annotate_clusters_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="annotate_clusters_+3A_cluster_labels">cluster_labels</code></td>
<td>
<p>list of cluster labels, automatically converted to factor.</p>
</td></tr>
<tr><td><code id="annotate_clusters_+3A_long">long</code></td>
<td>
<p>if <code>TRUE</code>, returned data frame will be in long format. See details for spec. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="annotate_clusters_+3A_selected_clusters">selected_clusters</code></td>
<td>
<p>optional cluster labels to filter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Long data frame will have columns: <code>Cluster</code>, <code>Measurement</code> and <code>Value</code>.
</p>


<h3>Value</h3>

<p>a wide or long data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmat &lt;- compute_dmat(iris, "euclidean", TRUE, c("Petal.Length", "Sepal.Length"))
res &lt;- compute_clusters(dmat, "complete")
cluster_labels &lt;- cut_clusters(res, 2)
annotated_data &lt;- annotate_clusters(iris[, c("Petal.Length", "Sepal.Length")], cluster_labels)
head(annotated_data)
</code></pre>

<hr>
<h2 id='bin_df'>Simulated binary data</h2><span id='topic+bin_df'></span>

<h3>Description</h3>

<p>Simulated binary data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_df
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 10 variables:
</p>

<dl>
<dt>a</dt><dd><p>variable a</p>
</dd>
<dt>b</dt><dd><p>variable b</p>
</dd>
<dt>c</dt><dd><p>variable c</p>
</dd>
<dt>d</dt><dd><p>variable d</p>
</dd>
<dt>e</dt><dd><p>variable e</p>
</dd>
<dt>f</dt><dd><p>variable f</p>
</dd>
<dt>g</dt><dd><p>variable g</p>
</dd>
<dt>h</dt><dd><p>variable h</p>
</dd>
<dt>i</dt><dd><p>variable i</p>
</dd>
<dt>j</dt><dd><p>variable j</p>
</dd>
</dl>



<h3>Source</h3>

<p>package author
</p>

<hr>
<h2 id='cluster_boxplots'>Plot boxplots with clusters</h2><span id='topic+cluster_boxplots'></span>

<h3>Description</h3>

<p>This is a convenience wrapper function for <code>facet_boxplot()</code>.
Combined with <code>annotate_clusters()</code>, it
doesn't require specifying axes in <code>facet_boxplot()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_boxplots(annotated_data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_boxplots_+3A_annotated_data">annotated_data</code></td>
<td>
<p>data frame returned by <code>annotate_clusters()</code></p>
</td></tr>
<tr><td><code id="cluster_boxplots_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>facet_boxplot()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>boxplots faceted by clusters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmat &lt;- compute_dmat(iris, "euclidean", TRUE, c("Petal.Length", "Sepal.Length"))
clusters &lt;- compute_clusters(dmat, "complete")
cluster_labels &lt;- cut_clusters(clusters, 2)
annotated_data &lt;- annotate_clusters(iris[, c("Petal.Length", "Sepal.Length")], cluster_labels)
cluster_boxplots(annotated_data, boxplot_colors = visxhclust::cluster_colors)
</code></pre>

<hr>
<h2 id='cluster_colors'>List of colors used in the Shiny app for clusters</h2><span id='topic+cluster_colors'></span>

<h3>Description</h3>

<p>List of colors used in the Shiny app for clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_colors
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 39.
</p>

<hr>
<h2 id='cluster_heatmaps'>Plot heatmap with cluster results and dendrogram</h2><span id='topic+cluster_heatmaps'></span>

<h3>Description</h3>

<p>Plot heatmap with cluster results and dendrogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_heatmaps(
  scaled_selected_data,
  clusters,
  k,
  cluster_colors,
  scaled_unselected_data = NULL,
  annotation = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_heatmaps_+3A_scaled_selected_data">scaled_selected_data</code></td>
<td>
<p>scaled matrix or data frame with variables used for clustering</p>
</td></tr>
<tr><td><code id="cluster_heatmaps_+3A_clusters">clusters</code></td>
<td>
<p>hierarchical cluster results produced by <code><a href="fastcluster.html#topic+hclust">fastcluster::hclust()</a></code></p>
</td></tr>
<tr><td><code id="cluster_heatmaps_+3A_k">k</code></td>
<td>
<p>targeted number of clusters</p>
</td></tr>
<tr><td><code id="cluster_heatmaps_+3A_cluster_colors">cluster_colors</code></td>
<td>
<p>list of cluster colors to match with boxplots</p>
</td></tr>
<tr><td><code id="cluster_heatmaps_+3A_scaled_unselected_data">scaled_unselected_data</code></td>
<td>
<p>(optional) scaled matrix or data frame with variables not used for clustering</p>
</td></tr>
<tr><td><code id="cluster_heatmaps_+3A_annotation">annotation</code></td>
<td>
<p>(optional) <a href="ComplexHeatmap.html#topic+columnAnnotation">ComplexHeatmap::columnAnnotation</a> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ComplexHeatmap.html#topic+Heatmap">ComplexHeatmap::Heatmap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmat &lt;- compute_dmat(iris, "euclidean", TRUE, c("Petal.Length", "Sepal.Length"))
clusters &lt;- compute_clusters(dmat, "complete")
species_annotation &lt;- create_annotations(iris, "Species")
cluster_heatmaps(scale(iris[c("Petal.Length", "Sepal.Length")]),
                 clusters,
                 3,
                 visxhclust::cluster_colors,
                 annotation = species_annotation)
</code></pre>

<hr>
<h2 id='compute_clusters'>Compute clusters hierarchically from distance matrix</h2><span id='topic+compute_clusters'></span>

<h3>Description</h3>

<p>Compute clusters hierarchically from distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_clusters(dmat, linkage_method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_clusters_+3A_dmat">dmat</code></td>
<td>
<p>a distance matrix</p>
</td></tr>
<tr><td><code id="compute_clusters_+3A_linkage_method">linkage_method</code></td>
<td>
<p>a linkage method supported by <code><a href="fastcluster.html#topic+hclust">fastcluster::hclust()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>clusters computed by <code><a href="fastcluster.html#topic+hclust">fastcluster::hclust()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmat &lt;- compute_dmat(iris, "euclidean", TRUE, c("Petal.Length", "Sepal.Length"))
res &lt;- compute_clusters(dmat, "complete")
</code></pre>

<hr>
<h2 id='compute_dmat'>Compute a distance matrix from scaled data</h2><span id='topic+compute_dmat'></span>

<h3>Description</h3>

<p>This function applies scaling to the columns of a data frame and
computes and returns a distance matrix from a chosen distance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_dmat(
  x,
  dist_method = "euclidean",
  apply_scaling = FALSE,
  subset_cols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_dmat_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix</p>
</td></tr>
<tr><td><code id="compute_dmat_+3A_dist_method">dist_method</code></td>
<td>
<p>a distance measure to apply to the scaled data. Must be those supported by <code><a href="stats.html#topic+dist">stats::dist()</a></code>, plus <code>"mahalanobis"</code> and <code>"cosine"</code>. Default is <code>"euclidean"</code>.</p>
</td></tr>
<tr><td><code id="compute_dmat_+3A_apply_scaling">apply_scaling</code></td>
<td>
<p>use TRUE to apply <code><a href="base.html#topic+scale">base::scale()</a></code>. By default does not scale data.</p>
</td></tr>
<tr><td><code id="compute_dmat_+3A_subset_cols">subset_cols</code></td>
<td>
<p>(optional) a list of columns to subset the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;dist&quot; (see <code><a href="stats.html#topic+dist">stats::dist()</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmat &lt;- compute_dmat(iris, "euclidean", TRUE, c("Petal.Length", "Sepal.Length"))
print(class(dmat))
</code></pre>

<hr>
<h2 id='compute_gapstat'>Compute Gap statistic for clustered data</h2><span id='topic+compute_gapstat'></span>

<h3>Description</h3>

<p>Compute Gap statistic for clustered data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_gapstat(df, clusters, gap_B = 50, max_k = 14)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_gapstat_+3A_df">df</code></td>
<td>
<p>the data used to compute clusters</p>
</td></tr>
<tr><td><code id="compute_gapstat_+3A_clusters">clusters</code></td>
<td>
<p>output of <code><a href="#topic+compute_clusters">compute_clusters()</a></code> or <code><a href="fastcluster.html#topic+hclust">fastcluster::hclust()</a></code></p>
</td></tr>
<tr><td><code id="compute_gapstat_+3A_gap_b">gap_B</code></td>
<td>
<p>number of bootstrap samples for <code><a href="cluster.html#topic+clusGap">cluster::clusGap()</a></code> function. Default is 50.</p>
</td></tr>
<tr><td><code id="compute_gapstat_+3A_max_k">max_k</code></td>
<td>
<p>maximum number of clusters to compute the statistic. Default is 14.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the Tab component of <code><a href="cluster.html#topic+clusGap">cluster::clusGap()</a></code> results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_to_cluster &lt;- iris[c("Petal.Length", "Sepal.Length")]
dmat &lt;- compute_dmat(data_to_cluster, "euclidean", TRUE)
clusters &lt;- compute_clusters(dmat, "complete")
gap_results &lt;- compute_gapstat(scale(data_to_cluster), clusters)
head(gap_results)
</code></pre>

<hr>
<h2 id='compute_metric'>Compute an internal evaluation metric for clustered data</h2><span id='topic+compute_metric'></span>

<h3>Description</h3>

<p>Metric will be computed from 2 to max_k clusters. Note that the row number in results will be different from k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_metric(dmat, clusters, metric_name, max_k = 14)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_metric_+3A_dmat">dmat</code></td>
<td>
<p>distance matrix output of <code><a href="#topic+compute_dmat">compute_dmat()</a></code> or <code><a href="stats.html#topic+dist">stats::dist()</a></code></p>
</td></tr>
<tr><td><code id="compute_metric_+3A_clusters">clusters</code></td>
<td>
<p>output of <code><a href="#topic+compute_clusters">compute_clusters()</a></code> or <code><a href="fastcluster.html#topic+hclust">fastcluster::hclust()</a></code></p>
</td></tr>
<tr><td><code id="compute_metric_+3A_metric_name">metric_name</code></td>
<td>
<p>&quot;silhouette&quot; or &quot;dunn&quot;</p>
</td></tr>
<tr><td><code id="compute_metric_+3A_max_k">max_k</code></td>
<td>
<p>maximum number of clusters to cut using <code><a href="dendextend.html#topic+cutree-methods">dendextend::cutree()</a></code>. Default is 14.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with columns <code>k</code> and <code>score</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_to_cluster &lt;- iris[c("Petal.Length", "Sepal.Length")]
dmat &lt;- compute_dmat(data_to_cluster, "euclidean", TRUE)
clusters &lt;- compute_clusters(dmat, "complete")
compute_metric(dmat, clusters, "dunn")
</code></pre>

<hr>
<h2 id='correlation_heatmap'>Plot a correlation heatmap</h2><span id='topic+correlation_heatmap'></span>

<h3>Description</h3>

<p>Computes pairwise Pearson correlation; if there are fewer than 15 columns, prints
the value of the correlation coefficient inside each tile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation_heatmap(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correlation_heatmap_+3A_df">df</code></td>
<td>
<p>numeric data frame to compute correlations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ComplexHeatmap.html#topic+Heatmap">ComplexHeatmap::Heatmap</a>
</p>

<hr>
<h2 id='create_annotations'>Create heatmap annotations from selected variables</h2><span id='topic+create_annotations'></span>

<h3>Description</h3>

<p>This function will create a <a href="ComplexHeatmap.html#topic+columnAnnotation">ComplexHeatmap::columnAnnotation</a> object with rows
for each variable passed as argument. Character columns will be coerced into factors.
For factors, the ColorBrewer palette <code>Set3</code> will be used. For non-negative numeric, the
<code>PuBu</code> palette will be used, and for columns with negative values, the reversed <code>RdBu</code> will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_annotations(df, selected_variables)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_annotations_+3A_df">df</code></td>
<td>
<p>a data frame. It can be an original unscaled data, or a scaled one</p>
</td></tr>
<tr><td><code id="create_annotations_+3A_selected_variables">selected_variables</code></td>
<td>
<p>list of columns in the data frame to create annotations for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ComplexHeatmap.html#topic+columnAnnotation">ComplexHeatmap::columnAnnotation</a> object
</p>

<hr>
<h2 id='cut_clusters'>Cut a hierarchical tree targeting k clusters</h2><span id='topic+cut_clusters'></span>

<h3>Description</h3>

<p>Cut a hierarchical tree targeting k clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_clusters(clusters, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cut_clusters_+3A_clusters">clusters</code></td>
<td>
<p>cluster results, produced by e.g. <code><a href="fastcluster.html#topic+hclust">fastcluster::hclust()</a></code></p>
</td></tr>
<tr><td><code id="cut_clusters_+3A_k">k</code></td>
<td>
<p>target number of clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cluster labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmat &lt;- compute_dmat(iris, "euclidean", TRUE, c("Petal.Length", "Sepal.Length"))
clusters &lt;- compute_clusters(dmat, "complete")
cluster_labels &lt;- cut_clusters(clusters, 2)
head(cluster_labels)
</code></pre>

<hr>
<h2 id='dmat_projection'>Plot a 2D MDS projection of a distance matrix</h2><span id='topic+dmat_projection'></span>

<h3>Description</h3>

<p>Plot a 2D MDS projection of a distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmat_projection(dmat, point_colors = NULL, point_palette = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dmat_projection_+3A_dmat">dmat</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="dmat_projection_+3A_point_colors">point_colors</code></td>
<td>
<p>optional list of labels to color points (will be coerced to factor)</p>
</td></tr>
<tr><td><code id="dmat_projection_+3A_point_palette">point_palette</code></td>
<td>
<p>optional palette used with <code><a href="ggplot2.html#topic+scale_manual">ggplot2::scale_colour_manual()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmat &lt;- dist(iris[, c("Sepal.Width", "Sepal.Length")])
dmat_projection(dmat)
</code></pre>

<hr>
<h2 id='facet_boxplot'>Faceted boxplots with points or violin plots</h2><span id='topic+facet_boxplot'></span>

<h3>Description</h3>

<p>Faceted boxplots with points or violin plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_boxplot(
  df,
  x,
  y,
  facet_var = NULL,
  boxplot_colors = NULL,
  shape = c("boxplot", "violin"),
  plot_points = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="facet_boxplot_+3A_df">df</code></td>
<td>
<p>a data frame containing all the variables matching the remaining arguments</p>
</td></tr>
<tr><td><code id="facet_boxplot_+3A_x">x</code></td>
<td>
<p>categorical variable</p>
</td></tr>
<tr><td><code id="facet_boxplot_+3A_y">y</code></td>
<td>
<p>continuous variable</p>
</td></tr>
<tr><td><code id="facet_boxplot_+3A_facet_var">facet_var</code></td>
<td>
<p>optional variable to facet data</p>
</td></tr>
<tr><td><code id="facet_boxplot_+3A_boxplot_colors">boxplot_colors</code></td>
<td>
<p>list of colors to use as fill for boxplots</p>
</td></tr>
<tr><td><code id="facet_boxplot_+3A_shape">shape</code></td>
<td>
<p>either &quot;boxplot&quot; or &quot;violin&quot;</p>
</td></tr>
<tr><td><code id="facet_boxplot_+3A_plot_points">plot_points</code></td>
<td>
<p>boolean variable to overlay jittered points or not. Default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>facet_boxplot(iris, x = "Species", y = "Sepal.Length", facet_var = "Species")
</code></pre>

<hr>
<h2 id='line_plot'>A custom line plot with optional vertical line</h2><span id='topic+line_plot'></span>

<h3>Description</h3>

<p>A custom line plot with optional vertical line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_plot(df, x, y, xintercept = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="line_plot_+3A_df">df</code></td>
<td>
<p>data source</p>
</td></tr>
<tr><td><code id="line_plot_+3A_x">x</code></td>
<td>
<p>variable for horizontal axis</p>
</td></tr>
<tr><td><code id="line_plot_+3A_y">y</code></td>
<td>
<p>variable for vertical axis</p>
</td></tr>
<tr><td><code id="line_plot_+3A_xintercept">xintercept</code></td>
<td>
<p>optional value in horizontal axis to highlight</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object
</p>

<hr>
<h2 id='logscaled_df'>Simulated logscaled data</h2><span id='topic+logscaled_df'></span>

<h3>Description</h3>

<p>Simulated logscaled data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logscaled_df
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 10 variables:
</p>

<dl>
<dt>a</dt><dd><p>variable a</p>
</dd>
<dt>b</dt><dd><p>variable b</p>
</dd>
<dt>c</dt><dd><p>variable c</p>
</dd>
<dt>d</dt><dd><p>variable d</p>
</dd>
<dt>e</dt><dd><p>variable e</p>
</dd>
<dt>f</dt><dd><p>variable f</p>
</dd>
<dt>g</dt><dd><p>variable g</p>
</dd>
<dt>h</dt><dd><p>variable h</p>
</dd>
<dt>i</dt><dd><p>variable i</p>
</dd>
<dt>j</dt><dd><p>variable j</p>
</dd>
</dl>



<h3>Source</h3>

<p>package author
</p>

<hr>
<h2 id='normal_annotated'>Simulated normal data with annotations</h2><span id='topic+normal_annotated'></span>

<h3>Description</h3>

<p>Simulated normal data with annotations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_annotated
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 10 variables:
</p>

<dl>
<dt>a</dt><dd><p>variable a</p>
</dd>
<dt>b</dt><dd><p>variable b</p>
</dd>
<dt>c</dt><dd><p>variable c</p>
</dd>
<dt>d</dt><dd><p>variable d</p>
</dd>
<dt>e</dt><dd><p>variable e</p>
</dd>
<dt>f</dt><dd><p>variable f</p>
</dd>
<dt>g</dt><dd><p>variable g</p>
</dd>
<dt>h</dt><dd><p>variable h</p>
</dd>
<dt>i</dt><dd><p>variable i</p>
</dd>
<dt>j</dt><dd><p>variable j</p>
</dd>
<dt>annot</dt><dd><p>annotation column</p>
</dd>
</dl>



<h3>Source</h3>

<p>package author
</p>

<hr>
<h2 id='normal_df'>Simulated normal data</h2><span id='topic+normal_df'></span>

<h3>Description</h3>

<p>Simulated normal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_df
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 10 variables:
</p>

<dl>
<dt>a</dt><dd><p>variable a</p>
</dd>
<dt>b</dt><dd><p>variable b</p>
</dd>
<dt>c</dt><dd><p>variable c</p>
</dd>
<dt>d</dt><dd><p>variable d</p>
</dd>
<dt>e</dt><dd><p>variable e</p>
</dd>
<dt>f</dt><dd><p>variable f</p>
</dd>
<dt>g</dt><dd><p>variable g</p>
</dd>
<dt>h</dt><dd><p>variable h</p>
</dd>
<dt>i</dt><dd><p>variable i</p>
</dd>
<dt>j</dt><dd><p>variable j</p>
</dd>
</dl>



<h3>Source</h3>

<p>package author
</p>

<hr>
<h2 id='normal_missing'>Simulated normal data with missing values</h2><span id='topic+normal_missing'></span>

<h3>Description</h3>

<p>Simulated normal data with missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_missing
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 10 variables:
</p>

<dl>
<dt>a</dt><dd><p>variable a</p>
</dd>
<dt>b</dt><dd><p>variable b</p>
</dd>
<dt>c</dt><dd><p>variable c</p>
</dd>
<dt>d</dt><dd><p>variable d</p>
</dd>
<dt>e</dt><dd><p>variable e</p>
</dd>
<dt>f</dt><dd><p>variable f</p>
</dd>
<dt>g</dt><dd><p>variable g</p>
</dd>
<dt>h</dt><dd><p>variable h</p>
</dd>
<dt>i</dt><dd><p>variable i</p>
</dd>
<dt>j</dt><dd><p>variable with randomly missing values</p>
</dd>
</dl>



<h3>Source</h3>

<p>package author
</p>

<hr>
<h2 id='optimal_score'>Find minimum or maximum score in a vector</h2><span id='topic+optimal_score'></span>

<h3>Description</h3>

<p>This function is meant to be used with compute_metric. For Gap statistic,
use <code><a href="cluster.html#topic+clusGap">cluster::maxSE()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal_score(x, method = c("firstmax", "globalmax", "firstmin", "globalmin"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimal_score_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="optimal_score_+3A_method">method</code></td>
<td>
<p>one of &quot;firstmax&quot;, &quot;globalmax&quot;, &quot;firstmin&quot; or &quot;globalmin&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the index (not k) of the identified maximum or minimum score
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_to_cluster &lt;- iris[c("Petal.Length", "Sepal.Length")]
dmat &lt;- compute_dmat(data_to_cluster, "euclidean", TRUE)
clusters &lt;- compute_clusters(dmat, "complete")
res &lt;- compute_metric(dmat, clusters, "dunn")
optimal_score(res$score, method = "firstmax")
</code></pre>

<hr>
<h2 id='plot_annotation_dist'>Plot distribution of annotation data across clusters</h2><span id='topic+plot_annotation_dist'></span>

<h3>Description</h3>

<p>Plot distribution of annotation data across clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_annotation_dist(annotations_df, cluster_labels, selected_clusters = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_annotation_dist_+3A_annotations_df">annotations_df</code></td>
<td>
<p>data frame with variables not used in clustering</p>
</td></tr>
<tr><td><code id="plot_annotation_dist_+3A_cluster_labels">cluster_labels</code></td>
<td>
<p>output from <code><a href="#topic+cut_clusters">cut_clusters()</a></code></p>
</td></tr>
<tr><td><code id="plot_annotation_dist_+3A_selected_clusters">selected_clusters</code></td>
<td>
<p>optional vector of cluster labels to include in plots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>patchwork</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmat &lt;- compute_dmat(iris, "euclidean", TRUE, c("Petal.Length", "Sepal.Length"))
clusters &lt;- compute_clusters(dmat, "complete")
cluster_labels &lt;- cut_clusters(clusters, 2)
plot_annotation_dist(iris["Species"], cluster_labels)
</code></pre>

<hr>
<h2 id='plot_cluster_heatmaps'>Draw two heatmaps</h2><span id='topic+plot_cluster_heatmaps'></span>

<h3>Description</h3>

<p>Draw two heatmaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cluster_heatmaps(
  top_matrix,
  bottom_matrix,
  dendrograms,
  clusters_set,
  annotation = NULL,
  scaled = FALSE,
  distance_method = NULL,
  cluster_features = TRUE,
  show_col_names = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_cluster_heatmaps_+3A_top_matrix">top_matrix</code></td>
<td>
<p>matrix with selected variables</p>
</td></tr>
<tr><td><code id="plot_cluster_heatmaps_+3A_bottom_matrix">bottom_matrix</code></td>
<td>
<p>matrix with unselected variables</p>
</td></tr>
<tr><td><code id="plot_cluster_heatmaps_+3A_dendrograms">dendrograms</code></td>
<td>
<p>to draw above top matrix</p>
</td></tr>
<tr><td><code id="plot_cluster_heatmaps_+3A_clusters_set">clusters_set</code></td>
<td>
<p>list of cluster indices</p>
</td></tr>
<tr><td><code id="plot_cluster_heatmaps_+3A_annotation">annotation</code></td>
<td>
<p>(optional) any kind of annotation object to draw as top_annotation</p>
</td></tr>
<tr><td><code id="plot_cluster_heatmaps_+3A_scaled">scaled</code></td>
<td>
<p>(optional) boolean to modify colour scale if data has already been scaled</p>
</td></tr>
<tr><td><code id="plot_cluster_heatmaps_+3A_distance_method">distance_method</code></td>
<td>
<p>(optional) if &quot;Binary&quot;, use discrete colors for heatmap</p>
</td></tr>
<tr><td><code id="plot_cluster_heatmaps_+3A_cluster_features">cluster_features</code></td>
<td>
<p>(optional) If FALSE, row order does not change</p>
</td></tr>
<tr><td><code id="plot_cluster_heatmaps_+3A_show_col_names">show_col_names</code></td>
<td>
<p>(optional) If FALSE, does not show column names at base of heatmap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>two concatenated heatmaps drawn with ComplexHeatmap::draw
</p>

<hr>
<h2 id='run_app'>Runs the Shiny app</h2><span id='topic+run_app'></span>

<h3>Description</h3>

<p>Runs the Shiny app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_app()
</code></pre>


<h3>Value</h3>

<p>No return value, runs the app by passing it to print
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run this example in interactive R sessions
if (interactive()) {
library(visxhclust)
run_app()
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
