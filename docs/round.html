<!DOCTYPE html><html><head><title>Help for package round</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {round}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mathC99'><p>C99 'math' Library Functions (where Not in Standard aka 'Base' <span class="rlang"><b>R</b></span>)</p></a></li>
<li><a href='#randI'><p>Random Integers of Specified Number of Digits</p></a></li>
<li><a href='#roundX'><p>Rounding Numbers to Decimal Digits &ndash; Variants</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.21-0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-10</td>
</tr>
<tr>
<td>Title:</td>
<td>Rounding to Decimal Digits</td>
</tr>
<tr>
<td>Description:</td>
<td>Decimal rounding is non-trivial in binary arithmetic.  ISO
  standard round to even is more rare than typically assumed as most decimal fractions
  are not exactly representable in binary.  Our 'roundX()' versions explore differences
  between current and potential future versions of round() in R.
  Further, provides (some partly related) C99 math lib functions not in base R.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>grDevices, graphics, Matrix, lattice, gmp, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>KeepSource:</td>
<td>TRUE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/mmaechler/round/">https://gitlab.com/mmaechler/round/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/mmaechler/round/-/issues">https://gitlab.com/mmaechler/round/-/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-10 20:59:14 UTC; maechler</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  R-core [ctb] ("r1.C" only)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mathC99'>C99 'math' Library Functions (where Not in Standard aka 'Base' <span class="rlang"><b>R</b></span>)</h2><span id='topic+logB'></span><span id='topic+ilogb'></span><span id='topic+fpclassify'></span><span id='topic+isnormal'></span><span id='topic+nearbyint'></span><span id='topic+signbit'></span><span id='topic+nextafter'></span><span id='topic+nexttoward'></span>

<h3>Description</h3>

<p>Provides simple <span class="rlang"><b>R</b></span> versions of those C99 &ldquo;math lib&rdquo; / &ldquo;libmath&rdquo; /
&ldquo;libm&rdquo; functions that are not (yet) in standard (aka &lsquo;base&rsquo; <span class="rlang"><b>R</b></span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> logB(x) # C's logb(x), numeric integer-valued "log2".
         # R's logb() is defined as "log wrt base"
ilogb(x) # == logB(), but of *type* integer

fpclassify(x)
isnormal(x)
nearbyint(x)
signbit(x)

nextafter(x, y)
nexttoward(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mathC99_+3A_x">x</code>, <code id="mathC99_+3A_y">y</code></td>
<td>
<p>numeric vector(s); will be recycled to common length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+numeric">numeric</a></code> (<code><a href="base.html#topic+double">double</a></code> or
<code><a href="base.html#topic+integer">integer</a></code>) vector of the same (or recycled) length of
<code>x</code> (and <code>y</code> where appropriate) with the values of
<code>&lt;fn&gt;(x)</code> for the corresponding C99 libmath function <code>&lt;fn&gt;</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>Wikipedia (2020) <em>C mathematical functions</em>
<a href="https://en.wikipedia.org/wiki/C_mathematical_functions">https://en.wikipedia.org/wiki/C_mathematical_functions</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sqrt">sqrt</a></code>,  <code><a href="base.html#topic+log">log</a></code>, <code><a href="base.html#topic+exp">exp</a></code>, <code><a href="base.html#topic+Trig">Trig</a></code>;
</p>
<p><code><a href="base.html#topic+floor">floor</a></code>, <code><a href="base.html#topic+ceiling">ceiling</a></code>, <code><a href="base.html#topic+trunc">trunc</a></code>;
</p>
<p><code><a href="Matrix.html#topic+is.finite">is.finite</a></code>, <code><a href="Matrix.html#topic+is.na">is.na</a></code> .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- (1:20)*pi
stopifnot(ilogb (x) == logB (x),  is.integer(ilogb(x)),
          ilogb(-x) == logB(-x),  is.double ( logB(x)))
cbind(x, "2^il(x)"= 2^logB(x), ilogb = ilogb(x), signbit = signbit(x),
         fpclassify = fpclassify(x), isnormal = isnormal(x))

x &lt;- c(2^-(10:22), rexp(1000));
summary(x / 2^ilogb(x)) # in   [1, 2)  interval
stopifnot(nearbyint(x) == round(x))

nextafter(-0, +0)
nextafter(+0,  1)
nextafter(+0, -1)
nextafter(Inf, -1)
nextafter(-Inf, 0)
</code></pre>

<hr>
<h2 id='randI'>Random Integers of Specified Number of Digits</h2><span id='topic+randI'></span>

<h3>Description</h3>

<p>Create <code>n</code> random integer valued numbers all with a specified number of
digits <code>d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randI(n, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randI_+3A_n">n</code></td>
<td>
<p>numeric sample size, i.e., <code><a href="base.html#topic+length">length</a>()</code> of result.</p>
</td></tr>
<tr><td><code id="randI_+3A_d">d</code></td>
<td>
<p>a positive integer, giving the exact number of digits the
resulting numbers must have.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is based on <code><a href="stats.html#topic+runif">runif</a>()</code> and not
<code><a href="base.html#topic+sample">sample</a>()</code>, which for now also makes it less <span class="rlang"><b>R</b></span> version
dependent.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector of <code><a href="base.html#topic+length">length</a></code> <code>n</code> of
numbers <code>N</code> where each <code class="reqn">N</code> has exactly <code>d</code> digits;
equivalently,
</p>
<p style="text-align: center;"><code class="reqn">10^{d-1} \le N_i &lt; 10^d,</code>
</p>

<p><b>and</b> every <code class="reqn">N_i</code> appears with the same probability
<code class="reqn">1 / (9\cdot 10^{d-1})</code>
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p>Uniform random numbers <code><a href="stats.html#topic+runif">runif</a></code>; Random number generators,
seeds, etc: <code><a href="base.html#topic+RNG">RNG</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(
 T2 &lt;- table(randI(1e6, 2))) ; abline(h = 1e6 / (9*10^(2 - 1)), lty=2, col="gray70")
chisq.test(T2) # typically not at all significant
T3 &lt;- table(randI(1e6, 3))
chisq.test(T3)
stopifnot(exprs = {
  identical( 10:99 , as.integer(names(T2)))
  identical(100:999, as.integer(names(T3)))
})
</code></pre>

<hr>
<h2 id='roundX'>Rounding Numbers to Decimal Digits &ndash; Variants</h2><span id='topic+roundX'></span><span id='topic+roundVersions'></span><span id='topic+roundAll'></span><span id='topic+round_r3'></span>

<h3>Description</h3>

<p>Provide several <code>version</code>s of algorithms for <code><a href="base.html#topic+round">round</a>(x,
    digits)</code>, i.e., rounding to decimal digits.  In particular, provides
previous and current implementations of <span class="rlang"><b>R</b></span>'s <code>round()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundX  (x, digits, version = roundVersions, trace = 0)

roundAll(x, digits, versions = roundVersions)

round_r3(x, d, info=FALSE, check=TRUE)

roundVersions # "sprintf" "r0.C" "r1.C" "r1a.C" "r2.C"  "r3.C" "r3d.C"  "r3"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roundX_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="roundX_+3A_digits">digits</code>, <code id="roundX_+3A_d">d</code></td>
<td>
<p>integer number (for <code>d</code>) or numeric vector.</p>
</td></tr>
<tr><td><code id="roundX_+3A_version">version</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the version of
rounding.  Must match <code>roundVersions</code> (via
<code><a href="base.html#topic+match.arg">match.arg</a></code>).</p>
</td></tr>
<tr><td><code id="roundX_+3A_trace">trace</code></td>
<td>
<p>integer; if positive, the corresponding computations should
be &ldquo;traced&rdquo; (possibly proportionally to the value of
<code>trace</code>); currently only implemented for <code>version = "r3.C"</code>.</p>
</td></tr>
<tr><td><code id="roundX_+3A_versions">versions</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> vector, a subset of
<code>roundVersions</code>.</p>
</td></tr>
<tr><td><code id="roundX_+3A_info">info</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> specifying if <code>round_r3(*)</code> should
result in a <code><a href="base.html#topic+list">list</a></code> with components
</p>

<dl>
<dt><code>"r"</code>:</dt><dd><p>the rounded <code>x</code>,</p>
</dd>
<dt><code>"D"</code>:</dt><dd><p>the difference <code>(xu - x) - (x - xd)</code>, where
<code>xd</code> and <code>xu</code> are the round <b>d</b>own and <b>u</b>p
versions of <code>x</code>,</p>
</dd>
<dt><code>"e"</code>:</dt><dd><p>the modulo-2 remainder of <code>floor(x * 10^d)</code>,
which determines rounding to even (only) in case <code>D = 0</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="roundX_+3A_check">check</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if <code>x</code> and
<code>digits</code> should be checked for validity.  Is set to <code>FALSE</code>
when used in <code>roundX()</code> (or <code>roundAll</code>), as the checks happen
before <code>round_r3()</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rounding to decimal digits is non-trivial in binary arithmetic.  ISO
standard &ldquo;round to even&rdquo;, see <code><a href="base.html#topic+round">round</a>()</code>'s (help page),
is more rare than typically assumed as most decimal fractions
are not exactly representable in binary <code><a href="base.html#topic+double">double</a></code> precision
numbers.
</p>
<p>Decimal rounding is well defined when <code>digits = 0</code>, and calls the
(C99 standard) C library function <code><a href="#topic+nearbyint">nearbyint</a>()</code> (which
provide in this package as well, for completeness):
<code><a href="base.html#topic+round">round</a>(x)</code> is (<span class="rlang"><b>R</b></span> level) equivalent to <code>round(x, digits
  = 0)</code> and is also equivalent to (<span class="rlang"><b>R</b></span> and C level) <code>nearbyint(x)</code>
which is defined to return the closest integer number (as
<code><a href="base.html#topic+double">double</a></code>) and in the case of &ldquo;doubt&rdquo;, where both
integer number neighbours are of the same distance, i.e., distance
<code>0.5</code> the famous &ldquo;round to even&rdquo; strategy is used, such that,
e.g., <code>round(0:7 + 0.5) == c(0, 2, 2, 4, 4, 6, 6, 8)</code>.
</p>
<p>The following strategy / algorithms are used for the different
<code>roundVersions</code>; note that we <em>only</em> consider the crucial case
<code>digits &gt; 0</code> in the following description:

</p>

<dl>
<dt><code>"sprintf"</code>:</dt><dd><p>diverts the operation to
<code><a href="base.html#topic+sprintf">sprintf</a>("%.*f", digits, x)</code> which in turn diverts to the
corresponding C library function <code>sprintf()</code>; consequently may
be platform dependent (though we have not yet seen differences from
what we get by the most widely used GNU &lsquo;<span class="file">glibc</span>&rsquo; library,
<a href="https://www.gnu.org/software/libc/">https://www.gnu.org/software/libc/</a>).  This version does <em>not</em>
work with negative digits, returning <code><a href="base.html#topic+NA">NA</a></code> with a
<code><a href="base.html#topic+warning">warning</a></code> there.</p>
</dd>
<dt><code>"r0.C"</code>:</dt><dd><p>a (too much) simplified version of <span class="rlang"><b>R</b></span>'s
<code>"r1.C"</code>, just skipping the whole integer part computations;
this was the first patch proposal in R-bugs' report <a href="https://bugs.R-project.org/show_bug.cgi?id=17668">PR#17668</a>.

However, this completely breaks down in extreme cases.</p>
</dd>
<dt><code>"r1.C"</code>:</dt><dd><p>the version of <code><a href="base.html#topic+round">round</a>()</code> as in <span class="rlang"><b>R</b></span>
3.6.2 and earlier.  It first removes the integer part(s) of <code>x</code>,
then rounds and re-adds the integer part.</p>
</dd>
<dt><code>"r1a.C"</code>:</dt><dd><p>a slightly improved version of <code>"r1.C"</code>,
notably for |digits| &gt; 308.</p>
</dd>
<dt><code>"r2.C"</code>:</dt><dd><p>the version of <code><a href="base.html#topic+round">round</a>()</code> as added to
&lsquo;R-devel&rsquo; (the development version of <span class="rlang"><b>R</b></span>) with &lsquo;<span class="file">svn</span>&rsquo; revision
<code>.....</code>.  It does <em>not</em> remove and re-add the integer part(s)
of <code>x</code> but ensures that no unnecessary overflow to <code>+/-<a href="base.html#topic+Inf">Inf</a></code> or
underflow to <code>0</code> happens when numbers are multiplied and divided
by <code class="reqn">10^d</code>.</p>
</dd>
<dt><code>"r2a.C"</code>:</dt><dd><p>a slightly improved version of <code>"r2.C"</code>,
notably for large negative digits.</p>
</dd>
<dt><code>"r3"</code>:</dt><dd><p>(<span class="rlang"><b>R</b></span> level) implementation of &ldquo;correct&rdquo;
rounding, rounding to the nearest double precision number (with
&ldquo;round to even&rdquo; in case of equal distance) as seen in the
function definition of <code><a href="#topic+round_r3">round_r3</a>()</code>.  Note that
<code>info=TRUE</code> is only applied when when the <code>digits</code> <code class="reqn">d</code>
fulfill <code class="reqn">|d| &lt;= 308</code>.</p>
</dd>
<dt><code>"r3.C"</code>:</dt><dd><p>a C translation of <code>"r3"</code>, using <code>long
	double</code> for intermediate computations which is particularly
convenient for <code>digits</code> <code class="reqn">308 &lt; d &lt; ~324</code> as overflow is not
a possible then.</p>
</dd>
<dt><code>"r3d.C"</code>:</dt><dd><p>a version of <code>"r3.C"</code>, only using
<code>double</code> precision, and hence typically fast and less platform
dependent, and also more often identical to <code>"r3"</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>roundX()</code> returns a numeric vector (of length of recycled <code>x</code>
and <code>digits</code>, i.e., typically (when <code>digits</code> is of
length one) of <code>length(x)</code>.
</p>
<p><code>round_r3()</code> is the workhorse of <code>roundX(.., version = "r3")</code>;
it vectorizes in <code>x</code> but needs <code>length(d) == 1</code>.
</p>
<p><code>roundVersions</code> is a <code><a href="base.html#topic+character">character</a></code> vector of the versions
available for <code>roundX()</code>.
</p>
<p><code>roundAll()</code> applies <code>roundX()</code> for all <code>versions</code>,
returning a matrix if one of <code>x</code> or <code>digits</code> is not of length one.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler (R Core for version &quot;r1.C&quot;)</p>


<h3>References</h3>

<p>Wikipedia, Rounding, notably &quot;Round half to even&quot;:
<a href="https://en.wikipedia.org/wiki/Rounding#Round_half_to_even">https://en.wikipedia.org/wiki/Rounding#Round_half_to_even</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+round">round</a></code>, also <code><a href="base.html#topic+signif">signif</a></code> which is relatively
sophisticated (also by code from M.M.).</p>


<h3>Examples</h3>

<pre><code class='language-R'>roundVersions

round (55.55, 1)
roundX(55.55, 1, "r3")

## round() with all  roundVersions; quite simple (w/ recycling!)
roundAll # shows the function's definition

roundAll(55.55, 1)
roundAll(55.555, 2)
roundAll(55.5555, 3)
roundAll(55.55555, 4)
roundAll(55.555555, 5)
roundAll(55.5555555, 6)

## other "controversial" cases
rEx &lt;- cbind( x =  c(10.7775, 12.345, 9.18665),
         digits =  c(   3  ,    2   ,    4   ))

resEx &lt;- matrix(, length(roundVersions), nrow(rEx),
                dimnames = list(roundVersions, as.character(rEx[,"x"])))
for(i in 1:nrow(rEx))
  resEx[,i] &lt;-  roundAll(rEx[[i,"x"]], digits = rEx[[i,"digits"]])

resEx  # r0.C &amp; r2* agree and differ from the r1*;
       # "r3*" is close to "r2*" but not for 12.345
## The parts of "r3" :
r3rE &lt;- sapply(1:nrow(rEx), function(i)
               round_r3(rEx[[i,"x"]], rEx[[i,"digits"]], info=TRUE))
colnames(r3rE) &lt;- sapply(rEx[,"x"], format)
r3rE # rounding to even when D=0, but not when D &lt; 0

## "Deterministic" Simulation - few digits only:
long &lt;- interactive() # save time/memory e.g. when checking
I &lt;- if(long) 0:9999 else 0:999
Ix &lt;- I + 0.5
ndI &lt;- 1L + as.integer(log10(pmax(1,I))) # number of (decimal) digits of I
nd2 &lt;- outer(ndI, if(long) -3:4 else -2:3, `+`)
x   &lt;- c(t( Ix / (10^nd2) ))
nd2 &lt;- c(t( nd2 ))
 x  &lt;-  x [nd2 &gt; 0]
nd2 &lt;- nd2[nd2 &gt; 0]
rx &lt;- roundAll(x, digits = nd2)

formatF &lt;- function(.) format(., scientific=FALSE, drop0trailing=TRUE)
rownames(rx) &lt;- formatF(x)
options(width = 123)
noquote(cbind(d = nd2, formatF(rx))[1:140,])
## -&gt; The first cases already show a diverse picture; sprintf() a bit as outlier

## Error, assuming "r3" to be best, as it *does* really go to nearest:
Err &lt;- rx - rx[, "r3"]
## careful : allowing small "noise" differences:
tErr &lt;- abs(Err) &gt; 1e-3* 10^-nd2 # "truly" differing from "r3"
colSums(tErr)  ## --&gt; old R "r1*" is best here, then sprintf (among non-r3):
## For F30 Linux 64-bit (gcc),  and this selection of cases, r0+r2 are worst; r1 is best
## sprintf   r0.C   r1.C  r1a.C    r2.C  r2a.C   r3.C r3d.C  r3
##   15559  19778  14078  14078   19778  19778      8     0   0  {  long }
##    1167   1457   1290   1290    1457   1457      0     0   0  { !long }
if(long) { ## Q: where does  "r3.C"  differ from "r3" == "r3d.C" ?    A: in 10 cases; 8 "real"
  i3D &lt;- which(Err[,"r3.C"] != 0)
  print(cbind(d = nd2[i3D], formatF(rx[i3D,])), quote=FALSE)
  print.table(zapsmall(Err[i3D,]), zero.print = ".")# differences (not very small ones!)
}

## Visualization of error happening (FIXME: do zapsmall()-like not count "noise")
cumErr &lt;- apply(tErr[,colnames(rx) != "r3"], 2L, cumsum)
matPm &lt;- function(y) {
   matplot(y=y, type = "l", lwd = 2, xlab = "i", ylab = deparse(substitute(y)))
   abline(h = 0, lty=2, col="gray")
   legend("topleft", legend = setdiff(roundVersions, "r3"),
          col = 1:6, lty = 1:5, lwd = 2, bty = "n")
}
matPm(head(cumErr,  100)) # sprintf seems worst
matPm(head(cumErr,  250)) # now r0+2 is worst, sprintf best
matPm(head(cumErr, 1000)) # now sprintf clearly worst again
matPm(head(cumErr, 2000)) # 0r/r2 best sprintf catching up
if(long) {
matPm(head(cumErr, 5000)) # now sprintf clearly worst again
matPm(head(cumErr,10000)) # now r0+2 is worst,  r1 best
}
matPm( cumErr )

same_cols &lt;- function(m) all(m == m[,1])
stopifnot(same_cols(Err[, c("r0.C", "r2.C", "r2a.C")]))
stopifnot(same_cols(Err[, c("r1.C", "r1a.C")]))
if(FALSE) ## *not* in 'long' case, see above
stopifnot(same_cols(Err[, c("r3", "r3.C", "r3d.C")]))

sp &lt;- search()
if(long &amp;&amp; require("Matrix")) {
  showSp &lt;- function(m) print(image(as(m, "sparseMatrix"), aspect = 4,
         ## fails, bug in lattice?  useRaster = !dev.interactive(TRUE) &amp;&amp; (nrow(m) &gt;= 2^12),
                                border.col = if(nrow(m) &lt; 1e3) adjustcolor(1, 1/2) else NA))
  showSp(head(Err, 100))
  showSp(head(Err, 1000))
  showSp(Err)
  showSp(Err != 0) # B&amp;W version ..
  if(!any(sp == "package:Matrix")) detach("package:Matrix")
}

## More digits random sample simulation tend go against "sprintf";
## see ../tests/  and also the vignette
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
