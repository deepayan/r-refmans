<!DOCTYPE html><html><head><title>Help for package longitudinalData</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {longitudinalData}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#longitudinalData-package'><p>~ Package overview: longitudinalData ~</p></a></li>
<li><a href='#artificialJointLongData'><p>~ Data: artificialJointLongData ~</p></a></li>
<li><a href='#artificialLongData'><p>~ Data: artificialLongData ~</p></a></li>
<li><a href='#Constants'><p>~ Constants ~</p></a></li>
<li><a href='#distFrechet'><p>~ Function: Frechet distance ~</p></a></li>
<li><a href='#expandParLongData'>
<p>~ Function: expandParLongData ~</p></a></li>
<li><a href='#imputation'><p> ~ Function: imputation ~</p></a></li>
<li><a href='#initializePartition'>
<p>~ Function: initializePartition ~</p></a></li>
<li><a href='#ListPartition-class'><p>~ Class: ListPartition ~</p></a></li>
<li><a href='#longData'><p> ~ Function: longData ~</p></a></li>
<li><a href='#LongData-class'><p>~ Class: LongData ~</p></a></li>
<li><a href='#longData-internal'><p>~ longData: internal objects and methods ~</p></a></li>
<li><a href='#longData3d'><p> ~ Function: longData3d ~</p></a></li>
<li><a href='#LongData3d-class'><p>~ Class: LongData3d ~</p></a></li>
<li><a href='#longDataFrom3d'><p> ~ Function: longDataFrom3d ~</p></a></li>
<li><a href='#longDataTo3d'><p> ~ Function: longDataTo3d ~</p></a></li>
<li><a href='#makeLatexFile'>
<p>~ Function: makeLatexFile ~</p></a></li>
<li><a href='#ordered+28ListPartition+29'>
<p>~ Function: ordered(ListPartition) ~</p></a></li>
<li><a href='#parLongData'>
<p>~ Function: parLongData, parTraj and parMean~</p></a></li>
<li><a href='#ParLongData-class'><p>~ Class: ParLongData ~</p></a></li>
<li><a href='#partition'><p> ~ Function: partition ~</p></a></li>
<li><a href='#Partition-class'><p>~ Class: Partition ~</p></a></li>
<li><a href='#parWindows'>
<p>~ Function: parWindows ~</p></a></li>
<li><a href='#ParWindows-class'><p>~ Class: ParWindows ~</p></a></li>
<li><a href='#plot3dPdf'>
<p>~ Function: plot3dPdf for LongData ~</p></a></li>
<li><a href='#plotAllCriterion'>
<p>~ Function: plotAllCriterion ~</p></a></li>
<li><a href='#plotCriterion'>
<p>~ Function: plotCriterion ~</p></a></li>
<li><a href='#plotTrajMeans+2CLongData'><p> ~ Function: plotTrajMeans for LongData ~</p></a></li>
<li><a href='#plotTrajMeans3d+2CLongData'><p> ~ Function: plotTrajMeans3d for LongData3d ~</p></a></li>
<li><a href='#qualityCriterion'>
<p>~ Function: qualityCriterion ~</p></a></li>
<li><a href='#regroup'>
<p>~ Function: regroup ~</p></a></li>
<li><a href='#reshapeLongToWide'>
<p>~ Function: longToWide (or reshapeWide) ~</p></a></li>
<li><a href='#reshapeWideToLong'>
<p>~ Function: wideToLong (or reshapeWideToLong) ~</p></a></li>
<li><a href='#restoreRealData'>
<p>~ Function: restoreRealData ~</p></a></li>
<li><a href='#saveTrianglesAsASY'>
<p>~ Function: saveTrianglesAsASY ~</p></a></li>
<li><a href='#scale'>
<p>~ Function: scale for LongData ~</p></a></li>
<li><a href='#windowsCut'>
<p>~ Function: windowsCut ~</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Longitudinal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-09</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for longitudinal data and joint longitudinal data (used by packages kml and kml3d).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods,clv,class,rgl,utils,misc3d</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>global.r function.r constants.r myMisc3d.r longData.r
longData3d.r distanceFrechet.R imputCross.R imputTraj.R
imputLinearInterpol.R imputCopyMean.R imputation.r partition.r
listPartition.r parLongData.r parWindows.r newPlot.r</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Christophe Genolini [cre, aut],
  Bruno Falissard [ctb],
  Dai Fang [ctb],
  Patrice Kiener [ctb],
  Luke Tierney [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christophe Genolini &lt;christophe.genolini@u-paris10.fr&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-11 19:35:06 UTC; hornik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-13 17:27:53 UTC</td>
</tr>
</table>
<hr>
<h2 id='longitudinalData-package'>~ Package overview: longitudinalData ~</h2><span id='topic+longitudinalData'></span><span id='topic+longitudinalData-package'></span>

<h3>Description</h3>

<p><code>longitudinalData</code> package provide some tools to deal with the clusterization
of longitudinal data.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> longitudinalData</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 2.4.1</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2016-02-02</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
    Depends: </td><td style="text-align: left;"> methods,clv,rgl,misc3d</td>
</tr>
<tr>
 <td style="text-align: left;">
    URL:</td><td style="text-align: left;"> http://www.r-project.org</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Overview</h3>

<p><code>longitudinalData</code> provide some tools to deal with the clustering of longitudinal data, mainly:
</p>

<ol>
<li> <p><a href="#topic+plotTrajMeans">plotTrajMeans</a>
</p>
</li>
<li> <p><a href="#topic+imputation">imputation</a>
</p>
</li>
<li> <p><a href="#topic+qualityCriterion">qualityCriterion</a>
</p>
</li></ol>



<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSM, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] Christophe M. Genolini and Bruno Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] Christophe M. Genolini and Bruno Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011
</p>


<h3>See Also</h3>

<p>Classes: <code><a href="#topic+LongData-class">LongData</a></code>, <code><a href="#topic+Partition-class">Partition</a></code> <br />
Methods: <code><a href="#topic+longData">longData</a></code>, <code><a href="#topic+partition">partition</a></code>, <code><a href="#topic+ordered">ordered</a></code><br />
Plot: <code><a href="#topic+plotTrajMeans">plotTrajMeans</a></code>, <code><a href="#topic+plotTrajMeans3d">plotTrajMeans3d</a></code><br />
Imputation: <code><a href="#topic+imputation">imputation</a></code><br />
Criterion: <code><a href="#topic+qualityCriterion">qualityCriterion</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Generation of artificial longData
data(artificialJointLongData)
myData &lt;- longData3d(artificialJointLongData,timeInData=list(var1=2:12,var2=13:23,var3=24:34))

part &lt;- partition(rep(1:3,each=50))
plotTrajMeans3d(myData,part)

### Quality criterion
qualityCriterion(myData,part)
</code></pre>

<hr>
<h2 id='artificialJointLongData'>~ Data: artificialJointLongData ~</h2><span id='topic+artificialJointLongData'></span>

<h3>Description</h3>

<p>Some artificial joint longitudinal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(artificialJointLongData)</code></pre>


<h3>Format</h3>

<p>Some joint longitudinal data in wide format. It includes 90 trajectories
divided in 3 groups.
</p>

<dl>
<dt><code>id</code></dt><dd><p>unique idenfier for each patient.</p>
</dd>
<dt><code>v0</code></dt><dd><p>Measurment of variable 'V' at time t0</p>
</dd>
<dt><code>v1</code></dt><dd><p>Measurment of variable 'V' at time t1</p>
</dd>
<dt><code>...</code></dt><dd><p>...</p>
</dd>
<dt><code>v10</code></dt><dd><p>Measurment of variable 'V' at time t0</p>
</dd>
<dt><code>w0</code></dt><dd><p>Measurment of variable 'W' at time t0</p>
</dd>
<dt><code>w1</code></dt><dd><p>Measurment of variable 'W' at time t1</p>
</dd>
<dt><code>...</code></dt><dd><p>...</p>
</dd>
<dt><code>w10</code></dt><dd><p>Measurment of variable 'W' at time t0</p>
</dd>
<dt><code>x0</code></dt><dd><p>Measurment of variable 'X' at time t0</p>
</dd>
<dt><code>x1</code></dt><dd><p>Measurment of variable 'X' at time t1</p>
</dd>
<dt><code>...</code></dt><dd><p>...</p>
</dd>
<dt><code>x10</code></dt><dd><p>Measurment of variable 'X' at time t0</p>
</dd>
</dl>



<h3>Details</h3>

<p>Some joint longitudinal data in wide format. It includes 90 trajectories
divided in 3 groups.
</p>


<h3>Author(s)</h3>

<p>Christophe Genolini</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(artificialJointLongData)
str(artificialJointLongData)
</code></pre>

<hr>
<h2 id='artificialLongData'>~ Data: artificialLongData ~</h2><span id='topic+artificialLongData'></span>

<h3>Description</h3>

<p>Some artificial longitudinal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(artificialLongData)</code></pre>


<h3>Format</h3>

<p>Some longitudinal data in wide format. It includes 120 trajectories
divided in 4 groups.
</p>

<dl>
<dt><code>id</code></dt><dd><p>unique idenfier for each patient.</p>
</dd>
<dt><code>t0</code></dt><dd><p>Measurment at time t0</p>
</dd>
<dt><code>t1</code></dt><dd><p>Measurment at time t1</p>
</dd>
<dt><code>...</code></dt><dd><p>...</p>
</dd>
<dt><code>t10</code></dt><dd><p>Measurment at time t10</p>
</dd>
</dl>



<h3>Details</h3>

<p>Some artificial longitudinal data in wide format. It includes 120 trajectories
divided in 4 groups.
</p>


<h3>Author(s)</h3>

<p>Christophe Genolini</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(artificialLongData)
str(artificialLongData)
</code></pre>

<hr>
<h2 id='Constants'>~ Constants ~</h2><span id='topic+MAX_CLUSTERS'></span><span id='topic+CLUSTER_NAMES'></span><span id='topic+CRITERION_MIN_OR_MAX'></span><span id='topic+CRITERION_NAMES'></span><span id='topic+DISTANCE_METHODS'></span><span id='topic+CHOICE_STYLE'></span>

<h3>Description</h3>

<p>Constants define in the package ~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAX_CLUSTERS
CRITERION_NAMES
DISTANCE_METHODS
CHOICE_STYLE
</code></pre>


<h3>Value</h3>

<p>MAX_CLUSTERS = 26
</p>
<p>CLUSTER_NAMES = paste(&quot;c&quot;,2:MAX_CLUSTERS,sep=&quot;&quot;)
</p>
<p>CRITERION_NAMES &lt;- c(<br />
&quot;Calinski.Harabatz&quot;,&quot;Kryszczuk.Calinski&quot;,&quot;Genolini.Calinski&quot;,&quot;Ray.Turi&quot;,&quot;Davies.Bouldin&quot;,<br />
&quot;BIC&quot;,&quot;BIC2&quot;,&quot;AIC&quot;,&quot;AICc&quot;,&quot;AICc2&quot;,&quot;postProbaGlobal&quot;,&quot;random&quot;<br />
)
</p>
<p>DISTANCE_METHODS = c(&quot;manhattan&quot;, &quot;euclidean&quot;, &quot;minkowski&quot;, &quot;maximum&quot;, &quot;canberra&quot;, &quot;binary&quot;)
</p>
<p>CHOICE_STYLE = list(<br />
typeTraj=c(&quot;l&quot;,&quot;l&quot;,&quot;n&quot;),<br />
colTraj=c(&quot;clusters&quot;,&quot;black&quot;,&quot;black&quot;),<br />
typeMean=c(&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;l&quot;,&quot;l&quot;,&quot;n&quot;),<br />
colMean=c(&quot;clusters&quot;,&quot;black&quot;,&quot;clusters&quot;,&quot;black&quot;,&quot;clusters&quot;,&quot;black&quot;,&quot;black&quot;),<br />
pchMean=c(&quot;letters&quot;,&quot;letters&quot;,&quot;symbols&quot;,&quot;symbols&quot;,&quot;letters&quot;,&quot;letters&quot;,&quot;letters&quot;)<br />
)<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Maximum number of clusters that kml can deal with
MAX_CLUSTERS

### Names of the field that save clusters in object 'ClusterLongData'
cat(CLUSTER_NAMES,"\n")

### List of the available criterion
CRITERION_NAMES

### Distance available
DISTANCE_METHODS[2]

### Define the style use by choice
CHOICE_STYLE[['typeTraj']][2]
</code></pre>

<hr>
<h2 id='distFrechet'>~ Function: Frechet distance ~</h2><span id='topic+distFrechet'></span>

<h3>Description</h3>

<p>Compute Frechet distance between two trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distFrechet(Px,Py,Qx, Qy, timeScale=0.1, FrechetSumOrMax = "max")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distFrechet_+3A_px">Px</code></td>
<td>
<p>[vector(numeric)] Times (abscisse) of the first trajectories.</p>
</td></tr>
<tr><td><code id="distFrechet_+3A_py">Py</code></td>
<td>
<p>[vector(numeric)] Values of the first trajectories.</p>
</td></tr>
<tr><td><code id="distFrechet_+3A_qx">Qx</code></td>
<td>
<p>[vector(numeric)] Times of the second trajectories.</p>
</td></tr>
<tr><td><code id="distFrechet_+3A_qy">Qy</code></td>
<td>
<p>[vector(numeric)] Values of the second trajectories.</p>
</td></tr>
<tr><td><code id="distFrechet_+3A_timescale">timeScale</code></td>
<td>
<p>[<code>numeric</code>]: allow to modify the time scale,
increasing or decreasing the cost of the horizontal shift. If timeScale is
very big, then the Frechet's distance is equal to the
euclidienne distance. If timeScale is very small, then it is equal to
the Dynamic Time Warping.</p>
</td></tr>
<tr><td><code id="distFrechet_+3A_frechetsumormax">FrechetSumOrMax</code></td>
<td>
<p>[<code>character</code>]: The Frechet's distance can
be define using the 'sum' function or the 'max' function. This option
let the user to chose one or the other.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two curve P and Q, Frechet distance between P and Q is define as
<code>inf_{a,b} max_{t} d(P(a(t)),Q(b(t)))</code>. It's computation is a
NP-complex problem. When P and Q are trajectories (discrete curve), the
problem is polynomial.
</p>
<p>The Frechet distance can also be define using a sum instead of a max:
<code>inf_{a,b} sum_{t} d(P(a(t)),Q(b(t)))</code>
</p>
<p>The function <code>distFrechet</code> is C compiled,
the function <code>distFrechetR</code> is in R,
the function <code>distFrechetRec</code> is in recursive (the slowest) in R.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSM, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] Thomas Eiter &amp; Heikki Mannila: <br />
&quot;Computing Discrete Fr´echet Distance&quot;<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[3] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p>distTraj</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Px &lt;- 1:20
   Py &lt;- dnorm(1:20,12,2)
   Qx &lt;- 1:20
   Qy &lt;- dnorm(1:20,8,2)

   distFrechet(Px,Py,Qx,Qy)

   ### Frechet using sum instead of max.
   distFrechet(Px,Py,Qx,Qy,FrechetSumOrMax="sum")
</code></pre>

<hr>
<h2 id='expandParLongData'>
~ Function: expandParLongData ~
</h2><span id='topic+expandParLongData'></span><span id='topic+expandParLongData+2CParLongData+2CPartition-method'></span><span id='topic+expandParLongData+2CParLongData+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Prepare the values of an object
<code><a href="#topic+ParLongData-class">ParLongData</a></code> to make them being usable by a
plotting function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandParLongData(xParLongData, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandParLongData_+3A_xparlongdata">xParLongData</code></td>
<td>
<p><code>[ParLongData]</code>: The object to expand.</p>
</td></tr>
<tr><td><code id="expandParLongData_+3A_y">y</code></td>
<td>
<p><code>[Partition]</code> or <code>[numeric]</code>: see detail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+ParLongData-class">ParLongData</a></code> object can hold values that are easy
to specify (like <code>col="clusters"</code> or <code>pch="symbol"</code>) but that can not
be directly used by graphical functions <a href="#topic+plotTrajMeans">plotTrajMeans</a> and
<a href="#topic+plotTrajMeans3d">plotTrajMeans3d</a>. This function modify theses values to
make them fit with <code>plotTrajMeans</code> and <code>plotTrajMeans3d</code> expectations.
</p>
<p>The field <code>col</code> and <code>pch</code> are the ones concern by this
function.
</p>
<p>If <code>y</code> is a <code>Partition</code>, <code>col</code> and <code>pch</code> are
extanded to fit with the number of individual. If <code>y</code> is a number of
clusters, <code>col</code> and <code>pch</code> are extanded to fit with the
number of clusters.
</p>
<p>If <code>col='clusters'</code>, a color is affected to each clusters. Then
the field <code>col</code> receive a vector of color such that each
individual (if <code>y</code> is a <code>Partition</code>) or each clusters (if
<code>y</code> is a number of clusters) get its corresponding color.
</p>
<p>If <code>pch='letters'</code>, a letters is affected to each clusters. Then
the field <code>pch</code> receive a vector of letters such that each
individual (if <code>y</code> is a <code>Partition</code>) or each clusters (if
<code>y</code> is a number of clusters) get its corresponding letters.
</p>
<p>Same if <code>pch='symbols'</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ParLongData-class">ParLongData</a></code>
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###################
### Some parameters for trajectories
(paramTraj &lt;- parTRAJ(col="clusters"))

### Expand to a small partition with 3 clusters
part &lt;- partition(LETTERS[rep(1:3,4)])
expandParLongData(paramTraj,part)


###################
### Some parameters for the mean trajectories
paramMean &lt;- parMEAN()

### If there is 3 clusters :
expandParLongData(paramMean,3)

### If there is 5 clusters :
expandParLongData(paramMean,5)
</code></pre>

<hr>
<h2 id='imputation'> ~ Function: imputation ~ </h2><span id='topic+imputation'></span><span id='topic+imputation+2Cmatrix-method'></span><span id='topic+imputation+2Carray-method'></span><span id='topic+imputation+2CLongData-method'></span><span id='topic+imputation+2CLongData3d-method'></span>

<h3>Description</h3>

<p><code>imputation</code> is a function that offer different methods to impute
missing value of a <code><a href="#topic+LongData-class">LongData</a></code> (or a matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputation(traj,method="copyMean",lowerBound="globalMin",upperBound="globalMax")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputation_+3A_traj">traj</code></td>
<td>
<p><code>[LongData]</code> or <code>[matrix]</code> : trajectories to impute.</p>
</td></tr>
<tr><td><code id="imputation_+3A_method">method</code></td>
<td>
<p><code>[character]</code>: Name of the imputation method (see detail)</p>
</td></tr>
<tr><td><code id="imputation_+3A_lowerbound">lowerBound</code></td>
<td>
<p><code>[character]</code> or <code>[numeric]</code>: fixes the
smallest value that an imputed value can take. If a single value is
given, it is duplicate for all the column. The special value <code>'min'</code>
means that the lower bound will be the smallest value of the
column. The special value <code>'globalMin'</code> means that the lower
bound will be the overall smallest value (of each variable if there
is several variable-trajectories). The special value <code>'NA'</code> can
be used to impute without using a lower bound.</p>
</td></tr>
<tr><td><code id="imputation_+3A_upperbound">upperBound</code></td>
<td>
<p><code>[character]</code> or <code>[numeric]</code>: fixes the
biggest value that an imputed value can take. If a single value is
given, it is duplicate for all the column. The special value <code>'max'</code>
means that the upper bound will be the biggest value of the column.
The special value <code>'globalMax'</code> means that the upper
bound will be the overall biggest value (of each variable if there
is several variable-trajectories). The special value <code>'NA'</code> can
be used to impute without using an upper bound.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>imputation</code> is a function that impute
missing value of a <code><a href="#topic+LongData-class">LongData</a></code> or a <code>matrix</code>.
Several imputation methods are available. A brief description
follows. For a fully detailled description, see [3].
Illustrating examples showing strenghs and weakness of methods are presented section &quot;examples&quot;.
</p>
<p>For each method, the imputation has to deal with monotone missing
value (at start and at end of the trajectories) and intermitant (in
the middle). Here is a brief description of each methods.
</p>

<dl>
<dt>'linearInterpol.locf' (linear interpolation, locf)</dt><dd>

<dl>
<dt>Intermitant:</dt><dd><p> values imediatly surounding the missing are join by a line.</p>
</dd>
<dt>Monotone:</dt><dd><p> imputed by 'locf' or 'nocb'.</p>
</dd>
</dl>

</dd>
<dt>'linearInterpol.global' (linear interpolation, global slope)</dt><dd>

<dl>
<dt>Intermitant:</dt><dd><p> values imediatly surounding the missing are join by a line.</p>
</dd>
<dt>Monotone:</dt><dd><p> the line joining the first and last non-missing value
is considered (this line is the everage progression of the actual
individual trajectoire). Missing-value at start and at end are chosen on
this line.</p>
</dd>
</dl>

</dd>
<dt>'linearInterpol.local' (linear interpolation, global slope)</dt><dd>

<dl>
<dt>Intermitant:</dt><dd><p> values imediatly surounding the missing are join by a line.</p>
</dd>
<dt>Monotone at start:</dt><dd><p> the line joining the first and second non-missing value
is considered. Missing-value at start are chose on this line.</p>
</dd>
<dt>Monotone at end:</dt><dd><p> the line joining the last and penultimate non-missing value
is considered. Missing-value at end are chosen on this line.</p>
</dd>
</dl>

</dd>
<dt>'linearInterpol.bisector' (linear interpolation, bisector)</dt><dd>

<dl>
<dt>Intermitant:</dt><dd><p> values imediatly surounding the missing are join by a line.</p>
</dd>
<dt>Monotone:</dt><dd><p> linearInterpol.global is not
sensitive to local variation, linearInterpol.local might be too much sensitive to
abnormal value. linearInterpol.bisector offer a medium solution by considering the
bissectrice of Global and Local solution. Point are chosen on
the bissectrices.</p>
</dd>
</dl>

</dd>
<dt>'copyMean.locf' (copy mean, locf)</dt><dd>
<p>this method impute in two stages. First, it use 'linearInterpol.locf'. Then it add to each imputed value a variation that make the imputed value
follow the shape of the average trajectory. For more details, see [3] and examples' section.
</p>
</dd>
<dt>'copyMean.global' (copy mean, global slope)</dt><dd>
<p>this method impute in two stages. First, it use 'linearInterpol.global'. Then it add to each imputed value a variation that make the imputed value
follow the shape of the average trajectory. For more details, see [3] and examples' section.
</p>
</dd>
<dt>'copyMean.local' (copy mean, local slope)</dt><dd>
<p>this method impute in two stages. First, it use 'linearInterpol.local'. Then it add to each imputed value a variation that make the imputed value
follow the shape of the average trajectory. For more details, see [3] and examples' section.
</p>
</dd>
<dt>'copyMean.bisector' (copy mean, bisector)</dt><dd>
<p>this method impute in two stages. First, it use 'linearInterpol.bisector'. Then it add to each imputed value a variation that make the imputed value
follow the shape of the average trajectory. For more details, see [3] and examples' section.
</p>
</dd>
<dt>locf (Last Occurence Carried Forward)</dt><dd>
<p>THIS METHOD HAS BEEN PROUVEN TO NOT BE EFFICIANT SEVERAL TIME BY VARIOUS AUTHOR, we strongly recommand to not use it !
</p>

<dl>
<dt>Intermitant and monotone at end:</dt><dd><p> the previous non-missing value is
dipplicated forward.</p>
</dd>
<dt>Monotone at start:</dt><dd><p> the first non-missing value is
dupplicated backward (nocb).</p>
</dd>
</dl>

</dd>
<dt>nocb (Next Occurence Carried Backward)</dt><dd>
<p>THIS METHOD HAS BEEN PROUVEN TO NOT BE EFFICIANT SEVERAL TIME BY VARIOUS AUTHOR, we strongly recommand to not use it !
</p>

<dl>
<dt>Intermitant and monotone at start:</dt><dd><p> the next non-missing value is
dipplicated backward.</p>
</dd>
<dt>Monotone at end:</dt><dd><p> the last non-missing value is dupplicated forward (locf).</p>
</dd>
</dl>

</dd>
<dt>trajMean</dt><dd><p> missing are imputed by the mean of the trajectory.</p>
</dd>
<dt>trajMedian</dt><dd><p> missing are imputed by the median of the trajectory.</p>
</dd>
<dt>trajHotDeck</dt><dd><p> each missing is imputed by one non-missing (randomly choosen) value of the trajectory.</p>
</dd>
<dt>crossMean</dt><dd><p> missing value at time t are imputed by the mean of all value present at time t.</p>
</dd>
<dt>crossMedian</dt><dd><p> missing value at time t are imputed by the median of all value present at time t.</p>
</dd>
<dt>crossHotDeck</dt><dd><p> each missing value at time t is imputed by one non-missing (randomly choosen) value present at time t.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code><a href="#topic+LongData-class">LongData</a></code> or a <code>matrix</code> with no missing values.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121,
2011<br />
</p>
<p>[3] Christophe Genolini, René Écochard and Hélène Jacqmin-Gadda<br />
&quot;Copy Mean: A New Method to Impute Intermittent Missing Values in Longitudinal Studies&quot;<br />
Open Journal of Statistics, vol 3(26),2013<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LongData-class">LongData</a></code>, <code><a href="#topic+Partition-class">Partition</a></code>, <code><a href="#topic+qualityCriterion">qualityCriterion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
### Preparation of the data
par(ask=TRUE)
timeV &lt;- 1:14

matMissing &lt;- matrix(
    c(NA  ,NA  ,NA  ,18  ,22  ,NA  ,NA  ,NA  ,NA  , 24  , 22  , NA  , NA  , NA,
      24  ,21  ,24  ,26  ,27  ,32  ,30  ,22  ,26  , 26  , 28  , 24  , 23  , 21,
      14  ,13  , 10 , 8  , 7  ,18  ,16  , 8  ,12  ,  6  ,  10 ,  10 ,  9  ,  7,
       3  ,1   , 1  , 1  ,  3,9   , 7  , -1 , 3   ,  2   ,  4 ,  1  ,  0  , -2
   ),4,byrow=TRUE
)


matplot(t(matMissing),col=c(2,1,1,1),lty=1,type="l",lwd=c(3,1,1,1),pch=16,
   xlab="Black=trajectories; Green=mean trajectory\nRed=trajectory to impute",
   ylab="",main="Four trajectories")
moy &lt;- apply(matMissing,2,mean,na.rm=TRUE)
lines(moy,col=3,lwd=3)

 # # # # # # # # # # # # # # # # # # # # # # # # # #
#   Illustration of the different imputing method   #
 #           The best are at end  !!!              #
  # # # # # # # # # # # # # # # # # # # # # # # # #



##################
### Methods using cross sectionnal information (cross-methods)

par(mfrow=c(1,3))
mat2 &lt;- matrix(c(
  NA, 9, 8, 8, 7, 6,NA,
   7, 6,NA,NA,NA, 4,5,
   3, 4, 3,NA,NA, 2,3,
  NA,NA, 1,NA,NA, 1,1),4,7,byrow=TRUE)

### crossMean
matplot(t(imputation(mat2,"crossMean")),type="l",ylim=c(0,10),
   lty=1,col=1,main="crossMean")
matlines(t(mat2),type="o",col=2,lwd=3,pch=16,lty=1)

### crossMedian
matplot(t(imputation(mat2,"crossMedian")),type="l",ylim=c(0,10),
   lty=1,col=1,main="crossMedian")
matlines(t(mat2),type="o",col=2,lwd=3,pch=16,lty=1)

### crossHotDeck
matplot(t(imputation(mat2,"crossHotDeck")),type="l",ylim=c(0,10),
   lty=1,col=1,main="crossHotDeck")
matlines(t(mat2),type="o",col=2,lwd=3,pch=16,lty=1)



##################
### Methods using trajectory information (traj-methods)

par(mfrow=c(2,3))
mat1 &lt;- matrix(c(NA,NA,3,8,NA,NA,2,2,1,NA,NA),1,11)

### locf
matplot(t(imputation(mat1,"locf")),type="l",ylim=c(0,10),
   main="locf\n DO NOT USE, BAD METHOD !!!")
matlines(t(mat1),type="o",col=2,lwd=3,pch=16)

### nocb
matplot(t(imputation(mat1,"nocb")),type="l",ylim=c(0,10),
   main="nocb\n DO NOT USE, BAD METHOD !!!")
matlines(t(mat1),type="o",col=2,lwd=3,pch=16)

### trajMean
matplot(t(imputation(mat1,"trajMean")),type="l",ylim=c(0,10),
   main="trajMean")
matlines(t(mat1),type="o",col=2,lwd=3,pch=16)

### trajMedian
matplot(t(imputation(mat1,"trajMedian")),type="l",ylim=c(0,10),
   main="trajMedian")
matlines(t(mat1),type="o",col=2,lwd=3,pch=16)

### trajHotDeck
matplot(t(imputation(mat1,"trajHotDeck")),type="l",ylim=c(0,10),
   main="trajHotDeck 1")
matlines(t(mat1),type="o",col=2,lwd=3,pch=16)

### spline
matplot(t(imputation(mat1,"spline",lowerBound=NA,upperBound=NA)),
   type="l",ylim=c(-10,10),main="spline")
matlines(t(mat1),type="o",col=2,lwd=3,pch=16)





##################
### Different linear interpolation

par(mfrow=c(2,2))

### linearInterpol.locf
matplot(t(imputation(mat1,"linearInterpol.locf",NA,NA)),type="l",
   ylim=c(-5,10),lty=1,col=1,main="linearInterpol.locf")
matlines(t(mat1),type="o",col=2,lwd=3,pch=16,lty=1)

### linearInterpol.global
matplot(t(imputation(mat1,"linearInterpol.global",NA,NA)),type="l",
   ylim=c(-5,10),lty=1,col=1,main="linearInterpol.global")
matlines(t(mat1),type="o",col=2,lwd=3,pch=16,lty=1)

### linearInterpol.local
matplot(t(imputation(mat1,"linearInterpol.local",NA,NA)),type="l",
   ylim=c(-5,10),lty=1,col=1,main="linearInterpol.local")
matlines(t(mat1),type="o",col=2,lwd=3,pch=16,lty=1)

### linearInterpol.bisector
matplot(t(imputation(mat1,"linearInterpol.bisector",NA,NA)),type="l",
   ylim=c(-5,10),lty=1,col=1,main="linearInterpol.bisector")
matlines(t(mat1),type="o",col=2,lwd=3,pch=16,lty=1)



##################
### Copy mean

mat3 &lt;- matrix(c(
  NA, 9, 8, 8, 7, 6,NA,
   7, 6,NA,NA,NA, 4,5,
   3, 4, 3,NA,NA, 2,3,
  NA,NA, 1,NA,NA, 1,1),4,7,byrow=TRUE)


par(mfrow=c(2,2))

### copyMean.locf
matplot(t(imputation(mat2,"copyMean.locf",NA,NA)),type="l",
   ylim=c(-5,10),lty=1,col=1,main="copyMean.locf")
matlines(t(mat2),type="o",col=2,lwd=3,pch=16,lty=1)

### copyMean.global
matplot(t(imputation(mat2,"copyMean.global",NA,NA)),type="l",
   ylim=c(-5,10),lty=1,col=1,main="copyMean.global")
matlines(t(mat2),type="o",col=2,lwd=3,pch=16,lty=1)

### copyMean.local
matplot(t(imputation(mat2,"copyMean.local",NA,NA)),type="l",
   ylim=c(-5,10),lty=1,col=1,main="copyMean.local")
matlines(t(mat2),type="o",col=2,lwd=3,pch=16,lty=1)

### copyMean.bisector
matplot(t(imputation(mat2,"copyMean.bisector",NA,NA)),type="l",
   ylim=c(-5,10),lty=1,col=1,main="copyMean.bisector")
matlines(t(mat2),type="o",col=2,lwd=3,pch=16,lty=1)




### crossMean
matImp &lt;- imputation(matMissing,method="crossMean")
matplot(t(matImp),col=c(2,1,1,1),lty=c(2,1,1,1),type="l",lwd=c(2,1,1,1),pch=16,
   xlab="Dotted red=imputed trajectory\nFull red=trajectory to impute",
   ylab="",main="Method 'crossMean'")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)


### crossMedian
matImp &lt;- imputation(matMissing,method="crossMedian")
matplot(t(matImp),col=c(2,1,1,1),lty=c(2,1,1,1),type="l",lwd=c(2,1,1,1),pch=16,
   xlab="Dotted red=imputed trajectory\nFull red=trajectory to impute",ylab="",
   main="Method 'crossMedian'")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)

### crossHotDeck
matImp &lt;- imputation(matMissing,method="crossHotDeck")
matplot(t(matImp),col=c(2,1,1,1),lty=c(2,1,1,1),type="l",lwd=c(2,1,1,1),pch=16,
   xlab="Dotted red=imputed trajectory\nFull red=trajectory to impute",ylab="",
   main="Method 'crossHotDeck'")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)


##################
### Method using trajectory

par(mfrow=c(2,3))
### trajMean
matImp &lt;- imputation(matMissing,method="trajMean")
plot(timeV,matImp[1,],type="l",lwd=2,ylim=c(10,30),ylab="",xlab="nocb")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)

### trajMedian
matImp &lt;- imputation(matMissing,method="trajMedian")
plot(timeV,matImp[1,],type="l",lwd=2,ylim=c(10,30),ylab="",xlab="nocb")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)

### trajHotDeck
matImp &lt;- imputation(matMissing,method="trajHotDeck")
plot(timeV,matImp[1,],type="l",lwd=2,ylim=c(10,30),ylab="",xlab="nocb")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)

### locf
matImp &lt;- imputation(matMissing,method="locf")
plot(timeV,matImp[1,],type="l",lwd=2,ylim=c(10,30),ylab="",xlab="locf")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)

### nocb
matImp &lt;- imputation(matMissing,method="nocb")
plot(timeV,matImp[1,],type="l",lwd=2,ylim=c(10,30),ylab="",xlab="nocb")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)

par(mfrow=c(2,2))

### linearInterpol.locf
matImp &lt;- imputation(matMissing,method="linearInterpol.locf")
plot(timeV,matImp[1,],type="o",ylim=c(0,30),ylab="",xlab="LI-Global")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)

### linearInterpol.local
matImp &lt;- imputation(matMissing,method="linearInterpol.local")
plot(timeV,matImp[1,],type="o",ylim=c(0,30),ylab="",xlab="LI-Global")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)

### linearInterpol.global
matImp &lt;- imputation(matMissing,method="linearInterpol.global")
plot(timeV,matImp[1,],type="o",ylim=c(0,30),ylab="",xlab="LI-Global")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)

### linearInterpol.bisector
matImp &lt;- imputation(matMissing,method="linearInterpol.bisector")
plot(timeV,matImp[1,],type="o",ylim=c(0,30),ylab="",xlab="LI-Global")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)


par(mfrow=c(2,2))

### copyMean.locf
matImp &lt;- imputation(matMissing,method="copyMean.locf")
plot(timeV,matImp[1,],type="o",ylim=c(0,30),ylab="",xlab="LI-Global")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)
lines(timeV,moy,col=3,type="o",lwd=3)

### copyMean.local
matImp &lt;- imputation(matMissing,method="copyMean.local")
plot(timeV,matImp[1,],type="o",ylim=c(0,30),ylab="",xlab="LI-Global")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)
lines(timeV,moy,col=3,type="o",lwd=3)

### copyMean.global
matImp &lt;- imputation(matMissing,method="copyMean.global")
plot(timeV,matImp[1,],type="o",ylim=c(0,30),ylab="",xlab="LI-Global")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)
lines(timeV,moy,col=3,type="o",lwd=3)

### copyMean.bisector
matImp &lt;- imputation(matMissing,method="copyMean.bisector")
plot(timeV,matImp[1,],type="o",ylim=c(0,30),ylab="",xlab="LI-Global")
lines(timeV,matMissing[1,],col=2,type="o",lwd=3)
lines(timeV,moy,col=3,type="o",lwd=3)

par(ask=FALSE)
</code></pre>

<hr>
<h2 id='initializePartition'>
~ Function: initializePartition ~
</h2><span id='topic+initializePartition'></span><span id='topic+initializePartition+2Cnumeric+2Cnumeric+2Ccharacter+2CANY-method'></span><span id='topic+initializePartition+2Cnumeric+2Cnumeric+2Ccharacter+2Carray-method'></span>

<h3>Description</h3>

<p>This function provide different way of setting the initial partition
for an EM algoritm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initializePartition(nbClusters, lengthPart, method = "kmeans++", data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initializePartition_+3A_nbclusters">nbClusters</code></td>
<td>
<p>[numeric]: number of clusters of that the initial
partition should have.</p>
</td></tr>
<tr><td><code id="initializePartition_+3A_lengthpart">lengthPart</code></td>
<td>
<p>[numeric]: number of individual in the partition.</p>
</td></tr>
<tr><td><code id="initializePartition_+3A_method">method</code></td>
<td>
<p>[character]: one off &quot;randomAll&quot;, &quot;randomK&quot;, &quot;maxDist&quot;,
&quot;kmeans++&quot;, &quot;kmeans+&quot;, &quot;kmeans&ndash;&quot; or &quot;kmeans-&quot;.</p>
</td></tr>
<tr><td><code id="initializePartition_+3A_data">data</code></td>
<td>
<p>[matrix]: <code>data</code> is the matrix of the individuals (usefull for the methods that
need to compute distance between
individual). If <code>data</code> is an array, the distance is computed
using &quot;maxDist&quot; is used, the
function needs to know the matrix of the distance between each individual.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before alternating the phase Esperance and Maximisation, the EM
algorithm needs to initialize a starting configuration. This initial
partition has been proven to have an important impact on the
final result and the convergence time.
</p>
<p>This function provides different ways of setting the initial partition.
</p>

<ul>
<li><p> randomAll: all the individual are randomly assigned to a
cluster with at least one individual in each clusters.
</p>
</li>
<li><p> randomK: K individuals are randomly assigned to a
cluster, all the other are not assigned (each cluster has only one
individual).
</p>
</li>
<li><p> maxDist: K indivuals are chosen. The two formers are the
individual separated by the highest distance. The latter are added one
by one, they are the &quot;farthest&quot; individual among those that are already been
selected. &quot;farthest&quot; is the individual with the highest distance (min)
to the selected individuals (if &quot;t&quot; are the individual already selected, the
next selected individual is &quot;i&quot; such that
max_i(min_t(dist(IND_i,IND_t))) ). This method is efficient but time
consuming.
</p>
</li>
<li><p> kmeans++: see [3]
</p>
</li>
<li><p> kmeans+, kmeans&ndash;, kmeans-: experimental methods derived from [3].
</p>
</li></ul>



<h3>Value</h3>

<p>vecteur of numeric.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>
<p>[3] D. Arthur and S. Vassilvitskii<br />
&quot;k-means++: the advantages of careful seeding&quot;<br />
Proceedings of the eighteenth annual ACM-SIAM symposium on Discrete
algorithms. pp. 1027-1035, 2007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(ask=TRUE)
###################
### Constrution of some longitudinal data
data(artificialLongData)
dn &lt;- longData(artificialLongData)
plotTrajMeans(dn)

###################
### partition using randamAll
pa1a &lt;- initializePartition(3,lengthPart=200,method="randomAll")
plotTrajMeans(dn,partition(pa1a),parMean=parMEAN(type="n"),parTraj=parTRAJ(col="clusters"))
pa1b &lt;- initializePartition(3,lengthPart=200,method="randomAll")
plotTrajMeans(dn,partition(pa1b),parMean=parMEAN(type="n"),parTraj=parTRAJ(col="clusters"))

###################
### partition using randamK
pa2a &lt;- initializePartition(3,lengthPart=200,method="randomK")
plotTrajMeans(dn,partition(pa2a),parMean=parMEAN(type="n"),parTraj=parTRAJ(col="clusters"))
pa2b &lt;- initializePartition(3,lengthPart=200,method="randomK")
plotTrajMeans(dn,partition(pa2b),parMean=parMEAN(type="n"),parTraj=parTRAJ(col="clusters"))

###################
### partition using maxDist
pa3 &lt;- initializePartition(3,lengthPart=200,method="maxDist",data=dn["traj"])
plotTrajMeans(dn,partition(pa3),parMean=parMEAN(type="n"),parTraj=parTRAJ(col="clusters"))
### maxDist is deterministic, so no need for a second example


###################
### Example to illustrate "maxDist" method on classical clusters
point &lt;- matrix(c(0,0, 0,1, -1,0, 0,-1, 1,0),5,byrow=TRUE)
points &lt;- rbind(point,t(t(point)+c(10,0)),t(t(point)+c(5,6)))
points &lt;- rbind(points,t(t(points)+c(30,0)),t(t(points)+c(15,20)),t(-t(point)+c(20,10)))
plot(points,main="Some points")

paInit &lt;- initializePartition(2,nrow(points),method="maxDist",points)
plot(points,main="Two farest points")
lines(points[!is.na(paInit),],col=2,type="p",pch=16)

paInit &lt;- initializePartition(3,nrow(points),method="maxDist",points)
plot(points,main="Three farest points")
lines(points[!is.na(paInit),],col=2,type="p",pch=16)

paInit &lt;- initializePartition(4,nrow(points),method="maxDist",points)
plot(points, main="Four farest points")
lines(points[!is.na(paInit),],col=2,type="p",pch=16)

par(ask=FALSE)
</code></pre>

<hr>
<h2 id='ListPartition-class'>~ Class: ListPartition ~</h2><span id='topic+ListPartition'></span><span id='topic+ListPartition-class'></span><span id='topic++5B+2CListPartition-method'></span><span id='topic++5B+2CListPartition-methods'></span><span id='topic++5B+2CListPartition-ANY+2CANY+2CANY'></span><span id='topic++5B+2CListPartition-ANY+2CANY+2CANY-method'></span><span id='topic++5B+2CListPartition-ANY+2CANY+2CANY-methods'></span><span id='topic++5B+3C-+2CListPartition-method'></span><span id='topic++5B+3C-+2CListPartition-ANY+2CANY+2CANY'></span><span id='topic+ListPartition_show'></span><span id='topic+show+2CListPartition-method'></span><span id='topic+listPartition'></span><span id='topic+listPartition-method'></span>

<h3>Description</h3>

<p>An object of class <code>ListPartition</code> contain several liste of
<code>Partition</code> sorted by cluster numbers.
</p>


<h3>Objects from the Class</h3>

<p>Objects are mainly design to store the numerous <code>Partition</code> found
by <code>kml</code> or <code>kml3d</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>criterionActif</code></dt><dd><p>[character]: Store the criterion name
that will be used by fonctions that need a single criterion
(like <a href="#topic+plotCriterion">plotCriterion</a> or <a href="#topic+ordered">ordered</a>).</p>
</dd>
<dt><code>initializationMethod</code></dt><dd><p>[vector(chararcter)]: list all
the initialization method that has allready been used to find some
<code>Partition</code>
(usefull to not run several time a deterministic method).</p>
</dd>
<dt><code>sorted</code></dt><dd><p><code>[logical]</code>: are the <code>Partition</code>
curently hold in the object sorted in decreasing (or increasing, according to
<code>criterionActif</code>) order ?</p>
</dd>
<dt><code>c1</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 1 clusters.</p>
</dd>
<dt><code>c2</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 2 clusters.</p>
</dd>
<dt><code>c3</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 3 clusters.</p>
</dd>
<dt><code>c4</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 4 clusters.</p>
</dd>
<dt><code>c5</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 5 clusters.</p>
</dd>
<dt><code>c6</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 6 clusters.</p>
</dd>
<dt><code>c7</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 7 clusters.</p>
</dd>
<dt><code>c8</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 8 clusters.</p>
</dd>
<dt><code>c9</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 9 clusters.</p>
</dd>
<dt><code>c10</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 10 clusters.</p>
</dd>
<dt><code>c11</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 11 clusters.</p>
</dd>
<dt><code>c12</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 12 clusters.</p>
</dd>
<dt><code>c13</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 13 clusters.</p>
</dd>
<dt><code>c14</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 14 clusters.</p>
</dd>
<dt><code>c15</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 15 clusters.</p>
</dd>
<dt><code>c16</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 16 clusters.</p>
</dd>
<dt><code>c17</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 17 clusters.</p>
</dd>
<dt><code>c18</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 18 clusters.</p>
</dd>
<dt><code>c19</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 19 clusters.</p>
</dd>
<dt><code>c20</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 20 clusters.</p>
</dd>
<dt><code>c21</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 21 clusters.</p>
</dd>
<dt><code>c22</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 22 clusters.</p>
</dd>
<dt><code>c23</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 23 clusters.</p>
</dd>
<dt><code>c24</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 24 clusters.</p>
</dd>
<dt><code>c25</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 25 clusters.</p>
</dd>
<dt><code>c26</code></dt><dd><p>[list(Partition)]: list of <code>Partition</code> with 26 clusters.</p>
</dd>
</dl>



<h3>Construction</h3>

<p>Class <code>ListPartition</code> objects are mainly constructed by
<code>kml</code>.
Neverdeless, it is also possible to construct them from
scratch using the fonction <code><a href="#topic+listPartition">listPartition</a></code> that does
create an empty object.
</p>


<h3>Methods</h3>


<dl>
<dt><code>object['xxx']</code></dt><dd><p>If 'xxx' is 'cX',
'initializationMethod', 'sorted'
or 'criterionActif', get the value of the field
<code>xxx</code>.</p>
</dd>
<dt><code>object['criterionValues',j]</code></dt><dd><p>Give the values of the
criterion 'j' for all the Partitions. The result is return as a
list. If 'j' is missing, the criterion actif is used.</p>
</dd>
<dt><code>object['criterionValuesAsMatrix',j]</code></dt><dd><p>Give the values of the
criterion 'j' for all the Partitions. The result is return as a
matrix. If 'j' is missing, the criterion actif is used.</p>
</dd>
<dt><code>object['xxx']</code></dt><dd><p>If 'xxx' is a criterion, this is
equivalent to object['criterionValuesAsMatrix','xxx']</p>
</dd>
<dt><code>object['initializationMethod']&lt;-value</code></dt><dd><p>Set the field to
<code>value</code></p>
</dd>
<dt><code>object['criterionActif']&lt;-value</code></dt><dd><p>If 'value' is one of
CRITERION_NAMES, it sets the field to the criterion 'value'.</p>
</dd>
<dt><code>object['add']&lt;-value</code></dt><dd><p>If 'value' is an object of class
'Partition', then value is added to
the Partition already hold in the field 'cX'. Note that a Partition with
'X' clusters is automatiquely added to the correct list 'cX' according to its number of
clusters.</p>
</dd>
<dt><code>object['clear']&lt;-'cX'</code></dt><dd><p>Clear the list 'cX'.</p>
</dd>
<dt><code>listPartition</code></dt><dd><p>Constructor. Build an empty object.</p>
</dd>
<dt><code>ordered</code></dt><dd><p>Order the Partition according to the criterion
actif.</p>
</dd>
<dt><code>regroup</code></dt><dd><p>Order then merge identical Partition (usefull
to reduce the size of the <code>ListPartition</code>)</p>
</dd>
</dl>



<h3>Author</h3>

<p>Christophe Genolini^{1,2}<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSM, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] Christophe M. Genolini and Bruno Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] Christophe M. Genolini and Bruno Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011
</p>


<h3>See Also</h3>

<p>Classes: <code><a href="#topic+LongData-class">LongData</a></code> <br />
Methods: <code><a href="#topic+Partition-class">Partition</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############
### Preparing data
data(artificialLongData)
traj &lt;- as.matrix(artificialLongData[,-1])

### Some clustering
part2 &lt;- partition(rep(c("A","B"),time=100),traj)
part3 &lt;- partition(rep(c("A","B","C","A"),time=50),traj)
part3b &lt;- partition(rep(c("A","B","C","B","C"),time=40),traj)
part4 &lt;- partition(rep(c("A","B","A","C","D"),time=40),traj)


################
### ListPartition
listPart &lt;- listPartition()
plotCriterion(listPart)

listPart["add"] &lt;- part2
listPart["add"] &lt;- part3
listPart["add"] &lt;- part3b
listPart["add"] &lt;- part4
listPart["add"] &lt;- part4
listPart["add"] &lt;- part3
listPart["add"] &lt;- part3b

plotCriterion(listPart)
ordered(listPart)
plotCriterion(listPart)
regroup(listPart)
plotCriterion(listPart)
plotAllCriterion(listPart)
</code></pre>

<hr>
<h2 id='longData'> ~ Function: longData ~</h2><span id='topic+longData'></span><span id='topic+longData+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+longData+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>longData</code> is a constructor for the class <code><a href="#topic+LongData-class">LongData</a></code>.
It create object <code><a href="#topic+LongData-class">LongData</a></code> containing a single variable-trajectory.
For creating joint variable-trajectories, see <code><a href="#topic+longData3d">longData3d</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longData(traj, idAll, time, timeInData,varNames,maxNA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longData_+3A_traj">traj</code></td>
<td>
<p><code>[matrix(numeric)]</code>, <code>[array(numeric)]</code> or <code>[data.frame]</code>: structure containning the trajectories.</p>
</td></tr>
<tr><td><code id="longData_+3A_idall">idAll</code></td>
<td>
<p><code>[vector(character)]</code>: single identifier for each trajectory (ie each individual).</p>
</td></tr>
<tr><td><code id="longData_+3A_time">time</code></td>
<td>
<p><code>[vector(numeric)]</code>: time at which measures were made.</p>
</td></tr>
<tr><td><code id="longData_+3A_timeindata">timeInData</code></td>
<td>
<p><code>[list(vector(numeric))]</code>: precise the column
containing the trajectories.</p>
</td></tr>
<tr><td><code id="longData_+3A_varnames">varNames</code></td>
<td>
<p><code>[character]</code>: name of the variable-trajectory being measured.</p>
</td></tr>
<tr><td><code id="longData_+3A_maxna">maxNA</code></td>
<td>
<p><code>[numeric]</code>: maximum number of NA that are tolerates
on a trajectory. If a trajectory has more
missing than <code>maxNA</code>, then it is remove from the analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>longData</code> construct a object of class <code><a href="#topic+LongData-class">LongData</a></code>.
Two cases can be distinguised:
</p>

<dl>
<dt><code>traj</code> is an <code>array</code>:</dt><dd><p> lines are individual. Column
are time of measurment.
</p>
<p>If <code>idAll</code> is missing, the individuals are labelled <code>i1</code>,
<code>i2</code>, <code>i3</code>,...
</p>
<p>If <code>timeInData</code> is missing, all the column
are used (<code>timeInData=1:ncol(traj)</code>).</p>
</dd>
<dt>If <code>traj</code> is a <code>data.frame</code>:</dt><dd><p> lines are
individual. Column are time of measurement.
</p>
<p>If <code>idAll</code> is missing, then the first column of the
<code>data.frame</code> is used for <code>idAll</code>
</p>
<p>If <code>timeInData</code> is missing and <code>idAll</code> is missing, then
all the columns but the first are used for <code>timeInData</code> (the
first is omited since it is already used for <code>idAll</code>): <code>idAll=traj[,1],timeInData=2:ncol(traj)</code>.
</p>
<p>If <code>timeInData</code> is missing but <code>idAll</code> is not missing,
then all the column including the first are used for <code>timeInData</code>: <code>timeInData=1:ncol(traj)</code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code><a href="#topic+LongData-class">LongData</a></code>.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p><a href="#topic+LongData-class">LongData</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
### From matrix

### Small data
mat &lt;- matrix(c(1,NA,3,2,3,6,1,8,10),3,3,dimnames=list(c(101,102,104),c("T2","T4","T8")))
longData(mat)
(ld1 &lt;- longData(traj=mat,idAll=as.character(c(101,102,104)),time=c(2,4,8),varNames="V"))
plotTrajMeans(ld1)

### Big data
mat &lt;- matrix(runif(1051*325),1051,325)
(ld2 &lt;- longData(traj=mat,idAll=paste("I-",1:1051,sep=""),time=(1:325)+0.5,varNames="Random"))

####################
### From data.frame

dn &lt;- data.frame(id=1:3,v1=c(NA,2,1),v2=c(NA,1,0),v3=c(3,2,2),v4=c(4,2,NA))

### Basic
longData(dn)

### Selecting some times
(ld3 &lt;- longData(dn,timeInData=c(1,2,4),varNames=c("Hyp")))

### Excluding trajectories with more than 1 NA
(ld3 &lt;- longData(dn,maxNA=1))
</code></pre>

<hr>
<h2 id='LongData-class'>~ Class: LongData ~</h2><span id='topic+LongData'></span><span id='topic+LongData-class'></span><span id='topic++5B+2CLongData-method'></span><span id='topic++5B+2CLongData-ANY+2CANY+2CANY'></span><span id='topic++5B+3C-+2CLongData-method'></span><span id='topic++5B+3C-+2CLongData-ANY+2CANY+2CANY'></span><span id='topic+LongData_show'></span><span id='topic+show+2CLongData-method'></span><span id='topic+is.na+2CLongData-method'></span>

<h3>Description</h3>

<p><code>LongData</code> is an objet containing the longitudinal
data (the individual trajectories) and some associate value (like time, individual
identifiant,...). It can be used either for a single
variable-trajectory or for joint variable-trajectories.
</p>


<h3>Objects from the Class</h3>

<p>Object <code>LongData</code> for single variable-trajectory can be created using
the fonction <code><a href="#topic+longData">longData</a></code> on a <code>data.frame</code> or on a <code>matrix</code>.
</p>
<p><code>LongData</code> for joint trajectories can be created by calling
the fonction <code><a href="#topic+longData3d">longData3d</a></code> on a <code>data.frame</code> or on an <code>array</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>idAll</code></dt><dd><p><code>[vector(character)]</code>: Single identifier
for each of the longData (each individual). Usefull to export clusters.</p>
</dd>
<dt><code>idFewNA</code></dt><dd><p><code>[vector(character)]</code>: Restriction of
<code>idAll</code> to the trajectories that does not have 'too many' missing
value. See <code>maxNA</code> for 'too many' definition.</p>
</dd>
<dt><code>time</code></dt><dd><p><code>[numeric]</code>: Time at which measures are made.</p>
</dd>
<dt><code>varNames</code></dt><dd><p><code>[character]</code>: Name of the variable measured.</p>
</dd>
<dt><code>traj</code></dt><dd><p><code>[matrix(numeric)]</code>: Contains
the longitudianl data. Each lines is the trajectories of an
individual. Each column is the time at which measures
are made.</p>
</dd>
<dt><code>dimTraj</code></dt><dd><p><code>[vector3(numeric)]</code>: size of the matrix
<code>traj</code> (ie <code>dimTraj=c(length(idFewNA),length(time))</code>).</p>
</dd>
<dt><code>maxNA</code></dt><dd><p><code>[numeric]</code> or <code>[vector(numeric)]</code>:
Individual whose trajectories contain 'too many' missing value
are exclude from <code>traj</code> and will no be use in
the analysis. Their identifier is preserved in <code>idAll</code> but
not in <code>idFewNA</code>. 'too many' is define by <code>maxNA</code>: a
trajectory with more missing than <code>maxNA</code> is exclude.</p>
</dd>
<dt><code>reverse</code></dt><dd><p><code>[matrix(numeric)]</code>: if the trajectories
are scale using the function <code><a href="#topic+scale">scale</a></code>, the 'scaling
parameters' (probably mean and standard deviation) are saved in
<code>reverse</code>. This is usefull to restore the original data after a
scaling operation.</p>
</dd>
</dl>



<h3>Construction</h3>

<p>Object <code>LongData</code> for single variable-trajectory can be created by calling
the fonction <code><a href="#topic+longData">longData</a></code> on a <code>data.frame</code> or on a <code>matrix</code>.
</p>
<p><code>LongData</code> for joint trajectories can be created by calling
the fonction <code><a href="#topic+longData3d">longData3d</a></code> on a <code>data.frame</code> or on an <code>array</code>.
</p>


<h3>Get [</h3>


<dl>
<dt>Object[&quot;idAll&quot;]</dt><dd><p>[vecteur(character)]: Gets the full list of individual
identifiant (the value of the slot <code>idAll</code>)</p>
</dd>
<dt>Object[&quot;idFewNA&quot;]</dt><dd><p>[vecteur(character)]: Gets the list of individual
identifiant with not too many missing values (the value of the slot <code>idFewNA</code>)</p>
</dd>
<dt>Object[&quot;varNames&quot;]</dt><dd><p>[character]: Gets the name(s) of the variable (the value of the slot <code>varNames</code>)</p>
</dd>
<dt>Object[&quot;time&quot;]</dt><dd><p>[vecteur(numeric)]: Gets the times (the value of the slot <code>time</code>)</p>
</dd>
<dt>Object[&quot;traj&quot;]</dt><dd><p>[array(numeric)]: Gets all the longData' values (the value of the slot <code>traj</code>)</p>
</dd>
<dt>Object[&quot;dimTraj&quot;]</dt><dd><p>[vector3(numeric)]: Gets the dimension of <code>traj</code>.</p>
</dd>
<dt>Object[&quot;nbIdFewNA&quot;]</dt><dd><p>[numeric]: Gets the first dimension of
<code>traj</code> (ie the number of individual include in the analysis).</p>
</dd>
<dt>Object[&quot;nbTime&quot;]</dt><dd><p>[numeric]: Gets the second dimension of
<code>traj</code> (ie the number of time measurement).</p>
</dd>
<dt>Object[&quot;nbVar&quot;]</dt><dd><p>[numeric]: Gets the third dimension of
<code>traj</code> (ie the number of variables).</p>
</dd>
<dt>Object[&quot;maxNA&quot;]</dt><dd><p>[vecteur(numeric)]: Gets maxNA.</p>
</dd>
<dt>Object[&quot;reverse&quot;]</dt><dd><p>[matrix(numeric)]: Gets the matrix of the
scaling parameters.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code><a href="#topic+scale">scale</a></code></dt><dd><p>scale the trajectories. Usefull to
normalize variable trajectories measured with different units.</p>
</dd>
<dt><code><a href="#topic+restoreRealData">restoreRealData</a></code></dt><dd><p>restore original data that
have been modified after a scaling operation.</p>
</dd>



<dt><code><a href="#topic+longDataFrom3d">longDataFrom3d</a></code></dt><dd><p>Extract a variable trajectory
form a dataset of joint trajectories.</p>
</dd>
<dt><code>plotTrajMeans</code></dt><dd><p>plot all the variables of the <code>LongData</code>, optionnaly according to a <code><a href="#topic+Partition-class">Partition</a></code>.</p>
</dd>
<dt><code>plotTrajMeans3d</code></dt><dd><p>plot two variables of the <code>LongData</code> in 3 dimensions, optionnaly according to a <code><a href="#topic+Partition-class">Partition</a></code>.</p>
</dd>
<dt><code>plot3dPdf</code></dt><dd><p>create 'Triangle objects' representing in
3D the cluster's center according to a
<code><a href="#topic+Partition-class">Partition</a></code>. 'Triangle object' can latter be
include in a LaTeX file to get a dynamique (rotationg) pdf
figure.</p>
</dd>
<dt><code>imputation</code></dt><dd><p>Impute the missing values of the trajectories.</p>
</dd>
<dt><code>qualityCriterion</code></dt><dd><p>Compute some quality criterion that
can be use to compare the quality of differents <code><a href="#topic+Partition-class">Partition</a></code>.</p>
</dd>
</dl>



<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p>Overview: <code><a href="#topic+longitudinalData-package">longitudinalData-package</a></code> <br />
Methods: <code><a href="#topic+longData">longData</a></code>,  <code><a href="#topic+longData3d">longData3d</a></code>, <code><a href="#topic+imputation">imputation</a></code>, <code><a href="#topic+qualityCriterion">qualityCriterion</a></code><br />
Plot: <code><a href="#topic+plotTrajMeans">plotTrajMeans</a></code>,
<code><a href="#topic+plotTrajMeans3d">plotTrajMeans3d</a></code>,  <code><a href="#topic+plot3dPdf">plot3dPdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################
### building trajectory (longData)
mat &lt;- matrix(c(NA,2,3,4,1,6,2,5,1,3,8,10),4)
ld &lt;- longData(mat,idAll=c("I1","I2","I3","I4"),time=c(2,4,8),varNames="Age")

### '[' and '[&lt;-'
ld["idAll"]
ld["idFewNA"]
ld["varNames"]
ld["traj"]
(ld)

### Plot
plotTrajMeans(ld,parMean=parMEAN(type="n"))
</code></pre>

<hr>
<h2 id='longData-internal'>~ longData: internal objects and methods ~</h2><span id='topic+catShort'></span><span id='topic+printShort'></span><span id='topic+printMatrixShort'></span><span id='topic+printOneTraj'></span><span id='topic+printTrajLong'></span><span id='topic+METHODS'></span><span id='topic+medianNA'></span><span id='topic+meanNA'></span><span id='topic+sdNA'></span><span id='topic+sdcNA'></span><span id='topic+varNA'></span><span id='topic+rangeNA'></span><span id='topic+which.minNA'></span><span id='topic+is.tna'></span><span id='topic+showLongData'></span><span id='topic+showLongData3d'></span><span id='topic+showListPartition'></span><span id='topic+canonicalizeAndMergeScene'></span><span id='topic+colorScene'></span><span id='topic+t2ve'></span><span id='topic+is.Triangles3D'></span><span id='topic+colorTriangles'></span>

<h3>Description</h3>

<p>longData: internal objects and methods</p>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<ul>
<li><p> medianNA : median with option na.rm=TRUE
</p>
</li>
<li><p> meaanNA : mean with option na.rm=TRUE
</p>
</li>
<li><p> sdNA : sandard deviation with option na.rm=TRUE
</p>
</li>
<li><p> sdcNA : standard deviation corrected (n-1)/n with option na.rm=TRUE
</p>
</li>
<li><p> varNA : var with option na.rm=TRUE
</p>
</li>
<li><p> rangeNA : range with option na.rm=TRUE
</p>
</li>
<li><p> which.minNA : which.min that return NA if it argument has only
NA values.
</p>
</li>
<li><p> NAtrunc : function that remove only the NA value in the tail
of its argument.
</p>
</li>
<li><p> showLongData : methods use to define the function 'show'
</p>
</li>
<li><p> METHODS : constant=c(&quot;manhattan&quot;, &quot;euclidean&quot;, &quot;minkowski&quot;,
&quot;maximum&quot;, &quot;canberra&quot;, &quot;binary&quot;)
</p>
</li></ul>



<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>

<hr>
<h2 id='longData3d'> ~ Function: longData3d ~</h2><span id='topic+longData3d'></span><span id='topic+longData3d+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+longData3d+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>longData3d</code> is a constructor of the class <code><a href="#topic+LongData-class">LongData</a></code>.
It create object <code><a href="#topic+LongData-class">LongData</a></code> containing several joint trajectory (two
or more variable-trajectories). For creating a single
variable-trajectory, see <code><a href="#topic+longData">longData</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longData3d(traj, idAll, time, timeInData,varNames,maxNA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longData3d_+3A_traj">traj</code></td>
<td>
<p><code>[array(numeric)]</code> or <code>data.frame</code>: structure containning the variable-trajectories.</p>
</td></tr>
<tr><td><code id="longData3d_+3A_idall">idAll</code></td>
<td>
<p><code>[vector(character)]</code>: single identifier for each trajectory (ie each individual).</p>
</td></tr>
<tr><td><code id="longData3d_+3A_time">time</code></td>
<td>
<p><code>[vector(numeric)]</code>: time at which measures were made.</p>
</td></tr>
<tr><td><code id="longData3d_+3A_timeindata">timeInData</code></td>
<td>
<p><code>[list(vector(numeric))]</code>:  Precise the column containing the
trajectories.  If <code>traj</code> is a <code>data.frame</code>, it sould be a list.</p>
</td></tr>
<tr><td><code id="longData3d_+3A_varnames">varNames</code></td>
<td>
<p><code>[character]</code>: name of the variable-trajectories being measured.</p>
</td></tr>
<tr><td><code id="longData3d_+3A_maxna">maxNA</code></td>
<td>
<p><code>[vector(numeric)]</code>: maximum number of NA that are tolerates
on a trajectory (one for each variable). If a trajectory has more
missing than maxNA, then it is remove from the analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>longData3d</code> construct a object of class
<code><a href="#topic+LongData-class">LongData</a></code>. Two cases can be distinguised:
</p>

<dl>
<dt><code>traj</code> is an <code>array</code>:</dt><dd><p> the first dimension (line) are
individual. The second dimension (column) are time at which the
measurement are made. The third dimension are the differents
variable-trajectories. For example, <code>traj[,,2]</code> is the second variable-trajectory.
</p>
<p>If <code>idAll</code> is missing, the individuals are labelled <code>i1</code>,
<code>i2</code>, <code>i3</code>,...
</p>
<p>If <code>timeInData</code> is missing, all the column
are used (<code>1:ncol(traj)</code>).</p>
</dd>
<dt>If <code>traj</code> is a <code>data.frame</code>:</dt><dd><p> lines are individual. Time of
measurement and variables should be provide through
<code>timeInData</code>. <code>timeInData</code> is a list.
The label of the list are the
variable-trajectories names. Elements of the list are the column
containning the trajectories. For example, if
<code>timeInData=list(V=c(2,3,4),W=c(6,8,12))</code>, then the first
variable-trajectory is 'V', its measurement are in column 2,3 and
4. The second variable-trajectory is 'W', its measurement are in column
6,8 and 12.
</p>
<p>If <code>idAll</code> is missing, the first column of the <code>data.frame</code>
is used.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code><a href="#topic+LongData-class">LongData</a></code>.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p><a href="#topic+LongData-class">LongData</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>#################
### From array

mat &lt;- array(c(1,NA,3,2,3,6,1,8,10,1,NA,1,2,NA,3,2,3,2),dim=c(3,3,2))
longData3d(mat)
(ld1 &lt;- longData3d(mat,varNames=c("Hyp","Col"),idAll=c("i101","i104","i105")))
plotTrajMeans3d(ld1)

#################
### From data.frame

dn &lt;- data.frame(id=1:3,v1=c(2,2,1),t1=c(20,21,22),v1=c(3,2,2),t2=c(23,20,28),t3=c(25,24,29))
longData3d(dn,timeInData=list(c(2,4),c(3,5)),varNames=c("V","T"))
(ld3 &lt;- longData3d(dn,timeInData=list(V=c(2,4,NA),T=c(3,5,6))))
plotTrajMeans3d(ld3)
</code></pre>

<hr>
<h2 id='LongData3d-class'>~ Class: LongData3d ~</h2><span id='topic+LongData3d'></span><span id='topic+LongData3d-class'></span><span id='topic++5B+2CLongData3d-method'></span><span id='topic++5B+2CLongData3d-ANY+2CANY+2CANY'></span><span id='topic++5B+2CLongData3d-ANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CLongData3d-method'></span><span id='topic++5B+3C-+2CLongData3d-ANY+2CANY+2CANY-method'></span><span id='topic+LongData3d_show'></span><span id='topic+show+2CLongData3d-method'></span><span id='topic+is.na+2CLongData3d-method'></span>

<h3>Description</h3>

<p><code>LongData3d</code> is an objet containing joint longitudinal
data and some associate value (like time, individual
identifiant,...).
</p>


<h3>Objects from the Class</h3>

<p>Object <code>LongData3d</code> can be created using
the fonction <code><a href="#topic+longData3d">longData3d</a></code> on a <code>data.frame</code> or on an <code>array</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>idAll</code></dt><dd><p><code>[vector(character)]</code>: Single identifier
for each of the longData3d (each individual). Usefull to export clusters.</p>
</dd>
<dt><code>idFewNA</code></dt><dd><p><code>[vector(character)]</code>: Restriction of
<code>idAll</code> to the trajectories that does not have 'too many' missing
value. See <code>maxNA</code> for 'too many' definition.</p>
</dd>
<dt><code>time</code></dt><dd><p><code>[numeric]</code>: Time at which measures are made.</p>
</dd>
<dt><code>varNames</code></dt><dd><p><code>[vector(character)]</code>: Names of the variable measured.</p>
</dd>
<dt><code>traj</code></dt><dd><p><code>[array(numeric)]</code>: Contains
the joint variable-trajectories. Each horizontal plan (first
dimension) corresponds to the joint-trajectories of an
individual. Vertical plans (second dimension) refer to the time at which measures
are made. Transversal plans (the third dimension) are for variables.</p>
</dd>
<dt><code>dimTraj</code></dt><dd><p><code>[vector3(numeric)]</code>: size of the array
<code>traj</code> (ie <code>dimTraj=c(length(idFewNA),length(time),length(varNames))</code>).</p>
</dd>
<dt><code>maxNA</code></dt><dd><p><code>[numeric]</code> or <code>[vector(numeric)]</code>:
Individual whose trajectories contain 'too many' missing value
are exclude from <code>traj</code> and will no be use in
the analysis. Their identifier is preserved in <code>idAll</code> but
not in <code>idFewNA</code>. 'too many' is define by <code>maxNA</code>: a
trajectory with more missing than <code>maxNA</code> is exclude.
When <code>maxNA</code> is a single number, it is
recycled for all the variables.</p>
</dd>
<dt><code>reverse</code></dt><dd><p><code>[matrix(numeric)]</code>: if the trajectories
are scale using the function <code><a href="#topic+scale">scale</a></code>, the 'scaling
parameters' (probably mean and standard deviation) are saved in
<code>reverse</code>. This is usefull to restore the original data after a
scaling operation.</p>
</dd>
</dl>



<h3>Construction</h3>

<p><code>LongData3d</code> can be created by calling
the fonction <code><a href="#topic+longData3d">longData3d</a></code> on a <code>data.frame</code> or on an <code>array</code>.
</p>


<h3>Get [</h3>


<dl>
<dt>Object[&quot;idAll&quot;]</dt><dd><p>[vecteur(character)]: Gets the full list of individual
identifiant (the value of the slot <code>idAll</code>)</p>
</dd>
<dt>Object[&quot;idFewNA&quot;]</dt><dd><p>[vecteur(character)]: Gets the list of individual
identifiant with not too many missing values (the value of the slot <code>idFewNA</code>)</p>
</dd>
<dt>Object[&quot;varNames&quot;]</dt><dd><p>[character]: Gets the name(s) of the variable (the value of the slot <code>varNames</code>)</p>
</dd>
<dt>Object[&quot;time&quot;]</dt><dd><p>[vecteur(numeric)]: Gets the times (the value of the slot <code>time</code>)</p>
</dd>
<dt>Object[&quot;traj&quot;]</dt><dd><p>[array(numeric)]: Gets all the joint trajectories (the value of the slot <code>traj</code>)</p>
</dd>
<dt>Object[&quot;dimTraj&quot;]</dt><dd><p>[vector3(numeric)]: Gets the dimension of <code>traj</code>.</p>
</dd>
<dt>Object[&quot;nbIdFewNA&quot;]</dt><dd><p>[numeric]: Gets the first dimension of
<code>traj</code> (ie the number of individual include in the analysis).</p>
</dd>
<dt>Object[&quot;nbTime&quot;]</dt><dd><p>[numeric]: Gets the second dimension of
<code>traj</code> (ie the number of time measurement).</p>
</dd>
<dt>Object[&quot;nbVar&quot;]</dt><dd><p>[numeric]: Gets the third dimension of
<code>traj</code> (ie the number of variables).</p>
</dd>
<dt>Object[&quot;maxNA&quot;]</dt><dd><p>[vecteur(numeric)]: Gets maxNA.</p>
</dd>
<dt>Object[&quot;reverse&quot;]</dt><dd><p>[matrix(numeric)]: Gets the matrix of the
scaling parameters.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code><a href="#topic+scale">scale</a></code></dt><dd><p>scale the trajectories. Usefull to
normalize variable trajectories measured with different units.</p>
</dd>
<dt><code><a href="#topic+restoreRealData">restoreRealData</a></code></dt><dd><p>restore original data that
have been modified after a scaling operation.</p>
</dd>


<dt><code><a href="#topic+longDataFrom3d">longDataFrom3d</a></code></dt><dd><p>Create a
<code><a href="#topic+LongData-class">LongData</a></code> by extracting a single variable trajectory
form a dataset of joint variable-trajectories.</p>
</dd>
<dt><code>plotTrajMeans</code></dt><dd><p>plot all the variable of the <code>LongData3d</code>, optionnaly according to a <code><a href="#topic+Partition-class">Partition</a></code>.</p>
</dd>
<dt><code>plotTrajMeans3d</code></dt><dd><p>plot two variables of the <code>LongData3d</code> in
a 3 dimensions graph, optionnaly according to a <code><a href="#topic+Partition-class">Partition</a></code>.</p>
</dd>
<dt><code>plot3dPdf</code></dt><dd><p>create 'Triangle objects' representing in
3D the cluster's center according to a
<code><a href="#topic+Partition-class">Partition</a></code>. 'Triangle object' can latter be
include in a LaTeX file to get a dynamique (rotationg) pdf
figure.</p>
</dd>
<dt><code>imputation</code></dt><dd><p>Impute the missing values of the trajectories.</p>
</dd>
<dt><code>qualityCriterion</code></dt><dd><p>Compute some quality criterion that
can be use to compare the quality of differents <code><a href="#topic+Partition-class">Partition</a></code>.</p>
</dd>
</dl>



<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p>Overview: <code><a href="#topic+longitudinalData-package">longitudinalData-package</a></code> <br />
Methods: <code><a href="#topic+LongData-class">LongData</a></code>,  <code><a href="#topic+longData3d">longData3d</a></code>, <code><a href="#topic+imputation">imputation</a></code>, <code><a href="#topic+qualityCriterion">qualityCriterion</a></code><br />
Plot: <code><a href="#topic+plotTrajMeans">plotTrajMeans</a></code>,
<code><a href="#topic+plotTrajMeans3d">plotTrajMeans3d</a></code>,  <code><a href="#topic+plot3dPdf">plot3dPdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################
### building joint trajectories

dn &lt;- data.frame(id=1:3,v1=c(11,14,16),t1=c(1,5,7),v2=c(12,10,13),t2=c(2,5,0),t3=c(3,6,8))
(ld &lt;- longData3d(dn,timeInData=list(Vir=c(2,4,NA),Tes=c(3,5,6))))

### Scaling
scale(ld)
(ld)

### Plotting
plotTrajMeans3d(ld)
restoreRealData(ld)
</code></pre>

<hr>
<h2 id='longDataFrom3d'> ~ Function: longDataFrom3d ~</h2><span id='topic+longDataFrom3d'></span>

<h3>Description</h3>

<p>Extract a single variable-trajectory from an object
<code><a href="#topic+LongData-class">LongData</a></code> that contain some joint-trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longDataFrom3d(xLongData3d,variable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longDataFrom3d_+3A_xlongdata3d">xLongData3d</code></td>
<td>
<p><code>[LongData3d]</code>: structure containning some joint-trajectories.</p>
</td></tr>
<tr><td><code id="longDataFrom3d_+3A_variable">variable</code></td>
<td>
<p><code>[character]</code>: either the name of one of the
variable of <code>xLongData3d</code>, or its number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract a single variable-trajectory from an object
<code><a href="#topic+LongData3d-class">LongData3d</a></code> that contain some join-trajectories.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+LongData-class">LongData</a></code>.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p><a href="#topic+LongData-class">LongData</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>### Creation of joint-trajectories
mat &lt;- array(c(1,NA,3,2,3,6,1,8,10,1,NA,1,2,NA,3,2,3,2),dim=c(3,3,2))
(ldJoint &lt;- longData3d(mat,varNames=c("Hyp","Som")))

### Extraction of the first variable-trajectory
(ldHyp &lt;- longDataFrom3d(ldJoint,variable="Hyp"))

### Extraction of the second variable-trajectory
(ldSom &lt;- longDataFrom3d(ldJoint,variable="Som"))

### Extraction of the second variable-trajectory, using number
(ldSom &lt;- longDataFrom3d(ldJoint,variable=2))
</code></pre>

<hr>
<h2 id='longDataTo3d'> ~ Function: longDataTo3d ~</h2><span id='topic+longDataTo3d'></span>

<h3>Description</h3>

<p>Build a object <code><a href="#topic+LongData3d-class">LongData3d</a></code> from an object
<code><a href="#topic+LongData-class">LongData</a></code>. The resulting object has a single
variable-trajectory stored in a array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longDataTo3d(xLongData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longDataTo3d_+3A_xlongdata">xLongData</code></td>
<td>
<p><code>[LongData]</code>: structure containning a variable-trajectory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Build a object <code><a href="#topic+LongData3d-class">LongData3d</a></code> from an object
<code><a href="#topic+LongData-class">LongData</a></code>. The resulting object has a single
variable-trajectory stored in a array.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+LongData3d-class">LongData3d</a></code>.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p><a href="#topic+LongData-class">LongData</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>### Creation of single variable-trajectory
mat &lt;- matrix(c(1,NA,3,2,3,6,1,8,10,1,NA,1,2,NA,3,2,3,2),6,3)
(ldSingle &lt;- longData(mat))

### Extension to joint trajectories
(ldHyp &lt;- longDataTo3d(ldSingle))
</code></pre>

<hr>
<h2 id='makeLatexFile'>
~ Function: makeLatexFile ~
</h2><span id='topic+makeLatexFile'></span>

<h3>Description</h3>

<p>Create a LaTeX document that inclusde 3D objects into PDF documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeLatexFile(filename = "main.tex", asyToInclude = "scene+0.prc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeLatexFile_+3A_filename">filename</code></td>
<td>
<p>Name of the LaTeX file</p>
</td></tr>
<tr><td><code id="makeLatexFile_+3A_asytoinclude">asyToInclude</code></td>
<td>
<p>Name of the file holding the 3D graph to include.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a LaTeX document that inclusde 3D objects into PDF documents with PDF-1.5/1.6 compatibility.
</p>


<h3>Value</h3>

<p>A LaTeX file, in the current directory.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p><a href="misc3d.html#topic+makeTriangles">makeTriangles</a>,<code><a href="#topic+plot3dPdf">plot3dPdf</a></code>, <code><a href="#topic+saveTrianglesAsASY">saveTrianglesAsASY</a>.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### Move to tempdir
  wd &lt;- getwd()
  setwd(tempdir()); getwd()
  
  ### Generating the data
  data(artificialJointLongData)
  myLd &lt;- longData3d(artificialJointLongData,timeInData=list(var1=2:12,var2=13:23))
  part &lt;- partition(rep(1:3,each=50))
  plotTrajMeans3d(myLd,part)

  ### Creation of the scene
  scene &lt;- plot3dPdf(myLd,part)
  drawScene.rgl(scene)

  ### Export in '.asy' file
  saveTrianglesAsASY(scene)

  ### Creation of a '.prc' file
  # Open a console, then run:
  # 'asy -inlineimage -tex pdflatex scene.asy'

  ### Creation of the LaTeX main document
  makeLatexFile()

  ### Creation of the '.pdf'
  # Open a console window, then run
  # pdfLatex main.tex
  
  ### Go back to current dir
  setwd(wd)
</code></pre>

<hr>
<h2 id='ordered+28ListPartition+29'>
~ Function: ordered(ListPartition) ~
</h2><span id='topic+ordered'></span><span id='topic+ordered+2CListPartition'></span><span id='topic+ordered+2CListPartition-method'></span>

<h3>Description</h3>

<p>Sort the <code><a href="#topic+Partition-class">Partition</a></code> of a
<code><a href="#topic+ListPartition-class">ListPartition</a></code> according to a quality criterion.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordered(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordered+2B28ListPartition+2B29_+3A_x">x</code></td>
<td>
<p>[ListPartition]: Object whose <code>Partition</code> should be sort.</p>
</td></tr>
<tr><td><code id="ordered+2B28ListPartition+2B29_+3A_...">...</code></td>
<td>
<p>Note used, for S4 compatibility only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sort the <code>Partition</code> of a <code>ListPartition</code> for each
list (sort the 'c2' list, the 'c3' list,...) according to a quality criterion.
The criterion used to sort is the one in the field
<code>criterionActif</code>.
</p>


<h3>Value</h3>

<p>This function change internaly the order of the fields <code>c2</code>,
<code>c3</code>, ... <code>c26</code> of an object. In addition, it return the
permutation matrix (the matrix use to re-ordered the <code>ci</code>).
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] Christophe M. Genolini and Bruno Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] Christophe M. Genolini and Bruno Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############
### Preparing data
data(artificialLongData)
traj &lt;- as.matrix(artificialLongData[,-1])

### Some clustering
part2 &lt;- partition(rep(c("A","B"),time=100),traj)
part3 &lt;- partition(rep(c("A","B","C","A"),time=50),traj)
part3b &lt;- partition(rep(c("A","B","C","B"),time=50),traj)
part4 &lt;- partition(rep(c("A","B","C","D"),time=50),traj)


################
### ListPartition
listPart &lt;- listPartition()
listPart['criterionActif'] &lt;-"Davies.Bouldin"
plotCriterion(listPart)

listPart["add"] &lt;- part2
listPart["add"] &lt;- part3
listPart["add"] &lt;- part3b
listPart["add"] &lt;- part4
listPart["add"] &lt;- part4
listPart["add"] &lt;- part3
listPart["add"] &lt;- part3b

plotCriterion(listPart)
ordered(listPart)
plotCriterion(listPart)

listPart['criterionActif'] &lt;-"Calinski.Harabatz"
plotCriterion(listPart)
ordered(listPart)
plotCriterion(listPart)


</code></pre>

<hr>
<h2 id='parLongData'>
~ Function: parLongData, parTraj and parMean~
</h2><span id='topic+parLongData'></span><span id='topic+parTRAJ'></span><span id='topic+parMEAN'></span>

<h3>Description</h3>

<p><code>parLongData</code>, <code>parTraj</code> and <code>parMean</code> are constructors for the class
<code><a href="#topic+ParLongData-class">ParLongData</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parLongData(type, col, pch, pchPeriod, cex, xlab, ylab)
parTRAJ(type = "l", col = "black", pch = "1",
   pchPeriod = 0, cex = 1, xlab = "Time", ylab = "")
parMEAN(type = "b", col = "clusters", pch = "letters",
   pchPeriod = 1, cex = 1.2, xlab = "Time", ylab = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parLongData_+3A_type">type</code></td>
<td>
<p><code>[character]</code>: Set type of the plot should be
drawn ('p' for point, 'l' for line, 'b' for both, 'c' line appart, 'o'
for overplot, 'h' for histogram, 's' and 'S' for steps, 'n' for no
ploting)</p>
</td></tr>
<tr><td><code id="parLongData_+3A_col">col</code></td>
<td>
<p><code>[character]</code>: Set the plotting color. Vector of
values are accepted. The special value 'clusters' can be use to color
each trajectories according to its clusters (see details).</p>
</td></tr>
<tr><td><code id="parLongData_+3A_pch">pch</code></td>
<td>
<p><code>[numeric]</code> or <code>[character]</code>: Either an integer
specifying a symbol or special values 'letters' or 'symbol' (see details).</p>
</td></tr>
<tr><td><code id="parLongData_+3A_pchperiod">pchPeriod</code></td>
<td>
<p><code>[numeric]</code>: Fix the number of point that should be plot. Usefull to
plot points on trajectories with a lot of mesurement (see examples
in <code><a href="#topic+plotTrajMeans">plotTrajMeans</a></code> for <code>LongData</code> for details).</p>
</td></tr>
<tr><td><code id="parLongData_+3A_cex">cex</code></td>
<td>
<p><code>[numeric]</code>: Set the
amount by which plotting text and symbols should be magnified relative
to the default.</p>
</td></tr>
<tr><td><code id="parLongData_+3A_xlab">xlab</code></td>
<td>
<p><code>[character]</code>: Title for the x axis.</p>
</td></tr>
<tr><td><code id="parLongData_+3A_ylab">ylab</code></td>
<td>
<p><code>[character]</code>: Title for the y axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>parLongData</code> is the basic constructor of the class
<code><a href="#topic+ParLongData-class">ParLongData</a></code>.
</p>
<p><code>parTRAJ</code> create an object with default values for ploting
individual trajectories ;
</p>
<p><code>parMEAN</code> create an object with default values for ploting mean trajectories.
</p>
<p>If col='clusters', pch='letters' or pch='symbol', the object can not be use directly, it
should first be prepared using the function <a href="#topic+expandParLongData">expandParLongData</a>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ParLongData-class">ParLongData</a></code>
</p>


<h3>Author(s)</h3>

<p>Christophe Genolini<br />
PSIGIAM: Paris Sud Innovation Group in Adolescent Mental Health<br />
INSERM U669 / Maison de Solenn / Paris<br /><br />
</p>
<p>Contact author : &lt;genolini@u-paris10.fr&gt;
</p>


<h3>English translation</h3>

<p>Raphaël Ricaud<br />
Laboratoire &quot;Sport &amp; Culture&quot; / &quot;Sports &amp; Culture&quot; Laboratory <br />
University of Paris 10 / Nanterre
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
### Construction of LongData

time=c(1,2,3,4,8,12,16,20)
id2=1:120
f &lt;- function(id,t)((id-1)%%3-1) * t
g &lt;- function(id,t)(id%%2+1)*t
ld2 &lt;- longData3d(
   array(cbind(outer(id2,time,f),outer(id2,time,g))+rnorm(120*8*2,0,3),
   dim=c(120,8,2)))

### Example with default value
plotTrajMeans3d(ld2)
plotTrajMeans3d(ld2,parTraj=parTRAJ())

### Example with default value except for the color
plotTrajMeans3d(ld2,parTraj=parTRAJ(col="blue"))
</code></pre>

<hr>
<h2 id='ParLongData-class'>~ Class: ParLongData ~</h2><span id='topic+ParLongData'></span><span id='topic+ParLongData-class'></span><span id='topic++5B+2CParLongData-method'></span><span id='topic++5B+3C-+2CParLongData-method'></span>

<h3>Description</h3>

<p><code>ParLongData</code> is an objet containing some graphical
parameter used to plot <code><a href="#topic+LongData-class">LongData</a></code> object and / or mean trajectories. They work as
define in <code>par</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p><code>[character]</code>: Type of the plot that should be
drawn ('p' for point, 'l' for line, 'b' for both, 'c' line appart, 'o'
for overplot, 'h' for histogram, 's' and 'S' for steps, 'n' for no
ploting)</p>
</dd>
<dt><code>col</code></dt><dd><p><code>[character]</code>: A specification for the
default plotting color. Can be either a single value or a vector.</p>
</dd>
<dt><code>pch</code></dt><dd><p><code>[numeric]</code> or <code>[character]</code>: Either an integer
specifying a symbol or a single character to be used as the default in plotting
points.  See example in <a href="graphics.html#topic+points">points</a> for possible values and their
interpretation.</p>
</dd>
<dt><code>pchPeriod</code></dt><dd><p><code>[numeric]</code>: Fix the number of point that should be plot. Usefull to
plot points on trajectories with a lot of mesurement (see examples
in <code><a href="#topic+plotTrajMeans">plotTrajMeans</a></code> for <code>LongData</code> for details).</p>
</dd>
<dt><code>cex</code></dt><dd><p><code>[numeric]</code>: A numerical value giving the
amount by which plotting text and symbols should be magnified relative
to the default.</p>
</dd>
<dt><code>xlab</code></dt><dd><p><code>[character]</code>: A title for the x axis.</p>
</dd>
<dt><code>ylab</code></dt><dd><p><code>[character]</code>: A title for the y axis.</p>
</dd>
</dl>



<h3>Construction</h3>

<p>Object <code>ParLongData</code> can be created by three functions:
</p>

<ol>
<li> <p><code>parLongData</code> create an object from scratch ;
</p>
</li>
<li> <p><code>parTraj</code> create an object containing default value to plot
individutal trajectories;
</p>
</li>
<li> <p><code>parMean</code> create an object containing default value to
plot mean trajectories.
</p>
</li></ol>



<h3>Methods</h3>


<dl>
<dt><code>object['xxx']</code></dt><dd><p>Get the value of the field <code>xxx</code>.</p>
</dd>
<dt><code>object['xxx']&lt;-value</code></dt><dd><p>Set the field <code>xxx</code> to <code>value</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Christophe Genolini<br />
PSIGIAM: Paris Sud Innovation Group in Adolescent Mental Health<br />
INSERM U669 / Maison de Solenn / Paris<br /><br />
</p>
<p>Contact author : &lt;genolini@u-paris10.fr&gt;
</p>


<h3>English translation</h3>

<p>Raphaël Ricaud<br />
Laboratoire &quot;Sport &amp; Culture&quot; / &quot;Sports &amp; Culture&quot; Laboratory <br />
University of Paris 10 / Nanterre
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ### Building ParLongData
   parMyData &lt;- parLongData(type="n",col=3,pch="1",pchPeriod=20,cex=1,xlab="Time",ylab="Size")

   ### Get
   parMyData['col']

   ### Set
   parMyData['cex'] &lt;- 3
   (parMyData)
</code></pre>

<hr>
<h2 id='partition'> ~ Function: partition ~ </h2><span id='topic+partition'></span><span id='topic+partition+2CANY+2Cmissing+2CANY-method'></span><span id='topic+partition+2CANY+2Carray+2CANY-method'></span><span id='topic+partition+2CANY+2Cmatrix+2CANY-method'></span><span id='topic+partition+2CANY+2CLongData+2CANY-method'></span><span id='topic+partition+2CANY+2CLongData3d+2CANY-method'></span><span id='topic+partition+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>partition</code> is the constructor of the class
<code><a href="#topic+Partition-class">Partition</a></code>. It can be build either alone or
relatively to a object <code>LongData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(clusters, traj, details=character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_+3A_clusters">clusters</code></td>
<td>
<p><code>[vector(factor)]</code>: cluters to which each
individual belongs. Each clusters is represented by an upper letters.</p>
</td></tr>
<tr><td><code id="partition_+3A_traj">traj</code></td>
<td>
<p><code>[matrix]</code> or <code>[array]</code>: if an object <code>LongData</code> is
provide, it will be used to compute the quality criterion of the
clustering. <code>array</code> are simply turn into matrix by &quot;sticking&quot;
all the variables one behind the other.</p>
</td></tr>
<tr><td><code id="partition_+3A_details">details</code></td>
<td>
<p><code>[vector(character)]</code>: the slot <code>details</code> is
used to store various informations. If the <code>Partition</code> has been
find using an algorithm, it can store the name of the algorithm, the
time before convergence, the number of iteration and any other
informations. The syntaxe is <code>details=c(algoritm="kmeans",convergenceTime="6",otherInfo="WhateverIWant")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>partition</code> construct a object of class
<code><a href="#topic+Partition-class">Partition</a></code>. It does not provide any default
values. <code>yLongData</code> and <code>details</code> are optional.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+Partition-class">Partition</a></code>.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSM, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] Christophe M. Genolini and Bruno Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] Christophe M. Genolini and Bruno Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011
</p>


<h3>See Also</h3>

<p><a href="#topic+Partition-class">Partition</a>,<code><a href="#topic+ordered">ordered</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### Empty partition
partition()

### Small partition
partition(clusters=c("A","B","A","C","C"))

### Random partition
partition(clusters=LETTERS[floor(runif(100,1,5))])

### Partition that clusters correctly some data
###   Quality criterion are high
data(artificialLongData)
traj &lt;- as.matrix(artificialLongData[,-1])
partition(clusters=rep(1:4,each=50),traj)

### Partition that does not cluster correctly the data
###   Quality criterion are low
partition(clusters=rep(1:4,50),traj)
</code></pre>

<hr>
<h2 id='Partition-class'>~ Class: Partition ~</h2><span id='topic+Partition-class'></span><span id='topic++5B+2CPartition-method'></span><span id='topic++5B+3C-+2CPartition-method'></span><span id='topic+show+2CPartition-method'></span><span id='topic+is.na+2CPartition-method'></span>

<h3>Description</h3>

<p>An object of class <code>Partition</code> is a partition of a population
into subgroups. The object also contains some information like the
percentage of trajectories in each group or some qualities criterion.
</p>


<h3>Objects from the Class</h3>

<p>Objects are mainly intend to be created by some clustering methods
(like k-means, fuzzy k-means, mixture modeling, latent class
analysis,...)
</p>


<h3>Slots</h3>


<dl>
<dt><code>nbClusters</code></dt><dd><p>[numeric]: number of groups, between 1 and 26</p>
</dd>
<dt><code>clusters</code></dt><dd><p>[vector(factor)]: vector containing the
groups of each individual. Groups are in upper-case
letters.</p>
</dd>
<dt><code>percentEachCluster</code></dt><dd><p>[vector(numeric)]: percentage of
trajectories contained in each group.</p>
</dd>
<dt><code>postProba</code></dt><dd><p>[matrix(numeric)]: assuming that in
each clusters C and for each time T, variable follow a normal law
(mean and standard deviation of the variable at time T restricted
to clusters C), then it is possible to compute the postterior
probabilities of each individual (that is the probabilities that
an individual has to belong to each clusters). These probabilities
are hold in postProba.</p>
</dd>
<dt><code>postProbaEachCluster</code></dt><dd><p>[vector(numeric)]: for each
clusters C, mean of the post probabilities to belong to C of the
individual that effectively belong to C. A high percent means that
the individual that are in this cluter realy meant to be here.</p>
</dd>
<dt><code>criterionValues</code></dt><dd><p>[vector(numeric)]: Value of the quality
criterions used to evaluate the quality of the
<code>Clustering</code>. See <code><a href="#topic+qualityCriterion">qualityCriterion</a></code> for details.</p>
</dd>
<dt><code>details</code></dt><dd><p>[vector(character)]: hold different optionnal informations like
the algorithm (if any) used to find the partition, the convergence
time, the imputation methods, the starting condition.
Examples:
<code>details=c(algorithm="kmeans",convergenceTime="3")</code>.</p>
</dd>
</dl>



<h3>validation rules</h3>

<p>A class <code>Partition</code> object must follow some rules to be valid:
</p>

<ul>
<li><p> Slots should be either all empty, or all non empty.
</p>
</li>
<li> <p><code>nbClusters</code> has to be lower or equal to 26.
</p>
</li>
<li> <p><code>clusters</code> is a factor in <code>LETTERS[1:nbCluster]</code>.
</p>
</li></ul>



<h3>Construction</h3>

<p>Class <code>Partition</code> objects are mainly constructed by some clustering methods
(like k-means, fuzzy k-means, mixture modeling, latent class
analysis,...). Neverdeless, it is also possible to construct them from
scratch using the fonction <code><a href="#topic+partition">partition</a></code>.
</p>


<h3>Get [</h3>


<dl>
<dt>Object[&quot;nbClusters&quot;]</dt><dd><p>[numeric]: Gets the number of clusters
(the value of the slot <code>nbClusters</code>)</p>
</dd>
<dt>Object[&quot;clusters&quot;]</dt><dd><p>[vector(factor)]: Gets the cluster of each
individual (the value of the slot <code>clusters</code>)</p>
</dd>
<dt>Object[&quot;clustersAsInteger&quot;]</dt><dd><p><code>[vector(integer)]</code>: Gets the
cluster of each individual and turn them into integer</p>
</dd>
<dt>Object[&quot;percentEachClusters&quot;]</dt><dd><p><code>[vector(numeric)]</code>: Get the
percent of individual
in each clusters (the value of the slot <code>nbClusters</code>)</p>
</dd>
<dt>Object[&quot;postProbaEachClusters&quot;]</dt><dd><p><code>[vector(numeric)]</code>: Get the
post probabilities for each clusters.</p>
</dd>
<dt>Object[&quot;postProba&quot;]</dt><dd><p><code>[matrix(numeric)]</code>: Get the
post probabilities for each individual and each clusters.</p>
</dd>
<dt>Object[&quot;criterionValues&quot;]</dt><dd><p><code>[vector(numeric)]</code>: gives the values
of all the
criterion values (the value of the slot <code>criterionValues</code>)</p>
</dd>
<dt>Object[&quot;details&quot;]</dt><dd><p><code>[vector(character)]</code>: Get the values
of the slot <code>details</code>.</p>
</dd>
<dt>Object[&quot;XcriterionX&quot;]</dt><dd><p><code>[numeric]</code>: Get the value of the criterion
<code>XcriterionX</code>. It can be one of <code>Calinski.Harabatz</code>,
<code>Krzysztof.Calinski</code>, <code>Genolini.Calinski</code>, <code>Ray.Turi</code>,
<code>Davies.Bouldin</code>, <code>BIC</code>, <code>AIC</code>, <code>AICc</code> or <code>random</code>.</p>
</dd>
<dt>Object[&quot;XspecialX&quot;]</dt><dd><p><code>[character]</code>: Get the value named
<code>XspecialX</code> in
the slot <code>details</code> (probably one of <code>multiplicity</code>,
<code>convergenceTime</code>, <code>imputationMethod</code> or
<code>algorithm</code>.)</p>
</dd>
</dl>



<h3>Setteur [&lt;-</h3>


<dl>
<dt>Object[&quot;multiplicity&quot;]&lt;-value</dt><dd><p>[numeric]: In the slot
<code>details</code>, sets the values names <code>multiplicity</code> to <code>value</code>.</p>
</dd>
<dt>Object[&quot;convergenceTime&quot;]&lt;-value</dt><dd><p>[numeric]: In the slot
<code>details</code>, sets the values names <code>convergenceTime</code> to <code>value</code>.</p>
</dd>
</dl>

<p>The others slot can not be change after the object creation.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p>Overview: <code><a href="#topic+longitudinalData-package">longitudinalData-package</a></code> <br />
Classes: <code><a href="#topic+LongData-class">LongData</a></code> <br />
Methods: <code><a href="#topic+partition">partition</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
### Building Partition

### number
part &lt;- partition(rep(c(1,2,1,3),time=3))

### LETTERS
part &lt;- partition(rep(c("A","B","D"),time=4),details=c(convergenceTime="3",multiplicity="1"))

### Others don't work
try(partition(rep(c("A","Bb","C"),time=3)))

#############
### Setteur and Getteur

### '['
part["clusters"]
part["clustersAsInteger"]
part["nbClusters"]

### '[&lt;-'
part["multiplicity"] &lt;- 2
(part)
</code></pre>

<hr>
<h2 id='parWindows'>
~ Function: parWindows ~
</h2><span id='topic+parWindows'></span>

<h3>Description</h3>

<p><code>parWindows</code> is the constructor of object <code><a href="#topic+ParWindows-class">ParWindows</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parWindows(nbRow, nbCol, addLegend,closeScreen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parWindows_+3A_nbrow">nbRow</code></td>
<td>
<p><code>[numeric]</code>: Number of row of the screen matrix.</p>
</td></tr>
<tr><td><code id="parWindows_+3A_nbcol">nbCol</code></td>
<td>
<p><code>[numeric]</code>: Number of column of the screen matrix.</p>
</td></tr>
<tr><td><code id="parWindows_+3A_addlegend">addLegend</code></td>
<td>
<p><code>[logical]</code>: Shall a legend be added on the graph?</p>
</td></tr>
<tr><td><code id="parWindows_+3A_closescreen">closeScreen</code></td>
<td>
<p><code>[logical]</code>: Some function need to add details on a graph. This option let
them call a plot function that will not call a <code>close.screen</code>
on exit, so the graph will be modifiable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>parWindows</code> is the constructor of object <code><a href="#topic+ParWindows-class">ParWindows</a></code>.
Given a number of rows and colonnes, it computes the <code>screenMatrix</code> that
is use by <a href="graphics.html#topic+split.screen">split.screen</a> for plot object
<code><a href="#topic+LongData-class">LongData</a></code>. If <code>addLegend</code> is true, an
extra space is added on the top of the graphes to print the legend.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ParWindows-class">ParWindows</a></code>.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Building ParWindows
(paramWin &lt;- parWindows(3,2,FALSE,TRUE))

### Get
figsScreen &lt;- paramWin['screenMatrix']

### Usage
listScreen &lt;- split.screen(figsScreen)
screen(listScreen[1])
plot(-5:5/10,2.5-(-5:5)^2/20,ylim=c(0,6),axes=FALSE,xlab="",ylab="",type="l",lwd=3)
lines(-5:5/10,(-5:5)^2/20,ylim=c(0,6),type="l",lwd=3)

screen(listScreen[3])
plot(-5:5/10,2.5-(-5:5)^2/20,ylim=c(0,6),axes=FALSE,xlab="",ylab="",type="l",lwd=3)
lines(-5:5/10,(-5:5)^2/20,ylim=c(0,6),type="l",lwd=3)

screen(listScreen[5])
plot(-5:5/10,(-5:5)^2/10,ylim=c(0,6),axes=FALSE,xlab="",ylab="",type="l",lwd=3)
lines(-5:5/10,(-5:5)^2/20+1.25,ylim=c(0,6),type="l",lwd=3)
close.screen(all.screens=TRUE)

### :-)
</code></pre>

<hr>
<h2 id='ParWindows-class'>~ Class: ParWindows ~</h2><span id='topic+ParWindows'></span><span id='topic+ParWindows-class'></span><span id='topic++5B+2CParWindows-method'></span><span id='topic++5B+3C-+2CParWindows-method'></span>

<h3>Description</h3>

<p><code>ParWindows</code> is an objet containing graphical
parameter used to set the screen display.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nbCol</code></dt><dd><p><code>[numeric]</code>: Number of column of the screen
matrix.</p>
</dd>
<dt><code>nbRow</code></dt><dd><p><code>[numeric]</code>: Number of row of the screen
matrix.</p>
</dd>
<dt><code>addLegend</code></dt><dd><p><code>[logical]</code>: Shall a legend be added on
the graph?</p>
</dd>
<dt><code>closeScreen</code></dt><dd><p><code>[logical]</code>: On exit, high level plot
function can either close the screen that they open and return
nothing ; or not close it and return the list of the screen number.</p>
</dd>
<dt><code>screenMatrix</code></dt><dd><p><code>[matrix(numeric)]</code>: Matrix with 4
column defining the screen region, like the <code>figs</code> argument
of the function <a href="graphics.html#topic+screen">screen</a>. The <code>screenMatrix</code> can be specified
by the user (bad idea) or can be compute automaticaly according to
<code>nbCol</code>, <code>nbRow</code> and <code>addLegend</code>. For that, use
<a href="#topic+windowsCut">windowsCut</a>.</p>
</dd>
</dl>



<h3>Construction</h3>

<p>Object <code>ParWindows</code> can be created by the constructor
<code><a href="#topic+parWindows">parWindows</a></code> or by the function <code><a href="#topic+windowsCut">windowsCut</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>object['xxx']</code></dt><dd><p>Get the value of the field <code>xxx</code>.</p>
</dd>
<dt><code>object['xxx']&lt;-value</code></dt><dd><p>Set the field <code>xxx</code> to value.</p>
</dd>
</dl>



<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Building ParWindows
(paramWin &lt;- parWindows(3,2,FALSE,TRUE))

### Get
figsScreen &lt;- paramWin['screenMatrix']

### Usage
listScreen &lt;- split.screen(figsScreen)
screen(listScreen[1])
plot(-5:5/10,2.5-(-5:5)^2/20,ylim=c(0,6),axes=FALSE,xlab="",ylab="",type="l",lwd=3)
lines(-5:5/10,(-5:5)^2/20,ylim=c(0,6),type="l",lwd=3)

screen(listScreen[3])
plot(-5:5/10,2.5-(-5:5)^2/20,ylim=c(0,6),axes=FALSE,xlab="",ylab="",type="l",lwd=3)
lines(-5:5/10,(-5:5)^2/20,ylim=c(0,6),type="l",lwd=3)

screen(listScreen[5])
plot(-5:5/10,(-5:5)^2/10,ylim=c(0,6),axes=FALSE,xlab="",ylab="",type="l",lwd=3)
lines(-5:5/10,(-5:5)^2/20+1.25,ylim=c(0,6),type="l",lwd=3)
close.screen(all.screens=TRUE)

### Sorry for that...
</code></pre>

<hr>
<h2 id='plot3dPdf'>
~ Function: plot3dPdf for LongData ~
</h2><span id='topic+plot3dPdf'></span><span id='topic+plot3dPdf+2CLongData3d-method'></span><span id='topic+plot3dPdf+2CLongData3d+2Cmissing-method'></span><span id='topic+plot3dPdf+2CLongData3d+2Cnumeric-method'></span><span id='topic+plot3dPdf+2CLongData3d+2CPartition-method'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+LongData-class">LongData</a></code> and a <code><a href="#topic+Partition-class">Partition</a></code>, this
function create 'Triangle objects' representing the 3D plot the
clusters centers. Triangle object can latter be used to include
dynamic rotating graph in a pdf file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LongData3d,missing'
plot3dPdf(x,y,varY=1,varZ=2)
## S4 method for signature 'LongData3d,numeric'
plot3dPdf(x,y,varY=1,varZ=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3dPdf_+3A_x">x</code></td>
<td>
<p><code>[LongData]</code>: Object containing the trajectories to plot.</p>
</td></tr>
<tr><td><code id="plot3dPdf_+3A_y">y</code></td>
<td>
<p><code>[numeric]</code>: <code>Partition</code> that will be use to plot
the object.</p>
</td></tr>
<tr><td><code id="plot3dPdf_+3A_vary">varY</code></td>
<td>
<p><code>[numeric]</code> or <code>[character]</code>: either the
number or the name of the first variable to display. 1 by default.</p>
</td></tr>
<tr><td><code id="plot3dPdf_+3A_varz">varZ</code></td>
<td>
<p><code>[numeric]</code> or <code>[character]</code>: either the
number or the name of the second variable to display. 2 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create Triangle objects representing the 3D plot of the main
trajectories of a <code><a href="#topic+LongData-class">LongData</a></code>.
</p>
<p>The three functions <code><a href="#topic+plot3dPdf">plot3dPdf</a></code>, <code><a href="#topic+saveTrianglesAsASY">saveTrianglesAsASY</a></code> and <code><a href="#topic+makeLatexFile">makeLatexFile</a></code>
are design to export a 3D graph to a Pdf file. The process is the following:
</p>

<ol>
<li> <p><code><a href="#topic+plot3dPdf">plot3dPdf</a></code>: Create a scene, that is a collection of Triangle object that
represent a 3D images.
</p>
</li>
<li> <p><code><a href="#topic+saveTrianglesAsASY">saveTrianglesAsASY</a></code>: Export the scene in an '.asy' file.
</p>
</li>
<li><p> '.asy' can not be include in LaTeX file. LaTeX can read only
'.pre' file. So the next step is to use the software
<code>asymptote</code> to convert '.asy' to '.pre'. This is done by the command <code>asy -inlineimage -tex pdflatex
      scene.asy</code> (not in R, in a console).
</p>
</li>
<li><p> The previous step did produce a file <code>scene+0.prc</code> that can be include in a LaTeX file.
<code><a href="#topic+makeLatexFile">makeLatexFile</a></code> create a LaTeX file that is directly compilable (using <code>pdfLatex</code>).
It produce a pdf file that contain the 3D object.
</p>
</li></ol>



<h3>Value</h3>

<p>A Triangle object.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saveTrianglesAsASY">saveTrianglesAsASY</a></code>,<code><a href="#topic+makeLatexFile">makeLatexFile</a></code>,<code><a href="misc3d.html#topic+makeTriangles">makeTriangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### Move to tempdir
  wd &lt;- getwd()
  setwd(tempdir()); getwd()
  
  ### Generating the data
  data(artificialJointLongData)
  myLd &lt;- longData3d(artificialJointLongData,timeInData=list(var1=2:12,var2=13:23))
  part &lt;- partition(rep(1:3,each=50))
  plotTrajMeans3d(myLd,part)

  ### Creation of the scene
  scene &lt;- plot3dPdf(myLd,part)
  drawScene.rgl(scene)

  ### Export in '.asy' file
  saveTrianglesAsASY(scene)

  ### Creation of a '.prc' file
  # Open a console, then run:
  # 'asy -inlineimage -tex pdflatex scene.asy'

  ### Creation of the LaTeX main document
  makeLatexFile()

  ### Creation of the '.pdf'
  # Open a console window, then run
  # pdfLatex main.tex
  
  ### Go back to current dir
  setwd(wd)
</code></pre>

<hr>
<h2 id='plotAllCriterion'>
~ Function: plotAllCriterion ~
</h2><span id='topic+plotAllCriterion'></span><span id='topic+plotAllCriterion-method'></span><span id='topic+plotAllCriterion+2CListPartition'></span><span id='topic+plotAllCriterion+2CListPartition-method'></span>

<h3>Description</h3>

<p>This function graphically displays the quality criterion of all the
<code><a href="#topic+Partition-class">Partition</a></code> of a <code><a href="#topic+ListPartition-class">ListPartition</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAllCriterion(x, criterion=CRITERION_NAMES[1:5],standardized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAllCriterion_+3A_x">x</code></td>
<td>
<p>[ClusterLongData]: object whose quality criterion should be
displayed.</p>
</td></tr>
<tr><td><code id="plotAllCriterion_+3A_criterion">criterion</code></td>
<td>
<p>[character]: name of the criterion(s) to plot. It can either display all the
value for a single specific criterion or display several criterion,
only the best value for each clusters number and for each criterion.</p>
</td></tr>
<tr><td><code id="plotAllCriterion_+3A_standardized">standardized</code></td>
<td>
<p>[logical]: If <code>standardized=TRUE</code>, all the
criterion will be mapped into [0,1]. This makes them more easely comparable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function display graphically several quality criterion, probably to
decide the best clusters' number.
</p>


<h3>Value</h3>

<p>No value are return. A graph is printed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###############
### Data generation
data(artificialLongData)
traj &lt;- as.matrix(artificialLongData[,-1])

### Some clustering
listPart &lt;- listPartition()
listPart["add"] &lt;- partition(rep(c("A","B"),time=100),traj)
listPart["add"] &lt;- partition(rep(c("A","B","B","B"),time=50),traj)
listPart["add"] &lt;- partition(rep(c("A","B","C","A"),time=50),traj)
listPart["add"] &lt;- partition(rep(c("A","B","C","D"),time=50),traj)
ordered(listPart)

################
### graphical display
plotAllCriterion(listPart)
plotAllCriterion(listPart,criterion=CRITERION_NAMES[1:5],TRUE)
</code></pre>

<hr>
<h2 id='plotCriterion'>
~ Function: plotCriterion ~
</h2><span id='topic+plotCriterion'></span><span id='topic+plotCriterion-method'></span><span id='topic+plotCriterion+2CListPartition'></span><span id='topic+plotCriterion+2CListPartition-method'></span>

<h3>Description</h3>

<p>This function graphically displays the quality criterion of all the
<code><a href="#topic+Partition-class">Partition</a></code> of a <code><a href="#topic+ListPartition-class">ListPartition</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCriterion(x, criterion=x["criterionActif"],nbCriterion=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCriterion_+3A_x">x</code></td>
<td>
<p>[ClusterLongData]: object whose quality criterion should be
displayed.</p>
</td></tr>
<tr><td><code id="plotCriterion_+3A_criterion">criterion</code></td>
<td>
<p>[character]: name of the criterion(s) to plot. It can either display all the
value for a single specific criterion or display several criterion,
only the best value for each clusters number and for each criterion.</p>
</td></tr>
<tr><td><code id="plotCriterion_+3A_nbcriterion">nbCriterion</code></td>
<td>
<p>[numeric]: if there is a big number of
<code>Partition</code>, the graphical display of all of them can be
slow. <code>nbCriterion</code> lets the user limit the number of criteria
that will be taken in account.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function display graphically the quality criterion (probably to
decide the best clusters' number). It can either display all the
criterion ; this is useful to see the consistency of the result : is
the best clusterization obtain several time or only one ? It can also
display only the best result for each clusters number : this helps to
find the local maximum, which is classically used to chose the
&quot;correct&quot; clusters' number.
</p>


<h3>Value</h3>

<p>No value are return. A graph is printed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###############
### Data generation
data(artificialLongData)
traj &lt;- as.matrix(artificialLongData[,-1])

### Some clustering
listPart &lt;- listPartition()
listPart["add"] &lt;- partition(rep(c("A","B"),time=100),traj)
listPart["add"] &lt;- partition(rep(c("A","B","B","B"),time=50),traj)
listPart["add"] &lt;- partition(rep(c("A","B","C","A"),time=50),traj)
listPart["add"] &lt;- partition(rep(c("A","B","C","D"),time=50),traj)
ordered(listPart)

################
### graphical display
plotCriterion(listPart)
plotAllCriterion(listPart,criterion=CRITERION_NAMES[1:5],TRUE)
</code></pre>

<hr>
<h2 id='plotTrajMeans+2CLongData'> ~ Function: plotTrajMeans for LongData ~ </h2><span id='topic+plotTrajMeans'></span><span id='topic+plotTrajMeans+2CLongData'></span><span id='topic+plotTrajMeans+2CLongData-method'></span><span id='topic+plotTrajMeans+2CLongData+2Cmissing-method'></span><span id='topic+plotTrajMeans+2CLongData+2CPartition-method'></span>

<h3>Description</h3>

<p>Plot the <code><a href="#topic+LongData-class">LongData</a></code> or <code><a href="#topic+LongData3d-class">LongData3d</a></code> optionnaly relatively
to a <code><a href="#topic+Partition-class">Partition</a></code>. For joint trajectories, one
graphe for each variable trajectory is displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTrajMeans(x, y, parTraj=parTRAJ(), parMean=parMEAN(),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTrajMeans+2B2CLongData_+3A_x">x</code></td>
<td>
<p><code>[LongData]</code> or <code>[LongData3d]</code>: Object containing the trajectories
to plot.</p>
</td></tr>
<tr><td><code id="plotTrajMeans+2B2CLongData_+3A_y">y</code></td>
<td>
<p><code>[numeric]</code>: <code>Partition</code> that will be use to plot
the object. If <code>y</code> is missing, a
<code>Partition</code> with a single cluster is considered.</p>
</td></tr>
<tr><td><code id="plotTrajMeans+2B2CLongData_+3A_partraj">parTraj</code></td>
<td>
<p><code>[ParLongData]</code>: Set the graphical parameters
used to plot the trajectories. See
<code><a href="#topic+ParLongData-class">ParLongData</a></code> and examples
for details.</p>
</td></tr>
<tr><td><code id="plotTrajMeans+2B2CLongData_+3A_parmean">parMean</code></td>
<td>
<p><code>[ParLongData]</code>: Set the graphical parameters
used to plot the mean trajectories of each clusters
(only when <code>y</code> is non missing). See <code><a href="#topic+ParLongData-class">ParLongData</a></code>
and examples for details.</p>
</td></tr>
<tr><td><code id="plotTrajMeans+2B2CLongData_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot either a <code><a href="#topic+LongData-class">LongData</a></code>,
or each variable of a <code><a href="#topic+LongData3d-class">LongData3d</a></code>
optionnaly according to the <code>Partition</code> define by <code>y</code>.
</p>
<p>Graphical option concerning the individual trajectory (col, type, pch
and xlab) can be change using <code>parTraj</code>.
Graphical option concerning the cluster mean trajectory (col, type, pch,
pchPeriod and cex) can be change using <code>parMean</code>. For more
detail on  <code>parTraj</code> and  <code>parMean</code>, see object of
class <code><a href="#topic+ParLongData-class">ParLongData</a></code>.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSM, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LongData-class">LongData</a></code>, <code><a href="#topic+LongData3d-class">LongData3d</a></code>, <code><a href="#topic+plotTrajMeans3d">plotTrajMeans3d</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
### Construction of the data
data(artificialLongData)
ld &lt;- longData(artificialJointLongData)
part &lt;- partition(rep(1:3,each=50))

### Basic plotting
plotTrajMeans(ld)
plotTrajMeans(ld,part,xlab="Time")


##################
### Changing graphical parameters 'par'

### No letters on the mean trajectories
plotTrajMeans(ld,part,parMean=parMEAN(type="l"))

### Only one letter on the mean trajectories
plotTrajMeans(ld,part,parMean=parMEAN(pchPeriod=Inf))

### Color individual according to its clusters (col="clusters")
plotTrajMeans(ld,part,parTraj=parTRAJ(col="clusters"))

### Mean without individual
plotTrajMeans(ld,part,parTraj=parTRAJ(type="n"))


### No mean trajectories (type="n")
### Color individual according to its clusters (col="clusters")
plotTrajMeans(ld,part,parTraj=parTRAJ(col="clusters"),parMean=parMEAN(type="n"))

### Only few trajectories
plotTrajMeans(ld,part,nbSample=10,parTraj=parTRAJ(col='clusters'),parMean=parMEAN(type="n"))


##################
### single variable trajectory

data(artificialLongData)
ld2 &lt;- longData(artificialLongData)
part2 &lt;- partition(rep(1:4,each=50))
plotTrajMeans(ld2)
plotTrajMeans(ld2,part2)
</code></pre>

<hr>
<h2 id='plotTrajMeans3d+2CLongData'> ~ Function: plotTrajMeans3d for LongData3d ~ </h2><span id='topic+plotTrajMeans3d'></span><span id='topic+plotTrajMeans3d+2CLongData3d'></span><span id='topic+plotTrajMeans3d+2CLongData3d-method'></span><span id='topic+plotTrajMeans3d+2CLongData3d+2CPartition-method'></span><span id='topic+plotTrajMeans3d+2CLongData3d+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot two variables of a <code><a href="#topic+LongData3d-class">LongData3d</a></code> object in 3D, optionnaly
relatively to a <code><a href="#topic+Partition-class">Partition</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTrajMeans3d(x,y,varY=1,varZ=2,
   parTraj=parTRAJ(),parMean=parMEAN(type="n"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTrajMeans3d+2B2CLongData_+3A_x">x</code></td>
<td>
<p><code>[LongData3d]</code>: Object containing the trajectories to plot.</p>
</td></tr>
<tr><td><code id="plotTrajMeans3d+2B2CLongData_+3A_y">y</code></td>
<td>
<p><code>[Partition]</code>: <code>Partition</code> that will be use to plot
the object. If <code>y</code> is missing, a <code>Partition</code> with a single
clusters is considered.</p>
</td></tr>
<tr><td><code id="plotTrajMeans3d+2B2CLongData_+3A_vary">varY</code></td>
<td>
<p><code>[numeric]</code> or <code>[character]</code>: either the
number or the name of the first variable to display. 1 by default.</p>
</td></tr>
<tr><td><code id="plotTrajMeans3d+2B2CLongData_+3A_varz">varZ</code></td>
<td>
<p><code>[numeric]</code> or <code>[character]</code>: either the
number or the name of the second variable to display. 2 by default.</p>
</td></tr>
<tr><td><code id="plotTrajMeans3d+2B2CLongData_+3A_partraj">parTraj</code></td>
<td>
<p><code>[parLongData]</code>: Set the graphical parameters
used to plot the trajectories of the <code>LongData3d</code>. See
<code><a href="#topic+ParLongData-class">ParLongData</a></code> and examples for details.</p>
</td></tr>
<tr><td><code id="plotTrajMeans3d+2B2CLongData_+3A_parmean">parMean</code></td>
<td>
<p><code>[parLongData]</code>:  Set the graphical parameters
used to plot the mean trajectories of each clusters <code>LongData3d</code>
(only when <code>y</code> is non missing). See <code><a href="#topic+ParLongData-class">ParLongData</a></code>
and examples for details.</p>
</td></tr>
<tr><td><code id="plotTrajMeans3d+2B2CLongData_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot two variables of a <code><a href="#topic+LongData3d-class">LongData3d</a></code> object in 3D. It
use the <code><a href="rgl.html#topic+rgl">rgl</a></code> library. The user can make the
graphical representation turn using the mouse.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LongData3d-class">LongData3d</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##################
### Construction of the data


time=c(1,2,3,4,8,12,16,20)
id2=1:120
f &lt;- function(id,t)((id-1)%%3-1) * t
g &lt;- function(id,t)(id%%2+1)*t
h &lt;- function(id,t)(id%%4-0.5)*(20-t)
ld &lt;- longData3d(array(cbind(outer(id2,time,f),outer(id2,time,g),outer(id2,time,h))+
   rnorm(120*8*3,0,3),dim=c(120,8,3)))
part &lt;- partition(rep(1:6,20))

### Basic plotting
plotTrajMeans3d(ld)
plotTrajMeans3d(ld,part)

### Variable 1 and 3, then 2 and 3
plotTrajMeans3d(ld,part)
plotTrajMeans3d(ld,part,varY=3,varZ=2)
plotTrajMeans3d(ld,part,varY=1,varZ=3)

##################
### Changing graphical parameters 'par'

### Color individual according to its clusters (col="clusters")
plotTrajMeans3d(ld,part,parTraj=parTRAJ(col="clusters"))
plotTrajMeans3d(ld,part,parTraj=parTRAJ(col="clusters"),varY=1,varZ=3)

### No mean trajectories (type="n"), only few trajectories
### Color individual according to its clusters (col="clusters")
plotTrajMeans3d(ld,part,parTraj=parTRAJ(col="clusters"),parMean=parMEAN(type="n"),nbSample=10)

</code></pre>

<hr>
<h2 id='qualityCriterion'>
~ Function: qualityCriterion ~
</h2><span id='topic+qualityCriterion'></span><span id='topic+qualityCriterion+2Cmatrix+2CANY-method'></span><span id='topic+qualityCriterion+2Carray+2CANY-method'></span><span id='topic+qualityCriterion+2CLongData+2CPartition-method'></span><span id='topic+qualityCriterion+2CLongData3d+2CPartition-method'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+LongData-class">LongData</a></code> and a
<code><a href="#topic+Partition-class">Partition</a></code>, the fonction <code>qualityCriterion</code> calculate
some qualities criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualityCriterion(traj,clusters,imputationMethod="copyMean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qualityCriterion_+3A_traj">traj</code></td>
<td>
<p><code>[LongData]</code> or <code>[matrix]</code>: object containing
the trajectories on which the criterion is calculate.</p>
</td></tr>
<tr><td><code id="qualityCriterion_+3A_clusters">clusters</code></td>
<td>
<p><code>[Paritition]</code> or <code>[vector(integer)]</code>:
clusters to which individual belongs.</p>
</td></tr>
<tr><td><code id="qualityCriterion_+3A_imputationmethod">imputationMethod</code></td>
<td>
<p><code>[character]</code>: if some value are missing in the
<code>LongData</code>, it is necessary to impute them. Then the function
<code>qualityCriterion</code> call the function <code><a href="#topic+imputation">imputation</a></code> using
the method <code>method</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code><a href="#topic+LongData-class">LongData</a></code> and a
<code><a href="#topic+Partition-class">Partition</a></code> (or a <code>matrix</code> and a vector of
<code>integer</code>), the fonction <code>qualityCriterion</code> calculate several
quality criterion and return then as a list (see 'value' below).
</p>
<p>If some individual have no clusters (ie if <code>Partition</code> has some
missing values), the corresponding trajectories are exclude from the
calculation.
</p>
<p>Note that if there is an empty cluster or an empty trajectory, most of
the criterions are anavailable.
</p>
<p>Basicaly, 6 non-parametrics criterions are computed.
In addition, ASSUMING THAT in each clusters C and for each time T,
the variable follow a NORMAL LAW (mean and standard deviation of the variable at time T restricted
to clusters C), it is possible to compute the the posterior
probabilities of the individual trajectories and the
likelihood. From there, we can also compute the BIC, the AIC and
the global posterior probability. The function <code>qualityCriterion</code>
also compute these criterion. But the user should alway keep in mind
that these criterion are
valid ONLY under the hypothesis of normality. If this
hypothèsis is not respected, algorithm like k-means will converge but the BIC and AIC
will have no meaning.
</p>
<p>IMPORTANT NOTE: Some criterion should be maximized, some other should be
minimized. This might be confusing for the non expert. In order to
simplify the comparison of the criterion, <code>qualityCriterion</code>
compute the OPPOSITE of the criterion that should be minimized (Ray &amp; Bouldin, Davies &amp; Turi, BIC and AIC). Thus,
all the criterion computed by this function should be maximized.
</p>


<h3>Value</h3>

<p>A list with three fields: the first is the list of the criterions.
the second is the clusters post probabilities;
the third is the matrix of the individual post probabilities.
</p>


<h3>Non-parametric criterion</h3>

<p>Notations: k=number of clusters; n=number of individual;
B=Between variance ; W=Within variance
The criterion are:
</p>

<dl>
<dt>Calinski.Harabatz</dt><dd><p><code>[numeric]</code>: Calinski and Harabatz
criterion: <code>c(k)=Trace(B)/Trace(W)*(n-k)/(k-1)</code>.</p>
</dd>
<dt>Calinski.Harabatz2</dt><dd><p><code>[numeric]</code>: Calinski and Harabatz
criterion modified by Krysczuk: <code>c(k)=Trace(B)/Trace(W)*(n-1)/(n-k)</code>.</p>
</dd>
<dt>Calinski.Harabatz3</dt><dd><p><code>[numeric]</code>: Calinski and Harabatz
criterion modified by Genolini:
<code>g(k)=Trace(B)/Trace(W)*(n-k)/sqrt(k-1)</code>.</p>
</dd>
<dt>Ray.Turi</dt><dd><p><code>[numeric]</code>: Ray and Turi criterion: <code>r(k)=-Vintra/Vinter</code> with
<code>Vintra=Sum(dist(x,center(x)))</code> and
<code>Vinter=min(dist(center_i,center_j)^2)</code>. (The &quot;true&quot; index of
Ray and Turi is <code>Vintra/Vinter</code> and should me minimized. See IMPORTANT NOTE  above.)</p>
</dd>
<dt>Davies.Bouldin</dt><dd><p><code>[numeric]</code>: Davies and Bouldin criterion:
<code>d(k)=-mean(Proximite(cluster_i,cluster_j))</code> with
<code>Proximite(i,j)=(DistInterne(i)+DistInterne(j))/(DistExterne(i,j))</code>. (The &quot;true&quot; index of
Davies and Bouldin is <code>mean(Proximite())</code> and should me
minimized. See IMPORTANT NOTE above.)</p>
</dd>
<dt>random</dt><dd><p><code>[numeric]</code>: random value following the normal law N(0,1).</p>
</dd>
</dl>



<h3>Parametric criterion</h3>

<p>All the parametric indices should be minimized. So the function
<code>qualityCriterion</code> compute their opposite (see IMPORTANT NOTE above.)
</p>
<p>Notation: L=likelihood; h=number of parameters; n=number of
trajectories; t=number of time measurement; N=total number of
measurement (N=t.n).
</p>
<p>SECOND IMPORTANT NOTE: the formula of parametrics criterion ofen
include the size of the population. In the specific case on
longitudinal data, the definition of the &quot;size of the population&quot; is
not obvious. It can be either the number of individual <code>n</code>, or the number of
measurement <code>N=n.t</code>. So, the function <code>qualityCriterion</code> gives
two version of all the non parametrics criterion, the first using <code>n</code>,
the second using <code>N</code>.
</p>

<dl>
<dt>BIC</dt><dd><p><code>[numeric]</code>: Bayesian Information Criterion: BIC=2*log(L)-h*log(n). See IMPORTANT NOTE above.</p>
</dd>
<dt>BIC2</dt><dd><p><code>[numeric]</code>: Bayesian Information Criterion: BIC=2*log(L)-h*log(N). See IMPORTANT NOTE above.</p>
</dd>
<dt>AIC</dt><dd><p><code>[numeric]</code>: Akaike Information Criterion, bis: AIC=2*log(L)-2*h. See IMPORTANT NOTE above.</p>
</dd>
<dt>AICc</dt><dd><p><code>[numeric]</code>: Akaike Information Criterion with correction: AIC=AIC+(2h(h+1))/(n-h-1). See IMPORTANT NOTE above.</p>
</dd>
<dt>AICc2</dt><dd><p><code>[numeric]</code>: Akaike Information Criterion with correction, bis: AIC=AIC+(2h(h+1))/(n-h-1). See IMPORTANT NOTE above.</p>
</dd>
</dl>



<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSM, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LongData-class">LongData</a></code>, <code><a href="#topic+Partition-class">Partition</a></code>,
<code><a href="#topic+imputation">imputation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
### Preparation of some artificial data
par(ask=TRUE)
data(artificialLongData)
ld &lt;- longData(artificialLongData)


### Correct partition
part1 &lt;- partition(rep(1:4,each=50))
plotTrajMeans(ld,part1)
(cr1 &lt;- qualityCriterion(ld,part1))

### Random partition
part2 &lt;- partition(floor(runif(200,1,5)))
plotTrajMeans(ld,part2)
(cr2 &lt;- qualityCriterion(ld,part2))

### Partition with 3 clusters instead of 4
part3 &lt;- partition(rep(c(1,2,3,3),each=50))
plotTrajMeans(ld,part3)
(cr3 &lt;- qualityCriterion(ld,part3))


### Comparisons of the Partition
plot(c(cr1[[1]],cr2[[1]],cr3[[1]]),main="The highest give the best partition
(according to Calinski &amp; Harabatz criterion)")
par(ask=FALSE)
</code></pre>

<hr>
<h2 id='regroup'>
~ Function: regroup ~
</h2><span id='topic+regroup'></span>

<h3>Description</h3>

<p>Remove duplicate <code><a href="#topic+Partition-class">Partition</a></code> present in a
<code><a href="#topic+ListPartition-class">ListPartition</a></code> (or, by inheritance, in
<code>ClusterLongData</code> and  <code>ClusterLongData3d</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regroup(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regroup_+3A_object">object</code></td>
<td>
<p><code>[<a href="#topic+ListPartition-class">ListPartition</a>]</code>: object
that should be simplified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A clusterizing algorithm can find a <code>Partition</code> several time. It
is store several time in object <code>ListPartition</code>(or in
<code>ClusterLongData</code> or in <code>ClusterLongData3d</code>), encombering
the memory. <code>regroup</code> remove the duplicate
<code><a href="#topic+Partition-class">Partition</a></code>. Note that if the <code>ListPartition</code>
is not ordered, then
<code>regroup</code> sort it unless <code>toOrder=FALSE</code>.
</p>


<h3>Value</h3>

<p>None (this function change internaly the field of an object, it does
not return any values.)
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] Christophe M. Genolini and Bruno Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] Christophe M. Genolini and Bruno Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Some data
data(artificialLongData)
myLd &lt;- as.matrix(artificialLongData[,-1])
### Some clustering
part2 &lt;- partition(rep(c("A","B","A","C"),time=50),myLd)
part3 &lt;- partition(rep(c("A","B","C","D"),time=50),myLd)

################
### ListPartition
listPart &lt;- listPartition()

listPart["add"] &lt;- part2
listPart["add"] &lt;- part3
listPart["add"] &lt;- part2
listPart["add"] &lt;- part3

### Some clustering has been found several time
### regroup will suppress the duplicate one
regroup(listPart)
plotCriterion(listPart)
</code></pre>

<hr>
<h2 id='reshapeLongToWide'>
~ Function: longToWide (or reshapeWide) ~
</h2><span id='topic+reshapeLongToWide'></span><span id='topic+longToWide'></span>

<h3>Description</h3>

<p>This function reshapes a data frame in 'long' format (repeated
measurements in the same column) into a data frame in 'wide' format
(repeated measurements in separate columns). It also correct a bug of reshape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longToWide(trajLong)
reshapeLongToWide(trajLong)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshapeLongToWide_+3A_trajlong">trajLong</code></td>
<td>
<p>[<code>data.frame</code>]: <code>data.frame</code> that hold the
trajectories in long format. The data.frame has to be
(no choice!) in the following format: the first column should be the individual
indentifiant. The second should be the times at which the measurement
are made and should be numeric. The third one should be the measurement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reshapes a data frame in 'long' format (repeated
measurements in the same column) into a data frame in 'wide' format
(repeated measurements in separate columns).
</p>


<h3>Value</h3>

<p>A data frame in 'wide' format (repeated measurements in separate columns).
</p>


<h3>Note</h3>

<p><code>longToWide</code> is just a 'friendly overlay' of the function
<code><a href="stats.html#topic+stats">reshape</a></code>. It also corrects a <code>reshape</code> bug
(modification of the order of some trajectories value when some times
are missing).
</p>


<h3>Author(s)</h3>

<p>Christophe Genolini
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wideToLong">wideToLong</a></code>, <code><a href="stats.html#topic+stats">reshape</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(Indometh)
longToWide(Indometh)


df2 &lt;- data.frame(id = rep(LETTERS[1:4], rep(2,4)),
                 visit = I(rep(c("3","6"), 4)),
                 x = rnorm(4), y = runif(4),
                 sex=rep(c("H","F","H"),time=c(4,2,2)))[1:7,]
longToWide(df2[,1:3])
longToWide(df2[,c(1,2,4)])
</code></pre>

<hr>
<h2 id='reshapeWideToLong'>
~ Function: wideToLong (or reshapeWideToLong) ~
</h2><span id='topic+reshapeWideToLong'></span><span id='topic+wideToLong'></span>

<h3>Description</h3>

<p>This function reshapes a data frame in 'wide' format (repeated
measurements in separate column) into a data frame in 'long' format
(repeated measurements in the same columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wideToLong(trajWide,times=1:(ncol(trajWide)-1))
reshapeWideToLong(trajWide,times=1:(ncol(trajWide)-1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshapeWideToLong_+3A_trajwide">trajWide</code></td>
<td>
<p><code>[data.frame]</code>: a data frame in 'wide' format (repeated
measurements in separate column). The first column has to be the
individual indentier. All the other column should be the trajectories.</p>
</td></tr>
<tr><td><code id="reshapeWideToLong_+3A_times">times</code></td>
<td>
<p><code>[vector(numeric)]</code>:
specification of the times at wich the longitudinal data have
been measured (like ages, year, month). If times is missing, it
takes the value <code>1:(ncol(trajWide)-1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reshapes a data frame in 'wide' format (repeated
measurements in separe column) into a data frame in 'long' format
(repeated measurements in the same columns). The first column has to be the
individual indentier. All the other column should be the trajectories.
The missing values are removed in long format.
</p>


<h3>Value</h3>

<p>A data frame in 'long' format.
</p>


<h3>Author(s)</h3>

<p>Christophe Genolini
</p>


<h3>See Also</h3>

<p><code><a href="#topic+longToWide">longToWide</a></code>, <code><a href="stats.html#topic+stats">reshape</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df3 &lt;- data.frame(id = LETTERS[rep(1:4)], sex=c("H","F","H","F"),
    v1=rnorm(4),v2=rnorm(4),w1=rnorm(4),w2=rnorm(4))

wideToLong(df3[,c(1,3,4)])
wideToLong(df3[,c(1,5,6)])
wideToLong(df3[,c(1,3:6)])
wideToLong(df3[,c(1,3:6)],times=c(1,2,4,8))
</code></pre>

<hr>
<h2 id='restoreRealData'>
~ Function: restoreRealData ~
</h2><span id='topic+restoreRealData'></span><span id='topic+restoreRealData+2CLongData'></span><span id='topic+restoreRealData+2CLongData3d'></span><span id='topic+restoreRealData+2CLongData-method'></span><span id='topic+restoreRealData+2CLongData3d-method'></span>

<h3>Description</h3>

<p>This function revert the effect of <code><a href="#topic+scale">scale</a></code> by restauring
the initial values of trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restoreRealData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restoreRealData_+3A_object">object</code></td>
<td>
<p><code>[LongData]</code>: Object containnig trajectories to restore.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function revert the effect of <code><a href="#topic+scale">scale</a></code> by restauring
the initial values of trajectories.
</p>


<h3>Value</h3>

<p>None: this function change internaly the field of an object, it does not return any values.)
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale">scale</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
### Building LongData

time=c(1,2,3,4,8,12,16,20)
id2=1:12
f &lt;- function(id,t)((id-1)%%3-1) * t
g &lt;- function(id,t)(id%%2+1)*t
ld1 &lt;- longData3d(array(cbind(outer(id2,time,f),outer(id2,time,g))+rnorm(12*8*2,0,1),dim=c(12,8,2)))
plotTrajMeans3d(ld1)

##################
### Scaling by 'mean' and 'standard deviation'
scale(ld1,scale=c(-1,-1))
plotTrajMeans3d(ld1)

##################
### Back to the first version of the data
restoreRealData(ld1)
plotTrajMeans3d(ld1)
</code></pre>

<hr>
<h2 id='saveTrianglesAsASY'>
~ Function: saveTrianglesAsASY ~
</h2><span id='topic+saveTrianglesAsASY'></span>

<h3>Description</h3>

<p>Export a <code>Triangle</code> object to an '.asy' file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveTrianglesAsASY(scene, filename = "scene.asy")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveTrianglesAsASY_+3A_scene">scene</code></td>
<td>
<p><code>[Triangle]</code>: Object representing the graph to plot,
probably produce by <code><a href="#topic+plot3dPdf">plot3dPdf</a></code>.</p>
</td></tr>
<tr><td><code id="saveTrianglesAsASY_+3A_filename">filename</code></td>
<td>
<p><code>[character]</code>: Name of exported file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Export a <code>Triangle</code> object to an '.asy' file. See
<code><a href="#topic+plot3dPdf">plot3dPdf</a></code> for a summary of the overall procedure.
</p>


<h3>Value</h3>

<p>An '.asy' file, in the current directory.
</p>


<h3>Author(s)</h3>

<p>Luke Tierney <br />
Chair, Statistics and Actuarial Science <br />
Ralph E. Wareham Professor of Mathematical Sciences<br />
University of Iowa <br />
</p>


<h3>References</h3>

<p><a href="https://homepage.divms.uiowa.edu/~luke/R/misc3d/misc3d-pdf/misc3d-pdf.pdf">https://homepage.divms.uiowa.edu/~luke/R/misc3d/misc3d-pdf/misc3d-pdf.pdf</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3dPdf">plot3dPdf</a></code>,<code><a href="#topic+makeLatexFile">makeLatexFile</a></code>,<code><a href="misc3d.html#topic+makeTriangles">makeTriangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### Move to tempdir
  wd &lt;- getwd()
  setwd(tempdir()); getwd()
  
  ### Generating the data
  data(artificialJointLongData)
  myLd &lt;- longData3d(artificialJointLongData,timeInData=list(var1=2:12,var2=13:23))
  part &lt;- partition(rep(1:3,each=50))
  plotTrajMeans3d(myLd,part)

  ### Creation of the scene
  scene &lt;- plot3dPdf(myLd,part)
  drawScene.rgl(scene)

  ### Export in '.asy' file
  saveTrianglesAsASY(scene)

  ### Creation of a '.prc' file
  # Open a console, then run:
  # 'asy -inlineimage -tex pdflatex scene.asy'

  ### Creation of the LaTeX main document
  makeLatexFile()

  ### Creation of the '.pdf'
  # Open a console window, then run
  # pdfLatex main.tex
  
  ### Go back to current dir
  setwd(wd)
</code></pre>

<hr>
<h2 id='scale'>
~ Function: scale for LongData ~
</h2><span id='topic+scale'></span><span id='topic+scale+2CLongData'></span><span id='topic+scale+2CLongData3d'></span><span id='topic+scale+2CLongData-method'></span><span id='topic+scale+2CLongData3d-method'></span>

<h3>Description</h3>

<p><code>scale</code> the trajectories of the different variable of a
<code><a href="#topic+LongData-class">LongData</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale(x, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_+3A_x">x</code></td>
<td>
<p><code>[LongData]</code>: Object containnig trajectories to be scale.</p>
</td></tr>
<tr><td><code id="scale_+3A_center">center</code></td>
<td>
<p><code>[logical]</code> or <code>[vector(numeric)]</code>: Value that
will be substract from each mesurement of a variable. If <code>center=TRUE</code>, the mean of
each variable-trajectory is used. Otherwise, <code>center</code> should have a value
for each variables.</p>
</td></tr>
<tr><td><code id="scale_+3A_scale">scale</code></td>
<td>
<p><code>[logical]</code> or <code>[vector(numeric)]</code>: Value that
will divided, after the substration, each mesurement of a variable.
If <code>scale=TRUE</code>, the standard deviation of
each variable-trajectory is used. Otherwise, <code>scale</code> should have a value
for each variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When variable with different unit are used jointly, it might be necessary to
change their scale them in order to change their individual influance.
This is what <code>scale</code> do.
</p>
<p>More precisely, all the value x[i,j,k] of the variable k will be scale
according to the classic formula <code>(x[i,j,k]- m_k)/s_k</code> where
m_k and s_k are respectively the k-ieme value of the argument
<code>center</code> and <code>scale</code>.
</p>
<p>Note that <code>center=TRUE</code> is a special value that set <code>m_k=mean(x[,,k],na.rm=TRUE)</code>.
Similarly, <code>scale=TRUE</code> is a special value that set <code>s_k=sd(x[,,k],na.rm=TRUE)</code>.
</p>


<h3>Value</h3>

<p><code>scale</code> directly
modify the internal value of the <code>LongData</code>. No value is return.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSM, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+restoreRealData">restoreRealData</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
### Building LongData

time=c(1,2,3,4,8,12,16,20)
id2=1:12
f &lt;- function(id,t)((id-1)%%3-1) * t
g &lt;- function(id,t)(id%%2+1)*t
ld1 &lt;- longData3d(array(cbind(outer(id2,time,f),outer(id2,time,g))+rnorm(12*8*2,0,1),dim=c(12,8,2)))
plotTrajMeans3d(ld1)

##################
### Scaling by 'mean' and 'standard deviation'
plotTrajMeans3d(ld1)
scale(ld1)
plotTrajMeans3d(ld1)

### Scaling by some parameters
scale(ld1,center=c(10,100),scale=c(3,-1))
plotTrajMeans3d(ld1)

##################
### To restore the data
restoreRealData(ld1)
</code></pre>

<hr>
<h2 id='windowsCut'>
~ Function: windowsCut ~
</h2><span id='topic+windowsCut'></span>

<h3>Description</h3>

<p><code>windowsCut</code> prepare an object <code><a href="#topic+ParWindows-class">ParWindows</a></code>
according to its arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>windowsCut(x, addLegend = TRUE,closeScreen=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="windowsCut_+3A_x">x</code></td>
<td>
<p><code>[numeric]</code> or <code>[couple(numeric)]</code>: <code>x</code> is
used to calculate the fields <code>nbCol</code> and <code>nbRow</code> of the
object <code>ParWindows</code>. If <code>x</code> is a couple, then <code>x[1]</code> is <code>nbRow</code>
and <code>x[2]</code> is <code>nbCol</code>. If <code>x</code> is a single number
(the number of plot that should be display), <code>nbCol</code> and <code>nbRow</code> parameters are calculate
consequently (see detail).
</p>
</td></tr>
<tr><td><code id="windowsCut_+3A_addlegend">addLegend</code></td>
<td>
<p><code>[logical]</code>: If <code>addLegend</code>is true, an
extra space is reserved on the top of the screen to print the
legend.
</p>
</td></tr>
<tr><td><code id="windowsCut_+3A_closescreen">closeScreen</code></td>
<td>
<p><code>[logical]</code>: Some function
need to add details on a graph. This option let
them call a plot function that will not call a <code>close.screen</code>
on exit, so the graph will be modifiable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a number of variable, the column and row number are
estimate according to the formula
<code>nbCol &lt;- ceiling(sqrt(x))</code> and <code>nbRow &lt;- ceiling(x/nbCol)</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ParWindows-class">ParWindows</a></code>.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSM, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### Simple cut with no space for legent
  windowsCut(3,FALSE)
  windowsCut(4,FALSE)
  windowsCut(5,FALSE)

  ### Simple cut with legend
  windowsCut(5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
