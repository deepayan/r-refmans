<!DOCTYPE html><html><head><title>Help for package mar1s</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mar1s}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compose.ar1'><p> Compose and Decompose AR(1) Process</p></a></li>
<li><a href='#compose.mar1s'><p> Compose and Decompose MAR(1)S Process</p></a></li>
<li><a href='#fit.mar1s'><p> Fit Multiplicative AR(1) with Seasonal Process to Data</p></a></li>
<li><a href='#forest.fire'><p> Forest fire in Irkutsk region, USSR: historical data</p></a></li>
<li><a href='#mar1s-internal'><p>Internal mar1s objects</p></a></li>
<li><a href='#nesterov.index'><p> Nesterov index in Irkutsk region, USSR: historical data</p></a></li>
<li><a href='#seasonal.ave'><p> Averaged Seasonal Component of Time Series</p></a></li>
<li><a href='#seasonal.smooth'><p> Smooth Seasonal Component of Time Series</p></a></li>
<li><a href='#sim.mar1s'><p> Simulate from MAR(1)S Process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiplicative AR(1) with Seasonal Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-08-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrey Paramonov</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrey Paramonov &lt;paramon@acdlabs.ru&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>cmrutils, fda, zoo</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiplicative AR(1) with Seasonal is a stochastic
  process model built on top of AR(1). The package provides the
  following procedures for MAR(1)S processes: fit, compose, decompose,
  advanced simulate and predict.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/aparamon/mar1s">https://github.com/aparamon/mar1s</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-18 09:23:21 UTC; acd2</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-18 15:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='compose.ar1'> Compose and Decompose AR(1) Process </h2><span id='topic+compose.ar1'></span><span id='topic+decompose.ar1'></span>

<h3>Description</h3>

<p><code>compose.ar1</code> composes AR(1) process realization by given vector(s)
of innovations.
</p>
<p><code>decompose.ar1</code> extracts AR(1) process residuals from time
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose.ar1(arcoef, innov, init = 0, xregcoef = 0, xreg = NULL,
            init.xreg = rep(0, length(xregcoef)))

decompose.ar1(arcoef, data, init = NA, xregcoef = 0, xreg = NULL,
              init.xreg = rep(NA, length(xregcoef)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compose.ar1_+3A_arcoef">arcoef</code></td>
<td>

<p>A number specifying autoregression coefficient.
</p>
</td></tr>
<tr><td><code id="compose.ar1_+3A_innov">innov</code></td>
<td>

<p>A univariate or multivariate time series containing the innovations.
</p>
</td></tr>
<tr><td><code id="compose.ar1_+3A_data">data</code></td>
<td>

<p>A univariate or multivariate time series containing the process
realization(s).
</p>
</td></tr>
<tr><td><code id="compose.ar1_+3A_init">init</code></td>
<td>

<p>A number specifying the value of the process just prior to the start
value in <code>innov</code>/<code>data</code>.
</p>
</td></tr>
<tr><td><code id="compose.ar1_+3A_xregcoef">xregcoef</code></td>
<td>

<p>A vector specifying coefficients for the external regressors.
</p>
</td></tr>
<tr><td><code id="compose.ar1_+3A_xreg">xreg</code></td>
<td>

<p>A matrix-like object of the same row count as
<code>innov</code>/<code>data</code>, specifying the values of external
regressors. The default <code>NULL</code> means zeroes.
</p>
</td></tr>
<tr><td><code id="compose.ar1_+3A_init.xreg">init.xreg</code></td>
<td>

<p>A vector specifying the values of external regressors just prior to
the start values in <code>xreg</code>. The default <code>NULL</code> means
zeroes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here <dfn>AR(1) process with external regressors</dfn> is a linear
regresson with AR(1) model for the error term:
</p>
<p style="text-align: center;"><code class="reqn">y_t = b_1 x_{t, 1} + \dots + b_k x_{t, k} + z_t</code>
</p>

<p style="text-align: center;"><code class="reqn">z_t = a z_{t-1} + e_t</code>
</p>

<p>Use <code>xreg = NULL</code> for the regular AR(1) process.
</p>


<h3>Value</h3>

<p>An object of the same type and dimensions as <code>innov</code>/<code>data</code>
(typically time series).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+arima">arima</a></code> for more general <code class="reqn">ARMA(p, q)</code> processes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple
e &lt;- ts(c(0, 1, 0, 1, 0), freq = 12)
compose.ar1(0.1, e)
compose.ar1(0.1, e, 1)

x &lt;- ts(c(0, 1, 0, 1, 0), freq = 12)
decompose.ar1(0.1, x)
decompose.ar1(0.1, x, 1)

## Multiseries
compose.ar1(0.1, ts(cbind(0, 1)))
compose.ar1(0.1, ts(cbind(c(0, 1, 0), c(1, 0, 1))))

decompose.ar1(0.1, ts(cbind(0, 1)))
decompose.ar1(0.1, ts(cbind(c(0, 1, 0), c(1, 0, 1))))

## External regressors
xreg1 &lt;- rep(2, 5)
xreg2 &lt;- matrix(rep(c(2, 1), each = 5), 5, 2)
e &lt;- ts(c(0, 1, 0, 1, 0), freq = 12)
compose.ar1(0.1, e, xregcoef = 0.5, xreg = xreg1)
compose.ar1(0.1, e, xregcoef = 0.5, init = 0, xreg = xreg1, init.xreg = -2)
compose.ar1(0.1, e, xregcoef = c(1, -1), xreg = xreg2)

x &lt;- ts(c(0, 1, 0, 1, 0), freq = 12)
decompose.ar1(0.1, x, xregcoef = 0.5, xreg = xreg1)
decompose.ar1(0.1, x, xregcoef = 0.5, init = 0, xreg = xreg1, init.xreg = -2)
decompose.ar1(0.1, x, xregcoef = c(1, -1), xreg = xreg2)

## Back-test
a &lt;- 0.5
innov &lt;- ts(rnorm(10), frequency = 12)
init &lt;- 1
xrcoef &lt;- seq(-0.1, 0.1, length.out = 3)
xreg &lt;- matrix(1:30, 10, 3)
init.xreg &lt;- 1:3
x &lt;- compose.ar1(a, innov, init, xrcoef, xreg, init.xreg)
r &lt;- decompose.ar1(a, x, init, xrcoef, xreg, init.xreg)
stopifnot(all.equal(innov, r))
</code></pre>

<hr>
<h2 id='compose.mar1s'> Compose and Decompose MAR(1)S Process </h2><span id='topic+compose.mar1s'></span><span id='topic+decompose.mar1s'></span>

<h3>Description</h3>

<p><code>compose.mar1s</code> composes MAR(1)S process realization by given
vector of log-innovations.
</p>
<p><code>decompose.mar1s</code> extracts MAR(1)S process components from time
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose.mar1s(object, loginnov, start.time = head(time(loginnov), 1),
              xreg.absdata = NULL, init.absdata = NULL)

decompose.mar1s(object, absdata, start.time = head(time(absdata), 1),
                init.absdata = rep(NA, NCOL(absdata)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compose.mar1s_+3A_object">object</code></td>
<td>

<p>An object of class <code>"mar1s"</code> specifying the model parameters.
</p>
</td></tr>
<tr><td><code id="compose.mar1s_+3A_loginnov">loginnov</code></td>
<td>

<p>A univariate time series containing the log-innovations.
</p>
</td></tr>
<tr><td><code id="compose.mar1s_+3A_absdata">absdata</code></td>
<td>

<p>A univariate or multivariate time series containing the process
realization.
</p>
</td></tr>
<tr><td><code id="compose.mar1s_+3A_start.time">start.time</code></td>
<td>

<p>The sampling time for the first simulation step.
</p>
</td></tr>
<tr><td><code id="compose.mar1s_+3A_xreg.absdata">xreg.absdata</code></td>
<td>

<p>A matrix-like object with row count = <code>n.ahead</code>, specifying the
values for the external regressors. If <code>NULL</code>, default values
are used.
</p>
</td></tr>
<tr><td><code id="compose.mar1s_+3A_init.absdata">init.absdata</code></td>
<td>

<p>A vector specifying the initial values of the process. If
<code>NULL</code>, default values are used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><dfn>Multiplicative AR(1) with Seasonal (MAR(1)S) process</dfn> is defined
as
</p>
<p style="text-align: center;"><code class="reqn">x_t = exp(s_t + y_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">y_{t, 1} = b_1 y_{t, 2} + \dots + b_k y_{t, k + 1} + z_t</code>
</p>

<p style="text-align: center;"><code class="reqn">z_t = a z_{t-1} + e_t</code>
</p>

<p>where
</p>
<p><code class="reqn">s_t</code> is the log-seasonal component,
</p>
<p><code class="reqn">y_t</code> is the AR(1) (log-stochastic) component,
</p>
<p><code class="reqn">e_t</code> is the log-residuals (random component).
</p>


<h3>Value</h3>

<table>
<tr><td><code>absdata</code></td>
<td>

<p>Realization of the process (a univariate or multivariate time series
object).
</p>
</td></tr>
<tr><td><code>logdata</code></td>
<td>

<p>Logarithm of <code>absdata</code> (a univariate or multivariate time
series object).
</p>
</td></tr>
<tr><td><code>logstoch</code></td>
<td>

<p>Log-stochastic component (a univariate or multivariate time series
object).
</p>
</td></tr>
<tr><td><code>logresid</code></td>
<td>

<p>Random component (a univariate time series object).
</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>decompose.mar1s</code> and <code>fit.mar1s</code> compute the random
component in different ways: <code>decompose.mar1s</code> uses <code>filter</code>
while <code>fit.mar1s</code> saves the residuals returned by <code>arima</code>.
The results may be different in:
</p>

<dl>
<dt>the first value:</dt><dd><p><code>decompose.mar1s</code> uses specified
<code>init.absdata</code> while <code>arima</code> always assumes zero initial
values for the fitted process;</p>
</dd>
<dt>non-finite values:</dt><dd><p><code>decompose.mar1s</code> handles non-finite
values more accurately.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+compose.ar1">compose.ar1</a></code> for the AR(1) with external regressors
processes, <code><a href="#topic+fit.mar1s">fit.mar1s</a></code> for fitting MAR(1)S process to
data, <code><a href="#topic+sim.mar1s">sim.mar1s</a></code> for MAR(1)S process simulation and
prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(forest.fire, package = "mar1s")
data(nesterov.index, package = "mar1s")

## Simple
mar1s &lt;- fit.mar1s(window(forest.fire, 1969, 1989))

x &lt;- ts(rnorm(365, sd = mar1s$logresid.sd), start = c(1989, 1))
plot(compose.mar1s(mar1s, x)$absdata)

decomp &lt;- decompose.mar1s(mar1s, mar1s$decomposed$absdata)
delta &lt;- abs(nan2na(mar1s$decomposed$logresid) -
             nan2na(decomp$logresid))
stopifnot(all(na.exclude(tail(delta, -1)) &lt; 1E-6))

## External regressors
mar1s &lt;- fit.mar1s(window(forest.fire, 1969, 1989),
                   window(nesterov.index[, "mean"], 1969, 1989))

x &lt;- rnorm(365, sd = mar1s$logresid.sd)
xreg &lt;- window(nesterov.index[, "mean"], 1989.001, 1990)
plot(compose.mar1s(mar1s, x, c(1989, 1), xreg)$absdata)

decomp &lt;- decompose.mar1s(mar1s, mar1s$decomposed$absdata)
delta &lt;- abs(mar1s$decomposed$logstoch - decomp$logstoch)
stopifnot(all(na.exclude(delta) &lt; 1E-6))
delta &lt;- abs(nan2na(mar1s$decomposed$logresid) -
             nan2na(decomp$logresid))
stopifnot(all(na.exclude(tail(delta, -1)) &lt; 1E-6))
</code></pre>

<hr>
<h2 id='fit.mar1s'> Fit Multiplicative AR(1) with Seasonal Process to Data </h2><span id='topic+fit.mar1s'></span>

<h3>Description</h3>

<p>Fits Multiplicative AR(1) with Seasonal process model to time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.mar1s(x, xreg = NULL, seasonal.fun = seasonal.smooth, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.mar1s_+3A_x">x</code></td>
<td>

<p>A univariate time series.
</p>
</td></tr>
<tr><td><code id="fit.mar1s_+3A_xreg">xreg</code></td>
<td>

<p>A univariate or multivariate time series of external regressors, or
<code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="fit.mar1s_+3A_seasonal.fun">seasonal.fun</code></td>
<td>

<p>A function which takes a univariate time series as its first
argument and returns the estimated seasonal component.
</p>
</td></tr>
<tr><td><code id="fit.mar1s_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>seasonal.fun</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"mar1s"</code> with the following components:
</p>
<table>
<tr><td><code>logseasonal</code></td>
<td>

<p>Estimated log-seasonal figure (a univariate or multivariate time
series object).
</p>
</td></tr>
<tr><td><code>logstoch.ar1</code></td>
<td>

<p>AR(1) with external regressors model fitted for the log-stochastic
component (an object of class <code>"Arima"</code>).
</p>
</td></tr>
<tr><td><code>logresid.sd</code></td>
<td>

<p>Standard deviation of the residuals.
</p>
</td></tr>
<tr><td><code>decomposed</code></td>
<td>

<p>An object of class <code>"mar1s.ts"</code> containing decomposed time
series (see <code><a href="#topic+compose.mar1s">compose.mar1s</a></code>).
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+compose.mar1s">compose.mar1s</a></code> for MAR(1)S process formal definition and
composition/decomposition functions, <code><a href="#topic+seasonal.ave">seasonal.ave</a></code>,
<code><a href="#topic+seasonal.smooth">seasonal.smooth</a></code> for seasonal component extraction
functions, <code><a href="#topic+sim.mar1s">sim.mar1s</a></code> for MAR(1)S process simulation and
prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(forest.fire, package = "mar1s")
data(nesterov.index, package = "mar1s")

## Simple
mar1s &lt;- fit.mar1s(forest.fire)
plot(mar1s$logseasonal)
confint(mar1s$logstoch.ar1)
mar1s$logresid.sd
resid &lt;- nan2na(mar1s$decomposed$logresid)
qqnorm(resid)
qqline(resid)

## External regressors
mar1s &lt;- fit.mar1s(forest.fire, nesterov.index[, "mean"])
plot(cbind(mar1s$logseasonal, mar1s$logseasonal.r))
confint(mar1s$logstoch.ar1)
resid &lt;- nan2na(mar1s$decomposed$logresid)
qqnorm(resid)
qqline(resid)
</code></pre>

<hr>
<h2 id='forest.fire'> Forest fire in Irkutsk region, USSR: historical data </h2><span id='topic+forest.fire'></span>

<h3>Description</h3>

<p>Number of forest fire seats in Irkutsk region, USSR. Daily from April
01 to October 31, 1969&ndash;1991 (total 4708 observations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(forest.fire)</code></pre>


<h3>Format</h3>

<p>A univariate time series.
</p>


<h3>Source</h3>

<p>AviaLesoOkhrana (<a href="http://www.nffc.aviales.ru/engl/main.sht">http://www.nffc.aviales.ru/engl/main.sht</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(forest.fire)
colnames(forest.fire)
plot(forest.fire)
</code></pre>

<hr>
<h2 id='mar1s-internal'>Internal mar1s objects</h2><span id='topic+mar1s-internal'></span>

<h3>Description</h3>

<p>Internal mar1s objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='nesterov.index'> Nesterov index in Irkutsk region, USSR: historical data </h2><span id='topic+nesterov.index'></span>

<h3>Description</h3>

<p>Values of Nesterov index in 6 distincts of Irkutsk region, USSR +
region averaged. Daily from April 01 to October 31, 1969&ndash;1991 (total
4708 observations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nesterov.index)</code></pre>


<h3>Format</h3>

<p>A multivariate time series.
</p>


<h3>Details</h3>

<p>The Nesterov index is the official Russian fire-danger rating
specified by standard GOST R 22.1.09&ndash;99. It is calculated using the
ignition index, the temperature, the dew-point temperature and the
number of days since last significant (<code class="reqn">\ge 3 mm</code>) precipitation.
</p>
<p>The dataset consists of daily values 1969&ndash;1991.
</p>


<h3>Source</h3>

<p>Russian Institute of Hydrometeorogical Information&ndash;World Data Center
(<a href="http://meteo.ru/english/">http://meteo.ru/english/</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nesterov.index)
colnames(nesterov.index)
plot(nesterov.index)
</code></pre>

<hr>
<h2 id='seasonal.ave'> Averaged Seasonal Component of Time Series </h2><span id='topic+seasonal.ave'></span>

<h3>Description</h3>

<p>Extracts seasonal component of time series by averaging observations
on the same position in the cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasonal.ave(x, ave.FUN = mean, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasonal.ave_+3A_x">x</code></td>
<td>

<p>A univariate time series.
</p>
</td></tr>
<tr><td><code id="seasonal.ave_+3A_ave.fun">ave.FUN</code></td>
<td>

<p>Averaging function.
</p>
</td></tr>
<tr><td><code id="seasonal.ave_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>ave.FUN</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A time series object with times from 0 to 1 and the same frequency as
<code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ave">ave</a></code>, <code><a href="#topic+seasonal.smooth">seasonal.smooth</a></code> for alternative
seasonal extraction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(19860306)

## Artificial example
x &lt;- ts(sin(2*pi*(3:97)/10) + 0.5*rnorm(length(3:97)),
	start = c(0, 3), frequency = 10)

plot.default(time(x)%%1, x, xlab = "Phase")
lines(seasonal.ave(x), col = "blue")
lines(seasonal.ave(x, median), col = "green")
legend("bottomleft",
       legend = c("Mean averaging",
		  "Median averaging"),
       col = c("blue", "green"),
       lty = "solid")

## Realistic example
data(nesterov.index, package = "mar1s")
x &lt;- log(nesterov.index[, "mean"])
x[x &lt; -10] &lt;- -Inf

plot.default(time(x)%%1, x, xlab = "Phase", pch = ".")
lines(seasonal.ave(x), col = "blue")
lines(seasonal.ave(x, median), col = "green")
legend("topleft",
       legend = c("Mean averaging",
		  "Median averaging"),
       col = c("blue", "green"),
       lty = "solid")
</code></pre>

<hr>
<h2 id='seasonal.smooth'> Smooth Seasonal Component of Time Series </h2><span id='topic+seasonal.smooth'></span>

<h3>Description</h3>

<p>Extracts seasonal component of time series by fitting the data with a
linear combination of smooth periodic functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasonal.smooth(x, basis = create.fourier.basis(nbasis = 3), lambda = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasonal.smooth_+3A_x">x</code></td>
<td>

<p>A univariate time series.
</p>
</td></tr>
<tr><td><code id="seasonal.smooth_+3A_basis">basis</code></td>
<td>

<p>A functional basis object (see <code><a href="fda.html#topic+basisfd">basisfd</a></code>). By
default, use a linear combination of <code>const</code>,
<code>sin((2*pi)*t)</code> and <code>cos((2*pi)*t)</code>.
</p>
</td></tr>  
<tr><td><code id="seasonal.smooth_+3A_lambda">lambda</code></td>
<td>

<p>A nonnegative number specifying the amount of smoothing. By default,
apply no additional smoothing.
</p>
</td></tr>  
<tr><td><code id="seasonal.smooth_+3A_...">...</code></td>
<td>

<p>Not currently used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although it is possible to specify arbitrary functional basis object,
the function will only work properly if the basis is periodical on the
unit interval. It is recommended to use a Fourier basis with default
period (<code><a href="fda.html#topic+create.fourier.basis">create.fourier.basis</a></code>).
</p>
<p>Positive values of <code>lambda</code> imply a restriction on roughness of
the result. The more the value, the more smooth result is; see
<code><a href="fda.html#topic+smooth.basis">smooth.basis</a></code> for more detailed description.
</p>


<h3>Value</h3>

<p>A time series object with times from 0 to 1 and the same frequency as
<code>x</code>. The smoothing functional data object is stored in attribute
<code>fd</code>.
</p>


<h3>See Also</h3>

<p><code><a href="fda.html#topic+smooth.basisPar">smooth.basisPar</a></code>, <code><a href="fda.html#topic+fd">fd</a></code> for
functional data objects, <code><a href="#topic+seasonal.ave">seasonal.ave</a></code> for alternative
seasonal extraction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(19860306)

## Artificial example
x &lt;- ts(sin(2*pi*(3:97)/10) + 0.5*rnorm(length(3:97)),
	start = c(0, 3), frequency = 10)

fourier3 &lt;- seasonal.smooth(x)
fourier9 &lt;- seasonal.smooth(x, create.fourier.basis(nbasis = 9))
fourier9s&lt;- seasonal.smooth(x, create.fourier.basis(nbasis = 9), 1E-6)

plot.default(time(x)%%1, x, xlab = "Phase")
points(fourier3, pch = 20,  col = "blue")
lines(attr(fourier3, "fd"), col = "blue")
points(fourier9, pch = 20,  col = "green")
lines(attr(fourier9, "fd"), col = "green")
points(fourier9s,pch = 20,  col = "red")
lines(attr(fourier9s, "fd"),col = "red")
legend("bottomleft",
       legend = c("Fourier-3 basis",
		  "Fourier-9 basis",
		  "Fourier-9 basis, smooth"),
       col = c("blue", "green", "red"),
       lty = "solid")

## Realistic example
data(nesterov.index, package = "mar1s")
x &lt;- log(nesterov.index[, "mean"])
x[x &lt; -10] &lt;- -Inf

fourier3 &lt;- seasonal.smooth(x)
fourier9 &lt;- seasonal.smooth(x, create.fourier.basis(nbasis = 9))
fourier9s&lt;- seasonal.smooth(x, create.fourier.basis(nbasis = 9), 2E-5)

plot.default(time(x)%%1, x, xlab = "Phase", pch = ".")
lines(attr(fourier3, "fd"), col = "blue")
lines(attr(fourier9, "fd"), col = "green")
lines(attr(fourier9s,"fd"), col = "red")
legend("topleft",
       legend = c("Fourier-3 basis",
		  "Fourier-9 basis",
		  "Fourier-9 basis, smooth"),
       col = c("blue", "green", "red"),
       lty = "solid")
</code></pre>

<hr>
<h2 id='sim.mar1s'> Simulate from MAR(1)S Process </h2><span id='topic+sim.mar1s'></span><span id='topic+predict.mar1s'></span>

<h3>Description</h3>

<p><code>sim.mar1s</code> simulates from MAR(1)S process.
</p>
<p><code>predict.mar1s</code> is a wrapper around <code>sim.mar1s</code> which
estimates confidence intervals for the future values of the MAR(1)S
process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.mar1s(object, n.ahead = 1, n.sim = 1, start.time = 0,
          xreg.absdata = NULL, init.absdata = NULL)

## S3 method for class 'mar1s'
predict(object, n.ahead = 1, start.time = 0,
        xreg.absdata = NULL, init.absdata = NULL,
        probs = c(0.05, 0.5, 0.95), n.sim = 1000, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.mar1s_+3A_object">object</code></td>
<td>

<p>An object of class <code>"mar1s"</code> specifying the model parameters.
</p>
</td></tr>
<tr><td><code id="sim.mar1s_+3A_n.ahead">n.ahead</code></td>
<td>

<p>Number of steps ahead at which to simulate/predict.
</p>
</td></tr>
<tr><td><code id="sim.mar1s_+3A_n.sim">n.sim</code></td>
<td>

<p>Number of simulations.
</p>
</td></tr>
<tr><td><code id="sim.mar1s_+3A_start.time">start.time</code></td>
<td>

<p>The sampling time for the first simulation step.
</p>
</td></tr>
<tr><td><code id="sim.mar1s_+3A_xreg.absdata">xreg.absdata</code></td>
<td>

<p>A matrix-like object with row count = <code>n.ahead</code>, specifying the
values for the external regressors. If <code>NULL</code>, default values
are used.
</p>
</td></tr>
<tr><td><code id="sim.mar1s_+3A_init.absdata">init.absdata</code></td>
<td>

<p>A vector specifying the initial values of the process. If
<code>NULL</code>, default values are used.
</p>
</td></tr>
<tr><td><code id="sim.mar1s_+3A_probs">probs</code></td>
<td>

<p>A vector of probabilities.
</p>
</td></tr>
<tr><td><code id="sim.mar1s_+3A_...">...</code></td>
<td>

<p>Arguments from previous methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>sim.mar1s</code>, a vector of simulated values.
</p>
<p>For <code>predict.mar1s</code>, a vector of estimated quantiles.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compose.mar1s">compose.mar1s</a></code> for MAR(1)S process formal definition and
composition/decomposition functions, <code><a href="#topic+fit.mar1s">fit.mar1s</a></code> for
fitting MAR(1)S process to data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(forest.fire, package = "mar1s")
data(nesterov.index, package = "mar1s")

## Univariate
mar1s &lt;- fit.mar1s(forest.fire)

sim.mar1s(mar1s)
sim.mar1s(mar1s, n.sim = 6)
sim.mar1s(mar1s, n.ahead = 3)

predict(mar1s)
predict(mar1s, n.ahead = 10)
predict(mar1s, init.absdata = 100)

t &lt;- seq(1/12, 11/12, 1/6) 
p &lt;- mapply(predict, start.time = t,
            MoreArgs = list(object = mar1s, probs = c(0.05, 0.95)))
plot(exp(mar1s$logseasonal), ylim = c(0, max(p)),
     ylab = "Forest fire")
arrows(t, p[1, ], t, p[2, ],
       code = 3, angle = 90, length = 0.05)

## External regressors
mar1s &lt;- fit.mar1s(forest.fire, nesterov.index[, "mean"])

sim.mar1s(mar1s)
sim.mar1s(mar1s, n.sim = 6)

predict(mar1s)
predict(mar1s, xreg.absdata = 10000)
predict(mar1s, init.absdata = c(100, 1000))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
